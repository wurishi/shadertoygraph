{"ver":"0.1","info":{"id":"mddGzX","date":"1678141963","viewed":235,"name":"Pampa F16-11 missile Trail ","username":"DENFOR","description":"2023.03.01  Test  missileContrail \n","likes":14,"published":1,"flags":64,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lst3Dn","filepath":"https://soundcloud.com/protomen/danger-zone","previewfilepath":"https://soundcloud.com/protomen/danger-zone","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // created by Kali      https://www.shadertoy.com/view/ddBSWR\n // created by Ingagard  https://www.shadertoy.com/view/MlscWX\n#define trail\n#define letterboxfullscreen\n//#define startinlake\n//#define noplane\n//#define onlymouse\n#define missieTrail                        // ad \n\n#define resolution iResolution\n#ifdef startinlake\n    #define time mod(iTime*.83+120.,200.)   // reverse -iTime\n#else\n    #define time mod(iTime*.83,200.)        // reverse -iTime\n#endif\n\nfloat hashseed=0.;\nfloat det=.01;\nfloat maxdist=40.;\nvec3 objcol;\nvec3 ldir;\nfloat /*id=0.,*/   oc=1.,dcab=0.,t=0.,h=0.,speed=0.,baja=0.,ref=0.;\nvec3 pos, pfus, pmot, pcab, parm, pwin, ptim, ptai, tpos;  vec3 q ;\nvec3 pbody,pfront,prear,ptop,pcock,pmissile,pmissile2, pbomb2 , pesm, pflap,peflame   ;\nvec3 ppos=vec3(0.),ppos2=vec3(0.);\nmat2 rotyz, rotxy, rotxz;\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nbool mTime ;\n\nfloat interhash(float seed, float t) {\n    t+=hash(seed+hashseed)*123.;\n    return mix(hash(floor(t)),hash(floor(t+1.)),smoothstep(.3,1.,fract(t)));\n}\n\nfloat path(float t) {\n    return sin(t+cos(t*.5687))*.5;\n}\n\n\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat ssub ( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.z -= clamp( p.z, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat elipse( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n////////////////////////////////////////////// (1)  Turn Burn  base data\n//////////////////////////////////////////////////////////////////////////////////////\n// PLANE BUFFER   -   RENDERS PLANE ONLY\n//////////////////////////////////////////////////////////////////////////////////////\n// Channel 0 = Buffer B. Get the colors of the terrain buffer render.\n// Channel 1 = LowRes noise texture. Used in fast noise functions.\n// Channel 2 = Buffer A. Read data from data-buffer.\n// Channel 3 = Forest blurred cube map. Used in reflections in plane window and hull.\n\n//  #pragma optimize(off) \n#define PI acos(-1.)\n//  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n//  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define RAYSTEPS 300\n  #define CLOUDLEVEL -70.0\n  float turn=0., pitch = 0., roll=0., rudderAngle = 0.;\n//float speed = 0.5;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\nvec3 planePos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat winDist=10000.0;      float body ; float dd =10000. ;\nfloat engineDist=10000.0;\nfloat eFlameDist=10000.0;\nfloat blackDist=10000.0;\nfloat bombDist=10000.0;\nfloat bombDist2=10000.0;\nfloat missileDist=10000.0;    float missileDist2 =10000.;\nfloat frontWingDist=10000.0;\nfloat rearWingDist=10000.0;\nfloat topWingDist=10000.0;\nvec2 missilesLaunched=vec2(0.);\n\nfloat sgn(float x) \n{   \n  return (x<0.)?-1.:1.;\n}\n/*\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n\n  float winDist;\n  float engineDist;\n  float eFlameDist;\n  float blackDist;\n  float bombDist;\n  float bombDist2;\n  float missileDist;\n  float frontWingDist;\n  float rearWingDist;\n  float topWingDist;\n}; */\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.z - h;\n  float q = p.z - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nmat2 r2(float r)\n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n  void pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a, r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\n// limited by euler rotation. I wont get a good plane rotation without quaternions! :-(\nvec3 TranslatePos(vec3 p, float _pitch, float _roll)\n{\n  pR(p.xy, _roll-PI);\n  p.z+=5.;\n  pR(p.zy, _pitch);\n  p.z-=5.; \n  return p;\n}\n\nfloat drawRect(vec2 p1, vec2 p2, vec2 uv) \n{\n  vec4 rect = vec4(p1, p2);\n  vec2 hv = step(rect.xy, uv) * step(uv, rect.zw);\n  return hv.x * hv.y;\n}\n\n// Thanks IÃ±igo Quilez!\nfloat line(vec2 p, vec2 a, vec2 b, float size)\n{\n  vec2 pa = -p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  float d = length( pa - ba*h );\n\n  return clamp((((1.0+size) - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid AddLetters(vec2 hitPos, inout vec3 col, vec2 linePos)\n{\n  // text          -- E F Z --\n  vec3 textColor = vec3(0.2);\n  vec2 absHitPos2 = vec2(hitPos.x-1.05, hitPos.y);\n\n  pModInterval1(absHitPos2.x, 8., linePos.x, linePos.x+10.);\n\n  // E\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.45, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.9), linePos+vec2(1.1, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.65), linePos+vec2(1.25, 0.65), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.1, .4), 0.06));\n  // F            \n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.4), linePos+vec2(0.9, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.9), linePos+vec2(.65, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.65), linePos+vec2(.75, 0.65), 0.06));\n  // Z\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.9), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.4), 0.06));\n}\n\n/*\nvec3 GetReflectionMap(vec3 rayDir, vec3 normal)\n{\n  return texture(iChannel3, reflect( rayDir, normal )).rgb;\n}\n*/\n\n////////////////////////////////////////////////   F16 Base Data END\n\nmat3 flMat;\nvec4 csWm, csWt;  \nvec3 sunDir, qHit, flPos, dwf, dwr;\nfloat tCur, dstFar, angWm, drpWm, angWt, drpWt, grndScl, flSzFac, flyVel;\nint idObj, vuMode;     float id, idd  ;\nbool wlDown;\n//////////////////////////////////////////////////// turn Burn Data\nconst /*int*/ float idFus = 1., idCkp = 2., idEng = 3., idWngM = 4., idWngT = 5., idFin = 6.,\n  /* idWhl = 7., idLeg = 8., idFr = 9. */ idHolder=7., idbom2 =8., idBlack=9.,\n  ideFlame =10., idMiss=11., idEsm =12., idtailFlap =13. ,idMiss2=14.  ;\nconst float pi = 3.1415927;\n\n#define DMINQ(idd) if (d < dMin) { dMin = d;  id = idd;  qHit = q; }\n\n////////////////////////////////////////////////( 1) Turn Burn  base data\n     \n/// Simple noise algorithm by Trisomie21\nfloat snoise( vec2 p ) {\n    p.y-=hashseed*100.;\n    p.xy=p.yx;\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1., v+1000.0, v+1001.);\n\tr = fract(12345.*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\nfloat terrain( vec2 p) {\n\tfloat h = 0.0; \n\tfloat w = .5; \n\tfloat m = .5; \n\tfor (int i=0; i<5; i++) {\n\t\th += w * snoise((p * m));\n\t\tw *= .25;\n\t\tm *= 4.;\n\t}\n    return h;\n}\n\nfloat terrain(vec3 p) {\n    if (p.y>2.) return p.y+2.;\n    p.z+=time*3.*1.5 ;\n    float ini=smoothstep(100.,70.,p.z);\n//    p.x+=ini*4.5;\n      p.y+=.4+smoothstep(120.*3.*0.2,130.*3.,p.z)*.65;\n     p.x-=path(p.z);\n\th = terrain(p.xz*vec2(.5,1.)) * 1.2;\n\th += smoothstep(-0.3, 1.5, h);\n    h*=1.-ini*.7;\n\tfloat ap=.3+max(0.,sin(p.z*.05+cos(p.z*.123)*.0))*.5;\n    h=mix(h,-1.,exp(-ap*(abs(p.x-.5*snoise(p.zz*.5)))));\n\tfloat d = p.y - h;\t\n    tpos=p;\n\treturn d*.5;\n}\n\n//////////////////////////////////////////////  2 Pampa() \n//////////////// /////////////////////   F16  parts object     Turn Burn\nfloat MapEsmPod(vec3 p)\n{   float d, dMin = 1000. ;vec3 q ;\n  float dist = fCylinder( p, 0.15, 1.0);   \n  checkPos =  p- vec3(0, 0, -1.0);\n  pModInterval1(checkPos.z, 2.0, .0, 1.0);\n  /*return*/ d = min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));\n   DMINQ(idEsm) ;  pesm =p ;\n   return  d    ;\n}\n\nfloat MapMissile(vec3 p)\n{\n  float d= fCylinder( p, 0.70, 1.7); float dMin=1000.  ; vec3 q; \n    mTime = mod(iTime,30.)<15.;    //de mod( 2./30.*iTime,2.)>1.  ;\n   if(mTime ){\n     //   p.z +=time*3.*1.5  ;    } //ad speed(time*10.) and injection\n    }\n//  if (d<1.0)\n//  {\n    missileDist = min(missileDist, fCylinder( p, 0.12*1.5, 1.2));   \n    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12*1.5, 0.12*1.5, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n//  }\n    d =missileDist ; DMINQ(idMiss) ; pmissile =p ;\n  return   d  /*missileDist */;\n}\n\n///////////////////////////////////float MapMissile Smoke Trail(p)  2023 03/03\n\n\n\n\n\n //   d =missileTrail ; DMINQ(idMissTrail) ; pmissiletrail =p ;\n //   return   d  /*missileTrail */;\n//////////////////////////////////////      Smoke Trail end\n///////////////////////////////////////     Smoke Trail Color()   2023 03/03\n\n\n\n\n\n\n\n//////////////////////////////////////     Missile Trail Color\n\n////////////////////////////////////////// Smoketrail gentenPosition start\nfloat hashTrl(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noiseTrail(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hashTrl(n + 0.0), hashTrl(n + 1.0), f.x), \n    mix(hashTrl(n + 157.0), hashTrl(n + 158.0), f.x), f.y), \n    mix(mix(hashTrl(n + 113.0), hashTrl(n + 114.0), f.x), \n    mix(hashTrl(n + 270.0), hashTrl(n + 271.0), f.x), f.y), f.z);\n}\n\n\nfloat getTrailDensity( vec3 p)\n{\n  return noiseTrail(p*3.)*2.;  // de *1. => *2.\n} \n\n\n///////////////////////////////////////////////// Smoketrai Position End\n\n\nfloat MapFrontWing(vec3 p, float mirrored)\n{\n  missileDist=10000.0;  float d, dMin=1000.;  vec3 q ;\n\n  checkPos = p;  q= checkPos ;    // Change q=checkPos\n  pR(checkPos.xy, -0.02);\n  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); \n   \n\n // if (wing<5.) //Bounding Box test\n//  {\n    // cutouts\n    checkPos = p-vec3(3.0, 0.3, -.30);\n    pR(checkPos.xz, -0.5);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p - vec3(8.0, 0.3, -8.80);\n    pR(checkPos.xz, -0.05);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p- vec3(9.5, 0.3, -8.50);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);\n\n    // join wing and engine\n    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));\n    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    \n\n    checkPos = p;\n    pR(checkPos.xz, -0.03);\n    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   \n\n    checkPos = p;\n    pR(checkPos.yz, 0.75);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); \n    pR(checkPos.yz, -1.95);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); \n\n    checkPos = p- vec3(0.47, 0.0, -4.3);\n    pR(checkPos.yz, 1.57);\n    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   \n\n    // flaps\n    wing =max(wing, -sdBox( p- vec3(3.565, 0.1, -6.4), vec3(1.50, 1.4, .5)));\n    wing =max(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))));\n\n    checkPos = p- vec3(3.565, 0.18, -6.20+0.30);\n    pR(checkPos.yz, -0.15+(0.8*pitch));\n    wing =min(wing, sdBox( checkPos+vec3(0.0, 0.0, 0.30), vec3(1.46, 0.007, 0.3)));\n\n    // missile holder\n    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));\n\n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); \n\n    // bomb\n    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   \n\n    // missiles (fixed missile)\n    checkPos = p-vec3(2.9, -0.45, -4.50);\n\n    // check if any missile has been fired. If so, do NOT mod missile position  \n    float maxMissiles =0.; \n    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));\n    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); \n\n    pModInterval1(checkPos.x, 1.8, .0, maxMissiles);\n    holder = min(holder, MapMissile(checkPos));\n    \n    //  missile2 (inject missile)      ////////////////////////// \n      float missTime =mod(iTime,15.) ;\n     checkPos = p-vec3(2.9, -0.45+1., -4.50+2.+2.+20.*missTime );\n\n    // check if any missile has been fired.  \n    //float maxMissiles =0.; \n    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));\n    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); \n\n    pModInterval1(checkPos.x, 1.8*0., .0, maxMissiles);\n    holder = min(holder, MapMissile(checkPos));\n      \n     ////////////////////////////////////////////  SmokeTrail start\n   vec3 checkPosTrail = p-vec3(2.9*1.1, -0.45+1., -4.50 -4.-2.+20.*missTime );\n      float spreadDistance =1.5 ;     //  lll 111\n    //  p.z +=3.82 ;                                    //0.=>2. trail startPos\n     float s =pModInterval1(checkPosTrail.z, -spreadDistance,0.-1.,\n                          min(12.,(checkPosTrail.z-ppos.z)/spreadDistance ) );\n   //    vec2 dist =MapSmokeTrail(   ) ;                   \n     float distSmokeTrail =sdEllipsoid(checkPosTrail+vec3(0.,0.,-0.4*0.),vec3(0.6*0.15,0.6*0.15,3. ));\n      distSmokeTrail -=getTrailDensity(checkPosTrail+vec3(10.*s ))*0.25*0.4;    //2023.3.2  thick & long\n      \n      \n      holder =min(holder,  distSmokeTrail   );   //=>  color line 1050\n    \n    ////////////////////////////////////////////   SmokeTrail End\n  \n    // ESM Pod\n    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));      // 2023 3/2 pod advanced\n\n    // wheelholder\n    wing=min(wing, sdBox( p- vec3(0.6, -0.25, -3.8), vec3(0.8, 0.4, .50)));\n\n    wing=min(bombDist, min(wing, holder));\n//  }\n      d =wing ;  DMINQ(idWngM) ;  pfront =p ;\n  return wing;\n}\n\nfloat MapRearWing(vec3 p)\n{    // float d, dMin=100000.0;　　vec3 q ;\n       float d, dMin=1000. ; vec3 q ;\n  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5*1.2, 0.017, 1.3)); \n  if (wing2<0.15) //Bounding Box test\n  {\n    // cutouts\n    q=checkPos ;\n    checkPos = p-vec3(3.0, 0.0, -5.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); \n\n    checkPos = p-vec3(0.0, 0.0, -4.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);\n\n    checkPos = p-vec3(3.0, 0.0, -11.70);\n    pR(checkPos.xz, -0.05);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); \n\n    checkPos = p-vec3(4.30, 0.0, -11.80);\n    pR(checkPos.xz, 1.15);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n  }\n    d =wing2 ;  DMINQ(idWngT) ; prear =p ;\n  return   d /*wing2 */ ;\n} \n\nfloat MapTailFlap(vec3 p, float mirrored)\n{      float d, dMin=100000.0;  vec3 q ;\n  p.z+=0.3;\n  pR(p.xz, rudderAngle*(-1.*mirrored)); \n  p.z-=0.3;\n\n  float tailFlap =sdBox(p- vec3(0., -0.04, -.42), vec3(0.025, .45, .30));\n\n  // tailFlap front cutout\n  q =checkPos ;\n  checkPos = p- vec3(0., 0., 1.15);\n  pR(checkPos.yz, 1.32);\n  tailFlap=max(tailFlap, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n  // tailFlap rear cutout\n  checkPos = p- vec3(0., 0, -2.75);  \n  pR(checkPos.yz, -0.15);\n  tailFlap=fOpIntersectionRound(tailFlap, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n  checkPos = p- vec3(0., 0., -.65);\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.25, 0), vec3(0.06, 0.05, 0.15)));\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.10, 0), vec3(0.06, 0.05, 0.15)));\n   d =tailFlap;    DMINQ(idtailFlap) ; pflap =p ;\n\n  return d  /*tailFlap  */;\n}\n\nfloat MapTopWing(vec3 p, float mirrored)\n{     vec3 q ;   q =checkPos ;\n\n  checkPos = p- vec3(1.15, 1.04, -8.5);   float d, dMin=100000.0;\n  pR(checkPos.xy, -0.15);  \n  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));\n  if (topWing<.15) //Bounding Box test\n  {\n    float flapDist = MapTailFlap(checkPos, mirrored);\n\n    checkPos = p- vec3(1.15, 1.04, -8.5);\n    pR(checkPos.xy, -0.15);  \n    // top border    \n    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));\n\n    float flapCutout = sdBox(checkPos- vec3(0., -0.04, -1.19), vec3(0.02, .45, 1.0));\n    // tailFlap front cutout\n    checkPos = p- vec3(1.15, 2., -7.65);\n    pR(checkPos.yz, 1.32);\n    flapCutout=max(flapCutout, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n    // make hole for tail flap\n    topWing=max(topWing, -flapCutout);\n\n    // front cutouts\n    checkPos = p- vec3(1.15, 2., -7.);\n    pR(checkPos.yz, 1.02);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 1.6)), 0.05);\n\n    // rear cutout\n    checkPos = p- vec3(1.15, 1., -11.25);  \n    pR(checkPos.yz, -0.15);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n    // top roll \n    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.3), 0.06)); \n\n    topWing = min(topWing, flapDist);\n  }\n      d =topWing ; DMINQ(idFin) ; ptop =p ;\n  \n  return  d  /*topWing */;\n}\n\n////////////////////////////// Fus(body + window+ nose))\nfloat MapBody ( vec3 p){\n    float d=100000. , dMin=100000.0; vec3 q ;\n  vec3 pOriginal = p;  \n  // rotate position \n  p=TranslatePos(p, pitch, roll);   p.xy *=rot(pi) ; // z axis rotation PI(180)\n  float mirrored=0.;\n  // AABB TEST  \n//  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    \n//  if (test>1.0) return test;\n\n  // mirror position at x=0.0. Both sides of the plane are equal.\n  mirrored = pMirror(p.x, 0.0);\n\n  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   \n\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n  // window\n  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n  winDist = max(winDist, -body);\n  body = min(body, winDist);\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));\n\n  // front (nose)\n  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));\n  checkPos = p-vec3(0, 0, 2.5);\n  pR(checkPos.yz, 1.57);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos +vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos +vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);\n  d =body ; DMINQ(idFus) ;  pbody = p ;\n  \n   return   d /*body*/ ;\n\n}  ///////////////////////////  Fus END\n\n///////////////////////////////   window(cockpit) start\n float MapCkp ( vec3 p){\n    float d=100000. , dMin=100000.0; vec3 q ;\n  vec3 pOriginal = p;  \n  // rotate position \n  p=TranslatePos(p, pitch, roll);   p.xy *=rot(pi) ; // z axis rotation PI(180)\n  float mirrored=0.;\n  // AABB TEST  \n//  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    \n//  if (test>1.0) return test;\n\n  // mirror position at x=0.0. Both sides of the plane are equal.\n  mirrored = pMirror(p.x, 0.0);\n\n  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   \n\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n  // window\n  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n  winDist = max(winDist, -body);\n\n  d =winDist ; DMINQ(idFus) ;  pcock =p ;\n  \n   return   d /*window(cockpit)*/ ;\n\n} \n/////////////////////////////// window end\n\n/////////////////////////////////    large bomb start\n  float MapBomb2 ( vec3 p){\n    float d=100000. , dMin=100000.0; vec3 q ;\n  vec3 pOriginal = p;  \n  // rotate position \n  p=TranslatePos(p, pitch, roll);  // p.xy *=rot(pi) ; // z axis rotation PI(180)\n  float mirrored=0.;\n \n  float holder =sdBox(p-vec3( 0.,1.1,-4.3 ),vec3(0.2,0.4,0.8 ));\n   d =holder ; \n   bombDist2 = fCylinder( p- vec3(0., 1.6*0.8, -4.0), 0.45, 1.);   // y axis reverse -1.6=>+1.6\n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., 1.6*0.8, -3.20), vec3(0.45, 0.45, 2.)));   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., 1.6*0.8, -4.80), vec3(0.45, 0.45, 2.)));   \n\n  d=min(d, bombDist2);\n\n//  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    \n\n  checkPos = p- vec3(0, 0.2, -5.0);\n // d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);\n\n // d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);\n\n   DMINQ(idbom2) ;  pbomb2 =p ;\n  \n   return   d /*  large bomb2*/ ;\n\n}\n/////////////////////////////////    larage bomb end\n   /////////////////////////////  eFlame  Start\n   float MapEflame ( vec3 p){\n    float d=100000. , dMin=100000.0; vec3 q ;\n  vec3 pOriginal = p;  \n  // rotate position \n  p=TranslatePos(p, pitch, roll);  // p.xy *=rot(pi) ; // z axis rotation PI(180)\n  float mirrored=0.;\n \n     float eflame = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0*3.)*0.014*10.-2.),\n                  vec3(.17, 0.17, .10*4.)*0.135);   // color line 940\n   \n     d = eflame   ;\n     DMINQ(ideFlame) ;  peflame =p ;\n  \n   return   d /*  large bomb2*/ ;\n\n }\n   ///////////////////////////   eflame end\n   \n   //////////////////////////////////////// float MapMissileTrail()\n   \n   \n   \n   \n   \n   \n   //////////////////////////////////////// MissileTrail end\n   \n   \n   \n   \n\n////////////////  union pampa()   F16 F16 F16 Union\n////////////////////////////////////\n float pampa(vec3 p) {   p.xz *=rot(pi) ;  //direction PI(180 do) reverse\n    p.z+=2.8;\n    p.y-=.8;\n    p.yz*=rotyz;\n    p.xz*=rotxz;\n    p.z-=2.8;\n    p.y+=.8;\n    p.xy*=rotxy;\n  //  float bound=box(p,vec3(5.,3.*3.,6.),0.);\n#ifdef noplane\n //   bound=box(p,vec3(1.,1.,2.3),0.);id=1.;return bound;\n#endif\n//    if (bound>.65) return bound+.65; \n    \n    objcol=vec3(1.);\n    p.z*=-1.05;\n    ////////////////////// parts objects\n     float d =1000. ;\n     float mirrored =0. ;\n           mirrored =pMirror(p.x,0.0) ;\n     \n    float ckp =MapCkp(p) ;\n    float body =MapBody/*fus*/(p);\n    float wingm =MapFrontWing/*wingm*/(p, mirrored ) ;\n //   float eng  =eng(p)  ;\n //   float eng2 =eng2(p) ;\n    float wingt =MapRearWing/*wingt*/(p);\n    float wingf =MapTopWing/*wingf*/(p,mirrored);\n    float bomb2 =MapBomb2(p)  ;\n    float esm   =MapEsmPod(p) ;\n    float eflame =MapEflame(p) ;    // color line 940\n                          //    float missile =MapMissile(p) ; \n                          //    float missile2 =MapMissile2(p) ;\n          d =min(d, body) ;\n          d =min(ckp,body) ;\n          d =min(d,wingm) ;\n     //     d =min(d,eng) ;\n     //     d =min(d,eng2);\n          d =min(d,wingt);\n          d =min(d,wingf);\n          d =min(d,bomb2) ;\n          d =min(d, esm) ;\n          d =min(d,eflame);   // d =min(d,missile) ;  // d =min(d,missile2);\n          \n     if(d ==body) id =1.;\n     if(d ==ckp) id =2.;\n     if(d ==wingm) id =4. ;\n //    if(d ==eng ) id =3. ;\n  //   if(d ==eng2) id =3. ;\n     if(d ==wingt)id =5. ;\n     if(d ==wingf)id =6. ;\n     if(d ==bomb2)id =8. ;\n     if(d == esm )id =12.;\n     if(d == eflame) id =10. ;  // ideFlame\n                            // if(d == missile )   id = 11.0 ;     \n                           //  if(d == missile2)   id = 14.;\n    //////////////////////\n    id=max(0.,id);  \n    \n    pos=p;\n    return d   /**0.5 */;   //  ? d*1.2 ?\n \n  }\n\n////////////////////////////////////////////////\n\nfloat water(vec3 p) {\n    p.z+=time*3.*1.5;\n    p.x-=path(p.z);\n    p.x*=2.;\n    return (p.y+1.75+snoise(p.xz*20.+time*0.)*.0002)*.9;\n}\n\nvec2 contrail(vec3 p) {\n    vec3 pp=p-ppos;\n    float t2=(tpos.z/(3.*1.5))*speed-2.+.04*speed;\n    float chx=(interhash(0.,t2)-.5)*4.5;\n    float chy=.8+(interhash(-10.,t2*.75)-.5)*1.5+.018-baja;\n    float w=.003+min(.05,-pp.z*.005)*2.;\n    w=min(.03,w);\n    float chorro=length(p.xy-vec2(chx,chy))-snoise(tpos.zz*15.)*w*.4;\n    chorro=max(.003,abs(chorro));\n    chorro=max(chorro,pp.z+.1);\n    chorro=max(chorro,-pp.z-14.);\n    return vec2(chorro,w);\n}\n\n\nfloat de(vec3 p) {\n    vec3 pos=p-ppos;\n    float pam=pampa(pos*20.)/20.;//  float missile2 =MapMissile2(pos*30.)/30. ;\n    float ter=terrain(p/1.5)*1.5;\n    float wat=water(p);\n    float d=min(wat,ter);\n    d=min(d,pam);               //  d =min(d,missile2) ;\n    if (d==ter) id=-1.;\n    if (d==wat) id=-2.;\n    return d;\n}\n\n\nfloat ao(vec3 p, vec3 n) {\n    float st=.05;\n    float ao=0.;\n    for(float i=0.; i<8.; i++ ) {\n        float td=.02+st*i;\n        float d=de(p+n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n    return clamp(1.-ao*.15,0.,1.);\n}\n\nfloat shadows(vec3 p, vec3 ldir) \n{\n    float td=.0,sh=1.,d=.01,dt;\n    for (int i=0; i<50; i++) {\n\t\tp+=ldir*d;\n        float map=de(p);\n        vec2 ctrail=contrail(p);\n        dt=ctrail.x-ctrail.y*1.5+.05;\n        d=min(map,dt);\n        td+=d;\n        if (dt<.05&&map>.01) {\n            sh=.6+ctrail.y*8.; break;\n        }\n\t\tif (d<.002) {\n            sh=.5;\n            break;\n        }\n        if (td>maxdist) break;\n    }\n    return clamp(sh,0.5,1.);\n}\n\n\nvec3 normal3(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\n/// normal hack by Shane to reduce compilation time\nvec3 normal(vec3 pos) {\n    vec2 e=vec2(0.,det*.5);\n    vec3[4] ev = vec3[4](e.yxx, e.xyx, e.xxy, e.xxx-.000001);\n    vec3 nn = vec3(0);\n    for(int i = 0; i<4; i++){\n        nn += sign(ev[i])*de(pos + ev[i]);\n        if(nn.x<-1e8) break; // Fake break.\n    } \n    return normalize(nn);\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(water(p+e.yxx),water(p+e.xyx),water(p+e.xxy))-water(p));\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\nfloat fbm(in vec3 q)\n{\n\tfloat f  = 0.5000*noise( q ); q = m3*q*2.01;\n\tf += 0.2500*noise( q ); q = m3*q*2.02;\n\tf += 0.1250*noise( q ); q = m3*q*2.03;\n\tf += 0.0625*noise( q ); q = m3*q*2.04;\n\treturn f;\n}\n\n\n /////////////////////////////////////////////  3 pampa Color(mihty ann225)\n //////////////////////////////////////////\n vec3 pampaColors() {\n  \n  ////////////////////////////////////// Base Data\n   //  vec3 hitPos =TranslatePos(rayHit.hitPos, pitch, roll);\n          \n          \n  vec2 center;\n  float dist;\n\n  float specLevel=0.7;\n  float specSize=0.7;\n\n  float fre = 0.5 ; //    　pow( 1.0-abs(dot( rayHit.normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  // vec3 tint = vec3(0.62,.50,0.40)*1.15;  \n  vec3 tint = vec3(1.62, 1.50, 1.30)*0.65;\n  vec3 brightCamo =1.15*tint;\n  vec3 darkCamo = 0.78*tint;\n\n\n  vec3 baseTexture = mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(pos*1.6)));// hitPos=>pos\n\n  // baseTexture = col;\n  vec3 col=mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(pos*1.6*2.)));\n  vec3 reflection =  vec3 (0.5) ;   //GetReflectionMap(rayDir, rayHit.normal);\n  // create base color mixes\n  vec3 lightColor = (vec3(1.0));\n  vec3 darkColor = (vec3(0.25));\n  vec3 missilBaseCol =  lightColor*0.5;\n  vec3 missilBaseCol2 =  darkColor;\n  vec3 missilCol = lightColor;\n  vec3 missilCol2 = lightColor*0.27;\n  \n      // side 17      \n    vec2 linePos = vec2(-0.55 , 0.);\n    vec3 textColor = vec3(.99,0.0,0.05);  // blue col\n    if (pos.x/*pbody.x */<0.)\n    {\n      col =mix(col, textColor, line(pos.zy /*pbody.zy*/, linePos+vec2(0., -0.2), linePos+vec2(0., .2), 0.04));\n      col =mix(col, textColor, line(pos.zy /*pbody.zy*/, linePos+vec2(-0.2, -0.2), linePos+vec2(-.4, -.2), 0.04));\n      col =mix(col, textColor, line(pos.zy /*pbody.zy*/, linePos+vec2(-0.4, -0.2), linePos+vec2(-.25, .2), 0.04));\n    } else\n    {\n      col =mix(col, textColor, line(pbody.zy, linePos+vec2(-0.35, -0.2), linePos+vec2(-0.35, .2), 0.04));\n      col =mix(col, textColor, line(pbody.zy, linePos+vec2(0.1, -0.2), linePos+vec2(-.15, -.2), 0.04));\n      col =mix(col, textColor, line(pbody.zy, linePos+vec2(-0.15, 0.2), linePos+vec2(.10, -.2), 0.04));\n    }    \n  \n    ///////////////////////////////// engines exhaust (object  from line 731 )\n  //  if(id == 10.){ \n     if(pos.z<-9.45  && length(pos.xy)<0.4){\n        col=mix(vec3( 0.950,0.25,0.)*8. /*col+0.5*/, vec3(0.970 )*1. /*col*/, \n              smoothstep(.04*1.35, 0.10*1.35, distance(-9.45/*2.75*/, /*peflame.z */pos.z)));\n      }       \n      \n      ////////////////////////////////  missile trail color      // object => line 50\n      float missTime =mod(iTime,15.) ;\n      if(pos.z< (  -4.5*0.5 +20.*missTime )     && pos.z> ( 5.  ) ){\n      \n    \n        col =mix( mix(vec3(0.995,0.925*0.4,0.)*8.,reflection*2.5,fre),         // case (2)\n                     vec3(0.95,0.95,0.95),\n                      smoothstep( 5., -4.5*0.+20.*missTime, pos.z)) ;\n      \n      }   \n      \n  // }\n  \n  //////////////////////////////////////  Base Data End\n  \n  if (id/*Obj*/ == 1. /* idFus  pbody */) {   qHit =pbody ;\n  \n       /////////////////////////////////////// Turn Burn Data\n        // vec3 tint = vec3(0.62,.50,0.40)*1.15;  \n  vec3 tint = vec3(1.62, 1.50, 1.30)*0.65;\n  vec3 brightCamo =1.15*tint;\n  vec3 darkCamo = 0.78*tint;\n\n\n  vec3 baseTexture = mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(pos*1.6)));// hitPos=>pos\n\n  // baseTexture = col;\n  vec3 col=mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(qHit/*pos*/*1.6)));\n                                                             // qHit*1.6 ???\n                                                             \n     // remove camo from wing tip\n    col =mix(col, brightCamo, line(vec2(abs(qHit.x), qHit.z), vec2(-7.25, 5.), vec2(-1.45, 1.7), 0.3));\n\n    // color bottom gray\n    col=mix(lightColor*0.7, col, step(0.01, qHit.y));\n\n    // front\n    col = mix(col, lightColor, smoothstep(3.0, 3.02, qHit.z));  \n    col = mix(col, darkColor, smoothstep(3.08, 3.1, qHit.z));\n    col =mix(col*1.4, col, smoothstep(.07, .09, distance(1.8, qHit.z)));                                                        \n                                                             \n                                                           \n                                                            \n       ///////////////////////////////////////\n  } \n    /*else if (id ==2. ) { // idCkp\n   \n   \n  } else if (id ==3. ) { // idEng\n    \n    \n  }*/\n  \n  else if (id ==4./* idWngM   pfront */) {\n    //////////////////////////////////////////  Turn Burn Data \n       // front wing stripes\n       \n ///////////////////////////////////////////////////////////////////////////Default\n    col=mix(darkColor, col, smoothstep(1.4, 1.42, distance(-6.90, pfront.z)));\n    col=mix(lightColor, col, smoothstep(1.3, 1.32, distance(-6.90, pfront.z)));\n    col=mix(darkColor, col, smoothstep(.84, 0.86, distance(-6.7, pfront.z)));\n    col=mix(lightColor, col, smoothstep(.22, 0.235, distance(-6.94, pfront.z))); \n\n    // vertical stripes   \n    float xMod = mod(/*qHit*/pfront.x-0.5, 11.0);\n    col=mix(darkColor, col, smoothstep(0.5, 0.52, distance(5., xMod)));\n    col=mix(lightColor, col, smoothstep(0.4, 0.42, distance(5., xMod)));\n\n\n    // boxes \n    vec2 absqHit = abs(/*qHit*/pfront.xz);    //hitPos =>pos \n\n    col =mix(col, col*1.40, drawRect(vec2(0.4, 2.0)-0.05, vec2(0.8, 2.0)+0.05+0.25, absqHit));\n    col =mix(col, col*0.2, drawRect(vec2(0.4, 2.0), vec2(0.8, 2.0)+0.2, absqHit));\n\n   \n    if (pfront.y/*qHit.y*/>0.15)   // hitPos ->pos\n    {\n      // letters BoundingBox\n      if (drawRect(vec2(3.2, 3.8)-0.05, vec2(4.9, 4.8), absqHit)>=1.)\n      {\n        AddLetters(pfront.xz, col, vec2(-3.70, 3.60));\n      }\n\n      // more boxes \n      col =mix(col, col*1.40, drawRect(vec2(0.2, 3.6)-0.05, vec2(1., 3.6)+0.05+0.35, absqHit)); \n      col =mix(col, col*0.2, drawRect(vec2(0.2, 3.6), vec2(1., 3.6)+0.3, absqHit));\n    //   col =mix(col, vec3(0.,1.,0.8)*0.2*5., drawRect(vec2(3.5, 4.8), vec2(4.5, 5.3), absqHit));\n     \n                                // line 1030 delete => water reflection more clear\n      // create star (front wings)         \n      center = vec2(5., -5.1)-vec2(xMod, pfront.z);\n      dist = length(center);\n      col=mix(/*lightColor*/vec3 (0.,0.,1.), col, smoothstep(0.8, 0.82, dist));\n      col=mix(/*darkColor*/vec3(1.,0.,0. ), col, smoothstep(0.7, 0.72, dist));\n      col=mix(lightColor, col, smoothstep(0.7, 0.72, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n      col=mix(/*darkColor*/ vec3(0.,1.,0. ), col, smoothstep(0.6, 0.62, (dist*1.50)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n    } else\n    {\n      // bottom details\n      col =mix(col, darkColor, line(vec2(absqHit.x, pfront.z), vec2(0., -1.5), vec2(-0.3, -1.5), 0.06));\n      col =mix(col, darkColor, line(vec2(absqHit.x, pfront.z), vec2(-0.3, -1.5), vec2(-0.3, -1.), 0.085));\n    } \n    //////////////////////////////////////////////  missile trail color\n    \n    \n    \n    ////////////////////////////////////\n    \n    //////////////////////////////////////////\n    \n  } else if (id ==5. ) {  // idWngT (tailWing) rearWing   prear\n  //  qHit.xz *=rot(PI) ;\n    ///////////////////////////////////    Turn Burn Data\n     qHit =prear ;  //ad\n      col=mix(darkColor, col, smoothstep(.55, 0.57, distance(-9.6, qHit.z)));\n    col=mix(lightColor, col, smoothstep(.5, 0.52, distance(-9.6, qHit.z)));\n    col=mix(darkColor, col, smoothstep(.4 , 0.42, distance(-9.6, qHit.z)));  \n    \n    /////////////////////////////////////\n  } \n   else if (id ==6./* idFin*/) {  // idFin( TopWing)   ptop\n  \n    //////////////////////////////////////// Turn Burn Data\n    // top wing stripes\n    qHit = ptop ;  // ad\n    \n    col=mix(darkColor, baseTexture, smoothstep(0.55, 0.57, distance(0.85, qHit.y)));\n    col=mix(lightColor, col, smoothstep(.32, 0.34, distance(0.95, qHit.y)));\n\n    // create star (top wings)    \n     \n    center = vec2(-8.73, 0.95)-vec2(qHit.z, qHit.y);\n    dist = length(center); \n    col=mix(darkColor, col, smoothstep(0.24, 0.26, dist));\n    col=mix(lightColor, col, smoothstep(0.24, 0.26, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.13))); \n    ///////////////////////////////////////\n  } \n\n  \n  /////////////////////////////  \n    else if(id ==8.) {      // idbom2 (large Bomb )    pbomb2\n    \n     qHit = pbomb2 ;  // ad\n     \n     col=mix(missilBaseCol2, missilCol, smoothstep(1.48, 1.5, distance(-4.1, qHit.z)));      \n    col=mix(col, missilBaseCol, smoothstep(1.6, 1.62, distance(-4.1, qHit.z)));      \n    col=mix(missilBaseCol, col, smoothstep(0.45, 0.47, distance(-4.1, qHit.z)));   \n    \n    }\n    \n//   else if(id == 12.) {    // idEsm   pesm\n   if( pos.x> 7. ){\n     qHit = pos ; //pesm ;\n     \n      vec2 absHitPos =abs(qHit.xz) ;                           // unscseeded ??\n      col =mix( col/*tint*/, lightColor*0.75,smoothstep(7.02*cos(iTime*0.3),7.04,abs(qHit.x ))) ;\n   }\n   //////////////////////////////////////   missile\n /*  else if( id == 11. ){\n    qHit = pos ; //pmissile ;\n     col=mix(missilBaseCol, missilCol2, smoothstep(-3.35, -3.37, qHit.z));\n    col=mix(col, missilCol, smoothstep(-3.2, -3.22,qHit.z));\n    col=mix(missilCol2, col, smoothstep(.32, 0.34, distance(-4.75, qHit.z)));\n    col=mix(missilBaseCol, col, smoothstep(.25, 0.27, distance(-4.75, qHit.z)));\n   \n   } */\n   \n   //////////////////////////////////////\n   \n   \n // }\n \n    col/*4.rgb*/ *=.5+oc*.5;\n    col/*4.rgb*/ *=1.05-noise(pos*20.)*.1;\n    return col/*4.rgb*/ *vec3(1.,.95,.9);\n    \n   }\n ////////////////////////////////////////////   3 end\n \n\n \n\nvec3 terrainColors(vec3 p, vec3 n, float y) {\n    vec3 col = mix( vec3(0.2, 0.18, 0.18)*.7, vec3(0.22, 0.19, 0.16)*.8, smoothstep(0.7, 1.0, n.y) *.5) * 3.;\n    float r=snoise(p.xy*vec2(7., 50.0)*2.)*.8;\n    col = mix( r*vec3(.5, 0.4, 0.4), col, n.y); \n    float clear=smoothstep(.0,.07,h+.75);\n    vec3 veg=vec3(.9, .77, .6)*.4;\n    veg=mix(veg,vec3(1.1,.95,0.7)*.23,smoothstep(0.,.5,snoise(p.xz*.5)));\n    veg*=(1.+snoise(p.xz*90.)*.3);\n    col = mix( col, veg, clear*smoothstep(.8, .9, n.y) *smoothstep(1.,0.,snoise(p.xz+123.)));\n    col*=1.-smoothstep(-.3,-1.2,p.y)*.7;\n    return col*1.6;\n}\n\nvec3 shade(vec3 p, vec3 dir) {\n    float y=tpos.y-h;\n    float id2=id;\n    vec3 n = normal(p);\n    vec3 col;\n    float oc=1.;\n    if (id<0.) col=terrainColors(tpos,n,y),oc=ao(p,n); else col=pampaColors();\n    float amb=max(.5,dot(-dir,n))*.5*oc;\n    amb=.4*oc;\n    float sh=1.;\n    if (ref<.5) sh=shadows(p,ldir);\n    float dif=max(0.,dot(ldir,n))*.6;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),50.);\n    if (id2!=2.) spe*=.3;\n    if (id2<0.) spe*=.4;\n    \n    return col*(amb+dif*sh)+spe*sh*vec3(1.1,1.,.9);\n}\n\nvec3 shadeRiver(vec3 p, vec3 dir) {\n    float sh=1.;\n    vec3 n = normal(p);\n    float tr=smoothstep(120.*3.,130.*3.,tpos.z);\n    vec3 col=mix(vec3(0.14,0.12,0.1)*2.,vec3(0.1,0.1,0.105)*3.3,tr);\n    col+=smoothstep(.05,.0,tpos.y-h)*.2;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*.55;\n    return col*(.7+sh*.3)+spe;\n}\n\nvec3 shadeVid(vec3 p, vec3 dir) {\n    vec3 cab=vec3(.1);\n    float t=step(.07,abs(pcab.z+.3-pcab.y*.5));\n    t=min(t,step(.05,abs(pcab.z+1.4+pcab.y*.3)));\n    vec3 col=cab;\n    vec3 n = normal(p);\n    float amb=.4;\n    float dif=max(0.,dot(ldir,n))*.5;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*1.5;\n    return col*(amb+dif)+spe*vec3(1.1,1.,.9);\n}\n\n\n\nvec3 march(vec3 from, vec3 dir, vec2 uv) \n{\n    ldir = normalize(vec3(1,1.,1.5));\n    float d, td=0., td2=0., vid=0., g=0.,aro=g, chorro=1.;\n    vec3 p=from, col=vec3(.0), colvid=col, shaderef=col, pp=p, pref=p, odir=dir;\n    float h=hash(uv*1000.)*.1;\n  //  FlyerParms();                // ad Ann225    4  wing Data \n    \n    for (int i=0; i<250; i++) {\n        p+=d*dir;\n        d=de(p)*(1.0-h);\n        det=id<0.?.003:.0002;\n        det*=1.0+pow(td,1.2)*.75;\n        if (id==2.&&d<det) {\n            if (vid<.5) colvid=shadeVid(p,dir);\n            vid=1.;\n            d=max(.01,abs(d));\n        };\n        if (id==-2.&&d<det&&ref<.5) {\n            ref=1.;\n            pref=p;\n            vec3 n=normal2(p);\n            dir=reflect(dir,n);\n            p+=dir*.05;\n            td2=td;\n            d=det;\n            //continue;\n        };\n        if (d<det || td>maxdist) break;\n        pp=p-ppos;\n        aro=max(abs(pp.y)-.005,abs(length(pp.xz)-.3));\n        if (time>1.5 && time < 8.) d=min(d,aro);\n#ifdef trail\n        if (pp.z<-.51&&p.z>-14.){\n            vec2 ctrail=contrail(p);\n            float chorro=ctrail.x;\n            float w=ctrail.y;\n            d=min(d,chorro*(.5+w*17.));\n            g=max(g,max(0.,w-chorro)/w*smoothstep(-14.,0.,pp.z)*(1.-ref*.5)\n                *smoothstep(-.07,-.35,pp.z));\n        }\n#endif        \n        td+=d;\n    }\n    float id2=id;\n    float clou=0.;\n    vec3 sky=mix(vec3(.75,.77,.85)*1.0,vec3(0.6,.7,.85)*.9,clamp(p.y*.07+.2,-.4,1.))*.8;\n    sky+=pow(max(0.,dot(dir,ldir)),70.)*vec3(1.4,1.,.6)*.5;\n    vec3 colref=vec3(0.);\n    if (d<det&&d!=aro) {\n        p-=det*dir*2.;\n        col=shade(p, dir);\n    } else {\n        td=maxdist;\n        p=dir*maxdist;\n        vec3 ps=dir*2.5;\n        ps.y*=4.;\n        ps.z+=time*.05;\n        clou=fbm(ps);\n        clou=smoothstep(.4,1.2,clou);\n        clou*=smoothstep(0.,5.,p.y);\n    }\n    if (ref>.5) {\n        shaderef=shadeRiver(pref,odir);\n        colref=mix(shaderef,sky,td2/maxdist);\n    }\n    sky+=clou*step(td-.5,maxdist)*.3*vec3(1.,.85,.6)*(1.+ref*.7);\n    col=mix(col,sky,pow(td/maxdist,1.5));\n    col=mix(col,colvid,vid*.5);\n    if (ref>.5) col=colref*.5+col*.5;\n    col=mix(col,col.ggg,smoothstep(1.,0.,t));\n    vec3 back = vec3(length(smoothstep(.8,1.,fract(uv*20.)))*.2);\n    float b=max(-1.,1.5-time);\n    float c=max(-1.,3.7-time);\n    float li=smoothstep(.01,.0,abs(uv.x+.5-b))*step(abs(uv.y+.025),.425*min(1.,time*2.));\n    back+=li*step(.5,fract(sqrt(time*13332.654)));\n    back+=hash(uv*1234.+time)*.2;\n    if (time>2.5) {\n        li=smoothstep(.01,.0,abs(uv.y+.5-c))*step(abs(uv.x+.025),.425*min(1.,time*2.));\n        back+=li*step(.5,fract(sqrt(time*13332.654)));\n    }\n    if (id2<0.||uv.x<b-.5||(time>2.5&&uv.y<c-.5)) col=mix(col,back,smoothstep(1.,0.,t));\n    if (fract(time*10.)*step(abs(time-8.5),.5)>.5) col=back;\n    col=mix(col,back,step(time,9.5)*step(aro,d)*step(.5,fract(time*2.+1.*atan(pp.x,pp.z))));\n \n   /////////////////////////////// trail color\n    g*=smoothstep(0.5,1.,t);\n    col=mix(col,vec3(.85),g*.5);\n    //////////////////////////////// misile trail volor\n    /*     float missTime =mod(iTime,15.) ;\n          if(id == 4. ){\n      if(pfront.z< (  -4.5 +20.*missTime ) && pfront.z> 5.  && \n          pfront.x<2.9*1.45 && pfront.x>2.9*1.15 &&  pfront.y<-0.405 && pfront.y>-0.605  ){\n      \n    \n        col =mix( mix(vec3(0.95,0.925*0.,0.)*8.,vec3(0.5), 0.5),        \n                     vec3(0.95,0.95*0.,0.95*0.),\n                      smoothstep( 5., -4.5+20.*missTime, pfront.z)) ;\n      \n      }   \n    } */\n    \n    ////////////////////////////////\n    \n    return col;\n}\n\nmat3 lookat(vec3 dir,vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashseed=floor(iTime*.83/200.);\n    vec2 uv = gl_FragCoord.xy/resolution.xy-.5;\n    uv.x*=resolution.x/resolution.y;\n    float fov=1.1*1.5*0.8;\n    fragColor=vec4(0.);\n#ifdef letterboxfullscreen\n    if (resolution.x>1500.&&abs(uv.y)>.37) return;\n    if (resolution.x>1500.) fov=.8;\n#endif\n    speed=.25;\n    t=time*speed-2.;\n    float start=smoothstep(0.,.5,t);\n    float t1=t*start;\n    float t2=time*speed+.13-2.;\n    t2*=start;\n    float z=-.65-interhash(11.,t1)*1.8;\n    float xz=1.-interhash(22.,t1*.5)*5.;\n    float yz=.3-interhash(33.,t1*.5)*1.1;\n    ppos.x=(interhash(0.,t1)-.5)*4.5;\n    ppos2.x=(interhash(0.,t2)-.5)*4.5;\n    baja=smoothstep(125.,130.,time)*1.65;\n    ppos.y=.8+(interhash(-10.,t1*.75)-.5)*1.5-baja;\n    ppos2.y=.8+(interhash(-10.,t2*.75)-.5)*1.5-baja;\n    rotyz=rot((ppos.y-ppos2.y)*.5);\n    rotxy=rot((ppos.x-ppos2.x)*.8);\n    rotxz=rot((ppos.x-ppos2.x)*.3);\n    vec3 from=vec3(0.,0.3,z);\n    vec2 m=iMouse.xy/iResolution.xy;\n    bool mouseon=false;\n#ifndef onlymouse\n    if (iMouse.z<1.) {\n        from.yz*=rot(yz);\n        from.xz*=rot(xz);\n    } else {\n        from.yz*=rot(.5-(1.-m.y)*1.5);\n        from.xz*=rot(-m.x*6.);\n        mouseon=true;\n    }\n#endif\n#ifdef onlymouse\n    from.yz*=rot(.5-(1.-m.y)*1.5);\n    from.xz*=rot(-m.x*6.);\n    mouseon=true;\n#endif\n    from+=ppos;\n    if (!mouseon && mod(time,30.)>24.) from=vec3(.7,0.,mod(-time*4.,30.)-15.),fov*=1.3;\n    vec3 g=mix(vec3(0.5,1.,0.),vec3(1.),smoothstep(0.,1.,t));\n    if (t<0.) {\n        ppos=vec3(0.);\n        ppos2=ppos;\n        from=vec3(0.,.6,-0.1);\n        if (time>2.8) from=vec3(.5,.3,0.), from.xz*=rot(-time*.3);\n    }\n    vec3 dir=normalize(vec3(uv,fov));\n    float s=sin(time*.3);\n    dir.xz*=rot(s*s*s*.25*start);\n    dir=lookat(ppos-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from,dir,uv*max(1.,2.-time*2.))*g;\n    col=pow(col,vec3(1.2))*1.15;\n    col*=smoothstep(200.,198.,mod(time,200.));\n    col*=smoothstep(0.,.5,mod(time,200.));\n    fragColor = vec4(col,1);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}