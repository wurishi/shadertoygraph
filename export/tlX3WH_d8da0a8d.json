{"ver":"0.1","info":{"id":"tlX3WH","date":"1556224757","viewed":848,"name":"Interstellar icosahedron","username":"Quinchilion","description":"Recreation of https://www.reddit.com/r/blackmagicfuckery/comments/bh54yo/interstellar/","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","icosahedron","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define REFL_COUNT 10\n#define WALL_THICKNESS 0.05\n\nconst float ico_a = 0.525731;\nconst float ico_b = 0.850651;\n\n#define ICO_FACES 20\nconst uvec3 icoIndices[ICO_FACES] = uvec3[ICO_FACES](\n    uvec3(0, 1, 4),\n    uvec3(0, 6, 1),\n    uvec3(2, 5, 3),\n    uvec3(2, 3, 7),\n    \n    uvec3(4, 5, 8),\n    uvec3(4, 10, 5),\n    uvec3(6, 9, 7),\n    uvec3(6, 7, 11),\n\n    uvec3(8, 9, 0),\n    uvec3(8, 2, 9),\n    uvec3(10, 1, 11),\n    uvec3(10, 11, 3),\n    \n    uvec3(0, 4, 8),\n    uvec3(0, 9, 6),\n    uvec3(1, 10, 4),\n    uvec3(1, 6, 11),\n    uvec3(2, 8, 5),\n    uvec3(2, 7, 9),\n    uvec3(3, 11, 7),\n    uvec3(3, 5, 10)\n);\n\n// Returns the position of icosahedron vertex of index i\n// The vertices of an icosahedron lie on the corners of three rectangles\n// that are orthogonal to each other.\nvec3 icoVec(uint index) {\n\tuint i = index / 4u;\n    uint j = index - i * 4u;\n    float asign = (j & 1u) == 1u ? -1.0 : 1.0;\n    float bsign = j >= 2u ? -1.0 : 1.0;\n    \n    if (i == 0u) {\n        return vec3(0.0, asign * ico_a, bsign * ico_b);\n    } else if (i == 1u) {\n        return vec3(bsign * ico_b, 0.0, asign * ico_a);\n    } else { // i == 2\n        return vec3(asign * ico_a, bsign * ico_b, 0.0);\n    }\n}\n\nstruct TriangleHit {\n\tfloat t;\n    vec3 bary;\n    vec3 normal;\n};\n    \nconst TriangleHit noHit = TriangleHit(1000.0, vec3(0.0), vec3(0.0));\n\n// Möller–Trumbore Ray-triangle intersection algorithm\nTriangleHit rayTriHit(vec3 origin, vec3 dir, uvec3 indices) {\n\tvec3 v1 = icoVec(indices.x);\n    vec3 v2 = icoVec(indices.y);\n    vec3 v3 = icoVec(indices.z);\n    \n    vec3 d12 = v2 - v1;\n    vec3 d13 = v3 - v1;\n    \n    vec3 h = cross(dir, d13);\n    float a = dot(d12, h);\n    float f = 1.0 / a;\n    \n    vec3 s = origin - v1;\n    float u = dot(s, h) * f;\n    vec3 q = cross(s, d12);\n    float v = dot(dir, q) * f;\n    float w = 1.0 - u - v;\n    float t = dot(d13, q) * f;\n    \n    if (t >= 0.0001 && u >= 0.0 && u < 1.0 && v >= 0.0 && w > 0.0) {\n    \tTriangleHit hit;\n        hit.t = t;\n        hit.bary = vec3(u, v, w);\n        hit.normal = normalize(cross(d12, d13));\n        return hit;\n    }\n\n    return noHit;\n}\n\n// Ray - icosahedron intersection, assuming the origin is outside\nTriangleHit rayIcoOuterHit(vec3 origin, vec3 dir) {\n    for (int i = 0; i < ICO_FACES; i++) {\n    \tTriangleHit hit = rayTriHit(origin, dir, icoIndices[i]);\n        if (hit.t <= 10.0 && dot(dir, hit.normal) < 0.0) {\n        \treturn hit;\n        }\n    }\n    return noHit;\n}\n\n// Ray - icosahedron intersection, assuming the origin is inside\nTriangleHit rayIcoInnerHit(vec3 origin, vec3 dir) {\n    for (int i = 0; i < ICO_FACES; i++) {\n    \tTriangleHit hit = rayTriHit(origin, dir, icoIndices[i]);\n        if (hit.t <= 10.0) return hit;\n    }\n    return noHit;\n}\n\n// Shading of walls, returns reflectivity in alpha\nvec4 wallColor(vec3 dir, TriangleHit hit) {\n    float d = min(min(hit.bary.x, hit.bary.y), hit.bary.z);\n    \n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(hit.bary.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n    \n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(hit.normal, vec3(0.8, 0.5, 0.0)), 0.0);\n    \n    if (dot(dir, hit.normal) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max(max(hit.bary.x, hit.bary.y), hit.bary.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n        \n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n        \n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n\treturn vec4(1.0);\n}\n\n// Background cubemap\nvec3 background(vec3 dir) {\n\tvec3 col = texture(iChannel0, dir).rgb;\n    col = pow(col, vec3(2.2));\n    \n    // de-tonemap\n    float origLuma = dot(col, vec3(0.2126, 0.7152, 0.0722)) * 0.7;\n    return 2.5 * col / (1.0 - origLuma);\n}\n\nvec3 drawRay(vec3 origin, vec3 dir) {\n    vec3 color = vec3(0.0);\n    \n    // First test ray intersection with the outer shell\n    TriangleHit hit = rayIcoOuterHit(origin, dir);\n    if (hit.t > 10.0) {\n    \treturn background(dir);\n    }\n    \n    // Render reflections\n    vec3 reflDir = reflect(dir, hit.normal);\n    vec3 bgColor = pow(background(reflDir), vec3(1.0));\n    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(dir, -hit.normal), 0.0), 5.0);\n    color += bgColor * fresnel;\n    \n    // Check if we're close enough to the edge of the triangle to render a wall\n    float d = min(min(hit.bary.x, hit.bary.y), hit.bary.z);\n    if (d < WALL_THICKNESS) {\n        vec4 wc = wallColor(dir, hit);\n    \treturn color * wc.a + wc.rgb;\n    }\n    \n    // Move origin inside the icosahedron and check inner intersections\n    origin = origin + hit.t * dir;\n    hit = rayIcoInnerHit(origin, dir);\n    vec3 transmittance = vec3(1.0);\n    \n    // Bounce rays inside the icosahedron until a wall is hit or we run out of iterations\n    for (int i = 0; i < REFL_COUNT; i++) {\n    \tfloat d = min(min(hit.bary.x, hit.bary.y), hit.bary.z);\n        if (d < WALL_THICKNESS) {\n        \treturn color + transmittance * wallColor(dir, hit).rgb;\n        }\n        \n        origin = origin + hit.t * dir;\n        dir = reflect(dir, hit.normal);\n        origin += dir * 0.001;\n        transmittance *= vec3(0.50, 0.47, 0.38); // Every reflection loses some light\n        \n        hit = rayIcoInnerHit(origin, dir);\n    }\n    \n    return color;\n}\n\n// Returns a 3x3 rotation matrix from a defined forward vector and an up vector\nmat3x3 lookAt(vec3 forwardVec, vec3 upVec) {\n\tvec3 Z = normalize(forwardVec);\n    vec3 X = normalize(cross(forwardVec, upVec));\n    vec3 Y = normalize(cross(X, forwardVec));\n\n    return mat3x3(X, Y, Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n    // Camera movement and rotation. It always looks at the origin.\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n\n    float cameraRadius = 1.4;\n    vec3 cameraPos = cameraRadius * vec3(\n        cos(movement.x)*cos(movement.y),\n        sin(movement.y),\n        sin(movement.x)*cos(movement.y)\n    );\n    \n    vec3 forwardVec = normalize(-cameraPos);\n    mat3x3 rotMat = lookAt(forwardVec, vec3(0, 1, 0));\n    \n    vec3 screenRay = normalize(vec3(uv, 1.0));\n    vec3 cameraRay = normalize(rotMat * screenRay);\n    \n    vec3 color = drawRay(cameraPos, cameraRay);\n\n    // Tonemaping and gamma correction\n    color = color / (color * 0.5 + 0.5);\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}