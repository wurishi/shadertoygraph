{"ver":"0.1","info":{"id":"ttsSzX","date":"1563828383","viewed":1297,"name":"Triangulated Heightfield Trick 3","username":"fizzer","description":"Following on from my [url=https://www.shadertoy.com/view/tlXSzB]previous[/url] development in procedural triangle meshes and prompted by Shane's comment regarding irregular perturbed triangles, I decided to tackle deformation in the X and Z axes too.","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","heightfield","polygonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Following on from my previous development in procedural triangle meshes and\n// prompted by Shane's comment regarding irregular perturbed triangles, I decided to\n// tackle deformation in the X and Z axes too.\n//\n// The traversal still takes only one 'heightfield' sample per step, but now it\n// needs to keep track of both UV coordinates and worldspace coordinates of the\n// triangle sequence. The algorithmic logic is still pretty simple though.\n//\n// This was also a nice exercise in maintaining numerical stability!\n//\n//\n// The shaders of this series:\n//\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\n//\n\n// Constants\nconst float pi = 3.14159265358979323;\nconst float th = pi * 2. / 3.;\n\n// Equilateral triangle edge length\nconst float edgeLength = 2. / tan(th);\n\n// Transformations for deforming the equilateral triangle grid into\n// a square grid with diagonal lines\nconst float th2 = -pi * .25;\nconst float e = edgeLength * 1.5;\nconst mat2 rm = mat2(cos(th2), sin(th2), -sin(th2), cos(th2));\nconst mat2 m = rm * mat2(1. / 2., 0., 0., e / 2.) * sqrt(2.);\nconst mat2 mt = (1. / sqrt(2.)) * mat2(2., 0., 0., 2. / e) * transpose(rm);\n\n// Normals of the 3 line directions in the equilateral triangle grid.\n// This is used only in UV space.\nconst vec2 ns[3] = vec2[3](vec2(1, 0), vec2(cos(th), sin(th)), vec2(cos(th * 2.), sin(th * 2.)));\n\nconst float maxHeight = 9.6;\n\n// Heightfield\nfloat sampleHeightfield(vec2 p)\n{\n    float h = \ttextureLod(iChannel0, p / 5. + p.y, 4.).b *\n    \t\t\ttextureLod(iChannel1, p / 60., 2.).g * 1.6;\n    \n    return clamp(h, 0., 1. - 1e-4) * maxHeight;\n}\n\n// Vertex deformation\nvec3 mapVertex(vec2 uv)\n{\n    vec3 v = vec3(uv.x, sampleHeightfield(uv), uv.y);\n    v.x += cos(v.x / 2. + iTime) * .4;\n    v.z += cos(v.z / 2. + iTime) * .4;\n    v.xz += cos(v.z * 2. + iTime) * .4;\n    v.x += cos(v.z / 3. + iTime) * .2;\n    return v;\n}\n\nbool pointIsInTriangle(vec2 p, vec2 ta, vec2 tb, vec2 tc)\n{\n    float alpha = area(ta, tb, p);\n    float beta = area(tb, tc, p);\n    float gamma = area(tc, ta, p);\n\n    float area = alpha + beta + gamma;\n\n    if(area < 0.)\n        return false;\n\n    return alpha > 0. && beta > 0. && gamma > 0.;\n}\n\n// The raytracing function.\nfloat trace(vec3 ro, vec3 rd, out vec3 triNorm, out vec3 bary)\n{\n    vec3 oro = ro;\n    \n    float mint = (maxHeight * step(rd.y, 0.) - ro.y) / rd.y;\n\n    // Move ray start to bounding slab of heightfield.\n    ro += rd * max(0., mint);\n\n    // Determine the starting triangle by transforming the XZ\n    // plane triangular grid to a square grid with diagonal cuts at each square,\n    // then transforming the closet corners in that square grid back again.\n    \n    // This is done in a (somewhat large) neighbourhood around the query point\n    // so that all the likely candidate deformed triangles can be included.\n    \n    vec2 u = m * ro.xz;\n    \n    vec2 tri0, tri1, tri2;\n    vec2 uv0, uv1, uv2;\n    bool notFound = true;\n\n    for(int y = -2; y <= +2 && notFound; ++y)\n\t    for(int x = -2; x <= +2; ++x)\n        {\n    \t\tvec2 cu = floor(u) + vec2(x, y);\n            \n            uv0 = mt * cu;\n            tri0 = mapVertex(uv0).xz;\n\n            uv1 = mt * (cu + vec2(1, 1));\n            uv2 = mt * (cu + vec2(1, 0));\n            \n            tri1 = mapVertex(uv1).xz;\n            tri2 = mapVertex(uv2).xz;\n\n            if(pointIsInTriangle(ro.xz, tri0, tri1, tri2))\n            {\n                notFound = false;\n                break;\n            }\n            \n            uv1 = mt * (cu + vec2(0, 1));\n            uv2 = mt * (cu + vec2(1, 1));\n            \n            tri1 = mapVertex(uv1).xz;\n            tri2 = mapVertex(uv2).xz;\n\n            if(pointIsInTriangle(ro.xz, tri0, tri1, tri2))\n            {\n                notFound = false;\n                break;\n            }\n\t\t}\n\n    vec3 triangle[3];\n    vec2 triangleUV[3];\n\n    // Sort the triangle corners so that the corner at index N is opposite\n    // to the triangle edge coincident to grid line normal at index N.\n    for(int j = 0; j < 3; ++j)\n    {\n        float d0 = abs(dot(uv1 - uv0, ns[j]));\n        float d1 = abs(dot(uv2 - uv1, ns[j]));\n        float d2 = abs(dot(uv0 - uv2, ns[j]));\n\n        triangleUV[j] = uv1;\n\n        if(d0 < d1)\n        {\n            if(d0 < d2)\n        \t\ttriangleUV[j] = uv2;\n        }\n        else if(d1 < d2)\n        \ttriangleUV[j] = uv0;\n        \n        triangle[j] = mapVertex(triangleUV[j]);\n    }\n\n    float t0 = 0., t1, t = -1.;\n        \n    float maxt = (maxHeight * step(0., rd.y) - ro.y) / rd.y;\n    \n    triNorm = vec3(0);\n    \n    // The ray stepping loop\n    // \"min(iFrame, 0)\" is used here to prevent complete unrolling of the loop (which\n    // causes the compiler to take forever on OpenGL).\n    for(int i = min(iFrame, 0); i < 200; ++i)\n    {       \n        // Determine which triangle edge has the next closest intersection, and get the index\n        // of the triangle corner which is opposite to the edge coincident with that line.\n\n        // Note that the edge index (idx) calculated in the previous step\n        // can be used to skip one of the intersection tests, but I haven't done that yet.\n        \n        vec2 ns2[3] = vec2[3](\tvec2(triangle[2].z - triangle[1].z, triangle[1].x - triangle[2].x),\n                            \tvec2(triangle[0].z - triangle[2].z, triangle[2].x - triangle[0].x),\n                            \tvec2(triangle[1].z - triangle[0].z, triangle[0].x - triangle[1].x));\n        vec3 is;\n                \n        // Edge intersection distances\n        is.x = dot(triangle[2].xz - ro.xz, ns2[0]) / dot(rd.xz, ns2[0]);\n        is.y = dot(triangle[0].xz - ro.xz, ns2[1]) / dot(rd.xz, ns2[1]);\n        is.z = dot(triangle[1].xz - ro.xz, ns2[2]) / dot(rd.xz, ns2[2]);\n        \n        if(dot(rd.xz, ns2[0]) < 0.)\n            is.x = 1e9;\n        \n        if(dot(rd.xz, ns2[1]) < 0.)\n            is.y = 1e9;\n        \n        if(dot(rd.xz, ns2[2]) < 0.)\n            is.z = 1e9;\n        \n        int idx = 2;\n        t1 = is.z;\n\n        if(is.x < is.y)\n        {\n            if(is.x < is.z)\n            {\n                idx = 0;\n                t1 = is.x;\n            }\n        }\n        else if(is.y < is.z)\n        {\n        \tidx = 1;\n            t1 = is.y;\n        }\n        \n        // Intersect ray with triangle. Actually this is just a ray-versus-plane\n        // intersection, because the intersection point is already bounded by t0 and t1.\n        triNorm = cross(triangle[2] - triangle[0], triangle[1] - triangle[0]);\n        t = dot(triangle[0] - ro, triNorm) / dot(rd, triNorm);\n\n        if(t > t0 && t < t1)\n            break;\n        \n\t\tif(t1 > maxt)\n        \treturn 1e5;\n        \n        int idx1 = (idx + 1) % 3, idx2 = (idx + 2) % 3;\n        \n        // Mirror the UV triangle aross this grid line (which is coincident with\n        // the edge opposite the triangle corner being moved here). This reverses\n        // the winding.\n        triangleUV[idx] -= 2. * ns[idx] * sign(dot(triangleUV[idx] - triangleUV[idx1], ns[idx]));\n        \n        // Take a single sample of the mesh using the newly-calculated UV corner.\n        triangle[idx] = mapVertex(triangleUV[idx]);\n        \n        // Swap the other two corners, to maintain correspondence between triangle\n        // corners and opposite edge lines. This also has the effect of reversing the winding\n        // a second time, so all of the constructed triangles in fact have the same winding order.\n        {\n            vec3 temp = triangle[idx1];\n            triangle[idx1] = triangle[idx2];\n            triangle[idx2] = temp;\n        }\n\n        // Also swap the UV corners to maintain consistency.\n        {\n            vec2 temp = triangleUV[idx1];\n            triangleUV[idx1] = triangleUV[idx2];\n            triangleUV[idx2] = temp;\n        }\n\n        t0 = t1;\n    }\n    \n    // Return the final intersection information.\n    \n    triNorm = normalize(triNorm);\n\n    vec3 rp = ro + rd * t;\n    \n    // Get the barycentric coordinates.\n    \n    float alpha = area(triangle[0], triangle[1], rp);\n    float beta = area(triangle[1], triangle[2], rp);\n    float gamma = area(triangle[2], triangle[0], rp);\n\n    float area = alpha + beta + gamma;\n\n    bary = vec3(alpha, beta, gamma) / area;\n\n    return distance(oro, rp);\n}\n\n// Ray direction function\nvec3 rfunc(vec2 uv)\n{\n    vec3 r = normalize(vec3(uv.xy, -1.4));\n    mat3 m = rotX(-.75);\n    return m * r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;    \n    uv.x *= iResolution.x / iResolution.y;\n\n    // Setup primary ray.\n    vec3 o = vec3(cos(iTime / 4.) * 4.*0., 10., -iTime), r = rfunc(uv);\n    \n    vec3 triNorm, bary;\n    float t = trace(o, r, triNorm, bary);\n    \n    vec3 n = triNorm;\n\n    vec3 rp = o + r * t;\n    vec3 ld = normalize(vec3(10, 6, 3));\n    \n    // Directional light\n\tcol = vec3(max(0., dot(triNorm, ld))) * .8;\n                \n    // Shadow\n    float st = trace(rp + ld * 1e-2, ld, triNorm, triNorm);\n    if(st > 1e-2 && st < 1e3)\n\t\tcol *= .1;\n    \n    // Ambient light\n    col += max(0., n.y) * vec3(.2);\n    \n    col *= sin(-(rp.y - 58.5) * vec3(1.2,1.2,1.5)/3.)*.47+.5;\n    col *= 1.5;\n    \n    float w = t / 800. + pow(max(0., 1. - dot(-r, n)), 4.) * .2;\n    col *= mix(2., 1., smoothstep(.02 - w, .02 + w, min(bary.x, min(bary.y, bary.z))));\n\n    col += textureLod(iChannel2, reflect(r, n), 3.5).rgb * .5 * max(0., n.y) *\n        \tclamp(1. - dot(-r, n), 0., 1.);\n    \n    // Fog\n    col = mix(vec3(.5, .5, 1.), col, exp2(-t / 300.));\n    \n    // Clamp and gamma-correct\n    fragColor = vec4(pow(clamp(col, 0., 1.), vec3(1. / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nfloat area(vec3 a,vec3 b,vec3 c)\n{\n   b-=a;\n   c-=a;\n   return length(cross(b,c))/2.;\n}\n\nfloat area(vec2 a,vec2 b,vec2 c)\n{\n   b-=a;\n   c-=a;\n   return (b.x*c.y-b.y*c.x)/2.;\n}\n\n","name":"Common","description":"","type":"common"}]}