{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define pi 3.14159\n\nbool between_0_1(float x)\n{\n    if (x > 0. && x < 1.)\n        return true;\n    else\n        return false;\n}\n        \n\n// Test if r lies inside the box (x,y,z) \\in [0,1]\nbool in_box(vec3 r)\n{\n    if ((between_0_1(r.x) && between_0_1(r.y)) && between_0_1(r.z) )\n        return true;\n    else\n        return false;\n}\n\nvec3 screen_to_world(vec2 uv, mat4 O, mat4 d)\n{\n    mat4 c_uv = cvec(vec3(uv, 0.));\n    \n    mat4 O_T = transpose(O);\n    \n    return evec(O*c_uv*O_T + d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from -0.5 to 0.5 on y axis)\n    vec2 uv = 3.*(fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec3 ax_1 = vec3(0., 0., 1.);\n    vec3 ax_2 = vec3(-1. ,1., 0.)/sqrt(2.);\n    mat4 O = rotor(ax_2, atan(sqrt(2.)))*rotor(ax_1, 3.*pi/4.);\n    \n    float a = cos(0.1*iTime);\n    a *= a;\n    vec3 d = vec3(a, a, a);\n    \n    // Pixel space to world space\n    vec3 r = screen_to_world(uv, O, cvec(d));\n    \n    vec3 bg_col = vec3(0.2);\n    \n    vec3 col;\n    \n    if (in_box(r))\n        col = vec3(0.8);\n    else\n        col = bg_col; \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// Clifford algebra definitions\nconst mat4 I = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n\nconst mat4 g1 = mat4(\n    0, 0, 0, 1,\n    0, 0, 1, 0,\n    0, 1, 0, 0,\n    1, 0, 0, 0);\nconst mat4 g2 = mat4(\n    0, 0, 1, 0,\n    0, 0, 0, -1,\n    1, 0, 0, 0,\n    0, -1, 0, 0);\nconst mat4 g3 = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, -1, 0,\n    0, 0, 0, -1);\nconst mat4 g23 = g2*g3;\nconst mat4 g31 = g3*g1;\nconst mat4 g12 = g1*g2;\nconst mat4 g123 = g1*g2*g3;\n\n// Trace of 4x4 matrix\nfloat tr(mat4 A)\n{\n    return A[0][0] + A[1][1] + A[2][2] + A[3][3];\n}\n\n// Euclidean vector to Clifford vector\nmat4 cvec(vec3 u)\n{\n    return u.x * g1 + u.y * g2 + u.z * g3;\n}\n\n// Clifford vector to Euclidean vector\nvec3 evec(mat4 A)\n{\n    return 0.25*vec3(tr(A*g1), tr(A*g2), tr(A*g3));\n}\n\n// Normalize a Clifford vector\nmat4 cnormalize(mat4 a)\n{\n    return a / sqrt(tr(a*a)/4.);\n}\n\n// Clifford dot product\nfloat cdot(mat4 a, mat4 b)\n{\n\treturn tr(a*b + b*a) / 8.;\n}\n\n// Clifford cross product\nmat4 ccross(mat4 a, mat4 b)\n{\n    return -0.5*g123*(a*b - b*a);\n}\n\n// Rotation vector: RxR^T\nmat4 rotor(vec3 n, float a)\n{\n    float c = cos(a/2.);\n    float s = sin(a/2.);\n    return c * I - s * (n.x * g23 + n.y * g31 + n.z * g12);\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"3lBSzh","date":"1734785924","viewed":26,"name":"A Cube's Sections","username":"Trips","description":"Cross secions of a cube along its main diagonal","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""}}