{"ver":"0.1","info":{"id":"MclfzN","date":"1723792524","viewed":36,"name":"Test_task_001","username":"opezdl","description":"1) simple HeightField AO\n2) simple HeightField Shadows with penumbra hack\n3) PBR\n4) naive IBL","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["shadow","ao","ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CubeMaxMip 8.0\n#define Light_Color vec3(255, 210, 100) / 255.\n#define albedo vec3(130, 135, 155) / 255.\n#define roughness float(0.05)\n#define metalness float(0.05) \n#define pbr_F0 vec3(0.04) \n#define iIBL_samples 8\n#define IBL_samples\t(float(iIBL_samples))\n#define Light_Intencity 0.05\n#define IBL_Intencity 0.05\n#define Emissive_Intencity 0.05\n\n\nvec3 brdf_diffuse(float NL, float NV, float NH, float VL, float VH, vec3 diffuse_color, float alpha)\n{\n    float facing = 0.5 + 0.5 * VL;\n    float energyBias = mix(0.0, 0.5, alpha);\n    float F90 = energyBias + 2.0 * VH * VH * alpha;    \n    float F_NL = 1.0 - (0.04 + (F90 - 0.04) * exp2((-5.55473 * NL - 6.98316) * NL));\n    float F_NV = 1.0 - (0.04 + (F90 - 0.04) * exp2((-5.55473 * NV - 6.98316) * NV));  \n\n    float surf_rough = NH <= 0.0 ? 0.0 : facing * (0.9 - 0.4 * facing) * ((0.5 + NH) / NH);\n    float surf_smooth = (F_NL * F_NV) * 1.008;\n    float singlescatter = mix(surf_smooth, surf_rough, alpha) * inv_Pi;\n    float multiscatter = 0.1159 * alpha;\n    return clamp(diffuse_color * (singlescatter + diffuse_color * multiscatter), 0.0, 1.0);\n}\n\nvec3 brdf_specular(float NL, float NV, float NH, float LH, vec3 specular_color, float alpha)\n{\n    float NDF = NDF_GGX(NH, alpha);\n\tfloat G2 = G2_Smith(NL, NV, alpha);\n\tvec3 F = F_SphericalGaussian(LH, specular_color);\n    vec3 numerator = (NDF * G2) * F;\n    float denominator = max(4.0 * NL * NV, EPS);\n    return numerator / denominator;\n}\n\nvec3 compute_PBR(vec3 N, vec3 V, vec3 L, vec3 diffuse_color, vec3 specular_color, float alpha, vec3 LIGHT_COLOR)\n{\n    float VL = dot(V, L);  \n    float NL = max(dot(N, L), 0.0);\n    float NV = max(dot(N, V), 0.0);\n    float rcpLen_LV = inversesqrt(2.0 * VL + 2.0);\n    float NH = rcpLen_LV * (NL + NV);\n    float LH = rcpLen_LV * VL + rcpLen_LV;\n    vec3 diffuse_light = brdf_diffuse(NL, NV, NH, VL, LH, diffuse_color, alpha);\n    vec3 specular_light = brdf_specular(NL, NV, NH, LH, specular_color, alpha);    \n    vec3 light = (diffuse_light + specular_light) * LIGHT_COLOR * NL;\n    return light;\n}\n\n\nvec3 ibl_diffuse(vec3 V_tangent, mat3 TBN, float dither, vec3 diffuse_color, float alpha)\n{\n    vec3 accumulated_samples = vec3(0.0); \n\n    for(int i = 0; i < iIBL_samples; i++)\n    {\n        vec2 sample_points = distribute_bayer(i, iIBL_samples, dither);\n        vec3 L_tangent = Sample_CosineHemisphere(sample_points);\n        vec3 H_tangent = normalize(V_tangent + L_tangent);\n        float NL = clamp(L_tangent.z, 0.0, 1.0);\n        float NV = clamp(V_tangent.z, 0.0, 1.0);\n        float NH = H_tangent.z;\n        float LH = clamp(dot(L_tangent, H_tangent), 0.0, 1.0);\n        float VL = dot(V_tangent, L_tangent);\n        vec3 brdf = brdf_diffuse(NL, NV, NH, VL, LH, diffuse_color, alpha) * Pi;\n        L_tangent.xyz = TBN * L_tangent.xyz;\n        L_tangent = vec3(L_tangent.x, L_tangent.z, L_tangent.y);\n        if(NV > 0.0 && NL > 0.0)\n            accumulated_samples += reversetonemap(GammaToLinear(textureLod(iChannel3, L_tangent.xyz, 1.0).xyz)) * brdf;     \n    }\n    return accumulated_samples / IBL_samples;\n}\n\nvec3 ibl_specular(vec3 V_tangent, mat3 TBN, float dither, vec3 specular_color, float alpha)\n{\n    vec3 accumulated_samples = vec3(0.0);\n    \n    for(int i = 0; i < iIBL_samples; i++)\n    {\n        vec2 sample_points = distribute_bayer(i, iIBL_samples, dither);\n        vec3 H_tangent = Sample_VNDF(V_tangent, sample_points, alpha);\n        vec3 L_tangent = -reflect(V_tangent, H_tangent);\n        float NL = clamp(L_tangent.z, 0.0, 1.0);\n        float NV = clamp(V_tangent.z, 0.0, 1.0);\n        float NH = H_tangent.z;    \n        float VH = dot(V_tangent, H_tangent);\n        vec3 F = F_SphericalGaussian(VH, specular_color);\n        float G2 = G2_Smith(NL, NV, alpha);\n        float G1 = G1_Smith(NV, alpha); \n        vec3 estimator = (F * G2) / G1;\n        L_tangent.xyz = TBN * L_tangent.xyz;\n        L_tangent = vec3(L_tangent.x, L_tangent.z, L_tangent.y);\n        if(NV > 0.0 && NL > 0.0)\n            accumulated_samples +=  reversetonemap( GammaToLinear(textureLod(iChannel1, L_tangent.xyz, 1.0).rgb)) * estimator;\n    }\n    return accumulated_samples / IBL_samples;\n}\n\nvec3 compute_IBL(vec3 N, vec3 V, vec3 diffuse_color, vec3 specular_color, float alpha)\n{\n    float dither = bayer32(gl_FragCoord.xy);\n    mat3 TBN = mat3(vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));//get_tbn_basis(N); \n    vec3 V_tangent =  V * TBN;\n    vec3 diffuse_light = ibl_diffuse(V_tangent, TBN, dither, diffuse_color, alpha);\n    vec3 specular_light = ibl_specular(V_tangent, TBN, dither, specular_color, alpha);\n    return diffuse_light + specular_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 Mouse = iMouse.xy / iResolution.xy;\n\n    vec4 normalHeight = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    normalHeight.w /= Boost;\n    vec3 OS =  texture(iChannel2, fragCoord/iChannelResolution[2].xy).xyz;\n    //float noise = OS.z; \n         OS += texture(iChannel2, (fragCoord + vec2(1.,0.))/iChannelResolution[2].xy).xyz;\n         OS += texture(iChannel2, (fragCoord + vec2(0.,1.))/iChannelResolution[2].xy).xyz;\n         OS += texture(iChannel2, (fragCoord + vec2(-1.,0.))/iChannelResolution[2].xy).xyz;\n         OS += texture(iChannel2, (fragCoord + vec2(0.,-1.))/iChannelResolution[2].xy).xyz;        \n         OS /= 5.0;\n    float occlusion = clamp(OS.x, 0.0, 1.0);\n    float shadows = clamp(OS.y, 0.0, 1.0);\n    float emissive = GammaToLinear(0.5 * OS.z + 0.5);\n    shadows = GammaToLinear(shadows);\n    occlusion = GammaToLinear(occlusion);  \n    vec3 normal = normalize(2.0 * normalHeight.xyz - 1.0);\n    \n    vec3 lightPos = vec3(2.0 * Mouse.xy - 1.0, 1.1); // 2.0 * Mouse.xy - 1.0\n    vec3 pixelPos = vec3(2.0 * uv - 1.0, normalHeight.w); // 2.0 * uv - 1.0\n    vec2 tpos = 2.0 * uv.xy - 1.0;\n    vec3 lightDir = normalize(lightPos - pixelPos);\n    vec3 ViewDir = normalize(vec3(0,0,10.0)); // tpos, 10.0\n    float lightDistSqr = dot(lightPos - pixelPos,lightPos - pixelPos) / (max(Boost, 40.0));\n   \n    vec3 specular_color = mix(pbr_F0, albedo, metalness);\n    vec3 diffuse_color = (1.0 - metalness) * albedo;\n    float alpha = roughness * roughness;\n\n    vec3 direct_light = shadows * compute_PBR(normal, ViewDir, lightDir, diffuse_color, specular_color, alpha, GammaToLinear(Light_Color)) / lightDistSqr;\n    vec3 indirect_light = occlusion * compute_IBL(normal, ViewDir, diffuse_color, specular_color, alpha);\n\n    fragColor.rgb = Light_Intencity * direct_light + IBL_Intencity * indirect_light + Emissive_Intencity * emissive * albedo;\n    \n    //fragColor.rgb = 1.0 - exp(-fragColor.rgb * 0.15);\n    fragColor.rgb = ACESFilm(fragColor.rgb);\n    fragColor.rgb = smoothstep(vec3(0.05), vec3(0.95), fragColor.rgb);\n    fragColor.rgb = linearToGamma(fragColor.rgb);\n    //float noise = IGN(fragCoord.xy);\n    //fragColor.rgb = vec3(occlusion, shadows, 0.0);\n    \n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Pi float(3.14159265359)\n#define PI2 2.0 * Pi\n#define inv_Pi float(0.318309)\n#define EPS float(1e-5)\n#define Boost 20.\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\nfloat powerToMipBias(float power)\n{\n    return -(log2(power)*0.445743);\n}\n\nfloat GammaToLinear(float v)     \n{                               \n    return pow(v,  2.2);   \n}\n\nvec2 GammaToLinear(vec2 v)     \n{                               \n    return vec2(GammaToLinear(v.x),GammaToLinear(v.y));   \n}\n\nvec3 GammaToLinear(vec3 v)     \n{                               \n    return vec3(GammaToLinear(v.x),GammaToLinear(v.y),GammaToLinear(v.z));   \n}\nfloat linearToGamma(float v)     \n{                               \n    return pow(v, (1.0 / 2.2));   \n}\n\nvec2 linearToGamma(vec2 v)     \n{                               \n    return vec2(linearToGamma(v.x),linearToGamma(v.y));   \n}\n\nvec3 linearToGamma(vec3 v)     \n{                               \n    return vec3(linearToGamma(v.x),linearToGamma(v.y),linearToGamma(v.z));   \n}\n\nvec3 reversetonemap(vec3 v)\n{\n    return v / (1.09 - 0.990 * v);\n}\n\nvec3 tonemap(vec3 v)\n{\n    return v / (1.0 + v);\n}\n\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 i_ACESFilm( vec3 x )\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x / (a / x - b)) * max(x / (c / x - d) - e, EPS);\n}\n\nfloat IGN(vec2 p)\n{\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract( magic.z * fract(dot(p,magic.xy)) );\n}\nvec2 getDist(float i, float maxsamples, float noise)\n{\n    vec2 res = vec2(0.0);\n    float D = (noise + i / maxsamples);\n    float t = D * maxsamples * 1228.8; //magic\n    vec2 temp = vec2(0.0);\n    temp.x = D;\n    temp.y = 1.0 / Pi * (t - floor(t/Pi)*Pi);\n    float alpha = temp.x * 2.0 * Pi;\n    temp.x = sqrt(temp.y);\n    res = vec2(temp.x * cos(alpha), temp.x * sin(alpha));\n    return res;\n}\n\nmat3 get_tbn_basis(vec3 N)\n{\n    vec3 T = normalize(cross(N, normalize(vec3(0.01, 0.01, 1.0))));\n    vec3 B = cross(N, T);\n    mat3 tangent_to_world = mat3(T, B, N);  \n    return tangent_to_world;\n}\n\nfloat NDF_GGX(float NH, float alpha)\n{\n    float denominator = (NH * alpha - NH) * NH + 1.0;\n    return alpha / (Pi * denominator * denominator);\n}\n\nfloat Lambda_Smith(float dotproduct, float alpha)\n{\n\tfloat dotproduct_sqr = dotproduct * dotproduct;\n\tfloat lambda = (-1.0 + sqrt(1.0 + alpha * (1.0 - dotproduct_sqr) / dotproduct_sqr)) * 0.5;\n    return lambda;\n}\n\nfloat G1_Smith(float dotproduct, float alpha)\n{\n\treturn 1.0 / (1.0 + Lambda_Smith(dotproduct, alpha));\n}\n\nfloat G2_Smith(float NL, float NV, float alpha)\n{\n\tfloat lambdaV = Lambda_Smith(NV, alpha);\n\tfloat lambdaL = Lambda_Smith(NL, alpha);\n\treturn 1.0 / (1.0 + lambdaV + lambdaL);\n}\n\nvec3 F_SphericalGaussian(float dotproduct, vec3 F0)\n{\n    return F0 + (1.0 - F0) * exp2((-5.55473 * dotproduct - 6.98316) * dotproduct);\n}\n\nvec3 Sample_VNDF(vec3 Ve, vec2 Xi, float alpha)\n{\n\tvec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1,0,0);\n\tvec3 T2 = cross(Vh, T1);\n\tfloat r = sqrt(Xi.y);\t\n\tfloat phi = 2.0 * Pi * Xi.x;\t\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1 * t1) + s * t2;\n\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\tvec3 Ne = normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));\t\n\treturn Ne;\n}\n\n//Cosine-weighted hemisphere\nvec3 Sample_CosineHemisphere(vec2 Xi)\n{\n    float SinTheta = sqrt(Xi.y);\n    float Phi = Xi.x * Pi * 2.0;\n    \n    vec3 L = vec3(0.0, 0.0, 0.0);\n    L.x = SinTheta*cos(Phi);\n    L.y = SinTheta*sin(Phi);\n    L.z = sqrt(1.0-Xi.y);\n\n    return normalize(L);\n}\n\n//Analytical bayer matrix (Jodie)\nfloat bayer32(vec2 a){\n    uvec2 b = uvec2(a);\n    uint c = (b.x^b.y)<<1u;\n    return float(\n        ((c&32u|b.y&16u)>>4u)|\n        ((c&16u|b.y&8u)>>1u)|\n        ((c&8u|b.y&4u)<<2u)|\n        ((c&4u|b.y&2u)<<5u)|\n        ((c&2u|b.y&1u)<<8u)\n    ) / 1024.0;\n}\n\n//Bayer sampler (Jodie)\nvec2 distribute_bayer(int index, int max_i, float dither)\n{\n\tdither = (dither + float(index)) / float(max_i);\n\tvec2 Xi = vec2(0.0, 0.0);\n    Xi.x = dither;\n    Xi.y = mod(dither * float(max_i) * 1228.8, Pi) * inv_Pi;\n\treturn clamp(Xi, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float GetDepth(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iChannelResolution[0].xy).r * Boost;\n}\n\nvec3 GetNormal(vec2 fragCoord)\n{\n    float ang1 = (1.0 / 12.0) * 6.2831853;\n    float ang2 = (5.0 / 12.0) * 6.2831853;\n    float ang3 = (9.0 / 12.0) * 6.2831853;\n    \n    vec3 v1 = vec3(fragCoord + vec2(sin(ang1), cos(ang1)) * 0.5, 0);\n    vec3 v2 = vec3(fragCoord + vec2(sin(ang2), cos(ang2)) * 0.5, 0);\n    vec3 v3 = vec3(fragCoord + vec2(sin(ang3), cos(ang3)) * 0.5, 0);\n    \n    v1.z = GetDepth(v1.xy);\n    v2.z = GetDepth(v2.xy);\n    v3.z = GetDepth(v3.xy);\n    \n    vec3 norm = normalize(cross(v1 - v2, v3 - v2));\n    \n    return norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(iFrame>80){ discard; }\n    fragColor.rgb = 0.5 * GetNormal(fragCoord) + 0.5;\n    fragColor.a = GetDepth(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define iAO_samples 4\n#define AO_samples\t(float(iAO_samples))\n#define AO_maxrange 16.0 // in pixels\n#define AO_fade_distance 0.5\n#define AO_intencity 1.2\n#define AO_power 0.5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //if(iFrame>80){ discard; }\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec3 col = vec3(0.0);\n    vec4 texData = texture(iChannel0, uv);\n    vec3 normal = texData.xyz * 2.0 - 1.0;\n    float height = texData.w / Boost;\n    float occlusion = 0.0;\n    float radius = AO_maxrange / min(iResolution.x, iResolution.y);\n    //vec2 noiseUV = mod(fragCoord.xy, iChannelResolution[1].xy) / iChannelResolution[1].xy;\n    //float noiseValue = texture(iChannel1, noiseUV).r / 1.;\n    float noiseValue = bayer32(fragCoord.xy);\n    \n    for (int i = 0; i < iAO_samples; i++) \n    {\n        float angle = PI2 * (float(i) / AO_samples + noiseValue);\n        vec2 offset = (radius + 1.0/min(iResolution.x, iResolution.y)) * vec2(cos(angle), sin(angle)) * (float(i) + 1.)/(AO_samples + 1.);\n        float sampleHeight = texture(iChannel0, uv + offset).w / Boost;\n        float range = sampleHeight - height;\n        float weight = 1.0 / (1.0 + AO_fade_distance * length(vec3(offset, range)));\n        occlusion += max(0.0, AO_intencity * dot(normal,  normalize(vec3(offset, range))) * weight);\n    }\n    //ao /= float(AO_samples);\n    occlusion = 1.0 - clamp(occlusion / AO_samples, 0.0, 0.95);\n    occlusion = pow(occlusion, AO_power);\n    fragColor = vec4(linearToGamma(occlusion),0.0,0.0,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define minSteps 6.\n#define maxSteps 24.\n#define LightSize 0.8\n#define ShadowIntensity 10. \n#define ShadowSoftness 1.0 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    vec3 lightPos = vec3(iMouse.xy / iChannelResolution[0].xy, 1.1);\n    float fragHeight = texture(iChannel0, uv).r;\n    vec3 fragPos = vec3(uv, fragHeight);\n    vec3 lightDir = lightPos - fragPos;\n    float lightDistance = length(lightDir);\n    lightDir = normalize(lightDir);\n    float shadowSum = 0.0;\n    int numSteps = int(mix(minSteps, maxSteps, clamp(lightDistance / 0.5, 0.0, 1.0)));\n    float noiseValue = bayer32(fragCoord.xy);\n    float firstStepOffset = noiseValue * (1.0 / float(numSteps));\n    \n    for (int i = 0; i < numSteps; i++) {\n        float sstep = float(i)  / float(numSteps) + firstStepOffset;\n        vec3 currentPos = fragPos + lightDir * sstep;\n        float currentHeight = texture(iChannel0, currentPos.xy).r;\n        if (currentHeight - currentPos.z > EPS) \n        {\n            float distanceFactor = pow((float(numSteps - i) / float(numSteps)), ShadowSoftness);\n            float penumbra = smoothstep(0.0, LightSize, lightDistance);\n            shadowSum += distanceFactor * penumbra;\n        }\n    }\n    float shadowFactor = clamp(1.0 - shadowSum / float(numSteps), 0.0, 1.0);\n    shadowFactor = mix(1.0, shadowFactor, ShadowIntensity);\n    shadowFactor = linearToGamma(shadowFactor);\n    float AO = texture(iChannel1, fragCoord.xy/iChannelResolution[1].xy).r;\n    \n    fragColor = vec4(AO,shadowFactor,fragHeight,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}