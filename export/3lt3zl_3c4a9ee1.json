{"ver":"0.1","info":{"id":"3lt3zl","date":"1577266929","viewed":254,"name":"DynamicSpace","username":"VolkodavAD","description":"Test Shader for Space","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixel = 1.0/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*tan(iTime+uv.xyx+vec3(0,2,4));\n    \n    float Deltapower = 2.0; // * abs(sin(iTime*0.1));\n    \n    // обработка маски\n    // цвет текущего пикселя\n    vec2 deltauv = vec2(0.0, 0.0);\n    float MaskCol = \tabs(sin(texture(iChannel0, uv+deltauv).x*4.0 + iTime*0.5)); \n    // цвет выше справа пикселя по каналк х(r)\n    deltauv = pixel;\n    float MaskColNex1 = abs(sin(texture(iChannel0, uv+deltauv).x*4.0 + iTime*0.5));     \n    // цвет выше слева пикселя по каналк х(r)\n    deltauv = vec2(pixel.x, pixel.y*-1.0);    \n    float MaskColNex2 = abs(sin(texture(iChannel0, uv+deltauv).x*4.0 + iTime*0.5));\n    \n    //MaskColNex = abs(sin(texture(iChannel0, (uv + vec2(pixel.r,pixel.x))).x + iTime*0.25)*4.0);\n    vec4 EndDelta = vec4(0.0, 0.0, 0.0, 0.0);\n        \n    //если пиксель светлее чем вверху справа    \n    /*\n    if (MaskColNex1 > MaskCol)\n    {  \tEndDelta = EndDelta + vec4(MaskCol-MaskColNex1, 0.0, 0.0, 0.0); }\n    else\n    { \tEndDelta = EndDelta + vec4(MaskColNex1-MaskCol, 0.0, 0.0, 0.0);}\n    \n    if (MaskColNex2 > MaskCol)\n    {   EndDelta = EndDelta + vec4(0.0, MaskCol-MaskColNex2, 0.0, 0.0);  }\n    else\n    {   EndDelta = EndDelta + vec4(0.0, MaskColNex2-MaskCol, 0.0, 0.0);  }        \n\t*/\n    \n    //Болле оптимально! в таком варианте if не нуженб  сразу вычисляем дельту \n    EndDelta = EndDelta + vec4(MaskCol-MaskColNex1, 0.0, 0.0, 0.0)*Deltapower;\n    EndDelta = EndDelta + vec4(0.0, MaskCol-MaskColNex2, 0.0, 0.0)*Deltapower;\n    \n    // маска для контроля искажений\n    vec4 LightMask = texture(iChannel0, uv);\n    //LightMask = LightMask;\n    \n    // ---------- Эксперименты ---------\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //float Hight = (texture(iChannel1, uv).r-1.0)*2.0;    \n\t//float clampHight = clamp (Hight,1.0,1.0);\n    //fragColor = texture(iChannel0, uv+(sin(Hight+iTime)*0.002));\n    \n    fragColor = vec4(MaskCol,MaskCol,MaskCol,MaskCol);\n    vec4 DisTexture = texture(iChannel0, uv + EndDelta.xy*0.1*LightMask.xy);\n    fragColor = LightMask*LightMask +DisTexture*DisTexture;\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}