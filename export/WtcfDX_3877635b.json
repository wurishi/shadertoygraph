{"ver":"0.1","info":{"id":"WtcfDX","date":"1633610574","viewed":169,"name":"julia sets","username":"shanesimmsart","description":"playing","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec3 slerp(vec3 start, vec3 end, float percent)\n{\n     // Dot product - the cosine of the angle between 2 vectors.\n     float dot = dot(start, end);     \n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec3 RelativeVec = normalize(end - start*dot); // Orthonormal basis\n     // The final result.\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 c = fragCoord/iResolution.xy;\n    c = (c * 2.0) - vec2(1.0);\n    c.y *= iResolution.y / iResolution.x;\n    c *= 2.0;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m = (m * 2.0) - vec2(1.0);\n    m.y *= iResolution.y / iResolution.x;\n    m *= 4.0;\n    \n    vec2 z = c;\n    \n    float speed = 0.008;\n    vec2 d = vec2(cos(iTime*speed), sin(iTime*speed)) * m;\n    \n    int maxIterations = 64;\n    int numIterations = 0;\n    \n    while (numIterations < maxIterations && z.x*z.x + z.y*z.y < 4.0) {\n        numIterations += 1;\n\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + d;\n        // z = vec2(z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y) + d;\n        // z = vec2(z.x*z.x*z.x*z.x - 6.0*z.x*z.x*z.y*z.y + z.y*z.y*z.y*z.y, 4.0*z.x*z.x*z.x*z.y - 4.0*z.x*z.y*z.y*z.y) + d;\n    }\n    \n    vec3 colA = vec3(0.18, 0.09, 0.18);\n    vec3 colB = vec3(1.0, 1.0, 0.09);\n \n    // Time varying pixel color\n    vec3 col = slerp(colA, colB, float(numIterations)/float(maxIterations));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}