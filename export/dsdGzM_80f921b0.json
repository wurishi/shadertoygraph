{"ver":"0.1","info":{"id":"dsdGzM","date":"1678412544","viewed":40,"name":"Ising Model 1","username":"complexbezier","description":"not quite a monte carlo. Function on line 27 is used to reduce the probability of two adjacent cells being chosen for flipping simultaneously, which results in errors.\nrandom function taken from https://www.shadertoy.com/view/Xt23Ry","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simulation","thermodynamics","isingmodel","scientific"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nconst float Beta = 50.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 stepsize = 1.0/iResolution.xy;\n    \n    //If we're just starting, randomize\n    if (iFrame==1) {\n        float f = 0.0;\n        if ((rand(uv*iTime*(iTime+4.0))<0.5)) {\n            f = 1.0;\n        }\n        fragColor=vec4(0.0,0.0,f,1.0);\n        return;\n    }\n    \n    //If close to mouse, fix value\n    if ((length(iMouse.xy - fragCoord.xy)<=40.0) && (iMouse.z>0.5)) {\n        fragColor=texture(iChannel0,uv);\n        fragColor.b = 1.0;\n        return;\n    }\n    //Decide if should select\n    if (rand(uv*iTime*(iTime+4.0))<0.8) {\n        fragColor=texture(iChannel0,uv);\n        return;\n    }\n    \n    float prev = (texture(iChannel0,uv).b - 0.5)*2.0;\n    float energy = 0.0;\n    energy -= (texture(iChannel0,vec2(uv.x+stepsize.x,uv.y)).b - 0.5)*prev*2.0;\n    energy -= (texture(iChannel0,vec2(uv.x-stepsize.x,uv.y)).b - 0.5)*prev*2.0;\n    energy -= (texture(iChannel0,vec2(uv.x,uv.y+stepsize.y)).b - 0.5)*prev*2.0;\n    energy -= (texture(iChannel0,vec2(uv.x,uv.y-stepsize.y)).b - 0.5)*prev*2.0;\n    //Hypothetical flipped energy\n    float flippedEnergy = 0.0 - energy;\n    //If flipped energy would be less, flip\n    if (flippedEnergy < energy)\n        prev *= -1.0;\n    else { //Otherwise flip probabilistically\n        if (rand(uv*(iTime+1.0))<exp(-Beta*(flippedEnergy-energy))) {\n            prev *= -1.0;\n        }\n    }\n    //Renormalize from [-1,1] -> [0,1]\n    prev += 1.0;\n    prev /= 2.0;    \n\n    //Output color decided\n    float norm = 0.0*(energy+4.0)/4.0;\n    fragColor = vec4(norm,0.0,prev,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}