{"ver":"0.1","info":{"id":"ldXfWB","date":"1497844079","viewed":171,"name":"Father's Day!","username":"4onen","description":"A 2D SDF happy father's day for my dad. Now with descriptive comments!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","text"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===DEBUG===\n//#define SHOW_TEXTURE\n\n//===VERSION===\n//#define VERSION_1\n//#define VERSION_2\n#define VERSION_3\n\n//===TEXT===\n//Defines the sampler2D to use for \n// pulling in the letter shapes\n#define LETTER_CHANNEL iChannel0\n\n//Letter positions in x+16*y format\n#define CHAR_A 65\n#define CHAR_a 97\n#define CHAR_SPACE 32\n#define CHAR_APOSTROPHE 180\n#define CHAR_COMMA 12+16*2\n#define CHAR_EXCLAM_PT 33\n\n//Deprecated define\n#define MSG_LINE_1 0\n//Define stating the length of the\n// first line of the message\n#define MSG_LINE_1_LEN 14\n//The character array of the\n// message's first line\nconst int msgLn1[] = int[]\n    (CHAR_A+7//H\n    ,CHAR_a+0//a\n    ,CHAR_a+15//p\n    ,CHAR_a+15//p\n    ,CHAR_a+24//y\n    ,CHAR_SPACE\n    ,CHAR_A+5//F\n    ,CHAR_a+0//a\n    ,CHAR_a+19//t\n    ,CHAR_a+7//h\n    ,CHAR_a+4//e\n    ,CHAR_a+17//r\n    ,CHAR_APOSTROPHE\n    ,CHAR_a+18//s\n    );\n\n//Depreceated define\n#define MSG_LINE_2 1\n//Define stating the length of the\n// second line of the message\n#define MSG_LINE_2_LEN 9\n//The character array of the\n// message's second line\nconst int msgLn2[] = int[]\n    (CHAR_A+3//D\n    ,CHAR_a+0//a\n    ,CHAR_a+24//y\n    ,CHAR_COMMA\n    ,CHAR_SPACE\n    ,CHAR_A+3//D\n    ,CHAR_a+0//a\n    ,CHAR_a+3//d\n    ,CHAR_EXCLAM_PT\n    );\n\n\n//Convert a [0,1]x[0,1] texture \n// coordinate to the position of a\n// specified letter\nvec2 texCoordToCharCoord(vec2 uv, int char){\n    const float scal = 0.0625;//(1/16)\n    uv = clamp(uv,0.0,1.0);\n    uv *= scal;\n    \n    int char_y = 15-char/16;\n    int char_x = char%16;\n    \n    uv += vec2\n        (float(char_x)*scal\n        ,float(char_y)*scal\n        );\n    \n    return uv;\n}\n\n//Convert a [0,1]x[0,1] texture\n// coordinate to the distance map at\n// that point for the given character\nfloat letter(vec2 uv, int char){\n    return -1.0+2.0*texture(LETTER_CHANNEL,texCoordToCharCoord(uv,char)).w;\n}\n\n//Convert the first line of text\n// to a signed distance field on [0,1]\nfloat textBoxLn1(in vec2 r, in float spacing){\n    //Setup an initial unachievably large distance\n    float ret = 9999.0;\n    \n    //Iterate through every letter\n    for(int i=0;i<MSG_LINE_1_LEN;i++){\n        //If it's an apostrophe, take up less space\n        if(msgLn1[i] == CHAR_APOSTROPHE) r += vec2(spacing/4.0,0.0);\n        //Load the letter from the texture, and decide if its distance\n        // field is closer than the previously closest\n        ret = min(ret,letter(r,msgLn1[i]));\n        //If it's an apostrophe, take up less space\n        if(msgLn1[i] == CHAR_APOSTROPHE) r += vec2(spacing/2.0,0.0);\n        //Move to the next letter\n        r -= vec2(spacing,0.0);\n    }\n    \n    //Return the signed distance to the string\n    return ret;\n}\n\n//Convert the second line of text\n// to a signed distance field on [0,1]\nfloat textBoxLn2(in vec2 r, in float spacing){\n    //For inline comments, see above\n    float ret = 9999.0;\n    \n    for(int i=0;i<MSG_LINE_2_LEN;i++){\n        //Special spacing on commas and exclamation marks\n        if(msgLn2[i]==CHAR_EXCLAM_PT||msgLn2[i]==CHAR_COMMA) r += vec2(spacing/4.0,0.0);\n        ret = min(ret,letter(r,msgLn2[i]));\n        r -= vec2(spacing,0.0);\n    }\n    \n    return ret;\n}\n\n//Generate a two-line sdf of text\n// with distances [0,1]\nfloat textBox(in vec2 r){\n    //Fix the center a bit\n    r+=vec2(0.75,0.0);\n    \n    //Write the first line's SDF\n    float ret = textBoxLn1(r+vec2(2.0,0.0),0.4);\n    //Write the second line's SDF\n    ret = min(ret,textBoxLn2(r+vec2(1.3,1.0),0.44));\n    \n    //Return the SDF\n    return ret;\n}\n//==END TEXT==\n\n\n//===Raytrace===\n//Maximum number of iterations before\n// we assume we've hit something\n#define MAX_ITER 24\n//Maximum distance we'll travel before\n// assuming we'll hit nothing\n#define MAX_ITER_DIST 5.0\n\n//Makes a ray for the given pixel pointing\n// in the positive-z direction.\nvec3 makeRay(vec2 r){\n    return normalize(vec3(r,1.0));\n}\n\n//&&V2&&\n//Function returning the signed distance\n// to the nearest surface in 3D space\nfloat map(vec3 p){\n    float push = 2.0-p.z;\n    float text = textBox(p.xy);\n    return (max(push,text));\n}\n\n//Function raymarching from the origin to\n// the nearest intersect, stepping the\n// total distance to the nearest surface\n// each step.\nfloat trace(vec3 r){\n    float t = 0.0;\n    for(int i=0;i<MAX_ITER;i++){\n        t += clamp(map(r*t),0.0,999.0);\n    }\n    return t;\n}\n\n//Function to convert the distance travelled\n// by the raymarching function into something\n// with somewhat visible depth.\n//No color or other fanciness.\nfloat fog(float t){\n    return 1.0 / (1.0 + t * t * t * t * t * 0.005);\n}\n\n//&&V3&&\n//Function to take two vec2 represented objects\n// and merge their distance fields, returning \n// the distance and material of the closer obj.\nvec2 objUnion(vec2 o1, vec2 o2){\n    return o1.x<o2.x ? o1 : o2;\n}\n\n//Function to take two vec2 represented objects\n// and merge their distance fields, returning\n// the distance and material of the FARTHER obj.\nvec2 objIntersect(vec2 o1, vec2 o2){\n    return o1.x>o2.x ? o1 : o2;\n}\n\n//Function returning the signed distance to the\n// nearest object in 3D space, and the material\n// of said surface.\nvec2 objMap(vec3 p){\n    //Distance to the text in 2D\n    float text = textBox(p.xy);\n    \n    //3D distance\n    return objUnion\n        //Distance to white text\n        (vec2(max(2.0-p.z,text),1.0)\n        //Distance to orange text\n        ,vec2(max(2.000001-p.z,text),0.0)\n        );\n}\n\n//Function tracing a ray from point o along \n// vector r, seeking a total travelled distance\n// of MAX_ITER_DIST or a total iteration count\n// of MAX_ITER. Returns vec2(distance,material)\nvec2 objTrace(vec3 o, vec3 r){\n    float t; vec2 obj;\n    \n    for(int i=0;i<MAX_ITER;i++){\n        obj = objMap(o+r*t);\n        t += 0.6*obj.x;\n        if(obj.x<t/iResolution.y) break;\n        if(t>MAX_ITER_DIST) return vec2(MAX_ITER_DIST,4.0);\n    }\n    return vec2(t,obj.y);\n}\n\n//Converts converts material values of the given\n// object into RGB colors for the screen.\nvec3 material(vec2 obj){\n    //Like the fog function\n    float mul = 1.0 / (1.0 + obj.x * obj.x * obj.x * obj.x * 0.005);\n    \n    //Switch on the material component\n    switch(int(obj.y)){\n        case 4: return vec3(0.0);\n        case 0: return mul*vec3(1.0,0.5,0.3);\n        case 1: return mul*vec3(1.0);\n    }\n    //Return zero if we got an invalid material\n    return vec3(0.0);\n}\n//==END Raytrace==\n\n//Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Make a [-1,1]x[-1,1] coordinate space\n\tvec2 r = -1.0+2.0*fragCoord.xy / iResolution.xy;\n    //Apply aspect ratio\n    r.x *= iResolution.x/iResolution.y;\n    \n    //Return color\n    vec3 ret = vec3(0.0);\n    \n    //Time variable\n    float time = iTime;\n    \n    //V1\n    //If we're showing the first version\n    #ifdef VERSION_1\n    //Establish textbox distance field\n    float dist = textBox(2.0*r);\n    //Mix in the orange color\n    ret = mix(ret,vec3(1.0,0.5,0.3),1.0-smoothstep(0.0,0.1,dist));\n    //Mix in the white color\n    ret = mix(ret,vec3(1.0),\n              1.0-smoothstep(0.0,0.01,dist));\n    #endif\n    \n    //V2\n    //If we're displaying the second version\n    #ifdef VERSION_2\n    //Write the fog output directly into the return color\n    ret = vec3(fog(trace(makeRay(r))));\n    #endif\n    \n    //V3\n    //If we're displaying the third version\n    #ifdef VERSION_3\n    //Write the material output directly to the return color\n    ret = material(objTrace(vec3(0.0),makeRay(r)));\n    #endif\n    \n    //If we're displaying a debug mode\n    #ifdef SHOW_TEXTURE\n    //Overwrite any other return value with the iChannel0 texture\n    ret = texture(LETTER_CHANNEL,fragCoord.xy/iResolution.xy).www;\n    #endif\n    \n    //Output the return color\n\tfragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"}]}