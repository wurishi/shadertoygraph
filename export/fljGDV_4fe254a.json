{"ver":"0.1","info":{"id":"fljGDV","date":"1624759754","viewed":229,"name":"TT remastr: Plento MusicMaker v1","username":"ttg","description":"TTG Remaster: Use fixed-precision (DSP sample) time representation.  Fix DC offsets from stopped sample counters.\nPlento: The goal of this is to create a compact music arranger that can be re-used to make all kinds of fun shadertoy music.","likes":15,"published":1,"flags":40,"usePreview":0,"tags":["2d","sound","gpusound","remaster","sampleprecise"],"hasliked":0,"parentid":"7t23z3","parentname":"Music Maker v1 (GPU Music)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Cole Peterson \n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes.\n\n*/\n\n/*\n    Rights to all modifications herein are hereby assigned to Cole Peterson in\n    hopes that they are found useful and may be reintegrated freely.\n    - Theron Tarigo (ttg)\n*/\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*.031;\n    \n    vec2 id = floor(uv*110.)*.03;\n    vec2 id2 = floor(uv*20.);\n    \n    vec3 tex = texture(iChannel0, id).xyz;\n    \n    col = tex;\n    \n    if(cos(id2.x*10. + id2.y*8. + iTime) > 0.)\n        col = mix(col.rrr, col, .5+.5*cos(length(uv)*4. - iTime));\n    \n    col *= (1.-step(.44, abs(uv2.y)));\n    f = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*\n    Rights to all modifications herein are hereby assigned to Cole Peterson in\n    hopes that they are found useful and may be reintegrated freely.\n    - Theron Tarigo (ttg)\n*/\n\n\n#define R iResolution.xy\n\n// Constants\nconst float pi = 3.1415;\nconst float BPM = 175.0;\n\n\nconst float pitchWheel = 4.0;\n\nconst float swing = -0.4;\n\nfloat intfract(int s, float n) {\n  // Implements fract(s/n)\n  // Explanation and copyright: shadertoy.com/view/4ltfRN\n  // Given sample number and period, calculate phase with high accuracy.\n  // Uses integer overflow for modulo.\n  int sn = int(n), a = s%sn, b = (s/sn);\n  const float MAXF = float(uint(-1))+1.;\n  return fract(  (float(a)/n) + float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF );\n}\n\nfloat phase(int s, float f) {\n    return 6.2831855*intfract(s, iSampleRate/f);\n}\n\n#define ST(t) int(round((t)*iSampleRate))\n#define FT(s) (float(s)/iSampleRate)\n\n// noise\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Metronome sound\nfloat blip(int t, float hz, float k){\n    return (1. - exp(-FT(t)*40.)) * sin(phase(t,hz)) * exp(-FT(t) * k);\n}\n\n\n\n// A beat\nint b(int t){\n    return t%(ST(15./BPM)*4);\n}\n\n\n\n// Various durations of time\n#define bar_l (ST(15. / BPM)*16) // Bar\n#define beat_l (ST(15. / BPM)*4) // beat\n#define half_l (ST(15. / BPM)*2) // half beat\n#define quarter_l (ST(15. / BPM)*1) // quarter beat\n\nconst int qdiv= (1<<10); // defines precision of q\n// Get the correct time for a note based on its time offset\n// q = note start time (bar, beat, half beat, quarter beat)\n// nBeats = number of beats in pattern\n// t = time\nint noteTime(vec4 q, int nBeats, int t){\n    ivec4 qd = ivec4(round(q*float(qdiv)));\n    int start = t - (bar_l*qd.x/qdiv + beat_l*qd.y/qdiv + half_l*qd.z/qdiv + quarter_l*qd.w/qdiv);\n    return start<0 ? -1 : start % (nBeats*ST(15./BPM)*4);\n}\n\n\n// Loop a pattern\n// q = pattern start time (bar, beat, half beat, quarter beat)\n// loop = number of times to loop pattern\n// nb = number of beats in pattern\n// t = time\nint seq(vec4 q, int loop, int nb, int t){\n    ivec4 qd = ivec4(round(q*float(qdiv)));\n    int start = (bar_l*qd.x/qdiv + beat_l*qd.y/qdiv + half_l*qd.z/qdiv + quarter_l*qd.w/qdiv);\n    int dur = nb*loop*ST(15./BPM)*4;\n    \n    if(t > start && t < start + dur)\n        return t - start;\n    else\n        return -1;\n}\n\n\n\n\n// Distortions\nfloat dist1(float s, float d){\n \treturn clamp(d * s, -1., 1.);   \n}\nvec2 dist2(vec2 s, float d){\n \treturn clamp(d * s, vec2(-1.0), vec2(1.0));   \n}\n\n\n\n// Attack and decay from exponential and sqrt funcs\nfloat env(float t, float atk, float rel){\n    return (1. - exp(-t*atk)) * exp(-t*rel);\n}\n\n// Linear envelope thing\n// t = time\n// p = (attack, sustain, release)\nfloat envelope(int t, vec3 p){\n    float a = FT(t) / p.x;\n    float b = (p.y + p.x + p.z - FT(t));\n    return max(min(min(a, 1.), b), 0.);\n}\n\n\n\n// Note stuff\nconst float baseFreq = 110.0; // A1\nconst float d12thRootOf2 = pow(2.0, 1.0 / 12.0);\n\n// Return the note's frequency\nfloat n(float k){\n    return baseFreq * pow(d12thRootOf2, k + pitchWheel);\n}\n\n\n\n// Waveforms\nfloat sine(int t, float hz){\n    return sin(phase(t,hz));\n}\n\nfloat triangle(int t, float hz){\n    return (2. / pi) * asin(sin(phase(t,hz)));\n}\n\nfloat tri(int t, float hz){\n    return (2. / pi) * asin(sin(phase(t,hz)));\n}\n\nfloat sqr(int t, float hz){\n    return sign(sin(phase(t,hz))) * 0.5;\n}\n\nfloat saw(int t, float hz){\n    return 2.*phase(t,hz/2.)/(2.*pi) - 1.;\n}\n\n// Stereo versions\nvec2 sqr_2(int t, float nt, float sep){\n    return vec2(sqr(t, n(nt)), sqr(t, n(nt) + sep));\n}\n\nvec2 tri_2(int t, float nt, float sep){\n    return vec2(tri(t, n(nt)), tri(t, n(nt) + sep));\n}\n\nvec2 sine_2(int t, float nt, float sep){\n    return vec2(sine(t, n(nt)), sine(t, n(nt) + sep));\n}\n\nvec2 saw_2(int t, float nt, float sep){\n    return vec2(saw(t, n(nt)), saw(t, n(nt) + sep));\n}\n\n\n\n\n// Chords\nvec2 minor_tri(int t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .5*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 3., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\nvec2 major_tri(int t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .1*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 4., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\n\n\n\n\n\n\n\n// Synths\n\n\n// Major triad thingy\nvec2 synth_2(float k, float dur, vec4 q, int nBeats, int t){\n    vec2 ms = vec2(0);\n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n\n    ms += major_tri(t0, k, 0.75);\n    \n    return ms * smoothstep(0.0, .05, FT(t0)) * smoothstep(2.0, .0, FT(t0));\n    \n}\n\n\n// lead saw / triangle thingy\nvec2 synth_5(float k, float dur, vec4 q, int nBeats, int t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n\n    ms += tri_2(t0, k, 6.);\n    ms += .2*saw_2(t0, k + 12., 6.);\n    \n    return ms * smoothstep(0.0, .1, FT(t0)) * smoothstep(dur + .25, dur, FT(t0));\n    \n}\n\n// Saw lead \nvec2 synth_6(float k, float dur,float oct, vec4 q, int nBeats, int t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n\n    ms += saw_2(t0, k + 24., 2.);\n    //ms += .35*saw_2(t0, k + 12., 3.);\n    \n    //return ms * smoothstep(0.0, .1, t0) * smoothstep(1.8, 0., t0);\n    return ms * smoothstep(0.0, .2, FT(t0)) * smoothstep(dur + .25, dur, FT(t0));\n    \n}\n\n// Subby bass \nvec2 synth_3(float k, float dur, vec4 q, int nBeats, int t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n    \n    ms += .2*tri_2(t0, k, 0.4);\n    ms += sine_2(t0, k - 12., 0.);\n    \n    return ms * smoothstep(0.0, .01, FT(t0)) * smoothstep(dur + .01, dur, FT(t0));\n    //return ms * smoothstep(0.0, .4, t0) * smoothstep(2.2, .0, t0);\n}\n\n\n\n\n// Drums\nvec2 snare(vec4 q, int nBeats, int t){\n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n    \n    vec2 s = exp(-FT(t0)*16.) * (hash22(iSampleRate * vec2(FT(t0), FT(t0)*1.423)) * 2.0 - 1.0); \n    s = dist2(s, 1.13) * .85;\n    s += 1.3*dist1(exp(-FT(t0)*24.) * sine(t0, 200.), 4.0);\n    s += .1*dist1(exp(-FT(t0)*24.) * sine(t0, 150.), 3.0);\n    return s * 0.25;\n}\n\n\nvec2 kick(vec4 q, int nBeats, int t){\n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n    \n    vec2 s = vec2(0);\n    s += 1.5*dist2(exp(-FT(t0)*22.) * vec2(sine(t0, 72.)), 4.7);\n    s += 4. * exp(-FT(t0)*15.) * vec2(sine(t0, 70.));\n    return s * .15;\n}\n\nvec2 hat(vec4 q, int nBeats, int t){\n    int t0 = noteTime(q, nBeats, t);\n    if (t0==-1) return vec2(0.);\n    \n    vec2 s = envelope(t0, vec3(.1, .01, .01)) * (hash22(iSampleRate * vec2(FT(t), FT(t)*1.423)) * 2.0 - 1.0); \n    \n    //s = dist2(s, 1.1) * .85;\n    return s * 0.4;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"\n\n/*\n    Cole Peterson\n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes and arrange patterns.\n\n*/\n\n/*\n    Rights to all modifications herein are hereby assigned to Cole Peterson in\n    hopes that they are found useful and may be reintegrated freely.\n    - Theron Tarigo (ttg)\n*/\n\n\n// t = time\n// nb = Number of beats in this pattern\nvec2 pattern_chords_1(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    // play note 15 for 4 beats on the first bar. vec4(bar, beat, half beat, quarter beat)\n    ms += synth_2(15., 4., vec4(0., 0., 0., 0.), nb, t);\n    \n    // play note 10 for 4 beats on the second bar... ect.\n    ms += synth_2(10., 4., vec4(1., 0., 0., 0.), nb, t);\n    \n    ms += synth_2(13., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_2(8., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_lead_1(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_5(15. + 12., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_5(13. + 12., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_5(15. + 12., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    ms += synth_5(15. + 12., 4., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_5(20. + 12., 4., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_5(19. + 12., 4., vec4(7., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_lead_2(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_6(15., 2., 1., vec4(0., 2., 0., 0.), nb, t);\n    ms += synth_6(14., 4., 1., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_6(13., 4., 1., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_6(15., 2., 1., vec4(3., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 2., 1., vec4(3., 2., 0., 0.), nb, t);\n    ms += synth_6(10., 4., 1., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_6(12., 4., 1., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_6(8., 4., 1., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 4., 1., vec4(7., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_bass_1(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_3(3., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_3(-2., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_3(1., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_3(-4., 4., vec4(3., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_drums_hat(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += hat(vec4(0., 0., 0., 0.), nb, t);\n    ms += hat(vec4(0., 1., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 1., 1., 1.0 + swing), nb, t);\n    ms += hat(vec4(0., 2., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 1., 1.0 + swing), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_kick(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += kick(vec4(0., 0., 0., 0.), nb, t);\n    ms += kick(vec4(0., 0., 3., 1. + swing), nb, t);\n    ms += kick(vec4(0., 3., 0., 0.), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_snare(int t, int nb){\n    vec2 ms = vec2(0);\n    \n    ms += snare(vec4(0., 2., 0., 0.), nb, t);\n    ms += snare(vec4(0., 6., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\n\n\n\n// Arrange song\nvec2 snd(int t){\n    vec2 ms = vec2(0);\n    \n    ms += .3*pattern_chords_1(seq(vec4(0., 0., 0., 0.), 32, 16, t), 16);\n    \n    ms += .35*pattern_bass_1(seq(vec4(4., 0., 0., 0.), 32, 16, t), 16);\n    \n    ms += .0544*pattern_lead_1(seq(vec4(8., 0., 0., 0.), 32, 32, t), 32);\n    \n    ms += .036*pattern_lead_2(seq(vec4(24., 0., 0., 0.), 16, 16, t), 32);\n    \n    \n    ms += .5*pattern_drums_hat(seq(vec4(4., 0., 0., 0.), 32, 16, t), 4);\n    ms += .7*pattern_drums_kick(seq(vec4(4., 0., 0., 0.), 32, 16, t), 8);\n    ms += .5*pattern_drums_snare(seq(vec4(4., 0., 0., 0.), 32, 16, t), 8);\n    \n    return ms * .5;\n}\n\nvec2 mainSound( int samp, float time ){\n    vec2 ms = snd(samp);\n    \n    float vol = min(time*.6, 1.);\n    \n    \n    //ms += blip(b(samp), 825., 60.) * .4;\n    return ms * vol;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv *= 1. + cos(iTime*3.)*.04;\n    \n    float sun = smoothstep(.3, .305, length(uv));\n    sun *= smoothstep(.3, .36, (.5 + .5*cos(cos(iTime-length(uv)*20.)+atan(uv.y / uv.x) * 30.)));\n    \n    vec3 col = .3 + .4*cos(vec3(.6, 6., 1.)*length(uv*2.)+iTime+vec3(2., 2.2, 1.))* (1.-abs(uv.y));\n    col = mix(.5 + .3*cos(vec3(.6, 2., 4.)*length(uv*4.)-iTime), col, sun);\n    \n\n    \n    f = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}