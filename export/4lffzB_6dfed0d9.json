{"ver":"0.1","info":{"id":"4lffzB","date":"1512220745","viewed":618,"name":"testing SM/GPC - fragSniffer","username":"FabriceNeyret2","description":"The frame rate doubles if bufA::offset is computed on a different SM than (0,0).\nNot only there are warps and groups, but also SM, statically associated to screen regions.\n\nAuto adjust to you GPU power","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["warp","fps","sm","gpu","perfmeter","compilation","sp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of  https://shadertoy.com/view/4tsBzN\n// more GPU reverse engineering (aka fragSniffing) here: https://hal.inria.fr/hal-01643579\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tO = texelFetch(iChannel0, ivec2(U), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Warp/SM/GPC tester. \n\n#define warp vec2(4,8)    // on nvidia warps are 4x8 pixels, aligned with window coordinates\n#define T 1               // repeat each cell\n\nvoid mainImage( out vec4 O, vec2 U )\n{                                        // N will adjust depending on your GPU power\n    int N = iFrame==0 ? 300000 : int( texelFetch(iChannel0, ivec2(0),0).a );\n                                 \n    if ( floor(U/warp) == vec2(0) ) {    // --- eval(0,0). Simpler and free to compute the full warp\n        for(int i = 0; i< N; i++) \n            O.b += sin(iTime);\n        \n         O.a = iFrame<30  && iResolution.y>200.         // use 30 frames to adjust to your computer\n            ? float(N) * (.8 + .2*(1./31.)/iTimeDelta ) // relaxation towards 30fps goal.\n            : float(N);\n    }       \n    else                                 // --- offset of second sample evaluation \n    { \n        O = texelFetch(iChannel0, ivec2(U), 0);   \n        vec2 V = floor(U/warp), R = floor(iResolution.xy/warp);\n        if (  // V == U/warp &&         // if commented: simpler and free to compute the full warp\n              (iFrame-30)/T == int(V.x+V.y*R.x) ) {     // diverging costly branch...\n            for(int i = 0; i< N; i++)                   // ...only if offset is in the same warp than (0,0)\n                O.a += cos(iTime);\n    \n             O.rgb += 1./float(T)/(iTimeDelta*60.) ;    // draw performance map. max = 60 fps\n     }  } \n}","name":"Buf A","description":"","type":"buffer"}]}