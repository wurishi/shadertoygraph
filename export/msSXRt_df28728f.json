{"ver":"0.1","info":{"id":"msSXRt","date":"1670699349","viewed":94,"name":"WIP Sketch","username":"OfficeBatman","description":"/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 backgroundColor = vec3(.1, .1, .1);\n\nfloat axis(vec2 p) {\n    return min(abs(p.x), abs(p.y));\n}\n\nfloat star(vec2 p) {\n    float dis = length(p) * 5.;\n    float maxThickness = .1;\n    float thickness = maxThickness*(1. - pow(dis, .5));\n    return axis(p) - thickness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = UV_SCALED;\n\n    // Pixel color\n    vec3 col = backgroundColor;\n    \n    float starD = star(uv);\n    vec3 starColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    starColor = clamp(starColor, vec3(0), vec3(1));\n    //starColor = vec3(1.);\n    col = mix(starColor, col, clamp(10. * starD, 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n#define IZERO (min(0, int(iTime)))\n#define FZERO (min(0., iTime))\n#define INF 1./FZERO\n\nfloat min_(float x1) {\n    return x1;\n}\n\nfloat min_(float x1, float x2) {\n    return min(x1, x2);\n}\n\nfloat min_(float x1, float x2, float x3) {\n    return min_(x1, min(x2, x3));\n}\n\nfloat min_(float x1, float x2, float x3, float x4) {\n    return min_(x1, x2, min(x3, x4));\n}\n\nfloat max_(float a) {\n    return a;\n}\n\nfloat max_(float a, float b) {\n    return max(a, b);\n}\n\nfloat max_(float a, float b, float c) {\n    return max(max(a, b), c);\n}\n\n#define CLAMP01(X) clamp((X), 0., 1.)\n\n// Vectors\n#define RIGHT vec3(1., 0., 0.)\n#define UP vec3(0., 1., 0.)\n#define FORWARD vec3(0., 0., 1.)\n#define ZERO vec3(0)\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat mapRange(float x, float min1, float max1, float min2, float max2) {\n    return (clamp(x, min1, max1) - min1) * ((max2 - min2) / (max1 - min1)) + min2;\n}\n\n#define OP_SCALE(SDF, P, S) \\\n    SDF((P) / (S)) * (S)\n\nmat3 rotateX(float a) {\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\nmat3 rotateY(float a) {\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n    );\n}\nmat3 rotateZ(float a) {\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\n// Noise functions\n\nfloat hash2d(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash2d( ii + vec2(0.0,0.0) );\n\tfloat b = hash2d( ii + vec2(1.0,0.0) );    \n    float c = hash2d( ii + vec2(0.0,1.0) );\n\tfloat d = hash2d( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash2d( ii + vec2(0.0,0.0) );\n\tb = hash2d( ii + vec2(1.0,0.0) );    \n    c = hash2d( ii + vec2(0.0,1.0) );\n\td = hash2d( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n// Sdf\n\n#define TOUCHING(SDF, POS) (abs(SDF((POS))) < E_SURF)\n#define INSIDE(SDF, POS) (SDF((POS)) < E_SURF)\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sphere(vec3 p) {\n    return sphere(p, 1.);\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    return box(p, b, 0.);\n}\n\nfloat box(vec3 p) {\n    return box(p, vec3(1));\n}\n\nfloat capsule(vec3 p, float r, float height) {\n    return length(p - (UP * clamp(p.y, r, height - r))) - r;\n}\n\nfloat plane(vec3 p) {\n\treturn p.y;\n}\n\nfloat cone(vec3 p, vec2 c, float h) {\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat roundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot(pa*l2 - ba*y, pa*l2 - ba*y);\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n#define NORMAL_SAMPLE_R 0.01\n#define DEFINE_GET_NORMAL(scene) \\\n    vec3 getNormal(vec3 p) \\\n    { \\\n        return normalize(vec3( \\\n            scene(vec3(p.x + NORMAL_SAMPLE_R, p.y, p.z)) - scene(vec3(p.x - NORMAL_SAMPLE_R, p.y, p.z)), \\\n            scene(vec3(p.x, p.y + NORMAL_SAMPLE_R, p.z)) - scene(vec3(p.x, p.y - NORMAL_SAMPLE_R, p.z)), \\\n            scene(vec3(p.x, p.y, p.z + NORMAL_SAMPLE_R)) - scene(vec3(p.x, p.y, p.z - NORMAL_SAMPLE_R)) \\\n        )); \\\n    }\n\n// Main\n#define UV_SCALED (2. * fragCoord.xy - iResolution.xy) / iResolution.yy\n\n// parameters should be normalized\nmat3 camera(vec3 forward, vec3 globalUp) {\n    vec3 right = cross(forward, globalUp);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}","name":"Common","description":"","type":"common"}]}