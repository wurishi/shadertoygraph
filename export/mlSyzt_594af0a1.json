{"ver":"0.1","info":{"id":"mlSyzt","date":"1692157636","viewed":33,"name":"Durand-Kerner solver (numerical)","username":"Envy24","description":"https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method\nWith float works for degrees [2-7], but not so stable for 5,6,7 degrees.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","complex","solver","polynomial","numeric","durand","kerner"],"hasliked":0,"parentid":"mllcz7","parentname":"Aberth solver (numerical)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define SCENE_SCALE               ( 3. )\n#define UNIT                      ( (SCENE_SCALE*3.0) / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\nfloat explicit(float x) { return eval_poly(vec2(x, 0.), pcs, degree).x; }\nfloat dydx(float x)\n{\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n\n    init_poly_coeffs(iTime);\n\n    vec3 color = vec3(1.);\n         color -= draw_explicit_func(NDC, explicit(NDC.x), dydx(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n  \n    for (int d = 1; d <= degree; ++d)\n    {\n        pcs[d] = cdiv(pcs[d], pcs[0]);\n    }\n    pcs[0] = cdiv(pcs[0], pcs[0]);\n  \n    // Numeric solver.\n    DurandKernerMethod(roots, pcs);\n\n    for (int r = 0; r < degree; ++r)\n    {\n        float x = roots[r].x;\n        \n        /* With validation off. *\n        if (abs(roots[r].y) > 1e-5)\n            color = mix(color, vec3(0, 0, 1), SMAA(diskSDF_L2(NDC, vec2(x, 0.0), 0.05))); // invalid root\n        else\n            color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, vec2(x, 0.0), 0.05))); // valid root\n        /* With validation on. */\n        if (roots[r].x != 9e5)\n            color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, vec2(x, 0.0), 0.05))); // valid root\n        /**/\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Min degree 1, max degree 7.\nconst int degree = 6;\nvec2 roots[degree];\nvec2 pcs[degree + 1]; // Polynomial coeffitients\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvoid init_poly_coeffs(float iTime)\n{\n    float T = iTime;\n    pcs[0].x = sinOSC(-1.25, 1.25, T * 0.15);  // a   \n    pcs[1].x = sinOSC( -2.0,  2.0, T * 0.6);   // b\n    pcs[2].x = sinOSC( -1.0,  1.0, T * 0.45);  // c\n    pcs[3].x = sinOSC( -1.0,  1.0, T * 0.25);  // d\n    pcs[4].x = sinOSC( -1.0,  1.0, T * 0.17);  // e\n    pcs[5].x = sinOSC( -1.0,  1.0, T * 0.07);  // f\n    pcs[6].x = sinOSC( -1.0,  1.0, T * -0.17); // g\n    //pcs[7].x = sinOSC( -1.0,  1.0, T * -0.3);  // h\n    \n    for (int d = 0; d <= degree; ++d)\n    {\n        pcs[d].y = 0.;\n    }\n}\n\nvec2 cadd(vec2 l, vec2 r)\n{\n    return vec2(l.x+r.x, l.y + r.y);\n}\nvec2 cmul(vec2 l, vec2 r)\n{\n    return vec2(l.x * r.x - l.y * r.y, l.x * r.y + r.x * l.y);\n}\n\nvoid cmul_(inout vec2 l, vec2 r)\n{\n    vec2 p = vec2(l.x * r.x - l.y * r.y, l.x * r.y + r.x * l.y);\n    \n    l.x = p.x;\n    l.y = p.y;\n}\n\nvec2 cdiv(vec2 l, vec2 r)\n{\n    float inverseDivider = 1.0 / (r.x * r.x + r.y * r.y);\n\n    return vec2(\n        (l.x * r.x + r.y * l.y) * inverseDivider, \n        (r.x * l.y - l.x * r.y) * inverseDivider);\n}\nvec2 eval_poly(\n    vec2 x,\n    vec2 pcs[degree+1],\n    int degree)\n{\n    vec2 power = x, p_sum = pcs[degree];\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        vec2 t = cmul(power, pcs[degree - d]);\n        p_sum = cadd(p_sum, t);\n        power = cmul(power, x);\n    }\n\n    return p_sum;\n}\n\nvoid DurandKernerMethod(\n    inout vec2[degree] roots,\n    in vec2[degree + 1] coef)\n{\n    vec2 arb = vec2(0.4, 0.9);\n\n    roots[0] = arb;\n\n    for (int r = 1; r < degree; ++r)\n    {\n        roots[r] = roots[r - 1] * arb;\n    }\n\n    for (int i = 0; i < 64; ++i)\n    {\n        for (int r = 0; r < degree; ++r)\n        {\n            vec2 numer = coef[degree];\n            vec2 power = roots[r];\n\n            for (int c = degree - 1; c >= 0; --c)\n            {\n                numer += cmul(coef[c], power);\n                cmul_(power, roots[r]);\n            }\n\n            vec2 denom = vec2(1.0, 0.0);\n\n            for (int k = 0; k < degree; ++k)\n            {\n                if (k == r) { continue; }\n\n                cmul_(denom, roots[r] - roots[k]);\n            }\n\n            roots[r] -= cdiv(numer, denom);\n        }\n    }\n    \n    /* On/Off roots validation */\n    const float tolerance = 1e-6;\n    for (int r = 0; r < degree; ++r)\n    {\n        if (abs(roots[r].y) > tolerance)\n             roots[r] = vec2(9e5);\n    }   \n    /**/\n}","name":"Common","description":"","type":"common"}]}