{"ver":"0.1","info":{"id":"Nd3GDj","date":"1630621383","viewed":74,"name":"draw circles","username":"bonfire","description":"draw circles","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// slider\n//https://www.shadertoy.com/view/4lBcD3\n\nconst vec2 cSliderStore = vec2(0);\n\nvec4 LoadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = fragCoord - 0.5*iResolution.xy;\n    r = 2.0* r.xy/iResolution.y;\n    \n    vec4 sliders = LoadValue(cSliderStore) * 0.07;\n\n\n    float distance = length(r);\n    float b = sliders[0];\n    float val = abs(sin(distance/b));\n\n    if(val > 0.98)\n    {\n        fragColor = vec4(1,1,1,1);\n    }else\n    {\n       fragColor = vec4(0,0,0,1);\n    }\n    \n    vec2 uv_overlay = fragCoord/iResolution.xy;\n    vec4 debugOverlay = texture(iChannel0, uv_overlay);\n    fragColor = mix(fragColor, debugOverlay, debugOverlay.a);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Store your save data positions as constants for easy retrieval and storage\nconst vec2 cSliderStore = vec2(0);\nconst vec2 cPreviousMouseClickStore = vec2(1.0, 0.0);\n\n// State storing taken from: https://www.shadertoy.com/view/MddGzf\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 LoadValue( in vec2 re )\n{\n    return textureLod( iChannel0, (0.5+re) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid StoreValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 LoadData(in ivec2 pos)\n{\n    return texelFetch(iChannel0, pos, 0);\n}\n\nfloat Equal(in vec2 rhs, in vec2 lhs) \n{\n    vec2 signOf = sign(rhs - lhs);\n    return max(1.0 - abs(signOf.x + signOf.y), 0.0);\n}\n\nfloat Not(in float l)\n{\n    return 1.0 - l;\n}\n\n// Draw a slider, and update it's value based on the mouse position\nvec4 Slider(in vec2 uv, in vec2 pos, inout float currentSlider)\n{   \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n\t// Draw the slider bar\n    const vec2 cSquareHalfSize = vec2(0.01, 0.1);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    // Draw the actual slider\n    const vec2 cSliderHalfSize = vec2(0.02, 0.01);\n    vec2 sliderAbsPoint = abs(uv - (pos + vec2(0.0, currentSlider * 2.0 * cSquareHalfSize.y - cSquareHalfSize.y)));\n    vec2 inSliderV = step(sliderAbsPoint, cSliderHalfSize);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSlider = inSliderV.x * inSliderV.y;\n    \n    // Check collision against the slider\n    const vec2 cColliderBox = vec2(0.02, 0.1);\n    vec2 relativeMousePoint = (mouseUV - pos);\n    vec2 mouseInCollider = step(abs(relativeMousePoint), cColliderBox);\n    \n\t// Update the slider's position if we're in the collider\n    float sliderHeight = (relativeMousePoint.y + cColliderBox.y) / (2.0 * cColliderBox.y);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    currentSlider = mix(currentSlider, sliderHeight, mouseInCollider.x * mouseInCollider.y);\n    \n    // Draw out the slider\n    return vec4(0.5, 0.8, 0.4, 1.0) * inSquare + vec4(1.0) * inSlider;\n}\n\nvec4 Toggle(in vec2 uv, in vec2 pos, inout float currentToggle)\n{\n    vec2 previousMouseClick = LoadValue(cPreviousMouseClickStore).xy;\n    \n    vec2 clickUV = iMouse.zw / iResolution.xy;\n    \n    float hasClickStateChanged = Not(Equal(clickUV.xy, previousMouseClick.xy));\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 cSquareHalfSize = vec2(0.02 / aspect, 0.02);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    vec2 relativeAbsMousePoint = abs(previousMouseClick - pos);\n    vec2 mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    currentToggle = mix(currentToggle, 1.0 - currentToggle, mouseInCollider.x * mouseInCollider.y * hasClickStateChanged);\n    \n    vec2 cOutlineHalfSize = vec2(0.025 / aspect, 0.025);\n    vec2 inOutlineV = step(relativeAbsPoint, cOutlineHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inOutline = inOutlineV.x * inOutlineV.y;\n    \n    vec4 outlinecolor = vec4(1.0);\n    \n    relativeAbsMousePoint = abs(clickUV - pos);\n    mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    vec4 toggleColor = mix(vec4(0.5,0.5,0.5,1.0), vec4(0.5, 0.8, 0.4, 1.0), currentToggle);\n    toggleColor = mix(toggleColor, toggleColor * 0.95,  mouseInCollider.x * mouseInCollider.y);\n    return mix(outlinecolor * inOutline, toggleColor, inSquare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t// Load the values that you stored a previous frame\n    vec4 sliderValues = LoadValue(cSliderStore);\n\n    // Draw the sliders and update the slider values based on the mouse input\n\tvec4 sliderColor = Slider(uv, vec2(0.05, 0.85), sliderValues.x);\n    //sliderColor += Slider(uv, vec2(0.1, 0.85), sliderValues.y);\n    //sliderColor += Slider(uv, vec2(0.15, 0.85), sliderValues.z);\n    //sliderColor += Toggle(uv, vec2(0.2, 0.85), sliderValues.w);\n    \n    // Draw out the sliders\n    fragColor = sliderColor;\n    \n    // Store the values into the buffer\n    StoreValue(cSliderStore, sliderValues, fragColor, fragCoord);\n    StoreValue(cPreviousMouseClickStore, vec4(iMouse.zw / iResolution.xy, 0, 0), fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}