{"ver":"0.1","info":{"id":"ctfyzB","date":"1690870825","viewed":108,"name":"Storm Of Hearts","username":"andrew741","description":"A bunch of hearts slowly moving by, almost like leaves in a gentle breeze.\n\nThis is created using the equation x^2+(y-x^(2/3))^2 (found the equation on Google), a modulo operator to repeat the domain, and stacking many of those layers + more.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["blur","parallax","animation","shader","red","rotation","hearts","love","layered","intractable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EquationExponent 2./3.  // changes the shape of the heart\n#define CellSize vec2(5.75)     // the cell size for the hearts\n#define OffsetStrength 1.6      // the strength of the random offset of the hearts\n#define Itterations 10.         // the number of layers of hearts\n#define Thickness 1.7           // the thickness of the hearts\n#define BlurDepth 10.           // the depth at which hearts are fully blurred\n\n// the matrix for the hash function\n#define HashMat mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n\n// the colors for the hearts (are blended between)\n#define HeartCol1 vec3(1., 0., 0.)\n#define HeartCol2 vec3(1., 0.2, 0.65)\n\n// this hash is from someone elses shader (with a slight modifaction)\nvec3 hash( vec3 p ) {  return fract(sin(p * HashMat) * 43758.5453123) * 2. - 1.;  }\n\n// rotates a 2d point based on an angle\nvec2 rot2D(vec2 v, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return v * mat2(ca, -sa, sa, ca);\n}\n\n// gets the distance to hearts\nvec4 heartDst(vec2 uv, float scale, float rot, vec2 offset, float seed)\n{\n    // getting a random hash for each cell\n    vec2 cell = floor((uv * scale - offset) / (CellSize * 2.));\n    vec3 rand = hash(vec3(cell, seed));\n    \n    // getting the new uv position for the cell\n    vec2 np = rot2D(mod(uv * scale - offset, CellSize * 2.) - CellSize + rand.xy * OffsetStrength, rot * rand.x + rand.z*2.) + rand.xy * OffsetStrength;\n    \n    // getting the distance to the heart\n    float brightness = 0.;\n    np.y -= pow(abs(np.x), EquationExponent);\n    float dst = length(np);\n    \n    // getting the highlights\n    bool domainX = (np.x > 0.4 && np.x < 1.5) || (np.x > -1.2 && np.x < -0.1);\n    if (domainX && np.y > 0.2 && dst < Thickness - 0.1 && dst > Thickness - 0.25) brightness = 1.;\n    \n    // returning the depth and color/highlights info\n    return vec4(dst, rand.z, rand.y*0.5+0.5, brightness);\n}\n\n// the main method\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv coord\n    float time = max(iTime - 1.5, 0.);                  // waits before starting the animation\n    float time2 = max(iTime - 6., 0.) - 5.;             // used for the second zooming animation\n    float transition = smoothstep(10., 0., time*time);  // used for the starting animation\n    transition -= smoothstep(10., 0., time2*time2) * 0.25;  // the second zooming animation (goes in and back out using a parabola)\n    float zoom = transition * 100. + 40.;               // the zoom distance of the camera\n    vec2 offset = iMouse.xy / iResolution.y * 100.;     // moving the camera based on the mouse pos\n    vec2 uv = rot2D((fragCoord - iResolution.xy * 0.5) / iResolution.y, length(offset) * 0.002 - transition) * zoom + offset;\n    \n    // the pixel size for antialiasing\n    float pixelSize = zoom / iResolution.y * 1.5;\n    \n    // looping through many layers of hearts\n    vec3 col = vec3(1., 0.1, 0.325) * (1.5 / (Itterations + 1.));\n    for (float i = Itterations; i > 0.; i--)\n    {\n        // getting the distance to 2 overlapping layers of hearts (to prevent hearts getting cliped while keeping it non grid like)\n        float layerScale = (i * 0.5);\n        float itterationScalar = (Itterations - i) / Itterations;\n        vec2 layerOffset = vec2(iTime * itterationScalar);\n        float layerRotation = iTime * itterationScalar;\n        vec4 dst1 = heartDst(uv + hash(vec3(-i)).xy                      , layerScale, layerRotation, layerOffset, i              );\n        vec4 dst2 = heartDst(uv + hash(vec3(-i)).xy + CellSize/layerScale, layerScale, layerRotation, layerOffset, i + Itterations);\n        float dst = (dst1.x < Thickness && dst2.x < Thickness) ? dst1.x : min(dst1.x, dst2.x);\n        \n        // getting the heart's color\n        vec3 heartCol;\n        if (dst != dst1.x) dst1 = dst2;\n        heartCol = mix(HeartCol1, HeartCol2, dst1.y) + dst1.w * (dst1.z*0.2+0.2) * itterationScalar;\n        \n        // rendering the hearts\n        float blur = (pixelSize + smoothstep(1., BlurDepth, i)) * 0.5;  // the background blur\n        col = mix(col, (1.5 / i) * heartCol, smoothstep(blur, -blur, dst-Thickness));\n    }\n    \n    // the final color\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}