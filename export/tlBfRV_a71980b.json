{"ver":"0.1","info":{"id":"tlBfRV","date":"1599911028","viewed":231,"name":"Interactive Alien Liquid","username":"snolot","description":"forked from tmst Interactive liquid metal blob https://www.shadertoy.com/view/3tGXz3 one my favourite.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = textureLod(iChannel0, uv, 0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BOX_N 127.0\n#define DENSITY_THRESH 3.0\n\n// Data is organized into 3 \"pages\" of 128x128x128 values.\n// (The values are at voxel corners, so there are 127x127x127 voxels)\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn)\n{\n    // subtexture within [0,8)^2\n    float l = mod(floor(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(floor(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    if (l < 64.0) {\n        return fv;\n    } else {\n        return -fv;\n    }\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn)\n{\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n#define EPS 0.0001\n\n// ================\n// Generic helpers\n// ================\n\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid materialShader(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuse,\n    out vec3 specular\n) {\n    float intensityDiffuse = clamp(dot(nvNormal, nvFragToLight), 0.0, 1.0);\n    intensityDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float intensitySpecular = pow(clamp(dot(nvNormal, blinnH), 0.0, 1.0), specularExponent);\n    intensitySpecular *= specularCoefficient;\n\n    diffuse = intensityDiffuse * texColor * lightColor;\n    specular = intensitySpecular * lightColor;\n}\n\n// Blackbody color palette. Handy for all kinds of things.\nvec3 colormapBlackbody(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    t *= 4000.; // Temperature range. Hardcoded from 0K to 4000K, in this case.    \n    \n    // Planckian locus or black body locus approximated in CIE color space.\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    // Converting XYZ color space to RGB: http://www.cs.rit.edu/~ncs/color/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    // Apply Stefanâ€“Boltzmann's law to the RGB color\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colormapIQ(float t){\n    //vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n   \t// nice blue\n    vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    \n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    \n   //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    //vec3 col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\nvec3 colormapInferno(float t) {\n    return vec3(\n        1.0 - (t - 1.0)*(t - 1.0),\n        t*t,\n        t * (3.0*t - 2.0)*(3.0*t - 2.0)\n    );\n}\n\nvec3 colormapViridis(float t) {\n\n    const vec3 c0 = vec3(0.0, 0.0, 0.0);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n#define COLOR_FUNC colormapIQ\n\nvec3 skybox(vec3 nvDir) {\n    return texture(iChannel1, nvDir).rgb;\n}\n\n// ========================\n// Marching through voxels\n// ========================\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t);\n}\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return floor(uvw * vec3(BOX_N));\n}\n\nvoid readLMN(in vec3 lmn, out vec2 st, out vec3 n) {\n    st = texture(iChannel0, vcubeFromLMN(2, lmn)).st;\n    n = 2.0 * (texture(iChannel0, vcubeFromLMN(3, lmn)).xyz - 0.5);\n}\n\nvoid boxFromLMN(in vec3 lmn, out vec3 boxMin, out vec3 boxMax) {\n    vec3 boxSize = (BOX_MAX - BOX_MIN) / BOX_N;\n\n    boxMin = BOX_MIN + (floor(lmn)/BOX_N) * (BOX_MAX - BOX_MIN);\n    boxMax = boxMin + boxSize;\n}\n\n// Interpolate normal, density, and temperature in voxel volume\nvoid hitVoxel(\n    in vec3 lmn,\n    in vec3 pVoxelIn, in vec3 pVoxelOut, in vec3 voxelBoxMin, in vec3 voxelBoxMax,\n    out vec3 pHit, out vec3 nvHit, out vec2 stHit, out bool didHit\n) {\n    vec3  n000,  n001,  n010,  n011,  n100,  n101,  n110,  n111;\n    vec2 st000, st001, st010, st011, st100, st101, st110, st111;\n\n    readLMN(lmn, st000, n000);\n    readLMN(lmn + vec3(0.0, 0.0, 1.0), st001, n001);\n    readLMN(lmn + vec3(0.0, 1.0, 0.0), st010, n010);\n    readLMN(lmn + vec3(0.0, 1.0, 1.0), st011, n011);\n    readLMN(lmn + vec3(1.0, 0.0, 0.0), st100, n100);\n    readLMN(lmn + vec3(1.0, 0.0, 1.0), st101, n101);\n    readLMN(lmn + vec3(1.0, 1.0, 0.0), st110, n110);\n    readLMN(lmn + vec3(1.0, 1.0, 1.0), st111, n111);\n\n    vec3 nc000 = n000;\n    vec3 nc001 = n001 - n000;\n    vec3 nc010 = n010 - n000;\n    vec3 nc100 = n100 - n000;\n    vec3 nc011 = n011 - n001 - n010 + n000;\n    vec3 nc101 = n101 - n001 - n100 + n000;\n    vec3 nc110 = n110 - n010 - n100 + n000;\n    vec3 nc111 = n111 - n011 - n101 - n110 + n001 + n010 + n100 - n000;\n\n    vec2 stc000 = st000;\n    vec2 stc001 = st001 - st000;\n    vec2 stc010 = st010 - st000;\n    vec2 stc100 = st100 - st000;\n    vec2 stc011 = st011 - st001 - st010 + st000;\n    vec2 stc101 = st101 - st001 - st100 + st000;\n    vec2 stc110 = st110 - st010 - st100 + st000;\n    vec2 stc111 = st111 - st011 - st101 - st110 + st001 + st010 + st100 - st000;\n\n    vec3 tb0 = (pVoxelIn - voxelBoxMin) / (voxelBoxMax - voxelBoxMin);\n    vec3 in0  =  nc000 + tb0.z* nc001 + tb0.y*( nc010 + tb0.z* nc011) + tb0.x*( nc100 + tb0.z* nc101 + tb0.y*( nc110 + tb0.z* nc111));\n    vec2 ist0 = stc000 + tb0.z*stc001 + tb0.y*(stc010 + tb0.z*stc011) + tb0.x*(stc100 + tb0.z*stc101 + tb0.y*(stc110 + tb0.z*stc111));\n\n    vec3 tb1 = (pVoxelOut - voxelBoxMin) / (voxelBoxMax - voxelBoxMin);\n    vec3 in1  =  nc000 + tb1.z* nc001 + tb1.y*( nc010 + tb1.z* nc011) + tb1.x*( nc100 + tb1.z* nc101 + tb1.y*( nc110 + tb1.z* nc111));\n    vec2 ist1 = stc000 + tb1.z*stc001 + tb1.y*(stc010 + tb1.z*stc011) + tb1.x*(stc100 + tb1.z*stc101 + tb1.y*(stc110 + tb1.z*stc111));\n\n    float th = (DENSITY_THRESH - ist0.s) / (ist1.s - ist0.s);\n    didHit = th > 0.0 && th < 1.0;\n    pHit = mix(pVoxelIn, pVoxelOut, th);\n    nvHit = normalize(mix(in0, in1, th));\n    stHit = mix(ist0, ist1, th);\n}\n\nvoid march(in vec3 p, in vec3 nv, out vec4 color) {\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n\n    color = vec4(0.0);\n    if (didHitBox < 0.5) {\n        return;\n    }\n\n    float t = tRange.s;\n    for (int i=0; i<500; i++) {\n        // Get voxel data\n        vec3 worldPos = p + (t+EPS)*nv;\n        vec3 lmn = lmnFromWorldPos(worldPos);\n\n        vec3 curBoxMin, curBoxMax;\n        boxFromLMN(lmn, curBoxMin, curBoxMax);\n\n        vec2 curTRange;\n        float curDidHit;\n        boxClip(curBoxMin, curBoxMax, p, nv, curTRange, curDidHit);\n\n        // Quick lookup to see if the surface intersects this voxel\n        float isSolid = texture(iChannel0, vcubeFromLMN(2, lmn)).w;\n        if (isSolid > 0.0) {\n            // It does, so hit interpolated surface inside the voxel\n            vec3 pVoxelIn  = p + curTRange.s * nv;\n            vec3 pVoxelOut = p + curTRange.t * nv;\n\n            vec3 pHit;\n            vec3 nvHit;\n            vec2 stHit;\n            bool didHitSurf;\n            hitVoxel(\n                lmn,\n                pVoxelIn, pVoxelOut, curBoxMin, curBoxMax,\n                pHit, nvHit, stHit, didHitSurf\n            );\n\n            // Hit surface, so determine color and quit\n            if (didHitSurf) {\n                vec3 lightPos = p + vec3(0.0, 1.0, 0.0);\n                vec3 nvFragToLight = normalize(lightPos - pHit);\n                vec3 nvFragToCam = normalize(p - pHit);\n\n                vec3 matColor = COLOR_FUNC(stHit.t);\n                vec3 lightColor = vec3(.7);\n\n                vec3 diffuse;\n                vec3 specular;\n                materialShader(\n                    1.0-stHit.t, 1.0-stHit.t, 20.0,\n                    lightColor, matColor, nvHit,\n                    nvFragToLight,\n                    nvFragToCam,\n                    diffuse, specular\n                );\n                vec3 ambient = stHit.t * matColor;\n\n               /* vec3 vRefl = reflect(-nvFragToCam, nvHit);\n                vec3 cRefl = skybox(vRefl);\n\n                vec3 colorFinal = clamp(diffuse+ambient, 0., 1.)  +specular  ;//mix(clamp(diffuse+ambient, 0., 1.), cRefl , 0.75*(1.0-stHit.t))+specular;\n*/\n                vec3 vRefl = reflect(-nvFragToCam, nvHit);\n                vec3 cRefl = skybox(vRefl);\n\n                vec3 colorFinal = mix(diffuse+ambient, cRefl, 0.75*(1.0-stHit.t)) + specular;\n                \n                color = vec4(clamp(colorFinal, 0.0, 1.), 1.0);\n                break;\n            }\n        }\n\n        // Move up to next voxel\n        t = curTRange.t;\n        if (t+EPS > tRange.t) { break; }\n    }\n}\n\n// =============\n// Render scene\n// =============\n\nvoid sceneCamera(in vec2 fragCoord, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 sphPos = vec2(0.1*iTime, 0.5*3.14159);\n    camPos = 2.5 * (\n        sin(sphPos.y) * vec3(cos(2.0*sphPos.x), 0.0, sin(2.0*sphPos.x)) +\n        cos(sphPos.y) * vec3(0.0, 1.0, 0.0)\n    );\n    vec3 lookTarget = vec3(0.0);\n\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    nvCamDir = normalize(vWorld.xyz / vWorld.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 camPos;\n    vec3 nvCamDir;\n    sceneCamera(fragCoord, camPos, nvCamDir);\n\n    vec3 bgColor = vec3(.1);//skybox(nvCamDir);\n\n    vec4 objColor;\n    march(camPos, nvCamDir, objColor);\n    vec3 finalColor = objColor.rgb + (1.0 - objColor.a)*bgColor;\n\n    fragColor = vec4(finalColor, 1.0);\n\n    // Mouse input\n    // For load/store cf. https://www.shadertoy.com/view/MddGzf\n    //---------------------------------------\n    ivec2 ipx = ivec2(fragCoord - 0.5);\n\n    bool storeEntry = ipx == ivec2(0,0);\n    bool storeExit = ipx == ivec2(1,0);\n\n    if (storeEntry || storeExit) {\n        vec4 entry = vec4(0.0);\n        vec4 exit = vec4(0.0);\n\n        vec2 mouseXY;\n        if (iMouse.z > 0.0) {\n            mouseXY = iMouse.xy;\n        } else {\n            float radius = 0.5*min(iResolution.x,iResolution.y);\n            mouseXY = 0.5*iResolution.xy + radius*vec2(cos(.2*iTime ), sin(.2*iTime));\n        }\n\n        vec3 camPosMouse;\n        vec3 nvCamDirMouse;\n        sceneCamera(mouseXY, camPosMouse, nvCamDirMouse);\n\n        vec2 tRange;\n        float didHitBox;\n        boxClip(BOX_MIN, BOX_MAX, camPosMouse, nvCamDirMouse, tRange, didHitBox);\n\n        if (didHitBox > 0.5) {\n            vec3 pEntry = camPosMouse + tRange.s*nvCamDirMouse;\n            vec3 lmnEntry = lmnFromWorldPos(pEntry);\n            entry = vec4(lmnEntry / BOX_N, 1.0);\n\n            vec3 pExit = camPosMouse + tRange.t*nvCamDirMouse;\n            vec3 lmnExit = lmnFromWorldPos(pExit);\n            exit = vec4(lmnExit / BOX_N, 1.0);\n        }\n\n        if (storeEntry) {\n            fragColor = entry;\n        } else if (storeExit) {\n            fragColor = exit;\n        }\n    }\n    //---------------------------------------\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// --------------------------------------\n// Helpers for accessing volumetric data\n// --------------------------------------\n\nvec2 getDataNearest(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(1, lmn)).st;\n}\n\nvec2 getDataInterp(vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    vec2 d000 = getDataNearest( flmn );\n    vec2 d001 = getDataNearest( flmn + vec3(0.0, 0.0, 1.0) );\n    vec2 d010 = getDataNearest( flmn + vec3(0.0, 1.0, 0.0) );\n    vec2 d011 = getDataNearest( flmn + vec3(0.0, 1.0, 1.0) );\n    vec2 d100 = getDataNearest( flmn + vec3(1.0, 0.0, 0.0) );\n    vec2 d101 = getDataNearest( flmn + vec3(1.0, 0.0, 1.0) );\n    vec2 d110 = getDataNearest( flmn + vec3(1.0, 1.0, 0.0) );\n    vec2 d111 = getDataNearest( flmn + vec3(1.0, 1.0, 1.0) );\n\n    // TODO: Compare to interpolation in Buf A\n    vec3 t = lmn - flmn;\n    vec2 dY0Z0 = mix(d000, d100, t.x);\n    vec2 dY1Z0 = mix(d010, d110, t.x);\n    vec2 dY0Z1 = mix(d001, d101, t.x);\n    vec2 dY1Z1 = mix(d011, d111, t.x);\n    vec2 dZ0 = mix(dY0Z0, dY1Z0, t.y);\n    vec2 dZ1 = mix(dY0Z1, dY1Z1, t.y);\n    return mix(dZ0, dZ1, t.z);\n}\n\n// ------------------------------\n// Some noise for the cube faces\n// ------------------------------\n\nfloat rand(in vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    vec2 m = pf*pf*(3.0-2.0*pf);\n    return mix(mix(r00, r10, m.x), mix(r01, r11, m.x), m.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*32.0;\n\n    float v = noise(p);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    return v;\n}\n\n// ----------------------------------------------------------------------\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\n// in matrix form: (1-c)[n*n^T] + cI - s[[0,n3,-n2][-n3,0,n1][n2,-n1,0]]\n// ----------------------------------------------------------------------\n\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 n = normalize(axis);\n\n    return mat3(\n        (1.0-c)*n.x*n.x + c,\n        (1.0-c)*n.y*n.x + s*n.z,\n        (1.0-c)*n.z*n.x - s*n.y,\n\n        (1.0-c)*n.x*n.y - s*n.z,\n        (1.0-c)*n.y*n.y + c,\n        (1.0-c)*n.z*n.y + s*n.x,\n\n        (1.0-c)*n.x*n.z + s*n.y,\n        (1.0-c)*n.y*n.z - s*n.x,\n        (1.0-c)*n.z*n.z + c\n    );\n}\n\n// -----------------------\n// Volumetric data update\n// -----------------------\n\n// NOTE: These pixels refer to voxel *corners* with s as \"density\" and\n// t as \"temperature\".  These will be interpolated in the voxel volume.\n\nvec3 cpLine(vec3 q0, vec3 q1, vec3 p) {\n    vec3 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + t*vEdge;\n}\n\nfloat sdLine(vec3 q0, vec3 q1, vec3 p) {\n    vec3 x = cpLine(q0, q1, p);\n    return distance(x, p);\n}\n\nvoid doPage1(out vec4 fragColor, in vec3 lmn)\n{\n    float iTimeN = float(iFrame)/60.0;\n\n    vec3 mid = vec3(63.5);\n    vec3 absd = abs(lmn-mid);\n    float dcorner = max(max(absd.x, absd.y), absd.z);\n\n    vec2 stNext = vec2(0.0);\n    if (dcorner > 62.0) {\n        // On the cube faces, add density noise at 0 temperature\n        float noiseVal = 0.0;\n\n        if (absd.x > 62.0) {\n            noiseVal = fbm(0.02*lmn.yz);\n        } else if (absd.y > 62.0) {\n            noiseVal = fbm(0.02*lmn.xz);\n        } else if (absd.z > 62.0) {\n            noiseVal = fbm(0.02*lmn.xy);\n        }\n\n        float modTime = mod(iTimeN, 12.0);\n        float dofull = 1.0 - step(0.64, abs(modTime-3.0));\n        float doempty = 1.0 - step(0.45, abs(modTime-6.0));\n\n        float dNext = 2.0*pow(noiseVal, 3.);\n        dNext = mix(dNext, 0.5, mix(0.0, 0.8, dofull));\n        dNext = mix(dNext, 0.0, mix(0.0, 0.8, doempty));\n\n        stNext = vec2(dNext, 0.0);\n\n    } else {\n        // On the interior: shrink, rotate, increase density, and lower temperature\n        vec3 dlmn = lmn - mid;\n\n        float axisAng = 0.5*iTimeN;\n        vec3 nvAxis = normalize( vec3(cos(axisAng),0.0,sin(axisAng)) );\n\n        mat3 mr = glRotate(nvAxis, 0.075*cos(iTimeN));\n        vec3 dlmnrot = mr * dlmn;\n        vec3 lmnrot = mid + dlmnrot;\n\n        float mamt = -0.0025;\n        vec3 next = mix(lmnrot, mid, mamt);\n\n        vec2 stOld = getDataInterp(next);\n        stNext = vec2( stOld.s*1.05, stOld.t*0.99 );\n    }\n\n    // Mouse input\n    //---------------------------------------\n    // Punch a hole along entry-exit axis, setting density 0 and temperature 1 (max)\n    vec4 entry = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 exit = texelFetch(iChannel1, ivec2(1,0), 0);\n\n    if (entry.a > 0.5 && exit.a > 0.5) {\n        vec3 lmnEntry = BOX_N * entry.xyz;\n        vec3 lmnExit = BOX_N * exit.xyz;\n\n        float dHole = sdLine(lmnEntry, lmnExit, lmn);\n        stNext = mix(\n            vec2(0.0, 1.0),\n            stNext,\n            smoothstep(10.0, 16.0, dHole)\n        );\n    }\n    //---------------------------------------\n\n    fragColor = vec4(stNext, 0.0, 0.0);\n}\n\n// -----------------------------------------\n// Check if level surface at DENSITY_THRESH\n// -----------------------------------------\n\n// NOTE: These pixels refer to the voxel volumes,\n// not the corner points as in page 1.\n\nvoid doPage2(out vec4 fragColor, in vec3 lmn)\n{\n    vec2 data0 = getDataNearest(lmn);\n\n    float h000 = data0.s;\n    float h001 = getDataNearest( lmn + vec3(0.0, 0.0, 1.0) ).s;\n    float h010 = getDataNearest( lmn + vec3(0.0, 1.0, 0.0) ).s;\n    float h011 = getDataNearest( lmn + vec3(0.0, 1.0, 1.0) ).s;\n    float h100 = getDataNearest( lmn + vec3(1.0, 0.0, 0.0) ).s;\n    float h101 = getDataNearest( lmn + vec3(1.0, 0.0, 1.0) ).s;\n    float h110 = getDataNearest( lmn + vec3(1.0, 1.0, 0.0) ).s;\n    float h111 = getDataNearest( lmn + vec3(1.0, 1.0, 1.0) ).s;\n\n    // Check if at least one of the values is beyond threshold\n    float solid = (\n        step(DENSITY_THRESH, h000) + step(DENSITY_THRESH, h001) +\n        step(DENSITY_THRESH, h010) + step(DENSITY_THRESH, h011) +\n        step(DENSITY_THRESH, h100) + step(DENSITY_THRESH, h101) +\n        step(DENSITY_THRESH, h110) + step(DENSITY_THRESH, h111)\n    ) / 8.0;\n\n    // Also record the density/temp here, so it's not off by a frame\n    fragColor = vec4(data0, 0.0, solid);\n}\n\n// ---------------------------------------\n// Compute normals at voxel corner points\n// ---------------------------------------\n\n#define GD 2.0\n\nvoid doPage3(out vec4 fragColor, in vec3 lmn)\n{\n    // Compute normal\n    float hLA = getDataNearest( lmn + vec3(-GD,  0.0,  0.0) ).s;\n    float hLB = getDataNearest( lmn + vec3( GD,  0.0,  0.0) ).s;\n    float hMA = getDataNearest( lmn + vec3( 0.0, -GD,  0.0) ).s;\n    float hMB = getDataNearest( lmn + vec3( 0.0,  GD,  0.0) ).s;\n    float hNA = getDataNearest( lmn + vec3( 0.0,  0.0, -GD) ).s;\n    float hNB = getDataNearest( lmn + vec3( 0.0,  0.0,  GD) ).s;\n\n    vec3 gradA = vec3(hLB-hLA, hMB-hMA, hNB-hNA);\n    vec3 normal = 0.5 + 0.5*(-gradA/(length(gradA) + 1e-5));\n\n    fragColor = vec4(normal, 0.0);\n}\n\n// -------------------------------------\n// Determine what to do based on rayDir\n// -------------------------------------\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)\n{\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        doPage1(fragColor, lmn);\n    } else if (pageDst == 2) {\n        doPage2(fragColor, lmn);\n    } else if (pageDst == 3) {\n        doPage3(fragColor, lmn);\n    }\n}\n","name":"Cube A","description":"","type":"cubemap"}]}