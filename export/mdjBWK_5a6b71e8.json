{"ver":"0.1","info":{"id":"mdjBWK","date":"1690217266","viewed":171,"name":"Triangle Barycentric Coordinates","username":"beans_please","description":"This started as a 4 AM question: \"How do vertex attributes get interpolated in a fragment shader?\"\nThe Wikipedia page for Barycentric Coordinates was too complicated for me, so hopefully this is easier to und.\nhttps://www.desmos.com/calculator/8g8xjejuox\n","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["2d","triangle","barycentric","linear","matrix","interpolation","vectors","matrices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\n// Basically |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 barycentric2cart(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\n// https://www.desmos.com/calculator/8g8xjejuox\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    return b;\n}\n\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2, bool clamped, out bool outside)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    outside = min(min(b.x, b.y), b.z) < 0.0;\n    if (clamped)\n    {\n        b = max(b, 0.0);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid get_vertices(out vec2 v0, out vec2 v1, out vec2 v2)\n{\n    v0 = vec2(random() - 0.5, random() - 0.5);\n    v1 = vec2(random() - 0.5, random() - 0.5);\n    v2 = vec2(random() - 0.5, random() - 0.5);\n    \n    v0 = mix(v0, 1.3 * vec2(0.0, 0.4), 0.6);\n    v1 = mix(v1, 1.3 * vec2(-0.5, -0.3), 0.6);\n    v2 = mix(v2, 1.3 * vec2(0.5, -0.3), 0.6);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Time stuff\n    const float speed = 1.7;\n    float ti = floor(iTime * speed);\n    float tfrac = fract(iTime * speed);\n    \n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Triangle vertices\n    vec2 v0, v1, v2,\n        v0a, v0b,\n        v1a, v1b,\n        v2a, v2b;\n    {\n        prng_init(vec3(ti, 1.0, 2.0));\n        get_vertices(v0a, v1a, v2a);\n        \n        prng_init(vec3(ti + 1.0, 1.0, 2.0));\n        get_vertices(v0b, v1b, v2b);\n        \n        float t = smoothstep(0.0, 1.0, tfrac);\n        v0 = mix(v0a, v0b, t);\n        v1 = mix(v1a, v1b, t);\n        v2 = mix(v2a, v2b, t);\n    }\n    \n    // Get barycentric coords\n    bool outside;\n    vec3 col = cart2barycentric(uv, v0, v1, v2, true, outside);\n    \n    // Darken the outer areas\n    if (outside)\n    {\n        col *= cos(TAU * speed * 0.1 * iTime) * 0.45 + 0.55;\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 0\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n","name":"Common","description":"","type":"common"}]}