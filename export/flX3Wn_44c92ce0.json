{"ver":"0.1","info":{"id":"flX3Wn","date":"1622587279","viewed":99,"name":"Circular Waves - 2d SDF","username":"eurigilberto","description":"Just a little test to see how to make a 2d sdf look like a 3d object by creating a 3d normal from the 2d sdf and applying a simple diffuse plus ambient lighting to it.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define xCenter (iResolution.x/iResolution.y)/2.\n#define yCenter (iResolution.y/iResolution.y)/2.\n\nfloat easeInOutCirc(float x) {\n    return x < 0.5\n      ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n      : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat easeOutBack(float x){\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}\n\nfloat easeInOutBack(float x){\n    float c1 = 5.;//prev 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat easeInBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}//from https://iquilezles.org/articles/distfunctions/distfunctions.htm\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}//from https://iquilezles.org/articles/distfunctions/distfunctions.htm\n    \nfloat distortion(vec2 p, float mult, vec2 timeMult, float yMult){\n    return sin(mult * p.x + sin(iTime * timeMult.x + p.y * yMult)) + cos(mult * p.y + iTime * timeMult.y);\n}\n\nfloat InvLerp( float a, float b, float v){\n    return (v - a)/(b - a);\n}\n\nfloat circle_sdf(vec2 p, vec2 center, float rad){\n    float dist = length(p - center) - rad;\n    return dist;\n}\n\nfloat fluid_sdf(vec2 p){\n    float d = distortion(p, 20., vec2(5., 10.), 10.) * 0.01;\n    \n    float circle1 = circle_sdf(p, vec2(xCenter,yCenter), 0.25) + d;\n    \n    \n    float duration = 3.;\n    float dropAnimTime = mod(iTime, duration)/duration;\n    //dropAnimTime = easeInOutBack(dropAnimTime);\n    \n    float yPosChange;\n    float sizeChange;\n    float dMultiplier;\n    \n    //dropAnimTime = 1.2;\n    \n    if(dropAnimTime < 0.5){\n        float animT = dropAnimTime/0.5;\n        animT = easeInOutBack(animT);\n        \n        yPosChange = mix(yCenter * 0.4, yCenter, animT);\n        sizeChange = abs(mix(0.1, 0.15, animT));\n        dMultiplier = animT;\n    }else{\n        float animT = (dropAnimTime - 0.5)/0.5;\n        animT = easeInOutBack(animT);\n        \n        yPosChange = mix(yCenter, yCenter * 0.4, animT);\n        sizeChange = abs(mix(0.15, 0.1, animT));\n        dMultiplier = 1.-animT;\n    }\n    \n    float dropDistortion = distortion(p, 20., vec2(20., 2.), 2.);\n    \n    float circle2 = circle_sdf(p, vec2(xCenter,yPosChange), sizeChange) + d;\n    \n    return sminCubic(circle1, circle2, mix(0.2, 0.6, dMultiplier));\n}\n\nfloat sMinFluidSDF(vec2 p){\n    return fluid_sdf(p);// sminCubic(fluid_sdf(p), -0.07, 0.002);\n}\n\nvec3 fluidNormal(vec2 p, float minVal){\n    float epsilon = 0.05;\n\n    vec2 right = vec2(epsilon, 0);\n    vec2 up = vec2(0, epsilon);\n    \n    float center = sMinFluidSDF(p); \n    float north = sMinFluidSDF(p + up);\n    float south = sMinFluidSDF(p - up);\n    float east = sMinFluidSDF(p + right);\n    float west = sMinFluidSDF(p - right);\n    \n    float xAxis = east - west;\n    float yAxis = north - south;\n    \n    return normalize(vec3(xAxis, yAxis, center * 1.0));\n}\n\nvec3 directionalLight(vec3 lightDir, vec3 lightColor, vec3 normal, float bands){\n    float light = dot(normal, lightDir);\n    light = InvLerp(-0.4, 1., light);\n    light = bands == 0. ? light : round(light * bands)/bands;\n    \n    return lightColor * clamp(light, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float circle = fluid_sdf(uv);\n    float step_circle = step(0., circle);\n    \n    if(step_circle < 0.5){\n        vec3 normal = fluidNormal(uv, -0.1);\n        \n        float bands = 0.;\n        \n        vec3 lightDir1 = normalize(vec3(1,1,0));\n        vec3 light1 = directionalLight(lightDir1, vec3(1,1,1), normal, bands);\n        \n        //vec3 lightDir2 = normalize(vec3(0,-1,0));\n        //vec3 light2 = directionalLight(lightDir2, vec3(0.1,0.6,0.9), normal, bands);\n        \n        vec3 light2 = vec3(0.1,0.1,1.) * 0.4;\n        \n        vec3 color = vec3(0.1,1,0.5) * ((light1 + light2));\n        //vec3 color = vec3(0.1,1,0.5) * light1;\n        \n        //fragColor = vec4(sin(circle * 100.));\n        //fragColor = vec4(rawX*100.,rawY*100.,-circle * 2., 1);\n        fragColor = vec4(color.xyz,1);\n    }else{\n        fragColor = vec4(0);\n    }\n}","name":"Image","description":"","type":"image"}]}