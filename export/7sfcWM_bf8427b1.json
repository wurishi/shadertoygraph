{"ver":"0.1","info":{"id":"7sfcWM","date":"1642153266","viewed":137,"name":"Lights and Texture Mapping","username":"PGRacer","description":"Added support for multiple lights and locking textures to moving objects to my marcher.\nWASD, shift, space to move.","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","sdf","lighting","textures","lights","texturing"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////\n// IMAGE SHADER //\n//////////////////\n\nint MAT0 = 0;\nint MAT1 = 1;\nint MAT2 = 2;\nint MAT3 = 3;\n\nSDFSample Scene(vec3 p)\n{\n    vec3 pBox = RotateY(PI) * (p - vec3(-1.0, -0.0, 0.0));\n    SDFSample dBox = Box(pBox, vec3(0.25, 2.0, 2.0));\n    \n    vec3 pFrame1 = RotateY(PI) * (p - vec3(-1.0, -0.75, 0.0));\n    SDFSample dFrame1 = BoxFrame(pFrame1, vec3(0.2, 0.3, 1.05), 0.001);\n    dFrame1.d -= 0.025;\n    dFrame1.matID = MAT1;\n    \n    vec3 pFrame2 = RotateY(PI) * (p - vec3(-1.0, 0.30, 0.0));\n    SDFSample dFrame2 = BoxFrame(pFrame2, vec3(0.2, 0.74, 1.05), 0.001);\n    dFrame2.d -= 0.025;\n    dFrame2.matID = MAT1;\n    \n    vec3 pTorus1 = RotateZ(TIME) * (p - UP * 0.25);\n    SDFSample dTorus1 = Torus(pTorus1, 0.5, 0.1);\n    \n    vec3 pSphere1 = p - vec3(0.0, 0.25 + sin(TIME), 0.0);\n    SDFSample dSphere1 = Sphere(pSphere1, 0.2);\n    dSphere1.matID = MAT1;\n    \n    vec3 pSphere2 = p - vec3(cos(TIME), 0.25, 0.0);\n    SDFSample dSphere2 = Sphere(pSphere2, 0.2);\n    dSphere2.matID = MAT1;\n    \n    vec3 pCylinder = (p - vec3(1.3, -0.75, 0.0));\n    SDFSample dCylinder = Cylinder(pCylinder, 1.0, 0.2);\n    dCylinder.matID = MAT1;\n    \n    vec3 pCylinder2 = pCylinder - UP * 0.65;\n    SDFSample dCylinder2 = Cylinder(pCylinder2, 0.15, 0.15);\n    dCylinder2.matID = MAT1;\n    \n    dCylinder = SmoothUnion(dCylinder, dCylinder2, 0.4);\n    \n    vec3 pTorus2 = RotateY(TIME * 8.0) * (p - RIGHT * 1.3) - vec3(0.2, -0.68, 0.0);\n    SDFSample dTorus2 = Torus(pTorus2, 0.5, 0.1);\n    \n    vec3 pTorus3 = RotateY(-TIME * 8.0) * (p - RIGHT * 1.3) - vec3(0.2, -0.48, 0.0);\n    SDFSample dTorus3 = Torus(pTorus3, 0.5, 0.1);\n    \n    vec3 pPlatform = (p - DOWN);\n    SDFSample dPlatform = Cylinder(pPlatform, 0.000001, 4.0);\n    dPlatform.d -= 0.025;\n    dPlatform.matID = MAT2;\n    \n    SDFSample platformBlend = SmoothUnion(dPlatform, dCylinder, .5);\n    platformBlend = SmoothUnion(platformBlend, dSphere1, 0.5);\n    dBox = Difference(dBox, dSphere2, 0.25);\n    \n    SDFSample dist = Union(dBox, dFrame1);\n    dist = Union(dist, dFrame2);\n    dist = Union(dist, dTorus1);\n    dist = Union(dist, dSphere2);\n    dist = Union(dist, platformBlend);\n    dist = Union(dist, dTorus2);\n    dist = Union(dist, dTorus3);\n    \n    return dist;\n}\n\nvec3 GetNormal(SDFSample s)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n    \n\tvec3 n = Scene(s.pW).d - vec3(\n\t\tScene(s.pW - e.xyy).d,\n\t\tScene(s.pW - e.yxy).d,\n\t\tScene(s.pW - e.yyx).d\n\t\t);\n\treturn normalize(n);\n}\n\nfloat GetAO(SDFSample s, vec3 n)\n{\n    float stepSize = AMBIENT_OCCLUSION_STEP_SIZE;\n    float t = stepSize;\n\n    float ac = 0.0;\n\n    for(float i = 0.0; i < AMBIENT_OCCLUSION_STEP_COUNT; i++) {\n        float d = Scene(s.pW + n * t).d;\n        ac += t - d;\n        t += stepSize;\n    }\n    return 1.0 - ac / 2.0;\n}\n\nfloat GetShadows(vec3 ro, vec3 rd, float tMax)\n{\n    float res = 1.0;\n    float t = SHADOW_CORRECTION;\n    for( int i=0; i<50; i++ )\n    {\n        float h = Scene(ro + rd * t).d;\n        res = min( res, tMax*h/t );\n        t += h;clamp( h, 0.005, 0.5 );\n        if( res<0.005 || t>tMax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nSDFSample GetSurface(vec3 origin, vec3 rayDir, out float distFromOrigin, out bool hit, out bool outline)\n{\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    vec3 p;\n    float prevDist = MAX_DIST;\n    SDFSample s;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = origin + rayDir * distFromOrigin;\n\t\ts = Scene(p);\n\t\tdistFromOrigin += s.d;\n        \n        if (s.d < outlineWidth * pow(distFromOrigin, OUTLINE_DIST_COMP))\n\t\t{\n\t\t\toutline = true;\n\t\t}\n        \n        if (distFromOrigin >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s.d < SURFACE_DISTANCE_TOLERANCE)\n\t\t{\n            hit = true;\n\t\t\toutline = false;\n            s.pW = p;\n\t\t\tbreak;\n\t\t}\n        \n        if (outline && prevDist < s.d)\n        {\n            hit = false;\n            break;\n        }\n        \n        prevDist = s.d;\n    }\n    \n    return s;\n}\n\nvec3 GetLight(SDFSample s, LightSource ls, float ao, vec3 normal)\n{\n    vec3 lightDir = normalize(s.pW - ls.pos);\n\n    float lightDist = distance(s.pW, ls.pos);\n    float shadowValue = GetShadows(s.pW, -lightDir, lightDist);\n\n    float directAttenuation = 1.0 / (pow(lightDist, 2.0));\n    float light = ls.str * directAttenuation;\n\n    float scalar = dot(-lightDir, normal);\n    float specular = SPECULAR_POWER * pow(scalar, SPECULAR_FOCUS);\n    light += specular;\n    scalar = clamp(scalar, 0.0, 1.0);\n     \n    light *= scalar;\n    light *= shadowValue;\n    light += ao * ls.str * directAttenuation;   \n        \n    return light * ls.col;\n}\n\nvec3 GetTriPlanarTexture(vec3 p, vec3 normal, sampler2D sampler)\n{\n    vec3 texXY = texture(sampler, p.xy * 0.5 + 0.5).rgb;\n    vec3 texXZ = texture(sampler, p.xz * 0.5 + 0.5).rgb;\n    vec3 texYZ = texture(sampler, p.yz * 0.5 + 0.5).rgb; \n        \n    normal = abs(normal);\n    normal = pow(normal, vec3(1.0));\n    normal /= SumComponents(normal);\n    \n    vec3 tex = texXY * normal.z + texXZ * normal.y + texYZ * normal.x;\n    \n    return tex;\n}\n\nvec3 GetColor(SDFSample s, vec3 normal)\n{\n    if (s.matID == MAT0)\n    {\n        return GetTriPlanarTexture(s.pO * 1.0, normal, iChannel1);\n    }\n    if (s.matID == MAT1)\n    {\n        return GetTriPlanarTexture(s.pO * 10.0, normal, iChannel2);\n    }\n    if (s.matID == MAT2)\n    {\n        return GetTriPlanarTexture(s.pO * 2.0, normal, iChannel3);\n    }\n}\n\nvec3 ColorCorrection(vec3 color)\n{\n    if (COLOR_BIT_DEPTH < 8.0)\n    {\n        float colorsPerChannel = pow(2.0, COLOR_BIT_DEPTH);\n        color = floor(color * colorsPerChannel) / colorsPerChannel;\n    }\n    \n    color = (color - vec3(0.5)) * CONTRAST + vec3(0.5);\n    color = pow(color / 255.0, vec3(1.0 / GAMMA)) * 255.0;\n    color = mix(vec3(AvgComponentLength(color)), color, SATURATION);\n    color = mix(color, vec3(1.0) - color, NEGATIVE);\n    color *= TINT;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter resolution for old-school look\n    fragCoord *= RESOLUTION_RATIO;\n    fragCoord = floor(fragCoord) / RESOLUTION_RATIO;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split-screen stereoscopy\n#ifdef STEREO_ENABLED\n    bool leftEye = uv.x >= 0.5;\n    uv.x = fract(uv.x * 2.0);\n    uv.x *= 0.5;\n    uv -= vec2(0.25, 0.5);\n#else\n    uv -= vec2(0.5);\n#endif\n\n    // Vignette\n    float uvLength = length(uv);\n    uvLength = uvLength * 1.33333 - .25;\n    float vignette = smoothstep(0.99, 0.001, uvLength);\n    \n    // Aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Camera Stuff\n    vec3 camPos = textureLod(iChannel0, vec2(0.5, 0.5)/iResolution.xy, 0.0).xyz;\n\n    // Camera look direction\n    vec3 camRot = textureLod(iChannel0, vec2(1.5, 0.5)/iResolution.xy, 0.0).xyz;\n    mat3x3 yawMat = Rotate3(camRot.x, UP);\n    mat3x3 pitchMat = Rotate3(camRot.y, RIGHT);\n    mat3x3 rollMat = Rotate3(camRot.z, FORWARD);\n    mat3x3 rotMat = yawMat * pitchMat * rollMat;\n    vec3 camDir = rotMat * normalize(vec3(uv.x, uv.y, 1.0));\n    \n#ifdef STEREO_ENABLED\n    // Stereo eye-positioning\n    camPos += rotMat * ((leftEye ? LEFT : RIGHT) * INTERPUPILARY_DISTANCE * 0.5);\n#endif\n    \n    // Do raymarching\n    float distFromOrigin = 0.0;\n    bool hit;\n\tbool outline;\n    float prevDist = MAX_DIST * MAX_DIST;\n\n    SDFSample s = GetSurface(camPos, camDir, distFromOrigin, hit, outline);\n    \n    // Background\n    vec3 bgColor = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), smoothstep(-1.0, -.25, -abs(camDir.y)));\n    vec3 color = WHITE;\n    \n    float distRatio = distFromOrigin / MAX_DIST;\n    \n    // Apply color to pixel\n    if (hit)\n    {\n        vec3 normal = GetNormal(s);\n        color = GetColor(s, normal);\n        float ao = GetAO(s, normal);\n        \n        LightSource ls1 = LightSource(RotateY(TIME * 1.0) * vec3(25.0, 20.0, -25.0), RED + GREEN, 500.0);\n        LightSource ls2 = LightSource(RotateY(TIME * 0.75) * vec3(18.0, 18.0, -35.0), GREEN + BLUE, 500.0);\n        LightSource ls3 = LightSource(RotateY(TIME * 0.5) * vec3(18.0, 18.0, -35.0), BLUE + RED, 500.0);\n        \n        vec3 light = GetLight(s, ls1, ao, normal);\n        light += GetLight(s, ls2, ao, normal);\n        light += GetLight(s, ls3, ao, normal);\n        \n        color *= light;\n    }\n    else if (outline)\n    {\n        color = vec3(0.0);\n    }\n    else\n    {\n        color = bgColor;\n    }\n    \n    // Saturate and apply distance fade\n    color = clamp(color, vec3(0.0), vec3(1.0));\n    color = mix(color, bgColor, pow(distRatio, FADE_ATTENUATION));\n    \n    // Apply color correction\n    color = ColorCorrection(color);\n    \n#ifdef SCAN_LINES_ENABLED\n    if (mod(fragCoord.y * RESOLUTION_RATIO, 2.0) < 1.0) color = BLACK;\n#endif\n    \n    // Fade scene in at start\n    color *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    color *= vignette;\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 2000\n#define MAX_DIST 10.0\n#define SURFACE_DISTANCE_TOLERANCE 0.0001\n#define NORMAL_CHECK_OFFSET 0.0001\n\n// TIMING\n#define TIME iTime * 1.0\n\n// OUTLINE\n#define OUTLINE_WIDTH 6.0\n#define OUTLINE_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define FADE_ATTENUATION 4.0\n#define SPECULAR_POWER 1.0\n#define SPECULAR_FOCUS 2.0\n#define AMBIENT_STRENGTH 0.75\n#define AMBIENT_OCCLUSION_STEP_SIZE 0.006\n#define AMBIENT_OCCLUSION_STEP_COUNT 20.0\n#define AMBIENT_OCCLUSION_ATTENUATION 1.0\n#define SHADOW_CORRECTION 0.000001\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define TAU 6.283185\n#define PI  TAU / 2.0\n#define ROOT2 1.414213\n\n// AXIAL VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// COLORS\n#define BLACK vec3(0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define BROWN vec3(0.5, 0.2, 0.0)\n#define DARK_GREY vec3(0.25, 0.25, 0.25)\n#define FUCHSIA vec3(1.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define LIGHT_GREY vec3(0.75, 0.75, 0.75)\n#define MEDIUM_GREY vec3(0.5, 0.5, 0.5)\n#define ORANGE vec3(1.0, 0.5, 0.0)\n#define PINK vec3(1.0, 0.5, 0.5)\n#define RED vec3(1.0, 0.0, 0.0)\n#define TURQOISE vec3(0.0, 1.0, 1.0)\n#define WHITE vec3(1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n// COLOR CORRECTION\n#define COLOR_BIT_DEPTH 8.0\n#define GAMMA 1.0\n#define CONTRAST 1.0\n#define SATURATION 1.0\n#define NEGATIVE 0.0\n#define TINT WHITE\n\n// RENDERING OPTIONS\n//#define STEREO_ENABLED // Comment/Uncomment to disable/enable. Use cross-eye method to view.\n#define INTERPUPILARY_DISTANCE 1.0 // Not a real world measurment. Maybe in the future.\n//#define SCAN_LINES_ENABLED // Comment/Uncomment to disable/enable.\n#define RESOLUTION_RATIO 1.0 // 0.0 will result in divide-by-zero, magnitude 1.0+ will have no effect.  negative values will shift pixels (-1,-1).\n\n// INPUT KEYS\n#define KEY_SHIFT   16\n#define KEY_CONTROL 17\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_A       65\n#define KEY_B       66\n#define KEY_C       67\n#define KEY_D       68\n#define KEY_E       69\n#define KEY_F       70\n#define KEY_G       71\n#define KEY_H       72\n#define KEY_I       73\n#define KEY_J       74\n#define KEY_K       75\n#define KEY_L       76\n#define KEY_M       77\n#define KEY_N       78\n#define KEY_O       79\n#define KEY_P       80\n#define KEY_Q       81\n#define KEY_R       82\n#define KEY_S       83\n#define KEY_T       84\n#define KEY_U       85\n#define KEY_V       86\n#define KEY_W       87\n#define KEY_X       88\n#define KEY_Y       89\n#define KEY_Z       90\n#define KEY_0       48\n#define KEY_1       49\n#define KEY_2       50\n#define KEY_3       51\n#define KEY_4       52\n#define KEY_5       53\n#define KEY_6       54\n#define KEY_7       55\n#define KEY_8       56\n#define KEY_9       57\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// MATRICES\nmat2x2 Rotate2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat3x3 Rotate3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\nmat3 RotateX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\nmat3 RotateY(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 RotateZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\n// USEFUL MATH STUFF\nfloat SumComponents(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\nfloat SumComponentLength(vec3 v)\n{\n    return SumComponents(abs(v));\n}\n\nfloat AvgComponents(vec3 v)\n{\n    return (v.x + v.y + v.z) / 3.0;\n}\n\nfloat AvgComponentLength(vec3 v)\n{\n    return AvgComponents(abs(v));\n}\n\nfloat NSin(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat NCos(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\nfloat SFract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 SFract(vec2 v)\n{\n    return vec2(SFract(v.x), SFract(v.y));\n}\n\nvec3 SFract(vec3 v)\n{\n    return vec3(SFract(v.xy), SFract(v.z));\n}\n\nfloat SMod(float v, float x)\n{\n    return x == 0.0 ? v : SFract(v / x) * x;\n}\n\nvec2 SMod(vec2 v, vec2 x)\n{\n    return vec2(SMod(v.x, x.x), SMod(v.y, x.y));\n}\n\nvec3 SMod(vec3 v, vec3 x)\n{\n    return vec3(SMod(v.xy, x.xy), SMod(v.z, x.z));\n}\n\nvec3 FlipX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 FlipY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 FlipZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 AbsX(vec3 p)\n{\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 AbsY(vec3 p)\n{\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 AbsZ(vec3 p)\n{\n    return vec3(p.x, p.y, abs(p.z));\n}\n\nvec3 AbsXY(vec3 p)\n{\n    return vec3(abs(p.x), abs(p.y), p.z);\n}\n\nvec3 AbsXZ(vec3 p)\n{\n    return vec3(abs(p.x), p.y, abs(p.z));\n}\n\nvec3 AbsYZ(vec3 p)\n{\n    return vec3(p.x, abs(p.y), abs(p.z));\n}\n\nvec3 NegateX(vec3 p)\n{\n    return vec3(-abs(p.x), p.y, p.z);\n}\n\nvec3 NegateY(vec3 p)\n{\n    return vec3(p.x, -abs(p.y), p.z);\n}\n\nvec3 NegateZ(vec3 p)\n{\n    return vec3(p.x, p.y, -abs(p.z));\n}\n\n// STRUCTS\nstruct SDFSample\n{\n    float d;\n    vec3 pO;\n    vec3 pW;\n    int matID;\n};\n\nstruct LightSource\n{\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Material\n{\n    vec3 col;\n    float metallic;\n    float smoothness;\n};\n\n// COMBINATIONS\nSDFSample Union(SDFSample d1, SDFSample d2)\n{\n    if (d1.d < d2.d) return d1; return d2;\n}\n\nSDFSample SmoothUnion(SDFSample d1, SDFSample d2, float smoothing)\n{\n    float h = clamp(0.5 + 0.5 * (d2.d - d1.d) / smoothing, 0.0, 1.0);\n    return SDFSample(mix(d2.d, d1.d, h) - smoothing * h * (1.0 - h), d1.d < d2.d ? d1.pO : d2.pO, d1.pW, d1.d < d2.d ? d1.matID : d2.matID);\n}\n\nSDFSample Difference(SDFSample d1, SDFSample d2, float c)\n{\n    float clearance = d2.d - c;\n    return SDFSample(d1.d > -clearance ? d1.d : -clearance, d1.pO, d1.pW, d1.matID);\n}\n\nSDFSample SmoothDifference(SDFSample d1, SDFSample d2, float smoothing) {\n    float h = max(smoothing - abs(-d2.d - d1.d), 0.0);\n    return SDFSample(max(d1.d, -d2.d) + h * h  *0.25 / smoothing, d1.pO, d1.pW, d1.matID);\n}\n\nSDFSample Intersection(SDFSample d1, SDFSample d2)\n{\n    return SDFSample(d1.d > d2.d ? d1.d : d2.d, d1.pO, d1.pW, d1.d > d2.d ? d2.matID : d1.matID);\n}\n\nSDFSample SmoothIntersection(SDFSample d1, SDFSample d2, float smoothing) {\n    float h = clamp(0.5 - 0.5 * (d2.d - d1.d) / smoothing, 0.0, 1.0);\n    return SDFSample(mix(d2.d, d1.d, h) + smoothing * h * (1.0 - h), d1.pO, d1.pW, d1.d > d2.d ? d2.matID : d1.matID);\n}\n\n// DISTORTIONS\nvec3 Twist(vec3 p, float twist)\n{\n    float c = cos(twist * p.y);\n    float s = sin(twist * p.y);\n    mat2  m = mat2(c, -s ,s, c);\n    vec2 pT = m*p.xz;\n    vec3  q = vec3(pT.x, p.y, pT.y);\n    return q;\n}\n\nvec3 Bend(vec3 p, float bend)\n{\n    float c = cos(bend * p.x);\n    float s = sin(bend * p.x);\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec4 Elongate(vec3 p, vec3 h)\n{   \n    // Usage: dist = min(dist, w.w+DistFunc(w.xyz, ... ) );\n    // Where w is the output of this function\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat Layer(float d, float h)\n{\n    return abs(d) - h;\n}\n\n// Repetitions\nvec3 RepeatRange(in vec3 p, in vec3 c, in vec3 l)\n{\n    p -= c * 0.5 * (1.0 - mod(l, 2.0));\n    return p - c * (clamp(round(p / c), ceil(-l * 0.5), ceil(l * 0.5) - vec3(1.0)));\n}\n\nvec3 RepeatInfinite(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat Extrusion(vec3 p, float d, float h)\n{\n    vec2 w = vec2(d, abs(p.y) - h * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 2D PRIMITIVES\nvec2 Circle(vec3 p, float r)\n{\n    return vec2(length(vec2(p.x, p.z)) - r, 0.0);\n}\n\nfloat Star5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// 3D PRIMITIVES - Mostly adapted from https://iquilezles.org/articles/distfunctions\nSDFSample SquareColumn(vec3 p, vec2 d)\n{\n    p = abs(p);\n    return SDFSample(max(p.x - d.x / 2.0, p.z - d.y / 2.0), p, p, 0);\n}\n\nSDFSample Sphere(vec3 p, float r)\n{\n\treturn SDFSample(length(p) - r, p, p ,0);\n}\n\nSDFSample Disk(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, p, 0);\n}\n\nSDFSample Capsule(vec3 p, float h, float r)\n{\n\tvec3 a = vec3(0.0, h * 0.5, 0.0);\n\tvec3 b = vec3(0.0, -h * 0.5, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn SDFSample(length(p - c) - r, p, p, 0);\n}\n\nSDFSample Cylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);\n  return SDFSample(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), p, p, 0);\n}\n\nSDFSample Tube(vec3 p, float h, float r, float t)\n{\n    float dHoop = abs(Circle(p, r).x) - t;\n    return SDFSample(Extrusion(p, dHoop, h), p, p, 0);\n}\n\nSDFSample Torus(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, p, 0);\n}\n\nSDFSample Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return SDFSample(abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width, p, p, 0);\n}\n\nSDFSample Box(vec3 p, vec3 dimensions)\n{\n\treturn SDFSample(length(max(abs(p) - (0.5 * dimensions), 0.0)), p, p, 0);\n}\n\nSDFSample BoxFrame(vec3 p, vec3 b, float e)\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  float minimum = min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n      \n      return SDFSample(minimum, p, p, 0);\n}\n\nSDFSample Plane(vec3 p)\n{\n    return SDFSample(abs(p.y), p, p, 0);\n}\n\nSDFSample InfiniteCone(vec3 p, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(p.xz), -p.y);\n    float d = length(q - c * max(dot(q, c), 0.0));\n    return SDFSample(d * ((q.x * c.y - q.y * c.x < 0.0) ? -1.0 : 1.0), p, p, 0);\n}\n\nSDFSample CappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return SDFSample(s*sqrt( min(dot(ca,ca),dot(cb,cb)) ), p, p, 0);\n}\n\n// Slicing\nfloat SliceXZ(vec3 p, float d)\n{\n    return max(abs(p.y), d);\n}\n\nfloat SliceXY(vec3 p, float d)\n{\n    return max(abs(p.z), d);\n}\n\nfloat SliceYZ(vec3 p, float d)\n{\n    return max(abs(p.x), d);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////\n// INPUT SHADER //\n//////////////////\n\n// CAMERA PARAMETERS\n#define INIT_CAM_POS vec3(1.7, 1.0, -2.8)\n#define INIT_CAM_YAW 0.5\n#define INIT_CAM_PITCH -0.32\n#define INIT_CAM_ROLL 0.0\n#define ROTATION_SPEED 8.0\n#define BASE_MOVE_SPEED 2.0\n#define MOVE_ACCELERATION 1.01\n\n// UPDATE AND RECORD INPUT\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (int(fragCoord.y) == 0 )\n    {\n        if (int(fragCoord.x) <= 1)\n        {\n            // CAMERA CONTROLS\n            vec4 camPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy, -100.0);\n            vec4 camRot = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0).xy;\n            \n            float yawAngle = camRot.x - ROTATION_SPEED * mousePosData.x / iResolution.x;\n            float pitchAngle = clamp(camRot.y + ROTATION_SPEED * mousePosData.y / iResolution.y, -PI / 2.0, PI / 2.0);\n            float rollAngle = camRot.z;\n\n            //if (ReadKey(iChannel1, KEY_Q, false))\n            //{\n            //    rollAngle -= ROTATION_SPEED * iTimeDelta;\n            //}\n\n            //if (ReadKey(iChannel1, KEY_E, false))\n            //{\n            //    rollAngle += ROTATION_SPEED * iTimeDelta;\n            //}\n            \n            if (camRot.w == 0.0)\n            {\n                // ADD INIT ANGLES\n                yawAngle += INIT_CAM_YAW;\n                pitchAngle += INIT_CAM_PITCH;\n                rollAngle += INIT_CAM_ROLL;\n            }\n            \n            if (ReadKey(iChannel1, KEY_F, false))\n            {\n                rollAngle = 0.0;\n            }\n            \n            if (int(fragCoord.x) == 0)\n            {\n                // CAMERA POSITION\n                vec3 moveDir = vec3(0.0);\n                \n                mat3x3 yawMat = Rotate3(yawAngle, UP);\n                mat3x3 pitchMat = Rotate3(pitchAngle, RIGHT);\n                mat3x3 rollMat = Rotate3(rollAngle, FORWARD);\n                mat3x3 rotMat = yawMat * pitchMat * rollMat;\n                \n                float moveSpeed = camPos.w;\n                \n                if (camRot.w == 0.0)\n                {\n                    // SET INIT MOVE SPEED\n                    moveSpeed = BASE_MOVE_SPEED;\n                }\n                \n                // ACCELERATE/DECELERATE\n                if (ReadKey(iChannel1, KEY_UP, false))\n                {\n                    moveSpeed *= MOVE_ACCELERATION;\n                }\n                if (ReadKey(iChannel1, KEY_DOWN, false))\n                {\n                    moveSpeed /= MOVE_ACCELERATION;\n                }\n                \n                // MOVEMENT\n                if (ReadKey(iChannel1, KEY_W, false))\n                {\n                    moveDir += rotMat * FORWARD;\n                }\n                if (ReadKey(iChannel1, KEY_S, false))\n                {\n                    moveDir += rotMat * BACKWARD;;\n                }\n                if (ReadKey(iChannel1, KEY_A, false))\n                {\n                    moveDir += rotMat * LEFT;\n                }\n                if (ReadKey(iChannel1, KEY_D, false))\n                {\n                    moveDir += rotMat * RIGHT;\n                }\n                if (ReadKey(iChannel1, KEY_SPACE, false))\n                {\n                    moveDir += rotMat * UP;\n                }\n                if (ReadKey(iChannel1, KEY_SHIFT, false))\n                {\n                    moveDir += rotMat * DOWN;\n                }            \n\n                vec3 movement = vec3(0.0);\n                if (length(moveDir) > 0.0)\n                {\n                    movement = normalize(moveDir) * iTimeDelta * moveSpeed;\n                }\n\n                if (camRot.w == 0.0)\n                {\n                    // ADD INIT POSITION\n                    movement += INIT_CAM_POS;\n                }\n                \n                fragColor = vec4(camPos.xyz + movement, moveSpeed);\n            }\n            else\n            {                \n                // CAMERA ROTATION\n                fragColor = vec4(yawAngle, pitchAngle, rollAngle, 1.0); // w value 1.0 means no longer first frame\n            }\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            // MOUSE CLICK\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);            \n            fragColor = vec4(iMouse.z, mouseClickData.x, IsNewClick(mouseClickData.xy) || IsPersistentClick(mouseClickData.xy) ? iMouse.xy : vec2(0.0));\n        }\n        else if (int(fragCoord.x) == 3)\n        {\n            // MOUSE MOVEMENT\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);\n            vec4 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mouseDelta = IsPersistentClick(mouseClickData.zw) ? iMouse.xy - mouseClickData.zw : vec2(0.0);\n            vec2 mouseCumulative = mousePosData.zw + mouseDelta;\n            fragColor = vec4(mouseDelta, mouseCumulative);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}