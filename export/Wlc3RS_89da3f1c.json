{"ver":"0.1","info":{"id":"Wlc3RS","date":"1614120883","viewed":56,"name":"CHNTest","username":"CHN","description":"Test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define deg2rad(x) x/180.*3.1415\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothSB(vec3 pS, vec3 pB)\n{\n    return opSmoothUnion(sdSphere(pS,0.5),sdSphere(pB,0.5),1.5);\n}\nvec2 map(vec3 pos)\n{\n    vec2 res = vec2(20.,-1.);\n   \t/*{\n        float v = sdBox(pos-vec3(sin(iTime),cos(iTime),-0.5), vec3(.1));\n   \t\tif(v<res.x)res = vec2(v,1);\n    }\n    */\n    {\n        float v = sdSphere(pos-vec3(cos(iTime),sin(iTime),-1.), .4);\n   \t\tif(v<res.x)res = vec2(v,2);\n    }\n    { // PLANE\n        float v = dot(pos - vec3(0,-1.5,0),vec3(0,1,0));\n        if(v < res.x) res = vec2(v,4.);\n    }\n    {\n        //float v = smoothSB(pos-vec3(0,0,-1.0),pos-vec3((iMouse.x-iResolution.x/2.)/iResolution.x*6.,(iMouse.y-iResolution.y/2.)/iResolution.y*6.,-1.0));\n        //float v = smoothSB(pos-vec3(0,0,-1.0),pos-vec3(sin(iTime)*1.7,cos(iTime)*1.7,-1.0));\n        vec3 p = pos-vec3(0.,-0.5,-1.8);\n        //p = vec3(p.x * cos(iTime) - p.y * sin(iTime) ,p.x * sin(iTime) + p.y * cos(iTime),p.z);\n        float v = sdBox(p,vec3(.8));\n        if(v<res.x)res = vec2(v,3);\n    }\n    {\n        float v = sdSphere(pos-vec3(2.,0,-2.), 1.);\n   \t\tif(v<res.x)res = vec2(v,3);\n    }\n    {\n        if(res.x == 20.0)\n        {\n            res = vec2(20.0,0);\n        }\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float h = 0.00001; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map( p + k.xyy*h ).x + \n                      k.yyx* map( p + k.yyx*h ).x + \n                      k.yxy* map( p + k.yxy*h ).x + \n                      k.xxx* map( p + k.xxx*h ).x );\n}\nvec2 castRay( in vec3 ro, in vec3 rd,out vec3 nor,out vec3 pos)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i=0; i<3000 && t<tmax; i++ )\n    {\n    \tvec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n        \tres = vec2(t,h.y); \n            nor = calcNormal(ro+rd*t);\n            pos = ro+rd*t;\n            return res;\n        }\n        t += h.x;\n    }\n    return res;\n}\nfloat N21(vec2 v)\n{\n    return fract(sin(dot(v,vec2(52.27468,267.27986786))*617728.) * v.y * 15.23678);\n}\nmat3 rot(float x, float y, float z)\n{\n    return mat3(cos(z) * cos(y),sin(z),-sin(y),\n                  sin(z),cos(x) * cos(z),sin(x),\n                  sin(y),-sin(x),cos(x) * cos(y));\n}\nvec3 render(vec3 ro, vec3 rd,out vec3 nor,out vec3 pos,vec2 uv,vec3 lightPos,vec3 lightDir,vec2 res,inout int b)\n{\n    vec3 col = vec3(0);\n    b++;\n    //if(b > 0)return vec3(0);\n    res = castRay(ro,rd,nor,pos);\n    if(res.y == -1.)\n    {\n        col = vec3(0,0.4,0.6) * pow(abs(uv.y+1.),3.25) + vec3(1) * (1.-abs(uv.y));\n        col = clamp(col,0.,1.);\n    }\n    if(res.y == 1.)\n    {\n        float d = dot(normalize(vec3(cos(deg2rad(45.))*uv.x,sin(deg2rad(45.))*uv.y,-1.)),nor);\n        col = vec3(1,0,0) * dot(nor,lightDir);\n    }\n    if(res.y == 2.)\n    {\n        float d = dot(normalize(vec3(cos(deg2rad(45.))*uv.x,sin(deg2rad(45.))*uv.y,-1.)),nor);\n        col = vec3(1,0,0) * dot(nor,lightDir);\n    }\n    if(res.y == 3.)\n    {\n       // float d = dot(normalize(vec3(cos(deg2rad(45.))*uv.x,sin(deg2rad(45.))*uv.y,-1.)),nor);\n        vec3 nor2,pos2;\n        vec3 col2 = vec3(0);\n        //if(b < -2)\n        res = castRay(pos,reflect(rd,nor),nor2,pos2);\n        col = vec3(0,0,1) * dot(nor,lightDir) + vec3(1,0,0) * (res.y==2.?1.:0.);\n        col = clamp(col,0.,1.);\n    }\n    if(res.y == 4.)\n    {\n        vec3 dir = normalize(lightPos - pos);\n        vec2 res = castRay(pos,dir,nor,pos);\n        col = vec3(0,1,0) * (res.x == -1.?1.:0.5);\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n   \n    vec3 col = vec3(1);\n    vec3 light = -normalize(vec3(-1.,-1,-1));\n    vec3 lightPos = vec3(2. * sin(iTime),2.,-.4 * cos(iTime));\n    vec3 camO = vec3(2.,0,2.5 + (iMouse.y / iResolution.y - 0.5) * 20. + 2.);\n    vec3 camDir = vec3(0,0,-1);\n    //camDir.z += length(uv) * 0.54;\n    //camDir = normalize(vec3(cos(deg2rad(45.)) * (uv.x),sin(deg2rad(45.))*uv.y,camDir.z));\n    float fovAngleY =sin (deg2rad(30.) * (uv.x * iResolution.y / iResolution.x)) / iResolution.y * iResolution.x;\n    float fovAngleX =sin (deg2rad(30.) * (uv.y));\n    camDir = rot(fovAngleX,fovAngleY + deg2rad(10.),0.) * camDir;\n    //camDir = vec3(camDir.x * cos(fovAngle) + camDir.y * sin(fovAngle), camDir.x * sin(fovAngle) - camDir.y * cos(fovAngle), camDir.z);\n    //camDir = vec3(camDir.x * cos(iTime) + camDir.z * sin(iTime), camDir.y, camDir.x * sin(iTime) - camDir.z * cos(iTime));\n    vec3 nor = vec3(0);\n    vec3 pos = vec3(0);\n    vec2 res = vec2(-1);\n    int bDummy = 0;\n    col = render(camO,camDir,nor,pos,uv,lightPos,light,res,bDummy);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}