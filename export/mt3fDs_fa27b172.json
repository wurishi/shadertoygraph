{"ver":"0.1","info":{"id":"mt3fDs","date":"1702053218","viewed":19,"name":"tp1 INSA synthese d'images","username":"Shaunerie","description":"pour le tp noté de synthese d'images 3if","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int Steps = 10000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=0.01;  //nimum ray marching distance from origin\nconst float rB=50.0; // Maximum\nconst float hauteur_eau = -0.1;\nconst float hauteur_nuage = 3.0;\nconst float taille_nuage_max = 0.5;\nconst float vitesse_jour = 1.0;\nconst float rapport_lumi = 0.4;\n\nconst float taille_vague = 0.09;\nconst float frequence_vague_x = 3.0;\nconst float frequence_vague_z = 2.0;\n\n\n\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\n\nfloat ridged(vec2 p){\n    return 2.0*(0.5-abs(0.5-noise(p)));\n\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave)\n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridged(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nfloat turbulenceNuage(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave)\n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*noise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n\n\n\n\n// ----------------------------------------------------------\n// ----------------------------------------------------------\n// ----------------------------------------------------------\n// ----------------------------------------------------------\n\n\n\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n    mat3 m = mat3(\n   cos(a), 0.0, -sin(a), // first column (not row!)\n   0.0, 1.0, 0.0, // second column\n   sin(a), 0.0, cos(a)  // third column\n    );\n   return m*p;\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n    mat3 m = mat3(\n   1.0, 0.0, 0.0, // first column (not row!)\n   0.0, cos(a), -sin(a), // second column\n   0.0, sin(a), cos(a)  // third column\n    );\n   return m*p;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    float amplitude = 1.0; // amplitude devant le noise\n    float attenuation = 0.4; //ttenuation devant l'amplitude a chaque couche\n    float fbase = 0.15; // frÃ©quence du motif (scale des pixels)\n    int noctave = 7; // nb de couche de bruit\n \n  float res;\n  res = turbulence(p.xz, amplitude, fbase, attenuation, noctave);\n  if (res<hauteur_eau+taille_vague*(sin(p.x*frequence_vague_x+iTime)*sin(p.z*frequence_vague_z+iTime)*sin(iTime)))\n  {\n      res = hauteur_eau+taille_vague*(sin(p.x*frequence_vague_x+iTime)*sin(p.z*frequence_vague_z+iTime)*sin(iTime));\n  }\n  \n  return res-p.y;\n}\n\n\nfloat objectNuage(vec3 p)\n{\n \n  float resNuage;\n  \n  // Nuage\n  float amplitude = 0.45; // amplitude devant le noise\n  float attenuation = 0.33; //ttenuation devant l'amplitude a chaque couche\n  float fbase = 0.3; // frÃ©quence du motif (scale des pixels)\n  int noctave = 5; // nb de couche de bruit\n  resNuage = turbulenceNuage(p.xz+iTime, amplitude, fbase, attenuation, noctave)-(sqrt((p.y-hauteur_nuage)*(p.y-hauteur_nuage)+0.005)-sqrt(0.005));\n\n\n  return resNuage;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z)) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z)) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps)) - v;\n   return normalize(n);\n}\n\nvec3 ObjectNormalNuage(vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = objectNuage(p);\n   n.x = objectNuage( vec3(p.x+eps, p.y, p.z)) - v;\n   n.y = objectNuage( vec3(p.x, p.y+eps, p.z)) - v;\n   n.z = objectNuage( vec3(p.x, p.y, p.z+eps)) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out bool nuage)\n{\n   h = false;\n    \n    \n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float resNuage = objectNuage(p);\n      float v = object(p);\n      // Hit Sol || nuage\n      if (v > 0.0)\n      {\n         nuage = false;\n         s=i;\n         h = true;\n         break;\n      }\n      else if(resNuage>0.0)\n      {\n          nuage = true;\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,-max(v,resNuage)/4.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25)+ rapport_lumi*sin(iTime*vitesse_jour);\n}\n\n\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s, vec3 rd)\n{\n    vec3 c;\n    float res = object(p);    \n    \n    vec3 lightPos = vec3((6.0, 20.0, 50.0)+ rapport_lumi*sin(iTime*vitesse_jour));\n    vec3 l = normalize(lightPos - p);\n    float diff = 0.5*(1.0+dot(n, l));\n    float fog = 0.7*float(s)/(float(Steps-1));\n    if(res>0.0)\n    {\n        if(mod(p.y, 0.1) <= 0.008)\n        {\n              c = vec3(0.0,0.0,0.0);\n        }\n        else\n        {\n             float value = p.y+rapport_lumi*sin(iTime*vitesse_jour);\n             c =  0.6*vec3(value*0.8, value*0.5, value*0.2)+0.5*diff;\n             c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n        }\n    }\n    else // c'est un nuage\n    {\n            float value = p.y+rapport_lumi*sin(iTime*vitesse_jour);\n            // Not even Phong shading, use weighted cosine instead for smooth transitions\n            c =  0.5* vec3(0.1*value, 0.1*value, 0.1*value)+0.5*diff;\n            c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n            \n    \n\n    }\n       \n   return c;\n}\n\n\n\n\n\n\nvec3 ShadeWater(vec3 p, vec3 n, int s, vec3 rd)\n{\n\n   vec3 lightPos = vec3((6.0, 20.0, 50.0)+ rapport_lumi*sin(iTime*vitesse_jour));\n   vec3 l = normalize(lightPos - p);\n   vec3 c;\n   float resNuage;\n   float diff = 0.5*(1.0+dot(n, l));\n   float amplitude = 0.9; // amplitude devant le noise\n   float attenuation = 0.3; // attenuation devant l'amplitude a chaque couche\n   float fbase = 0.2; // frÃ©quence du motif (scale des pixels)\n   int noctave = 7; // nb de couche de bruit\n   float res;\n   res = turbulence(p.xz, amplitude, fbase, attenuation, noctave);\n   c =  0.5 * vec3(0.0,  0.1-0.5*abs(res)+0.5*diff+rapport_lumi*sin(iTime*vitesse_jour), 0.5-1.2*log(1.0+0.7*abs(res))+0.5*diff+rapport_lumi*sin(iTime*vitesse_jour));\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n        \n        \n        \n    // Reflet dans l'eau\n    vec3 ro = vec3(p.x, p.y+0.05, p.z);\n    rd = reflect(rd, n);\n    bool hit;\n    bool nuage;\n    float t = Trace(ro, rd, hit,s, nuage);\n    vec3 couleur_reflet;\n    if(hit)\n    {\n        vec3 point_reflet = t*rd+ro;\n        if(nuage)\n        {\n            n = ObjectNormalNuage(point_reflet);\n        }\n        else\n        {\n            n = ObjectNormal(point_reflet);\n        }\n        couleur_reflet = Shade(point_reflet, n, s, rd);\n    }\n    c = c*0.8 + 0.2*couleur_reflet;\n\n       \n  return c;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y-0.5, -4.0);\n   vec3 ro = vec3(0.0, 2.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy -0.5;\n   float a=-3.0*mouse.x;//iTime*0.25;\n   float b=+3.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n   ro = rotateX(ro, b);\n   rd = rotateX(rd, b);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n   bool nuage;\n   float t = Trace(ro, rd, hit,s, nuage);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n;\n      if(nuage)\n      {\n          n = ObjectNormalNuage(pos);\n      }\n      else\n      {\n          n = ObjectNormal(pos);\n      }\n\n      // Shade object with light\n      if(pos.y<hauteur_eau+taille_vague*(sin(pos.x*frequence_vague_x+iTime))*sin(pos.z*frequence_vague_z+iTime)*sin(iTime))\n      {\n          rgb = ShadeWater(pos, n, s, rd);\n      }\n      else\n      {\n          rgb = Shade(pos, n, s, rd);\n      }\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}