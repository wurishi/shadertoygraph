{"ver":"0.1","info":{"id":"wdXfRH","date":"1588372833","viewed":171,"name":"Japanese Torii Gate","username":"catherineliang39","description":"Rendering of a Torii Gate above water","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["noise","reflection","dof","specular","ambientocclusion","japan","torii","cosinepalette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// DRAG MOUSE TO PAN!\n\nconst int NUM_KERNEL_SQRT = 7;\nconst float SIGMA = 20.;\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    // creates an 11 by 11 kernel\n    const int mSize = NUM_KERNEL_SQRT;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = SIGMA;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    // square Z to account for mSize squared kernels\n    Z = Z*Z;\n    \n    // get each surrounding pixel\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            vec4 textureCol = texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy);\n            // optimization to ensure foreground is not blurred with background:\n            // don't include current pixel if not blurred\n            if (textureCol.a != 0.) {\n            \t// multiply with kernel, accumulate in final color\n                final_color += kernel[kSize+j]*kernel[kSize+i]*textureCol.rgb;\n            } else {\n                // if pixel isn't blurred, must adjust Z to account for decrease in kernel\n                Z -= kernel[kSize+j]*kernel[kSize+i];\n            }\n        }\n    }\n    // normalize/average final color\n    final_color /= Z;\n    \n    // uv of screen coord in [0, 1]\n    vec2 uv = fragCoord/iResolution.xy;\n    // get color from channel 0\n    vec4 unblurredColor = texture(iChannel0, uv);\n    // mix final color and unblurred color by using stored blur amount\n    fragColor = vec4(mix(unblurredColor.rgb, final_color, unblurredColor.a), 1.0);\n    //fragColor = vec4(unblurredColor.rgb, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FOVY = 19.5;\nconst int RAY_STEPS = 256;\nconst float AMBIENCE = 0.2;\n// thin lens camera params\nconst float FOCAL_LENGTH = 50.0;\nconst float FOCAL_RANGE = 30.0;\n// AO params\nconst float AO_DIST = 0.3;\nconst float FIVETAP_K = 1.;\n\n// colors\nconst vec3 lightColor = vec3(1.0, 0.9, 0.75);\nconst vec3 surfaceColor = vec3(0.6, 0.6, 0.85);\nconst vec3 subsurfaceColor = vec3(1.0, 0.67, 0.5);\n// camera & light positions\nconst vec3 lightPos = vec3(10., 45., -10.);\nvec3 eye = vec3(30, 4, -50);\nconst vec3 ref = vec3(0., 2, 0.);\n\n#define DEG_TO_RAD 3.141592 / 180.\n#define MAX_FLOAT 3.402823466e+38\n#define PI 3.141592\n#define EPSILON 0.1\n\n// intersection object\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 origp;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n\n// transform object\nstruct Transform {\n    vec3 trans;\n    vec3 rot;\n    vec3 scale;\n};\n\n// generates 1D random numbers for noise functions\nfloat random1(vec2 p) {\n    return fract(sin(dot(p,vec2(341.58, 735.42)))\n                 *40323.3851);\n}\n\n// generates 1D random numbers for noise functions\nfloat random1vec3(vec3 p) {\n    return fract(sin(dot(p,vec3(341.58, 735.42, 491.34)))\n                 *40323.3851);\n}\n\n// generates 2D random numbers for noise functions\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(833.41, 124.94)),\n                          dot(p,vec2(329.21, 419.38))))\n                 *38201.3429);\n}\n\n// generates 3D random numbers for noise functions\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n// interpolates 2D noise for fractal brownian\nfloat interpNoise2D(float x, float y) {\n    // interpolates 2D based fract (x, y) between curr and next int (x, y)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    float i1 = mix(random1(vec2(intX, intY)), random1(vec2(intX + 1, intY)), fractX);\n    float i2 = mix(random1(vec2(intX, intY + 1)), random1(vec2(intX + 1, intY + 1)), fractX);\n    return mix(i1, i2, fractY);\n    \n}\n\n// calculates 2D fractal brownian w/ octaves input\nfloat FractalBrownian2D(vec2 p, int octaves, bool animate) {\n    // Animate the point\n    vec2 point;\n    if (animate) {\n        point = p + vec2(iTime * 0.22, iTime * 0.53);\n    } else {\n        point = p;\n    }\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise2D(point.x * freq, point.y * freq) * amp;\n    }\n    return total;\n}\n\n\n// calculates 2D fractal brownian\nfloat FractalBrownian2D(vec2 p, bool animate) {\n    return FractalBrownian2D(p, 4, animate);\n}\n\n// interpolates 3D noise for fractal brownian\nfloat interpNoise3D(float x, float y, float z) {\n    // interpolates 3D based fract (x, y, z) between curr and next int (x, y, z)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    int intZ = int(floor(z));\n    float fractZ = fract(z);\n    float i1 = mix(random1vec3(vec3(intX, intY, intZ)), random1vec3(vec3(intX + 1, intY, intZ)), fractX);\n    float i2 = mix(random1vec3(vec3(intX, intY + 1, intZ)), random1vec3(vec3(intX + 1, intY + 1, intZ)), fractX);\n    float i3 = mix(random1vec3(vec3(intX, intY, intZ + 1)), random1vec3(vec3(intX + 1, intY, intZ + 1)), fractX);\n    float i4 = mix(random1vec3(vec3(intX, intY + 1, intZ + 1)), random1vec3(vec3(intX + 1, intY + 1, intZ + 1)), fractX);\n    float j1 = mix(i1, i2, fractY);\n    float j2 = mix(i3, i4, fractY);\n    return mix(j1, j2, fractZ);\n    \n}\n\n// calculates 3D fractal brownian w/ octaves input\nfloat FractalBrownian3D(vec3 point, int octaves, bool animate) {\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise3D(point.x * freq, point.y * freq, point.z * freq) * amp;\n    }\n    return total;\n}\n    \n// rotate degree a along X-axis\nvec3 rotateX(vec3 p, float a) {\n    a = DEG_TO_RAD * a;\n    return vec3(p.x, cos(a) * p.y + -sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\n// rotate degree a along Y-axis\nvec3 rotateY(vec3 p, float a) {\n    a = DEG_TO_RAD * a;\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// rotate degree a along Z-axis\nvec3 rotateZ(vec3 p, float a) {\n    a = DEG_TO_RAD * a;\n    return vec3(cos(a) * p.x + -sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n// applies inverse transform to point\nvec3 transformPoint(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = (p - trans);\n    p_transformed = rotateX(rotateY(rotateZ(p_transformed, -rot.z), -rot.y), -rot.x);\n    return p_transformed / scale;\n}\n\n// sphere sdf\nfloat sphere(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float sdf = distance(p_transformed, vec3(0, 0, 0)) - 0.5;\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n// cube sdf\nfloat cube(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    vec3 q = abs(p_transformed) - 0.5;\n    float sdf = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.);\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n// square plane sdf\nfloat squarePlane(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float xmin = -0.5;\n    float xmax = 0.5;\n    float ymin = -0.5;\n    float ymax = 0.5;\n    float sdf;\n    if (p_transformed.x > xmin && p_transformed.x < xmax && p_transformed.y > ymin && p_transformed.y < ymax) {\n        // dist to plane\n        sdf = dot(p_transformed, vec3(0, 0, 1));\n    } else if (p_transformed.x > xmin && p_transformed.x < xmax) {\n        // dist to sides\n        float ydist =  min(abs(p_transformed.y - ymin), abs(p_transformed.y - ymax));\n        sdf = length(vec2(ydist, p_transformed.z));\n    } else if (p_transformed.y > ymin && p_transformed.y < ymax) {\n        float xdist = min(abs(p_transformed.x - xmin), abs(p_transformed.x - xmax));\n        sdf = length(vec2(xdist, p_transformed.z));\n    }else {\n        // dist to corner\n        sdf = MAX_FLOAT;\n        vec3[4] corners;\n        corners[0] = vec3(xmin, ymin, 0);\n        corners[1] = vec3(xmax, ymin, 0);\n        corners[2] = vec3(xmin, ymax, 0);\n        corners[3] = vec3(xmax, ymax, 0);\n        for (int i = 0; i < 4; i++) {\n            float dist = distance(p_transformed, corners[i]);\n            if (dist < sdf) {\n                sdf = dist;\n            }\n        }\n    }\n    sdf = sdf * min(scale.x, min(scale.y, scale.z));\n    return sdf;\n}\n\n// turn point according to z to see shape as if its bending\nvec3 opCheapBend( in vec3 p, float k )\n{\n    return rotateZ(p, k * p.x);\n}\n\n// https://iquilezles.org/articles/distfunctions\n// cylinder SDF\nfloat cylinder( vec3 p, vec3 trans, vec3 rot, vec3 scale )\n{\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float h = 0.5;\n    float r = 0.5;\n    vec2 d = abs(vec2(length(p_transformed.xz), p_transformed.y)) - vec2(h, r);\n    float sdf = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/distfunctions\n// cone SDF\nfloat cappedCone( vec3 p, float r1, float r2, vec3 trans, vec3 rot, vec3 scale )\n{\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float h = 0.5;\n    vec2 q = vec2( length(p_transformed.xz), p_transformed.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    float sdf = s*sqrt( min(dot2(ca),dot2(cb)) );\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n// mat2 for waterMap\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\n// modified from https://www.shadertoy.com/view/MsB3WR\n// maps water based on x and z of plane\nfloat waterMap( vec2 pos ) {\n    float radius = length(pos - eye.xz);\n\tvec2 posm = pos * m2;\n    if (radius > 10. && radius < 50.) {\n        return (1. - smoothstep(30., 50., radius)) * (smoothstep(10., 30., radius)) \n            * abs( FractalBrownian2D(vec2(posm), true) - 0.8 )* 0.05;\n    } else {\n        return 0.;\n    }\n}\n\nfloat mountainMap(vec2 pos) {\n    // simulate shore\n    if (pos.y > 65. && pos.y < 70.) {\n        float detailTexture = FractalBrownian2D(pos / 3.f, 2, false) * 2.5;\n        return smoothstep(65., 66., pos.y) * detailTexture;\n    }\n    // simulate mountains\n    float radius = length(pos);\n    float baseHeight = FractalBrownian2D(vec2(pos / 20.f), 2, false) * 10.;\n    float detailElevation = FractalBrownian2D(vec2(pos / 20.f), false) * 10.;\n    float detailTexture = FractalBrownian2D(pos / 2.f, false) * 1.;\n    return smoothstep(70., 85., radius) * (baseHeight + detailElevation + detailTexture);\n}\n\n\n// mountain sdf\nfloat mountain(vec3 p) {\n    float radius = length(p.xz);\n    if (radius > 65. && radius < 120.) {\n        return p.y - mountainMap(p.xz);\n    } else if (radius < 65.) {\n        // compute distance based on horizontal and vertical distance\n        return length(vec2((65. - radius), (p.y - mountainMap(normalize(p.xz) * 65.))));\n    } else { // p.z > 100.\n        return MAX_FLOAT;\n    }\n}\n\nfloat grassMap(vec2 pos) {\n    float radius = length(pos);\n    float baseHeight = FractalBrownian2D(vec2(pos / 20.f + 1.5f), 2, false) - 0.6;\n    float detailElevation = FractalBrownian2D(pos, false) * 0.25;\n    return (baseHeight + detailElevation) - (smoothstep(-13., -5., pos.y));\n}\n\n\n// mountain sdf\nfloat grass(vec3 p) {\n    if (p.z > -50. && p.z < -5.) {\n        return p.y - grassMap(p.xz);\n    } else {\n        return MAX_FLOAT;\n    }\n}\n\n// smoothblend, takes in SDF 1, SDF 2\nfloat smoothBlend(float a, float b, float k) {\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\n// define sdfs (p, trans, rot, scale) & ids of each geom\n#define TORII_CONE_SDF cappedCone(pos, 0.8, 0.5, transform.trans, transform.rot, transform.scale)\n#define TORII_CYLINDER_SDF cylinder(pos, transform.trans, transform.rot, transform.scale)\n#define TORII_BEAM_SDF cube(opCheapBend(pos, -0.25), transform.trans, transform.rot, transform.scale)\n// displace pos by abs sin to create roof bends\n#define TORII_ROOF_FRONT_SDF cube(opCheapBend((1. - abs(sin(pos.x * 5.))) * 0.2 + pos, -0.25), transform1.trans, transform1.rot, transform1.scale)\n#define TORII_ROOF_BACK_SDF cube(opCheapBend((1. - abs(sin(pos.x * 5.))) * 0.2 + pos, -0.25), transform2.trans, transform2.rot, transform2.scale)\n// smooth blend front and back of roof\n#define TORII_ROOF_BOTTOM_SDF smoothBlend(TORII_ROOF_FRONT_SDF, TORII_ROOF_BACK_SDF, 0.01)\n#define TORII_ROOF_TOP_SDF cube(opCheapBend(pos, -0.45), transform3.trans, transform3.rot, transform3.scale)\n// smooth blend top and bottom of roof\n#define TORII_ROOF_SDF smoothBlend(TORII_ROOF_BOTTOM_SDF, TORII_ROOF_TOP_SDF, 0.01)\n#define TORII_SIGN_SDF cube(pos, transform.trans, transform.rot, transform.scale)\n#define GRASS_SDF grass(pos)\n#define WATER_SDF squarePlane(pos, transform.trans, transform.rot, transform.scale)\n#define MOUNTAIN_SDF mountain(pos)\n#define SKY_SDF -1. * sphere(pos, transform.trans, transform.rot, transform.scale)\n#define BLINN_PHONG_RED_ID 1\n#define BLINN_PHONG_BLACK_ID 2\n#define SIGN_ID 3\n#define GRASS_ID 4\n#define SPECULAR_ID 5\n#define MOUNTAIN_ID 6\n\n// compare t (distance) from each object, outputs minimum t & obj w/ min t (obj hit)\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    // right column\n    Transform transform = Transform(vec3(-5, 7, 0), vec3(0, 0, 0), vec3(1, 10, 1));\n    t = TORII_CONE_SDF;\n    obj = BLINN_PHONG_RED_ID;\n    \n    float t2;\n    // left column\n    transform = Transform(vec3(5, 7, 0), vec3(0, 0, 0), vec3(1, 10, 1));\n    if((t2 = TORII_CONE_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_RED_ID;\n    }\n    // right column bottom\n    transform = Transform(vec3(-5, 1, 0), vec3(0, 0, 0), vec3(0.8/0.5, 2, 0.8/0.5));\n    if((t2 = TORII_CYLINDER_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_BLACK_ID;\n    }\n    // left column bottom\n    transform = Transform(vec3(5, 1, 0), vec3(0, 0, 0), vec3(0.8/0.5, 2, 0.8/0.5));\n    if((t2 = TORII_CYLINDER_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_BLACK_ID;\n    }\n    // right column top\n    transform = Transform(vec3(-5, 12.25, 0), vec3(0, 0, 0), vec3(1.4, 0.5, 1.6));\n    if((t2 = TORII_CYLINDER_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_RED_ID;\n    }\n    // left column top\n    transform = Transform(vec3(5, 12.25, 0), vec3(0, 0, 0), vec3(1.4, 0.5, 1.6));\n    if((t2 = TORII_CYLINDER_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_RED_ID;\n    }\n    // bottom red beam\n    transform = Transform(vec3(0, 10, 0), vec3(0, 0, 0), vec3(16, 1, 0.5));\n    if((t2 = TORII_BEAM_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_RED_ID;\n    }\n    // top red beam\n    transform = Transform(vec3(0, 13, 0), vec3(0, 0, 0), vec3(16, 1, 1));\n    if((t2 = TORII_BEAM_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_RED_ID;\n    }\n    // roof front\n    Transform transform1 = Transform(vec3(0, 13.7, -0.7), vec3(60, 0, 0), vec3(20, 2, 0.3));\n    // roof back\n    Transform transform2 = Transform(vec3(0, 13.7, 0.7), vec3(-60, 0, 0), vec3(20, 2, 0.3));\n    // roof top\n    Transform transform3 = Transform(vec3(0, 14.2, 0), vec3(0, 0, 0), vec3(25, 1, 0.3));\n    if((t2 = TORII_ROOF_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_BLACK_ID;\n    }\n    // sign forward\n    transform = Transform(vec3(0, 11.4, -0.5), vec3(-8, 0, 0), vec3(1.6, 3, 0.2));\n    if((t2 = TORII_SIGN_SDF) < t) {\n        t = t2;\n        obj = SIGN_ID;\n    }\n    // sign back\n    transform = Transform(vec3(0, 11.4, 0.5), vec3(8, 0, 0), vec3(1.6, 3, 0.2));\n    if((t2 = TORII_SIGN_SDF) < t) {\n        t = t2;\n        obj = BLINN_PHONG_BLACK_ID;\n    }\n    // grass\n    if((t2 = GRASS_SDF) < t) {\n        t = t2;\n        obj = GRASS_ID;\n    }\n    // lake\n    transform = Transform(vec3(0, 0, 0), vec3(-90, 0, 0), vec3(1000, 1000, 1));\n    if((t2 = WATER_SDF) < t) {\n        t = t2;\n        obj = SPECULAR_ID;\n    }\n    // mountains\n    if((t2 = MOUNTAIN_SDF) < t) {\n        t = t2;\n        obj = MOUNTAIN_ID;\n    }\n    // skydome\n    transform = Transform(vec3(0, 0, 0), vec3(0, 0, 0), vec3(360, 360, 360));\n    if((t2 = SKY_SDF) < t) {\n        t = t2;\n        obj = -1;\n    }\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\n// computes normal by finding diff in t\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n// march at min dist to any object, m (from sceneMap3D), from orig toward dir, until obj hit\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.01;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.05, 0.05);\nconst vec3 b = vec3(0.5, 0.3, 0.);\nconst vec3 c = vec3(0.25, 0.5, 0.0);\nconst vec3 d = vec3(0., 0., 0.);\n\n// computes cosine color palette with a, b, c and d\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\n// uses Fractal Brownian to create noise and orangey-red cosine palette for coloring \n#define BLINN_PHONG_RED lightColor * (colorPalette(1.-smoothstep(0.1, 0.6, FractalBrownian3D(p/1.5, 4, false))) * lambert + vec3(0.8, 0.75, 0.05) * specular)\n#define BLINN_PHONG_BLACK lightColor * (smoothstep(0.1, 0.6, FractalBrownian3D(p/1.5, 4, false))) * vec3(0.3, 0.3, 0.3) * (lambert + specular)\n#define BLINN_PHONG_YELLOW lightColor * vec3(0.95, 0.95, 0.7) * (lambert + specular)\n// log modifies colors to be lighter toward higher end\n#define LAMBERT_BLUE lightColor * log(p.y / 10. + 1.8) * vec3(0.25, 0.42, 0.73) * lambert\n#define LAMBERT_GREEN lightColor * log(p.y * 4. + 1.3) * vec3(0.85, 0.95, 0.4) * lambert\n#define COLOR_WHITE lightColor\n// view is from isect to eye, so view.y is negative in the sky\n#define SKY vec3(0.85,0.82,0.85) + smoothstep(-0.1, -0.3, view.y)*vec3(-.2, -.07, -.05)\n\n// computes shading based on surface material (e.g. lambert)\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = clamp(max(0.0, dot(lightVec, n)) + AMBIENCE, 0., 1.);\n    vec3 h = normalize((view + lightVec) / 2.);\n    float hdotn = dot(h, n);\n    float specular = 0.;\n    if (hdotn > 0.) {\n        specular = clamp(max(pow(dot(h, n), 15.), 0.), 0., 1.);\n    }\n    switch(hitObj) {\n        case BLINN_PHONG_RED_ID:\n        return BLINN_PHONG_RED;\n        break;\n        case BLINN_PHONG_BLACK_ID:\n        return BLINN_PHONG_BLACK;\n        break;\n        case MOUNTAIN_ID:\n        return LAMBERT_BLUE;\n        break;\n        case GRASS_ID:\n        return LAMBERT_GREEN;\n        break;\n        case -1:\n        return SKY;\n        break;\n        case SIGN_ID:\n        if (p.y < 12.8 && p.y > 10. && abs(p.x) < 0.7 ) {\n            if (abs(p.x) > 0.55 || p.y > 12.7 || p.y < 10.1) {\n                return BLINN_PHONG_YELLOW;\n            }\n        }\n        return BLINN_PHONG_BLACK;\n        break;\n    }\n    return SKY;\n}\n\n// computes ambient occlusion by stepping through normal (k is artistic coeff)\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n// marches ray to get min t and obj hit, computes isect, nor, light dir to get material color\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 origIsect = eye + t * dir; // first intersection, never changed\n    vec3 isect = origIsect; // changed if specular\n    vec3 nor = computeNormal(isect);\n    vec3 surfaceColor = vec3(1.);\n    \n    // if object hit is specular lake\n    while (hitObj == SPECULAR_ID) {\n        // compute normal of waterMap sdf\n        vec2 pos = isect.xz;\n        vec2 epsilon = vec2( EPSILON, 0. );\n        nor = vec3( 0., 1., 0. );\n\t\tnor.x = (waterMap(pos + epsilon.xy) - waterMap(pos - epsilon.xy) ) / (2. * EPSILON);\n\t\tnor.z = (waterMap(pos + epsilon.yx) - waterMap(pos - epsilon.yx) ) / (2. * EPSILON);\n\t\tnor = normalize( nor );\t\n        vec3 rayDir = reflect(dir, normalize(nor));\n        march(isect, rayDir, t, hitObj);\n        // re-compute intersection pt & normal\n        isect = isect + t * rayDir;\n    \tnor = computeNormal(isect);\n        // alter surfaceColor by reflection color\n        surfaceColor *= vec3(0.95, 0.9, 0.85);\n    } \n    vec3 lightDir = normalize(lightPos - isect);\n    \n    surfaceColor *= computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    // ambient occlusion\n    if (length(isect - vec3(0.)) < 65.) {\n        surfaceColor *= fiveTapAO(isect, nor, FIVETAP_K);\n    }\n    // output origIsect for blur and new isect for fog\n    return Intersection(t, surfaceColor, origIsect, isect, hitObj);\n}\n\n// raycasts from eye to ref, returns vec3 ray direction\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rotation\n    eye = rotateY(eye, (iMouse.x + 200. - iResolution.x / 2.) / 5.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    float distFromCamera = abs(dot(normalize(ref - eye), (isect.origp - eye)));\n    // subtracting 30 ensures there is no blur within a distance of 30 from the focal length\n    float dofBlurAmount = min(1.0, max(abs(distFromCamera - FOCAL_LENGTH) - 20., 0.) / FOCAL_RANGE);\n\n    // fog\n    float fog = smoothstep(65.0, 100.0, distance(isect.p, vec3(0.))) * (1. - smoothstep(120.0, 130.0, distance(isect.p, vec3(0.))));\n    \n    // Output to screen\n    fragColor = vec4(mix(isect.color, vec3(0.7, 0.75, 0.85), fog), dofBlurAmount);\n}","name":"Buffer A","description":"","type":"buffer"}]}