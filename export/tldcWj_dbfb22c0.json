{"ver":"0.1","info":{"id":"tldcWj","date":"1610029391","viewed":105,"name":"Shader Experiment/Visualiser","username":"Aeshe","description":"Music influenced noise applied to a circles and then colours.  (If no sound can be heard, try pausing and playing the shader again)\nThe background, A black circle and inner circle is influenced by noise.","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"llXSzN","filepath":"https://soundcloud.com/gotmilkblood/1-sick-of-being-honest","previewfilepath":"https://soundcloud.com/gotmilkblood/1-sick-of-being-honest","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = PerlinNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*PerlinNoise(pos, iScale);\n    }\n    return noise;\n}\n\nconst vec2 points[8] = vec2[8](\n    vec2(0.1, 0.2),\n    vec2(0.9, 0.8),\n    vec2(0.3, 0.3),\n    vec2(0.7, 0.5),\n    vec2(0.8, 0.3),\n    vec2(0.6, 0.6),\n    vec2(0.3, 0.1),\n    vec2(0.4, 0.5)\n);\nconst vec4 colors[8] = vec4[8](\n    vec4(0.5, 0.3, 0.9, 1.0),\n    vec4(0.2, 0.7, 0.2, 1.0),\n    vec4(0.7, 0.5, 0.1, 1.0),\n    vec4(0.8, 0.9, 0.3, 1.0),\n    vec4(0.3, 0.8, 0.7, 1.0),\n    vec4(0.4, 0.1, 0.8, 1.0),\n    vec4(0.6, 0.4, 0.4, 1.0),\n    vec4(0.9, 0.2, 0.7, 1.0)\n);\n\nconst float a[8] = float[8](0.3, 0.2, 0.1, -0.4, -0.3, 0.1, 0.05, 0.4);\nconst float b[8] = float[8](0.2, 0.8, 0.1, 0.7, -0.2, -0.5, 0.9, -0.6);\nconst float c[8] = float[8](2.0, 3.0, 6.0, 3.0, 1.0, 3.0, 1.0, 1.0 );\n\nvec4 hsv2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n    return vec4(color,1);\n}\n\nvec4 GetColor(in int i)\n{\n    float noise0 = 0.5 * (PerlinNoise(vec3(points[i], iTime), 1.0));\n    float noise1 = 0.5 * (PerlinNoise(vec3(points[i], iTime+100.0), 1.0));\n    vec3 hsv = vec3(noise0, 0.7+0.3*noise1, 1.0);\n    return hsv2rgb(hsv);\n    \n}\n\nvec2 GetPoint(in int i )\n{\n    // move the points on orbits\n    float x = points[i].x + a[i]*cos(c[i]*iTime*0.1);    \n    float y = points[i].y + b[i]*sin(c[i]*iTime*0.1); \n    return vec2(x,y);\n}\n\nvec4 GetVoronoiColor(in vec2 point)\n{\n    float nearDistSq = 1e20;\n    vec4 color;\n    vec2 offset;\n    //offset.x = 0.3*FractalNoise(vec3(point, iTime * 0.3), 3.0, 0.5, 3);\n    offset.x = 0.3*FractalNoise( vec3(point, iTime+texture(iChannel0, vec2(0,0)).r),1.0, 0.5, 5);\n    offset.y = 0.3*FractalNoise(vec3(point, iTime +texture(iChannel0, vec2(0,0)).r + 100.0), 3.0, 0.5, 3);\n    for ( int i = 0; i < 8; i++ )\n    {\n        vec2 diff = point+offset-GetPoint(i);\n        float d2 = dot(diff,diff);\n        if ( d2 < nearDistSq )\n        {\n            nearDistSq = d2;\n            color = GetColor(i);\n        }\n    }\n    return color;\n}\n\nbool sphere(in vec3 position, in vec3 direction, in vec3 centre, in float radius, in mat3 rotMat, out vec3 hitPosition,\n                        out vec3 hitNorms, out vec3 hitPosLocal)\n{\n    float a = dot(position - centre, direction) * 2.0;\n    float b = dot(position - centre, position - centre) - radius * radius;\n    \n    float sq = sqrt(a * a - 4.0 * b);\n    float sol1 = 0.5 * (-b - sq);\n    float sol2 = 0.5 * (-b + sq);\n    \n    if(a * a < 4.0 * b)\n    {\n        return false;\n    }\n    \n    if(sol1 > sol2)\n    {\n        sol1 = sol2;\n    }\n    \n    hitPosition = position + direction * sol1;\n    hitNorms = normalize(hitPosition - centre);\n    hitPosLocal = transpose(rotMat) * (hitPosition - centre);\n    \n    return true;\n    \n}\n                        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 newUV = vec2(0.0, 0.0);\n    uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 i = vec3(0.0, 0.0, 0.5);\n    vec3 j = normalize(vec3(uv, 0.0) - i);\n    \n    //=================================================================\n    // Noise\n    //=================================================================\n\n    \n    float noise = FractalNoise( vec3(texture(iChannel0, vec2(uv))), 1.0, 0.5, 5);        //Switch UV's here for different effects!\n    float bgNoise = FractalNoise( vec3(texture(iChannel0, vec2(0.3,0.3))), 1.0, 0.5, 5);        //Switch UV's here for different effects!\n    //float noise = FractalNoise( vec3(iTime+texture(iChannel0, vec2(0,0)).r, uv.x, uv.y),1.0, 0.5, 5);    For splodges instead - Change background colours to make it stand out\n    \n    \n    \n    //=================================================================\n    //Sphere Positions\n    //=================================================================\n\n    vec3 spherePosition = vec3(0, 0, 0.9);\n    vec3 bg1SpherePos = vec3(0, 0, 1.55);\n    vec3 bg2SpherePos = vec3(0, 0, 0.8);\n    vec3 bg3SpherePos = vec3(0, 0, 1.3);\n    \n    //=================================================================\n    // Radius\n    //=================================================================\n    \n    mat3 rotMat = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    float noiseInfluRadius = noise;\n    float newNoiseRadius = bgNoise;\n    float radius = 0.5;                \n    \n    //=================================================================\n    //Positions\n    //=================================================================\n\n    vec3 hitPosition, hitNorms, hitPosLocal;\n    bool hit, bgHit, bg2Hit, bg3Hit;\n    \n    //=================================================================\n    //Background\n    //=================================================================\n    \n    fragColor = GetVoronoiColor(uv);\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);   //backup background\n   \n    \n    //=================================================================\n    //Main\n    //=================================================================    \n    \n    \n    //Sphere\n    hit = sphere(i, j, spherePosition, noiseInfluRadius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    \n    //Background - Defintely a better way to do this...\n    bgHit = sphere(i, j, bg1SpherePos, radius, rotMat, hitPosition, hitNorms, hitPosLocal);   \n    \n    bg2Hit = sphere(i, j, bg2SpherePos, newNoiseRadius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    \n    bg3Hit = sphere(i, j, bg3SpherePos, radius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    if(bg3Hit)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n    \n    if(bg2Hit)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if(bgHit)\n    {\n        fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n    }\n    \n    \n    if(hit)\n    {\n        fragColor = GetVoronoiColor(uv);\n    }\n    \n    //Ignore all of my bad comments pls\n    \n    //Credits\n    // Music: https://soundcloud.com/gotmilkblood/1-sick-of-being-honest  - Sick of being honest by Milkblood\n    // Paste any song you want from soundcloud into the dialogue box that pops up when clicking on iChannel0 \n    \n    \n}","name":"Image","description":"","type":"image"}]}