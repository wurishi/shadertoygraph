{"ver":"0.1","info":{"id":"ttdyzH","date":"1608508540","viewed":109,"name":"Square Colosseum","username":"kastorp","description":"[url=https://en.wikipedia.org/wiki/Palazzo_della_Civilt%C3%A0_Italiana]This[/url] building really exists!  I love it... built in 1940 and now Fendi HQ \n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I was mainly interested in writing a compact map() function for this building\n//\n// CREDITS:\n// borrowed some code from the following shaders\n//  rendering  from \"One small step (3Kb)\"   https://www.shadertoy.com/view/tt3yRH by Dean_The_Coder\n//  clouds from \"lake in highland\" https://www.shadertoy.com/view/4sdfz8 by Fishman\n\n\n//#define INFINITE  \n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\nfloat map(vec3 p) {\n         \n#ifdef INFINITE\n    vec3 p0 =  vec3((p.x -3.5) - floor((p.x+3.5) /12.)*12.,p.y,(p.z -3.5) - floor((p.z+3.5) /12.)*12.);; \n#else\n    vec3 p0 = p;\n#endif\n\n    p0.xz=-1.70 + abs(p0.xz +1.);\n    p0.xz= vec2(p0.x+p0.z,p0.x-p0.z)/sqrt(2.)   ;\n    p0.y= .5 + p0.y*.5 + abs( p0.y -.7)*.6; \n   \n    float cv = 1.3,ch=.6;\n    vec3 p1 =  vec3(p0.x, p0.y-cv*clamp(round((p0.y-.9) /cv), -.1,5.),p0.z); //vertical repetition\n    \n    vec3 p2 = vec3(p1.x,p1.y,p1.z-ch*clamp(round(p1.z/ch),-4.,4.)); //horizontal repetition\n    float b = sdCappedCylinder(p2,vec3(.5,1.,0.),vec3(-.3,1.,0.),.2);\n     b =min(b,sdBox(p2- vec3(0.1,.7,0),vec3(.4,.3,.2)));\n     b= min(b,sdCappedCylinder(p1,vec3(0.,1.,-3.0),vec3(0.,1.,3.0),.2));\n     b =min(b,sdBox(p1- vec3(0,.7,0),vec3(.2,.3,3.0)));\n     b =min(b,sdBox(p1- vec3(-1.3,.9,0),vec3(1.02,.5,2.0)));\n    b= max(-b,sdBox(p0- vec3(-1.1,4.3,0.),vec3(1.5,4.3,3.)));\n    b= min(b,sdBox(vec3(p0.x,p.y,p0.z)- vec3(-1.5,.0,0.),vec3(4.,.1,6.)));\n    return min(b,p.y);\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n) / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  1.;//.5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\nvec3 lightDir = normalize( vec3(6,19,-6.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, 0.5*smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = .1 + .9 * dot(vec3(ao(p, n, .1), ao(p, n, .4), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\n\t// Primary light.\n\tl1 = max(0., .2 + .8 * dot(ld, n)),\n\n\t// Secondary(/bounce) light.\n    #ifdef INFINITE\n\tl2 = 1.,\n    #else\n    l2 =  max(0., .2 + .8 * dot(ld * vec3(-18, .5, -12), n)) * .4,\n    #endif\n\n\t// Specular.\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\t// Combine.\n\tl1 *= .1 + .9 * calcShadow(p, ld);\n\tvec3 lig = ((l1 + l2) * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\n\t\tif (abs(h) < .0015)\n\t\t\tbreak;\n\n\t\td += h; // No hit, so keep marching.\n\t}\n    if(d>50.) return  RayMarchCloud( ro, rd)*.6;\n\n\treturn lights(p, rd, d) * exp(-d * .085)*(p.y<0.01? vec3(0,1,0):vec3(1))\n    #ifndef INFINITE\n     * (sdBox(vec3(p.x+p.z+2.,p.y,p.x-p.z),vec3(3,8.,3.))<0. ?vec3(0.165,0.165,0.016):vec3(1.))\n     #endif\n     ;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tfloat t =iTime * .2;\n\tvec3 ro = vec3(-3.-cos(t)*5., 4., 4.5+cos(t)*5.);\n\t\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(-1.5,ro.y,-1.5), uv)), vec3(.45)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}