{"ver":"0.1","info":{"id":"XstXW7","date":"1459734069","viewed":206,"name":"Twisting Pylon","username":"jackdavenport","description":"A raymarched, twisting pylon","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","box","rotation","trigonometry","twisting","pylon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 256\n#define MIN_DISTANCE .001\n\n#define LIGHT_COL vec3(1.)\n#define LIGHT_DIR normalize(vec3(90.,80.,-45.))\n\nstruct Ray { vec3 ori;  vec3 dir; };\nstruct Dst { float dst; int id;   };\nstruct Hit { vec3 p;    int id;   };\n    \nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n    \nDst dstPillar(vec3 p, vec3 pos, vec3 box) {\n        \n    p.xz = rot2D(p.xz, (iTime + p.y) * 45.);\n    \n    vec3    d = abs(pos - p) - box;\n    float dst = min(max(d.x,max(d.y,d.z)), 0.) + length(max(d, 0.));\n    \n    return Dst(dst, 0);\n    \n}\n\nDst dstFloor(vec3 p, float y) {\n \n    return Dst(p.y - y, 1);\n    \n}\n\nDst dstMin(Dst a, Dst b) {\n \n    if(b.dst < a.dst) return b;\n    return a;\n    \n}\n\nDst dstScene(vec3 p) {\n \n    Dst dst = dstPillar(p, vec3(0.), vec3(.5,2.,.5));\n    dst = dstMin(dst, dstFloor(p, -2.));\n    \n    return dst;\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dst scn = dstScene(p);\n        p += ray.dir * scn.dst * .75;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n  \n// Shadow code from the incredible iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t ).dst;\n        res = min( res,32.0*h/t );\n        t += clamp( h, 0.05, 0.50 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,\n                   \tdstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,\n                   \tdstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 calcLighting(vec3 n, float s, Hit scn) {\n \n    float d = max(dot(LIGHT_DIR,n), 0.);\n\td *= s;\n    \n    return LIGHT_COL * d;\n    \n}\n\nvec3 getPylonDiffuse(vec3 n, float s, Hit scn) {\n \n    return calcLighting(n, s, scn);\n    \n}\n\nvec3 getFloorDiffuse(Hit scn) {\n \n    vec2 uv = mod(scn.p.xz / 3.5, 1.);\n    float s = softShadow(scn.p, LIGHT_DIR, .0015, 10.);\n    \n    return texture(iChannel1, uv).xyz * calcLighting(vec3(0., 1., 0.), s, scn);\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn  = raymarch(ray);\n    vec3 col = texture(iChannel0, ray.dir).xyz;\n    \n    if(scn.id == 0) {\n     \n        vec3 n = calcNormal(scn.p);\n        vec3 r = reflect(ray.dir, n);\n        \n        Ray rr = Ray(scn.p + r * .001, r);\n        Hit rh = raymarch(rr);\n        \n        float sh = softShadow(scn.p, LIGHT_DIR, .0015, 10.);\n        vec3  dc = getPylonDiffuse(n, sh, scn);\n        vec3 rc  = \n            rh.id == 0 ? getPylonDiffuse(calcNormal(rh.p),softShadow(scn.p, LIGHT_DIR, .0015, 10.),rh) : \n            rh.id == 1 ? getFloorDiffuse(rh) :\n            texture(iChannel0, rr.dir).xyz;\n        \n        vec3 s = LIGHT_COL * pow(max(dot(LIGHT_DIR,r),0.), 30.) * softShadow(scn.p, LIGHT_DIR, .0015, 10.);\n        float f = mix(.1, .9, 1. - max(pow(-dot(ray.dir,n), .1), 0.));\n        return mix(dc, rc, f) + s;\n        \n        \n    } else if(scn.id == 1) {\n    \n        col = getFloorDiffuse(scn);\n    \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-5.5);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}