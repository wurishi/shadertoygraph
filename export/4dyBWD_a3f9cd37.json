{"ver":"0.1","info":{"id":"4dyBWD","date":"1528880430","viewed":2995,"name":"LUT Color Grading","username":"mitjaprelovsek","description":"Based on https://www.shadertoy.com/view/Mdfcz7 and modified so that in the Buf A you can import a custom ACES LUT png file. In order to import a custom LUT png you need a Shadertoy Custom Textures Chrome Plugin.","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["lut","colorgrading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBased on the awesome ACES Color Grading shader (https://www.shadertoy.com/view/Mdfcz7) developed by Mynx. \nI modified it so that in Buf A you can use a custom LUT PNG file. \nIn order to be able to import a custom LUT png to one of the iChannels on Shadertoy you need\nShadertoy Custom Textures Chrome Plugin.\n\nIf you need a custom PNG file there is a sample here: \nhttps://support.lightact-systems.com/wp-content/uploads/2018/06/LUTFromShadertoy.png\n\n\n*/\n\n/*ORIGINAL BELOW*/\n//  Description: Transform input image to linear space and apply the 3D LUT for grading.\n//               Input for the LUT is in ACESproxy space (12bit version).\n//               Works for post-exposure HDR renders, i.e. games with HDR rendering.\n\n#define LUT_SIZE 22.0\n#define LUT_WIDTH (LUT_SIZE * LUT_SIZE)\n#define PI 3.1415926535897932384626433832795\n\n\n////////////////////////////////////////////////////////////////////////////\n//\n// # License Terms for Academy Color Encoding System Components #\n// \n// Academy Color Encoding System (ACES) software and tools are provided by the\n// Academy under the following terms and conditions: A worldwide, royalty-free,\n// non-exclusive right to copy, modify, create derivatives, and use, in source and\n// binary forms, is hereby granted, subject to acceptance of this license.\n// \n// Copyright Â© 2013 Academy of Motion Picture Arts and Sciences (A.M.P.A.S.).\n// Portions contributed by others as indicated. All rights reserved.\n// \n// Performance of any of the aforementioned acts indicates acceptance to be bound\n// by the following terms and conditions:\n// \n// * Copies of source code, in whole or in part, must retain the above copyright\n// notice, this list of conditions and the Disclaimer of Warranty.\n// \n// * Use in binary form must retain the above copyright notice, this list of\n// conditions and the Disclaimer of Warranty in the documentation and/or other\n// materials provided with the distribution.\n// \n// * Nothing in this license shall be deemed to grant any rights to trademarks,\n// copyrights, patents, trade secrets or any other intellectual property of\n// A.M.P.A.S. or any contributors, except as expressly stated herein.\n// \n// * Neither the name \"A.M.P.A.S.\" nor the name of any other contributors to this\n// software may be used to endorse or promote products derivative of or based on\n// this software without express prior written permission of A.M.P.A.S. or the\n// contributors, as appropriate.\n// \n// This license shall be construed pursuant to the laws of the State of\n// California, and any disputes related thereto shall be subject to the\n// jurisdiction of the courts therein.\n// \n// Disclaimer of Warranty: THIS SOFTWARE IS PROVIDED BY A.M.P.A.S. AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND\n// NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL A.M.P.A.S., OR ANY\n// CONTRIBUTORS OR DISTRIBUTORS, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, RESITUTIONARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// \n// WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, THE ACADEMY SPECIFICALLY\n// DISCLAIMS ANY REPRESENTATIONS OR WARRANTIES WHATSOEVER RELATED TO PATENT OR\n// OTHER INTELLECTUAL PROPERTY RIGHTS IN THE ACADEMY COLOR ENCODING SYSTEM, OR\n// APPLICATIONS THEREOF, HELD BY PARTIES OTHER THAN A.M.P.A.S.,WHETHER DISCLOSED OR\n// UNDISCLOSED.\n//\n// -------------------------------------------------------------------------\n////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Transform_Common.a1.0.0\n\nconst mat3 AP0_2_XYZ_MAT = mat3\n(\n\t0.9525523959, 0.0000000000, 0.0000936786,\n\t0.3439664498, 0.7281660966,-0.0721325464,\n\t0.0000000000, 0.0000000000, 1.0088251844\n);\n\nconst mat3 AP1_2_XYZ_MAT = mat3\n(\n\t 0.6624541811, 0.1340042065, 0.1561876870,\n\t 0.2722287168, 0.6740817658, 0.0536895174,\n\t-0.0055746495, 0.0040607335, 1.0103391003\n);\n\nconst mat3 XYZ_2_AP0_MAT = mat3\n(\n\t 1.0498110175, 0.0000000000,-0.0000974845,\n\t-0.4959030231, 1.3733130458, 0.0982400361,\n    0.0000000000, 0.0000000000, 0.9912520182\n);\n\nconst mat3 XYZ_2_AP1_MAT = mat3\n(\n\t 1.6410233797,-0.3248032942,-0.2364246952,\n\t-0.6636628587, 1.6153315917, 0.0167563477,\n\t 0.0117218943,-0.0082844420, 0.9883948585\n);\n\nconst mat3 AP0_2_AP1_MAT = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\nconst mat3 AP1_2_AP0_MAT = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\nconst vec3 AP1_RGB2Y = vec3(AP1_2_XYZ_MAT[0][1], AP1_2_XYZ_MAT[1][1], AP1_2_XYZ_MAT[2][1]);\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Utilities_Color.a1.0.0\n\n// Transformations between CIE XYZ tristimulus values and CIE x,y \n// chromaticity coordinates\nvec3 XYZ_2_xyY( vec3 XYZ)\n{  \n\tvec3 xyY;\n\tfloat divisor = (XYZ[0] + XYZ[1] + XYZ[2]);\n\tif (divisor == 0.0)\n\t\tdivisor = 1e-10;\n\n\txyY[0] = XYZ[0] / divisor;\n\txyY[1] = XYZ[1] / divisor;  \n\txyY[2] = XYZ[1];\n  \n\treturn xyY;\n}\n\nvec3 xyY_2_XYZ( vec3 xyY)\n{\n\tvec3 XYZ;\n\tXYZ[0] = xyY[0] * xyY[2] / max( xyY[1], 1e-10);\n\tXYZ[1] = xyY[2];  \n\tXYZ[2] = (1.0 - xyY[0] - xyY[1]) * xyY[2] / max(xyY[1], 1e-10);\n\n\treturn XYZ;\n}\n\nconst mat3 CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.89510, 0.26640,-0.16140,\n\t-0.75020, 1.71350, 0.03670,\n\t 0.03890,-0.06850, 1.02960\n);\n\nconst mat3 INV_CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.9869929055,-0.1470542564, 0.1599626517,\n\t 0.4323052697, 0.5183602715, 0.0492912282,\n\t-0.0085286646, 0.0400428217, 0.9674766958\n);\n\nmat3 calculate_cat_matrix\n  (vec2 src_xy,        // x,y chromaticity of source white\n   vec2 des_xy         // x,y chromaticity of destination white\n  )\n{\n\t// Calculates and returns a 3x3 Von Kries chromatic adaptation transform \n\t// from src_xy to des_xy using the cone response primaries defined \n\t// by coneRespMat.\n\n\tvec3 src_XYZ = xyY_2_XYZ( vec3( src_xy, 1 ) );\n\tvec3 des_XYZ = xyY_2_XYZ( vec3( des_xy, 1 ) );\n\n\tvec3 src_coneResp = (src_XYZ * CONE_RESP_MAT_BRADFORD);\n\tvec3 des_coneResp = (des_XYZ * CONE_RESP_MAT_BRADFORD);\n\n\tmat3 vkMat = mat3\n\t(\n\t\tdes_coneResp[0] / src_coneResp[0], 0.0, 0.0,\n\t\t0.0, des_coneResp[1] / src_coneResp[1], 0.0,\n\t\t0.0, 0.0, des_coneResp[2] / src_coneResp[2]\n\t);\n\n\tmat3 cat_matrix = ( ( CONE_RESP_MAT_BRADFORD * vkMat ) * INV_CONE_RESP_MAT_BRADFORD );\n\n\treturn cat_matrix;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.ODT_Common.a1.0.0\n\nconst vec2 AP0_WhitePoint = vec2(0.32168, 0.33767);\nconst vec2 REC709_WhitePoint = vec2(0.31270, 0.32900);\n\n////////////////////////////////////////////////////////////////////////////\n// ODT.Academy.RGBmonitor_D60sim_100nits_dim.a1.0.0\n\nconst mat3 XYZ_2_DISPLAY_PRI_MAT = mat3\n(\n\t 3.2409699419,-1.5373831776,-0.4986107603,\n\t-0.9692436363, 1.8759675015, 0.0415550574,\n\t 0.0556300797,-0.2039769589, 1.0569715142\n);\n\nconst mat3 DISPLAY_PRI_2_XYZ_MAT = mat3\n(\n\t0.4123907993, 0.3575843394, 0.1804807884,\n\t0.2126390059, 0.7151686788, 0.0721923154,\n    0.0193308187, 0.1191947798, 0.9505321523\n);\n\n// ACEScsc.ACES_to_ACESproxy12i.a1.0.3\n    \nconst float StepsPerStop = 200.0;\nconst float MidCVoffset  = 1700.0;\nconst float CVmin        = 256.0;\nconst float CVmax        = 3760.0;\n\nvec3 ACES_2_ACESproxy(vec3 x)\n{\n    x = clamp( x, 0.0, 65535.0);\n    x = x * AP0_2_AP1_MAT;\n    x.r = (x.r <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.r) + 2.5) * StepsPerStop + MidCVoffset)));\n\tx.g = (x.g <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.g) + 2.5) * StepsPerStop + MidCVoffset)));    \n    x.b = (x.b <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.b) + 2.5) * StepsPerStop + MidCVoffset)));\n\treturn x / 4095.0;\n}\n\nvec3 ACESproxy_2_ACES(vec3 x)\n{\n    x = x * 4095.0;\n    x = pow(vec3(2.0), (x - MidCVoffset) / StepsPerStop - 2.5);\n\treturn x * AP1_2_AP0_MAT;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nvec3 log10(vec3 n)\n{\n\tconst float logBase10 = 1.0 / log2(10.0);\n\treturn log2( n ) * logBase10;\n}\n\nvec3 linear_2_cineon_log(in vec3 color)\n{\n\treturn ((log10(color.xyz * (1.0 - 0.0108) + 0.0108) * 300.0) + 685.0) / 1023.0;\n}\n\nvec3 rgb_2_ap0( vec3 color )\n{\n    mat3 D65_2_D60_CAT = calculate_cat_matrix( REC709_WhitePoint, AP0_WhitePoint );\n    mat3 sRGB_2_AP0 = ((DISPLAY_PRI_2_XYZ_MAT * D65_2_D60_CAT) * XYZ_2_AP0_MAT);\n\treturn (color * sRGB_2_AP0);\n}\n\nvec3 apply_chart(vec3 image,vec4 scaledLUT)\n{\n\tconst vec3 scale = vec3(LUT_SIZE - 1.0, LUT_SIZE - 1.0, LUT_SIZE - 1.0) / LUT_SIZE;\n\tconst vec3 bias = vec3(1.5, 0.5, 0.0) / LUT_SIZE;\n    \n\tvec3 lookup = clamp(image, 0.0, 1.0) * scale + bias;\n \n\tfloat slice = lookup.z * LUT_SIZE;\t\n\tfloat sliceFrac = fract(slice);\t\n\tfloat sliceIdx = slice - sliceFrac;\n\t\n\tlookup.x = (lookup.x + sliceIdx) / LUT_SIZE;\n    lookup.xy /= iResolution.xy;\n    lookup.xy *= vec2(LUT_WIDTH, LUT_SIZE);\n    \n \tvec3 col0 = texture(iChannel1, lookup.xy).xyz;\n    //vec3 col0=scaledLUT.xyz;\n    //vec3 test=texture(scaledLUT.xyz,lookup.xy).xyz;\n    \n    // slice interpolation\n \tlookup.x += 1.0 / LUT_SIZE * LUT_WIDTH / iResolution.x;\n \tvec3 col1 = texture(iChannel1, lookup.xy).xyz;\n    //vec3 col1=scaledLUT.xyz;\n    \n\treturn col0 + (col1 - col0) * sliceFrac;\n    //return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 image = texture(iChannel0, uv);\n    image.xyz = pow(image.xyz, vec3(2.2));\n    \n    vec4 scaledLUT=vec4(0.0);\n    \n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE){\n    \tvec2 uv_LUT = fragCoord.xy/vec2(LUT_WIDTH,LUT_SIZE);\n    \tscaledLUT=texture(iChannel1, uv_LUT);\n    }else{\n        scaledLUT=vec4(0.0);\n    }\n    \n    //if (fragCoord.x < iMouse.x)\n    if (1==1)\n    {        \n        // move to proxy space\n        image.xyz = ACES_2_ACESproxy(rgb_2_ap0(image.xyz));\n\n        // apply the chart\n        image.xyz = apply_chart(image.xyz,scaledLUT);\n    }\n    else\n    {\n        image.xyz = pow(image.xyz, vec3(1.0 / 2.2));   \n    }\n   \n    vec3 lookupTable = (texture(iChannel1, uv).xyz);\n    lookupTable=scaledLUT.xyz;\n    \n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE)\n    {\n        //This is commented so that we don't see the LUT\n    \t//image.xyz = lookupTable.xyz;\n    }else{\n        //image.xyz=image.xyz;\n    }\n    \n    fragColor = vec4(image.xyz,1.0);\n    //fragColor=vec4(texture(iChannel1, uv).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Description: Generate a 3D color-grading LUT using the Academy Color Encoding System (ACES).\n//               Original sources for ACES can be found here: https://github.com/ampas/aces-dev/\n\n#define LUT_SIZE 22.0\n#define LUT_WIDTH (LUT_SIZE * LUT_SIZE)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    // LUT in bottom rect.\n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE)\n    {    \n\n        vec2 uv = fragCoord.xy/vec2(LUT_WIDTH,LUT_SIZE);\n      \n        fragColor=texture(iChannel1, uv);\n\n    }\n\n}","name":"Buf A","description":"","type":"buffer"}]}