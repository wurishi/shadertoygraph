{"ver":"0.1","info":{"id":"M32fR1","date":"1729373120","viewed":80,"name":"ray marching - ebajec","username":"ebajec","description":"a","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592654;\nconst float inf = 1e9;\nconst float epsilon = 0.005;\n\nfloat random(vec3 st) {\n    return fract(sin(dot(st, vec3(12.9898, 78.233,32.022))) * 43758.5453123);\n}\n\nvec2 normaldist(vec3 st) {\n    // Generate two uniform random numbers between 0 and 1\n    float u1 = random(st);\n    float u2 = random(st + vec3(1));\n\n    // Box-Muller transform\n    float r = 1.5*(1.0 + 2.0 * log(u1));\n    float theta = 2.0 * PI * u2;\n\n    return r * vec2(cos(theta),sin(theta));\n}\n\nvec4 quat_mult(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y, \n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x, \n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w, \n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z  \n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    vec4 exp_q = vec4(cos(angle/2.0),sin(angle/2.0)*axis);\n    vec4 exp_q_conj = vec4(exp_q.x,-exp_q.yzw);\n    vec4 v_p = vec4(0.0,v);\n\n    vec4 result = quat_mult(quat_mult(exp_q,v_p),exp_q_conj);\n    \n    return result.yzw;\n}\n\nfloat dist_sq(vec3 a, vec3 b)\n{\n    vec3 diff = a-b;\n    return dot(diff,diff);\n}\n\nstruct DistResult\n{\n    float v;\n    float dif;\n    float ref;\n    vec3 color;\n};\n\n// Signed distance function for a torus\n// p: the position vector\n// t: vec2 where t.x is the major radius (outer radius), and t.y is the minor radius (tube radius)\nDistResult sdfTorus(vec3 p,vec3 c, vec2 t) \n{\n    p = rotate(p-c,normalize(vec3(1.0,0,0.5)),3.0*iTime);\n\n    DistResult result;\n    \n    vec2 q = vec2(length(p.xz) - t.x, p.y);  // Flatten to 2D on the xz-plane, then offset by major radius\n    \n    float theta = atan(p.z,p.x);\n    \n    result.v = length(q) - t.y; \n    result.color = vec3(1);\n    \n    return result;              // Compute distance from torus' tube\n}\n\nDistResult sdfPlane(vec3 p, vec3 o, vec3 n)\n{\n    vec3 d = p-o;\n    float dist = dot(d,n);\n    \n    float rad = 200.0;\n    float value = dist_sq(d,dist*n) < rad*rad ? dist : inf;\n    \n    DistResult result;\n    result.v = value;\n    result.color = 0.4*vec3(1);\n    \n    return result;\n}\n\n\nDistResult sdfPeriod(vec3 p, vec3 o, float r)\n{\n    vec3 d = p-o;\n    \n    d *= 2.0*PI;\n    d /= 20.0;\n    \n    float a = 3.0*(2.0+sin(iTime));\n    \n    float s_dist = pow(d.x*d.x + d.y*d.y + d.z*d.z,0.6);\n   \n    float t = iTime;\n    \n    mat3 T = mat3(\n         1, 0, 0,\n         0, 1, 0,\n         0, 0, 1\n    );\n    \n    d = T*d;\n    \n    float value = cos(d.x)+cos(d.y)+cos(d.z) + s_dist/a;\n    \n    DistResult result;\n    result.v = value;\n    result.color = normalize(abs(vec3(d.x,d.y,d.z)));\n    return result;\n}\n\nDistResult sdfSphere(vec3 p, vec3 o , float r)\n{\n    vec3 d = p-o;\n    \n    \n    float s_dist = sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n   \n    float value = r-s_dist;\n    \n   \n    DistResult result;\n    result.v = value;\n    result.color = abs(normalize(d));\n    return result;\n}\n\n\nDistResult sdf(vec3 v)\n{\n    DistResult torus,sphere,period,plane,wall;\n    \n    vec3 c = vec3(0,0,4);\n    \n    torus  = sdfTorus(v,   c, vec2(5,2));\n    plane  = sdfPlane(v,   vec3(0,0,-20),vec3(0,0,1));\n    period = sdfPeriod(v,  c,1.0);\n    wall   = sdfPlane(v,   vec3(0,0,0),vec3(1,0,0));\n    sphere = sdfSphere(v, vec3(0,0,-1),80.0);\n\n    float value = min(min(torus.v,period.v),plane.v);\n    \n    if (value == torus.v)  return torus;\n    if (value == plane.v)  return plane;\n    if (value == sphere.v)  return sphere;\n    if (value == period.v) return period;\n    if (value == wall.v)   return  wall;\n}\n\nstruct SurfacePoint\n{\n    vec3 p;\n    vec3 n;\n    vec3 c;\n    float ref;\n    float dif;\n};\n\nvec3 sdf_grad(vec3 p)\n{\n    const float h = 0.0001;\n    const float denom = 1.0/(h);\n    \n    float v = sdf(p).v;\n    \n    float delx = denom*(sdf(p + vec3(h,0,0)).v - v);\n    float dely = denom*(sdf(p + vec3(0,h,0)).v - v);\n    float delz = denom*(sdf(p + vec3(0,0,h)).v - v);\n    \n    vec3 grad = normalize(vec3(delx,dely,delz));\n    return grad;\n}\n\nSurfacePoint march_ray(vec3 o, vec3 ray, float max_dist)\n{\n    vec3 outer = o;\n    \n    SurfacePoint S;\n    DistResult r;\n    r = sdf(outer);\n    S.p = o;\n    S.n = vec3(0.0);\n    S.c = r.color;\n    \n    float dist = r.v;\n        \n    //return 0 if we are inside the object\n    if (dist < 0.0) return S;\n    \n    const int max_steps = 200;\n    int steps = 0;\n    \n    while (dist > epsilon && steps < max_steps)\n    {\n        outer += dist*ray;\n        r = sdf(outer);\n        dist = r.v;\n        \n        S.p = outer;\n        \n        // Break if ray goes too far\n        if (dist_sq(outer,o) > max_dist*max_dist) return S;\n        steps++;\n    }\n    \n    // Now we know that dist < epsilon and dist > 0\n    \n    vec3 hit = outer;\n\n    S.n = sdf_grad(hit);\n    S.p = hit + epsilon*S.n;\n    S.c = r.color;\n    \n    return S;\n}\n\nmat3 view(vec3 normal)\n{\n\tvec3 basis[3];\n\n\tnormal = normalize(normal);\n\tbasis[2] = normal;\n\tbasis[0] = cross(normal, vec3(0,0,1));\n\tbasis[1] = cross(basis[0], basis[2]);\n\tbasis[0] = normalize(basis[0]);\n\tbasis[1] = normalize(basis[1]);\n\n\treturn mat3(basis[0],basis[1],basis[2]);\n}\n\nstruct Light\n{\n    vec3 p;\n    vec3 c;\n    vec3 K;\n};\n\nconst float max_dist = 1000.0;\n\n\nvec3 illuminate(SurfacePoint S, Light light)\n{\n    const float amb = 0.2;\n\n    vec3 K =  light.K;\n    \n    vec3 color = light.c;\n    float lr = length(light.p-S.p);\n    vec3 light_dir = (light.p-S.p)/lr;\n    SurfacePoint L = march_ray(S.p,light_dir,1000.0);\n    \n    float cast_dist = dist_sq(L.p,S.p);\n    float lit = cast_dist < lr*lr ? 0.0 : 1.0;\n    float prod = dot(S.n,light_dir);\n    prod = prod > 0.0 ? prod : 0.0;\n    lit *= prod;\n        \n    return color*S.c*(amb + (1.0-amb)*lit*(K.x/(1.0+lr*K.y+lr*lr*K.z)));\n}\n\nvec3 random_normal(SurfacePoint S)\n{\n    vec2 rand = 2.0*normaldist(S.p);\n    vec3 T_x = normalize(cross(S.n,vec3(-0.61,0.4,0.6)));\n    vec3 T_y = cross(S.n,T_x);\n   \n    return normalize(S.n + rand.x*T_x + rand.y*T_y);\n}\n\nvec3 scatter(SurfacePoint S,Light light)\n{\n    const int scatter_count = 100;\n    const int steps = 1;\n    const vec3 K = vec3(1,1,1);\n    \n    vec3 color_final = vec3(0);\n    int N =0;\n    \n    for (int i = 0; i < scatter_count; i++)\n    {\n        vec3 color = vec3(0);\n        vec3 ray = random_normal(S);\n        \n        float first_incidence = dot(ray,S.n);\n        \n        // Compute light contribution from ray cast out from surface. \n        SurfacePoint P = S;\n        vec3 prev = P.p;\n        P = march_ray(P.p,ray,max_dist); \n         \n        float incidence = first_incidence;\n    \n        for (int i = 0; i < steps; i++)\n        {     \n            if (dot(P.n,P.n) == 0.0) continue;\n            N++;\n            \n            vec3 light_color = illuminate(P,light);\n            float r = length(prev-P.p);\n            \n            color += incidence*light_color/(K.x + K.y*r + K.z*r*r);\n              \n            incidence *= -dot(ray,P.n);\n            ray = reflect(ray,P.n);\n            \n            prev = P.p;\n            P = march_ray(P.p,ray,max_dist); \n            \n            if (abs(incidence) < 0.05) break;\n        } \n        \n        color_final += abs(first_incidence*color*S.c);\n    }\n\n    return color_final;\n}\n\n// Cast a ray from origin (o) and calculate the lighting\n// from an sdf. \nvec3 cast_ray(vec3 o, vec3 ray,Light light)\n{\n    vec3 color_final = vec3(0);\n    const int n_steps = 10;\n    \n    SurfacePoint S,O; // Ray hit at sdf\n    \n    S = march_ray(o+ray,ray,max_dist); \n    \n    if (length(S.n) < 0.1) return vec3(0);\n    \n    // Direct light\n    O = S;\n    color_final += illuminate(O,light);\n    \n    // Reflected light\n    float incidence = 1.0;\n    vec3 light_color = O.c;\n    float ref = pow(sin(iTime),2.0);\n    \n    for (int i = 0; i < n_steps; i++)\n    {      \n        ray = reflect(ray,S.n);\n        incidence *= dot(ray,S.n);\n        S = march_ray(S.p,ray,max_dist); \n        \n        // Light reflected by hit surface\n        light_color *= illuminate(S,light);\n        \n        color_final += incidence*light_color;                           \n                     \n        if (length(light_color*incidence) < 0.05) break;\n    } \n    \n    return color_final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = iTime;\n    \n    // Ray marching\n    vec3 o = 30.0*vec3(cos(t),sin(t),1.5);\n    vec3 n = -o;\n    o += vec3(0,0,4);\n    mat3 coords = view(n);\n    vec2 sp = (2.0*uv - vec2(1.0,1.0))*vec2(1.0,aspect);\n    vec3 ray = normalize(coords[2] + sp.x*coords[0]+ sp.y * coords[1]);\n    \n    Light light;\n    light.p = vec3(0,0,15);\n    light.c = vec3(0.9,1,1);\n    light.K = vec3(1.0,0.0,0.0001);\n  \n    vec3 color = cast_ray(o,ray,light);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}