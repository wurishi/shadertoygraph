{"ver":"0.1","info":{"id":"ttc3Wf","date":"1604706446","viewed":206,"name":"Wandering Horizon","username":"novem","description":"A raymarching terrain. Maybe someday I will learn how to do screen space reflection to make this a little prettier!\n\nAlso, there was supposed to be some clouds as well, but since this implementation became a little heavy I had to scrap that idea.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["terrain","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raymarch scene of a moving horizon\n\n//obs: y-axis points up\n\n//Hold the mouse click to look around!\n\n//Raymarch configurations\n\n\n//Fog distance\n#define fogMin 0.0\n#define fogMax 500.0\n\n//Max Ray Distance\n#define RAY_MAX_DIST 600.0\n\n//Raymarch resolutions-----------\n\n//Precision of the terrain raymarch. Lower this to raise performance\n#define TERRAIN_STEPS 100\n\n//Raises the terrain precision. Raises GPU load exponentially, increase at your own risk\n#define BINARYSTEPS 7\n\n//Terrain Properties------------\n\n//Octaves = detail layers => Higher = more detail\n#define OCTAVES 8\n#define TERRAIN_NOISE_SCALE 0.025\n#define TERRAIN_HEIGHT 30.0\n\n//Maximum height of the terrain below the camera height. Negative values will glitch the terrain.\n#define TERRAIN_POSITION_Y 10.0 \n\n//No need to change this\n#define TERRAIN_NORMAL_DELTA 0.01\n\n//Water Settings----------------\n\n#define WATER_LEVEL -30.0\n#define WATER_COLOR vec3(.2 , .2 , .3)\n\n\n//Sun Settings\n#define SUN_COLOR vec3(1.0, 1.0, 0.8)\n#define SUN_ANGLE 0.25\n#define SUN_FALLOFF 5.\n\n\n//Camera and Sun Revolution\n#define CAMERA_MOVE_SPEED 20.0\n#define DAY_REVOLUTION_DURATION 25.0\n\n\n//near-clipping plane\nfloat ncDist = 1.0; \n\n//Field of View\nfloat fov = 60.0;\n\n//COLORS\n#define blue vec3(0,0,1)\n#define red vec3(1,0,0)\n#define green vec3(0,1,0)\n#define white vec3(1,1,1)\n#define black vec3(0,0,0)\n\n//Sunrise color\n#define DAWN_COLOR vec3(.97, .78, .64)\n\n//Sky Color\nvec3 ambColor = vec3(.7,.9,.95); // sky color at night is sky color divided by 5\n\n\n//check TerrainColorByHeight Function to see how those colors works exactly:\n//Terrain colors at top, middle and lower level\n#define TOP_COLOR vec3(.9, .8, .71)\n#define MID_COLOR vec3(.45, .35, .28)\n#define BOTTOM_COLOR vec3(.24, .31, .23)\n//Colors by normal\n#define NORMAL_SIDE vec3(.58, .47, .35) \n#define NORMAL_TOP vec3(.35, .4, .35)\n\n\n\n//Support values\n\n#define PI 3.141592\n\n\n//Global Variables\nvec3 cameraPos = vec3(0.);\nfloat cameraTilt = .0;    \nfloat cameraPan = .0;\n\n\n//Starting light direction\n//It's only initialized here, the function that actually defines the \n//sun's trajectory is inside the mainImage function (bottom of page)\nvec3 lightDir = vec3(0.0);\n\n\n//Noise algorithms as presented by Inigo Quilez at https://thebookofshaders.com/edit.php#11/2d-gnoise.frag\n\nvec2 random2(vec2 st) //range -1 to 1\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 random3(vec3 p) //range -1 to 1\n{\n    p = vec3(\n        \t\tdot(p, vec3(127.1, 311.7, 98.8)),\n        \t\tdot(p, vec3(268.5, 193.3, 342.4)),\n        \t\tdot(p, vec3(450.2, 110.4, 85.3))\n        \t);\n    \n    return -1.0 + 2.0 * fract(sin(p)* 61324.6492314);\n}\n\nfloat noise(vec2 st) { //perlin noise\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise3d(vec3 p) //perlin noise\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n     vec3 u = f*f*f*(f*(f*6.-15.)+10.);\n    \n    return mix(\n        \t\t\tmix(\n                        mix(\n                                dot( random3 (i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                                dot( random3 (i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ),\n                                u.x\n                            ),\n\n                        mix(\n                                dot( random3 (i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                                dot( random3 (i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ),\n                                u.x\n                            ),\n                        u.y\n                    ),\n        \n        \t\t\tmix(\n                        \n                        mix(\n                                dot( random3 (i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                                dot( random3 (i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ),\n                                u.x\n                            ),\n\n                        mix(\n                                dot( random3 (i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                                dot( random3 (i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ),\n                                u.x\n                            ),\n                        u.y\n                    ),\n        \n        \t\t\tu.z    \n    \t\t   );\n    \n}\n\nfloat perlinNoise3d(vec3 pos, float scale, int octaves)\n{\n    pos*= scale; //scaling\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n     \tresult += (noise3d(pos*exp2(float(i))) - .5) / exp2(float(i));\n    }    \n    \n    result += .5;\n    \n    result = result*.5+.5;\n    \n    return result;\n}\n\n\nfloat perlinNoise(vec2 pos, float scale, int octaves) //returns the perlin noise, with octaves considered\n{\n    pos*= scale; //scaling\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n     \tresult += (noise(pos*exp2(float(i))) / exp2(float(i)));\n    }    \n    \n    \n    result = result*.5+.5;\n    \n    return result;\n}\n\n\nfloat h_combine(float h1, float h2) //height combine\n{\n    h1 -= 0.5;\n    h2 -= 0.5;\n    \n    return (h1+h2) + .5;\n}\n\n\n\n//takes two angles (in degrees) and returns a normalized direction vector after applying both as rotations\n//both angles set to 0 returns vec3 = (1,0,0)\nvec3 GetDirByAngles(float xzAngle, float yAngle)\n{\n    const float degToRad = PI / 180.0;\n    \n    xzAngle *= degToRad;\n    \n    yAngle *= degToRad;\n    \n    \n    vec2 xzpos = vec2 (cos(xzAngle), sin(xzAngle));\n    \n    xzpos *= cos(yAngle);\n    \n    vec3 finalDir = vec3(xzpos.x, sin(yAngle), xzpos.y);\n        \n    return finalDir;\n}\n\nvec4 SunColor(vec3 rayDir, vec3 lightDir, float angle, float smoothAngle)\n{\n \tfloat angleDirToLight = acos(clamp(dot(rayDir, lightDir),0.0,1.0)) * 180.0/PI;\n                  \n    float interpolator;\n    \n    if(angleDirToLight <= angle)\n        interpolator = 1.0;\n    \n    else if(angleDirToLight < angle + smoothAngle)\n    {\n        interpolator = smoothstep(1.0,0.0,(angleDirToLight - angle)/smoothAngle);\n    }\n    else\n        interpolator = 0.0;\n    \n    \n    return vec4(interpolator * SUN_COLOR , 1.0);\n    \n}\n\nvec3 TerrainColorByHeight(float h, vec3 normal)\n{\n    float top_h = -43.0;\n    float mid_h = -55.0;\n    float bot_h = -60.0;\n    \n    vec3 h_Color;\n    float hFactor;\n    \n    if(h < bot_h)\n    \th_Color = BOTTOM_COLOR;\n    else if(h< mid_h)\n    {\n        hFactor = smoothstep(0.,1., (h - bot_h)/(mid_h-bot_h));\n        h_Color = mix(BOTTOM_COLOR, MID_COLOR, hFactor);\n    }\n    else if(h< top_h)\n    {\n        hFactor = smoothstep(0.,1., (h - mid_h)/(top_h-mid_h));\n        h_Color = mix(MID_COLOR, TOP_COLOR, hFactor);\n    }\n    else\n    \th_Color = TOP_COLOR;\n    \n    float nFactor;\n    vec3 n_Color;\n    \n    //0-1 from normal [.3, .4]\n    nFactor = smoothstep(0.,1., (abs(normal.y)-.5)/.3);\n    \n    n_Color = mix(NORMAL_SIDE, NORMAL_TOP, nFactor);\n    \n    return mix(h_Color, n_Color, .7);\n    \n}\n    \n  \n\nvec4 lighting_lambert (vec3 l_dir, float l_intensity, vec3 normal, vec3 surf_color)\n{\n \tfloat NdotL = max(dot(normal, l_dir), 0.0);\n    \n    if(l_dir.y < 0.2)\n    {\n        NdotL = mix(0.0, NdotL, clamp((l_dir.y + .2)/.4, .0, 1.0) );\n    }\n    \n    vec3 reflectedColor = ambColor * .15;    \n    \n    float aux = NdotL * NdotL;\n    \n    \n    return vec4((NdotL * surf_color * l_intensity) + (1.0-aux) * reflectedColor, 1.0);\n    \n}\n\n\nfloat TerrainNoise(vec2 p)\n{\n    return 1.0 - perlinNoise(p.xy, TERRAIN_NOISE_SCALE, OCTAVES);\n}\n\n\nvec4 marchInsideTerrain(vec3 dir, vec3 p, float currentDist)\n{\n    float startH = p.y;\n    \n    float effectiveHeight = TERRAIN_HEIGHT*(2.0-pow(2.0, -float(OCTAVES)));    \n    \n    float deltaStep = (effectiveHeight - WATER_LEVEL)/float(TERRAIN_STEPS);\n    \n    vec3 offset = (dir/abs(dir.y)) * deltaStep;\n    \n    vec3 lastP = p;\n    \n    \n    float stepLength = length(offset);\n    \n \tfor(int i=0; i< TERRAIN_STEPS; i++)\n    {\n        \n     \t//check if ray is inside the Terrain\n        if(p.y <= startH - TerrainNoise(p.xz) * TERRAIN_HEIGHT)\n        {\n            \n            #ifdef BINARYSTEPS\n            \n            \n            for(int s=1;s<=BINARYSTEPS; s++)\n            {\n             \tif(p.y <= startH - TerrainNoise(p.xz) * TERRAIN_HEIGHT)\n                    p-= offset/exp2(float(s));\n                else\n                    p+= offset/exp2(float(s));\n            }\n            \n            \n            #endif\n            \n            if(p.y < WATER_LEVEL)\n            {\n                float fogFactor = clamp( (currentDist - fogMin) / (fogMax - fogMin), 0.0 , 1.0 );\n                \n                return mix(lighting_lambert (lightDir, 1.0, vec3(0.0,1.0,0.0), (WATER_COLOR * ambColor) / 2.), vec4(ambColor,1.0), fogFactor);\n            }\n            \n            \n            \n            //if it is, grab the local normal, and return the lit color\n            \n            vec3 normal = normalize(vec3( TERRAIN_HEIGHT * ( (1.0-TerrainNoise(vec2(p.x - TERRAIN_NORMAL_DELTA, p.z))) - (1.0-TerrainNoise(vec2(p.x + TERRAIN_NORMAL_DELTA, p.z)))),\n                                                    \n                \t\t\t\t\t\t\t2.0 * TERRAIN_NORMAL_DELTA,\n                                         \n\t\t\t\t\t\t\t\t\t\t\tTERRAIN_HEIGHT * ((1.0-TerrainNoise(vec2(p.x, p.z - TERRAIN_NORMAL_DELTA))) - (1.0-TerrainNoise(vec2(p.x, p.z + TERRAIN_NORMAL_DELTA))))                \n                \t\t\t\t\t\t)           \n                \t\t\t\t\t);\n            \n            float fogFactor = clamp( (currentDist - fogMin) / (fogMax - fogMin), 0.0 , 1.0 );\n            \n            vec3 TerrainColor = TerrainColorByHeight(p.y, normal);\n            return mix(lighting_lambert (lightDir, 1.0, normal, TerrainColor), vec4(ambColor,1.0), fogFactor);\n            \n        }\n        \n        lastP = p;\n        p += offset;\n        currentDist += stepLength;\n        \n       if(currentDist > RAY_MAX_DIST) \n           return vec4(0.0);\n        \n    }\n    \n    return vec4(0.0);\n}\n\nvec4 findTerrain(vec3 dir, vec3 p)//find the terrain plane, and begin raymarching from there\n{\n    \n    if(abs(dir.y) > .01)\n    {\n    \n        float totalTravel = ((p.y - TERRAIN_POSITION_Y)/dir.y);\n        \n        if(totalTravel > RAY_MAX_DIST)\n            return vec4(0);   \n\n        p += dir * totalTravel;\n\n        return marchInsideTerrain(dir, p, totalTravel);\n    } \n       \n   \n    \n    \n    return vec4(0);\n}\n\nvec3 AmbColorByLightDir(vec3 lDir)\n{\n    vec3 dawnColor = DAWN_COLOR;\n    \n    float nightHeight = -.2;\n    float dawnHeight = .2;\n    float dayHeight = .6;\n    \n    if(lDir.y < nightHeight)\n        return ambColor * .2;\n    \n    else if(lDir.y < dawnHeight)\n    {\n        float factor = smoothstep(0.,1., (lDir.y - nightHeight)/(dawnHeight - nightHeight));\n        return mix(ambColor * .2, dawnColor, factor);\n    }\n    \n    else if(lDir.y < dayHeight)\n    {\n        float factor = smoothstep(0.,1., (lDir.y - dawnHeight)/(dayHeight - dawnHeight));\n        return mix(dawnColor, ambColor, factor);\n    }\n    else\n        return ambColor;\n    \n    \n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 trueUv = uv;\n    //remapping the uv to [-1, 1] range\n    uv = (uv - .5) * 2.0;\n    \n    lightDir = GetDirByAngles(60.0,25.0 + iTime * 360.0/DAY_REVOLUTION_DURATION);\n    \n    ambColor = AmbColorByLightDir(lightDir);\n       \n    float clippingPlaneWidth = tan(fov * PI / 360.0) * 2.0 * ncDist;\n    \n    float clippingPlaneHeight = clippingPlaneWidth * (iResolution.y/iResolution.x);\n    \n    if(iMouse.z > 0.)\n    {\n        cameraTilt = -((iMouse.y/iResolution.y)-.5)* PI;    \n    \tcameraPan = -((iMouse.x/iResolution.x)-.5)*2.0 * PI;\n    }\n    \n    float cameraAngle = cameraTilt * PI / 180.0;\n    \n     \n    \n    vec3 camRight = vec3(cos(cameraPan), 0., sin(cameraPan));\n    \n    vec3 camFwd = vec3(cos(cameraPan + (PI/2.)), 0., sin(cameraPan + (PI/2.)));\n    \n    camFwd = camFwd * cos(cameraTilt) + cross(camRight, camFwd)*sin(cameraTilt); \n    \n    vec3 camUp = normalize(-cross(camRight, camFwd));\n    \n    \n    \n    \n    vec3 startPos = camFwd * ncDist + camRight * uv.x * clippingPlaneWidth + camUp * uv.y * clippingPlaneHeight;\n        \n    \n    vec3 rayDir = normalize(startPos - cameraPos);\n    \n    vec4 col = findTerrain(rayDir, startPos + vec3(0.0,0.0,iTime * CAMERA_MOVE_SPEED));\n    \n    \n    vec4 SunColor = SunColor(rayDir, lightDir, SUN_ANGLE, SUN_FALLOFF);\n    \n    \n\n   \n    col = mix(vec4(ambColor + vec3(SunColor),1.0), col, col.w);\n    //col = texture(iChannel0, trueUv,0.0); //visualize buffer A\n    \n    \n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Vizualization Buffer\n\n\nvec2 random2(vec2 st) //range -1 to 1\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 random3(vec3 p) //range -1 to 1\n{\n    p = vec3(\n        \t\tdot(p, vec3(127.1, 311.7, 98.8)),\n        \t\tdot(p, vec3(268.5, 193.3, 342.4)),\n        \t\tdot(p, vec3(450.2, 110.4, 85.3))\n        \t);\n    \n    return -1.0 + 2.0 * fract(sin(p)* 61324.6492314);\n}\n\nvec2 random2worley( vec2 p ) //range 0 to 1\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 random3worley(vec3 p)\n{\n     p = vec3(\n        \t\tdot(p, vec3(127.1, 311.7, 98.8)),\n        \t\tdot(p, vec3(268.5, 193.3, 342.4)),\n        \t\tdot(p, vec3(450.2, 110.4, 85.3))\n        \t);\n    \n    return fract(sin(p)* 61324.6492314);\n}\n\nfloat noise(vec2 st) { //perlin noise\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise3d(vec3 p) //perlin noise\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n     vec3 u = f*f*f*(f*(f*6.-15.)+10.);\n    \n    return mix(\n        \t\t\tmix(\n                        mix(\n                                dot( random3 (i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                                dot( random3 (i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ),\n                                u.x\n                            ),\n\n                        mix(\n                                dot( random3 (i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                                dot( random3 (i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ),\n                                u.x\n                            ),\n                        u.y\n                    ),\n        \n        \t\t\tmix(\n                        \n                        mix(\n                                dot( random3 (i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                                dot( random3 (i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ),\n                                u.x\n                            ),\n\n                        mix(\n                                dot( random3 (i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                                dot( random3 (i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ),\n                                u.x\n                            ),\n                        u.y\n                    ),\n        \n        \t\t\tu.z    \n    \t\t   );\n    \n}\n\nfloat perlinNoise3d(vec3 pos, float scale, int octaves)\n{\n    pos*= scale; //scaling\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n     \tresult += (noise3d(pos*exp2(float(i))) - .5) / exp2(float(i));\n    }    \n    \n    result += .5;\n    \n    result = result*.5+.5;\n    \n    return result;\n}\n\n\nfloat perlinNoise(vec2 pos, float scale, int octaves) //returns the perlin noise, with octaves considered\n{\n    pos*= scale; //scaling\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n     \tresult += (noise(pos*exp2(float(i))) - .5) / exp2(float(i));\n    }    \n    \n    result += .5;\n    \n    result = result*.5+.5;\n    \n    return result;\n}\n\nfloat worleyNoise(vec2 pos, float scale, int octaves)\n{\n    pos *= scale;\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n        vec2 tempPos = exp2(float(i)) * pos;\n\n        vec2 i_pos = floor(tempPos);\n        vec2 f_pos = fract(tempPos);\n\n        float m_dist = 1.; //minimum distance\n\n        for (int y= -1; y <= 1; y++)\n        {\n            for (int x= -1; x <= 1; x++) {\n                // Neighbor place in the grid\n                vec2 neighbor = vec2(float(x),float(y));\n\n                // Random position from current + neighbor place in the grid\n                vec2 point = random2worley(i_pos + neighbor);\n\n                // Vector between the pixel and the point\n                vec2 diff = neighbor + point - f_pos;\n\n                // Distance to the point\n                float dist = length(diff);\n\n                // Keep the closer distance\n                m_dist = min(m_dist, dist);\n            }\n        }\n\n        result += ((1.0-m_dist) -.5)/exp2(float(i));  \n    }\n    \n    result += .5;\n    \n    return result;\n}\n\nfloat worleyNoise3d(vec3 pos, float scale, int octaves)\n{\n    pos *= scale;\n    \n    float result = 0.0;\n    \n    for(int i=0;i<octaves;i++)\n    {\n        vec3 tempPos = exp2(float(i)) * pos;\n\n        vec3 i_pos = floor(tempPos);\n        vec3 f_pos = fract(tempPos);\n\n        float m_dist = 1.; //minimum distance\n\n        for (int z= -1; z <= 1; z++)\n        {\n            for (int y= -1; y <= 1; y++)\n            {\n                for (int x= -1; x <= 1; x++) \n                {\n\n                    // Neighbor place in the grid\n                    vec3 neighbor = vec3(float(x),float(y), float(z));\n\n                    // Random position from current + neighbor place in the grid\n                    vec3 point = random3worley(i_pos + neighbor);\n\n                    // Vector between the pixel and the point\n                    vec3 diff = neighbor + point - f_pos;\n\n                    // Distance to the point\n                    float dist = length(diff);\n\n                    // Keep the closer distance\n                    m_dist = min(m_dist, dist);\n                }\n            }\n        }\n\n        result += ((1.0-m_dist) -.5)/exp2(float(i));  \n    }\n    \n    result += .5;\n    \n    return result;\n}\n\n\nfloat h_combine(float h1, float h2) //height combine\n{\n \th1 -= 0.5;\n    h2 -= 0.5;\n    \n    return (h1+h2) + .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = (uv - .5) * 2.0;\n        \n       \n    vec3 col;\n    \n    //2d noises\n    //col = vec3(h_combine(worleyNoise(uv, 5.0, 3), perlinNoise(uv, 6.0, 4))); \n    \n    //3d noises\n    col = vec3(h_combine(perlinNoise3d(vec3(uv, 0.0 + iTime/10.0), 3.0, 4), worleyNoise3d(vec3(uv, 0.0 + iTime/10.0), 2.0, 4))); \n\n    \n    //col = vec3(perlinNoise3d(vec3(uv, 0.0 + iTime/10.0), 3.0, 4));\n    //col = vec3(worleyNoise3d(vec3(uv, 0.0 + iTime/10.0), 2.0, 6));\n    \n   \n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}