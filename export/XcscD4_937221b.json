{"ver":"0.1","info":{"id":"XcscD4","date":"1721150093","viewed":115,"name":"Scyphozoan","username":"igneus","description":"Using metaballs and recursive blending to create a psychedelic deep sea creature. \n\nClick to see individual buffers.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["jellyfish","sealife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 rgba, in vec2 xyScreen)\n{     \n    vec2 xyZone = (iMouse.z <= 0.) ? xyScreen : vec2(ivec2(xyScreen * 2.) % ivec2(iResolution.xy));\n    int zoneIdx = (iMouse.z <= 0.) ? 1 : (2 * int(xyScreen.y / (iResolution.y * 0.5)) + int(xyScreen.x / (iResolution.x * 0.5)));\n    \n    vec3 L = kZero;\n    \n    SetGlobals(xyZone, iResolution.xy);    \n    PCGInitialise(HashOf(uint(iFrame)));  \n    \n    switch(zoneIdx)\n    {    \n    case 1:\n    {\n        // Soft defocus blur\n        int defocusRadius = max(1, int(3. * iResolution.x / 1200.));\n        vec3 sumWeights = kZero;\n        for(int v = -defocusRadius; v <= defocusRadius; ++v)\n        {\n            for(int u = -defocusRadius; u <= defocusRadius; ++u)\n            {            \n                vec2 uv = vec2(xyZone.x + float(u * 1), xyZone.y + float(v * 1));\n\n                float d = length(xyZone - iResolution.xy * 0.5) / (iResolution.y * 0.5);         \n                vec3 weight = exp(-sqr(vec3(0.1, 0.2, 0.4) * length(vec2(u, v)) / max(1e-5, d - 0.1)));            \n\n                L += texture(iChannel0, (uv + vec2(0.5)) / iResolution.xy, 0.0).xyz * weight;\n                sumWeights += weight;\n            }\n        }\n        L /= sumWeights;  \n\n        // Add second pass of separable bloom\n        if(kApplyBloom)\n        {\n            vec3 bloom = Bloom(xyZone, iResolution, ivec2(0, 1), iChannel1) * kBloomGain; \n            if(kDebugBloom)\n            {\n                 rgba = vec4(bloom, 1.0);\n                 return;\n            }\n\n            L += pow(bloom * 0.5, vec3(1.));\n        }  \n\n        // Gamma correct\n        #define kOutputGain 1.\n        #define kOutputGamma 1.2\n        L = pow(saturate(kOutputGain * L), vec3(1.0 / kOutputGamma));    \n\n        // Boost the saturation\n        vec3 hsv = RGBToHSV(L);    \n        hsv.z *= 1.1;\n        L = HSVToRGB(hsv);  \n\n        // Lift up the blacks\n        L = (L * vec3(0.9)) + vec3(0.08);\n    } \n    break;\n    case 0:\n        L = texelFetch(iChannel1, ivec2(xyZone) / kBloomDownsample, 0).xyz; break;\n    case 2:\n        L = texelFetch(iChannel2, ivec2(xyZone), 0).xyz; break;        \n    case 3:\n        L = texelFetch(iChannel0, ivec2(xyZone), 0).xyz; break;            \n    }\n\n    rgba = vec4(L, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\n#define Timecode               vec2\n\n#define kPi                    3.14159265359\n#define kInvPi                 (1.0 / 3.14159265359)\n#define kTwoPi                 (2.0 * kPi)\n#define kFourPi                (4.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kLog10                 2.30258509299\n#define kFltMax                3.402823466e+38\n#define kOneThird              (1.0 / 3.0)\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.)\n#define kZero                  vec3(0.)\n#define kRed                   vec3(1., 0., 0.)\n#define kGreen                 vec3(0., 1., 0.)\n#define kBlue                  vec3(0., 0., 1.)\n#define kPink                  vec3(1., 0., 0.2)\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nvec2 sqr(vec2 a)               { return a * a; }\nvec3 sqr(vec3 a)               { return a * a; }\nvec4 sqr(vec4 a)               { return a * a; }\nint sqr(int a)                 { return a * a; }\nint cub(int a)                 { return a * a * a; }\nfloat cub(float a)             { return a * a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat mod2(float a, float b)   { return mod(mod(a, b) + b, b); }\nvec3 mod2(vec3 a, vec3 b)      { return mod(mod(a, b) + b, b); }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\nvec3 saturate(vec3 a)          { return clamp(a, 0.0, 1.0); }\nvec4 saturate(vec4 a)          { return clamp(a, 0.0, 1.0); }\nfloat saw01(float a)           { return abs(fract(a) * 2.0 - 1.0); }\nfloat cwiseMax(vec3 v)         { return (v.x > v.y) ? ((v.x > v.z) ? v.x : v.z) : ((v.y > v.z) ? v.y : v.z); }\nfloat cwiseMax(vec2 v)         { return (v.x > v.y) ? v.x : v.y; }\nint cwiseMax(ivec2 v)        { return (v.x > v.y) ? v.x : v.y; }\nfloat cwiseMin(vec3 v)         { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nfloat cwiseMin(vec2 v)         { return (v.x < v.y) ? v.x : v.y; }\nfloat max3(float a, float b, float c) { return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c); }\nfloat min3(float a, float b, float c) { return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c); }\nvoid sort(inout float a, inout float b) { if(a > b) { float s = a; a = b; b = s; } }\nvoid swap(inout float a, inout float b) { float s = a; a = b; b = s; }\nvoid swap(inout int a, inout int b) { int s = a; a = b; b = s; }\n\nvec3 safeAtan(vec3 a, vec3 b)\n{\n    vec3 r;\n    #define kAtanEpsilon 1e-10\n    r.x = (abs(a.x) < kAtanEpsilon && abs(b.x) < kAtanEpsilon) ? 0.0 : atan(a.x, b.x); \n    r.y = (abs(a.y) < kAtanEpsilon && abs(b.y) < kAtanEpsilon) ? 0.0 : atan(a.y, b.y); \n    r.z = (abs(a.z) < kAtanEpsilon && abs(b.z) < kAtanEpsilon) ? 0.0 : atan(a.z, b.z); \n    return r;\n}\n\nvec3 GuardedNormalise(vec3 v, vec3 n)\n{\n    float len = length(v);\n    return (len > 1e-10) ? (v / len) : n;\n}\n\nvec3 SafeNormaliseTexel(vec4 t)\n{\n    return t.xyz / max(1e-15, t.w);\n}\n\nvec4 Sign(vec4 v)\n{\n    return step(vec4(0.0), v) * 2.0 - 1.0;\n}\n\nfloat Sign(float v)\n{\n    return step(0.0, v) * 2.0 - 1.0;\n}\n\nbool IsNan( float val )\n{\n    return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nbvec3 IsNan( vec3 val )\n{\n    return bvec3( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true);\n}\n\nbvec4 IsNan( vec4 val )\n{\n    return bvec4( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true,\n                  ( val.w < 0.0 || 0.0 < val.w || val.w == 0.0 ) ? false : true);\n}\n\n\n#define SignedGamma(v, gamma) (sign(v) * pow(abs(v), gamma))\n\n// *******************************************************************************************************\n// Global variables\n\nvec2 gResolution;\nvec2 gFragCoord;\nuvec4 rngSeed;\nfloat gDxyDuv;\n\nvoid SetGlobals(vec2 fragCoord, vec2 resolution)\n{\n    gFragCoord = fragCoord;\n    gResolution = resolution;\n    \n     // First derivative of screen to world space (assuming square pixels)\n    gDxyDuv = 1.0 / min(gResolution.x, gResolution.y);\n}\n\nbool IsTexelInClipRegion(vec2 xy)\n{\n    //return true;\n    return (abs(xy.x - (gResolution.x / 2.0)) < gResolution.y / 2.0);\n}\n\n\n// *******************************************************************************************************\n//    Half-precision float\n// *******************************************************************************************************\n\n#define half uint\n//#define USE_REFERENCE_FLOAT_PACKING\n\n#ifdef USE_REFERENCE_FLOAT_PACKING\n\n    half FloatToHalf(float f)\n    {\n        float exponent = ceil(log(abs(f)));\n        int mantissa = int(float((1 << 10) - 1) * (abs(f) / exp(exponent)));\n\n        return (half((sign(f) + 1.0) * 0.5) << 15u) | half((int(exponent) + 15) << 10) | half(mantissa);\n    }\n\n    float HalfToFloat(half h)\n    {\n        float exponent = float(((int(h) >> 10) & ((1 << 5) - 1)) - 15);\n        float mantissa = float(int(h) & ((1 << 10) - 1)) / float((1 << 10) - 1);\n        float sgn = float((int(h) >> 15) & 1) * 2.0 - 1.0;\n\n        return mantissa * exp(exponent) * sgn;\n    }\n\n    float PackFloats(in float a, in float b)\n    {\n        return uintBitsToFloat((FloatToHalf(a) << 16) | FloatToHalf(b));\n    }\n\n    void UnpackFloats(in float packed, out float a, out float b)\n    {\n        a = HalfToFloat(floatBitsToUint(packed) >> 16);\n        b = HalfToFloat(floatBitsToUint(packed) & uint((1 << 16) - 1));\n    }\n    \n#else\n\n    float PackFloats(in float a, in float b)\n    {\n        return uintBitsToFloat(packHalf2x16(vec2(a, b)));\n    }\n\n    float PackFloats(in vec2 v)\n    {\n        return uintBitsToFloat(packHalf2x16(v));\n    }\n\n    void UnpackFloats(in float i, out float a, out float b)\n    {\n        vec2 v = unpackHalf2x16(floatBitsToUint(i));\n        a = v.x; b = v.y;\n    }\n\n    vec2 UnpackFloats(in float i)\n    {\n        return unpackHalf2x16(floatBitsToUint(i));\n    }\n    \n#endif\n\n// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\nfloat SmoothStep(float a, float b, float x) { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nvec4 SmoothStep(vec4 a, vec4 b, float x)    { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nfloat SmoothStep(float x)                   { return mix(0.0, 1.0, x * x * (3.0 - 2.0 * x)); }\n\n//float SineStep(float a, float b, float x) { return mix(a, b, sin(x * kPi - kHalfPi) * 0.5 + 0.5); }\n\nfloat PaddedSmoothStep(float x, float a, float b)\n{ \n    return SmoothStep(saturate(x * (a + b + 1.0) - a));\n}\n\nfloat PaddedSmoothStep(float x, float a)\n{\n    return PaddedSmoothStep(x, a, a);\n}\n\nfloat Impulse(float x, float axis, float stdDev)\n{\n    return exp(-sqr((x - axis) / stdDev));\n}\n\nfloat AnisotropicImpulse(float x, float axis, float stdDevA, float stdDevB)\n{\n    float impulse = (x < axis) ? exp(-sqr((x - axis) / stdDevA)) : exp(-sqr((x - axis) / stdDevB));\n    return saturate((impulse - 0.05) / (1.0 - 0.05));\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    if(t < p1.x)\n    {\n        return mix(p0.y, p1.y, max(0.0, exp(-sqr((t - p1.x)*2.145966026289347/(p1.x-p0.x))) - 0.01) / 0.99);\n    }\n    else if(t < p2.x)\n    {\n        return mix(p1.y, p2.y, (t - p1.x) / (p2.x - p1.x));\n    }\n    else\n    {  \n        return mix(p3.y, p2.y, max(0.0, exp(-sqr((t - p2.x)*2.145966026289347/(p3.x-p2.x))) - 0.01) / 0.99);\n    }\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n    return KickDrop(t, p0, p1, p1, p2);\n}\n\nbool QuadraticSolve(float a, float b, float c, out float t0, out float t1)\n{\n    float b2ac4 = b * b - 4.0 * a * c;\n    if(b2ac4 < 0.0) { return false; } \n\n    float sqrtb2ac4 = sqrt(b2ac4);\n    t0 = (-b + sqrtb2ac4) / (2.0 * a);\n    t1 = (-b - sqrtb2ac4) / (2.0 * a);    \n    return true;\n}\n\n// Closed-form approxiation of the error function.\n// See 'Uniform Approximations for Transcendental Functions', Winitzki 2003, https://doi.org/10.1007/3-540-44839-X_82\nfloat ErfApprox(float x)\n{    \n     float a = 8.0 * (kPi - 3.0) / (3.0 * kPi * (4.0 - kPi));\n     return sign(x) * sqrt(1.0 - exp(-(x * x) * (4.0 / kPi + a * x * x) / (1.0 + a * x * x)));\n}\n\n// The antiderivative of the normalised Gaussian with standard deviation sigma\nfloat AntiderivGauss(float x, float sigma)\n{    \n    return 0.5 * (1.0 + ErfApprox(x / (sigma * kRoot2)));\n}\n\n// *******************************************************************************************************\n//    2D SVG\n// *******************************************************************************************************\n\nfloat SDFLine(vec2 p, vec2 v0, vec2 v1, float thickness)\n{\n    v1 -= v0;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1));\n    vec2 perp = v0 + t * v1;\n    return saturate((thickness - length(p - perp)) / gDxyDuv);\n}\n\nfloat SDFQuad(vec2 p, vec2 v[4], float thickness)\n{\n    float c = 0.0;\n    for(int i = 0; i < 4; i++)\n    {\n        c = max(c, SDFLine(p, v[i], v[(i+1)%4], thickness)); \n    }\n \n    return c;\n}\n\nfloat SDFCircle(vec2 p, vec2 o, float r, float thickness, bool fill)\n{\n    float dist = fill ? ((r - length(o - p)) / thickness) : (1.0 - abs(r - length(o - p)) / thickness);\n    return saturate(dist);\n}\n\n// *******************************************************************************************************\n//    2D primitive tests\n// *******************************************************************************************************\n\nbool IsPointInQuad(vec2 uv, vec2 v[4])\n{\n    for(int i = 0; i < 4; i++)\n    {\n        if(dot(uv - v[i], v[i] - v[(i+1)%4]) > 0.0) { return false; }\n    }\n    return true;\n}\n\n// *******************************************************************************************************\n//    Transforms \n// *******************************************************************************************************\n\nmat3 WorldToViewMatrix(float rot, vec2 trans, float sca)\n{   \n    return mat3(vec3(cos(rot) / sca, sin(rot) / sca, trans.x), \n                vec3(-sin(rot) / sca, cos(rot) / sca, trans.y),\n                vec3(0.0, 0.0, 1.0));\n}\n\nmat3 WorldToViewMatrix(vec2 trans, float sca)\n{   \n    return mat3(vec3(1.0 / sca, 0.0, trans.x), \n                vec3(0.0, 1.0 / sca, trans.y),\n                vec3(0.0, 0.0, 1.0));\n}\n\nvec2 TransformScreenToWorld(vec2 p)\n{   \n    return (p - vec2(gResolution.xy) * 0.5) / float(gResolution.y); \n}\n\nvec2 TransformScreenToWorld(vec2 p, vec2 o)\n{   \n    return (p - o * 0.5) / float(gResolution.y); \n}\n\n\nvec3 Cartesian2DToBarycentric(vec2 p)\n{    \n    return vec3(p, 0.0) * mat3(vec3(0.0, 1.0 / 0.8660254037844387, 0.0),\n                          vec3(1.0, 0.5773502691896257, 0.0),\n                          vec3(-1.0, 0.5773502691896257, 0.0));\n    \n}\n\nmat2 Rotate2D(float theta)\n{\n    float sinTheta = sin(theta), cosTheta = cos(theta);\n    return mat2(vec2(cosTheta, sinTheta),\n                vec2(-sinTheta, cosTheta));\n}\n\n// Maps an input uv position to periodic hexagonal tiling\n//     inout vec2 uv: The mapped uv coordinate\n//     out vec3 bary: The Barycentric coordinates at the point on the hexagon\n//     out ivec2 ij: The coordinate of the tile\nvec2 Cartesian2DToHexagonalTiling(in vec2 uv, out vec3 bary, out ivec2 ij)\n{    \n    #define kHexRatio vec2(1.5, 0.8660254037844387)\n    vec2 uvClip = mod(uv + kHexRatio, 2.0 * kHexRatio) - kHexRatio;\n    \n    ij = ivec2((uv + kHexRatio) / (2.0 * kHexRatio)) * 2;\n    if(uv.x + kHexRatio.x <= 0.0) ij.x -= 2;\n    if(uv.y + kHexRatio.y <= 0.0) ij.y -= 2;\n    \n    bary = Cartesian2DToBarycentric(uvClip);\n    if(bary.x > 0.0)\n    {\n        if(bary.z > 1.0) { bary += vec3(-1.0, 1.0, -2.0); ij += ivec2(-1, 1); }\n        else if(bary.y > 1.0) { bary += vec3(-1.0, -2.0, 1.0); ij += ivec2(1, 1); }\n    }\n    else\n    {\n        if(bary.y < -1.0) { bary += vec3(1.0, 2.0, -1.0); ij += ivec2(-1, -1); }\n        else if(bary.z < -1.0) { bary += vec3(1.0, -1.0, 2.0); ij += ivec2(1, -1); }\n    }\n\n    return vec2(bary.y * 0.5773502691896257 - bary.z * 0.5773502691896257, bary.x);\n}\n\nbool InverseSternograph(inout vec2 uv, float zoom)\n{\n    float theta = length(uv) * kPi * zoom;\n    if(theta >= kPi - 1e-1) { return false; }\n    \n    float phi = atan(-uv.y, -uv.x) + kPi;\n    \n    vec3 sph = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), -cos(theta));\n    \n    uv = vec2(sph.x / (1.0 - sph.z), sph.y / (1.0 - sph.z));\n    return true;\n}\n\n// *******************************************************************************************************\n//    Random number generation\n// *******************************************************************************************************\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 PCGAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 Rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (ivec2(gFragCoord) + ivec2(PCGAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 Rand()\n{\n    return vec4(PCGAdvance()) / float(0xffffffffu);\n}\n\n// Generates a tuple of canonical random numbers\n#define URand PCGAdvance()\nivec4 IRand() { return ivec4(PCGAdvance()); }\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid PCGInitialise(uint frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * frame;\n}\n\n// Reverse the bits of 32-bit inteter\nuint RadicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HaltonBase2(uint i)\n{    \n    return float(RadicalInverse(i)) / float(0xffffffffu);\n}\n\nfloat HaltonBase3(uint seed)\n{\n    uint accum = 0u;\n    accum += 1162261467u * (seed % 3u); seed /= 3u;\n    accum += 387420489u * (seed % 3u); seed /= 3u;\n    accum += 129140163u * (seed % 3u); seed /= 3u;\n    accum += 43046721u * (seed % 3u); seed /= 3u;\n    accum += 14348907u * (seed % 3u); seed /= 3u;\n    accum += 4782969u * (seed % 3u); seed /= 3u;\n    accum += 1594323u * (seed % 3u); seed /= 3u;\n    accum += 531441u * (seed % 3u); seed /= 3u;\n    accum += 177147u * (seed % 3u); seed /= 3u;\n    accum += 59049u * (seed % 3u); seed /= 3u;\n    accum += 19683u * (seed % 3u); seed /= 3u;\n    accum += 6561u * (seed % 3u); seed /= 3u;\n    accum += 2187u * (seed % 3u); seed /= 3u;\n    accum += 729u * (seed % 3u); seed /= 3u;\n    accum += 243u * (seed % 3u); seed /= 3u;\n    accum += 81u * (seed % 3u); seed /= 3u;\n    accum += 27u * (seed % 3u); seed /= 3u;\n    accum += 9u * (seed % 3u); seed /= 3u;\n    accum += 3u * (seed % 3u); seed /= 3u;\n    return float(accum + seed % 3u) / 3486784400.0f;\n} \n\nvec2 SampleUnitDisc(vec2 xi)\n{\n    float phi = xi.y * kTwoPi;   \n    return vec2(sin(phi), cos(phi)) * sqrt(xi.x);   \n}\n\n// *******************************************************************************************************\n//    Hash functions\n// *******************************************************************************************************\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Mix and combine two hashes\nuint HashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint HashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\nuint HashOf(int a) { return HashOf(uint(a)); }\nuint HashOf(uint a, uint b) { return HashCombine(HashOf(a), HashOf(b)); }\nuint HashOf(uint a, uint b, uint c) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashOf(c)); }\nuint HashOf(uint a, uint b, uint c, uint d) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashCombine(HashOf(c), HashOf(d))); }\nuint HashOf(vec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\nuint HashOf(ivec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\n\nfloat HashToFloat(uint i)\n{    \n    return float(HashOf(i) & ((1u << 31u) - 1u)) / float((1u << 31u) - 1u);\n    //return float(HashOf(i)) / float(0xffffffffu);\n}\n\nfloat UintToFloat(uint i)\n{    \n    return float(i & ((1u << 30u) - 1u)) / float((1u << 30u) - 1u);\n}\n\nconst mat4 kOrderedDither = mat4(vec4(0.0, 8.0, 2.0, 10.), vec4(12., 4., 14., 6.), vec4(3., 11., 1., 9.), vec4(15., 7., 13., 5.));\nfloat OrderedDither()\n{    \n    return (kOrderedDither[int(gFragCoord.x) & 3][int(gFragCoord.y) & 3] + 1.0) / 17.0;\n}\n\nvec3 SampleUnitSphere(vec2 xi)\n{\n    xi.x = xi.x * 2.0 - 1.0;\n    xi.y *= kTwoPi;\n\n    float sinTheta = sqrt(1.0 - xi.x * xi.x);\n    return vec3(cos(xi.y) * sinTheta, xi.x, sin(xi.y) * sinTheta);\n}\n\n// *******************************************************************************************************\n//    Colour functions\n// *******************************************************************************************************\n\nfloat FBM(in vec3 p, in int octaves)\n{\n    float F = 0.0;\n    float sumWeights = 0.0;\n    for(int i = 0; i < octaves; ++i)\n    {\n        float exponent = pow(2.0, float(i));\n        vec3 fp = fract(p * exponent);\n        uvec3 ip = uvec3(p * exponent);     \n        \n        float x0 = SmoothStep(UintToFloat(HashOf(ip[0], ip[1], ip[2])), UintToFloat(HashOf(ip[0] + 1u, ip[1], ip[2])), fp[0]);\n        float x1 = SmoothStep(UintToFloat(HashOf(ip[0], ip[1] + 1u, ip[2])), UintToFloat(HashOf(ip[0] + 1u, ip[1] + 1u, ip[2])), fp[0]);\n        float x2 = SmoothStep(UintToFloat(HashOf(ip[0], ip[1], ip[2] + 1u)), UintToFloat(HashOf(ip[0] + 1u, ip[1], ip[2] + 1u)), fp[0]);\n        float x3 = SmoothStep(UintToFloat(HashOf(ip[0], ip[1] + 1u, ip[2] + 1u)), UintToFloat(HashOf(ip[0] + 1u, ip[1] + 1u, ip[2] + 1u)), fp[0]);\n        \n        F += SmoothStep(SmoothStep(x0, x1, fp[1]), SmoothStep(x2, x3, fp[1]), fp[2]) / exponent;\n        sumWeights += 1.0 / exponent;        \n    }\n    return F / sumWeights;\n}\n\nvec3 Hue(float phi)\n{\n    float phiColour = 6.0 * phi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\n// A Gaussian function that we use to sample the XYZ standard observer \nfloat CIEXYZGauss(float lambda, float alpha, float mu, float sigma1, float sigma2)\n{\n   return alpha * exp(sqr(lambda - mu) / (-2.0 * sqr(lambda < mu ? sigma1 : sigma2)));\n}\n\nvec3 HSVToRGB(vec3 hsv)\n{\n    return mix(vec3(0.0), mix(vec3(1.0), Hue(hsv.x), hsv.y), hsv.z);\n}\n\nvec3 RGBToHSV( vec3 rgb)\n{\n    // Value\n    vec3 hsv;\n    hsv.z = cwiseMax(rgb);\n\n    // Saturation\n    float chroma = hsv.z - cwiseMin(rgb);\n    hsv.y = (hsv.z < 1e-10) ? 0.0 : (chroma / hsv.z);\n\n    // Hue\n    if (chroma < 1e-10)        { hsv.x = 0.0; }\n    else if (hsv.z == rgb.x)    { hsv.x = (1.0 / 6.0) * (rgb.y - rgb.z) / chroma; }\n    else if (hsv.z == rgb.y)    { hsv.x = (1.0 / 6.0) * (2.0 + (rgb.z - rgb.x) / chroma); }\n    else                        { hsv.x = (1.0 / 6.0) * (4.0 + (rgb.x - rgb.y) / chroma); }\n    hsv.x = fract(hsv.x + 1.0);\n\n    return hsv;\n}\n\n// *******************************************************************************************************\n//    Ray tracing\n// *******************************************************************************************************\n\n#define kNullRay                 -1.0\n\nstruct Transform\n{\n    vec3 trans;\n    mat3 rot;\n    float sca;\n};\n\nmat3 Identity()\n{\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nmat3 ScaleMat3(float scale)\n{\n    float invScale = 1.0f / scale;\n\treturn mat3(vec3(invScale, 0.0, 0.0),\n\t\t\tvec3(0.0, invScale, 0.0),\n\t\t\tvec3(0.0, 0.0, invScale));\n}\n\nmat3 RotXMat3(float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(1.0, 0.0, 0.0),\n\t\t\tvec3(0.0, cosTheta, -sinTheta),\n\t\t\tvec3(0.0, sinTheta, cosTheta));\n}\n\nmat3 RotYMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, 0.0, sinTheta),\n\t\t\tvec3(0.0, 1.0, 0.0),\n\t\t\tvec3(-sinTheta, 0.0, cosTheta));\n}\n\nmat3 RotZMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, -sinTheta, 0.0),\n\t\t\tvec3(sinTheta, cosTheta, 0.0),\n\t\t\tvec3(0.0, 0.0, 1.0));\n}\n\nTransform CompoundTransform(vec3 trans, vec3 rot, float scale)\n{\n    Transform t;\n    t.rot = Identity();\n    t.sca = scale;\n    t.trans = trans;\n\n    if (rot.x != 0.0) { t.rot *= RotXMat3(rot.x); }\n    if (rot.y != 0.0) { t.rot *= RotYMat3(rot.y); }\n    if (rot.z != 0.0) { t.rot *= RotZMat3(rot.z); }\n\n    if (scale != 1.0f) { t.rot *= ScaleMat3(scale); }\n    \n    return t;\n}\n\nTransform IdentityTransform()\n{\n    Transform t;\n    t.rot = Identity();\n    t.sca = 1.0;\n    t.trans = kZero;\n    return t;\n}\n\n// Fast construction of orthonormal basis using quarternions to avoid expensive normalisation and branching \n// From Duf et al's technical report https://graphics.pixar.com/library/OrthonormalB/paper.pdf, inspired by\n// Frisvad's original paper: http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nmat3 CreateBasis(vec3 n)\n{\n    float s = Sign(n.z);\n    float a = -1.0 / (s + n.z);\n    float b = n.x * n.y * a;\n    \n    return mat3(vec3(1.0f + s * n.x * n.x * a, s * b, -s * n.x),\n                vec3(b, s + n.y * n.y * a, -n.y),\n                n);\n}\n\nmat3 CreateBasis(vec3 n, vec3 up)\n{\n    vec3 tangent = normalize(cross(n, up));\n\tvec3 cotangent = cross(tangent, n);\n\n\treturn transpose(mat3(tangent, cotangent, n));\n}\n\n// The minimum amount of data required to define an infinite ray in 3D space\nstruct RayBasic\n{\n    vec3   o;                   // Origin \n    vec3   d;                   // Direction  \n};\n\n// The \"full fat\" ray objects that most methods will refer to\nstruct Ray\n{\n    RayBasic od;   \n    \n    float    tNear;\n    vec3     weight;\n    float    pdf;\n    uint     flags;\n};\n\n#define kFlagsBackfacing      1u\n#define kFlagsSubsurface      2u\n#define kFlagsDirectRay       4u\n#define kFlagsScattered       8u\n#define kFlagsLightSample     16u\n#define kFlagsProbePath       32u\n#define kFlagsCausticPath     64u\n#define kFlagsVolumetricPath  128u\n\n//#define InheritFlags(ray) (ray.flags & kFlagsScattered)\n#define InheritFlags(ray) (ray.flags & (kFlagsProbePath | kFlagsCausticPath))\n\n#define IsBackfacing(ray) ((ray.flags & kFlagsBackfacing) != 0u)\n#define IsSubsurface(ray) ((ray.flags & kFlagsSubsurface) != 0u)\n#define IsScattered(ray) ((ray.flags & kFlagsScattered) != 0u)\n#define IsLightSample(ray) ((ray.flags & kFlagsLightSample) != 0u)\n#define IsProbePath(ray) ((ray.flags & kFlagsProbePath) != 0u)\n#define IsCausticPath(ray) ((ray.flags & kFlagsCausticPath) != 0u)\n#define IsVolumetricPath(ray) ((ray.flags & kFlagsVolumetricPath) != 0u)\n\n#define kPassForeground 0\n\nstruct HitCtx\n{\n    vec3     n;\n    vec2     uv;\n    float    kickoff;\n    int      matID;\n    float    chi;\n};\n\nvoid SetRayFlag(inout Ray ray, in uint flag, in bool set)\n{\n    ray.flags &= ~flag;\n    if(set) \n    {\n        ray.flags |= flag;\n    }  \n}\n\n#define PointAt(ray) (ray.od.o + ray.od.d * ray.tNear)\n\nRayBasic RayToObjectSpace(in RayBasic world, in Transform transform) \n{\n\tRayBasic object;\n\tobject.o = world.o - transform.trans;\n\tobject.d = world.d + object.o;\n\tobject.o = transform.rot * object.o;\n\tobject.d = (transform.rot * object.d) - object.o;\n\treturn object;\n}\n\nvoid CreateRay(inout Ray ray, vec3 o, vec3 d, vec3 kickoff, vec3 weight, float pdf, uint flags)\n{     \n    ray.od.o = o + kickoff;\n    ray.od.d = d;\n    ray.tNear = kFltMax;\n    ray.weight = weight;\n    ray.pdf = pdf;\n    ray.flags = flags;\n}\n\n\n// *******************************************************************************************************\n//    Filters\n// *******************************************************************************************************\n#define kApplyBloom               true\n\n#define kBloomGain                2.        // The strength of the bloom effect \n#define kBloomTint                vec3(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth               (0.1 / float(1))             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight              (0.1 / float(1))             // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape               vec3(0.7, 1.0, 1.5)            // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample          4            // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom               false           // Show only the bloom in the final comp\n#define kBloomBurnIn              vec3(0.) \n    \n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec3 Bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler)\n{        \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return kZero; }\n    \n    float bloomSize = (delta.x == 1) ? kBloomWidth : kBloomHeight;\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec3 sumWeights = vec3(0.0);\n    vec3 sumRgb = vec3(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 texel = texture(renderSampler, xy / iResolution.xy);\n        vec3 rgb = max(texel.xyz / max(1.0, texel.w), vec3(0.0));            \n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec3 weight = kOne;\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            weight = (max(kZero, (exp(-pow(kOne * d * 4.0, kBloomShape)) - 0.0183156) / 0.981684));            \n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(kZero, rgb - kBloomBurnIn)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    PASS 1: Render a swam of metaballs for an interesting, fluid-like pattern\n*/\n\n// Ray-plane intersection test\nbool RayPlane(inout Ray ray, bool bounded, inout HitCtx hit, in Transform transform)\n{\n    RayBasic localRay = RayToObjectSpace(ray.od, transform);\n    if(abs(localRay.d.z) < 1e-10) { return false; } \n\n    float t = localRay.o.z / -localRay.d.z;\n    if (t <= 0.0 || t >= ray.tNear) { return false; }\n    \n    float u = (localRay.o.x + localRay.d.x * t) + 0.5;\n    float v = (localRay.o.y + localRay.d.y * t) + 0.5;\n    \n    if(bounded && (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)) { return false; }   \n    \n    ray.tNear = t;\n    SetRayFlag(ray, kFlagsBackfacing, localRay.o.z < 0.0);\n    hit.n = transpose(transform.rot) * vec3(0.0, 0.0, 1.0) * transform.sca;\n    hit.kickoff = 1e-4;\n    hit.uv = vec2(u, v);\n    \n    return true;\n}\n\n#define kMetaNumIsos 20\n#define kChargeGain 0.4\n\nvoid GetMetaballProperties(inout RayBasic localRay, in Timecode time, inout vec4 M[kMetaNumIsos], inout float tMin, inout float tMax)\n{               \n    // Determine the min/max value of t along the ray that represents a valid intersection\n    uvec4 pushSeed = rngSeed;\n    PCGInitialise(878625u);\n    \n    float dotod = dot(localRay.o, localRay.d);\n    for(int idx = 0; idx < kMetaNumIsos; ++idx)\n    {             \n       // Initialise the metaball positions\n       vec4 xi = Rand();\n       float theta = kTwoPi * mix(-1.0, 1.0, xi.x) + time.y * xi.y;\n       float phi = kTwoPi * mix(-1.0, 1.0, xi.z) + time.y * xi.w;\n       \n       xi = Rand();\n       vec3 p = vec3(cos(theta), sin(phi), sin(theta)) * mix(vec3(0.1), vec3(0.7), pow(xi.zzw, vec3(mix(0.8, 1.5, sin01(time.y)))));\n       \n       M[idx].xyz = p;\n       M[idx].w = mix(0.01, 0.025, pow(xi.w, 2.0)) * kChargeGain;       \n       \n       float tPerp = dot(M[idx].xyz, localRay.d) - dotod;\n       tMax = max(tMax, tPerp);\n       tMin = min(tMin, tPerp - 5.0 * sqrt(M[idx].w));\n    }\n    \n    tMin = max(0., tMin);\n    rngSeed = pushSeed;\n}\n\n// Ray-metaball intersection test\nbool TestRayMetaballCloud(inout Ray ray, inout HitCtx hit, in Transform transform, in Timecode time, inout vec3 L)\n{        \n    RayBasic localRay = RayToObjectSpace(ray.od, transform);\n    float localMag = length(localRay.d);\n    localRay.d /= localMag;    \n  \n    #define kMetaIsosurface 1.\n    #define kMetaMaxIters 20\n    #define kMetaCutoffThreshold 1e-5\n    #define kMetaNewtonStep 0.5\n    \n    vec3 p;\n    int iterIdx;\n    float node;\n    bool isSubsurface;\n    float tMax = 0.0, tMin = kFltMax;    \n    vec3 dFdn = kZero; \n    \n    // Get the position and charge of the metaballs\n    vec4 M[kMetaNumIsos];    \n    GetMetaballProperties(localRay, time, M, tMin, tMax);  \n    \n    // March along the ray\n    float t = tMin;\n    float FMax = -kMetaIsosurface;\n    float c, r;    \n    float chi;\n    for(iterIdx = 0; iterIdx < kMetaMaxIters; ++iterIdx)\n    {\n        p = localRay.o + localRay.d * t;        \n   \n        // Warp ray space slightly along the gradient of the field\n        if(iterIdx > 0) { p += normalize(dFdn) * 0.1; }\n        \n        c = 0.0, r = 0.0;\n        float sumw = 0.0;\n        float F = 0.;\n        dFdn = kZero;\n        chi = 0.0;\n\t\tfor(int idx = 0; idx < kMetaNumIsos; ++idx)\n        {\n           float cj = M[idx].w;\n           vec3 m = M[idx].xyz;\n           \n           float ri = length(p - m);\n           float w = 1.0 / max(1e-10, ri*ri);\n           F += cj * w;\n           \n           // Compute the gradient of the field\n           dFdn += 2.0 * cj * (p - m) * sqr(w);\n           \n           r += 1.0 / max(1e-10, ri);\n           sumw += w;\n           chi += w * float(idx) / float(kMetaNumIsos);\n        }        \n   \n        r /= sumw;\n        chi /= sumw;\n        c = F * r*r;        \n        F -= kMetaIsosurface;\n        \n        if(iterIdx == 0) { isSubsurface = (F > 0.0); }\n        \n        if (abs(F) < kMetaCutoffThreshold * ((F > 0.0) ? 1.0 : length(dFdn))) { break; }\n\n\t\tfloat dt = (-sqrt(c) + r * kMetaIsosurface) / kMetaIsosurface;        \n        dt *= -sign(F) * kMetaNewtonStep;\n        \n        if((isSubsurface && F <= 0.0) || (!isSubsurface && F > 0.0)) { dt *= -1.0; }\n        \n        t += dt;// * mix(0.5, 1.0, Rand().x);\n        \n        if(t < 0.0 || t > ray.tNear * localMag || (!isSubsurface && t > tMax)) { return false; }\n    } \n    \n    t /= localMag;\n    \n    // Errors can cause the shading normal to point away from the ray origin. Correct for this here.\n    float cosTheta = dot(dFdn, localRay.d);\n    if(cosTheta > 0.0) \n    { \n        dFdn = dFdn - cosTheta * localRay.d;\n    }\n    \n    ray.tNear = t;\n    hit.n = normalize(transpose(transform.rot) * dFdn);\n    hit.kickoff = 1e-3;\n    hit.chi = chi;\n    SetRayFlag(ray, kFlagsBackfacing, isSubsurface);\n    \n    //L = hit.n;\n    //return false;    \n    \n    return true;\n}\n\nfloat Fresnel(float cosI, float eta1, float eta2)\n{\n    float sinI = sqrt(1.0 - cosI * cosI);\n    float beta = 1.0 - sqr(sinI * eta1 / eta2);\n   \n    if(beta < 0.0) { return 1.0; }\n    \n    float alpha = sqrt(beta);\n    return (sqr((eta1 * cosI - eta2 * alpha) / (eta1 * cosI + eta2 * alpha)) +\n            sqr((eta1 * alpha - eta2 * cosI) / (eta1 * alpha + eta2 * cosI))) * 0.5;\n}\n\nfloat FresnelApprox(float cosI, float eta1, float eta2)\n{\n    // Schlick's approximation of the Fresnel term\n    float alpha = 1.0 - cosI;\n    alpha *= alpha;\n    alpha *= alpha;\n    return mix(sqr((eta1 - eta2) / (eta1 + eta2)), 1.0, alpha * (1.0 - cosI));\n}\n\nbool Shade(inout Ray ray, in Timecode time, ivec2 sampleIdx, int renderPass, vec2 resolution, sampler2D sampler, inout vec3 L, out vec3 features)\n{\n    // Interatively sample the path\n    HitCtx hit; \n    L = vec3(0.);\n    \n     //transform = CompoundTransform(vec3(-0.0, 0., 0.0), vec3(kTwoPi * time * 0.2, kHalfPi * time * 0.3, 0.0), 0.3);\n    Transform transform = CompoundTransform(vec3(0.0), vec3(0.0, time.x * 0.1, 0.0), 0.4);\n    if(!TestRayMetaballCloud(ray, hit, transform, time, L))\n    { \n        features.xy = vec2(0.0, 0.0);\n        return false;\n    }    \n    float tNear = ray.tNear;        \n    \n    // Figure out what kind of intersection we're doing\n    #define kIOR 2.2\n    vec2 eta = vec2(1.0, kIOR);\n    vec3 n = hit.n;\n    \n    float fres = min(1., FresnelApprox(dot(-ray.od.d, n), eta.x, eta.y));    \n    \n    // Reflected component\n    vec3 r = reflect(ray.od.d, n);    \n    ray.od.o = PointAt(ray);\n    ray.od.d = r;\n    ray.tNear = kFltMax;    \n\n    // Test for specular reflection of a quad emitter\n    transform = CompoundTransform(vec3(0., -0., 0.5), vec3(-0., 0.0, 0.), 1.0);\n    if(RayPlane(ray, true, hit, transform))\n    {\n        L.xyz += 2.0 * fres * kOne; \n    } \n    else\n    {\n        L.xyz += fres * kOne * acos(-ray.od.d.y) / kPi;            \n    }           \n    \n    L.xyz *= Hue(3.0 * hit.chi + time.y * 0.1);    \n    L.xyz = pow(L.xyz * 3.0, vec3(2.0));\n    \n    features.xy = vec2(tNear, 1.0);     \n    return true;\n}\n\nRay CreatePinholeCameraRay(vec2 uvScreen, vec3 cameraPos, vec3 cameraLookAt)\n{   \n    #define kFocalLength          74.\n    Ray ray;\n    ray.od.o = cameraPos;\n    ray.od.d = CreateBasis(normalize(cameraPos - cameraLookAt), vec3(0., 1., 0.)) * normalize(vec3(uvScreen, -tan(toRad(kFocalLength))));\n    ray.tNear = kFltMax;\n    ray.weight = vec3(1.0, 1.0, 1.0);\n    ray.pdf = kFltMax;   \n\n    return ray;  \n}\n\nvoid mainImage( out vec4 rgba, in vec2 xyScreen )\n{  \n    rgba = vec4(0.0);   \n      \n    SetGlobals(xyScreen, iResolution.xy); \n    \n    //if(!IsTexelInClipRegion(xyScreen)) { return; }\n     \n    #define kContinuousRender true\n    #define kStopAfterFrames 1\n    #define kAntiAlias 1\n    #define kNumSamples (kAntiAlias*kAntiAlias)\n    \n    uint screenHash = HashOf(uint(xyScreen.x), uint(xyScreen.y));\n    //PCGInitialise(screenHash);    \n    PCGInitialise(987262983u);\n    \n    #define kCaptureTimeSpeed 1.1\n    #define kCaptureTimeOffset 9.    \n    #define kMotionBlur 2.\n    #define kTimeDelta (1. / 60.)\n    #define kAA 1\n         \n    vec3 L = kZero;\n    vec3 F = kZero;    \n    for(int v = 0, sampleIdx = 0; v < kAA; ++v)\n    {\n        for(int u = 0; u < kAA; ++u, ++sampleIdx)\n        {            \n            vec2 uvView = TransformScreenToWorld(xyScreen + vec2(u, v) / float(kAA));\n            \n            Timecode time;\n            time.x = kCaptureTimeSpeed * iTime + kCaptureTimeOffset + kMotionBlur * Rand(iChannel0).x * kTimeDelta; \n            time.y = time.x;\n\n            vec2 uvScreen = (xyScreen - iResolution.xy * 0.5) / (iResolution.y * 0.5);\n         \n            //Ray ray = CreatePerspectiveCameraRay(uvView, vec3(0.0, 0.0, 1.5), vec3(0.0, 0.0, 0.0), 0.1, 17.0, iResolution.xy, iChannel0);  \n            Ray ray = CreatePinholeCameraRay(uvView, vec3(0.0, 0.0, 1.5), vec3(0.0, 0.0, 0.0));\n            vec3 Li = kZero, Fi = kZero;\n            Shade(ray, time, ivec2(sampleIdx, kAA*kAA), kPassForeground, iResolution.xy, iChannel0, Li, Fi);\n            \n            L += Li;\n            F += Fi;\n        }\n    }\n    \n    L = pow(max(kZero, L / float(kAA*kAA)), vec3(0.8));\n    F.x = (F.y > 0.0) ? (F.x / F.y) : kFltMax;\n    F.y /= float(kAA*kAA);\n    \n    // Grade\n    vec3 hsv = RGBToHSV(L);\n    hsv.x += -sin((hsv.x + 0.05) * kTwoPi) * 0.07;\n    hsv.y *= 1.0;    \n    L = HSVToRGB(hsv);   \n\n    rgba.xyz = L;\n    rgba.w = F.y;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    PASS 2: Duplicate and overlay the rendered objects based on a recursive pattern\n*/\n\n#define kNestRecursions 30\n#define kNestTortuosity 0.5\n#define kNestPitch 1.1\n\nvoid mainImage(out vec4 L, in vec2 xyScreen)\n{      \n    L = vec4(0.0);\n    for(int passIdx = 0; passIdx < 2; ++passIdx)\n    {\n        for(int nestIdx = 0; nestIdx < kNestRecursions; ++nestIdx)\n        {\n            float beta = float(nestIdx) / (float(kNestRecursions) / kNestTortuosity);\n            float theta = -(1.0 - 2.0 * float(passIdx)) * kTwoPi * beta;\n            vec2 uvNest = Rotate2D(theta) * (xyScreen - iResolution.xy * 0.5);\n            uvNest = (uvNest * pow(kNestPitch, float(nestIdx)) + iResolution.xy * 0.5 + vec2(0.5)) / iResolution.xy;\n\n            if(uvNest.x <= 0.0 || uvNest.y <= 0.0 || uvNest.x >= 1.0 || uvNest.y >= 1.0) { continue; }\n    \n            vec4 texel = texture(iChannel0, (passIdx == 0) ? uvNest : (vec2(1. - uvNest.x, uvNest.y)), 0.);         \n            L = vec4(max(L.xyz, 0.3 * mix(1.0, 0.1, pow(beta, 0.5)) * texel.xyz), max(L.w, texel.w));\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    PASS 3: Apply a hazy lens bloom effect\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 xy )\n{   \n    fragColor = vec4(0.0);\n    if(kApplyBloom)\n    {    \n        fragColor.xyz = Bloom(xy, iResolution, ivec2(1, 0), iChannel0); \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}