{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat3 rotY(in float a) {\n\treturn mat3( cos(a), 0.0, sin(a),\n\t\t\t\t 0.0,    1.0, 0.0,\n\t\t\t\t-sin(a), 0.0, cos(a)\n\t\t\t    );\n}\nfloat smin( float a, float b, float k ) {\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat length2( vec2 p ) {\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p ) {\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p ) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus82( vec3 p, vec2 t ){\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\n    vec3 pa = p - a , ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat palkki(in vec3 p, out vec3 color){\n    \n    float finalDistance = 10000000.;\n    \n    finalDistance = min(finalDistance, udRoundBox( p-vec3(0.0), vec3(2.0,8.0+sin(p.x)*2.,2.0) , 0.1) );\n    vec3 p2 = p;\n    vec3 p3 = p;\n    vec3 p4 = p;\n    p2.yxz *= rotY(3.14145*0.25);\n    finalDistance = min(finalDistance, udRoundBox( (p2-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p2-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    \n    \n    p3.zyx *= rotY(3.14145*0.5);\n    p3.yxz *= rotY(3.14145*0.25);\n    p.zyx *= rotY(3.14145*0.5);\n    finalDistance = min(finalDistance, udRoundBox( (p3-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p3-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    \n    \n    p4.zyx *= rotY(-3.14145*0.5);\n    p4.yxz *= rotY(3.14145*0.25);\n    p.zyx *= rotY(3.14145);\n    finalDistance = min(finalDistance, udRoundBox( (p4-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p4-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    return finalDistance;\n}\nfloat calculateDistance(in vec3 p, out vec3 color) {\n    float height = texture(iChannel1, vec2(p.xz+iTime)*0.05 ).r;\n    color = height+vec3(1.0);  \n    float finalDistance = 10000000.;\n    finalDistance = min(finalDistance, udBox( p-vec3(0.0,-2.0+height*0.1+sin(p.x*0.6+iTime)*0.1,0.0), vec3(30.,0.7,30.0) ) );\n    float dist1 = palkki(p,color);\n    if(dist1 < finalDistance){\n        finalDistance = dist1;\n        color = vec3(5.0,0.0,0.0);\n    }\n    return finalDistance;\n}\n\nfloat THESHITYO( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 C;\n        float h = calculateDistance(ro + rd*t, C);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.8 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tracer(vec3 rayStartPosition, vec3 rayDirection) {\n    vec3 finalColor = vec3(0., 0., 0.);\n    vec3 rayPosition = rayStartPosition;\n    float stepable = 0.4;\n    float dist = 0.01;\n    vec3 normalVector = rayDirection;\n    float coff = 0.3;\n    float find;\n    vec3 lightSource = vec3(120.0,120.0,120.0);\n    \n    for(float k=0.; k<3.; k++) {\n        find = 0.0;\n        for(float i=0.; i<50.; i++) {\n            vec3 color;\n            stepable = calculateDistance(rayPosition, color);\n            dist += stepable;\n            rayPosition = rayStartPosition + dist * rayDirection;\n            \n            \n            vec3 lightDir = (lightSource-rayPosition);\n            lightDir = normalize(lightDir);\n            float directLight = dot(normalVector, lightDir);\n            finalColor+= texture(iChannel0, (rayPosition.xy + rayPosition.y) * 0.8 ).r * texture(iChannel1, (rayPosition.xz + rayPosition.z) * 0.8 ).r * \n                \t\t\t0.2 * max(pow(directLight,7.)*  vec3(1.7,1.1,.9) * 1.8,0.0001);\n            \n            if(length(rayPosition)>25.) { \n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = normalize(lightDir);\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max( pow(directLight,7.) * vec3(1.7,1.1,.9) * 1.8, 0.01) + 0.2 * texture(iChannel1, 2.0*vec2(abs(atan(rayDirection.x,rayDirection.z)/3.141),rayDirection.y)).rgb * 0.7 * min(max(length(rayDirection.xz) * 3.0,0.0),1.0);;\n                return finalColor;\n            }\n            \n            if( abs(stepable) <= 0.005){\n                const float epsilon = 0.005;\n                vec3 C;\n                normalVector = vec3(\tcalculateDistance(rayPosition+vec3(epsilon,0,0),C)-calculateDistance(rayPosition+vec3(-epsilon,0,0),C),\n                                        calculateDistance(rayPosition+vec3(0,epsilon,0),C)-calculateDistance(rayPosition+vec3(0,-epsilon,0),C),\n                                        calculateDistance(rayPosition+vec3(0,0,epsilon),C)-calculateDistance(rayPosition+vec3(0,0,-epsilon),C));\n                normalVector = normalize(normalVector);\n                \n                \n                float shadow = (THESHITYO(rayPosition + normalVector, normalize(lightSource), 0.01, 0.6) * 1.9);\n                finalColor = mix(finalColor, (color * vec3(dot(normalVector, -rayDirection)) / (k*9.0*(shadow+1.0) + 1.0)) * shadow, coff) ;\n                finalColor = mix(finalColor, vec3(0.0), dist/24.0);  /*fog*/\n                find = 1.0;\n                break;\n                \n            }\n        }\n        dist = 0.1;\n        rayStartPosition = rayPosition + normalVector;\n        rayPosition = rayStartPosition;\n        rayDirection = reflect(rayDirection, normalVector);\n        coff *= 0.3;\n    }\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPosition = vec3( -0.7, 0.0, -17.0 );\n    cameraPosition.yxz *= rotY( -0.2 );\n    cameraPosition *= rotY( 0.1 * 2.0 * 3.1415 * iTime );\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv *= vec2(sin(iTime+uv.x)/10.+1.,1.0);\n    float aspect = iResolution.x / iResolution.y;\n    if(length(uv*vec2(0.,aspect))>0.9) discard;\n    vec3 direction = normalize(vec3(.5 * uv * vec2(aspect, 1.0), 1. )) ;\n    direction.yxz *= rotY( -0.2 );\n    direction *= rotY( 0.1 * 2.0 * 3.1415 * iTime );\n    fragColor = vec4(tracer(cameraPosition, direction),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlB3zz","date":"1426625419","viewed":297,"name":"the magic cube","username":"Branch","description":"the magic cube","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["themagiccube"],"hasliked":0,"parentid":"","parentname":""}}