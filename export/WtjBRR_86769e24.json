{"ver":"0.1","info":{"id":"WtjBRR","date":"1598388989","viewed":104,"name":"Soft shadows - athibaul","username":"athibaul","description":"An alternative algorithm for computing soft shadows.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// An alternative to iq's algorithm for soft shadows\n// with results somewhat closer to physical based lighting.\n\n// Inigo Quilez's tutorial on soft shadows:\n// https://iquilezles.org/articles/rmshadows\n\n// The algorithm by iq makes shadows are a bit too large:\n// it widens the penumbra,\n// but it does not shrink the area of the umbra.\n// This is because we still consider that the light \n// is fully blocked whenever the center of the light source is occluded.\n\n// My alternative is to do a modified raymarching loop,\n// where the distance marched is the scene SDF + the \"width\" of the light bundle.\n// Occlusion is computed using the signed distance:\n// d <= -w   ==> Full occlusion\n// d = 0     ==> Half occlusion\n// d > w     ==> No occlusion\n// This results in (much!) stronger artifacts,\n// but they can be reduced using a randomized first step.\n\n\n// 0: Hard shadows\n// 1: Soft shadows by iq\n// 2: Soft shadows by iq, reduced artifacts\n// 3: Soft shadows by athibaul\n#define SHADOW_TYPE 3\n\n// Just a golden color\n#define C_GOLD vec3(1., 0.86, 0.57);\n\n// How many steps until full shadow\n#define LIGHT_STEPS 100\n// Use blue noise in various places to reduce banding/aliasing artifacts\n#define USE_BLUE_NOISE true\n// Sun half-angle size in radians\n#define SUN_SIZE 0.1\n\n\n\nvec4 bluenoise(in vec2 fragCoord)\n{\n    if(!USE_BLUE_NOISE) return vec4(0.);\n    ivec2 c = ivec2(fragCoord);\n    c.x %= 1024;\n    c.y %= 1024;\n    return texelFetch(iChannel0, c, 0) - 0.5;\n}\n\nfloat boxDist(in vec3 p, in vec3 r)\n{\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sphereDist(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat map( in vec3 p )\n{\n    float d = boxDist(p, vec3(1.))-0.1;\n    d = min(d, p.z+1.);\n    d = min(d, sphereDist(p - vec3(0.,2.,0.), 1.));\n    return d;\n}\n\nvec3 normal( in vec3 p )\n{\n    vec2 eps = vec2(0.0001, 0.);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\n\nvec3 camRay( in vec3 fwd, in vec2 fragCoord, in float fov )\n{\n    vec3 up = vec3(0.,0.,1.); // Z is up\n    // Orthonormalize\n    up = normalize(up - fwd * dot(fwd, up));\n    vec3 right = cross(fwd, up);\n    // Relative coordinates : from 0 to 1, then from -1 to 1 vertically\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    return normalize(fwd + fov * (uv.x * right + uv.y * up));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime*0.2;\n    vec3 ro = vec3(5.*cos(theta),5.*sin(theta),2.5);\n    vec3 target = vec3(0.);\n    vec2 coo = fragCoord;\n    //vec2 coo = fragCoord + bluenoise(fragCoord).xy;\n    vec3 ri = camRay(normalize(target-ro), coo, 0.7);\n    \n    // Raymarching loop\n    vec3 pos, norm;\n    float tray;\n    {\n        float d, t=0.;\n        int i;\n        for(i=0; i<300; i++)\n        {\n            d = map(ro + t*ri);\n            if(d < 0.0001) break;\n            t += d;\n            if(t > 100.) break;\n        }\n        pos = ro + t*ri;\n        norm = normal(pos);\n        tray = t;\n    }\n    \n    // Lighting loop\n    float shadow = 1.; // 1 for full light, 0 for full shadow\n\tvec3 li = normalize(vec3(2.,1.,2.2)); // Directional light\n    vec3 lo = pos + 0.001*norm; // Get away from the surface\n    float th = -iTime*0.5 + 3.14159; // Sun revolves around the scene\n    li.xy = mat2(cos(th), sin(th), -sin(th), cos(th)) * li.xy;\n    {\n        float d, t = map(lo) * (bluenoise(fragCoord).w+0.5);\n        int i;\n        float r1=1000., r2; // Previous and current \"step size\"\n        for(i=0;i<LIGHT_STEPS;i++)\n        {\n            d = map(lo + t*li);\n            // Hard shadows       \n            #if SHADOW_TYPE==0\n\t\t\tif(d < 0.0001) { shadow = 0.; break; }\n            t += d;\n\t\t\t#endif\n            \n            // Soft shadows - iq's simple version\n            // https://iquilezles.org/articles/rmshadows\n            // This exhibits some artifacts at sharp corners,\n            // which can be reduced using blue noise.\n            #if SHADOW_TYPE==1\n            float w = SUN_SIZE*t;\n            shadow = min(shadow, smoothstep(0., w, d));\n            t += d;\n            #endif\n            \n            // Soft shadows - iq's version 2, with reduced artifacts\n            #if SHADOW_TYPE==2\n            float w = SUN_SIZE*t;\n            r2 = d;\n            float y = r2*r2/(2.0*r1)*0.999;\n            float true_d = sqrt(r2*r2-y*y);\n            float true_w = SUN_SIZE*max(0.,t-y);\n            shadow = min(shadow, smoothstep(0., true_w, true_d));\n            t += r2;\n            r1 = r2;\n            #endif\n            \n            // Soft shadows - athibault version\n            #if SHADOW_TYPE==3\n            float w = SUN_SIZE*t;\n            shadow = min(shadow, smoothstep(-w, w, d));\n            t += d+w;\n            #endif\n            \n            if(t > 100.) break;\n        }\n        if(i==LIGHT_STEPS) { // Didn't find the light\n            shadow = 0.;\n        }\n    }\n    \n    // Output to screen\n    //vec3 col = vec3(t/10.);\n    vec3 diffuse = abs(norm.yzx) * clamp(dot(norm, li),0.,1.) * 2.;\n    vec3 col = mix(diffuse * shadow, vec3(0.2,0.6,0.2), smoothstep(3., 50., tray));\n    //vec3 col = vec3(shadow);\n    //vec3 col = diffuse;\n    \n    col /= length(vec2(length(col), 1.0));\n    fragColor = vec4(col,1.0);\n    // Add some noise to avoid banding\n    fragColor.rgb += 0.02 * bluenoise(fragCoord).xyz;\n}","name":"Image","description":"","type":"image"}]}