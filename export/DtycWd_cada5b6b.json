{"ver":"0.1","info":{"id":"DtycWd","date":"1701250192","viewed":191,"name":"car donut","username":"foxthreefire","description":"Inspired by Ken Blockâ€™s Climbkhana TWO https://youtu.be/ZX2uXBMkO8U?si=r8KVqUU4pb3Y_MdH\nR.I.P. Ken Block","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["donut","car","drift","rsdonut","kenblock","climbkhana"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Phase(float g, float cosTheta)\n{\n    // Schlick aaproximation of HG\n    float k = 1.55*g-0.55*g*g*g;\n    float l = 1.0-k*cosTheta;\n    return (1.0-k*k)/(4.0*PI*l*l);\n}\n\n// ray march\nvec2 map(vec3 pos,float attenRadius,float time)\n{\n    vec3 wheelPos = GetWheelPos(time);\n    float rad = length(wheelPos.xz - GetDriftCenter().xz);\n\n    // donut\n    float noise = 0.28*texture(iChannel1,vec3(attenRadius*0.01)).x;\n    vec2 ddonut = vec2(sdTorusY(pos,vec2(rad,0.18 + (attenRadius + noise) * 0.6 + 0.03*sin(time))), DEFAULT);\n\n    vec2 res = vec2(100.0, DEFAULT);\n    res = xmin(res, ddonut);\n    return res;\n}\n\nvec4 renderSmoke(vec3 ro, vec3 rd, float time, float depthRef)\n{\n    vec4 col = vec4(0,0,0,0);\n    \n    const float tmin = TMIN;\n    const float tmax = TMAX;\n    const int stepCount = 100;\n    const float trailRad = radians(90.0);\n    \n    float t = tmin;\n    float tStep = 0.01; // (tmax - tmin)/float(stepCount);\n    float cosThetaSun = dot(rd, GetSunDir());\n    int sampleCount = 0;\n    float radWheel = PosToRad(GetWheelPos(time).xz);\n    bool entered = false;\n            \n    for(int i=0; i<stepCount && t>0.0 && t<depthRef; i++)\n    {\n        vec2 h;\n        vec3 pos = ro+rd*t;\n        \n        float rad = PosToRad(pos.xz);\n        float radRef = radWheel;\n        if (radRef<rad)\n            radRef += TWO_PI;\n        float attenRad = 0.0;\n        float attenRadius = 1.0f;\n        if (radRef-rad < trailRad)\n        {\n            attenRadius = (radRef-rad)/trailRad;\n            attenRad = 1.0-attenRadius;\n        }\n        \n        h = map(pos,attenRadius,time);\n        if(h.x<HIT_IF_SMALLER) \n        {\n            float noise = texture(iChannel1, pos*0.5+time*0.01).r;\n            float smoke = noise * Phase(0.0,cosThetaSun) * 80.0;\n            \n            smoke *= attenRad * 0.8;\n            smoke *= exp(mix(-7.0, 15.0, clamp(abs(h.x)+0.02+attenRadius*0.15, 0.0, 0.3)));\n            \n            col += vec4(1,1,1,smoke);\n            sampleCount++;\n            entered = true;\n        }\n        else if (entered)\n          break; // if exit, break, not necessarily correct if self occlusion happens, but we are fine here\n        t += max(tStep, h.x); // if hit, h.x < 0, we want to keep going\n    }\n    if (sampleCount > 0)\n       col /= float(sampleCount);\n    return clamp(col,vec4(0,0,0,0),vec4(1,1,1,1));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 uvNorm = fragCoord / iResolution.xy;\n    vec3 ro, rd;\n    \n    vec4 col = texture(iChannel0, uvNorm);\n    GetRoRd(fragCoord, iResolution.xy, iMouse, time, ro, rd);\n    vec4 smoke = renderSmoke(ro, rd, time, col.a);\n    \n    fragColor = vec4(mix(col.rgb, smoke.rgb, smoke.a), 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// defs\n#define STATIC_CAM     0\n#define FISHEYE_CAM    1\n#define CAMERA_CONTROL 1\n#define HIT_IF_SMALLER 0.000001\n#define NOT_HIT        100.0\n#define TMIN           0.01\n#define TMAX           20.0\n\n#define SUN_X      0.6\n#define SUN_Y      0.4\n#define SUN_Z      0.2\n#define SKY_COL1   vec3(255,171,105)/255.0\n#define SKY_COL2   vec3(222,146,159)/255.0\n#define SKY_COL3   vec3(124,105,161)/255.0\n\n#define DEFAULT    1.0\n#define RED        2.0\n#define GREEN      3.0\n#define BLUE       4.0\n#define GROUND     5.0\n#define LOGO_WHITE 6.0\n#define LOGO_GREEN 7.0\n#define BODY_BLACK 8.0\n#define BODY_METAL 9.0\n#define BODY_RED   10.0\n#define WHEEL      11.0\n#define WHEEL_TYRE 12.0\n#define WHEEL_CAP  13.0\n#define WINDOW     14.0\n#define HEAD_LIGHT 15.0\n#define TYRE_MARK  16.0\n\n// util\n#define cmod(x,  r)     (mod(x + 0.5 *r, r) - 0.5 * r)\n#define PI              3.1415926\n#define TWO_PI          6.2831853\n#define ONE_OVER_PI     0.3183098\n\n// https://www.shadertoy.com/view/4tByz3\nvec2  noise2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\nvec3  hash3( vec3 p ) { return fract(sin(p)*vec3(338.5453123,278.1459123,191.1234)); }\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0), vec2(1));\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat dot2(in vec3 v ) \n{ \n    return dot(v,v); \n}\n\nfloat dot2(in vec2 v ) \n{ \n    return dot(v,v); \n}\n\nfloat fresnell(vec3 nor, vec3 rd, float power)\n{\n    return pow((1.0 - clamp(dot(nor, rd), 0.0, 1.0)), power);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    return vec2(smin(a.x, b.x, k), a.x < b.x ? a.y : b.y);\n}\n\nvec2 xmin( vec2 a, vec2 b)\n{\n    return vec2(min(a.x, b.x), a.x < b.x ? a.y : b.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec2 smax(vec2 a, vec2 b, float k)\n{\n    return vec2(smax(a.x, b.x, k), a.x > b.x ? a.y : b.y);\n}\n\nvec2 smax( vec2 a, vec2 b, float mixy, float k )\n{\n    return vec2(smax(a.x, b.x, k), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax( vec2 a, vec2 b, float mixy)\n{\n    return vec2(max(a.x, b.x), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax(vec2 a, vec2 b)\n{\n    return vec2(max(a.x, b.x), a.x > b.x ? a.y : b.y);\n}\n\n// primitive\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt(dot(p,p) + ra*ra - 2.0*ra*k) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat sdCappedCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdTorusY(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTorusX(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.zy)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat sdCappedTorusY(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// 2d primitives\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdScaledQuad( in vec2 p, in vec2 v[4], in float scale )\n{\n    for(int i=0;i<4;i++)\n    {\n        v[i] *= scale;\n    }\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdQuad( in vec2 p, in vec2 v[4] )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdRing( in vec2 p, in vec2 sc, in float r, float th )\n{\n    p.x = abs(p.x);\n   \n    p = mat2x2(sc.y,sc.x,-sc.x,sc.y)*p;\n\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n}\n\n// operations\nvec3 opCheapBendY(vec3 p, float degree)\n{\n    float c = cos(degree*p.z);\n    float s = sin(degree*p.z);\n    mat2 m = mat2(c,-s,s,c);\n    vec2 q = m*p.xz;\n    return vec3(q.x,p.y,q.y);\n}\n\nfloat opRound( float d, in float r )\n{\n  return d - r;\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat opExtrusionX(vec3 p, float sdf, float h )\n{\n    vec2 w = vec2( sdf, abs(p.x) - h ); // mirror\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opExtrusionY(vec3 p, float sdf, float h )\n{\n    vec2 w = vec2( sdf, (p.y - h) * sign(p.y) );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opExtrusionZ(vec3 p, float sdf, float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h ); // mirror\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opExtrusionQuadTaperY(vec3 pos, vec2[4] quad, float height, float beginTaperY, float endTaperY, float beginTaper, float endTaper)\n{\n    float scale = clamp((pos.y - beginTaperY) / (endTaperY - beginTaperY), 0.0, 1.0) * (endTaper - beginTaper) + beginTaper;\n    return opExtrusionY(pos, sdScaledQuad(pos.xz, quad, scale), height);\n}\n\nvec2 opRot2D(vec2 p, float degree)\n{\n    float rad = radians(degree);\n    float s = sin(rad);\n    float c = cos(rad);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\nvec3 opRotY(vec3 p, float degree)\n{\n    vec2 res = opRot2D(p.xz, degree);\n    return vec3(res.x, p.y, res.y);\n}\n\nvec3 opRotZ(vec3 p, float degree)\n{\n    vec2 res = opRot2D(p.xy, degree);\n    return vec3(res.x, res.y, p.z);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRepXZ(vec3 p, vec3 c)\n{\n    vec2 res = mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz;\n    return vec3(res.x, p.y, res.y);\n}\n\nvec2 opRepOriginXZ(vec3 p, vec3 c)\n{\n    vec3 origin = floor((p + 0.5*c)/c) * c;\n    return vec2(origin.x, origin.z);\n}\n\nfloat PackTwoUnormInOneFloat(vec2 uv)\n{\n    uvec2 uUV = uvec2(uv * float(1 << 16));\n    uUV = clamp(uUV, uvec2(0), uvec2(0xffff));\n    uint packeduUV = ((uUV.x & 0xffffu) << 16) | (uUV.y & 0xffffu);\n    return uintBitsToFloat(packeduUV);\n}\n\nvec2 UnpackOneFloatInTwoUnorm(float packed)\n{\n    uint packeduUV = floatBitsToUint(packed);\n    uvec2 uUV = uvec2((packeduUV & 0xffff0000u) >> 16, packeduUV & 0xffffu);\n    return vec2(uUV) / float(1 << 16);\n}\n\n// common func\nstruct SurfaceDataIn\n{\n    vec3 mAlbedo;\n    vec3 mPosWorld;\n    vec3 mNorWorld;\n\tfloat mRoughness;\n\tfloat mFresnel;\n\tfloat mMetallic;\n\tfloat mSpecularity;\n};\n\nfloat CosTheta(vec3 w, vec3 nor)\n{\n    return dot(w, nor);\n}\n\nfloat TanTheta(vec3 w, vec3 nor)\n{\n    float b = dot(w, nor);\n    float a = length(w - b * nor);\n    return a / b;\n}\n\n// Trowbridge-Reitz micro-facet distribution function (GGX)\nfloat GGX_D(float cosThetaH, float alpha)\n{\n    float temp = cosThetaH * cosThetaH * (alpha * alpha - 1.0f) + 1.0f;\n    return alpha * alpha / (PI * temp * temp);\n}\n\n// Trowbridge-Reitz masking shadowing function\nfloat GGX_G(float tanThetaI, float tanThetaO, float alpha)\n{\n    float alpha2 = alpha * alpha;\n    float tanThetaI2 = tanThetaI * tanThetaI;\n    float tanThetaO2 = tanThetaO * tanThetaO;\n    float AI = (-1.0f + sqrt(1.0f + alpha2 * tanThetaI2)) / 2.0f;\n    float AO = (-1.0f + sqrt(1.0f + alpha2 * tanThetaO2)) / 2.0f;\n    return 1.0f / (1.0f + AI + AO);\n}\n\nfloat GGX_PDF(vec3 wo, vec3 wh, vec3 nor, float alpha)\n{\n\tfloat cosTheta = CosTheta(wh, nor);\n\treturn GGX_D(cosTheta, alpha) * abs(cosTheta) / (4.0f * dot(wo, wh));\n}\n\n// wi = lightDir, wo = eyeDir\nfloat GGX_NoFresnel(vec3 wi, vec3 wo, vec3 wh, vec3 N, float roughness)\n{\n    return saturate(GGX_D(CosTheta(wh, N), roughness) * GGX_G(TanTheta(wi, N), TanTheta(wo, N), roughness) / (4.0f * CosTheta(wi, N) * CosTheta(wo, N)));\n}\n\n// Schlick approximation\nfloat Fresnel(float vDotH, float F0)\n{\n\treturn F0 + (1.0f - F0) * pow(1.0f - vDotH, 5.0f);\n}\n\n// wi = lightDir, wo = eyeDir\nfloat GGX(vec3 wi, vec3 wo, vec3 wh, vec3 N, float roughness, float fresnel)\n{\n\tfloat f = Fresnel(dot(wh, wo), fresnel);\n\treturn saturate(f * GGX_NoFresnel(wi, wo, wh, N, roughness));\n}\n\nvec2 Hammersley(int index, int num)\n{\n    int numSampleBits = int(log2(float(num)));\n    float invNumSamples = 1.0 / float(num);\n    int t = index;\n    int bits = 0;\n    for (int j = 0; j < numSampleBits; j++)\n    {\n        bits = bits * 2 + (t - (2 * (t / 2)));\n        t /= 2;\n    }\n    return vec2(float(index), float(bits)) * invNumSamples;\n}\n\nvec3 ImportanceSampleGGX(vec2 xi, float roughness, vec3 N)\n{\n\tfloat a = roughness * roughness;\n\tfloat Phi = 2.0 * PI * xi.x;\n\tfloat CosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n\tfloat SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n\tvec3 H;\n\tH.x = SinTheta * cos(Phi);\n\tH.y = SinTheta * sin(Phi);\n\tH.z = CosTheta;\n\tvec3 UpVector = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n\tvec3 tangentX = normalize(cross(UpVector, N));\n\tvec3 tangentY = cross(N, tangentX);\n\t// tangent to world space\n\treturn tangentX * H.x + tangentY * H.y + N * H.z;\n}\n\nvec3 BRDF_GGX(SurfaceDataIn sdi, vec3 wi, vec3 wo)\n{\n\tif (dot(wi, sdi.mNorWorld) < 0.0f || dot(wo, sdi.mNorWorld) < 0.0f)\n\t\treturn vec3(0);\n\n\tvec3 wh = (wo + wi);\n\tif (length(wh) == 0.0f)\n\t{\n\t\t// if wo and wi point to the opposite directions\n\t\t// use the perpendicular on the normal's side as the wh\n\t\tvec3 tangent = normalize(cross(sdi.mNorWorld, wi));\n\t\twh = normalize(cross(wi, tangent));\n\t}\n\telse\n\t\twh = normalize(wh);\n\n\tfloat specular = GGX(wi, wo, wh, sdi.mNorWorld, sdi.mRoughness, sdi.mFresnel);\n\tfloat diffuse = ONE_OVER_PI;\n\treturn sdi.mAlbedo * (diffuse * (1.0f - sdi.mMetallic) + specular * sdi.mMetallic) * saturate(CosTheta(wi, sdi.mNorWorld));\n}\n\nfloat PosToRad(vec2 pos)\n{\n    float l = length(pos);\n    if (l == 0.0)\n        return 0.0;\n    float radCos = acos(pos.x/l);\n    float radSin = asin(pos.y/l);\n    if (radSin >= 0.0)\n        return radCos;\n    else\n        return TWO_PI-radCos;\n}\n\nfloat GetDriftWobble(float time)\n{\n    return 8.0*sin(2.0*time) + cos(10.0*time + 3.0);\n}\n\nfloat GetWheelAngle(float time)\n{\n    return 30.0 - 2.0 * GetDriftWobble(time);\n}\n\nfloat GetDriftAngle(float time)\n{\n    return 30.0 + GetDriftWobble(time);\n}\n\nvec3 GetDriftHead(float time)\n{\n    float r = 1.0 + 0.2 * sin(time);\n    vec3 pos = vec3(cos(time),0,sin(time)) * r;\n    return pos;\n}\n\nvec3 GetDriftCenter()\n{\n    return vec3(0,0,0);\n}\n\nmat3x3 GetCarToWorldMat(float time)\n{\n    const vec3 yAxis = vec3(0,1,0);\n    vec3 head = GetDriftHead(time);\n    vec3 xAxis = GetDriftCenter() - head;\n    if (length(xAxis) == 0.0)\n        xAxis = vec3(1,0,0);\n    else\n        xAxis = normalize(xAxis);\n    vec3 zAxis = cross(xAxis,yAxis);\n    return mat3x3(xAxis,yAxis,zAxis);\n}\n\nvec3 GetCarOffset()\n{\n    return vec3(-0.4,0,0);\n}\n\nvec4 WorldToCar(vec4 pos, float time)\n{\n    vec3 head = GetDriftHead(time);\n    mat3x3 carToWorld = GetCarToWorldMat(time);\n    \n    pos.xyz -= head * pos.w;\n    pos.xyz *= carToWorld;\n    \n    pos.xyz = opRotY(pos.xyz, GetDriftAngle(time));\n    pos.xyz -= GetCarOffset() * pos.w;\n    \n    return pos;\n}\n\nvec4 CarToWorld(vec4 pos, float time)\n{\n    vec3 head = GetDriftHead(time);\n    mat3x3 carToWorld = GetCarToWorldMat(time);\n    \n    pos.xyz += GetCarOffset() * pos.w;\n    pos.xyz = opRotY(pos.xyz, -GetDriftAngle(time));\n    \n    pos.xyz = carToWorld * pos.xyz;\n    pos.xyz += head * pos.w;\n    return pos;\n}\n\nvec4 CarToWorldNoWobble(vec4 pos, float time)\n{\n    mat3x3 carToWorld = GetCarToWorldMat(time);\n    pos.xyz = carToWorld * pos.xyz;\n    return pos;\n}\n\nvec3 GetWheelPos(float time)\n{\n    vec3 result = GetDriftHead(time);\n    vec3 wheelPos = CarToWorld(vec4(-0.26,0.03,0.2,1), time).xyz;\n    return wheelPos;\n}\n\nvec3 GetSunDir()\n{\n    return normalize(vec3(SUN_X, SUN_Y, SUN_Z));\n}\n\nvec3 FishEyeCam(vec2 ndc, vec2 angle, float r)\n{\n    vec2 rad = radians(angle) * ndc;\n    vec3 result;\n    result.x = r * cos(rad.y) * sin(rad.x);\n    result.y = r * sin(rad.y);\n    result.z = r * cos(rad.y) * cos(rad.x);\n    return result;\n}\n\nvoid GetRoRd(vec2 fragCoord, vec2 resolution, vec4 mouse, float time, out vec3 ro, out vec3 rd)\n{\n    vec2 p = (-resolution.xy+2.0*fragCoord)/resolution.y;\n    vec2 pNormalized = (-resolution.xy+2.0*fragCoord)/resolution.xy;\n    vec3 up = vec3(0.0,1.0,0.0);\n    \n#if STATIC_CAM\n    // camera\t\n    const float dist = 1.2;\n    float cam = 0.0f;\n#if CAMERA_CONTROL\n    cam = mouse.x;\n#endif\n    float an = 10.57*cam/resolution.x+2.5;\n    vec3 ta = vec3(0,0,0);\n    ro = ta + vec3(dist*cos(an),0.7,dist*sin(an));\n#else // STATIC_CAM\n    vec3 ta = GetDriftHead(time);\n    vec3 camRadOffset = CarToWorldNoWobble(vec4(normalize(vec3(0.3,0.9,0.8))*(vec3(0.6,0.8,0.6)+vec3(0.3,0.1,0.3)*cos(time)),1),time).xyz;\n    ro = vec3(cos(time),0,sin(time))*0.4+camRadOffset;\n    vec3 right = cross(normalize(ta-ro),up);\n    up = normalize(up+right*0.2*sin(time*0.7));\n#endif // STATIC_CAM\n\n    // frame\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = up;\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    \n#if FISHEYE_CAM\n    vec3 dir = FishEyeCam(pNormalized, vec2(70,45), 1.8);\n    rd = normalize( dir.x*cu + dir.y*cv + dir.z*cw );\n#else\n    rd = normalize( p.x*cu + p.y*cv + 1.8*cw );\n#endif\n}\n\nvec3 GetSkyCol(float dirY)\n{\n    const float t0 = -0.1;\n    const float t1 = 0.5;\n    float t = clamp((dirY-t0)/(t1-t0),0.0,1.0);\n    vec3 colA = mix(SKY_COL1, SKY_COL2, t);\n    vec3 colB = mix(SKY_COL2, SKY_COL3, t);\n    return mix(colA, colB, t);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SHOW_AXES 0\n\n// element\nvec2 axes(vec3 pos, float axisLength, float axisThickness)\n{\n    vec2 daxis = vec2(100.0, DEFAULT);\n    axisLength /= 2.0; // account for abs in sdBox\n    axisThickness /= 2.0; // account for abs in sdBox\n    daxis = vec2(sdBox(pos - vec3(axisLength,0,0), vec3(axisLength,axisThickness,axisThickness)), RED);\n    daxis = xmin(daxis, vec2(sdBox(pos - vec3(0,axisLength,0), vec3(axisThickness,axisLength,axisThickness)), GREEN));\n    daxis = xmin(daxis, vec2(sdBox(pos - vec3(0,0,axisLength), vec3(axisThickness,axisThickness,axisLength)), BLUE));\n    return daxis;\n}\n\nvec2 ground( in vec3 pos, float time, bool approx)\n{\n    float fh = -0.05;\n    float d = pos.y - fh;\n    vec2 dground = vec2(d, GROUND);\n    \n    if (approx)\n        return dground;\n\n    float r = length(pos.xz);\n    float rad = acos(pos.x);\n\n    float rad_a = radians(13.0 + 10.0 * noise2(vec2(r,r)).x);\n    float rad_b = radians(34.0 + 10.0 * noise2(vec2(r,r)).x);\n    float rad_c = radians(19.0 + 8.0 * noise2(vec2(r,r)).x);\n    float rad_d = radians(23.0 + 8.0 * noise2(vec2(r,r)).x);\n\n    vec2 tyreMark_a = vec2(max(dground.x, sdCappedTorusY(opRotY(pos,42.0) - vec3(0,fh,0), vec2(sin(rad_a),cos(rad_a)), 2.5, 0.043)), TYRE_MARK);\n    vec2 tyreMark_b = vec2(max(dground.x, sdCappedTorusY(opRotY(pos,126.0) - vec3(0,fh,0), vec2(sin(rad_b),cos(rad_b)), 1.1, 0.032)), TYRE_MARK);\n    vec2 tyreMark_c = vec2(max(dground.x, sdCappedTorusY(opRotY(pos,245.0) - vec3(0,fh,0), vec2(sin(rad_c),cos(rad_c)), 0.7, 0.039)), TYRE_MARK);\n    vec2 tyreMark_d = vec2(max(dground.x, sdCappedTorusY(opRotY(pos,305.0) - vec3(0,fh,0), vec2(sin(rad_d),cos(rad_d)), 1.6, 0.056)), TYRE_MARK);\n    \n    vec2 res = vec2(1.0, DEFAULT);\n    res = xmin(res, dground);\n    res = xmin(res, tyreMark_a);\n    res = xmin(res, tyreMark_b);\n    res = xmin(res, tyreMark_c);\n    res = xmin(res, tyreMark_d);\n    return res;\n}\n\nvec2 wheelHoles(vec3 pos, float time)\n{\n    vec2 res = vec2(1.0, DEFAULT);\n    const vec3 offsetSide = vec3(0,0,0.04);\n    const float radiusHole = 0.01;\n    const float offsetCenter = 0.025;\n    float angleRot = time * 800.0;\n    res = xmin(res, vec2(sdCappedCylinder(opRotZ(pos, 0.0 + angleRot) - vec3(0,offsetCenter,0), offsetSide, -offsetSide, radiusHole), WHEEL_CAP));\n    res = xmin(res, vec2(sdCappedCylinder(opRotZ(pos, 72.0 + angleRot) - vec3(0,offsetCenter,0), offsetSide, -offsetSide, radiusHole), WHEEL_CAP));\n    res = xmin(res, vec2(sdCappedCylinder(opRotZ(pos, 144.0 + angleRot) - vec3(0,offsetCenter,0), offsetSide, -offsetSide, radiusHole), WHEEL_CAP));\n    res = xmin(res, vec2(sdCappedCylinder(opRotZ(pos, 216.0 + angleRot) - vec3(0,offsetCenter,0), offsetSide, -offsetSide, radiusHole), WHEEL_CAP));\n    res = xmin(res, vec2(sdCappedCylinder(opRotZ(pos, 288.0 + angleRot) - vec3(0,offsetCenter,0), offsetSide, -offsetSide, radiusHole), WHEEL_CAP));\n    return res;\n}\n\nvec2 wheels(in vec3 pos, float time, bool approx)\n{\n    vec2 res = vec2(1.0, DEFAULT);\n    \n    const vec3 offset_fr = vec3(0.325,0.03,0.2);\n    const vec3 offset_fl = vec3(0.325,0.03,-0.2);\n    const vec3 offset_rr = vec3(-0.26,0.03,0.2);\n    const vec3 offset_rl = vec3(-0.26,0.03,-0.2);\n    const vec3 offset_f = (offset_fr + offset_fl) / 2.0;\n    const vec3 offset_r = (offset_rr + offset_rl) / 2.0;\n    const vec3 offsetTyre = vec3(0,0,0.03);\n    const vec3 offsetRim = vec3(0,0,0.04);\n    const vec3 offsetCavityBegin = vec3(0,0,0.03);\n    const vec3 offsetCavityEnd = vec3(0,0,0.05);\n    const float radiusTyre = 0.07;\n    const float radiusRim = 0.05;\n    const float radiusCavity = 0.04;\n    const float roundWheelTyre = 0.005;\n    \n    vec3 pos_fr = opRotY(pos - offset_fr, GetWheelAngle(time));\n    //vec3 pos_fl = opRotY(pos - offset_fl, GetWheelAngle(time));\n    vec3 pos_rr = pos - offset_rr;\n    //vec3 pos_rl = pos - offset_rl;\n    \n    vec2 fr = vec2(opRound(sdCappedCylinder(pos_fr, offsetTyre, -offsetTyre, radiusTyre), roundWheelTyre), WHEEL_TYRE);\n    //vec2 fl = vec2(opRound(sdCappedCylinder(pos_fl, offsetTyre, -offsetTyre, radiusTyre), roundWheelTyre), WHEEL_TYRE);\n    vec2 rr = vec2(opRound(sdCappedCylinder(pos_rr, offsetTyre, -offsetTyre, radiusTyre), roundWheelTyre), WHEEL_TYRE);\n    //vec2 rl = vec2(opRound(sdCappedCylinder(pos_rl, offsetTyre, -offsetTyre, radiusTyre), roundWheelTyre), WHEEL_TYRE);\n    \n    res = xmin(res, fr);\n    //res = xmin(res, fl);\n    res = xmin(res, rr);\n    //res = xmin(res, rl);\n    \n    //if (!approx)\n    {\n    //vec2 raxle = vec2(sdCappedCylinder(pos, offset_f, offset_r, 0.01), WHEEL);\n    //vec2 caxle = vec2(sdCappedCylinder(pos, offset_rl, offset_rr, 0.01), WHEEL);\n    vec2 frRim = vec2(sdCappedCylinder(pos_fr, offsetRim, -offsetRim, radiusRim), WHEEL);\n    //vec2 flRim = vec2(sdCappedCylinder(pos_fl, offsetRim, -offsetRim, radiusRim), WHEEL);\n    vec2 rrRim = vec2(sdCappedCylinder(pos, offset_rr + offsetRim, offset_rr - offsetRim, radiusRim), WHEEL);\n    //vec2 rlRim = vec2(sdCappedCylinder(pos, offset_rl + offsetRim, offset_rl - offsetRim, radiusRim), WHEEL);\n    vec2 frCavity = vec2(sdCappedCylinder(pos_fr, offsetCavityBegin, offsetCavityEnd, radiusCavity), WHEEL_CAP);\n    //vec2 flCavity = vec2(sdCappedCylinder(pos_fl, -offsetCavityBegin, -offsetCavityEnd, radiusCavity), WHEEL_CAP);\n    vec2 rrCavity = vec2(sdCappedCylinder(pos, offset_rr + offsetCavityBegin, offset_rr + offsetCavityEnd, radiusCavity), WHEEL_CAP);\n    //vec2 rlCavity = vec2(sdCappedCylinder(pos, offset_rl - offsetCavityBegin, offset_rl - offsetCavityEnd, radiusCavity), WHEEL_CAP);\n    vec2 frHoles = wheelHoles(pos_fr, time);\n    //vec2 flHoles = wheelHoles(pos_fl, time);\n    vec2 rrHoles = wheelHoles(pos_rr, time);\n    //vec2 rlHoles = wheelHoles(pos_rl, time);\n    \n    //res = xmin(res, raxle);\n    //res = xmin(res, caxle);\n    res = xmin(res, frRim);\n    //res = xmin(res, flRim);\n    res = xmin(res, rrRim);\n    //res = xmin(res, rlRim);\n    res = xmax(res, vec2(-frCavity.x, WHEEL_CAP));\n    //res = xmax(res, vec2(-flCavity.x, WHEEL_CAP));\n    res = xmax(res, vec2(-rrCavity.x, WHEEL_CAP));\n    //res = xmax(res, vec2(-rlCavity.x, WHEEL_CAP));\n    res = xmax(res, vec2(-frHoles.x, WHEEL_CAP));\n    //res = xmax(res, vec2(-flHoles.x, WHEEL_CAP));\n    res = xmax(res, vec2(-rrHoles.x, WHEEL_CAP));\n    //res = xmax(res, vec2(-rlHoles.x, WHEEL_CAP));\n    }\n    \n    return res;\n}\n\nvec2 details(vec3 pos)\n{\n    vec2 res = vec2(1.0, DEFAULT);\n\n    // tail\n    vec2 body2d_d0[4];\n    body2d_d0[0] = vec2(0,0);\n    body2d_d0[1] = vec2(-0.05,0.018);\n    body2d_d0[2] = vec2(-0.048,0.025);\n    body2d_d0[3] = vec2(0,0.01);\n    vec3 pos_d0 = pos - vec3(-0.47,0.175,0);\n    vec2 dBody_d0 = vec2(opExtrusionZ(pos_d0, sdQuad(pos_d0.xy, body2d_d0), 0.18), BODY_METAL);\n    \n    // rod\n    vec2 dBody_d1 = vec2(1.0, DEFAULT);\n    dBody_d1 = xmin(dBody_d1, vec2(sdStick(pos, vec3(0,0.26,0.13), vec3(-0.19,0.1,0.14), 0.006, 0.006), BODY_METAL));\n    dBody_d1 = xmin(dBody_d1, vec2(sdStick(pos, vec3(0,0.26,-0.13), vec3(-0.19,0.1,-0.14), 0.006, 0.006), BODY_METAL));\n    vec2 dBody_d2 = vec2(1.0, DEFAULT);\n    dBody_d2 = xmin(dBody_d2, vec2(sdStick(pos, vec3(0,0.1,0.14), vec3(-0.48,0.1,0.14), 0.006, 0.006), BODY_METAL));\n    dBody_d2 = xmin(dBody_d2, vec2(sdStick(pos, vec3(0,0.1,-0.14), vec3(-0.48,0.1,-0.14), 0.006, 0.006), BODY_METAL));\n    \n    // engine\n    vec2 dBody_d3 = vec2(1.0, DEFAULT);\n    dBody_d3 = xmin(dBody_d3, vec2(sdStick(pos, vec3(0.33,0.17,0.12), vec3(0.36,0.18,0.12), 0.01, 0.012), BODY_METAL));\n    dBody_d3 = xmin(dBody_d3, vec2(sdStick(pos, vec3(0.33,0.17,-0.12), vec3(0.36,0.18,-0.12), 0.01, 0.012), BODY_METAL));\n    dBody_d3 = xmin(dBody_d3, vec2(sdTorusX(pos - vec3(0.36,0.18,0.12), vec2(0.01,0.01)), BODY_RED));\n    dBody_d3 = xmin(dBody_d3, vec2(sdTorusX(pos - vec3(0.36,0.18,-0.12), vec2(0.01,0.01)), BODY_RED));\n    \n    vec2 body2d_d3[4];\n    body2d_d3[0] = vec2(0,0);\n    body2d_d3[1] = vec2(0.01,0.04);\n    body2d_d3[2] = vec2(0.1,0.04);\n    body2d_d3[3] = vec2(0.12,0);\n    vec3 pos_d3 = pos - vec3(0.3,0.15,0);\n    dBody_d3 = xmin(dBody_d3, vec2(opExtrusionZ(pos_d3, sdQuad(pos_d3.xy, body2d_d3), 0.02), BODY_METAL));\n    \n    // lights\n    vec2 dBody_d4 = vec2(1.0, DEFAULT);\n    dBody_d4 = xmin(dBody_d4, vec2(sdSphere(pos - vec3(0.48,0.09,0.15), 0.03), HEAD_LIGHT));\n    dBody_d4 = xmin(dBody_d4, vec2(sdSphere(pos - vec3(0.48,0.09,-0.15), 0.03), HEAD_LIGHT));\n    \n    // mirros\n    vec2 dBody_d5 = vec2(1.0, DEFAULT);\n    vec3 pos_d5 = pos - vec3(0.20,0.19,0);\n    dBody_d5 = xmin(dBody_d5, vec2(sdBox(pos_d5 - vec3(0,0,0.215), vec3(0.005,0.015,0.025)), BODY_BLACK));\n    dBody_d5 = xmin(dBody_d5, vec2(sdBox(pos_d5 - vec3(0,0,-0.215), vec3(0.005,0.015,0.025)), BODY_BLACK));\n    \n    res = xmin(res, dBody_d0);\n    res = xmin(res, dBody_d1);\n    res = xmin(res, dBody_d2);\n    res = xmin(res, dBody_d3);\n    res = xmin(res, dBody_d4);\n    res = xmin(res, dBody_d5);\n    \n    return res;\n}\n\nvec2 claw(vec3 pos)\n{\n    vec2 claw2d[4];\n    claw2d[0] = vec2(0,0.03);\n    claw2d[1] = vec2(-0.04,0.138);\n    claw2d[2] = vec2(-0.054,0.144);\n    claw2d[3] = vec2(-0.022,0.15);\n    return vec2(opExtrusionZ(pos, sdQuad(pos.xy + vec2(noise2(vec2(pos.x,pos.y)*0.01).x * 0.008 - 0.004, 0), claw2d), 0.25), LOGO_GREEN);\n}\n\nvec2 monster(vec3 pos)\n{\n    vec2 res = vec2(1.0, DEFAULT);\n    // rear to forward\n    res = xmin(res, claw(opRotZ(pos,-6.0) * vec3(1.25,1.1,1) - vec3(-0.11,0.013,0)));\n    res = xmin(res, claw(opRotZ(pos,-2.0) * vec3(1.2,0.98,1) - vec3(-0.085,0,0)));\n    res = xmin(res, claw(opRotZ(pos,0.0) * vec3(1.4,1.1,1) - vec3(-0.076,0.018,0)));\n    return res;\n}\n\nfloat char(vec2 p,float c)\n{\n    // whichever gets the job done I guess\n\t//if(p.x<0.||p.x>1.||p.y<0.||p.y>1.)\n    //    return 1.0;\n    //else\n    //    return texture(iChannel1,p/16.+fract(floor(vec2(c,16.-c/16.))/16.)).a - 0.5+1.0/256.0;\n\tif(p.x<0.||p.x>1.||p.y<0.||p.y>1.)\n        return 1.0;\n    float result = texture(iChannel1,p/16.+fract(floor(vec2(c,16.-c/16.))/16.)).r;\n    if (result > 0.0)\n        return 0.0;\n    else\n        return 1.0;\n}\n\nvec2 letters(vec3 pos)\n{\n    const float scale = 20.0;\n    const float offset = 0.025*scale;\n    const vec2 origin = vec2(0, 0.09);\n    const float italic = 0.5;\n    vec2 res = vec2(1.0, DEFAULT);\n    // italic\n    vec2 letterPos = (pos.xy-vec2(italic*(pos.y-origin.y),origin.y))*scale;\n    // TOYO\n    if (char(letterPos,84.0) <= 0.0 ||\n        char(letterPos-vec2(offset,0),79.0) <= 0.0 ||\n        char(letterPos-vec2(2.0*offset,0),89.0) <= 0.0 ||\n        char(letterPos-vec2(3.0*offset,0),79.0) <= 0.0)\n        res = vec2(sdBox(pos, vec3(0.5,0.5,0.5)), LOGO_WHITE);\n        \n    letterPos -= vec2(0.03,-0.045)*scale;\n    // TIRES\n    if (char(letterPos,84.0) <= 0.0 ||\n        char(letterPos-vec2(offset,0),73.0) <= 0.0 ||\n        char(letterPos-vec2(2.0*offset,0),82.0) <= 0.0 ||\n        char(letterPos-vec2(3.0*offset,0),69.0) <= 0.0 ||\n        char(letterPos-vec2(4.0*offset,0),83.0) <= 0.0)\n        res = vec2(sdBox(pos, vec3(0.5,0.5,0.5)), LOGO_WHITE);\n    return res;\n}\n\nvec2 numbers(vec3 pos)\n{\n    const float scale = 7.0;\n    const float offset = 0.06*scale;\n    const vec2 origin = vec2(-0.12, 0);\n    const float italic = 0.3;\n    vec2 res = vec2(1.0, DEFAULT);\n    // z is u, x is v\n    vec2 letterPos = (pos.zx-vec2(italic*(pos.x-origin.y)+origin.x,origin.y))*scale;\n    // 43\n    if (char(letterPos,52.0) <= 0.0 ||\n        char(letterPos-vec2(offset,0),51.0) <= 0.0)\n        res = vec2(sdBox(pos, vec3(0.5,0.5,0.5)), LOGO_WHITE);\n        \n    return res;\n}\n\nvec2 car(vec3 pos, float time, bool approx)\n{\n    vec2 res = vec2(1.0, DEFAULT);\n#if 0\n    res = vec2(sdBox(pos-vec3(0,0.2,0),vec3(0.5,0.15,0.2)), BODY_BLACK);\n#else\n    vec3 offset = GetCarOffset();\n    \n#if SHOW_AXES\n    // axes\n    res = xmin(res, axes(pos, 0.6, 0.03));\n#endif\n    \n    // body a - frame\n    vec2 body2d_a0[4];\n    body2d_a0[0] = vec2(-0.3,-0.21);\n    body2d_a0[1] = vec2(0.51,-0.21);\n    body2d_a0[2] = vec2(0.51,0.21);\n    body2d_a0[3] = vec2(-0.3,0.21);\n    vec3 pos_a0 = pos - vec3(0,0.01,0);\n    vec2 dBody_a0 = vec2(opExtrusionQuadTaperY(pos_a0, body2d_a0, 0.05, offset.y + 0.04, offset.y + 0.05, 1.0, 0.95), BODY_BLACK);\n    \n    vec2 body2d_a1[4];\n    body2d_a1[0] = vec2(-0.5,-0.2);\n    body2d_a1[1] = vec2(0.5,-0.2);\n    body2d_a1[2] = vec2(0.5,0.2);\n    body2d_a1[3] = vec2(-0.5,0.2);\n    vec3 pos_a1 = pos - vec3(0,0.15,0);\n    vec2 dBody_a1 = vec2(opExtrusionQuadTaperY(pos_a1, body2d_a1, 0.025, 0.0, 0.025, 1.0, 0.95), BODY_BLACK);\n    dBody_a1 = xmin(dBody_a1, vec2(sdBox(pos - vec3(0,0.075,0), vec3(0.5,0.075,0.2)), BODY_BLACK));\n    \n    // wheel fenders\n    vec2 dBody_a2 = vec2(1.0, DEFAULT);\n    // wheel cavity\n    vec2 dBody_a3 = vec2(1.0, DEFAULT);\n    // trunk cavity\n    vec2 dBody_a4 = vec2(1.0, DEFAULT);\n    // radiator cavity\n    vec2 dBody_a5 = vec2(1.0, DEFAULT);\n    // engine cavity\n    vec2 dBody_a6 = vec2(1.0, DEFAULT);\n    // grille cavity\n    vec2 dBody_a7 = vec2(1.0, DEFAULT);\n    // monster\n    vec2 dBody_a8 = vec2(1.0, DEFAULT);\n    // letters\n    vec2 dBody_a9 = vec2(1.0, DEFAULT);\n    \n    if (!approx)\n    {\n    // wheel fenders\n    dBody_a2 = xmin(dBody_a2, vec2(sdCappedCylinder(pos, vec3(0.325,0.04,-0.22), vec3(0.325,0.04,0.22), 0.09), BODY_BLACK));\n    dBody_a2 = xmin(dBody_a2, vec2(sdCappedCylinder(pos, vec3(-0.26,0.04,-0.22), vec3(-0.26,0.04,0.22), 0.09), BODY_BLACK));\n    \n    // wheel cavity\n    dBody_a3 = xmin(dBody_a3, vec2(sdCappedCylinder(pos, vec3(0.325,0.03,-0.25), vec3(0.325,0.03,0.25), 0.075), BODY_BLACK));\n    dBody_a3 = smin(dBody_a3, vec2(sdCappedCylinder(pos, vec3(0.325,0.01,-0.25), vec3(0.325,0.01,0.25), 0.09), BODY_BLACK), 0.02);\n    dBody_a3 = xmin(dBody_a3, vec2(sdCappedCylinder(pos, vec3(-0.26,0.03,-0.25), vec3(-0.26,0.03,0.25), 0.075), BODY_BLACK));\n    dBody_a3 = smin(dBody_a3, vec2(sdCappedCylinder(pos, vec3(-0.26,0.01,-0.25), vec3(-0.26,0.01,0.25), 0.09), BODY_BLACK), 0.02);\n    \n    // trunk cavity\n    dBody_a4 = vec2(sdBox(pos - vec3(-0.25,0.125,0), vec3(0.2,0.06,0.16)), BODY_BLACK);\n    \n    // radiator cavity\n    vec2 body2d_a5[4];\n    body2d_a5[0] = vec2(0,-0.01);\n    body2d_a5[1] = vec2(-0.2,-0.01);\n    body2d_a5[2] = vec2(-0.2,0.08);\n    body2d_a5[3] = vec2(0,0.01);\n    vec3 pos_a5 = pos - vec3(-0.34,0,0);\n    dBody_a5 = vec2(opExtrusionZ(pos_a5, sdQuad(pos_a5.xy, body2d_a5), 0.3), BODY_BLACK);\n    \n    // engine cavity\n    dBody_a6 = vec2(1.0, DEFAULT);\n    dBody_a6 = xmin(dBody_a6, vec2(sdBox(pos - vec3(0.34,0.18,0.12), vec3(0.03,0.018,0.018)), BODY_BLACK));\n    dBody_a6 = xmin(dBody_a6, vec2(sdBox(pos - vec3(0.34,0.18,-0.12), vec3(0.03,0.018,0.018)), BODY_BLACK));\n    dBody_a6 = xmin(dBody_a6, vec2(sdBox(pos - vec3(0.36,0.18,0), vec3(0.06,0.02,0.03)), BODY_BLACK));\n    \n    // grille cavity\n    dBody_a7 = vec2(1.0, DEFAULT);\n    dBody_a7 = xmin(dBody_a7, vec2(sdBox(pos - vec3(0.5,0.15,0), vec3(0.04,0.006,0.14)), BODY_BLACK));\n    dBody_a7 = xmin(dBody_a7, vec2(sdBox(pos - vec3(0.5,0.12,0), vec3(0.04,0.005,0.12)), BODY_BLACK));\n    dBody_a7 = xmin(dBody_a7, vec2(sdBox(pos - vec3(0.5,0.09,0), vec3(0.04,0.005,0.12)), BODY_BLACK));\n    dBody_a7 = xmin(dBody_a7, vec2(sdBox(pos - vec3(0.5,0.06,0), vec3(0.04,0.005,0.12)), BODY_BLACK));\n    \n    // monster\n    dBody_a8 = monster(pos);\n    \n    // letters\n    dBody_a9 = letters(pos);\n    }\n    \n    vec2 dBody_a = vec2(1.0, DEFAULT);\n    dBody_a = xmin(dBody_a, dBody_a0);\n    dBody_a = xmin(dBody_a, dBody_a1);\n    if (!approx)\n    {\n    dBody_a = smin(dBody_a, dBody_a2, 0.05);\n    dBody_a = xmin(dBody_a, vec2(max(dBody_a.x, dBody_a8.x), LOGO_GREEN));\n    dBody_a = xmin(dBody_a, vec2(max(dBody_a.x, dBody_a9.x), LOGO_WHITE));\n    dBody_a = xmax(dBody_a, vec2(-dBody_a3.x, BODY_BLACK));\n    dBody_a = xmax(dBody_a, vec2(-dBody_a4.x, BODY_BLACK));\n    dBody_a = xmax(dBody_a, vec2(-dBody_a5.x, BODY_BLACK));\n    dBody_a = xmax(dBody_a, vec2(-dBody_a6.x, BODY_BLACK));\n    dBody_a = xmax(dBody_a, vec2(-dBody_a7.x, BODY_BLACK));\n    }\n    \n    // body b - cockpit\n    vec2 body2d_b0[4];\n    body2d_b0[0] = vec2(0.2,-0.19);\n    body2d_b0[1] = vec2(-0.08,-0.19);\n    body2d_b0[2] = vec2(-0.08,0.19);\n    body2d_b0[3] = vec2(0.2,0.19);\n    vec3 pos_b = pos - vec3(0.05,0.175,0);\n    vec2 dBody_b0 = vec2(opExtrusionQuadTaperY(pos_b, body2d_b0, 0.12, offset.y + 0.0, offset.y + 0.12, 1.0, 0.79), BODY_BLACK);\n    \n    // front window cull\n    vec2 dBody_b1 = vec2(sdBox(opRotZ(opCheapBendY(pos_b - vec3(0.185,0.1,0), 1.0), -30.0), vec3(0.04,0.12,0.2)), BODY_BLACK);\n    \n    // front window\n    vec2 dBody_b2 = vec2(1.0, DEFAULT);\n    // side window\n    vec2 dBody_b3 = vec2(1.0, DEFAULT);\n    // back window\n    vec2 dBody_b4 = vec2(1.0, DEFAULT);\n    // numbers\n    vec2 dBody_b5 = vec2(1.0, DEFAULT);\n    \n    if (!approx)\n    {\n    // front window\n    vec2 body2d_b2[4];\n    body2d_b2[0] = vec2(-0.17,0.185);\n    body2d_b2[1] = vec2(-0.14,0.28);\n    body2d_b2[2] = vec2(0.14,0.28);\n    body2d_b2[3] = vec2(0.17,0.185);\n    vec3 pos_b2 = pos - vec3(0.16,0,0);\n    dBody_b2 = vec2(opExtrusionX(pos_b2, sdQuad(pos_b2.zy, body2d_b2), 0.1), WINDOW);\n    \n    // side window\n    vec2 body2d_b3[4];\n    body2d_b3[0] = vec2(0.02,0.2);\n    body2d_b3[1] = vec2(0.022,0.265);\n    body2d_b3[2] = vec2(0.13,0.265);\n    body2d_b3[3] = vec2(0.16,0.2);\n    vec3 pos_b3 = pos;\n    dBody_b3 = vec2(opRound(opExtrusionZ(pos_b3, sdQuad(pos_b3.xy, body2d_b3), 0.3), 0.012), WINDOW);\n    \n    // back window\n    dBody_b4 = vec2(opRound(sdBox(pos - vec3(0,0.22,0), vec3(0.05,0.03,0.08)), 0.02), WINDOW);\n    \n    // numbers\n    dBody_b5 = numbers(pos);\n    }\n    \n    vec2 dBody_b = vec2(1.0, DEFAULT);\n    dBody_b = xmin(dBody_b, dBody_b0);\n    dBody_b = smax(dBody_b, vec2(-dBody_b1.x, BODY_BLACK), 0.01);\n    if (!approx)\n    {\n    dBody_b = xmin(dBody_b, vec2(max(dBody_b.x, dBody_b2.x), WINDOW));\n    dBody_b = xmin(dBody_b, vec2(max(dBody_b.x, dBody_b3.x), WINDOW));\n    dBody_b = xmin(dBody_b, vec2(max(dBody_b.x, dBody_b4.x), WINDOW));\n    dBody_b = xmin(dBody_b, vec2(max(dBody_b.x, dBody_b5.x), LOGO_WHITE));\n    }\n    \n    // body c - wheels\n    vec2 dBody_c = wheels(pos, time, approx);\n    \n    // body d - details\n    vec2 dBody_d = details(pos);\n    \n    // composite\n    vec2 dBody = vec2(100.0, DEFAULT);    \n    dBody = xmin(dBody, dBody_a);\n    dBody = xmin(dBody, dBody_b);\n    dBody = xmin(dBody, dBody_c);\n    if(!approx)\n    {\n    dBody = xmin(dBody, dBody_d);\n    }\n    \n    // result\n    res = xmin(dBody, res);\n#endif\n    return res;\n}\n\n// ray march\nvec2 map(vec3 pos, float time, bool approx)\n{\n    // ground\n    vec2 dground = ground(pos, time, approx);\n    \n    // car\n    vec2 dcar = car(WorldToCar(vec4(pos,1), time).xyz, time, approx);\n    \n#if SHOW_AXES\n    vec2 daxes = axes(pos, 0.1, 0.04);\n    vec2 daxesCar = axes(pos-GetDriftHead(time), 0.4, 0.04);\n    vec2 daxesWheel = axes(pos-GetWheelPos(time), 0.6, 0.01);\n#endif\n\n    vec2 res = vec2(100.0, DEFAULT);\n    res = xmin(res, dground);\n    res = xmin(res, dcar);\n    \n#if SHOW_AXES\n    res = xmin(res, daxes);\n    res = xmin(res, daxesCar);\n    res = xmin(res, daxesWheel);\n#endif\n\n    return res;\n}\n\nvec2 castRay(vec3 ro, in vec3 rd, float time, bool approx)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    const float tmin = TMIN;\n    const float tmax = TMAX;\n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h;\n        h = map(ro+rd*t,time,approx);\n        if(h.x<HIT_IF_SMALLER) \n        {\n            res = vec2(t,h.y);\n            break;\n        }\n        t += h.x; // min(0.05, h.x);\n    }\n    return res;\n}\n\n// compile time optimization magic suggested by Shane, thanks!\nvec3 calcNormal(in vec3 p, float time, bool approx) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n        vec2 res = map(p + sgn*e6[i/2], time, approx);\n\t\tmp[i] = res.x;\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nvec3 EvaluateProbe(vec3 wi)\n{\n    return texture(iChannel2, wi).rgb;\n}\n\nvec3 SpecularIBL(vec3 specularColor, float roughness, float fresnel, vec3 N, vec3 V)\n{\n    vec3 specularLighting = vec3(0);\n    const int NumSamples = 10;\n    for (int i = 0; i < NumSamples; i++)\n    {\n        vec2 Xi = Hammersley(i, NumSamples);\n        vec3 H = ImportanceSampleGGX(Xi, roughness, N);\n        vec3 L = 2.0 * dot(V, H) * H - V;\n        float NoL = saturate(dot(N, L));\n        if (NoL > 0.0)\n        {\n            vec3 probeColor = EvaluateProbe(L);\n            specularLighting += specularColor * probeColor * GGX(V, L, H, N, roughness, fresnel) * saturate(CosTheta(L, N));\n        }\n    }\n    return specularLighting / float(NumSamples);\n}\n\nvec3 lighting(SurfaceDataIn sdi, vec3 eyeDir, float t, float time)\n{\n    vec3 col = vec3(0);\n    vec3 sunDir = GetSunDir();\n    const float norOffset = 0.001;\n    float sunShadow = step(castRay(sdi.mPosWorld+norOffset*sdi.mNorWorld,sunDir,time,true).y,0.0);\n    float facingSun = saturate(dot(sunDir,sdi.mNorWorld));\n    vec3 sunLight = BRDF_GGX(sdi, sunDir, eyeDir) * saturate(facingSun) * vec3(40,30,20) * sunShadow;\n    vec3 IBL = SpecularIBL(sdi.mAlbedo, sdi.mRoughness, sdi.mFresnel, sdi.mNorWorld, eyeDir);\n    if (sdi.mMetallic == 0.0f)\n        IBL *= sdi.mSpecularity;\n    col = sunLight + IBL;\n    col = mix(col, SKY_COL1, 1.0-exp(-0.0001*t*t*t)); // blend to sky if far\n    return col;\n}\n\nvec3 sky(vec2 uv, vec3 rd, float time)\n{\n    // vec3 col = vec3(0.5,0.7,0.9) - max(rd.y,0.0)*0.5;\n    vec3 col = GetSkyCol(rd.y);\n    return col;\n}\n\n\nfloat flash(vec2 pos, float rad, float radius, float thickness, vec2 shear)\n{\n    vec2 sc = vec2(0,-1);\n    float posRad = PosToRad(pos);\n    float offset = saturate(posRad / (2.0*rad));\n    offset = mod(offset, 0.2)/0.2 * 2.0 - 1.0;\n    float t = sdRing(pos + shear * vec2(1.0 - 0.5 * offset),sc,radius,thickness + thickness * offset);\n    return t;\n}\n\nfloat decals(vec2 pos)\n{\n    float t = TMAX;\n    t = min(t, flash(pos.xy * vec2(1.5,2) - vec2(-0.3,0.15), radians(80.0), 0.15, 0.01, vec2(0.05,0.01)));\n    t = min(t, flash(pos.xy * vec2(1.5,-2) - vec2(-0.08,0.05), radians(100.0), 0.2, 0.02, vec2(0.05,0.01)));\n    t = min(t, flash(pos.xy * vec2(1.5,2) - vec2(0.4,0.1), radians(70.0), 0.23, 0.03, vec2(0.05,0.01)));\n    t = min(t, flash(pos.xy * vec2(1.5,-2) - vec2(0.3,-0.05), radians(90.0), 0.37, 0.02, vec2(0.05,0.01)));\n    t = min(t, flash(pos.xy * vec2(1.5,2) - vec2(0.4,0.1), radians(120.0), 0.35, 0.05, vec2(0.05,0.01)));\n    t = min(t, flash(pos.xy * vec2(1.5,2) - vec2(-0.4,0.1), radians(120.0), 0.35, 0.05, vec2(0.05,0.01)));\n    return t;\n}\n\nvec4 Render(vec2 uv, vec3 ro, vec3 rd, float time)\n{ \n    // sky dome\n    vec3 col = sky(uv, rd, time);\n    float tdepth = TMAX; // very large value\n    vec2 res = castRay(ro, rd, time, false);\n    if(res.x>0.0)\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor;\n        if (res.y == GROUND || res.y == TYRE_MARK)\n            nor = vec3(0,1,0);\n        else\n            nor = calcNormal(pos,time,false);\n        tdepth = t;\n        SurfaceDataIn sdi;\n        sdi.mPosWorld = pos;\n        sdi.mNorWorld = nor;\n        sdi.mRoughness = 1.0;\n        sdi.mFresnel = 0.8;\n        sdi.mMetallic = 0.0f;\n        sdi.mSpecularity = 0.0f;\n        if (res.y<DEFAULT+0.5)\n        {\n            sdi.mAlbedo = vec3(0.09, 0.008, 0.09);\n        }\n        else if (res.y<RED+0.5)\n        {\n            sdi.mAlbedo = vec3(0.09, 0.008, 0.008);\n        }\n        else if (res.y<GREEN+0.5)\n        {\n            sdi.mAlbedo = vec3(0.008,0.09,0.008);\n        }\n        else if (res.y<BLUE+0.5)\n        {\n            sdi.mAlbedo = vec3(0.008,0.008,0.09);\n        }\n        else if (res.y<GROUND+0.5)\n        {\n            sdi.mAlbedo = vec3(0.01,0.01,0.01);\n            sdi.mRoughness = 0.9;\n            sdi.mMetallic = 0.1;\n            vec3 nor = texture(iChannel0, pos.xz).rgb * 2.0 - 1.0;\n            sdi.mNorWorld = normalize(vec3(0.2*nor.x,1.0+(nor.y),0.2*nor.z));\n        }\n        else if (res.y<LOGO_WHITE+0.5)\n        {\n            sdi.mAlbedo = vec3(0.2,0.2,0.2);\n            sdi.mRoughness = 0.4;\n            sdi.mMetallic = 0.2;\n        }\n        else if (res.y<LOGO_GREEN+0.5)\n        {\n            sdi.mAlbedo = vec3(0.008,0.09,0.008);\n            sdi.mRoughness = 0.4;\n            sdi.mMetallic = 0.4;\n        }\n        else if (res.y<BODY_BLACK+0.5)\n        {\n            sdi.mAlbedo = vec3(0.02,0.02,0.02);\n            sdi.mRoughness = 0.1;\n            sdi.mMetallic = 0.8;\n            \n            vec3 posCar = WorldToCar(vec4(sdi.mPosWorld,1), time).xyz;\n            vec3 norCar = WorldToCar(vec4(sdi.mNorWorld,0), time).xyz;\n            vec3 absNorCar = abs(norCar);\n            if (absNorCar.x > absNorCar.y && absNorCar.x > absNorCar.z)\n            {\n                // facing x axis\n                if (decals(posCar.zy) < 0.0)\n                {\n                    sdi.mAlbedo = vec3(0.05,0.05,0.05);\n                }\n            }\n            else if (absNorCar.y > absNorCar.x && absNorCar.y > absNorCar.z)\n            {\n                // facing y axis\n                if (decals(posCar.xz*vec2(1,-1)) < 0.0)\n                {\n                    sdi.mAlbedo = vec3(0.05,0.05,0.05);\n                }\n            }\n            else if (absNorCar.z > absNorCar.x && absNorCar.z > absNorCar.y)\n            {\n                // facing z axis\n                if (decals(posCar.xy) < 0.0)\n                {\n                    sdi.mAlbedo = vec3(0.05,0.05,0.05);\n                }\n            }\n        }\n        else if (res.y<BODY_METAL+0.5)\n        {\n            sdi.mAlbedo = vec3(0.2,0.2,0.2);\n            sdi.mRoughness = 0.2;\n            sdi.mMetallic = 0.8;\n        }\n        else if (res.y<BODY_RED+0.5)\n        {\n            sdi.mAlbedo = vec3(0.09,0.008,0.009);\n            sdi.mRoughness = 0.2;\n            sdi.mMetallic = 0.7;\n        }\n        else if (res.y<WHEEL+0.5)\n        {\n            sdi.mAlbedo = vec3(0.09,0.09,0.09);\n            sdi.mRoughness = 0.3;\n            sdi.mMetallic = 0.75;\n        }\n        else if (res.y<WHEEL_TYRE+0.5)\n        {\n            sdi.mAlbedo = vec3(0.008,0.008,0.008);\n            sdi.mRoughness = 0.8;\n            sdi.mMetallic = 0.01;\n        }\n        else if (res.y<WHEEL_CAP+0.5)\n        {\n            sdi.mAlbedo = vec3(0.35,0.3,0.1);\n            sdi.mRoughness = 0.08;\n            sdi.mMetallic = 0.96;\n        }\n        else if (res.y<WINDOW+0.5)\n        {\n            sdi.mAlbedo = vec3(0.1,0.2,0.9);\n            sdi.mRoughness = 0.04;\n            sdi.mMetallic = 0.98;\n            sdi.mSpecularity = 0.0;\n        }\n        else if (res.y<HEAD_LIGHT+0.5)\n        {\n            sdi.mAlbedo = vec3(0.4,0.3,0.01);\n            sdi.mRoughness = 0.02;\n            sdi.mMetallic = 0.92;\n        }\n        else if (res.y<TYRE_MARK+0.5)\n        {\n            sdi.mAlbedo = vec3(0.001,0.001,0.001);\n            sdi.mRoughness = 0.9;\n            sdi.mMetallic = 0.01;\n        }\n        else\n        {\n            sdi.mAlbedo = vec3(0, 0, 0);\n        }\n        col = lighting(sdi,-rd,t,time);\n    }\n    vec3 pos = ro+tdepth*rd;\n    return vec4(col, tdepth);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 ro, rd;\n    \n    GetRoRd(fragCoord, iResolution.xy, iMouse, time, ro, rd);\n    vec4 col = Render(uv, ro, rd, time);\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}