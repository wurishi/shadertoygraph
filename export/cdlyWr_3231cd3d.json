{"ver":"0.1","info":{"id":"cdlyWr","date":"1686920075","viewed":1896,"name":"Imposter Syndrome","username":"stilltravelling","description":"This is a collection of shaders I've mangled together and somehow make them coherent(ish). I do not claim to be a shader expert, they are the people who really deserve the praise in this. Any optimizations would be vastly appreciated. Drag the sun around.","likes":71,"published":1,"flags":0,"usePreview":1,"tags":["sun","clouds","sky","moon","eclipse","scattering","rainbow","aurora","aurora","fireworks","weather","solar","shootingstars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Please don't hate me, if this needs removing let me know.\n\n//Pretty much most of this code is not mine\n//I will make attmepts to link to the original shaders if I can find them again\n//Apologies to all those that I don't find and apologies it's so messy. I'm sure there are much better ways to put these shaders together.\n//Stems from the original...\n// The sun, the sky and the clouds. By StillTravelling\n// https://www.shadertoy.com/view/tdSXzD\n\n//Ideally I would have like to add a bit of terrain, maybe some planes passing by but my head is far injured for now\n//\n\n//precision highp float;\n#define cloudy  0.3 //0.0 clear sky density of cloud\n#define cld1 0.4 //sort of acts as cloud cover? bigger gap between cld1 and cld2 = more coverage\n#define cld2 0.6 //sort of acts as cloud cover?\n#define rainvol 0.0 //0.5 //make it rain\n#define rainmulti 8.0 // makes clouds darker more density\n#define RAINBOW_BRIGHTNESS  0. //show rainbow\n#define scatonly 0. //Show certain components only\n#define snowvol 0. //Add snow\n#define fireworkson 0. // Add fireworks\n\n//cloud directions\n#define xaxiscloud -100.0*t //t*5e2 +t left -t right *speed\n#define yaxiscloud t*100.0 //0. //hmmm?\n#define zaxiscloud 250.0*t //t*6e2 +t away from horizon -t towards horizon *speed\n\n\n#define auroraINT 1.5\n#define lensflare 1.\n\n#define Dfact 0.5 //position of horizon\n\n#define scatter_steps 8\n#define scatter_steps2 4\n\n#define TAU 6.283185307179586\n#define ANIMATE_CLOUDS 0\n\n\n\n#define ENABLE_RAIN 1 //enable rain \n#define ENABLE_DENSE_RAIN 1 //enable DENSITY RAIN\n#define ENABLE_DENSE_RAIN2 0\n#define ORIG_CLOUD 0\n#define SIMPLE_SUN 1\n#define ENABLE_MOON 1\n#define ENABLE_MOON_2 0\n#define ENABLE_SEA 1\n#define ENABLE_LENS_FLARE 1\n#define ENABLE_BACK_TEXTURE 1\n#define EXPENSIVE_CALC 1 //not actually sure if these are expensive calcs!\n#define ENABLE_SCAT_OPTIONS 1\n#define SOFT_SUN 1\n#define NICE_HACK_SUN 1\n#define FIREWORK_COUNT 2 //2\n#define FIREWORK_DURATION 8.\n#define FIREWORK_LOW .75\n#define FIREWORK_HIGH 1.05\n#define ROCKET_PARTICES 16\n#define ROCKET_DURATION 1.5\n#define FLASH_DURATION ROCKET_DURATION + .2\n#define THRUSTER_SPEED .25\n#define EXPLOSION_STRENGTH .03;\n#define EXPLOSION_PARTICLES 32 //32\n\n\n#define cameraheight 5e1 //50m\n#define t iTime\n\n#define fov tan(radians(60.0))\n\n#define moonspec 10.\n#define moonillumination 1.0 //\n#define moon_rotate  0.\n#define moonlod 2.\n#define MoonINT 2.\n\n\n#define Rm 120.0\n\n\n#define rr 0.0000059\n#define rg 0.0000121\n#define rb 0.0000182\n//#define haze 0.01 * (cloudy*20.);\n//#define haze  custom5 //0.01 * (cloudy*20.)\n#define haze 0.01\n#define g0 0.76\n\n#define RI0 20. //Rayleigh Intensity\n\n\n#define mincloudheight 5000. //5e3 //5000m\n#define maxcloudheight 8000. //8e3 affects performance\n#define Hr 7.994e3\n#define Hm 1.2e3\n#define R0 6361e3 //planet radius //6360e3 - 6361e3\n#define Ra 6369e3 //atmosphere radius //6380e3 -6369e3\n#define rorder 0.\n#define SI 10. //Sun Intensity\n#define MI0 8. //Mie Intensity\n\n\n#define bM vec3(0.000051)\n#define cloudnoise 0.0002 //4e-4 //2e-4\n#define phaseR1 0.0596831\n#define phaseM1 0.1193662\n\n\n#define aurora_mt 1. //10\n\n#define aurora_noise 0.06 //0.1\n#define aurora_steps 50 //5.\n#define aurora_height 0. //1e-5\n#define aurorardy -0.05\n#define aurora2 0.\n#define aurorardz 0. //0\n#define aurora_f 0.065 //0.065\n#define aurora_sy 1. //0.065\n\n#define aurora_col 0.043 //0.043\n#define wavenoise 0.003\n#define wave_f 10.\n#define wave_t1 4.\n#define wave_t2 -1.\n#define aur_style 0.\n#define cloudtype 0.\n#define add_noise 0.\n\n#define eclispethreshold 0.05\n#define camera_height 10.\n#define camera_H_rotate radians(0.)\n#define camera_V_rotate radians(0.)\n#define camera_T_rotate radians(0.)\n#define camera_depth 0.\n#define aurora_ss 5. //5.\n#define aurora_ss2 0.002 //15.\n#define aurora_of 0.006 //0.006\n#define res 1.\n\n//#define 0.0 custom70\n#define h1 100.\n#define h2 1000.\n\n\n\n\n#define aurora_r 2.15 //2.15\n#define aurora_g -1. // -0.5\n#define aurora_b 1. // 1.2\n\n#define MIMin1  8.0\n#define SEA_HEIGHT 0.6\n#define SEA_CHOPPY 4.0\n#define SEA_SPEED 0.8\n#define SEA_FREQ 0.16\n#define SEA_BASE vec3(0.1,0.19,0.22)\n\n\n#define camz 0.001\n#define tonemap 9. // not really tonemap, just a quick way to test\n#define rb1 1.25\n//#define rb3 0.\n#define HmMin1 1200.\n#define SEA_NUM_STEPS 7.\n#define aa1 -1.\n#define aa2 0.\n#define sat 1.1\n#define vib 0.\n#define hue 0.\n#define spec 40.\n#define winddirx 0.\n#define rain1 4.\n#define rain2 0.05\n#define rain3 0.0\n#define rain4 0.05\n#define rain5 0.1\n#define rain6 10000.\n#define rain7 1.\n#define rain8 0.01\n#define rain9 1000.\n#define rain10 1000.\n#define rain11 0.4\n#define rain12 0.6\n#define rain13 0.25\n#define raleighgam 2.2\n#define miegam 1.6\n#define raleighgammin 1.0\n#define miegamin 1.6\n#define specmin 20.\n#define sealight 1.\n#define specbrightness 0.5\n#define mietype 0.\n\n\n#define lensflareb 1.\n#define lensgam 1.4\n#define lensflaretype 2.\n\n#define spectype 1.\n#define diffusepow 80.\n#define RRMin 0.0000025\n#define RRMax 0.0000058\n\n#define round(x, f) (floor((x)/(f) + 0.5) * (f))\n#define C1(x) clamp(x, 0., 1.)\n#define S1(a, b, x) smoothstep(a, b, x)\n#define F(x, f) (floor(x * f) / f)\n#define saturate(x)\tclamp(x, 0.0, 1.0)\n\n#define Argb vec3(aurora_r,aurora_g,aurora_b)\n#define C  vec3(0., -R0, 0.) //planet center\n\n\n\n//const float R0 = 6361e3; //planet radius //6360e3 - 6361e3\n//const float Ra = 6369e3; //atmosphere radius //6380e3 -6369e3\nconst int steps = 8; //16 is fast, 128 or 256 is extreme high\nconst int stepss = 4; //16 is fast, 16 or 32 is high\n\nconst float I = 10.; //sun light power, 10.0 is normal\n\n//const float RI = 10.; //Rayleigh Intensity\n//const float MI = 10.; //Mie Intensity\n//const float SI = 5.; //Sun Intensity\n\nconst float ng = 0.05; //light concentration for sky.76 //.45 //.6  .45 is normaL\nconst float ng2 = ng * ng;\n\nconst float s = 0.999; //light concentration for sun\n#if SOFT_SUN\nconst float s2 = s;\n#else\nconst float s2 = s * s;\n#endif\n\nconst float moon_s = 0.999; //light concentration for moon\n#if SOFT_SUN\nconst float moon_s2 = moon_s;\n#else\nconst float moon_s2 = moon_s * moon_s;\n#endif\n\n//const float Hr = 7.994e3; //Rayleigh scattering top //8e3\n//const float Hm = 1.2e3; //Mie scattering top //1.3e3\n//Note that there is a specific scale height value HM for the Mie scattering which is usually set to 1.2 km\n\n//vec3 bM = vec3(21e-6); //normal mie // vec3(21e-6)\n//vec3 bM = vec3(50e-6); //high mie\nvec3 bM2 = vec3(5e-6);\n\n\n//Rayleigh scattering (sky color, atmospheric up to 8km)\n//vec3 bR = vec3(5.5e-6, 13.0e-6, 22.4e-6); //normal earth\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //original earth\n//vec3 bR = vec3(5.8e-6, 20.5e-6, 33.1e-6); //redder sunset\n//vec3 bR = vec3(0.0000058,0.0000135,0.0000331);\n//vec3 bR = vec3(3.8e-6, 13.5e-6, 33.1e-6);\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\n//Wvec3 C = vec3(0., -R0, 0.); //planet center\nvec3 Ds = normalize(vec3(0., .09, -1.)); //sun direction?\nvec3 Dsm = normalize(vec3(0., .09, -1.)); //moon direction?\n\nconst float PI = 3.14159265358979323846;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\n\nfloat cloudyhigh = 0.05; //if cloud2 defined\n#if ORIG_CLOUD\nfloat cloudnear = 1.0; //9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; //15e3 17e3\n#else\nfloat cloudnear = 1.0; //15e3 17e3\nfloat cloudfar = 160e3; //9e3 12e3  //do not render too close clouds on the zenith\n#endif\n\n#define S(x, y, z) smoothstep(x, y, z)\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n//AURORA_STUFF\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(t*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.01,0.15), vec3(0.01,0.05,0.15), sd);\n    return col*.63;\n}\n\n\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nvoid aurora(vec3 rayorigin, vec3 raydirection, out vec3 bpos, out vec4 col)\n{\n    //vec4 col = vec4(0.);\n\t//mat3 rotY = rotateX(rain9);\n\tmat3 rotY = rotateX(-0.25);\n    vec4 avgCol = vec4(0);\n    rayorigin.z += t*aurora_height;\n\t//rayorigin *= fov;\n    //raydirection.y += -0.25;\n\traydirection.y +=0.1;\n\t//raydirection.y +=aurorardy;\n    raydirection.y *= aurora_sy;\n    //raydirection.z += aurorardz;\n\traydirection.z += -0.3;\n    raydirection *= rotY;\n\t\n\n\n    float mt = aurora_mt;\n    float ms = 50.;\n    for(int i=0;i<aurora_steps;i++)\n\n\n        {\n\n            float of = aurora_of * hash21(gl_FragCoord.xy) * smoothstep(0.,15., float(i) * mt);\n            float pt = ((.8 + pow(float(i),1.4) * aurora_ss2) - rayorigin.y) / (raydirection.y * 2. + 0.4);\n            pt -= of;\n            bpos = rayorigin + pt * raydirection ;\n\t\t\t//bpos *= fov;\n            vec2 p = bpos.zx +sin(t*0.01);\n            float rzt = triNoise2d(p, aurora_noise);\n            vec4 col2 = vec4(0,0,0, rzt);\n            col2.rgb = (sin(1. -vec3(aurora_r, aurora_g, aurora_b) + (float(i) * mt) * aurora_col) * 0.5 + 0.5) * rzt;\n            avgCol =  mix(avgCol, col2, .5);\n            col += avgCol * exp2( (-float(i)*mt) * aurora_f - 2.5) * smoothstep(0., aurora_ss, float(i)*mt);\n        }\n    col *= clamp(raydirection.y * 15. +0.4, 0., 1.);\n\tcol *= auroraINT;\n    //return col*auroraINT; //col*2.\n}\n\n//END AURORA_STUFF\n\n//SIMPLE SUN STUFF\nconst float density = 0.5;\nconst vec3 skyColor = vec3(0.37, 0.55, 1.0) * (1.0 + 0.0);\n\n\nfloat getSunPoint(vec2 p, vec2 lp){\n    return smoothstep(0.036*(fov/2.0), 0.001*(fov/2.0), distance(p, lp)) * 100.0;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n    float mytest = lp.y < 0.5 ? (lp.y+0.5)*pow(0.05,20.0):0.05;\n    float disk = clamp(1.0 - pow(distance(p, lp), mytest), 0.0, 1.0);\n    return disk*disk*(3.0 - 2.0 * disk) * 0.25 * PI;\n}\n\nvec3 getSkyAbsorption(vec3 x, float y){\n    vec3 absorption = x * y;\n    absorption = pow(absorption, 1.0 - (y + absorption) * 0.5) / x / y;\n    return absorption;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp, float zenithOffset){\n    float zenithnew = density / pow(max(p.y - zenithOffset, 0.0035), 0.75); //zenithDensity(p.y);\n    float sunPointDistMult =  clamp(length(max(lp.y + 0.1 - zenithOffset, 0.0)), 0.0, 1.0);\n    vec3 absorption = getSkyAbsorption(skyColor, zenithnew);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, density / pow(max((lp.y + 0.2) - zenithOffset, 0.0035), 0.15)); //zenithDensity(lp.y + 0.2));\n    vec3 sun3 = getSunPoint(p, lp) * absorption;\n    vec3 totalSky = sun3; //+ mie2;\n    totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n    vec3 newSky = jodieReinhardTonemap(totalSky);\n    return newSky;\n}\n//END SIMPLE SUN STUFF\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hashf(vec3 p3){\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3,p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noisef(vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hashf(i+vec3(0, 0, 0)), \n                       hashf(i+vec3(1, 0, 0)),f.x),\n                   mix(hashf(i+vec3(0, 1, 0)), \n                       hashf(i+vec3(1, 1, 0)),f.x),f.y),\n               mix(mix(hashf(i+vec3(0, 0, 1)), \n                       hashf(i+vec3(1, 0, 1)),f.x),\n                   mix(hashf(i+vec3(0, 1, 1)), \n                       hashf(i+vec3(1, 1, 1)),f.x),f.y),f.z);\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n\nfloat random(float p)\n{\n    return fract(52.043*sin(p*205.429));\n}\nfloat random2(float p)\n{\n    return random(p)*2.0-1.0;\n}\n\n\nvec3 meteor(vec2 uv, float gtime, float delay)\n{\n    float seed = round(gtime, delay);\n\n    float startTime = (delay - 1.5) * random(seed);\n    float time = max(0.0, min(1.0, gtime-seed - startTime));\n\n    vec2 start = vec2(\n        random2(seed),\n        0.7 + 0.3 * random(seed+0.1)\n    );\n\n    vec2 end = start * 0.5;\n\n    uv = uv - mix(start, end, time);\n\n    end = normalize(end - start);\n    uv = uv * mat2(end.x, end.y, -end.y, end.x);\n    uv.x *= 0.1;\n\n    float alpha = 16.0 * pow(time, 2.0) * pow(time - 1.0, 2.0);\n    return vec3(max(0.0, alpha - iResolution.y * length(uv)));\n}\n\nvec3 meteorstorm(vec2 uv)\n{\n    return\n        meteor(uv, iTime, 9.5837) +\n        meteor(uv, iTime + 15.3, 15.459) +\n        meteor(uv, iTime + 125.0, 31.2);\n}\n\nvoid fireworks(in vec2 st, out float MI2, out vec3 fire, out vec3 fireworkCol2)\n{\n    vec2 fireworkPos, particlePos;\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\n    shimmerThreshold, fade, fade2, timeHash, timeOffset, rocketPath;\n    vec3 particleHash, fireworkHash, fireworkCol,finalCol;\n\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\n\n    {\n        timeHash = hash11(float(j + 1) * 9.6144 + 4098.6118);\n        // original timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\n\n        // This hash changes after each firework cycle (rocket + explosion)\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146 + float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\n        fireworkCol = fireworkHash * .5 + .5;\n        fireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\n\n        // Random firework x coordinate but confined to a certain column based on j\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .50)/ float(FIREWORK_COUNT)) * 2. - 1.;\n        // original fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)/ float(FIREWORK_COUNT)) * 2. - 1.;\n\n        // Duration of each firework with a random start time\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\n         if (time > ROCKET_DURATION)\n        {\n            //fireworkCol2 = fireworkCol;\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\n\n    for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\n            {\n                // Unique hash that yeilds a separate spread pattern for each explosion\n                particleHash = hash31(float(j) * 1291.1978 + float(i) * 1619.8196 + 469.7119);\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\n\n                // Radius expands exponentially over time, i.e. explosion effect\n                radius = radiusScale * time * time;\n\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\n\n                // Shimmering effect for explosion particles\n                shimmer = max(0., sqrt(sparkDistFromOrigin) * (sin((iTime + particleHash.y * TAU) * 18.)));\n                shimmerThreshold = FIREWORK_DURATION * .6;\n\n\n\n                // Fade after a certain time threshold\n                fade = C1((FIREWORK_DURATION * 2.) * radiusScale - radius);\n\t\t\t\tfade2 += fade;\t\t\t\n\t\t\t\t\n                if(shimmer > 0. && fade>0.){\n\t\t\t\t\t\n                    fireworkCol2 = fireworkCol;\n\t\t\t\t}\n                finalCol += clamp(mix(spark, spark * shimmer, smoothstep(shimmerThreshold\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\n                    * fade * fireworkCol,0.0,1.);\n\n            }\n\n             MI2 = fade2;\n            // Initial instant flash for the explosion\n            if(time < FLASH_DURATION)\n            \tfinalCol += clamp(spark / (.01 + mod(time, ROCKET_DURATION)),0.,1.);\n\n\n\n         }\n        else\n        {\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\n            // ease out sine\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\n            fireworkPos = vec2(fireworkHash.x, rocketPath * fireworkHash.y);\n\n\n            // Slight random wiggle for the rocket's path\n            fireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\n\n            // Rockets flying before the explosion\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\n            {\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\n\n                // rocket trail size\n                float t = time * (2. - time);\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED * particleHash.z * .1;\n\n                // Confine theta to a small value for a vertical thrust effect\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                finalCol += clamp(8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.),0.0,10.);\n            }\n        }\n    }\n\n\n    fire =finalCol;\n    //MI2 = 5.;\n    MI2 = clamp(MI2,0.,1000.);\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.,0.,0.0);\n    float res0 = res / 2.0;\n    float res1 = 0.;\n    if (iResolution.x <iResolution.y){\n        res1 = iResolution.y * res0;\n    }\n    else{\n        res1 = iResolution.x * res0;\n    }\n\n    for (int i=0;i<4;i++)\n    {\n        vec3 q = fract(p*(.15*res1))-0.5;\n        vec3 id = floor(p*(.15*res1*(1./res0)));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+float(i)*float(i)*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\n\nfloat noise(in vec2 v) { return textureLod(iChannel0, (v+.5)/256., 0.).r; }\n\n// by iq\nfloat noise(in vec3 v) {\n\tvec3 p = floor(v);\n    vec3 f = fract(v);\n\t//f = f*f*(3.-2.*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy;\n\tvec2 rg1 = textureLod( iChannel0, (uv+.5)/256., -100.).yx;\n\treturn mix(rg1.x, rg1.y, f.z);\n}\n\nfloat Noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg1 = texture( iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n\treturn mix( rg1.x, rg1.y, f.z );\n}\n\nfloat fnoise(in vec3 v ) {\n#if ANIMATE_CLOUDS\n\treturn\n\t\t.55 * noise(v) +\n\t\t.225 * noise(v*2. + (t +(t*0.0)) *.04) +\n\t\t.125 * noise(v*3.99) +\n\t\t.0625 * noise(v*8.9);\n#else\n\treturn\n\t\t.55 * noise(v) +\n\t\t.225 * noise(v*2.) +\n\t\t.125 * noise(v*3.99) +\n\t\t.0625 * noise(v*8.9);\n#endif\n}\n\nfloat fnoise2( vec3 p, in float t )\n{\n\tp *= .25;\n    float f;\n\n\tf = 0.5000 * Noise2(p); p = p * 3.02; p.y -= t*.02;\n\tf += 0.2500 * Noise2(p); p = p * 3.03; p.y += t*.06;\n\tf += 0.1250 * Noise2(p); p = p * 3.01;\n\tf += 0.0625   * Noise2(p); p =  p * 3.03;\n\tf += 0.03125  * Noise2(p); p =  p * 3.02;\n\tf += 0.015625 * Noise2(p);\n    return f;\n}\n\n\n\nfloat cloud(vec3 p, in float t ) {\n    float cld =0.;\n    cld = fnoise2(p*cloudnoise,t) + cloudy*0.1;\n    cld = smoothstep(cld1+.04, cld2+.04, cld);\n    cld *= cld * (5.0*rainmulti);\n    return cld+haze;\n}\n\nvoid densities(in vec3 pos, in float highclouds, out float rayleigh, out float mie, in float Hm1, in float height_off) {\n\n    vec3 d = pos;\n    d *=fov;\n\t//d *=rotateX(0.5);\n    //vec3 dN = normalize(vec3(pos.x,pos.y,fov));\n    d.y = 0.0;\n    float dist = length(d); //z distance i think\n\n    float cld = 0.;\n    float godray =0.;\n    float test =0.;\n    float test2 =0.;\n    float test3 =0.;\n    float AR = iResolution.x/iResolution.y;\n\tfloat h = length(pos - C) - R0;\n\n    //density_l.z = clamp((1.0 / cosh((height_absorption - height_l) / absorption_falloff)) * density_l.x, 0.0, 1.0);\n\tif(dist < 500000.){\n    if (mincloudheight < h && h < maxcloudheight) {\n        //cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n        cld = cloud(pos + vec3(xaxiscloud,yaxiscloud, zaxiscloud),t)*cloudy;\n        cld *= sin(3.1415*(h-mincloudheight)/mincloudheight) * cloudy;\n\n    }\n\n    #ifdef cloud2\n    float cld2 = 0.;\n    if (12e3 < h && h < 15.5e3) {\n        cld2 = fnoise2(pos*3e-4,t)*cloud(pos*32.0+vec3(27612.3, 0.,-t*15e3), t);\n        cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n        cld2 = clamp(cld2,0.0,1.0);\n    }\n    #endif\n\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.,10.);\n        cld *= factor;\n\t\t\n\n\n    //FAKE HIGH CLOUDS\n    if(highclouds >0.){\n    if(d.y > 1000. && d.z > -20000.){\n        vec2 uv00 = (gl_FragCoord.xy / iResolution.xy);\n        vec2 uv3 = uv00 * (2.0) - (1.0);\n        uv3.x *=AR;\n        uv3.y +=Dfact;\n        float cldhighvol = cloudy + 0.5;\n        vec2 st0 =  (uv3 * vec2(.5 +(uv00.y +2.) *.75, 10.) + vec2(0. + uv00.y *10., t*0.05)) * 0.05;\n        float f0 = texture(iChannel0, st0, -100.0).y * texture(iChannel0, st0*.123, -100.0).x * 0.25;\n        float cloud1 = clamp(cldhighvol -.15, 0.0, 1.0);\n        float cloudthing = clamp( pow( abs(f0), 15.) * 1.0 * (cloud1*cloud1*5.), 0.0, (uv00.y +.1) *.6);\n        test3 = clamp(mix(cloudthing, cldhighvol,f0),0.,0.5);\n    }\n        }\n\n\n\n\n    // Add Rain\n    if(pos.y < rain6){\n    if(rainvol >0.){\n        \n            //BAKED GODRAY TYPE THING\n        vec2 uv0 = (gl_FragCoord.xy / iResolution.xy);\n            vec2 uv = uv0 * (2.0) - (1.0);\n            uv.x *=AR;\n            uv.y +=Dfact;\n            //uv  *= moonsz *M;\n            float rainvol0 = rainvol;\n            float rainthing;\n            float rainangle = winddirx;\n            vec2 st =  (uv * vec2(.5 +(uv0.y +rain1) *rain2, .1) + vec2(rain3 + uv0.y *rainangle, t*rain4)) * rain5;\n            float f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.123, -100.0).x * 1.55;\n            float rain = clamp(rainvol0 -.15, 0.0, 1.0);\n            rainthing = clamp( pow( abs(f), 15.) * 1.0 * (rain*rain*5.), 0.0, (uv0.y +0.1) *0.6);\n            test = clamp(mix(rainthing, rainvol0,f),0.,0.5);\n            float fade = smoothstep(0.5,0.6,abs(1.-uv0.y)); //between pos 0.5 and 0.6 fade \n\t\t\t//float fade = smoothstep(0.5,2.9,abs(1.-uv0.y)); //between pos 0.5 and 0.6 fade \n            //test = test * fade /8.;\n\t\t\ttest = test * fade;\n\t\t\t\n            if(rain7 ==1.){\n\t\t\t\tvec2 uv2 = uv0 * (2.0) - (1.0);\n\t\t\t\tuv2.x *=AR;\n\t\t\t\tuv2.y +=Dfact;\n\t\t\t\tfloat rainthing2;\n\t\t\t\t\tvec2 st2 =  (uv2 * vec2(.5 +(uv0.y +2.) *.5, .1) + vec2(0. + uv0.y *rainangle, t*0.05));\n\t\t\t\tfloat f2 = texture(iChannel0, st2, -100.0).y * texture(iChannel0, st2*.123, -100.0).x * 1.55;\n\t\t\t\tfloat rain2a = clamp(rainvol -.15, 0.0, 1.0);\n\t\t\t\trainthing2 = clamp( pow( abs(f2), 15.0) * 1.0 * (rain2a*rain2*5.), 0.0, (uv0.y +.1) *.6);\n\t\t\t\ttest2 = clamp(mix(rainthing2, 0.5*rainvol,f2),0.,0.1);\n\t\t\t\tfloat fade2 = smoothstep(rain11,rain12,abs(1.-uv0.y));\n\t\t\t\ttest2 = test2 * fade2;\n            }\n    }\n}\n    //End Rain\n\t\t/*\n\t\tif(dist > rain8){\n\t\t\tcld = smoothstep(0.,rain8,dist);\n\t\t\t//haze = 0.;\n\t\t\ttest = 0.;\n\t\t\ttest2 = 0.;\n\t\t}\n\t\t*/\n    }\n\t\n    if(tonemap == 4.0){\n    rayleigh =  exp(-h/Hr) + (cld*0.5);\n        }\n    else{\n        rayleigh =  exp(-h/Hr);// + (cld*rain10);\n    }\n\n    \n    if(tonemap == 10.){\n        if(h<height_off && h>=0.){\n        mie = exp((-h-rain10)/Hm1) + cld * + godray + test + test2 + test3 + haze ;\n            }\n        else{\n            mie = exp((-h)/Hm1) + cld  + godray + test + test2 + test3 + haze;\n        }\n        //mie +=  (cld * factor);\n    }\n    else if(tonemap==5.0){\n        mie = exp(-h/Hm1) + cld + godray + test + test2 + test3 + haze;\n        //mie +=  (cld * factor);\n    }\n    else{\n        mie = exp((-h)/Hm1) + godray + cld + test + test2 + test3 + haze;\n    }\n\n    #ifdef cloud2\n    mie += cld2;\n    #endif\n\n}\n\nvoid densities(in vec3 pos, in float Hm1, out float rayleigh, out float mie) {\n\t\n\tvec3 d = pos;\n    d *=fov;\n    //vec3 dN = normalize(vec3(pos.x,pos.y,fov));\n    //d.y = 0.0;\n   // float dist = length(d);\n\t\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\t//vec3 d = pos;\n    //d.y = 0.0;\n    float dist = length(d);\n    \n\tfloat cld = 0.;\n\tif (mincloudheight < h && h < maxcloudheight) {\n\t\t//cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n        cld = cloud(pos+vec3(xaxiscloud,yaxiscloud, zaxiscloud),t)*cloudy;\n\t\tcld *= sin(3.1415*(h-mincloudheight)/mincloudheight) * cloudy;\n\t}\n\t\n\t#ifdef cloud2\n        float cld2 = 0.;\n        if (12e3 < h && h < 15.5e3) {\n            cld2 = fnoise2(pos*3e-4,t)*cloud(pos*32.0+vec3(27612.3, 0.,-t*15e3), t);\n            cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n            cld2 = clamp(cld2,0.0,1.0);\n        }\n    \n    #endif\n\n    #if ORIG_CLOUD\n    if (dist<cloudfar) {\n        float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #else\n/*\n    if (dist>cloudfar) {\n\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n\t*/\n\t //if (dist>cloudfar) {\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.,10.);\n        //float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.,1.);\n        //float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.,1.);\n        cld *= factor;\n   // }\n\t\n    #endif\n\n\tmie = exp(-h/Hm1) + cld + haze;\n\t#ifdef cloud2\n\t\tmie += cld2;\n\t#endif\n    \n}\n\n\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n\n\nvoid scatter(vec3 camera_position, vec3 camera_vector, vec3 light_dir, vec2 uvMouse, vec3 moon_light_dir, vec3 aur_pos, vec3 aurr, vec3 BR1, vec3 bM1, float MI, float RI, float Hm1, float g1,out vec3 raleigh, out float scat,out vec3 themie,out vec3 thesun,out vec3 themoon, out float depthM,  out vec3 auro) {\n\n\t//float MI = MI0;\n\t//float RI = RI0;\n    //vec3 newSky = jodieReinhardTonemap(totalSky);\n    //vec3 bR = vec3(5.8e-6*cos(t),13.5e-6*cos(t), 33.1e-6*cos(t));\n    //vec3 bR = vec3(0.0005*cos(t),0.0002*cos(t), 0.0001*cos(t));\n\tfloat AR = iResolution.x/iResolution.y;\n\tfloat Dsfact = (0.5 - (Dfact/2.0));\n\tfloat ymax = Dsfact*0.8;\n\tfloat hz0 = Dsfact+0.08;\n\t//vec3 light_dir2 = normalize(vec3(uvMouse.x-(0.5*AR), uvMouse.y-Dsfact, (fov/-2.0)));\n\tvec3 light_dir2 = normalize(vec3(uvMouse.x-(0.5*AR), 0.08, (fov/-2.0)));\n\t\n\tvec3 bR2 =vec3( 13.5e-6, 13.5e-6, 13.5e-6 );\n\tvec3 aR2 = vec3( 0.000005, 0.000005, 0.000005 );\n    float MIM = 8.;\n\t\n    float g = g1/fov; //light concentration for sky.76 //.45 //.6  .45 is normaL\n    float g2 = g * g;\n\t\n\tfloat mg = 0.999;\n\tfloat mg2 = mg;\n\t\n\tfloat au = rain8;\n\tfloat au2 = au * au;\n\t\n\t\n\tvec3 aur_v = aur_pos *4.;\n    //aur_v.y += aurorardy;\n    //aur_v.y *= aurora_sy;\n    //aur_v.z += aurorardz;\n\t//vec3 aur_v = vec3(0.,1.,Ra);\n\t//vec3 aur_v = light_dir;\n\t\t\n\tfloat mu = dot(camera_vector, light_dir);\n\tfloat mu_moon = dot(camera_vector,moon_light_dir);\n\tfloat mu_aur = dot(camera_vector,aur_v);\n\t\n    float opmu2 = 1. + mu*mu;\n    float opmu2_moon = 1. + mu_moon*mu_moon;\n\tfloat opmu2_aur = 1. + mu_aur*mu_aur;\n\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n    float phasenM = .1193662 * (1. - ng2) * opmu2 / ((2. + ng2) * pow(1. + ng2 - 2.*ng*mu, 1.5));\n    float phaseS = .1193662 * (1. - s2) * opmu2 / ((2. + s2) * pow(1. + s2 - 2.*s*mu, 1.5));\n\n    //float phaseSm = .1193662 * (1. - moon_s2) * opmu2_moon / ((2. + moon_s2) * pow(1. + moon_s2 - 2.*moon_s2*mu_moon, 1.5));\n\tfloat phaseMoon = .1193662 * (1. - mg) * opmu2_moon / ((2. + mg) * pow(1. + mg - 2.*mg*mu_moon, 1.5));\n\t\n\t//float phaseAur = rain9 * (1. - au2) * opmu2_aur / ((2. + au2) * pow(1. + au2 - 2.*au*mu_aur, 1.5));\n\t//float phaseAur= rain9 * (1. - mg) * opmu2_aur / ((2. + mg) * pow(1. + mg - 2.*mg*mu_aur, 1.5));//\n\t//float phaseAur= 0.0596831 * opmu2_aur;\n\tfloat phaseAur= 0.00596831 * opmu2_aur;\n\t\n\tfloat highclouds = 0.;\n\tfloat height_off = 0.;\n\tfloat depthR = 0.; \n    depthM=0.;\n\tvec3 R = vec3(0.), M = vec3(0.),R2 = vec3(0.), M2 = vec3(0.), MR = vec3(0.), MM = vec3(0.),AMR = vec3(0.), AMM = vec3(0.);\n\t\n\t\n\tfloat L = escape(camera_position, camera_vector, Ra);\n\t//float dl = L / float(steps);\n\tfloat step_size_i = 0.;\n        step_size_i = L / float(scatter_steps);\n        for(int i=0; i < scatter_steps; ++i)\n     {\n\t//for (int i = 0; i < steps; ++i) {\n\t\t\n\t\t\n\t\tfloat l = float(i) * step_size_i;\n\t\tvec3 p = (camera_position + camera_vector * l);\n\t\tfloat dR, dM;\n\t\t\n\t\t#if ENABLE_DENSE_RAIN\n\t\tdensities(p,highclouds,dR,dM,Hm1,height_off) ;\n\t\t#else\n\t\tdensities(p,Hm1, dR, dM);\n\t\t#endif\n\t\t\n\t\tdR *= step_size_i; dM *= step_size_i;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, light_dir, Ra);\n\t\tfloat Ls2 = escape(p, light_dir2, Ra);\n\t\tfloat mLs = escape(p, moon_light_dir,Ra);\n\t\tfloat AmLs = escape(p, aur_v,Ra);\n\t\t\n\t\tif (Ls > 0.) {\n\t\t\t//float dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n                float step_size_l = Ls / float(scatter_steps2);\n                for (int j = 0; j < scatter_steps2; ++j)\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n\t\t\t{\n\t\t\t\tfloat ls = float(j) * step_size_l;\n\t\t\t\tvec3 ps = ( p + light_dir * ls );\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\t\t#if ENABLE_DENSE_RAIN2\n\t\t\t\t\tdensities(p,highclouds,dRs,dMs,Hm1,height_off) ;\n\t\t\t\t\t#else\n\t\t\t\t\tdensities(ps,Hm1, dRs, dMs);\n\t\t\t\t\t#endif\t\n\t\t\t\tdepthRs += dRs * step_size_l;\n\t\t\t\tdepthMs += dMs * step_size_l;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(BR1 * (depthRs + depthR) + bM1  * (depthMs + depthM)));\n\t\t\tR += (A * dR);\n\t\t\tM += A * dM; ;\n\t\t} \n\t\telse {\n\t\t}\n\t\t\n\t\tif (uvMouse.y < hz0) {\n\t\t\t//float dls = Ls2 / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n                float step_size_l = Ls2 / float(scatter_steps2);\n                for (int j = 0; j < scatter_steps2; ++j)\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n\t\t\t{\n\t\t\t\tfloat ls = float(j) * step_size_l;\n\t\t\t\tvec3 ps = ( p + light_dir2 * ls );\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\t\t#if ENABLE_DENSE_RAIN2\n\t\t\t\t\tdensities(p,highclouds,dRs,dMs,Hm1,height_off) ;\n\t\t\t\t\t#else\n\t\t\t\t\tdensities(ps,Hm1, dRs, dMs);\n\t\t\t\t\t#endif\t\n\t\t\t\tdepthRs += dRs * step_size_l;\n\t\t\t\tdepthMs += dMs * step_size_l;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(BR1 * (depthRs + depthR) + bM1  * (depthMs + depthM)));\n\t\t\tR2 += (A * dR);\n\t\t\tM2 += A * dM; ;\n\t\t} \n\t\telse {\n\t\t}\n\t\t\n\t\tif (mLs > 0.) {\n\t\t\t//float mdls = mLs / float(stepss);\n\t\t\tfloat mdepthRs = 0., mdepthMs = 0.;\n\t\t\t\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n                float step_size_l = mLs / float(scatter_steps2);\n                for (int j = 0; j < scatter_steps2; ++j)\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n\t\t\t{\n\t\t\t\tfloat mls = float(j) * step_size_l;\n\t\t\t\tvec3 mps = ( p + moon_light_dir * mls );\n\t\t\t\tfloat mdRs, mdMs;\n\t\t\t\t\t#if ENABLE_DENSE_RAIN2\n\t\t\t\t\tdensities(mps,highclouds,mdRs,mdMs,Hm1,height_off) ;\n\t\t\t\t\t#else\n\t\t\t\t\tdensities(mps,Hm1, mdRs, mdMs);\n\t\t\t\t\t#endif\n\t\t\t\tmdepthRs += mdRs * step_size_l;\n\t\t\t\tmdepthMs += mdMs * step_size_l;\n\t\t\t}\n\n\t\t\tvec3 MA = exp(-(bR2 * (mdepthRs + depthR) + bM1  * (mdepthMs + depthM)));\n\t\t\tMR += (MA * dR);\n\t\t\tMM += MA * dM; ;\n\t\t\t/*\n\t\t\tvec3 AMA = exp(-(aurr * (mdepthRs + depthR) + bM1  * (mdepthMs + depthM)));\n\t\t\tAMR += (AMA * dR);\n\t\t\tAMM += AMA * dM; ;\n\t\t\t*/\n\t\t} \n\t\telse {\n\t\t}\n\t\n\t\tif (AmLs > 0.) {\n\t\t\t//float Amdls = AmLs / float(stepss);\n\t\t\tfloat AmdepthRs = 0., AmdepthMs = 0.;\n\t\t\t\n\t\t\t//for (int j = 0; j < stepss; ++j) {\n                float step_size_l = AmLs / float(scatter_steps2);\n                for (int j = 0; j < scatter_steps2; ++j)\n\t\t\t{\n\t\t\t\tfloat Amls = float(j) * step_size_l;\n\t\t\t\tvec3 Amps = ( p + aur_v\t* Amls );\n\t\t\t\tfloat AmdRs, AmdMs;\n\t\t\t\tdensities(Amps,Hm1, AmdRs, AmdMs);\n\t\t\t\tAmdepthRs += AmdRs * step_size_l;\n\t\t\t\tAmdepthMs += AmdMs * step_size_l;\n\t\t\t}\n\n\t\t\tvec3 AMA = exp(-(aR2 * (AmdepthRs + depthR) + bM1  * (AmdepthMs + depthM)));\n\t\t\tAMR += (AMA * dR);\n\t\t\tAMM += AMA * dM; ;\n\t\t} \n\t\telse {\n\t\t}\n\t\t\n\t}\n\tif (uvMouse.y < hz0) {\n        themie = (MI) *(M2 * bM1  * (phaseM ));\n\t\tdepthM = depthM;\n    }\n\telse{\n\t\tthemie = (MI) *(M * bM1  * (phaseM )); // Mie scattering\n\t\tdepthM = depthM;\n\t}\n\traleigh = (RI) *(max(R,Rm) * BR1 * phaseR); //Rayleigh scattering\n    #if NICE_HACK_SUN\n    thesun = (SI) *(M * bM1  *phaseS); //Sun\n    #endif\n    //col = (RI) *(R * BR1 * phaseR); //Rayleigh scattering\n    scat = 1.0 - clamp(depthM*3e-5,0.,0.99); \n    \n    //themoon = ((Moon_I) *(bM1 *depthM*0.5) * (phaseSm)); //depthM - Cloud\n\tthemoon = (MoonINT * moonillumination) *(MM * bM1 * phaseMoon); //Moon\n\tauro = (1.) * (AMM * bM1) * phaseAur;\n}\n\nvec3 get_camera_vector(vec3 resolution, vec2 coord, float Dfacta) {\n    vec2 uv    = (coord.xy / resolution.xy) * 2. - 1.;\n    uv.x *= resolution.x / resolution.y;\n    uv.y +=Dfacta;\n\n    return normalize(vec3(uv.x, uv.y, -fov));\n}\n\n\n\nconst float MAX = 10000.0;\n//-----------------------------------------------------\n// Lightning functions\n//-----------------------------------------------------\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\n}\n//-----------------------------------------------------\n// Math functions\n//-----------------------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n    return length(p)-r;\n}\n\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\n    float b = dot( p, dir );\n    float c = dot( p, p ) - r * r;\n    float d = b * b - c;\n    if ( d < 0.0 ) return -MAX;\n    return -b + sqrt( d );\n}\n\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\n    float b = dot( p, dir );\n    float c = dot( p, p ) - r * r;\n    float d = b * b - c;\n    if ( d < 0.0 ) return vec2( MAX, -MAX );\n    d = sqrt( d );\n    return vec2( -b - d, -b + d );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// Seascape by TDM\n// \n// https://www.shadertoy.com/view/Ms2SD1\n//-----------------------------------------------------\n//const int   SEA_NUM_STEPS = 7;\nconst int   SEA_ITER_GEOMETRY = 3;\nconst int   SEA_ITER_FRAGMENT = 5;\n\nconst float SEA_EPSILON\t= 1e-3;\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\n//const vec3  SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n//const vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.1);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat sea_noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( \n        mix( hash( i + vec2(0.0,0.0) ), \n            hash( i + vec2(1.0,0.0) ), \n            u.x),\n        mix( hash( i + vec2(0.0,1.0) ), \n            hash( i + vec2(1.0,1.0) ), \n            u.x), \n        u.y);\n}\n\nfloat seaOctave( in vec2 uv, const in float choppy) {\n    if(tonemap!=8.){\n        uv += sea_noise(uv); //5ffps difference on laptop sea_noise vs noise\n    }\n    else{\n    uv += noise(uv); //5ffps difference on laptop sea_noise vs noise\n        }\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat seaMap(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {\n        d = seaOctave((uv+SEA_TIME)*freq,choppy);\n        d += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;\n        uv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat seaMapHigh(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \n        d = seaOctave((uv+SEA_TIME)*freq,choppy);\n        d += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSkyColor(vec3 e, vec3 skycolor) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    if (tonemap==3.){\n        return  skycolor;\n        }\n    else{\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n        }\n\n}\n\nvec3 hsv(float shue, float ssaturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(shue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), ssaturation);\n}\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist, vec3 skycolor,in float spec1, in vec3 moon_light,in float mLight, in float scat) {\n    \n    float RAINBOW_WATER_SATURATION\t= 0.35;\n    float RAINBOW_WATER_LIGHTNESS\t\t= 0.1; //0.2\n    float RAINBOW_WATER_SPEED \t\t= 0.1;\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n\n\n\n    vec3 reflected = getSkyColor(reflect(eye,n),skycolor);//*skycolor;\n\n    if(tonemap==7.){\n    vec3 weights_ = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n    float luminance_ = dot(reflected, weights_);\n    reflected = mix(vec3(luminance_), reflected, 0.1);\n    }\n    //vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    vec3 refracted = SEA_BASE + diffuse(n,l,diffusepow) * SEA_WATER_COLOR * 0.12; \n\n\n    vec3 color = mix(refracted,skycolor,fresnel) * skycolor ;\n\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    //color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    color +=  clamp(SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.08 * atten,0.,1.) ;\n\n    //vec3 l2 = normalize(vec3(l.x,0.5,l.z));\n    if(spectype==0.){\n        color += clamp(vec3(specular(n,l,eye,60.))* skycolor * specbrightness,0.,1.);\n    }\n    if(spectype==1.){\n        color += clamp(vec3(specular(n,l,eye,spec1))* skycolor * specbrightness,0.,1.);\n        }\n    if(spectype==2.){\n        color += clamp(vec3(specular(n,l,eye,spec1*scat))* skycolor * specbrightness,0.,1.);\n        }\n    if(spectype==3.){\n        color += clamp(vec3(specular(n,l,eye,clamp(1000.0*scat,10.,60.)))* skycolor * specbrightness,0.,1.);\n    }\n    if(spectype==4.){\n        color += clamp(vec3(specular(n,l,eye,clamp(1000.0*scat,10.,60.)))* skycolor * scat,0.,1.);\n    }\n    if(spectype==5.){\n        color += clamp(vec3(specular(n,l,eye,clamp(1000.0*scat,10.,60.)))* skycolor * scat* specbrightness,0.,1.);\n    }\n    if(spectype==6.){\n        color += clamp(vec3(specular(n,l,eye,spec1))* skycolor * scat* specbrightness,0.,1.);\n    }\n    if(spectype==7.){\n        color += clamp(vec3(specular(n,l,eye,60.))* skycolor * scat* specbrightness,0.,1.);\n    }\n    //color += clamp(vec3(specular(n,l*(1.-scat),eye,spec1))* skycolor * specbrightness,0.,1.);\n    color += vec3(specular(n,moon_light,eye,moonspec))* skycolor * moonillumination*mLight;\n\n    //color +=mix(vec3(specular(n,l,eye,spec1)),vec3(specular(n,moon_light,eye,60.))* moonillumination,0.5)* skycolor;\n    color = pow(color,vec3(0.65));\n    //color += hsv((p.z * 0.3) - iTime * RAINBOW_WATER_SPEED, RAINBOW_WATER_SATURATION, RAINBOW_WATER_LIGHTNESS);\n\n    return color;\n}\n\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\n    vec3 n;\n    n.y = seaMapHigh(p);    \n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat seaheightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;// really far distance, this could likely be tweaked a bit as desired\n    float hx = seaMap(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = seaMap(ori + dir * tm);    \n    float tmid = 0.0;\n\t\n    for(int i = 0; i < int(SEA_NUM_STEPS); i++) {\n\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n        float hmid = seaMap(p);\n        if(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n\nvec3 seaTransform( in vec3 x ) {\n    x.yz = rotate( 0.8, x.yz );\n    return x;\n}\n\nvec3 seaUntransform( in vec3 x ) {\n    x.yz = rotate( -0.8, x.yz );\n    return x;\n}\n\nfloat noisef2(float t)\n{\n    return texture(iChannel0,vec2(t,.0)/iChannelResolution[0].xy).x;\n}\nfloat noisev2(vec2 t)\n{\n    return texture(iChannel0,t/iChannelResolution[0].xy).x;\n}\n\nvec3 lensFlare(vec2 uv,vec2 pos,float whichtype)\n{\n    //uv.y +=-Dfact;\n    vec2 main = uv-pos;\n    vec2 uvd = uv*(length(uv));\n\n    float ang = atan(main.x,main.y);\n    float dist=length(main); dist = pow(dist,.1);\n    float n = noisev2(vec2(ang*16.0,dist*32.0));\n\n    float f0 = 1.0/(length(uv-pos)*16.0+6.0);\n\n    //f0 = f0*(sin(noisef2(sin(ang*2.+pos.x+sin(iTime*0.5))*4.0 - cos(ang*4.+pos.y))*16.)*.1 + dist*.1 + .8)*2.2;\n    //f0 = f0*(sin(noisef2(sin(ang*2.+pos.x-sin(iTime*0.15))*4.0 - cos(ang*4.+pos.y+sin(iTime*-0.15)))*16.)*.1 + dist*.1 + .8)*2.2;\n    f0 = f0*(sin(noisef2(sin(ang*2.+pos.x-(sin(iTime*0.05))*2.)*4.0 - cos(ang*4.+pos.y+cos(iTime*0.15)))*16.)*.1 + dist*.1 + .8)*2.2;\n\n    float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n    float f2,f22,f23;\n    float f4,f42,f43;\n    float f5,f52,f53;\n    float f6,f62,f63;\n    \n\n    if(whichtype == 2.){\n        f2 = max(1.0/(1.0+32.*pow(length(uv-0.05-pos),1.5)),.0)*00.25;\n        f22 = max(1.0/(1.0+32.*pow(length(uv+0.0-pos),1.5)),.0)*00.23;\n        f23 = max(1.0/(1.0+32.*pow(length(uv+0.05-pos),1.5)),.0)*00.25;\n        //f2 = max(1.0/(1.0+32.*pow(length(uv+0.0-pos),1.5)),.0)*00.25;\n        //f22 = max(1.0/(1.0+32.*pow(length(uv+0.0-pos),1.5)),.0)*00.23;\n        //f23 = max(1.0/(1.0+32.*pow(length(uv+0.0-pos),1.5)),.0)*00.21;\n    }\n    else{\n        f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n        f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n        f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n    }\n    vec2 uvx = mix(uv,uvd,-0.5);\n\n    if(whichtype == 2.){\n        f4 = max(0.01-pow(length(uv+0.0-pos),1.4),.0)*6.0;\n        f42 = max(0.01-pow(length(uv+0.0-pos),1.4),.0)*5.0;\n        f43 = max(0.01-pow(length(uv+0.0-pos),1.4),.0)*3.0;\n    }\n    else{\n        f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n        f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n        f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n    }\n\n    uvx = mix(uv,uvd,-.4);\n\n    if(whichtype == 2.){\n        f5 = max(0.01-pow(length(uv+0.0-pos),2.5),.0)*2.0;\n        f52 = max(0.01-pow(length(uv+0.0-pos),2.5),.0)*2.0;\n        f53 = max(0.01-pow(length(uv+0.0-pos),2.5),.0)*2.0;\n    }\n    else{\n        f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n        f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n        f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n    }\n\n    uvx = mix(uv,uvd,-0.5);\n\n    if(whichtype == 2.){\n        f6 = max(0.01-pow(length(uv+0.0-pos),1.6),.0)*6.0;\n        f62 = max(0.01-pow(length(uv+0.0-pos),1.6),.0)*3.0;\n        f63 = max(0.01-pow(length(uv+0.0-pos),1.6),.0)*5.0;\n    }\n    else{\n        f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n        f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n        f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n    }\n\n\n\n    vec3 c = vec3(.0);\n\n    if(whichtype == 2.){\n        c.r+=f2+f4+f5+f6; \n        c.g+=f22+f42+f52+f62; \n        c.b+=f23+f43+f53+f63;\n    }\n    else{\n        c.r+=f2+f4+f5+f6; \n        c.g+=f22+f42+f52+f62; \n        c.b+=f23+f43+f53+f63;\n    }\n\n    c = c*1.3 - vec3(length(uvd)*.05);\n    c+=vec3(f0);\n\n    return c;\n}\n\n\n//SNOW STUFF\nfloat SIZE_RATE = 0.1;\nfloat XSPEED = 0.5;\nfloat YSPEED = 0.75;\nfloat LAYERS = 20.;\n\nfloat Hash11(float p)\n{\n    vec3 p3 = fract(vec3(p) * 0.1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nvec2 Hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * 0.3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 Rand22(vec2 co)\n{\n    float x = fract(sin(dot(co.xy ,vec2(122.9898,783.233))) * 43758.5453);\n    float y = fract(sin(dot(co.xy ,vec2(457.6537,537.2793))) * 37573.5913);\n    return vec2(x,y);\n}\n\nvec3 SnowSingleLayer(vec2 uv,float layer){\n    vec3 acc = vec3(0.0,0.0,0.0);\n    uv = uv * (2.0 + layer);\n    float xOffset = uv.y * (((Hash11(layer)*2.-1.)*0.5+1.)*XSPEED);\n    float yOffset = YSPEED * iTime;\n    uv += vec2(xOffset,yOffset);\n    vec2 rgrid = Hash22(floor(uv)+(31.1759*layer));\n    uv = fract(uv) - (rgrid*2.-1.0) * 0.35 - 0.5;\n    float r = length(uv);\n    float circleSize = 0.04*(1.5+0.3*sin(iTime*SIZE_RATE));\n    float val = smoothstep(circleSize,-circleSize,r);\n    vec3 col = vec3(val,val,val)* rgrid.x  ;\n    return col;\n}\n// END SNOW\n\nfloat calcvalue(in float pos, in float min1, in float max1, in float bmin, in float bmax){\n\tfloat val = 0.;\n\tval = clamp(((max1-min1) * ((pos-bmin)/(bmax-bmin))) + min1,min1,max1);\n\treturn val;\n}\n\nvec3 getPixel(in vec2 coord, float time, in vec3 skycolor, in vec3 light_dir, in float spec1, in vec3 moon_light_dir2, in float mLight, in float scat) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += Dfact;\n    // ray\n    vec3 ang = vec3(0.0,0.0,0.0);\n    vec3 ori = vec3(xaxiscloud*0.001,3.5,zaxiscloud*0.001);\n    //vec3 ori = vec3(0.0,3.5,time);\n    \n    // This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.x,uv.y,-fov));\n    vec3 dir2 = dir;\n    \n    // Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n    //dir.z += length(uv) * 0.14;\n    mat3 rotZ = rotateZ(camera_T_rotate); //rotate on the Z axis //tilt\n    mat3 rotY = rotateY(camera_H_rotate);  //rotate on the Y axis //left and right\n    mat3 rotX = rotateX(camera_V_rotate);  //rotate on the Y axis //up and down\n    // Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * rotX * rotY * rotZ;\n\n    // tracing\n    // ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    seaheightMapTracing(ori,dir,p);\n    vec3 dist = p - ori; // distance vector to ocean surface for this pixel's ray\n    \n    // Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = seaGetNormal(p, dot(dist,dist) * SEA_EPSILON_NRM);\n    \n    // direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 moon_light = normalize(moon_light_dir2);\n    vec3 light = normalize(vec3(light_dir.x,light_dir.y,light_dir.z));\n\n    /*\n    if(mousepos.y < 0.5 - (Dfact/2.0)){\n        light.x=sun_pos_x;light.y=sun_pos_y;light.z=sun_pos_z;\n    }\n    */\n    // color\n    if (tonemap==3.){\n        return mix(\n            skycolor,\n            getSeaColor(p,n,light,dir,dist,skycolor,spec1,moon_light,mLight,scat),\n            pow(smoothstep(0.0,-0.02,dir.y),0.9));\n    }\n    else{\n        return getSeaColor(p,n,light,dir,dist,skycolor,spec1,moon_light,mLight,scat);\n\n        }\n}\n\n#define mul3x(x) \t\t\t\tx * x * x\n#define RAINBOW_START_Y\t\t\t\t\t0.0\n\n\nvec2 _smoothstep(in vec2 f)\n{\n    return f * f * (3.0 - 2.0 * f);\n}\n\nvec3 _smoothstep(in vec3 p)\n{\n    return p * p * 3.0 - 2.0 * mul3x(p);\n}\n\n\n\nvec3 rainbowColor(in vec3 ray_dir, in vec3 light_dir)\n{\n    \n    float RAINBOW_INTENSITY   \t\t= 0.3;\n    vec3 RAINBOW_COLOR_RANGE \t\t= vec3(56.0, 53.0, 50.0);  // The angle in degrees for red, green and blue\n\n    vec3 \t    RAINBOW_DIR \t\t\t\t= vec3(-0.2, -0.1, 0.0);\n    RAINBOW_DIR = normalize(light_dir);\n\n    float theta = degrees(acos(dot(RAINBOW_DIR, ray_dir)))*1.;\n    vec3 nd \t= saturate(1.0 - abs((RAINBOW_COLOR_RANGE - theta) * 0.2));\n    vec3 color  = _smoothstep(nd) * RAINBOW_INTENSITY;\n\n    return color * max((RAINBOW_BRIGHTNESS - 0.75) * 1.5, 0.0);\n}\n\nvec3 rainbow(vec2 fragCoord, vec3 light_dir)\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 p = fragCoord;\n    //p.y +=Dfact ;\n    float Dsfact = 0.5 - (Dfact/2.0);\n    vec3 RAINBOW_POS\t= vec3(0., -0.5, 0.5);\n    vec3 color = vec3(0.0);\n\n\n    if (p.y >= RAINBOW_START_Y)\n    {\n        vec3 rainbowW   \t  = -normalize(-RAINBOW_POS);\n        vec3 rainbowUp  \t  = normalize(cross(rainbowW, vec3(0.0, 1.0, 0.0)));\n        vec3 rainbowVertical = normalize(cross(rainbowUp, rainbowW));\n\n        vec3 dir = normalize(vec3(p, fov) - vec3(0.0, 0.25, rb1));\n        vec3 wdDir = normalize(dir.x * rainbowUp + dir.y * rainbowVertical - dir.z * rainbowW);\n\n        color += rainbowColor(wdDir,light_dir);\n    }\n    return saturate(color);\n}\n\nvec3 rainbow2(vec2 fragCoord, vec3 light_dir)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x / iResolution.y, 1.0);\n    p.y +=Dfact ;\n    vec3 RAINBOW_POS\t= vec3(4.5, -0.5, 0.5);\n    vec3 color = vec3(0.0);\n\n\n    if (p.y >= RAINBOW_START_Y)\n    {\n        vec3 rainbowW   \t  = -normalize(-RAINBOW_POS);\n        vec3 rainbowUp  \t  = normalize(cross(rainbowW, vec3(0.0, 1.0, 0.0)));\n        vec3 rainbowVertical = normalize(cross(rainbowUp, rainbowW));\n\n        vec3 dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n        vec3 wdDir = normalize(dir.x * rainbowUp + dir.y * rainbowVertical - dir.z * rainbowW);\n\n        color += rainbowColor(wdDir,vec3(-0.2, -0.1, 0.0));\n    }\n    return saturate(color);\n}\n\nvec3 rainbowhalo(vec2 fragCoord, vec3 light_dir)\n{\n\n    vec2 p = fragCoord;\n    //p.y +=Dfact ;\n    float Dsfact = 0.5 - (Dfact/2.0);\n    vec3 RAINBOW_POS\t= vec3(0., 0., 0.15);\n    vec3 color = vec3(0.0);\n\n\n    if (p.y >= RAINBOW_START_Y)\n    {\n        vec3 rainbowW   \t  = -normalize(-RAINBOW_POS);\n        vec3 rainbowUp  \t  = normalize(cross(rainbowW, vec3(0.0, 1.0, 0.0)));\n        vec3 rainbowVertical = normalize(cross(rainbowUp, rainbowW));\n\n        vec3 dir = normalize(vec3(p, -fov) - vec3(0.0, 0.25, 1.5));\n        vec3 wdDir = normalize(dir.x * rainbowUp + dir.y * rainbowVertical - dir.z * rainbowW);\n\n        color += rainbowColor(wdDir,light_dir);\n    }\n    return saturate(color);\n}\n\n\nvec3 shiftHue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return col;\n}\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, d);\n}\n\nvec3 circle2(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn color * d;\n}\n\nvec3 DrawCircle(vec2 uv, float radius, float fade)\n{\n    // Determine the length of the point away from the \"center\" of the circle.\n    float uvLength = length(uv);\n    // Apply color to any coordinate that lies within the circle.\n    // Black if coord is outside and white if it is inside the circle.\n    // The smoothstep function applies the fade to the circle.\n    // The min value is the radius, and max value is the radius minus\n    // the \"fade\" variable.\n    // This means the fade is applied within the bounds of the circle.\n    vec3 circle = vec3(smoothstep(radius, radius - fade, uvLength));\n    \n    return vec3(circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float AR = iResolution.x/iResolution.y;\n    float M = 1.; //res\n\tfloat Dsfact = 0.5 - (Dfact/2.0);\n\t\n\tvec2 uvMouse = (iMouse.xy / iResolution.xy);\n    uvMouse.x *= AR;\n    \n    vec2 uvMouseN = ((iMouse.xy / iResolution.xy)) * 2.0 - 1.0;\n    \n    if (uvMouse.y == 0.) uvMouse.y=(0.5-(0.05*fov)); //initial view \n    if (uvMouse.x == 0.) uvMouse.x=(1.0-(0.05*fov)); //initial view\n\t\n    mat2 ma = mat2(cos(moon_rotate), -sin(moon_rotate), sin(moon_rotate), cos(moon_rotate));\n\t\n\tmat3 rotZ = rotateZ(camera_T_rotate); //rotate on the Z axis //tilt\n    mat3 rotY = rotateY(camera_H_rotate);  //rotate on the Y axis //left and right\n    mat3 rotX = rotateX(camera_V_rotate);  //rotate on the Y axis //up and down\n    \n    float moonsz = 1.0;\n    //float moon_y2 = 1.75;\n    float moon_x2 = uvMouse.x-(0.5*AR);\n    float mlightoffsetx = 0.;\n    float moonpos_y =sin((uvMouseN.x) * 1.5);\n\t\n\tfloat uvMoonpos_y = (moonpos_y); \n    float uvMoonpos_y3 = ((moonpos_y) / 2.) + 0.125; //I don't understand what I'm doing here\n    float uvMoonpos_y2 = (moonpos_y)-Dsfact; //co-ordinates 0 to 1, 0.5 being center\n\n\n    float moon_size = moonsz *M;\n    \n    vec2 q = (fragCoord.xy /(iResolution.xy) ) * 2.0 - 1.0;\n    //q.x *=AR;\n   // q  *= moon_size;\n    \n    //float mfixx = (iMouse.x / iResolution.x); //*moon_size*AR;\n    float mfixy = (uvMoonpos_y2);//*moon_size;\n\n    vec2 uv0 = (fragCoord.xy / iResolution.xy);\n    uv0 *= M;\n\n    vec2 uv = uv0 * (2.0*M) - (1.0*M);\n    uv.x *=AR;\n\n   \n\n\tvec3 D_moon = normalize(vec3(q, -(fov*M)));\n\n    mat2 mar = mat2(cos(t*0.9), -sin(t*0.9), sin(t*0.9), cos(t*0.9));\n\n\n    vec2 uvMouse0 = (iMouse.xy / iResolution.xy);\n    float uvM = radians(uvMouse0.x*360.);\n\n    mat2 ma2 = mat2(cos(uvM), -sin(uvM), sin(uvM), cos(uvM));\n    float mlightoffsetx1 = (mlightoffsetx -0.5)/10.0; //From moon phase determines direction of light when not a full moon for example\n\n    vec3 camera_position = vec3(0,camera_height, camera_depth);\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord, Dfact)* rotZ * rotY * rotX;\n\n    //I don't understand why uvMouse.x-(0.5*AR) works (specifically (0.5*AR)) is it because the offset has to be multiplied by AR too?\n    float uvMo = uvMouse.x - (0.5 * AR) ;\n\n    \n    vec3 light_dir = normalize(vec3(uvMo, uvMouse.y-Dsfact, (fov/-2.0))); //changes later if (uvMouse.y < hz0)\n    //vec3 light_dir = normalize(vec3(uvMouse.x-(0.5*AR), uvMouse.y-Dsfact, (fov/-2.0))); //changes later if (uvMouse.y < hz0)\n    vec3 moon_light_dir = normalize(vec3(moon_x2, uvMoonpos_y3 , (fov/-2.0)));\n    vec3 light_dir_original = normalize(vec3(uvMouse.x-(0.5*AR), clamp(uvMouse.y,0.,1.), (fov/-2.0)));\n\n\t\n\t\n\n\tvec3 color = vec3(0.);\n    vec3 color2 = vec3(0.);\n\tvec3 raleigh = vec3(0.);\n    vec3 themoon = vec3(0.);\n    vec3 thesun = vec3(0.);\n    vec3 themie = vec3(0.);\n    vec3 star = vec3(0.);\n\tvec3 lensf = vec3(0.);\n\tvec3 fireworkCol = vec3(0.);\n\tvec3 fire = vec3(0.);\n\tvec3 auro = vec3(0.);\n    vec4 aur = vec4(0.);\n\tvec3 a_pos = vec3(0.);\n\n    float scat = 0.;\n    float depthM = 0.;\n\tfloat att = 1.;\n    float refatt = 1.;\n    float att_moon = 1.;\n    float sunatt = 1.;\n    float sunscat = 1.;\n    float moonatt = 1.;\n    float thing = 1.;\n\n    float staratt = 1.1 -min(1.0,pow(uvMouse.y+((Dfact/2.)+0.51),16.));\n    float scatatt = 1.0 -min(1.0,clamp((clamp(uvMouse.y,0.,1.)*((Dfact*4.)+2.)),0.55,1.));\n\t\n\t\n    float auratt = 1. -min(1.0,pow(uvMouse.y+0.51,64.));\n\n\t float fade = smoothstep(0.,0.01,abs(camera_vector.y))*0.1+0.9;\n\t\n\tvec3 bg1 = vec3(0.);\n    bg1 = bg(camera_vector) * fade;\n\t\n\tfloat MI2 = 1.;\n\t\n\tvec2 uvl = fragCoord.xy / iResolution.xy - 0.5;\n    uvl.x *= iResolution.x/iResolution.y;\n\t\n\t\n\tfloat hz = Dsfact;\n    float hzO = 0.08; //8% above horizon?\n    float hz0 = hz+hzO; //0.58\n\tfloat hz1 = hz0*0.84; \n\tfloat hz2 = Dsfact*0.84;\n\tfloat hd = hz0-hz1;     //0.0928\n    float hz1a = hz*0.84;   //0.4872\n    float hda = hz-hz1a;     //0.0928\n\n\tfloat g1 = g0;\n    float gmax = g0;\n    float gmin = 0.1;\n\t\n\tfloat newx = uvMouse.x-(0.5*AR);\n\t//float newx = 0.;\n    float newx2 = 0.;\n    float diffEI = (uvMoonpos_y3) - (uvMouse.y-Dsfact);\n    float diffEIp = 1.-abs(diffEI/eclispethreshold);\n\t\n\tfloat Hm1 = Hm;\n    float HmMax =Hm;\n    float HmMin =HmMin1;\n\n\tfloat RR1 = rr;\n    float RR1Max = rr;\n    float RR1Min = RRMin;\n\t\n\tfloat gam = 1.0;\n    float gamMax =miegam;\n    float gamMin =miegamin;\n\t\n\t\n\tfloat rgam = raleighgam;\n    float rgamMax =raleighgam;\n    float rgamMin =raleighgammin;\n\t\n     //2142\n    float spec1 = spec;\n    float specMax = spec;\n    float specMin = specmin;\n    float symax = Dsfact * 0.6;\n    float symin = Dsfact;\n    \n    float spymax = Dsfact * 0.8;\n    float spymin = Dsfact;\n\tfloat uvyD = (uvMouse.y-Dsfact);\n\t\n\tfloat ymax = Dsfact * 0.8;\n    float ymin = Dsfact * 0.6;\n\t\n\tfloat lensb = lensflareb;\n    float lensbMax = lensflareb;\n\t\n\t\n\tfloat mLight = 0.;\n    float mLightMax =1.;\n    float mLightMin = 0.;\n\t\n\tfloat bM1 = bM.x;\n    float bMMax = bM.x;\n    float bMMin = 0.000021;\n\t\n\tvec3 BM1 = bM;\n\t\n\tfloat MI1 = MI0;\n    float MImax = MI0;\n    float MImin = MIMin1;\n\t\n\tfloat RI1 = RI0;\n    float RImax = RI1;\n    float RImin = 0.;\n\t\n\tfloat EI = 0.;\n    float EImax = MI0;\n    float EImin1 = 0.;\n\tfloat RE =rain13;\n\t\n    float EImin = clamp(((EImax-EImin1)* ((moonillumination-1.)/(0.-1.))) + EImin1,EImin1,EImax);\n\t\n\tfloat sLight = 0.;\n    float sLightMax =2.;\n    float sLightMin =hzO;\n\t\n\n    bM1 = clamp(((bMMax-bMMin) * ((uvMouse.y-(Dsfact*1.5))/(1.-(Dsfact*1.5)))) +   bMMin,bMMin,bMMax);\n    vec3 bM11 = vec3(bM1);\n\t\n\tvec3 BR1;\n\t\n\tfloat uvMyin_ymaxymin = (uvMouse.y-ymin)/(ymax-ymin);\n\tfloat uvMyin_ymaxymin2 = (uvMouse.y-ymax)/(0.5-ymax);\n\tfloat uvMyin_ymaxymin3 = (uvMouse.y-Dsfact)/(0.5-Dsfact);\n\tfloat uvMyin_ymaxymin4 = (uvMouse.y-hz0)/(0.5-hz0);\n\tfloat uvMyin_ymaxymin5 = (uvMouse.y-Dsfact)/(0.3-Dsfact);\n\tfloat uvMyin_ymaxyminA = (uvMouse.y-ymax)/(Dsfact-ymax);\n\n\t\n\n\t\n\t\n\tif(sealight==0.){\n        uvyD = sLight;\n    }\n\t\n\tnewx2 = uvMouse.x-(0.5*AR);\n    vec3 sea_light_dir = normalize(vec3(newx2, uvyD, (fov/-2.0)));\n    vec3 moon_light_dir2 =vec3(0.);\n\t\n\t#if EXPENSIVE_CALC\n\tmLight = calcvalue(uvMouse.y, mLightMin, mLightMax,spymin,spymax);\n\tsLight = calcvalue(uvMouse.y, sLightMin, sLightMax,hz0,1.);\n\tspec1 = clamp(((specMin-specMax) * ((uvMouse.y-Dsfact)/(0.75-Dsfact))) + specMax,specMin,specMax);\n\trgam = clamp(((rgamMax-rgamMin) * (uvMyin_ymaxymin3)) + rgamMin,rgamMin,rgamMax);\n\tgam = clamp(((gamMin-gamMax) * (uvMyin_ymaxymin2)) + gamMax,gamMin,gamMax);\n\t#endif\n\t\n\t if(tonemap==9.){\n\t\t#if EXPENSIVE_CALC\n        Hm1 = clamp(((HmMax-HmMin) * (uvMyin_ymaxymin4)) + HmMin,HmMax,HmMin);\n        RR1 = clamp(((RR1Max-RR1Min) * (uvMyin_ymaxymin5)) + RR1Min,RR1Min,RR1Max);\n\t\t#endif\n        BR1 = vec3(RR1,rg,rb);\n\t\t\n    }\n    else{\n        BR1 = vec3(RR1,rg,rb);\n    }\n\t\n\t\n    if (uvMouse.y < Dsfact) {\n\n        light_dir = normalize(vec3(newx, -(0.01), (fov/-2.0)));\n\t\tmoon_light_dir2 = normalize(vec3((uvMouse.x-mlightoffsetx1)-(0.5*AR), uvMoonpos_y2 , (fov/-2.0)));\n\t\tspec1 = clamp(((specMax-specMin) * ((uvMouse.y-spymax)/(symin-spymax))) + specMin,specMin,specMax);\n\t\tgam = clamp(((gamMax-gamMin) * (uvMyin_ymaxymin)) + gamMin,gamMin,gamMax);\n\t\tlensb = clamp(((lensbMax-0.) * (uvMyin_ymaxyminA)) + 0.,0.,lensbMax);\n        att = 1.;\n        sunatt = 0.; \n        staratt = min(0.7,staratt);\n\t\t\n\t\t if(tonemap!=9.){\n\t\t\t#if EXPENSIVE_CALC\n\t\t\t\tHm1 = clamp(((HmMax-HmMin) * ((uvMouse.y-spymax)/(symin-spymax))) + HmMin,HmMin,HmMax);\n\t\t\t#endif\n\n        }\n\t\telse{\n\t\tHm1 = clamp((((HmMin-HmMax) * ((uvMouse.y-0.25)/(0.25-0.2)))) + HmMin,HmMax,HmMin);\t\n\t\t//Hm1 = 100.;\n\t\t}\n\t\t\n    }\n\t\n\t\n\tif (uvMouse.y < hz0) {\n\t\t\tsLight = clamp(((sLightMax-sLightMin) * ((uvMouse.y-symin)/(symax-symin))) + sLightMin,sLightMin,sLightMax);\n\t\t\tsea_light_dir = normalize(vec3(newx2, sLight, (fov/-2.0)));\n\t\t\tg1 = clamp(((gmax-gmin) * (uvMyin_ymaxymin)) + gmin,gmin,gmax);\n\t\t\tMI1 = clamp(((MImax-MImin) * (uvMyin_ymaxymin)) + MImin,MImin,MImax);\n\t\t\n\t\t\n        if(tonemap!=9.){\n\t\t\t\tHm1 = clamp(((HmMax-HmMin) * (uvMyin_ymaxymin)) + HmMin,HmMin,HmMax);\n\n        }\n\t\t\n\t\t\n\t\n\tif(uvMouse.y < Dsfact * 0.95){\n            //Do not add eclipse effect once sun is below horizon\n        }\n        else{\n            if (diffEI >= -eclispethreshold && diffEI <= eclispethreshold)  {\n                EI = clamp((((EImax-EImin) * (abs(diffEI)/(eclispethreshold-0.))) + EImin),EImin,EImax);\n                RE = clamp((((rain13-1.) * (abs(diffEI)/(eclispethreshold-0.))) + 1.),0.,1.);\n                MI1 = EI;\n            }\n        }\n\n        RI1 = clamp(((RImax-RImin) * ((uvMouse.y-ymin)/(ymax-ymin))) + RImin,RImin,RImax);\n \n        att = 1.;\n        staratt = min(0.7,staratt);\n    }\n    else{\n        //eclipse\n        if (diffEI >= -eclispethreshold && diffEI <= eclispethreshold)  {\n            EI = clamp((((EImax-EImin) * (abs(diffEI)/(eclispethreshold-0.))) + EImin),EImin,EImax);\n            RE = clamp((((rain13-1.) * (abs(diffEI)/(eclispethreshold-0.))) + 1.),0.,1.);\n            MI1 = EI;\n        }\n    }\n\n\n    //b = milkyway b1 = fireworks\n    vec2 b,b1,b2;\n    b = b1 = b2 = (fragCoord.xy /(iResolution.xy) ) * 2.0 - 1.0; //center coordinates?\n    b1.y +=Dfact;\n\n    float z = 1.2;\n    if (AR<1.0){\n        z = 2.4;\n    }\n    else {\n        z = 1.2;\n    }\n\n    float zoom = (2.0 *AR) * z;\n    b   /=zoom;\n    b.x *= AR;\n    b1.x *= AR;\n\t\n\t    //draw the badly implemented sun\n\t#if SIMPLE_SUN\n\n\t\tvec2 uv1 = (fragCoord.xy / iResolution.xy);\n\t\tuv1 *=M;\n\t\tuv1.x *=AR;\n\n\t\tfloat zenithoffset = (1.-Dfact)*0.48;\n\n\t\tvec3 sun2 = getAtmosphericScattering(uv1, uvMouse, zenithoffset) ;\n    #endif\n\n    //draw the reflection\n\tif (camera_vector.y < -0.01) {\n\t\tfloat L = - camera_position.y / camera_vector.y;\n\t\tcamera_position = camera_position + camera_vector * L;\n        camera_vector.y = -camera_vector.y;\n        q.y = (Dfact *-(moonsz * 2.)) -q.y;\n        b1.y = -b1.y;\n        b.y = -b.y;\n\n\t\trefatt = .6;\n        att_moon = .2;\n        star = stars(vec3(camera_vector.xy*ma2,camera_vector.z -camz));\n        if( uvMouse.y < Dsfact){\n\t\t\taurora(vec3(0.,camera_height/10000.,(camera_depth/10000.)-6.7),camera_vector,a_pos,aur);\n\t\t\taur = smoothstep(0.0,2.5,aur);\n\t\t}\n\t\telse{\n\t\t\taur = aur;\n\t\t}\n\t}\n    else{\n     \tfloat L1 =  camera_position.y / camera_vector.y;\n\t\tvec3 O1 = camera_position + camera_vector * L1;\n    \tvec3 D1 = vec3(1.);\n        D1 = normalize(camera_vector +vec3(1., 0.0009*sin(t+6.2831 * noise(O1.xz +vec2(0.,t*0.8))), 0.));\n        D1.xy *=ma2;\n    \tstar = stars(D1);\n\t\tif( uvMouse.y < Dsfact){\n\t\t\taurora(vec3(0.,camera_height/10000.,(camera_depth/10000.)-6.7),camera_vector,a_pos,aur);\n\t\t\taur = smoothstep(0.0,1.5,aur)* fade;\n\t\t}\n\t\telse{\n\t\t\taur = aur;\n\t\t}\n    }\n\t\n\tq.y > (0.2 * (moon_size/2.)/M) ? thing = 1.:  thing = (q.y / ((moon_size/2.)/M))*5.;\n\n    q.x += -uvMouseN.x;\n    q.y += -mfixy;\n    \n    q.x *= AR;\n\n    //q *= ma;\n    //q += 0.5;\n\t\n\tb.xy *=ma2;\n    b +=0.5;\n\t\n\tif (fireworkson >0.){\n        fireworks(b1,MI2,fire,fireworkCol);\n    }\n    \n    \n    \n    vec3 moon_texture1= textureLod(iChannel1,q, moonlod ).rgb;\n    //moon_texture1 = pow(moon_texture1,vec3(2.2));\n\t\n    vec4 layer1 = vec4(0.0, 0.0, 0.0, 1.0);\n    //vec3 layer2 = circle2(q.xy, q.xy*0.5, 0.1, vec3(1.,1.,1.));\n    vec3 layer2 = DrawCircle(q,0.05,0.01);\n    vec3 moon_texture = layer2*moon_texture1.rgb;\n    \n\n    //vec3 moon_texture = textureLod(iChannel1,q, 4. ).xyz;\n    moon_texture = pow(moon_texture,vec3(2.2));\n    \n    #if ENABLE_MOON_2\n    themoon *= moon_texture;\n    themoon *= att_moon;\n    color += themoon;\n    #endif\n\n    #if ENABLE_MOON\n    moon_texture *=att_moon;\n\t//moon_texture.rgb = pow(moon_texture.rgb,vec3(2.2));\n\n    #endif\n\n\n    vec3 Dn = camera_vector;\n \n    Dn.xy *=ma2; \n    Dn += 0.5;\n\n\n    vec3 back_texture = textureLod(iChannel2,vec2(b.x,b.y), 0. ).xyz;\n\tback_texture = pow(back_texture,vec3(2.2))*0.8;;\n\t\n\n    vec3 newmie = vec3(0.);\n    vec3 nightmie = vec3(0.);\n\t\n\n    scatter(camera_position, camera_vector,light_dir,uvMouse,moon_light_dir,a_pos,aur.rgb,BR1,bM11,MI1,RI1,Hm1,g1,raleigh,scat,themie,thesun,themoon,depthM,auro);\n \n    \n\tfloat seed = round(t, 1.);\n    float metx = random(seed);\n\n\tvec3 met = meteorstorm(vec2(camera_vector.x - metx,camera_vector.y+0.5));\n\t\n\tfloat scatfactor = ((abs(camera_vector.y)/0.5) * 0.00003) +0.00001;\n\n    scat = 1.0 - clamp(depthM*scatfactor,0.,1.);\n\n\t\n\tthemie *=  refatt;\n\traleigh *= refatt;//  *  (scat);\n\t\n\t\n\t\n\t\n\tif (uvMouse.y>hz0){\n    }\n    else {\n      sunscat = scat - (-1. +((uvMouse.y-hz0)/(hz0-hz1)));\n    }\n\t\n\tfloat ralatt = 1.0;\n\tfloat mieatt = 1.0;\n    if (uvMouse.y >= Dsfact){\n    }\n    else{\n\t\tvec3 weights2_ = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n\t\tfloat newmie2 = dot(themie, weights2_);\n        newmie = mix(themie,vec3(newmie2),1. -(max(hz2,uvMouse.y)-hz2)/0.04);\n\t\tralatt = (max(0.2,uvMouse.y)-0.2)/(0.25-0.2);\n\t\tmieatt = clamp((max(hz2,uvMouse.y)-hz2)*25.,0.15,1.0);\n\n\t\tcolor +=vec3(0.0,0.0,0.01* (1. -(max(hz2,uvMouse.y)-hz2)/0.04) );\n        themie = newmie;\n\t\tthemie = themie;\n\t\t\n    }\n\t\n\tcolor += back_texture.rgb * scat * scatatt;\n\n    themoon *= moonatt;\n    thesun *=  sunatt;\n  \n    star *=    staratt * refatt * scat;\n    met *=     staratt * refatt * scat;\n\tfire *=     staratt * refatt * scat;\n    \n\nvec3 mcolor =((vec3(scat)))*themie;\n\n if (diffEI >= -eclispethreshold && diffEI <= eclispethreshold)  {\n        vec3 newsun = clamp(thesun,0.,1.);\n        vec3 newsun2 = clamp(sun2,0.,1.);\n        color += (themoon*moonillumination*scat) * (1.-diffEIp);\n        color += moon_texture.rgb * scat * (1.-diffEIp);\n        vec3 moon2 = clamp(moon_texture.rgb*1000.,0.,1.);\n        //moon2 = mix(moon_texture.rgb,moon2,diffEIp);\n        color += clamp(newsun-(moon2),0.,1.)  * refatt * (scat);\n        color += clamp(newsun2-(moon2),0.,1.)  * refatt * (scat);\n    }\n    else{\n        if(tonemap==0. || tonemap==9.){\n            mcolor *=moon_texture.rgb * 30.;\n            color += mix(mcolor,color,0.9);\n        }\n        color += sun2 * (scat);\n        color += thesun* (scat);\n        color += (themoon*moonillumination*scat);\n        color += moon_texture.rgb * scat;\n\t\t\n    }\n\ncolor += clamp(auro * (aur.rgb*2. *themie)  * scatatt * refatt,0.,1.);\n\n\nif(tonemap!=12.){\n        raleigh = mix(raleigh*refatt,raleigh*refatt*scat,RE );\n        }\n    else{\n        raleigh *= refatt  *  (scat);\n    }\n\nif(tonemap==1. || tonemap==9.){\n    color += pow(raleigh *ralatt, vec3(rgam));\n}\nelse{\n    color += raleigh *ralatt;\n}\n\nif(tonemap==2. || tonemap==9.){\n    color += pow(themie, vec3(gam)) ;\n\n}\nelse{\n    color += themie;\n}\n\ncolor += pow(star, vec3(2.2));\ncolor += pow(met, vec3(2.2));\n\nvec3 firescatter = ((vec3(1.0-scat)))*themie;\nfirescatter *= (fireworkCol * MI2);\ncolor += mix(firescatter,color,0.5) *scatatt;\ncolor += fire;\n//color += clamp(fire,0.0,2.0);\n\nvec3 aur_col = bg1 *(1.-aur.a) + (aur.rgb*2.) * (scat);\naur_col = pow(aur_col, vec3(2.2));\naur_col *= scatatt * refatt;\ncolor += aur_col;\n\n//vec3 acolor = clamp(((vec3(1.0-scat)))*(themie-0.01),0.,1.);\n//acolor *=  aur.rgb*(2.);\n//color += mix(acolor,color,0.5) *scatatt;\n\n\n\n\n#if ENABLE_RAIN\nif(rainvol>0.){\n    float rainangle = winddirx;\n    vec2 st =  (uv * vec2(.5 +(uv0.y +2.) *.5, .02) + vec2(t*.5 + uv0.y *rainangle, t*0.1));\n    //vec2 st =  uv * vec2(.5 +(uv0.y +2.) *.5, .02) + vec2(t*.5 + uv0.y*.2, t*.1);\n    float f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\n    float rain = clamp(rainvol -.15, 0.0, 1.0); //amount of rain\n    f = clamp( pow( abs(f), 15.0) * 1.0 * (rain*rain*5.0), 0.0, (uv0.y +.1)*.6);\n    color = mix(color, vec3(0.15, .15, .15), f);\n}\n#endif\ncolor += rainbow(camera_vector.xy,light_dir_original) *refatt * clamp(min(RI1/RI0,MI1/MI0)*ralatt,0.,1.) * clamp(scat+0.1,0.,1.);\n\n\nif(snowvol>0.){\n    vec2 uv2 = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 acc = vec3(0,0,0);\n    for (float i = 0.; i < LAYERS; i++) {\n        acc += SnowSingleLayer(uv2,i); \n    }\n\n\n    color += acc.rgb;\n}\n\n#if ENABLE_LENS_FLARE\n\tif(lensflare>0.){\n\n\t\tvec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n\t\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\t\tif(lensflaretype==1.){\n\t\t\tlensf= vec3(1.4,1.2,1.0)*lensFlare(camera_vector.xy, normalize(vec3(uvMouse.x-(0.5*AR), uvMouse.y-Dsfact, (fov/-2.0))).xy,lensflaretype);//*clamp\n\n\t\t}\n\t\telse{\n\t\t\tlensf= vec3(1.4,1.2,1.0)*lensFlare(uvl, mouse,lensflaretype);//*clamp( flare+.3, 0., 1.);\n\t\t}\n\t\t//lensf += flamingSun(uvl,mouse);\n\t\tlensf = clamp(lensf*scat*lensb,0.,1.);\n\t\tlensf=pow(lensf,vec3(lensgam));\n\t\tcolor += lensf*ralatt;\n\t}\n#endif\n\ncolor =pow(color, vec3(1./2.2));\n//color =pow(color, vec3(1./2.2));\n\n#if ENABLE_SEA\n\t#define AA\n\t#ifdef AA\n\t\tint aa1a = int(aa1);\n\t\tint aa2a = int(aa2);\n\t\tfloat aadiff = abs(aa2-aa1)+1.;\n\t\tfloat aapow = pow(aadiff,2.);\n\t\tvec3 seacolor = vec3(0.0);\n\t\tfor(int i = aa1a; i <= aa2a; i++) {\n\t\t\tfor(int j = aa1a; j <= aa2a; j++) {\n\t\t\t\tvec2 uv = fragCoord+vec2(i,j)/aadiff;\n\t\t\t\tseacolor += getPixel(uv, t,color,sea_light_dir,spec1,moon_light_dir2,mLight,scat);\n\t\t\t}\n\t\t}\n\t\tseacolor /= aapow;\n\t#else\n\t\tvec3 seacolor = getPixel(fragCoord, t,color,sea_light_dir,spec1,moon_light_dir2,mLight,scat);\n\t#endif\n\n\tif (tonemap==3.){\n\t\tcolor = seacolor;\n\t}\n\telse{\n\t\tfloat L2 =  camera_position.y / camera_vector.y;\n\t\tif(L2 < 1.){\n\n\t\t\tcolor = mix(color,seacolor,pow(smoothstep(0.0,-0.05,-camera_vector.y), 0.5));\n\t\t}\n\t}\n#endif\n\n\nif (scatonly==1.){\n    color = vec3(scat); //white is sky\n}\nif(scatonly==2.){\n    color = vec3(1.-scat); //white is cloud\n}\nif(scatonly==3.){\n    color = vec3(0.5-scat);\n}\nif(scatonly==4.){\n    color = (vec3(1.-(scat))) * pow(vec3(0.0,1.,1.5)*(auroraINT*0.1)*scatatt,vec3(2.2));\n}\nif(scatonly==5.){\n    color = themie; //white is cloud;\n}\nif(scatonly==6.){\n    color = 1.-themie; //white is sky;\n}\n\nif(scatonly==7.){\n    color = vec3(scat)*themie; //white is sky;\n}\n\nif(scatonly==8.){\n    color = vec3(1.-scat)*themie; //white is sky;\n}\n\nif(scatonly==9.){\n    color = vec3(scat)*(1.-themie); //white is sky;\n}\n\nif(scatonly==10.){\n    color = vec3(1.-scat)*(1.-themie); //white is sky;\n}\n\nif(scatonly==11.){\n    vec3 acolor2 = clamp(((vec3(1.0-scat)))*(themie-0.01),0.,1.);\n    acolor2 *=  aur.rgb*(20.);\n    color = acolor2* scatatt;\n}\nif(scatonly==12.){\n    color = vec3(scat)*themie; //white is sky;\n    color += raleigh;\n}\n\nif(scatonly==13.){\n    color = vec3(scat)+themie;\n    color += raleigh;\n}\nif(scatonly==14.){\n    color = vec3(scat);\n    color += raleigh;\n}\nif(scatonly==15.){\n    color = themie;\n    color += raleigh;\n}\nif(scatonly==16.){\n    //color = themie;\n    color = raleigh;\n}\nif(scatonly==17.){\n    //color = themie;\n    color = vec3(scat)*raleigh;\n}\nif(scatonly==18.){\n    //color = themie;\n    color = lensf;\n}\nif(scatonly==19.){\n\tcolor = auro;\n}\nif(scatonly==20.){\n\tcolor = auro * ((aur.rgb) * themie) * scatatt * refatt;\n}\nif(scatonly==21.){\n\tcolor = auro * ((aur.rgb)) * scatatt * refatt;\n}\nif(scatonly==22.){\n\tcolor = aur.rgb;\n}\nif(scatonly==23.){\n\tcolor = aur_col;\n}\nif(scatonly==24.){\n\tcolor = aur_col;\n\tcolor += auro * ((aur.rgb) * themie) * scatatt * refatt;\n}\n\nvec3 weights_ = vec3(0.2125, 0.7154, 0.0721); // sums to 1\nfloat luminance_ = dot(color, weights_);\ncolor = mix(vec3(luminance_), color, sat);\n\n//vibrance\nfloat average = (color.r + color.g + color.b) / 3.;\nfloat mx = max(color.r, max(color.g, color.b));\nfloat vibrance = (mx - average) * vib;\ncolor = clamp(color - (mx - color) * vibrance,0.,1.);\n\ncolor = shiftHue(color, hue);\n\tfragColor = vec4(color, 1.);\n    //fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.); //Gamma Correction\n    //fragColor = vec4(pow(color, vec3(1.0/1.5)), 1.);\n}","name":"Image","description":"","type":"image"}]}