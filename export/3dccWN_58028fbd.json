{"ver":"0.1","info":{"id":"3dccWN","date":"1601016748","viewed":571,"name":"volumetric smoke","username":"bluebean","description":"Smoke","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf","volumetric","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tmax = 20.0;\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sdScene(vec3 p)\n{\n    vec2 res = vec2(999.0);\n    float r = 4.4;\n    res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\n    return res;\n}\n\n//iq's LUT 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\n    f = f*f*(3.0-2.0*f);\n     \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// assign colour to the media\nvec3 computeColour( float density)\n{\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.57,0.57,0.57), density );\n\t\n\treturn result;\n}\n\nfloat Turbulence(vec3 p)\n{\t\n\tfloat t = 0.;\n\tfloat oof = 1.;\n\tfor (int i=0; i<7; i++)\n\t{\n\t\tt += abs(noise(p))*oof;\n\t\toof *= 0.5;\n\t\tp *= 2.7;\t//bigger number, more detail\n\t}\n\t\n\treturn t-1.;\n}\n\n// maps 3d position to colour and density\nfloat densityFn( in vec3 p)\n{\n    float den = 0.0;\n    vec3 bottom = vec3(0.0,-4.4,0.0);\n    float r = 0.2;\n    float sr = 0.65;\n    float r_sq = r*r;\n    float downS = 1.0;\n    float maxH = 8.8;\n    float sBeginH = 1.0;\n\n    float theta_s = iTime*1.0;\n    float c = cos(theta_s);\n    float s = sin(theta_s);\n    float down = downS*iTime;\n    float c2 = 0.01*c;\n    float s2 = 0.0075*s;\n    float c3 = c2*2.25;\n    float s3 = s2*4.5;\n    float down3 = down*2.25;\n    vec3 lp = p;\n    float height = lp.y - bottom.y + noise(lp)*r;\n    height -= sBeginH;\n    height = max(0.0, height);\n    float tease = height/maxH;\n    lp.x += c3;\n    lp.y -= down3;\n    lp.z += s3;\n    float turb = Turbulence(lp);\n    float turbAmount = (turb-0.875)*(0.2 + 0.8*tease);\n    float pathTurb = turb*(0.2 + 0.8*tease);\n    height += 0.1*turbAmount;\n    \n    vec3 helPath = vec3(0.0);\n    helPath.x = c2*(1.0+pathTurb)*(1.0+tease*0.1)*(1.0+cos((p.y+down*0.5)*3.14159*2.0)*0.11) + sr*pathTurb;\n    helPath.z = s2*(1.0+pathTurb)*(1.0+tease*0.1)*(1.0+sin((p.y+down*0.5)*3.14159*2.0)*0.085) + 0.01*pathTurb;\n    helPath.y = -down - pathTurb;\n    vec3 direction = p + helPath;\n    vec3 center = vec3(bottom.x,p.y,bottom.z);\n    center.x += -turbAmount;\n    center.z += 0.75*turbAmount;\n    vec3 diff = vec3(0.0);\n    diff.x = center.x - direction.x;\n    diff.z = center.z - direction.z;\n    float dist_sq = diff.x*diff.x + diff.z*diff.z;\n    \n    den = (1.0-dist_sq/r_sq+turb*0.05)*2.11;\n    \n    den = max(0.0,den);\n\treturn den;\n}\n\nvec4 volumetricInternal(in vec3 rayo, in vec3 rayd,in float t)\n{\n    vec3 pos = rayo+rayd*t;\n    vec4 sum = vec4( 0.0 );\n    \n\tfloat Far = 10.;\n\t\n    float last_t = t;\n    for( int i = 0; i < 128 && t < tmax; i++ )\n    {\n        if( sum.a > 0.99 ) continue;\n\t\t\t\t\n\t\tfloat dens;\n\t\t\n        dens = densityFn(pos);\n\t\tdens *= (t-last_t)*1.5;\n\t\tvec4 col = vec4( computeColour(dens), dens );\n\t\t\n\t\t// colour by alpha\n\t\tcol.rgb *= col.a;\n\t\t\n\t\t// alpha blend in contribution\n\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t\n\t\t// step along ray\n        last_t = t;\n\t\tt += 0.062;\n\t\tpos = rayo + rayd * t;\n    }\n\tvec4 bg = texture(iChannel1,rayd); \n    //bg.a *= 0.6;\n    bg.rgb *= bg.a;\t\n\tsum = sum + bg*(1.0 - sum.a);  \n        \n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\n{\n    vec3 pos = rayo;\n    float t = 0.0;\n\t\n\tfor(int i = 0; i < 15 && t < tmax; i++)\n    {\n        vec2 h = sdScene(pos);\n        if( h.x < 0.0001*t)\n        { \n            return volumetricInternal(rayo,rayd,t); \n        }\n        t += h.x;\n        pos = rayo + rayd * t;\n    }\n    vec4 bg = texture(iChannel1,rayd); \n    //bg.a *= 0.6;\n    bg.rgb *= bg.a;\t\n    return bg; \n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\t\n    float camRadius = 10.8;\n\t// use mouse x coord\n\tfloat a = 0.0;// iTime * 20.;\n    if( iMouse.z > 0. )\n    {\n\t\ta = iMouse.x;\n        camRadius = iMouse.y/iResolution.y*camRadius;\n    }\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,0.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n\tvec3 rayDir, cameraPos;\n    rayDir = computePixelRay( p, cameraPos );\n\t\n\tvec4 col = vec4(0.);\n\tcol = raymarch( cameraPos, rayDir);\n    // smoothstep final color to add contrast\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\n}\n","name":"Image","description":"","type":"image"}]}