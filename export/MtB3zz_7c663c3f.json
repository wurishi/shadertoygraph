{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat3 rotY(in float a){\n\treturn mat3( cos(a), 0.0, sin(a),\n\t\t\t\t 0.0,    1.0, 0.0,\n\t\t\t\t-sin(a), 0.0, cos(a)\n\t\t\t    );\n}\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n    //r-=p.y*1.12;\n    //p*=rotY(iTime*.087683+p.x*.061);\n    //p.yxz*=rotY(iTime*.1+p.x*.016);\n    if(p.y>-1.9)\n    r+=-p.y*-1.1*texture(iChannel0,vec2((32./1024.)*3.141*atan(p.x,p.z)+0.1,p.y*.00811-iTime*.0126)).r;\n\n    vec3 pa = p - a , ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdHexPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdSphere( vec3 p, float s ){\n  s+=texture(iChannel2, vec2(2.+atan(p.x,p.z)*1.1,p.y)*0.21+iTime*.1).r*0.13;\n  return length(p)-s;\n}\nfloat pallo( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat scene(vec3 pos){\n\tfloat tulos=2.;\n    tulos = min(tulos, distance(texture(iChannel0, pos.xz*0.02423).r*0.6-1.3,pos.y+.1*sin(pos.z+sin(pos.x+iTime)+iTime)));\n    return tulos*0.86;\n}\nfloat calculateDistance(in vec3 p, out vec3 color){\n    vec3 rayPosition = vec3(p.xz, p.y).xzy;\n    vec3 d = abs(rayPosition) - vec3(2.0, 0.0, -52.0);\n    color = vec3(3.8, 1.0, 0.6);  \n    float finalDistance = 10000000.;\n    //float dist1;\n    float dist1 = sdCapsule( p, vec3(0.,5.5,0.), vec3(0.,-.0,0.), 1.84);\n    //dist1 = min(dist1, distance(texture(iChannel0, p.xz*0.02423).r*0.6-1.3,p.y+.1*sin(p.z+sin(p.x+iTime)+iTime)));\n\tdist1=min(dist1,scene(p));\n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.2, 1.0, 0.6)*19.15*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    \n    /*\n    dist1 = sdSphere( p-vec3(0.,0.,0.), 2.);\n    \n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.,2.1,1.1)*1.5*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    \n    dist1 = pallo( p-vec3(0.,0.,0.), 2.02);\n    \n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.,2.,6.1)*1.5*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    */\n    return finalDistance;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ){\n    float res = 1.0;\n    float t = mint;\n    for( float i=0.; i<11.; i++ ){\n        vec3 C;\n        float h = calculateDistance(ro + rd*t, C);\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tracer(vec3 rayStartPosition, vec3 rayDirection){\n\n    vec3 finalColor = vec3(0., 0., 0.);\n    vec3 rayPosition = rayStartPosition;\n    float stepable = 1.;\n    float dist = 0.;\n    vec3 normalVector = rayDirection;\n    float coff = 1.;\n    float find;\n    vec3 lightSource = vec3(16.,12.*sin(3.141*iTime*.01+3.141*.5), -6.7);\n    \n    for(float k=0.; k<2.; k++) {\n        find = 0.0;\n        for(float i=0.; i<33.; i++) {\n            vec3 color;\n            stepable = calculateDistance(rayPosition, color);\n            dist += stepable;\n            rayPosition = rayStartPosition + dist * rayDirection;\n            if(length(rayPosition)>33.) {\n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = (lightDir/length(lightDir));\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max(pow(directLight,55.)*vec3(1.6,1.1,.9)*1.8,0.0001);\n                return finalColor;\n            }\n            float value = 0.7;\n            if( abs(stepable) <= value){\n                float epsilon = value;\n                vec3 C;\n                normalVector = vec3(\tcalculateDistance(rayPosition+vec3(epsilon,0,0),C)-calculateDistance(rayPosition+vec3(-epsilon,0,0),C),\n                                        calculateDistance(rayPosition+vec3(0,epsilon,0),C)-calculateDistance(rayPosition+vec3(0,-epsilon,0),C),\n                                        calculateDistance(rayPosition+vec3(0,0,epsilon),C)-calculateDistance(rayPosition+vec3(0,0,-epsilon),C));\n                normalVector = normalize(normalVector);\n                \n                \n                float shadow = (0.3+softshadow(rayPosition + normalVector, normalize(lightSource), 0.01, 22.0) * .6);\n                finalColor = mix(finalColor, color * vec3(dot(normalVector, -rayDirection)) * shadow, coff) ;\n                finalColor = mix(finalColor, vec3(0.0), dist/15.0);  /*fog*/\n                find = 1.0;\n                break;\n                \n            }\n        }\n        dist = 0.0;\n        rayStartPosition = rayPosition + normalVector;\n        rayPosition = rayStartPosition;\n        rayDirection = reflect(rayDirection, normalVector);\n        coff *= 0.26;\t\n    }\n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = (lightDir/length(lightDir));\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max(pow(directLight,1.+iTime*0.4)*vec3(1.6,1.1,.9)*1.8,0.0001);\n                return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 cameraPosition = vec3( 0., 5.+sin(iTime/8.), -18.+sin(iTime/5.)*4.);\n    cameraPosition*=rotY(-3.141*2.*iTime*0.081);\n    cameraPosition*=rotY(3.141*2.*iTime*0.0001);\n\tcameraPosition*=rotY(iTime*.7);\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(.5 * uv * vec2(aspect, 1.0), 1. )) ;\n    direction.yxz *= rotY(-0.24);\n    direction*=rotY(-3.141*2.*iTime*0.081);\n    direction *= rotY(iTime*.7);\n    vec4 C = vec4(tracer(cameraPosition, direction),1.0);\n\tfloat vignette = 1.165 / (1.25 + 1.4*dot(uv, uv));\n\t\n    fragColor=vec4(pow(C.r,2.2)*C.rgb-vec3(.27),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtB3zz","date":"1426624703","viewed":521,"name":"Fire and water","username":"Branch","description":"Fire and water","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["fireandwater"],"hasliked":0,"parentid":"","parentname":""}}