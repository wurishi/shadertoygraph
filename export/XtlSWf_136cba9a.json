{"ver":"0.1","info":{"id":"XtlSWf","date":"1440210361","viewed":211,"name":"Jack's Raymarcher","username":"jackdavenport","description":"My experiment doing a raymarcher.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","test","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 300\n#define MIN_DISTANCE 0.001\n\nstruct Ray {\n  \n    vec3 pos;\n    vec3 dir;\n    \n};\n    \nstruct Hit {\n\n    vec3 p;\n    float d;\n    int id;\n    int iterations;\n    \n};\n    \nstruct Distance {\n\n    float dist;\n    int id;\n    \n};\n    \nvec3 light1 = vec3(1.,2.,-3.);\nfloat ambient = .2;\n\nfloat sphere(vec3 p, vec3 pos, float radius) {\n \n    return length(pos - p) - radius;\n    \n}\n\nfloat cube(vec3 p, vec3 pos, vec3 radius) {\n \n    vec3 d = p - pos;\n    vec3 r = abs(d) - radius;\n    \n    return max(r.x,max(r.y,r.z));\n    \n}\n\nfloat plane(vec3 p, float h) {\n \n    return p.y - h;\n    \n}\n\nvec2 rot2D(vec2 p, float angle) {\n    \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    float x = p.x * c - p.y * s;\n    float y = p.x * s + p.y * c;\n    \n    return vec2(x,y);\n    \n}\n\nvec3 rotY(vec3 p, float angle) {\n \n    vec2 xz = p.xz;\n    xz = rot2D(xz,angle);\n    \n    return vec3(xz.x,p.y,xz.y);\n    \n}\n\nDistance dMin(Distance d1, float d2, int id) {\n \n    if(d1.dist < d2) {\n     \n        return d1;\n        \n    } else {\n     \n        return Distance(d2,id);\n        \n    }\n    \n}\n\nDistance distScene(vec3 p) {\n    \n    float angle = 90.;\n    vec3 r = rotY(p, p.y * angle * sin(iTime));\n    \n    if(iMouse.z > 0.) {\n     \n        vec2 m = iMouse.xy / iResolution.xy;\n        float rot = -angle + (m.x * (angle * 2.));\n        \n        r = rotY(p, p.y * angle);\n        \n    }\n    \n    float dSphere = sphere(p,vec3(sin(iTime),0.,1.),.8);\n    float dSphere1 = sphere(p,vec3(sin(iTime + .8),0.,1.),.8);\n    float dBox = cube(r,vec3(.2,0.,1.),vec3(.5,2.,.5));\n    float dPlane = plane(p,-1.); \n    \n    float dInt = max(dSphere,dSphere1);\n    \n    Distance d = Distance(dInt,0);\n    //d = dMin(d,dSphere1,0);\n    d = Distance(dBox,0);\n    d = dMin(d,dPlane,1);\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n \n    const float d = .001;\n    \n    vec3 left = vec3(p.x - d,p.yz);\n    vec3 right = vec3(p.x + d,p.yz);\n    vec3 up = vec3(p.x,p.y-d,p.z);\n    vec3 down = vec3(p.x,p.y+d,p.z);\n    vec3 front = vec3(p.xy,p.z-d);\n    vec3 back = vec3(p.xy,p.z+d);\n    \n    float distLeft = distScene(left).dist;\n    float distRight = distScene(right).dist;\n    float distUp = distScene(up).dist;\n    float distDown = distScene(down).dist;\n    float distFront = distScene(front).dist;\n    float distBack = distScene(back).dist;\n    \n    return normalize(vec3(distRight-distLeft,distDown-distUp,distBack-distFront));\n    \n}\n\nHit trace(Ray ray) {\n \n   const float s = .75;\n    \n   vec3 p = ray.pos;\n   float d = 0.;\n   int id = -1;\n   int iter = 0;\n    \n   for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n   \t  Distance dist = distScene(p);\n      p += ray.dir * dist.dist * s;\n       \n      if(dist.dist < MIN_DISTANCE) {\n        \n           d = dist.dist;\n           id = dist.id;\n           iter = i;\n           \n           break;\n           \n      }\n        \n   }\n    \n   return Hit(p,d,id,iter); \n    \n}\n\nfloat lighting(vec3 pos, vec3 normal) {\n \n    const float epsilon = 0.01;\n    vec3 l = light1 - pos;\n    \n    Ray shadowRay = Ray(pos + (l * epsilon),l);\n    Hit shadow = trace(shadowRay);\n    \n    if(shadow.id < 0) {\n     \n        float diffuse = dot(normalize(l),normal);\n        return ambient + max(diffuse * (1. - ambient),0.);\n        \n    }\n    \n\treturn ambient;\n    \n}\n\nfloat specular(vec3 pos, vec3 normal, Ray ray, float shininess) {\n \n    const float epsilon = 0.01;\n    \n    vec3 l = light1 - pos;\n    \n    Ray shadowRay = Ray(pos + (l * epsilon),l);\n    Hit shadow = trace(shadowRay);\n    \n    if(shadow.id < 0) {\n    \n        vec3 r = reflect(ray.dir,normal);\n    \treturn pow(max(dot(normalize(r),normalize(l)),0.),shininess);\n        \n    }\n    \n    return 0.;\n    \n}\n\nvec4 shadeSphere(Hit sphere, vec3 normal, Ray ray) {\n \n    vec3 color = vec3(1.,0.,0.);\n    color *= lighting(sphere.p, normal);\n    \n    vec3 spec = vec3(1.,1.,1.);\n    spec *= specular(sphere.p,normal,ray,20.);\n    color += spec;\n    \n    return vec4(color.xyz,1.);\n    \n}\n\nvec4 shadePlane(Hit plane, vec3 norm, Ray ray) {\n    \n    float scale = 1.;\n    float u = plane.p.x;\n    float v = plane.p.z;\n    \n    u = mod(u * scale, 1.);\n    v = mod(v * scale, 1.);\n    \n    vec3 color = texture(iChannel0,vec2(u,v)).xyz;\n    \n    if((u > .5 || v > .5) && !(u > .5 && v > .5)) {\n     \n        color /= 2.;\n        \n    }\n    \n    vec3 ref = reflect(ray.dir,norm);\n    Ray rr = Ray(plane.p + 0.001,ref);\n    \n    Hit scene = trace(rr);\n    vec3 n = calcNormal(scene.p);\n    vec3 rc = (scene.id == 0 ? shadeSphere(scene,n,ray) : texture(iChannel1,rr.dir)).xyz;\n    \n    color = mix(color,rc,.5);\n    color *= lighting(plane.p,norm);\n    \n    return vec4(color.xyz,1.);\n    \n}\n\nvec4 shade(Ray ray) {\n \n    Hit scene = trace(ray);\n    vec3 n = calcNormal(scene.p);\n    \n    if(scene.id == 0) {\n     \n        return shadeSphere(scene,n,ray);\n        \n    } else if(scene.id == 1) {\n        \n        return shadePlane(scene,n,ray);\n        \n    }\n    \n    return texture(iChannel1,ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    \n    vec3 pos = vec3(0.,0.,-3.);\n    vec3 dir = normalize(vec3(uv.x,uv.y,1.));\n    \n \tRay ray = Ray(pos,dir);\n\tfragColor = shade(ray);\n}","name":"Image","description":"","type":"image"}]}