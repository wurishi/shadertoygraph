{"ver":"0.1","info":{"id":"mtVSWy","date":"1686336985","viewed":125,"name":"Raymarching scene","username":"DrElectry","description":"Have fun!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 1.0;\nconst float MAX_STEPS = 256.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.001;\n\nconst float PI = 3.14159265;\nconst float TAU = (2.*PI);\n\n// functions lol\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\nfloat fDisplace(vec3 p) {\n    pR(p.yz, sin(2.0 * iTime));\n    return (sin(p.x + 4.0 * iTime) * sin(p.y + sin(2.0 * iTime)) * sin(p.z + 6.0 * iTime));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat sgn(float x) {\n    float r = (x<0.)?-1.:1.;\n\treturn r;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1:1, (v.y<0.)?-1:1);\n}\n\nvec2 fOpUnionStairsID(vec2 res1, vec2 res2, float r, float n) {\n    float dist = fOpUnionStairs(res1.x, res2.x, r, n);\n    return (res1.x < res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\nvec2 fOpUnionChamferID(vec2 res1, vec2 res2, float r) {\n    float dist = fOpUnionChamfer(res1.x, res2.x, r);\n    return (res1.x < res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.0)/((n-1.)*2.+sqrt(2.0));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.0)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.0) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// scene\n\nvec2 fOpUnionID(vec2 res1, vec2 res2) {\n    return (res1.x < res2.x) ? res1 : res2;\n}\n\nvec2 fOpDifferenceID(vec2 res1, vec2 res2) {\n    return (res1.x > -res2.x) ? res1 : vec2(-res2.x, res2.y);\n}\n\nvec2 fOpDifferenceColumnsID(vec2 res1, vec2 res2, float r, float n) {\n    float dist = fOpDifferenceColumns(res1.x, res2.x, r, n);\n    return (res1.x > -res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\nvec2 map(vec3 p) {\n\n    // plane\n    \n    float planeDist = fPlane(p, vec3(0, 1, 0), 14.0);\n    float planeID = 2.0;\n    vec2 plane = vec2(planeDist, planeID);\n    \n    // sphere\n    \n    float sphereDist = fSphere(p, 9.0 + fDisplace(p));\n    float sphereID = 1.0;\n    vec2 sphere = vec2(sphereDist, sphereID);\n    \n    // manipulation operators\n    \n    pMirrorOctant(p.xz, vec2(50, 50));\n    p.x = -abs(p.x) + 20.0;\n    pMod1(p.z, 15.0);\n    \n    // roof\n    \n    vec3 pr = p;\n    pr.y -= 15.5;\n    pR(pr.xy, 0.6);\n    pr.x -= 18.0;\n    float roofDist = fBox2(pr.xy, vec2(20, 0.3));\n    float roofID = 4.0;\n    vec2 roof = vec2(roofDist, roofID);\n    \n    // box\n    \n    float boxDist = fBox(p, vec3(3, 9, 4));\n    float boxID = 3.0;\n    vec2 box = vec2(boxDist, boxID);\n    \n    // cylinder\n    \n    vec3 pc = p;\n    pc.y -= 9.0;\n    float cylDist = fCylinder(pc.yxz, 4.0, 3.0);\n    float cylID = 3.0;\n    vec2 cyl = vec2(cylDist, cylID);\n    \n    // wall\n    \n    float wallDist = fBox2(p.xy, vec2(1, 15));\n    float wallID = 3.0;\n    vec2 wall = vec2(wallDist, wallID);\n    \n    // result\n    \n    vec2 res;\n//    res = wall;\n    res = fOpUnionID(box, cyl);\n    res = fOpDifferenceColumnsID(wall, res, 0.6, 3.0);\n    res = fOpUnionChamferID(res, roof, 0.9);\n    res = fOpUnionStairsID(res, plane, 4.0, 5.0);\n    res = fOpUnionID(res, sphere);\n  \n  return res;\n}\n\n// casting rays\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    vec2 hit, object;\n    for (float i = 0.0; i < MAX_STEPS; i++) {\n        vec3 p = ro + object.x * rd;\n        hit = map(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n// lighting\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color) {\n    vec3 lightPos = vec3(20.0, 40.0, -30.0);\n    vec3 L = normalize(lightPos - p);\n    vec3 N = getNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n    \n    vec3 specColor = vec3(0.5);\n    vec3 specular = specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = color * 0.05;\n    vec3 fresnel = 0.25 * color * pow(1.0 + dot(rd, N), 3.0);\n    \n    // shadows\n    float d = rayMarch(p + N * 0.02, normalize(lightPos)).x;\n    if (d < length(lightPos - p)) return ambient + fresnel;\n    \n    return diffuse + ambient + specular + fresnel;\n}\n\n// adding colors\n\nvec3 getMaterial(vec3 p, float id) {\n    vec3 m;\n    switch (int(id)) {\n       case 1:\n       m = vec3(0.9, 0.0, 0.0); break;\n       case 2:\n       m = vec3(0.2 + 0.4 * mod(floor(p.x) + floor(p.z), 2.0)); break;\n       case 3:\n       m = vec3(0.7, 0.8, 0.9); break;\n       case 4:\n       vec2 i = step(fract(0.5 * p.xz), vec2(1.0 / 10.0));\n       m = ((1.0 - i.x) * (1.0 - i.y)) * vec3(0.37, 0.12, 0.0); break;\n    }\n    return m;\n}\n\n// camera\n\nmat3 getCam(vec3 ro, vec3 lookAt) {\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0, 1, 0), camF));\n    vec3 camU = cross(camF, camR);\n    return mat3(camR, camU, camF);\n}\n\n// mouse\nvoid mouseControl(inout vec3 ro) {\n    float x = iMouse.x / iResolution.x;\n    pR(ro.xz, x * TAU);\n}\n\n// rendering\n\nvoid render(inout vec3 col, in vec2 uv) {\n    vec3 ro = vec3(3.0, 25.0, -30.0);\n    mouseControl(ro);\n    vec3 lookAt = vec3(0, 0, 0);\n    vec3 rd = getCam(ro, lookAt) * normalize(vec3(uv, FOV));\n    \n    vec2 object = rayMarch(ro, rd);\n    \n    vec3 background = vec3(0.5, 0.8, 0.9);\n    if (object.x < MAX_DIST) {\n        vec3 p = ro + object.x * rd;\n        vec3 material = getMaterial(p, object.y);\n        col += getLight(p, rd, material);\n        // fog\n        col = mix(col, background, 1.0 - exp(-0.0001 * object.x * object.x));\n    } else {\n        col += background - max(0.95 * rd.y, 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col;\n    \n    render(col, uv);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}