{"ver":"0.1","info":{"id":"4l2Sz1","date":"1441691438","viewed":186,"name":"Sceneradio @ Wappuradio, live","username":"Exca","description":"Coding live for 2 hours @ wappuradio.fi radio broadcast.\nEdit: Live coding ended.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sceneradio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Union\nfloat un(float d1, float d2)\n{\n \treturn min(d1, d2);   \n}\n\n//Subctract\nfloat sub(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat sphere(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n//More shapes\nfloat box(vec3 p, vec3 c)\n{\n \treturn length(max(abs(p)-c, 0.));   \n}\n\n//Smoothing function by iq.\n//Great source for computer graphics: https://iquilezles.org/\nfloat smin(float a, float b, float k)\n{\n \tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nfloat repSphere(vec3 p, vec3 c, float r)\n{\n \tvec3 q = mod(p,c)-0.5*c;\n    return sphere(q, r);\n}\n\nfloat repBox(vec3 p, vec3 c, vec3 b)\n{\n \tvec3 q = mod(p,c)-0.5*c;\n    return box(q, b);\n}\n\n\n//Next up, move the camera by some random sine waves\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n    uv = uv*2.-1.;\n    \n    vec3 eye = vec3(sin(iTime*0.1)*30., sin(iTime*0.4)*20., 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = vec3(1., 0., 0.);\n    vec3 forward = cross(right, up);\n    \n    float rx = iTime*0.1;\n    float ry = iTime*0.05;\n    float rz = iTime*0.2;\n    mat3 rotX = mat3(1., 0., 0.,\n                     0., cos(rx), -sin(rx),\n                     0., sin(rx), cos(rx));\n    mat3 rotY = mat3(cos(ry), 0., sin(ry),\n                     0., 1., 0.,\n                     -sin(ry), 0, cos(ry));\n    mat3 rotZ = mat3(cos(rz), -sin(rz), 0.,\n                     sin(rz), cos(rz), 0,\n                     0., 0., 1.);\n    \n    const int maxSteps = 60;\n    \n    vec3 ro = eye;\n    float focal = 2.;\n    vec3 rd = normalize(forward * focal + right*uv.x + up*uv.y);\n    rd = rotX * rd;\n    \n    float t = 0.;\n    vec3 color = vec3(0.);\n    float epsilon = 0.05;\n    float beat = mod( iTime*0.4, 1.6)*9.;\n    for(int i = 0; i < maxSteps; i++)\n    {\n     \tvec3 p = ro + t*rd;\n        float dSphere = repSphere(p-vec3(0.,.0,iTime), vec3(5., 5., 5.), 0.5);\n        float dSphere2 = repSphere(p-vec3(sin(iTime*0.2)*10.,0.,20.), vec3(5., 5., 5.), 0.5+beat);\n        \n        float dBox = repBox(p, vec3(7., 7, 5.), vec3(.5, .5, 0.1));\n        \n        dBox = un(dBox, dSphere);\n        //float minsum = smin(dSphere, dSphere2, 0.1);\n         \n        // this might be abit epileptic now ;)\n        if(t>.2) \n        {\n            if(dBox < epsilon)\n            {\n                //Coder colors ftw :) swapping to distance based gradient.\n                \n                //Let's make the colors be a distance based plasma instead of sine.\n/*                float r1 = sin(0.13*t*(iTime*.03));\n                float r2 = cos(0.15*t+iTime*.5);//*(p.y+p.y+iTime*.02));\n                float g1 = sin(0.11*t + iTime);//*(p.y+p.y+iTime*.03));\n                float g2 = cos(0.5*t);//*(p.x-iTime*.07));\n                \n                float b1 = sin(0.01/t+iTime);//*(p.y+p.y+iTime*.3));\n                float b2 = cos(0.05/t+iTime);//*(p.x-iTime*.7));\n                \n                float r = min(1., max(r1*r2,.0));\n                float g = min(1.,max(g1*g2, 0.));\n                float b = min(1.,max(b1*b2,0.));\n  */              \n            \t//color = vec3(r,g,b) + vec3(.3, .3, .3); \n                vec3 pal = palette((t+p.x)/20., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n                color = pal*0.2+ vec3(1.-t/50.);\n            }\n            if(dSphere < epsilon)\n            {\n                vec3 pal = 0.3* palette((t+p.x)/20., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n                color =pal* vec3(max(0.,1.- .5*sin(t*73.)));\n            }\n            if(dSphere2 <  epsilon)\n            {\n             //   color -= vec3(max(0.,1.-t/80.));   \n            }\n        }\n        float min = min(dSphere, dBox);//, dBox);\n        t+=min;\n    }\n    color = max(vec3(0., 0., 0.), color);\n    //Fog!\n    color +=palette(uv.y/1.+uv.x*.3, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30))*min(t,140.)/140.;\n    \n    color += beat <0.4 ? 0.2*beat : 0.;\n     \n\tfragColor =vec4( color,1.);\n} ","name":"","description":"","type":"image"}]}