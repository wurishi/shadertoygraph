{"ver":"0.1","info":{"id":"3sycDG","date":"1603565722","viewed":67,"name":"Mr Mandel","username":"emedan","description":"Everybody makes their own Mandelbrot.\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  . Repeated calculations of the value is made at each point.\n  . If the value at a point is > 4, then the point is not part of the set.\n  . Only so many repeated caclulations for one point can be done, so stop after\n      a pre defined maximum amount.\n  . It's most common to color by the nbr of iterations it took to determine\n      that a point was outside the set.\n  . Coloring is 99% of the code, there are many other ways. Distance functions. \n*/\n\n\nvec2 squareComplex(vec2 z) {\n\treturn vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    ///////////////////////////////////////////////////\n    // Zoom\n    float time = 5.0;\n    time = iTime;\n    \n    //time = iMouse.x/iResolution.x*40.0;\t//\t\t\t\t<---- UNCOMMENT TO MOVE ZOOM WITH MOUSE\n    \n    float span = 2.0 * pow(0.8, min(time, 40.0));\n    vec2 center = vec2(-1.0122, 0.3110);\n    \n    uv *= span;\n\tuv += center;\n    ///////////////////////////////////////////////////\n    \n    int maxIter = 20 + int(pow(time, 3.0));\t\t//\t\t\t\t<---- PLAY WITH THIS\n    //maxIter = 1000;\n    float lenSq;\n    \n    // Determine for each pixel\n\tvec2 z = uv;\n    int iter;\n    for (iter = 0; iter < maxIter; iter++) {\n        // Do not check inside the circle at -1, 0\n        float a = uv.x + 1.0;\n        float b = uv.y;\n        if (a*a+b*b < 0.0625) break;\n        //////////////////////////////////////////\n        \n        // Calculate next z\n\t\tz = squareComplex(z) + uv;\n        \n        // Exit if not part of the set\n        lenSq = z.x*z.x + z.y*z.y;\n        if (lenSq >= 4.0) break;  \n    }\n    \n    \n    \n    vec3 col;\n\n    // Bands with color ramps between them.\n    float nbrBands = 5.0;\n    vec3 bc0 = vec3(1, 8, 124)/255.0;\t\t// Blue\n    vec3 bc1 = vec3(255, 199, 0)/255.0;\t\t// Gold\n    vec3 bc2 = vec3(255, 61, 127)/255.0;\t// Pink\n    vec3 bc3 = vec3(218, 216, 167)/255.0;\t// Light  gold\n    vec3 bc4 = vec3(127, 199, 175)/255.0;\t// Gr\n    \n    float bandSteps = 100.0;\t\t//\t\t\t\t\t\t<---- PLAY WITH THIS\n    float fiter = float(iter);\n    \n    float band = mod(fiter, bandSteps*nbrBands);\n    band = floor(band/bandSteps);\n    \n    vec3 c0, c1;\n    if      (band == 0.) {\n        c0 = bc0;\n        c1 = bc1;\n    }\n    else if (band == 1.) {\n        c0 = bc1;\n        c1 = bc2;\n    }\n    else if (band == 2.) {\n        c0 = bc2;\n        c1 = bc3;\n    }\n    else if (band == 3.) {\n        c0 = bc3;\n        c1 = bc4;\n    }\n    else if (band == 4.) {\n        c0 = bc4;\n        c1 = bc0;\n    }\n    \n    col = mix(c0, c1, mod(fiter, bandSteps)/bandSteps);    \n    \n    \n    // Color possible members at the time iteration stopped white.\n    //  The same as using iter == maxIter.\n    if (lenSq < 4.0) col = vec3(1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}