{"ver":"0.1","info":{"id":"ss2cRW","date":"1643219417","viewed":96,"name":"Billiard/Pool","username":"maurice","description":"Italian forgotten boccette biliard game. Move mouse to turn camera around the center.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*****\n *\n * Example on how to ray march. Italian forgotten boccette biliard game (pool).\n *\n *****/\n \n#define PI 3.1415\n#define _2PI PI * 2.0\nconst vec3 upDirection = vec3( 0.0, 1.0, 0.0 );\n\n/*\n * Envirornment color definitions and functions\n */\n \n// colors\nconst vec3 sunColor = vec3(2.0, 2.0, 0.5); // vec3( 0.8, 0.8, 0.2 );\n\nconst vec3 factoryColor = vec3( 0.0, 0.0, 0.0 );\nconst vec3 spotlightColor = vec3(2.0, 2.2, 2.0);\n\nconst vec4 evenSquareColor = vec4( 0.6, 0.5, 0.6, 1.0 );\nconst vec4 oddSquareColor = vec4( 0.7, 0.7, 0.7, 1.0 );\n\n// normals\nconst vec3 groundOrigin = vec3( 0.0 );  // plane origin\nconst vec3 groundNormal = upDirection;  // plane normal\n\n#define OBLIQUE_FLOOR\n\n/** Returns the ground color given a point on it.\n */\nvec4 ground( vec3 point )\n{\n    return mix( vec4( 0.0 ),\n        mix( evenSquareColor, oddSquareColor,\n#ifndef OBLIQUE_FLOOR\n            mod( floor( point.z ) + floor( point.x ), 2.0 )\n#else\n            smoothstep( -0.01, 0.01, sin( point.z * 2.5 ) - cos( point.x * 2.5 + 1.9 ) )\n#endif\n        ),\n        smoothstep( 32., 0., distance( point, groundOrigin ) )\n    );\n}\n\nvec3 lightDirection( float time )\n{\n    return normalize( vec3( sin(0.5), 3.2, cos(0.5) ));\n}\n\n/**Returns the color of the envirornment given a ray and time\n */\nvec3 background( vec3 ro, vec3 rd, float time )\n{    \n    vec3 light = lightDirection( time );\n    vec3 sunDirection = light;\n    \n    // sky/ceil factor: dot product with ray direction and up vector\n    float sky = pow( max( 0.0, dot( upDirection, rd ) ), 1.0 );\n    \n    // sun factor: dot product with ray direction and light direction\n    vec3 rrd = rd;\n    float light1 = max( 0.0, dot( rrd, sunDirection ) );\n    float light2 = max( 0.0, dot( rrd, normalize( sunDirection + vec3( 0.5, 0.0, 0.0 ) ) ) );\n    float light3 = max( 0.0, dot( rrd, normalize( sunDirection + vec3( -0.5, 0.0, 0.0 ) ) ) );\n    float lightHaze = 64.0; // max( 2.0, 0.0 + (cos(t) * 256.0 ) );\n    \n    return \n        pow( sky, 0.50 ) * factoryColor\n        + ( pow( light1, lightHaze ) + 0.2 * pow( light1, 2.0 ) ) * spotlightColor\n        + ( pow( light2, lightHaze ) + 0.2 * pow( light1, 2.0 ) ) * spotlightColor\n        + ( pow( light3, lightHaze ) + 0.2 * pow( light1, 2.0 ) ) * spotlightColor\n        ;\n}\n\n/*\n * SDF functions\n */\n \nfloat sdfSphere( vec3 p, vec3 c, float r )\n{\n    return length( c - p ) - r;\n}\n\nfloat sdfBox( vec3 p, vec3 c, vec3 r )\n{\n    return length( max( abs( c - p  ) - r, 0.0 ) );\n}\n\n/*\n * SDF composition functions\n */\n\nfloat sdUnion( float a, float b, in vec4 newColor, inout vec4 color )\n{\n    color = mix( color, newColor, step( 0.0, a - b ) );\n    return min( a, b );\n}\n\nfloat sdSubtract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat sdIntersect(float d1, float d2){\n    return max(d1, d2);\n}\n\n/* Scene definitions\n *\n */\nconst vec2 poolSize = vec2( 5.0, 2.5 );\nconst vec4 poolColor = vec4( 0.4, 0.1, 0.0, 1.0 );\nconst float poolBorder = 0.35;\nconst float poolInnBorder = 0.45;\nconst float poolRoundness = 0.2;\nconst float poolDepthY = 0.075;\n\nconst float ballRadius = 0.2;\nconst float ballBoccinoDeltaRadius = - 0.05;\nconst vec4 ballRed = vec4( 0.6, 0.2, 0.25, 0.75 )*1.20;\nconst vec4 ballBlue = vec4( 0.0, 0.1, 0.7, 1.25 );\nconst vec4 ballWhite = vec4( 1.5, 1.5, 1.5, 0.5 );\nconst vec4 ballYellow = vec4( 1.1, 0.95, 0.65, 0.35 )*1.40;\n\nconst float holeSize = 0.25;\n\n#define MORE_BALLS\n\nfloat map( vec3 p, out vec4 color )\n{\n    float bgFloor = p.y;\n    color = ground( p );\n    \n    // wood\n    vec3 poolP = vec3( abs( p.x ), p.y, abs( p.z ) - p.y * 0.1 );\n    float box = sdfBox( poolP, vec3( 0., 1.0, 0. ), vec3( poolSize.x, 1.0, poolSize.y) ) - poolRoundness;\n    float f = sdUnion( bgFloor, box, poolColor, color );\n    \n    // green carpet\n    box = sdfBox( poolP, vec3( 0., 1.0, 0. ), vec3( poolSize.x - poolBorder, 1.0, poolSize.y - poolBorder ) ) - poolRoundness;\n    f = sdUnion( f, box, vec4( 0.0, 0.25, 0.0, 0.0 ), color );\n    \n    f = sdSubtract( f, sdfBox( poolP, vec3( 0., 2.0, 0. ), \n        vec3( poolSize.x - poolBorder - poolInnBorder, poolDepthY, poolSize.y - poolBorder -poolInnBorder ) ) - poolRoundness );\n    \n    // holes\n    poolP = vec3( mod( poolP.x, poolSize.x - poolBorder - poolInnBorder ), poolP.y, poolP.z );\n    f = sdSubtract( f, sdfSphere( poolP,\n        vec3( 0.0, 2.0, poolSize.y - poolBorder -poolInnBorder*0.5 ), holeSize ) - poolRoundness );\n        \n    \n    // balls\n    float ballY = 2. - poolRoundness * 1. + ballRadius - poolDepthY * 1.;\n    f = sdUnion( f, sdfSphere( p, vec3(3., ballY, -1.), ballRadius ), ballRed, color );\n    f = sdUnion( f, sdfSphere( p, vec3(3.2, ballY + ballBoccinoDeltaRadius, -0.3), ballRadius + ballBoccinoDeltaRadius ), ballBlue, color );\n    \n    f = sdUnion( f, sdfSphere( p, vec3(2.1, ballY, -0.2), ballRadius ), ballWhite, color );\n    f = sdUnion( f, sdfSphere( p, vec3(2.3, ballY, 0.2), ballRadius ), ballYellow, color );  \n\n#ifdef MORE_BALLS\n    f = sdUnion( f, sdfSphere( p, vec3(-3., ballY, 1.), ballRadius ), ballRed, color );\n    f = sdUnion( f, sdfSphere( p, vec3(-0.1, ballY, 0.3), ballRadius ), ballRed, color );\n    \n    f = sdUnion( f, sdfSphere( p, vec3(4.1, ballY, -1.03), ballRadius ), ballWhite, color );\n    f = sdUnion( f, sdfSphere( p, vec3(-4.1, ballY, -0.15), ballRadius ), ballWhite, color );\n      \n    f = sdUnion( f, sdfSphere( p, vec3(3.3, ballY, 0.12), ballRadius ), ballYellow, color );    \n    f = sdUnion( f, sdfSphere( p, vec3(4.0, ballY, -0.5), ballRadius ), ballYellow, color );  \n    f = sdUnion( f, sdfSphere( p, vec3(-2.9, ballY, -0.75), ballRadius ), ballYellow, color );\n#endif\n    \n    \n    return f;\n}\n\n/*\n * Ray march functions\n */\n#define INITIAL_STEP 0.01\n#define NORMAL_EPSILON 0.0001\n\n#define MAX_STEPS 1000\n#define MAX_DIST 64.\n#define SURF_EPSILON 0.0001\n\nvec3 sdfNormal( vec3 p )\n{\n    vec4 c;\n    return normalize( vec3(\n        map( vec3( p.x + NORMAL_EPSILON, p.y, p.z ), c ) - map( vec3( p.x - NORMAL_EPSILON, p.y, p.z ), c ),\n        map( vec3( p.x, p.y + NORMAL_EPSILON, p.z ), c ) - map( vec3( p.x, p.y - NORMAL_EPSILON, p.z ), c ),\n        map( vec3( p.x, p.y, p.z + NORMAL_EPSILON ), c ) - map( vec3( p.x, p.y, p.z - NORMAL_EPSILON ), c )\n    ) );\n}\n\nfloat rayMarch( vec3 ro, vec3 rd, float time, inout vec4 color )\n{\n    float dist = 0.;\n    float d = INITIAL_STEP;\n    vec3 p = ro;\n    \n    for( int i = 0; i < MAX_STEPS; i++ )\n    {\n        p = ro + rd * d;\n        dist = map( p, color );\n        d += dist;\n        if(d > MAX_DIST || dist < SURF_EPSILON){\n            break;\n        }\n    }\n    \n    return d;\n}\n\nvec3 scene( vec3 ro, vec3 rd, float time )\n{\n    vec4 color;\n    float d = rayMarch( ro, rd, time, color );\n    \n    // finds the point that hit some scene object\n    vec3 p = ro + rd * d;\n    \n    // calculates point normal\n    vec3 normal = sdfNormal( p );\n    vec3 lightDir = lightDirection( time );\n    \n    // looks for shadow\n    vec4 shadowdColor = vec4( 0.0 );\n    float shadowMap = rayMarch( p + lightDir * 0.1, lightDir, time, shadowdColor );\n    \n    // looks for reflection\n    vec4 reflectedColor;\n    vec3 reflecionDir = reflect( rd, normal );\n    float refl = rayMarch( p + reflecionDir * 0.1, reflecionDir, time, reflectedColor );\n    reflectedColor = mix( reflectedColor, \n        vec4(1.) + vec4( background( p + reflecionDir * 0.1, reflecionDir, time ), 0. ), \n        step(MAX_DIST, refl ) );\n    \n    \n    float diffuseLight = 0.5;\n    return mix( background( ro, rd, time ), \n            color.rgb * mix( vec3(1.0),\n                sqrt( reflectedColor.rgb ) * color.w, // multiplies with reflected color if material has reflectiveness\n                color.w )  // reflectiveness\n            * (min( ( dot( lightDir, normal ) ) + diffuseLight, 1.0 ) ) \n            * (step( MAX_DIST, shadowMap )*0.7 ), \n        (1.0 - step( MAX_DIST, d ) ) );\n}\n\n/*\n * View, rays and camera definitions\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    // ray direction with some movment determined by mouse\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n    \n    // rotates the camera around x-axis to look a bit down\n    float lookDownAngle = -0.4;\n    rd.yz = mat2( \n        cos( lookDownAngle ), -sin( lookDownAngle ),\n        sin( lookDownAngle ), cos( lookDownAngle ) ) * rd.yz;\n    \n    // rotates the camera around the origin\n    float angle = (iMouse.z > 0.0 ? iMouse.x / iResolution.x : iTime * .05) * _2PI + 0.6;\n    vec2 cameraDirection = mat2( \n        cos( angle ), -sin( angle ),\n        sin( angle ), cos( angle ) ) * rd.xz;\n        \n    rd = normalize( vec3( cameraDirection.x, rd.y-.01, cameraDirection.y ) );\n    \n    // ray origin\n    vec2 cameraOrigin = vec2( -sin( angle ), -cos( angle ) ) * 5.0;\n    vec3 ro = vec3( cameraOrigin.x, 3.0, cameraOrigin.y );\n    \n    vec3 outColor = scene( ro, rd, iTime ).rgb;\n    \n    fragColor = vec4(outColor,1.0);\n}","name":"Image","description":"","type":"image"}]}