{"ver":"0.1","info":{"id":"3dX3zn","date":"1544648709","viewed":420,"name":"FBM Toy","username":"CyanSprite","description":"Glitch, static, cloud/water like things","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float speed = 2.0;\nfloat brightness = 1.7;\n\nfloat rand(in vec2 p, float speed)\n{\n    float t = speed > 0.0 ? floor(iTime * speed) : 1.0;\n    return fract(\n        sin(\n            dot(p, vec2(t * 67.0, t * 76.0))\n        ) * 67.76\n    );\n}\n\nfloat noise(in vec2 uv, float block)\n{   \n    vec2 fr = fract(uv);\n    vec2 op = floor(uv);\n\n    // here you don't have to add vec2(0,0) but... consistency\n    float a = rand(op+vec2(0,0), block);\n    float b = rand(op+vec2(1,0), block);\n    float c = rand(op+vec2(0,1), block);\n    float d = rand(op+vec2(1,1), block);\n\n\t// u = step(block, lv);\n    // you can use step above if you want complete blockiness.\n    vec2 u;\n    if ( block > 0.0 )\n        u = smoothstep(0.0, 1.0 + block, fr);\n    else\n        u = fr * fr * (3.0 - 2.0 * fr);\n\n    // just mix a bunch of values up.\n   return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 uv, int octaves, float block)\n{\n    // In this case just how narrow do you want the glitch lines.\n    float lacunarity = 10.0;\n    \n    // how much increase in amplitude each octave\n    float gain = 0.5;\n\n    // our ending value, and amplitude\n    float v = 0.0;\n    float amp = 0.5;\n\n    // loop for octaves\n    for ( int i = 0; i < octaves; i++ ) \n    {\n    \tv += amp * noise(uv, block);\n        amp *= gain;\n        uv *= lacunarity;    \n    }\n    \n    return v;\n}\n\nvec4 glitch(in vec2 uv, vec2 uv2)\n{\n    const float amp = 0.2;\n    const float block = 10.0;\n    const float reducer = 9.0;\n    const int octaves = 4;\n    \n    float shift = amp * pow(\n        fbm(uv2,\n            octaves,\n            block\n        ),\n        reducer);\n    \n    float colR = texture(iChannel0, vec2(uv.x - shift, uv.y)).r * (1. - shift);\n    float colG = texture(iChannel0, vec2(uv.x + shift, uv.y)).g * (1. - shift);\n    float colB = texture(iChannel0, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n    \n    vec3 f = vec3(colR, colG, colB);\n    //f = vec3(noise(uv, glitchBlockiness));\n    \n    return vec4(f, 1.);\n}\n\nfloat getTime() { return iTime * 0.5 * speed; }\n\nfloat fbm2(in vec2 uv, int octaves)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(22.0);\n    \n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    \n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(uv, -2.0);\n        uv = rot * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n// Noise inception\nvec4 smoke(vec2 uv2, int octaves)\n{\n    vec3 color = vec3(0.0);\n\tvec2 q = vec2(0.);\n\tvec2 r = vec2(0.);\n    \n    // first fbm vec\n    q.x = fbm2(uv2 + 0.01 * getTime() * vec2(0.10), octaves);\n    q.y = fbm2(uv2 + 0.1 * getTime() * vec2(-0.50) , octaves);\n\n    // 2nd fbm vec + 1 fbm vec\n    r.x = fbm2(uv2 + 2.1*q + vec2(0.0, 1.0) * 0.1*sin(getTime()), octaves);\n    r.y = fbm2(uv2 + 3.0*q + vec2(1.0, 0.0) * 0.1*sin(getTime()), octaves);\n\n    // float of an 2nd fbm vec containing 1st fbm vec\n    float f = fbm2(uv2+r, octaves);\n\n    vec3 c1 = vec3(1.0, 0.2, 0.4);\n    vec3 c2 = vec3(0.0, 0.0, 0.3);\n    vec3 c3 = vec3(0.0, 0.5, 0.45);\n    vec3 c4 = vec3(0.4, 0.4, 0.4);\n\n    color = mix(c2,\n                c1,\n                clamp((f*f),0.0,1.0));\n\n    color = mix(color,\n                c3,\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                c4,\n                clamp(length(r.x),0.0,1.0));\n\n    return vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / iResolution.x, exp(a.y));\n    \n    fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    // fragColor = glitch(uv, uv2);\n    \n    fragColor = fragColor + smoke(uv*2.5, 3) * brightness;\n    \n    fragColor = 2.0 * brightness * smoke(uv*2.5, 5) - fragColor;\n    \n    fragColor = fragColor - smoke(uv *2.5, 10) * vec4(0.05, 0.15, 0.35, 1.0) * brightness * brightness;\n    fragColor = fragColor * vec4(sin(iTime * .001), cos(iTime * .01), 1.0, 1.0);\n    fragColor = fragColor * vec4(1.5, 1.5, 1.5, 1.0);\n}","name":"Image","description":"","type":"image"}]}