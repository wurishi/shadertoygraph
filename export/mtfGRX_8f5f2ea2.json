{"ver":"0.1","info":{"id":"mtfGRX","date":"1672212338","viewed":94,"name":"3D Sine Wave","username":"mattwilson720","description":"Uses an iterative approach to ray-march a sinusoidal surface.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","waves","raycasting","sine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Matthew K. Wilson\n\n#define PI 3.14159265\n#define MAX_ITER 50\n\n// Define the camera\nvec3 camPosition = vec3(0,8,0);\nvec3 lookAtP = vec3(5,2,5);\nvec3 vup = vec3(0,1,0);\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat sdf(vec3 p) {\n    return p.y - 0.5 * sin((p.x + iTime));\n}\n\nvec3 calcNormal(vec3 poi) {\n    float px = cos(poi.x + iTime);\n    float py = -1.0;\n    float pz = 0.0;\n    return normalize(vec3(px,py,pz));\n}\n\nvec3 calcColor(vec3 pos) {\n    const vec3 lightDir = vec3(0.0,-1.0,0.0);\n\n    vec3 N = calcNormal(pos);\n    vec3 L = normalize(lightDir);\n    float i = max(dot(N,L), 0.0);\n\n    float height = (pos.y + 1.0) / 2.0;\n\n    return vec3(1.0, 0.7, 0.2)*i*height;\n}\n\nvec3 march(Ray ray) {\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n    \n    float dist = sdf(o);\n    int it = 0;\n    float step = 1.0;\n    \n    while(abs(dist) > 0.01 && it < MAX_ITER) {\n       o += d*step;\n       dist = sdf(o);\n       \n       if (dist * step < 0.0) {\n           step /= -2.0;\n       }\n       it++;\n    }\n    \n    if(abs(dist) <= 0.01) {\n        return calcColor(o);\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\n// creates ray in world coordinates\nRay createRay(vec2 uv) {\n    vec3 k = normalize(camPosition - lookAtP);\n    vec3 i = normalize(cross(vup, k));\n    vec3 j = cross(k, i);\n    mat4 Mcam = mat4(vec4(i,0.0), vec4(j,0.0), vec4(k,0.0), vec4(camPosition, 1.0));\n\n    // Define the view frustum\n    float aspect = 16.0/9.0;\n    float n = 5.0;\n    float f = 10.0;\n\n    float r = 3.0;\n    float l = -r;\n\n    float b = l/aspect;\n    float t = r/aspect;\n\n    float x = uv.x * (2.0*r) - r;\n    float y = uv.y * (2.0*t) - t;\n    float z = -n;\n    vec4 position = Mcam * vec4(x,y,z,1.0);\n    vec3 direction = normalize(position.xyz - camPosition);  \n    return Ray(camPosition, direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    Ray ray = createRay(uv);\n    vec3 color = march(ray);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}