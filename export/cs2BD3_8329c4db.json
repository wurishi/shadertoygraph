{"ver":"0.1","info":{"id":"cs2BD3","date":"1690215330","viewed":199,"name":"PerfTest Uni, Bi, TriPlanar","username":"gehtsiegarnixan","description":"Simple performance Test for Tri-, Bi-, and Uni-planar mapping to see who is fastest. This repeats the function n times with different values to tank your fps, so you can see which is fastest.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["test","triplanar","dither","cubemap","performance","performance","interpolation","biplanar","uniplanar"],"hasliked":0,"parentid":"mdSfRw","parentname":"PerfTest Cubemapping"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis performance test aims to compare planar mapping implementations. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 900 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = uniplanarIf using dithered deriviative Mips ~ 133 fps\n// 1 = uniplanarIf using deriviative Mips ~ 127 fps\n// 2 = uniplanarIf (use linear texture) ~ 130 fps\n// 3 = uniplanarLerp (use linear texture) ~ 127 fps\n// 4 = Biplanar  ~ 32 fps\n// 5 = Triplanar ~ 92 fps\n#define TEST 1\n\n// shows the blend area\n//#define SHOWBLEND\n#define LINETHICKNESS 0.05\n\n// 1 for no contrast, higher values for more contrast\n#define CONTRAST 16.0 \n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfDitheredMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast)\n{    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n        duvdx = duvwdx.yz; // how is this thing allowed?\n        duvdy = duvwdy.yz;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        uv = uvZ;\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }\n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    float lineThickness = 0.05; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast)\n{    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n    if (alpha.x>alpha.y && alpha.x>alpha.z) {\n        duvdx = duvwdx.yz;\n        duvdy = duvwdy.yz;\n    } else if (alpha.y>alpha.z) {\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }  \n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIf( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast)\n{    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarLerp( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast)\n{\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    //apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = step(0., alpha.y + xDitherPart);\n    float xDither = step(0., xDitherPart);\n    vec3 ditherAlpha = vec3(xDither, yDitherPart - xDither, 1.0 - yDitherPart);\n    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // interpolate (since we use bitmasks it is allowed for UVs)\n    vec2 uv = uvX * ditherAlpha.x + uvY * ditherAlpha.y + uvZ * ditherAlpha.z;\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Biplanar mapping implementation (https://www.shadertoy.com/view/ws3Bzf)\n// The MIT License\n// Copyright © 2020 Inigo Quilez\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // contrast\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // transition control\n    m = pow( m, vec2(k/8.0) );\n    m = m / (m.x + m.y);\n    \n    // interpolate\n\tvec4 col = x*m.x + y*m.y;\n    \n    #ifdef SHOWBLEND\n    vec2 mask = step(abs(m - 0.1), vec2(LINETHICKNESS));\n    return vec4(max(mask, col.xy), col.zw);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Triplanar mapping implementation (https://www.shadertoy.com/view/MtsGWH)\n// The MIT License\n// Copyright © 2015 Inigo Quilez\nvec4 triplanar( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and contrast\n    vec3 m = pow( abs(n), vec3(k) );\n    m = m / (m.x + m.y + m.z);\n    \n    // interpolate\n    vec4 col = (x*m.x + y*m.y + z*m.z);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(m - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 dir = sphereNormals(uv);\n\n    // if you get around 144 fps use a higher repeat value\n    vec4 test;\n    for(int i=0; i<REPEAT; i++) {\n        float mut = (float(i)/float(REPEAT)); // permutation each iteration\n            \n        // use which ever you wish to test\n        #if TEST == 0\n            test += uniplanarIfDitheredMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 1\n            test += uniplanarIfMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 2\n            test += uniplanarIf(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 3\n            test += uniplanarLerp(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 4\n            test += biplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #else\n            test += triplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #endif\n    }\n\n    // Output to screen\n    fragColor = fract(test);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926536\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 sphereNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * PI;\n\tfloat phi   = uv.x * PI * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),\n                    cos(theta), \n                    sinTheta * cos(phi));\n    return dir;\n}\n\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n","name":"Common","description":"","type":"common"}]}