{"ver":"0.1","info":{"id":"mdjXWy","date":"1670853692","viewed":78,"name":"sphere with light","username":"lambwww","description":"sphere，使用了SDF的思想，用视线到球体表面的距离进行一系列判断。因为使用的是平行光，所以平移球体光照依然是不变的，所以就改变一下光线的位置","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct sphere{vec3 center;float radius;};\nstruct ray{vec3 start;vec3 dir;};\nvec3 ambient()\n{\n    float k=0.2;\n    vec3 ambCol=vec3(0.3,0.1,0.1);\n    return ambCol*k;\n}\nfloat diffuse(vec3 light,vec3 normal)\n{\n    float k=0.2;\n    float halfLamb=dot(light,normal)*0.5+0.5;\n    return halfLamb;\n}\n//原点在【0，0】，这里就是求p点到球心的距离减去球的半径，也就是p到球的最短距离\nfloat map(vec3 p){\n    vec3 center=vec3(0,0, 4); //这里代表球心的位置，我没有进行传参，所以手动赋值一下\n    return length(p-center)-1.0;\n}\n//利用曲面的梯度求法线，就是对xyz分量求偏导\nvec3 GetNormal(vec3 p){\n    float d = map(p);\n    vec2 e = vec2(0.001,0.0);\n    float  fdx = d-map(p-e.xyy);\n    float fdy = d-map(p-e.yxy);\n    float fdz = d-map(p-e.yyx);\n    return normalize(vec3(fdx,fdy,fdz));\n}\n//求光线到球表面的距离，使用光线无限接近\nfloat rayMatch(vec3 rayS,vec3 rayD)\n{\n    float d=0.;\n    for(int i=0;i<100;i++)\n    {\n        vec3 p=rayS+rayD*d;\n        float tempD=map(p);\n        if(tempD<=0.001 || tempD>=40.) //太近代表找到了，太远代表看不见\n            break;\n        d+=tempD;\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv初始化\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //生成视线\n    ray viewRay;\n    viewRay.start=vec3(0,0,-3);\n    viewRay.dir=normalize(vec3(uv,1));//光线向量，要限制在【0，1】中间\n    //生成球体，这里主要是球体的简单信息\n    sphere mys;\n    mys.center=vec3(0, 0, 4);\n    mys.radius=1.;\n    //求眼睛到球体的距离，如果在距离内代表可以被看见，就进行着色\n    float temp=rayMatch(viewRay.start,viewRay.dir);\n    if(temp<=40.)\n    {\n        //光线起点到球表面的最小距离\n        float d=rayMatch(viewRay.start,viewRay.dir);\n        //球表面的点\n        vec3 p=viewRay.start+viewRay.dir*d;\n        //表面那个点对应的法线\n        vec3 normal = GetNormal(p);\n        //生成光线\n        ray light;\n        light.start=vec3(0,10.*sin(iTime),-5);\n        light.dir=normalize(light.start-p);\n        //diffuse\n        float diffuse = dot(normal,light.dir);\n        vec3 color = vec3(1,1,1);\n        color=diffuse*color+ambient(); //加上了环境光\n        \n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n        fragColor = vec4(0.3, 0.1, 0.1, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}