{"ver":"0.1","info":{"id":"cdGfzR","date":"1697816678","viewed":110,"name":"Even-odd and Non-zero fill rules","username":"Envy24","description":"Can anyone recommend vector graphics books?\nLMB down -> even-odd rule,\nLMB up     -> non-zero rule.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fill","zero","shape","odd","even","non","collection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.2 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat pathSDF(vec2 NDC)\n{\n    if (iMouse.z > 0.)\n        return pathSDF_arrow(NDC);\n    return pathSDF_segment(NDC);\n}\n\n/* \n    Source: https://www.youtube.com/watch?v=33KqDTwdR08\n    Non-zero fill rule. \n*/\nint is_inside_shape_nonzero(vec2 P)\n{\n    int winding = 0;\n\n    for (int p = 0; p < path_lenght; ++p)\n    {      \n        int pn = (p + 1) % path_lenght;\n    \n        float x1 = path[p].x,  y1 = path[p].y,\n              x2 = path[pn].x, y2 = path[pn].y,\n              ratio = (P.y - y1) / (y2 - y1);\n        \n        // Ray intersects with segment?\n        if ( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) )\n        {\n            // Segment goes down?\n            if (y1 > y2)\n                winding += 1;\n            else\n                winding -= 1;\n        }\n    }\n     \n    return int(winding != 0);\n}\n\n/*\n    My implementation.\n    Even-Odd fill rule.\n*\nint is_inside_shape_evenodd(vec2 P)\n{\n    int parity = 0;\n    vec2 uv = vec2(-1);\n    vec2 inf_p = P - vec2(100,0);\n    \n    for (int p = 0; p < path_lenght - 1; ++p)\n    {        \n        uv = segment_segment_intersection(inf_p, P, path[p], path[p + 1]);\n        parity += int( (uv.x >= 0. && uv.x <= 1.) && (uv.y >= 0. && uv.y <= 1.) );\n    }\n    uv = segment_segment_intersection(inf_p, P, path[path_lenght - 1], path[0]);\n    parity += int( (uv.x >= 0. && uv.x <= 1.) && (uv.y >= 0. && uv.y <= 1.) );\n      \n    return int( (parity & 1) == 1 );\n}\n\n/*\n    Even-Odd fill rule.\n    Source: https://www.youtube.com/watch?v=RSXM9bgqxJM\n*/\nint is_inside_shape_evenodd(vec2 P)\n{\n    int cnt = 0;\n\n    for (int p = 0; p < path_lenght; ++p)\n    {        \n        int pn = (p + 1) % path_lenght;\n        float x1 = path[p].x,  y1 = path[p].y,\n              x2 = path[pn].x, y2 = path[pn].y,\n              ratio = (P.y - y1) / (y2 - y1);\n        \n        cnt += int( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) );\n    }\n      \n    return cnt&1;\n}\n\n/*\n    https://www.shadertoy.com/view/DsyfRh (mla)\n*\nint polywind(vec2 p, vec2 q, vec2 r) {\n  // Numerical Recipes winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.x <= 0.0) {\n    if (r.x > 0.0 && t > 0.0) return 1;\n  } else {\n    if (r.x <= 0.0 && t < 0.0) return -1;\n  }\n  return 0;\n}\n\nint is_inside_shape_evenodd(vec2 P)\n{\n    int parity = 0;\n    for (int p = 0; p < path_lenght; ++p)\n    {        \n      parity += polywind(P,path[p],path[(p+1)%path_lenght]);\n    }\n    return int( (parity & 1) == 1 );\n}\n/**/\n\nint is_inside_shape(vec2 P)\n{\n    if (iMouse.z > 0.)\n        return is_inside_shape_nonzero(P);\n    return is_inside_shape_evenodd(P);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //init_path();\n    randomize(iTime*.2);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    float min_d = 9e5;\n    vec3 color = is_inside_shape( NDC ) == 0 ? vec3(1) : vec3(1,0,0);\n    /* Path. */\n    min_d = pathSDF(NDC);\n    color = mix( color, vec3(0), SMAA(min_d) );\n    /* Blue ray. */\n    min_d = segmentSDF( NDC, MP, -vec2(100,0), 0. ) + 0.004;\n    color = mix( color, vec3(0,0,1), SMAA( min_d ));\n    /* Circle sample. */\n    min_d = circleSDF( NDC, MP, 0.014 );\n    vec3 circle_col = is_inside_shape( MP ) == 1 ? vec3(0,1,0) : vec3(0);\n    color = mix( color, circle_col, SMAA( min_d ));\n    /**/\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n// Points exactly at point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.05, //      U--\n         U = C + up  * 0.020,  // B----C----E\n         D = C - up  * 0.020;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.05 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float a = P1.x - P0.x,\n          b = P3.x - P2.x,\n          \n          c = P1.y - P0.y,\n          d = P3.y - P2.y,\n          \n          e = P2.x - P0.x,\n          f = P2.y - P0.y; \n    return vec2(\n        (e*d-b*f)/(a*d-b*c),    // t for P0 -> P1 segment\n        (c*e-a*f)/(a*d-c*b) );  // t for P2 -> P3 segment\n}\n\nconst int path_lenght = 32;\nvec2 path[path_lenght];\nvoid init_path()\n{\n    path[0] = vec2(-1, -1.0);\n    path[1] = vec2(-1, 1);\n    path[2] = vec2(1, 1.0);\n    path[3] = vec2(1, -1);\n}\nfloat pathSDF_segment(vec2 NDC)\n{\n    float min_d = 9e5;\n    for (int p = 0; p < path_lenght - 1; ++p)\n    {\n        min_d = min( min_d, segmentSDF(NDC, path[p], path[p + 1], 0.) );\n    }\n    min_d = min( min_d, segmentSDF(NDC, path[path_lenght - 1], path[0], 0.) );\n    \n    return min_d;\n}\nfloat pathSDF_arrow(vec2 NDC)\n{\n    float min_d = 9e5;\n    for (int p = 0; p < path_lenght - 1; ++p)\n    {\n        min_d = min( min_d, arrowSDF(NDC, path[p], path[p + 1], 0.) );\n    }\n    min_d = min( min_d, arrowSDF(NDC, path[path_lenght - 1], path[0], 0.) );\n    \n    return min_d;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 h2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seed source values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < path_lenght; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = 1.2*h2to2(x, y);\n        vec2 n = 1.2*h2to2(x + 1u, y + 2u);\n    \n        path[k] = c * (1. - t) + n * t;\n    }\n}","name":"Common","description":"","type":"common"}]}