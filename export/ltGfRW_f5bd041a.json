{"ver":"0.1","info":{"id":"ltGfRW","date":"1542037480","viewed":1003,"name":"Yet another Disco 2","username":"denosya","description":"Trying randoms things...","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MARBLE_RADIUS  = 0.1075;\nconst float MARBLE_SPACING = 0.5;\n\n\n\nfloat map(in vec3 m, out vec3 normal) {\n    \n    float angle = iTime*0.15;\n    float c = cos(angle);\n    float s = sin(angle);        \n    \n    mat3 sphereMat = mat3(vec3(c, 0.0, s),\n                          vec3(0.0, 1.0, 0.0),\n                          vec3(-s, 0.0, c));\n    \n    vec3 center = vec3(0, 0, -2.5 + cos(iTime*0.5)*1.5 );\n    float radius = 4.0;\n    \n    vec3 v = m - center;\n    \n    v = sphereMat * v;\n    \n    float distToCenter = length(v) - radius;\n    \n    vec3 marbleCenter = floor((v + MARBLE_SPACING*0.5) / MARBLE_SPACING) * MARBLE_SPACING;\n\n    if(length(marbleCenter) > radius - MARBLE_RADIUS*0.5) {\n        return max(distToCenter, MARBLE_SPACING * 0.5);\n    }\n    else {\n        float d = length(v - marbleCenter);\n        normal = normalize(v - marbleCenter);\n        \n        if(d<0.0) return MARBLE_SPACING * 0.75;\n        return d - MARBLE_RADIUS;\n    }\n}\n\n\n\nvec2 getUV(in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv -= vec2(0.5, 0.5);    \n    uv.x *= ratio;\n    return uv;\n}\n\n\nfloat raymarch(in vec3 dir, out vec3 m, out vec3 normal) {\n    \n    float mattercrossed = 0.0;\n    \n    for(int i=0; i<100; i++) {\n\t\tfloat d = map(m, normal);        \n \n        if(d > -0.05 && d < 0.05) {\n            mattercrossed += 1.0;\n        }        \n        \n        d = max(d, 0.01);\n        \n        m += dir * d * 0.5;\n    }\n    \n    return mattercrossed;\n}\n\nvec4 lighting(float matter, vec3 m, in vec3 normal) {\n    \n    vec4 color = vec4(cos(m.x), cos(m.y), cos(m.z), 1.0);\n    \n    \n    return color * matter * 0.02;\n}\n\nbool isdot(vec3 m) {\n \t\n    vec3 closest = mod(m, vec3(0.1, 0.1, 0.1));\n\n    float d = length(closest);\n    \n    return d < 0.05;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = getUV(fragCoord);\n\tvec3 dir = normalize(vec3(uv.x, uv.y, -1));\n\n    vec3  m = vec3(0);//cos(iTime*1.0)*1.0, cos(iTime*0.5)*2.5, 0.0);\n    vec3  normal;\n\n    float matter = raymarch(dir, m, normal);\n    \n    if(matter>0.0000000) {\n        \tfragColor = lighting(matter, m, normal);\n    }\n    else {\n\t    fragColor = vec4(0);    \n    }\n}\n","name":"Image","description":"","type":"image"}]}