{"ver":"0.1","info":{"id":"4dVcWW","date":"1523846849","viewed":149,"name":"Complex Transform ","username":"lucastakejame","description":"Just trying some complex operations on uv plane","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["complexnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// complex number multiplication \nvec2 zMult(vec2 a, vec2 b)\n{\n\treturn mat2(a, -a.y, a.x)*b;\t    \n}\n\nvec2 zDiv(vec2 a, vec2 b)\n{\n    return a * mat2(b,-b.y,b.x) / dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // mouse coordinate scaled and translated by uv factor\n \tvec2 scaledMouse = (iMouse.xy/iResolution.xy);\n    \t\n    float ratio = iResolution.x/iResolution.y;\n    float factor = .4;\n    \n    // scaling uv plane\n    vec2 scaledUV  = vec2(mapToRange(uv.x, factor*-ratio, factor*ratio),\n                          mapToRange(uv.y, -factor, factor));\n    \n    vec2 zz = zMult(scaledUV, scaledUV);\n    vec2 uvtransform = zDiv(vec2(.5, 1.5)- .1*vec2(cos(1.3*iTime), sin(2.*iTime)) - zz, vec2(1.35, 1.) + zz);\n    //vec2 uvtransform = zDiv(vec2(1.6, 0.) - scaledUV, vec2(1., 0.) + scaledUV);\n    \n    \n    fragColor = vec4(texture(iChannel1, uvtransform , 1.));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\n// converts HSL (vec3(hue, saturation, lightness) ) to RGB\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// SuperFormula radius\nfloat r(float theta, float a, float b, float m, float n1, float n2, float n3)\n{\n    return pow(  \n                pow(abs(cos(m*theta/4.)/ a), n2) +\n                pow(abs(sin(m*theta/4.)/ b), n3)\n        , -1./n1);\n}\n\n// TRANSFORMS\n\n// get value in interval [a, b] (similar to mod, but works with negative) \nfloat modExpanded( float x, float a, float b)\n{       \n   \treturn a + mod(x-a, b-a);\n}\n\n// expects value in [0, 1] and transforms in to [a, b]\n// values outside [0,1] will be scaled accordingly\nfloat mapToRange(float value,  float a, float b)\n{\n    return value*(b - a) + a;\n}\n\nfloat tileCoordinate( float coord, float tilling, vec2 window, float offset, out float index) \n{   \n    // Zoom\n    float value = coord*tilling + offset;\n    \n    // Set tile index\n    index = floor((value - window.x)/(window.y - window.x));\n    \n    // Chop in to windows\n    value = modExpanded(value, window.x, window.y);\n    \n    return value;\n}\n\n// transforms original UV\nvec2 uvTransform(vec2 coord, vec2 resolution, vec2 tilling, vec2 offset, inout vec2 index)\n{   \n    vec2 result ;\n    \n    // screen ratio\n    float ratio = resolution.x/resolution.y;\n    \t\n    // This will normalize (0 to 1) (based on Y AXIS, x will be bigger on most screens)\n    // x -> [0 , ratio]\n    // y -> [0 , 1]\n    result = coord/resolution.xy;\n    \n    // remaps coordinates to fit these intervals\n    result.x = mapToRange(result.x, -ratio, ratio);\n    result.y = mapToRange(result.y, -1., 1.);\n\n    result.x = tileCoordinate( result.x, tilling.x, 2.*vec2(-1., 1.), offset.x, index.x);\n    result.y = tileCoordinate( result.y, tilling.y, 2.*vec2(-1., 1.), offset.y, index.y);\n  \n    return result;\n}\n\n// INTERVAL CHECKS\n\n// Checks if angle is in interval (a, b) considering the plane discontinuity\n// assumption: the angle interval is going from a to b counter clockwise\nbool isInAngleInterval(float angle, float a, float b)\n{\n    bool result = false;\n    \n    angle = mod(angle, 2.*M_PI);\n    a = mod(a, 2.*M_PI);\n    b = mod(b, 2.*M_PI); \n    \n    // b passed 2pi and became mod(b , 2pi)\n    if( b < a)\n    {\n        if(angle > a)\n        {\n            if(a <= angle && angle <= b + 2.*M_PI)\n            {\n                result = true;\n            }\n        }\n        else\n        {\n            if(a - 2.*M_PI <= angle && angle <= b)\n            {\n                result = true;\n            }\n        }\n    }\n    else if (a == b)\n    {\n        result = (angle == a);\n    }\n    else\n    {\n        if(a <= angle && angle <= b)\n        {\n            result = true;\n        }\n    }\n    \n    \n    return result;\n}\n\n// checks if num is in close interval [a,b]\nbool isInInterval(float num, float a, float b)\n{\n    return (a <= num && num <= b);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // transformed mouse cordinates\n    vec2 mouseUV = iMouse.xy*2./iResolution.y - vec2(iResolution.x/iResolution.y, 1.);\n    \n    vec2 tileIndex;\n    \n    // transformed UV coordinates\n    vec2 uv = uvTransform(fragCoord, iResolution.xy, vec2(6.), vec2(iTime, 0.), tileIndex);\n    \n    // SuperFormula inputs\n    float a = 1.;\n    float b = 1.;\n    float m = 12.;\n    float n1 = 1. + 1.5*mouseUV.y;\n    float n2 = 2.0 + 1.1*sin(iTime);\n    float n3 = 1.0; \n\n    // Angle Rotation\n    float rotation = (mod((tileIndex.x + tileIndex.y),2.) == 0.)? 1.*iTime: -2.*iTime;\n\n    // Superformula angle parameter AND current pixel angle\n    float SFtheta = modExpanded(atan( uv.y, uv.x), 0., 2.*M_PI) + rotation;\n    \n    // current pixel radius\n    float pixRadius = distance(uv, vec2(0.,0.));\n    float pixRadius2 = 1.1*distance(uv, vec2(0.,0.));\n\n\n    // receives superformula's Radius coordinate of the point to this set of parameters\n    float SFradius = r(SFtheta,  a,  b,  m,  n1,  n2,  n3);\n\n    // stroke \n    float thickness = 0.01;\n\n    // change offset of color radial repetition\n    float colorOffset = iTime;\n\n    if(isInInterval(pixRadius, SFradius - thickness, pixRadius))\n    {\n        vec3 hsl = hsl2rgb(vec3(\n            mod((pixRadius - SFradius)/5. + 0.1*colorOffset, 1.),\n            1.,\n            0.5\n        ));\n        vec3 hslFromNeighbor = hsl2rgb(vec3(\n            mod((pixRadius2 - SFradius)/5. + 0.1*colorOffset, 1.),\n            1.,\n            0.5\n        ));\n        // interpolation to get smoother edges\n        float p = ((pixRadius2 - SFradius)/SFradius < 1.1) ?\n            \t1.:\n        \t\tmin((pixRadius2 - SFradius)/SFradius - 1.1, 1.);\n        fragColor = p*vec4(hsl, p) + (1. - p)*vec4(hslFromNeighbor, 1.-p);       \n    }\n    else\n    {\n        vec3 hsl = \n            (mod((tileIndex.x + tileIndex.y),2.) == 0.)?\n            hsl2rgb(vec3(\n            mod(pixRadius - SFradius - colorOffset*.1, .5*mouseUV.x),\n            1.0,\n            0.5)):\n        \thsl2rgb(vec3(\n            mod(pixRadius - SFradius - colorOffset*1.5, .2*mouseUV.x),\n            1.,\n            .5));\n        fragColor = vec4(hsl,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}