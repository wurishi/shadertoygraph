{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n * # Implicit Clean Union Test\n *\n * ```\n * Author:  Paul Kanyuk   \n * ```\n *\n * Based off SÃ©bastien Pierre's sphere example.  This is a test of the \"clean union\" implicit\n * blending operator described in \n * \n * PASKO, A., ADZHIEV, V., SOURIN, A., AND SAVCHENKO, V. 1995. Function\n * representation in geometric modeling: concepts, implementation and\n * applications. The Visual Computer 11, 8, 429â€“446.\n *\n * you can find that at: http://www.hyperfun.org/F-rep.pdf\n *\n * The main idea of the operator is that it's a union on the iso-surface,\n * but unlike a regular union (a min operator), the sdf is continuous outisde\n * the combined object.  This is important when using the sdf for effects like\n * a \"glow\" where want to avoid discontinuities.  You can test this out by mouse\n * dragging in this demo to see how to cleanUnion smooths out the sdf glow.\n *\n * Note, this was a test to help understand the work which went into the more\n * recent Siggraph Asia paper on implicit skinning which really pushes work\n * with implicits: http://rodolphe-vaillant.fr/permalinks/elastic_implicit_skinning_project.php\n *\n*/\n\n/**\n  * Distance field function for a sphere at [0,0,0] of radius `s`\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n/**\n  * Distance field function for an infinite cylinder at direction 'dir' of radius `s`\n*/\nfloat sdCylinder(vec3 p, float s, vec3 dir)\n{\n    vec3 q = p - (dot(p,dir)*dir);\n    float dist = length(q)-s;\n    return dist;\n}    \n\n/**\n  * Returns the clean union of inputs a and b\n*/\nvec2 fragCoord;\nfloat cleanUnion( float a, float b )\n{\n\tif( iMouse.z>0.0 && iMouse.x>fragCoord.x ) return min(a,b);\n\t\n\t\n    return ((a+b) - sqrt( pow(a,2.0) + pow(b, 2.0) ))/1.0;\n}\n\n/**\n  * Returns the distance to the closest object in the scene to the given point.\n*/\nfloat map( in vec3 p )\n{\n\tfloat xCyl =  sdCylinder(p, 0.25, vec3(1.0,0.0,0.0));\n    float yCyl =  sdCylinder(p, 0.25, vec3(0.0,1.0,0.0));\n    //return min(xCyl,yCyl);\n    return cleanUnion(xCyl,yCyl);\n    //return ((xCyl+yCyl) + sqrt( pow(xCyl,2.0) + pow(yCyl, 2.0) ))/5.0;\n    //return sdSphere(p,0.25);\n}\n\n\n/**\n  * Returns the distance on the ray with origin `ro` and delta `rd`\n  * to the closest object in the scene.\n*/\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 20.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = 1.0*map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\n/**\n  * Accumulates \"distance\" in direction rd from ro.  This is used for\n  * rendering \"glow\"\n*/\nfloat softIntersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 20.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    float total = 0.0;\n    float loops = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    h = map( ro+rd*t )/1.0;\n        t = t+0.1;\n        total = total+h;\n        loops = loops+1.0;\n    }\n    total = total/loops;\n\t\n    return total;\n}\n\n\n/**\n  * `pointlight` is the basic function to evaluate the effect of\n  * a light source at a given point. It takes the point position `pos`,\n  * the light position `lgt`, the light color `col` and the light\n  * `intensity`, and returns the corresponding color.\n  *\n  * Note that this does not do any shadow casting, so it does not take\n  * into account any object that might be between the light and the\n  * point.\n*/\nvec3 pointlight( in vec3 pos, in vec3 lgt, in vec3 col, float intensity ){\n    // We start by calculating the distance between the current point\n    // and the light source. As light's intensity decreases (ie. is\n    // attenuated according to distance), we need this as the primary\n    // value.\n    float distance    = length(lgt - pos);\n    // What we want to calculate next is how the intesity decreases with\n    // the distance. In that case, we use a quadratic attenuation, meaning\n    // that we divide the intensity by the distance^2.\n    float attenuation = intensity / (distance * distance);\n    // We return the corresponidng color.\n    vec3 color        = col * attenuation;\n    return color;\n}\n\n/**\n  * `lighting` creates three point lights, one red, one green and one blue\n  * and return the composite value. The blue light follows the mouse pointer.\n*/\nvec3 lighting( in vec3 pos ) {\n    // In order to make the lighting interesting, we'll make the lights revolve\n    // aroud the Y axis at different speeds. This will allow to show how the\n    // emitted light blends together. You can adjust the speed of the revolution\n    // by changing `s`. Set it to 0.0 to have the lights still.\n    float s  = 1.0;\n    float a1 = 0.0 * 3.1416 / 3.0 + s*0.5*iTime;\n    float a2 = 1.0 * 3.1416 / 3.0 + s*0.3*iTime;\n    float a3 = 1.0 * 3.1416 / 3.0 + s*0.1*iTime;\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    return pointlight(pos, vec3(r1 * cos(a1), 1.0, r1 * sin(a1)), vec3( 1.0, 0.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r2 * cos(a2), 1.0, r2 * sin(a2)), vec3( 0.0, 1.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r3 * cos(a3), 1.0, r3 * sin(a3)), vec3( 0.0, 0.0, 1.0), 2.0)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 iFragCoord )\n{\n    fragCoord = iFragCoord;\n    // `q` is the normalized position of the current shaded pixel\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    // `p` is positioned so that [0,0] is at the center of the screen\n    vec2 p = 2.0 * q - 1.0;\n    \n    // sets aspect ration to `p \n    p.x *= iResolution.x/iResolution.y;  \n    \n    // `ro` is the camera origin where the rays are cast\n\tvec3 ro = vec3(p.x, p.y, 2.0 );\n    \n    // `rd` is the ray delta, ie. it's normalized direction\n    vec3 rd = normalize( vec3(0.0,0.0,-1.0) );\n\t\n    // col is the color of the pixel, black by default.\n\tvec3 col = vec3(0.0);\n\n    // `t` will hold the distance to the intersection with the scene\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        // `pos` is the point found by interesect, ie. the point of \n        // where the ray interseted the scene.\n        vec3 pos = ro + t*rd;\n        // We call the basic `lighting` function to see the point lights\n        // in action.\n        col  = lighting(pos);\n    }\n\t// We assign the color we've just computed.\n    \n    // Mix in a red glow\n    float glow = softIntersect(ro,rd)*1.0;\n    if( iMouse.z>0.0 && iMouse.x>fragCoord.x ) glow = glow * 0.67;\n    glow = pow(glow,3.0);\n    glow = clamp(glow,0.0,1.0);\n    vec3 col2 = glow*vec3(1.0,0.0,0.0) + (1.0-glow)*col;\n    fragColor = vec4( col2, 1.0 );\n}\n\n// EOF","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tsGz7","date":"1420249450","viewed":302,"name":"Clean Union Blend","username":"OttoVonBismarck","description":"Not very pretty, but this tests how the \"clean union\" implicit blend works.  This was described in an old Siggraph Paper (see comments) and is a way of keeping an SDF continuous after a union, which is useful for glow effects. Mouse drag to toggle.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["implicitcleanunion"],"hasliked":0,"parentid":"","parentname":""}}