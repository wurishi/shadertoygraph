{"ver":"0.1","info":{"id":"WlyyDw","date":"1611171462","viewed":48,"name":"Caméra","username":"Akanoa","description":"Une caméra dans un monde en 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["camra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.desmos.com/calculator/t1iqt8tj9z?lang=fr\n\n#define MIN_DISTANCE   0.001\n#define MAX_DISTANCE   20.\n#define MAX_ITERATIONS 200\n\n\n#define MATERIAL_SPHERE1   1  \n#define MATERIAL_SPHERE2  2\n#define MATERIAL_GROUND 3\n\n\n#define PI 3.14159\n#define DEG2RAD 0.01745329251\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n/**\n* m : index du matériau à appliquer\n* d : distance à la surface observée\n*/\nstruct Data {\n    float d;\n    int m;\n};\n\n\n/**\n* Calcul la distance signée en entre le point p et la surface de la sphère\n* p : point courant calculé par rapport à la sphère\n* r : rayon de la sphère\n* m : matériau à appliquer sur la surface de la sphère\n*/\nData sdSphere(vec3 p, float r, int m) {\n    return Data(length(p) - r, m);\n}\n\n/**\n* Calcule la distance signée entre le point p et la surface du plan de hauteur h\n* p : point courant calculé par rapport à la sphère\n* h : hauteur du plan par rapport à l'origine du monde\n* m : matériau à appliquer sur la surface du plan\n*/\nData sdPlanH(vec3 p, float h, int m) {\n    return Data(p.y - h, m);\n}\n\nData sdBox(vec3 p, vec3 b, int m) {\n    vec3 q = abs(p) - b;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    return Data(d, m);\n}\n\nData sdTorus(vec3 p, vec2 t, int m) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Data(d, m);\n}\n\n\n\nData sdCylinder( vec3 p, float h, float r, int m)\n{\n  vec2 q = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  return Data(d, m);\n}\n\n\nData minData(Data d1, Data d2) {\n    \n    if(d1.d < d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData maxData(Data d1, Data d2) {\n    \n    if(d1.d > d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData minusData(Data d) {\n    return Data(-d.d, d.m);\n}\n\nData scene(vec3 p) {\n\n    vec3 cp1 = p - vec3(0,0,0);\n    cp1.xy *= Rot(90.0*DEG2RAD);\n    \n    Data c1 = sdCylinder(cp1, 0.35, 1.5, MATERIAL_SPHERE2);\n    \n    \n    vec3 cp2 = p - vec3(0,0,0);\n    Data c2 = sdCylinder(cp2, 0.35, 1.5, MATERIAL_SPHERE2);\n    \n    \n    vec3 cp3 = p - vec3(0,0,0);\n    cp3.yz *= Rot(90.0*DEG2RAD);\n    \n    Data c3 = sdCylinder(cp3, 0.35, 1.5, MATERIAL_SPHERE2);\n\n  \n    Data pl = sdPlanH(p, -1., MATERIAL_GROUND);\n    \n    \n    \n    Data s1 = sdSphere(p, 1.41421356237, MATERIAL_SPHERE2);  \n    \n    vec3 bp1 = p - vec3(0, 0.0, 0);\n    Data b1 = sdBox(bp1, vec3(1.0), MATERIAL_SPHERE1);\n    \n    \n\n    Data cr = minData(c1, c2);\n    cr = minData(cr, c3);\n    \n    \n    \n    //s = minData(b1, pl);\n    // Data s = minData(cr, b1);\n    \n    Data s = maxData(b1, s1);\n    s = maxData(minusData(cr), s);\n    \n    s = minData(s, pl);\n    \n    \n    return s;\n}\n\nData rayMarch(vec3 rO, vec3 rD) {\n    \n    float d = 0.0;\n    int m = 0;\n    for(int i=0; i < MAX_ITERATIONS; i++) {\n        \n        vec3 p =  rO + rD * d;\n        Data ds =  scene(p);\n        d += ds.d;\n        m = ds.m;\n        if (ds.d < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    \n    return Data(d, m);\n\n}\n\n\nvec3 material(int index) {\n\n    vec3 col = vec3(0);\n\n    switch(index) {\n        case MATERIAL_SPHERE1:\n            col = vec3(0.8, 1.1, 5);\n            break;\n        case MATERIAL_SPHERE2:\n            col = vec3(1.0, 0.2, 0.3);\n            break;\n        case MATERIAL_GROUND:\n            col = vec3(1.0, 1.0, 0);\n        default:\n            break;\n    }\n    \n    return col * 0.2;\n        \n}\n\nvec3 normal(vec3 p) {\n    float dp = scene(p).d;\n    \n    float eps = 0.01;\n    \n    float dx = scene(p + vec3(eps, 0, 0)).d - dp;\n    float dy = scene(p + vec3(0, eps, 0)).d - dp;\n    float dz = scene(p + vec3(0, 0, eps)).d - dp;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat lighting(vec3 p, vec3 n, vec3 lp) {\n    \n    vec3 ld = lp - p;\n    vec3 ln = normalize(ld);\n    \n    float d = rayMarch(p + n * 0.01, ln).d;\n    \n    if (d < length(ld)) return 0.0;\n    \n    return max(0.0, dot(ln, n));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5* iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    \n    float k = 4.5;\n    float t = 0.1;\n    vec3 lp = abs(vec3(cos(iTime*t)*k, 2.0, sin(iTime*t)*k));\n    \n    \n    //vec3 camera = vec3(0, mouse.y, 0);\n    //vec3 screen = vec3(uv, 1.0);\n    \n    float phi = -DEG2RAD * -60.0;\n    float fov = 1.0;\n    float r = 4.0;\n    \n    vec3 eye = vec3(\n        cos(2.0 * PI * mouse.x + phi) * r,\n        mouse.y * 10., \n        sin(2.0 * PI * mouse.x + phi)* r\n    );\n    \n    \n    \n    vec3 target = vec3(0,0,0);\n    \n    // base vectorielle\n    vec3 forward = normalize(target-eye) ;\n    vec3 side = cross(vec3(0,1,0), forward);\n    vec3 up = cross(forward, side);\n    \n    vec3 screenPos = eye + fov*forward + uv.x * side + uv.y * up;\n    \n    vec3 rD = normalize(screenPos - eye);\n    \n    Data data =  rayMarch(eye, rD);\n    \n    // ciel\n    vec3 skyColDark = vec3(0.08, 0.3, 1.0);\n    vec3 skyColLight = vec3(0.5, 0.8, 1.0);\n    \n    vec3 col = mix(skyColLight, skyColDark, pow(uv.y + 0.5, 1.5));\n    \n    if(data.d < MAX_DISTANCE) {\n    \n       vec3 p = eye + rD * data.d;\n       vec3 n = normal(p);\n       float l = lighting(p, n, lp);\n       \n       vec3 m = material(data.m);\n       \n       col = m * l;\n       \n       vec3 ambiant = vec3(5, 0, 10) * 0.07;\n       vec3 ambiantSky = n.y * skyColLight;\n           \n       col = col * ( ambiant + ambiantSky + l);\n       \n    }\n    \n    // gamma \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}