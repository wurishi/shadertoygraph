{"ver":"0.1","info":{"id":"fdySDD","date":"1634629408","viewed":274,"name":"20210930_CLUB-CAVE-09 [Denoise]","username":"spawner64","description":"Initial toy by @0b5vr: \"20210930_CLUB-CAVE-09\", who won a well deserved Shader of The Week for a lot of weeks.\n\nAs usual, added few serial EMA IIR filters with Variance Clipping to slightly denoise the output. It's smudgy, but less noisy.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","filter","pathtracer","livecoding","denoise","iir","temporal","taa","varianceclipping","ema"],"hasliked":0,"parentid":"ss3SD8","parentname":"20210930_CLUB-CAVE-09"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    \n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = texture(iChannel0, uv);\n    } else {\n        fragColor = texture(iChannel3, uv);\n    }\n    \n    \n    vec2 p=uv*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    \n    //fragColor.rgb *= 0.01;\n    //fragColor.rgb = pow(fragColor.rgb, vec3(4.0));\n    \n    fragColor.rgb=pow(fragColor.rgb/20.0,vec3(.4545));\n    fragColor.rgb*=1.0-0.4*length(p);\n    fragColor.rgb=vec3(\n      smoothstep(.1,.9,fragColor.rgb.x),\n      smoothstep(.0,1.0,fragColor.rgb.y),\n      smoothstep(-.1,1.1,fragColor.rgb.z)\n    );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fs(i) (fract(sin((i)*114.514)*1919.810))\n#define lofi(i,j) (floor((i)/(j))*(j))\n\nconst float PI=acos(-1.);\n\n// CAVE 09\n// ENTER THE CAVE\n//\n// DJ: Pinieon\n\nfloat time;\nfloat seed;\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.999?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nfloat random(){\n  seed++;\n  return fs(seed);\n}\n\nvec3 uniformLambert(vec3 n){\n  float p=PI*2.*random();\n  float cost=sqrt(random());\n  float sint=sqrt(1.0-cost*cost);\n  return orthBas(n)*vec3(cos(p)*sint,sin(p)*sint,cost);\n}\n\nvec4 tbox(vec3 ro,vec3 rd,vec3 s){\n  vec3 or=ro/rd;\n  vec3 pl=abs(s/rd);\n  vec3 f=-or-pl;\n  vec3 b=-or+pl;\n  float fl=max(f.x,max(f.y,f.z));\n  float bl=min(b.x,min(b.y,b.z));\n  if(bl<fl||fl<0.){return vec4(1E2);}\n  vec3 n=-sign(rd)*step(f.yzx,f.xyz)*step(f.zxy,f.xyz);\n  return vec4(n,fl);\n}\n\nstruct QTR {\n  vec3 cell;\n  vec3 pos;\n  float len;\n  float size;\n  bool hole;\n};\n\nbool isHole(vec3 p){\n  if(abs(p.x)<.5&&abs(p.y)<.5){return true;}\n  float dice=fs(dot(p,vec3(-2,-5,7)));\n  if(dice<.3){return true;}\n  return false;\n}\n\nQTR qt(vec3 ro,vec3 rd){\n  vec3 haha=lofi(ro+rd*1E-2,.5);\n  float ha=fs(dot(haha,vec3(6,2,0)));\n  ha=smoothstep(-0.2,0.2,sin(0.5*time+PI*2.*(ha-.5)));\n  \n  ro.z+=ha;\n  \n  QTR r;\n  r.size=1.;\n  for(int i=0;i<4;i++){\n    r.size/=2.;\n    r.cell=lofi(ro+rd*1E-2*r.size,r.size)+r.size/2.;\n    if(isHole(r.cell)){break;}\n    float dice=fs(dot(r.cell,vec3(5,6,7)));\n    if(dice>r.size){break;}\n  }\n  \n  vec3 or=(ro-r.cell)/rd;\n  vec3 pl=abs(r.size/2./rd);\n  vec3 b=-or+pl;\n  r.len=min(b.x,min(b.y,b.z));\n  \n  r.pos=r.cell-vec3(0,0,ha);\n  r.hole=isHole(r.cell);\n  \n  return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  time=iTime;\n  \n  seed=texture(iChannel0,p * vec2(time)).x;\n  seed+=fract(time);\n\n  float haha=time*62.0/60.0;\n  float haha2=floor(haha)-.2*exp(-fract(haha));\n\n  p=r2d(time*.2+.2*floor(haha))*p;\n  \n  vec3 ro0=vec3(0,0,1);\n  ro0.z-=haha2;\n  ro0+=.02*vec3(sin(time*1.36),sin(time*1.78),0);\n\n  vec3 rd0=normalize(vec3(p,-1.));\n  \n  vec3 ro=ro0;\n  vec3 rd=rd0;\n  vec3 fp=ro+rd*2.;\n  ro+=vec3(0.04*vec2(random(),random())*mat2(1,1,-1,1),0);\n  rd=normalize(fp-ro);\n  \n  float rl=.01;\n  vec3 rp=ro+rd*rl;\n  \n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1);\n  float samples=1.;\n\n  for(int i=0;i<200;i++){\n    QTR qtr=qt(rp,rd);\n    \n    vec4 isect;\n    if(qtr.hole){\n      isect=vec4(1E2);\n    }else{\n      float size=qtr.size*.5;\n      size-=.01;\n      size-=.02*(.5+.5*sin(5.0*time+15.0*qtr.cell.z));\n      isect=tbox(rp-qtr.pos,rd,vec3(size));\n    }\n\n    if(isect.w<1E2){\n      float fog=exp(-.2*rl);\n      colRem*=fog;\n      \n      rl+=isect.w;\n      rp=ro+rd*rl;\n      \n      vec3 mtl=fs(cross(qtr.cell,vec3(4,8,1)));\n\n      vec3 n=isect.xyz;\n      \n      if(mtl.x<.1){\n        col+=colRem*vec3(10,1,1);\n        colRem*=0.;\n      }else if(mtl.x<.2){\n        col+=colRem*vec3(6,8,11);\n        colRem*=0.;\n      }else{\n        colRem*=0.3;\n      }\n      \n      ro=ro+rd*rl;\n      rd=mix(uniformLambert(n),reflect(rd,n),pow(random(),.3));\n      rl=.01;\n    } else{\n      rl+=qtr.len;\n      rp=ro+rd*rl;\n    }\n    \n    if(colRem.x<.01){\n      ro=ro0;\n      rd=rd0;\n      vec3 fp=ro+rd*2.;\n      ro+=vec3(0.04*vec2(random(),random())*mat2(1,1,-1,1),0);\n      rd=normalize(fp-ro);\n      rl=.01;\n      rp=ro+rd*rl;\n      colRem=vec3(1);\n      samples++;\n    }\n  }\n  \n  /*\n  col=pow(col/samples,vec3(.4545));\n  col*=1.0-0.4*length(p);\n  col=vec3(\n    smoothstep(.1,.9,col.x),\n    smoothstep(.0,1.0,col.y),\n    smoothstep(-.1,1.1,col.z)\n  );\n  */\n  \n  \n  //col=mix(texture(iChannel1,uv).xyz,col,.5);\n  //\n  //fragColor = vec4(col,1);\n  \n  // Slightly modified for shadertoy: to make thumbnail not dimmed\n  //vec4 prev=texture(iChannel1,uv);\n  //fragColor = mix(vec4(col,1),prev,.5*prev.w);\n  \n  //col = pow(col, vec3(0.25));\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    /*\n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n    */\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n    history = clamp(history, colorMin, colorMax);\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EMA_IIR_INVERSE_CUTOFF_FREQUENCY        (0.75)      // 0.0 - 0.999\n#define VARIANCE_CLIPPING_COLOR_BOX_SIGMA       (0.98)      // 0.5 - 1.0\n#define SPLIT_SCREEN_SWEEP_SPEED                (1.5)\n\n#define SAMPLE_RGBA(sampler, coord) (texture((sampler), (coord)))\n#define SAMPLE_RGB(sampler, coord) (SAMPLE_RGBA((sampler), (coord)).rgb)\n\nfloat pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/4dSBDt\nvec3 RGBToYCoCg(vec3 RGB) {\n    float cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = dot(RGB, vec3( 1, 2,  1)) * 0.25;\n\tfloat Co = dot(RGB, vec3( 2, 0, -2)) * 0.25 + cTerm;\n\tfloat Cg = dot(RGB, vec3(-1, 2, -1)) * 0.25 + cTerm;\n\treturn vec3(Y, Co, Cg);\n}\n\n// https://www.shadertoy.com/view/4dSBDt\nvec3 YCoCgToRGB(vec3 YCoCg) {\n\tfloat cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = YCoCg.x;\n\tfloat Co = YCoCg.y - cTerm;\n\tfloat Cg = YCoCg.z - cTerm;\n\tfloat R  = Y + Co - Cg;\n\tfloat G  = Y + Cg;\n\tfloat B  = Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\n// based on https://www.shadertoy.com/view/4dSBDt\nvoid getVarianceClippingBounds(vec3 color, sampler2D colorSampler, ivec2 screenSpaceUV, float colorBoxSigma, out vec3 colorMin, out vec3 colorMax) {\n    vec3 colorAvg = color;\n    vec3 colorVar = color * color;\n\n    // Marco Salvi's Implementation (by Chris Wyman)\n    // unrolled loop version\n    \n    vec3 fetch = vec3(0);\n\n    // unwinded the for loop\n    {\n        // top\n        {\n            // left / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // center\n        {\n            // left / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            \n            // center / center is intentionally skipped\n            \n\n            // right / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // bottom\n        {\n            // left / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n    }\n\n    colorAvg *= 0.111111111;\n    colorVar *= 0.111111111;\n\n    vec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg * colorAvg));\n\tcolorMin = colorAvg - colorBoxSigma * sigma;\n\tcolorMax = colorAvg + colorBoxSigma * sigma;\n}\n\nvec4 renderVSplitLine(vec4 fragColor, vec3 lineColor, float lineThickness, vec2 screenSpaceUV, float splitScreenSpaceX) {\n    if (abs(screenSpaceUV.x - splitScreenSpaceX) < lineThickness) {\n        fragColor.rgb = lineColor;\n\t}\n\n    return fragColor;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    /*\n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n    */\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n    history = clamp(history, colorMin, colorMax);\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    /*\n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n    */\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n    history = clamp(history, colorMin, colorMax);\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}