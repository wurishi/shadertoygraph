{"ver":"0.1","info":{"id":"3sjXDm","date":"1554057905","viewed":1010,"name":"Raytracing Quadratic Bezier 3D","username":"bloxard","description":"Analytical solution for ray tracing 3D quadratic bezier curves.\nIntersection between a ray and a 3D quadratic bezier is calculated once, rather than calculating the distance between a point and a 3D quadratic bezier multiple times while stepping forward.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","bezier","intersection","analytical","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Per Bloksgaard, 2019 - https://perbloksgaard.dk\n// Analytical solution for ray tracing 3D quadratic bezier curves.\n// Intersection between a ray and a 3D quadratic bezier is calculated once, rather than calculating\n// the distance between a point and a 3D quadratic bezier multiple times while stepping forward.\n\n#define PI 3.14159265358979\n#define HALFPI 1.57079632679\n\nconst float thickness = 35e-3;\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q+4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z)-q)*0.5;\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// How to resolve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nvec3 intersectQuadraticBezier(vec3 p0, vec3 p1, vec3 p2) \n{\n\tvec2 A2 = p1.xy - p0.xy;\n\tvec2 B2 = p2.xy - p1.xy - A2;\n\tvec3 r = vec3(-3.*dot(A2,B2), dot(-p0.xy,B2)-2.*dot(A2,A2), dot(-p0.xy,A2)) / -dot(B2,B2);\n\tvec2 t = clamp(solveCubic2(r.x, r.y, r.z), 0., 1.);\n\tvec3 A3 = p1 - p0;\n\tvec3 B3 = p2 - p1 - A3;\n\tvec3 D3 = A3 * 2.;\n\tvec3 pos1 = (D3+B3*t.x)*t.x+p0;\n\tvec3 pos2 = (D3+B3*t.y)*t.y+p0;\n\tpos1.xy /= thickness;\n\tpos2.xy /= thickness;\n\tfloat pos1Len = length(pos1.xy);\n\tif (pos1Len>1.)\n\t{\n\t\tpos1 = vec3(1e8);\n\t}\n\tfloat pos2Len = length(pos2.xy);\n\tif (pos2Len>1.)\n\t{\n\t\tpos2 = vec3(1e8);\n\t}\n\tpos1.z -= cos(pos1Len*HALFPI)*thickness;\n\tpos2.z -= cos(pos2Len*HALFPI)*thickness;\n\treturn (length(pos1) < length(pos2)) ? vec3(pos1Len,pos1.z,t.x) : vec3(pos2Len,pos2.z,t.y);\n}\n\n// Convert HSL colorspace to RGB. http://en.wikipedia.org/wiki/HSL_and_HSV\nvec3 HSLtoRGB(in float h, in float s, in float l)\n{\n\tvec3 rgb = clamp(abs(mod(h+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\treturn l+s*(rgb-0.5)*(1.-abs(2.*l-1.));\n}\n\nmat3 inverseView(vec2 a)\n{\n    vec2 c = cos(a);\n    vec2 s = sin(a);\n    return mat3(c.y,0.,-s.y,s.x*s.y,c.x,s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tvec3 vCamPos = vec3(0.0,1.1,-1.2-sin(iTime*0.35)*0.5);\n\tvec3 vCamTarget = vec3(0.,0.5,0.);\n\tvec3 vCamForward = normalize(vCamTarget-vCamPos);\n\n\tvec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n\tvec3 vCamUp = normalize(cross(vCamRight,vCamForward));\n\tvec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*1.5);\n\tmat3 m = inverseView(vec2(asin(-vRayDir.y),atan(vRayDir.x, vRayDir.z)));\n\n\tvec3 bRes = vec3(1e4,1e4,0.);\n\tfloat bI = 0.;\n\tfor (float i=1.; i<19.; i+=1.)\n\t{\n\t\tfloat t = (iTime+i*0.15+11.)*0.5;\n\t\tvec3 p0 = vec3(sin(0.15-t*0.74)*2.0,cos(t*-1.17)*2.0,0.61+sin(0.3+t*1.71)*0.5);\n\t\tvec3 p1 = vec3(cos(t*-0.85)*2.13,sin(-t*0.432)*2.134,0.61+cos(0.2+-t*0.64)*0.5);\n\t\tvec3 p2 = vec3(sin(0.45-t*1.72)*2.,cos(t*1.331)*1.972,0.61+sin(0.9-t*0.53)*0.5);\n\t\tp1 += vec3(1e-1)*(1.-abs(sign(p1*2.-p0-p2)));\n\t\tvec3 lRes = intersectQuadraticBezier((p0-vCamPos)*m, (p1-vCamPos)*m, (p2-vCamPos)*m);\n\t\tif (lRes.y > 0.0 && bRes.y > lRes.y)\n\t\t{\n\t\t\tbRes = lRes;\n\t\t\tbI = i;\n\t\t}\t    \n\t}\n\tfloat alpha = 1.-clamp(bRes.x*0.9,0.,1.);\n\tvec3 color = HSLtoRGB(bRes.z*2.+bI/19.*6.,1.,alpha);\n\tfloat t = max(-2./vRayDir.y,0.);\n\tif (t < bRes.y && vRayDir.y < 0.)\n\t{\n\t\tvec3 pos = vCamPos + vRayDir*t;\n\t\tvec2 grid = 5.7-pow(vec2(1.4),abs(vec2(0.5)-fract(pos.xz*4.))*10.2);\n\t\tvec3 c = vec3(clamp(min(grid.x,grid.y),0.,1.));\n\t\tcolor = mix(c*clamp(1.-t*0.15,0.,1.),color*0.5,alpha);\n\t}\n\tfragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"}]}