{"ver":"0.1","info":{"id":"lllczl","date":"1506076838","viewed":329,"name":"SmplxGNoise 3d","username":"TinyTexel","description":"3d simplex gradient noise (+ analytical gradients)\ncamera controls via mouse + shift key","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["noise","perlin","gradient","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SmplxGNoise 3d\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\n3d simplex gradient noise\ncamera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n//#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nfloat PrimHash128(vec3 p)\n{\n    return mod(dot(p, vec3(59.0, 107.0, 43.0)), 128.0) / 127.0 * 2.0 - 1.0;\n}\n\n\nfloat SCurveC2(float x) \n{ \n\tfloat x2 = x * x; \n\t\n\treturn x2 * x * (10.0 - 15.0 * x + 6.0 * x2);\n}\n\n#define mad(x, m, a) ((x) * (m) + (a))\nfloat SCurveC2D1(float x) \n{ \n\tfloat x2 = x * x; \n\t\n\t// return x2 * (30.0 * x2 - 60.0 * x + 30.0);\n\treturn x2 * (mad(x2, 30.0, mad(x, -60.0, 30.0)));\n}\n\nfloat SCurveC3(float x) \n{ \n\tfloat x2 = x * x; \n\tfloat x4 = x2 * x2; \n\t\n\treturn x4 * mad(mad(x, 25.0 - x4, -48.0), x, 25.0);\n}\n\nfloat SCurveC3D1(float x) \n{ \n\tfloat x2 = x * x; \n\tfloat x3 = x2 * x; \n\t\n\t// return -10.0 * x3 * (-10.0 + (24.0 * x) - (15.0 * x2) + (x3 * x3));\n\treturn -10.0 * x3 * (mad(x, 24.0, -10.0) + mad(x2, -15.0, x3 * x3));\n}\n\n// a.xyz: gradient | a.w: value\nvec4 Mul(vec4 a, vec4 b) { return vec4(a.www * b.xyz + a.xyz * b.www, a.w * b.w); }\n\n/*\nfloat len; vec3 dir;\nNormAndNormalize(vec, OUT len, dir);\n*/\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\trcpLen = max(-1.0, rcpLen);\n    \n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n#define LOOP(head0, head1, head2, head3, body) {head0 body} {head1 body} {head2 body} {head3 body}\n\n// https://en.wikipedia.org/wiki/Simplex_noise\nfloat SmplxGNoise(vec3 p, uint seed)\n{\n    // const float n = 3.0;\n    const float F = 1.0 / 3.0;// (sqrt(n + 1.0) - 1.0) / n;\n    const float G = 1.0 / 6.0;// (1.0 - rsqrt(n + 1.0)) / n;\n    \n    vec3 p2 = p + (p.x + p.y + p.z) * F;\n    \n    vec3 ip = floor(p2);\n    vec3 fp = p2 - ip;\n    \n\n    float res = 0.0;\n\n    vec3 vo1, vo2;\n    {\n        float xz = step(fp.z, fp.x); \n        float yz = step(fp.z, fp.y); \n        \n        if(fp.x > fp.y)\n        {\n            vo1 = vec3(xz, 0., xz);          \n            vo2 = vec3(1., yz, yz);\n        }\n        else\n        {\n            vo1 = vec3(0., yz, yz);\n            vo2 = vec3(xz, 1., xz);\n        }\n        \n        vo1.z = 1.0 - vo1.z;\n        vo2.z = 1.0 - vo2.z;        \n    }\n\n    \n    uvec3 vSeed = uvec3(0xED347D40u, 0x90F2E7EAu, 0x432905BDu) ^ uvec3(seed);\n    \n    LOOP(vec3 vert = vec3(0.0, 0.0, 0.0);, \n         vec3 vert = vo1;,\n         vec3 vert = vo2;,          \n         vec3 vert = vec3(1.0, 1.0, 1.0);,\n        \n         #if 1\n         uint vHash = HashUInt(vert + ip, vSeed);\n\n         float h0 = HashFlt(vHash, 0xE2EE2C90u);\n         float h1 = HashFlt(vHash, 0x806C2B4Fu);\n         \n         vec3 g = Sample_Sphere(h0, h1);\n\n         #else\n         const float texDim = 64.0;\n    \t const vec2 prime = vec2(53.0, 41.0);\n    \t const float txlDim = 1.0 / texDim;\n         \n         vec3 vp = vert + ip;\n         \n         #if 1\n         vec3 vHash = textureLod(iChannel1, (vp.xz + vp.y * prime + 0.5) * txlDim, 0.0).rgb * 2.0 - 1.0; \n\t\t #else\n         vHash = vec3(PrimHash128(vp.xyz), \n                      PrimHash128(vp.yzx), \n                      PrimHash128(vp.zxy));\n         #endif\n         \n         #if 0\n         vec3 g = vHash * rsqrt(3.0);\n         #elif 1\n         vec3 g = normalize(vHash);\n         #else\n         vec3 g = Sample_Sphere(vHash.x, vHash.y);\n         #endif\n         #endif\n         \n\n        vec3 vec  = fp - vert;\n             vec -= (vec.x + vec.y + vec.z) * G;\n         \n        float w = Pow3(clamp01(1.0 - 2.0 * SqrLen(vec)));\n              //w = SCurveC2(clamp01(1.0 - sqrt(2.0)*length(vec)));        \n        \n        float v = dot(vec, g);\n        \n        res += w * v;\n\t)\n\n    //res *= 3.904;//SCurveC2\n    res *= 4.738;//Pow3\n    //res *= 6.729;//Pow4\n\n    return res;\n}\n\n// result.xyz: gradient | result.w: value\nvec4 SmplxGNoise2(vec3 p, uint seed)\n{\n    // const float n = 3.0;\n    const float F = 1.0 / 3.0;// (sqrt(n + 1.0) - 1.0) / n;\n    const float G = 1.0 / 6.0;// (1.0 - rsqrt(n + 1.0)) / n;\n    const float sqrt2 = sqrt(2.0);\n    \n    vec3 p2 = p + (p.x + p.y + p.z) * F;\n    \n    vec3 ip = floor(p2);\n    vec3 fp = p2 - ip;\n    \n\n    vec4 res = vec4(0.0);\n\n    vec3 vo1, vo2;\n    {\n        float xz = step(fp.z, fp.x); \n        float yz = step(fp.z, fp.y); \n        \n        if(fp.x > fp.y)\n        {\n            vo1 = vec3(xz, 0., xz);          \n            vo2 = vec3(1., yz, yz);\n        }\n        else\n        {\n            vo1 = vec3(0., yz, yz);\n            vo2 = vec3(xz, 1., xz);\n        }\n        \n        vo1.z = 1.0 - vo1.z;\n        vo2.z = 1.0 - vo2.z;        \n    }\n\n    \n    uvec3 vSeed = uvec3(0xED347D40u, 0x90F2E7EAu, 0x432905BDu) ^ uvec3(seed);\n    \n    LOOP(vec3 vert = vec3(0.0, 0.0, 0.0);, \n         vec3 vert = vo1;,\n         vec3 vert = vo2;,          \n         vec3 vert = vec3(1.0, 1.0, 1.0);,\n        \n         #if 1\n         uint vHash = HashUInt(vert + ip, vSeed);\n\n         float h0 = HashFlt(vHash, 0xE2EE2C90u);\n         float h1 = HashFlt(vHash, 0x806C2B4Fu);\n         \n         vec3 g = Sample_Sphere(h0, h1);\n\n         #else\n         const float texDim = 64.0;\n    \t const vec2 prime = vec2(53.0, 41.0);\n    \t const float txlDim = 1.0 / texDim;\n         \n         vec3 vp = vert + ip;\n         \n         #if 1\n         vec3 vHash = textureLod(iChannel1, (vp.xz + vp.y * prime + 0.5) * txlDim, 0.0).rgb * 2.0 - 1.0; \n\t\t #else\n         vHash = vec3(PrimHash128(vp.xyz), \n                      PrimHash128(vp.yzx), \n                      PrimHash128(vp.zxy));\n         #endif\n         \n         #if 0\n         vec3 g = vHash * rsqrt(3.0);\n         #elif 1\n         vec3 g = normalize(vHash);\n         #else\n         vec3 g = Sample_Sphere(vHash.x, vHash.y);\n         #endif\n         #endif\n         \n\n        vec3 vec  = fp - vert;\n             vec -= (vec.x + vec.y + vec.z) * G;\n         \n         float len; vec3 dir;\n\t\t NormAndNormalize(vec, OUT len, dir);\n         \n         float warg = clamp01(1.0 - sqrt2 * len);\n         float w = SCurveC2(warg);        \n        \n        float v = dot(vec, g);\n        \n         res += Mul(vec4(g, v), vec4(SCurveC2D1(warg) * -dir * sqrt2, w));\n\t)\n\n    res *= 3.904;//SCurveC2\n\n    return res;\n}\n#undef LOOP\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if 0\nfloat func(vec3 x);\n\nvec3 GradientCD(vec3 x, float o)\n{\n\tfloat xn = func(vec3(x.x - o, x.y, x.z));\n\tfloat xp = func(vec3(x.x + o, x.y, x.z));\n\t\n\tfloat yn = func(vec3(x.x, x.y - o, x.z));\n\tfloat yp = func(vec3(x.x, x.y + o, x.z));\n\t\n\tfloat zn = func(vec3(x.x, x.y, x.z - o));\n\tfloat zp = func(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n\t\n\treturn g;\n}\n#endif\n\nfloat Fbm(vec3 uv, uint seed)\n{\n    const float count = 8.0;\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    //float rs = 0.2;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float v = SmplxGNoise(uv, seed);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        //rs *= -1.7;        \n        w *= 0.52;\n        uv *= 2.2;\n        \n        seed = GMXorShift(seed);\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n//#define USE_FBM\n\nvec3 EvalSceneCol(\n    vec3 rp, Cam cam, vec2 uv0, vec3 light, bool right)\n{\n    vec3 col = vec3(0.0);\n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n     \n    uint seed = 0x8E983083u;\n        \n    if(right)\n    {      \n        vec3 rd = NewRay(cam, tex21);\n    \n        float t; vec3 n; vec3 a;\n        float hit = 0.0;\n\n        {\n            vec2 tt;\n            float th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, OUT tt);\n\n            if(th > 0.0)\n            if(hit <= 0.0 || tt.x < t)\n            {\n                t = tt.x;\n                n = normalize(rp + rd * tt.x);\n                a = vec3(1.0);\n\n                hit = 1.0;\n            }\n        }\n    \n        \n        if(hit > 0.0)// RIGHT ----------------------------------------------------------------------\n        {\n\t\t\tvec3 p = rp + rd * t; \n\n            p *= 8.0;\n            \n            //col = sin(p.x)*sin(p.y)*sin(p.z);\n            \n            col = vec3(SmplxGNoise2(p, seed).w);\n            \n            \n            #if 1\n            if(tex.y > 0.5)\n            col = SmplxGNoise2(p, seed).xyz * 0.25;\n            #elif 0\n            vec3 x = p;\n            float o = 0.0001;\n           \tfloat xn = SmplxGNoise2(vec3(x.x - o, x.y, x.z), seed).w;\n            float xp = SmplxGNoise2(vec3(x.x + o, x.y, x.z), seed).w;\n\n            float yn = SmplxGNoise2(vec3(x.x, x.y - o, x.z), seed).w;\n            float yp = SmplxGNoise2(vec3(x.x, x.y + o, x.z), seed).w;\n\n            float zn = SmplxGNoise2(vec3(x.x, x.y, x.z - o), seed).w;\n            float zp = SmplxGNoise2(vec3(x.x, x.y, x.z + o), seed).w;\n\n            vec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n            \n            col = g * 0.25;\n            #endif\n            \n            #ifdef USE_FBM\n            col = vec3(Fbm(p, seed));\n\t\t\t#endif\n            \n            col = col*.5+.5;\n        }\n        else\n        {\n           col = vec3(0.11);           \n        }\n    }\n    else// LEFT ------------------------------------------------------------------------------------\n    { \n        uv0 -= PixelCount * 0.5;\n        uv0 *= 0.01 + length(rp)*0.01;\n        \n        float n = (SmplxGNoise2(vec3(uv0, 0.4), seed).w);\n        \n        #ifdef USE_FBM\n        n = (Fbm(vec3(uv0, 0.), seed));\n        #endif\n        \n        n = n*.5+.5;\n        \n        col = vec3(n);\n        \n        vec3 p = vec3(uv0, 0.4);\n        \n        #if 1\n        if(tex.y > 0.5)\n            col = SmplxGNoise2(p, seed).xyz * 0.25;\n        #elif 1\n        vec3 x = p;\n        float o = 0.0001;\n        float xn = SmplxGNoise2(vec3(x.x - o, x.y, x.z), seed).w;\n        float xp = SmplxGNoise2(vec3(x.x + o, x.y, x.z), seed).w;\n\n        float yn = SmplxGNoise2(vec3(x.x, x.y - o, x.z), seed).w;\n        float yp = SmplxGNoise2(vec3(x.x, x.y + o, x.z), seed).w;\n\n        float zn = SmplxGNoise2(vec3(x.x, x.y, x.z - o), seed).w;\n        float zp = SmplxGNoise2(vec3(x.x, x.y, x.z + o), seed).w;\n\n        vec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n\n        col = g * 0.25;\n        #endif\n    }\n\n    col = pow(clamp01(col), vec3(2.2));\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(0.0, 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.6 + mouseAccu.w * 0.02));\n    \n\n\t#ifdef USE_AA\n    float flip = step(0.5, fract(uv.y * 0.5));\n    \n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 0.5  ), 1./6.), light, right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 5./6.), 0.5  ), light, right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 1./6.), 5./6.), light, right);    \n    \n    col /= 3.0;   \n    #else\n    col = vec3(EvalSceneCol(cpos, cam, uv, light, right));    \n    #endif\n    \n\n    \n    //if(col.x > 1.0) col = vec3(1.0, 0.0, 1.0);\n    //if(col.x >\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n/*\n    if(false)\n    {\n    vo1 = fuv.x > fuv.y ? (fuv.x > fuv.z ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0)): \n    \t\t\t\t\t  (fuv.y > fuv.z ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0));\n                              \n    vo2 = fuv.x > fuv.y ? (fuv.y > fuv.z ? vec3(1.0, 1.0, 0.0) : vec3(1.0, 0.0, 1.0)): \n    \t\t\t\t\t  (fuv.x > fuv.z ? vec3(1.0, 1.0, 0.0) : vec3(0.0, 1.0, 1.0));\n    }\n    \n    if(false)\n    {\n        vec3 xz_a, xz_b;\n        if(fuv.x > fuv.z)\n        {\n            xz_a = vec3(1.0, 0.0, 0.0);\n            xz_b = vec3(1.0, 1.0, 0.0);\n        }\n        else\n        {\n            xz_a = vec3(0.0, 0.0, 1.0);\n            xz_b = vec3(0.0, 1.0, 1.0);\n        }\n        \n        vec3 yz_a, yz_b;\n        if(fuv.y > fuv.z)\n        {\n            yz_a = vec3(0.0, 1.0, 0.0);\n            yz_b = vec3(1.0, 1.0, 0.0);\n        }\n        else\n        {\n            yz_a = vec3(0.0, 0.0, 1.0);\n            yz_b = vec3(1.0, 0.0, 1.0);\n        }\n        \n        if(fuv.x > fuv.y)\n        {\n            vo1 = xz_a;\n            vo2 = yz_b;\n        }\n        else\n        {\n            vo1 = yz_a;\n            vo2 = xz_b;\n        }\n    }\n    \n    if(false)\n    {\n        vec3 xz = fuv.x > fuv.z ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n        vec3 yz = fuv.y > fuv.z ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);        \n        \n        if(fuv.x > fuv.y)\n        {\n            vo1 = xz;\n            vo2 = 1.0 - yz.xzy;\n        }\n        else\n        {\n            vo1 = yz;\n            vo2 = 1.0 - xz.zyx;\n        }\n    }\n    \n    if(false)\n    {\n        vec3 xz, yz;\n        xz.y = 0.0;  xz.xz = fuv.x > fuv.z ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        yz.x = 0.0;  yz.yz = fuv.y > fuv.z ? vec2(1.0, 0.0) : vec2(0.0, 1.0); \n                   \n        if(fuv.x > fuv.y)\n        {\n            vo1 = xz;\n            vo2 = 1.0 - yz.xzy;\n        }\n        else\n        {\n            vo1 = yz;\n            vo2 = 1.0 - xz.zyx;\n        }\n    }\n    \n    if(false)\n    {\n        vec3 xz, yz;\n        xz.y = 0.0;  xz.x = step(fuv.z, fuv.x); xz.z = 1.0 - xz.x;\n        yz.x = 0.0;  yz.y = step(fuv.z, fuv.y); yz.z = 1.0 - yz.y;\n                   \n        if(fuv.x > fuv.y)\n        {\n            vo1 = xz;\n            vo2 = yz.xzy;\n        }\n        else\n        {\n            vo1 = yz;\n            vo2 = xz.zyx;\n        }\n        \n        vo2 = 1.0 - vo2;\n    }\n    \n    if(false)\n    {\n        float xz = step(fuv.z, fuv.x); \n        float yz = step(fuv.z, fuv.y); \n        \n        float xzc = 1.0 - xz;\n        float yzc = 1.0 - yz;\n        \n        \n        if(fuv.x > fuv.y)\n        {\n            vo1 = vec3(xz, 0., xzc);          \n            vo2 = vec3(1., yz, yzc);\n        }\n        else\n        {\n            vo1 = vec3(0., yz, yzc);\n            vo2 = vec3(xz, 1., xzc);\n        }\n    }\n    \n    if(false)\n    {\n        float xy = step(fuv.y, fuv.x);\n        float xz = step(fuv.z, fuv.x); \n        float yz = step(fuv.z, fuv.y); \n        \n        float xyc = 1.0 - xy;\n        float xzc = 1.0 - xz;\n        float yzc = 1.0 - yz;\n        \n        if(fuv.x > fuv.y)\n        {\n            vo1 = vec3(xz, xyc, xzc);           \n            vo2 = vec3(xy, yz , yzc);\n        }\n        else\n        {\n            vo1 = vec3(xy, yz , yzc);\n            vo2 = vec3(xz, xyc, xzc);\n        }\n    }\n\n    if(false)\n    {\n        bool c = fuv.x <= fuv.y;\n        if(c) fuv.xy = fuv.yx;\n        \n        float xz = step(fuv.z, fuv.x); \n        float yz = step(fuv.z, fuv.y); \n        \n        float xzc = 1.0 - xz;\n        float yzc = 1.0 - yz;\n        \n        vo1 = vec3(xz, 0., xzc);\n        vo2 = vec3(1., yz, yzc);\n        \n        if(c)\n        {\n            vo1.xy = vo1.yx;\n            vo2.xy = vo2.yx;\n        }\n    }\n    \n    //if(false)\n    {\n        float xz = step(fuv.z, fuv.x); \n        float yz = step(fuv.z, fuv.y); \n        \n        if(fuv.x > fuv.y)\n        {\n            vo1 = vec3(xz, 0., xz);          \n            vo2 = vec3(1., yz, yz);\n        }\n        else\n        {\n            vo1 = vec3(0., yz, yz);\n            vo2 = vec3(xz, 1., xz);\n        }\n        \n        vo1.z = 1.0 - vo1.z;\n        vo2.z = 1.0 - vo2.z;        \n    }\n    \n    \n    \n    if(fuv.x > fuv.y)\n    {\n        if(fuv.x > fuv.z)\n        {\n            vo1 = vec3(1.0, 0.0, 0.0);\n            vo2 = fuv.y > fuv.z ? vec3(1.0, 1.0, 0.0) : vec3(1.0, 0.0, 1.0);\n        }\n        else\n        {\n            vo1 = vec3(0.0, 0.0, 1.0);\n            vo2 = vec3(1.0, 0.0, 1.0);            \n        }\n    }\n    else\n    {\n        if(fuv.y > fuv.z)\n        {\n            vo1 = vec3(0.0, 1.0, 0.0);\n            vo2 = fuv.x > fuv.z ? vec3(1.0, 1.0, 0.0) : vec3(0.0, 1.0, 1.0);\n        }\n        else\n        {\n            vo1 = vec3(0.0, 0.0, 1.0);\n            vo2 = vec3(0.0, 1.0, 1.0);            \n        }\n    }\n    \n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SmplxGNoise 3d\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\n3d simplex gradient noise\ncamera controls via mouse + shift key\n*/\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}","name":"Buffer A","description":"","type":"buffer"}]}