{"ver":"0.1","info":{"id":"Nd2XRz","date":"1619560591","viewed":114,"name":"Excalibur","username":"wycwyc99a88b","description":"Excalibur in Fate/stay night","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","depthoffield","ambientocclusion","blinnphong","noisefunction","specularreflection","smoothblendingsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float SHADOW_HARDNESS = 6.0;\nvec3 eye = vec3(0.0, 8.5, -35);\n\n// Ambient occlusion\nconst float AO_DIST = 0.02;\nconst float AO_K = 2.0;\n\n// Depth of Field\nconst float FOCAL_LENGTH = 35.;\nconst float FOCAL_RANGE = 100.0;\n\n#define pi 3.1415926\n#define EPSILON 0.1\n\n#define LIGHT_POS vec3(-6.0, 8.0, -10.0)\n\n// properties for handle of sword\n#define HANDLE1 1\n#define HANDLE2 2\n\n#define HANDLE1_COLOR vec3(25.0/255.0, 50.0/255.0, 93.0/255.0)\n#define HANDLE2_COLOR vec3(229.0/255.0, 200.0/255.0, 97.0/255.0)\n\n#define HANDLE11_SDF sdCappedCylinder(opCheapBend(pos - vec3(0.0, 8.0, 0.0)), 0.25, 1.7)\n#define HANDLE12_SDF sdCappedCylinder(opCheapBend(rotateZ(pos - vec3(0.0, 8.0, 0.0), 180.0 * 2.0 * pi / 360.0)), 0.25, 1.7)\n#define HANDLE13_SDF box(pos - vec3(0.0, 4.8, 0.0), vec3(0.25, 0.8, 1.0))\n#define HANDLE14_SDF sdTriPrism(rotateZ(pos - vec3(0.0, 3.8, 0.0), 180. * pi / 180.), vec2(0.35, 1.0))\n\n#define HANDLE1_SU1_SDF opSmoothUnion(HANDLE11_SDF, HANDLE12_SDF, 0.1)\n#define HANDLE1_SU2_SDF opSmoothUnion(HANDLE13_SDF, HANDLE14_SDF, 0.1)\n\n#define HANDLE1_SDF opSmoothUnion(HANDLE1_SU1_SDF, HANDLE1_SU2_SDF, 0.0)\n\n\n\n#define HANDLE21_SDF box(opCheapBend(pos - vec3(0.0, 5.5, 0.0)), vec3(1.8, 0.3, 1.1))\n#define HANDLE22_SDF sdCappedCone(pos - vec3(0.0, 6., 0.0), 0.3, 0.1 , 0.35)\n#define HANDLE23_SDF sdCappedCone(pos - vec3(0.0, 9.6, 0.0), 0.1, 0.35, 0.35)\n\n#define HANDLE24_SDF box(pos - vec3(0.0, 4.8, 0.0), vec3(0.35, 0.8, 1.0))\n#define HANDLE25_SDF sdTriPrism(rotateZ(pos - vec3(0.0, 3.8, 0.0), 180. * pi / 180.), vec2(0.5, 1.0))\n\n#define HANDLE2_SU1_SDF opSmoothUnion(HANDLE21_SDF, HANDLE22_SDF, 0.1)\n#define HANDLE2_SU2_SDF opSmoothUnion(HANDLE23_SDF, HANDLE24_SDF, 0.1)\n#define HANDLE2_SU3_SDF opSmoothUnion(HANDLE2_SU1_SDF, HANDLE2_SU2_SDF, 0.1)\n\n#define HANDLE2_SDF opSmoothUnion(HANDLE2_SU3_SDF, HANDLE25_SDF, 0.)\n\n// properties for body of sword\n#define SWORD 3\n\n#define SWORD_SDF box(pos - vec3(0.0, -0.5, 0.0), vec3(0.5, 6.0, 0.8))\n//#define SWORD2_SDF sdPyramid(rotateZ((pos - vec3(0.0, 0.5, 0.0)), 180.0 * 2.0 * pi / 360.0) , 1.0)\n//#define SWORD_SDF opSmoothUnion(SWORD1_SDF, SWORD2_SDF, 1.0)\n#define SWORD_COLOR vec3(199.0/255.0, 197.0/255.0, 198.0/255.0)\n\n\n#define CASE 7\n#define CASE1_SDF sdRoundBox(pos - vec3(-0.39, -0.5, 0.0), vec3(0.01, 6.0, 0.9), 0.1)\n#define CASE2_SDF sdRoundBox(pos - vec3(0.39, -0.5, 0.0), vec3(0.01, 6.0, 0.9), 0.1)\n#define CASE_SDF opSmoothUnion(CASE1_SDF, CASE2_SDF, 0.1)\n\n#define MOON 4\n#define MOON_POS vec3(-10.0, 8.0, 10.0)\n#define MOON_SDF sphere(pos, 2., MOON_POS)\n#define MOON_COLOR vec3(239./255., 237./255., 222./255.)\n\n#define LAKE 5\n#define LAKE_SDF box(pos, vec3(100., 0., 100.))\n#define LAKE_COLOR vec3(1.0)\n\n#define SKY 6\n#define SKY_SDF -1. * sphere(pos, 1000.0, vec3(0.0, 0.0, 0.0))\n#define SKY_COLOR vec3(49.0/255.0, 86.0/255.0, 153.0/255.0)\n#define SKY_TRANSITION_COLOR vec3(123./255., 185./255.,237./255.)\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvec3 opCheapBend(in vec3 p )  {\n    const float k = -0.1; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.4);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 ) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// rendering lake\n// From https://www.shadertoy.com/view/MsB3WR\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\n\nfloat random1(vec2 p) {\n    return fract(sin(dot(p,vec2(341.58, 735.42)))\n                 *40323.3851);\n}\n\nfloat random1vec3(vec3 p) {\n    return fract(sin(dot(p,vec3(341.58, 735.42, 491.34)))\n                 *40323.3851);\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    float i1 = mix(random1(vec2(intX, intY)), random1(vec2(intX + 1, intY)), fractX);\n    float i2 = mix(random1(vec2(intX, intY + 1)), random1(vec2(intX + 1, intY + 1)), fractX);\n    return mix(i1, i2, fractY);   \n}\n\nfloat interpNoise3D(float x, float y, float z) {\n    // interpolates 3D based fract (x, y, z) between curr and next int (x, y, z)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    int intZ = int(floor(z));\n    float fractZ = fract(z);\n    float i1 = mix(random1vec3(vec3(intX, intY, intZ)), random1vec3(vec3(intX + 1, intY, intZ)), fractX);\n    float i2 = mix(random1vec3(vec3(intX, intY + 1, intZ)), random1vec3(vec3(intX + 1, intY + 1, intZ)), fractX);\n    float i3 = mix(random1vec3(vec3(intX, intY, intZ + 1)), random1vec3(vec3(intX + 1, intY, intZ + 1)), fractX);\n    float i4 = mix(random1vec3(vec3(intX, intY + 1, intZ + 1)), random1vec3(vec3(intX + 1, intY + 1, intZ + 1)), fractX);\n    float j1 = mix(i1, i2, fractY);\n    float j2 = mix(i3, i4, fractY);\n    return mix(j1, j2, fractZ);   \n}\n\nfloat fbm2D(vec2 p) {\n    // Animate the point\n    vec2 point = p + vec2(iTime * 0.22, iTime * 0.53);\n    int octaves = 4;\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise2D(point.x * freq, point.y * freq) * amp;\n    }\n    return total;\n}\n\nfloat fbm3D(vec3 p) {\n    vec3 point = p + vec3(iTime * 0.22, iTime * 0.53, iTime * 0.93);\n    int octaves = 4;\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise3D(point.x * freq, point.y * freq, point.z * freq) * amp;\n    }\n    return total;\n}\n\n\nfloat waterMap( vec2 pos ) {\n\tvec2 posm = pos * m2;\n    return abs(fbm2D(vec2(posm)) - 0.8 )* 0.02;\n\n}\n\nvec3 getMoonColor(vec3 view) {\n    vec3 moonDir = normalize(MOON_POS - eye);\n    float angle = acos(dot(-view, moonDir)) * 360.0 / pi;\n    vec3 skyCol = SKY_COLOR - smoothstep(0.1, 0.3, -view.y)*vec3(0.2);\n    if (angle < 1.) {\n        return MOON_COLOR;\n    } else {\n        float t = (angle - 1.) / 10.;\n        t = smoothstep(0.0, 1.0, t); // making the transition more smooth\n        return mix(MOON_COLOR, SKY_COLOR, t);\n    }\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 view, vec3 rayDir) {\n    // blinn phong\n    vec3 lightDir = normalize(LIGHT_POS - p);\n    vec3 col = vec3(1.0);\n    float lambert = clamp(dot(n, lightDir), 0., 1.) + 0.2;\n    vec3 h = normalize((-rayDir + lightDir) / 2.f);\n    float specularIntensity = max(pow(dot(h, n), 2.f), 0.f);\n\n    switch(hitObj) {\n        case CASE:\n        case HANDLE1:\n            col = HANDLE1_COLOR;\n            break;\n        case HANDLE2:\n            col = HANDLE2_COLOR;\n            break;\n        case SWORD:\n            col = SWORD_COLOR;\n            break;\n        case MOON:\n            return getMoonColor(view);//MOON_COLOR;\n            break;\n        case SKY:\n            return SKY_COLOR - smoothstep(0.1, 0.3, -view.y)*vec3(0.2);\n            break;\n        case -1:\n            col = vec3(0.);\n            break;\n    }\n    return col * lambert * MOON_COLOR * specularIntensity;\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = LAKE_SDF;\n    t = min(t, HANDLE1_SDF);\n    t = min(t, HANDLE2_SDF);\n    t = min(t, SWORD_SDF);\n    t = min(t, MOON_SDF);\n    t = min(t, SKY_SDF);\n    t = min(t, CASE_SDF);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = LAKE_SDF;\n    obj = LAKE;\n    \n    float t2;\n    if ((t2 = HANDLE1_SDF) < t) {\n        t = t2;\n        obj= HANDLE1;\n    }\n    if ((t2 = HANDLE2_SDF) < t) {\n        t = t2;\n        obj= HANDLE2;\n    }\n    if ((t2 = SWORD_SDF) < t) {\n        t = t2;\n        obj= SWORD;\n    }\n    if ((t2 = MOON_SDF) < t) {\n        t = t2;\n        obj= MOON;\n    }\n    if ((t2 = SKY_SDF) < t) {\n        t = t2;\n        obj= SKY;\n    }\n    if ((t2 = CASE_SDF) < t) {\n        t = t2;\n        obj= CASE;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for (int i=0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                          sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                          sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; i++) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - AO_K * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 point = eye + t * dir;\n    vec3 nor = computeNormal(point);\n    vec3 lightDir = normalize(LIGHT_POS - point);\n    float lightDot = max(0.0, dot(nor, lightDir));\n\n    vec3 isect = point;\n    vec3 surfaceColor = vec3(1.0f);\n    bool hitLake = false;\n    while (hitObj == LAKE) {\n        // compute normal of waterMap sdf\n        hitLake = true;\n        vec2 pos = isect.xz;\n        vec2 epsilon = vec2( EPSILON, 0. );\n        nor = vec3( 0., 1., 0. );\n        nor.x = (waterMap(pos + epsilon.xy) - waterMap(pos - epsilon.xy) ) / (2. * EPSILON);\n        nor.z = (waterMap(pos + epsilon.yx) - waterMap(pos - epsilon.yx) ) / (2. * EPSILON);\n        nor = normalize( nor );\t\n        vec3 rayDir = reflect(dir, normalize(nor));\n        march(isect, rayDir, t, hitObj);\n        // re-compute intersection pt & normal\n        isect = isect + t * rayDir;\n        nor = computeNormal(isect);\n        // alter surfaceColor by reflection color\n        surfaceColor *= vec3(0.2);\n\n    } \n    \n    surfaceColor = computeMaterial(hitObj, isect, nor, normalize(eye - isect), dir);\n    if (hitObj == SKY && !hitLake) {\n        surfaceColor += (abs(fbm3D(point)) - 0.5) * 0.2 * vec3(1.);\n    }\n    float ao = fiveTapAO(point, nor);\n    surfaceColor = surfaceColor * ao;\n    vec3 col = lightDot * vec3(1.0, 0.88, 0.7) * softShadow(lightDir, point, 0.1, SHADOW_HARDNESS);\n        col *= surfaceColor;\n    return Intersection(t, surfaceColor, point, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, vec3 eye, out vec3 ref) {\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(0.3403392 * 0.75) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, ref;\n    raycast(uv2, dir, eye, ref);\n    \n    // Time varying pixel color\n    Intersection isect = sdf3D(dir, eye);\n    vec3 col = isect.color;\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n    \n    // Output to screen\n    fragColor = vec4(col,dofZ);\n}","name":"Buffer A","description":"","type":"buffer"}]}