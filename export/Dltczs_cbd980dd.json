{"ver":"0.1","info":{"id":"Dltczs","date":"1699548151","viewed":81,"name":"Simple Smoke Rendering","username":"DiegoSS3","description":"Simple smoke rendering utilizing ray marching, voxels and volume rendering techniques.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","ray","volume","voxel","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY 3.402823466e+38\n#define MAX_STEPS 128\n#define ROTATION_ENABLED true\n#define ROTATION_SPEED 0.25\n#define SMOKE_RESOLUTION 8.0\n#define SMOKE_SPEED 1.75\n#define SMOKE_MIN_DENSITY 0.0\n#define SMOKE_MAX_DENSITY 0.05\n\nconst vec3 volume_box_min = vec3(-0.5f);\nconst vec3 volume_box_max = vec3(0.5f);\n\nconst vec3 smoke_color = vec3(0.80f, 0.71f, 0.63f);\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 rotate_2d(vec2 point, float angle) {\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\treturn vec2(point.x * cos_a - point.y * sin_a,\n                point.y * cos_a + point.x * sin_a);\t\n}\n\n// From: https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// From: https://www.shadertoy.com/view/4sfGzS\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// From: https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\nbool ray_box_intersection(Ray ray, vec3 box_min, vec3 box_max, out float tmin, out float tmax) {\n    tmin = 0.0f;\n    tmax = INFINITY;\n    \n    for (int i = 0; i < 3; ++i) {\n        float t1 = (box_min[i] - ray.origin[i]) / ray.direction[i];\n        float t2 = (box_max[i] - ray.origin[i]) / ray.direction[i];\n\n        tmin = max(tmin, min(t1, t2));\n        tmax = min(tmax, max(t1, t2));\n    }\n\n    return tmax > max(tmin, 0.0);\n}\n\nvec3 sky_color(Ray ray) {   \n    float t = 0.5f * (ray.direction.y + 1.0f);\n    return (1.0f - t) * vec3(1.0f) + t * vec3(0.5f, 0.7f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Generate camera ray\n    float fov = radians(70.0f);\n    float fx = tan(fov / 2.0f) / iResolution.x;\n    vec2 d = fx * (fragCoord.xy * 2.0f - iResolution.xy);\n    Ray ray = Ray(vec3(0.0f, 1.0f, 3.0f), vec3(d.xy - vec2(0.0f, 0.4f), -1.0f));\n    \n    // Rotate ray origin and direction\n    if (ROTATION_ENABLED) {\n        ray.origin.xz = rotate_2d(ray.origin.xz, iTime * ROTATION_SPEED);\n        ray.direction.xz = rotate_2d(ray.direction.xz, iTime * ROTATION_SPEED);\n    }\n    \n    ray.direction = normalize(ray.direction);\n    \n    // Check for intersection with the volume bounding box\n    float tmin, tmax;\n    if (ray_box_intersection(ray, volume_box_min, volume_box_max, tmin, tmax)) {\n        // Calculate the hit position\n        vec3 hit_position = ray.origin + ray.direction * tmin;\n        \n        // Calculate the voxel that the ray hit first\n        vec3 voxel_size = (volume_box_max - volume_box_min) / SMOKE_RESOLUTION;\n        vec3 start_voxel = (hit_position - volume_box_min) / voxel_size;\n        \n        // Initiate ray marching through the volume\n        float step_size = 1.0f / SMOKE_RESOLUTION;\n        vec4 accumulated_color = vec4(0.0f);\n        vec3 voxel = start_voxel;\n        for (int i = 0; i < MAX_STEPS; i++) {\n            // Sample the noise 3D and map its value to the smoke density limits\n            float noise_value = map(noise(voxel + vec3(SMOKE_SPEED * iTime)), 0.0f, 1.0f, SMOKE_MIN_DENSITY, SMOKE_MAX_DENSITY);\n            vec4 voxel_color = vec4(smoke_color, noise_value);\n            \n            // Accumulate the color through the marching\n            accumulated_color.xyz += (1.0f - accumulated_color.w) * (voxel_color.w * voxel_color.xyz);\n            accumulated_color.w += (1.0f - accumulated_color.w) * voxel_color.w;\n            \n            // Step\n            voxel += ray.direction * step_size;\n            \n            // Check for early termination\n            if (voxel.x >= SMOKE_RESOLUTION || voxel.x < 0.0f) break;\n            if (voxel.y >= SMOKE_RESOLUTION || voxel.y < 0.0f) break;\n            if (voxel.z >= SMOKE_RESOLUTION || voxel.z < 0.0f) break;\n        }\n        \n        // Accumulated the color of the sky\n        accumulated_color.xyz += (1.0f - accumulated_color.w) * (1.0f * sky_color(ray));\n        accumulated_color.w += (1.0f - accumulated_color.w) * 1.0f;\n        \n        fragColor = accumulated_color;\n    }\n    else\n        fragColor = vec4(sky_color(ray), 1.0f);\n}","name":"Image","description":"","type":"image"}]}