{"ver":"0.1","info":{"id":"NdSGWt","date":"1618323035","viewed":109,"name":"CG_CMC_2021","username":"netika","description":"Машграф","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cmc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Simple vignette posteffect\n    float vig = 1.0 - distance(uv, vec2(0.5));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) * vig / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Consts\nconst float INF = 1e10;\nconst vec3 CAM_P = vec3(0, 0.2, -6);\n\nconst vec3 PL_P = vec3(0, 0, 0);\n\nvec3 L1_P = vec3(-3, 1.5, 0);\nconst float L1_R = 0.5;\nconst vec3 L1_C = vec3(1, 1, 0.8);\n\nvec3 L2_P = vec3(1.5, 1, 2);\nconst float L2_R = 0.25;\nconst vec3 L2_C = vec3(0, 0, 1);\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// Random vectors\nvec3 randomDirection;\nvec3 randomValues;\n\n// Plane\nfloat plane(vec3 position, vec3 direction, out vec3 normal)\n{\n    float t = (-1.2 - position.y) / direction.y;\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n\n    vec3 worldPosition = t * direction + position;\n    if (dot(worldPosition.xz, worldPosition.xz) >= 100.0)\n    {\n        return INF;\n    }\n\n    normal = vec3(0, 1, 0);\n\n    return t;\n}\n\n// Sphere\nfloat sphere(vec3 position, vec3 direction, float r, out vec3 normal)\n{\n    float a = dot(direction, direction);\n    float b = dot(position, direction);\n    float c = dot(position, position) - r * r;\n\n    float D = b * b - a * c;\n    if (D < 0.0)\n    {\n        return INF;\n    }\n\n    float t = -b - sqrt(D);\n    if (t > 0.0)\n    {\n        normal = normalize(position + t * direction);\n        return t;\n    }\n\n    t = -b + sqrt(D);\n    if (t < 0.0)\n    {\n        return INF;\n    }\n\n    normal = normalize(position + t * direction);\n    return t;\n}\n\n// Cylinder\nfloat cylinder(vec3 position, vec3 direction, out vec3 normal)\n{\n    // Plane part\n    float r = 0.5;\n    float t = (-1.0 - position.y) / direction.y;\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n\n    vec3 worldPosition = t * direction + position;\n    if (dot(worldPosition.xz, worldPosition.xz) < r)\n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n\n    // Conical part\n    float a = dot(direction.xz, direction.xz);\n    float b = dot(position.xz, direction.xz);\n    float c = dot(position.xz, position.xz) - r;\n    float D = b * b - a * c;\n    if (D < 0.0)\n    {\n        return INF;\n    }\n\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0)\n    {\n        worldPosition = t * direction + position;\n        if (worldPosition.y <= -1.0)\n        {\n            normal = normalize(vec3(worldPosition.x, 0, worldPosition.z));\n            return t;\n        }\n    }\n\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0)\n    {\n        return INF;\n    }\n\n    worldPosition = t * direction + position;\n    if (worldPosition.y <= -1.0)\n    {\n        normal = normalize(vec3(worldPosition.x, 0, worldPosition.z));\n        return t;\n    }\n\n    return INF;\n}\n\n// Checks if the point is in the shadow or not\nbool occlusion(vec3 position, vec3 target)\n{\n    vec3 direction = target - position;\n    float dist = length(direction);\n    direction /= dist;\n\n    // Tracing a ray from point of interest to sphere with light\n    vec3 sphNorm;\n    float sphT = sphere(position, direction, 1.0, sphNorm);\n    if (sphT < dist)\n    {\n        return true;\n    }\n\n    // Tracing a ray from point of interest to the cylinder\n    vec3 cylNorm;\n    float cylT = cylinder(position, direction, cylNorm);\n    return (cylT < dist);\n}\n\n// Function that computes shadows and lights themselves\nvec3 lighting(vec3 position, vec3 color, vec3 normal)\n{\n    // Yellow light\n    vec3 toLight1 = L1_P - position;\n    float dist1 = length(toLight1);\n    float distSq1 = dot(toLight1, toLight1);\n    // Moving a point in random directions to get soft shadows\n    float att1 = occlusion(position, L1_P + randomDirection * L1_R) ? 0.0 : 20.0f / distSq1;\n\n    // Blue light\n    vec3 toLight2 = L2_P - position;\n    float dist2 = length(toLight2);\n    float distSq2 = dot(toLight2, toLight2);\n    // Moving a point in random directions to get soft shadows\n    float att2 = occlusion(position, L2_P + randomDirection * L2_R) ? 0.0 : 10.0f / distSq2;\n\n    return color * (max(0.0, dot(normal, normalize(toLight1))) * att1 * L1_C +\n                    max(0.0, dot(normal, normalize(toLight2))) * att2 * L2_C +\n                    texture(iChannel1, normal).rgb * 0.3);\n}\n\n// Computes refraction of the light in refractive materials.\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2)\n{\n    if (dot(v, normal) < 0.0)\n    {\n        normal = -normal;\n    }\n\n    float cosA = dot(v, normalize(normal));\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n\n    return normalize(sinB * tang + cosB * normal);\n}\n\n// Random. Some magic, taken from the lecture.\nfloat rand(float frame)\n{\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Generating random values and random direction vector\n    vec3 randomValues = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randomDirection = normalize(randomValues - 0.5);\n\n    // Calculating view vector\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 - (randomValues.xy - 0.5) * 2.0) / iResolution.x;\n    vec3 front = normalize(-CAM_P);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n\n    // Defining camera positions and direction of initial ray tracing\n    vec3 curPos = CAM_P;\n    vec3 curDir = viewVec;\n\n    // Defining material constants\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    const float WATER_N = 1.3;\n\n    // Calculating material constants\n    float n1 = AIR_N;\n    float WATER_R = (GLASS_N - WATER_N) / (GLASS_N + WATER_N) * (GLASS_N - WATER_N) / (GLASS_N + WATER_N);\n    float GLASS_R = (AIR_N - GLASS_N) / (AIR_N + GLASS_N) * (AIR_N - GLASS_N) / (AIR_N + GLASS_N);\n    float AIR_R = (WATER_N - AIR_N) / (WATER_N + AIR_N) * (WATER_N - AIR_N) / (WATER_N + AIR_N);\n\n    // Main tracing cycle\n    for (int i = 0; i < 30; i++)\n    {\n        // Distance\n        float t = INF;\n\n        // Defining variables for objects\n        int materialType;\n        vec3 color;\n        vec3 normal;\n\n        // Outside of the sphere is air\n        float nEnter = AIR_N;\n\n        // Amount of bubbles in the aquarium\n        const int BUBBLE_AMOUNT = 10;\n\n        // Defining normals for scene objects\n        vec3 l1Norm;\n        vec3 l2Norm;\n        vec3 planeNorm;\n        vec3 bubbleNorm[BUBBLE_AMOUNT];\n        vec3 cylynderNorm;\n        vec3 glassSphereNorm;\n        vec3 waterSphereNorm;\n\n        // Calculating distances to objects\n        float cylT = cylinder(curPos, curDir, cylynderNorm);\n        float planeT = plane(curPos - PL_P, curDir, planeNorm);\n        float light1T = sphere(curPos - L1_P, curDir, L1_R, l1Norm);\n        float light2T = sphere(curPos - L2_P, curDir, L2_R, l2Norm);\n        float glassSphereT = sphere(curPos, curDir, 1.0, glassSphereNorm);\n        float waterSphereT = sphere(curPos, curDir, 0.8, waterSphereNorm);\n\n        // Calculating distances to bubbles\n        float bubbleT[BUBBLE_AMOUNT];\n        bubbleT[0] = sphere(curPos + vec3(0.0, 0.5, 0.0), curDir, 0.02, bubbleNorm[0]);\n        bubbleT[1] = sphere(curPos + vec3(0.01, 0.45, 0.0), curDir, 0.03, bubbleNorm[1]);\n        bubbleT[2] = sphere(curPos + vec3(0.02, 0.35, 0.0), curDir, 0.025, bubbleNorm[2]);\n        bubbleT[3] = sphere(curPos + vec3(-0.03, 0.3, 0.0), curDir, 0.035, bubbleNorm[3]);\n        bubbleT[4] = sphere(curPos + vec3(0.04, 0.15, 0.0), curDir, 0.04, bubbleNorm[4]);\n        bubbleT[5] = sphere(curPos + vec3(-0.05, 0.08, 0.0), curDir, 0.055, bubbleNorm[5]);\n        bubbleT[6] = sphere(curPos + vec3(0.06, 0, 0.0), curDir, 0.045, bubbleNorm[6]);\n        bubbleT[7] = sphere(curPos + vec3(0.06, -0.12, 0.0), curDir, 0.06, bubbleNorm[7]);\n        bubbleT[8] = sphere(curPos + vec3(0.0, -0.2, 0.0), curDir, 0.053, bubbleNorm[8]);\n        bubbleT[9] = sphere(curPos + vec3(-0.13, -0.26, 0.0), curDir, 0.068, bubbleNorm[9]);\n\n        // Checking if the ray collided with the plane\n        if (planeT < t)\n        {\n            t = planeT;\n            vec3 worldPosition = t * curDir + curPos;\n            color = texture(iChannel0, worldPosition.xz * 0.2).rgb;\n            normal = planeNorm;\n            // 20% of all time the plane is reflective, frames are then added, so it is both reflective and textured\n            if (randomValues.x < 0.2)\n            {\n                materialType = REFLECTION;\n            }\n            else\n            {\n                materialType = DIFFUSE;\n            }\n        }\n\n        // Lights\n        if (light1T < t)\n        {\n            t = light1T;\n            materialType = EMISSION;\n            color = L1_C;\n            normal = l1Norm;\n        }\n\n        if (light2T < t)\n        {\n            t = light2T;\n            materialType = EMISSION;\n            color = L2_C;\n            normal = l2Norm;\n        }\n\n        // Glass sphere - both reflective and refractive, outside is air, inside is glass\n        if (glassSphereT < t)\n        {\n            t = glassSphereT;\n            normal = glassSphereNorm;\n\n            if (randomValues.x * 0.5 < GLASS_R)\n            {\n                materialType = REFLECTION;\n            }\n            else\n            {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0)\n                {\n                    nEnter = AIR_N;\n                }\n                else\n                {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        \n        // Water sphere, outside is glass, inside there are several water bubbles\n        if (waterSphereT < t)\n        {\n            t = waterSphereT;\n            normal = waterSphereNorm;\n\n            if (randomValues.x * 0.5 < WATER_R)\n            {\n                materialType = REFLECTION;\n            }\n            else\n            {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0)\n                {\n                    nEnter = GLASS_N;\n                }\n                else\n                {\n                    nEnter = WATER_N;\n                }\n            }\n        }\n\n        // Cycle for bubbles, outside is water, inside is air, not sure if it needs to be reflective, but why not\n        for (int j = 0; j < BUBBLE_AMOUNT; j++)\n        {\n            if (bubbleT[j] < t)\n            {\n                t = bubbleT[j];\n                normal = bubbleNorm[j];\n\n                if (randomValues.x * 0.5 < AIR_R)\n                {\n                    materialType = REFLECTION;\n                }\n                else\n                {\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0)\n                    {\n                        nEnter = WATER_N;\n                    }\n                    else\n                    {\n                        nEnter = AIR_N;\n                    }\n                }\n            }\n        }\n\n        // Cylinder\n        if (cylT < t)\n        {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPosition = t * curDir + curPos;\n            color = texture(iChannel2, worldPosition.xz * worldPosition.y).rgb;\n            normal = cylynderNorm;\n        }\n\n        // Drawing materials\n        if (t != INF)\n        {\n            vec3 worldPosition = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPosition.xz);\n\n            bool breakflag = false;\n            switch (materialType)\n            {\n            // Emissive objects (lights)\n            case EMISSION:\n                fragColor.rgb = color;\n                return;\n            // Diffusive objects (plane)\n            case DIFFUSE:\n                fragColor.rgb = lighting(worldPosition, color, normal);\n                break;\n            // Reflective objects (plane, all the spheres)\n            case REFLECTION:\n                curDir = reflect(curDir, normal);\n                curPos = worldPosition + curDir * 1e-5;\n                break;\n            // Refractive objects (all the spheres)\n            case REFRACTION:\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPosition + curDir * 1e-5;\n                n1 = nEnter;\n                break;\n            }\n        }\n        else\n        {\n            // Drawing skybox if the ray did not hit anything.\n            fragColor = texture(iChannel1, curDir);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}