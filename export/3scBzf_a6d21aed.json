{"ver":"0.1","info":{"id":"3scBzf","date":"1605632552","viewed":130,"name":"Icecream world","username":"jpupper","description":"Looks like you want to step in and eat the icecream and die of diabetes","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define pi 3.14159265359\n\n// COPIAR OBJETOS A LO LARGO DE VARIOS EJES\n\n// utilizando la función mod, podemos repetir objetos en la escena\n\n// VARIABLES GLOBALES\n\nfloat det = 0.004;\nfloat maxdist = 1000.;\n\nint maxsteps = 1000;\n\nvec3 objcol;\n\n// FUNCION DE ROTACION\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// FUNCIONES DE DISTANCIA PRIMITIVAS \n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\nfloat ground(vec3 p, float y) \n{\n    p.y += y;\n    return abs(p.y);\n}\n\n\n// FUNCION DE ESTIMACION DE DISTANCIA\nfloat mapr(float _value,float _low2,float _high2) {\n    float val = _low2 + (_high2 - _low2) * (_value - 0.) / (1.0 - 0.);\n    //float val = 0.1;\n    return val;\n}\n\n\n\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat de(vec3 p) \n{\n\n\n    float box = 1.;\n    vec3 pos = p;\n    float pz = abs(fract(sin(p.z*0.33)*1.0-1.));\n    \n    float cnt = 4.;\n    vec3 col1 = vec3(0.9,0.2,0.7);\n    vec3 col2 = vec3(0.4,0.5,0.8);\n   \n    for(float i=0.; i<cnt; i++){\n        float index = i/float(cnt);\n        float ms = 5.;\n       // p.x+= i;\n      //    p.z+= sin(index*pi*+time);\n        p.x = mod(p.x, ms) - ms/2.;\n        p.z = mod(p.z, ms*2.) - ms*2./2.;\n        vec3 pbox = p;\n        vec3 pcono = p;\n        pcono.y -=1.5;\n        pcono.x+= sin(pcono.y*10.+iTime)*0.2;\n        \n        float mof = cos(p.z*4.+index*pi*4.+iTime)*0.04;\n        box = min(box,sdCone(pcono,vec2(0.1+mof,0.01+index*0.05+mof),8.1));   \n        \n        vec3 col11 = vec3(0.7,0.7,0.7);\n        vec3 col12 = vec3(0.7,0.7,0.7);\n        vec3 col21 = vec3(0.8,0.2,0.8);\n        vec3 col22 = vec3(0.8,0.3,0.4);\n        \n        col1 = mix(col11,col12,index);\n        \n        col2 = mix(col21,col22,index);\n    }\n    vec3 pospiso = pos;\n   // pospiso.z+=sin(time);\n    //pospiso.y+=sin(p.x*10)*0.2+0.5;\n    //pospiso.xy = vec2(sin(p.x));\n    pospiso.y += cos(pospiso.x*3.+pospiso.z*4.)*.1;    \n    pospiso.y += sin(pospiso.z*4.+pospiso.y*4.)*.1;    \n    float pla = ground(pospiso, 0.8);\n    \n    float d = box;\n    \n    d = min(box,pla);\n    // para generar el cuadriculado   \n   \n    float c = pow(max(max(fract(p.x),fract(p.y)), fract(p.z)),0.5);\n    float b = pow(max(fract(p.x),fract(p.z)),5.);\n\n   // length(fract(pos.xz));\n  //  if (d==box) objcol=vec3(0.8-pz,sin(length(fract(pos.zz))*1)*0.7,pz);\n \n  \n   \n   \n   \n   \n    if (d==box) objcol=mix(col1,col2,pz);\n    if (d==pla) objcol=vec3(0.7,0.7,0.7);\n\n\n\n    return d *.7;\n}\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADOW\n// calcula la sombra, generando un efecto de suavizado de los bordes\n// a medida que se aleja del objeto\n\nfloat shadow(vec3 p, vec3 ldir) {\n    float td=.001,sh=150.,d=det;\n    \n    for (int i=0; i<0; i++) {\n        p+=ldir*d;\n        d=de(p);\n        td+=d;\n        sh=min(sh,1.*d/td);\n        if (sh<.001) break;\n    }\n    return clamp(sh,0.,0.9);\n}\n\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n\n    vec3 col = objcol;\n    \n    vec3 lightdir = normalize(vec3(sin(iTime)*0.5+0.5, 0.9, 0.9)); \n\n    vec3 n = normal(p);\n\n    float sh = shadow(p, lightdir);    \n    \n    float diff = max(0.0, dot(lightdir, n)) * sh; // multiplicamos por sombra;\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0., dot(lightdir, refl)), 0.01) * sh; // multiplicamos por sombra;\n    \n    float amb = .1;\n    \n    return col*(amb*6.0 + diff) + spec * 0.1;\n    \n}\n\n\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p, col;\n\n\n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    } else {\n        // si no golpeo con ningun objeto, llevamos la distancia a la máxima\n        // que se definió, o sea al fondo de la escena\n        // esto sirve para el correcto cálculo de la niebla\n        td = maxdist;\n    }\n    // efecto niebla\n    // mix entre el color obtenido y un color de la niebla\n    // utilizando para mezclarlos la funcion exp con la variable td\n    // que es la distancia en la que quedo el rayo con respecto a la cam\n    // el -.01 en la funcion exp altera la distancia de la niebla\n    \n    vec3 colfondo = vec3(1.-p.y,1.-p.y,1.-p.y);\n    \n    float f = sin(dir.z*100.+iTime)*0.5+0.5;\n    vec3 col1 = vec3(0.8,0.3,0.4);\n    vec3 col2 = vec3(0.7,0.7,0.7);\n    vec3 colf = mix(col1,col2,f);\n  //  colfondo = col1;\n    col = mix(colf,col, exp(-.0005*td*td));\n    return col;    \n}\n\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    vec3 from = vec3(0., 0.,2.);\n    //from.z-=time*0.1;\n    vec3 dir = normalize(vec3(uv, 1.));\n\n    //una forma simple de rotar la cámara\n    //es rotando en los mismos ejes tanto from como dir\n    from.xz *= rot(iTime*.2);\n    \n    from.z-=iTime*1.;\n    from.y+=sin(iTime*.001);\n     from.y+=1.9;\n    //dir.xz *= rot(time*.2);\n    //dir.xy *= rot(time*.02);\n   // dir.z+= sin(time)*0.8;\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}