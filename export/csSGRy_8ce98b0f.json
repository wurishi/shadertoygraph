{"ver":"0.1","info":{"id":"csSGRy","date":"1667759324","viewed":96,"name":"Three Body Chaos","username":"neurofuzzy","description":"Basic symplectic euler simulation of the three body chaos problem with initial conditions of: two particles in a circular orbit, stationary 3rd particle. The color corresponds to the minimum distance achieved between the third particle and the two others.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe gravitational 3 body problem \nG=m1=m2=m3=1\npos1=(x,y), pos2=(0,1), pos3=(0,-1).\nvel1=(x,y), vel2=(-0.707,0), vel3=(0.707,0).\n\n*/\n\nint ntimesteps=4000; //timesteps, higher = smaller dt. Computational time \\propto ntimesteps\nint ss=1; // supersampling. Computational time \\propto ss^2\nfloat scale=1.0; //scale, higher = more zoomed out\n\nvec4 getFrag(float x1, float y1, float dt, int ntimesteps) {\n\n    float x3=0.0,y3=-1.0,x2=0.0,y2=1.0;\n    float p3x=0.707,p3y=0.0,p2x=-0.707,p2y=0.0,p1x=0.0,p1y=0.0;\n    float d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n    float d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n    float d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n    float m=min(d12,d31);\n    \n    for(int i=0;i<ntimesteps;i++){\n        d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n        d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n        d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n        //m=min(m,min(d12,min(d23,d31)));\n        m=min(m,min(d31,d12));\n        d12=pow(d12,-1.5);\n        d23=pow(d23,-1.5);\n        d31=pow(d31,-1.5);\n        p1x += dt* ((x2-x1)*d12+(x3-x1)*d31);\n        p1y += dt* ((y2-y1)*d12+(y3-y1)*d31);\n        p2x += dt* ((x3-x2)*d23+(x1-x2)*d12);\n        p2y += dt* ((y3-y2)*d23+(y1-y2)*d12);\n        p3x += dt* ((x2-x3)*d23+(x1-x3)*d31);\n        p3y += dt* ((y2-y3)*d23+(y1-y3)*d31);\n        x1 += dt*p1x;\n        y1 += dt*p1y;\n        x2 += dt*p2x;\n        y2 += dt*p2y;\n        x3 += dt*p3x;\n        y3 += dt*p3y;\n    }\n    \n    float h=-log(m/2.0)/10.0;\n    return vec4(h,h,h,1.0);;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float totaltime=iTime/3.0;\n    float dt=totaltime/float(ntimesteps);\n    \n   \tvec2 xpos = (fragCoord.xy-iResolution.xy*0.5)*2.0/iResolution.xx;\n    \n    float x1=xpos.x*scale,y1=xpos.y*scale;\n    \n    float dx=2.0*scale/(iResolution.x*float(ss));\n    \n    vec4 fragAverage=vec4(0.0,0.0,0.0,1.0);\n    \n    for(int i=0;i<ss;i++){\n        for(int j=0;j<ss;j++){\n            fragAverage+=getFrag(x1+float(i)*dx,y1+float(j)*dx,dt,ntimesteps);\n        }\n    }\n\n    fragColor = fragAverage/float(ss*ss);\n    \n}\n","name":"Image","description":"","type":"image"}]}