{"ver":"0.1","info":{"id":"4l2XzW","date":"1442073231","viewed":263,"name":"TheThirdLaw","username":"dila","description":"Rotozoom of some type. Probably way too much code for what you get.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["rotozoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 q = clamp(p, -s, s);\n    return length(p - q);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 q = p;\n    \n    float sc = 1.0;\n    \n    q = (fract(q * sc) * 2.0 - 1.0) * sc;\n    \n    vec3 spc = fract(p + 0.5) * 2.0 - 1.0;\n    \n    float md = 1000.0;\n    float it = 0.0;\n    \n    const int iters = 5;\n    \n    for (int i = 0; i < iters; ++i) {\n        \n        float n = float(i) / float(iters-1);\n        \n        vec3 s = sign(q);\n        \n        vec3 w = normalize(q);\n        \n        float sm = abs(p.x) + abs(p.y) + abs(p.z) * 1.0;\n        \n        float mx = mix(1.0, 2.1, 0.5+0.5*sin(sm+iTime));\n        \n        q = mix(q, s*w*w, mx);\n        \n        float d = box(q, w*w*yrot(n*pi*2.0));\n        \n        float r = mix(1.0, 1.8, 0.5+0.5*sin(p.z*n+iTime));\n        \n        float sp = length(spc.xy) - r;\n        \n        d = max(d, -sp);\n        \n        if (d < md) {\n        \tmd = d;\n            it = n;\n        }\n        \n        md = min(md, d);\n    }\n    \n    return vec2(md, it);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.3;\n    }\n    return t;\n}\n\nvec3 pal(float idx)\n{\n    vec3 gt = vec3(1.2,0.5,0.8) * iTime;\n    mat3 c = xrot(gt.x) * yrot(gt.y) * zrot(gt.z);\n    vec3 p = mix(c[0], c[1], idx);\n    vec3 q = mix(c[1], c[2], idx);\n    vec3 m = abs(mix(p, q, idx));\n    return 0.5 + m * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvo = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)));\n    \n    float rt = floor(iTime) + smoothstep(0.0, 1.0, fract(iTime));\n    \n    r *= zrot(rt);\n    o.z += iTime * 4.0;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 fd = map(w);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 100.0);\n\n    vec3 fc = pal(fd.y) * fog;\n    \n    fc = 1.0 - sqrt(fc);\n    \n    float edge = max(abs(uvo.x), abs(uvo.y));\n    \n    fc *= 1.0 - pow(edge,8.0);\n\n\tfragColor = vec4(fc, 1.0);\n}","name":"","description":"","type":"image"}]}