{"ver":"0.1","info":{"id":"l3SBW1","date":"1729382110","viewed":23,"name":"randomCircle","username":"enomotoai","description":"glsl beginner","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 光が球にどのくらい近いか求める関数\nfloat sphereSDF(vec3 p, vec3 spherePos, float radius) {\n    return length(p - spherePos) - radius;\n}\n\n// 簡易ランダム関数\nfloat random(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0.0, -7.0, -15.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 100;\n    float maxDistance = 20.0;\n    float epsilon = 0.001;\n    bool hit = false;\n\n    // 球の動きをさらにゆっくりにするために iTime を調整\nfloat slowTime = iTime * 0.2;\n    // ランダムに複数の球を作成\n    for (int j = 0; j < 5; j++) { // 5個の球を描画\n        // ランダムな位置とサイズ\n        vec2 seed = vec2(float(j) * 1.0, slowTime); // 調整された時間をシードにする\n        vec3 spherePos = vec3(\n            random(seed + vec2(1.0)) * 10.0 - 5.0,  // ランダムなX座標\n            random(seed + vec2(2.0)) * 10.0 - 5.0,   // ランダムなY座標（-5から5に調整）\n            random(seed + vec2(3.0)) * 10.0 - 10.0  // ランダムなZ座標（奥行き）\n        );\n        float sphereRadius = random(seed + vec2(4.0)) * 0.5 + 0.3; // ランダムな半径\n\n        // レイマーチングのループ\n        t = 0.0; // それぞれの球に対して t をリセット\n        for (int i = 0; i < maxSteps; i++) {\n            vec3 currentPos = cp + t * rd;\n            float distance = sphereSDF(currentPos, spherePos, sphereRadius);\n            if (distance < epsilon) {\n                hit = true;\n                col = vec3(0.0, 0.5, 1.0); // 球にヒットしたらオレンジ色\n                break;\n            }\n            t += distance;\n            if (t > maxDistance) break;\n        }\n        if (hit) break; // 1つでもヒットしたら次の球体は無視\n    }\n    \n    // ヒットしなければ黒色\n    if (!hit) {\n        col = vec3(0.0);\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}