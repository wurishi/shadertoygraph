{"ver":"0.1","info":{"id":"XctGRj","date":"1711896620","viewed":38,"name":"ray marching oscillating egg ","username":"ShadedSky","description":"ray marching, fbm, sdf, noise, iridescent egg, Hippitus Hoppitus","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","sdf","fbm","lacunarity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float boundSine(float x, float a, float b, float h) {\n    float amplitude = (b - a) * 0.5;\n    float offset = (a + b) * 0.5;\n    return amplitude * sin(h*x) + offset;\n}\n\n\n// Raymarch a basic shape, an elongated ellipsoid to mimic an egg shape\n\nfloat eggShapeSDF(vec3 p) {\n\n    // Modify these parameters to create an egg shape.\n    float radius = 1.08;\n    float height = boundSine(iTime, 1.16, 1.6, 1.0);\n    \n    vec3 q = vec3(p.x, p.y, p.z + radius - height);\n    \n    // Create the lower part of the egg shape with a sphere SDF.\n    float lowerPart = length(q) - radius;\n    \n    // Create the upper part of the egg shape with an elongated ellipsoid SDF.\n    float upperPart = length(q * vec3(1.5, 1.0, height / radius)) - radius;\n    \n    // Combine the two parts to create the egg shape.\n    return mix(lowerPart, upperPart, smoothstep(-0.5, 0.5, p.z));\n}\n\n// Generates a pseudo-random value based on a 2D coordinate.\n// The randomness is generated using the sine of the dot product of the coordinate\n// and a constant vector, scaled to produce a fractal result.\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Generates a smooth noise value based on 2D simplex noise.\n// It interpolates between four points to create a smooth gradient of noise.\nfloat noise(in vec2 _st) {\n    vec2 i = floor(_st); // The integer part of _st\n    vec2 f = fract(_st); // The fractional part of _st\n\n    // Calculate noise contributions from each of the four corners\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smoothly interpolate between the corners\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n\n#define NUM_OCTAVES 5\n\n// Calculates Fractal Brownian Motion (FBM) based on the noise function.\n// It accumulates noise at different octaves to produce fractal-like structures.\nfloat fbm(in vec2 _st) {\n    float value = 0.0;\n    float amplitude = 1.3;\n    float gain_modifier = 0.8;\n    float lacunarity = 3.9;\n    \n    // add \"flow\" to shift with sin \n    vec2 shift = vec2(1.0);//*sin(2.0*iTime));\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5)); // Rotation matrix\n\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        value += amplitude * noise(_st);\n        _st = rot * _st * lacunarity + shift;\n        // adjust amplitude / gain effect\n        amplitude *= gain_modifier;\n    }\n    return value;\n}\n\n\n// Normal calculation with perturbation for the liquid effect\nvec3 calculateNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    \n    // Use the gradient of the SDF to calculate the normal.\n    vec3 normal = normalize(vec3(\n        eggShapeSDF(p + e.xyy) - eggShapeSDF(p - e.xyy),\n        eggShapeSDF(p + e.yxy) - eggShapeSDF(p - e.yxy),\n        eggShapeSDF(p + e.yyx) - eggShapeSDF(p - e.yyx)\n    ));\n    \n    // Perturb the normal using a noise function (e.g., fbm).\n    // `fbm` would be a function you need to define that computes fractional Brownian motion.\n    float noise = fbm(vec2(p * 5.0 + iTime));\n    normal += 0.1 * vec3(noise);\n    \n    return normalize(normal);\n}\n\n// Iridescence calculation\nvec3 iridescence(vec3 normal, vec3 viewDir) {\n    // The color will change with the angle of incidence.\n    float angle = acos(dot(normal, -viewDir));\n    \n    // Calculate the iridescence effect.\n    vec3 color = 0.5 + 0.5 * cos(angle + vec3(0.0, 0.33, 0.67) * 6.2831*sin(0.5*iTime));\n    \n    return color;\n}\n\nconst float MAX_DISTANCE = 100.0; // Maximum raymarching distance\nconst int MAX_STEPS = 64;        // Maximum number of steps\nconst float EPSILON = 0.001;     // Threshold for surface hit\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        float dist = eggShapeSDF(p);\n        if (dist < EPSILON) {\n            return p; // surface hit\n        }\n        t += dist;\n        if (t >= MAX_DISTANCE) break; // too far, no hit\n    }\n    return vec3(0); // return a default value indicating no hit\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -2.0); // ray origin\n    vec3 rd = normalize(vec3(uv, 2.0)); // ray direction\n    \n    // Lighting setup\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -0.6));\n    \n    // Perform raymarching to find the surface point\n    vec3 p = rayMarch(ro, rd);\n    \n    // Default background color\n    vec3 bgColor = vec3(0.0);\n    \n    // If we hit the surface, calculate color and lighting\n    if (length(p) > 0.0) { // assuming a hit if p is not zero\n        // Calculate the perturbed normal\n        vec3 n = calculateNormal(p);\n        \n        // Get the iridescence color\n        vec3 color = iridescence(n, -rd);\n        \n        // Simple lighting\n        float diff = max(dot(n, lightDir), 0.0);\n        \n        // Combine color with lighting\n        vec3 finalColor = color * diff;\n        \n        fragColor = vec4(finalColor, 1.0);\n    } else {\n        // No hit, render background\n        fragColor = vec4(bgColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}