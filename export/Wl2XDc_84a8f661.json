{"ver":"0.1","info":{"id":"Wl2XDc","date":"1567536984","viewed":417,"name":"Sandglass","username":"TambakoJaguar","description":"I created this animated sandglass and I'm quite happy with the result. What do you think?\nUse mouse to move around\nUP/DOWN or PGUP/PGDOWN to change the zoom\nF for the half, R for the whole sandglass\nLEFT/RIGHT for rotation speed","likes":20,"published":1,"flags":48,"usePreview":1,"tags":["raymarching","mouse","time","refraction","refraction","animated","glass","animation","wood","stone","sand","realistic","metallic","sandglass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Sandgass\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// ToDo:\n// Light bump on glass\n// Floor reflection (with diffuse reflection with AA)\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define floor_reflection\n#define sand_structure\n#define complex_wood\n//#define shadow\n//#define test_mode\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 4;\n\n// Campera options\nvec3 campos = vec3(0., 0., 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 3.1;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.31;\n\n// Specular options\nconst float specint_wood = 0.46;\nconst float specshin_wood = 5.5;\nconst float specint_metal = 1.2;\nconst float specshin_metal = 20.;\nconst float specint_floor = 0.16;\nconst float specshin_floor = 15.;\nfloat specint;\nfloat specshin;\n\n// Shadow options\nfloat shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 60.;\nconst int nbref = 8;\n\n// Glass perameters\nconst float glassRadius = 0.5;\nconst float glassThickness = 0.018;\n\n// Color options\nvec3 sand_color = vec3(0.8, 0.67, 0.55);\nvec3 metal_color = vec3(.85, 0.74, 0.42);\nvec3 floor_color = vec3(0.8, 0.65, 0.6);\nvec3 sky_color1 = vec3(0., 0., 0.);\nvec3 sky_color2 = vec3(0., 0.2, 0.45);\n\n// Timing options\nfloat fill_time = 38.;\nfloat pause_time = 1.;\nfloat rotation_time = 1.;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n    float ior;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define GLASS_OBJ     1\n#define FLOOR_OBJ     2\n#define WOOD_OBJ      3\n#define METAL_OBJ     4    \n#define SAND_OBJ      5  \n    \nLamp lamps[2];\n\nTransMat glassMat;\n\nbool rhalf = true;\nfloat sand_level;\nfloat sg_rot_angle;\nfloat sg_rot_angle2;\n\nint aai;\nint aaj;\n\nvoid init()\n{\n    #ifdef test_mode\n    rhalf = true;\n    #else\n    rhalf = (texture(iChannel3, vec2(0., 0.)).g==1.);\n    #endif\n    \n    sand_level = clamp(mod(iTime/fill_time, (fill_time + pause_time + rotation_time)/fill_time), 0., 1.);\n    if (rotation_time>0.)\n    {\n       sg_rot_angle = pi*smoothstep(fill_time + pause_time , fill_time + pause_time + rotation_time, mod(iTime, fill_time + pause_time + rotation_time));\n       sg_rot_angle2 = sg_rot_angle + pi*mod(floor(iTime/(fill_time + pause_time + rotation_time)), 2.);\n    }\n    else\n    {\n       sg_rot_angle = 0.;\n       sg_rot_angle2 = 0.;\n    }\n    \n    lamps[0] = Lamp(vec3(-6., 7., -2.), vec3(1., 1., 1.), 1.2, 0.01);\n    lamps[1] = Lamp(vec3(7., -3., 8.), vec3(0.7, 0.8, 1.), 0.85, 0.01);\n    \n    glassMat = TransMat(vec3(0.94, 0.99, 0.82),\n                        vec3(0.01, 0.02, 0.02),\n                        vec3(1.),\n                        vec3(0.3, 0.5, 0.9),\n                        0.25,\n                        45.,\n                        1.47);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat get_zoom()\n{\n    float zoomfact = texture(iChannel3, vec2(0., 0.)).r;\n    return zoomfact==0.?1.:zoomfact;\n}\n\nfloat get_rotspeed()\n{\n    return texture(iChannel3, vec2(0., 0.)).b;\n}\n\nfloat sdCylinder(vec3 p, vec2 h, float t, float rr)\n{\n    h-= vec2(rr);\n    vec2 d = abs(vec2(length(p.xz*(1. + t*p.y)),p.y)) - h;\n    return -rr + min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map_floor(vec3 pos)\n{\n   return pos.y + 2.15;\n}\n\nfloat map_glass0(vec3 pos)\n{\n   float d;\n   float py = abs(pos.y);\n    \n   float d1 = glassRadius*(0.98 - 0.91*cos(pow(py*0.97, 0.93)*pi));\n   float d2 = min(1.99*glassRadius*sqrt(1.- 1.82*pow(py - 1., 2.85)), .994999);\n   d = mix(d1, d2, smoothstep(.5, 1.3, py));\n    \n   d-= 0.03*noise(pos*3.2);\n   \n   return max(length(pos.xz) - d, (py - 1.7));  \n}\n\nfloat gla_inside;\nfloat gla_outside;\nfloat map_glass(vec3 pos)\n{ \n   pos.y-= abs(0.5*sin(sg_rot_angle2));\n   pos.xy = rotateVec(pos.xy, sg_rot_angle2);\n    \n   gla_outside = map_glass0(pos) - glassThickness*0.5;\n   gla_inside = map_glass0(pos) + glassThickness*0.5;\n   \n   #ifdef test_mode\n   float glass = gla_outside;\n   #else\n   float glass = max(gla_outside, -gla_inside);\n   #endif\n    \n   if (rhalf) glass = max(glass, pos.x + pos.z);\n    \n   return glass;\n}\n\nfloat map_metal(vec3 pos)\n{\n   pos.y-= abs(0.5*sin(sg_rot_angle2));\n   pos.xy = rotateVec(pos.xy, sg_rot_angle2);\n    \n   float r = 0.03 + 0.02*sqrt(3.*pos.y*pos.y + 0.27);\n   r+= 0.085*smoothstep(0.085, 0.015, abs(pos.y));\n   r+= 0.004*smoothstep(0.025, 0.0, abs(pos.y))*sin(120.*atan(abs(pos.x) - glassRadius*1.55, abs(pos.z) - glassRadius*1.55)/pi);\n   float metal = sdCylinder(abs(pos) - vec3(glassRadius*1.57, 0., glassRadius*1.57), vec2(r, 2.12), 0., 0.06);\n    \n   if (rhalf) metal = max(metal, pos.x + pos.z);\n    \n   return metal;\n}\n\nfloat map_wood(vec3 pos)\n{\n   pos.y-= abs(0.5*sin(sg_rot_angle2));\n   pos.xy = rotateVec(pos.xy, sg_rot_angle2);\n    \n   #ifdef complex_wood    \n   float woodh = sdCylinder(abs(pos) - vec3(0., 1.72, 0.), vec2(0.78, 0.065), -0.5, 0.03);\n   woodh = max(woodh, -gla_outside + 0.04);\n    \n   float a = atan(pos.x, pos.z)/(2.*pi);\n   float c = pow(abs(smoothstep(-0.03, 1.03, fract(a*6.)) - 0.5), 8.);\n   pos.xz/= 1. - 18.*c - 0.06*smoothstep(1.4, 2.5, 1. + sin((a + 0.125)*12.*pi));    \n   #endif\n    \n   float wood = sdCylinder(abs(pos) - vec3(0., 1.89, 0.), vec2(glassRadius*2.77, 0.14), -0.27, 0.06);\n   wood = max(wood, - sdTorus(abs(pos) - vec3(0., 1.74, 0.), vec2(glassRadius*2.64, 0.055)));\n    \n   #ifdef complex_wood  \n   wood = min(wood, woodh);\n   #endif\n    \n   if (rhalf) wood = max(wood, pos.x + pos.z);\n   \n   return wood;\n}\n\n#ifndef test_mode\nfloat map_sand(vec3 pos)\n{ \n   pos.y-= abs(0.5*sin(sg_rot_angle));\n   pos.xy = rotateVec(pos.xy, sg_rot_angle);\n    \n   float sand = gla_inside + 0.005;\n\n   float sl2 = 0.9*pow(sand_level, 1.6);\n   sand = max(sand, min(pos.y + 1.78 - 1.05*pow(sand_level, 0.5) + 0.34*pow(length(pos.xz), 0.7), -pos.y + 0.03));\n   sand = max(sand, pos.y - 0.905 + sl2 - 0.28*mix(1., pow(length(pos.xz), 0.7), smoothstep(0., 0.22, sand_level)));\n   \n   float ll1 = 1.7*smoothstep(0.991, 1.01, sand_level) - 0.04;\n   float ll2 = 1.7*smoothstep(0.0, 0.015, sand_level);\n    \n   float sand2 = min(sand, sdCylinder(pos - vec3(0., -0.8, 0.), vec2(0.012 + 0.017*smoothstep(-0.15, 0., pos.y), 0.85), 0., 0.));\n   #ifdef sand_structure\n   vec3 pos2 = pos + 0.06*noise(pos*5.);\n   sand+= 0.0045*noise(210.*(pos2 + vec3(0., pos.y>0.?sl2:0., 0.)));\n   sand2+= 0.018*noise(130.*(pos + vec3(0., sand_level*100., 0.)));\n   #endif\n    \n   sand2 = max(sand2, pos.y + ll1);\n   sand2 = max(sand2, -pos.y - ll2);\n    \n   sand = min(sand, sand2);\n    \n   if (rhalf) sand = max(sand, pos.x + pos.z);\n    \n   return sand;\n}\n#endif\n\nvec2 map(vec3 pos, bool inside, bool noglass)\n{\n    float glass = map_glass(pos);\n    if (inside)\n    {\n        glass*=-1.;\n        return vec2(glass, GLASS_OBJ);\n    }\n    float wood = map_wood(pos);\n    vec2 res = vec2(wood, WOOD_OBJ);\n    \n    if (!noglass)\n       res = opU(res, vec2(glass, GLASS_OBJ));\n    \n    float metal = map_metal(pos);\n    res = opU(res, vec2(metal, METAL_OBJ));\n    \n    #ifndef test_mode\n    float sand = map_sand(pos);\n    res = opU(res, vec2(sand, SAND_OBJ));\n    #endif\n    \n    float floor = map_floor(pos);\n    res = opU(res, vec2(floor, FLOOR_OBJ));     \n    \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 115; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.45;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, inside, false).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, false, true).x;\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    return texture(iChannel0, ray).rgb;\n}\n\nvec3 getSkyColor2(vec3 ray)\n{ \n    return mix(sky_color1, sky_color2, ray.y);\n}\n\nvec3 getFloorColor(vec3 pos)\n{\n    return  mix(floor_color, texture(iChannel2, 0.17*pos.xz).rgb, 0.55);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==GLASS_OBJ)\n      #ifdef test_mode\n      return vec3(0.5, 0.55, 0.6);\n      #else\n      return glassMat.col_dif;\n      #endif\n   else if (objnr==WOOD_OBJ)\n   {\n      pos.y-= abs(0.5*sin(sg_rot_angle2));\n      pos.xy = rotateVec(pos.xy, sg_rot_angle2);\n      return 0.8*texture(iChannel1, 0.6*(pos.xy + pos.yz)).rgb;\n   }\n   else if (objnr==METAL_OBJ)\n      return metal_color*0.25;\n   else if (objnr==SAND_OBJ)\n      return sand_color;\n   else if (objnr==FLOOR_OBJ)       \n      return getFloorColor(pos);\n   else\n      return getSkyColor(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (objnr!=SAND_OBJ)\n        col+= (objnr==METAL_OBJ?metal_color:vec3(1.))*lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    if (objnr==GLASS_OBJ)\n    {\n       specint = glassMat.specint;\n       specshin = glassMat.specshin;           \n    }\n    else if (objnr==WOOD_OBJ)\n    {\n       specint = specint_wood;\n       specshin = specshin_wood;  \n    }    \n    else if (objnr==FLOOR_OBJ)\n    {\n       specint = specint_floor;\n       specshin = specshin_floor;  \n    } \n    else if (objnr==METAL_OBJ)\n    {\n       specint = specint_metal;\n       specshin = specshin_metal;  \n    } \n    \n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm + get_rotspeed()*iTime);\n\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        if (objnr==FLOOR_OBJ)\n           col = mix (sky_color1, col, smoothstep(0.85*maxdist, 0.2*maxdist, length(pos.xz)));\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.1 + pow(dist*6., 2.)));\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov*get_zoom());\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n  \tbool inside = false;\n  \tfloat cior = glassMat.ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n\n    glassf = vec3(1.);\n\n    for (int i=0; i<nbref; i++)\n    {\n        #ifndef test_mode\n        if (traceinf.objnr==GLASS_OBJ)\n        {\t \n            float gv = glassf.r;\n            #ifdef reflections\n            refray = reflect(ray, traceinf.norm);\n            float rf = fresnel(ray, traceinf.norm, glassMat.ior); \n            vec3 colGl = mix(col, getSkyColor(refray), 1.2*rf*glassf);\n          \n            if (!inside)\n            {\n            \tcol = colGl;\n            \tglassf*= (1.- rf);\n            }\n            #endif\n            \n            cior = inside?1./glassMat.ior:glassMat.ior;\n\n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n                inside = !inside;\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n            vec3 pos = traceinf.pos;\n\n            traceinf = trace0(pos + 0.03*ray_r, ray_r, maxdist, inside);\n            if (inside)\n                glassf*= getGlassAbsColor(distance(pos, traceinf.pos), glassMat.col_vol);\n            glassf*= glassMat.col_fil;\n            \n            col+= clamp(traceinf.col*glassf, 0., 1.);\n\n            ray = ray_r;\n        }\n        #endif\n        if (traceinf.objnr==METAL_OBJ)\n        {\n            #ifdef reflections\n            refray = reflect(ray, traceinf.norm);\n            traceinf = trace0(traceinf.pos, refray, maxdist, false);\n\n            if (traceinf.objnr!=GLASS_OBJ)\n               col+= clamp(glassf*metal_color*traceinf.col, 0., 1.);\n            glassf*= metal_color;\n            \n            ray = refray;\n            \n            #endif\n        }\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            col+= clamp(glassf*getSkyColor2(ray), 0., 1.);\n            break;\n        }\n        if (traceinf.objnr==FLOOR_OBJ)\n        {\n            #ifdef floor_reflection\n            refray = reflect(ray, traceinf.norm);\n            #ifdef antialias\n            refray.x+= 0.08*float(aai-aasamples/2)/float(aasamples-1);\n            refray.y+= 0.08*float(aaj-aasamples/2)/float(aasamples-1);\n            #endif\n           \n            float rf = fresnel(ray, traceinf.norm, 6.);\n            traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n           \n            col = mix(col, traceinf.col, rf*glassf);\n            glassf*= (1.- rf);\n            ray = refray;\n            #else\n            break;\n            #endif\n        }\n    }\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer handles the keyboard\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_PG_UP   = 33.5/256.0;\nconst float KEY_UP      = 38.5/256.0;\nconst float KEY_PG_DOWN = 34.5/256.0;\nconst float KEY_DOWN    = 40.5/256.0;\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\nconst float zfact = 1.008;\nconst float rotsstep = 0.02;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = texture(iChannel1, vec2(0., 0.)).r;\n    if (zoom==0.)\n         zoom = 1.;\n    \n    if (isKeyPressed(KEY_UP) && zoom<8.)\n       zoom*= zfact;\n    \n    if (isKeyPressed(KEY_DOWN) && zoom>0.3)\n       zoom/= zfact;\n    \n    if (isKeyPressed(KEY_PG_UP) && zoom<8.)\n       zoom*= pow(zfact, 5.);\n    \n    if (isKeyPressed(KEY_PG_DOWN) && zoom>0.3)\n       zoom/= pow(zfact, 5.);\n    \n    bool rhalf = texture(iChannel1, vec2(0., 0.)).g==1.;\n    \n    if (isKeyPressed(KEY_R) && zoom<8.)\n       rhalf = false;\n    \n    if (isKeyPressed(KEY_F) && zoom<8.)\n       rhalf = true;\n    \n    float rotspeed = texture(iChannel1, vec2(0., 0.)).b;\n    if (isKeyPressed(KEY_LEFT) && rotspeed>-1.)\n       rotspeed-= rotsstep;\n    \n    if (isKeyPressed(KEY_RIGHT) && rotspeed<1.)\n       rotspeed+= rotsstep;   \n        \n    fragColor = vec4(zoom, rhalf?1.:0., rotspeed, 0.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}