{"ver":"0.1","info":{"id":"XcccDH","date":"1730552681","viewed":230,"name":"stars 02.11","username":"nayk","description":"combination","likes":6,"published":3,"flags":1,"usePreview":0,"tags":["fractal","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n#define UVScale 3.5\n#define AnimSpeed 1.2\n#define FBM_Octaves 6\n\n//0.45 to 0.6 works good\n#define FBM_Amp 0.5\n\n\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, s, -s, c);\nreturn m * v;\n}\n\nvec2 hash22(vec2 p)\n{\nvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 noise(in vec2 p)\n{\n    vec2 ipos = floor(p);\n    vec2 fpos = fract(p);\n   \n    vec2 a = hash22(ipos + vec2(0, 0));\n    vec2 b = hash22(ipos + vec2(1, 0));\n    vec2 c = hash22(ipos + vec2(0, 1));\n    vec2 d = hash22(ipos + vec2(1, 1));\n   \n    vec2 t = smoothstep(0.0, 1.0, fpos);\n    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n}\n\nvec2 fbm(in vec2 p)\n{\n    p += 1.13;\n   \n    vec2 res = vec2(0.0);\n    float amp = 0.5;\n    float freq = 2.2;\n    for (int i = 0; i < 6; ++i)\n    {\n        vec2 n = noise(freq*p);\n        res += amp * ((1.0-abs(n *2.0 -1.0)));\n        amp *= FBM_Amp;\n        freq *= 2.03;\n    }\n    return res;\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n#define PI 3.14159265359\n\nvec3 pal2( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 4.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal2( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n #define size 100.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 36.3) * 453.2);\n    float y = fract(sin(t * 54.3) * 453.2);\n   \n    return vec2(x,y);\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(2.5, 2.5, 2.5);\n    vec3 b = vec3(2.5, 2.5, 2.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(1.263,0.416,0.557);\n\n    return a + b*cos( 60.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\n   \nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\n   float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .17)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, -si, si, co);\n   \n   \n    vec2 uv3 = fragCoord / iResolution.xy;\n uv3 = uv3 * 2.0 - 1.0;\n    uv3.x *= iResolution.x / iResolution.y; // Aspect ratio correction\n\n    // Animated light position (rotating around the center)\n    float t3 = iTime * 0.005; // Time-based animation speed\n    vec3 lightPos = vec3(sin(t3), cos(t3), 1.5); // Moving light position\n\n    // Surface normal at each point (simplified sphere shape)\n    vec3 normal = normalize(vec3(uv3, 1.0));\n\n    // View direction (camera looking towards the center)\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n\n    // Gradient background\n    vec3 backgroundColor = mix(vec3(0.1, 0.1, 0.3), vec3(0.9, 0.3, 0.5), uv3.y * 0.5 + 0.5);\n   \n    // Lighting calculations\n    vec3 lightDir = normalize(lightPos - normal);\n    float diffuse = max(dot(lightDir, normal), 0.0);\n\n    // Animated color palette for the object\n    vec3 baseColor = vec3(0.5 + 0.5 * sin(iTime), 0.5 + 0.5 * cos(iTime * 0.7), 0.7);\n\n    // Diffuse lighting (color influenced by light direction)\n    vec3 diffuseColor = diffuse * baseColor;\n\n    // Specular highlight (shiny effect)\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); // Shiny factor\n    vec3 specularColor = specular * vec3(1.0, 1.0, 1.0); // White highlight\n\n    // Fresnel effect (edge glow)\n    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);\n    vec3 fresnelColor = fresnel * vec3(0.8, 0.9, 1.0); // Light blue glow at edges\n\n    // Final color combining all effects\n    vec3 color = backgroundColor + diffuseColor + specularColor + fresnelColor;\n\n    // Apply soft glow using exponential falloff for a smooth finish\n    float glow = exp(-length(uv3) * 1.0);\n    color += glow * vec3(0.3, 1.5, 0.9)*0.001; // Add soft glow effect\nvec4 o=fragColor;\nvec2 F=fragCoord;\n vec2 R = iResolution.xy;\n    o-=o;\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \n    {   d = fract( i -3.*t );                                          \n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \n        for (int j=0 ; j++ <27; )                                      \n            c.xzyw = abs( c / dot(c,c)                                \n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                    \n    }\n\n   \n\n    vec3 col3 = vec3(0.0);\n    float tt = iTime*0.00001;\n\n    for(float i = 0.; i < size; i++)\n    {\n       vec3 col2 = palette(length(uv) + i*.4 + iTime*.004);\n\n        vec2 dir= Hash12(i+tt) -.5;\n\n        float d = length(uv-dir);\n \n        float brightness2 = 0.002+i*0.0001;\n        col3 += vec3(brightness2 / d)*color;  \n   \n    }  \n    uv*=ma;\n    float test = length(uv)-0.5;\n    uv= rotate(uv, test+(iTime/20.0)*3.1415*2.0);\n   \nvec3 dir=vec3(uv*zoom,1.);\n;\nfloat aspect = iResolution.x / iResolution.y;\n\n    vec4 col =fragColor;\n    col = vec4(2.0, 0.5, 0.2, 1.0)*0.5;\n   \n    float time = iTime *AnimSpeed;\n    vec2 x = fbm(uv);\n\n   \n   \n    x = fbm(uv + x*1.00 + 0.01*time);\n    x = fbm(uv + x*1.00 - 0.03*time);\n    x = smoothstep(-0.2,1.0,x);\n \n\nvec3 from=vec3(1.,.5,0.5)*col.xyz+o.xyz;\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=col*1.+vec4(col3.xyz*1.,1.);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 1.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.1,0.2,0.5)*0.325, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}