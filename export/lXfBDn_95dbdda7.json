{"ver":"0.1","info":{"id":"lXfBDn","date":"1728252869","viewed":87,"name":"morphing gas giant","username":"davidullmann271","description":"3D noise, followup of \"breathing planet\"","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","recursive","iterations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//feel free to use this anywhere in any way without crediting me, feel free to modify or continue it.\n//tip: it looks the best on fullscreen\n\nconst float PI = 3.1415927;\n\n// 3D hash function\nfloat hash(float n) { return fract(sin(n) * 43758.5453123); }\nfloat hash(vec3 p) { return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123); }\n\n// 3D noise function with smoother interpolation\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    // 8 corners of the cube\n    float n000 = hash(p + vec3(0.0, 0.0, 0.0));\n    float n001 = hash(p + vec3(0.0, 0.0, 1.0));\n    float n010 = hash(p + vec3(0.0, 1.0, 0.0));\n    float n011 = hash(p + vec3(0.0, 1.0, 1.0));\n    float n100 = hash(p + vec3(1.0, 0.0, 0.0));\n    float n101 = hash(p + vec3(1.0, 0.0, 1.0));\n    float n110 = hash(p + vec3(1.0, 1.0, 0.0));\n    float n111 = hash(p + vec3(1.0, 1.0, 1.0));\n\n    // Smoother interpolation (quintic)\n    vec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    float n00 = mix(n000, n100, u.x);\n    float n01 = mix(n001, n101, u.x);\n    float n10 = mix(n010, n110, u.x);\n    float n11 = mix(n011, n111, u.x);\n\n    float n0 = mix(n00, n10, u.y);\n    float n1 = mix(n01, n11, u.y);\n\n    return mix(n0, n1, u.z);\n}\n\nfloat highAmpNoise(vec3 x) {\n    return noise(x) * 1.5; \n}\n\nfloat fbm(vec3 x) {\n    float v = 0.0;\n    float a = 0.5;\n    mat3 rot = mat3(1.0);\n\n    for (int i = 0; i < 6; ++i) { \n        v += a * highAmpNoise(x);\n        x = rot * x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat domainWarping(vec3 p) {\n    float t = iTime * 0.01;  \n\n    vec3 highAmpWarp = vec3(\n        highAmpNoise(p * 0.1 + t),\n        highAmpNoise(p * 0.1 + t + 10.0),\n        highAmpNoise(p * 0.1 + t + 20.0)\n    );\n\n    vec3 q = vec3(\n        fbm(p + highAmpWarp + vec3(0.0, 0.0, 0.0)),\n        fbm(p + highAmpWarp + vec3(5.2, 1.3, 2.1)),\n        fbm(p + highAmpWarp + vec3(2.0, 3.0, 1.0))\n    );\n    vec3 r = vec3(\n        fbm(p + 2.0 * q + vec3(1.7, 9.2 + t, 4.5)),\n        fbm(p + 2.0 * q + vec3(8.3 + t, 2.8, 5.1)),\n        fbm(p + 2.0 * q + vec3(3.1, 6.2, 7.4))\n    );\n    vec3 s = vec3(\n        fbm(p + 2.0 * r + vec3(3.4, 7.1 + t, 2.3)),\n        fbm(p + 2.0 * r + vec3(5.6 + t, 1.2, 8.8)),\n        fbm(p + 2.0 * r + vec3(4.4, 2.7, 9.9))\n    );\n    return fbm(0.5 * p + 0.5 * s);\n}\n\nvec3 hexToRgb(int hexValue) {\n    return vec3(\n        float((hexValue >> 16) & 0xFF) / 255.0,\n        float((hexValue >> 8) & 0xFF) / 255.0,\n        float(hexValue & 0xFF) / 255.0\n    );\n}\n\nvec3 palette(float t) {\n    t = fract(t + sin(t * 123.456) * 0.02); \n    t = clamp(t, 0.0, 1.0);\n\n    int hexColors[5] = int[5](\n        0x2C3531, // #2C3531\n        0x116466, // #116466\n        0xD9B08C, // #D9B08C\n        0xFFCB9A, // #FFCB9A\n        0xD1E8E2  // #D1E8E2\n    );\n\n    vec3 colors[5];\n    for (int i = 0; i < 5; i++) {\n        colors[i] = hexToRgb(hexColors[i]);\n        colors[i] = mix(vec3(0.5), colors[i] * 0.9, 1.2);\n    }\n    float thresholds[15] = float[15](\n        0.07, 0.15, 0.22, 0.28, 0.35, 0.42, 0.48, 0.55, 0.62, 0.68, 0.75, 0.82, 0.88, 0.95, 1.0\n    );\n\n    if (t < thresholds[0]) {\n        return mix(colors[0], colors[1], t / thresholds[0]);\n    } else if (t < thresholds[1]) {\n        return mix(colors[1], colors[2], (t - thresholds[0]) / (thresholds[1] - thresholds[0]));\n    } else if (t < thresholds[2]) {\n        return mix(colors[2], colors[3], (t - thresholds[1]) / (thresholds[2] - thresholds[1]));\n    } else if (t < thresholds[3]) {\n        return mix(colors[3], colors[4], (t - thresholds[2]) / (thresholds[3] - thresholds[2]));\n    } else if (t < thresholds[4]) {\n        return mix(colors[4], colors[0], (t - thresholds[3]) / (thresholds[4] - thresholds[3]));\n    } else if (t < thresholds[5]) {\n        return mix(colors[0], colors[1], (t - thresholds[4]) / (thresholds[5] - thresholds[4]));\n    } else if (t < thresholds[6]) {\n        return mix(colors[1], colors[2], (t - thresholds[5]) / (thresholds[6] - thresholds[5]));\n    } else if (t < thresholds[7]) {\n        return mix(colors[2], colors[3], (t - thresholds[6]) / (thresholds[7] - thresholds[6]));\n    } else if (t < thresholds[8]) {\n        return mix(colors[3], colors[4], (t - thresholds[7]) / (thresholds[8] - thresholds[7]));\n    } else if (t < thresholds[9]) {\n        return mix(colors[4], colors[0], (t - thresholds[8]) / (thresholds[9] - thresholds[8]));\n    } else if (t < thresholds[10]) {\n        return mix(colors[0], colors[1], (t - thresholds[9]) / (thresholds[10] - thresholds[9]));\n    } else if (t < thresholds[11]) {\n        return mix(colors[1], colors[2], (t - thresholds[10]) / (thresholds[11] - thresholds[10]));\n    } else if (t < thresholds[12]) {\n        return mix(colors[2], colors[3], (t - thresholds[11]) / (thresholds[12] - thresholds[11]));\n    } else if (t < thresholds[13]) {\n        return mix(colors[3], colors[4], (t - thresholds[12]) / (thresholds[13] - thresholds[12]));\n    } else {\n        return mix(colors[4], colors[0], (t - thresholds[13]) / (thresholds[14] - thresholds[13]));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Compute distance from the center\n    float lenSq = dot(uv, uv);\n\n    if (lenSq > 1.0) {\n        // Outside the sphere, set background color\n        fragColor = vec4(0.0);\n    } else {\n        // Compute z coordinate of the sphere surface\n        float z = sqrt(1.0 - lenSq);\n\n        // Normal vector on the sphere surface (world coordinates)\n        vec3 N = vec3(uv.x, uv.y, z);\n\n        // Copy of the normal vector for texture mapping (object coordinates)\n        vec3 P = N;\n\n        // Auto-rotation based on time\n        float rotX = 0.2 * sin(iTime * 0.2); // Adjust amplitude and speed as needed\n        float rotY = iTime * 0.03;            // Adjust speed as needed\n\n        // Rotation matrices around X and Y axes\n        mat3 rotationX = mat3(\n            1.0,          0.0,           0.0,\n            0.0, cos(rotX), -sin(rotX),\n            0.0, sin(rotX),  cos(rotX)\n        );\n\n        mat3 rotationY = mat3(\n            cos(rotY), 0.0, sin(rotY),\n            0.0,       1.0,       0.0,\n           -sin(rotY), 0.0, cos(rotY)\n        );\n\n        // Apply rotations to the texture mapping coordinates\n        P = rotationY * rotationX * P;\n\n        // Adjust the scale as needed\n        float scale = 3.0;\n\n        // Compute procedural texture value using rotated coordinates\n        float n = domainWarping(P * scale);\n\n        // Get color from palette\n        vec3 color = palette(n);\n\n        // Lighting calculations\n        vec3 lightDir = normalize(vec3(-2.0, 0.8, 1.2)); // Direction of the light source\n        float diffuse = max(dot(N, lightDir), 0.0);\n\n        // Ambient light intensity\n        float ambient = 0.2;\n\n        // Combine diffuse and ambient lighting\n        float lighting = diffuse + ambient;\n\n        // Apply lighting to the color\n        color *= lighting;\n        fragColor = vec4(color, 1.0);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}