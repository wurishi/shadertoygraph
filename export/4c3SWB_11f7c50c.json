{"ver":"0.1","info":{"id":"4c3SWB","date":"1714375287","viewed":18,"name":"Playing With Perlin Noise","username":"zboumghar","description":"Implemented Perlin Noise at a basic level and used it to make an interesting looping solar system animation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","proceduralgeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* GLOBAL VARIABLES + PARAMETERS */\n\n//Parameters for our star\nvec3 starColor = vec3(1.0, 0.41, 0.0);\n\n//Parameters for our stormy planet\nvec3 stormy1Color = vec3(1.0, 0.75, 0.0);\nvec3 stormy2Color = vec3(0.85, 0.1, 0.0);\n\n//Parameters for our Earth-like planet\nvec3 ocean1Color = vec3(0.0, 0.0, 0.5);\nvec3 ocean2Color = vec3(0.0, 0.0, 1.0);\nvec3 land1Color = vec3(0.0, 0.70, 0.0);\nvec3 land2Color = vec3(0.0, 0.75, 0.0);\nvec3 cloudColor = vec3(0.9, 0.9, 0.9);\n\n//Parameters for our asteroids\nvec3 asteroid1Color = vec3(0.55, 0.55, 0.55);\nvec3 asteroid2Color = vec3(0.45, 0.45, 0.45);\nvec3 asteroid3Color = vec3(0.25, 0.25, 0.25);\n\n//Parameters for animation speed of various components\nfloat noiseSpeed = 0.05;\nfloat stormSpeed = 0.19;\nfloat cloudSpeed = 0.15;\nfloat asterSpeed = 0.25;\nfloat repeatTime = 35.0;\nfloat scrollSpeed = 0.1;\n\n//Parameters for influencing randomness\nuint hashSeed = 0x12345678U;\n\n//Parameters for 1st layer of Perlin Noise\nfloat amplitude = 2.0;\nfloat persistance = 0.5;\nfloat freq = 8.0;\nfloat lacunarity = 2.0;\nint octaves = 6;\n\n//Parameters for 2nd layer of Perlin Noise\nfloat cAmp = 4.0;\nfloat cPer = 0.5;\nfloat cFre = 16.0;\nfloat cLac = 2.0;\nint cOct = 5;\n\n//Parameters for 3rd layer of Perlin Noise\nfloat aAmp = 1.1;\nfloat aPer = 0.35;\nfloat aFre = 16.0;\nfloat aLac = 2.0;\nint aOct = 6;\n\n/* FUNCTIONS BEGIN HERE */\nuint hash(uvec2 p, uint seed) {\n    /* Take our corner vector and get a hash value */\n    uint m = 0x5bd1e995U;\n    uint hash = seed;\n    uint k = 0x00000000U;\n    \n    //Process first vector element\n    k = p.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    \n    //Process second vector element\n    k = p.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    \n\t//Final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    \n    return hash;\n}\n\nfloat fade(float t) {\n    /* Smooth out transition value for interpolation between last 2 values */\n    //Equation: 6(t^5) - 15(t^4) + 10(t^3)\n    return (6.0 * (t * t * t * t * t)) + (-15.0 * (t * t * t * t)) + (10.0 * (t * t * t));\n}\n\nvec2 gradientDirection(uint value) {\n    /* Use last four bits of hash to get gradient direciton vector */\n    switch (int(value) & 3) {\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float bL, float bR, float tL, float tR, float diff_X, float diff_Y) {\n    /* Linear interpolate bottoms and tops, then smooth interpolate for last value */\n    float outerMix = fade(diff_Y);\n    float innerMix = fade(diff_X);\n    \n    return mix(mix(bL, bR, innerMix), mix(tL, tR, innerMix), outerMix);\n}\n\nfloat Noise2D(float x, float y) {\n    /* Figure out what box our coordinates are in our grid */\n    float floor_X = floor(x);\n    float floor_Y = floor(y);\n    float diff_X = x - floor_X;\n    float diff_Y = y - floor_Y;\n    \n    vec2 botLeftTP = vec2(diff_X, diff_Y);\n    vec2 botRightTP = vec2(diff_X - 1.0, diff_Y);\n    vec2 topLeftTP = vec2(diff_X, diff_Y - 1.0);\n    vec2 topRightTP = vec2(diff_X - 1.0, diff_Y - 1.0);\n    \n    /* Get the gradient vector for each corner */\n    vec2 botLeftGV = gradientDirection(hash(uvec2(floor_X, floor_Y), hashSeed));\n    vec2 botRightGV = gradientDirection(hash(uvec2(floor_X + 1.0, floor_Y), hashSeed));\n    vec2 topLeftGV = gradientDirection(hash(uvec2(floor_X, floor_Y + 1.0), hashSeed));\n    vec2 topRightGV = gradientDirection(hash(uvec2(floor_X + 1.0, floor_Y + 1.0), hashSeed));\n    \n    /* Do the dot product */\n    float botLeftDP = dot(botLeftGV, botLeftTP);\n    float botRightDP = dot(botRightGV, botRightTP);\n    float topLeftDP = dot(topLeftGV, topLeftTP);\n    float topRightDP = dot(topRightGV, topRightTP);\n    \n    /* Interpolate the dot product values to get final noise! */\n    float noise = interpolate(botLeftDP, botRightDP, topLeftDP, topRightDP, diff_X, diff_Y);\n    \n    return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    /* Create anchor points for planets based on window size */\n    vec2 starPoint = vec2(iResolution.x * 1.4, iResolution.y / 2.0);\n    float starRadius = iResolution.y / 2.8;\n    \n    vec2 stormyPoint = vec2(starPoint.x + starRadius + (iResolution.x * 0.5), iResolution.y / 1.2);\n    float stormyRadius = iResolution.y / 9.0;\n    \n    vec2 earthPoint = vec2(stormyPoint.x + stormyRadius + (iResolution.x * 0.5), iResolution.y / 3.3);\n    float earthRadius = iResolution.y / 6.5;\n    \n    vec2 strangePoint = vec2(earthPoint.x + earthRadius + (iResolution.x * 0.5), iResolution.y / 1.35);\n    float strangeRadius = iResolution.y / 4.4;\n    \n    starPoint.x -= mod(iTime, repeatTime) * (scrollSpeed * iResolution.x);\n    stormyPoint.x -= mod(iTime, repeatTime) * (scrollSpeed * iResolution.x);\n    earthPoint.x -= mod(iTime, repeatTime) * (scrollSpeed * iResolution.x);\n    strangePoint.x -= mod(iTime, repeatTime) * (scrollSpeed * iResolution.x);\n    \n    \n    /* Normalize coordinates points */\n        //Yes, we have to do this three times since we have 3 layers of PN\n    vec2 coordNorm = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    vec2 cloudNorm = coordNorm;\n    vec2 asterNorm = coordNorm;\n    \n    /* Add offset of coordinates based on time to get animation effect */\n    coordNorm.x += iTime * noiseSpeed;\n    cloudNorm.x += iTime * cloudSpeed;\n    asterNorm.x += iTime * asterSpeed;\n    \n    /* Perlin Noise Layer 1 */\n    float total_noise = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        float noise = Noise2D(coordNorm.x * freq, coordNorm.y * freq) * amplitude;        \n        total_noise += noise;\n        \n        amplitude *= persistance;\n        freq *= lacunarity;\n        hashSeed += 0x10U;\n    }\n    \n    total_noise += 1.0;\n    total_noise *= 0.5;\n    \n    /* Perlin Noise Layer 2 */\n    float cloud_noise = 0.0;\n    for (int i = 0; i < cOct; i++) {\n        float noise = Noise2D(cloudNorm.x * cFre, cloudNorm.y * cFre) * cAmp;        \n        cloud_noise += noise;\n        \n        cAmp *= cPer;\n        cFre *= cLac;\n        hashSeed += 0x10U;\n    }\n    \n    cloud_noise += 1.0;\n    cloud_noise *= 0.5;\n    \n    /* Perlin Noise Layer 3 */\n    float aster_noise = 0.0;\n    for (int i = 0; i < aOct; i++) {\n        float noise = Noise2D(asterNorm.x * aFre, asterNorm.y * aFre) * aAmp;        \n        aster_noise += noise;\n        \n        aAmp *= aPer;\n        aFre *= aLac;\n        hashSeed += 0x10U;\n    }\n    \n    aster_noise += 1.0;\n    aster_noise *= 0.5;\n\n    /* Get coordinate position relative to planets */\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    vec2 distToStar = fragCoord - starPoint;\n    vec2 distToStormy = fragCoord - stormyPoint;\n    vec2 distToEarth = fragCoord - earthPoint;\n    vec2 distToStrange = fragCoord - strangePoint;\n    \n    /* Determine coordinate color scheme based on distance to planets */\n    if (length(distToStar) < starRadius) {\n        if (total_noise < 0.25) {total_noise = 0.25;}\n        finalColor = starColor * total_noise;\n    } else if (length(distToStormy) < stormyRadius) {\n        float color_multiplier = cos(iTime * total_noise * stormSpeed);\n        if (color_multiplier < 0.25) {\n            finalColor = stormy1Color;\n        } else {\n            finalColor = stormy2Color * color_multiplier;\n        }\n    } else if (length(distToEarth) < earthRadius) {\n        if (total_noise < 0.45) {\n            float noise_diff = 0.45 - total_noise;\n            float noise_to_apply = 1.0 - noise_diff;\n            finalColor = ocean1Color * noise_to_apply;\n        } else if (total_noise < 0.60) {\n            float noise_diff = 0.60 - total_noise;\n            float noise_to_apply = 1.0 - noise_diff;\n            finalColor = ocean2Color * noise_to_apply;\n        } else if (total_noise < 0.65) {\n            finalColor = land1Color;\n        } else {\n            finalColor = land2Color;\n        }\n\n        if (cloud_noise > 0.9998) {\n            cloudColor *= cloud_noise;\n            finalColor = mix(finalColor, cloudColor, 0.9);\n        } else if (cloud_noise > 0.945) {\n            finalColor = mix(finalColor, cloudColor, 0.8);\n        }\n    } else if (length(distToStrange) < strangeRadius) {\n        float rComponent = 1.0 * total_noise;\n        float gComponent = sin(total_noise * 6.28);\n        float bComponent = cos(total_noise * 6.28);\n        finalColor = vec3(rComponent, gComponent, bComponent);\n    }\n    \n    /* Coordinate is not within planet, so give chance of it being an asteroid */\n        //We do this OUTSIDE the previous if-statement to layer asteroids\n        //on top of the planets, creating a more realistic animation.\n    if (aster_noise < 0.01) {\n        finalColor = asteroid3Color;\n    } else if (aster_noise < 0.07) {\n        finalColor = asteroid2Color;\n    } else if (aster_noise < 0.15) {\n        finalColor = asteroid1Color;\n    }\n    \n    /* Output final results to screen! */\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}