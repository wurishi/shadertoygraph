{"ver":"0.1","info":{"id":"wtlGW7","date":"1556568234","viewed":373,"name":"Attraction","username":"dyla","description":"Experiment: storing particle system state in render buffer","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["simulation","particles","system","multipass","phsysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Particle {\n    vec2 position;\n    float radius;\n    float color;\n};\n\nParticle getParticle(int i) {\n    vec4 data = texelFetch(iChannel0, ivec2(i,10), 0);\n    return Particle(data.xy, data.z<0.0 ? -1.0 : sqrt(data.z)*0.05, data.w);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xx * 2.0 /zoom;\n    \n    float intensity = 0.0;\n \n    for (int i=0; true; i++) {\n        Particle p = getParticle(i);\n        if (p.radius<0.0) break;\n        float ip = p.color * smoothstep(-5.0/(zoom*iResolution.x),0.0, p.radius-length(uv-p.position));\n        intensity += ip;\n    }\n    \n    fragColor = vec4(intensity*0.5, intensity*0.7, intensity, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Particle {\n    vec2 position;\n    vec2 velocity;\n    float mass;\n    float color;\n};\n\nParticle getParticle(int i) {\n    vec4 pdata = texelFetch(iChannel0, ivec2(i,posRow), 0);\n    vec4 vdata = texelFetch(iChannel0, ivec2(i,velRow), 0);\n    return Particle(pdata.xy, vdata.xy, pdata.z, pdata.w);\n}\n\nfloat prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) ;\n}\n\nvec4 rand(vec2 p) {\n    return vec4(prand(p), prand(p+0.71), prand(p-0.31), prand(p+0.97));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    int index = int(fragCoord.x);\n    int row = int(fragCoord.y);\n    bool isPos = row==posRow;\n    bool isVel = row==velRow;\n    \n    if (iFrame<5) {\n        // set initial \"random\" positions, masses and colors        \n        if (index == 0) {\n            // initialize central, non-updated particle\n            if (isPos) \n            \tfragColor = vec4(0.0,0.0,25.0,2.0);\n        } else if (index<PART_CNT) {\n            // initialize normal particles\n            if (isPos) // position, mass, and color\n    \t\t\tfragColor = 2.3*(rand(fragCoord) + vec4(-0.5,-0.5,0.01,0.2));\n            else if (isVel) // velocity\n            \tfragColor = 0.5*(rand(fragCoord+0.777) - vec4(0.5,0.5,0.0,0.0));\n            else discard;\n        }  else {\n            // negative mass will be a stop condition for render shader\n            fragColor = vec4(-1.0);\n        }\n    } else if (index > 0 && index<PART_CNT) {\n        Particle thisp = getParticle(index);\n        if (isPos) {\n            // update position based on velocity\n      \t\tfragColor = vec4(thisp.position + DT*thisp.velocity, thisp.mass, thisp.color);\n        } else if (isVel) {\n            // update velocity based on force\n            vec2 force = vec2(0.0);\n            for (int i=0; i<PART_CNT; i++) {\n                Particle thatp = getParticle(i);\n                if (index==i) continue;\n                float realDistance = length(thatp.position - thisp.position);\n                if (realDistance<0.0001) continue;\n                float dist = max(realDistance, DIST_MIN);\n                float absForce = CONSTANT_MULTIPLIER * \n                    thisp.mass * thatp.mass / \n                    pow(dist, DIST_POW);\n                force += absForce * normalize(thatp.position - thisp.position);\n            }\n            fragColor = vec4(thisp.velocity + DT*force/thisp.mass, 0.0, 0.0);\n    \t} else {\n            discard;\n        }\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// number of particles\n#define PART_CNT 100\n\n// simulation time-step\n#define DT 0.05\n// #define DT (iTimeDelta * 4.0)\n\n// minimal distance used in force calculation\n#define DIST_MIN 0.05\n\n// interaction force is proportional to 1/r^DIST_POW instead of 1/r^2\n// when DIST_POW < 2.0, particles can't ecape to infinite distance\n#define DIST_POW 1.5\n\n// Final formula for interaction force: \n// CONSTANT_MULTIPLIER * m1 * m2 / pow(min(distance, DIST_MIN), DIST_POW)\n#define CONSTANT_MULTIPLIER 0.0025\n\n// buffer row for positions, mass and color\n#define posRow 10\n\n// buffer row for velocities\n#define velRow 20\n\n// display zoom level\n#define zoom 0.1","name":"Common","description":"","type":"common"}]}