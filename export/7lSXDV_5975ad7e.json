{"ver":"0.1","info":{"id":"7lSXDV","date":"1628641233","viewed":157,"name":"2x2 Bayer Dithering","username":"BrushC","description":"A super simple, super easy, and probably super inefficient implementation of 2x2 Bayer dithering. This is my first project, and I had a ton of fun writing this effect. As simple as it is, it was a fun project and I'm glad I could get it working.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["processing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --------------------------------------------------------------------------------------\n// License CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n// ----------------------------------------------------------------------------------------\n// Code by Andrew Combs (BrushC)\n\n#define ScaleFactor  0.5\n#define Gamma        2.2\n\n// Creates a 2x2 Bayer matrix\nfloat bayer_2x2( vec2 uv, vec2 res ) {\n    float y = float(int(uv.y*res.y)%2);\n    float x = float(int(uv.x*res.x+y)%2);\n    float o = x*(y*2.+1.);\n    return o/8.;\n}\n\n// Average value RGB to Grayscale\nfloat rgb_to_g( vec3 rgb ) {\n    return (rgb.r + rgb.b + rgb.g)/3.;\n    \n}\n\n// Applies Simple Greenscreen Effect\nvec3 greenscreen( vec3 front, vec3 back ) {\n    float rb_max = max(front.r, front.b);\n    float mix_fact = clamp(front.g-rb_max, 0., 1.);\n    \n    float green_diff = front.g;\n    front.g = min(front.g, rb_max*.8);\n    front += green_diff - front.g;\n    \n    return mix(front, back, mix_fact*2.);\n}\n\n// Gamma corrected RGB to Grayscale\n// Thank you to FabriceNeyret2 for optimization\nfloat rgb_to_g_corrected( vec3 rgb, float g ) {\n    return dot(vec3(.2126,.7152,.0722) , pow(rgb, vec3(g)));\n}\n\n\n// Applies Simple Greenscreen Effect with gamma correction already applied\n// Thank you to FabriceNeyret2 for optimization\nfloat greenscreen_gray( vec3 front, vec3 back ) {\n    float rb_max = max(front.r, front.b);\n    float mix_fact = clamp(front.g-rb_max, 0., 1.);\n    \n    float green_diff = front.g;\n    front.g = min(front.g, rb_max*.8);\n    front += green_diff - front.g;\n    \n    return mix(rgb_to_g_corrected(front, Gamma), rgb_to_g_corrected(back, Gamma), mix_fact);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n     \n    // CODE START\n    \n    vec3 tex_gs = texture(iChannel0, uv).rgb;\n    vec3 tex_bg = texture(iChannel1, uv).rgb;\n    \n    float tex_gray = greenscreen_gray(tex_gs, tex_bg);\n    \n    float p = bayer_2x2( uv*ScaleFactor, res );\n    float m = step(p, tex_gray);\n    \n    vec3 col = vec3(m);\n    \n    // CODE END\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}