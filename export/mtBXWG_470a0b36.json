{"ver":"0.1","info":{"id":"mtBXWG","date":"1676495766","viewed":77,"name":"frag","username":"oudend","description":"expanding circle pattern. ","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["frag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x  / iResolution.y;\n    \n    vec2 resRatio = vec2(ratio * .5, 1. / ratio);\n    \n    float centerDist = 1.-distance(uv*resRatio, vec2(.5,.5)*resRatio);\n\n    // Time varying pixel color\n    vec3 col = .5 + .8*cos(centerDist+iTime*.1*vec3(0,1,4) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n    vec4 BufferA = texture(iChannel0, uv);\n\n    fragColor = vec4(col*.1 + col*BufferA.w, 1.);\n    \n    //fragColor = BufferA;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int adjacentCount(vec2 uv, float alphaThreshold)\n{\n    //return true;\n    int count = 0;\n    \n    for(int i = -searchRadius; i <= searchRadius; i++)\n    {\n        for(int j = -searchRadius; j <= searchRadius; j++)\n        {\n            if(i == 0 && j == 0)\n            {\n                continue;\n            }\n\n            vec2 adjacentCoords = vec2(float(i),float(j))/iResolution.xy;\n\n            vec2 offsetUV = uv + adjacentCoords;\n            vec4 pixel = texture(iChannel0, offsetUV);\n\n            if(pixel.w >= alphaThreshold)\n            {\n                count++;\n                //return true;\n            }\n        }\n    }\n    return count;\n}\n\nfloat distToEdge(vec2 uv)\n{\n    return min( 1. - max(uv.x, uv.y), min(uv.x, uv.y) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x  / iResolution.y;\n    \n    vec2 resRatio = vec2(ratio * .5, 1. / ratio);\n    \n    bool initialized = iTime > 1.;\n    \n    //bool initialized2 = mod(iTime, 2.5) > 1.;\n    \n    float distanceToCenter = distance(uv*resRatio, vec2(.5,.5)*resRatio);\n    \n    if(!initialized && ( distanceToCenter < circleSize ) )// || ( distanceToCenter < circleSize + .01 && distanceToCenter > circleSize ) ) )// && uv.y == 0.)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    } else if(!initialized)\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    \n    \n    vec4 BufferB = texture(iChannel0, uv);\n    \n    int adjacents = adjacentCount(uv, .3);\n    \n    noiseThreshold = float(adjacents) / 8.;\n    \n    //if(uv.x == 0. || uv.x == 1. || uv.y == 0. || uv.y == 1.) \n    //{\n        //noiseThreshold = 10.\n    //} \n    \n    \n    //adjacents > 0\n    \n    if(BufferB.w <= .3 && gold_noise(uv, iTime+iDate.w*uv.x+uv.y ) < noiseThreshold && adjacents > adjacentThreshold)//int(mod(iTime, 3.)) == 0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0 );\n        return;\n    }\n    \n    fragColor = BufferB;\n    \n    if(fragColor.w > 0.)\n    {\n        fragColor = vec4(BufferB.xyz * decrease, max( 0., BufferB.w * decrease - .01 ) );\n    }\n    \n    //if(fragColor.w <= .1 && fragColor.w > 0. && distToEdge(uv) < .01)// && gold_noise(uv, iTime * iDate.w ) < .1 ) \n    //{\n    //    fragColor.w = 1.;\n    //}\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 BufferA = texture(iChannel0, uv);\n\n    fragColor = BufferA;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nint searchRadius = 2;\nfloat noiseThreshold = .4;\nfloat decrease = .99;\nfloat circleSize = .01;\nint adjacentThreshold = 0;","name":"Common","description":"","type":"common"}]}