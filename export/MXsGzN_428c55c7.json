{"ver":"0.1","info":{"id":"MXsGzN","date":"1707244978","viewed":43,"name":"Lets see if I can do perlin nois","username":"pathtracerenthusiast","description":"Perlin noise?? Idk if I can do it. I did it! Just had to use my own smoothstep.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653579\n\nfloat seed = 0.0;\nfloat rand(void) {\n    float p = fract(seed * .2097);\n    p *= p + 23.48;\n    p *= p + p;\n    seed += 14.2657;\n    return fract(p);\n}\n\nfloat randFrom(vec2 coord) {\n    seed = coord.x;\n    seed *= 2.0 * rand() + coord.y;\n    seed += 17.9 * rand() * (coord.x+coord.y);\n    return rand();\n}\n\nvec2 randomGrad(in vec2 coord) {\n    coord = trunc(coord);\n    float random = randFrom(coord) * PI * 2.0;\n    return vec2(cos(random),sin(random));\n}\n\nfloat dotGridGrad(vec2 cell,vec2 pos) {\n    vec2 grad = randomGrad(cell);\n    vec2 dp = pos-cell;\n    return dot(dp,grad);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + (b-a)*t;\n}\n\nfloat smoothlerp(float a, float b, float t) {\n    float w = t*t*t*(t * (t*6.0 - 15.0) + 10.0);\n    return lerp(a,b,w);\n}\n\nfloat perlin(vec2 pos) {\n    vec2 p0 = trunc(pos);\n    vec2 p1 = p0+1.0;\n    \n    vec2 dp = pos - p0;\n    \n    float n00,n10,n01,n11,i0,i1,v;\n    \n    n00 = dotGridGrad(vec2(p0.x,p0.y),pos);\n    n10 = dotGridGrad(vec2(p1.x,p0.y),pos);\n    i0 = smoothlerp(n00,n10,dp.x);\n    \n    n01 = dotGridGrad(vec2(p0.x,p1.y),pos);\n    n11 = dotGridGrad(vec2(p1.x,p1.y),pos);\n    i1 = smoothlerp(n01,n11,dp.x);\n    \n    v = smoothlerp(i0,i1,dp.y);\n    \n    return 0.5 + 0.5*v;\n}\n\nfloat FBM(int layers,float fStart,float factor,vec2 coord) {\n    float totalVal = 0.0;\n    float totalFac = 0.0;\n    float freq = fStart;\n    float amp = 1.0;\n    for (int i = 0; i < layers; i++) {\n        vec2 c = coord * freq;\n        totalVal += amp * perlin(coord*freq);\n        totalFac += amp;\n        amp /= factor;\n        freq *= factor;\n    }\n    return totalVal/totalFac;\n}\n\nvoid mainImage( out vec4 color, in vec2 fC ) {\n    vec2 uv = fC/iResolution.y;\n    float val = FBM(1,10.0,2.0,uv);\n    color = vec4(val,val,val,1.0);\n}","name":"Image","description":"","type":"image"}]}