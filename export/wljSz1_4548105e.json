{"ver":"0.1","info":{"id":"wljSz1","date":"1565107172","viewed":7462,"name":"Subsurface lattice","username":"noby","description":"Simple distance field with some pseudo-organic shading via half lambert and fake subsurface scattering. Super sampled (4x) so it's a bit slow.\n\n(If the result looks just blue try F5-ing the page a few times, it's a shadertoy bug with the volume textures).","likes":173,"published":1,"flags":0,"usePreview":0,"tags":["sss","raymarch","sdf","scattering","subsurface","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUMPY\n//#define LIGHT_SOURCE\n//#define SPLOTCHES\n//#define HIGH_CONTRAST\n\n#ifdef HIGH_CONTRAST\n#define LIGHT_SOURCE\n#endif\n\nfloat T;\nfloat hash(float x){\n    return fract(sin(x*54265.135165416));\n}\n\n// by TinyTexel, mentioned at https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\n// store the matrix globally so the 2D \"normal map\" sticks better\nmat2 R;\nfloat map(vec3 p){\n    // rotate\n    float r = 3.14159*sin(p.z*0.15)+T*0.25;\n    R = mat2(cos(r), sin(r), -sin(r), cos(r));\n    p.xy *= R;\n    vec3 op = p;\n    \n    // per-cell random values\n    float h = hash(floor(p.x+p.y+p.z));\n    float h2 = 3.141*hash(floor(-p.x-p.y-p.z));\n    \n    // bumpy\n    #ifdef BUMPY\n    float f = pow(texture(iChannel2, p*0.1).b,4.0);\n   \tvec3 dd = vec3(sin(p.z*71.), cos(p.x*73.), -cos(p.y*77.))\n               -0.6*vec3(cos(p.y*141.), sin(p.z*143.), -sin(p.x*147.));\n    p = mix(p, p-dd*0.005, f);\n    #endif\n    \n    // repeat lattice\n    const float a = 1.0;\n    p = mod(p, a)-a*0.5;\n    \n    // primitives\n    // center sphere\n    float v = length(p)-(0.02+(0.18*h*(0.6+0.4*sin(3.0*T+h2)) ));\n    // four connecting cylinders\n    v = smin(v, length(p.xy+0.01*sin(-3.2*T+13.0*op.z))-0.03, 0.2);\n    v = smin(v, length(p.xz+0.01*cos(-4.1*T+11.0*(op.y-op.z)))-0.03, 0.2);\n    v = smin(v, length(p.yz+0.01*sin(-5.0*T-8.0*(op.x-op.z)))-0.03, 0.2);\n    \n    return v;\n}\n\nvec3 normal(vec3 p){\n    mat3 e = mat3(0.001);\n    return normalize(vec3(map(p+e[0]), map(p+e[1]), map(p+e[2])) - map(p));\n}\n\nvec3 march(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 100; ++i){\n        float d = 0.5*map(p);\n        e += d;\n        if(d < 0.005 || e > 12.0)\n            break;\n        p += d*dir;\n    }\n    \n    return p;\n}\n\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 7; ++i){\n        float d = map(p);\n        e += -d;\n        if(d > -0.001)\n            break;\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\n\n// from http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n#ifdef LIGHT_SOURCE\nfloat sphere(vec3 ro, vec3 rd, vec3 pos, float r){\n    vec3 ce = ro-pos;\n    float b = dot(rd, ce);\n    return -b-sqrt(b*b-dot(ce, ce)+r*r);\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float tm = 2.0;\n    T = iTime*tm;\n    float ot = T;\n    \n    // quadratic, increase this if your gpu is gpu enough\n    const int samples = 2;\n    \n    vec3 c = vec3(0);\n    for(int y = 0; y < samples; ++y)\n    for(int x = 0; x < samples; ++x){\n        // anti-aliasing\n        vec2 p = -1.0 + 2.0 * (uv + (-0.5+(vec2(x, y)/float(samples)))/iResolution.xy);\n        p.x *= iResolution.x/iResolution.y;\n        \n        // motion blur\n        float r = texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r;\n        T = ot+(tm*r)/36.0;\n        \n        // camera setup\n        vec3 cam = vec3(0.1*sin(T*0.51),0.1*cos(T*0.59),T);\n        vec3 l = vec3(0.6*cos(T*0.83),0.6*sin(T*0.79),cam.z+3.0+0.5*sin(0.7*T));\n        //vec3 l = vec3(0.6*cos(T*0.83),0.6*sin(T*0.79),cam.z+3.0);\n    \tvec3 dir = normalize(vec3(p, 2.0)+0.1*vec3(sin(T*0.63),cos(T*0.71),0));\n        \n        // solve intersection and normal\n    \tvec3 pos = march(cam, dir);\n        vec3 mp = pos;\n        mp.xy *= R;\n        vec3 np = pos+vec3(0,0,-0.08*texture(iChannel1, mp.xy*4.0).r);\n        vec3 n = normalize(mix(normal(np), pow(texture(iChannel2, pos*2.0).xyz, vec3(2)), 0.08));\n        \n        // shade\n        vec3 ld = normalize(l-pos);\n        vec3 alb = mix((vec3(0.3,0.5,0.9)),\n                       (vec3(0.75,0.9,0.4)),\n                       texture(iChannel2, 0.04*mp).r)*1.25;\n        #ifdef SPLOTCHES\n        float mat = smoothstep(0.1,0.8,pow(texture(iChannel2, 0.14*mp).b, 3.0));\n        alb = mix(alb, vec3(0.9,0.78,0.42), mat);\n        #endif\n        float dif = 0.5+0.5*dot(n, ld);\n        \n        #ifdef SPLOTCHES\n        float spe = ggx(n, -dir, ld, mix(0.3,0.5,mat), mix(0.7,1.0,mat));\n        #else\n        float spe = ggx(n, -dir, ld, 0.3, 0.7);\n        #endif\n        float att = 1.0+pow(distance(l, pos), 2.0);\n        dif /= att;\n        spe /= att;\n        \n        // subsurface scattering\n        vec3 h = normalize(mix(-normal(pos), dir, 0.5));\n        // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n        vec4 sv = subsurface(pos+h*0.02, dir);\n        // subsurface magic term\n        float sss = max(0.0, 1.0-3.0*sv.w);\n        // light visibility across the volume\n        float ssha = max(0.0, dot(normal(sv.xyz), normalize(l-sv.xyz)));\n        sss /= att;\n        ssha /= att;\n        \n        // mix reflecting and refracting contributions\n        dif = mix(dif, mix(sss, ssha, 0.2), 0.5);\n        \n        c += alb*dif+0.025*spe;\n        \n        // draw light source\n        #ifdef LIGHT_SOURCE\n        float vs = max(0.0, sphere(cam, dir, l, 0.03));\n        float occluded = step(distance(cam, l), distance(cam,pos));\n        c += 0.4*vs * occluded;\n        vec3 e = pos - cam;\n        vec3 cp = cam + e * dot(e, l-cam) / dot(e, e);\n        c += 1.6*max(0.0, 1.0-pow(distance(cp, l), 0.1)) * (0.5+0.5*occluded);\n        #endif\n    }\n    \n\tfragColor.rgb = c/float(samples*samples);\n    \n    // \"color grade\" and gamma\n    fragColor.rgb = mix(vec3(dot(fragColor.rgb, vec3(.2125,.7154,.0721))), fragColor.rgb, 1.4);\n    #ifdef HIGH_CONTRAST\n    fragColor.rgb = smoothstep(0.12, 1.6, fragColor.rgb);\n    #else\n    // default color grading\n    fragColor.rgb = smoothstep(0.0, 1.25, fragColor.rgb);\n    #endif\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}