{"ver":"0.1","info":{"id":"4s2fRW","date":"1499767265","viewed":297,"name":"Mandelbulb morphing","username":"Slyth","description":"Basic mandelbulb ray tracing","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n\t\treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+4.0,0);\n}\n\nvec2 obj_sphere(in vec3 p, float r)\n{\n    return vec2(length(p) - r, 0);\n}\n\nvec2 obj_mandel(in vec3 p, in float power)\n{\n    float angle = radians(45.0);\n    mat3 rot = mat3(cos(angle), -sin(angle), 0,\n                    0, 0, 1,\n                    sin(angle), cos(angle), 0);\n    vec3 z = p * rot; // remove rot to see real mandelbulb. rotation is glitchy.\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++) {\n\t\tr = length(z);\n\t\tif (r>4.0) break;\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=p;\n\t}\n\treturn vec2(0.5*log(r)*r/dr, 1.0);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n    float power = (sin(iTime * 0.1 + 40.0) + 1.0) * 0.5 * 12.0 + 1.0;\n  \treturn obj_union(obj_floor(p), obj_mandel(p / 3.0, power));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t );\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distance_to_obj( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 floor_color(in vec3 p)\n{\n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n\treturn 0.3 + 0.1 * f * vec3(1.0);\n}\n\nvec3 prim_c(in vec3 p)\n{\n    float d = obj_sphere(p, 1.0).x;\n  \treturn vec3(d / 5.0, d / 2.0, d / 3.0); // simplistic orbit trap coloring to darken towards center\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,0,0);\n\n\tvec3 prp = vec3(sin(iTime*0.15) * 6.0, 2.0, cos(iTime * 0.15) * 6.0); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(sin(iTime * 0.5) * 7.0, 3.0, -cos(iTime * 0.5) * 7.0);\n  \tvec3 fogColor = vec3(0.5,0.6,0.7);\n    vec3 lightColor = vec3(0.8);\n\n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    float stepDist = 0.9;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p);\n            N = vec3(0.0, 1.0, 0.0);\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(N, lightDir), 0.0);\n\t\tvec3 diffuse = 0.3 + diff * lightColor; \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0625, length(lightPos-p), 128.0 );\n        float ambient = 0.15;\n        float ao = calcAO(p, N);\n        \n        float fogAmount = 1.0 - exp(-sqrt(p.x * p.x + p.z * p.z) * 0.065 );\n    \tfragColor = vec4(mix(c * diffuse * (ao * 1.0) * (vis + 1.3) + ambient, fogColor, fogAmount), 1.0);\n  }\n  else \n    fragColor = vec4(fogColor,1);\n    \n}","name":"Image","description":"","type":"image"}]}