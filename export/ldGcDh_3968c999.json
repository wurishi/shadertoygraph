{"ver":"0.1","info":{"id":"ldGcDh","date":"1521776176","viewed":3881,"name":"Favela","username":"duvengar","description":"It's crazy how drawing into small hexagons, can be fun and obsessive! I hope you guys like it. ","likes":122,"published":1,"flags":64,"usePreview":0,"tags":["2d","fisheye","night","tiling","hexagons","house","day","building","favela"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sBSDw","filepath":"https://soundcloud.com/dj-schasko/dj-schasko-bossa-and-brazilian","previewfilepath":"https://soundcloud.com/dj-schasko/dj-schasko-bossa-and-brazilian","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Favela by Julien Vergnaud @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n///////////////////////////////////////////////////////////////////////////////////////////\n// Based on the Minimal Hexagonal Grid example from @Shane.\n\n\n// Minimal Hexagonal Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst vec2 s = vec2(1, 1.7320508);\n\nfloat hex(in vec2 p)\n{\n    \n    p = abs(p);\n    \n    return max(dot(p, s *.5), p.x );\n}\n\nvec4 getHex(vec2 p)\n{  \n \n    vec4 hC = floor(vec4(p, p - vec2(.5, 1)) / s.xyxy) + .5;\n\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define M(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define S(a, b, c) smoothstep(a, b, c)\n#define SAT(a) clamp(a, .0, 1.)\n#define T iTime\n#define PI acos(-1.)\n#define TWO_PI (PI * 2.)\n#define SIZE .4\n#define BLUR .02\nconst float LOWRES = 50.;\n\nfloat rem(vec2 iR)\n{\n    float slices = 10. * floor(iR.y / LOWRES);\n  \n    return  sqrt(slices);\n}\n\nfloat stripes( vec2 uv, mat2 rot, float num, float amp, float blr){\n    \n    uv *= rot;\n    float v =  smoothstep(amp+blr, amp - blr,  length(fract(uv.x * num)-.5));\n   // uv *= M(.02);\n    float h =  smoothstep(amp+blr, amp - blr,  length(fract(uv.x * num )-.5));\n    return h;\n}\n\nfloat dfDiamond (vec2 h) {\n    h *= s;\t\t\t\t\t\t\t\t\t// rescale diamond verticaly with the helper vector\n \tvec2 p =  vec2(abs(h.x), abs(h.y));\n    float d = (p.x+p.y)/.5; \n    //return S(.2,.9,length(d));\n     return d;\n}\n\nfloat rect(vec2 uv,vec2 p, float w, float h, float b){\n    \n    uv += p;\n    float rv = S(h, h + b, length(uv.x));\n    float rh = S(w, w + b, length(uv.y));\n    return rv + rh;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n    \n//  set up pixel coord\n//  ------------------\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    //uv *= M(.25 * cos(PI) * .5 * length(uv));                     // twist the pixels domain\n    uv *= 1.1;                                                   // scale up the pixels domain\n   \tuv *= M(PI);                                                 // rotate the pixels domain\n    //uv *= .8+dot(uv*.3,uv*.3);                                   // length distortion\n\n//  ------------------------------------------------------------------------------------------------\n//  variables\n//  ------------------------------------------------------------------------------------------------\n    float motion =  T * .5;\t\t   // speed\n    float SCALE = rem(iResolution.xy)*SIZE;    // screen rescaling ratio\n    //float blr = BLUR;\t\t\t\t           // blur value\n    float blr = fwidth(uv.x)*length(uv)*8.;\n   // blr = S(.0,1.,length(uv)*.13);\n    vec2 pos = uv - motion;\t\t\t\t\t   // position\n    vec3 lights = vec3(.0);\n    vec3 blights = vec3(.0);\n    float sun = cos(T*.3);\n    \n//  Hexagons grid\n//  -------------\n    vec4 h = getHex( pos + SCALE * uv + s.yx); // hexagons center\n    float eDist = hex(h.xy);                   // hexagone Edge distance.   \n\tfloat eDist2 = hex(h.xy + vec2(.0,.25));\n    float cDist = length(h.xy);                // @Shane: cDist = dot(h.xy, h.xy);  \n    \n    float tilt  = hash2(h.zw*2376.345791);     // random value depending on cel ids\n    \n\n//  ------------------------------------------------------------------------------------------------    \n//  sorting the hexagons\n//  ------------------------------------------------------------------------------------------------\n\n    //  hexagons states booleans\n//  ------------------------\n    float hills = .0;\n    float red = .0;\n    float flip = .0;\n    float empty = .0;\n    float tex = .0;\n\tfloat wnds = .0;\n    float tree = .0;\n    float doors = .0;\n\n//  wich tile are flipped?\n//  ----------------------\n    float ff = cos(5. * sin(h.z - h.w)*tilt);\n    if( ff > .0)\n    {\n       flip = 1.;\n       h.xy *= M(PI); \n       empty = ff > .99 ? 1. : .0;\n    } \n        \n        \n//  polar coordinates + cubes faces angles\n//  --------------------------------------\n    vec2 pol  = vec2(atan(h.x, h.y) / TWO_PI + .5, length(uv));\n    vec2 ang = vec2(.333333, .666666);\n    \n    if(pol.x <=  ang.x || tilt >= .7)\n    { \n        wnds = 1.;\n        if(tilt >=.9)\n        {\n            doors = 1.;\n        }\n    }\n    \n//  wich tiles are hills?\n//  ---------------------\n    if (flip == .0 && noise(h.zw)*.5 > .3){\n    \thills = 1.;\n        tree = tilt >.5 ? 1. : .0;\n    }\n\n//  ------------------------------------------------------------------------------------------------    \n//  create the windows elements \n//  ------------------------------------------------------------------------------------------------    \n    \n   \tvec2 pat = h.xy;                                                              // original position (up lozenge in the hexagon)\n    vec2 pat2 = h.xy-(vec2(flip == 1. ? .05 : - .05,flip == 1. ? .03 : - .03));   // offseted and rotated position on the right side\n    vec2 pat3 = h.xy-(vec2(flip == 0. ? .05 :  -.05, flip == 1. ? .05 : - .05));  // offseted and rotated position on the left side\n     \n    float s1 = stripes(pat, M(.0)*M(.02), flip == 1. ? 2.: 4., .3, blr );         // vertical stripes\n    float s2 = stripes(pat, M(TWO_PI*.666)*M(.02), 4., .3, blr );                 // oriented stripes\n    \n    float s3 = stripes(pat, M(TWO_PI*.333 )*M(.02), 4., .3, blr );\n    float s4 = stripes(pat, M(.0)*M(.02), flip == 1. ? 4.: 2., .3, blr );\n    \n    float m1 = stripes(pat2, M(.0)*M(.02), flip == 1. ? 2.: 4., .3, blr );\n    float m2 = stripes(pat2, M(TWO_PI*.333 )*M(.02), 4., .3, blr );\n    \n    float ml1 = stripes(pat3, M(.0)*M(.02), flip == 1. ? 4.: 4., .3, blr );\n    float ml2 = stripes(pat3, M(TWO_PI*.666)*M(.02), 4., .3, blr );\n    \n    float windowsR = min(s1,s3);                    // windows on the Right side\n    float windowsL = min(s4,s2);                    // windows on the Left side\n    \n    float maskR = min(m1,m2);                       // offseted Right windows\n    float maskL = min(ml1,ml2);                     // offseted Left windows\n    \n    float winnerR = min(windowsR, maskR);           // cuted Right inner windows\n    float winnerL = min(windowsL, maskL);           // cuted Left inner windows\n    \n    float wbevelR = min(windowsR,windowsR-winnerR); // cuted Right bevel\n    float wbevelL = min(windowsL,windowsL-winnerL); // cuted Left bevels\n//  blured windows\n//  --------------\n    \n    float blr2 = BLUR * 8.;\n    float bs1 = stripes(pat, M(.0)*M(.02), flip == 1. ? 2.: 4., .3, blr2 );         // vertical stripes\n    float bs2 = stripes(pat, M(TWO_PI*.666)*M(.02), 4., .3, blr2 );                 // oriented stripes\n    \n    float bs3 = stripes(pat, M(TWO_PI*.333 )*M(.02), 4., .3, blr2 );\n    float bs4 = stripes(pat, M(.0)*M(.02), flip == 1. ? 4.: 2., .3, blr2 );\n    \n    float bm1 = stripes(pat2, M(.0)*M(.02), flip == 1. ? 2.: 4., .3, blr2 );\n    float bm2 = stripes(pat2, M(TWO_PI*.333 )*M(.02), 4., .3, blr2 );\n    \n    float bml1 = stripes(pat3, M(.0)*M(.02), flip == 1. ? 4.: 4., .3, blr2 );\n    float bml2 = stripes(pat3, M(TWO_PI*.666)*M(.02), 4., .3, blr2 );\n    \n    \n    \n    float bwindowsR = min(bs1,bs3);                    // windows on the Right side\n    float bwindowsL = min(bs4,bs2);                    // windows on the Left side\n    \n    float bmaskR = min(bm1,bm2);                       // offseted Right windows\n    float bmaskL = min(bml1,bml2);                     // offseted Left windows\n    \n    float bwinnerR = min(bwindowsR, bmaskR);           // cuted Right inner windows\n    float bwinnerL = min(bwindowsL, bmaskL);           // cuted Left inner windows\n       \n//  ------------------------------------------------------------------------------------------------      \n//  shading the cubes faces\n//  ------------------------------------------------------------------------------------------------    \n\n//  noise texture\n//  -------------\n    vec3 col = vec3(1.);\n    float n1 = .5-(fbm(((uv -motion*.24)* 20.)));\n    float n2 = .5-(fbm(((uv -motion*.31)* 5.)));\n    col += .4 * (max(n1,n2));\n\n    \n//  painting\n//  --------\n    vec3 paint = vec3(cos(h.z + h.w *.2),cos(tilt)*.3,noise(h.zw));\n     \n//  lightning\n//  ---------\n    vec2 facespos = h.xy;\n    facespos *= M(TWO_PI*ang.x);\n    \n    vec2 fa = facespos;\n    float shw = .7 * S(1.1+ blr, 1.-blr, dfDiamond(facespos - (vec2(.0, .3))));\n    facespos *= M(TWO_PI*ang.x);\n    \n    vec2 fb = facespos;\n    shw += .2 * S(1.1+blr, 1.-blr, dfDiamond(facespos - (vec2(.0, .3))));\n    col -= shw;\n   \n    \n    float fao = clamp(smoothstep(1.,.0,eDist), .0, 1.);                  // Fake lightning gradient \n    //fao = hills == 1. ? fao * 1.5 : fao;\n    fao = flip == .0 || empty == .1 ?  .65 * fao :  .65 * (1.-fao);                      // apply it as a shadow or light on the cubes\n\tcol -= fao;\n    col = mix(col,vec3(.7,.3,.0),.45);\n  \n//  face 01 (right)\n//  --------------   \n    if(pol.x <=  ang.x )\n    {    \n \t\tif ( hills == .0)\n        {\n        \tcol = tilt > .2  ? col :  col +.3 * paint ;\n        \tvec2 dir =  cos(T + h.z) > .0 ? M(PI/3.)*h.xy : -M(PI/3.)*h.xy;\n        \tfloat blink = S(1.,.9,fract(dir.x*2.)* 3.333 -.5)-.5;\n   \t\t\t\n            float on = S(-1.,1.,sun);\n            float light = (-1. + tilt * floor(on*10.) > .0 ? blink : -1.);\n            light = empty == 1. ? -.5 : light;\n            float lum = light > .0 ? -.1 : .3;\n        \n            col -= tilt > .0 ? lum * wbevelR : .0;\n        \tcol += tilt > .0 ? light * winnerR : .0;\n            \n            \n            lights += tilt > .0 ? light * winnerR : .0;\n            blights += tilt > .8 && flip == 1.? light * bwinnerR : .0;\n            \n            float t1 = stripes(pat - vec2(.01,.0), M(.0)*M(.02), 8., .05, blr*2. );\n        \tfloat tt = stripes(pat - vec2(fract(M(-PI*.666)*pat*8.).x >.5 ? .20 : .01,.00), M(.0)*M(.02), 8., .05, blr*2. );\n    \t    float t2 = stripes(pat - vec2(-.19,.01), M(TWO_PI*.333)*M(.02),   16.  , .05, blr*2. );\n            col += hills == .0 ? .1*(t2+tt)* pow(noise((uv-motion*.15)*20.),1.5) : .0;\n            \n            \n        }\n        else\n        {\n        \tcol = mix(col,vec3(.52,.13,.01), .5);   \n   \t    \tcol = mix(col, vec3(.5,.45,.1), 1.-S(.1,.3,length(h.y - fb.y)));\n            \n        }\n    }\n    \n//  face 02 (left)\n//  ---------------\n    if(pol.x >= ang.y)     \n    { \n        col += tilt > .2 ? vec3(.0) : .3 * paint ;\n        vec2 dir =  cos(T + h.z) > .0 ? M(PI)*h.xy : -M(PI)*h.xy; \n        float blink = S(1.,.9,fract(dir.x*2.)* 3.333 -.5)-.5;\n        float on = S(-1.,1.,sun);\n        float light = .5*(-1. + tilt * floor(on*10.) > .0 ? blink : -1.);\n        col = hills == 1. ? mix(col,vec3(.52,.13,.01), .5) : col;  \n        col =  hills == 1. ? mix(col, vec3(.5,.45,.1), 1.-S(.1,.3,length(h.y - fa.y))) : col;      \n        col += tilt > .8 && flip == 1. ? light * winnerL : .0;\n        col += tilt > .8 && flip == 1. ? light*.3 * wbevelL : .0;\n        lights += tilt > .8 && flip == 1.? light * winnerL : .0;\n        blights += tilt > .8 && flip == 1.? light * bwinnerL : .0;\n//      walls texture\n        float t1 = stripes(pat - vec2(.01,.0), M(.0)*M(.02), 8., .05, blr*2. );\n        float tt = stripes(pat - vec2(fract(M(-PI*.333)*pat*8.).x >.5 ? .20 : .01,.00), M(.0)*M(.02), 8., .05, blr*2. );\n    \tfloat t2 = stripes(pat - vec2(-.19,.01), M(TWO_PI*.666)*M(.02),   16.  , .05, blr*2. );\n        \n        col += hills == .0 ? .15*(t2+tt)* pow(noise((uv-motion*.15)*20.),1.5) : .0;\n//      doors        \n        vec2 pos1 = vec2(.25,.0);\n        vec2 pos2 = vec2(.215,.0);\n        float door = stripes(pat + pos1 , M(.0)*M(.02), 1., .05, blr);\n        float doorcut = 1.-stripes(pat + pos1 , M(TWO_PI*.666)*M(.02), 1., .18, blr);\n        float maskcut = 1.-stripes(pat + pos2 , M(TWO_PI*.666)*M(.02), 1., .18, blr);\n        float doormask = stripes(pat + pos2 , M(.0)*M(.02), 1., .05, blr);\n        door =  min(door,doorcut);\n        doormask = min(doormask, maskcut);\n        float dbevel = SAT(min(door,door-doormask));\n        col += doors == 1. && flip == .0 && hills == .0 ? dbevel * .2 : .0;\n        col += doors == 1. && flip == .0 && hills == .0? doormask * .4 : .0;\n       \n    }\n    \n    \n//  face 03 (top)\n//  -------------\n    if(pol.x > ang.x && pol.x < ang.y)\n    { \n        if (hills == 1.){\n        col += .1 * vec3(.5,.45,.1); \n        float grass = 1.-S(1.1+blr, .5-blr, dfDiamond(h.xy - vec2(.0, .3)));\n        col = mix(vec3(.5,.45,.1),col,1.-grass);     \n        }\n    }\n    \n//  face 04 (inside)\n//  ----------------\n    vec2 ang2 = ang + vec2(-.1665,.1665);\n    if(pol.x  <= ang2.x  || pol.x >= ang2.y)\n    { \n    }\n\n//  trees  \n//  -----\n    \n    if ( tree == 1.)\n    {\n        float tw = .07;\n        float crown = S(.25+blr,.25,eDist2);\n      \n        float trunk = S(tw+blr, tw, hex(h.xy - vec2(.0, .0)));\n        trunk = max(trunk,S(tw+(blr*.5), tw, hex(h.xy - vec2(.0, .5*tw*2.5))));\n        trunk = max(trunk,S(tw+(blr*.5), tw, hex(h.xy - vec2(.0, .5*tw*5.))));\n        trunk = max(trunk,S(tw+(blr*.5), tw, hex(h.xy - vec2(.0, .5*tw*7.5))));\n\t\t\n        float a = pol.x < .5 ? 2.5 : .5 ;\n        col = mix(col,vec3(.5,.3,.2),trunk*a);\n        col = mix(col,vec3(.55,.6,.3),crown);  \n        \n        float shw = .2 * S(.5 + (blr*3.), .5 - blr, dfDiamond(fb + (vec2(.22, .02))));\n        shw += .35 * S(.5 + (blr*3.), .5 - blr, dfDiamond(fa - (vec2(.22, -.02))));\n        \n        col -= shw;\n        \n    }\n    if(hills == 1.0)\n    {\n    \tcol -= fao*.2;\n    }    \n//  Roof top\n//  --------\n\n    vec2 frh = fract(h.xy * 2.);\n    float d1 = S(.8+blr, .8-blr, dfDiamond(h.xy - vec2(.0, flip*.3)));\n    float d2 = S(.8+blr, .8-blr, dfDiamond(h.xy - vec2(.0, flip*.2)));\n    \n    if (hills == 1.)\n    {\n \t\tcol  += .08*(.6-hash2(uv*34869.54334));      \n    }\n    \n    if(hills == .0 && flip == 1.)\n    {   \n\t\tif (empty == .0)\n        {            \n       \t\tfloat shw = pol.x < .5 ? .33 : .15 ;\n        \tcol -= shw *(d1-min(d1,min(d1,d2))); // inner bevel\n            if( tilt > .7)\n            {\t\n                vec2 wtp = vec2(.0,-.2);\n                vec2 wtp2 = vec2(.0,-.58);\n                vec2 wtp3 = vec2(.0,-.25);\n            \tfloat watertank = S(.02,.02-(blr*.5),dot(h.xy*s + wtp, h.xy*s + wtp));\n                float watertanktop = S(.02,.02-(blr*.5),dot(h.xy*s + wtp2, h.xy*s + wtp2));\n                float watertanktop2 = S(.016,.016-(blr*.5),dot(h.xy*s + wtp2, h.xy*s + wtp2));\n                float watertankside = 1. - rect(h.xy, wtp3, .1,.125, blr);\n                watertank = max(watertank,watertanktop);\n                watertank = min(d1,watertank);\n                watertankside = SAT(watertankside);\n                float wtglobal = max(watertank, min(d1,watertankside));\n                \n                col = mix(col,vec3(.2,.32,.45),wtglobal);\n                col -= watertanktop2 * .15;\n                col += max(watertank,watertankside) * S(.0,.15,length(h.x-.05))*.15;\n            } else {\n            \tif(tilt > .3 )\n                {\n                    vec2 fanpos = vec2(-.1,-.35);\n                    float fan = S(.125,.125-blr,hex(h.xy + fanpos));\n                    col = mix(col,vec3(1.),fan);\n                    col = mix(col,.95*vec3(.9,.75,.6),fan);\n                    float ff1 = dfDiamond(fa.xy + vec2(.35,.015));\n                    float ff2 = dfDiamond(fb.xy - vec2(.255,-.19));\n                    col -= vec3(.45*S(.26,.26-(blr*2.),ff1));\n                    col -= vec3(.2*S(.26,.26-(blr*2.),ff2));\n                }\n            }\n            \n            \n            \n        } else {\n            float shw = pol.x < .5 ? .4 : .15 ;\n        \tcol -=  shw * d1;                    // empty houses\n            \n        }\n    } \n     \n    \n    // postprocessing\n    \n    \n    col /=1.1-.2;\n    col += mix(.15 * S(.0,6.,length(uv*s)), -.8 * S(.0,6.,length(uv*s)), sun);\n    col = clamp(col,vec3(.15), vec3(1.));\n    vec3 day = col;\n    vec3 night = col;\n    night = mix(day, vec3(.2,.5,.9),.5);\n    \n    night = pow(night, vec3(3.));\n    night += SAT(lights);\n    night += SAT(blights)*4. ;\n    \n    vec3 final = mix(day,night,S(-1., 1.,sun));\n    \n    \n    // color output\n\n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// hash2 taken from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash2(vec2 p)\n{\n    \n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n///// NOISE /////\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453123);   \n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\n////// FBM ////// \n// see iq // https://www.shadertoy.com/view/lsfGRr\n\nmat2 m = mat2( 0.6, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p){\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= m * 2.02;\n    f += 0.2500 * noise(p); p *= m * 2.03;\n    f += 0.1250 * noise(p); p *= m * 2.01;\n    f += 0.0625 * noise(p); p *= m * 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n/////////////////////////////////////////////////////////////////////\n// iq's cosine palette function\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}","name":"Common","description":"","type":"common"}]}