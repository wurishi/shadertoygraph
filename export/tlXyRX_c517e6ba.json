{"ver":"0.1","info":{"id":"tlXyRX","date":"1592586369","viewed":93,"name":"RainbowDisc_veryUnoptimized","username":"Mukul","description":"Just something I felt is interesting which came out of me practicing glsl fragment shaders.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circle","rainbow","concentric","polarform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159;\nconst float twoPI = 2.0*PI;//6.28318\n\nconst float PIbyThree = PI/3.0;\nconst float twoPIbyThree = twoPI/3.0;\nconst float fourPIbyThree = 4.0*PI/3.0;\nconst float fivePIbyThree = 5.0*PI/3.0;\n\nfloat diatance(vec2 p1, vec2 p2){\n    return (\n        sqrt(\n            pow((p2.y - p1.y),2.0) + pow((p2.x - p1.x),2.0)\n    ));\n}\n\n//Translating Points at an angle w.r.t center point using polar form of a straight line in 2D geometry\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 FragCoord = fragCoord.xy;\n    vec2 res = iResolution.xy;\n    float diagonal = distance(vec2(0.0,0.0),res);\n    vec2 center = vec2(res.x/2.0,res.y/2.0);\n\tcenter.x += res.x * 5.4 * sin(iTime/3.0);center.y += res.y * 5.4 * cos(iTime/3.0);\t//--rotating the center\n    float \tdist = distance (FragCoord,center),\n        \tR=0.0,G=0.0,B=0.0,tmp, grad1, grad2;\t\t\t\t\t\t\t\t\t\t\t\n    float angle = atan((FragCoord.y - center.y) , (FragCoord.x - center.x));\n        \n    angle = mod((angle + iTime),twoPI);\t//--small increment to angle to show animation, negate addition to\n    \t\t\t\t\t\t\t\t\t\t\t//  rotate counter Clockwise\n    //**new method using smoothstep, I tried pls point out anything bad.\n    R = (angle <= twoPIbyThree && angle >= 0.0)? 1.0 : 0.0;\n    R += smoothstep(fivePIbyThree, twoPI, angle);\n    tmp = ( smoothstep(twoPIbyThree, PI, angle)); \n    R += (((tmp < 1.0 && tmp > 0.0) && R == 0.0)? 1.0-tmp : 0.0);\n    \n    \n    G = (angle <= fourPIbyThree && angle >= twoPIbyThree)? 1.0 : 0.0;\n    tmp = smoothstep(PIbyThree, twoPIbyThree, angle);\n    G += (((tmp < 1.0 && tmp > 0.0) && G == 0.0)? tmp : 0.0);\n    tmp = (smoothstep(fourPIbyThree, fivePIbyThree, angle) ); \n    G += (((tmp < 1.0 && tmp > 0.0) && G == 0.0)? 1.0-tmp : 0.0);\n    \n    B = (angle <= twoPI && angle >= fourPIbyThree)? 1.0 : 0.0;\n    tmp = smoothstep(PI, fourPIbyThree, angle);\n    B += (((tmp < 1.0 && tmp > 0.0) && B == 0.0)? tmp : 0.0);\n    tmp = (smoothstep(0.0, PIbyThree, angle)); \n    B += (((tmp < 1.0 && tmp > 0.0) && B == 0.0)? 1.0-tmp : 0.0);\n    \n    \n    //**old method - scrapped, tho still works\n    //if(angle >= twoPIbyThree && angle < fourPIbyThree){\n    //    G = 1.0;\n    //}\n    //else if((angle < twoPIbyThree && angle >= PIbyThree)){\n    //    G = (angle - PIbyThree) / (PIbyThree);\n    //}\n    //else if (angle > fourPIbyThree && angle <= fivePIbyThree){\n    //    G = 1.0 - (angle - fourPIbyThree) / (PIbyThree);\n    //}\n    //\n    //if(angle >= fourPIbyThree && angle < twoPI){\n    //    B = 1.0;\n    //}\n    //else if(angle > 0.0 && angle <= PIbyThree){\n    //    B = 1.0 - (angle) / (PIbyThree);\n    //}\n    //else if(angle > PI && angle <= fourPIbyThree){\n    //    B = (angle - PI) / (PIbyThree);\n    //}\n    \n    //R +=  - sin(iTime) * dist/diagonal;\n    //G +=  - sin(iTime + 2.0*PI/3.0) * dist/diagonal;\n    //B +=  - sin(iTime + 4.0*PI/3.0) * dist/diagonal;\n    \n    // My old experiment, I don't even know how I came up with this.\n\ttmp = mod(dist + 1000.0*pow(sin(iTime/5.0)+1.0,2.0),50.0 + 50.0*cos(iTime/5.0));\n    //** I don't know how to use smoothstep to reduce jaggered edges from circles\n    /*if( tmp <= 10.0 ){\t\n        grad1 = smoothstep(0.0,1.0,(tmp*tmp)/150.0);\n        tmp = 10.0-tmp;\t//reverse gradient for inner edge\n        grad2 = smoothstep(0.0,1.0,(tmp*tmp)/150.0);\n        \n        tmp = (grad1 + grad2);\n        //tmp/2.0 to give lighter, more transparent look\n        R += smoothstep( 0.0,1.0, tmp/2.0);\n        G += smoothstep( 0.0,1.0, tmp/2.0);\n        B += smoothstep( 0.0,1.0, tmp/2.0);\n    }*/\n    \n    vec3 color;\n    color = vec3(R,G,B);\n\tcolor *= ((sin(iTime))+2.0);\t//dancing color pellets\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}