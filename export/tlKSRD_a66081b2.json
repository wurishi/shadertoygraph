{"ver":"0.1","info":{"id":"tlKSRD","date":"1582323236","viewed":262,"name":"Some Water Ripples","username":"stduhpf","description":"Water ripples using simulated 2D wave equation.\nWith the shadertoy browser extension you can increase the amount of \"print calls\" wich allow to reduce the value of dt in Buffer A, for a faster and more precise simulation.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["wave","simulation","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup camera\n    vec3 rd = getRd(fragCoord,iResolution.xy);\n    \n    // intersect water surface plane\n    float d = getD(rd);\n    if(d>0.){\n        // get UV coordinates on water surface\n        vec2 p = getP(d,rd,iResolution.xy);\n        // get wave data from texture\n        fragColor = texture(iChannel0,p.xy);\n        vec3 n = normalize(vec3(fragColor.gb,1.)); //normal mapping using spatial derivatives\n        float f0 = 0.0209731878419714;\n        // schlick approximation for fresnel effect\n        float fresnel = ((1.0 - f0) * pow(1.0 - max(dot(-rd, n), 0.0), 5.0) + f0);\n        // Shade the image using Cubemap reflection and refraction\n        #if 1\n        fragColor.rgb = mix(vec3(.1,.11,.16)+vec3(.85,.84,.8)*\n                       \ttexture(iChannel1,refract(rd,n,1./1.333).yzx).rgb,\n        \t\t\t\ttexture(iChannel1,reflect(rd,n).yzx).rgb,\n                        fresnel);\n                        \n        #else\n        // this is supposed to be the correct way of shading this image because of the gamma correction,\n        // but somehow it looks worse, probably because of the bad dynamic range of the cubemap \n        fragColor.rgb = pow(\n                        mix(pow(vec3(.1,.11,.16)+vec3(.85,.84,.8)*\n                       \ttexture(iChannel1,refract(rd,n,1./1.333).yzx).rgb,vec3(2.2)),\n        \t\t\t\tpow(texture(iChannel1,reflect(rd,n).yzx).rgb,vec3(2.2)),\n                        fresnel),\n                        vec3(1./2.2));\n        #endif\n        //if(fract(p.xy+vec2(.5,0.))!=p.xy+vec2(.5,0.)) fragColor*=.75;\n    }else{\n        fragColor = texture(iChannel1,rd.yzx);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 getGradient(vec2 p,int c){\n    vec2 dxh = vec2(1.,0.);\n    float dfx = texture(iChannel0,(p+dxh)/iResolution.xy)[c]-texture(iChannel0,(p-dxh)/iResolution.xy)[c];\n    float ddx = .5*dfx/dxh.x;\n    float dfy = texture(iChannel0,(p+dxh.yx)/iResolution.xy)[c]-texture(iChannel0,(p-dxh.yx)/iResolution.xy)[c];\n    float ddy = .5*dfy/dxh.x;\n    \n    return vec2(ddx,ddy);\n}\n\nvec2 get2ndDeriv(vec2 p, int c){\n    //based on lagrangian interpolation, then derived twice\n        vec2 dxh = vec2(1,0.);\n    float u = texture(iChannel0,p/iResolution.xy)[c];\n    float dfx = texture(iChannel0,(p+dxh)/iResolution.xy)[c]-\n        2.*u\n        +texture(iChannel0,(p-dxh)/iResolution.xy)[c];\n    float ddx = dfx/(dxh.x*dxh.x);\n    \n    float dfy = texture(iChannel0,(p+dxh.yx)/iResolution.xy)[c]-\n        2.*u\n        +texture(iChannel0,(p-dxh.yx)/iResolution.xy)[c];\n    float ddy = dfy/(dxh.x*dxh.x);\n\n    return vec2(ddx,ddy); \n}\n\n\nvec2 dsmoothstep(float edge0, float edge1, float t){\n\tt = clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n\treturn vec2(t*t*(3.0-2.0*t),6.0*t*(1.0-t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float dt = 1./(60.);\n    //retrieving last frame's state from texture (height and time partial derivative)  \n    vec4 tmp = texture(iChannel0,fragCoord/iResolution.xy);\n\tfloat u = tmp.x;    \n    float dudt = tmp.a;\n    \n    //vec2 ddudx2 = vec2(getGradient(fragCoord,1).x,getGradient(fragCoord,2).y);\n\n    \n    //computing first and second order spatial partial derivativesd for this frame\n    vec2 ddudx2 = get2ndDeriv(fragCoord,0);\n    vec2 dudx = getGradient(fragCoord,0);\n    \n    // speed of propagation\n    float c = 30.;\n    \n    // updating verical speed (time derivative)\n    // https://en.wikipedia.org/wiki/Wave_equation\n    // vertical acceleration is c²*(d²u/dx²+d²u/dy²), so multiplying this by frametime gives the change in speed\n    dudt+=c*c*dot(ddudx2,vec2(1.))*dt;\n    \n    //updating height value\n    u+=dudt*dt;\n    // attenuation (energy gets lost over time)\n    u*=exp(-dt*.002);\n    //dudt+=100.*dot(ddudx2,vec2(1.))*dt;\n    /*\n    if(iFrame<2){\n        vec2 c = fragCoord-iResolution.xy*.5;\n        float ph = length(c)*.1;\n        vec2 mask = dsmoothstep(200.,0.,length(c));\n     \tu=cos(ph)*mask.x;\n        dudt = 0.*(-sin(ph)*mask.x+cos(ph)*mask.y);\n    }*/\n    \n    // default behaviour\n    if(iMouse.x<=0.&&(distance(fragCoord,iResolution.xy*.5))<2.){\n        float w = 9.;\n        float A =3.;\n        u=A*sin(w*dt*float(iFrame));\n        dudt = -A*cos(w*dt*float(iFrame))/(w);\n    }\n    // handle mouse interacions\n    if(iMouse.z>0.){\n        // project click coords onto water surface UV using a raycast\n        vec3 rd = getRd(iMouse.xy,iResolution.xy);\n    \n        vec2 p = getP(getD(rd),rd,iResolution.xy);\n\n        // add perturbation to water surface around the clicking position.\n        float A = smoothstep(15.,2.,distance(fragCoord,fract(p.xy)*iResolution.xy));\n     \t//dudt=mix(dudt,1.5/sqrt(dt),A);\n        u=mix(u,-1.5,A);\n    }\n    \n    // raindrop effect  (disabled)\n    #if 0\n    if(hash11(float(iFrame)*.1)<.01*dt){\n        float A = smoothstep(15.,2.,distance(fragCoord,hash21(float(iFrame)*.3)*iResolution.xy));\n     \tdudt=mix(dudt,.75*sqrt(dt),A);\n        u=mix(u,-2.,A);\n    }\n    #endif\n    \n    // write relevant data to texture for next frae and for visualisation.\n    fragColor = vec4(u,dudx,dudt)*exp2(-dt/60.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CAM_HEIGHT .25\n\n#define CAM_ROTATION vec2(0,-.85) \n\nconst mat3 rot = mat3(1,0,0,0,cos(CAM_ROTATION.y),sin(CAM_ROTATION.y),0,-sin(CAM_ROTATION.y),cos(CAM_ROTATION.y))\n    * mat3(cos(CAM_ROTATION.x),0,sin(CAM_ROTATION.x),0,1,0,-sin(CAM_ROTATION.x),0,cos(CAM_ROTATION.x));\n\nvec3 getRd(vec2 uv,vec2 res){\n    \n    return normalize(vec3(uv-res.xy*.5,-res.x*.2))*rot;\n}\n\nfloat getD(vec3 rd){\n    return -CAM_HEIGHT/rd.z;\n}\n\nvec2 getP(float d, vec3 rd,vec2 r){\n    vec2 a = r.yx/r.x;\n    return (vec3(0,0,CAM_HEIGHT)+d*rd).xy*a;\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}","name":"Common","description":"","type":"common"}]}