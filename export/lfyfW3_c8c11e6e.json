{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//References \n//https://www.shadertoy.com/view/XlcBR7\n\n#define FAR 50.\n#define PI 3.14159265358979\n\n#define AA 1\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat crystal(vec3 p, float scale){\n  float d = sdBox(p, vec3(scale));\n  for(float k=1.; k<5.; k++){\n    float cs = scale*(1.-0.2*k);\n    float offset = -scale-cs+scale*0.1*k;\n    //array of vec3\n    vec3[3] dirs = vec3[3](vec3(1., 0., 0.),vec3(0., 1., 0.),vec3(0., 0., 1.));\n    for(float i = -1.; i<=1.; i+=2.){\n      for(int j = 0; j<3; j++){\n        float d2 = sdBox(p+dirs[j]*i*offset, vec3(cs));\n        d = max(-d2, d);\n      }\n    }\n  }\n  return d;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(42.2347, 43.4271))) * 342.324234);   \n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n\nfloat map(vec3 _p){\n \n  float d = 10.;\n  for(float i=1.; i<4.; i++){\n     vec3 l = vec3(1.0,0.0,1.);\n    for(float j=1.; j<10.; j++){\n    vec3 s = vec3(0.5/i, 0.5/i, 0.5/i);\n    vec3 p = _p - vec3(0.,i*0.01,0.) + hash31(j)*vec3(1., 1., 1.);\n    vec3 q = p - s*clamp(round(p/s), -l*i, l*i);\n    vec2 id = round(p.xz/s.xz);\n    float off = hash12(id)*0.1/i;\n    float d2 = sdBox(q+vec3(0.,off,0.), vec3(0.15/i));\n    //much beter but computationally expensive\n    //float d2 = crystal(q+vec3(0.,off,0.), 0.15/i);\n    d = min(d, d2);\n    }\n  }\n\n  return d;\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n        h = map(ro+rd*t);\n        if(h<0.002 || t>FAR) break; \n        t += h*.8;\n    }\n    return t;\n}\n\nvec3 calcNormal(in vec3 p){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n//Color palette function taken from iq's shader @ https://www.shadertoy.com/view/ll2GD3\n#define  pal(t) ( .5 + .5* cos( 6.283*( t + vec4(0,1,2,0)/3.) ) )\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n//with soft shadow diff spec\nfloat shading (in vec3 sp, in vec3 sn, in vec3 ld, in vec3 rd){\n    float diff = clamp(dot(sn, ld), 0., 1.);\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n    float shadow = calcSoftshadow(sp, ld, 0.01, 10.);\n    return clamp((diff*0.1+spec)*shadow, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n  vec3 tot = vec3(0.);\n  for( int m=0; m<AA; m++ ){\n    for( int n=0; n<AA; n++ )\n    {\n      // Screen coordinates.\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n      vec2 uv = ((fragCoord+o) - iResolution.xy*0.5)/iResolution.y;\n      \n      // Camera Setup.\n      vec3 lookAt = vec3(-0.5, -0.5, -0.5); \n      vec3 ro = lookAt + vec3(1.8*cos(iTime*0.2), 1.5*sin(iTime*0.1), 1.8*sin(iTime*0.2)); \n        float FOV = PI/3.; \n        vec3 forward = normalize(lookAt-ro);\n        vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n        vec3 up = cross(forward, right);\n        vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n        float t = trace(ro, rd);\n      vec3 col = vec3(0.);\n      \n      if(t < FAR){\n          vec3 sp = t * rd+ro;\n          vec3 sn = calcNormal(sp);\n          float ao = calculateAO(sp, sn);\n          float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n          float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n          sn += tex3D(iChannel0, sp, sn)*0.05;//randomize normal\n          vec3 ld = normalize(vec3(0.3, 1., 0.3));\n          float shadow = shading(sp, sn, ld, rd);\n          //on every vertex of cube\n          vec3[8] lights = vec3[8](vec3(-1., -1., -1.), vec3(-1., -1., 1.), vec3(-1., 1., -1.), vec3(-1., 1., 1.),\n                                    vec3(1., -1., -1.), vec3(1., -1., 1.), vec3(1., 1., -1.), vec3(1., 1., 1.));\n          for(int i = 0; i<8; i++){\n            float sh = shading(sp, sn, normalize(lights[i]*1.5-sp), rd);\n            shadow += sh;\n          }\n          // vec3 lp = vec3(-1.0, -1.5, -1.0);\n          // vec3 ld2 = normalize(lp-sp);\n          // float shading2 = shading(sp, sn, ld2, rd);\n          // vec3 lp2 = vec3(1.0, 1.5, -1.0);\n          // vec3 ld3 = normalize(lp2-sp);\n          // float shading3 = shading(sp, sn, ld3, rd);\n          \n          float tex = tex3D(iChannel0, sp, sn).x;\n          vec3 albedo = pal(fre+crv*0.5+ao*2.+tex*0.2).xyz;\n          col = albedo*(shadow*ao+fre);\n          float edge = (curve(sp, 0.01)-5.); //reduce noise by subtraction\n          col -= vec3(max(edge, 0.)*0.003);\n          col = pow( col, vec3(0.4545) );//gamma\n      }\n      tot += col;\n    }\n  }\n  #if AA > 1\n  tot /= float(AA*AA);\n  #endif\n\tfragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyfW3","date":"1734509446","viewed":88,"name":"Iridescent Bismuth","username":"Nekodigi","description":"Thin film was simulated using color mapping of fresnel and some offset.\nAdding noise to the normal resulted in variance of reflection strength which simulate imperfectioness of material.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","metal","material","film","hologram","iridescent","ore"],"hasliked":0,"parentid":"","parentname":""}}