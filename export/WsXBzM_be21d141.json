{"ver":"0.1","info":{"id":"WsXBzM","date":"1587866626","viewed":158,"name":"Texture interpolation filters","username":"tyrells","description":"Examples of nearest neighbor, bilinear, bicubic and quilez texture interpolation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interpolationfiltering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Converts a color from linear light gamma to sRGB gamma\nvec4 fromLinear(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n// Converts a color from sRGB gamma to linear light gamma\nvec4 toLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n// Only makes sense for non nearest-neighbour filter (e.g. bilinear)\nvec4 nnFilter(in vec2 uv)\n{\n    vec2 nnCoord = floor(uv * iChannelResolution[0].xy) + vec2(0.5);\n    return texture(iChannel0, nnCoord / iChannelResolution[0].xy);\n}\n\n// Does NOT require linear filter (replicates one)\n// Source: https://stackoverflow.com/questions/43482392/what-algorithm-does-gl-linear-use-exactly\nvec4 blFilter(in vec2 uv)\n{\n    // subtract 0.5 here and add it again after the floor to centre the texel\n    vec2 texCoord = uv * iChannelResolution[1].xy - vec2(0.5);\n    vec2 s0t0 = floor(texCoord) + vec2(0.5);\n    vec2 s0t1 = s0t0 + vec2(0.0, 1.0);\n    vec2 s1t0 = s0t0 + vec2(1.0, 0.0);\n    vec2 s1t1 = s0t0 + vec2(1.0);\n\n    vec4 c_s0t0 = texture(iChannel1, s0t0 / iChannelResolution[1].xy);\n    vec4 c_s0t1 = texture(iChannel1, s0t1 / iChannelResolution[1].xy);\n    vec4 c_s1t0 = texture(iChannel1, s1t0 / iChannelResolution[1].xy);\n    vec4 c_s1t1 = texture(iChannel1, s1t1 / iChannelResolution[1].xy);\n    \n    vec2 weight = fract(texCoord);\n    \n    vec4 c0 = c_s0t0 + (c_s1t0 - c_s0t0) * weight.x;\n    vec4 c1 = c_s0t1 + (c_s1t1 - c_s0t1) * weight.x;\n    \n    return (c0 + (c1 - c0) * weight.y);\n}\n\nvec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}\n\n// Requires linear filter\n// Source: http://www.java-gaming.org/index.php?topic=35123.0\n// TODO: needs to be fixed, not looking right\nvec4 bicubicFilterTest(in vec2 uv)\n{\n    vec2 invTexSize = 1.0 / iChannelResolution[0].xy;\n    vec2 texCoords = uv * iChannelResolution[0].xy - vec2(0.5);\n    \n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n    \n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n    \n    vec4 c = texCoords.xxyy + vec2(-0.5, +1.5).xyxy;\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;\n    \n    offset *= invTexSize.xxyy;\n    vec4 sample0 = texture(iChannel0, offset.xz);\n    vec4 sample1 = texture(iChannel0, offset.yz);\n    vec4 sample2 = texture(iChannel0, offset.xw);\n    vec4 sample3 = texture(iChannel0, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n    \n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvoid weights(out vec4 x, out vec4 y, vec2 t)\n{\n   vec2 t2 = t * t;\n   vec2 t3 = t2 * t;\n\n   vec4 xs = vec4(1.0, t.x, t2.x, t3.x);\n   vec4 ys = vec4(1.0, t.y, t2.y, t3.y);\n\n   const vec4 p0 = vec4(+0.0, -0.5, +1.0, -0.5);\n   const vec4 p1 = vec4(+1.0,  0.0, -2.5, +1.5);\n   const vec4 p2 = vec4(+0.0, +0.5, +2.0, -1.5);\n   const vec4 p3 = vec4(+0.0,  0.0, -0.5, +0.5);\n\n   x = vec4(dot(xs, p0), dot(xs, p1), dot(xs, p2), dot(xs, p3));\n   y = vec4(dot(ys, p0), dot(ys, p1), dot(ys, p2), dot(ys, p3));\n}\n\nvec4 bicubicFilterReference(in vec2 uv)\n{\n   vec2 texCoord = uv * iChannelResolution[1].xy - vec2(0.5);\n   vec2 texel = floor(texCoord);\n   vec2 tex = (texel + 0.5) / iChannelResolution[1].xy;\n   vec2 phase = texCoord - texel;\n\n#define TEX(x, y) textureLodOffset(iChannel1, tex, 0.0, ivec2(x, y)).rgb\n\n   vec4 x;\n   vec4 y;\n   weights(x, y, phase);\n\n   vec3 color;\n   vec4 row = x * y.x;\n   color  = TEX(-1, -1) * row.x;\n   color += TEX(+0, -1) * row.y;\n   color += TEX(+1, -1) * row.z;\n   color += TEX(+2, -1) * row.w;\n\n   row = x * y.y;\n   color += TEX(-1, +0) * row.x;\n   color += TEX(+0, +0) * row.y;\n   color += TEX(+1, +0) * row.z;\n   color += TEX(+2, +0) * row.w;\n\n   row = x * y.z;\n   color += TEX(-1, +1) * row.x;\n   color += TEX(+0, +1) * row.y;\n   color += TEX(+1, +1) * row.z;\n   color += TEX(+2, +1) * row.w;\n\n   row = x * y.w;\n   color += TEX(-1, +2) * row.x;\n   color += TEX(+0, +2) * row.y;\n   color += TEX(+1, +2) * row.z;\n   color += TEX(+2, +2) * row.w;\n\n   return vec4(color, 1.0);    \n}\n    \n\n// Source: https://iquilezles.org/articles/texture\nvec4 quilez(in vec2 uv)\n{\n\tvec2 texCoords = uv * iChannelResolution[0].xy + vec2(0.5);\n\tvec2 iuv = floor( texCoords );\n\tvec2 fuv = fract( texCoords );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5) / iChannelResolution[0].xy;\n\treturn texture( iChannel0, uv );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    if (fract(iTime) < 0.5)\n    \tfragColor = quilez(uv);\n    else\n    \tfragColor = bicubicFilterReference(uv);\n}","name":"Image","description":"","type":"image"}]}