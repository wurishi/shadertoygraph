{"ver":"0.1","info":{"id":"Nl2cWw","date":"1649887785","viewed":187,"name":".motion","username":"xrx","description":" ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["dither","motion","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//motion integration by sampling at frame t, equal step subframe, and rand diffuse.\n\n//- pause for frame view\n//- m.x - pixel render probability 0..2 (0..1 skips pixels to maintain 60fps)\n//- m.y - subframe sampling 0..32\n\nfloat gamma = 2.25;\n\n//------------------------------------------------------------------------- \nvoid mainImage( out vec4 C, in vec2 p){\n    ivec2 ip = ivec2(p);\n    C = ip.y>0? texelFetch(iChannel0,ip,0): vec4(.1); // excl temp vars\n    C = pow(C,vec4(1./gamma));    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--------------------------------- imports\n// iq\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&0x7fff; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame ){\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n\n\n//---------------------------------\n#define PI acos(-1.)\n#define PI2 (PI*2.)\n\nmat2 rotx(float t){  return mat2(cos(t), -sin(t), sin(t), cos(t)); }\n//float wavesignal(float t, float f) {return -cos(t*PI2*f)*.5+.5;}\nfloat wavesignal(float t,  float f) {return sin(t*PI2*f);}\nvec2 wavesignal(float t,  vec2 f) {return vec2(wavesignal(t,f.x), wavesignal(t,f.y)); }\n//float wavesignal2(float f) {return 1.-abs(fract(iTime*f)*2.-1.);}\nfloat powexp2(float x, float e){return pow(x, exp2(e));}\nfloat signal_pwr(float t, float f, float pp){\n    t *= f;\n    t = fract(t);\n    t = t<.5?t:1.-t;\n    f = pow(t*2., pp);\n    return f;\n}\n\n\n\n//---------------------------------\nfloat fmax = 60.; // max rev \nfloat fscene = 1./30.;\n\n// has to be non random\nfloat angle_add(float t, float dt){\n    //vec2 r = iResolution.xy;\n    //vec2 m = iMouse.xy/r;//*2.-1.;\n\n    float f = 1.;\n    //f = wavesignal(t, 1./20.);    f = powexp2(abs(f),2.)*sign(f);\n    f = signal_pwr(t,fscene, 4.);\n    f*= fmax;\n    //f*= .25;\n    //f*= 1e3;\n    \n    //f=1.;\n    //f=60.; // tst\n    //f=60./1.; // tst\n    //f = 60./4.;\n    //f+=1./60.; //sec\n    \n    return PI2*dt*f;\n}\n\n\n/*\nfloat shk(float t){\n    float u1= 1.;\n    //u1*=wavesignal(t, 8.);\n    u1*= powexp2(-cos(t*PI2*fscene)*.5+.5, 6.);\n    u1*= .25;\n    //u1*=0.;\n    return u1;\n}\n*/\n\n/*float shk2(float t){\n    float u1= wavesignal(t, 1.2*8.);\n    u1*= powexp2(-cos(t*PI2*fscene*1.)*.5+.5, 6.);\n    u1*= .1;\n    u1*=0.;\n    return u1;\n}*/\n\nvec2 shake(float tr){\n    //return vec2(0);\n    return .25*\n        powexp2(-cos(tr*PI2*fscene)*.5+.5, 6.)* \n        vec2(cos(tr*PI2*8.),sin(tr*PI2*8.*4.));\n}\n\nfloat scene_circle(vec2 p, vec2 c, float rad){\n    vec2 r = iResolution.xy; \n    float m = min(r.x,r.y)/2.;\n    //p-=vec2(-.5,0);\n    //float d = smoothstep(r, r+.01, length(p - c));\n    //float d = smoothstep(1., 0., abs(length(p - c)-rad)*m-0.);\n    float d = smoothstep(1., 0., (length(p - c)-rad)*m-0.);\n    //float a = abs(length(p-c)-r)/(.1*r); a = clamp(a,0.,1.);\n\treturn d;\n}\n\nvec4 scene(vec2 u, float t){ \n    //if (abs(u.x)>.49*1.5) return vec4(0);\n    //if (abs(u.y)>.49) return vec4(0);\n \n    float rev = texelFetch(iChannel1,ivec2(0,0),0).x; // prev rev at iTime\n    //float t0 = texelFetch(iChannel1,ivec2(0,0),0).y;\n    float a  = rev*PI2 + angle_add(t, t-iTime); a=-a;\n    //t+= iTimeDelta*frand();\n\n    \n    vec4 c = vec4(0);\n    //for(int i=0; i<samples; i++){\n    // -----------------------------------------------------------------\n    if (1==1){ // circle\n        //float sr = .45*(wavesignal(t,  fmax*2.22));\n            //vec4 c2;\n            //c2= mix(vec4(1,0,0,0),vec4(0,1,0,0),wavesignal(t,  fmax*3.33)*.5+.5);\n            //c2 = iFrame%2>0?vec4(1,0,0,0):vec4(0,1,0,0);\n        c+=scene_circle(u-vec2(0,.5), .5*vec2(cos(a),sin(a)), 0.025)                          *vec4(1);\n        c+=scene_circle(u-vec2(0,.5), (sin(t*PI2* 1.)*.5+.5)*.5*vec2(-sin(a), cos(a)), 0.025) *vec4(1,0,0,0);\n        c+=scene_circle(u-vec2(0,.5), (sin(t*PI2* 2.)*.5+.5)*.5*vec2(-cos(a),-sin(a)), 0.025) *vec4(0,1,0,0);\n        c+=scene_circle(u-vec2(0,.5), (sin(t*PI2* 4.)*.5+.5)*.5*vec2(sin(a), -cos(a)), 0.025) *vec4(0,0,1,0);\n    }\n    // -----------------------------------------------------------------\n    if (1==1){ // tex\n        vec2 loc = rotx(a)*(u-vec2(.0,-.5));\n        loc+=vec2(.5);\n        if (loc.x>0. && loc.y>0. && loc.x<1. && loc.y<1.)\n        c+=pow(texture(iChannel0,fract((loc))), vec4(2.2));   \n        //c*=.25;\n    }\n    return c;\n}\n\n\nvec4 scene_motion(vec2 u0, float t0/*, int ii*/){\n    vec2 r = iResolution.xy; \n    vec2 asp = r/min(r.x,r.y);    \n    int samples = 1<<4;\n\n\tvec4 c = vec4(0);\n    for(int i=0; i<samples; i++){ // not internal\n        //srand(ivec2(u0*2000.), iFrame*1+i);\n        \n        //float tr = t; \n        //float tr = t-iTimeDelta*frand(); \n        //float tr = t-iTimeDelta*((float(i)+frand())/float(ii)); //nop? introduce linearity into average\n        vec2 u;\n        float t;\n        //-------------\n        t = t0;\n        u = u0; u+= shake(t);\n        //if (u.x<0. && u.y>0.)     c += scene(u-vec2(-.5,.5)*asp, t);                                 // LU steps\n        if (u.x<0.) c += scene(u-vec2(-.5,.0)*asp, t);                                 // LU steps\n        //-------------\n        //if (u.x>0. && u.y>0.)     c += scene(u-vec2(.5,.5)*asp, t-iTimeDelta*float(i)/float(ii));  // RU sub-steps \n        //if (u.x>0. && u.y>0.)     c += scene(u-vec2(.5,.5)*asp, t-iTimeDelta);                       // RU  sub-steps \n        t = t0+ iTimeDelta*frand();\n        u = u0; u+= shake(t);\n        if (u.x>0.) c += scene(u-vec2(.5,-.0)*asp, t);                                // LL rand diffuse\n        //-------------\n    }\n    c/= float(samples);\n    return c;\n}\n\n\n\nvoid mainImage(out vec4 C, vec2 p){\n    //p = p+.5;\n\tvec2 r = iResolution.xy; ivec2 ir = ivec2(r);    ivec2 ip = ivec2(p);\n    \n    srand(ip, iFrame%3600);\n    //p+= vec2(frand(), frand())-.5; // rand pix\n    vec2 u =(2.*p-r)/min(r.x,r.y);    \n    //vec2 m = iMouse.xy/r;\n    \n    //float t = 0.; t+= iTime; t+=iTimeDelta; \n    float t = iTime; //t+=iTimeDelta; \n\n    //float fpsratio =m.x*2.; if(m==vec2(0)) fpsratio = 1.;\n    //float prob = frand();\n   \n    //int s = 1;\n    //if ((iloc.y%(s*s))==(iFrame%(s*s))){\n    //if (((iloc.x+iloc.y*s)%(s*s))==(iFrame%(s*s))){\n    //if (filt<1./float(s*s)){\n    //if (prob<fpsratio){\n    if (1==1){\n       \n        //int ii = 1;// multisample average (more stable)\n        //ii = int(m.y*32.); if(m==vec2(0)) ii = 1<<5;\n        \n        \n        float tadj = 0.;\n        //tadj = float(iFrame%(s*s))/float(s*s)*iTimeDelta;\n        //tadj = iTimeDelta*frand(); //not here\n        \n        vec4 c = scene_motion(u, t-tadj/*, ii*/);//-tadj\n       /* if (0==1 &&  !(iMouse.z>0.)){\n            c*=vec4(.1,.1,1,0);\n            float dt1= powexp2(-cos(T*PI2*1./30.)*.5+.5, 6.-2.);\n            c += scene_motion(u+vec2(0,1)*.0, T-iTimeDelta*.1*dt1)*vec4(.1,1,.1,0);\n            c += scene_motion(u+vec2(0,1)*.0, T-iTimeDelta*.2*dt1)*vec4(1,.1,.1,0);\n        }*/\n        C = c;\n        //if (iloc.x<s && iloc.y<s) C = vec4(1);\n    }else{\n        // reproj\n        C = texelFetch(iChannel1,ip,0); \n        //if (iloc.x<s && iloc.y<s) C = vec4(0);\n    }\n    //if (iloc.y==0) C = iloc.x==iFrame%s?vec4(1):vec4(0);\n\n    // store temp vars\n    if (ip==ivec2(0,0)) {\n        // prev rev\n        float rev = texelFetch(iChannel1,ivec2(0,0),0).x; // iTime-iTimeDelta\n        //float t0 = texelFetch(iChannel1,ivec2(0,0),0).y;\n        \n        // next rev\n        rev += angle_add(t, iTimeDelta)/PI2; \n        rev = fract(rev);//req\n        C = vec4(rev,t,0,0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}