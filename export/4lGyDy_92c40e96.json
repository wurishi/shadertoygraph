{"ver":"0.1","info":{"id":"4lGyDy","date":"1537504134","viewed":1587,"name":"Cloud-VolumeRender","username":"senzheng","description":"test","likes":39,"published":1,"flags":32,"usePreview":1,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat godRays(vec2 uv, vec2 sunPos)\n{\n    \n   \tfloat ra =0.0;\n   \tvec2 p = uv-sunPos;\n    float add = hash(uv*4000.)*.02;\n    //add = 0.0;\n    \n    \n \tfor (float x = .1; x < 1.; x+=.02)\n\t{\n\t\tfloat z = max(textureLod(iChannel0,sunPos+(p*(x+add)), 0.).w, 10.0)-10.;\n\t\tra += z*x;\n\t}\n   \n    return ra*0.0001;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/ iResolution.xy;\n    \n    vec2 sunPos2 = (-iResolution.xy + 2.0*iMouse.xy)/ iResolution.y;\n    sunPos2.x *= iResolution.y / iResolution.x;\n    sunPos2 = (sunPos2 + vec2(1.0) ) / 2.0;\n    \n    vec3 col = textureLod(iChannel0, uv, 1.0).xyz;\n    float d = textureLod(iChannel0, uv, 1.0).w;\n    \n    float gr = godRays(uv, sunPos2);\n    gr = pow(gr, 0.5);\n    \n    //fragColor = vec4(vec3(d/17.0), 1.0);\n    //fragColor = vec4(vec3(gr), 1.0);\n    fragColor = vec4(col + vec3(gr), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 sunColor = vec3(1.0, 0.4, 0.15);\n\n//----------------------------------------------------\n// 2D texture based 3 component 1D, 2D, 3D noise\n// From Mu6k https://www.shadertoy.com/view/XsSGDy\n\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){\n    float m = mod(p.z,1.0);\n    float s = p.z-m; \n    float sprev = s-1.0;\n    if (mod(s,2.0)==1.0) { \n        s--; sprev++; m = 1.0-m; \n    };\n    return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);\n}\n\n//----------------------------------------------------\n// SDF Function from iq\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//------------------------------------------------------------------\n// SDF Boolean Operations Function from iq\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += (noise(x).x*2.0-1.0)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nvec3 fbm3(in vec3 x)\n{\n    vec3 rz = vec3(0.);\n    float a = .45;\n    for (int i = 0; i<3; i++)\n    {\n        rz += (noise(x)*2.0-1.0)*a;\n        a*=.3;\n        x*= 4.;\n    }\n    return rz;\n}\n\nfloat map(vec3 p) {\n    \n    p += fbm3(p/2.0 - vec3(iTime))*8.;\n    \n    float den = 0.;\n    float d = sdSphere(p, 2.);\n    d = opU(d, sdSphere(p + vec3(0., 0.0, 0.), 4.) );\n    den = -d + fbm(p);\n    \n    return den/2.;\n    \n}\n\nfloat calcuShadow(in vec3 pos, vec3 sunPos) {\n    float step = 0.1;\n    float t = 0.1;\n    float shad = 1.0;\n    vec3 sunDir = normalize(sunPos - pos);\n    for (int i = 0 ; i < 3 ; i++) {\n    \tfloat den = map(pos + t*sunDir);\n        shad -= exp(-t)*den*0.08;\n        t += step;\n    }\n    shad = min(1.0, max(0.0, shad));\n    return shad;\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 sunPos, out float d) {\n\tvec4 sum = vec4(0.0);\n    float tmin = 3.;\n    float t = tmin;\n    float step = 0.1;\n    \n    for (int i = 0 ; i < 128 ; i++) {\n        if (sum.a > 0.99) break;\n        \n    \tvec3 pos = ro + rd * t;\n        float den = map(pos);\n        \n        if (den > 0.01) {\n            // Basic Color\n            vec4 col = vec4( vec3(0.93), den );\n            \n            // Shading\n            float shad = calcuShadow(pos, sunPos);\n            col.rgb *= shad;\n            col.xyz += sunColor  * pow( (1.0 - shad), 1.8) * 2.5;\n            \n            // Bleanding\n            col.a *= 0.5;\n            col.rgb *= col.a;\n            sum += col*(1.0-sum.a)*step*10.;\n        }\n        if (d == 0.0 && sum.a > 0.1)\n            d = t;\n        \n        step = max(0.1, 0.01*(t-tmin));\n        t += step;\n    }\n    if (d == 0.0)\n        d = t ;\n    return sum;\n}\n\nvec4 render(vec3 ro, vec3 rd, vec3 sunPos) {\n    \n    float d = 0.0;\n    \n    // Background Color\n    vec3 skyColor = mix(vec3(0.9, 0.82, 0.82), vec3(0.7, 0.9, 0.95), rd.y+0.6);\n    skyColor = pow(skyColor, vec3(2.2));\n    \n    vec3 sunDir = normalize(sunPos - ro);\n    float sun = clamp( dot(sunDir, rd), 0.0, 1.0 );\n    sun = pow(sun, 8.0) * 0.05 + pow(sun, 16.0) * 0.18 + pow(sun, 128.0) * 0.25;\n    vec3 col = skyColor + sunColor * sun;\n    \n    \n    // Cloud Color\n    vec4 res = raymarch( ro, rd, sunPos, d );\n    col = col*(1.0 - res.w) + res.xyz;\n    \n    // Add some fake light effect just like the light penetrates clouds\n    col += sunColor * sun * 0.45;\n    \n    col = pow(col, vec3(2.2));\n\treturn vec4(col, d);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    \n     // Camera\n    vec3 ro = vec3(sin(iMouse.x / iResolution.x*3. + iTime*0.0) * 9., 0.0, cos(iMouse.x / iResolution.x*3. + iTime*0.0) * 9.);\n\tvec3 ta = normalize(vec3(0.0, 0.0, 0.0));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // SunPos\n    vec2 sunPos2 = (-iResolution.xy + 2.0*iMouse.xy)/ iResolution.y;\n    vec3 sunPos = ca * normalize( vec3( sunPos2, 1.5 ) ) * 80.0;\n    \n    // Ray\n    vec3 rd = ca * normalize( vec3( uv.xy, 1.5 ) );\n    \n    fragColor = render( ro, rd, sunPos );\n}","name":"Buffer A","description":"","type":"buffer"}]}