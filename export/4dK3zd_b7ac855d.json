{"ver":"0.1","info":{"id":"4dK3zd","date":"1456009951","viewed":957,"name":"texture2D bias illustration","username":"Hamneggs","description":"What does that third parameter even do, anyway? This shader demonstrates what effect positive values of bias do to texture lookups, and also conveniently allows you to view mipmaps. (On my machine there's 10.)","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["text","texture2d","bias","mipmaps","illustration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: MIT\n\n// Let's create some definitions to make iChannelX assignment more memorable.\n#define TEXTURE iChannel0\n#define LABEL_BUFFER iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized texture coordinates.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Illustrative values.\n    float miplevel_cont = uv.x*10.0;\t\t\t// Discretely stepped.\n    float miplevel_disc = floor(miplevel_cont);\t// Continuous range.\n    \n    // Go ahead and arithmetically OR these two together in different areas of the screen.\n    float miplevel = miplevel_cont*step(uv.y,.25) // discrete * (is .25 greater than our current uv.y?)\n                   + miplevel_disc*step(.75,uv.y);// continuous * (is our current uv.y greater than .75?)\n    \n    // Load texture elements.\n    vec4 mips  = texture(TEXTURE, uv, miplevel); // Oh look! Check out that snazzy third parameter!\n    vec4 label = texture(LABEL_BUFFER, uv, 0.0); // The freshly outlined label.\n    \n    // The final color is the image, unless the label's alpha is nonzero. (Alpha blending).\n    fragColor = mix(mips,label,label.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tThis buffer just draws the text that labels each mipmap level. Pay it no mind.\n\tOr if you want to know how it works, go to gerardgeer.com/bittext\n\tP_Malin came up with the technique, but I wrote you guys an explanation.\n*/\n\n#define _f float\n// Just the characters for 'CONTINUOUS' and 0-9\nconst highp _f CH_C    = _f(0xe111e), CH_I    = _f(0xf444f), CH_N    = _f(0x9bd99), \n\t\t\t   CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_R    = _f(0x79759),\n    \t\t   CH_O    = _f(0x69996), CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), \n    \t\t   CH_U    = _f(0x99996), CH_0    = _f(0x6bd96), CH_1    = _f(0x46444), \n    \t\t   CH_2    = _f(0x6942f), CH_3    = _f(0x69496), CH_4    = _f(0x99f88), \n     \t\t   CH_5    = _f(0xf1687), CH_6    = _f(0x61796), CH_7    = _f(0xf8421), \n    \t\t   CH_8    = _f(0x69696), CH_9    = _f(0x69e84), CH_FSTP = _f(0x00066),\n    \t\t   CH_COMM = _f(0x00064), CH_LBRC = _f(0x62226), CH_RPRN = _f(0x24442);\nconst lowp float KERN = 6.0;\nconst lowp vec2 MAP_SIZE = vec2(4,5);\n#undef _f\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map/exp2(index) ), 2.0 );\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent uv coordinate. The key difference with this implementation\n    and my reference one is that this one has a (very useful) side\n    effect of moving the carriage.\n*/\nfloat drawChar( in float char, inout vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv -= pos;\n    uv /= size;    \n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    pos.x += KERN;\n    return clamp(res,0.0,1.0);\n}\n\n\n/*\n    Draws the text labels.\n*/\nvec4 drawLabels( in vec2 uv, in vec2 size, in vec3 color )\n{\n    vec2 scr = uv*vec2(320,180); // Number of \"pixels\" in the \"screen\" onto which we draw text.\n    vec2 pos = vec2(10,60); // Starting position.\n    \n    // \"CONTINUOUS\"\n    // \"[0.0 10.0)\"\n    float char = drawChar(CH_C,pos,size,scr);\n    char += drawChar(CH_O,pos,size,scr);\n    char += drawChar(CH_N,pos,size,scr);\n    char += drawChar(CH_T,pos,size,scr);\n    char += drawChar(CH_I,pos,size,scr);\n    char += drawChar(CH_N,pos,size,scr);\n    char += drawChar(CH_U,pos,size,scr);\n    char += drawChar(CH_O,pos,size,scr);\n    char += drawChar(CH_U,pos,size,scr);\n    char += drawChar(CH_S,pos,size,scr);\n    \n    pos = vec2(10,50);\n    char += drawChar(CH_LBRC,pos,size,scr);\n    char += drawChar(CH_0,pos,size,scr);\n    char += drawChar(CH_FSTP,pos,size,scr);\n    char += drawChar(CH_0,pos,size,scr);\n    char += drawChar(CH_COMM,pos,size,scr);\n    char += drawChar(CH_1,pos,size,scr);\n    char += drawChar(CH_0,pos,size,scr);\n    char += drawChar(CH_FSTP,pos,size,scr);\n    char += drawChar(CH_0,pos,size,scr);\n    char += drawChar(CH_RPRN,pos,size,scr);\n    \n    // \"0 1 2 3 4 5 6 7 8 9\"\n    // \"DISCRETE\"\n    pos = vec2(10, 115);\n    char += drawChar(CH_D,pos,size,scr);\n    char += drawChar(CH_I,pos,size,scr);\n    char += drawChar(CH_S,pos,size,scr);\n    char += drawChar(CH_C,pos,size,scr);\n    char += drawChar(CH_R,pos,size,scr);\n    char += drawChar(CH_E,pos,size,scr);\n    char += drawChar(CH_T,pos,size,scr);\n    char += drawChar(CH_E,pos,size,scr);\n    \n    pos = vec2(10, 125);\n    char += drawChar(CH_0,pos,size,scr);\n    pos.x = 42.0;\n    char += drawChar(CH_1,pos,size,scr);\n    pos.x = 74.0;\n    char += drawChar(CH_2,pos,size,scr);\n    pos.x = 106.0;\n    char += drawChar(CH_3,pos,size,scr);\n    pos.x = 138.0;\n    char += drawChar(CH_4,pos,size,scr);\n    pos.x = 170.0;\n    char += drawChar(CH_5,pos,size,scr);\n    pos.x = 202.0;\n    char += drawChar(CH_6,pos,size,scr);\n    pos.x = 234.0;\n    char += drawChar(CH_7,pos,size,scr);\n    pos.x = 266.0;\n    char += drawChar(CH_8,pos,size,scr);\n    pos.x = 298.0;\n    char += drawChar(CH_9,pos,size,scr);\n    \n    return vec4(color,char);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 text = drawLabels(uv, MAP_SIZE, vec3(1));\n    vec4 outl = drawLabels(uv, MAP_SIZE*1., vec3(0));\n    fragColor = clamp(text+outl,0.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tThis buffer has the sole responsibility of outlining the text so it's visible.\n\tIt does that by calculating the local differential of the text buffer's alpha\n\tchannel, then by mixing the original text with black where a difference exists.\n*/\n\n#define EPSILON .002\n#define LABEL_BUFFER iChannel0\nfloat diff( in sampler2D t, in vec2 uv )\n{\n    vec2 d = vec2(EPSILON,0);\n    float dx = texture(t,uv+d.xy).a - texture(t,uv-d.xy).a;\n    float dy = texture(t,uv+d.yx).a - texture(t,uv-d.yx).a;\n    // We don't need to divide by two as we are simply testing\n   \t// for existence.\n    return step(.5, abs(dx)+abs(dy) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Get the original text.\n    vec4 buffA = texture(iChannel0, uv);\n    // Create the outline color.\n    vec4 outline = vec4(0,0,0, diff(LABEL_BUFFER,uv) );\n    \n    // Start off with the outline...\n    fragColor = outline;\n    // then alpha blend the original text atop it.\n    fragColor = mix(fragColor,buffA, buffA.a);\n}","name":"Buf B","description":"","type":"buffer"}]}