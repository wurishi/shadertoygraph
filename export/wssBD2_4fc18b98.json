{"ver":"0.1","info":{"id":"wssBD2","date":"1589136609","viewed":50,"name":"htw/Meatball","username":"htw6174","description":"gross meatball","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Based on shaders by Jamie Wong featured on his blog:\n * http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n */\n\nconst int MAX_STEPS = 255;\nconst float NEAR_CLIP = 0.1;\nconst float FAR_CLIP = 100.0;\nconst float EPSILON = 0.0001;\n\nconst float SPECULAR = 0.5;\nconst float DIFFUSE = 0.7;\nconst float REFLECTION = 1.0;\nconst float SHININESS = 10.0;\n\nconst float LIGHT_AMBIENT = 0.0;\nconst float LIGHT1_SPECULAR = 0.4;\nconst float LIGHT1_DIFFUSE = 0.4;\n\nconst float SPHERE_RAD = 1.0;\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 100000.0);\n}\n\nfloat rand2(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec3 rand3(vec3 st)\n{\n    st = vec3( dot(st, vec3(12.9898,78.233, 37.135)),\n               dot(st, vec3(325.800, 228.540, 561.121)),\n               dot(st, vec3(285.760, 189.060, 126.580)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat noise(vec3 st)\n{\n    vec3 i = floor(st);\n    vec3 fractional = fract(st);\n    \n    // Eight samples from cube corners\n    float a = dot( rand3(i), fractional );\n    float b = dot( rand3(i + vec3(1.0, 0.0, 0.0)), fractional - vec3(1.0, 0.0, 0.0) );\n    float c = dot( rand3(i + vec3(0.0, 1.0, 0.0)), fractional - vec3(0.0, 1.0, 0.0) );\n    float d = dot( rand3(i + vec3(1.0, 1.0, 0.0)), fractional - vec3(1.0, 1.0, 0.0) );\n    float e = dot( rand3(i + vec3(0.0, 0.0, 1.0)), fractional - vec3(0.0, 0.0, 1.0) );\n    float f = dot( rand3(i + vec3(1.0, 0.0, 1.0)), fractional - vec3(1.0, 0.0, 1.0) );\n    float g = dot( rand3(i + vec3(0.0, 1.0, 1.0)), fractional - vec3(0.0, 1.0, 1.0) );\n    float h = dot( rand3(i + vec3(1.0, 1.0, 1.0)), fractional - vec3(1.0, 1.0, 1.0) );\n    \n    vec3 u = smoothstep(0.0, 1.0, fractional);\n    \n    float ab = mix(a, b, u.x);\n    float cd = mix(c, d, u.x);\n    float ef = mix(e, f, u.x);\n    float gh = mix(g, h, u.x);\n    float c1 = mix(ab, cd, u.y);\n    float c2 = mix(ef, gh, u.y);\n    return mix(c1, c2, u.z);\n}\n\nfloat sphereSdf(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat wobblySphereSdf(vec3 pos, float radius)\n{\n    //float mag = sin(iTime) * 10.0;\n    //float mag2 = cos(iTime + 0.72) * 7.0;\n    //pos.x = pos.x + sin(pos.y * mag) * 0.2;\n    //pos.z = pos.z + sin(pos.y * mag2) * 0.2;\n    float xbasis = dot(pos.y, pos.z) + iTime * 0.2;\n    float i = floor(xbasis * 10.0);\n    float f = fract(xbasis * 10.0);\n    float offx = mix(rand(i), rand(i + 1.0), smoothstep(0.0, 1.0, f));\n    pos.x = pos.x + offx * 0.5;\n    return length(pos) - radius;\n}\n\nfloat sceneSdf(vec3 pos)\n{\n    return wobblySphereSdf(pos, SPHERE_RAD);\n}\n\n/* Determines if the surface of the sceneSdf intersects the ray cast from the current fragment.\n * \n * eye: position of the scene camera\n * dir: normalized ray direction\n * \n * Returns: Distance from near clipping plane to surface if ray intersects surface\n *          -1 if ray doesn't intersect a surface within the far clip distance\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 dir)\n{\n    float depth = NEAR_CLIP;\n    float dist;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sceneSdf(eye + (dir * depth));\n        // If ray is inside or on the surface of the sdf\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        // If ray has exited the far clipping plane\n        if (dist >= FAR_CLIP)\n        {\n            return -1.0;\n        }\n        depth = depth + dist;\n    }\n    // -1 should be interpreted as a ray that never hits the sdf; 0 is a ray that is inside the sdf\n    return -1.0;\n}\n\n/* \n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSdf(vec3(p.x + EPSILON, p.y, p.z)) - sceneSdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSdf(vec3(p.x, p.y + EPSILON, p.z)) - sceneSdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSdf(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/* Return the normalized direction to march in from the origin for a fragment\n * \n * fov: vertical field of view in degrees\n * res: resolution of the image\n * fragCoord: x,y pixel coordinate of fragment\n */\nvec3 rayDirection(float fov, vec2 res, vec2 fragCoord)\n{\n    // Map fragCoord from range (0, res) to (-res/2, res/2)\n    vec2 xy = fragCoord - res / 2.0;\n    // z is unaltered by fragment position\n    float z = res.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat phongLighting(vec3 surface, vec3 normal, vec3 eye, vec3 dir, vec3 light)\n{\n    float ambient = REFLECTION * LIGHT_AMBIENT;\n    vec3 lightDir = normalize(light - surface);\n    vec3 reflection = normalize(reflect(-lightDir, normal));\n    //vec3 reflection = normalize((2.0 * dot(lightDir, normal) * normal) - lightDir);\n    vec3 viewer = -dir;\n    float dotLN = dot(lightDir, normal);\n    if (dotLN < 0.0) // Light not visible from position on surface, apply only ambient\n    {\n        return ambient;\n    }\n    float diffuse = DIFFUSE * dotLN * LIGHT1_DIFFUSE;\n    float dotRV = dot(reflection, viewer);\n    if (dotRV < 0.0) // Light reflection away from viewer, apply only ambient and diffuse\n    {\n        return ambient + diffuse;\n    }\n    float specular = SPECULAR * pow(dotRV, SHININESS) * LIGHT1_SPECULAR;\n    return ambient + diffuse + specular;\n    //return ambient + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Compute the aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    // Scale the long axis of uv space by the aspect ratio\n    uv.x = uv.x * aspect;\n    // Shift center of coordinate space to center of the screen\n    //uv = (uv * 2.0) - vec2(aspect, 1.0);\n    uv.x = (uv.x * 2.0) - aspect;\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    // Places a 'camera' at -5z facing along the +z axis\n    vec3 eye = vec3(0.0, 0.0, 8.0);\n    \n    // Distance of fragment from the surface\n    float dist = shortestDistanceToSurface(eye, dir);\n    // 0 if dist is 0 or negative, 1 if dist is positive\n    float surf = clamp(dist, 0.0, 1.0);\n    \n    vec3 intersect = eye + (dir * dist);\n    vec3 normal = estimateNormal(intersect);\n    //vec3 lightPos = vec3(2.0, 2.0, 2.0);\n    vec3 lightPos = vec3(2.0, 4.0 + 4.0 * cos(iTime), 1.0 + 3.0 * sin(iTime));\n    float light = phongLighting(intersect, normal, eye, dir, lightPos);\n    \n    vec3 noiseSample = intersect + vec3(0.0, iTime * 0.2, 0.0);\n    float val = 0.5 + 0.5 * noise(noiseSample * 6.0);\n\n    vec3 col = vec3(0.4 + surf * val, 0.3, 0.3) * light;\n    //vec3 col = normal;\n    //vec3 col = vec3(surf, 0.0, 0.0);\n    //vec3 col = vec3(uv, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}