{"ver":"0.1","info":{"id":"M3fGDB","date":"1707879375","viewed":75,"name":"Circle pixel coverage","username":"ladyhavoc","description":"Prototype of an antialiased circle algorithm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","antialiased","pixelart","pulsing"],"hasliked":0,"parentid":"lXf3WB","parentname":"Broken circle coverage 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelate = 8.0;\n    float radius = iResolution.y * 0.4 / pixelate * 0.5 * (1.0 + sin(iTime * 0.2));\n    vec2 center = iResolution.xy * 0.5 / pixelate;\n    vec2 pos = floor(fragCoord / pixelate + vec2(0.5));\n\n    // this calculates the horizontal and vertical pixel coverage\n    // using the core ideas of oldschool span rendering of circles,\n    // where the x range of a row is 1.0 - y*y, and conversely the y\n    // range of a column is 1.0 - x*x (both are equivalent methods of\n    // drawing a circle), it turns out that a lot of the math for\n    // relative pixel distance cancels out and becomes just a dot\n    // product however, i.e. we want the squared length of rel\n    vec2 rel = (pos - center);\n    // dot product will give us the squared length of rel, which is\n    // in the range 0..radius*radius, but we want 0..radius, so we\n    // divide by radius, which can look funny next to this 1+radius\n    // but is completely intentional, they are of the same magnitude\n    // due to the divide\n    float v = (1.0 + radius - dot(rel, rel) / radius);\n    // use 0.5 multiplier for radius when calculating the coverage,\n    // because we're measuring the whole pixel, not the pixel center\n    float coverage = clamp(v * 0.5, 0.0, 1.0);\n    \n    fragColor = vec4(vec3(coverage),1.0);\n}","name":"Image","description":"","type":"image"}]}