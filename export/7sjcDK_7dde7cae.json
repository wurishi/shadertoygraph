{"ver":"0.1","info":{"id":"7sjcDK","date":"1644160097","viewed":166,"name":"Mandelbulb - Ray March","username":"Pyromma","description":"Mandelbulb fractal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raytracer","raymarch","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define EPS 0.005\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n// Shoot Ray\nRay getFragCoordRay(const vec2 frag_coord) {\n  \t   \n    // FOV\n    float fov = 120.;\n    float cameraDistance = 1.0 / tan(fov * 0.5f * PI / 180.0);\n    vec3 position = vec3(0.0, 0.0, -6.5);\n    \n    vec3 rayTarget = vec3((frag_coord / iResolution.xy) * 2.0 - 1.0, cameraDistance);\n    rayTarget.y /= (iResolution.x / iResolution.y);\n    \n  \tvec3 origin = vec3(-0., 0.0, -11.0);\n    vec3 direction = normalize(rayTarget - origin + position);\n  \n  \treturn Ray(origin, direction);\n}\n\n//Rotate Mandelbulb\nvec3 rot(vec3 pos, float x, float y, float z)\n{\n\tmat3 rx = mat3(1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n\tmat3 ry = mat3(cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n\tmat3 rz = mat3(cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n\n\treturn rx * ry * rz * pos;\n}\n\n//Distance Estimator - MandelBulb\nfloat distEst(vec3 pos)\n{\n\tfloat dis = 0.0;\n\tfloat res = 0.0;\n    int iter = 8;\n\n    pos = rot(pos, sin(iTime * 0.2) * 0.01 - 0.3, 0.02 * iTime + cos(iTime * 0.2) * 0.02 - 0.3, 1.2);\n\tvec3 posN = vec3( pos.xyz );\n\n\tfloat p = sin(iTime * 0.1) + 9.0;\n\tfloat d = sin(iTime * 0.1) * 0.2 + 1.0;\n    \n\tfor(int l = 0; l < iter; ++l)\n\t{\n\t\t\n        dis = length(posN);\n\n        if( dis > 1.5 )\n        {\t\n            res = 0.3 * log(dis) * dis / d;\n        }\n        else\n        {\n            d = pow(dis, 7.0) * 7.0 * d + 1.0;\n            \n            float theta = atan( length( posN.xy ), posN.z );\n            float phi = atan( posN.y, posN.x );\n            \n            float tran = sin(theta * p);\n            float rPow = pow(dis, 8.0);\n            \n            posN.x = rPow * cos(phi * p) * tran;\n            posN.y = rPow * sin(phi * p) * tran;\n            posN.z = rPow * cos(theta * p);\n            \n            posN += pos;\n        }\n\t\t\t\n\t}\n\t\n\treturn res;\n}\n\n//Global var\nconst int maxSteps = 100;\nconst float maxDistance = 1000.;\n\n//Ray Marching\nvec2 rayMarch(Ray ray)\n{\n    float totalDistance = 0.0;\n    int steps;\n    \n\tfor (steps = 0; steps < maxSteps; ++steps)\n    {\n\t\tvec3 p = ray.origin + totalDistance * ray.direction;\n\t\tfloat distance = distEst(p);\n        \n\t\ttotalDistance += distance;\n\t\tif (totalDistance > maxDistance)\n            break;\n\t}\n\treturn vec2(totalDistance, float(steps) / float(maxSteps));\n}\n\n//Normal\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPS, 0);\n    float d = distEst(pos);\n    \n    vec3 n = d - vec3(\n        distEst(pos - e.xyy),\n        distEst(pos - e.yxy),\n        distEst(pos - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n//Get light\nfloat getLight(Ray ray, float dist, vec3 lightPos)\n{\n    vec3 pos = ray.origin + ray.direction * dist;\n    vec3 light = normalize(lightPos - pos);\n    vec3 n = getNormal(pos);\n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    \n    vec2 shadow = rayMarch(Ray(pos + n * EPS, light));\n    \n    dif *= 1.0 - shadow.y;\n    return dif;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightPos = vec3(7.0, 1.0, -10.0);\n\n    Ray ray = getFragCoordRay(fragCoord);\n    \n    vec2 res = rayMarch(ray);\n    float dist = res.x;\n    \n    vec3 col = 1.6 * vec3(0.8 * res.y, getLight(ray, dist, lightPos)+res.y * 0.2, 0.0) + 0.0 * vec3(1.0 - res.x, 1.0 - res.y, 0.0);\n    \n    //col = vec3(res.x, 1.0-res.y, 0);\n    //col = getNormal(ray.origin + ray.direction * dist);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}