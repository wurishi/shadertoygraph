{"ver":"0.1","info":{"id":"XsySRd","date":"1465941761","viewed":134,"name":"Blipvert","username":"akohdr","description":"Mouse allows browsing a catalogue of tiny procedural temporal textures / shaders.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","texture","tweet","halftweet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A simple way to collect / browse combinations of procedural temporal textures / shaders\n// (Looks like it's really slow to compile on iPad :( )\n//\n// TODO needs an overlay and naming for currently displayed texture\n//\t\tcolour space transforms\n//\t\tpipelining combinations\n//\n\n//#define BLIPVERT\n// Where the name comes from:\n//\t\thttps://en.wikipedia.org/wiki/Blipvert\n//\t\thttps://www.youtube.com/watch?v=PJP-Ilw_xaY\n//\n\n// the context provided to each texture\nvoid ctx(out vec4 k,\t// output colour\n             vec2 p,\t// xy position\n            float t,\t// global timebase\n           vec3 sct, \t// sin, cos, tan of global timebase\n             vec4 W,\t// iDate, world timebase\n             vec4 M, \t// iMouse\n             vec2 R\t\t// iResolution\n        ){}\n\n// definition macros\n#define DEF(n) void n(out vec4 k, vec2 p, float t, vec3 sct, vec4 W, vec4 M, vec2 R)\n#define DEF2(n,b) DEF(n){vec3 a_=vec3(0);b;k=vec4(a_,1);}\n\n// invocation macros (passes context by naming convention)\n#define CTX_(n,f) {f(n,p,t,sct,iDate,iMouse,iResolution.xy); \n#define CTX(n,f) CTX_(n,f)} \n#define CTXa(o,f) CTX_(k,f) a_ o k.rgb;}\n\n// context derived\n#define UV p/R\n#define CP UV-.5\n#define SC(a) sin(a),cos(a)\n#define SCT(a) vec3(SC(a),tan(a))\n//#define T t\n// by deriving T from iDate animation continues during mouse select\n#define T W.w\n\n// texture channels\nDEF(ch0){k = texture(iChannel0, UV);}\nDEF(ch1){k = texture(iChannel1, UV);}\nDEF(ch2){k = texture(iChannel2, UV);}\nDEF(ch3){k = texture(iChannel3, UV);}\n\n// first order texture example\nDEF(tx100){p/=-5e1;k = tan(p.x*vec4(9,-8,7,0) * length(tan(fract(p)))-T);}\nDEF(tx101){p/=-9e1;k = fract(p.x*vec4(9,-8,7,0) * length(sin(fract(p)))-T);}\n\n// second order example (accumulates final colour in local a_)\nDEF2(tx200,CTXa(-=,tx100) CTXa(-=,tx101) )\nDEF2(tx201,CTXa(+=,tx100) CTXa(-=,tx101) )\nDEF2(tx202,CTXa( =,tx100) CTXa(*=,tx101) )\n\n// ---------------------------------------------------------------------------------------\n// Selection of golfed textures initially named for their original char length before edits\n// \t\tshould use somekind of Godel'esque hash of the actual source for naming\n// \t\tthen could search texture generator space with approaches ala. Koza, Wolfram et al...\n\n    \nDEF(shiftinglines)\n{\n//derived https://www.shadertoy.com/view/4dVSWt\n#define N(a,b,t)(sin(dot( (vec3(dot(a, u), dot(b, u), dot(p-p, u))+t*T) ,vec3(1)))/3.)\n#define S(i) smoothstep(-.02, .02, l.i - .45)\n\tvec2 u = p / iResolution.y;\n//    u += vec2(.2 * sin(T * .41 + .7) * pow(abs(u.y - .5), 3.1) - sin(T * .07 + .1),\n//        \t   -T * .03 + .05 * sin(T * .3) * pow(abs(u.x - .5), 1.8));\n    vec2 l = abs(fract(u*=7.))-.5;\n    u = floor(u);\n    k = vec4(max(smoothstep(-.05, .05, abs(fract(dot(l, 4.9 * normalize(vec2(\n        N(vec2(1.7,  .9), vec2(2.6, 1.1), vec3( .55, .93, 0)), \n        N(vec2( .6, 1.9), vec2(1.3,  .3), vec3(1.25, .83, 0))))) + 3.6*T)-.5) - .25), max(S(x),S(y))));\n}\n        \nDEF(mandelbrot)\n{\n    // derived https://www.shadertoy.com/view/4sVXW3\n\tk-=k;for (int i=0; i<24; i++)\n\t\tk.rg = p/3e2 + mat2(k.g,-k.rrg)*k.gr;\n}\n\nDEF(mandelbrot2)\n{\n    // derived https://www.shadertoy.com/view/4sVXW3\n    //#define i(b) o.rg=u/3e2-mat2(-o.g,o.r,o)*o.gr;b;b;b;b\n\t//void mainImage(out vec4 o,vec2 u){o-=o;i(i(i()))}\n    #define i(b) k.rg=p/3e2-mat2(-k.g,k.r,k)*k.gr;b;b;b;b\n\tk-=k;i(i(i()));\n}\nDEF(polarGrad)\n{\n    // inspired by https://www.shadertoy.com/view/XdVSWG\n\tp -= R/2.;\n    p -= mod(p,p/2.);\t\t\t\t\t// hash line effect\n\n    k = vec4(1);\t\t\t\t\t\t// ensure k is valid (set alpha)\n    k.rgb = fract(W.w + .159 * atan(p.y, p.x) *\n                 5.\t\t\t\t\t\t// number of blades\n                 )\n    *(.5+.5*sin(W.w/vec3(1,2,3)))\t\t// colour cycle (+33 chars)\n    ;\n}\n    \nDEF(gearsRB)\n{\n    // variation on theme of Fab's meditation on hex tilings\n     \t p *= 2./R.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p,p.yxxy));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= fract( length(p)/.27 - \n        .1*sin(24.*(atan(p.y,p.x) - W.w*sign(g.z))) );    \n}\n\nDEF(gearsGM)\n{\n     \t p *= 4./R.y * mat2(.9,-.5, 0,1);\t\t\t\t\t// âˆ† # rows\n    vec4 g = fract(k=vec4(p,p));\t\t\t\t\t\t\t// âˆ† swizzled colour\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= fract( length(p)/.27 - \n        .1*sin(18.*(atan(p.y,p.x) - W.w*sign(g.z))) );    \t// âˆ† # teeth\n}\n\nDEF(seperation)\n{\n\t#define fSEP length(length(k*=k)-p)\n//    p = p.yx;\t\t\t\t\t\t// rotate 90 degrees (fullscreen)\n    p = (p.x>4e2 ? p.yy : p)/150.;\t// ortho project fade stripe / size\n    k = sct.xxxx;\n    k += vec4(fSEP,fSEP,fSEP,0);\n\tk = sct.x<0. ? 1.-k : k;\t\t\t// negative toggle (CMY on WHT / RGB on BLK)\n}\n\nDEF(bloom)\n{\n\t#define fBloom length(length(k*=k)-p/2e2)\n    k /= abs(k = cos(W.wwww))*vec4(fBloom,fBloom,fBloom,1);\n}\n\nDEF(g101)\n{\n    p/=-9e1;k = fract(p.x*vec4(9,-8,7,0) * length(sin(fract(p)))-T);\n}\n\nDEF(g90)\n{\n    k = sin((9.+vec4(0,.3,.6,0)) * length(sin(p/1e2)) - T);\n}\n\nDEF(g88)\n{\n    k = tan(vec4(2,3,5,1) * length(p/R.y) - T);\n}\n\nDEF(g140)\n{\n    p *= (R-p)/R;\n    vec2 q = max(length(p-fract(p)),\n            length(p))\n             - W.ww\n        ;\n\tk = sin(q.x/vec4(2,3,5,q));\n}\n\nDEF(g124)\n{\n    p /= R/3.;\n    p = tan(tan(sin(p)));\n    p *= mat2(sin(p.xyyx+T));\n    k = vec4(sin(p),p);\n}\n\nDEF(gMat2)\n{\n   \tp = CP;\t\t\t\t\t// centered normalized to +/- .5\n    p *= 25.;\t\t\t\t// zoom out for bigger picture\n    \n\tp /= t*vec2(-.5,.7);\t// offset\n\tp *= 5.;\t\t\t\t// zoom\n    \n    p *= mat2(sct.yxyy)*\n         mat2(sin(( \n        \t\t\tp.xxxx+\n                    p.xxyx+\n//                    p.xyxx+\n//                    p.xyyx+\n                    p.yxxx+\n//                    p.yxyx+\n//                    p.yyxx+\n                    p.yyyx\n                  )+vec4(2,3,5,0)*T));\n    k = vec4(SC(p));\n\n\tk = 1.-k;\n//\tk = fract(k);\n//\tk = tan(k);\n}\n\nDEF(g106)\n{\n    k.xy = sin(p+W.ww);\n    p /= R;\n    k = vec4(fract(p *= mat2(fract(k.yyxx))),p);\n}\n    \nDEF(g110)\n{\n    p /= iResolution.x/9.;\n    p *= mat2(sin(p.xyyx+T));\n    k = vec4(fract(p),p);\n}\n\nDEF(g115) \n{\n    p /= iResolution.x/9.;\n    p *= mat2(cos(p.xyyx+T));\n    k = p.yxxy+vec4(sin(p),p);\n}\n\nDEF(g116)\n{\n    p /= iResolution.x/9.;\n    p *= mat2(cos(p.xyyx+T));\n    k = W/vec4(sin(p),p)*W.wzzw;\n}\n\nDEF(gMat2a)\n{\n    k = vec4(p /= 2e1, cos(p *= mat2(sin(p.yxxy+T)))).zwzx;\n}\n\nDEF(g92)\n{\n    k = vec4(p /= R.x/9., sin(p *= mat2(cos(p.yxxy+T)))).wzww;\n}\n\nDEF(g108)\n{\n    p /= 6e1;\t // fixed res 95\n//    p /= iResolution.x/9.;\n    p *= mat2(cos(p.xyyx+T));\n    k = vec4(sin(p),p);\n}\n\nDEF(g131)\n{\n    p /= -R;\n    p += T - min(\n        \tlength(p - fract(p*=sqrt(R))),\n        \tlength(p)\n    \t);\n//\tk = sin(p.x/vec4(2,3,5,p));\n\tk = sin(p.xyxy);\n}\n\nDEF(g145)\n{\n    p = .5-p/R;\n    p += T - min(\n        \tlength(p-fract(p*=sqrt(R))),\n        \tlength(p)\n    \t);\n\tk = sin(p.x/vec4(2,3,5,p));\n}\n\nDEF(g163)\n{\n    p = .5-p/R;\n    p = min(\n        \tlength(p-fract(p*=sqrt(R))),\n        \tlength(p+3.)\n    \t)\n        - T+2e2*iMouse.xy/R\n        ;\n\tk = sin(p.x/vec4(2,3,5,p));\n}\n\nDEF(g176)\n{\n    vec2 q = vec2(.4);\n    p = q-p/R;\n    q = max(\n        \tlength(p-fract(p*=sqrt(R))),\n        \tlength(p+q*9.)\n    \t)\n        - T+192.*iMouse.xy/R;\n\tk = sin(q.x/vec4(2,3,5,q));\n}\n\n\n// from 'Tiny Texture' basically one-liners\nDEF(t99) {\n\tk += fract( dot(p,p)/999. - T) -k;\n}\n\nDEF(t60) {    \n    k += tan( dot(p,p)/9. + T) -k;\t// tan smaller and faster motion\n}\n\nDEF(t54) {\n    k += tan( dot(p,p) ) -k;\t\t\t\t// 54 chars without scaling and motion\n}\n\nDEF(t55) {\n    k += sin(p.xyxx/9.)-k;  \t\t  \t\t// 55 large colour grid\n}\n\nDEF(t52) {\n    k += sin(p.xyxx)-k;  \t\t  \t\t\t// 52 small colour grid\n}\n\nDEF(t52a) {\n    k += tan(p.xyxx)-k;  \t\t  \t\t\t// 52 small colour grid\n}\n\nDEF(t51) {\n\t  k = 1e2/p.xyxy;\t\t\t\t\t\t// we can init with spot of colour and remove -k;\n}\n\nDEF(t52b) {\n\t  k = (p/p.yx).xyxy;\t\t\t\t\t\t \n}\n\nDEF(t53) {\n\t  k = (p.yx/4e2).yxyy;\t\t\t\t\t// 53 colour fade\n}\n\nDEF(t51a) {\n\t  k = (p.yx/p).xyxy;\t\t\t\t\t// 51 colour fade\n}\n\nDEF(t48) {\n\t  k = 1e2/p.xyyy;\t\t\t\t\t\t// 48 colour axis\n}\n\nDEF(t47) {\n\t  k = 9./p.xyyy;\t\t\t\t\t\t// 47 colour axis\n}\n\nDEF(t44) {\n\t  k = p.xyyy;\t\t\t\t\t\t\t// 44 thin colour axis\n}\n\nDEF(t77) {\n\t  k += sin( dot(p,p)/9. + T);\n}\n\nDEF(t78) {\n\t  k += tan(dot(p,p) + T);\n}\n\nDEF(t99a) {\n\t  k += sin( (p.x=dot(p,p))/1e2 + (p.y=T));\t// some wave superposition with two more of these\n}\n\nDEF(t99b) {\n\t  k += sin( p.x/2e3 + p.y);\n}\n\nDEF(t99c) {\n\t  k += sin( p.x/4e1 + p.y);\n}\n\nDEF(quantWave)\n{\n    p = (vec2(.4,.5)-p/R)*sqrt(R);\n    vec2 q = max(length(p-fract(p)),\n            length(p+vec2(5,-.5)))\n             - T+192.*iMouse.xy/R;\n\tk = sin(q.x/vec4(2,3,5,q));\n}\n\n\n// some of following are borrowed as referenced\n// irony is reference url being longer than code :)\n\nDEF(t59)\n{\n    // https://www.shadertoy.com/view/XtfXzf\n    k -= k - mod(dot(p,p),20.1);\n}\nDEF(t64)\n{\n    // https://www.shadertoy.com/view/4tXSWH\n\tp *= 5e3 / T; k=vec4(0);k += fract( p.x * p.y );\n}\nDEF(t65)\n{\n    // https://www.shadertoy.com/view/XstGDN\n    k = tan( dot(p*=.1,p) + W.wzzw );\n}\nDEF(t68)\n{\n    // https://www.shadertoy.com/view/lstGRl\n    k = tan(p.xyyx*p.x*.4+T);\n}\nDEF(t61)\n{\n    // https://www.shadertoy.com/view/ll2XWV\n    k = sin(.314*p.xxxx*p.y)*9.;\n}\n\nDEF(t64a)\n{ \n    // https://www.shadertoy.com/view/XtfXRf\n    k += length( sin( 1e3 / p + T ) ); \n}\n\nDEF(t87)\n{\n    // https://www.shadertoy.com/view/MtfSz8\n    k = sin(length(.1*p-25.)+T/vec4(36e2,10,.78,1));\n}\n\n// ---------------------------------------------------------------------------------------\n// Create a texture as pipeline of other textures\nDEF(pipeline) \n{\n    vec4 a,b,c;\t\t\t// declare 2D colour fields\n    \n    CTX(a,tx200)\t\t// execute textures in context\n    CTX(b,gMat2)\n    CTX(c,quantWave)\n    CTX(k,ch0)\n        \n    k += a+b/c;\t\t\t// combine textures at this level (can be multi-level)\n    \n//    CTX(k,g176)\n//    CTX(k,quantWave)\n    \n    k *= sct.z;\t\t\t// temporal colour balance\n}\n\n// cycle macros automatically count declared TX() then cycle every dt secs\n#define CYCLE(b) float ct,i=-1.,m=1.;b;i++;ct=mod(t,m*dt);b;\n#define COUNT_TX if(i<0.) m++; else \n#define RENDER_TX(n) if(ct<mod(++i,m)*dt){CTX(k,n);return;}\n#define TX(n) COUNT_TX RENDER_TX(n)\n\n// provides 1D discrete index of position(p) within 2D space size(r) overlaid with grid(g)\n#define P2I(p,r,g) dot(vec2(1,g.x),floor(g*p/r));\n\nDEF(cycle)\n{\n#ifdef BLIPVERT\n\tfloat dt=1./iTime;\t\t\t// blipvert\n#else\n\tfloat dt=.5;\t\t\t\t\t\t// something little more reasonable\n#endif\n    \n    if(M.z>0.)\n        t = dt*P2I(M.xy,R,vec2(8,7));\t// tweaking global timebase allows selection\n    \n    CYCLE(\n        TX(shiftinglines)\n        TX(mandelbrot)\n        TX(mandelbrot2)\n        TX(polarGrad)\n        TX(gearsRB)\n\t\tTX(quantWave)\n        TX(bloom)\n        TX(seperation)\n\t\tTX(tx100)\n\t\tTX(g101)\n\t\tTX(g90)\n\t\tTX(g88)\n\t\tTX(g140)\n\t\tTX(g124)\n\t\tTX(gMat2)\n\t\tTX(tx101)\n\t\tTX(g106)\n\t\tTX(g110)\n        TX(gearsGM)\n\t\tTX(g115)\n\t\tTX(tx200)\n\t\tTX(g116)\n\t\tTX(gMat2a)\n\t\tTX(g92)\n\t\tTX(g108)\n\t\tTX(tx201)\n\t\tTX(g131)\n\t\tTX(g145)\n\t\tTX(g163)\n\t\tTX(g176)\n\t\tTX(tx202)\n\t\tTX(pipeline)\n\n        TX(t99)\n        TX(t60)     \n        TX(t54) \n        TX(t55) \n        TX(t52) \n        TX(t52a) \n        TX(t51) \n        TX(t52b) \n        TX(t53) \n        TX(t51a) \n        TX(t48) \n        TX(t47) \n        TX(t44) \n        TX(t77) \n        TX(t78) \n        TX(t99a) \n        TX(t99b) \n        TX(t99c)\n        \n        TX(t59)\n        TX(t64)\n        TX(t65)\n        TX(t68)\n        TX(t61)\n        TX(t64a)\n        TX(t87)\n    )\n}\n\nvoid mainImage(out vec4 k,vec2 p)\n{\n    float t = iTime;\t\t\t\t\t// global timebase\n    vec3 sct = SCT(t);\t\t\t\t\t\t// minimize trig calls\n\n    CTX(k,cycle)\n}\n","name":"Image","description":"","type":"image"}]}