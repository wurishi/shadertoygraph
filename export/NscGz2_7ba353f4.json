{"ver":"0.1","info":{"id":"NscGz2","date":"1630166552","viewed":166,"name":"D I G I T","username":"Fogrex","description":"Digits","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["digit","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(41.3455422+dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st) {\n    return vec2(\n        random(st),\n        random(\n            vec2(\n                random(st),\n                random(st + vec2(24.2145, 346.234))\n            )\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    // Color shift\n    float delta = exp((distance(uv, vec2(0.5, 0.5))) * 0.4) - 1.0;\n    \n    // limit time\n    float limTime = floor(iTime * 10.0) / 10.0;    \n    // pulse\n    float pulse = 0.0;//step(0.95, random(vec2(decTime)));\n    vec2 pulseUv = mix(uv,\n            uv * (0.2 + random(vec2(limTime, limTime + 0.3))) + (random2(vec2(limTime)) * 2.0 - vec2(1.0)) * 0.04,\n            pulse);\n\n    fragColor = vec4(\n        texture(iChannel0, pulseUv).r,\n        texture(iChannel0, pulseUv + vec2(0.01, 0.02) * delta).g,\n        texture(iChannel0, pulseUv + vec2(-0.02, 0.01) * delta).b,\n        1.0\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float[10] DIGIT = float[10](126.0, 48.0, 109.0, 121.0, 51.0, 91.0, 95.0, 114.0, 127.0, 123.0);\n\nfloat random (vec2 st) {\n    return fract(sin(41.3455422+dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st) {\n    return vec2(\n        random(st),\n        random(\n            vec2(\n                random(st),\n                random(st + vec2(24.2145, 346.234))\n            )\n        )\n    );\n}\n\nconst float blockSize = 3.0;\n\nfloat block(vec2 pos, vec4 set, float flag) {\n    vec2 temp = abs(pos - set.xy) - set.zw * 0.5;\n    return mix(1.0, step(0.0, max(temp.x, temp.y)), flag);\n}\nfloat map(vec2 pos, vec2 index, float flag) {\n    vec2 limPos = floor(pos * vec2(5.0, 8.0)) / vec2(5.0, 8.0);\n    float limTime = floor(iTime * 10.0) / 10.0;\n    float pulse = step(0.98, random(limPos + index + vec2(limTime)));\n    vec2 pulseDelta = (random2(limPos + index + vec2(limTime)) * 2.0 - vec2(1.0)) * 0.07 * pulse;\n    vec2 delta = (random2(index + vec2(limTime)) * 2.0 - vec2(1.0)) * 0.01;\n    \n    return min(\n        block(pos + delta + pulseDelta, vec4(0.5, 0.8, 0.8, 0.2), mod(floor(flag / 64.0), 2.0)),\n        min(\n            block(pos + delta + pulseDelta, vec4(0.8, 0.65, 0.2, 0.5), mod(floor(flag / 32.0), 2.0)),\n        min(\n            block(pos + delta + pulseDelta, vec4(0.8, 0.35, 0.2, 0.5), mod(floor(flag / 16.0), 2.0)),\n        min(\n            block(pos + delta + pulseDelta, vec4(0.5, 0.2, 0.8, 0.2), mod(floor(flag / 8.0), 2.0)),\n        min(\n            block(pos + delta + pulseDelta, vec4(0.2, 0.35, 0.2, 0.5), mod(floor(flag / 4.0), 2.0)),\n        min(\n            block(pos + delta + pulseDelta, vec4(0.2, 0.65, 0.2, 0.5), mod(floor(flag / 2.0), 2.0)),\n            block(pos + delta + pulseDelta, vec4(0.5, 0.5, 0.8, 0.2), mod(flag, 2.0))\n        )))))\n    );\n}\n\nfloat getPattern(vec2 uv, float limTime) {\n    vec2 index = vec2(0.0);\n    vec2 pUv = uv;\n    \n    for(float i = 1.0; i < pow(blockSize, 8.0);i *= blockSize) {\n        index += floor(pUv * blockSize) / blockSize / i;\n        \n        vec2 limUv = floor(pUv * blockSize);\n        \n        pUv = mod(uv, vec2(1.0 / blockSize / i)) * blockSize * i;\n        \n        float v = random(limUv + vec2(limTime));\n        if(0.5 > v) break;\n        \n    }\n    \n    return map(pUv, index, DIGIT[int(floor(random(index) * 10.0 + iTime * 10.0)) % 10]);\n}\n\nconst float interval = 1.7;\n\nfloat easeInOutExpo(float x) {\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : x < 0.5 ? pow(2.0, 20.0 * x - 10.0) / 2.0\n      : (2.0 - pow(2.0, -20.0 * x + 10.0)) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float limTime = floor(iTime / interval) * interval;\n    float gray1 = getPattern(uv, limTime);\n    float gray2 = getPattern(uv, (floor(iTime / interval) + 1.0) * interval);\n    \n    float progress = easeInOutExpo((iTime - limTime) / interval);\n    \n    \n    float gray = mix(gray1, gray2, progress);\n    fragColor = vec4(\n        gray,\n        gray,\n        gray,\n        1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}