{"ver":"0.1","info":{"id":"3lKcz1","date":"1610480757","viewed":85,"name":"image sampling by rows","username":"Jozin","description":"image interpolation row  by row - cubic vs linear - some dark ringing is observed clearly in the case of cubic interpolation,\ncannot avoid jagged edges, but in the case of cubic jagged edges seems less prominent\n\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["image","interpolation","levels","rows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define num_levels 20.0\n#define interp_hardness 1.0\n\n// from http://www.java-gaming.org/index.php?topic=35123.0\nvec4 cubic(float v){\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\n\n// from https://www.paulinternet.nl/?page=bicubic#:~:text=If%20the%20values%20of%20a,polynomial%20can%20be%20easily%20derived.\nvec3 cubicInterp(vec2 uv)\n{\n  \n  \n  //vec3 p0 = texture(iChannel0, vec2(uv.x, uv.y - (fract(uv.y *num_levels) + 1.0) / num_levels)).xyz;\n  //vec3 p1 = texture(iChannel0, vec2(uv.x, uv.y - (fract(uv.y *num_levels) + 0.0) / num_levels)).xyz;\n  //vec3 p2 = texture(iChannel0, vec2(uv.x, uv.y - (fract(uv.y *num_levels) - 1.0) / num_levels)).xyz;\n  //vec3 p3 = texture(iChannel0, vec2(uv.x, uv.y - (fract(uv.y *num_levels) - 2.0) / num_levels)).xyz;\n  \n  float step = 0.95;\n  \n  vec3 p0 = texture(iChannel0, vec2(uv.x, uv.y - 1.0 * step / num_levels)).xyz;\n  vec3 p1 = texture(iChannel0, vec2(uv.x, uv.y)).xyz;\n  vec3 p2 = texture(iChannel0, vec2(uv.x, uv.y + 1.0 * step / num_levels)).xyz;\n  vec3 p3 = texture(iChannel0, vec2(uv.x, uv.y + 2.0 * step / num_levels)).xyz;\n  \n  \n  \n  float x = fract(uv.y *num_levels );\n    \n    //return p1;\n  return p1 + 0.5 * x*(p2 - p0 + x*(2.0*p0 - 5.0*p1 + 4.0*p2 - p3 + x*(3.0*(p1 - p2) + p3 - p0)));\n  \n  \n}\n\nvec3 linearInterp(vec2 uv)\n{\n     // Time varying pixel color\n    float x = fract(uv.y *num_levels);\n    x = pow(x, interp_hardness);\n    \n    \n    vec3 col = texture(iChannel0,vec2(uv.x, uv.y - fract(uv.y *num_levels) / num_levels)).xyz;\n   col = mix(col, texture(iChannel0,vec2(uv.x, uv.y - (fract(uv.y *num_levels) - 1.0) / num_levels)).xyz, x);\n   \n   return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    //vec3 col = texture(iChannel0, uv).xyz;\n    vec3 i1 = linearInterp(uv);\n    vec3 i2 = cubicInterp(uv);\n    \n    i1.x += 0.05;\n    i2.y -= 0.05;\n    \n    float xCoord = fract(iMouse.x * 1.0 /iResolution.x + 0.5);\n    \n   vec3 col = mix(i1, i2, smoothstep(0.0 + xCoord, 0.0002 + xCoord, uv.x));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    fragColor.y *= smoothstep(0.0, 0.002, abs(uv.x -xCoord));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define num_levels 20.0\n#define interp_hardness 1000.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float rem = fract(uv.y *num_levels);\n    rem = pow(rem, interp_hardness);\n    \n    \n    vec3 col = texture(iChannel0,vec2(uv.x, uv.y - fract(uv.y *num_levels) / num_levels)).xyz;\n   //col = mix(col, texture(iChannel0,vec2(uv.x, uv.y - (fract(uv.y *num_levels) - 1.0) / num_levels)).xyz, rem);\n\n    \n    //col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}