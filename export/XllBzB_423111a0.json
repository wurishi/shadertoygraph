{"ver":"0.1","info":{"id":"XllBzB","date":"1513139843","viewed":219,"name":"Final","username":"akirkman10","description":"city","likes":7,"published":1,"flags":112,"usePreview":0,"tags":["city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsjSzh","filepath":"https://soundcloud.com/elginpark/mad-world-donnie-darko","previewfilepath":"https://soundcloud.com/elginpark/mad-world-donnie-darko","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifdef GL_OES_standard_derivatives\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives: enable\n#endif\n*/\n\n#define BUILDINGSPACING 20.\n#define MAXBUILDINGINSET 12.\n\n#define LIGHT_INT .43\n#define LIGHT_COL vec3(192.,192.,240.) / (255./LIGHT_INT)\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst int SPHERE = 0;\nconst int BOXPLANE =1;\nconst int BOX = 2;\nconst int CYLINDER = 3;\nconst int LENS = 4;\nconst int CUP = 5;\nconst int HANDLE = 6;\nconst int HEX = 7;\nconst int CONE = 8;\nconst int SHUTTER = 9;\nconst int TEXTBOX = 10;\nconst int TEXTBOX2 = 11;\nconst int TEXTBOX3 = 12;\nconst int TEXTBOX4 = 13;\nconst int LAMP = 14;\nconst int BUILDING = 15;\n\nconst float fogDensity = 0.05;\n\nbool ReadKey( int key, bool toggle );\n\nbool moveW = false;\nbool moveS = false;\nbool moveA = false;\nbool moveD = false;\nbool rotUp = false;\nbool rotDown = false;\nbool rotRight = false;\nbool rotLeft = false;\nvec3 dirVect;\nvec3 perpenVect;\nvec3 eye;\nvec3 at = vec3(0, 10.0, 50.0);\nvec3 up = vec3(0,1,0);\nfloat row;\nfloat theta;\nfloat phi;\n\nvec3 rayDir;\nstruct Object {\n    vec3 K_d;\n    vec3 K_s;\n    float d;\n    int type;\n    bool reflect;\n    bool normalMap;\n};\n\nstruct Ray {\n    vec3 hitPoint;\n    Object obj;\n    float minDist;\n    bool hit;\n};\nstruct fog {\n    vec3 color;\n    vec2 dist;\n};\n\n\n//UNIFORMS\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\n/* Function: filterWidth takes in pixel coordinates and\n *           computes how quickly any value is changing\n *           from pixel to pixel and therefore the area\n *           over which the procedural texture needs to be\n *           filtered.\n Precondition: takes in uv, pixel coordinate\n PostCondition: returns the coordinate that is increasing\n or decreasing the fastest.\n */\nfloat filterWidth (vec2 uv)\n{\n    vec2 fw = max(abs(dFdx(uv)), abs(dFdy(uv)));\n\n    return max(fw.x,fw.y);\n}\n\n/* Function: checkerboard2 takes in uv coordinates and\n *           computes the average color of the 2D range\n *           of the coordaintes from uv - .5 * filterwidth(uv)\n *           to uv + .5 * filterwidth(uv).\n Precondition: uv are coordinates\n PostCondition: returns the average color\n */\nvec3 checkerboard2(float u, float v, float interval)\n{\n    vec2 uv = vec2(u,v);\n    float width = filterWidth(uv);\n    vec2 p0 = uv - .5 * width;\n    vec2 p1 = uv + .5 * width;\n#define BUMPINT(x) (floor((x)/2.0) + 2.0 * max(((x)/2.0) - floor((x)/2.0) - 0.5, 0.0))\n    vec2 i = (BUMPINT(p1) - BUMPINT(p0)) / width;\n    float p = i.x * i.y + (1.0 - i.x) * (1.0 - i.y);\n    return vec3(p);\n\n}\n\n/* Function: skyColor this function takes a the ray direction\n *           to set the background color of the scene.\n Precondition: takes in a ray direction\n PostCondition: returns color\n */\nvec3 skyColor(in vec3 rd){\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n\n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n\n    vec3 col = vec3(0.);\n\n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); // Red / Green\n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n\n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n\n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n\n    return col;\n}\n\nvec3 skyColorReflect(in vec3 rd){\n    rd = -rd;\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n\n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n\n    vec3 col = vec3(0.);\n\n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); // Red / Green\n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n\n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n\n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n\n    return col;\n}\n\nfloat rand(vec2 v)\n{\n   float x = fract(sin(dot(v, vec2(1872.8497, -2574.9248))) * 72123.19);\n   return x;\n}\n\n//fract function returns the fractional part of x\n//floor function returns the largest integer number that is smaller or equal to x\n//Perlin noise algorithm\n\n/* subdividing a continuous floating number (p) into its integer (i) and fractional (f) components. use floor() to obtain i and fract() to obtain f. Then we apply rand() to the integer part of x, which gives a unique random value for each integer.\n */\nfloat noise(in vec2 p)\n{\n   vec2 i = floor(p);\n   vec2 f = fract(p);\n   vec2 u = f*f*(3.0-2.0*f);\n   return -1.0+2.0*mix(mix(rand(i + vec2(0.0,0.0)), rand(i + vec2(1.0,0.0)), u.x),\n                       mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)), u.x), u.y);\n   \n}\n\n\nfloat map(vec2 xz)\n{\n   \n   xz += noise(xz);\n   \n   vec2 a = 1.0 - abs(sin(xz));\n   vec2 b = abs(cos(xz));\n   return pow(dot(a, b), 0.5);\n}\n\nconst mat2 mat = mat2(1.8, 1.1, -1.1, 1.8);\n\nfloat water(vec3 p)\n{\n   vec2 xz = p.xz;\n   xz.x *= .5;\n   float amp = .2; //amplitude of wave(higher value = higher waves)\n   float h = 0.0; //initial water height\n   float freq = 0.2; //adjusts 'roughness' of water\n   for (int i = 0; i < 4; i++) // # of iterations waves generated\n   {\n      float h1 = map((xz + iTime) * freq);\n      h += (h1) * amp;\n      freq *= 0.8;\n      amp *= 0.18;\n      xz *= mat;\n   }\n   return (p.y - h);\n}\n\n\n/*SHAPE PRIMITIVE FUNCTIONS*/\n\n/* Function: sphereSDF creates sphere primitive based on starting\n pt and calculates diameter using d\n Precondition: takes in initial location pt and float d\n PostCondition: returns float\n */\nfloat sphereSDF(vec3 pt, float d)\n{\n    vec3 spt = vec3(0.,1.2,0.);\n    return length(pt-spt)-d;\n}\n\n/* Function: sdBox creates box primitive based on starting center point, pt,\n and b to represent demensions.\n Precondition: takes in vec3 pt and vec3 b\n d.x is the width\n d.y is the height\n d.z is the depth\n PostCondition: returns float\n */\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\n\n\n/* Function: sdTorus creates a torus primitive based on the starting center point, pt,\n and vec2 t representing width and height\n Precondition: takes in vec3 p and vec2 t\n PostCondition: returns float\n */\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n/* Function: sdCappedCylinder creates a cylinder primitive based on starting center, p\n and h the dimensions\n Precondition: takes in vec3 pt and vec2 h\n PostCondition: returns float\n */\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return length(p.xy)-h.x; //max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n/* Function: opTwist creates a twisted torus by calculating rotated points\n Precondition: takes in vec3 p the starting center point\n PostCondition: calls sdTorus function with the new rotated values to twist\n and returns twisted torus\n */\nfloat opTwist(vec3 p)\n{\n    float c = cos(10.0*p.y);\n    float s = sin(10.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q,vec2(0.310,0.10));\n}\n\n/* Function: sdConeSection create capped cone primitive using starting\n center point p and h, r1, and r2 represent dimensions.\n Precondition: vec3 p is center of primitive\n float h is height\n float r1, r2 width\n PostCondition: returns calculated float for sdConeSection\n */\nfloat sdConeSection(vec3 p, float h, float r1, float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n/* Function: unionSDF takes in 2 Objects objA and objB and\n returns the object with smaller dimensions\n Precondition: Takes in Objects, objA and objB\n PostCondition: Returns smaller object\n */\nObject unionSDF(Object objA,Object objB) {\n    if(objA.d < objB.d) {\n        return objA;\n    }\n    else {\n        return objB;\n    }\n}\n\n\n/* Function: opS subtracts one objects dimensions from another in\n order to merge different shape functions together\n to create a unique shape\n Precondition: takes in floats d1 and d2\n PostCondition: returns float of subtracted shape dimensions\n */\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n/* ROTATION FUNCTIONS */\n\n/* Function: rotAxis calculates the desired rotation of primitive shape\n in the scene using the desired axis coordinates and the\n amount of desired rotation\n Precondition: vec3 axis represents rotation of each axis (x, y, z)\n float a is the amount of rotation\n PostCondition: returns mat3\n */\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n/* Function: rotateY returns rotation matrix to rotate about\n the y axis.\n Precondition: theta - degrees of rotation\n PostCondition: returns mat4 to rotate about y axis\n */\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n                vec4(c, 0, s, 0),\n                vec4(0, 1, 0, 0),\n                vec4(-s, 0, c, 0),\n                vec4(0, 0, 0, 1)\n                );\n}\n\n/* Function: rotateX returns rotation matrix to rotate about\n the x axis.\n Precondition: theta - degrees of rotation\n PostCondition: returns mat4 to rotate about x axis\n */\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n                vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, c, -s, 0.0),\n                vec4(0.0, s, c, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0)\n                );\n}\n\n/* Function: rotateZ returns rotation matrix to rotate about\n the z axis.\n Precondition: theta - degrees of rotation\n PostCondition: returns mat4 to rotate about z axis\n */\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n                vec4(c, -s, 0.0, 0.0),\n                vec4(s, c, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0)\n                );\n}\n\nmat3 quatMatrix(vec3 axis, float angle)\n{\n\tfloat a = cos(angle/2.0);\n        float b = axis.x*sin(angle/2.0);\n\tfloat c = axis.y*sin(angle/2.0);\n        float d = axis.z*sin(angle/2.0);\n\tfloat len = sqrt(a*a+b*b+c*c+d*d);\n\ta/=len;\n\tb/=len;\n\tc/=len;\n\td/=len;\n\treturn mat3(a*a+b*b-c*c-d*d, 2.0*b*c-2.0*a*d, 2.0*b*d + 2.0*a*c,\n\t     2.0*b*c+2.0*a*d, a*a-b*b-c*c-d*d, 2.0*c*d-2.0*a*b,\n\t     2.0*b*d-2.0*a*c, 2.0*c*d+2.0*a*b, a*a-b*b-c*c-d*d);\n}\n\nfloat getXoffset( float z ) {\n   return 20.*sin( z*0.02);\n}\n\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nvec2 getBuildingInfo( in vec3 pos ) {\n\tvec2 res;\n\t// base index\n\tres.x = floor( pos.z/BUILDINGSPACING + 0.5 );\n\t// base z coord\n\tres.y = res.x * BUILDINGSPACING;\n\n\t// negative index for buildings at the right side\n\tres.x *= sign( pos.x + getXoffset(pos.z) );\n\n\treturn res;\n}\nvec2 getBuildingParams( in float buildingindex ) {\n\tvec3 h = vec3(.15);\n\treturn vec2(\n\t\t20. + 4.5*floor( h.x*7. ),\t // height\n\t\th.y*MAXBUILDINGINSET//,\n\t);\n}\n\nfloat baseBuilding( in vec3 pos, in float h ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\n\tfloat res =\n\topS(\n\t\t// main building\n\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\n\t\t\t// windows\n\t\topS(\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\tudBox( tpos+vec3(0.,-h,0.), vec3( 9.0, 1.0, 9.0 ) )\n\t\t)\n\t);\n\n\tres =\n\topU(\n\t\tres,\n\t\topI( // main building windows\n\t\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\n\t\t\topU(\n\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, h, 0.05 ) ),\n\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t)\n\t\t)\n\t);\n\treturn res;\n}\n\n/* Function: sceneSDF defines the objects of the scene by utilizing primitive functions\n and rotation coordinates. Unions all objects together to set all objects in\n scene.\n Precondition: vec3 pt is the next pt on the ray march\n PostCondition: returns Object\n */\nObject sceneSDF(vec3 pt)\n{\n    // rotation\n    mat3 rot = rotAxis(vec3(1.0,0.0,0.0),1.5);\n    //cylinder rotation\n    vec3 rc = rot*(pt+vec3(0.0,-.4,.9));\n    //torus rotation\n    vec3 rt = rot*(pt+vec3(-1.15,-0.4,-0.5));\n    float waterObj = water(pt+1.9);\n    \n    vec2 buildingInfo = getBuildingInfo(pt);\n    vec2 buildingParams = getBuildingParams( buildingInfo.x );\n\n    float z =buildingInfo.y;\n\n    vec3 pos =pt;\n    pos.x += getXoffset( pos.z );\n    pos.z = -abs(pos.z);\n    pos += vec3( 28.75+buildingParams.y, 2.5, 0.);\n\n\n    mat3 rmV = quatMatrix(vec3(1.0,0.0,0.0),-iTime);\n    pt.x += getXoffset( pt.z );\n\tpt.z = -abs( pt.z );\n    float zcenter = mod(pt.z+10.,20.)-10.;\n\n\n    Object obj11 = Object(vec3(1.,1.,1.),\n                           vec3(1.0,1.0,1.0),\n                           sdBox(vec3(pt.x,waterObj,pt.z),vec3(22000.0,.1,10000.)),\n                           HEX,true,false);\n\n    Object obj2 = Object(vec3(1.,1.,1.),\n                         vec3(1.0,1.0,1.0),\n                         sdBox(vec3(pt.x+30., pt.y, pt.z) , vec3( 20., 0.25, 99999. )),\n                         TEXTBOX4,false,true);\n\n   Object obj7 = Object(vec3(0.959,0.975,0.556),\n                        vec3(1.0,1.0,1.0),\n                        sphereSDF( vec3( pt.x+11.5, pt.y-6.0, zcenter) , 0.5 ),\n                        LAMP,false,false);\n\n   Object obj10 = Object(vec3(0.,0.,0.),\n                        vec3(1.0,1.0,1.0),\n                        sdCylinderXZ( vec3( pt.x+11.5, pt.y-3.6, zcenter), vec2( 0.1, 3.3) ),\n                        HEX,false,false);\n  \n\n   vec2 textcoord = vec2(pos.z,pos.y);\n   Object obj6 = Object( vec3(texture(iChannel3,textcoord)),\n                         vec3(1.0,1.0,1.0),\n                         baseBuilding(vec3(pos.x,pos.y,zcenter),buildingParams.x+2.5),\n                         BUILDING,false,false);\n\n    \n\n    Object obj = unionSDF(obj6,obj2);\n    //obj = unionSDF(obj,obj6);\n    obj = unionSDF(obj,obj7);\n    obj = unionSDF(obj,obj10);\n    obj = unionSDF(obj,obj11);\n\n\n    return obj;\n}\n\n/* Function: shortestDistanceToSurface finds the shortest distance to the\n surface of an object in the scene and returns Ray\n Precondition: eye - origin of the ray\n direction - the normalized direction to move down the ray\n start - starting point on the ray\n end - max distance to move\n PostCondition: returns ray of shortest distance based on eye and direction vectors\n */\nRay shortestDistanceToSurface(vec3 eye, vec3 direction, float start, float end)\n{\n    float depth = start;\n    bool hit = false;\n    vec3 hitPoint = vec3(0);\n    vec3 nextPt;\n    Object hitObj = Object(vec3(0.),vec3(0.),0.,0,false,false);\n\n    for (int i=0; i< MAX_MARCHING_STEPS; i++){\n        nextPt = eye + depth * direction;\n        Object obj = sceneSDF(nextPt);\n        if(obj.d < EPSILON){\n            hit = true;\n            hitPoint = nextPt;\n            hitObj = obj;\n            return Ray(hitPoint,hitObj,depth,hit);\n        }\n        depth+= obj.d *.9;\n        if (depth >=end){\n            return Ray(nextPt,hitObj,depth,hit);\n        }\n    }\n    return Ray(nextPt,hitObj,depth,hit);\n\n}\n\n/* Function: rayDirection finds the normalized direction to march\n in from the eye to a single pixel on the screen.\n Precondition: fieldOfView - vertical field of view in degrees\n size - resolution of the output image\n fragCoord - the x,y coordinate of the pixel in the output\n PostCondition: returns normalized ray direction\n */\nvec3 rayDirection (float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = (size.y/2.0)/tan(radians(fieldOfView)/2.0);\n    return normalize(vec3(xy,-z));\n}\n\n/* Function: This function takes in a point in the scene and\n *           uses the gradient of SDF to estimate the normal on\n *           the surface at that point.\n Precondition: takes in a point in the scene\n PostCondition: returns a normal on the surface at that point\n */\nvec3 estimateNormal(vec3 pt)\n{\n    return normalize(vec3(\n                          sceneSDF(vec3(pt.x+EPSILON,pt.yz)).d - sceneSDF(vec3(pt.x-EPSILON,pt.yz)).d,\n                          sceneSDF(vec3(pt.x,pt.y+EPSILON,pt.z)).d - sceneSDF(vec3(pt.x,pt.y-EPSILON,pt.z)).d,\n                          sceneSDF(vec3(pt.xy,pt.z+EPSILON)).d - sceneSDF(vec3(pt.xy,pt.z-EPSILON)).d\n                          ));\n}\n\nvec3 normalMapping(vec3 pt)\n{\n  vec4 texcolor = texture(iChannel1,vec2((pt.x+22.0)/8.0,(pt.z+100.0)/35.0));\n  vec3 mapNormal =vec3(texcolor.x,texcolor.y,texcolor.z);\n  mapNormal = (mapNormal*2.0)-1.0;\n  vec3 orientation = normalize(vec3(1.0,1.0,1.0));\n  //vec3 up = normalize(estimateNormal(pt));\n  vec3 N = normalize(estimateNormal(pt));\n  vec3 T = normalize(cross(orientation,N));\n  vec3 B = normalize(cross(N,T));\n  mat3 tangentToWorld = mat3(T.x,B.x,N.x,\n                             T.y,B.y,N.y,\n                             T.z,B.z,N.z);\n  return mapNormal * tangentToWorld;\n\n}\n\nfloat noise2( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z);\n\tvec2 uv2 = uv1  + offz;\n\treturn fract(z)-0.5;\n}\n\n/* Function: phongContribForLight is called by phongIllumination and\n calculates additional lighting model values\n k_d and k_s. Uses N, L, V and R vectors in the phong model to\n calculate diffuse lighting and specular lighting\n Precondition: vec3 k_d stores diffuse light vector\n vec3 k_s stores specular light vector\n float alpha is the scene shininess\n vec3 p is the point we are currrently analyzing\n vec3 eye is the position of eye, POV\n vec3 lightPos position coordinates of the light\n PostCondition: returns vec3 color coordinates of k_d, k_s values integrating\n shininess and light intensity. This value is added to the\n existing color value in phongIllumination that holds k_a.\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, Ray hitObject, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N;\n    vec3 L;\n    float isLeft;\n    vec2 buildingInfo;\n    vec2 buildingParams;\n    if (hitObject.obj.normalMap == true){\n       N = normalMapping(hitObject.hitPoint);\n    } else {\n       N = estimateNormal(hitObject.hitPoint);\n    }\n    //Material\n    vec3 mate, origmate;\n\t\tvec3 matpos = hitObject.hitPoint*0.3;\n    vec3 lp;\n    if(hitObject.obj.type == BUILDING){\n      buildingInfo = getBuildingInfo( hitObject.hitPoint);\n      buildingParams = getBuildingParams( buildingInfo.x );\n      isLeft = sign(buildingInfo.x);\n      float z = buildingInfo.y;\n\n      lp = vec3( 11.5*sign(buildingInfo.x)-getXoffset(z), 6.0, z );\n      L= normalize(lp-hitObject.hitPoint);\n\n    } else{\n      L = normalize(lightPos - hitObject.hitPoint);\n    }\n    vec3 V = normalize(eye - hitObject.hitPoint);\n    vec3 R = normalize(reflect(-L, N));\n\n\n    float dotLN = max(dot(L,N),0.0);\n\n    vec3 diffuseColor = k_d * dotLN * lightIntensity;\n\n    float dif = max(dot(N,L),0.0);\n    dif /= dot( lp-hitObject.hitPoint,lp-hitObject.hitPoint );\n\n    float bac = max(0.2 + 0.8*dot(N,normalize(vec3(-L.x,0.0,-L.z))),0.0);\n    vec3 lcol = vec3(2.9, 1.65, 0.65 );\n    vec3 amb = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 brdf = vec3(0.0);\n      brdf += (60.0*dif)*lcol;\n      brdf += (0.1*amb)*vec3(0.10,0.15,0.30);\n  brdf += (0.1*bac)*vec3(0.09,0.03,0.01);\n\n\n    float dotRV = max(dot(R,V),0.0);\n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha))+brdf;\n}\n\n/* Function: phongIllumination sets ambient light, k_a, and light intensity values then calls\n phongContribForLight to calculated additional color values of the lighting model\n that will contribute to the color of the point, p, in the scene\n Precondition: vec3 k_a stores ambient light vector\n vec3 k_d stores diffuse light vector\n vec3 k_s stores specular light vector\n float alpha is the scene shininess\n vec3 p is the current pt we are annalyzing\n vec3 eye position of eye point of view\n vec3 lightPos position coordinates of the light\n PostCondition: returns full calculated vec3 color based on lighting model\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, Ray hitObject, vec3 eye, vec3 lightPos) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n\n    vec3 lightIntensity = vec3(.75);\n\n    color += phongContribForLight(k_d, k_s, alpha, hitObject, eye,\n                                  lightPos,\n                                  lightIntensity);\n    return clamp(color,0.0,1.0);\n}\n\n/* Function: isVisible uses light position and the pt the ray hit to\n determine if the light reaches the point directly or not\n in order to set shadows\n Precondition: vec3 lightPos position coordinates of the light\n vec3 pt is the hitpoint of ray we are calculating\n relationship to light\n PostCondition: returns true if the light is hitting the point\n returns false otherwise\n */\nbool isVisible(vec3 lightPos, vec3 pt)\n{\n    vec3 lightRay = normalize(lightPos-pt);\n    Ray ray = shortestDistanceToSurface(pt,lightRay,MIN_DIST+.01, MAX_DIST);\n    if(!ray.hit)\n        return true;\n    else\n        return false;\n\n}\n\n/* Function: isReflect is called if Ray hits an object in which reflect = true.\n Calculates additional rays reflected off of reflected objects in order\n to find the color(K_d) that the reflected object should display at that\n location.\n Precondition: vec3 eye is location in which the initial ray is shot from in\n order to calculate which reflection color applies\n vec3 pt is the initial pt hit on reflected object\n If ray reflected off of reflected object does not hit another object\n set the reflected pt color to the backgroundColor\n PostCondition: returns the vec3 color (K_d) of the hit point on a reflected object\n */\nvec3 isReflect(vec3 eye, vec3 pt, vec3 backgroundColor){\n    vec3 reflectRay = normalize(eye-pt);\n    vec3 N = estimateNormal(pt);\n    vec3 r = normalize(reflect(-reflectRay,N));\n    Ray ray = shortestDistanceToSurface(pt,r,MIN_DIST+0.01,MAX_DIST);\n    if(ray.hit && !ray.obj.reflect){\n        if(ray.obj.type == BOXPLANE){//If hits checkerboard set pt to tex\n            vec3 tex = checkerboard2(ray.hitPoint.x, ray.hitPoint.z, 1.0);\n            ray.obj.K_d = (1.0,1.0,1.0) * tex;\n        }else if (ray.obj.type == TEXTBOX){\n         vec3 hp = ray.hitPoint + vec3(.0,-4.4,5.0);\n         vec2 textcoord = vec2(((hp.x+3.0)/6.0),((hp.y+1.0)/2.0));\n         ray.obj.K_d = vec3(texture(iChannel2,textcoord));\n      }\n        else if (ray.obj.type == TEXTBOX2){\n           vec3 hp = ray.hitPoint + vec3(.0,-1.4,7.0);\n           vec2 textcoord = vec2(((hp.x+3.0)/6.0),((hp.y+1.0)/2.0));\n           ray.obj.K_d = vec3(texture(iChannel2,textcoord));\n        }else if (ray.obj.type == TEXTBOX4){\n           vec3 hp = ray.hitPoint + vec3(30.0,0.0,0.0);\n           vec2 textcoord = vec2(((hp.x+22.0)/44.0),((hp.z+100.0)/200.0));\n           ray.obj.K_d = vec3(texture(iChannel1,textcoord));\n        }else if (ray.obj.type == TEXTBOX3){\n           vec3 hp = ray.hitPoint + vec3(2.0,-1.0,4.0);\n           vec2 textcoord = vec2(((hp.x+.5)/1.0),((hp.y+2.0)/4.0));\n           ray.obj.K_d = vec3(texture(iChannel2,textcoord));\n        }\n        vec3 rColor = ray.obj.K_d;\n        return rColor;\n    } else if (ray.hit && ray.obj.reflect){ //the first ray hits another reflecting object\n        for (int i= 0;i<4;i++){\n            if (!ray.obj.reflect){\n                break;\n            }\n            reflectRay = normalize(pt-ray.hitPoint);\n            N = estimateNormal(ray.hitPoint);\n            r = normalize(reflect(-reflectRay,N));\n            ray = shortestDistanceToSurface(ray.hitPoint,r,MIN_DIST+0.01,MAX_DIST);\n            if(ray.obj.type == BOXPLANE){//If hits checkerboard set pt to tex\n                vec3 tex = checkerboard2(ray.hitPoint.x, ray.hitPoint.z, 1.0);\n                ray.obj.K_d = (1.0,1.0,1.0) * tex;\n            }else if (ray.obj.type == TEXTBOX){\n               vec3 hp = ray.hitPoint + vec3(.0,-4.4,5.0);\n               vec2 textcoord = vec2(((hp.x+3.0)/6.0),((hp.y+1.0)/2.0));\n               ray.obj.K_d = vec3(texture(iChannel2,textcoord));\n            }\n            else if (ray.obj.type == TEXTBOX2){\n               vec3 hp = ray.hitPoint + vec3(.0,-1.4,7.0);\n               vec2 textcoord = vec2(((hp.x+3.0)/6.0),((hp.y+1.0)/2.0));\n               ray.obj.K_d = vec3(texture(iChannel2,textcoord));\n            }else if (ray.obj.type == TEXTBOX4){\n               vec3 hp = ray.hitPoint + vec3(30.0,0.0,0.0);\n               vec2 textcoord = vec2(((hp.x+22.0)/44.0),((hp.z+100.0)/200.0));\n               ray.obj.K_d = vec3(texture(iChannel1,textcoord));\n            }\n        }\n        return ray.obj.K_d;\n    }\n    else //ray didn't hit object set to backgroundColor, sky\n        return backgroundColor;\n}\n\n/* Function: This function sets the camera of the scene, by calculating\n forward, orientation, left and up vectors.\n Precondition: Takes in vec3 eye,\n vec3 center of the scene and\n float rotation amount\n PostCondition: retuns mat3 composed of left, up and forward vectors\n */\nmat3 setCamera(vec3 eye, vec3 center, float rotation){\n    vec3 forward = normalize(center-eye);\n    vec3 orientation = vec3(sin(rotation), cos(rotation),0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left,forward));\n\n    return mat3(left,up,forward);\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat clouds(vec3 p) {\n\tvec3 q = p + vec3(-0.1, sin(p.y)*0.25, 1.0)*(10.0+iTime);\n\tfloat v = 0.0;\n\tv += 0.550 * snoise(q*0.051);\n\tv += 0.250 * snoise(q*0.111);\n\tv += 0.125 * snoise(q*0.211);\n\treturn v;\n}\n\n\n//bool KeyIsPressed(float key){return texture( iChannel0, vec2(key, .2)).x > 0.0;}\n//bool KeyIsToggled(float key){return texture( iChannel0, vec2(key, 1.0)).x > 0.0;}\n\nbool iteration(){\n    return true;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = 2.0*uv-1.0;\n    eye = texture(iChannel0, vec2(0.)).xyz;\n    at += eye;\n    \n    \n    vec3 light1Pos = vec3(0.20, 50.0, 20.0)-at;\n    vec3 color = vec3(0.0);\n\n    fog fog1;\n    fog1.color = vec3(0.763,0.834,0.850);\n    fog1.dist = vec2(1.790,20.500);\n    float fogFact;\n    \n\t\n    \n    mat3 toWorld = setCamera(eye,at,0.0);\n    vec3 dir = toWorld * normalize(vec3(uv.xy,2.0));\n    rayDir = dir;\n    \n    float t = (20.0 - rayDir.y) / rayDir.y;\n\n    vec3 backgroundColor;;\n    float cloudA = (smoothstep(0.0, 1.0, 50.0/t)) * 0.25;\n       float cloud = smoothstep(0.0, 0.8, 0.2+clouds(t * rayDir));\n       vec3 col =  skyColor(rayDir);\n       backgroundColor = mix(col, skyColor(reflect(rayDir, vec3(0.0,1.0,0.0))), /*exp(-max(-uv.y*9.-4.8,0.))*/2. );\n      backgroundColor += vec3(cloudA * cloud);\n    \n\n    \n   \n\n    Ray ray = shortestDistanceToSurface(eye,rayDir,MIN_DIST, MAX_DIST);\n\n    if(!ray.hit) { //Set to sky color\n        // clouds\n       cloudA = (smoothstep(0.0, 1.0, 50.0/t)) * 0.25;\n       cloud = smoothstep(0.0, 0.8, 0.2+clouds(t * rayDir));\n       col =  skyColor(reflect(rayDir,vec3(0.,1.,0.)));\n       backgroundColor = mix(col, skyColor(rayDir), /*exp(-max(-uv.y*9.-4.8,0.))*/2. );\n       backgroundColor += vec3(cloudA * cloud);\n       color = backgroundColor;\n    } else {\n        Object hitObj = ray.obj;\n\n        vec3 pt = ray.hitPoint;\n\n        bool visible = isVisible(light1Pos,ray.hitPoint);\n\n        if(hitObj.type == BOXPLANE){ // Floor hit; Set to checkerboard\n          //  vec3 tex = checkerboard2(pt.x, pt.z, 1.0);\n          hitObj.K_d =  vec3(0.135,0.242,0.435);//(1.0,1.0,1.0) * tex;\n        /*  vec3 hp = ray.hitPoint; //+ vec3(.0,-4.4,5.0);\n          vec2 textcoord = vec2(((hp.x+20.0)/40.0),((hp.z+20.)/40.0));\n          hitObj.K_d = vec3(texture(iChannel0,textcoord));*/\n        } else if (hitObj.type == TEXTBOX){\n           vec3 hp = ray.hitPoint + vec3(.0,-4.4,5.0);\n           vec2 textcoord = vec2(((hp.x+3.0)/6.0),((hp.y+1.0)/2.0));\n           hitObj.K_d = vec3(texture(iChannel2,textcoord));\n        }\n        else if (hitObj.type == TEXTBOX2){\n           vec3 hp = ray.hitPoint + vec3(4.0,-2.5,4.0);\n           vec2 textcoord = vec2(((hp.y+.5)/1.0),((hp.z+3.0)/6.0));\n           hitObj.K_d = vec3(texture(iChannel2,textcoord));\n        }\n        else if (hitObj.type == TEXTBOX3){\n           vec3 hp = ray.hitPoint + vec3(2.0,-1.0,4.0);\n           vec2 textcoord = vec2(((hp.x+.5)/1.0),((hp.y+2.0)/4.0));\n           hitObj.K_d = vec3(texture(iChannel2,textcoord));\n        }else if (hitObj.type == TEXTBOX4){\n          vec3 hp = ray.hitPoint + vec3(30.0,0.0,0.0);\n          vec2 textcoord = vec2(((hp.x+22.0)/8.0),((hp.z+100.0)/35.0));\n           hitObj.K_d =  vec3(texture(iChannel1,textcoord));\n        }else if (hitObj.type == BUILDING){\n          vec3 hp = ray.hitPoint;\n          vec2 textcoord = vec2(hp.y,hp.z);\n            \n          // hitObj.K_d =  vec3(texture(iChannel3,textcoord));\n            \n        }\n\n\n        vec3 K_a = vec3(0.3, 0.3, 0.3);\n        vec3 K_d = vec3(0);\n        vec3 K_s = vec3(0);\n        float shininess =20.;\n        if(visible){\n            K_d = hitObj.K_d;\n            K_s = vec3(1.0,1.0,1.0);\n        }\n        if (hitObj.reflect){\n            vec3 rColor = isReflect(eye,pt, backgroundColor);\n            K_d = rColor;\n        }\n       if(hitObj.type == LAMP){\n          K_a = vec3(1.0,1.0,1.0);\n          //K_s = vec3(1.0,1.0,1.0);\n       }\n        color = phongIllumination(K_a, K_d, K_s, shininess, ray, eye, light1Pos);\n        \n    }\n    \n    vec3 pt = ray.hitPoint;\n    float vDist = distance(pt,eye);\n    //fogFact = clamp((fog1.dist.y-vDist)/\n      //        (fog1.dist.y-fog1.dist.x),0.0,1.0);\n    //Exponential Fog\n    fogFact = 1.0 / exp((vDist*fogDensity));\n    fogFact = clamp(fogFact,0.0,1.0);\n\n    vec3 c = mix(fog1.color,color,fogFact);\n\n\n    fragColor = vec4(color,1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_A = 65.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_W = 87.5/256.0;\nconst float KEY_D = 68.5/256.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) \n        pos = vec3(0.0,3.0,20.0);\n      \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n      \n    pos.x += (forwardBackward);\n\tpos.z += (leftRight  + leftRight );\n    \n    fragColor = vec4(pos,0.);\n}","name":"Buf A","description":"","type":"buffer"}]}