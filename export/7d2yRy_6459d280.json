{"ver":"0.1","info":{"id":"7d2yRy","date":"1643785510","viewed":178,"name":"test sample 01","username":"flutesandyou","description":"this shader is just a test by Maksim","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["vhs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// output + pixel effect on top\n\n#define resolution ( iResolution.xy )\n#define VHSRES vec2(320.0,240.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //A buff + VHSRes screen space\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy / iResolution.xy * VHSRES;\n    vec4 color = texture( iChannel0, uv );\n    \n    //CRT \"pixel\" effect\n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;  \n    \n    // Output to screen\n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// vhs effects + text buff\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define VHSRES vec2(320.0,240.0)\n#define saturate(i) clamp(i,0.,1.)\n#define validuv(v) (abs(v.x-0.5)<0.5&&abs(v.y-0.5)<0.5)\n#define SAMPLES 6\n\nfloat v2random( vec2 uv ) {\n  return texture( iChannel1, mod( uv, vec2( 0.0 ) ) ).x;\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\nvec3 rgb2yiq( vec3 rgb ) {\n  return mat3( 0.299, 0.596, 0.211, 0.587, -0.274, -0.523, 0.114, -0.322, 0.312 ) * rgb;\n}\n\nvec3 yiq2rgb( vec3 yiq ) {\n  return mat3( 1.000, 1.000, 1.000, 0.956, -0.272, -1.106, 0.621, -0.647, 1.703 ) * yiq;\n}\n\n\n//rgb to yiq color conversion to mimic TV broadcast colors + blur effect\nvec3 vhsTex2D( vec2 uv, float rot ) {\n  if ( validuv( uv ) ) {\n    vec3 yiq = vec3( 0.0 );\n    vec3 yiq2 = vec3 (0.0);\n    for ( int i = 0; i < SAMPLES; i ++ ) \n    {\n        yiq += (rgb2yiq( texture( iChannel0, uv - vec2( float( i ), 0.0 ) / VHSRES ).xyz ) *\n        vec2( float( i ), float( SAMPLES - 1 - i ) ).yxx / float( SAMPLES - 1 )) / float( SAMPLES ) * 2.0;\n    }\n    \n    for ( int i = 0; i < SAMPLES; i ++ ) \n    {\n        //reducing samples to reduce blur on \"PLAY\" text.\n        yiq2 += (rgb2yiq( texture( iChannel2, uv - vec2( float( i ), 0.0 ) / VHSRES ).xyz ) *\n        vec2( float( i ), float( SAMPLES - 2 - i ) ).yxx / float( SAMPLES - 1 )) / float( SAMPLES ) * 2.0;\n    }\n    \n    if ( rot != 0.0 ) { yiq.yz = rotate2D( rot ) * yiq.yz; }\n    return yiq2rgb( yiq + yiq2 );\n  }\n  return vec3( 0.1, 0.1, 0.1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / VHSRES;\n  float time = iTime;\n\n  vec2 uvn = uv;\n  vec3 col = vec3( 0.0, 0.0, 0.0 );\n\n  // tape crease\n  float tcPhase = smoothstep( 0.9, 0.96, sin( uvn.y * 8.0 - ( time + 0.14 * v2random( time * vec2( 0.67, 0.59 ) ) ) * PI * 1.2 ) );\n  float tcNoise = smoothstep( 0.3, 1.0, v2random( vec2( uvn.y * 1.77, time ) ) );\n  uvn.x = uvn.x -0.0 / VHSRES.x * 8.0;\n\n  // switching noise\n  float snPhase = smoothstep( 6.0 / VHSRES.y, 0.0, uvn.y );\n  uvn.y += snPhase * 0.3;\n  uvn.x += snPhase * ( ( v2random( vec2( uv.y * 100.0, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 24.0 );\n\n  // fetch\n  col = vhsTex2D( uvn, tcPhase * 0.2 + snPhase * 2.0 );\n\n  // crease noise\n  float cn = tcNoise * ( 0.3 + 0.7 * tcPhase );\n  if ( 0.29 < cn ) {\n    vec2 uvt = ( uvn + V.yx * v2random( vec2( uvn.y, time ) ) ) * vec2( 0.1, 1.0 );\n    float n0 = v2random( uvt );\n    float n1 = v2random( uvt + V.yx / VHSRES.x );\n    if ( n1 < n0 ) {\n      col = mix( col, 2.0 * V.yyy, pow( n0, 10.0 ) );\n    }\n  }\n\n  // color noise\n  col *= 0.9 + 0.1 * texture( iChannel1, mod( uvn * vec2( 1.0, 1.0 ) + time * vec2( 5.97, 4.45 ), vec2( 1.0 ) ) ).xyz;\n  col = saturate( col );\n  // yiq\n  col = rgb2yiq( col );\n  col = yiq2rgb( col );\n\n  fragColor = vec4( col, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//input buff with saturaton and chromatic aberration\n\n#define M_PI 3.1415926535897932384626433832795\n#define circlingTime 5.0\n#define restartTime 8.0\n#define circleStartOffset M_PI\n\n// saturation mtx func\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n    { \n    \n        vec2 uv = fragCoord.xy / iResolution.xy;\n        const float saturation = 1.5;\n        vec3 col;\n        float amount = 0.0;\n\n        \n        // chromatic aberrtion time\n        amount = smoothstep(0.8,1.0,sin(iTime*2.0));\n        amount = pow(amount, 8.0);\n        //chromatic aberration amount\n        amount *= 0.05;\n        \n        //map color offsets\n        col.r = texture( iChannel0, vec2(uv.x+amount,uv.y) ).r;\n        col.g = texture( iChannel0, uv ).g;\n        col.b = texture( iChannel0, vec2(uv.x-amount,uv.y) ).b;\n        \n        // output\n        fragColor = saturationMatrix( saturation ) * vec4(col,1.0);\n        \n    }","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Text buff\n\n#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    vec2 screenUV = uv.xy / iResolution.xy;\n    vec2 uvn = uv.xy / iResolution.xy;\n    O = vec4(0.0);\n    vec2 position = vec2(0.7,0.85);\n    float FontSize = 4.;\n    vec2 U = ( uvn - position)*64.0/FontSize;\n    C(16);C(12);C(1);C(25);C(224);C(197);\n    O = O.xxxx;\n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner\n//line 13 -> higher value = greater font size\n//line 15 -> Every argument is another char","name":"Buffer C","description":"","type":"buffer"}]}