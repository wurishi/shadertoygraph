{"ver":"0.1","info":{"id":"4llXzN","date":"1434980871","viewed":276,"name":"Shiny glowing metaballs","username":"zogi","description":"Raymarched metaballs.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define TMAX 20.0\n#define pi 3.14159265\n\n#define WISP_GLOW_R 0.3\n#define GLOW_COLOR (vec3(0.2, 0.3, 0.5))\n#define DIFFUSE_COLOR vec3(0.1, 0.4, 0.8)\n#define RF0 vec3(0.3, 0.3, 0.3)\n#define FREH_MULT 1.0\n\n//Bump mapping intensity\n#define BUMP_STRENGTH 0.02\n#define BUMP_WIDTH 0.4\n\nvec3 rot_y(vec3 v, float phi)\n{\n    return vec3(cos(phi)*v.x+sin(phi)*v.z, v.y, -sin(phi)*v.x+cos(phi)*v.z);\n}\n\nvec2 rot2d(vec2 v, float phi)\n{\n    return vec2(cos(phi)*v.x + sin(phi)*v.y, -sin(phi)*v.x + cos(phi)*v.y);\n}\n\nfloat time()\n{\n    return iTime;\n}\n\nfloat smin(float a, float b, float blendRadius)\n{\n\tfloat c = clamp(0.5 + (b - a) * (0.5 / blendRadius), 0.0, 1.0);\n\treturn mix(b, a, c) - blendRadius * c * (1.0 - c);\n}\n\nstruct wisp_opts\n{\n    float grow_r;\n    bool neg;\n};\n\nfloat sphere(vec3 p, float r, wisp_opts opts)\n{\n    float d = length(p) - (r+opts.grow_r);\n    return d;\n}\n\n#define N 4\n\nfloat wisp_gen(vec3 p, wisp_opts opts)\n{\n    float blend_r = 0.5;\n\n    float t = time();\n    vec3 c[N];\n    c[0] = 1.0*vec3(0.2, 0.4*sin(4.0*t), 0.0);\n    c[1] = 1.0*vec3(-0.2, -0.4*sin(4.0*t), 0.0);\n    c[2] = 1.25*vec3(0.4*cos(4.0*t), 0.2, 0.0);\n    c[3] = 1.25*vec3(-0.4*cos(4.0*t), -0.2, 0.0);\n    \n    /*\n    c[4] = 1.5*vec3(0.4*sin(8.0*t), 0.0, 0.4*cos(8.0*t));\n    c[5] = rot_y(c[4], pi*0.25);\n    c[6] = rot_y(c[4], pi*0.5);\n    c[7] = rot_y(c[4], pi*0.75);\n    \n    float AY = 0.4;\n    float P = 0.1;\n    c[4].y = AY*sin(2.0*(t));\n    c[5].y = AY*sin(2.0*(t + P));\n    c[6].y = AY*sin(2.0*(t + 2.0*P));\n    c[7].y = AY*sin(2.0*(t + 3.0*P));\n\t*/\n\n    float r[N];\n    r[0] = r[1] = r[2] = r[3] = 0.14;\n    /*\n    r[4] = r[5] = r[6] = r[7] = 0.001;\n\t*/\n    \n    float d =   sphere(p-c[0], r[0], opts);\n    for (int i = 1; i < N; ++i) {\n    \td = smin(d, sphere(p-c[i], r[i], opts), blend_r);\n    }\n    if (opts.neg)\n        d = -d;\n    return d;\n}\n\nfloat wisp(vec3 p)\n{\n    wisp_opts opts;\n    opts.grow_r = 0.0;\n    opts.neg = false;\n    return wisp_gen(p, opts);\n}\n\nvec3 wisp_normal(vec3 p)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        wisp(p+eps.xyy) - wisp(p-eps.xyy),\n        wisp(p+eps.yxy) - wisp(p-eps.yxy),\n        wisp(p+eps.yyx) - wisp(p-eps.yyx)));\n}\n\nvec3 normal_sobel(vec3 x)\n{\n    float delta = 0.1;\n    vec3 res = vec3(0.0, 0.0, 0.0);\n    for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n            float a = float(j==1) + float(k==1) + 2.0;\n            res.x +=  a * wisp(x + delta*vec3( 1,j-1,k-1));\n            res.x += -a * wisp(x + delta*vec3(-1,j-1,k-1));\n            res.y +=  a * wisp(x + delta*vec3(j-1, 1,k-1));\n            res.y += -a * wisp(x + delta*vec3(j-1,-1,k-1));\n            res.z +=  a * wisp(x + delta*vec3(j-1,k-1, 1));\n            res.z += -a * wisp(x + delta*vec3(j-1,k-1,-1));\n        }\n    }\n    return res/length(res);\n}\n\nfloat cast_ray_gen(vec3 p, vec3 v, wisp_opts opts)\n{\n    float eps = 0.01;\n    float tmin = 0.0;\n    \n    float t = tmin;\n    float last_t = t;\n    float last_d = 0.0;\n    for (int i = 0; i < 120; i++) {\n        float d = wisp_gen(p + t*v, opts);\n        \n        if (last_t+last_d-(t-d) > 0.0) {\n            t = last_t + last_d;\n            d = wisp_gen(p + t*v, opts);\n        }\n\t\t\n        if (d<eps || t>TMAX) break;\n\n        last_t = t;\n        last_d = d;\n        t += 1.2*d;\n    }\n    return t;\n}\n\nfloat cast_ray(vec3 p, vec3 v)\n{\n    wisp_opts opts;\n    opts.grow_r = 0.0;\n    opts.neg = false;\n    return cast_ray_gen(p, v, opts);\n}\n\n\nfloat cast_ray_glow(vec3 p, vec3 v, float tmax)\n{\n    tmax = min(tmax, TMAX);\n    float eps = 0.1;\n    \n    wisp_opts opts;\n    opts.grow_r = WISP_GLOW_R;\n    \n    float res = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 10; ++i) {\n        opts.neg = false;\n        float t_front = cast_ray_gen(p+t*v, v, opts);\n        t += t_front;\n        if (t > tmax) break;\n        \n        float t_enter = t;\n        opts.neg = true;\n        t += eps;\n        float thickness = cast_ray_gen(p+t*v, v, opts);\n        thickness = min(thickness, tmax-t);\n        t += thickness;\n        float d = 0.0;\n        for (float f = 0.25; f < 1.0; f += 0.25)\n            d += wisp(p+(f*t_enter+(1.0-f)*t)*v);\n        d /= 4.0;\n        float density = 1.0 - smoothstep(-0.0, WISP_GLOW_R, d);\n        density = pow(density, 1.5);\n        res += (thickness+eps)*density;\n        t += eps;\n        if (t > tmax) break;\n\t}\n    return res;\n}\n\n//From TekF (https://www.shadertoy.com/view/ltXGWS)\nfloat cells(in vec3 p)\n{\n    p = fract(p/2.0)*2.0;\n    p = min(p, 2.0-p);\n    return 1.-min(length(p),length(p-1.0));\n}\n\nfloat btex(in vec3 p)\n{\n    return cells(p*15.0);\n}\n\n//From ChristinaCoffin (https://www.shadertoy.com/view/ll23Rd)\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(BUMP_WIDTH*sqrt(ds)*0.5, 0);\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p+e.xyy)-n0, btex(p+e.yxy)-n0, btex(p+e.yyx)-n0)/e.x;\n    vec3 tgd = d - n*dot(n ,d);\n    n = normalize(n-tgd*BUMP_STRENGTH*2./(ds));\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = 0.35;\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.x;\n    vec2 c = vec2(0.0, 0.0);\n    \n    vec3 ray = vec3(uv - c, f);\n    normalize(ray);\n    \n    float T = time();\n    float phi = 0.3 * T;\n    ray = rot_y(ray, phi);\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    cam = rot_y(vec3(0.0, 0.0, -1.5), phi);\n\t\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 col_bg = texture(iChannel0, ray).xyz;\n\n    float tmax = 20.0;\n    \n    float t = cast_ray(cam, ray);\n    \n    vec3 p = cam + t*ray;\n    float ccos = 0.0;\n    if (t <= TMAX) {\n        vec3 n = wisp_normal(p);\n        \n        n = bump(p, n, distance(cam, p));\n        \n        vec3 rr = reflect(ray, n);\n        vec3 irrd = texture(iChannel1, n).xyz;\n        vec3 refl = texture(iChannel0, rr).xyz;\n        ccos = max(0.0, dot(-ray, n));\n        \n        float sch = pow(1.0-ccos, 5.0);\n        vec3 freh = RF0 + sch*(vec3(1.0,1.0,1.0)-RF0);\n        \n        col += mix(DIFFUSE_COLOR*irrd, refl, FREH_MULT*freh);\n    \n        // fake anti-aliasing\n\t\tcol = mix(col_bg+GLOW_COLOR, col, smoothstep(0.0, 1e-1, ccos));\n    } else {\n        col = col_bg;\n    }\n    \n    vec3 glow = cast_ray_glow(cam, ray, t) * GLOW_COLOR;\n\n    col += glow;\n    \n    col = pow(1.2*col, vec3(0.8,0.9,1.0));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}