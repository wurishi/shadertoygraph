{"ver":"0.1","info":{"id":"ml3GzX","date":"1682814582","viewed":194,"name":"Shader Jam SESSIONS 2023","username":"sp4ghet","description":"no time to practice or think of an idea, kind of want to try more of this effect","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["jam","livecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n#define saturate(x) clamp((x), 0., 1.)\n\nfloat time, beat, bHalf, whole;\nfloat bpm = 130.;\n\nmat3 ortho(vec3 z){\n  z = normalize(z);\n  vec3 up = vec3(0,1,0);\n  vec3 cx = normalize(cross(z, up));\n  vec3 cy = normalize(cross(cx, z));\n  return mat3(cx, cy, z);\n}\n\nfloat noise(vec3 p){\n  vec3 s = vec3(.1, .9, .2);\n  float n = 0.;\n  float amp = 1., gain = 0.5, lac = 1.4;\n  float warp = 1.3, warpTrk=.7,warpGa=1.5;\n  mat3 rot = ortho(s);\n  \n  for(int i=0; i < 5; i++){\n    p += sin(p.yzx * warpTrk)*warp;\n    n += amp*sin(dot(cos(p.zxy), sin(p.yzx)));\n    p *= rot;\n    p *= lac;\n    warpTrk *= warpGa;\n    amp *= gain;\n    \n    }\n  return n;\n}\n\nfloat random(int n){\n    n = (n << 13) ^ n;\n  return 1.0 - float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;\n  }\n\nfloat fractSin(vec2 p){\n    return fract(sin(dot(p, vec2(12.18181, 4.1141414))) * 42069.666);\n  }\n\nvec3 cosgrad(float t){\n    return 0.5 + 0.5 * cos(2. * PI * (vec3(t) + vec3(.66666, .33333, 0.)));\n}\n\nfloat aBeat = 0., aHalf;\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(0., max(q.x, max(q.y,q.z)));\n}\n\n#define r2d(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n#define sq(x) ((x)*(x))\n\n\nfloat map(vec3 q){\n    vec3 p = q;\n    float d = 1000.;\n    int mi = int(whole) % 6;\n    //mi = 1;\n    \n    if(mi == 0){\n      d = length(p) - .1 - aBeat;\n    }\n    if(mi == 1){\n      p.xz *= r2d(PI * .5 * p.y + PI * aHalf);\n      d = sdBox(p, vec3(1, 1, 1));\n      \n      p = q;\n      p = abs(p);\n      int exclude = int(random(int(beat)) * 3.);\n      int i = exclude == 0 ? 1 : 0;\n      int j = exclude == 0 ? 2 : exclude == 1 ? 2 : 1;\n      vec2 pp = vec2(p[i], p[j]);\n      pp *= r2d(0.5 * PI * aBeat);\n      p[i] = pp.x;\n      p[j] = pp.y;\n      d = min(d, sdBox(p - vec3(2,0,0), vec3(.25)));\n    }\n    if(mi == 2){\n      p = q;\n      p.xz *= r2d(PI * .5 * aBeat + time);\n      d = sdBox(p - vec3(0., 1./2., 0.), vec3(1., 1.0/6., 1.));\n      p = q;\n      p.xz *= r2d(time);\n      d = min(d, sdBox(p, vec3(1., 1.0/6., 1.)));\n      p.xz *= r2d(-PI * .5*aBeat);\n      d = min(d, sdBox(p + vec3(0., 1./2., 0.), vec3(1., 1.0/6., 1.)));\n    }\n    if(mi == 3){\n      int cnt = int(fract(whole) * 16.) + 1;\n      for(int i=-cnt/2; i<cnt/2; i++){\n        d = min(d, sdBox(p - vec3(float(i) * .2, sin(PI * p.x), 0.), vec3(.03, 1., 1.)));\n      }\n    }\n    if(mi == 4){\n      int sd = 114514 + int(beat);\n      for(int i=0; i<5; i++){\n        sd += i;\n        vec3 h = 2. * vec3(random(sd), random(sd + 186), random(sd + 189));\n        vec3 n = 2. * vec3(random(sd + 1), random(sd + 186 + 1), random(sd + 189 + 1));\n        vec3 c = mix(h,n, aBeat);\n        d = min(length(p - c) - .35 - .1 * random(sd), d);\n      }\n    }\n    if(mi == 5){\n      d = p.y + 2. - .1 * noise(vec3(p.xz, floor(beat) + aBeat));\n    }\n    \n    if(mi == 6){\n      // im out of ideas, bye\n    }\n    \n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n  vec2 e = vec2(0, 1e-4);\n  return normalize(\n  vec3(\n  map(p + e.yxx) - map(p -e.yxx),\n  map(p + e.xyx) - map(p -e.xyx),\n  map(p + e.xxy) - map(p -e.xxy)\n  )\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float offset = fractSin(pt * iTime);\n  time = iTime + offset * .2;\n  beat = time * bpm / 60.0;\n  bHalf = beat * .5;\n  whole = beat * .25;\n  \n  vec3 c = vec3(0,0,0);\n  float anim = 0.5 + 0.5 * cos(PI * exp(-3. * fract(beat)));\n  aBeat = anim;\n  aHalf = smoothstep(0., 1., fract(bHalf));\n  c += .01 * cosgrad(offset) * noise(vec3(pt * 4., floor(beat) + anim));\n  c = abs(c);\n\n  \n  vec3 ro = vec3(0., 0., -5. + sin(time));\n  vec3 rd = ortho(normalize(-ro)) * normalize(vec3(r2d(whole * .1) * pt, 1.));\n  float t = 0., d, thresh=1e-3;\n  vec3 p;\n  \n  for(int i=0; i<100; i++){\n    p = ro+rd*t;\n    d = map(p);\n    if(abs(d) < thresh || t > 100.){\n      break;\n    }\n    t += d;\n    thresh = 1e-3 * t;\n  }\n  \n\n  if(abs(d) < thresh){\n    vec3 n = normal(p);\n    vec3 l = normalize(vec3(1));\n    c += cosgrad(offset) * sq(0.5 + 0.5 * dot(n,l));\n  }\n  \n  c = pow(c, vec3(.4545));\n  fragColor = vec4(c,0);\n}","name":"Image","description":"","type":"image"}]}