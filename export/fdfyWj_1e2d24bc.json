{"ver":"0.1","info":{"id":"fdfyWj","date":"1642673551","viewed":143,"name":"Ease Demo","username":"Sudospective","description":"This is a shader to help with visualizing, understanding, and memorizing eases.\n\nThere are more details in the comments of the shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["study","learning","demonstration","tools","ease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415927\n\n/*\nEASE DEMO\nBy Sudospective\n\nThis is a shader to help with visualizing, understanding and memorizing eases.\n\nThe magenta line shows the graph of the current selected ease.\nThe vertical cyan line shows the time in the current ease position.\nThe horizontal cyan line shows the value in the current ease position.\nThe color gradient shows the relation between arbitrary points on a graph and the ease.\nRed indicates time closer to the end of the ease.\nGreen indicates a value below the ease at a current point in time.\n\nThe texture shows a live demonstration of the ease transforming the X-axis position.\nThe linear ease will give a soft scrolling effect while the inOutExpo ease will give\na \"quick-pan\" sort of transition.\n\nReplace the EASE definition with one of the integers listed in the ease comment below\nto visualize that ease.\n*/\n\n/*\nEases:\n    1.  linear\n    2.  inSine\n    3.  outSine\n    4.  inOutSine\n    5.  inQuad\n    6.  outQuad\n    7.  inOutQuad\n    8.  inCubic\n    9.  outCubic\n    10. inOutCubic\n    11. inQuart\n    12. outQuart\n    13. inOutQuart\n    14. inQuint\n    15. outQuint\n    16. inOutQuint\n    17. inExpo\n    18. outExpo\n    19. inOutExpo\n    20. inCirc\n    21. outCirc\n    22. inOutCirc\n    23. inBack\n    24. outBack\n    25. inOutBack\n    26. inElastic\n    27. outElastic\n    28. inOutElastic\n    29. inBounce\n    30. outBounce\n    31. inOutBounce\n*/\n#define EASE 1\n\nbool near(float var, float target, float size) {\n    return var >= target - size && var <= target + size;\n}\n\n// Ease functions from easings.net\nfloat linear(float x) {\n    return x;\n}\nvec2 linear(vec2 val) {\n    val.x = linear(val.x);\n    val.y = linear(val.y);\n    return val;\n}\n\nfloat inSine(float x) {\n    return 1.0 - cos(x * PI * 0.5);\n}\nvec2 inSine(vec2 val) {\n    val.x = inSine(val.x);\n    val.y = inSine(val.y);\n    return val;\n}\nfloat outSine(float x) {\n    return sin(x * PI * 0.5);\n}\nvec2 outSine(vec2 val) {\n    val.x = outSine(val.x);\n    val.y = outSine(val.y);\n    return val;\n}\nfloat inOutSine(float x) {\n    return -(cos(x * PI) - 1.0) * 0.5;\n}\nvec2 inOutSine(vec2 val) {\n    val.x = inOutSine(val.x);\n    val.y = inOutSine(val.y);\n    return val;\n}\n\nfloat inQuad(float x) {\n    return pow(x, 2.0);\n}\nvec2 inQuad(vec2 val) {\n    val.x = inQuad(val.x);\n    val.y = inQuad(val.y);\n    return val;\n}\nfloat outQuad(float x) {\n    return 1.0 - pow(1.0 - x, 2.0);\n}\nvec2 outQuad(vec2 val) {\n    val.x = outQuad(val.x);\n    val.y = outQuad(val.y);\n    return val;\n}\nfloat inOutQuad(float x) {\n    return x < 0.5 ? 2.0 * pow(x, 2.0) : 1.0 - pow(-2.0 * x + 2.0, 2.0) * 0.5;\n}\nvec2 inOutQuad(vec2 val) {\n    val.x = inOutQuad(val.x);\n    val.y = inOutQuad(val.y);\n    return val;\n}\n\nfloat inCubic(float x) {\n    return pow(x, 3.0);\n}\nvec2 inCubic(vec2 val) {\n    val.x = inCubic(val.x);\n    val.y = inCubic(val.y);\n    return val;\n}\nfloat outCubic(float x) {\n    return 1.0 - pow(1.0 - x, 3.0);\n}\nvec2 outCubic(vec2 val) {\n    val.x = outCubic(val.x);\n    val.y = outCubic(val.y);\n    return val;\n}\nfloat inOutCubic(float x) {\n    return x < 0.5 ? 4.0 * pow(x, 3.0) : 1.0 - pow(-2.0 * x + 2.0, 3.0) * 0.5;\n}\nvec2 inOutCubic(vec2 val) {\n    val.x = inOutCubic(val.x);\n    val.y = inOutCubic(val.y);\n    return val;\n}\n\nfloat inQuart(float x) {\n    return pow(x, 4.0);\n}\nvec2 inQuart(vec2 val) {\n    val.x = inQuart(val.x);\n    val.y = inQuart(val.y);\n    return val;\n}\nfloat outQuart(float x) {\n    return 1.0 - pow(1.0 - x, 4.0);\n}\nvec2 outQuart(vec2 val) {\n    val.x = outQuart(val.x);\n    val.y = outQuart(val.y);\n    return val;\n}\nfloat inOutQuart(float x) {\n    return x < 0.5 ? 8.0 * pow(x, 4.0) : 1.0 - pow(-2.0 * x + 2.0, 4.0) * 0.5;\n}\nvec2 inOutQuart(vec2 val) {\n    val.x = inOutQuart(val.x);\n    val.y = inOutQuart(val.y);\n    return val;\n}\n\nfloat inQuint(float x) {\n    return pow(x, 5.0);\n}\nvec2 inQuint(vec2 val) {\n    val.x = inQuint(val.x);\n    val.y = inQuint(val.y);\n    return val;\n}\nfloat outQuint(float x) {\n    return 1.0 - pow(1.0 - x, 5.0);\n}\nvec2 outQuint(vec2 val) {\n    val.x = outQuint(val.x);\n    val.y = outQuint(val.y);\n    return val;\n}\nfloat inOutQuint(float x) {\n    return x < 0.5 ? 16.0 * pow(x, 5.0) : 1.0 - pow(-2.0 * x + 2.0, 5.0) * 0.5;\n}\nvec2 inOutQuint(vec2 val) {\n    val.x = inOutQuint(val.x);\n    val.y = inOutQuint(val.y);\n    return val;\n}\n\nfloat inExpo(float x) {\n    return x == 0.0 ? 0.0 : pow(2.0, 10.0 * x - 10.0);\n}\nvec2 inExpo(vec2 val) {\n    val.x = inExpo(val.x);\n    val.y = inExpo(val.y);\n    return val;\n}\nfloat outExpo(float x) {\n    return x == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * x);\n}\nvec2 outExpo(vec2 val) {\n    val.x = outExpo(val.x);\n    val.y = outExpo(val.y);\n    return val;\n}\nfloat inOutExpo(float x) {\n    return x == 0.0\n        ? 0.0\n    \t: x == 1.0\n            ? 1.0\n            : x < 0.5\n                ? pow(2.0, 20.0 * x - 10.0) * 0.5\n    \t\t\t: (2.0 - pow(2.0, -20.0 * x + 10.0)) * 0.5;\n}\nvec2 inOutExpo(vec2 val) {\n    val.x = inOutExpo(val.x);\n    val.y = inOutExpo(val.y);\n    return val;\n}\n\nfloat inCirc(float x) {\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\nvec2 inCirc(vec2 val) {\n    val.x = inCirc(val.x);\n    val.y = inCirc(val.y);\n    return val;\n}\nfloat outCirc(float x) {\n    return sqrt(1.0 - pow(x - 1.0, 2.0));\n}\nvec2 outCirc(vec2 val) {\n    val.x = outCirc(val.x);\n    val.y = outCirc(val.y);\n    return val;\n}\nfloat inOutCirc(float x) {\n    return x < 0.5\n        ? (1.0 - sqrt(1.0 - pow(2.0 * x, 2.0))) * 0.5\n        : (sqrt(1.0 - pow(-2.0 * x + 2.0, 2.0)) + 1.0) * 0.5;\n}\nvec2 inOutCirc(vec2 val) {\n    val.x = inOutCirc(val.x);\n    val.y = inOutCirc(val.y);\n    return val;\n}\n\nconst float c1 = 1.70158;\nconst float c2 = c1 * 1.525;\nconst float c3 = c1 + 1.0;\nconst float c4 = (2.0 * PI) / 3.0;\nconst float c5 = (2.0 * PI) / 4.5;\n\nfloat inBack(float x) {\n    return c3 * pow(x, 3.0) - c1 * pow(x, 2.0);\n}\nvec2 inBack(vec2 val) {\n    val.x = inBack(val.x);\n    val.y = inBack(val.y);\n    return val;\n}\nfloat outBack(float x) {\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\nvec2 outBack(vec2 val) {\n    val.x = outBack(val.x);\n    val.y = outBack(val.y);\n    return val;\n}\nfloat inOutBack(float x) {\n    return x < 0.5\n        ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) * 0.5\n        : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) * 0.5;\n}\nvec2 inOutBack(vec2 val) {\n    val.x = inOutBack(val.x);\n    val.y = inOutBack(val.y);\n    return val;\n}\n\nfloat inElastic(float x) {\n    return x == 0.0\n        ? 0.0\n        : x == 1.0\n            ? 1.0\n            : -pow(2.0, 10.0 * x - 10.00) * sin((x * 10.0 - 10.75) * c4);\n}\nvec2 inElastic(vec2 val) {\n    val.x = inElastic(val.x);\n    val.y = inElastic(val.y);\n    return val;\n}\nfloat outElastic(float x) {\n    return x == 0.0\n        ? 0.0\n        : x == 1.0\n            ? 1.0\n            : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nvec2 outElastic(vec2 val) {\n    val.x = outElastic(val.x);\n    val.y = outElastic(val.y);\n    return val;\n}\nfloat inOutElastic(float x) {\n    return x == 0.0\n        ? 0.0\n        : x == 1.0\n            ? 1.0\n            : x < 0.5\n                ? -(pow(2.0, 20.0 * x - 10.0) * sin((20.0 * x - 11.125) * c5)) * 0.5\n    \t\t\t: (pow(2.0, -20.0 * x + 10.0) * sin((20.0 * x - 11.125) * c5)) * 0.5 + 1.0;\n}\nvec2 inOutElastic(vec2 val) {\n    val.x = inOutElastic(val.x);\n    val.y = inOutElastic(val.y);\n    return val;\n}\n\nfloat n1 = 7.5625;\nfloat d1 = 2.75;\n\n// Have to do outBounce before inBounce.\nfloat outBounce(float x) {\n    if (x < 1.0 / d1) {\n        return n1 * pow(x, 2.0);\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nvec2 outBounce(vec2 val) {\n    val.x = outBounce(val.x);\n    val.y = outBounce(val.y);\n    return val;\n}\nfloat inBounce(float x) {\n    return 1.0 - outBounce(1.0 - x);\n}\nvec2 inBounce(vec2 val) {\n    val.x = inBounce(val.x);\n    val.y = inBounce(val.y);\n    return val;\n}\nfloat inOutBounce(float x) {\n    return x < 0.5\n        ? (1.0 - outBounce(1.0 - 2.0 * x)) * 0.5\n        : (1.0 + outBounce(2.0 * x - 1.0)) * 0.5;\n}\nvec2 inOutBounce(vec2 val) {\n    val.x = inOutBounce(val.x);\n    val.y = inOutBounce(val.y);\n    return val;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = iResolution.x / iResolution.y;\n    uv.y *= 1.75;\n    uv.y -= 0.375;\n    \n    float easeTime = mod(iTime, 2.0) * 0.5;\n    \n    vec2 val = vec2(uv.x, easeTime);\n    \n    val = EASE == 1\n        ? linear(val)\n        : EASE == 2\n        ? inSine(val)\n        : EASE == 3\n        ? outSine(val)\n        : EASE == 4\n        ? inOutSine(val)\n        : EASE == 5\n        ? inQuad(val)\n        : EASE == 6\n        ? outQuad(val)\n        : EASE == 7\n        ? inOutQuad(val)\n        : EASE == 8\n        ? inCubic(val)\n        : EASE == 9\n        ? outCubic(val)\n        : EASE == 10\n        ? inOutCubic(val)\n        : EASE == 11\n        ? inQuart(val)\n        : EASE == 12\n        ? outQuart(val)\n        : EASE == 13\n        ? inOutQuart(val)\n        : EASE == 14\n        ? inQuint(val)\n        : EASE == 15\n        ? outQuint(val)\n        : EASE == 16\n        ? inOutQuint(val)\n        : EASE == 17\n        ? inExpo(val)\n        : EASE == 18\n        ? outExpo(val)\n        : EASE == 19\n        ? inOutExpo(val)\n        : EASE == 20\n        ? inCirc(val)\n        : EASE == 21\n        ? outCirc(val)\n        : EASE == 22\n        ? inOutCirc(val)\n        : EASE == 23\n        ? inBack(val)\n        : EASE == 24\n        ? outBack(val)\n        : EASE == 25\n        ? inOutBack(val)\n        : EASE == 26\n        ? inElastic(val)\n        : EASE == 27\n        ? outElastic(val)\n        : EASE == 28\n        ? inOutElastic(val)\n        : EASE == 29\n        ? inBounce(val)\n        : EASE == 30\n        ? outBounce(val)\n        : EASE == 31\n        ? inOutBounce(val)\n        : vec2(0.0, 0.0);\n    \n    \n    vec3 color = vec3(uv.x, smoothstep(-0.1, 0.1, val.x - uv.y), 0.0);\n    \n    vec2 tex_uv = fragCoord.xy / iResolution.xy;\n    tex_uv.x += val.y;\n    vec4 tex = texture(iChannel0, fract(tex_uv));\n    \n    if (near(uv.y, val.x, 0.005)) {\n        color = vec3(1.0, 0.0, 1.0);\n    }\n    if (near(uv.y, val.y, 0.005)) {\n        color = vec3(0.0, 1.0, 1.0);\n    }\n    if (near(uv.x, easeTime, 0.003 / scale)) {\n        color = vec3(0.0, 1.0, 1.0);\n    }\n    if (near(uv.y, 1.0, 0.005) || near(uv.y, 0.0, 0.005)) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(mix(color, tex.rgb, 0.5), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}