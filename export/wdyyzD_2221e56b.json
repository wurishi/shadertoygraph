{"ver":"0.1","info":{"id":"wdyyzD","date":"1602318024","viewed":382,"name":"Raymarching Engine [WIP]","username":"Dominexis","description":"Work-in-progress raymarching engine. Use WASD to move around, space to go up, X to go down, and C to go faster. Use the arrow keys to look around.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Minimum functions\n\nfloat min_3( in float entry_1, in float entry_2, in float entry_3 ){\n\treturn min(\n    \tmin(entry_1, entry_2),\n        entry_3\n    );\n}\nfloat min_4( in float entry_1, in float entry_2, in float entry_3, in float entry_4 ){\n\treturn min(\n    \tmin_3(entry_1, entry_2, entry_3),\n        entry_4\n    );\n}\nfloat min_5( in float entry_1, in float entry_2, in float entry_3, in float entry_4, in float entry_5 ){\n\treturn min(\n    \tmin_4(entry_1, entry_2, entry_3, entry_4),\n        entry_5\n    );\n}\nfloat min_6( in float entry_1, in float entry_2, in float entry_3, in float entry_4, in float entry_5, in float entry_6 ){\n\treturn min(\n    \tmin_5(entry_1, entry_2, entry_3, entry_4, entry_5),\n        entry_6\n    );\n}\nfloat min_7( in float entry_1, in float entry_2, in float entry_3, in float entry_4, in float entry_5, in float entry_6, in float entry_7 ){\n\treturn min(\n    \tmin_6(entry_1, entry_2, entry_3, entry_4, entry_5, entry_6),\n        entry_7\n    );\n}\n\n\n\n// Distance functions\n\nfloat foundation( in vec3 pos, in float altitude ){\n\treturn pos.z - altitude;\n}\nfloat sphere( in vec3 pos, in vec3 center, in float radius ){\n\treturn distance(pos, center) - radius;\n}\nfloat pillar( in vec3 pos, in vec2 center, in float radius ){\n\treturn distance(pos.xy, center.xy) - radius;\n}\nfloat box( in vec3 pos, in vec3 corner_1, in vec3 corner_2 ){\n\tpos = abs(pos - (corner_1 + corner_2)*0.5) - abs(corner_1 - corner_2)*0.5;\n    return min(max(max(pos.x, pos.y), pos.z), 0.0) + length(max(pos, 0.0));\n}\nvec3 infinite( in vec3 pos, in vec3 center, in float freq ){\n\treturn vec3( mod(pos.x-center.x, freq), mod(pos.y-center.y, freq), mod(pos.z-center.z, freq) );\n}\nvec3 infinite_xy( in vec3 pos, in vec2 center, in float freq ){\n\treturn vec3( vec2(mod(pos.x-center.x, freq), mod(pos.y-center.y, freq)), pos.z );\n}\n\nfloat sdf_object( in vec3 pos ){\n    return min_3(\n    \tmax(foundation( pos, -2.0 ), -sphere( pos, vec3(40.0, 10.0, -20.0), 30.0 )),\n        sphere( pos, vec3(4.0, 0.0, 0.0), 2.0 ),\n        /*\n        pillar( infinite_xy(pos, vec2(0.0), 30.0), vec2(15.0), 2.0 ) + 100.0,\n        sphere( infinite(pos, vec3(vec2(15.0), 0.0), 30.0), vec3(15.0), sin(iTime)+2.0 ) + 100.0,\n\t\t*/\n        max(box( pos, vec3(-2.0, 8.0, -1.8), vec3(8.0, 12.0, 4.0) ) - 0.2, 0.2-box( pos, vec3(0.0, 0.0, -1.0), vec3(6.0, 20.0, 3.0) ))\n    );\n}\nfloat sdf_light( in vec3 pos, in vec3 camera ){\n\treturn min(\n        sphere( pos, vec3(7.0, 15.0, 2.0), 1.0 ),\n        sphere( pos, camera + vec3(-30.0, -50.0, 100.0), 2.0 )\n    );\n}\nfloat sdf( in vec3 pos, in vec3 camera ){\n\treturn min(\n        sdf_object(pos),\n        sdf_light(pos, camera)\n    );\n}\n\n\n\n// Color functions\n\nfloat checker( in vec3 pos, in float freq ){\n\treturn mod(floor(pos.x/freq + 0.5) + floor(pos.y/freq + 0.5) + floor(pos.z/freq + 0.5),2.0);\n}\nvec4 get_color( in vec3 pos ){\n\tfloat min_dist = sdf_object(pos);\n    return vec4(\n    \tvec4(step(max(foundation( pos, -2.0 ), -sphere( pos, vec3(40.0, 10.0, -20.0), 30.0 )), min_dist)*( (checker(pos, 2.0)+2.0)*vec3(0.0, 1.0, 0.0)/4.0 ), 0.0) +\n        step(sphere( pos, vec3(4.0, 0.0, 0.0), 2.0 ), min_dist)*vec4(1.0, 0.0, 0.0, 0.15) +\n        /*\n        step(pillar( infinite_xy(pos, vec2(0.0), 30.0), vec2(15.0), 2.0 ) + 100.0, min_dist)*vec4(0.54, 0.26, 0.07, 0.0) +\n        step(sphere( infinite(pos, vec3(vec2(15.0), 0.0), 30.0), vec3(15.0), sin(iTime)+2.0 ) + 100.0, min_dist)*vec4(0.0, 0.75, 0.0, 0.15) +\n\t\t*/\n        step(max(box( pos, vec3(-2.0, 8.0, -1.8), vec3(8.0, 12.0, 4.0) ) - 0.2, 0.2-box( pos, vec3(0.0, 0.0, -1.0), vec3(6.0, 20.0, 3.0) )), min_dist)*vec4(0.0, 0.0, 1.0, 0.25)\n    );\n}\n\n\n\n// Ray functions\n\nvec4 sight_ray( in vec3 pos, in vec3 ray, in float limit, in vec3 camera ){\n    \n    // Initialize values\n    \n    float dist = 0.0;\n\tfloat min_light_dist = 10000.0;\n    \n    \n    \n    // Iterate through ray\n    \n    while( dist < limit ){\n        min_light_dist = min(min_light_dist, sdf_light( pos + ray*dist, camera ));\n    \tfloat min_dist = sdf( pos + ray*dist, camera );\n        if( min_dist < 0.001 ) break;\n        dist += min_dist;\n    }\n    \n    \n    \n    // Return value\n    \n    return vec4(pos + ray*dist, clamp(min_light_dist, 0.0, 1.0));\n}\nfloat shadow_ray( in vec3 pos, in vec3 normal, in vec3 light_pos, in float light_radius ){\n    \n    // Initialize values\n    \n\tpos += normal*0.01;\n    float limit = distance(pos, light_pos);\n    vec3 ray = normalize(light_pos-pos);\n    float prev_min_dist = 10000.0;\n    float shadow = 1.0;\n    float dist = 0.01;\n    \n    \n    \n    // Iterate through ray\n    \n    while( dist < limit-light_radius ){\n        \n    \tfloat min_dist = sdf_object( pos + ray*dist );\n        if ( min_dist < 0.001 ) return 0.0;\n        \n        float est_dist = max(dist - min_dist*min_dist*0.5/prev_min_dist, 0.01);\n        float est_min_dist = sdf_object( pos + ray*est_dist );\n        \n        shadow = min( shadow, (min_dist/dist)*(limit/light_radius) );\n        shadow = min( shadow, (est_min_dist/est_dist)*(limit/light_radius) );\n        \n        dist += min_dist;\n        prev_min_dist = min_dist;\n    }\n    \n    \n    \n    // Return value\n    \n    return shadow;\n}\n\n\n\n// Direction functions\n\nvec3 get_normal( in vec3 pos ){\n\tfloat min_dist = sdf_object(pos);\n    return normalize(vec3(\n        sdf_object(pos+vec3(0.001,0.0,0.0)) - min_dist,\n        sdf_object(pos+vec3(0.0,0.001,0.0)) - min_dist,\n        sdf_object(pos+vec3(0.0,0.0,0.001)) - min_dist\n    ));\n}\n\n\n\n// Light functions\n\nfloat light_source( in vec3 pos, in vec3 normal, in vec3 light_pos, in float light_radius, in float light_intensity ){\n    \n    // Initialize values\n    \n\tvec3 light_vector = normalize(light_pos-pos);\n    \n    \n    \n    // Compute contributers\n    \n    float base_light = light_radius/( (distance(pos,light_pos)/light_intensity)*(distance(pos,light_pos)/light_intensity) );\n    float exposure = cos( max(acos(clamp( max(dot(normal, light_vector), 0.0), 0.0, 1.0 ))\n                     - atan(light_radius, distance(pos,light_pos)), 0.0) );\n    float shadow = shadow_ray(pos, normal, light_pos, light_radius);\n    \n    \n    \n    // Return value\n    \n    return base_light*exposure*shadow;\n}\nfloat get_light( in vec3 pos, in vec3 normal ){\n    return clamp(\n        \n        // Combine light from various sources\n        \n        light_source( pos, normal, vec3(7.0, 15.0, 2.0), 1.0, 10.0 ) +\n        light_source( pos, normal, pos + vec3(-30.0, -50.0, 100.0), 2.0, 100.0 ),\n        0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Initialize values\n    \n    vec2 uv = ( 2.0*fragCoord.xy - iResolution.xy )*vec2(-1.0, 1.0)/iResolution.y;\n    vec3 pos_1 = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n    vec2 angle = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    \n    \n    // Calculate ray\n    \n    float fov = 0.8;\n    vec3 ray_1 = normalize(vec3(\n    \tcos(angle.x)*cos(angle.y) - sin(angle.x)*uv.x*fov - cos(angle.x)*sin(angle.y)*uv.y*fov,\n        sin(angle.x)*cos(angle.y) + cos(angle.x)*uv.x*fov - sin(angle.x)*sin(angle.y)*uv.y*fov,\n        sin(angle.y) + cos(angle.y)*uv.y*fov ));\n    \n    \n    \n    // Sky and fog\n    \n    float sky_dist = 100.0;\n    float fog_dist = sky_dist*0.25;\n    vec3 sky_color = vec3(0.52, 0.8, 0.92);\n    \n    \n    \n    // Diffuse light\n    \n    vec4 sight = sight_ray(pos_1, ray_1, sky_dist, pos_1);\n    vec3 pos_2 = sight.xyz;\n    float glow_1 = 1.0 - sight.w;\n    \n    vec3 normal_1 = get_normal(pos_2);\n    \n    float light = 0.0;\n    if( distance(pos_1, pos_2) < sky_dist ) light = get_light(pos_2, normal_1);\n    \n    vec4 color_1 = get_color(pos_2);\n    \n    vec3 diffuse_1 = color_1.xyz*vec3(light);\n    float reflectivity_1 = pow(1.0 - dot(-ray_1, normal_1), 4.0)*(1.0 - color_1.w) + color_1.w;\n    \n    \n    \n    // Reflected light\n    \n    vec3 ray_2 = reflect(ray_1, normal_1);\n    pos_2 = pos_2 + ray_2*0.01;\n    \n    if( distance(pos_1, pos_2) < sky_dist ) sight = sight_ray(pos_2, ray_2, sky_dist, pos_1);\n    vec3 pos_3 = sight.xyz;\n    float glow_2 = 1.0 - sight.w;\n    \n    vec3 normal_2 = get_normal(pos_3);\n    \n    light = 0.0;\n    if( distance(pos_1, pos_3) < sky_dist ) light = get_light(pos_3, normal_2);\n    \n    vec4 color_2 = get_color(pos_3);\n    \n    vec3 reflected_1 = color_2.xyz*vec3(light);\n    \n    \n    \n    // Combine light\n    \n    vec3 pixel = reflected_1;\n    \n    pixel += (sky_color - pixel)*smoothstep( 0.0, 1.0, clamp((distance(pos_2, pos_3)-fog_dist)/(sky_dist-fog_dist), 0.0, 1.0) );\n    pixel += (vec3(1.0) - pixel)*smoothstep( 0.0, 1.0, glow_2 );\n    pixel = clamp(pixel, 0.0, 1.0);\n    \n    pixel = (1.0 - reflectivity_1)*diffuse_1 + reflectivity_1*pixel;\n    \n    pixel += (sky_color - pixel)*smoothstep( 0.0, 1.0, clamp((distance(pos_1, pos_2)-fog_dist)/(sky_dist-fog_dist), 0.0, 1.0) );\n    pixel += (vec3(1.0) - pixel)*smoothstep( 0.0, 1.0, glow_1 );\n    pixel = clamp(pixel, 0.0, 1.0);\n    \n    \n    \n    // Assign pixel\n    \n    fragColor = vec4( pixel, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize values\n    \n    vec3 pos = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n    vec2 angle = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    float pos_speed = 0.04;\n    float angle_speed = 0.04;\n    \n    \n    \n    // Apply angle offset\n    \n    vec2 angle_offset = vec2(\n    \ttexture( iChannel1, vec2( 37.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 39.0/256.0, 0.0 ) ).x,\n        texture( iChannel1, vec2( 38.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 40.0/256.0, 0.0 ) ).x);\n    \n    angle_offset /= length(angle_offset) + step( length(angle_offset), 0.5 );\n    angle += angle_offset*angle_speed;\n    angle.y = clamp( angle.y, -1.5707, 1.5707 );\n    \n    \n    \n    // Apply position offset\n    \n    vec3 pos_offset = vec3( \n        texture( iChannel1, vec2( 87.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 83.0/256.0, 0.0 ) ).x, \n        texture( iChannel1, vec2( 68.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 65.0/256.0, 0.0 ) ).x,\n        texture( iChannel1, vec2( 32.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 88.0/256.0, 0.0 ) ).x);\n    \n    pos_offset /= length(pos_offset) + step( length(pos_offset), 0.5 );\n    \n    pos_offset = vec3(\n        cos(angle.x)*pos_offset.x + sin(angle.x)*pos_offset.y,\n        sin(angle.x)*pos_offset.x - cos(angle.x)*pos_offset.y,\n        pos_offset.z );\n    pos += pos_offset*pos_speed*(texture( iChannel1, vec2( 67.0/256.0, 1.0 ) ).x*7.0 + 1.0);\n    \n    \n    \n    // Write to buffer\n    \n    fragColor = vec4( step(fragCoord.x, 5.0)*pos + step(5.0, fragCoord.x)*vec3(angle, 0.0), 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}