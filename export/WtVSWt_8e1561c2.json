{"ver":"0.1","info":{"id":"WtVSWt","date":"1583919631","viewed":225,"name":"Transformator.","username":"Logos","description":"Dynamic version of my very old shader:\n\nhttps://warsztat.gd/screen/14209/inwersja.\n","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["sin","space","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 11.03.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n\n//--- camera stuff ---//\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, sin(0.59*iTime));\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\n//--- scene description ---//\n\nfloat distanceToScene(vec3 p)\n{\n\tfloat dp = dot(p, p);\n\t\n    p *= 3.0 / dp;\n\tp  = sin(3.0*p + iTime*vec3(0.0, -4.0, 0.0));\n\n\tfloat d = min(length(p.xz) - 0.15, length(p*p) - 0.1);\n\n\treturn 0.6*d * dp*0.111111;\n}\n\n\n//--- cheap normal computing ---//\n\nvec3 computeSurfaceNormal(vec3 p)\n{\n    float d = distanceToScene(p);\n    \n    return normalize(vec3(\n        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));\n}\n\n\n//--- output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- camera setup ---//\n    \n    float rtime = 0.35*iTime;\n    \n    vec2 p   = (-iResolution.xy + 2.0*fragCoord - 1.0) / iResolution.y;\n \tvec3 pos = vec3(5.0 + 5.0*cos(rtime), 10.0*cos(1.2*rtime), 6.0 + 5.0*sin(0.78*rtime));\n    vec3 tar = vec3(0.0);\n    vec3 dir = setCamera(pos, tar) * normalize(vec3(p.xy, 11.6));  \n    \n    \n    //--- distance to nearest object in the scene ---//\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 210; i++)\n    {\n\t\tfloat d = distanceToScene(pos + t*dir);\n\t\tif(d < 0.003) break;\n        \n\t\tt += d;\n\n        \n\t\t//--- early skip of background pixels ---//\n    \n        if (t > 27.0)\n        {\n            fragColor = vec4(0.0);\n            return;\n        }\n\t}\n    \n    \n    //--- output color depends on few things ---//\n    \n    vec3  sn = computeSurfaceNormal(pos + t*dir);\t\t\t// surface normal\n    float dc = clamp(dot(sn, normalize(pos)), 0.0, 1.0);\t// diffuse component\n    float sr = pow(dc, 100.0);\t\t\t\t\t\t\t\t// specular reflection\n    float od = length(pos + t*dir);\t\t\t\t\t\t\t// distance to origin\n    \n\tfragColor     = abs(dir.xzyz);\n    fragColor    *= 0.2 + 0.8*dc;\n    fragColor.yz *= clamp(od, 0.0, 1.0);\n    fragColor    += sr;\n    \n}","name":"Image","description":"","type":"image"}]}