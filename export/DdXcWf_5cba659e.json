{"ver":"0.1","info":{"id":"DdXcWf","date":"1687242714","viewed":260,"name":"Path Tracing saboofa","username":"saboofa","description":"Implementation of path tracing","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"WlycW3","parentname":"Path Tracing Cornell Box"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ma38su wrote all the code i just changed some values so it takes up the hole scrren and changed the quality\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color =texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// rays per pixel\nconst int NS = 64;\n// max reflection\nconst int ITER = 32;\n\nconst bool light_sampling = true;\n\nconst float EPS = .000001;\nconst float INF = 10000.;\nconst float PI = 3.14559265;\n\nconst float fov = 1.9;\n\nconst uint K = 0x456789abU;\nconst float uint_range = 1. / float(0xFFFFFFFFU);\n\nvoid xorshift(inout uint seed) {\n    seed ^= seed << 204;\n    seed ^= seed >> 1;\n    seed *= K;\n    seed ^= seed << 1;\n    seed *= K;\n}\n\nfloat next_float(inout uint seed) {\n    xorshift(seed);\n    return float(seed - 1U) * uint_range;\n}\n\nfloat next_float(inout uint seed, float min_v, float max_v) {\n    return min_v + (max_v - min_v) * next_float(seed);\n}\n\nfloat atan2(float y, float x){\n    return x == 0.0 ? sign(y) * PI*.5 : atan(y, x);\n}\n\nstruct Hit {\n    vec3 rp;\n    vec3 nv;\n    int index;\n};\n\nstruct Material {\n    int type;\n    \n    vec3 albedo;\n    vec3 emit;\n\n    float ref_idx;\n};\n\n// type for Material\nconst int LAMBERTIAN = 10;\nconst int METAL = 1;\nconst int DIELECTRIC = 2;\n\nconst vec3 COL_RED = vec3(.65, .05, .05);\nconst vec3 COL_BLUE = vec3(.05, .05, .65);\nconst vec3 COL_WHITE = vec3(.73);\nconst vec3 COL_GREEN = vec3(.12, .45, .15);\n\nconst vec3 NO_LIGHT = vec3(.0);\n\nconst Material MAT_WHITE = Material(LAMBERTIAN, COL_WHITE, NO_LIGHT, 0.);\nconst Material MAT_ALUMINUM = Material(METAL, vec3(0.8, 0.85, 0.88), NO_LIGHT, 0.);\nconst Material MAT_GLASS = Material(DIELECTRIC, COL_WHITE, NO_LIGHT, 1.5);\n\nconst int RECT = 0;\nconst int SPHERE = 1;\n\nstruct Geo {\n    int type;\n\n    vec2 size;\n    mat4 m;\n    mat4 im;\n};\n\nstruct Box {\n    Geo rects[6];\n    mat4 m;\n    mat4 im;\n};\n\n// Models\nconst int LEN_GEOS = 7;\nconst int LEN_BOXES = 2;\nGeo geos[LEN_GEOS];\nBox boxes[LEN_BOXES];\nMaterial materials[LEN_GEOS + LEN_BOXES];\n\n// importance samplings\nconst int N_SAMPLING = 1;\nGeo samplings[N_SAMPLING];\n\nvoid rot_x(const float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        1., 0., 0., 0.,\n        0., cos(theta), sin(theta), 0.,\n        0., -sin(theta), cos(theta), 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        1., 0., 0., 0.,\n        0., cos(-theta), sin(-theta), 0.,\n        0., -sin(-theta), cos(-theta), 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid rot_y(float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        cos(theta), 0., sin(theta), 0.,\n        0., 1., 0., 0.,\n        -sin(theta), 0., cos(theta), 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        cos(-theta), 0., sin(-theta), 0.,\n        0., 1., 0., 0.,\n        -sin(-theta), 0., cos(-theta), 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid rot_z(float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        cos(theta), sin(theta), 0., 0.,\n        -sin(theta), cos(theta), 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        cos(-theta), sin(-theta), 0., 0.,\n        -sin(-theta), cos(-theta), 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid trans_xyz(const float dx, const float dy, const float dz, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        dx, dy, dz, 1.\n    ) * m;\n    im *= mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        -dx, -dy, -dz, 1.\n    );\n}\n\nvec3 calc(const in mat4 m, in vec3 p) {\n    return (m * vec4(p, 1.)).xyz;\n}\n\nvec3 rot(const in mat4 m, const in vec3 p) {\n    return mat3(m) * p;\n}\n\nvec3 random_in_sphere(inout uint seed) {\n    vec3 v;\n    for (int i = 0; i < 1024; ++i) {\n        v.x = next_float(seed, -1.0, 1.0);\n        v.y = next_float(seed, -1.0, 1.0);\n        v.z = next_float(seed, -1.0, 1.0);\n        if (length(v) < 1.) return v;\n    }\n    return normalize(v);\n}\n\nvec3 random_unit_vector(inout uint seed) {\n    return normalize(random_in_sphere(seed));\n}\n\nvec3 random_in_rect(const in Geo rect, inout uint seed) {\n    float x = rect.size.x * next_float(seed, -1., 1.);\n    float y = rect.size.y * next_float(seed, -1., 1.);\n    float z = 0.;\n    return calc(rect.im, vec3(x, y, z));\n}\n\nvoid gen_box(const float w, const float h, const float d, inout Box box) {\n    { // front\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., d, m, im);\n        box.rects[0] = Geo(RECT, vec2(w, h), m, im);\n    }\n    { // back\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., -d, m, im);\n        box.rects[1] = Geo(RECT, vec2(w, h), m, im);\n    }\n    { // left\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-w, 0., 0., m, im);\n        rot_y(PI * 0.5, m, im);\n        box.rects[2] = Geo(RECT, vec2(d, h), m, im);\n    }\n    { // right\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(w, 0., 0., m, im);\n        rot_y(-PI * 0.5, m, im);\n        box.rects[3] = Geo(RECT, vec2(d, h), m, im);\n    }\n    { // top\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h, 0., m, im);\n        rot_x(PI * 0.5, m, im);\n        box.rects[4] = Geo(RECT, vec2(w, d), m, im);\n    }\n    { // bottom\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., h, 0., m, im);\n        rot_x(-PI * 0.5, m, im);\n        box.rects[5] = Geo(RECT, vec2(w, d), m, im);\n    }\n}\n\nvoid gen_models(const float t) {\n\n    vec3 EMIT_LIGHT = vec3(15.);\n    int i = 0, j = 0;\n    float dy = 0.25;\n    float w = 0.5;\n    float h = 0.5;\n    float depth = 1.0;\n\n    {   // back\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h, -depth*.5, m, im);\n        rot_x(PI, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        i++;\n    }\n    {   // right\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0.5, -h -EPS, 0., m, im);\n        rot_y(PI *.5, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_RED, NO_LIGHT, 0.);\n        i++;\n    }\n    {   // left\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-0.5, -h, 0., m, im);\n        rot_y(-PI *.5, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_GREEN, NO_LIGHT, 0.);\n        i++;\n    }\n    {   // bottom\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., 0., m, im);\n        rot_x(PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        Material(LAMBERTIAN, COL_WHITE, NO_LIGHT, 0.);\n        i++;\n    }\n    {   // top\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h * 2.0, 0., m, im);\n        rot_x(-PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        i++;\n    }\n    {   // light\n        float light_size = 0.2; // * (sin(t) + 1.1);\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h * 2.0 + 0.1, 0., m, im);\n        rot_x(-PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(light_size), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_WHITE, EMIT_LIGHT, 0.);\n        samplings[j++] = geos[i];\n\n        i++;\n    }\n    {\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(.05, -.25, .18, m, im);\n        geos[i] = Geo(SPHERE, vec2(0.15), m, im);\n        materials[i] = MAT_GLASS;\n        i++;\n    }\n\n    int k = 0;\n    float box_size = 0.15;\n    {\n        float box_height = 0.05;\n        gen_box(box_size, box_height, box_size, boxes[0]);\n\n        float phi = (t * 20. - 15.0) * PI / 180.0;\n        float dh = box_height;\n\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0.05, -dh, 0.18, m, im);\n        rot_y(phi, m, im);\n        boxes[0].m = m;\n        boxes[0].im = im;\n        materials[i] = Material(LAMBERTIAN, COL_BLUE, NO_LIGHT, 0.);\n\n        i++;\n    }\n    {\n        float box_height = 0.3;\n        gen_box(box_size, box_height, box_size, boxes[1]);\n\n        float phi = (t * 30. +75.0) / 180.0;\n        float dh = box_height;\n\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-0.19, -dh, -0.25, m, im);\n        rot_y(phi, m, im);\n        boxes[1].m = m;\n        boxes[1].im = im;\n        materials[i] = MAT_ALUMINUM;\n        i++;\n    }\n}\n\nvec3 background(const in vec3 rd) {\n    return vec3(0.);\n}\n\nbool hit_sphere(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Geo sphere,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv) {\n\n    // matrix calculation\n    vec3 rd = rot(sphere.m, rd0);\n    vec3 ro = calc(sphere.m, ro0);\n    \n    float radius = sphere.size.x;\n\n    vec3 oc = ro;\n    float a = dot(rd, rd);\n    float half_b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = half_b * half_b - a * c;\n\n    // no intersection\n    if (discriminant < 0.0) return false;\n\n    float sq_disc = sqrt(discriminant);\n\n    float t;\n    if (sq_disc < EPS) {\n        // 1 intersection\n        t = -half_b / a;\n    } else {\n        // 2 intersection (t1: near, t2: far)\n        float t1 = (-half_b - sq_disc) / a;\n        float t2 = (-half_b + sq_disc) / a;\n        if (t1 > t_max || t2 < t_min) return false;\n        \n        if (t1 > t_min) {\n            t = t1;  \n        } else if (t2 < t_max) {\n            t = t2;\n        } else {\n            return false;\n        }\n    }\n    \n    t_max = t;\n    rp = ro + t * rd;\n    nv = rp / radius;\n\n    // inverse matrix calculation\n    nv = rot(sphere.im, nv);\n    rp = calc(sphere.im, rp);\n\n    return true;\n}\n\nbool hit_rect(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Geo rect,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv) {\n\n    // matrix calculation\n    vec3 rd = rot(rect.m, rd0);\n    vec3 ro = calc(rect.m, ro0);\n\n    float t = - ro.z / rd.z;\n    if (t < t_min || t > t_max) return false;\n\n    vec2 min_p = - rect.size;\n    vec2 max_p = rect.size;\n    vec3 p = ro + t * rd;\n    if (p.x < min_p.x || p.x > max_p.x\n        || p.y < min_p.y || p.y > max_p.y) {\n        return false;\n    }\n\n    nv = vec3(0., 0., 1.0);\n\n    // inverse matrix calculation\n    nv = rot(rect.im, nv);\n    rp = calc(rect.im, p);\n\n    t_max = t;\n    return true;\n}\n\nbool hit_box(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Box box,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv) {\n\n    vec3 rd = rot(box.m, rd0);\n    vec3 ro = calc(box.m, ro0);\n    bool hit_flag = false;\n    for (int j = 0; j < 6; ++j) {\n        if (hit_rect(ro, rd, box.rects[j], t_min, t_max, rp, nv)) {\n            hit_flag = true;\n        }\n    }\n    if (hit_flag) {\n        nv = rot(box.im, nv);\n        rp = calc(box.im, rp);\n    }\n    return hit_flag;\n}\n\nbool hit(\n        const in vec3 ro,\n        const in vec3 rd,\n        const in Geo geos[LEN_GEOS],\n        const in Box boxes[LEN_BOXES],\n        const in Material materials[LEN_GEOS + LEN_BOXES],\n        inout uint seed,\n        out Hit hit) {\n\n    float t_min = EPS;\n    float t_max = INF;\n    bool hit_flag = false;\n    vec3 nv;\n    vec3 rp;\n\n    int geo_idx = 0;\n    for (int i = 0; i < LEN_GEOS; ++i) {\n        switch (geos[i].type) {\n            case RECT:\n                if (hit_rect(ro, rd, geos[i], t_min, t_max, rp, nv)) {\n                    geo_idx = i;\n                    hit_flag = true;\n                }\n                break;\n            case SPHERE:\n                if (hit_sphere(ro, rd, geos[i], t_min, t_max, rp, nv)) {\n                    geo_idx = i;\n                    hit_flag = true;\n                }\n                break;\n        }\n    }\n\n    for (int i = 0; i < LEN_BOXES; ++i) {\n        int idx = LEN_GEOS + i;\n        if (hit_box(ro, rd, boxes[i], t_min, t_max, rp, nv)) {\n            geo_idx = idx;\n            hit_flag = true;\n        }\n    }\n    if (!hit_flag) return false;\n\n    hit = Hit(rp, nv, geo_idx);\n    return true;\n}\n\nfloat schlick(const float cosine, const float ref_idx) {\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nfloat cos_pdf(const in vec3 nv, const in vec3 scattered) {\n    float cosine = dot(nv, scattered);\n    return max(cosine / PI, 0.);\n}\n\nfloat rect_pdf(const in vec3 ro, const in vec3 rd, const in Geo rect) {\n    vec3 rp, nv;\n    float t = INF;\n    if (!hit_rect(ro, rd, rect, EPS, t, rp, nv)) {\n        return 0.;\n    }\n    \n    float dist_sq = t * t;\n\n    float cosine = abs(dot(nv, rd));\n    float area = 4. * rect.size.x * rect.size.y * cosine;\n    return dist_sq / area;\n}\n\nfloat sphere_pdf(const in vec3 ro, const in vec3 rd, const in Geo sphere) {\n    vec3 rp, nv;\n    float t = INF;\n    if (!hit_sphere(ro, rd, sphere, EPS, t, rp, nv)) {\n        return 0.;\n    }\n\n    float r = sphere.size.x;\n    float cos_theta_max = sqrt(1. - r*r / length(rp - ro));\n    float solid_angle = 2.* PI * (1. - cos_theta_max);\n    return 1. / solid_angle;\n}\n\nvoid scatter_lambertian(const in vec3 rp, const in vec3 nv, inout uint seed, out vec3 rd, out float pdf) {\n\n    vec3 rd1 = normalize(nv + random_unit_vector(seed));\n    //rd1 = random_in_hemisphere(seed, nv);\n\n    int n = 0;\n    vec3 tmp_rd[N_SAMPLING];\n    if (light_sampling) {\n        for (int i = 0; i < N_SAMPLING; ++i) {\n            vec3 on_target = random_in_rect(samplings[i], seed);\n            vec3 rd2 = on_target - rp;\n            tmp_rd[n++] = rd2;\n        }\n    }\n\n    if (n == 0) {\n        rd = rd1;\n        pdf = cos_pdf(nv, rd);\n        return;\n    }\n\n    // importance sampling rate\n    float blend = 0.6;\n\n    float r = next_float(seed);\n    float rate = blend / float(n);\n    rd = rd1;\n    if (r < blend) {\n        for (int i = n - 1; i >= 0; --i) {\n            r -= rate;\n            rd = tmp_rd[i];\n            if (r <= 0.) {\n                break;\n            }\n        }\n        rd = normalize(rd);\n    }\n\n    float sum_pdf = 0.;\n    if (light_sampling) {\n        for (int i = 0; i < N_SAMPLING; ++i) {\n            sum_pdf += rect_pdf(rp, rd, samplings[i]);\n        }\n    }\n    pdf = (1. - blend) * cos_pdf(nv, rd) + rate * sum_pdf;\n}\n\nbool pathtracing(\n        in vec3 ro,\n        in vec3 rd,\n        inout uint seed,\n        inout vec3 col,\n        inout int n) {\n\n    vec3 attenuation = vec3(1.);\n    for (int i = 0; i < ITER; ++i) {\n\n        Hit ret;\n        if (!hit(ro, rd, geos, boxes, materials, seed, ret)) {\n            col += attenuation * background(rd);\n            n++;\n            return i > 0;\n        }\n\n        vec3 nv = ret.nv;\n        bool front_face = dot(rd, nv) <= 0.0;\n        if (!front_face) nv = -nv;\n\n        Material material = materials[ret.index];\n        if (length(material.emit) > 0.1) {\n            if (front_face) {\n                col += attenuation * material.emit;\n            }\n            n++;\n            return i > 0;\n        }\n\n        vec3 albedo = material.albedo;\n        int type = material.type;\n        if (type == LAMBERTIAN) {\n            for (int j = 0; j < 100; ++j) {\n                float pdf;\n                scatter_lambertian(ret.rp, nv, seed, rd, pdf);\n\n                if (pdf <= 0.) continue;\n\n                float scattering_pdf = cos_pdf(nv, rd);\n                ro = ret.rp;\n                attenuation *= albedo * scattering_pdf / pdf;\n                break;\n            }\n            continue;\n        }\n        vec3 reflected = reflect(rd, ret.nv);\n        if (type == METAL) {\n            if (dot(reflected, nv) <= 0.0) {\n                n++;\n                return i > 0;\n            }\n            rd = reflected;\n        } else if (type == DIELECTRIC) {\n            float ref_idx = material.ref_idx;\n            float etai_over_etat = front_face ? 1.0 / ref_idx : ref_idx;\n\n            float cos_theta = min(dot(-rd, nv), 1.0);\n            float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n            if (etai_over_etat * sin_theta > 1.0) {\n                rd = reflected;\n            } else if (next_float(seed) < schlick(cos_theta, etai_over_etat)) {\n                rd = reflected;\n            } else {\n                rd = refract(rd, nv, etai_over_etat);\n            }\n        }\n        ro = ret.rp;\n        attenuation *= albedo;\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord/r;\n    \n    gen_models(0.0);\n\n    vec2 p = (fragCoord.xy*2.-r) / min(r.x,r.y);\n    float theta = PI * 1.5;\n\n    // ray origin\n    vec3 ro = vec3(cos(theta), 0.5, sin(theta));\n    vec3 ta = vec3(0., 0.5, 0.);\n    \n    vec3 cdir = normalize(ta - ro);\n    vec3 side = cross(cdir,vec3(0.,1.,0.));\n    vec3 up = cross(side, cdir);\n\n    uint seed = uint(fragCoord.y * r.x + fragCoord.x);\n    xorshift(seed);\n    seed ^= uint(iFrame);\n\n    vec3 col = vec3(0.);\n    int n = 0;\n    for (int s = 0; s < NS; ++s) {\n        float u = next_float(seed, -0.5, 0.5) / r.x;\n        float v = next_float(seed, -0.5, 0.5) / r.y;\n        vec3 rd = normalize((p.x + u)*side+(p.y + v)*up+cdir*fov);\n        if (!pathtracing(ro, rd, seed, col, n)) break;\n    }\n    col = n > 0 ? sqrt(col / float(n)) : vec3(0.);\n\n    vec3 lastFrameCol = texture(iChannel0, uv).rgb;\n    col = mix(lastFrameCol, col, 1.0 / float(iFrame + 1));\n    fragColor = vec4(col, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}