{"ver":"0.1","info":{"id":"WltSWB","date":"1581628332","viewed":316,"name":"Simiancraft Nebula v2","username":"the_simian","description":"Another test for the simiancraft.com backdrop but with the values greatly increased","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["test","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SIMIANCRAFT Deadlights V2 'Deadlights nebula'\n// backdrop animation for https://simiancraft.com/\n// Jesse Harlin, 2020\n// MIT lisence\n// Exactly like the last one but cranked way way up with changes to speed/glow etc.\n\n#define STARFIELD_LAYERS_COUNT 12.0\n\nfloat PI = 3.1415;\nfloat MIN_DIVIDE = 64.0;\nfloat MAX_DIVIDE = .01;\n\n\nmat2 Rotate(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c,-s, s, c); //this rotates the thing.\n}\n\nfloat Star(vec2 uv, float flaresize, float rotAngle, float randomN){\n\n\tfloat d = length(uv);\n\t//Star core\n\tfloat starcore = 0.05/d;\n\tuv *= Rotate(-2.0 * PI * rotAngle);\n\tfloat flareMax = 1.0;\n\n\t//flares\n\tfloat starflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n\tstarcore += starflares * flaresize;\n\tuv *= Rotate(PI * 0.25);\n\tstarflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n\tstarcore += starflares * 0.3 * flaresize;\n\t//light can't go forever, fade it concentrically.\n\tstarcore *= smoothstep(1.0, 0.05, d);\n\treturn starcore;\n}\n\nfloat PseudoRandomizer(vec2 p){\n\t//its not really random, but it looks random.\n\tp = fract(p*vec2(123.45, 345.67));\n\tp+= dot(p, p+45.32);\n\treturn (fract(p.x * p.y));\n}\n\nvec3 StarFieldLayer(vec2 uv, float rotAngle){\n\tvec3 col = vec3(0);\n\n\tvec2 gv = fract(uv) -0.5;\n\tvec2 id = floor(uv);\n\t\n\tfloat deltaTimeTwinkle = iTime * 0.35;\n\n\t// this loop goes over the neighbors and includes adjacent cell information.\n\t// so the stars are not 'clipped'.\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\tvec2 offset = vec2(x, y);\n\n\t\t\t//randomize X and Y\n\t\t\tfloat randomN = PseudoRandomizer(id + offset); // rand in 0 to 1.\n\t\t\tfloat randoX = randomN - 0.5;\n\t\t\tfloat randoY = fract(randomN * 45.0) - 0.5;\n\t\t\tvec2 randomPosition = gv - offset - vec2(randoX, randoY);\n\t\t\t//uses the fract 'trick' to get random sizes\n\t\t\tfloat size = fract(randomN * 1356.33);\n\t\t\tfloat flareSwitch = smoothstep(0.9, 1.0, size);\n\t\t\t//the actual star.\n\t\t\tfloat star = Star(randomPosition, flareSwitch, rotAngle, randomN);\n\t\t\t\n\t\t\t//fract trick random colors.\n\t\t\tfloat randomStarColorSeed = fract(randomN * 2150.0) * (3.0 * PI) * deltaTimeTwinkle;\n\t\t\tvec3 color = sin(vec3(0.7, 0.3, 0.9) * randomStarColorSeed);\n\n\t\t\t//compress\n\t\t\tcolor = color * (0.4 * sin(deltaTimeTwinkle)) + 0.6;\n\t\t\t//filter\n\t\t\tcolor = color * vec3(1, 0.1,  0.9 + size);\n\t\t\tfloat dimByDensity = 15.0/STARFIELD_LAYERS_COUNT;\n\t\t\tcol += star * size * color * dimByDensity;\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n\t//Normalize the mouse also\n\t//vec2 Mouser = (iMouse.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat deltaTime = iTime * 0.01;\n\n\n\t//uv += uv + vec2(3.1, 0);\n    vec3 col = vec3(0.0);\n\t\n    float rotAngle = deltaTime * 0.09;\n\t\n\n\tfor(float i=0.0; i < 1.0; i += (1.0/STARFIELD_LAYERS_COUNT)){\n\t\tfloat layerDepth = fract(i + deltaTime);\n\t\tfloat layerScale = mix(MIN_DIVIDE,MAX_DIVIDE,layerDepth);\n\t\tfloat layerFader = layerDepth * smoothstep(0.1, 1.1, layerDepth);\n\t\tfloat layerOffset = i * (3430.00 + fract(i));\n\t\tmat2 layerRot = Rotate(rotAngle * i * -10.0);\n\t\tuv *= layerRot;\n\t\tvec2 starfieldUv = uv * layerScale + layerOffset;\n\t\tcol += StarFieldLayer(starfieldUv, rotAngle) * layerFader;\n\t}\n\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}