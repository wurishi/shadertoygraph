{"ver":"0.1","info":{"id":"wd2cDh","date":"1587236037","viewed":131,"name":"YinfinitY","username":"lucastakejame","description":"Trying to make an infinite zoom","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","chaos","yinyang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define SOFT .005\n#define PIXELATED 0\n\n#define ss(a,b,c) smoothstep(a,b,c)\n\nfloat circle(vec2 uv, float r, vec2 c, float softness)\n{\n    return ss(r+softness, r-softness, length(uv - c));\n}\n\nvec2 rot(vec2 uv, float a)\n{\n    vec2 i = vec2(cos(a),sin(a));\n    return vec2(uv.x*i.x - uv.y*i.y, uv.y*i.x + uv.x*i.y);\n}\n\n\nfloat window(float center, float val, float width, float fall)\n{\n    return ss(width + fall, width, length(center - val));\n}\n\n// map square coordinates of center c, radial range and angular range.\n// map to [-.5, 5]\nvec2 mapCrown(vec2 uv, vec2 c, vec2 radLim)\n{\n    float radius = (radLim.x + radLim.y)/2.;\n    float radrange = (radLim.y - radLim.x);\n    vec2 nuv = uv - c;\n    vec2 puv  =  vec2(length(nuv), atan(nuv.y, nuv.x) );\n    \n    uv = vec2((puv.x - radLim.x)/radrange - .5,\n              puv.y/PI);\n\t\n    return uv;\n}\n\n\n// generate a yinyang (yy) on .x and a round mask on .y\n// fits in [-.5, .5] when scale 1.\nvec2 yinyang(vec2 uv, float softness, float scale)\n{\n    \n    float r = .25*scale;\n    float whole = max(\n        \t\t\t\t// upper ball\n        \t\t\t\tcircle(uv, r, vec2(0., r), softness),\n                      \t(uv.x > 0.)?0.:1.-circle(uv, r,vec2(0., -r), softness)\n        \n                     );\n    whole +=  circle(uv, .06125*scale , vec2(0.,-r), softness);\n    whole -=  circle(uv, .06125*scale , vec2(0.,r), softness);\n    float br = .5*scale ;\n    float mask = ss(br+softness, br-softness, length(uv));\n    whole = mix(.0, whole, ss(br+softness, br-softness, length(uv)));\n    \n    return vec2(whole, mask);\n    \n}\n\n// generates big yy with a curve string of small yys on its edge\nvec2 chaos(vec2 uv, float softness, float scale, float scaleDiv)\n{\n    vec2 yy = vec2(0.);\n    \n\t\n    // first YY\n    yy += yinyang(uv, softness, scale);\n    \n    // uv for mapping small YY's in the big YY edge\n    vec2 nuv = rot(uv, PI/2.) - vec2(-0.25*scale, .0);\n    vec2 nuv2 = rot(uv, PI/2.) - vec2(0.25*scale, .0);\n        \n    // crown thickness\n    float thick = .5/scaleDiv;\n    \n    vec2 rads = scale*vec2(.25 - thick, .25 + thick);\n    \n    // morph UV to form an S shape on YY edge\n    uv = mix(mapCrown(nuv,  vec2(.0), rads.xy),\n             mapCrown(rot(nuv2,PI), vec2(.0), rads.yx) * vec2(1., -1.),\n             ss( 0.01, .0, sign(uv.x)) );\n\t\n    // angle of section in crown \n    // Calculated trying to aproximate section to a square\n    // r2 - r1 = angle*(r2 + r1)/2\n    float angle = 2.*(rads.y-rads.x)/(rads.y+rads.x);\n    \n    // repetition of angular coord\n    uv.y = fract(uv.y*floor(PI/angle)) - .5;\n    \n    // string phase shift \n    uv.y = (uv.y >= 0.)?uv.y-.5:uv.y+.5;\n    \n    // scale param is 1. cause uv has been scaled here already \n\tvec2 yyString = yinyang(uv, softness, 1.);\n    yy = mix(yy, yyString,  yyString.y);\n    \n    \n    // fill space out of YY\n    yy.x = (yy.y > 0.)?yy.x: (uv.x < 0.)?1.:0.;\n    \n    return yy;\n}\n\n// super pose 1 chaos small YYs with the big YY of another chaos\nvec2 connectYYs(vec2 uv, float softness, float startScale, float scaleDiv)\n{\n    float endScale = startScale/scaleDiv;\n    vec2 yy = chaos(uv, softness, startScale, scaleDiv);\n\t\n    //TODO: Make extra YYs follow edge curvature\n    // extra YYs\n    vec2 yy1 = chaos(uv+vec2(.0,  startScale *1.004), softness, startScale, scaleDiv);\n\tvec2 yy2 = chaos(uv+vec2(.0, -startScale *1.004), softness, startScale, scaleDiv);\n    yy = mix(yy, yy1, yy1.y);\n    yy = mix(yy, yy2, yy2.y);\n    \n\n    vec2 nuv = rot(uv, PI/2.);\n    vec2 newYY = chaos(nuv, softness, endScale, scaleDiv);\n    \n    // extra strings\n    vec2 newYY1 = chaos(nuv+vec2(0., endScale), softness, endScale, scaleDiv);\n    vec2 newYY2 = chaos(nuv+vec2(0., -endScale), softness, endScale, scaleDiv);\n    newYY = mix(newYY, newYY1, newYY1.y);\n    newYY = mix(newYY, newYY2, newYY2.y);\n    \n    yy = mix(yy, newYY, newYY.y);\n    \n    return yy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    #if (PIXELATED == 1)\n    float f = 40.;\n    uv = floor(uv*f)/f;\n    #endif\n    \n    // rotate everything\n    //uv = rot(uv,mix( 0., iTime, ss(1., 10., iTime)) );\n    \n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    float period = 8.;\n    float startScale = 4000.;\n    float scaleDiv = 150.;\n    \n    float tt;\n    float t;\n    float t1;\n    float t2;\n    float t3;\n    \n    // total time [0,1]\n    tt = fract(iTime/period);\n    //tt = mix(0.,tt,ss( 0., 3., iTime));\n    //tt = muv.x;\n    //tt = fragCoord.x/iResolution.x;\n    \n    #define SECTION_W 1.\n    #define DD 3.\n    tt *= 4.;\n    \n    // section time, the .9 mult is a workaround to make zoom more seamless\n    t  = (clamp( tt, 0.*SECTION_W, 1.*SECTION_W) - 0.*SECTION_W)/SECTION_W;\n    t1 = (clamp( tt, 1.*SECTION_W, 2.*SECTION_W) - 1.*SECTION_W)/SECTION_W;\n    t2 = (clamp( tt, 2.*SECTION_W, 3.*SECTION_W) - 2.*SECTION_W)/SECTION_W;\n    t3 = (clamp( tt, 3.*SECTION_W, 4.*SECTION_W) - 3.*SECTION_W)/SECTION_W;\n       \n    // Came to this experimenting trying to make zoom more linear\n          \n    // Tip from user mla\n \tvec2 uv0 = uv*startScale*exp(-t*log(scaleDiv));\n \tvec2 uv1 = uv*startScale*exp(-t1*log(scaleDiv));\n \tvec2 uv2 = uv*startScale*exp(-t2*log(scaleDiv));\n \tvec2 uv3 = uv*startScale*exp(-t3*log(scaleDiv));\n    \n    vec2 yy = vec2(0.);\n    vec2 newYY;\n    \n    float crossfade = .0001;\n    float softness = .0001;\n    \n    vec2 yy0 = connectYYs(uv0, softness, startScale, scaleDiv)*window(1.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n\n    uv1 = rot(uv1, PI/2.);\n    vec2 yy1 = connectYYs(uv1, softness, startScale, scaleDiv)*window(3.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n    \n    uv2 = rot(uv2, PI);\n    vec2 yy2 = connectYYs(uv2, softness, startScale, scaleDiv)*window(5.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n\n    uv3 = rot(uv3, 3.*PI/2.);\n    vec2 yy3 = connectYYs(uv3, softness, startScale, scaleDiv)*window(7.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n    \n    \n    // Stitching the 4 parts to make it a loop\n    yy = yy0 + yy1 + yy2 + yy3;\n    \n    // delineate yy\n    if(iTime < period/4.)\n        yy *= yy.y;\n    \n    fragColor = vec4(yy.x);\n    \n}","name":"Image","description":"","type":"image"}]}