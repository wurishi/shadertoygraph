{"ver":"0.1","info":{"id":"wlKyDW","date":"1702801640","viewed":33,"name":"Blackhole V2","username":"Pjbomb2","description":"very old raymarcher I was playing around wtih a few years ago","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).xyz;\n    \n    col *= 2.; // exposure\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    //col = pow( col, vec3(0.8,0.85,0.9) );\n    col = ACESFilm(col); // convert unbounded HDR color range to SDR color range\n    col = LinearToSRGB(col); // convert from linear to sRGB for display\n    col = smoothstep(0., 1., col); // increase contrast\n    \n    fragColor = vec4( col, 1 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define BOUNCECOUNT  5\n#define MATFLOOR 0.0\n#define MATLIGHT 1.0\n#define MATREFL1 2.0\n#define MATREFL2 3.0\n#define MATGLASS1 4.0\n#define MATGLASS2 5.0\n\n\n//#define debug 1\n\nvec3 LessThan(vec3 f, float value) {return vec3(lessThan(f, vec3(value)));}//Reccomended change by Dave_Hoskins\n \nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\n\n\n\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR, out float absorb) {//return material properties when what material is being hit is requested\n    if(matID == MATFLOOR) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(0.7, 0.7, 0.7);\n    }\n        if(matID == MATLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 100.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(1.0, 1.0, 1.0);\n    }\n            if(matID == MATREFL1) {\n        refl = 0.9;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.8, 0.1);\n    }\n                if(matID == MATREFL2) {\n        refl = 1.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(0.9, 0.1, 0.1);\n    }\n        if(matID == MATGLASS1) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 0.1;\n        IOR = 1.0;\n        return vec3(2.7, 2.3, 0.9);\n    }\n            if(matID == MATGLASS2) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 0.1;\n        IOR = 1.5;\n        return vec3(0.7, 0.3, 0.9);\n    }\n\n\n\nreturn vec3(1.0, 0.0, 1.0);\n}\n\n\n\n\n\n//SDF functions\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\n\nvoid Rotate(inout vec2 point, float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    float px = point.x * c - point.y * s;\n    float py = point.x * s + point.y * c;\n    point.x = px;\n    point.y = py;\n}\n\nfloat SDFSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nvec3 SunPos = vec3(100, 100, 0);\nvec3 sunCol = 2.0*vec3(0.8, 0.7, 0.6);\n\nvec3 BHPos = vec3(-12,0,10);\nfloat G = 1.0;\n\nuint wang_hash(inout uint seed) {//random number generator(unsigned integer)\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {//random number generator(float)\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor) {//cosine hemisphere ray direction calculation when ray bounces off an object\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\n\n\nvec2 map(vec3 p, in float inside) {//main mapping function\n\n    float a = SDFSphere(p - vec3(10,0,10), 1.0);\n    float b = SDFSphere(p - vec3(0,0,10), 1.0);\n\n    vec2 ret = vec2(a, MATLIGHT);\n    ret = Union(ret, vec2(b, MATFLOOR));\n    return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n}\n\nvec3 calcNormal( in vec3 pos ) {//normals calculation\n    vec2 eps = vec2(0.0001,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n\n\n\nfloat raymarch(inout vec3 ro, inout vec3 rd, in float inside) {//normal sphere tracing function\n\tfloat res = -1.0;\n    float tmax = 100.0;\n    float t = 0.001;\n    float h = 0.0;\n    vec3 pos = ro;\n    for(int i = 0; i < 1000; i++) {\n        pos += rd * 0.1;\n        h = map(pos, 0.0).x;\n        vec3 D2BH = normalize(pos - BHPos);\n        vec3 p = pos - BHPos;\n        \n        float G_M1_M2 = 0.50;\n        float d2 = dot(p,p);\n        vec3 gravityVec = normalize(-p)*( G_M1_M2/d2 );\n        \n        t += 0.1;\n        rd = normalize(rd + 0.1 * gravityVec);\n        if((h < 0.2) || (t > tmax)) break;\n        \n    }\n\n    ro = pos;\n    if(t<tmax)res = t; \n    return res;\n    \n}\n\n\n\n\nvec3 calcFinalColor(vec3 r1, vec3 r2, inout uint rngState) {//main function\n    \n    vec3 ro = r1;\n    vec3 rd = r2;\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 colorMask = vec3(1.0, 1.0, 1.0);\n    float refl, refr, emmis, IOR, absorb = 0.0;\n    \n    \n    #ifdef debug\n        #if debug == 1\n        \n        \n        \n        \n        #endif\n    #else\n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n        vec3 iColor = vec3(0.0);\n        float t = raymarch(ro, rd, 0.0);\n        if(length(ro - BHPos) < 1.0) return vec3(0.0);\n        \n        if(t < 0.0) {\n            colorMask *= texture(iChannel0, rd).xyz;\n            iColor += texture(iChannel0, rd).xyz+2.0*accumulatedColor;\n            accumulatedColor += iColor * colorMask * 0.5;\n            break;\n        }else{\n        \n            vec3 norm = calcNormal(ro);\n            vec3 surfaceColor = GetMatProps(map(ro, 0.0).y, refl, refr, emmis, IOR, absorb);//gets material color and properties\n            colorMask *= surfaceColor;\n        \n            rd = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), 1.0 - refl);\n            iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);//apply colors and emmisive materials\n            accumulatedColor += colorMask * iColor;//apply colors and emmissive to final color\n            }\n    \n        }\n    return accumulatedColor;\n    #endif\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {//Camera function to make flying camera\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;//anti-aliasing\n    \n    vec3 ro, rd, col = vec3(0.0);\n    Camera(fragCoord + jitter, ro, rd);\n    col = calcFinalColor(ro, rd, rngState);\n    \n    //reads from previous frame and blends the new frame into the old, and outputs that\n    vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n    float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    \n    fragColor = vec4(col,blend);\n}","name":"Buffer B","description":"","type":"buffer"}]}