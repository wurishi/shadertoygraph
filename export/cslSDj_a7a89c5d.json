{"ver":"0.1","info":{"id":"cslSDj","date":"1669637393","viewed":358,"name":"Stick Bug","username":"valena","description":"Get stick bugged lol!!!","likes":24,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","wood","bug","dance","dumb","woods","stickbug","musik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4tjSDw","filepath":"https://soundcloud.com/user-155228562/get-stick-bugged-lol","previewfilepath":"https://soundcloud.com/user-155228562/get-stick-bugged-lol","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nmat2 rmatrix(float a)    //Rotation matrix;\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(c, -s, s, c);\n}\n\nvec3 getRayDir(vec3 cameraDir, float cameraAngle, vec2 fragCoord)\n{\n\tvec2 coord = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n\tcoord.y /= iResolution.x / iResolution.y;\n\tvec3 xAxis = normalize(vec3(-cameraDir.z, 0, cameraDir.x)) * tan(cameraAngle / 2.0);\n\tvec3 yAxis = normalize(cross(cameraDir, xAxis)) * tan(cameraAngle / 2.0) * -1.0;\n\tvec3 result = normalize(cameraDir + xAxis * coord.x + yAxis * coord.y);\n\n\treturn (result);\n}\n\nvec3 cubeMap(vec3 p)   //Function for mapping 2d texture to 3d sphere\n{\n\tvec3 ap = abs(p);\n\tfloat m = max(ap.x, max(ap.y, ap.z));\n\tvec2 uv;\n\tfloat side;\n\n\tif (ap.x == m)\n\t{\n\t\tuv.x = atan(p.z, p.x) / (PI / 4.0);\n\t\tuv.y = atan(p.y, p.x) / (PI / 4.0);\n\t\tside = 1.0 * sign(p.x);\n\t}\n\tif (ap.z == m)\n\t{\n\t\tuv.x = atan(p.x, p.z) / (PI / 4.0);\n\t\tuv.y = atan(p.y, p.z) / (PI / 4.0);\n\t\tside = 2.0 * sign(p.z);\n\t}\n\tif (ap.y == m)\n\t{\n\t\tuv.x = atan(p.x, p.y) / (PI / 4.0);\n\t\tuv.y = atan(p.z, p.y) / (PI / 4.0);\n\t\tside = 3.0 * sign(p.y);\n\t}\n\treturn vec3(uv, side);\n}\n\n//That sdf id from iq's website \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLeg(vec3 p, vec3 a, vec3 b, float L1, float L2, float r)\n{\n    float L0 = length(a - b);\n    float l1 = -(L2 * L2 - L0 * L0 - L1 * L1) / (2.0 * L0);\n    float h = sqrt(L1 * L1 - l1 * l1);\n    \n    vec3 n = normalize(b - a);\n    \n    vec3 up = cross(n, normalize(vec3(n.z, 0.0, -n.x)));\n    \n    vec3 c = a + l1 * n + h * up;\n    \n    float t = sdCapsule(p, a, c, r);\n    t = min(t, sdCapsule(p, c, b, r));\n    return (t);\n}\n\nvec4 map(vec3 p)    \n{\n    vec2 uv = vec2(0.0);\n    float mat = 0.0;\n    float t = 1000000.0;\n    vec3 p1;\n    \n    float T = iTime * 2.8 * 2.5;\n    float r = 0.4;\n    float xoff = sin(T) * 0.2;\n    \n    vec3 off = vec3(xoff, sqrt(r * r - xoff * xoff) - r, 0.0);\n    \n    vec3 a = vec3(0.0, 0.1, -0.55) + off;\n    vec3 b = vec3(0.0, 0.0, 0.0) + off;\n    vec3 c = vec3(0.0, 0.1, 0.45) + off;\n    \n    t = sdCapsule(p, a, b, 0.02);\n    t = min(t, sdCapsule(p, c, b, 0.02));\n    \n    \n    t = min(t, sdLeg(p, vec3(0.3, -0.2, 0.3), b - vec3(0.0, 0.0, -0.05), 0.32, 0.27, 0.01));\n    t = min(t, sdLeg(p, vec3(0.36, -0.2, 0.0), b, 0.32, 0.27, 0.01));\n    t = min(t, sdLeg(p, vec3(0.3, -0.2, -0.3), b - vec3(0.0, 0.0, 0.05), 0.32, 0.27, 0.01));\n    \n    t = min(t, sdLeg(p, vec3(-0.3, -0.2, 0.3), b - vec3(0.0, 0.0, -0.05), 0.32, 0.27, 0.01));\n    t = min(t, sdLeg(p, vec3(-0.36, -0.2, 0.0), b, 0.32, 0.27, 0.01));\n    t = min(t, sdLeg(p, vec3(-0.3, -0.2, -0.3), b - vec3(0.0, 0.0, 0.05), 0.32, 0.27, 0.01));\n    \n    float cube = length(max(abs(p - vec3(0.0, -0.8, 0.0)) - vec3(0.5), vec3(0))) - 0.1;\n    \n    t = min(t, cube);\n    \n    if (t == cube)\n    {\n        mat = 1.0;\n        uv = cubeMap(p - vec3(0.0, -0.8, 0.0)).xy;\n    }\n\treturn vec4(t, uv, mat);\n}\n\nvec4 marchRay(vec3 rayOrigin, vec3 rayDir)  //almost classic raymarching\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 50.0;\n\tvec3 pos;\n    vec4 info;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        \n        info = map(pos);\n\t\t\n        d = info.x;\n\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n\tif (t > maxRange)\n\t\treturn vec4(-1.0);\n    \n    info.x = t;\n\treturn info;\n}\n\nvec3 getNorm(vec3 pos)\n{\n\tvec2 e = vec2(0.0001, 0);\n\tfloat tp = map(pos).x;\n\n\tvec3 norm = -normalize(vec3(map(pos - e.xyy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yxy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yyx).x - tp));\n\treturn (norm);\n}\n\nvec3 getColor(vec4 info)\n{\n   float mat = info.w;\n   vec2 uv = info.yz;\n   \n   if (mat == 0.0)\n   {\n       return vec3(0.6, 1.0, 0.6);\n   }\n   if (mat == 1.0)\n   {\n       return texture(iChannel1, uv).xyz;\n   }\n   return (vec3(0.0));\n}\n\nfloat getShadow(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 10.0;\n    vec4 info;\n\tvec3 pos;\n    \n    float res = 1.0;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        info = map(pos);\n\t\td = info.x;\n        res = min(res, d / t * 8.0);\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n        \n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float camPitch = 0.0;\n    float camYaw = iTime / 5.0;\n    float cameraDist = 1.0;\n    \n    vec2 muv = iMouse.xy;\n    \n    if (iMouse.xy == vec2(0.0))\n        muv.xy = vec2(iResolution.x * 0.3, iResolution.y * 0.4);\n    \n    camPitch = (muv / iResolution.xy + 0.5).y * PI;\n    camYaw = (muv / iResolution.xy + 0.5).x * PI * 2.0;\n    \n    camPitch = min(max(PI - 1.2, camPitch), PI + 1.2);\n    \n    vec3 cameraPos = cameraDist * vec3(cos(camYaw) * cos(camPitch), sin(camPitch), sin(camYaw) * cos(camPitch));\n    vec3 cameraDir = -normalize(cameraPos);\n    \n    cameraPos.y = max(-1.49, cameraPos.y);\n    \n\tvec3 rayDir = getRayDir(cameraDir, PI / 2.0, fragCoord);\n\tvec3 rayOrigin = cameraPos;\n    \n    vec4 info = marchRay(rayOrigin, rayDir);\n\tfloat t = info.x;\n\n\tvec3 color = texture(iChannel2, rayDir).xyz;\n\n\tif (t != -1.0)\n\t{\n\t\tvec3 pos = rayOrigin + rayDir * t;\n\t\tvec3 lightDir = normalize(vec3(-4, 4, 4));\n\t\tvec3 norm = getNorm(pos);\n\t\tfloat l = 0.4;\n        \n        color = getColor(info);\n        \n        lightDir = normalize(vec3(5) - pos);\n        \n        float mat = info.w;\n        \n        float st = getShadow(pos + norm * 0.001, lightDir);\n\n        l += max(0.0, dot(lightDir, norm)) * 0.6 * st;\n\n        color *= l;\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}