{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define AAS 0.02\n#define PI 3.14159265359\n#define TRIANGLE_NUMBER 6\n\n//#define MOUSE\n\nstruct triangle_t{\n\tvec2 a;\n   \tvec2 b;\n    vec2 c;\n};\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//returns the pseudo-cross product in two dimensions.\nfloat cross2(vec2 v1, vec2 v2){\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n\nfloat direction(vec2 p1, vec2 p2, vec2 p3){\n\treturn cross2(p3-p1,p2-p1);\n\n}\n\n//returns 1.0 if the segments a and b intersect strictly.\nfloat intersect(vec2 a1, vec2 a2, vec2 b1, vec2 b2){\n    \n    float d1 = direction(b1,b2,a1);\n    float d2 = direction(b1,b2,a2);\n    float d3 = direction(a1,a2,b1);\n    float d4 = direction(a1,a2,b2);\n    \n\tif ( (((d1 > 0.0) && (d2 < 0.0)) || ((d1 < 0.0) && (d2 > 0.0))) &&\n        (((d3 > 0.0) && (d4 < 0.0)) || ((d3 < 0.0) && (d4 > 0.0))) ){\n    \treturn 1.0;\n    }\n    \n    return 0.0;\n}\n\n\n\nfloat inside_tri (vec2 p, triangle_t t){\n\t\n    float ca = cross2(t.a-t.b,t.a-p);\n    float cb = cross2(t.b-t.c,t.b-p);\n    float cc = cross2(t.c-t.a,t.c-p);\n        \n    float sa = sign(ca);\n    float sb = sign(cb);\n    float sc = sign(cc);\n        \n    if((sa == sb) && (sb == sc)){\n    \treturn 1.0;\n    };\n    \n    return 0.0;\n                                      \n\t\n}\n\nvec2 rotate(vec2 p, float angle){\n\treturn vec2(cos(angle)*p.x+sin(angle)*p.y,\n                -sin(angle)*p.x+cos(angle)*p.y);\n\n}\n\ntriangle_t rotate(triangle_t t, float angle){\n\ttriangle_t ret;\n    ret.a = rotate(t.a,angle);\n    ret.b = rotate(t.b,angle);\n    ret.c = rotate(t.c,angle);\n    \n    return ret;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n    float ar = iResolution.x / iResolution.y;\n    vec2 r =  vec2(uv.x * ar,uv.y);\n    vec2 mouse = vec2(-1.0 + 2.0*iMouse.xy / iResolution.xy);\n    \n#ifdef MOUSE    \n    \n    vec2 mouser = vec2(mouse.x * ar,mouse.y);\n    \n#else    \n    vec2 mouser = vec2 (cos(0.89*iTime),0.8*sin(0.5*iTime));\n     \n#endif    \n    \n    float staticn = rand(r*cos(iTime));\n    float staticn2 = rand(r*sin(iTime));\n\n    triangle_t triangles[TRIANGLE_NUMBER];\n    \n        \n    triangles[0].a = vec2(-ar/2.0,0.0);\n    triangles[0].b = vec2(-ar/2.0 + 0.4,0.0);\n    triangles[0].c = vec2(-ar/2.0 + 0.2,sqrt(0.4)/2.0);\n    \n    triangles[0] = rotate(triangles[0],0.2*iTime);\n    for(int i = 1;i<TRIANGLE_NUMBER;i++){\n    \ttriangles[i] = rotate(triangles[i-1],2.0*PI/float(TRIANGLE_NUMBER));\n\n    }\n    \n    \n    vec2 lightpos = mouser;\n    \n    float shade = 0.0;\n\n    for(int i = 0;i<TRIANGLE_NUMBER;i++){\n\t\tshade += intersect(triangles[i].a,triangles[i].b,lightpos,r);\n        shade += intersect(triangles[i].a,triangles[i].c,lightpos,r); \n        shade += intersect(triangles[i].b,triangles[i].c,lightpos,r);        \n        \n    }\n\n    \n    \n    float shape = 0.0;\n    float lightshape = 0.0;\n\n    for(int i = 0;i<TRIANGLE_NUMBER;i++){\n        float s = inside_tri(r,triangles[i]);\n        shape += s;\n        \n        if (s > 0.5){\n        \tlightshape += inside_tri(mouser,triangles[i]);\n        }\n    }\n\n    \n\n    \n    \n    float col = 0.6 + 0.2*(1.0-length(r));\n    col +=1.0- smoothstep(0.0,staticn/3.0,length(mouser-r));\n    col += 0.5 -clamp(length(mouser-r)*5.0,0.0,0.5);\n    col += 0.2 - clamp(length(mouser-r)/2.0,0.0,0.2);\n    \n    if (shade > 0.5) col = staticn;\n    if (shape > 0.5) col = staticn*staticn2;\n    if (lightshape > 0.5) col = 1.0;\n    \n   \n\n    fragColor=vec4(vec3(col),1.0);\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltf3R8","date":"1418423894","viewed":411,"name":"Static Shadow","username":"Steel_Neuron","description":"I wanted to learn how to do 2d shadows, and played a bit with static-looking noise. Hopefully it looks half-decent! I'm not sure how to anti-aliasing with anything other than circles and rectangles, but that's next on the list :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","shadows","static"],"hasliked":0,"parentid":"","parentname":""}}