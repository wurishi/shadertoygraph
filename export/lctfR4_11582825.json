{"ver":"0.1","info":{"id":"lctfR4","date":"1733120563","viewed":224,"name":"Volumetric Ring of Fire","username":"BradyInstead","description":"Raymarched volumetric fire\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["fire","volumetric","raymarcher"],"hasliked":0,"parentid":"WllXzB","parentname":"Brady's Volumetric Fire"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR 1.0\n\nvec3 nearPixel(vec2 fragCoord, vec2 pos)\n{\n\treturn texture(iChannel0, (fragCoord+pos)/iResolution.xy).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get color + AA\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy * .1).rgb;\n    \n    // Uncomment for motion blur\n    col = mix(col, nearPixel(fragCoord, vec2(0., 1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(1., 0.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(0., -1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(-1., 0.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(-1., 1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(1., -1.)), BLUR);\n    \n    // Greyscale (remove for color)\n   \t//col = vec3(col.r + col.g + col.b)/3.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////\n// BRADY'S VOLUMETRIC FIRE //\n/////////////////////////////\n\n// from https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\nfloat noise( vec3 P )\n{\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\n// from https://www.shadertoy.com/view/Xsd3R2\nfloat fnoise(vec3 p, float time)\n{\n    float f = 0.0;\n    p = p - vec3(0.0, 1.0, 0.0) * .5 * time;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    return f;\n}\n\nfloat torusSDF( vec3 p, vec2 t ) // p = position, t = dimensions(outer, inner)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat model( in vec3 p )\n{\n    // position\n    p.y *= .7;\n    \n    // add noise to new position\n    vec3 np = p;\n    np += (fnoise(p*1.2, iTime)-.5)*.1;\n    \n    // torus\n    float torus = torusSDF(np, vec2(.8, .43));\n    \n    // calc variables\n    float distToCenter = abs(pow(length(np), 1.9)*.85);\n    float angle = atan(np.z, np.x);\n    \n    // new position operations\n    np.x = sin(angle);\n    np.z = cos(angle) + iTime*.2;\n    np.y = -pow(distToCenter, 4.);\n    np.xyz *= .9;\n    \n    // add fire noise\n    float res = torus + fnoise(np*1.5, iTime*3.)* (max(0.,1.-distToCenter/1.))*2.;\n    \n    // static outer torus (optional)\n    //float outerTorus = torusSDF(p, vec2(1.2, .125));\n    //res = smoothUnion(res, outerTorus, .2);\n    \n    return res*.86;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 40; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .001) return dist;\n        else if(dist > 6.) break;\n    }\n    return -1.;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Shaders/Builtin/Functions/saturation.glsl\nvec3 saturation(vec3 rgb, float adjustment)\n{\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nvec3 background(in vec2 p)\n{\n\treturn vec3(0.);\n}\n\nvec3 volume(in vec3 p, in vec3 rd, in vec3 ld, in vec2 sp)\n{\n    // volume variables\n    vec3 op = p;\n    float trans = 1.0;\n    float td = 0.0;\n    float dif = 0.0;\n    float emit = 0.0;\n    float steps = 15.; // increase to smooth\n    \n    // march\n    for(float i = 0.; i < steps; i++)\n    {\n        float m = model(p);\n        p += rd*.03;\n        \n        float dens = 1.-smoothstep(0., .35, -m);\n        td += dens;\n        trans *= dens;\n        \n        if(td > 1.0 && dif <= 0.)\n        {\n            td = 1.;\n        \tdif = clamp(1. - model(p - .1*ld), 0., 1.);\n            emit = pow(smoothstep(-.3, 0., model(p)), 4.);\n        }\n    }\n    \n    // transparency\n    trans = (1.-pow(td/steps, 4.5))*1.2;\n    trans = smoothstep(0., 1., trans);\n    \n    // emit\n    float emitmod = (emit*trans)+.05;\n    \n    // light\n    float distToCenter = abs(pow(length(p), 2.)*.85);\n    vec3 lin = vec3(.3, .2, .9);\n    lin = hueShift(lin, 4.5 + trans*.2 - distToCenter*.6);\n    lin *= emitmod;\n    \n    // bright/sat/contrast\n    lin = saturation(lin, trans);\n    lin *= 3.5;\n    lin -= vec3(.2);\n    lin *= trans*2.;\n    \n    return lin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel position\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    // camera positions\n    float rs = .5;\n    vec3 ro = vec3(0.01, 4.7, 0.);\n    vec3 ta = vec3(0., 0.0, .0);\t\t\t\t\n    \n    // camera matrix\n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., .5, 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.8)); // zoom\n    \n    // raymarch & get color\n    float dist = raymarch(ro, rd);\n    vec3 ld = vec3(-1., 1., 0.);\n    vec3 col = dist > 0. ? volume(ro+rd*dist, rd, ld, p) : background(p);\n    \n    // motion blur\n    vec3 prev = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\tcol = mix(prev, col, .8);\n    \n    // out\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}