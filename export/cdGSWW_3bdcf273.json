{"ver":"0.1","info":{"id":"cdGSWW","date":"1681077002","viewed":85,"name":"Carousels","username":"gest","description":"Somewhere it was, but I wanted to speed it up\n\nOriginal \"Ferris Wheel 2\" by wjbgrafx\nhttps://www.shadertoy.com/view/4scXz7","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarchreplicaangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n#define u_canvas iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n\n\nconst float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\t#if 1\n\t\t//Правильно\n\t\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\t\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\t#else\n\t\t//Не правильно\n\t\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\t\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\t#endif\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\t#if 1\t\t\n\t\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t#else\n\t\t\tfloat angle = radians(cam.fov);\n\t\t\tray.direction = normalize(vec3(sin(angle*0.5) * uv.x * cam.aspect,  sin(angle*0.5) * uv.y,  -cos(angle*0.5)));\n\t\t#endif\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n\n//-------------------Контроль времени-------------------\n//      -------         -------\n//     |       |       |       |\n//_____|       |_______|       |\nfloat demoTimer(float time, float intervalCount, float intervalDuration) {\n    float interval_id = floor(time/intervalDuration);\n\treturn mod(interval_id, intervalCount);\n}\n//       -------\n//      /\n//_____/\nfloat timeStep(float time, float time_start, float duration) {\n    return smoothstep(time_start, time_start + duration, time);\n}\n//       -------\n//      /       \\\n//_____/         \\______\n// v.x - time_start, v.y - time_stop\nfloat timeClamp(float time, vec2 v, float duration) {\n    return smoothstep(v.x, v.x+duration, time) - smoothstep(v.y-duration, v.y, time);\n}\n\n//-------------------Функции позиционирования объектов сцены\nvoid translate(inout vec3 p, vec3 dist) {\n\tp = p - dist;\n}\nvoid translate(inout vec2 p, vec2 dist) {\n\tp = p - dist;\n}\nvoid translate(inout float p, float dist) {\n\tp = p - dist;\n}\n\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\nvoid rotateX(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(r,0,0));\n\tp = tMat * p;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,r,0));\n\tp = tMat * p;\n}\n/*\nvoid rotateZ(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,0,r));\n\tp = tMat * p;\n}\n*/\nvoid rotateZ(inout vec3 p, float a) {\n  \tfloat s = sin(a), c = cos(a);\n  \tp = vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Размножение. Возвращает центр ячейки с id=0.\nfloat replica(inout float p, float d) {\n    float id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\n\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nfloat replicaLimit(inout float p, float d, float ida, float idb) {\n\tfloat id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec2 replicaLimit(inout vec2 p, vec2 d, vec2 ida, vec2 idb) {\n\tvec2 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec3 replicaLimit(inout vec3 p, vec3 d, vec3 ida, vec3 idb) {\n\tvec3 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nfloat replicaAngle(inout vec2 p, float n, float off) {\n\tfloat a = 2.* PI /n;\n\t//polar\n\tp = vec2(atan(p.y, p.x), length(p.xy));\n\tfloat id = floor(mod(p.x + 0.5*a + off, 2.*PI)/a);\n    p.x = mod(p.x + 0.5*a + off, a) - 0.5*a;\n\tp = p.y * vec2(cos(p.x),sin(p.x));\n\treturn id;\n}\n//Вытягивание 2D-профиля dist_2D_profile в направлении p (p.x, p.y, p.z) между -h...+h \nfloat extrude2D(float dist_2D_profile, float p, float h) {\n\tfloat dist_3D_between = abs(p) - h;\n    vec2 w = vec2(dist_2D_profile, dist_3D_between);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\nfloat extrude2D(float dist_2D_profile, float dist_3D_between) {\n    vec2 w = vec2(dist_2D_profile, dist_3D_between);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n//Все нечетные id\nbool replicaOddID(vec3 id) {\n\tid = sign(id - floor(id/2.)*2. - 0.5);\n\treturn id.x*id.y*id.z<0.;\n}\nbool replicaOddID(vec2 id) {\n\tid = sign(id - floor(id/2.)*2. - 0.5);\n\treturn id.x*id.y<0.;\n}\nbool replicaOddID(float id) {\n\tid = sign(id - floor(id/2.)*2. - 0.5);\n\treturn id<0.;\n}\n\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n//Мягкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 - 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) - k*h*(1.-h);\n}\n//Мягкое умножение / Пересечение / И (k==0 без)\nfloat AND(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n//-------------------функции расстояний до объектов\n\n\n\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\n\nfloat dfBefore(float p, float p1) {\n\treturn p - p1;\n}\nfloat dfAfter(float p, float p1) {\n\treturn -p + p1;\n}\nfloat dfBetween(float p, float p1, float p2) {\n\treturn max(-p + p1, p - p2);\n}\nfloat dfBall(vec3 p, float R) {\n\treturn length(p)-R;\n}\nfloat dfCircle(vec2 p, float R) {\n\treturn length(p) - R;\n}\n\nfloat dfPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat dfBox(vec3 p, vec3 b) {\n\tp = abs(p) - b;\n//\treturn max(max(p.x,p.y),p.z);\n\tvec3 v = min(p, vec3(0));\n\tfloat d = max(max(v.x, v.y), v.z);\n\treturn length(max(p, vec3(0))) + d;\n}\n\n//Цилиндрический отрезок от <a> до <b>, радиусом r\nfloat dfCylSegmentAB(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.);\n\tvec3 p1 = (ab*t + a) - p;\n\t//return dfBox(p1, vec3(r));\n\treturn dfBall(p1, r);\n}\n\n//Тор  в плоскости YZ\nfloat dfTorusX(vec3 p, float R, float r) {\n\treturn length(vec2(length(p.yz) - R, p.x)) - r;\n}\n//Тор  в плоскости XZ\nfloat dfTorusY(vec3 p, float R, float r) {\n\treturn length(vec2(length(p.xz) - R, p.y)) - r;\n}\n//Тор  в плоскости XY\nfloat dfTorusZ(vec3 p, float R, float r) {\n\treturn length(vec2(length(p.xy) - R, p.z)) - r;\n}\n\n#define ID_GROUND_ODD 0.0\n#define ID_GROUND 1.0\n#define ID_TOWER 2.0\n#define ID_SEAT_1 3.0\n#define ID_SEAT_2 4.0\n#define ID_SEAT_3 5.0\n#define ID_SEAT_4 6.0\n#define ID_SEAT_5 7.0\n#define ID_SEAT_6 8.0\n#define ID_SEAT_7 9.0\n#define ID_SEAT_8 10.0\n\nconst float sectors = 8.;\n\n//------------------------------------------------------------------------------\nfloat map(vec3 p, inout Object object) {  \n\tvec3 q, qq;\n\t\n\tobject = Object(1e6, -1.0); \n\t\n\tp.z += 3.*u_time;\n\t\n\tvec2 idXZ = replica(p.xz, vec2(15.));\n\tfloat rnd = rand(idXZ)*2.-1.;\n\trotateY(p, rnd);\n\t\n\tObject GROUND = Object(1e6, replicaOddID(idXZ) ? ID_GROUND_ODD : ID_GROUND);\n\t{\n\t\tq = p;\n\t\tGROUND.distance = dfBefore(q.y, 0.);\n\t}\n\tobject = OR(object, GROUND);\n\t\n\tfloat whellAngle = u_time * -0.5 * rnd;\n\t\n\t\n\tObject TOWER = Object(1e6, ID_TOWER);\n\t{\n\t\tq = p;\t\n\t\t// Mirror across x-axis.\n\t\tmirror( q.z, 0.0 );\n\t\t\n\t\t//Вертикальная опора\n\t\tqq = q;\n\t\tqq -= vec3( 0.0, 3.6, 1.5 );\n\t\tTOWER.distance = OR(TOWER.distance, dfBox(qq, vec3( 0.15, 3.6, 0.15 ) ));\n\t\t//Основание\n\t\tqq = q;\n\t\tqq -= vec3( 0.0, 0.2, 1.5 );\n\t\tTOWER.distance = OR(TOWER.distance, dfBox(qq, vec3( 5.0, 0.2, 0.3 ) ));\n\t\t//Наклонная опора1\n\t\tqq = q;\n\t\tTOWER.distance = OR(TOWER.distance, dfCylSegmentAB( qq, vec3( 4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ));\n\t\t//Наклонная опора2\n\t\tqq = q;\n\t\tTOWER.distance = OR(TOWER.distance, dfCylSegmentAB( qq, vec3( -4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ));\n\t\t//Балка\n\t\tqq = q;\n\t\tqq -= vec3( 0.0, 0.2, 0.0 );\n\t\tTOWER.distance = OR(TOWER.distance, dfBox(qq, vec3( 0.3, 0.2, 2.0 ) ));\n\t\t//Ось\n\t\tTOWER.distance = OR(TOWER.distance, dfCylSegmentAB( p, vec3( 0.0, 7.0, 1.5 ), vec3( 0.0, 7.0, -1.5 ), 0.2 ));\n\t\t\n\t\tq = p;\n\t\tq.y -= 7.0;\n\t\trotateZ( q, whellAngle );\n\t\tq.y += 7.0;\n\t\t\n\t\t//Отражение относительно плоскости XY\n\t\tmirror( q.z, 0.0 );\t\n\t\t\n\t\tqq = q;\n\t\tqq -= vec3( 0.0, 7.0, 1.0 );\n\t\t//Внешний обруч\n\t\tTOWER.distance = OR(TOWER.distance, dfTorusZ(qq, 5.0, 0.1 ));\n\t\t//Внутренний обруч\n\t\tTOWER.distance = OR(TOWER.distance, dfTorusZ(qq, 4.0, 0.05 ));\n\t\t//Осевой обруч\n\t\tTOWER.distance = OR(TOWER.distance, dfTorusZ(qq, 0.25, 0.05 ));\n\t\t\n\t\t//Спицы\n\t\tqq = q;\n\t\tqq -= vec3( 0.0, 7.0, 1.0 );\n\t\treplicaAngle(qq.xy, sectors, 0.);\n\t\tfloat d1 = dfCircle(qq.yz, 0.05);\n\t\tfloat d2 = dfBefore(qq.x, 5.0);\n\t\tTOWER.distance = OR(TOWER.distance, AND(d1, d2));\n\t}\n\tobject = OR(object, TOWER);\n\n\n\tq = p;\n\tq.y -= 7.0;\n\tfloat id = replicaAngle(q.xy, sectors, whellAngle);\n\tq.x -= 5.;\n\t\n\tObject SEATS = Object(1e6, ID_SEAT_1 + id);\n\t\n\trotateZ( q, -whellAngle );\n\trotateZ(q, (id-2.)*2.*PI/sectors);\n\tfloat seat = dfBox(q, vec3( 0.5, 0.8, 0.8 ));\n\tfloat seatCutA = dfBox( q-vec3(0.6,0,0), vec3( 0.5, 0.6, 1 ) );\n\tfloat seatCutB = dfBox( q-vec3(0.2,0,0), vec3( 0.5, 0.4, 1 ) );\n\tSEATS.distance = seat;\n\tSEATS.distance = AND( SEATS.distance, -seatCutA );\n\tSEATS.distance = AND( SEATS.distance, -seatCutB );\n\tSEATS.distance *= 0.6;\n\n\tobject = OR(object, SEATS);\n\n\treturn object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal( in vec3 p, float eps ) {\n    vec2 e = vec2(eps, -eps); \n    return normalize( \n\t\te.xyy * map( p + e.xyy ) + \n\t\te.yyx * map( p + e.yyx ) + \n\t\te.yxy * map( p + e.yxy ) + \n\t\te.xxx * map( p + e.xxx ) \n\t);\n}\n\nfloat rayMarch(inout Ray ray) {\n    ray.distance = ray.near;\n\tfloat steps = 1.;\n    for ( int i = 0; i < 100; ++i ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t    ray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance<ray.epsilon;\n        if ( ray.hit )  break;\n        ray.distance += ray.object.distance*ray.swing;\n        if (ray.distance > ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n    return steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n    float shade = 1.0;\n    ray.distance = ray.near;    \n\tfloat steps = 1.;\n    for ( int i = 0; i < 50; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n        ray.object.distance = map(ray.position);\n        shade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n        if (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\nvec3 getObjectColor( vec3 p, float objectID ) {    \n    vec3 col = vec3( 1.0 );\n\tif( objectID == ID_GROUND ) {\n\t\tcol = vec3( 0.0, 1.0, 0.0 );\n\t} else if ( objectID == ID_GROUND_ODD ) {\n\t\tcol = vec3( 1.0, 1.0, 1.0 );\n\t} else if ( objectID == ID_TOWER ) {\n\t\tcol = vec3( 0.95, 0.95, 1.0 );\n\t} else if ( objectID == ID_SEAT_1 ) {\n\t\tcol = vec3( 1.0, 0.0, 0.0 );// seat 1\n\t} else if ( objectID == ID_SEAT_2 ) {\n\t\tcol = vec3( 1.0, 0.5, 0.0 );\n\t} else if ( objectID == ID_SEAT_3 ) {\n\t\tcol = vec3( 1.0, 1.0, 0.0 );// seat 3\n\t} else if ( objectID == ID_SEAT_4 ) {\n\t\tcol = vec3( 0.5, 1.0, 0.0 );\n\t} else if ( objectID == ID_SEAT_5 ) {\n\t\tcol = vec3( 0.0, 1.0, 1.0 );// seat 5\n\t} else if ( objectID == ID_SEAT_6 ) {\n\t\tcol = vec3( 0.0, 0.0, 1.0 );\n\t} else if ( objectID == ID_SEAT_7 ) {\n\t\tcol = vec3( 0.5, 0.0, 1.0 );// seat 7\n\t} else if ( objectID == ID_SEAT_8 ) {\n\t\tcol = vec3( 1.0, 0.0, 0.5 );\n\t}\n    return col;\n}\n\nvec3 lighting(Ray ray, vec3 lightPos, vec3 mColor) {    \n    vec3 lightDir = normalize(lightPos - ray.position); \n\tvec3 lightCol = vec3( 1.0, 0.6, 0.2 );\n    float lightDist = max( length( lightPos - ray.position ), 0.001 ); \n\tfloat light_atten = 0.003;\n    float atten = 1.0 / ( lightDist * lightDist * light_atten );\n    float diff = max( dot( ray.normal, lightDir ), 0.0 );\n    float spec = pow( max( dot( reflect( -lightDir, ray.normal ), -ray.direction ), 0.0 ), 8.0 );\n    return ( mColor * ( diff + 0.15 ) + lightCol * spec * 2.0 ) * atten;\n}\n\nvec3 sky(vec3 rd) {\n\treturn vec3(1);\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv*2.-1.;\n\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5);\n\n\tvec3 angle = vec3(\n\t\t-mix(-90., 90., mouse.y) + 30. - 30.*sin(u_time),\n\t\t mix(-180.,180., mouse.x) + 30.*cos(u_time),\n\t\t 0.\n\t);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0, 10.0, -1.0 );\n\t\tcam.target  = vec3(0, 10.0,  0.0 );\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 80.;\n\t\tray.epsilon = 0.0025;\n\t\tray.swing\t= 1.0; //0.8 + 0.1 * rnd(uv)\n\t\tray.steps \t= 50.;\n\n\t\trotateOrigin(ray.direction, radians(angle));\n\t}\n\trayMarch(ray);\n\n\tvec3 lightPos = ray.origin + vec3( 0.0, 20.0, -10.0 );\n\tvec3 bgCol = sky(ray.direction);\n\tvec3 color = bgCol;\n\t   \n\tif ( ray.distance <ray.far ) {\n\t\tray.normal = mapNormal( ray.position, 0.005 );\n\t\t\n    \tvec3 mColor = getObjectColor( ray.position, ray.object.id );\n\n\t\tcolor = lighting(ray, lightPos, mColor);\n\t\t\n\t\t//Тень\n\t\tRay ray_s = ray;\n\t\t{\n\t\t\tray_s.origin \t= ray.position;\n\t\t\tray_s.direction\t= normalize(lightPos - ray.position);\n\t\t\tray_s.near\t\t= 0.01;\n\t\t\tray_s.far\t\t= max( length(lightPos - ray.position), 0.001 );\n\t\t\tray_s.steps\t\t= 20.;\n\t\t\tray_s.epsilon\t= 0.001;\n\t\t}\n\t\tfloat shadow = softShadow( ray_s, 24.0 );\n\t   \n\t   \tif (ray.object.id==ID_GROUND_ODD) {\n\t\t\t//Отражение\n\t\t\tRay ray_r = ray;\n\t\t\t{\n\t\t\t\tray_r.origin \t= ray.position;\n\t\t\t\tray_r.direction = reflect( ray.direction, ray.normal );\n\t\t\t\tray_r.steps\t\t= 50.;\n\t\t\t}\n\t\t\trayMarch(ray_r);\n\t\t\t\n\t\t\tif ( ray_r.distance <ray_r.far ) {\n\t\t\t\tray_r.normal = mapNormal( ray_r.position, 0.005 );\n\t\t\t\t\n\t\t\t\tmColor = getObjectColor( ray_r.position, ray_r.object.id );\n\t\t\t\t\n\t\t\t\tcolor += lighting( ray_r, lightPos, mColor) * 0.45;\n\t\t\t} else {\n\t\t\t\tcolor += bgCol * 0.45;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tcolor *= shadow;\n\t\tfloat fog = smoothstep( ray.far * 0.8, 0.0, ray.distance ); \n\t\tvec3 fogCol = bgCol;\n\t\tcolor = mix( color, fogCol, 1.0 - fog );\n\t\t\n\t}\n\tcolor = clamp( color, 0.0, 1.0 );\n\t\n\tgl_FragColor = vec4( color, 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}]}