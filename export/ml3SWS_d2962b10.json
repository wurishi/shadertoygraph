{"ver":"0.1","info":{"id":"ml3SWS","date":"1685734634","viewed":190,"name":"SDF Subtraction - Attempt (fork)","username":"kastorp","description":"fork ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","subtraction"],"hasliked":0,"parentid":"slGyWt","parentname":"SDF Subtraction - Attempt 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fork of SDF Subtraction - Attempt 1\n// https://www.shadertoy.com/view/slGyWt\n\n//debug vars\nvec3 col;\nbool trace;\nvec2 pos;\n\n//-----------------\n\n#define opSubtract(p,A,B,perimeter,steps)\\\n    /* regular subtraction */ \\\n    max(A.x,-B.x);\\\n    if( d>0.0 )\\\n    {\\\n        vec2 op = p;\\\n        /* if point is external to A, find closest point to A*/ \\\n        if(A.x>0.) p = p-A.x*A.yz; \\\n        /* if such point is external to B, use it*/ \\\n        if(B.x>0.){ \\\n            d= length(p-op); \\\n            if(trace && length(pos-p)<.02) col=vec3(0,1,0);\\\n        }else{ \\\n             /* otherwise circumnavigate B perimeter*/ \\\n            p= op- B.y*B.yz; \\\n            vec2 pm; \\\n            /* constant steps, for global minimum */ \\\n            float dl=perimeter/steps,dm=1e10;\\\n            for(int i=0;i<int(steps);i++){\\\n                /* using grandient works on circle but not on rectangle, because of the corners*/ \\\n                p +=vec2(B.z,-B.y)*dl;\\\n                p-= B.x*B.yz;\\\n                /* the closest point on B perimeter must be internal to A */ \\\n                float dp=dot(op-p,op-p),da =A.x; \\\n                if(da<.0  && dm >dp) {dm=dp; pm=p; }\\\n                if(trace && length(pos-p)<.005) col=vec3(0,0,1);  \\\n                /* TODO: interpolate if sign(da) change */ \\\n                /* TODO: dl dependency to abs(da) */ \\\n            }\\\n             /* using bisection for local minimum */ \\\n            for(int j=0;j<5;j++){\\\n            p=pm; p-=vec2(B.z,-B.y)*dl; p-= B.x*B.yz; dl*=.5; dm=1e10;\\\n            for(int i=0;i<=2;i++){\\\n                p +=vec2(B.z,-B.y)*dl;\\\n                p-= B.x*B.yz;\\\n                float dp=dot(op-p,op-p),da =A.x; \\\n                if(da<.0  && dm >dp) {dm=dp; pm=p; }\\\n            }}\\\n            if(trace && length(pos-pm)<.02) col=vec3(1,0,0);\\\n            d =length(op-pm); \\\n        } \\\n    }\n    \n\n\nfloat map( in vec2 m ,in vec2 p )\n{\n    trace=false;\n    if(p!=m){trace=true; pos=p;p=m;}\n    vec2 off = 0.1*sin(iTime+vec2(0.0,2.0));\n\n    float d = opSubtract( p, sdgBox(p,vec2(0.3,0.6)), \n                             sdgCircle(p,vec2(0.0,0.2)+off,0.4),(6.28*0.4),100.);  //subtract circle          \n                             //(sdgBox(p-off,vec2(0.6,0.3))-vec3(.0001,0,0)),3.6,400.);  //subtract rounded box\n                             //(sdMoon(p-off,.3, .4, .2 )-vec3(.0001,0,0)),6.,200.);\n    return d;\n}\nfloat map( in vec2 p){\n    return map(p,p);\n}\n\n\nvec2 gra( in vec2 p )\n{\n    const float e = 0.0002;\n    return vec2(map(p+vec2(e,0.0))-map(p-vec2(e,0.0)),\n                map(p+vec2(0.0,e))-map(p-vec2(0.0,e)))/(2.0*e);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // distance\n    float d = map(p);\n    \n    // coloring\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // debug gradient\n    {\n    #if 0\n        vec2 g = gra(p);\n        col *= 1.0 + vec3(0.5*g,0.0);\n        float l = length(g);\n        if( l>1.01 ) col=vec3(1,0,0);\n        if( l<0.99 ) col=vec3(0,0,1);\n    #endif\n    }\n\n    // debug distance with mouse\n    if( iMouse.z>0.001 )\n    {\n    d = map(m,p);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n//\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{\n    p -= c;\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nvec3 sdMoon(vec2 p, float d, float ra, float rb )\n{\n    float s = sign(p.y);\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        vec2 w = p-vec2(a,b); float d = length(w); w.y *= s;\n        return vec3(d,w/d);\n    }\n\n    vec2 w1 = p;         ; float l1 = length(w1); float d1 = l1-ra; w1.y *= s;\n    vec2 w2 = p-vec2(d,0); float l2 = length(w2); float d2 = rb-l2; w2.y *= s;\n    \n    return (d1>d2) ? vec3(d1,w1/l1) : vec3(d2,-w2/l2);\n}\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n","name":"Common","description":"","type":"common"}]}