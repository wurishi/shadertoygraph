{"ver":"0.1","info":{"id":"4ttGRf","date":"1470624005","viewed":612,"name":"Hypnogram","username":"sixstring982","description":"New slit-screen stacked plane deformations. Can create 23^8 different combinations.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["plane","deformations","slitscreen","hypnogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define INFTY 1e20\n\n// from Dave_Hoskins (thanks!)\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n    \n}\n\n/* This palette is randomly generated using the technique described \n * by iq here: https://iquilezles.org/articles/palettes\n */\nfloat palette_c(in float s, in float x) {\n    vec4 v = hash41(s);\n    return v.r + v.g * cos(2.0 * PI * (v.b + v.a * x));\n}\n\nvec3 palette(in float s, in float x) {\n    vec3 seeds = hash31(s);\n    float r = palette_c(seeds.x, x);\n    float g = palette_c(seeds.y, x);\n    float b = palette_c(seeds.z, x);\n    \n    return vec3(r, g, b);\n}\n\n/* Time for seed change in seconds */\n#define SEED_LENGTH 10.0\n#define SEED_OFFSET 113.0 // Change this to create different seed patterns (keep as whole number)\nfloat longSeed() {\n    return floor((iTime + SEED_LENGTH * (1.0 + SEED_OFFSET)) / SEED_LENGTH);\n}\n\nfloat icSinJulia(vec2 uv, float x) {\n    vec2 c = 0.4 + 0.1 * sin(x) * vec2(sin(iTime * 0.5), cos(iTime * 0.3));\n    vec2 z = uv * vec2(1.0, 1.2);\n    float nx;\n    \n    int iters = 0;\n    for (int i = 0; i < 64; i++) {\n        if (z.x * z.x + z.y * z.y > 4.0) {\n            continue;\n        }\n        \n        iters = i;\n        nx = z.x * z.x - z.y * z.y + c.x;\n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = nx;\n    }\n    \n    return (float(iters) + x * 4.0) / 32.0;\n}\n\nfloat icCosJulia(vec2 uv, float x) {\n    vec2 c = 0.4 + 0.1 * cos(x) * vec2(sin(iTime * 0.5), cos(iTime * 0.3));\n    vec2 z = uv * vec2(1.0, 1.2);\n    float nx;\n    \n    int iters = 0;\n    for (int i = 0; i < 64; i++) {\n        if (z.x * z.x + z.y * z.y > 4.0) {\n            continue;\n        }\n        \n        iters = i;\n        nx = z.x * z.x - z.y * z.y + c.x;\n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = nx;\n    }\n    \n    return (float(iters) + x * 4.0) / 32.0;\n}\n\nvec2 polarFromCart(in vec2 uv) {\n    return vec2(length(uv), atan(uv.x, uv.y));\n}\n\nvec2 cartFromPolar(in vec2 uv) {\n    return vec2(uv.x * sin(uv.y),\n                uv.x * cos(uv.y));\n}\n\nvec2 pcFisheye(in vec2 uv) {\n    vec2 p = polarFromCart(uv);\n    p.x *= p.x;\n    return cartFromPolar(p);\n}\n\nvec2 pcXMod(in vec2 uv, in float x) {\n    return mod(uv - vec2(1.0, 1.0), vec2(0.3, 2.0));\n}\n\nvec2 pcYMod(in vec2 uv, in float x) {\n    return mod(uv - vec2(1.0, 1.0), vec2(2.0, 0.3));\n}\n\nfloat icRadial(in vec2 uv, in float x) {\n \treturn length(uv) + x;   \n}\n\nfloat icSinCos(in vec2 uv, in float x) {\n    return sin(uv.x) + cos(uv.y) + x;\n}\n\nvec2 pcRotate(in vec2 uv, in float x) {\n    mat2 rot = mat2(cos(x), -sin(x), sin(x), cos(x));\n    return rot * uv;\n}\n\nvec2 pcSin(in vec2 uv, float x) {\n    return vec2(uv.x, uv.y * 0.5 + 0.5 * sin(uv.x * 5.0 * sin(x) + iTime));\n}\n\nvec2 pcCos(in vec2 uv, float x) {\n    return vec2(uv.x * 0.5 + 0.5 * sin(uv.y * 0.5 + sin(x) + iTime), uv.y);\n}\n\nfloat icInverse(in vec2 uv, in float x) {\n \treturn 1.0 / length(uv + vec2(x)) + x;\n}\n\nfloat icDiagonal(in vec2 uv, in float x) {\n \treturn uv.x + uv.y + x; \n}\n\nvec2 pcSwap(in vec2 uv, in float x) {\n \treturn uv.yx;\n}\n\nfloat icX(in vec2 uv, in float x) {\n    return uv.x + x;\n}\n\nfloat icY(in vec2 uv, in float x) {\n    return uv.y + x;\n}\n\nvec2 pcScale(in vec2 uv, in float x) {\n    return uv * (0.75 + 0.5 * sin(x));\n}\n\n#define PIXEL_SIZE 64.0\nvec2 pcPixelate(in vec2 uv, in float x) {\n    return floor(uv * PIXEL_SIZE) / PIXEL_SIZE;\n}\n\nfloat icBeam(in vec2 uv, in float x) {\n \treturn pow(abs(uv.x) * 20.0, 0.4) + x;\n}\n\n#define POPCORN_ITERS 5\n#define POPCORN_LAMBDA 0.1\nvec2 pcPopcorn(in vec2 uv, in float x) {\n    vec4 t = hash41(longSeed()) + vec4(x);\n    for (int i = 0; i < POPCORN_ITERS; i++) {\n        uv.x += POPCORN_LAMBDA * cos(t.x + uv.y + cos(t.y + PI * uv.x));\n        uv.y += POPCORN_LAMBDA * cos(t.z + uv.x + cos(t.z + PI * uv.y));\n    }\n    return uv;\n}\n\n#define STACK_SIZE 8\nfloat runStack(vec2 uv) {\n    /* \n     * One of two parameters may be transformed with every iteration:\n     * - x: a color index.\n     * - uv: a position which x usually depends on.\n     */\n    float x = iTime + 5.0;\n    float seed = longSeed();\n    for (int i = 0; i < STACK_SIZE; i++) {\n        seed = hash11(seed) * 23.0;\n        if (seed < 1.0) {\n            uv = pcFisheye(uv);\n        } else if (seed < 2.0) {\n            uv = pcXMod(uv, x);\n        } else if (seed < 3.0) {\n            uv = pcYMod(uv, x);\n        } else if (seed < 4.0) {\n            x = icSinJulia(uv, x);\n        } else if (seed < 5.0) {\n            x = icRadial(uv, x);\n        } else if (seed < 6.0) {\n            uv = pcRotate(uv, x);\n        } else if (seed < 7.0) {\n            uv = polarFromCart(uv);\n        } else if (seed < 8.0) {\n            uv = cartFromPolar(uv);\n        } else if (seed < 9.0) {\n            x = icInverse(uv, x);\n        } else if (seed < 10.0) {\n            x = icDiagonal(uv, x);\n        } else if (seed < 11.0) {\n            uv = pcSin(uv, x);\n        } else if (seed < 12.0) {\n            uv = pcCos(uv, x);\n        } else if (seed < 13.0) {\n            x = icSinCos(uv, x);\n        } else if (seed < 14.0) {\n            uv = pcCos(uv, x);\n        } else if (seed < 15.0) {\n            uv = pcSwap(uv, x);\n        } else if (seed < 16.0) {\n            x = icX(uv, x);\n        } else if (seed < 17.0) {\n            x = icY(uv, x);\n        } else if (seed < 18.0) {\n            uv = pcScale(uv, x);\n        } else if (seed < 19.0) {\n            x = icCosJulia(uv, x);\n        } else if (seed < 20.0) {\n            uv = pcPixelate(uv, x);\n        } else if (seed < 21.0) {\n            x = icSinCos(uv, x);\n        } else if (seed < 22.0) {\n            x = icBeam(uv, x);\n        } else {\n            uv = pcPopcorn(uv, x);\n        }\n    }\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * vec2(2.0);\n    vec3 p = palette(longSeed(), runStack(uv));\n\tfragColor = vec4(p, 1.0);\n}","name":"Image","description":"","type":"image"}]}