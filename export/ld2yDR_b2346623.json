{"ver":"0.1","info":{"id":"ld2yDR","date":"1491700412","viewed":96,"name":"LH","username":"gilesruscoe","description":"LH","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["giles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Aspect ratio of screen\n    float aspect = iResolution.y / iResolution.x;\n    //Uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Centered\n    uv = uv * 2.f - 1.f;\n    //Aspect ratio fix\n    uv.y *= aspect;\n    \n    //Circle mask\n    float circle = smoothstep(length(uv), length(uv)+0.005f, 0.5f);\n    \n    //Colors\n    const vec3 red = vec3(0.89, 0.27, 0.18);\n    const vec3 green = vec3(0.5f, 0.72f, 0.2f);\n    const vec3 blue = vec3(0.26f, 0.64f, 0.85f);\n    const vec3 mint = vec3(0.22f, 0.82f, 0.4f);\n    const vec3 orange = vec3(0.96f, 0.7f, 0.18f);\n    vec3 white = mix(blue, vec3(1.f, 1.f, 1.f), length(vec2(5.0f, -5.0f) - uv * 2.f) * 0.135f);\n    const vec4 bgCol = vec4(0.13,0.2,0.282,1);\n    \n    //Because sin is a bastard\n    const float PI = 3.14159265f;\n\t\n    //Base height of waves\n    const float waveBaseline = -0.25f;\n    \n    //Phase of the sine wave, to allow tiling phase modulation\n    float heightPhase = sin(mod(iTime * 0.35f, 0.5*PI)) * PI;\n    //increased phase mod for wave speed\n    float phase = heightPhase * 16.f;\n    \n    //Height of the waves controlled by phase modulation\n\tfloat waveHeight = 0.2f * (1.f-(sin(2.0*PI + heightPhase) * 0.5f + 0.5f));\n\t\n    //The red wave\n    vec4 redWave;\n    float redWaveform = sin(2.0*PI*uv.x * 0.7f + phase - 1.1f);//sin(5.3f + iTime * 0.75f + uv.x * 4.f);\n    redWave.rgb = red;\n    redWave.a = smoothstep(uv.y + redWaveform * waveHeight, uv.y + redWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //The blue wave\n    vec4 blueWave;\n    float blueWaveform = sin(2.0*PI*uv.x * 1.15f + phase - 0.6f);\n    blueWave.rgb = blue;\n    blueWave.a = smoothstep(uv.y + blueWaveform * waveHeight, uv.y + blueWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //The green wave\n    vec4 greenWave;\n    float greenWaveform = sin(2.0*PI*uv.x * 2.0f + phase);\n    greenWave.rgb = green; \n    greenWave.a = smoothstep(uv.y + greenWaveform * waveHeight, uv.y + greenWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //Combine waves\n    vec4 waveComp = mix(bgCol, redWave, redWave.a);\n    waveComp = mix(waveComp, blueWave, blueWave.a);\n    waveComp = mix(waveComp, greenWave, greenWave.a);\n    \n    //Overlap between green and blue\n    float mintSection = smoothstep( 1.99f, 2.0f, greenWave.a + blueWave.a);\n    waveComp = mix(waveComp, vec4(mint, 1.0f), mintSection);\n    \n    //Overlap between red and green\n    float orangeSection = smoothstep(1.99f, 2.0f, greenWave.a + redWave.a - blueWave.a);\n    waveComp = mix(waveComp, vec4(orange.rgb, 1.0f), orangeSection);\n   \n    //Overlap between all\n    float whiteSection = smoothstep(2.2f, 3.0f, greenWave.a + redWave.a + blueWave.a);\n    waveComp = mix(waveComp, vec4(white, 1.0f), whiteSection);\n    \n    //Lighthouse\n    vec2 LHPos = vec2(0.086f, -0.1f);\n    LHPos.y = mix(-0.05f, -0.1f, sin(iTime) * 0.5 + 0.5);\n    float leftTopPlane = smoothstep((LHPos.x + uv.x) * -4.f + (LHPos.y + uv.y) * 5.f, 0.02f +(LHPos.x + uv.x) * -4.f + (LHPos.y + uv.y) * 5.f, 1.f);\n\tfloat rightTopPlane = smoothstep((LHPos.x + uv.x) * 4.f + (LHPos.y + uv.y) * 5.f, 0.02f + (LHPos.x + uv.x) * 4.f + (LHPos.y + uv.y) * 5.f, 1.7f);\n    float middleSplit = step(uv.x, 0.0f);\n    float leftSidePlane = smoothstep((LHPos.x + uv.x) * -30.f + (LHPos.y + uv.y) * 5.f, 0.15f + (LHPos.x + uv.x) * -30.f + (LHPos.y + uv.y) * 5.f, 0.4f);\n    float rightSidePlane = smoothstep((LHPos.x + uv.x) * 30.f + (LHPos.y + uv.y) * 5.f, 0.15f + (LHPos.x + uv.x) * 30.f + (LHPos.y + uv.y) * 5.f, 5.65f);\n    float LHMask = leftSidePlane * leftTopPlane * rightTopPlane * rightSidePlane;\n    LHMask *= clamp(uv.y * 2.5 + 0.5, 0.f, 1.f);\n    float grad1 = uv.y * 0.75 + 0.3;\n    float grad2 = 1.3 * (uv.y * 0.75 + 0.4);\n    float LH = mix(grad1, grad2, middleSplit) * LHMask;\n    //Final comp\n    vec4 comp = mix(vec4(1,1,1,1), waveComp, circle);\n\tfragColor = comp + LH;\n}","name":"Image","description":"","type":"image"}]}