{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by Daniel Burke - burito/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float pi = 3.141592;\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( vec2(c,s), vec2(-s,c) );\n}\n\n// Thanks to Inigo Quilez for his fantastic articles...\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat bits_white(in vec3 p)\n{\n    float x;\n    // door sign\n\tx = sdBox(p + vec3(0.0426, -0.0421, -0.0952), vec3(0.0236, 0.0380, 0.002));\n    \n\treturn x;\n}\n\nfloat bits_glow(in vec3 p)\n{\n    float x;\n    // windows\n\tx = sdBox(p + vec3(0.0, -0.1350, 0.0), vec3(0.0952, 0.0380, 0.0952));\n\n    // the lamp\n    x = min(x, sdCappedCylinder(p + vec3(0.0, -0.2263, 0.0), vec2(0.012, 0.0175)));\n\n    return x;\n}\n\n\nfloat map( in vec3 p)\n{\n    float x;\n    p.xz = abs(p.xz);\n\n    // core body\n    x = sdBox(p + vec3(0.0,0.04,0.0), vec3(0.0952, 0.1582, 0.0952));\n    // floor panel\n    x = min(x, sdBox(p + vec3(0.0, 0.2058, 0), vec3(0.1280, 0.0075, 0.1280)));\n    // corner bits\n    x = min(x, sdBox(p+vec3(-0.0952, 0., -0.0952), vec3(0.017, 0.1982, 0.017)));\n    // middle ridge\n        // front\n    x = min(x, sdBox(p, vec3(0.005, 0.1982, 0.009+0.0952)));\n        // side\n    x = min(x, sdBox(p, vec3(0.009+0.0952, 0.1982, 0.005)));\n    // middle frame part\n        // front\n    x = min(x, sdBox(p, vec3(0.019, 0.1982, 0.005+0.0952)));\n        // side\n    x = min(x, sdBox(p, vec3(0.005+0.0952, 0.1982, 0.019)));\n    // outer frame part\n    x = min(x, sdBox(p+vec3(-0.0832, 0., -0.0832), vec3(0.017, 0.1982, 0.017)));\n    // horizontal slats\n    { \n        vec3 l = vec3(0.,2.,0.);\n        float c = 0.0928;\n        vec3 q = p-c*clamp(round(p/c),-l,l);\n        x = min(x, sdBox(q + vec3(0.0, 0.0043, 0), vec3(0.1002, 0.0084, 0.1002)));\n    }\n\n    // window frames\n        // horizontal\n    x = min(x, sdBox(p + vec3(0.0, -0.1350, 0), vec3(0.0965, 0.001, 0.0965)));\n        // front\n    x = min(x, sdBox(p + vec3(-0.0504, -0.1350, 0), vec3(0.001, 0.0380, 0.0965)));\n    x = min(x, sdBox(p + vec3(-0.0348, -0.1350, 0), vec3(0.001, 0.0380, 0.0965)));\n        // side\n    x = min(x, sdBox(p + vec3(0.0, -0.1350, -0.0504), vec3(0.0965, 0.0380, 0.001)));\n    x = min(x, sdBox(p + vec3(0.0, -0.1350, -0.0348), vec3(0.0965, 0.0380, 0.001)));\n    \n\t// lid    \n    x = min(x, sdBox(p + vec3(0.0, -0.1982, 0), vec3(0.1122, 0.0112, 0.1122)));\n    x = min(x, sdBox(p + vec3(0.0, -0.2032, 0), vec3(0.1022, 0.0112, 0.1022)));\n    \n    // lamp case\n    x = min(x, sdBox(p + vec3(0.0, -0.2102, 0), vec3(0.019, 0.0112, 0.019)));\n    x = min(x, sdCappedCylinder(p + vec3(-0.012, -0.2264, -0.012), vec2(0.001, 0.0174)));\n    x = min(x, sdCappedCylinder(p + vec3(0.0, -0.2438, 0.0), vec2(0.018, 0.001)));\n    x = min(x, sdCappedCylinder(p + vec3(0.0, -0.2448, 0.0), vec2(0.010, 0.007)));\n\n    x = min(x, bits_white(p));\n    x = min(x, bits_glow(p));\n    \n    return x;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n \tvec2 e = vec2(0.001, 0.0);\n    vec4 a = vec4( map(p+e.xyy), map(p+e.yxy), map(p+e.yyx), map(p+e.yyy));\n\n    return normalize(vec3( a.x-a.w,\n                           a.y-a.w,\n                           a.z-a.w));\n}\n\nvec3 colour;\nint full_bright = 0;\n\nvoid chooseMat(vec3 p)\n{\n    // tardis blue\n\tcolour = vec3(0.06274, 0.13725, 0.44705);\n    \n    if(bits_white(p) < 0.0001)\n    {\n     \tcolour = vec3(0.9);   \n    }\n    else if(bits_glow(p) < 0.0001)\n    {\n     \tcolour = vec3(1.0,1.0, 0.7);   \n        full_bright = 1;\n    }\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 ro1 = vec3(0.2, 0.0, 0.5);\n    vec3 rd1 = normalize(vec3(p, -1.0));\n    \n\tfloat tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    \n\n//    float rpy = 0.0;\n//    float rpz = 0.0;\n\n    float rpy = 0.2 * pi * sin(iTime);\n    float rpz = 0.3 * pi * sin(iTime*1.3);\n    float rp = iTime;\n    \n    vec3 ro = ro1, rd = rd1;\n\n    mat2 matx = rot(rpy);\n    mat2 maty = rot(rp);\n    mat2 matz = rot(rpz);\n\n    ro.yz *= matx;\n    rd.yz *= matx;\n\n    ro.xz *= maty;\n    rd.xz *= maty;\n\n    ro.xy *= matz;\n    rd.xy *= matz;\n\n    ro += rpy;\n   \n    for( int i=0; i<100; i++)\n    {\n        if( h < 0.0001 || t>tmax)break;\n        h = map(ro + t*rd);\n        t += h;\n    }\n    \n    vec3 lig = vec3(0.5773);\n    vec3 tard = vec3(0.06274, 0.13725, 0.44705);\n\n    lig.yz *= matx;\n    lig.xz *= maty;\n    lig.xy *= matz;\n  \n//    vec2 w = vec2(0);\n    vec2 w = vec2(sin(iTime), cos(iTime*0.5));\n    \n    chooseMat(ro + t*rd);\n    if( t < tmax)\n    {\n        if(full_bright > 0)\n        {\n            col = colour;\n        }\n        else\n        {\n            vec3 nor = calcNormal(ro+t*rd);\n            float aod = 0.007;\n            \n            float aoc = map((ro+t*rd)+nor*aod)/aod;\n            \n            aoc = aoc * 0.5 + 0.5;\n            \n            float dl = clamp(dot(lig, nor), 0.3, 1.0);\n            \n            col = colour * aoc *dl;\n            //col = colour * calcAO(ro+t*rd);\n        }\n    }\n    else\n    { // do the tunnel in the background\n        float r = length(p) * 0.6;\n        float a = atan(p.x, p.y) * 1. / (2. * pi);\n        vec3 tex1 = vec3(texture( iChannel0, vec2( r+iTime*1.1, a+w.x*0.1)).r);\n        vec3 tex2 = vec3(texture( iChannel0, vec2( r+iTime, a+w.y*0.2)).r);\n        vec3 tex3 = vec3(texture( iChannel0, vec2( r+iTime*0.9, a+w.x*0.3)).r);\n\n        tex1 *= vec3(0.3,0.2,0.8);\n        tex2 *= vec3(0.0,0.0,1.0);\n        tex3 *= vec3(0.1,0.1,1.0);\n        col = vec3((tex1 + tex2 + tex3) * (log(r)+1.5) * 0.3 );           \n    }\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define PI2 6.28318530718\n#define RES 0.02\n#define trunc(a) float(int(a))\n\nfloat n2f(float note)\n{\n   return 55.0*pow(2.0,(note-3.0)/12.); \n}\n\nvec2 bass(float time, float tt, float note)\n{\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\nvec2 duhduh(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   tt = mod(tt,8.0);\n   if (tt <4.0)\n     tt = mod(tt,2.0);\n   else\n     tt = mod(tt,4.0);\n   return bass(time,tt-3.0,bn+3.)+\n          bass(time,tt-2.0,bn+3.)+\n          bass(time,tt-1.0,bn+0.)+\n          bass(time,tt-0.0,bn+0.);\n}\n\nvec2 duhduh2(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   int ti = int(mod(tt,8.0)/2.0);\n   tt = mod(tt,2.0);\n   if (ti == 0)\n     return bass(time,tt-0.83,bn+12.0)+\n            bass(time,tt-0.50,bn+12.0)+\n            bass(time,tt-0.17,bn+12.0);\n    \n   if (ti == 3)\n     return bass(time,tt-0.66,bn+15.)+\n            bass(time,tt-0.0,bn+15.);\n    \n   return bass(time,tt-0.66,bn+12.)+\n          bass(time,tt-0.0,bn+12.);\n}\n\nfloat note(float nr)\n{\n    if (nr<=15.)  return -120.;\n    if (nr<=16.)  return 31.;\n    if (nr<=17.)  return 56.;\n    \n    if (nr<=22.)  return 55.;\n    if (nr<=23.)  return -120.;\n    \n    if (nr<=24.)  return 58.;\n    if (nr<=25.)  return 42.;\n    if (nr<=30.)  return 43.;\n    \n    if (nr<=33.)  return -120.;\n    \n    if (nr<=34.5)  return 43.;\n    if (nr<=35.5)  return 39.;\n    if (nr<=37.0)  return 31.;\n    if (nr<=39.0)  return 34.;\n    if (nr<=39.5)  return 32.;\n    if (nr<=40.5)  return 31.;\n    if (nr<=41.0)  return -120.;\n    if (nr<=42.5)  return 31.;\n    if (nr<=43.0)  return 44.;\n    if (nr<=46.0)  return 43.;\n    \n    return -120.0;\n}\n\nfloat getSample(float time, float tt, float FM)\n{\n    tt -= mod(tt,RES);\n\n    float note1 = note(tt);\n    float note2 = note(tt+0.5);\n    if (note1 <0.0)\n        return 0.0;\n    \n    float stepper = smoothstep(0.1,0.5,mod(tt,0.5));\n    \n    float note = mix(note1,note2,stepper);\n    \n    float angle = PI2*n2f(note)*time;\n    return sin(angle+FM*sin(angle*2.033));\n}\n\nvec2 theramin(float time, float tt)\n{\n    tt = mod(tt,48.0);\n    tt += 1.33;\n    float FM = 0.0;\n    if (tt>=32.)\n        FM = PI2/2.;\n        \n    float sample0;\n    float ta = mod(tt-RES/2.0,RES)-RES/2.0;\n    float halfSin = RES/4.0;//4.0/frequency;\n    if (abs(ta)<halfSin)\n    {\n        float sample1 = getSample(time,tt-RES/2.0,FM);\n        float sample2 = getSample(time,tt+RES/2.0,FM);\n        sample0 = mix(sample1,sample2,smoothstep(-halfSin,halfSin,ta));\n    }\n    else\n        sample0 = getSample(time,tt,FM);\n    \n    return vec2( sample0);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float tt = time *2.4;\n    \n    float d1 = clamp(duhduh(time,tt).x,-0.8,0.8)*1.3+\n               clamp(duhduh(time,tt-0.33).x,-0.5,0.5)*1.4+\n               clamp(duhduh(time,tt-0.66).x,-0.3,0.3)*2.0;\n    \n    float d2 = clamp(duhduh2(time,tt).x,-0.8,0.8)*.3+\n               clamp(duhduh2(time,tt-0.33).x,-0.8,0.8)*.2+\n               clamp(duhduh2(time,tt-0.66).x,-0.8,0.8)*.1;\n    \n    return 0.2*vec2(d1+0.5*d2,d2+0.5*d1)\n          +0.3*(\n            theramin(time,tt-0.75)*vec2(0.2,0.4)\n           +theramin(time,tt)*vec2(0.6,0.4)\n           +theramin(time,tt-0.506)*vec2(0.4,0.2)\n           +theramin(time,tt-1.00)*vec2(0.1,0.2));\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSXRm","date":"1410184982","viewed":984,"name":"Want a Jellybaby?","username":"burito","description":"The TARDIS translation matrix is on the fritz again, so you might have trouble reading things. Nothing to worry about.\n\nSound by Andre - https://www.shadertoy.com/view/MdfXWX","likes":15,"published":1,"flags":8,"usePreview":0,"tags":["tardis"],"hasliked":0,"parentid":"","parentname":""}}