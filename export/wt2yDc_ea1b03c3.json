{"ver":"0.1","info":{"id":"wt2yDc","date":"1601902422","viewed":248,"name":"Rhombic dodecahedron SDF","username":"Atchafalaya","description":"Exploring how to get an exact signed distance function for a rhombic dodecahedron.\n\nThis SDF seems correct but is still not exact (especially far away from the dodecahedron). I'll be working on a better version in the next days.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Left-handed world space. Vertical Y axis.\nconst vec3 CAMERA_POS = vec3(0., 0., -4.);\nconst float FOCAL_LENGTH = 2.0;\nconst float FAR_CLIP = 1000.;\nconst float EPSILON = 0.01;\nconst float PI = 3.1415926535;\nconst float sqrt2 = 1.4142135623;\nconst float sqrt3 = 1.7320508075;\n\nconst uint OBJECT_TYPE_PLANE = 0u;\nconst uint OBJECT_TYPE_AABB = 1u;\nconst uint OBJECT_TYPE_SPHERE = 2u;\nconst uint OBJECT_TYPE_R_DODECA = 3u;\n\nstruct Material\n{\n    vec3 diffuse;\n    float roughness;\n    float reflectivity;\n};\n    \nstruct Object\n{\n    uint type;\n    vec3 pos;\n    vec3 scale;\n    Material material;\n};\n\nconst Object Objects[] = Object[] (\n    Object(OBJECT_TYPE_PLANE     , vec3(0 ,-5,0), vec3(1),   Material(vec3(0.2,0.12,0.1), 0.08, 0.)),\n    Object(OBJECT_TYPE_R_DODECA  , vec3(0.), \t  vec3(0.7), Material(vec3(.7,0.6,0.4)   , 0.9, 0.7))\n);\n\nmat3 RotCam(vec2 angle)\n{\n    vec2 cc = cos(angle);\n    vec2 ss = sin(angle);\n    return mat3(vec3(cc.x      , 0.  , ss.x      ),\n\t\t\t\tvec3(ss.x*ss.y , cc.y, -ss.y*cc.x),\n                vec3(-cc.y*ss.x, ss.y, cc.x*cc.y ));\n}\n\n\nvec3 RayAt(vec2 fragCoord) {\n    float x = 2. * fragCoord.x - 1.0;\n    float y = 2. * fragCoord.y - 1.0;\n\tx *= iResolution.x / iResolution.y;\n    float z = FOCAL_LENGTH;\n    vec3 ray = vec3(x, y, z);\n    return ray / length(ray);\n}\n\nfloat SdfPlane(Object obj, vec3 pos){\n    return pos.y - obj.pos.y;\n}\n\nfloat SdfAABB(Object obj, vec3 pos){\n    vec3 q = abs(pos - obj.pos) - obj.scale;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SdfSphere(Object obj, vec3 pos){\n    return length(pos - obj.pos) - obj.scale.x;\n}\n\nfloat SdfRDodeca(Object obj, vec3 pos){\n    pos = pos - obj.pos;\n\n    vec3 normals[6];\n    float dists[6];\n    float signs[6];\n\n    // The rhombic dodecahedron has 6 pairs of opposite faces.\n    // Assign a normal to each pair of faces.\n    normals[0] = vec3(1.  ,   0.           , 0.          );\n    normals[1] = vec3(0.5 ,   0.           , sqrt3 / 2.  );\n    normals[2] = vec3(0.5 ,   0.           , - sqrt3 / 2.);\n    normals[3] = vec3(0.  , - sqrt2 / sqrt3, 1. / sqrt3  );\n    normals[4] = vec3(0.5 ,   sqrt2 / sqrt3, sqrt3 / 6.  );\n    normals[5] = vec3(0.5 , - sqrt2 / sqrt3, - sqrt3 / 6.);\n\n    // Compute the distance to each face (the sign tells which face of the pair of faces is closest)\n    for (int i = 0; i < 6; i++){\n        dists[i] = dot(normals[i], pos);\n        signs[i] = sign(dists[i]);\n        dists[i] = max(0., abs(dists[i]) - obj.scale.x);\n    }\n\n    bool sorted = false;\n    while(!sorted){\n        sorted = true;\n        for (int i = 0; i < 5; i++){\n            if (dists[i] < dists[i+1]){\n                vec3 n = normals[i];\n                float d = dists[i];\n                float s = signs[i];\n                normals[i] = normals[i+1];\n                dists[i] = dists[i+1];\n                signs[i] = signs[i+1];\n                normals[i+1] = n;\n                dists[i+1] = d;\n                signs[i+1] = s;\n                sorted = false;\n            }\n        }\n    }\n    \n    if (dists[1] < dists[0] * 0.5){\n        // case where the closest point is on a face\n        return dists[0];\n    }\n    else if (max(dists[2], dists[2] + dists[3]) < 0.35 * (dists[0] + dists[1])){\n        // case where the closest point is on an edge\n\t\t// the faces play symmetrical roles. This implies a symmetrical matrix\n\t\tfloat f = 4. / 3.;\n\t\tfloat g = -2. / 3.;\n        vec2 v = vec2(f);\n        mat2 m = mat2(v, v) + mat2(g - f);\n        vec2 w = m * vec2(dists[1], dists[0]);\n        return length( w.x * signs[0] * normals[0]\n                     + w.y * signs[1] * normals[1]);\n    }\n    else if (dists[2] > 0.35 * (dists[0]+dists[1]) && dists[3] == 0.){\n        // case where the closest point is on a vertex shared by three faces\n        float f = 0.35 * 2.38;\n\t\tfloat g = -0.49 * 2.38;\n        vec3 v = vec3(f);\n        mat3 m = mat3(v, v, v) + mat3(g - f);\n        vec3 w = m * vec3(dists[2], dists[1], dists[0]);\n        return length( w.x * signs[0] * normals[0]\n                     + w.y * signs[1] * normals[1]\n                     + w.z * signs[2] * normals[2]);\n    }\n    else {\n\t\t// case where the closest point is on a vertex shared by four faces\n        float f = 0.3756;\n\t\tfloat g = -0.628;\n        vec4 v = vec4(f);\n        mat4 m = mat4(v, v, v, v) + mat4(g - f);\n        vec4 w = m * vec4(dists[3], dists[2], dists[1], dists[0]);\n        return length( w.x * signs[0] * normals[0]\n                     + w.y * signs[1] * normals[1]\n                     + w.z * signs[2] * normals[2]\n                     + w.w * signs[3] * normals[3]);\n    }\n}\n\nfloat Sdf(Object obj, vec3 marchingPosition){\n    float dist = FAR_CLIP;\n    switch(obj.type)\n    {\n        case OBJECT_TYPE_PLANE:\n        \tdist = SdfPlane(obj, marchingPosition);\n        \tbreak;\n        case OBJECT_TYPE_AABB:\n        \tdist = SdfAABB(obj, marchingPosition); \n        \tbreak;\n        case OBJECT_TYPE_SPHERE:\n        \tdist = SdfSphere(obj, marchingPosition);\n        \tbreak;\n        case OBJECT_TYPE_R_DODECA:\n        \tdist = 0.5 * SdfRDodeca(obj, marchingPosition);\n        \tbreak;\n    };\n    return dist;\n}\n\nvec3 Normal(Object obj, vec3 position) {\n    vec3 normal = vec3(Sdf(obj, position + vec3(EPSILON, 0.0, 0.0)) - Sdf(obj, position - vec3(EPSILON, 0.0, 0.0)),\n                       Sdf(obj, position + vec3(0.0, EPSILON, 0.0)) - Sdf(obj, position - vec3(0.0, EPSILON, 0.0)),\n                       Sdf(obj, position + vec3(0.0, 0.0, EPSILON)) - Sdf(obj, position - vec3(0.0, 0.0, EPSILON)));\n    return normal / length(normal);\n}\n\nstruct SceneSamplePayLoad{\n    float distToScene;\n    Object closestObj;\n};\n\nSceneSamplePayLoad GetClosestObject(vec3 marchingPosition) {\n    SceneSamplePayLoad result;\n    result.distToScene = FAR_CLIP;\n    for (int i = 0; i < Objects.length(); i++) {\n        float distanceToObject = Sdf(Objects[i], marchingPosition);\n        if (distanceToObject < result.distToScene) {\n            result.distToScene = distanceToObject;\n            result.closestObj = Objects[i];\n        }\n    }\n    result.distToScene -= 0.3*abs(sin(0.5*iTime)) + 0.05;\n    return result;\n}\n\nstruct RayPayLoad {\n    bool hitScene;\n    Object obj;\n    vec3 hitPosition;\n    vec3 normal;\n    float minDistToScene;\n    float marchedDistance;\n};\n\nRayPayLoad RayMarch(vec3 marchingPosition, vec3 rayDirection, float marchedDistance){\n    RayPayLoad result;\n    result.minDistToScene = FAR_CLIP;\n    result.marchedDistance = marchedDistance;\n    for (int i = 0; i < 1024; i++) {\n        SceneSamplePayLoad scenePayLoad = GetClosestObject(marchingPosition);\n        marchingPosition = marchingPosition + rayDirection * scenePayLoad.distToScene;\n        result.marchedDistance = result.marchedDistance + scenePayLoad.distToScene;\n        result.minDistToScene = min(result.minDistToScene, scenePayLoad.distToScene);\n        if (abs(scenePayLoad.distToScene) < EPSILON){\n            // Found object\n            result.hitScene = true;\n            result.obj = scenePayLoad.closestObj;\n            result.hitPosition = marchingPosition;\n            result.normal = Normal(scenePayLoad.closestObj, marchingPosition);\n            break;\n        }\n        if (result.marchedDistance > FAR_CLIP){\n            // Went too far\n            result.hitScene = false;\n            break;\n        }\n    }\n    return result;\n}\n\nvec3 FresnelTermApprox(vec3 toEye, vec3 halfVec, vec3 minVal)\n{\n    return minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);\n}\n\nfloat MicrofacetDistribution(vec3 halfVec, vec3 normal, float roughness)\n{\n    float alpha = roughness * roughness;\n    float dotNH = dot(normal, halfVec);\n    float f = (dotNH * alpha - dotNH) * dotNH + 1.;\n    return alpha / (PI * f * f);\n}\n\nstruct LightSampleResult\n{\n    vec3 contrib;\n    vec3 diffuseContrib;\n    vec3 specularContrib;\n    bool isShadowed;\n};\n\nLightSampleResult SampleLight(vec3 fragPos, vec3 normal, vec3 toEye, vec3 toLight, vec3 lightColor, Material material, bool useShadows)\n{\n    float dnl = dot(normal, toLight);\n    LightSampleResult result;\n    result.contrib = vec3(0.);\n    result.isShadowed = false;\n    if (dnl <= 0.)\n    {\n        return result;\n    }\n    float toLightLength = length(toLight);\n    float ooToLightLength = 1./toLightLength;\n    dnl *= ooToLightLength;\n    vec3 toLightN = toLight*ooToLightLength;\n    float softShadows = 1.;\n    if (useShadows)\n    {\n        RayPayLoad rpl = RayMarch(fragPos + 0.1 * normal, toLightN, 0.);\n        if (rpl.hitScene)\n        {\n            result.isShadowed = true;\n            return result;\n        }\n        softShadows = 1. - smoothstep(0., 1., 10.*(0.1 - rpl.minDistToScene));\n    }\n    vec3 hvec = normalize(toLightN+toEye);\n    vec3 f0 = vec3(0.005);\n    vec3 fresnel = FresnelTermApprox(toEye, hvec, f0);\n    if (material.roughness < 1.)\n    {\n        float D = MicrofacetDistribution(hvec, normal, material.roughness);\n        result.specularContrib = fresnel * D;\n    }\n    else\n    {\n        result.specularContrib = vec3(0.);\n    }\n    result.diffuseContrib = (1./PI) * (1. - fresnel) * material.diffuse;\n\tresult.diffuseContrib *= lightColor;\n    result.contrib = (result.specularContrib+result.diffuseContrib)*(dnl*ooToLightLength*ooToLightLength);\n    result.contrib *= softShadows;\n    return result;\n}\n\nvec3 SampleScene(vec3 marchingPosition, vec3 rayDirection){\n    // Unique light source\n\tvec3 lightDirection = normalize(vec3(-1., 1., -1.));\n    vec3 color;\n    RayPayLoad rayResult = RayMarch(marchingPosition, rayDirection, 0.);\n    if (rayResult.hitScene){\n        // Shading\n        Material matOfClosestObj = rayResult.obj.material;\n        bool useShadows = true;\n        // main directional light\n        LightSampleResult lightSample = SampleLight(rayResult.hitPosition, rayResult.normal, -rayDirection, lightDirection, vec3(10.), matOfClosestObj, useShadows);\n        color = lightSample.contrib;\n        // bounce light\n        float bounce = clamp(dot(rayResult.normal, vec3(0.,-1., 0.)), 0., 1.);\n        color += bounce * vec3(0.2, 0.6, 0.9) * 0.2;\n        // ambiant\n        color += rayResult.obj.material.diffuse * 0.1;\n        // point light\n        vec3 lightPos = vec3(.5, 2. * pow(0.5 + 0.5 * sin(2. * iTime), 2.), 3.);\n        vec3 toEye = normalize(marchingPosition - rayResult.hitPosition);\n        vec3 reflectionDir = 2. * dot(toEye, rayResult.normal) * rayResult.normal - toEye;\n        RayPayLoad reflectRay = RayMarch(rayResult.hitPosition, reflectionDir, rayResult.marchedDistance);\n\t    vec3 reflColor = texture(iChannel0, reflectionDir).xyz;\n        if (reflectRay.hitScene){\n\t        vec3 reflColor = reflectRay.obj.material.diffuse;\n        }\n        float reflectCoef = matOfClosestObj.reflectivity;\n        if (rayResult.obj.type == OBJECT_TYPE_PLANE){\n            reflectCoef = smoothstep(reflectCoef, 0.95, rayResult.marchedDistance / 100.);\n        }  \n        return mix(color, reflColor, reflectCoef);\n    }\n    return texture(iChannel0, rayDirection).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 angle = vec2(2.*iMouse.xy/iResolution.xy - 1.)*vec2(-3,1);\n    angle += vec2(0.7 * iTime, 0.5);\n    mat3 rotCam = RotCam(angle);\n    vec3 marchingPosition = rotCam*CAMERA_POS;\n    vec3 rayDirection = rotCam*RayAt(uv);\n    vec3 col = SampleScene(marchingPosition, rayDirection);\n    // post-processing\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}