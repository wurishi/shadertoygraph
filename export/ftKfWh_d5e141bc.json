{"ver":"0.1","info":{"id":"ftKfWh","date":"1716556715","viewed":66,"name":"Smoke by Erik","username":"eriben0628","description":"asdf","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["adf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxIterations1 20\n#define maxIterations2 1\n#define stepSize 0.2\n\nfloat random(vec3 pos) {\n    float a = fract(pos.y*8.234 + 0.333);\n    a += fract(pos.x*1203.234);\n    a += fract(pos.z*7.2345+0.952);\n    \n    return fract(a*123.87);\n}\n\nfloat noise(vec3 pos) {\n    vec3 p000 = floor(pos);\n    vec3 p100 = p000 + vec3(1.0,0.0,0.0);\n    vec3 p110 = p000 + vec3(1.0,1.0,0.0);\n    vec3 p010 = p000 + vec3(0.0,1.0,0.0);\n    \n    vec3 p001 = p000 + vec3(0.0,0.0,1.0);\n    vec3 p101 = p000 + vec3(1.0,0.0,1.0);\n    vec3 p111 = p000 + vec3(1.0,1.0,1.0);\n    vec3 p011 = p000 + vec3(0.0,1.0,1.0);\n    \n    float r000 = random(p000);\n    float r010 = random(p010);\n    float r100 = random(p100);\n    float r110 = random(p110);\n    \n    float r001 = random(p001);\n    float r011 = random(p011);\n    float r101 = random(p101);\n    float r111 = random(p111);\n    \n    float digitsX = fract(pos.x);\n    float digitsY = fract(pos.y);\n    float digitsZ = fract(pos.z);\n    \n    float s00 = r000 + (r001-r000)*digitsZ;\n    float s01 = r010 + (r011-r010)*digitsZ;\n    float s10 = r100 + (r101-r100)*digitsZ;\n    float s11 = r110 + (r111-r110)*digitsZ;\n    \n    float s0 = s00 + (s01-s00)*digitsY;\n    float s1 = s10 + (s11-s10)*digitsY;\n    \n    float s = s0 + (s1-s0)*digitsX;\n    \n\n    return s;\n}\n\nfloat densityAtPoint(vec3 pos) {\n    float a = 0.0;\n    float frequenzy = 1.0;\n    float amplitude = 1.0;\n    \n    for(int i = 0; i < 4; i++) {\n        pos += vec3(13.74);\n        a += noise(pos*10.0*frequenzy + vec3(a*12.3184093, iTime, 0.0) )*amplitude;\n        amplitude *= 0.5;\n        frequenzy *= 2.0;\n    }\n    \n    return pow(a,1.0);\n}\n\nvec4 image(vec3 Dir, vec3 Pos) {\n    vec4 color = vec4(0.0);\n    vec3 lightPos = vec3(cos(iTime),0.0,3.0+sin(iTime));\n    vec4 lightColor = vec4(0.5,0.7,1.0,1.0)*3.0;\n    float distanceFromCamera = 0.2;\n    vec3 pos = Pos + Dir*distanceFromCamera;\n    \n    float transmittence = 1.0;\n    \n    for(int i = 0; i < maxIterations1; i++) {\n        distanceFromCamera += stepSize;\n        pos += stepSize * Dir;\n        vec3 lightDir = normalize(lightPos-pos);\n        transmittence *= exp(-stepSize * densityAtPoint(pos) );\n        \n        float stepSize2 = length(pos-lightPos)/float(maxIterations2);\n        vec3 p = pos;\n        \n        float transmittence2 = 1.0;\n        \n        for(int j = 0; j < maxIterations2; j++) {\n            float density = densityAtPoint(p);\n            transmittence2 *= exp(-stepSize2 * density);\n            p += stepSize2 * lightDir;\n        }\n        \n        vec4 tempColor = lightColor * transmittence * transmittence2;\n        tempColor /= dot(pos-lightPos, pos-lightPos);\n        tempColor *= stepSize;\n        color += tempColor;\n    }\n\n    return color/(color+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 Dir = normalize(vec3(uv, 1.0));\n\n    vec3 CameraPos = vec3(0.0);\n    fragColor = image(Dir, CameraPos);\n}","name":"Image","description":"","type":"image"}]}