{"ver":"0.1","info":{"id":"3dKSRG","date":"1574417789","viewed":214,"name":"marching test","username":"neur0sys","description":"sphere tracing test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheretracingtest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.01;\n\nstruct Sphere \t\t{ int id; vec3 p; float r; };\nstruct Plane  \t\t{ int id; vec3 p; vec4 n; };\nstruct Box    \t\t{ int id; vec3 p; vec3 b; };\nstruct Torus  \t\t{ int id; vec3 p; vec2 t; };\n        \nSphere \t\tsphere   = Sphere \t\t(0, vec3(3.0, -1.0, -5.0),  1.0);\nPlane  \t\tplane    = Plane  \t\t(1, vec3(0.0, -3.0, 0.0),   normalize(vec4(0.0, -1.0, 0.0, 0.0)));\nBox    \t\tbox      = Box    \t\t(2, vec3(-3.0, -1.0, -5.0), vec3(1.0));\nTorus  \t\ttorus    = Torus  \t\t(3, vec3(0.0, 2.0, -5.0),   vec2(1.5, 0.5));\n\nSphere lightObj = Sphere (4, vec3(0.0, 0.0, -10.0),   0.25);\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  float t = iTime;\n  p.xz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  p.yz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  p.xy *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float t0 = iTime;\n  p.xz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.yz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.xy *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat getDiffuse(vec3 lightDir, vec3 n)\n{\n\treturn max(dot(n, lightDir), 0.0);\n}\n\nfloat getSpecular(vec3 lightDir, vec3 n, vec3 p, vec3 o)\n{\n\tvec3 viewDir = normalize(p - o);\n    vec3 r = reflect(lightDir, n);\n    return pow(max(dot(viewDir, r), 0.0), 16.0);\n}\n\nfloat getLight(vec3 n, vec3 p, vec3 o, vec3 lp)\n{\n    float ambient = 0.1;\n    vec3 lightDir = normalize(lp - p);\n    float diffuse = getDiffuse(lightDir, n);\n    float spec = getSpecular(lightDir, n, p, o);\n    return ambient + diffuse + spec;\n}\n\nint getObject(vec3 p)\n{\n    if (sdSphere(sphere.p - p, sphere.r) <= epsilon) {\n        return sphere.id;\n    }\n\n    if (sdPlane(plane.p - p, plane.n) <= epsilon) {\n        return plane.id;\n    }\n    \n    if (sdBox(box.p - p, box.b) <= epsilon) {\n        return box.id;\n    }\n    \n    if (sdTorus(torus.p - p, torus.t) <= epsilon) {\n        return torus.id;\n    }\n    \n    if (sdSphere(lightObj.p - p, lightObj.r) <= epsilon) {\n        return lightObj.id;\n    }\n    return -1;\n}\n\nfloat map(vec3 p)\n{\n\tfloat t = 1e3;\n    \n    t = min(sdSphere(sphere.p - p, sphere.r), t);\n    t = min(sdPlane(plane.p - p, plane.n), t);\n    t = min(sdBox(box.p - p, box.b), t);\n    t = min(sdTorus(torus.p - p, torus.t), t);\n    t = min(sdSphere(lightObj.p - p, lightObj.r), t);\n    \n    return t;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n    \tvec3 d = o + r * t;\n        float k = map(d);\n        t += k;\n        if (k < epsilon) {\n            break;\n        }\n    }\n    return t;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n\tconst vec3 e = vec3(epsilon, 0, 0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, -1.0));\n    vec3 o = vec3(0.0, 0.0, 0.0);\n\n    vec3 lightColor = vec3(1.0);\n    \n    lightObj.p.z += cos(iTime) * 8.0;\n    lightObj.p.x += sin(iTime) * 8.0;\n    lightObj.p.y += sin(iTime * 2.0) * 2.0;\n    \n    sphere.p.xz += vec2(1.0) * mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    \n\n    float d = trace(o, r);\n    vec3 p = o + r * d;\n    \n    if (getObject(p) == lightObj.id) {\n    \tfragColor = vec4(lightColor, 1.0);\n        return;\n    }\n    \n    vec3 n = getNormal(p);\n    float i = getLight(n, p, o, lightObj.p);\n    vec3 col = lightColor * i;\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}