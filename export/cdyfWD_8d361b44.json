{"ver":"0.1","info":{"id":"cdyfWD","date":"1698215574","viewed":78,"name":"Pixel Confetti","username":"Chroma_Crash","description":"Early iteration of a confetti shader I'm working on. Unfinished right now but I need to go to bed lol.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","pixel","confetti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TRIANGLE_SIZE 25.0\n\n#define SQUIGGLE_WIDTH 3.0\n#define SQUIGGLE_LENGTH 40.0\n#define SQUIGGLE_DEPTH 4.0\n#define SQUIGGLE_SIZE 6.0\n\n#define NUM_TRIANGLES 60\n#define NUM_SQUIGGLES 30\n\n#define ROTATE_SPEED 3.0\n\n#define PI 3.14159\n\n#define PIXEL_SIZE 4.0\n\n#define DELAY 0.4\n#define SPRAY_TIME 3.2\n\n#define ACCELERATION -4.0\n#define VELOCITY 8.0\n\n#define START_X 0.2\n#define START_Y 0.6\n\n#define TIME_SCALING 4.0\n\n#define CONFETTI_SPREAD 20\n#define CONFETTI_ANGLE 40\n\n#define SIM_TIME 8.0\n\n#define VEL_SPREAD 0.3\n\n\n#define PALETTE_LENGTH 7\n\nvec4 palette[PALETTE_LENGTH] = vec4[](\nvec4(1, 0, 0, 1),\nvec4(0, 1, 0, 1),\nvec4(0, 1, 1, 1),\nvec4(1, 0, 1, 1),\nvec4(0, 0, 1, 1),\nvec4(1, 1, 0, 1),\nvec4(1, 1, 1, 1)\n);\n\nfloat det(vec2 p1, vec2 p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 getPos(float time, int i) {\n    time = time / TIME_SCALING;\n\n    bool left = (i % 2) == 0;\n    \n    vec2 pos;\n    \n    vec2 initialVelocity = vec2(VELOCITY, VELOCITY);\n    \n    int spreadNum = int(rand(vec2(i * 50, i * 10)) * float(CONFETTI_SPREAD * 2)) - CONFETTI_SPREAD;\n    \n    float radian = float(CONFETTI_ANGLE + spreadNum) * PI / 180.0;\n    \n    vec2 angle = vec2(cos(radian), sin(radian));\n    initialVelocity *= angle;\n    \n    float off = rand(vec2(i * 40, i * 30)) * VEL_SPREAD;\n    float t = time + off;\n    float d = exp(-t * 3.0);\n    \n    if (left) {\n        pos = vec2(0.0 - START_X, START_Y);\n        float a = ACCELERATION * time * time;\n        vec2 change = initialVelocity * d * time + vec2(0, a);\n        pos += change;\n    }\n    else {\n        pos = vec2(1.0 + START_X, START_Y);\n        float a = ACCELERATION * time * time;\n        vec2 change = initialVelocity * d * time * vec2(-1, 1) + vec2(0, a);\n        pos += change;\n    }\n    return pos * iResolution.xy;\n}\n\nbool triangleIntersection(vec2 frag, vec2 center, int i, float time) {\n    float t = mod(float(i) + time * ROTATE_SPEED, 2.0 * PI);\n    float rotate = float(i) + time;\n    center.x += cos(float(i) + time) * 40.0;\n    \n    vec2 offset = vec2(TRIANGLE_SIZE, TRIANGLE_SIZE) * vec2(cos(rotate), sin(rotate));\n    vec2 left = center - offset;\n    vec2 right = center + offset;\n    \n    vec2 mid = center + vec2(offset.x, -offset.y) * cos(t) * 2.0;\n    \n    mid = mid - left;\n    right = right - left;\n    \n    float a = (det(frag, mid) - det(left, mid)) / det(right, mid);\n    float b = (det(frag, right) - det(left, right)) / det(right, mid);\n    \n    return a > 0.0 && b > 0.0 && a + b < 1.0;\n}\n\nbool squiggleIntersection(vec2 frag, vec2 center, int i, float time) {\n    vec2 slope = center - getPos(time - 0.01, i);\n    float angle = atan(slope.x, slope.y);\n\n    center.x += cos(float(i) + iTime) * 40.0;\n    frag -= center;\n\n    float original = atan(frag.y, frag.x);\n    vec2 rot = vec2(cos(original + angle), sin(original + angle)) * length(frag);\n    \n    if (-SQUIGGLE_LENGTH < rot.y && rot.y < SQUIGGLE_LENGTH) {\n        float wave = cos(time / 60.0 + (frag.y + center.y) / SQUIGGLE_SIZE) * SQUIGGLE_DEPTH;\n        float r = rot.x - wave;\n        if (-SQUIGGLE_WIDTH < r && r < SQUIGGLE_WIDTH) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    \n    vec4 col = vec4(0, 0, 0, 1);\n    \n    float t = mod(iTime, SIM_TIME);\n    \n    if (t > DELAY) {\n        for (int i = 0; i < NUM_TRIANGLES; i++) {\n            float timeOffset = rand(vec2(i * 10, i * 10)) * SPRAY_TIME;\n            vec2 pos = getPos(t - DELAY - timeOffset, i);\n\n            if (triangleIntersection(uv, pos, i, t - DELAY - timeOffset)) {\n                col = palette[i % PALETTE_LENGTH];\n            }\n        }\n\n        for (int i = 0; i < NUM_SQUIGGLES; i++) {\n            float timeOffset = rand(vec2(i * 10, i * 10)) * SPRAY_TIME;\n            vec2 pos = getPos(t - DELAY - timeOffset, i + NUM_TRIANGLES);\n\n            if (squiggleIntersection(uv, pos, i + NUM_TRIANGLES, t - DELAY - timeOffset)) {\n                col = palette[i % PALETTE_LENGTH];\n            }\n        }\n    }\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}