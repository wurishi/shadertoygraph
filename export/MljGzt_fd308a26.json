{"ver":"0.1","info":{"id":"MljGzt","date":"1431541963","viewed":342,"name":"Torus World","username":"ostkaka","description":"Torus shaped \"planet\". :P","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["torusworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define ITERATIONS 128\n#define FAR 1000000.0\n\n#define PI 3.14159265358979323846264338\n\n \nfloat torus(in vec3 pos, in float r1, in float r2)\n{\n    return length(vec2(length(pos.xy)-r1,pos.z))-r2;\n}\n    \n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}  \n    \nfloat noise(in vec2 pos)\n{\n    vec2 fpos = floor(pos);\n    \n    float r = 0.0;\n    \n    float x1 = abs(1.0-fract(pos.x));\n    float y1 = abs(1.0-fract(pos.y));\n    float x2 = abs(fract(pos.x));\n    float y2 = abs(fract(pos.y));\n    \n    \n    r += rand(fpos+vec2(0.0,0.0))*x1*y1;\n    r += rand(fpos+vec2(0.0,1.0))*x1*y2;\n    r += rand(fpos+vec2(1.0,0.0))*x2*y1;\n    r += rand(fpos+vec2(1.0,1.0))*x2*y2;\n    \n    return 1.0-2.0*r;\n}\n\n\n \n \nfloat map(vec3 pos, float rayDistance)\n{\n    \n    // Cylinder transformation\n    float u = 5.0*PI*atan(pos.y,pos.x);\n    float v = length(pos.xyz);\n    //pos.x = u;//cos(u)*v;\n    vec3 tPos = pos;\n    \n    float rx = 12000.0;\n    float rz = 1200.0;\n    \n    tPos.y = torus(pos, rx, rz);//tan(v-1.0);//sin(u)*v;\n    tPos.x = rx*PI*atan(pos.y, pos.x);\n    tPos.z = rz*PI*atan(length(pos.xy)-rx, pos.z);\n    \n    pos = tPos;\n    \n    // plane\n    float distance = pos.y+3.0;\n    \n    \n    for (int i = 0; i < 3; ++i)\n    {\n        float p = pow(2.0, float(i));\n        float q =40.5/pow(p, 2.0)/max(1.0, 0.00001*rayDistance);\n        \n        if (0.5*distance > q)\n       \t\tbreak;\n        \n        vec3 pos3 = 1.0*p*tPos+vec3(16.0*rand(vec2(float(i))));\n        \n        distance += 1.0*q*noise(pos3.xz*p/2048.0);\n    }\n    \n    for (int i = 0; i < 6; ++i)\n    {\n        float p = pow(2.0, float(i));\n        float q =5.5/pow(p, 2.0)/max(1.0, 0.001*rayDistance);\n        \n        if (0.5*distance > q)\n       \t\tbreak;\n        \n        vec3 pos3 = 1.0*p*tPos+vec3(16.0*rand(vec2(float(i))));\n        \n        distance += 1.0*q*noise(pos3.xz*p/64.0);\n    }\n    \n\n    return distance;\n}\n\nvec3 calculateNormal(vec3 pos, float epsilon, float rayDistance)\n{\n\tvec3 epsilonVec = vec3( epsilon, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    map(pos+epsilonVec.xyy, rayDistance) - map(pos-epsilonVec.xyy, rayDistance),\n\t    map(pos+epsilonVec.yxy, rayDistance) - map(pos-epsilonVec.yxy, rayDistance),\n\t    map(pos+epsilonVec.yyx, rayDistance) - map(pos-epsilonVec.yyx, rayDistance) );\n\treturn normalize(normal);\n}\n\n\nvec4 castRay(vec3 pos, vec3 direction)\n{\n    \n\n    \n    vec3 rayPos = pos;\n    vec3 rayDirection = direction;\n    float rayDistance = 0.0;\n    float distance = 0.0;\n    \n    float epsilon = 0.00005;\n    \n    float distortionSum = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        j +=2.0*1.0/float(ITERATIONS);\n        k *= 0.99;\n        k += 1.0;\n        epsilon = 0.0005*rayDistance;\n        \n        distance = map(rayPos, rayDistance);\n        rayPos += distance*rayDirection;\n        rayDistance += distance;\n\n        if (distance < epsilon) break;\n        if (rayDistance  > FAR) break;\n        \n    }\n    \n    vec3 lightDir = vec3(0.0, 1.0, 1.0);\n    \n    vec3 normal = calculateNormal(rayPos, 10.0*epsilon, rayDistance);\n    \n    float lightDot = 0.5*dot(normal,lightDir);\n   \n    \n    \n    vec3 atmosphereColor = 0.4*j*vec3(0.0,0.3,1.0);\n    vec3 surfaceColor = 0.01*5.0*k*lightDot*vec3(0.6,0.4,0.1);\n    \n    if (distance <= 100.0)\n    \treturn vec4(atmosphereColor+surfaceColor, 1.0);\n    else\n        return vec4(atmosphereColor, 1.0);\n  \n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = 8.0 * (iMouse.xy / iResolution.xy -0.5);\n\tfloat time = 0.5*iTime;\n    \n    if (iMouse.y == 0.0 && iMouse.x == 0.0)\n    {\n    \tmouse.x = -0.25;\n        mouse.y = 0.25;\n    }\n    \n    // camera\t\n\tvec3 pos = vec3(0.0, -10010.0-800.0*clamp(1.0+cos(0.25*PI*time), 0.0, 1.0), 100.0);\n\tvec3 target = pos + vec3( cos(mouse.x ), tan(mouse.y-0.5), sin(mouse.x) );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( pos, target, 0.0 );\n    \n    // ray direction\n\tvec3 direction = ca * normalize( vec3(uv.xy,1.0) );\n    \n    \n\tfragColor = vec4(vec3(castRay(pos, direction).xyz), 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}