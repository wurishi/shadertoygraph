{"ver":"0.1","info":{"id":"4dcSWH","date":"1458965909","viewed":269,"name":"Cracker Car (the close up)","username":"zackpudil","description":"It's a sequel...https://www.shadertoy.com/view/4sdXzr. With mouse controls.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n)*43758.54523123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float n = i.x + i.y*57.0;\n    \n    return mix(\n        mix(hash(n), hash(n + 1.), f.x),\n        mix(hash(n + 57.), hash(n + 58.), f.x),\n        f.y);\n}\n\nfloat neLength(vec2 p, float l) {\n    return pow(\n       \tpow(abs(p.x), l) + pow(abs(p.y), l),\n        1.0/l);\n}\n\nfloat dCircleTorus(vec3 p, vec3 c, vec2 s) {\n    vec3 pc = p - c;\n    \n    vec2 d = vec2(length(pc.xy) - s.x, pc.z);\n    return neLength(d, 8.) - s.y;\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\nfloat dSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot2(ba), 0.0, 1.0);\n    \n    return length(pa - ba*h) - r;\n}\n\nfloat terrain(vec2 p) {\n    return 2.0*noise(0.5*p.xy);\n}\n\nstruct Car {\n    vec3 p;\n    vec3 wheels[4];\n};\n\nCar car;\n\nvoid initCar() {\n    vec3 carp = vec3(5.*iTime, 1, 0);\n    car.p = carp;\n    \n    for(int i = 0; i < 4; i++) {\n        vec3 w = carp - vec3(sign(float(i) - 1.5)*1.5, 0, sign(i == 0 ? 1. : float(i) - 2.5)*2.5);\n    \tw.y = 0.7 -  terrain(w.xz);\n        car.wheels[i] = w;\n    }\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p) {\n    float h = terrain(p.xz);\n    vec2 pl = vec2(p.y + h, 0.0);\n    \n    float wd = 20.0;\n    float rd = 20.0;\n    \n    vec3 ofh = vec3(.5, 0, 0);\n    vec3 ofv = vec3(0, .5, 0);\n    rotate(ofh.xy, -5.*iTime);\n    rotate(ofv.xy, -5.*iTime);\n    \n    for(int i = 0; i < 4; i++) {\n        wd = min(wd, dCircleTorus(p, car.wheels[i], vec2(.5, .1)));\n        \n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] + ofh, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] - ofh, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] + ofv, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] - ofv, 0.05));\n    }\n    \n    float cd = 20.0;\n    \n    vec3 c1 = mix(car.wheels[0], car.wheels[1], .5);\n    c1.y += .80;\n    vec3 c11 = mix(c1, car.wheels[0] + vec3(0, .80, 0), .75);\n    vec3 c12 = mix(c1, car.wheels[1] + vec3(0, .80, 0), .75);\n                   \n    vec3 c2 = mix(car.wheels[2], car.wheels[3], .5);\n    c2.y += .80;\n    vec3 c21 = mix(c2, car.wheels[2] + vec3(0, .80, 0), .75);\n    vec3 c22 = mix(c2, car.wheels[3] + vec3(0, .80, 0), .75);\n    \n\twd = min(wd, dSegment(p, car.wheels[0], c11, 0.1));\n    wd = min(wd, dSphere(p, c11, 0.2));\n    wd = min(wd, dSegment(p, c11, c1, 0.1));\n    wd = min(wd, dSegment(p, c1, c12, 0.1));\n    wd = min(wd, dSphere(p, c12, 0.2));\n    wd = min(wd, dSegment(p, c12, car.wheels[1], 0.1));\n    \n   \twd = min(wd, dSegment(p, car.wheels[2], c21, 0.1));\n    wd = min(wd, dSphere(p, c21, 0.2));\n    wd = min(wd, dSegment(p, c21, c2, 0.1));\n    wd = min(wd, dSegment(p, c2, c22, 0.1));\n    wd = min(wd, dSphere(p, c22, 0.2));\n    wd = min(wd, dSegment(p, c22, car.wheels[3], 0.1));\n    \n\tvec3 c = mix(c1, c2, .5);\n\tp.y -= .5;\n    p.y *= 1.5;\n    vec3 cp = p - c;\n\n\n    float bd = 20.0;\n    bd = min(bd, dSegment(p*vec3(1, 1.2, 1) - vec3(0, 0.2, 0), c1, c2, 1.3));\n                 \n\tvec2 w = vec2(wd, 1.0);\n    vec2 b = vec2(bd, 2.0);\n    \n    return opU(pl, opU(w, b));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float td = 0.0;\n    float mid = -1.0;\n    \n    for(int i = 0; i < 64; i++) {\n        vec2 s = map(ro + rd*td);\n        if(abs(s.x) < 0.001 || td >= 50.0) break;\n        \n        td += s.x*0.75;\n        mid = s.y;\n    }\n    \n    if(td >= 50.0) mid = -1.0;\n    return vec2(td, mid);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n\t);\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float td = 0.2;\n    float res = 1.0;\n    \n    for(int i = 0; i < 30; i++) {\n        float h = map(p + l*td).x;\n        td += h*.5;\n        res = min(res, 2.0*h/td);\n        if(abs(h) < .0001 || td > 10.) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd) {\n    vec3 n = normal(p);\n    vec3 l = normalize(lp);\n    vec3 r = reflect(rd, n);\n    \n    float amb = clamp(0.7 + 0.3*n.y, 0., 1.);\n    float dif = clamp(dot(l, n), 0., 1.);\n    float spe = pow(clamp(dot(r, l), 0., 1.0), 16.);\n    float fre = pow(clamp(1. + dot(n, rd), 0., 1.0), 2.);\n    float dom = smoothstep(-.1, .2, r.y);\n    \n    dif *= shadow(p, l);\n    \n    vec3 lin = vec3(0);\n    \n    lin += .5*amb;\n    lin += dif*vec3(1, .97, .85);\n    lin += 2.0*spe*vec3(1, .87, 1)*dif;\n    lin += 2.0*fre*vec3(1)*dif;\n    lin += 0.3*dom*vec3(1);\n    \n    return lin;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 rl = vec3(0, 1, 0);\n    vec3 f = normalize(l - e);\n    vec3 r = cross(rl, f);\n    vec3 u = cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    initCar();\n    \n    float s = 0.01*iMouse.x;\n    vec3 ro = car.p + 8.0*vec3(cos(s), 0.5, -sin(s));\n    vec3 rd = camera(ro, car.p)*normalize(vec3(uv, 2.0));\n    \n    vec3 col = vec3(.34, .54, .89);\n\tcol *= mix(0.6, 1.0, uv.y);\n    \n    vec2 i = intersect(ro, rd);\n    vec3 p = ro + rd*i.x;\n    \n    if(i.y == 0.0) col = vec3(.75, 0, .85)*.5;\n    if(i.y == 1.0) col = vec3(.7, .4, .5)*.1; \n    if(i.y == 2.0) col = vec3(.95, .34, 0)*.5;\n    \n    if(i.y != -1.0) col *= lighting(p, vec3(0, 2, -1), rd);\n    \n    col = pow(col, vec3(.454545));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}