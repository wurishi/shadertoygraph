{"ver":"0.1","info":{"id":"fsjyDV","date":"1644146188","viewed":165,"name":"Fib-spiral, patched (tech demo)","username":"stegu","description":"Zoom in and out with mouse drags.\n\nPatched errors in the Voronoi diagram (all Voronoi cells now seem correct for all fracN).\nTried unsuccessfully to reduce the number of neighbors for the search (fract(c) seems too imprecise to tell us much).\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animated","fibonacci","sunflower","growth","botany"],"hasliked":0,"parentid":"7d2czd","parentname":"Fibonacci spiral (tech demo)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N = iTime;\n    // Zoom out to fit most of the set in the viewport as it grows\n    float scale = 4.0*max(4.0, sqrt(N));\n    float uvscale = 1.0/max(iResolution.x, iResolution.y);\n    vec2 uvcenter = 0.5*iResolution.xy;\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.99,iMouse.y-abs(iMouse.w));\n    vec2 uv = zoom*scale*(uvscale*(fragCoord-uvcenter));\n\n    // This function and its documentation is in the \"Common\" tab\n    vec3 nn = inversePF(uv, floor(N), fract(N));\n\n    float d = length(uv-nn.xy);\n    // Draw small dots for index > intN, else large dots\n    float disksize = (nn.z > floor(N)) ? 0.2 : 0.7;\n    \n    vec3 diskcolor = vec3(aastep(0.5*disksize,d));\n    if(nn.z == floor(N)) diskcolor.b = 0.0; // Mark cell #0 in yellow\n    vec3 cellcolor = hashcolor(floor(N)-nn.z);\n    vec3 mixcolor = mix(cellcolor, diskcolor, 1.0-aastep(disksize,d));\n\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// A \"random\" vec3 generated from a float hash\nvec3 hashcolor(float i){\n\tfloat r = mod(i, 289.0);\n\tr = mod((r*34.0+10.0)*r, 289.0);\n\tfloat g = mod(i+r, 361.0);\n\tg = mod((g*38.0+8.0)*g, 361.0);\n\tfloat b = mod(i+g, 529.0);\n\tb = mod((b*46.0+18.0)*b, 529.0);\n\treturn vec3(r,g,b)/vec3(289.0, 361.0, 529.0);\n}\n\n\n// Symbolic constants and helper functions for inversePF\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n#define Phi 0.618033988749895\n\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction, for accuracy)\n\treturn k * Phi - floor(k * Phi);\n}\n\nvoid testPFpoint(inout vec2 p, inout vec3 nn, inout float dsqmin, float intN, float fracN, float k) {\n    float theta = 2.0*PI*fracmodphi(k-intN);\n    float r = sqrt(k+0.5+fracN);\n\tvec2 q = vec2(cos(theta)*r, sin(theta)*r);\n\tfloat dsq = dot(p-q, p-q); // Most numerically sound measure\n\tif (dsq < dsqmin) {\n\t\tdsqmin = dsq;\n\t\tnn.xy = q;\n\t\tnn.z = k;\n\t}\n}\n\n//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius sqrt(N) around the origin.\n//\n// This is a variation on the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Modified for planar mapping and smooth transitions\n// between N and N+1 cells. Added code to fix some flaws.\n// Copyright 2022 Stefan Gustavson, released under the\n// terms of the MIT license (\"use freely with credit\"):\n// https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the position of the nearest\n// neighbor in .xy, and its integer index (k) in .z.\n// A gradual blend between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N, the index needs to be\n// recomputed as (intN - k). The point set is not limited\n// to N points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n//\nvec3 inversePF(vec2 p, float intN, float fracN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fracN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values.\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,\n                  2.0*PI*B1, F1);\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    // Hack: +0.5 would be \"correct\" here, but -0.1 dodges a few errors\n    float ci = i - 0.1 + fracN;\n    vec2 c = invB * vec2(ctheta, ci);\n    // Tried looking at fract(c) to eliminate some nn tests. Didn't work.\n    float dsqmin = 1e10; // Effectively \"Inf\"\n    float i0 = dot(vec2(F0,F1), floor(c)); // Innermost of 2x2 neighbors\n    // The 4x abs() here fix some serious errors near the origin.\n    // We don't need them for larger i0, but abs() is a single bit flip, \n    // and it should come at no additional cost in execution time.\n    testPFpoint(p, nn, dsqmin, intN, fracN, abs(i0));\n    testPFpoint(p, nn, dsqmin, intN, fracN, abs(i0+F0));\n    testPFpoint(p, nn, dsqmin, intN, fracN, abs(i0+F1));\n    testPFpoint(p, nn, dsqmin, intN, fracN, abs(i0+F0+F1));\n    // The candidate tests above find the closest point in the set,\n    // but with a few glitches close to some Voronoi edge junctions\n    // for some values of fracN. This \"patch run\" repairs those.\n    // The extra work is only spent near the origin, so this is not\n    // an unreasonable amount of extra work to fix the errors.\n    // If speed is of utmost importance and precision isn't, the\n    // extra test of cell #0 is the one that matters the most.\n    // The others address considerably less serious flaws.\n    if(r2 < 6.0) { // These are near the origin\n        testPFpoint(p, nn, dsqmin, intN, fracN, 0.0); // Grave errors at large fracN\n        testPFpoint(p, nn, dsqmin, intN, fracN, 3.0); // Edge shaved at small fracN\n        testPFpoint(p, nn, dsqmin, intN, fracN, 4.0); // Corner cut at small fracN\n    }\n    else if(r2 < 8.0) { // && (r2 >= 6) from \"else\"\n        testPFpoint(p, nn, dsqmin, intN, fracN, 13.0); // Tiny cut at small fracN\n    }\n    if(r2 < 16.0) {\n        testPFpoint(p, nn, dsqmin, intN, fracN, 6.0); // Far *and* near corners cut\n    }\n    else if(r2 < 18.0) { // && (r2 >= 16) from \"else\"\n        testPFpoint(p, nn, dsqmin, intN, fracN, 7.0); // Far corner at large fracN\n        testPFpoint(p, nn, dsqmin, intN, fracN, 27.0); // Corner cut at small fracN\n    }\n    return nn;\n}\n","name":"Common","description":"","type":"common"}]}