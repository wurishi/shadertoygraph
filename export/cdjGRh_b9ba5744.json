{"ver":"0.1","info":{"id":"cdjGRh","date":"1667234295","viewed":170,"name":"DNA animation","username":"valdis","description":"DNA animation","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["dna"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 elementSize = vec2(0.45, 0.105);\nconst float elementStep = 0.125;\nconst float smoothv = 0.01;\n\n#define PI 3.14159265359\n\nfloat drawLine(vec2 uv, vec2 start, vec2 end, float width)\n{\n    vec2 lineNormal = normalize(end - start);     \n    mat2 rotate = mat2(lineNormal.x,- lineNormal.y,\n                lineNormal.y,lineNormal.x);\n    end = rotate * (end - start);\n    uv = rotate * (uv - start);\n    start = vec2(0.0); \n    \n    return (1.0 - step(width, abs(uv.y))) * step(start.x,uv.x) * (1.0 - step(end.x,uv.x));\n}\n\nfloat drawCircle(vec2 uv, vec2 center, float radius)\n{\n    vec2 r = uv - center;\n    float minr = radius*radius;\n    return (1.0 - smoothstep(minr, minr + (smoothv * radius), dot(r,r)));\n}\n\nvec2 circlePosition(vec2 chainCenter, float rotate)\n{\n    return chainCenter + vec2(cos(rotate) * elementSize.x * 0.5, 0.0);\n}\n\nfloat circleSize(float rotate)\n{\n    return ((0.2*(1.0 + sin(rotate))) + 0.3) * elementSize.y * 0.5;\n}\n\n\nfloat drawChainElement(vec2 uv, vec2 chainCenter, float rotate, float pixelSize)\n{\n    float z1 = circleSize(rotate);\n    vec2 c1 = circlePosition(chainCenter, rotate);\n    \n    float z2 = circleSize(rotate + PI);\n    vec2 c2 = circlePosition(chainCenter, rotate + PI);\n    \n    return drawCircle(uv, c1, z1)\n    + drawCircle(uv, c2, z2)\n    + drawLine(uv, c1, c2, pixelSize);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //one pixel\n    float pixelSize = 2.0/iResolution.y;\n    \n    float i = round(uv.y / elementSize.y);\n    float timeOffset = iTime + elementStep * PI * i;\n    vec2 pos = vec2(0.0, elementSize.y * i);\n\n    // Output to screen\n    fragColor = vec4(vec3(drawChainElement(uv, pos, timeOffset, pixelSize)),1.0);\n}","name":"Image","description":"","type":"image"}]}