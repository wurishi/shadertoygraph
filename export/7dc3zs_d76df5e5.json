{"ver":"0.1","info":{"id":"7dc3zs","date":"1630638006","viewed":102,"name":"Psalm 19:1","username":"ryguy","description":"A novel GLSL fragment shader implemented for my Computer Graphics class.","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference for glsl functions https://www.shaderific.com/glsl-functions/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    const vec2 ovalOrigin = vec2(0.5, 0.5);\n    vec2 deltaVector = uv - ovalOrigin;\n\n    // Init col to black, should be overwritten below\n    vec3 col = vec3(0.0);\n\n    // Generate a 2D shape\n    // help from the shader coding intro tut, https://www.youtube.com/watch?v=0ifChJ0nJfM\n    const float baseRadius = 0.06;\n    const float amplitude = 0.014;\n    const float frequency = 5.0;\n    const float rotation = -radians(90.0);\n    float radius = baseRadius + amplitude * cos(atan(deltaVector.y, deltaVector.x) * frequency + rotation);\n\n    if (length(deltaVector) < radius) {\n        // Inside 2D shape\n\n        // Generate a pattern on the 2D shape\n        const float detail = 80.0;\n        float r = length(deltaVector);\n        float pattern = exp(r * detail);\n        col = vec3(fract(pattern));\n\n        // Pixels farther away from the ovalOrigin get darker, brightest at oval's center\n        const float starBrightness = 10.0;\n        col /= r * starBrightness;\n\n    } else {\n        // Outside 2D shape\n\n        // Generate an animated pattern in the background\n\n        // Angle of the each pixel to ovalOrigin\n        float ovalAngle = atan(deltaVector.y, deltaVector.x);\n\n        // Distance of pixel uv to ovalOrigin\n        float r = length(deltaVector);\n\n        // Generate factors using radius, time, and angle along with some constant modifiers\n        const float backgroundSpeedFactor = 0.4;\n        float backgroundRotation = iTime * 1.2;\n        float backgroundComplexity = abs(sin(iTime));\n\n        // We can reverse the direction, and thus make it absorb like a black hole\n        const bool isEmitting = true;\n\n        // Rotation (which includes time) and angle\n        float rotationAngleFactor = ovalAngle + backgroundRotation;\n\n        // Time and distance\n        float timeDistFactor = backgroundSpeedFactor * iTime + r * backgroundComplexity * (isEmitting ? -1.0 : 1.0);\n\n        float backgroundFreq = 20.0;\n\n        // combine factors to make a pattern using sine\n        // changing the operator for how we combine these can create various cool patterns\n        float combinedFactor = sin(backgroundFreq * rotationAngleFactor) + sin(backgroundFreq * timeDistFactor);\n        \n        const float minBrightness = 1.1;\n        float backgroundBrightness = minBrightness - abs(sin(iTime));\n\n        // yellow (since I'm going for star/space theme)\n        vec3 backgroundBaseColor = vec3(1.0, 1.0, 0.0);\n\n        // mix the basecolor with combinedFactor\n        const float colorFreq = 4.0;\n        col = backgroundBrightness * sin(colorFreq * (backgroundBaseColor + combinedFactor));\n\n        // pixels farther away from the ovalOrigin get darker, brightest at oval's center\n        col /= r;\n    }\n    \n    // Generate an animated noise pattern (using refraction instead) over the entire screen \n    vec3 incidentVector = col;\n    vec3 normalVector = vec3(abs(sin(iTime)) - 1.41, abs(cos(iTime)) + 0.3, 0.0);\n    const float ratioIndicesOfRefraction = 0.9;\n    col *= refract(col, normalVector, ratioIndicesOfRefraction);\n\n    // Add space texture\n    col *= texture(iChannel0, uv).rgb;\n\n    // Modify final brightness of image\n    const float finalBrightnessModifier = 2.2;\n    col *= finalBrightnessModifier;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n\nvec2 mainSound( int samp, float time ) {\n    \n    // music/math help from https://amath.colorado.edu/pub/matlab/music/MathMusic.pdf\n    float freq = 0.0;\n    const int fundamental = 130;\n    const int numHarmonics = 4;\n    const float amplitude = 0.02;\n    \n    for (int i = 0; i < numHarmonics; i++){\n        freq += amplitude * sin(time * float(i * fundamental) * 2.0 * PI);\n    }\n    \n    float intervals = 1.0 - abs(sin(time));\n    \n    float result = intervals * freq;\n    return vec2(result);\n}","name":"Sound","description":"","type":"sound"}]}