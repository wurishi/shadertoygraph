{"ver":"0.1","info":{"id":"4lXSDr","date":"1435689356","viewed":247,"name":"raymarch'd ball + plane","username":"kaminate","description":"positions are in world-space","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float degreesToRadians = 3.14159 / 180.0;\nconst float rayEpsilon = 0.01;\nconst int rayIterations = 50;\nconst float exposure = 1.5;\nconst float tau = 6.2831853071;\n\n// http://filmicgames.com/archives/75\nvec3 TonemapAndGammaCorrection( vec3 color )\n{\n  color *= exposure;\n\n  vec3 x = max(vec3( 0 ),color- vec3( 0.004 ) );\n  vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n  return retColor;\n}\n\nfloat Sphere( vec3 position, vec3 spherePosition, float sphereRadius )\n{\n  return length(  position - spherePosition ) - sphereRadius;\n}\n\nfloat Plane( vec3 position, vec4 plane ) // ax + by + cz + d = 0\n{\n  return dot(  position, plane.xyz ) + plane.w;\n}\n\n\nfloat map( vec3 position )\n{   \n\n  float sphereRadius = 0.5;\n  vec3 spherePosition = vec3( \n      0,\n      0,\n      sphereRadius + abs(sin(iTime*5.0)) );\n  float sphereDist = Sphere( position, spherePosition, sphereRadius );\n  float dist = min( \n      sphereDist,\n      Plane( position, vec4( 0, 0, 1, 0 ) ) );\n  return dist;\n}\n\nvec3 GetNormal( vec3  position )\n{\n  float epsilon= 0.1;\n  vec3 dx = vec3(epsilon,0,0);\n  vec3 dy = vec3(0,epsilon,0);\n  vec3 dz = vec3(0,0,epsilon);\n\n  return normalize( vec3(\n        map( position + dx )- map( position - dx ),\n        map( position + dy )- map( position - dy ),\n        map( position + dz )- map( position - dz ) ) );\n}\n\n// https://www.shadertoy.com/view/lsf3zr\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float ao = 0.0;\n  float sca = 15.0;\n  for( int i=0; i<5; i++ )\n  {\n    float hr = 15.0*(0.01 + 0.015*float(i*i));\n    float dd = map( pos + hr*nor );\n    ao += (hr-dd)*sca/15.0;\n    sca *= 0.5;\n  }\n  return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nvoid Raymarch(\n    vec3 rayPosition,\n    vec3 rayDirection,\n    out float rayDepth,\n    out int iteration )\n{\n  rayDepth = 0.0;\n  iteration = 0;\n  for( int i = 0; i < rayIterations; ++i )\n  {\n    vec3 rayPoint = rayPosition + rayDirection * rayDepth;\n    float rayDist = map( rayPoint );\n    rayDepth += rayDist;\n    if( rayDist < rayEpsilon )\n    {\n      iteration = i;\n      break;\n    }\n\n    ++iteration;\n  }\n}\n\nvec3 AddLight(\n    vec3 lightPosition,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 geometryNormal,\n    vec3 geometryPosition )\n{\n  vec3 lightToGeometry = geometryPosition - lightPosition;\n  float distLightToGeometry = length( lightToGeometry );\n\n  float attenuation = 1.0 / ( distLightToGeometry * distLightToGeometry );\n\n  vec3 lightDirection = lightToGeometry / distLightToGeometry;\n  float ndotl = max( 0.0, dot( geometryNormal, -lightDirection ) );\n\n  return ndotl * lightColor * attenuation * lightIntensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ndcPixel = ( fragCoord.xy / iResolution.xy * 2.0 ) - 1.0;   \n  float aspectRatio = iResolution.x / iResolution.y;\n  vec3 wsUp = vec3( 0, 0, 1 );\n\n  // camera parameters\n  vec3 wsCamPos = vec3( 0, -6 , 1 );\n  vec3 wsCamDirection = vec3( 0, 1, 0 );\n  vec3 wsCamRight = -normalize( cross( wsUp, wsCamDirection ) );\n  vec3 wsCamUp = cross( wsCamRight, wsCamDirection );\n  float camNear = 0.1;\n  float camFar = 100.0;\n  float camFovY = degreesToRadians * 60.0;\n\n  float wsHalfProjH = camNear * tan( camFovY / 2.0 );\n  float wsHalfProjW = wsHalfProjH * aspectRatio;\n\n  vec3 wsCenterPixel = wsCamPos + wsCamDirection * camNear;\n  vec3 wsCurrentPixel = \n    wsCenterPixel + \n    wsCamRight * wsHalfProjW * ndcPixel.x +\n    wsCamUp * wsHalfProjH * ndcPixel.y;\n\n  vec3 rayPosition = wsCurrentPixel;\n  vec3 rayDirection = normalize( wsCurrentPixel - wsCamPos );\n\n  float rayDepth;\n  int iteration;\n  Raymarch( rayPosition, rayDirection, rayDepth, iteration );\n\n  vec3 wsHitPoint = rayPosition + rayDirection * rayDepth;\n  vec3 wsHitNormal = GetNormal( wsHitPoint );\n\n\n  vec3 color = vec3( 0, 0, 0 );\n\n  for( int i = 0; i < 3; ++i )\n  {\n    float offset = float( i ) * tau / 3.0;\n    vec3 lightPosition = vec3(\n        2.0 * sin( iTime + offset ), \n        2.0 * cos( iTime + offset ), \n        2.0 );\n    vec3 lightColor = vec3(0,0,0);\n    lightColor[ i ] = 1.0;\n    float lightIntensity = 1.0;\n\n    color += AddLight(\n        lightPosition,\n        lightColor,\n        lightIntensity,\n        wsHitNormal,\n        wsHitPoint );\n  }\n\n\n  color *= calcAO( wsHitPoint, wsHitNormal );\n  color = TonemapAndGammaCorrection( color );\n  fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}