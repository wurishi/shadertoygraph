{"ver":"0.1","info":{"id":"DlGyRy","date":"1700385782","viewed":82,"name":"Mandalabrot ","username":"PhiVape","description":"Using complex fractals to generate the black border. Still need to make the mandala mapping more seemless (pls give tips)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","psychedelic","art","mandala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define t iTime\n#define max_it 30.\n//iterative function z^5+c\nvec2 it_func1(in vec2 z, in vec2 c){\n    return pow_complex(z, 5.) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;   \n    vec2 uv0 = uv;\n    \n    //map space to mandala\n    uv *= 6.;\n    uv.y = uv.y * sign(uv.x);\n    uv.x = abs(uv.x);   \n    uv = polar(uv);\n    uv.y *= PI;\n    uv *= rotate(PI/4.);\n    uv.x += t;\n    \n    //rasterize screen\n    uv = fract(uv);\n    uv += vec2(-0.5);     \n    uv *= rotate(PI/4.);     \n    uv = uv /pow(length(uv), 2.);   \n    uv *= osc(0.3, 0.6, t*0.5+length(uv0));   \n    \n    //calculate mandelbrot variant\n    vec3 col = vec3(0.);\n    vec2 z = vec2(0, 0);\n    float i = 0.;\n    \n    for(; i< max_it && length(z) <= 1000.; i++){\n        z = it_func1(z, uv);\n    }\n    float f = i*0.1, l = length(uv0)*0.3;\n    i < max_it ? col = palette8(f+l+t*0.6): vec3(0.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rotate(float th){\n    return mat2(cos(th),-sin(th),sin(th),cos(th));\n}\n//turns complex cartesian coordinates into complex polar coordinates\nvec2 polar(in vec2 uv){\n    return vec2(length(uv), atan(uv.y,uv.x));\n}\n//turns complex polar coordinates into complex cartesian coordinates\nvec2 cartesian(in vec2 polar){\n    return vec2(polar.x*cos(polar.y), polar.x*sin(polar.y));\n}\n//return z^x for complex z = vec2(a, b) = a + bi\nvec2 pow_complex(in vec2 z, in float x){\n    z = polar(z);\n    z.x = pow(z.x, x);\n    z.y = z.y*x;\n    return cartesian(z);\n}\n//oscillates with sine wave from min to max. t should iTime*speed\nfloat osc(float min, float max, float t){\n    float r = sin(t);\n    float amp = max-min;\n    r = (r+1.)*amp*0.5 + min;\n    return r;\n}\n\nvec3 palette8( float t ) {\n\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}","name":"Common","description":"","type":"common"}]}