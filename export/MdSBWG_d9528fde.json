{"ver":"0.1","info":{"id":"MdSBWG","date":"1501859415","viewed":408,"name":"Synthwave","username":"X6Sire","description":"Desktop version of a messy experiment I wrote during my commute in an app called Shader Editor.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["retro","pixels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct pixel\n{\n    vec2 uv;\n    vec3 colour;\n};\n\nvec2 rotate(vec2 value, vec2 centre, float angle)\n{\n    value -= centre;\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    value *= mat2(cosAngle, sinAngle, -sinAngle, cosAngle);\n    value += centre;\n    return value;\n}\n\nfloat distsq(vec2 start, vec2 end)\n{\n\tvec2 vec = end-start;\n\treturn vec.x*vec.x + vec.y*vec.y;\n}\n\nvec3 ground(vec2 aim, float height)\n{\n    //aim = rotate(aim, vec2(0.5,0.5), sin(time));\n    vec3 cam = normalize(vec3(1.0,mix(-.625,.625,aim.x),mix(-1.0,1.0,aim.y)));\n    cam = (height/cam.z) * cam;\n    //cam.x += time;\n    return cam;\n}\n\nfloat grid(vec3 ground)\n{\n    vec2 grounduv = ground.xy;\n    float depth = grounduv.x;\n    grounduv.x += iTime; //floor(time*15.0)/15.0;\n    //grounduv.y -= (pointers[0].x*2.0)/resolution.x;\n    grounduv = fract(grounduv);\n    float val = min(abs(0.5-grounduv.x), abs(0.5-grounduv.y));\n    return clamp((1.0 - smoothstep(0.01,depth*0.06,val))/depth,0.0,1.0);\n}\n\npixel pixellate(vec2 value, float pixels)\n{\n    pixel ret;\n    const float bg = 0.4;\n    const vec3 black = \tvec3(bg, bg, bg);\n    const vec3 red = \tvec3(1.0, bg, bg);\n    const vec3 green = \tvec3(bg, 1.0, bg);\n    const vec3 blue = \tvec3(bg, bg, 1.0);\n    vec3 coloursA[4], coloursB[4];\n    coloursA[0] = black;\n    coloursA[1] = red;\n    coloursA[2] = green;\n    coloursA[3] = blue;\n    coloursB[0] = red;\n    coloursB[1] = green;\n    coloursB[2] = blue;\n    coloursB[3] = black;\n    \n    value *= pixels;\n    float shift = 0.5*floor(mod(value.x,2.0));\n    value.y += shift;\n    \n    vec2 px = fract(value);\n    int ci = int(4.0*px.x);\n    float ca = fract(4.0*px.x);\n    ret.colour = mix(coloursA[ci], coloursB[ci], ca);\n    float brightness = 2.0;\n    ret.colour *= brightness * max(1.0 - distsq(vec2(0.5,0.5),px), 0.0);\n    \n    value = floor(value);\n    value.y -= shift;\n    value /= pixels;\n    ret.uv = value;\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 blue = vec4(0.12,0.2,0.9,1.0);\n    vec4 cyan = vec4(0.05,0.5,0.9,1.0);\n    vec4 white = vec4(1.0,1.0,1.0,1.0);\n    vec4 orange = vec4(1.0,0.7,0.1,1.0);\n    vec4 pink = vec4(0.8,0.2,0.5,1.0);\n    vec4 black = vec4(0.02);\n    vec4 red = vec4(0.9,0.1,0.05,1.0);\n    \n    vec2 centre = vec2(0.45,0.5);\n    \n\tvec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    uv.y = 1.0 - uv.y;\n    uv.x -= 0.45;\n    float dist = distance(uv,centre);\n    uv += 0.15*dist*dist * (uv-centre);\n    pixel thisPixel = pixellate(uv, 128.0);\n    uv = thisPixel.uv;\n\n    //float crc = smoothstep(0.32, 0.3, distance(uv,centre));\n    \n    vec4 pixColour = vec4(thisPixel.colour, 1.0);\n\tfragColor = pixColour * texture(iChannel0, uv);\n\n    float mn = max(iResolution.x,iResolution.y);\n    //vec2 uv = gl_FragCoord.xy/mn;\n    //uv *= -1.0;\n    //float offset = 1.45*mn;//resolution.y-resolution.x;\n    //uv += vec2(0.0,offset/mn);\n    //uv.y = 1.45 - uv.y;\n    //vec2 centre = vec2(0.5,0.5);\n    //uv.y += 0.2*time;\n    vec4 pixcol = vec4(thisPixel.colour, 1.0);//12.0 * texture2D(grille, uv*pixels*-0.5);\n    //pixel pix = pixellate(uv, pixels);\n    uv = thisPixel.uv;\n    vec4 pixnoise = vec4(texture(iChannel2, uv*1.5 + vec2(iTime*8.0, iTime*8.0)).g);\n    float distort = 0.1 + 1.5* (uv.y - 0.15) /*fract((uv.y+iTime+0.7*sin(iTime*2.0))*0.4)*/ + 0.6*texture(iChannel2, 0.75*vec2(iTime*-1.5, fract(uv.y))).r;\n    distort = max(0.0,distort-1.3);\n    distort = 3.0*pow(distort,3.0);\n    uv.x += 2.0*distort;\n    \n    float angle = 0.2*sin(iTime);\n    float offsetx = 0.02*cos(iTime);\n    float offsety = 0.02*sin(iTime*2.0);\n    vec2 uvoffset = vec2(offsetx, offsety);\n    vec2 crcofs = uvoffset;\n    //crcofs.x = -crcofs.x;\n    //float crc = 1.0 - smoothstep(0.39,0.42,\n    //distance(centre+crcofs,uv));\n    vec2 crcuv = 0.7 * uv + vec2(0.2, 0.35);\n    crcuv.y = 1.0 - crcuv.y;\n    float crc = texture(iChannel0, crcuv + crcofs).r;\n    //float crcbg = 1.0 - smoothstep(0.39,0.42,\n    //distance(centre-crcofs,uv));\n    float crcbg = texture(iChannel0, crcuv - crcofs).r;\n    vec2 sireuv = uv*1.3;\n    sireuv.x -= 0.1;\n    sireuv.y = 0.15 - sireuv.y;\n    sireuv += 5.0* uvoffset;\n    vec2 sireshduv = sireuv - 3.0*uvoffset + vec2(0.0,0.01);\n    sireuv = rotate(sireuv,vec2(0.5,-0.5),angle);\n    sireshduv = rotate(sireshduv,vec2(0.5,-0.5),angle);\n    sireuv.x = clamp(sireuv.x,0.0,0.85);\n    sireuv.y = clamp(sireuv.y,-1.0,0.0);\n    sireshduv.x = clamp(sireshduv.x,0.0, 0.85);\n    sireshduv.y = clamp(sireshduv.y,-1.0,0.0);\n    sireuv.x /= 6.0;\n    sireshduv.x /= 6.0;\n    vec4 sire = texture(iChannel3,sireuv);\n    vec4 sireshd = texture(iChannel3,sireshduv);\n\n    vec4 crccol = mix(orange,pink,1.5*uv.y-0.3);\n    crccol = mix(black,crccol,crc);\n    crccol = mix(crccol,black,sireshd.a);\n    crccol = mix(crccol,cyan,sire.a);\n    sire = vec4(sire.xyz,sire.a);\n    sireshd = vec4(black.xyz,sireshd.a);\n\n    vec4 fg = mix(black,crccol,crc);\n    fg.a = max(crcbg,crc);\n\n    fg = mix(fg,black,sireshd.a);\n    fg.a = max(fg.a,sireshd.a);\n\n    fg = mix(fg,sire,sire.a);\n    fg.a = max(fg.a,sire.a);\n\n    vec3 grnd = ground(uv,10.0)*0.3;\n    float grd = grid(grnd);\n    float fog = min(2.0,abs(grnd.x)*0.1);\n    vec4 bg = mix(black, cyan*0.5, fog);\n    float glow = max(0.0,1.0-distsq(1.3*uv,1.3*centre));\n    bg += pink * 0.5 * glow;\n    vec4 gridcol = mix(bg,pink*1.5,grd);\n    float overbright = 2.0;\n    fragColor = pixcol *\n    min(\n    mix(\n    overbright*mix(gridcol,fg,fg.a),\n    pixnoise*3.0,\n    0.94*distort+0.06\n    ),\n    1.0\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float approxsqrt(float x)\n{\n    float omx = 1.0 - x;\n    return 1.0 - omx * omx;\n}\n\nfloat horizonWaves(float y)\n{\n    //y = 1.0 - y;\n    float w = abs(fract(1.0 / approxsqrt(y*0.25) + iTime) - 0.5);\n    w = max(0.0, w);\n    float a = smoothstep(-0.3, -0.6, y);\n    return mix(1.0, w, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 orange = vec4(1.0, 0.8, 0.6, 1.0);\n    vec4 blue = vec4(0.1, 0.15, 0.2, 1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy; //max(iResolution.x, iResolution.y);\n    \n    vec2 centre = vec2(0.5,0.3);\n    float crc = smoothstep(0.3, 0.28, distance(uv,centre));\n    \n\tfragColor = mix(blue, orange, crc * smoothstep(0.1,0.35,horizonWaves(uv.y*3.0-1.25)));\n}","name":"Buf A","description":"","type":"buffer"}]}