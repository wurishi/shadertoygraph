{"ver":"0.1","info":{"id":"lcByW1","date":"1730470437","viewed":30,"name":"Raymarching SDF2","username":"satyam","description":"Raymarching SDF","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 100\n#define MAXDIST 200.\n#define MINDIST 0.001\n#define SURF_DIST 0.001\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a-b), 0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\nmat2 Rotation(float a)\n{\n//Rotation as per matricies\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Capsule(vec3 p, vec3 c1, vec3 c2, float r)\n{\n    float t = dot(p-c1, c2-c1)/dot(c2-c1,c2-c1);\n    t = clamp(t,0.0,1.0);\n    vec3 pointOnLineSegment = c1 + t * (c2-c1);\n    float distanceToCapsule = length(p-pointOnLineSegment) - r;\n    return distanceToCapsule;\n}\n\nfloat Cylinder(vec3 p, vec3 c1, vec3 c2, float r)\n{\n    float t = dot(p-c1, c2-c1)/dot(c2-c1,c2-c1);\n    vec3 pointOnLineSegment = c1 + t * (c2-c1);\n    float x = length(p-pointOnLineSegment) - r;\n    float y = (abs(t-0.5)-0.5) * length(c2-c1);\n    float d = length(max(vec2(x,y),0.));\n    float interiorDistance = min(max(x,y),0.);\n    return d + interiorDistance;\n}\n\nfloat Torus(vec3 p, float r1, float r2)\n{\n    float l = length(p.xz) - r1;\n    float h = p.y;\n    return length(vec2(l,h)) - r2;\n}\n\nfloat Box(vec3 p, float height, float width, float depth)\n{\n    float pointOfContactOn_X = abs(p.x) - width/2.;\n    float pointOfContactOn_Y = abs(p.y) - height/2.;\n    float pointOfContactOn_Z = abs(p.z) - depth/2.;\n    \n    return length(vec3(max(pointOfContactOn_X,0.),max(pointOfContactOn_Y,0.),max(pointOfContactOn_Z,0.)));\n}\n\nfloat Sphere(vec3 p, vec3 center, float radius)\n{\n    return length(p- center) - radius;\n}\n\nfloat GetDist(vec3 p)\n{\n    float distanceToPlane = p.y;\n    \n    vec3 positionOfBox = p - vec3(0., abs(sin(iTime)) + 1., 2.);\n    positionOfBox.xy =  Rotation(sin(iTime)) * positionOfBox.xy; //Rotating the point\n    float distanceToBox = Box(positionOfBox, 1.,1.,1.);\n    \n    vec3 sphere;\n    sphere = p-vec3(3.,2.5,3.); //Translation\n    sphere = sphere * vec3(1.,1.,1.); //Scaling\n    float distSphere = length(sphere) - 2.;\n    \n    vec3 sphere2;\n    sphere2 = p-vec3(0.,2.,3.); //Translation\n    sphere2 = sphere2 * vec3(2.,.5,1.); //Scaling\n    float distSphere2 = length(sphere2) - 2.;\n    \n    \n    float distanceToSphere = Sphere(p, vec3(0.,3., 2.), 1.);\n    \n    vec3 q = fract(p) - 0.5;\n    q = abs(q);\n    float l = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);    \n    \n    float shape;\n    shape = smin(distSphere, distSphere2/2., 2.);\n    shape = min(shape, distanceToPlane);\n    \n    return shape;\n    //return smin(distanceToSphere,smin(distanceToCapsule, distanceToPlane, 1.),2.);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 smallMarginToShift = vec2(0.01, 0);\n    float distanceToPoint = GetDist(p);\n    \n    vec3 normal = vec3(\n        distanceToPoint - GetDist(p-smallMarginToShift.xyy),\n        distanceToPoint - GetDist(p-smallMarginToShift.yxy),\n        distanceToPoint - GetDist(p-smallMarginToShift.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceOrigin = 0.0;\n    for(int i = 0; i < STEPS ; i++)\n    {\n        vec3 pointOfFirstContact = rayOrigin + distanceOrigin * rayDirection;\n        float distanceFromCircelCenterToContact = GetDist(pointOfFirstContact);\n        distanceOrigin += distanceFromCircelCenterToContact;\n        \n        if(distanceOrigin > MAXDIST || distanceFromCircelCenterToContact < MINDIST) break;\n    }\n    \n    return distanceOrigin;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPosition = vec3(3.,5.,4.);\n    //lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    vec3 lightVector = normalize(lightPosition - p);\n    vec3 normal = GetNormal(p);\n    float diffuseValue = clamp(dot(lightVector,normal) * .5 + .5, 0.0, 1.0) ; //mul by .5 and add by .5 makes the image lighter\n    \n    //Shadow\n    float shadowToLight = RayMarch(p + normal * SURF_DIST,lightVector);\n    if(p.y<.01 && shadowToLight < length(lightPosition - p)) diffuseValue = diffuseValue * 0.5;\n    \n    return diffuseValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x/iResolution.x - 0.5, fragCoord.y/iResolution.y - 0.5) * 2.;\n    uv.x = uv.x * iResolution.x/iResolution.y; // To remove stretchiness from the scene because of uneven aspect ratio\n    \n    //vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y; //Shortform of the above thing\n\n    vec3 rO = vec3(0,3,-3);//RayOrigin\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    //rO.yz *= Rotation(-m.y+.4);\n    //rO.xz *= Rotation(.2-m.x*6.2831);\n    \n    \n    vec3 rD = normalize(vec3(uv.x,uv.y - 0.25 ,1));//RayDirection\n    \n    float col = RayMarch(rO, rD);\n    vec3 col3 = vec3(0);\n    \n    //Cuts of the surface to total black\n    if(col < MAXDIST){ \n        vec3 pointForLight = rO + rD * col;\n        float diffuseLight = GetLight(pointForLight);\n        col3 = vec3(diffuseLight);\n    }\n    \n    //col = col/12.;\n    //fragColor = vec4(col, col, col,1.0);\n    \n    \n    col3 = pow(col3, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col3,1.0);\n\n    //fragColor = vec4(col  , col  , col  , 1.0);\n}","name":"Image","description":"","type":"image"}]}