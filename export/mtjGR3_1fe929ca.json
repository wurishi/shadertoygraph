{"ver":"0.1","info":{"id":"mtjGR3","date":"1673636195","viewed":115,"name":"Drawing float numbers","username":"ianertson","description":"Drawing floating point numbers.\nYou can also hold and drag the text, and it will display the atan() of iMouse.xy.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["text","font","floats"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*  Stack-based floating point text render experiment\n*/\n\n\n// Modify NUM_DECIMALS with caution,\n// with too many decimals, you might overflow the stack.\n// So change the STACK_SIZE as well if you modify the number of decimals.\n#define NUM_DECIMALS 3\n#define STACK_SIZE 16\n#define FONT_SIZE 64.0\n\n// I'm drawing each character by representing them as \"boxes\"\nstruct Box {\n    vec2 min;\n    vec2 max;\n    vec2 uv;\n    vec3 color;\n};\n\n// just for some cool effects, this is detecting edges\nfloat edge(vec2 uv) {\n    float s = 0.002;\n    vec2 dir0 = vec2(0.0, s);\n    vec2 dir1 = vec2(-s, s);\n    vec2 dir2 = vec2(-s, 0.0);\n    float w = textureLod(iChannel1, uv, 0.0).r;\n    float r1 = textureLod(iChannel1, uv+dir0, 0.0).r;\n    float r2 = textureLod(iChannel1, uv+dir1, 0.0).r;\n    float r3 = textureLod(iChannel1, uv+dir2, 0.0).r;\n    float e = 0.0;\n    e += abs(w-r1);\n    e += abs(w-r2);\n    e += abs(r2-r1);\n    e += abs(w-r3);\n    e += abs(r3-r1);\n    e += abs(r3-r2);\n    return e / 6.0;\n}\n\n// get a numeric character from the font texture\nfloat getChar(vec2 uv, int digit) {\n    uv.y -= 3.0;\n    uv.x += 1.0;\n    uv.x += float(digit);\n    uv /= 16.0;\n    return textureLod(iChannel1, uv, 0.0).r + edge(uv);\n}\n\n// get a \"dot\" (.) for the decimals.\n// I'm not sure this is actually a proper period,\n// but it looks like a period so I guess it works.\nfloat getDot(vec2 uv) {\n    uv.x += 11.0;\n    uv.y += 5.0;\n    uv /= 16.0;\n    return textureLod(iChannel1, uv, 0.0).r + edge(uv);\n}\n\n// just to add some rainbow colors to the text\nvec3 getColor(in vec2 uv, int digit) {\n    vec2 d = vec2(0.001, -0.0001);\n    float n0 = float(digit);\n    float n = n0*256.0;\n    float x = fract(cos(((n*1.1)+3.14)*0.016));\n    float y = atan(x+(2.6*fract(n/0.98271)), n*sin(x*9.281));\n    vec2 offset = (vec2(x, y)*n*0.002)*(1.0+(n0*0.6));\n    float s = 64.0;\n    vec3 tex = textureLod(iChannel0, offset+(uv*1.6)/s, 0.0).rgb;\n    vec3 tex2 = textureLod(iChannel0, offset-((uv+(tex.xy*2.0))-(d*2.0))/s, 0.0).rgb;\n    return mix(tex, tex2, smoothstep(0.0, 1.0, fract(offset.x)));\n}\n\n// this is what's actually rendering the text\nbool getBox(vec2 fc, vec2 boxPos, float bsize, inout Box box, int digit, bool isDot) {\n    box.min = boxPos - vec2(bsize);\n    box.max = boxPos + vec2(bsize);\n\n    if (fc.x < box.min.x || fc.x > box.max.x) return false;\n    if (fc.y < box.min.y || fc.y > box.max.y) return false;\n    \n    vec2 size = box.max - box.min;\n    box.uv = ((box.max - fc)/size)*-1.0;\n    \n    if (isDot) box.uv.y += 0.3;\n\n    box.color = isDot ? vec3(getDot(box.uv)) : vec3(getChar(box.uv, digit));\n    box.color *= getColor(box.uv, digit);\n    return true;\n}\n\n// just an utility to estimate how big the final text is in pixels,\n// so that we can \"center\" the text\nint countDigits(float num) {\n    int count = 0;\n    int stack[STACK_SIZE];\n    int stackptr = 0;\n\n    for (int i = 0; i < STACK_SIZE && stackptr < STACK_SIZE; i++) {\n        num /= 10.0;\n        int digit = int(num);\n        int remain = int(num*10.0)%10;\n        stack[stackptr++] = remain;\n        if (digit <= 0) break;\n    }\n    \n    for (int i = 0; i < stackptr; i++) {\n        int idx =  (stackptr-1)-i;\n        int digit = stack[idx];\n        count += 1;\n    }\n    \n    return count;\n}\n\n\n// loops through all digits in a number and draws them\nvec3 drawNum(vec2 fc, inout vec2 boxPos, float boxSize, float num) {\n    num = abs(num);\n    \n    vec3 col = vec3(0.0);\n    \n    int stack[STACK_SIZE];\n    int stackptr = 0;\n    Box boxes[STACK_SIZE];\n\n    for (int i = 0; i < STACK_SIZE && stackptr < STACK_SIZE; i++) {\n        num /= 10.0;\n        int digit = int(num);\n        int remain = int(num*10.0)%10;\n        stack[stackptr++] = remain;\n        if (digit <= 0) break;\n    }\n    \n    for (int i = 0; i < stackptr; i++) {\n        int idx =  (stackptr-1)-i;\n        int digit = stack[idx];\n        \n        if (getBox(fc, boxPos, boxSize, boxes[i], digit, false))\n            col += boxes[i].color; boxPos.x += boxSize;\n    }\n    \n    return col;\n}\n\n// draws the left part of the float, and the decimal part\nvec3 drawFloat(vec2 fc, vec2 boxPos, float boxSize, float num) {\n    int numDigits = countDigits(num);\n    boxPos.x -= float(numDigits)*boxSize*0.5;\n    \n    float decimals = fract(num)*(pow(10., float(NUM_DECIMALS)));\n    \n    vec3 col = vec3(0.0);\n    col += drawNum(fc, boxPos, boxSize, num);\n    Box box; if (getBox(fc, boxPos, boxSize, box, 0, true)) col += box.color; boxPos.x += boxSize;\n    col += drawNum(fc, boxPos, boxSize, decimals);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 center = iResolution.xy/2.0;\n    vec2 uv = fc / iResolution.xy;\n    vec2 cuv = uv*2.0-1.0;\n    \n    float boxSize = 0.0;\n    vec2 pos = vec2(0.0);\n    float num = iDate.w;\n    \n    if (iMouse.z > 0.001) {\n        boxSize = FONT_SIZE;\n        pos = iMouse.xy;\n        num = atan(iMouse.x, iMouse.y);\n    } else {\n        boxSize = max(22.0, FONT_SIZE*(0.25+(0.5+(0.5*cos(iTime)))));\n        pos = center + vec2(cos(iTime), sin(iTime)) * (boxSize*0.5);\n        pos.x -= boxSize*1.5;\n    }\n    \n    // adding an offset to the text position\n    vec3 m = getColor((uv-(pos/iResolution.xy)), 4);\n    m = vec3(cos(iTime*m.x), sin(iTime*m.y), sin(iTime*m.z));\n    pos.x += (m.x+m.z)*0.5;\n    pos.y += (m.y+m.z)*0.5;\n\n    // drawing the text\n    col = drawFloat(fc, pos, boxSize, num);\n    \n    \n    // background effect stuff\n    float dist = abs(distance(uv, pos/iResolution.xy));\n    float f = pow(dist, 2.0);\n\n    vec3 bg = getColor(((uv*8.1+f) + (8.0+(f*2.0))*vec2(cos(iTime*0.1+0.1*sin(f*1.6)), sin(iTime*0.1+0.1*cos(f*1.6)))), 1);\n    bg = pow(bg, vec3(1.6));\n    \n    col = mix(col, bg * \n        smoothstep(0.0, 1.0, atan(-cuv.y, 0.6*cos(cuv.y+cuv.x))), max(0.0, 1.0 - length(col)));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}