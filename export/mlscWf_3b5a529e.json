{"ver":"0.1","info":{"id":"mlscWf","date":"1691504404","viewed":21,"name":"Cornell box path tracer","username":"vizaxo","description":"Cornell box path tracer with next event estimation for faster convergence","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracer","cornellbox","pathtracer","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 linear = vec3(0.);\n    \n    linear = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    fragColor = vec4(0.);\n#if ACCUMULATE\n#if DELAY\n    int samples = iFrame - 60;\n    if (samples <= 0) return;\n    linear /= float(samples);\n#else\n    if (iFrame == 0) return;\n    linear /= float(iFrame);\n#endif\n#endif\n\n    vec3 sRGB = pow(linear, vec3(0.4545));\n    fragColor = vec4(sRGB,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float farPlane = 100000.0;\n#define time iTime\n#define MAX_BOUNCES 3\n#define SPP 200\n#define NUM_RAND_CALLS 50\n\n#define ACCUMULATE 1\n#define DELAY 0\n\n\n// UTILS\nfloat lengthSquared(vec3 v) {\n    return dot(v,v);\n}\n\n\n// RANDOM SAMPLING\n\nuint hash(uint a) {\n        a = (a+0x479ab41du) + (a<<8);\n    a = (a^0xe4aa10ceu) ^ (a>>5);\n    a = (a+0x9942f0a6u) - (a<<14);\n    a = (a^0x5aedd67du) ^ (a>>3);\n    a = (a+0x17bea992u) + (a<<7);\n    return a;\n}\n\nfloat getRand( uint f ) {\n    f = hash(f);\n    \n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    f &= mantissaMask;\n    f |= one;\n        \n    float  r2 = uintBitsToFloat( f );\n    return r2 - 1.0;\n}\n\nstruct rngSeed {\n    ivec2 fragCoord; \n    vec3 iResolution; \n    int sampleNo; \n    int bounce; \n    int iFrame;\n};\n\nuint getRngSeed(rngSeed seed, int randID) {\n    uint id = uint(seed.fragCoord.x)\n        + uint(seed.fragCoord.y) * uint(seed.iResolution.x)\n        + uint(seed.sampleNo)    * uint(seed.iResolution.x) * uint(seed.iResolution.y)\n        + uint(seed.bounce)      * uint(seed.iResolution.x) * uint(seed.iResolution.y) * uint(SPP)\n        + uint(randID)           * uint(seed.iResolution.x) * uint(seed.iResolution.y) * uint(SPP) * uint(MAX_BOUNCES)\n        + uint(seed.iFrame)      * uint(seed.iResolution.x) * uint(seed.iResolution.y) * uint(SPP) * uint(MAX_BOUNCES) * uint(NUM_RAND_CALLS);\n    return id;\n}\n\nfloat getRand2(rngSeed seed, int randID) {\n    return getRand(getRngSeed(seed, randID));\n}\n\n// http://6degreesoffreedom.co/circle-random-sampling/\nvec3 sampleUnitSphere(rngSeed seed) {\n    float u = getRand2(seed, 2);\n    float v = getRand2(seed, 3);\n    float w = getRand2(seed, 4);\n    \n    float theta = u*6.28;\n    float phi = acos(1.-2.*v);\n    float r = pow(w, 1./3.);\n    \n    return vec3(cos(theta)*sin(phi), cos(phi) , sin(theta)*sin(phi)) * r;\n}\n\nvec3 sampleCircle(rngSeed seed, vec3 centre, float r, vec3 norm) {\n    vec3 circleU = normalize(cross(norm, vec3(0., 1., 0.))); //TODO: what if circle is pointing directly up?\n    vec3 circleV = cross(circleU, norm);\n    float theta = getRand2(seed, 5) * 6.28;\n    float sampleR = r * sqrt(getRand2(seed, 6));\n\n    vec3 circleSample = centre + sampleR * (circleU*cos(theta)+ circleV*sin(theta));\n    return circleSample;\n}\n\n// MATERIALS\n\n#define INVALID  0\n#define DIFFUSE  1\n#define METAL    2\n#define EMISSIVE 3\nstruct mat {\n    vec3 col;\n    int type;\n};\n\nconst mat nullMat = mat(vec3(-1.), INVALID);\n\n\n// LIGHTS\nstruct light {\n    vec3 pos;\n    float r;\n    vec3 col;\n};\n\n//TODO: mulutiple lights\nconst light mainLight = light(vec3(0.0, 1.3, 0.), 0.25, 8.*vec3(10.2, 10.05, 10.08));\n\n\n// INTERSECTIONS\n\nstruct hit {\n    vec3 norm;\n    float t;\n    mat mat;\n};\n\nconst hit nullhit = hit(vec3(0.), farPlane, nullMat);\n\nhit intersectSphere(vec3 ro, vec3 rd, vec3 cen, float r, mat m) {\n    float a = dot(rd, rd);\n    float b = 2.*dot(rd, ro - cen);\n    float c = dot(ro - cen, ro - cen) - r*r;\n\n    float discriminant = b*b - 4.*a*c;\n\n    if (discriminant < 0.) {\n        return hit(vec3(0.), farPlane, nullMat);\n    } else {\n        float t;\n        if (discriminant < 0.) return nullhit;\n        float x = (-b+sqrt(discriminant)) / 2.*a;\n        float y = (-b-sqrt(discriminant)) / 2.*a;\n        if (x < 0. && y < 0.) return nullhit;\n        if (x < 0. && y > 0.) t=y;\n        if (x > 0. && y < 0.) t=x;\n        else t = min(x, y);\n        \n        vec3 norm = normalize(ro+t*rd - cen);\n        return hit(norm, t, m);\n    }\n\n}\n\nhit intersectPlaneY(vec3 ro, vec3 rd, float h, mat m) {\n    float t = (h - ro.y) / rd.y;\n    bool b = t>0.;\n    float normSign = -sign(dot(rd, vec3(0., 1., 0.)));\n    mat retMat;\n    if (b) retMat=m; else retMat=nullMat;\n    return hit(b?normSign*vec3(0., 1., 0.):vec3(0.), b?t:farPlane, retMat);\n}\n\nhit intersectPlaneX(vec3 ro, vec3 rd, float h, mat m) {\n    float t = (h - ro.x) / rd.x;\n    bool b = t>0.;\n    float normSign = -sign(dot(rd, vec3(1., 0., 0.)));\n    mat retMat;\n    if (b) retMat=m; else retMat=nullMat;\n    return hit(b?normSign*vec3(1., 0., 0.):vec3(0.), b?t:farPlane, retMat);\n}\n\nhit intersectPlaneZ(vec3 ro, vec3 rd, float h, mat m) {\n    float t = (h - ro.z) / rd.z;\n    bool b = t>0.;\n    float normSign = -sign(dot(rd, vec3(0., 0., 1.)));\n    mat retMat;\n    if (b) retMat=m; else retMat=nullMat;\n    return hit(b?normSign*vec3(0., 0., 1.):vec3(0.), b?t:farPlane, retMat);\n}\n\nhit U(hit a, hit b) {\n    if (a.t < b.t) return a;\n    else return b;\n}\n\n\n// SCENE\n\nhit intersect(vec3 ro, vec3 rd) {\n    hit h;\n    mat diffuseRed = mat(vec3(0.3, 0.30, 0.38), DIFFUSE);\n    mat metal = mat(vec3(1., 1., 1.), METAL);\n    h.t = 1000000.0;\n    h = U(h, intersectSphere(ro, rd, vec3(-0.4, 0.25, 0.5), 0.25, metal));\n    //h = U(h, intersectSphere(ro, rd, vec3(0.0, 1.3, 0.), 0.25, light));\n    h = U(h, intersectSphere(ro, rd, mainLight.pos, mainLight.r, mat(mainLight.col, EMISSIVE)));\n    h = U(h, intersectSphere(ro, rd, vec3(0.3, 0.25, 0.), 0.25, diffuseRed));\n    mat diffuseGrey = mat(vec3(0.4, 0.4, 0.4), DIFFUSE);\n    h = U(h, intersectPlaneY(ro, rd, -0.0, diffuseGrey));\n    h = U(h, intersectPlaneY(ro, rd, 1.2, diffuseGrey));\n    h = U(h, intersectPlaneZ(ro, rd, 1.2, diffuseGrey));\n    h = U(h, intersectPlaneZ(ro, rd, -3.5, diffuseGrey));\n    h = U(h, intersectPlaneX(ro, rd, -0.8, mat(vec3(0.05, 0.05, 0.2), DIFFUSE)));\n    h = U(h, intersectPlaneX(ro, rd, 0.8, mat(vec3(0.05, 0.2, 0.05), DIFFUSE)));\n    return h;\n}\n\n\n// IMAGE\n\nvec3 cameraGetRd(vec3 iResolution, vec2 uv, vec3 camPos, vec3 lookAt) {\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0., 1., 0.)));\n    vec3 camUp = cross(camRight, camDir);\n    \n    vec2 filmSize = vec2(1.0, iResolution.y / iResolution.x);\n    \n    float filmDistance = 1.0;\n    vec3 filmCentre = camPos + camDir*filmDistance;\n    vec3 filmPos = filmCentre + (uv.x-0.5)*filmSize.x*camRight + (uv.y-0.5)*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos-camPos);\n    \n    return rd;\n}\n\nvec3 sampleRay(vec3 ro, vec3 rd, rngSeed seed) {\n    vec3 colour = vec3(0.);\n    vec3 albedoAcc = vec3(1.);\n    float useEmissive = 1.0;\n    \n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        seed.bounce = i;\n        hit h = intersect(ro, rd);\n        \n        // SUN LIGHTING\n        if (h.t >= farPlane) {\n            vec3 sunDir = normalize(vec3(-1.0, -1.0, -2.0));\n            float sunAttenuation = 0.1;//clamp(0., 1., dot(-sunDir, rd));\n            vec3 sunColour = vec3(9., 8., 6.);\n\n            colour *= sunAttenuation * sunColour;\n            return colour;\n        }\n        \n        mat m = h.mat;\n        albedoAcc *= m.col; //TODO: get rid of this *2. term\n        \n        ro += h.t * rd;\n        vec3 incoming = vec3(0.);;\n        if (m.type == EMISSIVE) {\n            incoming = useEmissive * vec3(1.);\n            useEmissive = 1.0;\n        } else if (m.type == METAL) {\n            rd = reflect(rd, h.norm);\n            useEmissive = 1.0;\n        } else if (m.type == DIFFUSE) {\n            useEmissive = 0.0;\n            // next event estimation\n            vec3 lightPos = mainLight.pos;\n            float lightR = mainLight.r;\n            vec3 circleSample = sampleCircle(seed, lightPos, lightR, normalize(lightPos-ro));\n            vec3 lightDir = normalize(circleSample-ro);\n            \n            hit shadowRay = intersect(ro+lightDir*0.001, lightDir);\n            if (shadowRay.mat.type == EMISSIVE) {\n                float p = lightR*lightR/(2.*lengthSquared(lightPos-ro));\n                incoming = shadowRay.mat.col * p * clamp(dot(h.norm, lightDir), 0.0, 1.0);\n            }\n            \n            rd = normalize(h.norm+sampleUnitSphere(seed));\n        }\n        colour += incoming*albedoAcc;\n        ro += rd*0.001;\n        if (m.type==EMISSIVE) break; //TODO: materials that are emissive and reflective?\n    }\n\n    return colour;\n}\n\nvec3 image(rngSeed seed, vec2 uv) {\n    float height = 0.5;\n    float angle = 3.14;\n    vec3 camPos = vec3(3.*sin(angle), height, 3.*cos(angle));\n    vec3 lookAt = vec3(0., camPos.y, 0.);\n    \n    vec3 rd = cameraGetRd(seed.iResolution, uv, camPos, lookAt);\n    vec3 ro = camPos;\n\n    return sampleRay(ro, rd, seed);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if ACCUMULATE\n#if DELAY\n    if (iFrame <= 60) {\n#else\n    if (iFrame == 0) {\n#endif\n        fragColor = vec4(0.);\n        return;\n    }\n    vec3 prev = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n#else\n    vec3 prev = vec3(0.);\n#endif\n\n\n#if 1\n\n    vec3 linear = vec3(0.);\n    for (int i = 0; i < SPP; i++) {\n        rngSeed seed = rngSeed(ivec2(fragCoord), iResolution, i, 0, iFrame);\n        vec2 jitter;\n        jitter.x = getRand2(seed, 0);\n        jitter.y = getRand2(seed, 1);\n        // uv (from 0 to 1)\n        vec2 uv = (fragCoord + jitter)/iResolution.xy;\n        linear += image(seed, uv);\n    }\n    linear /= float(SPP);\n    fragColor = vec4(linear+prev,1.0);\n#endif\n\n    //fragColor = vec4(prev+vec3(0.001), 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}