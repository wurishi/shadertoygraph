{"ver":"0.1","info":{"id":"XtyXDz","date":"1483784627","viewed":293,"name":"sdf debug","username":"acdimalev","description":"A tool for visualizing and debugging signed distance functions.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Usage\n// -----\n// \n// Click and drag to move camera and debug surface.\n// \n// \n// Abstract\n// --------\n// \n// When I first started with ray marching, I was under the impression that\n// CSG operations were generally safe to use.  I have since learned that\n// many commonly used SDFs (CSG operations included) result in under-estimated\n// distances that wreak havoc on scene lighting (wrong occlusion / false shadows).\n// \n// While it may still be interesting to use inaccurate distance functions\n// despite their limitations, I've decided to throw together this little tool\n// for visualizing what these inaccuracies look like.  Inspired by the tools of\n// those kind enough to document their work.\n// \n// http://mercury.sexy/hg_sdf/\n// https://youtu.be/s8nFqwOho-s\n\n\n// -- globals --\n\nconst float PI = 3.14159;\nconst float PHI = 1.0 / 1024.0;\nconst float MAX_DEPTH = 1024.0;\nconst int MAX_ITER = 32;\n\nconst float DISTANCE = 2.0;\n\n\n// -- object functions (edit these) --\n\n// input:\n//   p: point in space\n//\n// return:\n//   sd: signed distance from point to surface of object\n//\nfloat sd_object(vec3 p) {\n    // -- example --\n    vec3 q = abs(p);\n    float diamond = (q.x + q.y + q.z - 0.5) / sqrt(3.0);\n    float sphere = length(p) - 0.5;\n    //return diamond;\n    return max(sphere, diamond);\n}\n\n// input:\n//   p: point in space\n//\n// return:\n//   rgb: color of object at point, in linear color space\n//\nvec3 rgb_object(vec3 p) {\n    // -- example --\n    return vec3(p.y / 3.0 + 0.25);\n}\n\n\n// -- debug framework follows --\n\nvec2 debug; // = iMouse.xy / iResolution.xy - vec2(0.5);\n\nfloat sd_debug(vec3 p) {\n    return p.y - debug.y;\n}\n\nfloat rings(float width, float interval, float x) {\n    return step(width, mod(x + width/2.0, interval));\n}\n\nfloat offby(float error, float scale) {\n    return (max(error, PHI) - PHI) / max(PHI, scale);\n}\n\nvec3 rgb_debug(vec3 p) {\n    float sd = sd_object(p);\n    \n    const vec2 o = vec2(0.0, PHI);\n    \n    vec3 n = normalize(vec3(\n      sd_object(p + o.yxx) - sd\n    , sd_object(p + o.xyx) - sd\n    , sd_object(p + o.xxy) - sd\n    ));\n    \n    float error = sd_object(p - sd * n);\n    \n    // follow normal back to surface\n    // then mark any error greater than PHI\n    //\n    float under = sqrt(clamp(offby(error, sd), 0.0, 1.0));\n    float over = sqrt(clamp(offby(-error, sd), 0.0, 1.0));\n    //float under = step(PHI, error);\n    //float over = step(error, -PHI);\n    \n    // draw rings to visualize the distance function\n    //\n    float rings1 = rings(1.0/8.0, 1.0, sd);\n    float rings2 = rings(1.0/32.0, 1.0/4.0, sd);\n    float rings3 = rings(1.0/128.0, 1.0/16.0, sd);\n    \n    const vec3 white = vec3(1.0);\n    const vec3 lightred = vec3(1.0, 0.5, 0.5);\n    const vec3 darkred = vec3(0.5, 0.0, 0.0);\n    \n    vec3 color = mix(mix(white, lightred, under), darkred, over);\n    float intensity = (1.0 + rings1 * rings2 * rings3) / 2.0;\n    \n    return intensity * color;\n}\n\nconst float DEBUG_MATERIAL = 0.0;\nconst float OBJECT_MATERIAL = 1.0;\n\nvec2 sdmat_scene(vec3 p) {\n    vec2 object = vec2(sd_object(p), OBJECT_MATERIAL);\n    vec2 debug = vec2(sd_debug(p), DEBUG_MATERIAL);\n    return object.x < debug.x ? object : debug;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float rl = PHI;\n    vec2 sdmat = vec2(0.0);\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + rl * rd;\n        sdmat = sdmat_scene(p);\n        if (sdmat.x < PHI) { break; }\n        rl += sdmat.x;\n        if (rl >= MAX_DEPTH) { break; }\n    }\n    \n    return vec3(rl, sdmat);\n}\n\n// calculate ray vector for a given fragment coordinate\n//\n// this function also determines the handed-ness of the coordinate system\n//   z < 0 : left-handed\n//   z > 0 : right-handed\n//\nvec3 ray_vector(float fov, vec3 iResolution, vec2 fragCoord) {\n    \n    // scale relative to pixel density\n    float size = sqrt(iResolution.x * iResolution.y);\n    \n    // calculate vector in screen coordinates\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (size / 2.0) / tan(fov / 2.0);\n    \n    // return normalized vector\n    return normalize(vec3(xy, z));\n}\n\n// return a view matrix from `eye` to `center`\n//\n// based on gluLookAt\n// and kindly translated to GLSL by jlfwong\n// https://www.shadertoy.com/user/jlfwong\n//\n// the sign of `f` on the output matrix must be adjusted\n// to match the handed-ness of the coordinate system\n//   left-handed: -f\n//   right-handed: f\n//\nmat3 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    debug = iMouse.xy / iResolution.xy - vec2(0.5);\n    \n    float fov = radians(45.0);\n    float far = 256.0;\n    int max_iter = 32;\n    \n    float rot = debug.x * PI / 2.0;\n    \n    vec3 eye = vec3(\n      DISTANCE * sin(rot)\n    , 1.0\n    , -DISTANCE * cos(rot)\n    );\n    \n    vec3 center = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 view = view_matrix(eye, center, up);\n    \n    vec3 ray = view * ray_vector(fov, iResolution, fragCoord);\n    \n    vec3 result = raymarch(eye, ray);\n    vec3 p = eye + result.x * ray;\n    float material = result.z;\n    \n    vec3 color = vec3(0.0);\n    if (material == DEBUG_MATERIAL) { color = rgb_debug(p); }\n    if (material == OBJECT_MATERIAL) { color = rgb_object(p); }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}