{"ver":"0.1","info":{"id":"tsscz8","date":"1584189200","viewed":138,"name":"GFK lab 2 shader","username":"xopyip","description":"Shader napisany w 20 minut \n// autor: Mateusz Ba≈Çuch","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Hue_2_RGB(float v1, float v2, float vH ){\n   if ( vH < 0. ) vH += 1.;\n   if( vH > 1. ) vH -= 1.;\n   if ( ( 6. * vH ) < 1. ) return ( v1 + ( v2 - v1 ) * 6. * vH );\n   if ( ( 2. * vH ) < 1. ) return ( v2 );\n   if ( ( 3. * vH ) < 2. ) return ( v1 + ( v2 - v1 ) * ( ( 2. / 3. ) - vH ) * 6. );\n   return ( v1 );\n}\n\nvec4 HSLtoRGB(float H, float S, float L){\n    if ( S < 1e-8 ){\n       return vec4(L, L, L, 1);\n    }else{\n        float var_2, var_1;\n        if ( L < 0.5 )\n            var_2 = L * ( 1. + S );\n        else\n            var_2 = ( L + S ) - ( S * L );\n        var_1 = 2. * L - var_2;\n        return vec4(Hue_2_RGB( var_1, var_2, H + ( 1. / 3. ) ), Hue_2_RGB( var_1, var_2, H ), Hue_2_RGB( var_1, var_2, H - ( 1. / 3. ) ), 1);\n    }\n}\n\nvec4 HSVtoRGB(float H, float S, float V){\n    if ( S < 1e-8 )\n    {\n       return vec4(V, V, V, 1);\n    }\n    else\n    {\n       float var_h = H * 6.;\n       if ( abs(var_h - 6.) < 1e-8 ) var_h = 0.;\n        highp int i = int(var_h);\n       float var_1 = V * ( 1. - S );\n       float var_2 = V * ( 1. - S * ( var_h - float(i) ) );\n       float var_3 = V * ( 1. - S * ( 1. - ( var_h - float(i) ) ) );\n        float var_r, var_g, var_b;\n       if      ( i == 0 ) { var_r = V     ; var_g = var_3 ; var_b = var_1; }\n       else if ( i == 1 ) { var_r = var_2 ; var_g = V     ; var_b = var_1; }\n        else if ( i == 2 ) { var_r = var_1 ; var_g = V     ; var_b = var_3; }\n       else if ( i == 3 ) { var_r = var_1 ; var_g = var_2 ; var_b = V;     }\n       else if ( i == 4 ) { var_r = var_3 ; var_g = var_1 ; var_b = V;     }\n       else                   { var_r = V     ; var_g = var_1 ; var_b = var_2; }\n\t\treturn vec4(var_r, var_g, var_b, 1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(uv.x*800./450., uv.y);\n    uv = vec2(uv.x, 1.-uv.y); // przywracanie pozycji 0,0 pixeli w lewym gornym rogu zamiast lewym dolnym\n    \n    vec2 mouse = vec2(iMouse)/vec2(iResolution);\n    mouse = vec2(mouse.x, 1.-mouse.y); // przywracanie pozycji 0,0 myszki w lewym gornym rogu zamiast lewym dolnym\n    fragColor = vec4(0,0,0,1.0);   \n    \n    \n    //rysowanie skali 3 skladowej koloru\n    if(uv.x < 0.11) fragColor += vec4(uv.y, uv.y, uv.y, 1);\n    //rysowanie wskaznika wybranej 3 skladowej koloru\n    if(abs(uv.y-mouse.y) < 0.005 && uv.x < 0.12) fragColor += vec4(1,1,1, 1);\n    \n    \n    //RGB\n    vec2 dist1 = uv - vec2(1.05, 0.75);\n    float d1 = sqrt(dist1.x*dist1.x + dist1.y*dist1.y) * 5.;\n    \n    if(d1 < 1.){\n        float angle = atan(uv.y - 0.75, 1.05 - uv.x);\n     \tfragColor += vec4(d1,(angle + 3.14)/6.28,mouse.y,1.0);\n    }\n    \n    \n    //CMY\n    vec2 dist2 = uv - vec2(0.55, 0.75);\n    float d2 = sqrt(dist2.x*dist2.x + dist2.y*dist2.y) * 5.;\n    \n    if(d2 < 1.){\n        float angle = atan(uv.y - 0.75, 0.55 - uv.x);\n     \tfragColor += vec4(1.-(angle + 3.14)/6.28,1.-d2,1.-mouse.y,1.0);\n    }\n    \n    \n    \n    //HSL\n    vec2 dist3 = uv - vec2(0.55, 0.25);\n    float d3 = sqrt(dist3.x*dist3.x + dist3.y*dist3.y) * 5.;\n    \n    if(d3 < 1.){\n        float angle = atan(uv.y - 0.25, 0.55 - uv.x);\n     \tfragColor += HSLtoRGB((angle + 3.14)/6.29, d3, mouse.y);\n    }\n    \n    \n    \n    //HSV\n    vec2 dist4 = uv - vec2(1.05, 0.25);\n    float d4 = sqrt(dist4.x*dist4.x + dist4.y*dist4.y) * 5.;\n    \n    if(d4 < 1.){\n        float angle = atan(uv.y - 0.25, 1.05 - uv.x);\n     \tfragColor += HSVtoRGB((angle + 3.14)/6.29, d4, mouse.y);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"}]}