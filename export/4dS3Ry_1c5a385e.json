{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define M_PI 3.14159265358979323846\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand (vec2 co, float l) {\n\treturn rand(vec2(rand(co), l));\n}\n\nfloat rand (vec2 co, float l, float t) {\n\treturn rand(vec2(rand(co, l), t));\n}\n\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}\n\n// p must be normalized!\nfloat perlin(vec2 p, float dim) {\n\t\n\t/*vec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\t// For exclusively black/white noise\n\t/*float c = step(rand(pos, dim), 0.5);\n\tfloat cx = step(rand(posx, dim), 0.5);\n\tfloat cy = step(rand(posy, dim), 0.5);\n\tfloat cxy = step(rand(posxy, dim), 0.5);*/\n\t\n\t/*float c = rand(pos, dim);\n\tfloat cx = rand(posx, dim);\n\tfloat cy = rand(posy, dim);\n\tfloat cxy = rand(posxy, dim);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;*/\n\treturn perlin(p, dim, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat dt = 10.00;\n\tfloat time = floor(iTime / dt) * dt;\n\tfloat progress = fract(iTime / dt);\n\tvec3 clr = vec3(0.5);\n\tvec3 nextClr = vec3(0.5);\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\tfor (float i = 2.0; i < 11.0; ++i) {\n\t\tclr += pow(0.6, i) * vec3(perlin(uv, pow(2.0, i), time));\n\t\tnextClr += pow(0.6, i) * vec3(perlin(uv, pow(2.0, i), time + dt));\n\t}\n\t\n\tfragColor = mix (vec4(clr, 1.0), vec4(nextClr, 1.0), progress);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dS3Ry","date":"1389817726","viewed":343,"name":"Perlin Try","username":"bobismijnnaam","description":"perlin perlin perlin","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","unoptimized"],"hasliked":0,"parentid":"","parentname":""}}