{"ver":"0.1","info":{"id":"MstSRM","date":"1458428185","viewed":69,"name":"Triangle Intersection","username":"Yevano","description":"Triangle intersections with texture mapping","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0\n#define INF 999999.\n#define PI 3.14159265359\n\n#define IndexCountPerInstance 6u\n#define InstanceCount 6u\n\n    //-1.0, 1.0, -1.0, -1.0, 1.0,\t\t// 0 FRONT TOP LEFT\n    //1.0, 1.0, -1.0, 1.0, 1.0,\t\t\t// 1 FRONT TOP RIGHT\n    //1.0, -1.0, -1.0, 1.0, -1.0,\t\t// 2 FRONT BOTTOM RIGHT\n    //-1.0, -1.0, -1.0, -1.0, -1.0,   \t// 3 FRONT BOTTOM LEFT\n    //-1.0, 1.0, 1.0, -1.0, 1.0,\t\t// 4 BACK TOP LEFT\n    //1.0, 1.0, 1.0, 1.0, 1.0,\t\t\t// 5 BACK TOP RIGHT\n    //1.0, -1.0, 1.0, 1.0, -1.0,\t\t// 6 BACK BOTTOM RIGHT\n    //-1.0, -1.0, 1.0, -1.0, -1.0     \t// 7 BACK BOTTOM LEFT\n\nvec3 normal(vec3 p0, vec3 p1, vec3 p2) {\n    return normalize(cross(p0, p1));\n}\n\nmat4 angleAxis3x3(float angle, vec3 axis) {\n    float c, s;\n    s = sin(angle);\n    c = cos(angle);\n\n    float t = 1.0f - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat4(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y, 0.0,\n        t * x * y + s * z,  t * y * y + c,      t * y * z - s * x, 0.0,\n        t * x * z - s * y,  t * y * z + s * x,  t * z * z + c, 0.0,\n    \t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translate(vec3 v) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        v.x, v.y, v.z, 1.0\n    );\n}\n\nfloat per_vertex[] = float[] (\n    -1.0, 1.0, 0.0, -1.0, 1.0,\t\t// 0 FRONT TOP LEFT\n    1.0, 1.0, 0.0, 1.0, 1.0,\t\t// 1 FRONT TOP RIGHT\n    1.0, -1.0, 0.0, 1.0, -1.0,\t\t// 2 FRONT BOTTOM RIGHT\n\t-1.0, -1.0, 0.0, -1.0, -1.0     // 3 FRONT BOTTOM LEFT\n);\n\nfloat per_instance[16u * InstanceCount];\n\nuint indices[] = uint[] (\n    0u, 1u, 2u,\n\t0u, 2u, 3u);\n\nstruct DrawInfo {\n    vec3 pos;\n    vec2 texCoords;\n    vec3 normal;\n};\n\nDrawInfo drawn;\nfloat closest;\nmat4 mat;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 cartesian(vec3 b, vec2 v0, vec2 v1, vec2 v2) {\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n    \nvoid tri(vec3 p, vec3 d, uint id, uint instance, vec2 uv) {\n    uint o0 = indices[id * 3u + 0u] * 5u;\n    uint o1 = indices[id * 3u + 1u] * 5u;\n    uint o2 = indices[id * 3u + 2u] * 5u;\n    \n    vec4 v40 = vec4(per_vertex[o0 + 0u], per_vertex[o0 + 1u], per_vertex[o0 + 2u], 1.0);\n    vec4 v41 = vec4(per_vertex[o1 + 0u], per_vertex[o1 + 1u], per_vertex[o1 + 2u], 1.0);\n\tvec4 v42 = vec4(per_vertex[o2 + 0u], per_vertex[o2 + 1u], per_vertex[o2 + 2u], 1.0);\n\n\tvec2 t0 = vec2(per_vertex[o0 + 3u], per_vertex[o0 + 4u]);\n\tvec2 t1 = vec2(per_vertex[o1 + 3u], per_vertex[o1 + 4u]);\n\tvec2 t2 = vec2(per_vertex[o2 + 3u], per_vertex[o2 + 4u]);\n    \n    float[16u * InstanceCount] b = per_instance;\n    uint c = instance;\n    mat4 transform = mat4(\n        b[c * 16u + 0u], b[c * 16u + 1u], b[c * 16u + 2u], b[c * 16u + 3u],\n        b[c * 16u + 4u], b[c * 16u + 5u], b[c * 16u + 6u], b[c * 16u + 7u],\n        b[c * 16u + 8u], b[c * 16u + 9u], b[c * 16u + 10u], b[c * 16u + 11u],\n        b[c * 16u + 12u], b[c * 16u + 13u], b[c * 16u + 14u], b[c * 16u + 15u]);\n    \n    v40 *= transform * mat;\n    v41 *= transform * mat;\n    v42 *= transform * mat;\n    \n    vec3 v0 = v40.xyz;\n    vec3 v1 = v41.xyz;\n    vec3 v2 = v42.xyz;\n    \n    vec3 e1, e2, h, s, q;\n    float a, f, u, v, w, t;\n    \n    e1 = v1 - v0;\n    e2 = v2 - v0;\n    \n    h = cross(d, e2);\n    a = dot(e1, h);\n    \n    if(a < 0.0) return;\n    \n    //if(a > -EPS && a < EPS) return;\n    \n    f = 1./a;\n    s = p - v0;\n    u = f * dot(s, h);\n    \n    if(u < 0. || u > 1.) return;\n    \n    q = cross(s, e1);\n    v = f * dot(d, q);\n    \n    w = 1. - u - v;\n    \n    if(v < 0. || u + v > 1.) return;\n    \n    t = f * dot(e2, q);\n    \n    if(t < closest) {\n        closest = t;\n    } else {\n        return;\n    }\n    \n    if(t > EPS) drawn = DrawInfo(p + d * t, vec2(cartesian(vec3(w, u, v), t0, t1, t2)), normalize(cross(v1 - v0, v2 - v0)));\n}\n\nconst mat4 identity = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n\t0.0, 0.0, 0.0, 1.0);\n\nvec3 pixel(vec2 uv) {\n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    //mat = angleAxis3x3(-iTime, normalize(vec3(sin(iTime), cos(iTime * 0.17), 0.5 * sin(iTime * 0.29) + 0.5 * cos(iTime * 0.23))));\n    //mat = angleAxis3x3(-iTime, normalize(vec3(0.0, 1.0, 0.0)));\n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mat =  angleAxis3x3(-mouse.x * PI, normalize(vec3(0.0, 1.0, 0.0)));\n    mat *= angleAxis3x3(mouse.y * PI, normalize(vec3(1.0, 0.0, 0.0)));\n    \n    for(uint instance = 0u; instance < InstanceCount; instance++) {\n        for(uint index = 0u; index < IndexCountPerInstance / 3u; index++) {\n    \t\ttri(ro, rd, index, instance, uv);\n        }\n    }\n    \n    mat4 skyTransform = angleAxis3x3(0.0, vec3(0.0, 1.0, 0.0));\n    \n    if(closest == INF) return texture(iChannel1, (vec4(rd, 1.0) * skyTransform).xyz).xyz;\n    \n    return 0.5 * texture(iChannel0, drawn.texCoords * 0.5 + 0.5).xyz + 0.5 * texture(iChannel1, normalize(reflect((vec4(rd, 1.0) * skyTransform).xyz, drawn.normal))).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mat4 m0 = translate(vec3( 0.0,  0.0, -1.0)) * angleAxis3x3(0.0,      normalize(vec3(0.0f, 1.0f, 0.0f)));\n    mat4 m1 = translate(vec3( 0.0,  0.0,  1.0)) * angleAxis3x3(PI,       normalize(vec3(0.0f, 1.0f, 0.0f)));\n    mat4 m2 = translate(vec3(-1.0,  0.0,  0.0)) * angleAxis3x3(PI * 1.5, normalize(vec3(0.0f, 1.0f, 0.0f)));\n    mat4 m3 = translate(vec3( 1.0,  0.0,  0.0)) * angleAxis3x3(PI * 0.5, normalize(vec3(0.0f, 1.0f, 0.0f)));\n    mat4 m4 = translate(vec3( 0.0, -1.0,  0.0)) * angleAxis3x3(PI * 0.5, normalize(vec3(1.0f, 0.0f, 0.0f)));\n    mat4 m5 = translate(vec3( 0.0,  1.0,  0.0)) * angleAxis3x3(PI * 1.5, normalize(vec3(1.0f, 0.0f, 0.0f)));\n    \n    per_instance = float[] (\n        m0[0].x, m0[1].x, m0[2].x, m0[3].x,\n        m0[0].y, m0[1].y, m0[2].y, m0[3].y,\n        m0[0].z, m0[1].z, m0[2].z, m0[3].z,\n        m0[0].w, m0[1].w, m0[2].w, m0[3].w,\n\n        m1[0].x, m1[1].x, m1[2].x, m1[3].x,\n        m1[0].y, m1[1].y, m1[2].y, m1[3].y,\n        m1[0].z, m1[1].z, m1[2].z, m1[3].z,\n        m1[0].w, m1[1].w, m1[2].w, m1[3].w,\n\n        m2[0].x, m2[1].x, m2[2].x, m2[3].x,\n        m2[0].y, m2[1].y, m2[2].y, m2[3].y,\n        m2[0].z, m2[1].z, m2[2].z, m2[3].z,\n        m2[0].w, m2[1].w, m2[2].w, m2[3].w,\n\n        m3[0].x, m3[1].x, m3[2].x, m3[3].x,\n        m3[0].y, m3[1].y, m3[2].y, m3[3].y,\n        m3[0].z, m3[1].z, m3[2].z, m3[3].z,\n        m3[0].w, m3[1].w, m3[2].w, m3[3].w,\n\n        m4[0].x, m4[1].x, m4[2].x, m4[3].x,\n        m4[0].y, m4[1].y, m4[2].y, m4[3].y,\n        m4[0].z, m4[1].z, m4[2].z, m4[3].z,\n        m4[0].w, m4[1].w, m4[2].w, m4[3].w,\n\n        m5[0].x, m5[1].x, m5[2].x, m5[3].x,\n        m5[0].y, m5[1].y, m5[2].y, m5[3].y,\n        m5[0].z, m5[1].z, m5[2].z, m5[3].z,\n        m5[0].w, m5[1].w, m5[2].w, m5[3].w);\n    \n    closest = INF;\n    //mat = mat2(1, 0, 0, 1);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= iResolution.x/iResolution.y/2.;\n    uv.y -= .5;\n\tfragColor = vec4(pixel(uv), 1.);\n}","name":"Image","description":"","type":"image"}]}