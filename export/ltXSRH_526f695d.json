{"ver":"0.1","info":{"id":"ltXSRH","date":"1434409311","viewed":191,"name":"Reflective spheres","username":"berber","description":"Just some flying ballz","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"struct orb {\n    vec3 pos;\n    float rad;\n    float emit;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---------------------------------------\n    \n    #define OBJ_COUNT 3\n    \n    orb orbs[OBJ_COUNT];\n    \n    orbs[0].pos = vec3(-20.2 + cos(iTime) * 30.0, -15.7 + sin(iTime) * 11.0, 120.0 + sin(iTime / 3.5) * 60.0);\n    orbs[0].rad = 25.0;\n    orbs[0].emit = 0.0;\n    \n    orbs[1].pos = orbs[0].pos + vec3(cos(iTime) * 45.0, sin(iTime) * 42.0, sin(iTime) * 38.0);\n    orbs[1].rad = 20.0;\n    orbs[1].emit = 0.0;\n    \n    orbs[2].pos = orbs[0].pos + vec3(cos(iTime) * 104.0, sin(iTime / 2.6) * 92.0, sin(iTime) * 104.0);\n    orbs[2].rad = 20.0;\n    orbs[2].emit = 0.0;\n    \n    // ---------------------------------------\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * 2.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.y /= aspectRatio;\n    \n    vec3 rayUnit = normalize(vec3(uv, 1.0));\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n    float rayStrength = 1.0;\n    vec3 rayPos = vec3(0.0, 0.0, -1.0);\n    \n    float wallDepth = 50.0;\n    float wallScale = 80.0;\n    float wallLength = 5000.0;\n    \n    float minZ;\n    bool collision;\n    orb minOrb;\n    float underRoot;\n    float notUnder;\n    float currentZ;\n    vec3 surfaceNormal;\n    vec3 oMinusC;\n    float wallY;\n    float wallTileX;\n    float wallTileZ;\n    \n    bool emitterHit = false;\n    \n    for(int b = 0; b < OBJ_COUNT + 2; b++) {\n        \n        collision = false;\n        minZ = 0.0;\n        \n        for(int i = 0; i < OBJ_COUNT; i++) {\n\n            oMinusC = rayPos - orbs[i].pos;\n            underRoot = pow(dot(rayUnit, oMinusC), 2.0) - pow(length(oMinusC), 2.0) + pow(orbs[i].rad, 2.0);\n            notUnder = -1.0 * dot(rayUnit, oMinusC);\n\n            if(underRoot > 0.0) {\n\n                currentZ = min(max(notUnder + sqrt(underRoot), 0.0), max(notUnder - sqrt(underRoot), 0.0));\n\n                if(currentZ > 0.0 && (!collision || currentZ <= minZ)) {\n                    minZ = currentZ;\n                    collision = true;\n                    minOrb = orbs[i];\n                }\n            }\n        }\n        \n        if(collision && !emitterHit) {\n\t\t\t\n            rayPos = minZ * rayUnit + rayPos;\n            surfaceNormal = normalize(rayPos - minOrb.pos);\n            rayStrength *= -dot(rayUnit, surfaceNormal);\n            rayUnit = rayUnit + 2.0 * surfaceNormal * -1.0 * dot(surfaceNormal, rayUnit);\n            \n            if(minOrb.emit > 0.0) {\n                emitterHit = true;\n                rayColor += rayStrength * minOrb.emit;\n            }\n            \n        } else if(!emitterHit) {\n            \n            emitterHit = true;\n            wallY = abs(rayPos.y + wallDepth / rayUnit.y);\n            if(wallY * abs(rayUnit.z) <= wallLength && wallY * abs(rayUnit.x) <= wallLength) {\n                wallTileX = abs(floor(rayUnit.x * wallY / wallScale) - rayUnit.x * wallY / wallScale);\n                wallTileZ = abs(floor(rayUnit.z * wallY / wallScale) - rayUnit.z * wallY / wallScale);\n                if(wallTileX > 0.5 ^^ wallTileZ <= 0.5) {\n                    rayColor += rayStrength * abs(dot(vec3(0.0, 1.0, 0.0), rayUnit));\n                }\n            }\n            \n        }\n    }\n    \n\tfragColor = vec4(rayColor, 1.0);\n}","name":"","description":"","type":"image"}]}