{"ver":"0.1","info":{"id":"tlyGzG","date":"1590617055","viewed":204,"name":"Hedges Maze","username":"spalmer","description":"trying to make a hedge maze you can walk around in","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["leaf","vegetation","maze","walk","hedge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// think it was a fork of Halfpipe Maze at https://shadertoy.com/view/WlKGzD\n\n// see also Leafy Shapes 2D at https://shadertoy.com/view/tsjBW3 (currently still private)\n// where I'm trying to debug my kerning and leaf distribution, animation\n\n// I just cache maze into BufferA/iChannel0\n#define Maze     iChannel0\n#define CamState iChannel1\n#define Enviro   iChannel2\n \n//float imaze(vec2 p)\n//{\n// \treturn texelFetch(iChannel0,\n//                      ivec2(p + iChannelResolution[0].xy*4.) % ivec2(iChannelResolution[0].xy),\n//                      0).x; // MAZE(p)?1.:0.;\n//}\n// hardware bilinear texture filtering isn't very accurate; seems only few bits fractional precision\nfloat dmaze(vec2 p)\n{\n    return textureLod(Maze, p / iChannelResolution[0].xy, 0.).x;\n}\n\nfloat hmaze(vec2 p)\n{\n    float c = dmaze(p);\n    c = clamp(c*2.-1., 0., 1.);\n    return 1.-pow(max(0., 1.-c), 2.);\n//\treturn sqrt(sqrt(c));\n//    if (c >= .99) return .5;\n//    c = c * .5; // HACK thin walls\n     // round the hedges\n//    float s = sqrt(1. - c*c);\n//    return 0.; //.5 - .5 * c;   \n//    return c; //dmaze(p);\n}\n\nfloat dleaf(vec2 q)\n{\n    q.x = abs(q.x);\n    //float detail = .02 / (25.*length(fwidth(q.xy))+1e-3) * // aa\n    //                      sin(7.*(q.y-q.x));\n    //detail = abs(detail);\n    //detail /= 1. + max(0., q.y * -.5 + .5);\n    q.x = q.x + .5;\n    // if (close_enough)\n    //q.x += detail; // FIXME it really wrecks the field, though - mess with details later\n    return length(q) - 1.02;\n}\n\n\nfloat gt(vec3 p, vec3 c, vec3 o, inout float r)\n{\n//    return length(p) - .2; //.001; //1./tSpace;\n\n    vec3 q = p + o; // o is presently zero; q should be relative to cell origin, local coord, basically\n     // FIXME need random orientation\n    float n1 = hash(c) * 6.28;\n    float n2 = (hash(c+1.) * 2. - 1.) * .5 * 3.14; //sin(2.5*iTime) * 3.14 * .5; //\n    rot(q.xz, vec2(cos(n1),sin(n1)));\n    rot(q.yz, vec2(cos(n2),sin(n2))); // fine, we'll just do it this way!\n    #if 0\n    rot(q.yz, vec2(cos(n2),sin(n2))); // works fine!\n    #elif 0\n    rot(q.xy, vec2(cos(n2),sin(n2))); // works fine!\n    #elif 0\n    // well then I really don't know wtf\n    vec2 vr = vec2(1.,q.y);\n    rot(vr, vec2(cos(n2),sin(n2)));\n    q.y = vr.y; \n    q.xz *= vr.x; //max(1e-1f, abs(vr.x)); // max screws things up good\n    #endif\n    float d = dleaf(q.xz / .5) * .5;\n    float dy = abs(q.y) - .02;\n    d = max(d, dy); //min(d, dy); //d += dy; // flat\n    return r = min(r, d); //d; //\n}\n\nfloat gd(vec3 p)\n{ // TODO I'd be so much better off using a simplex lattice warp\n//    return 0.; \n    const float tSpace = 1.; //.2;\n\tvec3 c = floor(p / tSpace); // tile address\n    p.xyz = (fract(p / tSpace) - .5) * tSpace; // local coord\n    //return length(p) - .2; //.001; //1./tSpace;\n\tfloat r = 3e38; //dist2frame(p, 4.25);\n    gt(p, c, vec3(0), r);\n    // no, must re-tile again  - beware 0.5 scale factor! still causing problems\n    gt((fract((p + .25) / tSpace) - .5) * tSpace, c+.5, vec3(0), r);\n    // random offsets would be better but this is pretty dense and looks ok-ish for now\n    return r;\n //   return gt(p, c, vec3(0), 3e38); // actual leaf\n    // TODO checking neighbor cells will be necessary once I start perturbing their offsets near the cell boundaries\n\tvec2 z = vec2(0,1);\n\tgt(p, c, z.xxx, r);\n\tgt(p, c, z.yxx, r);\n\tgt(p, c, z.xyx, r);\n\tgt(p, c, z.yyx, r);\n\tgt(p, c, z.xxy, r);\n\tgt(p, c, z.yxy, r);\n\tgt(p, c, z.xyy, r);\n\tgt(p, c, z.yyy, r);\n//\tr = min(r, abs(p.y - 0.));\n\treturn r; \n}\n\nfloat max3(vec3 a) { return max(a.x,max(a.y,a.z)); }\n\nvec3 campos, camdir;\n\n// FIXME I really need the more high-quality maze anyway, \n// then I could do high-quality walls of any shape,\n// not this extruded displacement heightfield crap\nfloat sdf(vec3 p)\n{\n    const float dscalehack = .3; //.5; //.7; //1.; // HACK broken sdf because heightfield, must apply evenly or AO suffers\n\tfloat h = hmaze(p.xz);\n    float pd = p.y - h;\n    // TODO now I want to do a tiled randomized leaf texture\n    // but only in areas *beneath* the maze hedge height and above the ground\n    if (true &&\n        distance(p, campos) < 15. && // just switch to lod lod with distance\n        pd < .0 && \n        h > .001 &&\n        p.y > 0.001 // trying to keep leaves off the ground, only in the hedges; not working\n     //   && max3(fwidth(p)) < 1e-7 // totally not working how I'd hoped\n       ) {\n        float lscale = 1. / 16.; //32.; //4.; //8.; //64.; //\n        return gd(p/lscale)*lscale * dscalehack;\n    }\n    // this part's really supposed to be only the low-lod\n    h -= .01; // in fact, trim it down a bit so march won't stop on it before hitting leaves\n    h = max(0., h);\n    return (p.y - h) * dscalehack; // not a true sdf, just a heightfield, and texture sampler precision is poor\n}\n\nvec3 nmaze(vec3 p, float h)\n{\n    // TODO dFdx,dFdy\n    return normalize((vec3(sdf(p + vec3(h,0.,0.)), sdf(p + vec3(0.,h,0.)), sdf(p + vec3(0.,0.,h))) - sdf(p)) / h);\n}\n    \nfloat raymarch(vec3 ro, vec3 rd, int maxsteps)\n{\n    float ret = -1.;\n    float t = 0.0;\n    for (int i = 0; i < maxsteps; ++i) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if (d <= 1e-4) {\n          ret = t;\n          break;\n        }\n        t += max(d, .0005);\n    }\n    if (ret < 0. && rd.y < 0.)\n        ret = ro.y / -rd.y; // HACK pretend this method doesn't suck\n    return ret;\n}\n\nconst vec3 L = normalize(vec3(1.,1.,2.)); //.1,.2,.9)); //.3,.5,.866));\n\nfloat shadow(vec3 p)\n{\n    float r = raymarch(p, L, 96);\n    return r > 0. //&& r <= 2.\n        ? .0 : 1.;\n}\n\nvec3 lighting(vec3 p, vec3 d, float r)\n{\n    float nw = .005 * r;\n    vec3 n = nmaze(p, nw);\n//    return n * .5 + .5;\n    float dh = sdf(p);\n    float oao = .3; // ambient occlusion scan distance hack\n    float dao = sdf(p + n * oao);\n    // use directional derivative in normal direction\n    // to compute fake ambient occlusion factor\n    float ao = clamp(1. * dao / oao, 0., 1.);\n    vec3 cdiff = vec3(.3,.7,.1);\n    float h = p.y; // this color palette is bogus FIXME\n//    cdiff.b *= mix(1., .6, step(.5,  fract(h*12.)));\n//    cdiff.r *= mix(1., .8, step(.47, fract(h*2.+.2)));\n//    cdiff.g *= mix(1., .9, step(.62, fract(h*5.+.3)));\n    float nl = dot(L, n);\n    float shadowatten = shadow(p + n * .005 + nl * .03 * L); //1.; //\n    shadowatten *= pow(max(1e-2,ao), .5); // tuning ao falloff\n    nl = max(0., nl);\n    nl *= shadowatten;\n    float diff = mix(nl, 1., .1);  //nl; // ambient hacks\n    vec3 H = normalize(L+d); // blinn-phong hack\n    float spec = nl * pow(max(0., dot(H, n)), 64.); //0.; //\n    vec3 nr = reflect(n, d); //d, n); //\n   // vec3 env = textureLod(Enviro, nr, 0.).rgb;\n    return //env + \n        clamp(cdiff * diff + .6 * spec, 0., 1.); //mix(diff, 2.*spec, .5);\n}\n\nvec3 draw(vec2 q)\n{\n    campos = texelFetch(CamState, ivec2(0,0), 0).xyz;\n    camdir = texelFetch(CamState, ivec2(1,0), 0).xyz;\n    camdir = normalize(camdir);\n    mat3 m = cameraMatrix(camdir);\n    vec3 rp = campos;\n    vec3 rd = normalize(m * vec3(q, 2.));\n    float r = raymarch(rp, rd, 256);\n    float vl = max(dot(rd, L), 0.);\n   if (!(r >= 0.))\n        return (\n     //   textureLod(Enviro, rd, 0.).rgb\n      //  + \n            vec3(mix(.5,1.,pow(vl, 4.))))//exp2(-8. * max(0.,1.-vl))))\n       * 1.2*vec3(.85,.9,.95);\n    vec3 phit = rp + rd * r;\n    return lighting(phit, -rd, r);\n}\n//    vec2 hituv = phit.xz;\n//    vec2 uv = hituv; //q*12.; //\n//    return vec3(dmaze(uv));\n//    return rd * .5 + .5;\n//    return abs(n); //n * .5 + .5; //\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n//    c = texture(Maze, p/iResolution.xy); return; // debug Buffer A\n//    c = texture(CamState, p); return; // debug Buffer B\n    vec2 r = iResolution.xy;\n    c.rgb = draw((p+p-r)/r.y);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n\tc.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\n\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 25314.67283);\n}\n\nfloat hash(vec2 x)\n{\n\treturn rand(dot(x, vec2(7,5)));\n}\n\nfloat hash(vec3 x)\n{\n\treturn rand(dot(x, vec3(7,5,11)));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ALU maze by Fabrice Neyret https://shadertoy.com/view/lt2cRR\n// small enough I could use it in the main raymarcher loop,\n// but may as well cache to BufferA, but only needed\n// on frame 0 or periodically in case buffer was resized\n\n#define Z  2\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n   O = (iFrame & 1023) >= 3 //!= 0\n       ? texelFetch(iChannel0, ivec2(U), 0)\n       : vec4(vec3(\n       ((int((U)[int(1e4*length(ceil((U)/float(Z))))&1])&(Z-1))!=0)\n   ?0.:1.),1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define Maze     iChannel0\n#define CamState iChannel1\n#define Keyboard iChannel2\n\nconst float moverate = .5; // actually very slow.\n\nvec4 loadValue(int slot_id)\n{\n    return texelFetch(CamState, ivec2(slot_id, 0), 0);\n}\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = texelFetch(Keyboard, ivec2(vk,0), 0).x; // read keyboard key state from texture\n    return step(.5, s); //s > .5 ? 1. : 0.; // test if down\n}\n\nvec3 cameraPosition() \n{\n    return loadValue(slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection() \n{\n    return loadValue(slotCameraForward).xyz;\n}\n\n#if 0\n// debug camera from https://shadertoy.com/view/WlVGDh\nconst float turnratemouse = .02; // since mouse can't go outside window, must be pretty fast\n\nconst int\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n;\n\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\n//const int slotCameraPosition = 0;\n//const int slotCameraForward  = 1;\nconst int slotDesiredForward = 2;\nconst int slotMouseOld       = 3; // iMouse from prior frame\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\nvec3 desiredDirection() \n{\n    return loadValue(CamState, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(CamState, slotMouseOld);\n}\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition();\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n//    if (asleep(iMouse.xy)) fw = .5; // automate forward in thumbnails\n    vec3 camfwd = cameraDirection();\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n//    campos += sdfnormal(campos) * -min(sdf(campos) - camradius, .0); // collision with sdf\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n//    if (asleep(iMouse.xy)) {\n//    \torbit = vec2(.05*iTimeDelta, 0);   // attract mode slow spin\n//\t} else\n    {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t}\n    \t/*{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }*/\n    }\n    if (dot(orbit,orbit) != 0.) {\n        rot(desiredRot.xz, vec2(cos(orbit.x), sin(orbit.x)));\n        vec2 vr = vec2(1.,desiredRot.y);\n        rot(vr, vec2(cos(orbit.y),-sin(orbit.y)));\n        desiredRot.xz *= max(1e-1f, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection();\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// implements a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p);\n    c = loadValue(CamState, ip.x); // passthru by default\n    float elapsed = iTimeDelta; // seconds\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame == 0; //iTime == 0.; //\n    // executes extremely inefficiently on gpu\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(.0,1.5,-3.5) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n\n// in this case we output into Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{    \n    debugFlyCamera(c, p);\n}\n\n#else\n// main game avatar/camera code\n\n// http://keycode.info\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition();\n    float fw = key(KEY_W);\n    float lf = key(KEY_A);\n    float rt = key(KEY_D);\n    float bw = key(KEY_S);\n    float up = 0.; //key(KEY_SPACE);\n    float dn = 0.; //key(KEY_C); // anything but control!\n//    if (asleep(iMouse.xy)) fw = .5; // automate forward in thumbnails\n    vec3 camfwd = cameraDirection();\n    camfwd.y = 0.;\n    camfwd = normalize(camfwd);\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n    // TODO collision with hedgemaze\n    // FIXME actually should just prevent motion into the hedge, not rise over it!\n//    campos += sdfnormal(campos) * -min(sdf(campos) - camradius, .0); // collision with sdf\n    return campos;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec3 campos, camdir;\n    campos = cameraPosition();\n    camdir = cameraDirection();\n    float t = iTimeDelta;\n    camdir = normalize(camdir);\n    float speed = .6;\n    vec3 cammove = cameraMovement(false);\n    campos = cammove;\n    float rot = iMouse.x/iResolution.x * 13.;\n    float mtmix = exp2(-64.*iTimeDelta);\n \tcamdir = normalize(mix(vec3(sin(rot),-.4,cos(rot)), camdir, mtmix));\n    camdir = normalize(camdir);\n    c = vec4(0.,0.,0.,1.);\n    int q = int(p.x) + 16*int(p.y); // state id\n    switch (q) {\n        case slotCameraPosition: c = vec4(campos, 1.); break;\n        case slotCameraForward: c = vec4(camdir, 1.); break;\n    }\n    if (iFrame < 3) { //iFrame == 0) { // init\n        switch (q) {\n            case slotCameraPosition: c = vec4(vec3(.5*iChannelResolution[0].xy,1.25).xzy, 1.); break;\n            case slotCameraForward: c = vec4(0.,0.,1., 1.); break;\n        }\n    }\n}\n\n#endif\n\n","name":"Buffer B","description":"","type":"buffer"}]}