{"ver":"0.1","info":{"id":"sd3SW8","date":"1633013624","viewed":203,"name":"perlin watercolor fork","username":"Protowalker","description":"forked from https://www.shadertoy.com/view/lt2BRm#. Adds more than 1 dot","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["perlin","watercolor","aesthetic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"perlin watercolor\" by ws. https://shadertoy.com/view/lt2BRm\n// 2021-09-30 14:49:33\n\n// perlin noise from https://www.shadertoy.com/view/XdcXzH\n#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 0.0\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\nconst mat4 fg_cols = mat4(0.,110.,202.,256., // blue\n\t\t\t\t\t\t232., 141., 122.,256., // red\n\t\t\t\t\t\t90., 188., 94.,256., // green\n\t\t\t\t\t\t161., 90., 188. ,256.  )/256.; // purple \nconst vec4 bg_col = vec4(229.,204.,175.,256.)/256.;\n\n\nvec4 strokeAtPoint(vec2 coord, vec2 strokePoint, float seed, float shapeSeed, out vec4 baseColor) {\n    \n    strokePoint.x *= iResolution.x/iResolution.y;\n    float r = length(strokePoint);\n    \n    // fg_col = fg_cols[seed%4] logically, but this is a compatability workaround.\n    vec4 fg_col = vec4(0.);\n    fg_col += float(mod(seed,4.)==0.)*fg_cols[0];\n\tfg_col += float(mod(seed-1.,4.)==0.)*fg_cols[1];\n\tfg_col += float(mod(seed-2.,4.)==0.)*fg_cols[2];\n\tfg_col += float(mod(seed-3.,4.)==0.)*fg_cols[3];\n    \n    float noise_scale = 0.15+0.075*mod(shapeSeed, 3.);\n    float num_layers = 10.+2.*mod(shapeSeed, 5.);\n    shapeSeed *= num_layers;\n    \n    float v = 0.;\n    \n    for (float i = 0.; i < num_layers; i++) {\n        float h = noise_scale*perlin(strokePoint+vec2(i+shapeSeed))+r;\n        if (h < 0.4) { v += 1./num_layers; }\n    }\n    \n    baseColor = fg_col;\n    return mix(vec4(fg_col.xyz, 0.0), fg_col, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \tvec2 p = fragCoord.xy / iResolution.xy - 0.5;\n    vec2 p2 = vec2(p.x - 0.25, p.y);\n    float seed = floor(iTime*0.5);\n    \n    vec4 baseColor;\n    \n    fragColor = strokeAtPoint(fragCoord, p, seed, seed, baseColor);\n    fragColor += strokeAtPoint(fragCoord, p2, seed, seed + floor(iTime*0.1), baseColor);\n    fragColor = min(fragColor, baseColor);\n    \n    \n    fragColor = mix(bg_col, fragColor, fragColor.a);\n    //fragColor *= strokeAtPoint(fragCoord, p2, seed);\n}\n","name":"Image","description":"","type":"image"}]}