{"ver":"0.1","info":{"id":"WdS3zK","date":"1549359908","viewed":317,"name":"Worley Sky","username":"denosya","description":"First attempt to 2D clouds using Worley noise.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 SKYCOLOR = vec3(59.0/255.0, 121.0/255.0, 254.0/255.0) * 0.75;\nconst vec3 CLOUDCOLOR = vec3(1.0,1.0,1.0);\nconst vec3 HASHSCALE3 = vec3(.1031, .1030, .0973);\nconst float SIMULATION_SPEED = 8.0;\n\n\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 randomVec2(in float i, in float j) {\n    return vec2(i, j) + hash22(vec2(i, j));   \n}\n\nfloat worley(in vec2 uv, float scale)\n{\n    vec2 ij = floor(uv / scale);\n    \n    float minDist = 2.0;\n    \n    for(float x=-1.0;x<=1.0;x+=1.0) {\n        for(float y=-1.0;y<=1.0;y+=1.0) {\n        \tfloat d = length(randomVec2(ij.x+x, ij.y+y)*scale - uv);\n            minDist = min(minDist, d);\n        }\n\t}\n\n    return 1.0 - minDist / scale;\n}\n\nfloat anim(float a, float p) {\n\treturn (cos(iTime*6.283/p) * 0.5 + 0.5) * a;\n}\n\nfloat cloud(in vec2 uv) {\n\n    float t = iTime * SIMULATION_SPEED;\n\tvec2 uv1 = uv + t*0.01;\n\tvec2 uv2 = uv + vec2(t*0.01, t*0.0025);    \n    \n    float col[] = float[] ( worley(uv1, 0.1) * 0.00 + anim(0.05, 10.0),\n    \t\t\t\t\t\tworley(uv1, 0.2) * 0.15,\n\t\t\t\t\t\t\tworley(uv1, 0.4) * 0.2 + anim(0.25, 10.0),\n\t\t\t\t\t\t\tworley(uv1, 1.0) * 0.7,            \n\t\t\t\t\t\t\tworley(uv2, 0.1) * 0.05,\n\t\t\t\t\t\t\tworley(uv2, 0.2) * 0.15,    \n\t\t\t\t\t\t\tworley(uv2, 0.4) * 0.2 - anim(0.5, 25.0),        \n\t\t\t\t\t\t\tworley(uv2, 1.0) * 0.7);            \n\n    float layer1 = 0.0;\n    float layer2 = 0.0;    \n    \n    for(int l=0; l<4; l++) {\n    \tlayer1 += col[l];\n    }\n\n    for(int l=4; l<8; l++) {\n    \tlayer2 += col[l];\n    }\n    \n    float test1 = col[1]*5.0;\n    float test2 = col[2]*3.;    \n    \n//    return test1;\n//    return test2;    \n//    return (test1 + test2)*0.5;    \n    \n    \n    \n    return pow(mix(layer1, layer2, 0.5), 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    float cloudval = pow(cloud(uv), 1.0);\n    \n    //pseudo lighting attempt\n    vec3 light = normalize(vec3(1,-1,1)); //light = vec3(0,0,1);\n    \n    vec3 slope = vec3(1, -1, 0) * 0.12;\n    \n    float px1 = cloud(uv + slope.yz);\n    float px2 = cloud(uv + slope.xz);\n    float py1 = cloud(uv + slope.zy);\n    float py2 = cloud(uv + slope.zx);\n    \n    vec3 pseudo_normal = normalize(vec3(px2 - px1, py2 - py1, -0.1));\n    \n    float lighting = dot(pseudo_normal, -light); //  lighting=1.;\n    \n    vec3 color = mix(SKYCOLOR, CLOUDCOLOR * lighting, cloudval);\n    \n    fragColor = vec4(color, 1.0);  \n}","name":"Image","description":"","type":"image"}]}