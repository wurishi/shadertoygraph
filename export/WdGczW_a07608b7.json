{"ver":"0.1","info":{"id":"WdGczW","date":"1602266413","viewed":64,"name":"Ray March - Learn from Tutorial2","username":"ferrazrx","description":"ray","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 1000.\n#define MAX_STEP 1000\n#define MIN_DIST 0.01\n\n// Merge Meshes\nfloat smoothmin(float a, float b, float k){ \n    float h = max(k-abs(a-b),0.)/k; \n    return min(a,b) - h*h*h*k*1./6.0;\n}\n\nfloat Sphere(vec3 point,vec3 position, float radius){\n    return length(point - position) -  radius;\n}\n\nfloat Plane(vec3 p){\n\treturn p.y;\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat GetDist(vec3 p){\n    float sphere = Sphere(p, vec3(0., 1., 5.), 1.);  \n    float capsule = Capsule(p, vec3(0.,.7, 7.5), vec3(0.,.7,2.5), .3);\n    \n    float plane = Plane(p);\n    \n    float m = max(sphere, capsule * -1.);\n    return smoothmin(plane,m, 2.);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n\tfloat distanceOrigin = 0.;\n    \n    for(int i = 0; i<MAX_STEP; i++){\n    \tvec3 p = ro + rd * distanceOrigin;\n        float d = GetDist(p);\n        distanceOrigin += d;\n        if(d < MIN_DIST) break;\n        if(distanceOrigin > MAX_DIST) break;\n    }\n        \n    return distanceOrigin;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n\tvec2 e = vec2(0.01, 0.);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n    \n}\n\nfloat getLight(vec3 p, vec3 lightPos){\n \t\n    vec3 lp = lightPos - p;\n    vec3 l = normalize(lp);\n    vec3 n = GetNormal(p);\n     \n    float shadow = RayMarch(p + n * 0.05, l);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    \n    if(shadow < length(lp)) {\n    \tdif *= 0.6;\n    };\n        \n        \n    \n    return dif;\n}\n\nvec3 triplanarMap(vec3 surfacePos)\n{\n    vec3 normal =  GetNormal(surfacePos);\n    // Take projections along 3 axes, sample texture values from each projection, and stack into a matrix\n    mat3 triMapSamples = mat3(\n        texture(iChannel0, surfacePos.yz).rgb,\n        texture(iChannel0, surfacePos.xz).rgb,\n        texture(iChannel0, surfacePos.xy).rgb\n        );\n \n    // Weight three samples by absolute value of normal components\n    return triMapSamples * abs(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.);\n   \n    vec3 ro = vec3(sin(iTime), 2.5, -2. * cos(iTime));\n    vec3 lookat = vec3(0., 1., 5.);\n    float zoom = 1.;\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n    vec3 up = normalize(cross(forward, right));\n    vec3 center = ro + forward * zoom;\n                        \n    vec3 i = center + uv.x * right + uv.y * up;\n    vec3 rd = normalize(i - ro);\n    \n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 lightPos = vec3(sin(iTime * 3.) * 8., 8., 5. + cos(iTime * 3.)* 9.);\n    vec3 lightPos1 = vec3(sin(iTime * 4.) * 9., 8., 5. + cos(iTime * 4.)* 10.);\n    \n   \tfloat dif = getLight(p, lightPos);\n   \n    vec3 LDirectional = vec3(0.9, 0.9, 0.9) * dif;\n\tvec3 LAmbient = vec3(.01, .01, .01);\n    float textureFreq = 0.1;\n    vec3 surfaceCol = triplanarMap(p);\n    \n\tcol = surfaceCol * (LDirectional + LAmbient);\n    \n    \n    //Gamma Correction\n    col = pow(col, vec3(0.4545));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}