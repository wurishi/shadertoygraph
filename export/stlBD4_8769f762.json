{"ver":"0.1","info":{"id":"stlBD4","date":"1650919200","viewed":485,"name":"Mushroom [322 bytes]","username":"Xor","description":"Another little piece of shader art","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["golf","twigl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Tweet: https://twitter.com/XorDev/status/1518681953872064514\n//Twigl: https://t.co/BVcKVKeqMv\n\n//<512 Chars playlist: shadertoy.com/playlist/N3SyzR\n\n//Macro for \"length\" because it's used 5 times!\n#define L length\n\n//FabriceNeyret2 helped save 10 chars.\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Raymarch loop\n    for(\n            //Resolution for scaling\n            vec3 r = iResolution, \n            //Ray direction\n            d = (r-vec3(I+I,r.y)).yxz/r.y,\n            //Starting position (approx. vec3(0,0,3))\n            p = 3./r,\n            //Rotation vector\n            q;\n\n            //Iterate 200 times\n            r.z++ < 2e2;\n\n            //March forward using warped sphere SDF (stalk and cap respectively)\n            p += d*min(L(vec3(q.yz,.9+.2*q/(q-2.))),\n                 L(vec3(q.yz*.5,L(q)-2.5-q+q*q.y*.1))) - d\n        )\n        \n        //Rotate sample point\n        q = p,\n        q.yz *= mat2(cos(iTime*.2-vec4(0,11,33,0))),\n        //Output color based on distance, with spots and back glow.\n        O = vec4(1,3,8,0) * max((3.-L(p))/clamp(L(mod(q,.3)*1e2-9.),7.,9.), .1/dot(d,d));\n}\n\n///319 char version:\n/*\n//Macro for \"length\" because it's used 5 times!\n#define L length(vec3\n\n//FabriceNeyret2 helped save 10 chars.\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Raymarch loop\n    for(\n            //Resolution for scaling\n            vec3 r = iResolution, \n            //Ray direction\n            d = (r-vec3(I+I,r.y)).yxz/r.y,\n            //Starting position (approx. vec3(0,0,3))\n            p = 3./r,\n            //Rotation vector\n            q;\n\n            //Iterate 200 times\n            r.z++ < 2e2;\n\n            //March forward using warped sphere SDF (stalk and cap respectively)\n            p += d*min(L(q.yz,.9+.2*q/(q-2.))),\n                 L(q.yz*.5,L(q))-2.5-q+q*q.y*.1))) - d\n        )\n        \n        //Rotate sample point\n        q = p,\n        q.yz *= mat2(cos(iTime*.2-vec4(0,11,33,0))),\n        //Output color based on distance, with spots and back glow.\n        O = vec4(1,3,8,0) * max((3.-L(p)))/clamp(L(9)-mod(q,.3)*1e2),7.,9.), .1/dot(d,d));\n}\n*/\n\n///Original Version [335 chars]\n/*\n#define L length\n\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Resolution for scaling\n    vec3 r = iResolution, \n    //Ray direction\n    d=vec3(I+I,0)-r.xyy,\n    //Starting position (approx. vec3(0,0,3))\n    p=3./r,\n    //Rotation vector\n    q,\n    //Iteration variable for loop\n    i=r;\n    \n    //Divide ray by length and iterate.\n    for(d/=r.y; i.z++<2e2;\n    //March forward using warped sphere SDF (stalk and cap respectively)\n    p += d*min(L(vec3(.9+.2*q.y/(q.y+2.),q.xz)),\n    L(vec3(q.y-2.5+L(q)+q.x*q.y*.1,q.xz*.5)))-d )\n        //Rotate sample point\n        q = p,\n        q.xz *= mat2(cos(iTime*.2+vec4(0,11,33,0)));\n    \n    //Output color based on distance, with spots and back glow.\n    O = vec4(1,3,7,0)*max((3.-L(p))/clamp(L(mod(q,.3)/.1-.9),.7,1.)*.1,.1/dot(d,d));\n}\n*/","name":"Image","description":"","type":"image"}]}