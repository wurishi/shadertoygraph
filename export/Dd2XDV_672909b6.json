{"ver":"0.1","info":{"id":"Dd2XDV","date":"1670927650","viewed":158,"name":"Reflected Worlds","username":"scry","description":":)","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\n#define time iTime*0.1\n#define pi acos(-1.)\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvec3 cpos() {\n    vec3 c = vec3(0.);\n    c.z -= 4.;\n    c.y += 0.3;\n    c.xz *= r2d(time*0.05);\n    return c;\n}\n\nmat4 eye() {\n    vec3 c = cpos();\n    vec3 l = vec3(0.);\n    vec3 f = normalize(l-c);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,r);\n    return mat4(r,0.,u,0.,f,0.,vec3(0.),1.);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = a-b;\n    return 0.5*((a+b)-sqrt(h*h+k));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    p += cpos();\n    vec3 op = p;\n    \n    p.y -= 0.02;\n    p.yz *= r2d(time*0.01);\n    p.xz = abs(p.xz)-0.6;\n    p.xz = abs(p.xz)-0.6;\n    float d = length(p)-.3;\n    p = op;\n    float f = 2.;\n    float a = 3.;\n    for (int i=0;i<4;i++) {\n        p.xz += sin(p.zx*r2d(deg*45.))*0.3;\n        p.y += sin(p.x*f)*sin(p.z*f)*0.1*a;\n        a *= 0.065;\n        f *= 6.;\n    }\n    p.y += sin(p.x*12.)*sin(p.z*12.)*0.01;\n    d = smin(d,p.y+0.3,0.002);\n    d = min(d,-p.y+1.);\n    //d = min(d,p.y+0.3);\n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(map(p-h.xyy).w-map(p+h.xyy).w,\n    map(p-h.yxy).w-map(p+h.yxy).w,\n    map(p-h.yyx).w-map(p+h.yyx).w));\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<423;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 10000. || dS< 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 sh(vec3 p, vec3 n, vec3 l, vec3 rd) {\n    l -= cpos();\n    l = (inverse(eye())*vec4(l,1.)).xyz;\n    vec3 ld = normalize(l-p);\n    float s = 0.;\n    float dif = clamp(dot(ld,-n),0.,1.);\n    float d = RM(p-n*0.003,ld).x;\n    if (length(l-p) < d) {s = 1.;}\n    vec3 r = reflect(ld,n);\n    vec3 v = rd;\n    float a = 10.;\n    float k = 0.9;\n    float sp = clamp(pow(dot(r,v),a)*k,0.,1.);\n    return vec3(dif,s,sp);\n}\n\nvec3 colo(vec3 p, vec3 n, vec3 ro, vec3 rd, vec2 d) {\n    vec3 col = vec3(0.);\n    //float ebg = exp(-.01*d.x);\n    vec3 ebg = exp(-.05*d.x*vec3(1.,2.,4.));\n    vec3 bg = vec3(0.12,0.12,0.12);\n    vec3 l = vec3(0.,0.8,0.5);\n    vec3 s = sh(p,n,l,rd);\n    //bg.g += sin(rd.z*30)*0.04;\n    //col += 1.-d.x*0.1;\n    vec3 tc = sin(vec3(1.,2.,3.)+p.z*210.+time*10.)*0.5+0.1;\n    //col += tc;\n    tc = mix(tc,sin(p.xxx),0.5);\n    col += s.x*s.y*tc+s.z*tc*1.;\n    col *= 1.4;\n    //col += sin(vec3(1.,2.,3.)*0.5+d.y*1.+p.y*6.+2.);\n    col -= 0.1;\n    //col += sin(col*4.+vec3(1.,2.,3.)+2.)*0.5+0.5;\n    col = clamp(col,0.,1.);\n    col = col*ebg+(bg*(1.-ebg));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 bak = texture(iChannel0,tv).rgb;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    float c = length(uv);\n    //uv.y -= 0.;\n    \n    vec3 rd = normalize(vec3(uv,5.-pow(c,2.)*5.));\n    rd.zy *= r2d(deg*1.);\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col += colo(p,n,ro,rd,d);\n    vec2 od = d;\n    float td = d.x;\n    for (int i=0;i<4;i++) {\n        ro = p-n*0.003;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        td += d.x;\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,ro,rd,vec2(td,d.y));\n    }\n    col /= 1.1;\n    col -= 0.28;\n    //col += slogo(tv,ar,10.)/4.;\n    col = clamp(col,0.,1.);\n    col = mix(col,bak,0.85);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}