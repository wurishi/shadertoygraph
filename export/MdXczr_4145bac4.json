{"ver":"0.1","info":{"id":"MdXczr","date":"1497059932","viewed":265,"name":"Checker Test","username":"Chris","description":"Use mouse to compare.\nAA == 1\n   LEFT:  checkersFiltered -- https://www.shadertoy.com/view/XlcSz2\n   RIGHT:  checkersTest\n\nAA > 1\n   LEFT:  super-sampled (AA *AA)\n   RIGHT:  checkersTest\n\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// (Poorly) approximated antialiasing of a checkerboard pattern\n\n// Mostly copy pasted code from http://http.developer.nvidia.com/GPUGems/gpugems_ch25.html\n// See also this for a proper (and expensive) general filtering approach for procedural\n// textures: https://www.shadertoy.com/view/MdjGR1\n\n//===============================================================================================\n\n\n// Change AA to 11 or so (which is 11^2=121 samples per pixel) to see something closer to the ground truth\n\n#define AA 1\n\n\n//===============================================================================================\n\n\nvec2 integral( vec2 x )  //          __/\n{                        //       __/\n    x /= 2.0;            //    __/\n                         // __/\n    \n    return floor(x) + max( 2.0*fract(x)-1.0, 0.0);\n}\n\nfloat checkersFiltered( in vec2 p )\n{\n  vec2 fw = max(abs(dFdx(p)), abs(dFdy(p))); \n  float w = max(fw.x, fw.y);      // filter size\n    \n  //vec2 w = fwidth(p);           // filter size, same as abs(dFdx(p))+abs(dFdy(p))\n\n  vec2 i = (integral(p+0.5*w) -   // definite integral\n            integral(p-0.5*w));\n  i /= w;                         // average\n    \n  return i.x + i.y - 2.0*i.x*i.y; // xor pattern\n}\n\n\nfloat checkersRaw( in vec2 p )\n{\n    vec2 q = floor(p);\n    \n    return mod( q.x+q.y, 2.0 );\n    \n    //vec2 i = mod(q,2.0);\n    //return i.x + i.y - 2.0*i.x*i.y; // xor pattern\n}\n\n\n//===============================================================================================\n\n\nfloat checkersSin( in vec2 p )\n{  \n    p.x += 1.0;\n    \n    vec4 derivatives=\n        vec4(\n            dFdx(p),\n            dFdy(p)\n        );\n\n    vec2 duv_length=\n        vec2(\n            \tsqrt(dot(derivatives.xz, derivatives.xz)),\n                sqrt(dot(derivatives.yw, derivatives.yw))\n            );\n\n    float freq= 0.5;\n    float tweak= 0.5;\n        \n    vec2 checker= sin(p * freq * 2.0 * 3.1415926535);\n    \n    vec2 scale= tweak / duv_length;\n    \n    vec2 alpha= clamp(checker * scale, -1.0, 1.0);\n\n    return clamp(0.5 + 0.5 * alpha.x * alpha.y, 0.0, 1.0);\n}\n\n\nfloat checkersTest( in vec2 p )\n{  \n    p.x += 1.0;\n    \n    vec4 derivatives=\n        vec4(\n            dFdx(p),\n            dFdy(p)\n        );\n\n    vec2 duv_length=\n        vec2(\n            \tsqrt(dot(derivatives.xz, derivatives.xz)),\n                sqrt(dot(derivatives.yw, derivatives.yw))\n            );\n\n    float freq= 0.5;\n    float tweak= 0.5;\n        \n    vec2 checker= sin(p * freq * 2.0 * 3.1415926535);\n//    vec2 checker= 4.0 * abs(fract(p * freq) - 0.5) - 1.0;\n    \n    vec2 scale= tweak / duv_length;\n    \n    float dependency = sqrt(clamp(1.3f - length(duv_length), 0.0, 1.0));\n    \n    vec2 alpha= clamp(checker * scale, -1.0, 1.0);\n\n    return clamp(0.5 + 0.5 * alpha.x * alpha.y * dependency, 0.0, 1.0);\n}\n\n\nfloat checkers( in vec2 p )\n{\n    p.y += 1.5;\n    p.x += 0.5;\n        \n    vec4 derivatives=\n        vec4(\n            dFdx(p),\n            dFdy(p)\n        );\n\n    vec2 duv_length=\n        vec2(\n            \tsqrt(dot(derivatives.xz, derivatives.xz)),\n                sqrt(dot(derivatives.yw, derivatives.yw))\n            );\n\n    float freq= 0.5;\n    float tweak= 0.7;\n    \n    vec2 checker= 4.0 * abs(fract(p * freq) - 0.5) - 1.0;\n        \n    vec2 scale= tweak / duv_length;\n    \n    vec2 alpha= clamp(checker * scale, -1.0, 1.0);\n\n    return clamp(0.5 + 0.5 * alpha.x * alpha.y, 0.0, 1.0);\n}\n\n//===============================================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = 0.07*iTime;\n    float he = 0.8*smoothstep(-0.5,0.5,sin(iTime));\n    vec3 ro = vec3( cos(an), he, sin(an) );\n    vec3 ta = vec3( 0.0, he, 0.0 );\n    float cr = 0.2*cos(0.11*iTime);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // render\n    float accum = 0.0;\n    #if AA>1\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    #endif\n    {\n    #if AA>1\n        vec2 o = vec2( float(i), float(j) )/float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    #else\n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t#endif        \n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace horizontal planes at y=+-1\n        float h1 = (-1.0-ro.y)/rd.y;\n        float h2 = ( 1.0-ro.y)/rd.y;\n        float h = max( h1, h2 );\n        vec3 pos = ro + h*rd;\n\n        // texture\n        vec2 uv = 3.0*pos.xz;\n        #if AA==1\n        float f = checkersFiltered( uv );\n\t\t#else\n        float f = checkersRaw( uv );\n        #endif\n        \n        accum += f;\n    }\n    accum /= float(AA*AA);\n    \n    {\n      \tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        \n\t\t// create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace horizontal planes at y=+-1\n        float h1 = (-1.0-ro.y)/rd.y;\n        float h2 = ( 1.0-ro.y)/rd.y;\n        float h = max( h1, h2 );\n        vec3 pos = ro + h*rd;\n\n        // texture\n        vec2 uv = 3.0*pos.xz;\n\n    \taccum = (fragCoord.x < iMouse.x) ?\n\t        \t\taccum : checkersTest( uv );\n\t        \n        // fog\n    \taccum *= exp(-0.02*h);\n    }\n\n        \n    vec3 col = vec3(accum, accum, accum);\n    \n    // separation bar\n    col *= smoothstep( 2.0, 3.0, abs(fragCoord.x-iMouse.x) );\n\n    // approximate srgb gamma correction\n    col.x= pow(col.x, 1.0/2.2);\n    col.y= pow(col.y, 1.0/2.2);\n    col.z= pow(col.z, 1.0/2.2);\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}