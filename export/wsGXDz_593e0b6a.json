{"ver":"0.1","info":{"id":"wsGXDz","date":"1597933913","viewed":105,"name":"selfmade raymarching template","username":"Jarazz","description":"Basics for raymarching scene, not made with a direct guide though, so probably not A+ quality\n\nRaymarching tutorial by \"The Art of Code\" has the proper setup","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" \n//fancy struct from https://www.shadertoy.com/view/4t2cR1 (who probably has it from somewhere else)\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n\n     \n //preset variables\n   \tvec3 camPos = vec3(0,1,-4);\n   \tvec3 viewDir = vec3(0,-.2,1);\n    vec3 camUp = vec3(0,1,0);\n    vec3 camRight = vec3(1,0,0);\t//for more complex up and right vectors use: normalize(cross(camUp,viewDir));\n    float camSize = 1.;\n    float zoom = 2.;\n    \n \n  \n\n//helper functions:\n \n    \n    \n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nvec3 smin( vec3 a, vec3 b)\n{  \n    return vec3(smin(a.x,b.x,0.1),smin(a.y,b.y,0.1),smin(a.z,b.z,0.1));\n}\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\n\n\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 1.-(--f)*f*f*f*-f;\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) //https://iquilezles.org/articles/distfunctions\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 x, float sphereSize, vec3 spherePos)\n{\n    return length(x-spherePos)-sphereSize;\n    }\n\nfloat boxSDF( vec3 p, vec3 b ) //https://iquilezles.org/articles/distfunctions\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sceneSDF(vec3 pos)\n{ \n    float torus =  sdTorus(pos+vec3(0.,sin(iTime)*2.-2.,0), vec2(2.,.25));\n     \n    \n    \n    \n    vec3 boxPos = vec3(sin(iTime)+1.5,sin(iTime)+2.,0);\n    \n     float box = boxSDF(boxPos+pos,vec3(1.5,.5,.1) );\n    float sphere =sphereSDF(pos,  1.5 , vec3(1,-3,1) );\n    \n    float tmp = smin( sphere , box,1.4); \n     tmp = min(tmp, torus);\n\treturn tmp;\n}\n\n\n\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 estimateNormal(vec3 p) {\n    float EPSILON =5.0001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat calcLighting(vec3 p, vec3 lightPos, float brightness) {\n   vec3 n = estimateNormal(p);\n    vec3 l = normalize(lightPos-p)*brightness;\n    return max(0.,dot(n,l)); //standard cheap n.l lighting\n}\n\nfloat calcLighting(vec3 p) {\n    vec3 lightPos = vec3(10,10,2);\n    float brightness = 1.;\n    return calcLighting(p, lightPos, brightness);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 uvOffset = uv.x*camSize * camRight + uv.y*camSize*camUp; //the position of the pixel relative to the camera \n    vec3 pixelPos = camPos + uvOffset;\n    vec3 pixelForward = normalize( viewDir+uvOffset*zoom) ; // changes the cam from orthographic to perspective\n    \n    \n    \n    //Raymarch loop:\n    int maxIterations = 200;\n\tfloat maxStepDist = 11.;\n\tfloat hitDist = .03;\n    float dist;\n    float closestCall=9999999.;\n    int i = 0; \n    for(;i < maxIterations; i++){\n     \n        dist = sceneSDF(pixelPos);\n        closestCall = min(closestCall,dist);\n    \tif(dist<hitDist) break;\n        pixelPos+=  pixelForward*min(maxStepDist,dist);\n    \n    }\n   \n    \n    \n    \n    \n    vec3 col;//vec3(0.5 + 0.5*pixelPos/50., 0., 0.);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    \n    \n    //if we hit something:\n   // if(dist<hitDist){  }\n    \n    \n        float light = calcLighting(pixelPos) + calcLighting(pixelPos, vec3(-22.*sin(iTime),-22.*cos(3.1415*iTime),100.+222.*cos(0.521415*iTime)),1.);\n        //float light = calcLighting(pixelPos, vec3(0,0,0),1.);\n                         \n        float red = (-float(i)/float(maxIterations-1) )+(float(maxIterations)/float(maxIterations-1));\n        float blue =clamp( 1./(10.*(closestCall-hitDist)),0.,1.);   //clamp( - 4.*((closestCall/maxStepDist)-0.5)*((closestCall-hitDist)-0.5) +1.,0.,1.);\n        col = vec3( red*light, blue, 1.);\n    \n    \n    \n    \n    //col = vec3(pixelPos.z );\n    \n    \n    \n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}