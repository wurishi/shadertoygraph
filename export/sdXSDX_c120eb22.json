{"ver":"0.1","info":{"id":"sdXSDX","date":"1619556148","viewed":124,"name":"ps5_dualsense_texture","username":"skaplun","description":"shading taken from here https://www.shadertoy.com/view/MdS3Rw\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","ao","psttern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash2(vec2 p)\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nfloat pattern(vec2 input_uv)\n{\n    vec2 cntr = floor(input_uv);\n    float fin = 1.;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 nei = cntr + vec2(i, j);\n            vec2 vario = hash2(nei);\n            float id = vario.y;\n\n            vec2 offset = (vario - .5) * .5;\n            vec2 nuv = (input_uv - (nei + .5 + offset)) * 1.2;\n            float a = vario.y * PI;\n            nuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\n            //TODO make conditionless\n            if(id < .25)\n            {\n                float b = distance(0., sdBox(nuv, vec2(.5)));\n                fin = min(fin, b);\n            }\n            else if(id < .5)\n            {\n                float c = distance(0., sdEquilateralTriangle(nuv + vec2(0., -.3)));\n                fin = min(fin, c);\n            }\n            else if(id < .75)\n            {\n                float cr = sdCross(nuv, vec2(.5, .015), 0.);\n                fin = min(fin, cr);\n            }\n            else\n            {\n                float crcl = distance(0., sdCircle(nuv, .5));\n                fin = min(fin, crcl);\n            }\n        }\n    }\n    \n    return fin;\n}\n\nfloat map(vec3 p){\n    float res = p.y; \n    {\n        float ptrn = pattern(p.xz * 6.) - .1;\n        float h = pow(abs(ptrn)/.1, .5) * .005 * step(ptrn, 0.) + .01;\n        res = min(res, opExtrussion(p, ptrn, h));\n    }\n    \n    return res;\n}\n\nvec3 calculateNormals(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\nconst int max_iterations = 32;\nconst int   ao_iterations = 10;\nconst float ao_step = .01;\nconst float ao_scale = 1.1;\n\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = map( origin + dir * depth );\n\t\tif ( dist < EPS) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nfloat ao( vec3 v, vec3 n ) {\n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n\tfor ( int i = 0; i < ao_iterations; i++ ) {\n\t\tsum += (len - map( v + n * len )) * att;\n\t\tlen += ao_step;\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn max( 1.0 - sum * ao_scale, 0.0 );\n}\n\nfloat shadow( vec3 v, vec3 light ) {\n\tvec3 lv = v - light;\n\tfloat end = length( lv );\n\tlv /= end;\n\t\n\tfloat depth = ray_marching( light, lv, 0.0, end );\n\t\n\treturn step( end - depth, 0.02 );\n}\n\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tvec3 final = vec3(0.0);\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t{\n\t\tvec3 light_pos   = vec3(10. * sin(iTime), 5., 10. * cos(iTime));\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, 12.0 );\n\t\t\n\t\tfinal += vec3( 1. ) * ( diffuse * 0.4 + specular * .5) * shadow( v, light_pos ); \n\t}\n\t\n\tfinal += ao( v, n ) * vec3( 0.5 );\n\t\n\treturn final;\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01 / 3.1415;\n    vec3 origin = vec3(2. * cos(ang), 1., 2. * sin(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    \n    float minD = (.0151 - camRay.origin.y)/camRay.dir.y;\n    float maxD = (-camRay.origin.y)/camRay.dir.y;\n    \n    float dist = ray_marching(origin, dir, minD, maxD);\n    \n    if(dist <= 0.)\n    {\n        return vec3(0., 1., 1.);\n    }\n    else\n    {\n        vec3 p = camRay.origin + camRay.dir * dist;\n        vec3 nrm = calculateNormals(p);\n        return shading(p, nrm, camRay.origin);\n    }\n    \n}\n\n//suicide\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n\nconst float PI = acos(-1.); \nconst float EPS = 1e-3;\n\nstruct Ray{ vec3 origin, dir;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - .5;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    \n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdCircle(in vec2 p, in float r) \n{\n    return length(p)-r;\n}\n","name":"Common","description":"","type":"common"}]}