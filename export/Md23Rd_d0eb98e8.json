{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Simple Gyroid Isosurface (spherical crop)\n//\n// Mikael Hvidtfeldt Christensen\n// @SyntopiaDK\n//\n// License:\n// Creative Commons Attribution\n// http://creativecommons.org/licenses/by/3.0/\n\n\n#define MaxSteps 60\n#define MinimumDistance 0.01\n#define normalDistance     0.0002\n#define PI 3.141592\n#define FieldOfView 1.0\n#define FudgeFactor 0.8\n\n#define Ambient 0.35\n#define Diffuse 0.4\n#define Specular 0.08\n#define LightDir vec3(1.0,1.0,-0.65048)\n#define LightColor vec3(1.0,0.666667,0.6)\n#define LightDir2 vec3(1.0,-0.62886,1.0)\n#define LightColor2 vec3(0.9,0.8,1.0)\n\nfloat time;\nfloat scale;\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light source + env light\nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir, int mat) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat specular = pow(max(0.0,dot(lightDir,-reflect(lightDir, normal))),20.0); // Phong\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat specular2 = pow(max(0.0,dot(lightDir2,-reflect(lightDir2, normal))),20.0); // Phong\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\tfloat a = pow(abs(dot(normal,dir)),2.0);\n\tvec3 l = vec3(0.0);\n\t\t\n\tif (mat < 2) { \n\t\tl+=(Specular*specular)*LightColor+(diffuse*Diffuse)*(LightColor*color) +\n\t\t(Specular*specular2)*LightColor2+(diffuse2*Diffuse)*(LightColor2*color);\n\t\tl+=texture(iChannel0, reflect(dir, normal)).xyz*Specular;\n\t} else {\n\t\tl+= \n\t\t\t//(diffuse*0.8)*(LightColor*color) \n\t\t\t+(diffuse2*0.7)*(LightColor2*color);\n\t\t\n\t}\n\treturn l*a*1.7;\n}\n\n\n\nvec3 offset;\n\n\nfloat DE2(vec3 z, out int mat) { \n float sphere = abs(length(z))-15.0;\n z*= scale;\n float base = (cos(z.x) * sin(z.y) + cos(z.y) * sin(z.z) + cos(z.z) * sin(z.x));\n float inverse = -base + (1.0+cos(time/4.0))*4.0;\n if (base>inverse) {\n\t  mat = (sphere>-0.1) ? 0 : 2;\n } else {\n\t mat = (sphere>-0.1) ? 1 : 3;\n }\n return max(min(base,inverse),sphere);\n}\n\nfloat  DE(vec3 z) {\n  int i = 0;\n  return DE2(z, i);\n}\n\n\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)));\n}\n\n// Solid color with a little bit of normal :-)\nvec3 getColor(vec3 normal, vec3 pos, int material) {\n\tif (material == 0) {\n\t\treturn vec3(0.0,0.1,0.0); \n\t} else if (material == 1) {\n\t\treturn vec3(1.0,0.0,0.0); \n\t} else if (material == 2) {\n\t\treturn vec3(1.0)*length(pos)/10.0;\n\t} \n\treturn vec3(1.0)*length(pos)/10.0;\n\t\n}\n\n// Filmic tone mapping:\n// http://filmicgames.com/archives/75\nvec3 toneMap(in vec3 c) {\n\tc = c*c; // <- So much for proper gamma correction :-)\n\tvec3 x = max(vec3(0.),c-vec3(0.004));\n\tc = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n\treturn c;\n}\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = rand(fragCoord.xy+vec2(time));\n\t\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*(0.7*scale);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\tif (steps == MaxSteps-1) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep = float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.0-smoothStep/float(MaxSteps);\n\n\t// Since our distance field is not signed,\n    // backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\t\n\n\tint material = 0;\n\tDE2(pos, material);\n\t\n\tvec3 color = getColor(normal, pos, material);\t\n\tvec3 light = getLight(color, normal, dir, material);\n\treturn vec4(toneMap((color*Ambient+light)*ao),1.0);\n}\n\nfloat curve(float x) {\n\treturn cos(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    time = iTime + 38.0;\n\tscale = 0.8+(0.1*cos(time/3.0));\n    offset = vec3(1.0+0.2*(cos(time/5.7)),0.3+0.1*(cos(time/1.7)),1.).xzy;\n\n    \n\tfloat angle = time/5.0; \n\t\n\t// Camera position (eye), and camera target\n\tvec3 camPos =  19.0*vec3(1.0,0.5*curve(time*0.2),0.5*curve(7.0+0.3*time));\n\tvec3 target = vec3(0.0);\n\tvec3 camUp  = vec3(0.0,0.0,1.0);\n\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t \n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23Rd","date":"1392564390","viewed":2144,"name":"Spherical Gyroid","username":"Syntopia","description":"Periodic minimal surface, see: http://en.wikipedia.org/wiki/Gyroid\n\nVariation at: http://www.shadertoy.com/view/Ms2Gzd  ","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["gyroid"],"hasliked":0,"parentid":"","parentname":""}}