{"ver":"0.1","info":{"id":"slSXDR","date":"1627408425","viewed":93,"name":"Reflective Ball using Ray Tracin","username":"AshutoshR","description":"A simple reflective ball using Ray Tracing. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n} ray;\n\nstruct Material {\n    vec3 color;\n    float ambience;\n    float diffuse;\n    float specular;\n    float shininess;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n} sphere1;\n\nstruct Camera {\n    vec3 position;\n    float aspectRatio;\n    float screenPos;\n} camera;\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n} sunLight;\n\nvoid setupScene() {\n    sphere1.position = vec3(0 , 0 , 6);\n    sphere1.radius = 1.0;\n    \n    sphere1.material.color = vec3(0.5, 0.5, 1.0);\n    sphere1.material.ambience = 0.2;\n    sphere1.material.diffuse = 0.5;\n    sphere1.material.specular = 0.95;\n    sphere1.material.shininess = 25.;\n    \n    camera.position = vec3(0 , 0 , -3);\n    camera.screenPos = 1.;\n    camera.aspectRatio = iResolution.x / iResolution.y;\n    \n    sunLight.direction = normalize(vec3(-0.5 , -0.5 , 0.8));\n    sunLight.color = vec3(1.);\n}\n\nbool checkIntersect(Sphere sphere, out float p1, out float p2) {\n    vec3 oc = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, oc);\n    float c = dot(oc,oc) - pow(sphere.radius, 2.0);\n    \n    float d = pow(b, 2.0) - (4.0 * a *c);\n    if (d < 0.0) {\n        return false;\n    }\n    if (d == 0.0) {\n        p1 = p2 = -b / 2.0 * a;\n        return true;\n    }\n    if (d > 0.0) {\n       p1 = (-b - sqrt(d)) / 2.0 * a;\n       p2 = (-b + sqrt(d)) / 2.0 * a;\n       return true;\n    }\n}\n\nvec3 calculateSunLight(Sphere sphere, vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 invlDir = sunLight.direction;\n    float intensity = max(-dot(invlDir, sphereNormal), 0.);\n    return vec3(1) * intensity;\n}\n\nvec3 calculateShininess(Sphere sphere, vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 viewDirection = normalize(camera.position - hitPoint);\n    \n    vec3 refLight = normalize(reflect(sunLight.direction, sphereNormal));\n    \n    float intensity = max(0.,dot(viewDirection, refLight));\n    \n    float shininess = pow(intensity, sphere1.material.shininess);\n    \n    return shininess * sunLight.color;\n}\n\nvec3 calculateReflectivity(Sphere sphere, vec3 dir, vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n\n    vec3 refDir = reflect(dir, sphereNormal);\n    vec3 refCol = texture(iChannel0, refDir).rgb;\n    return refCol;\n}\n\n\nvec3 rayTrace(vec3 dir) {\n    float p1 , p2;\n    if(checkIntersect(sphere1, p1, p2)) {\n        float p = p1;\n        if (p2 < p) {\n            p = p2;\n        }\n        vec3 hitPoint = ray.origin + (dir * p);\n        vec3 refCol = calculateReflectivity(sphere1, dir, hitPoint);\n        sphere1.material.color = mix(sphere1.material.color, refCol, sphere1.material.specular);\n        \n        vec3 ambience = sphere1.material.ambience * sphere1.material.color * sunLight.color;\n        vec3 diffuse = sphere1.material.diffuse * calculateSunLight(sphere1, hitPoint) * sphere1.material.color;\n        vec3 specular = sphere1.material.specular * calculateShininess(sphere1, hitPoint) * sphere1.material.color;\n        \n        return ambience + diffuse + specular;\n    } else {\n        vec3 col = texture(iChannel0, dir).rgb;\n        return col;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n    sphere1.position.x = sin(iTime) * 2.9;\n    \n   // sunLight.direction.x = sin(iTime);\n   // sunLight.direction.y = cos(iTime);\n    \n    ///sphere1.material.shininess = sin(iTime) * 40. + 50.;\n    \n    ray.origin = camera.position;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= camera.aspectRatio;\n    \n    camera.position.z = -0.5;\n    ray.origin = camera.position;\n    ray.direction = normalize(vec3(uv, camera.screenPos) - ray.origin);\n    \n    vec3 col = rayTrace(ray.direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}