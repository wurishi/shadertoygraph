{"ver":"0.1","info":{"id":"3d3SWr","date":"1571743533","viewed":173,"name":"shader cloth","username":"MapleSyrupCS6","description":"it's like a cloth","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["maplestudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\nfloat rand(vec2 id)\n{\n    return sin(dot(id, vec2(12.9898, 78.233)) *43758.5453); \n}\n\nfloat distanceFunction(vec3 pos, float size){\n    return length(pos) - size;\n}\n\nfloat distanceFunction2( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat distanceFunction3(vec3 pos, vec3 b, float r){\n    \n    vec3 q = abs(pos) - b;\n    return length(max(q, 0.0) + min(max(q.x, max(q.y, q.z)), 0.0)) - r;\n}\n\nfloat df(vec3 p){\n    \n    float df1 = distanceFunction(p, 1.7);\n    p.x -= 5.5;\n    p.y += 0.2;\n    float df2 = distanceFunction2(p, vec2(2.0, 2.0));\n    p.x -= 5.5;\n    p.y -= 0.2;\n    float df3 = distanceFunction3(p, vec3(1.0, 1.0, 1.0), 0.5);\n    float m = min(df1, df2);\n    m = min(m ,df3);\n    return m;\n}\n\n\n\nvec3 normal(vec3 p, float size){\n    vec2 e = vec2(0.0001, 0);\n    float d  = df(p);\n    vec3 n = d- vec3(\n        df(p - e.xyy), \n        df(p - e.yxy),\n    \tdf(p - e.yyx));\n    return normalize(n);\n}\n\n\nvec3 image(vec2 uv){\n    \n    vec2 st = uv*2.0;\n    st = fract(st);\n    vec2 id = (floor(uv*2.0)+0.5)/2.0;\n    \n    float offs = rand(id)*60.;\n    float size = (1. + sin(iTime*3. + offs))*0.2;\n   \n    \n    float d = distance(st, vec2(0.5, 0.5));\n\td = step(d*sin(iTime*5.+offs), size);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 c1 = vec3(0.3, 0.5, 0.2);\n    vec3 c2 = vec3(0.7, 0.4, 0.3);\n   // col = mix(c1, c2, d);\n    col = vec3(0.2 , d, 0.4);\n    \n    return col;\n}\n\n\nvec3 image2(vec2 uv)\n{    \n    uv *= 10.0;\n    vec2 f_st = fract(uv);\n    vec2 id = uv;\n    \n\tfloat y = uv.y/abs(sin(iTime))*2.0 -cos(iTime)- sin(id.x*1.5 + iTime *PI);\n    y = smoothstep(0.05, 0.1, y);\n    \n    vec3 c1 = vec3(0.9, 0.75, 0.2);\n    vec3 c2 = vec3(0.3, 0.9, 0.9);\n    vec3 col = mix(c2, c1, y);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 CameraPos = vec3(5.5, 0, -15.);\n    float screenZ = 2.5;\n    vec3 RayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -10.));\n    vec3 lightDir2 = normalize(vec3(3.0, 1.0, -100.));\n    vec3 lightDir3 = normalize(vec3(-3.0, 1.0, -100.));\n    \n    //float size = abs(sin(iTime*2.))*2.;\n    float depth = 0.0;\n    float dist = 0.0;\n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 99; i++){\n     \trayPos = CameraPos + (RayDir * depth);   \n        dist = df(rayPos);\n        \n        if(dist < 0.0001) break;\n        \n        depth += dist;     \n    }\n    \n    \n    if(dist < 0.0001){\n     \t\n        vec3 n = normal(rayPos, 2.0);\n        float diff = dot(n, lightDir2+lightDir3);\n        vec3 c1 = vec3(0.5, 0.3, 0.2);\n        vec3 c2 = vec3(0.7, 0.9, 0.4);\n        vec3 im = image2(uv);\n        float d = rand(uv);\n        col = mix(c1, im, d);\n    }else{\n        float d = rand(uv);\n        vec3 cb = vec3(0.9, 0.2, 0.3);\n        vec3 cbr = vec3(0.4, 0.5, 0.8);\n     \tcol = mix(cb, cbr, d);  \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}