{"ver":"0.1","info":{"id":"ll23WG","date":"1432135371","viewed":149,"name":"Ray Tracing Experiment","username":"TheJimJames40","description":"random stuff","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","test","raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define time (iTime/2.)\n#define pi 3.141592\n\nfloat sphere(vec3 p, float d){\n    return length(p)-d;\n}\n\nfloat box( vec3 p, vec3 size )\n{\n  return length(max(abs(p)-size,0.0));\n}\n\n\nfloat rotBox(vec3 p, float t) {\n    p -= vec3(sin(t)*4.,sin(t)*3.,cos(t*3.)*4.);\n    return sphere(p,1.);\n}\n\nfloat scene(vec3 p){\n    float v = 1000.;\n   \n   // v = min(v,p.y+8.);\n   // v = min(v,-(p.z-8.));\n    // p +=     vec3(10,10,4);\n    vec3 c = vec3(20,20,20);\n    \n    v = min(v,box(p, vec3(1.)));\n    \n    for(int i = 1; i <= 4; i++){\n   \t\tv = min(v,rotBox(p,time+float(i)/4.*pi*2.));\n    }\n    return v;\n}\n\n\nfloat distFloor(vec3 p){\n    return abs(sphere(p,10.));\n}\n\nvec3 dist2Color(float d){\n    float v = sin(d*5.)/2.+0.5;\n    v = smoothstep(0.,1.,v*10.-9.);\n\treturn vec3(1.) * v;\n}\n\nvec4 dist(vec3 p){\n    float s = scene(p);\n    float f = distFloor(p);\n    if(f < s){\n    \treturn vec4(dist2Color(s),f);\n    }else{\n    \treturn vec4(vec3(1.,1.,1.),scene(p));\n    }\n}\n\nvec3 iter(vec3 p, vec3 dir){\n    vec3 v   = dir;\n    vec3 pos = p;\n    float depth = 0.;\n    for (int i = 0; i < 64; i++){\n        vec4 d = dist(pos);\n        if(abs(d.w) < 0.00001){\n        \treturn d.xyz/(float(i)/4.);\n        }\n        pos   += v*d.w;\n        depth += d.w;\n    }\n    return vec3(0.);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x * 4.;\n    \n    float angle =  (iMouse.x/iResolution.x-0.5) * 2.  * pi;\n    float angle2 = (iMouse.y/iResolution.y-0.5) * 0.8 * pi;\n    vec3 pos = vec3(0.,1.,10.);\n    \n    mat4 mat = rotationMatrix(vec3(0.,1.,0.),angle)*rotationMatrix(vec3(1.,0.,0.),angle2);\n    \n    vec3 dir = normalize((mat * vec4(uv,2.,1.)).xyz);\n    \n\tpos = (mat*vec4(0.,0.,-8.,0.)).xyz;\n    \n\tfragColor = vec4(iter(pos, dir),1.0);\n}","name":"Image","description":"","type":"image"}]}