{"ver":"0.1","info":{"id":"csdSRN","date":"1680784528","viewed":78,"name":"Projet 3D Web Benjamin Pin","username":"BenjaminPin","description":"3D WEB","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// La fonction mainImage est la fonction principale du shader qui va calculer la couleur de chaque pixel.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n    // On calcule le ratio de l'aspect de l'écran pour corriger la distorsion d'image.\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // On crée un rayon pour chaque pixel qui part de la caméra et qui passe par le pixel.\n    // La direction du rayon est calculée en fonction des coordonnées normalisées du pixel.\n    float time = iTime * 0.2;\n    vec3 cameraPos = vec3(3.0 * sin(time), 1.5, 3.0 * cos(time));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraPos);\n    vec3 cameraRight = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraPlaneUp = cross(cameraDir, cameraRight);\n    vec3 rayDir = normalize(cameraDir + uv.x * cameraRight + uv.y * cameraPlaneUp);\n    \n    // On initialise la position de départ du rayon à la position de la caméra.\n    // On va ensuite avancer le rayon le long de sa direction en détectant les collisions avec les objets de la scène.\n    vec3 rayOrigin = cameraPos;\n    vec3 currentPosition = rayOrigin;\n    float totalDistance = 0.0;\n    const int maxIterations = 128;\n    const float maxDistance = 100.0;\n    const float epsilon = 1e-4;\n\n    // Boucle principale du raytracing pour chaque pixel\n    for (int i = 0; i < maxIterations; i++)\n    {\n        //Animation de la position de la sphére\n        float sphereY = sin(iTime * 1.) * 0.7;\n        \n        // On calcule la distance entre la position courante du rayon et la surface de la sphère.\n        float distSphere = length(currentPosition - vec3(-1.0, sphereY, 0.0)) - 1.0;\n        \n        // On calcule la distance entre la position courante du rayon et la surface de la boîte.\n        float distBox = length(max(abs(currentPosition - vec3(1.0, 0.0, 0.0)) - vec3(0.5, 0.5, 0.5), 0.0));\n        \n        // On choisit la distance la plus petite entre les deux pour détecter la collision avec l'objet le plus proche.\n        float distance = min(distSphere, distBox);\n        \n        // On ajoute la distance de collision à la distance totale parcourue par le rayon.\n        totalDistance += distance;\n        \n        // On calcule la nouvelle position du rayon en se déplaçant dans la direction du rayon.\n        currentPosition = rayOrigin + totalDistance * rayDir;\n\n        if (distance < epsilon || totalDistance > maxDistance)\n        {\n            break;\n        }\n    }\n\n    vec3 baseColor; //Déclaration d'un vecteur 3D pour la couleur de base\n    if (totalDistance < maxDistance) //Si la distance totale est inférieure à la distance maximale\n    {\n        vec3 normal;\n        \n        //Déclaration d'une variable flottante pour la position y de la sphère\n        float sphereY = sin(iTime * 0.5) * 0.5;\n        \n        //Déclaration d'une variable flottante pour la distance entre la position actuelle et la position de la sphère\n        float distSphere = length(currentPosition - vec3(-1.0, sphereY, 0.0)) - 1.0;\n        \n        //\" et de la boîte\n        float distBox = length(max(abs(currentPosition - vec3(1.0, 0.0, 0.0)) - vec3(0.5, 0.5, 0.5), 0.0));\n        \n        //Si la distance à la sphère est inférieure à la distance à la boîte\n        if (distSphere < distBox)\n        {\n            baseColor = vec3(1.,0.1,0.1); //Couleur de base (rouge)\n            normal = normalize(currentPosition - vec3(-1.0, sphereY, 0.0));\n        }\n        else\n        {\n            baseColor = vec3(0.2, 0.2, 0.8); //Couleur de base (bleu)\n            \n            //Déclaration d'un vecteur 3D pour le gradient de la boîte\n            vec3 boxGradient = vec3(\n                (currentPosition.x - 1.0) / 1.0,\n                (currentPosition.y - 0.0) / 1.0,\n                (currentPosition.z - 0.0) / 1.0\n            );\n            normal = normalize(boxGradient);\n        }\n        \n        //Position de la lumière\n        vec3 lightPos = vec3(0.0, 10.0, -5.0);\n        //Direction de la lumière\n        vec3 lightDir = normalize(lightPos - currentPosition);\n        //Intensité de la lumière\n        float lightIntensity = max(dot(normal, lightDir), 0.3);\n        //Couleur ambiante\n        vec3 ambient = vec3(0.1, 0.1, 0.2);\n        //Couleur diffuse\n        vec3 diffuse = baseColor * lightIntensity;\n        //Couleur totale\n        vec3 color = ambient + diffuse;\n\n        // Réflexion spéculaire\n        vec3 viewDir = normalize(rayOrigin - currentPosition); //Direction de la vue\n        vec3 reflectDir = reflect(-lightDir, normal); //Direction de la réflexion\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); //Calcul de la réflexion spéculaire\n        vec3 specular = vec3(1.0, 1.0, 1.0) * spec; //Couleur de la réflexion spéculaire\n\n        //Ajout de la couleur de la réflexion spéculaire à la couleur totale\n        color += specular;\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // Background color\n        vec3 backgroundColor = vec3(0.6, 0.8, 0.3);\n        fragColor = vec4(backgroundColor, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}