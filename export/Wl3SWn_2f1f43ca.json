{"ver":"0.1","info":{"id":"Wl3SWn","date":"1580691784","viewed":319,"name":"WaterSimple","username":"JackSolace","description":"simple water drop effect using raymarching.\n\nLooks ALOT like glass as real water is noisy, often simulated.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ray","water","drop","march","reflect","refract","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Feb 2020\n//Basic Raymarch of a Water Drop using smooth min, reflections, refractions, and specularity.\n\n\n//from the Sphere example\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n//Cubic smooth minimum union function from user TinyTexel\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n//Get the Specular value (shine)\nfloat calculate_specular(in vec3 rayd, in vec3 normal, in vec3 toLight) {\n    //specular exponent\n    float shinnyness = 5.0;\n    //get the reflected light vector\n    vec3 reflected = 2.0*dot(toLight, normal)*normal - toLight;\n    //calculate specular value\n    return max(0.0,pow(dot(rayd,reflected),shinnyness));\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{\n    //chained smoothed min spheres to make a drop shape\n    float drop_dist = distance_from_sphere(p, vec3(0.0,-0.2,0.0), 0.3 );\n    drop_dist = sminCubic(drop_dist, distance_from_sphere(p, vec3(0.0,0.0,0.0), 0.17 ), 0.1);\n    drop_dist = sminCubic(drop_dist, distance_from_sphere(p, vec3(0.0,0.1,0.0), 0.12 ), 0.1);\n    drop_dist = sminCubic(drop_dist, distance_from_sphere(p, vec3(0.0,0.2,0.0), 0.08 ), 0.1);\n    drop_dist = sminCubic(drop_dist, distance_from_sphere(p, vec3(0.0,0.3,0.0), 0.05 ), 0.1);\n    drop_dist = sminCubic(drop_dist, distance_from_sphere(p, vec3(0.0,0.375,0.0), 0.035 ), 0.1);\n    return drop_dist;\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) + .07*sin(iTime*2.8+pos*60.+24.));  \n}\n\nfloat march_ray(vec3 ray_origin, vec3 ray_direction, float tmax) {\n\tfloat t = 0.0;//current depth\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        float h = map_the_world(pos);\n        //if we hit something break\n        if( h<0.0001 || t>tmax ) return t;\n        //step forward\n        t += h;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //the bulk of this comes from https://www.shadertoy.com/view/tdXGWr\n    //Ive removed the Anti-Aliasing for simplicity and performance\n    \n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color\n    vec3 total = vec3(0.0);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.0; //max march depth\n\tfloat t = march_ray(ray_origin, ray_direction, tmax);\n        \n    \n    \n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {\n        //where did it hit?\n        vec3 pos = ray_origin + t*ray_direction;\n        vec3 normal = calculate_normal(pos);\n        //get diffuse and specular at this point\n        float diffuse = clamp( dot(normal,vec3(0.5,1.0,0.0)), 0.0, 1.0 );\n        float specular = calculate_specular(ray_direction, normal,pos - vec3(0.5,1.0,0.0));\n         \n        //get reflection\n        vec3 reflect_direction = reflect(ray_direction, normal);\n         \n        //pow function is for color corretion/balancing\n        vec3 reflect_color = pow(texture(iChannel0, reflect_direction).rgb, vec3(2.2));\n\t\t//get reflract direction to prep for next ray\n        vec3 refract_direction = normalize(refract(ray_direction, normal, 1.000293/1.333));\n        t = march_ray(pos + 0.01*refract_direction, refract_direction, 2.0);\n        //light diffuse color\n\n         \n        //init refract color \n        vec3 refract_color = vec3(0.0);\n        if(t<tmax){\n            //hit within the drop\n        \tpos = pos + 0.01*refract_direction + t*refract_direction;\n        \tnormal = calculate_normal(pos);\n            //second refraction (other side of volume)\n            refract_direction = normalize(refract(refract_direction, normal, 1.333/1.000293));\n            refract_color = pow(texture(iChannel0, refract_direction).rgb, vec3(2.2));\n        }else{\n            //should never trigger but hey\n            refract_color = pow(texture(iChannel0, refract_direction).rgb, vec3(2.2));\n        }\n        //combine reflections, refractions ect...\n        color = refract_color + reflect_color*0.3 + diffuse*vec3(1.0)*0.01 + specular*vec3(1.0);\n     } else {\n        //ray missed drop\n     \tcolor =  pow(texture(iChannel0, ray_direction).rgb, vec3(2.2));\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}