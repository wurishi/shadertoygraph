{"ver":"0.1","info":{"id":"3td3DB","date":"1577461606","viewed":703,"name":"3d simplex noise sphere 2","username":"Bleuje","description":"It loops perfectly.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// Using code from : https://www.shadertoy.com/view/Xt2XDt\n// and 3D Simplex noise from https://www.shadertoy.com/view/XsX3zB\n// Got help from @tdhooper\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0006;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat TWO_PI = 2.0*3.141592;\n\nfloat sdSphere( vec3 p, float s )\n{\n  float angle = atan(p.z/p.x);\n  float rad = 1.3;\n  float offset = 1.0*angle/3.141592-2.5*p.y;\n  vec3 inp = vec3(rad*cos(TWO_PI*(iTime-offset)),rad*sin(TWO_PI*(iTime-offset)),3.0*p.y);\n  float ns =  simplex3d(inp);\n  float sph = abs(length(p)-s)-0.01;\n  float offset2 = 0.15; \n  if (sph < offset2) {\n    sph += 0.5*offset2 * ns;\n  }\n  return sph;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n\n    return vec2( sdSphere( pos - vec3( .0 , .0 , -0.4 ) , 0.75 ) , 1. ); ;\n    \n}\n\nvec3 result;\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += max(abs(h), 5.*INTERSECTION_PRECISION);\n        id = m.y;\n        result += vec3(0.0025);\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    result = vec3(0.);\n    vec3 color = vec3(0.,0.,0.);\n    for(float i=-0.25;i<=0.25;i+=0.5){\n        for(float j=-0.25;j<=0.25;j+=0.5){\n            vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(i,j)))/iResolution.y;\n\n            vec3 ro = vec3( 0., 0., 2.);\n            vec3 ta = vec3( 0. , 0. , 0. );\n\n            mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n            vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n            vec2 res = calcIntersection( ro , rd  );\n        }\n    }\n    fragColor = vec4(result,1.0);\n}\n","name":"Image","description":"","type":"image"}]}