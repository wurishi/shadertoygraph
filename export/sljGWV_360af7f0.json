{"ver":"0.1","info":{"id":"sljGWV","date":"1624793781","viewed":58,"name":"Polkadot Maze","username":"elefAntti","description":"An old maze solver & generator ported to Shadertoy and updated to use multibuffer for state.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["maze","multibuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y <= 1.0)\n    {\n        fragCoord.y = 2.0;\n    }\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define InitialPosition vec3( 0.59 * 10.0, 2.0, 0.59 * 10.0 )\n#define GridDist 0.1\n#define Scale 20.0\n#define CameraPosition vec3(0.0)\n#define AccuracyDropoff 10.0\n#define MaxCastLen 50.0\n#define VignetteStrength 0.6\n#define GammaValue 0.5\n#define HitDistance 0.001\n#define FocalLength 2.0\n#define DistanceMultiplier 0.1\n#define CameraTransform mazeCamera\n#define MainMaterial polkaDots\n#define GridDist2 1.0\n#define MagicValue vec4(1.0, 0.5, 2.0, 1.0)\n\nvec3 camera_position = vec3(0.0);\nvec3 camera_forward = vec3(0.0, 0.0, 1.0);\nfloat timeSinceUpdate = 0.0;\n#define M_PI 3.1415926535897932384626433832795\n\nfloat dist_model(vec3 pos, float my_time);\n\nfloat noise(float pos)\n{\n    //Picking the low bits, which are more random\n    return mod(sin(pos) * 10000.0, 1.0);\n}\n\nfloat noise(vec2 pos)\n{\n    //Combine x and y so that there is no visible pattern in the noise\n    //Just picking two numbers that are not multiples of each other\n    float key = pos.x * 111.0 + pos.y * 788.0;\n    return noise(key);\n}\n\nfloat noise(vec3 pos)\n{\n    float key = pos.x * 111.0 + pos.y * 788.0 + pos.z * 827.0;\n    return noise(key);\n}\n\nvec3 noise3(vec3 pos)\n{\n    float key = pos.x * 111.0 + pos.y * 788.0 + pos.z * 827.0;\n    return vec3(noise(key),\n        noise(key * 2.0 + 1.1),\n        noise(key * 1.7 + 2.2));\n}\n\nmat3 camera_rotation( vec3 look_at )\n{\n    vec3 x = vec3( look_at.z, 0, -look_at.x ); \n    vec3 y = cross( look_at, x );\n    return mat3( x, y, look_at );\n}\n\nfloat join_with_skirting(float dist_a, float dist_b, float skirting)\n{\n    return min(min(dist_a, dist_b), max(dist_a, dist_b) - skirting);\n}\n\n\n//Compute the gradient of the dist_model at pos\nvec3 gradient_model( vec3 pos, float eps, float my_time )\n{\n    return vec3(\n        dist_model( vec3( eps, 0.0, 0.0 ) + pos, my_time ),\n        dist_model( vec3( 0.0, eps, 0.0 ) + pos, my_time ),\n        dist_model( vec3( 0.0, 0.0, eps ) + pos, my_time ) )\n        - vec3( 1.0, 1.0, 1.0 ) * dist_model( pos, my_time );\n}\n\nfloat maze_dist(vec2 fixedCoord)\n{\n    fixedCoord *= mat2(1.0, 1.0, 1.0, -1.0);\n\n    vec2 coordInTile = fract( fixedCoord * 0.5 / GridDist ) - 0.5;\n    vec2 tileCoord = floor( fixedCoord * 0.5 / GridDist ); \n\n    if(noise(tileCoord) > 0.5)\n    {\n        coordInTile.x *= -1.0; \n    }\n\n    return abs(abs(coordInTile.x + coordInTile.y) - 0.5) - 0.1;\n}\n\nfloat dist_model(vec3 pos, float time)\n{\n    float maze_distance = min(3.0 - pos.y, join_with_skirting(\n        pos.y * 2.0,\n        maze_dist(pos.xz / Scale) * Scale, 0.2));\n    return maze_distance;\n}\n\nfloat maze(vec2 fixedCoord)\n{\n    vec3 pos = vec3(InitialPosition.y);\n    pos.xz = fixedCoord * Scale;\n    return 1.0 - step(0.0, dist_model(pos, 0.0) / Scale);\n}\n\nbool isCollision(vec2 from, vec2 dir)\n{\n    vec2 centerCoord = floor(from / GridDist + 0.5) * GridDist;\n    vec2 testPos = centerCoord + 0.5 * GridDist * dir;\n    return maze(testPos) > 0.5;  \n}\n\nvec2 ccw(vec2 v)\n{\n    return v.yx * vec2(1.0, -1.0);\n}\n\nvec2 cw(vec2 v)\n{\n    return v.yx * vec2(-1.0, 1.0);\n}\n\nvec4 mazeStep(vec2 currentPos, vec2 currentDir)\n{\n    if(!isCollision(currentPos, ccw(currentDir)))\n    {\n        currentDir = ccw(currentDir);\n    }\n    else if(!isCollision(currentPos, currentDir))\n    {\n        //Do nothing\n    }\n    else if(!isCollision(currentPos, cw(currentDir)))\n    {\n        currentDir = cw(currentDir);\n    }\n    else\n    {\n        currentDir *= -1.0;\n    }\n    currentPos += currentDir * GridDist;\n    return vec4(currentPos, currentDir);\n}\n\nvec4 mazeSolver(vec2 startPos, float duration, vec2 currentDir)\n{\n    vec2 currentPos = startPos;\n    vec2 prevPos = currentPos;\n    float my_time = duration;\n    while(my_time > 0.0)\n    {\n        prevPos = currentPos;\n        if(!isCollision(currentPos, ccw(currentDir)))\n        {\n            currentDir = ccw(currentDir);\n        }\n        else if(!isCollision(currentPos, currentDir))\n        {\n            //Do nothing\n        }\n        else if(!isCollision(currentPos, cw(currentDir)))\n        {\n            currentDir = cw(currentDir);\n        }\n        else\n        {\n            currentDir *= -1.0;\n        }\n        my_time -= GridDist * 15.0;\n        currentPos += currentDir * GridDist;\n    }\n    float frac_time = my_time / (15.0 * GridDist) + 1.0;\n\n    return vec4(mix(prevPos, currentPos, frac_time), currentDir);\n}\n\nvec4 GetInitialState()\n{\n    vec4 check = texelFetch(iChannel0, ivec2(0), 0);\n    if(check == MagicValue && iTime > 0.5)\n    {\n        return texelFetch(iChannel0, ivec2(15, 0), 0);\n    }\n    return vec4(InitialPosition.xz / Scale, 0.0, -1.0);\n}\n\nvec4 playerCoords( float time )\n{\n    //vec2 currentPos = InitialPosition.xz / Scale;\n    \n    vec4 startState = GetInitialState();\n    \n    return mazeSolver(startState.xy, time, startState.zw);\n}\n\nvec3 RawCameraPos(float time)\n{\n    vec3 pos = vec3(InitialPosition.y);\n    pos.xz = playerCoords(time).xy * Scale;\n    return pos;\n}\n\n\nvoid mazeCamera(float time, out vec3 camera_pos, out vec3 camera_dir)\n{\n    vec3 a = RawCameraPos(timeSinceUpdate);\n    vec3 b = RawCameraPos(timeSinceUpdate + 1.0);\n    vec3 dir = (b - a);\n    float wallClose = smoothstep( 2.0, 0.5, length(dir)) * 0.5;\n    dir.xz += vec2(wallClose);\n    camera_dir = normalize(dir);\n    camera_pos = (a + b) / 2.0 + vec3(0.0, sin(time * 6.0), 0.0) * 0.02;\n}\n\nfloat polkaDot(vec3 uv, vec3 center, float r)\n{\n    return smoothstep(0.01, 0.0, length( uv - center) - r);\n}\n\n// All components are in the range [0â€¦1], including hue.\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Center position of nearest polkadot\nvec3 polkaPosition(vec3 lookupPos)\n{\n    vec3 tileCoord = floor( lookupPos * 0.5 / GridDist2 ); \n    float radius = 0.3;\n    float my_time = 5.0;\n    vec3 center = (0.5 - radius) *\n        vec3(cos(noise(tileCoord) * my_time),\n             cos(noise(tileCoord * 1.1) * my_time ),\n             cos(noise(tileCoord * 2.31) * my_time));\n    return (tileCoord + center + vec3(0.5)) * 2.0 * GridDist2;\n}\n\nvec3 polkaColor(vec3 lookupPos)\n{\n    vec3 tileCoord = floor( lookupPos * 0.5 / GridDist2 ); \n    return hsv2rgb(vec3(noise(tileCoord), 0.9, 0.9));\n}\n\nvec3 polkaLights(vec3 hitPoint, vec3 norm, vec3 lookup)\n{\n    vec3 center2 = polkaPosition(lookup);\n\n    float centerDistance = length(center2 - hitPoint);\n    float lightIntensity = 1.0 / centerDistance;\n\n    float lambert = max(0.0, dot(normalize(center2 - hitPoint), norm )) * lightIntensity;\n    float subsurface = pow(lightIntensity, 8.0) * 0.05 * smoothstep(0.3, 0.6, centerDistance);\n    float reflectedIntensity = subsurface + pow(lambert, 4.0);\n    return reflectedIntensity * polkaColor(lookup);\n}\n\n//Polkadot material\nvec4 polkaDots(vec3 cameraPos, vec3 rayDir, float rayLen)\n{\n    vec4 dot_color = vec4(1.0);\n    vec3 hitPoint = cameraPos + rayDir * rayLen;\n    vec3 lookup1 = hitPoint;\n\n    float radius = 0.6;\n    vec3 center = polkaPosition(lookup1);\n    float dot_intensity = polkaDot(lookup1, center, radius); \n    dot_color.rgb = polkaColor(lookup1);\n\n    vec3 norm = normalize(gradient_model(hitPoint, 0.01, iTime));\n\n    // Find a nearby dot, use it to compute lighting\n    vec3 camera_left = vec3(-camera_forward.z, camera_forward.y, camera_forward.x);\n\n    vec3 testPos1 = camera_position + camera_forward * 2.0 + camera_left * 2.0 + vec3(0.0, 1.0, 0.0);\n    vec3 testPos2 = camera_position + camera_forward * 2.0 - camera_left * 2.0 + vec3(0.0, 1.0, 0.0);\n    vec3 testPos3 = camera_position + camera_forward * 2.0 + camera_left * 2.0 - vec3(0.0, 1.0, 0.0);\n    vec3 testPos4 = camera_position + camera_forward * 2.0 - camera_left * 2.0 - vec3(0.0, 1.0, 0.0);\n\n    float pointDistance =\n        min(distance(center, testPos4),\n            min(distance(center, testPos3),\n                min(distance(center, testPos1),\n                    distance(center, testPos2))));\n\n    float pointBrightness = smoothstep(2.0, 1.5, pointDistance);\n\n    vec3 baseColor = \n        +polkaLights( hitPoint, norm, testPos1 )\n        + polkaLights( hitPoint, norm, camera_position + camera_forward * 2.0 + camera_left * 2.0 - vec3(0.0, 1.0, 0.0) )\n        +polkaLights( hitPoint, norm, camera_position + camera_forward * 2.0 - camera_left * 2.0 + vec3(0.0, 1.0, 0.0) )\n        + polkaLights( hitPoint, norm, camera_position + camera_forward * 2.0 - camera_left * 2.0 - vec3(0.0, 1.0, 0.0) );\n\n    baseColor += vec3(0.005);\n    vec4 flatColor = vec4(vec3(-dot(rayDir, norm)), 1.0);\n\n    vec4 color = dot_intensity * dot_color * (vec4(pointBrightness) + flatColor * 0.1) + flatColor * vec4(baseColor, 1.0) * (1.0 - dot_intensity);\n    color.a = 1.0;\n    return color;\n}\n\n\nfloat castRay2( vec3 vStart, vec3 vDir, float dist_multiplier, float my_time  )\n{\n    float fCastLen = 0.0;\n    vec3 vHit = vStart;\n    while(fCastLen < MaxCastLen)\n    {\n        float fDistance = dist_model( vHit, my_time ) * dist_multiplier;\n\n        if(fDistance < HitDistance)\n        {\n            return fCastLen;\n        }\n\n        fDistance *= max(1.0, fCastLen / AccuracyDropoff);\n\n        fCastLen += fDistance;\n        vHit = vDir * fCastLen + vStart;\n    }\n\n    return MaxCastLen;\n}\n\nfloat castRay2( vec3 vStart, vec3 vDir, float dist_multiplier)\n{\n    return castRay2( vStart, vDir, 1.0, iTime );\n}\n\nfloat castRay( vec3 vStart, vec3 vDir, float my_time )\n{\n    return castRay2( vStart, vDir, DistanceMultiplier, my_time );\n}\n\nvec4 rayTraceMain( vec2 fragCoord, float time )\n{\n    vec2 position = fragCoord * -2.0 + 1.0;\n    vec3 rayDir = normalize(vec3( position, FocalLength));\n\n    vec3 cameraPos = vec3(0.0);\n\n    vec3 cameraDir = vec3(0.0, 0.0, 1.0);\n    CameraTransform(time, cameraPos, cameraDir);\n    camera_forward = cameraDir;\n    rayDir = camera_rotation( cameraDir ) * rayDir;\n\n    //Set a global variable, for blinking lights\n    camera_position = cameraPos;\n\n    float rayLen = castRay( cameraPos, rayDir, time );\n\n    return MainMaterial(cameraPos, rayDir, rayLen);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lastUpdate = texelFetch(iChannel0, ivec2(25,0), 0).x *200.0;\n    float dt = iTime - lastUpdate;\n    timeSinceUpdate = dt;\n    float timeStep = GridDist * 15.0;\n    bool updatePosition =( dt > timeStep) || iTime < 0.5;;\n    \n    if(fragCoord.y <= 1.0)\n    {\n        if(!updatePosition)\n        {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n        else if(fragCoord.x < 10.0)\n        {\n            fragColor = MagicValue;\n        }\n        else if(fragCoord.x < 20.0)\n        {\n            vec4 prevState =  GetInitialState();\n            fragColor = mazeStep(prevState.xy, prevState.zw);\n        }\n        else if(fragCoord.x < 30.0)\n        {\n            fragColor = vec4(iTime/200.0);\n        }\n        else\n        {\n           fragColor = vec4(0.0);\n        }\n        \n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.x;\n    uv.y = 1.0 -uv.y;\n\n    vec4 color = rayTraceMain( uv, iTime );\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n\n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}