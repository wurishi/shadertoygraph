{"ver":"0.1","info":{"id":"7tscDj","date":"1648749124","viewed":30,"name":"Fork CG 1 amjad_mahf 081","username":"amjad_mahfoud","description":"cg Homework","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["cg"],"hasliked":0,"parentid":"stlczl","parentname":"CG 1"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int k = 1;\n    \n    for(int i=-k; i <= k; i++)\n    for(int j=-k; j <= k; j++)\n    {\n    \n        fragColor += texelFetch(iChannel0,\n            ivec2(fragCoord)+ivec2(i,j)\n        ,0);    \n    }\n    \n    fragColor /=float((2*k+1)*(2*k+1));\n    fragColor *= 2.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 4;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int materialNo = 3;\nMaterial materials[materialNo];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-50.5, 0.1, 1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.Mid);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.Mid);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, -1);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n// Image-based lighting trick by reinder:\n// To approximate the integrated specular lobe in\n// environment maps, we can use them with\n// varying levels of detail.\n// https://www.shadertoy.com/view/lscBW4\nvec3 getSpecularLightColor( vec3 rd, float roughness )\n{\n    roughness = clamp(roughness, 0.0, 1.0);\n    float lod = log2(mix(1., 64., roughness));\n    // The large cubemap does not capture well high-intensity lights,\n    // so mix it with the small version.\n    vec3 t0 = pow(textureLod(iChannel2, rd.xzy, lod).rgb, vec3(2.2));\n    vec3 t1 = pow(textureLod(iChannel2, rd.xzy, lod).rgb, vec3(2.2));\n    vec3 col = mix(t0, t1, roughness);\n    // White balance\n    vec3 wb = pow(vec3(205.,159.,147.)/255.,vec3(-2.2));\n    return 3.0*wb*col;\n}\n\n\nfloat map( vec3 p )\n{\n    p.xy = mod(p.xy+0.5, 1.0)-0.5;\n    float d = length(p)-0.4;\n    d = min(d, p.z+0.41);\n\treturn d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.5 ) break;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    vec3 lightPos1=vec3(0.,0.,0.);\n    \n    vec3 l1 = lightPos1-p;\n    \n    float lightDist1 = length(l1);\n    \n    l1 /= lightDist1; // normalized direction to the light\n    \n    \n    Ray shadowray1 = Ray(p+0.001*n, 0.001, l1, lightDist1-3.01);\n                      /*     p0  , tmin , v,    tmax  */\n    //Ray shadowray = Ray(p+0.001*n, 0.001, (l1+l2)/2., (lightDist1+lightDist2)/2.);\n    TraceResult res1 = raycast(shadowray1);\n    \n    vec3 col = vec3(0.); // remains 0 if in shadow\n    if(res1.t==shadowray1.tmax)\n    {\n        if(materials[tr.Mid].Texture != -1){\n            float intensity = 0.7;\n            return  vec4(texture(iChannel3, ray.v.xy).xyx * intensity, 1.);\n        }\n            vec3 v = -ray.v;\n\n            //diffuse\n            float costheta = max(dot(n,l1),0.);\n            //vec3 k_d = vec3(1./pi);\n\n            // emission:\n            //vec3 k_d = -materials[tr.Mid].emission * dot(tr.n, ray.v);\n            // mul by metalness\n            vec3 k_d =  mix(materials[tr.Mid].color,vec3(0.),materials[tr.Mid].metalness); \n            vec3 specularCol = getSpecularLightColor(reflect(ray.v, tr.n), materials[tr.Mid].roughness);\n            vec3 F0 = mix(vec3(0.04), materials[tr.Mid].color, materials[tr.Mid].metalness);\n            vec3 fre = F0 + (1.0-F0)*pow(clamp(1.0-dot(-ray.v,tr.n),0.0,1.0), 5.0);\n            col = mix(k_d, specularCol, fre);\n            float ao = calcAO(p, tr.n);\n            col = col*ao;\n            \n            \n            //specular\n            vec3 toLight = normalize(lightPos1 - p);\n            vec3 toEye = -ray.v;\n            vec3 k_s = vec3(0.4);\n\n\n            vec3 h = normalize(toLight+toEye);\n            float si = pow(clamp(dot(h,n),0.,1.),10.);\n\n            //sum\n            col += (k_d + si*k_s )*costheta + materials[tr.Mid].color/pi;\n\n    }\n    return vec4(col,1.);\n}\n\n\nbool triangulation(Ray r, Triangle t, \n    out float _t, out float u, out float v){\n    \n    vec3 edge1 = t.b - t.a;\n    vec3 edge2 = t.c - t.a;    \n    vec3 pvec = cross(r.v,edge2);    \n    float det = dot(edge1, pvec);\n    float invDet = 1. / det;  \n    vec3 tvec = r.p0 - t.a;     \n    u = dot(tvec, pvec) * invDet;     \n    if (u < 0. || u > 1.) return false;  \n    vec3 qvec = cross(tvec, edge1);     \n    v = dot(r.v,qvec) * invDet;     \n    if (v < 0. || u + v > 1.) return false;      \n    _t = dot(edge2, qvec) * invDet;     \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 2 spheres\n    materials[0] = Material(vec3(1,1,1.), 1., vec3(0., 0., 0.), 0.03, 0);/// moon mat\n    materials[1] = Material(vec3(1.,1.,0.), 1., vec3(0.,0., 0.), 0.9, -1);// sun mat\n    materials[2] = Material(vec3(.1,1.,1.), 1., vec3(0.,0., 0.), 0.9, -1);// earth mat\n\n    float earthSpeed = .5;\n    float moonSpeed = .002;\n    float venusSpeed = .3;\n\n    vec2 earthCenter = vec2(sin(iTime * earthSpeed), cos(iTime * earthSpeed));\n    vec2 venusCenter = vec2(sin(iTime * venusSpeed), cos(iTime * venusSpeed));\n    vec2 moonCenter  = vec2(sin(iTime * moonSpeed), cos(iTime * moonSpeed));\n\n\n    spheres[0] = Sphere(vec3(0. ,0, 0), 3.f, 1);//sun\n    spheres[1] = Sphere(vec3(-27.*earthCenter.x - 5., 0, 27.*earthCenter.y + 4.), 1.f, 2);// earth\n    spheres[2] = Sphere(vec3(15.*venusCenter.x, 0, 15.*venusCenter.y), .3f, 1);//venus\n    spheres[3] = Sphere(vec3(5. * moonCenter.x , 0, 5. * moonCenter.y), 0.3f, 1);//moon\n\n    // planes[0] = Plane(vec3(0), normalize(vec3(1,1,1)), 0);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = result.t;//earth\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int Mid;   // material Id\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int Mid;    // material Id\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int Mid; // material Id\n};\n\n\nstruct Triangle{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nstruct Material { \n    vec3 color; // [0,1/pi] \n    float roughness; // [0,~7] \n    vec3 emission; // [0, inf] \n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals \n    int Texture; // texture for the matereal\n};\n","name":"Common","description":"","type":"common"}]}