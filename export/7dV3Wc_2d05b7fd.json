{"ver":"0.1","info":{"id":"7dV3Wc","date":"1632354303","viewed":74,"name":"14/49","username":"tono","description":"Continued from 7/49","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n    u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 op = p;\n    //o = length(p) - 3.;\n    o = p.y + 4.;\n    o -= noise(p/5. + iTime/13.) * 2.1;\n    // o = max(length(p)-2.8,o);\n    \n    if(o < 1.)\n    {\n    \to -= fbm(p*2. + iTime)/1.3;\n    }\n    // float l = \n    // o = min(o,l);\n    o*=.4;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec3 render(vec3 cp , vec3 rd,vec3 l,vec3 bg)\n{\n    float depth = 0.;\n    vec3 col = vec3(0.);\n    float trans = 1.;\n    float totaldens = 0.;\n    float diff = 0.;\n    float emit = 0.;\n    vec3 p = cp;\n    float t = iTime/2.;\n    float tt = fbm(iTime * 12. * vec3(1.));\n    for(int i = 0 ; i< 30 ; i++)\n    {\n        vec2 d = map(p);\n        p += rd * 0.03;\n   \t\tfloat dens = 1. - smoothstep(0.,.3,d.x);\n        totaldens += dens;\n        trans *= dens;\n        if(totaldens > 1. && diff <= 0.)\n        {\n            totaldens = 0.;\n            //表面から遠いほど内側\n            diff = clamp(1.-map(p).x,0.,1.);\n            emit = pow( smoothstep(0.1,.0,map(p).x) ,10.);\n            col += step(0.7,tt)*clamp(noise(p + t)-.5,0.,1.) * vec3(.0,.3,.7) * 3.;\n        }\n        depth += d.x;\n    }\n    trans = (1. - pow(totaldens/30.,10.5));\n    trans = smoothstep(0.,1.,trans);\n    emit = mix(emit*trans,1.,.2);\n    col = col + vec3(.5);\n    col = mix(col,bg,pow(trans,1.25) );\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-9.);\n    vec3 target = vec3(0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    fov = 2.5-dot(p,p)/2.;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    vec3 lightning = vec3(1.,1.,0.);\n    \n    p.x += ( fbm(vec3(p.xxy + iTime)*2.)-.5);\n    float th = sin(p.x * 10.) * step(fract(iTime*100. + p.x * 10.)-.5,.1);\n    th *= step(0.9,clamp(noise(iTime*3. + p.xxx*24.),0.,1.));\n    th *= step(p.y,.8-abs(sin(iTime+p.x*13.))*.8);\n    lightning *= clamp(th-.99,0.,1.) * 100.;\n    col += lightning;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(map(pos).x - vec3(map(pos - e.xyy).x , map(pos - e.yxy).x,map(pos - e.yyx).x));\n        //col = N;\n        vec3 sun = normalize(vec3(1.,-1.,.3));\n        col += render(pos,rd,sun,vec3(0.));\n        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}