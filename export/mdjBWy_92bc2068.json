{"ver":"0.1","info":{"id":"mdjBWy","date":"1690134691","viewed":47,"name":"Box, Rectangle SDF","username":"Envy24","description":"See Image tab header.","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["sdf","rectangle","box"],"hasliked":0,"parentid":"mdBBWD","parentname":"Halfway vector (bisection)"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Solution for generaled box/rectangle (in world coordinates), rectagle SDF.\n    Better solution (in box/rectangle local coordinates): \n        https://www.shadertoy.com/view/stcfzn\n        https://www.shadertoy.com/view/cts3W2\n        https://www.shadertoy.com/view/DssGR2 // L1, L2, Linf\n    \n    Press Q to see signed distance field.\n    Drag point with mouse.\n*/\n\n#define KEY_Q                     ( 81.5 )\n#define SDF_MODE                  ( texelFetch(iChannel2,ivec2(KEY_Q,2),0).x > 0.)\n\n#define SCENE_SCALE               ( 1.7)\n#define UNIT                      ( (SCENE_SCALE*4.) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// Character centered at pos.\nfloat char_intensity(vec2 uv, vec2 pos, float scale, int h_idx, int v_idx)  \n{   \n    pos -= 0.5;\n    // Apply scale.\n    uv -= 0.5; uv *= scale; uv += 0.5;\n    // Apply translation.\n    uv -= pos*scale;\n    \n    const float char_wh = 1./16.; // 0.0625\n    vec2 char = vec2(h_idx, v_idx) + uv; // xy in range [0; 15.], uv in range [0.; 1.]\n         char *= char_wh; // xy in range [0.; 1.]\n    return \n        (uv.x<0. || uv.x>1. || uv.y<0.|| uv.y>1.) == true ?\n            0. :\n            texture(iChannel3, char).x;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\n// Arbitrary point P and Rectangle both defined in world coordinates.\nvec4 rectangleSDF_L2(vec2 P, vec2 pos, vec2 right, vec2 h_wh)\n{\n    vec2 spos = pos;\n    P -= pos; pos -= pos; // Translate to local coordinates :)\n    vec2 PtoAxisProj = (dot(P, right) / dot(right, right)) * right,       \n         r_dir = PtoAxisProj - pos,\n         u_dir = P - PtoAxisProj;\n    float r_len = length(r_dir),\n          u_len = length(u_dir);\n         r_dir /= r_len;\n         u_dir /= u_len;\n              \n    float min_d;\n    vec2 CP;\n    float case_ = 0.;\n          \n    if (r_len < h_wh.x && u_len < h_wh.y)\n    {\n        // Inside.\n        vec2 P0 = pos + u_dir * h_wh.y + r_len * r_dir;\n        vec2 P1 = pos + u_dir * u_len + h_wh.x * r_dir;\n        float d0 = -length(P0 - P), d1 = -length(P1 - P);\n        min_d = max(d0, d1);\n        CP = min_d == d0 ? P0 : P1;\n        case_ = 0.;\n    }\n    else if (r_len > h_wh.x && u_len < h_wh.y)\n    {\n        // Outside 0       \n        CP = pos + u_dir * u_len + h_wh.x * r_dir;\n        min_d = length(CP - P);\n        case_ = 1.;\n    }\n    else if (r_len < h_wh.x && u_len > h_wh.y)\n    {\n        // Outside 1      \n        CP = pos + u_dir * h_wh.y + r_len * r_dir;        \n        min_d = length(CP - P);\n        case_ = 2.;\n    }\n    else\n    {\n        // Outside 2\n        vec2 A = pos + h_wh.y * u_dir + h_wh.x * r_dir,\n             B = pos + h_wh.y * u_dir - h_wh.x * r_dir,\n             C = pos - h_wh.y * u_dir - h_wh.x * r_dir,\n             D = pos - h_wh.y * u_dir + h_wh.x * r_dir;\n        float d0 = length(A-P), d1 = length(B-P),\n              d2 = length(C-P), d3 = length(D-P);             \n        min_d = min(d0, min(d1, min(d2, d3)));     \n        CP = A; \n        CP = min_d == d1 ? B : CP;\n        CP = min_d == d2 ? C : CP;\n        CP = min_d == d3 ? D : CP;\n        case_ = 3.;\n    }\n    \n    return vec4(min_d, CP + spos, case_);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ?\n             vec2(-1.1, -0.1) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    // Init scene for text printing.\n    vec3 color = vec3(1);           \n    vec3 char_color = vec3(1,0,0);\n    vec2 UV_ = NDC;\n    //\n    \n#define rotZ(a) ( mat2(cos(a), sin(a), -sin(a), cos(a)) )\n    /* Box, rectangle defnition. */\n    vec2 pos = vec2(sin(iTime*0.2), 0),\n         right = rotZ(iTime*0.2) * vec2(1, 0),\n         h_wh = vec2(1., 0.5);\n    /* Arbitrary point */\n    vec2 P = \n        SDF_MODE == true ?\n            NDC :\n            MP;\n    /* SDF */\n    vec4 data = rectangleSDF_L2(P, pos, right, h_wh);\n    vec2 CP = data.yz;\n    \n    vec3 colors[4] = vec3[4](\n        vec3(1) * 0.2,\n        vec3(1) * 0.4,\n        vec3(1) * 0.6,\n        vec3(1) * 0.8\n    );\n    color = colors[int(rectangleSDF_L2(NDC, pos, right, h_wh).w)];\n    \n    // Drawing stuff. \n    vec2 up = vec2(-right.y, right.x);\n    vec2 AA = pos + h_wh.x * right + h_wh.y * up,\n         BB = pos + h_wh.x * right - h_wh.y * up,\n         CC = pos - h_wh.x * right - h_wh.y * up,\n         DD = pos - h_wh.x * right + h_wh.y * up;\n    color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, AA, BB, 0.)));\n    color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, BB, CC, 0.)));\n    color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, CC, DD, 0.)));\n    color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, DD, AA, 0.)));\n    color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, CP, 0.025)));\n    color = mix(color, vec3(0, 1, 1), SMAA(segmentSDF_L2(NDC, CP, P, 0.)));\n    color = mix(color, vec3(0), SMAA(diskSDF_L2(NDC, P, 0.025)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, pos, 0.05)));\n    color = mix(color, vec3(0,1,0), SMAA(arrowSDF(NDC, pos, pos+right, 0.001)));\n        \n    /* On/Off Text */\n    char_color = vec3(0);\n    _P(P+vec2(0., 0.1), 0.2);\n    char_color = vec3(1,0,0);\n    _C(CP+vec2(-0.05, 0.1), 0.2);\n    _P(CP+vec2(0.05, 0.1), 0.2);\n    char_color = vec3(1,0,1);\n    vec2 range = map_to_centered_ndc(iResolution.xy, SCENE_SCALE, vec2(0), false);\n    if (data.w == 0.) { _i(-range + vec2(0.1, 0.15), 0.3); }\n    else if (data.w == 1.) { _o(-range + vec2(0.1, 0.15), 0.3); _0(-range + vec2(0.24, 0.15), 0.3); }\n    else if (data.w == 2.) { _o(-range + vec2(0.1, 0.15), 0.3); _1(-range + vec2(0.24, 0.15), 0.3); }\n    else if (data.w == 3.) { _o(-range + vec2(0.1, 0.15), 0.3); _2(-range + vec2(0.24, 0.15), 0.3); }\n    /* On/Off Text */  \n\n    O = \n        SDF_MODE == true ?\n            vec4(colorize_field(data.x, vec3(0.1, 0.4, 0.7)), 1) :\n            vec4(color,1.0);         \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0575, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.0575 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n/**\nfloat rectangleSDF_L2(vec2 P, vec2 pos, vec2 right, vec2 h_wh)\n{\n    vec2 spos = pos;\n    P -= pos; pos -= pos; // Translate to local coordinates :)\n    vec2 PtoAxisProj = (dot(P, right) / dot(right, right)) * right,\n         r_dir = PtoAxisProj - pos,\n         u_dir = P - PtoAxisProj;\n    float r_len = length(r_dir),\n          u_len = length(u_dir);\n         r_dir /= r_len;\n         u_dir /= u_len;\n              \n    float min_d;\n          \n    // Classify and solve:\n    if (r_len < h_wh.x && u_len < h_wh.y)\n    {\n        // Inside.\n        vec2 P0 = pos + u_dir * h_wh.y + r_len * r_dir - P;\n        vec2 P1 = pos + u_dir * u_len + h_wh.x * r_dir - P;\n        min_d = max(-length(P0), -length(P1));\n    }\n    else if (r_len > h_wh.x && u_len < h_wh.y)\n    {\n        // Outside 0       \n        min_d = length(pos + u_dir * u_len + h_wh.x * r_dir - P);\n    }\n    else if (r_len < h_wh.x && u_len > h_wh.y)\n    {\n        // Outside 1          \n        min_d = length(pos + u_dir * h_wh.y + r_len * r_dir - P);\n    }\n    else\n    {\n        // Outside 2\n        vec2 A = pos + h_wh.y * u_dir + h_wh.x * r_dir - P,\n             B = pos + h_wh.y * u_dir - h_wh.x * r_dir - P,\n             C = pos - h_wh.y * u_dir - h_wh.x * r_dir - P,\n             D = pos - h_wh.y * u_dir + h_wh.x * r_dir - P;          \n        min_d = min(length(A), min(length(B), min(length(C), length(D))));\n    }\n    \n    return min_d;\n}\n/**/\n\n#define _0(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 0, 12)) )\n#define _1(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 1, 12)) )\n#define _2(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 2, 12)) )\n#define _3(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 3, 12)) )\n#define _4(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 4, 12)) )\n#define _5(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 5, 12)) )\n#define _6(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 6, 12)) )\n#define _7(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 7, 12)) )\n#define _8(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 8, 12)) )\n#define _9(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 9, 12)) )\n\n#define _A(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 1, 11)) )\n#define _B(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 2, 11)) )\n#define _C(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 3, 11)) )\n#define _D(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 4, 11)) )\n#define _E(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 5, 11)) )\n#define _F(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 6, 11)) )\n#define _G(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 7, 11)) )\n#define _H(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 8, 11)) )\n#define _I(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 9, 11)) )\n#define _J(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 10, 11)) )\n#define _K(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 11, 11)) )\n#define _L(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 12, 11)) )\n#define _M(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 13, 11)) )\n#define _N(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 14, 11)) )\n#define _O(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 15, 11)) )\n#define _P(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 0, 10)) )\n#define _Q(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 1, 10)) )\n#define _R(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 2, 10)) )\n#define _S(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 3, 10)) )\n#define _T(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 4, 10)) )\n#define _U(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 5, 10)) )\n#define _V(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 6, 10)) )\n#define _W(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 7, 10)) )\n#define _X(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 8, 10)) )\n#define _Y(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 9, 10)) )\n#define _Z(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 10, 10)) )\n\n#define _a(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 1, 9)) )\n#define _b(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 2, 9)) )\n#define _c(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 3, 9)) )\n#define _d(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 4, 9)) )\n#define _e(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 5, 9)) )\n#define _f(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 6, 9)) )\n#define _g(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 7, 9)) )\n#define _h(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 8, 9)) )\n#define _i(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 9, 9)) )\n#define _j(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 10, 9)) )\n#define _k(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 11, 9)) )\n#define _l(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 12, 9)) )\n#define _m(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 13, 9)) )\n#define _n(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 14, 9)) )\n#define _o(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 15, 9)) )\n#define _p(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 0, 8)) )\n#define _q(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 1, 8)) )\n#define _r(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 2, 8)) )\n#define _s(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 3, 8)) )\n#define _t(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 4, 8)) )\n#define _u(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 5, 8)) )\n#define _v(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 6, 8)) )\n#define _w(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 7, 8)) )\n#define _x(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 8, 8)) )\n#define _y(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 9, 8)) )\n#define _z(pos, size) ( color = mix(color, char_color, char_intensity(UV_, pos, 1./size, 10, 8)) )\n","name":"Common","description":"","type":"common"}]}