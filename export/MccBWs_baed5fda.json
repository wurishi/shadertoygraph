{"ver":"0.1","info":{"id":"MccBWs","date":"1733627804","viewed":95,"name":"[phreax] auto fill maze","username":"phreax","description":"Implement an auto fill algorithm with a diffusion based approach. Not very optimized implementation.\n\nCircuit pattern based on the wonderful Wang tile implementation by srtuss https://www.shadertoy.com/view/Wds3z7\n\nClick to add fills, spacebar for reset.\n","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["diffusion","fill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   2024 phreax / jiagual\n   \n   Fill implementation & documentation in Buffer A\n   \n   The basic idea is to create diffusion based feedback system, where the grow & diffusion rate\n   is modulated by some noise in order to get am more dynamic looking, fluid like affect.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 UV = uv*2.-1.;\n    \n    /// mirroring / zoom / plane doformation\n\n    UV = transformUV(UV, iTime);\n\n    // convert back to 0-1 coordinates for texture lookup\n    uv = UV*.5+.5;\n\n    // Input textures\n    vec4 inputImage = texture(iChannel0, uv);  // Input mask (Channel 0)\n    vec4 state = texture(iChannel1, uv);       // Updated fill state (Buffer A)\n\n    // Activator (fill value)\n    float A = state.r;\n    float B = state.g;\n\n    // Visualization\n    vec3 col = inputImage.rgb;  // Original input image\n\n    vec3 gradient1 = mix(vec3(0.157,0.976,0.141), vec3(0.039,0.808,1.000), abs(UV).x);\n    vec3 gradient2 = mix(vec3(0.298,0.000,0.502), vec3(0.039,0.000,0.341), abs(UV).y);\n    \n    // Blend fill with base image\n    col = mix(col, col*gradient1*3., A*.9);\n    col = mix(col, gradient2, B);\n    col = pow(col*1.4, vec3(1.5));\n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nSome kind of a simple diffusion propagation inspired Gray-Scott reaction diffusion\nbut without the \"kill\" term\n*/\n\n\n// keyboard reference: https://shadertoy.com/view/llySRh\n#define keyClick(ascii)   ( texelFetch(iChannel2,ivec2(ascii,1),0).x > 0.) //\n#define SPACE_KEY 32\n#define DIFFUSE_NOISE 15.\n#define GROW_NOISE 15.\n\n\n// add a small point for the diffusion\nfloat addSeed(vec2 uv, vec2 p) {\n    float r = 0.001;            // Seed radius\n    return float(length(uv-p) < r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n     vec2 mouse = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n       \n    // Input textures\n    vec4 inputImage = texture(iChannel0, uv);  // Input mask (Channel 0)\n    vec4 prevState = texture(iChannel1, uv);  // Previous fill state (Channel 1)\n\n    // Boundary mask (1 = inside, 0 = outside)\n    float mask = float(inputImage.a > 0.1);\n\n    // Current activator (fill state)\n    float A = prevState.r;\n    float B = prevState.g;\n\n    // Neighbor sampling for diffusion\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec2 neighborSum = vec2(0);\n    vec2 offsets[4] = vec2[4](\n        vec2(texelSize.x, 0.0),  // Right\n        vec2(-texelSize.x, 0.0), // Left\n        vec2(0.0, texelSize.y),  // Up\n        vec2(0.0, -texelSize.y)  // Down\n    );\n\n    for (int i = 0; i < 4; i++) {\n        vec2 neighborUV = uv + offsets[i];\n        neighborSum += texture(iChannel1, neighborUV).rg;\n    }\n    neighborSum *= 0.25;  // Average activator value from neighbors\n\n   \n    // zero centered & mirrored UVs\n    vec2 UV =(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 UVa = UV;\n    UVa= abs(UVa);\n    \n    // add some randomess to the diffusion rate\n    float diffRate = mix(.3, .9,  smoothNoise21(UVa.xy*DIFFUSE_NOISE*2.)); // Diffusion rate for activator\n    float feedRate =  mix(.3, .9, mix(smoothNoise21(UVa.xy*GROW_NOISE*5.), smoothNoise21(UVa.xy*GROW_NOISE*2.), .5));   // Feed rate for fill growth\n\n    // Updated activator value\n    vec2 laplacian = neighborSum - prevState.rg; \n    float laplacianA = laplacian.r;\n    float laplacianB = laplacian.g;\n   \n    float speed = 1.5;\n\n    // could be done in one channel. In my original implementation I used the second\n    // to dissolve the fill\n    // here I use it just to fill some black parts of the with a separate color\n    A += (diffRate * laplacianA + feedRate * A) * mask * speed;\n    B += (diffRate * (laplacianB) + feedRate * B)*(1.-mask) * speed;\n\n\n    // add some seeds on first frame or resolution change (\n    if(iFrame < 1 || iResolution.x/1000. != prevState.b || keyClick(SPACE_KEY)) {\n        A = addSeed(UVa, vec2(0.3, 0.0)) +\n            addSeed(UVa, vec2(0.03, 0.23)) +\n            addSeed(UVa, vec2(0.83, 0.16)) +\n            addSeed(UVa, vec2(0.0, 0.04)) +\n            addSeed(UVa, vec2(0.2, 0.17)) +\n            addSeed(UVa, vec2(0.16, 0.16)) +\n            addSeed(UVa, vec2(0.7, 0.17)) +\n            addSeed(UVa, vec2(0.74, 0.25)) +\n            addSeed(UVa, vec2(0.87, 0.1)) +\n            addSeed(UVa, vec2(0.53, 0.1)) +\n            addSeed(UVa, vec2(0.58, 0.13)) +\n            addSeed(UVa, vec2(0.8, 0.11)) +\n            addSeed(UVa, vec2(0.02, 0.48)) +\n            addSeed(UVa, vec2(0.02, 0.4)) +\n            addSeed(UVa, vec2(0.62, 0.2)) +\n            addSeed(UVa, vec2(0.02, 0.0));\n\n        B = addSeed(UVa, vec2(0.26, 0.0)) +\n            addSeed(UVa, vec2(0.7, 0.0)) +\n            addSeed(UVa, vec2(0.33, 0.0)) +\n            addSeed(UVa, vec2(0.2, 0.4));\n\n    }\n    \n    \n    if(iMouse.z > .5) {\n        // make sure the clicks match the warped plane\n        mouse = transformUV(mouse, iTime);\n       \n       A += addSeed(UVa, mouse);\n    }\n    \n    A = clamp(A, 0., 1.);\n    B = clamp(B, 0., 1.);\n\n\n    // Output updated activator A & B (save resolution to detect a change)\n    fragColor = vec4(A, B, iResolution.x/1000., 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Cirquit maze pattern\n// \n// Pretty much taken as is from https://www.shadertoy.com/view/Wds3z7\n// by shadertoy user srtuss\n\n\n// Some more interesting seeds 19.41, 19.24, 19.19, 20.54, 24.53441\n#define PATTERN_SEED 19.41\n\nfloat k = .1;\n#define K2 ((1. - k) / 2.)\n#define K3 (sqrt(2.) * .5 - K2)\n#define R iResolution\n\nfloat tile0(vec2 uv)\n{\n    float v = length(uv) - K3;\n    float w = K2 - length(vec2(abs(uv.x) - .5, uv.y - .5));\n    return v = mix(v, w,\n                   //smoothstep(.1, -.1, abs(uv.x) - uv.y)\n                   step(abs(uv.x), uv.y)\n                  );\n}\n\nfloat tile1(vec2 uv)\n{\n    return abs(length(uv - .5) - .5) - k * .5;\n}\n\nfloat tile2(vec2 uv)\n{\n    return abs(uv.x) - k * .5;\n}\n\nfloat tile3(vec2 uv)\n{\n    return max(-uv.x - k * .5, K2 - length(vec2(uv.x - .5, abs(uv.y) - .5)));\n}\n\nfloat tile4(vec2 uv)\n{\n    return K2 - length(vec2(abs(uv.x) - .5, abs(uv.y) - .5));\n}\n\nfloat tile(vec2 uv, int tile)\n{\n\n    switch(tile)\n    {\n        case 0: return 1.414;\n        case 1: return max(tile0(uv), .15 - length(uv));\n        case 2: return tile0(uv.yx);\n        case 3: return tile1(uv);\n        case 4: return tile0(vec2(uv.x, -uv.y));\n        case 5: return tile2(uv);\n        case 6: return tile1(vec2(uv.x, -uv.y));\n        case 7: return tile3(uv);\n        case 8: return tile0(vec2(uv.y, -uv.x));\n        case 9: return tile1(vec2(-uv.x, uv.y));\n        case 10: return tile2(uv.yx);\n        case 11: return tile3(uv.yx);\n        case 12: return tile1(vec2(-uv.x, -uv.y));\n        case 13: return tile3(vec2(-uv.x, uv.y));\n        case 14: return tile3(vec2(-uv.y, uv.x));\n        case 15: return tile4(uv);\n    }\n}\n\n// \"Hash without Sine\" - borrowed from Dave Hoskins's shader\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash(vec2 p)\n{   \n    \n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + PATTERN_SEED);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat map(vec2 uv)\n{\n    int b = 0;\n    uv += .5;\n    vec2 id = floor(uv);\n    if(hash(id) >= .5)\n        b += 1;\n    if(hash(-id) >= .5)\n        b += 8;\n    if(hash(id - vec2(0., 1.)) >= .5)\n        b += 4;\n    if(hash(-(id + vec2(1., 0.))) >= .5)\n        b += 2;\n\n    return tile(fract(uv) - .5, b);\n}\n\nvec2 rotate(vec2 uv, float a)\n{\n    float co = cos(a);\n    float si = sin(a);\n    return uv * mat2(co, si, -si, co);\n}\n\nfloat height(vec2 uv)\n{\n    float r = map(uv) - .1;\n    return sqrt(.01 - min(r * r, .01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*R.xy)/R.y;\n\n    uv = abs(uv);\n    vec2 UVa = uv;\n  //  uv = rotate(uv, iTime * .1);\n    vec3 rd = normalize(vec3(uv, 1.66));\n    \n    float scale = 5. + sin(iTime * .5);\n    \n    uv *= 15.;\n    \n    vec2 h = vec2(.08, 0.);\n    float v = map(uv);\n    float c0 = height(uv);\n    float c1 = height(uv + h.xy);\n    float c2 = height(uv + h.yx);\n    \n    vec3 color = vec3(1)*smoothstep(0., 4. / R.y, min(v, abs(v - .18) - .01) / scale);\n    vec3 bColor = color;\n    \n\n    vec3 normal = normalize(vec3(c0 - c1, h.x, c0 - c2));\n    \n    rd.xy *= rot(.1*iTime);\n    vec3 bounce = reflect(rd, normal);\n    \n    vec3 lightDir = normalize(vec3(-.5, .5, .1));\n    \n    color *= dot(normal, lightDir);\n    \n    vec3 gradient = mix(vec3(0.859,0.486,0.059), vec3(1.000,0.894,0.600), .5*(UVa.x+UVa.y));\n    color *= mix(gradient, vec3(0.192,0.435,0.827), smoothstep(0., 2. / R.y, min(v, abs(v - .1) - .1) / scale));\n    \n    color *= texture(iChannel0, bounce).xyz;\n    \n    color *= 3.;\n    \n   \n    //color = bColor;\n    fragColor = vec4(color, bColor.r);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SIN(x) (sin(x)*.5+.5)\n\nvec2 transformUV(vec2 UV, float t) {\n    UV = abs(UV);\n    UV *= mix(1., .9, SIN(.5*t));\n    UV += .007*sin(5.*UV.yx+t);\n    return UV;\n}\n\n// smooth noise function I came to use in many places.\n// probably cheaper way of doing this without trigonometrics\nfloat smoothNoise21(vec2 p) {\n    // Calculate integer and fractional coordinates\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 seed = vec2(127.1, 311.7);\n    \n    // Compute gradients at the four corners of the cell\n    float n00 = dot(vec2(cos(dot(i, seed)), sin(dot(i, seed))), f - vec2(0.0, 0.0));\n    float n01 = dot(vec2(cos(dot(i + vec2(0.0, 1.0), seed)), sin(dot(i + vec2(0.0, 1.0), seed))), f - vec2(0.0, 1.0));\n    float n10 = dot(vec2(cos(dot(i + vec2(1.0, 0.0), seed)), sin(dot(i + vec2(1.0, 0.0), seed))), f - vec2(1.0, 0.0));\n    float n11 = dot(vec2(cos(dot(i + vec2(1.0, 1.0), seed)), sin(dot(i + vec2(1.0, 1.0), seed))), f - vec2(1.0, 1.0));\n\n    // Smooth interpolation using Hermite curve (smoothstep)\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Bilinear interpolation with gradients\n    return mix(mix(n00, n10, u.x), mix(n01, n11, u.x), u.y);\n}","name":"Common","description":"","type":"common"}]}