{"ver":"0.1","info":{"id":"Mc2Bzd","date":"1725403648","viewed":86,"name":"Test SDF with materials","username":"FrederickAmpsUp","description":"A PS4-esque game controller that can be used for testing rendering techniques.\nAdded materials and (semi)PBR!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"MfSyDw","parentname":"Test SDF for Rendering"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test SDF for Rendering Experiments\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// Inigo Quilez 3D SDF Functions\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor.rgb = pow(Tonemap_ACES(col), vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define MAT_METAL -1.0\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n};\n\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p += 0.1;\n    p *= p + 33.33;\n    p *= p + p;\n    p -= 0.1;\n    return fract(p);\n}\n\nfloat rand2(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(rand(i+1.), rand(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// Mirror\nvec3 mirrorX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\n// Rotation\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec3 rotX(vec3 p, float r) {\n    p.yz *= rot(r);\n    return p;\n}\n\nvec3 rotY(vec3 p, float r) {\n    p.xz *= rot(r);\n    return p;\n}\n\nvec3 rotZ(vec3 p, float r) {\n    p.xy *= rot(r);\n    return p;\n}\n\n// SDF\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 sdfMin(vec2 s1, vec2 s2) {\n    if (s1.x < s2.x) {\n        return s1;\n    }\n    return s2;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DEPTH 8.0\n#define CUBE_COUNT 8\n\nconst float minDepth = 0.01;\nconst float matchEps = 0.0001;\n\n// Global vars\nfloat time;\n\nvec3 sky(vec3 dir) {\n    return pow(texture(iChannel0, dir).xyz, vec3(2.2));\n}\n\nvec3 skyDiff(vec3 dir) {\n    return mix(pow(texture(iChannel1, dir).xyz, vec3(2.2)), 0.5*vec3(0.9, 0.85, 0.8), 0.85);\n}\n\nfloat controllerSDF(vec3 pos, out Material mat) {\n    mat.albedo = vec3(0.05);\n    mat.roughness = 1.0;\n    pos.y -= 0.21;\n    pos.yz *= rot(0.52);\n    float depth = 99999.0;\n    float mainBody = 0.0;\n    \n    vec3 mx = mirrorX(pos);\n    // body\n    mainBody = sdRoundBox(pos, vec3(0.5,0.1,0.2), 0.05);\n    // handles\n    mainBody = smin(\n        mainBody,\n        sdCapsule(mx - vec3(0.4, 0.0, 0.0), vec3(0.0, 0.0, -0.1), vec3(0.1, -0.1, 0.1), 0.2),\n        0.1\n    );\n    // ergonomic curve along bottom of controller\n    mainBody = ssub(\n        length(pos.zy - vec2(-0.2, -0.3)) - 0.1,\n        mainBody,\n        0.25\n    );\n    // flatten button areas\n    mainBody = ssub(\n        sdCappedCylinder(mx - vec3(0.42, 0.25, -0.1), 0.1, 0.2),\n        mainBody,\n        0.01\n    );\n    // thumbstick holders\n    vec3 stickHolder = mx - vec3(0.26, 0.03, 0.175);\n    mainBody = smin(\n        mainBody,\n        sdCappedCylinder(stickHolder, 0.05, 0.07) - 0.05,\n        0.1\n    );\n    \n    depth = mainBody;\n    // touchpad depression\n    vec3 touchpadPos = pos - vec3(0.0, 0.1, -0.1);\n    float touchpadCutout = sdRoundBox(touchpadPos, vec3(0.155, 0.05, 0.125), 0.001);\n    depth = max(-(abs(touchpadCutout) - 0.005), depth);\n    vec3 stick = stickHolder - vec3(0.0, 0.025, 0.0);\n    // holes in thumbsticks\n    depth = ssub(\n        sdSphere(stick, 0.06) - 0.05,\n        depth,\n        0.01\n    );\n    // stick ball\n    depth = min(\n        sdSphere(stick, 0.06) - 0.05,\n        depth\n    );\n    // stick\n    depth = min(\n        depth,\n        sdCappedCylinder(stick - vec3(0.0, 0.1, 0.0), 0.05, 0.035)\n    );\n    // stick caps\n    depth = smin(\n        depth,\n        sdCappedCylinder(stick - vec3(0.0, 0.15, 0.0), 0.01, 0.06) - 0.01,\n        0.01\n    );\n    // face buttons\n    vec3 rbs = pos;\n    rbs.x = abs(rbs.x);\n    rbs += vec3(-0.375, -0.15, 0.075);\n    rbs.xz *= rot(PI / 4.0);\n    rbs.xz = abs(rbs.xz);\n    rbs.xz -= 0.06;\n    float rbd = sdSphere(rbs, 0.045);\n    rbd = ssub(\n        sdCappedCylinder(rbs - vec3(0.0, 0.1, 0.0), 0.085, 0.05),\n        rbd,\n        0.01\n    );\n    depth = min(\n        depth,\n        rbd\n    );\n    \n    if (abs(depth - mainBody) < 0.002) {\n        \n        vec3 cp = pos*10.0;\n        bool checker = (mod(cp.x, 1.0)<0.5 != mod(cp.y, 1.0)<0.5) != mod(cp.z, 1.0)<0.5;\n        \n        mat.roughness = checker? 0.6 : 0.9;\n        mat.albedo = checker? vec3(0.5) : vec3(0.2);\n    }\n    \n    return depth;\n}\n\nvec2 sceneSDF(vec3 pos, out Material mat) {\n    float ground = length(pos-vec3(0.0, -10.0, 0.0))-10.0;\n    float controller = controllerSDF(pos, mat);\n    \n    if (ground < controller) {\n        mat.albedo = vec3(0.5, 0.5, 0.8);\n        mat.roughness = 1.0;\n    }\n    return vec2(min(ground, controller), 0.0);\n}\n\nvec2 sceneSDF(vec3 pos) {\n    Material _;\n    return sceneSDF(pos, _);\n}\n\nvec3 sceneNormal( in vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h).x + \n                      k.yyx*sceneSDF( p + k.yyx*h).x + \n                      k.yxy*sceneSDF( p + k.yxy*h).x + \n                      k.xxx*sceneSDF( p + k.xxx*h).x );\n}\n\nvec2 getDepthAndMaterial(vec3 eye, vec3 dir, out Material mat) {\n    float depth = 0.0;\n    float sdf = matchEps;\n    for (int steps = 0;\n         sdf >= matchEps && depth < MAX_DEPTH && steps < 120;\n         steps++) {\n        vec2 sdf = sceneSDF(eye + depth * dir, mat);\n        depth += sdf.x;\n    }\n    depth = min(depth, MAX_DEPTH);\n    \n    return vec2(depth, 0.0);\n}\n\nfloat occ( in vec3 p, in vec3 n)\n{\n    const float maxDist = 0.15;\n    const float falloff = 1.6;\n    const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = rand(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal for self occlusion problems!\n\n        ao += (l - max(sceneSDF( p + rd).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 light(\n    vec3 p,\n    vec3 n,\n    vec3 pos,\n    vec3 col,\n    float hardness\n) {\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 base_uv = fragCoord/iResolution.xy;\n    // time remapping/distortion here\n    time = iTime;\n    \n    vec3 eye, dir;\n    vec2 uv = base_uv;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = -1.75;\n    mat2 rx = rot(PI / 16.0);\n    mat2 ry = rot(PI * 0.25);\n    if (iMouse.z > 0.0) {\n        rx *= rot(0.5 * PI * (1.0 - iMouse.y / iResolution.y));\n        ry *= rot(2.0 * -PI * (iMouse.x / iResolution.x - 0.5));\n    }\n    eye = vec3(0.12, 0.25, dist);\n    eye.yz *= rx;\n    eye.xz *= ry;\n    dir = normalize(vec3(uv, 1.0));\n    dir.yz *= rx;\n    dir.xz *= ry;\n   \n    vec3 col = vec3(0.0);\n    \n    Material mat;\n    vec2 sdf = getDepthAndMaterial(eye, dir, mat);\n    float depth = sdf.x;\n    \n    if (depth < MAX_DEPTH) {\n        vec3 pos = eye + dir * depth;\n        vec3 norm;\n        \n        norm = sceneNormal(pos);\n        pos += norm * 0.001;\n        vec3 light = vec3(0.0);\n        \n        vec3 refl = reflect(dir, norm);\n        \n        vec3 diffuse = skyDiff(norm);\n        vec3 rough = pow(texture(iChannel1, refl).xyz, vec3(2.2));\n        vec3 perfect = sky(refl);\n        \n        vec3 reflected = mix(mix(perfect, rough, mat.roughness), mix(rough, diffuse, mat.roughness), mat.roughness); // not PB but easy\n        col += reflected * mat.albedo;\n        \n        // occlusion\n        float occ = occ(pos, norm);\n        \n        col *= vec3(occ);\n    } else {\n        col = sky(dir);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}