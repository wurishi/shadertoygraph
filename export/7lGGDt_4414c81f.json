{"ver":"0.1","info":{"id":"7lGGDt","date":"1638508213","viewed":150,"name":"Pudi (wip)","username":"panna_pudi","description":"üê∑","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["desert","pudding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 EPS = vec3(0., 0.01, 0.0001);\nconst int MAX_STEPS = 255;\nconst float MAX_DIST = 100.;\nconst float PI = 3.141592;\n\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec4 sdBezier(vec3 p, vec3 va, vec3 vb, vec3 vc) {\n    vec3 w = normalize(cross(vc - vb, va - vb));\n    vec3 u = normalize(vc - vb);\n    vec3 v = cross(w, u);\n\n    vec2 m = vec2(dot(va - vb, u), dot(va - vb, v));\n    vec2 n = vec2(dot(vc - vb, u), dot(vc - vb, v));\n    vec3 q = vec3(dot(p - vb, u), dot(p - vb, v), dot(p - vb, w));\n\n    float mn = det(m, n);\n    float mq = det(m, q.xy);\n    float nq = det(n, q.xy);\n\n    vec2 g = (nq + mq + mn) * n + (nq + mq - mn) * m;\n    float f = (nq - mq + mn) * (nq - mq + mn) + 4.0 * mq * nq;\n    vec2 z = 0.5 * f * vec2(-g.y, g.x) / dot(g, g);\n    // float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n    float t = clamp(0.5 + 0.5 * (det(z - q.xy, m + n)) / mn, 0.0, 1.0);\n    vec2 cp = m * (1.0 - t) * (1.0 - t) + n * t * t - q.xy;\n\n    float d2 = dot(cp, cp);\n    return vec4(sqrt(d2 + q.z * q.z), t, q.z, -sign(f) * sqrt(d2));\n}\n\nvec3 DomainRotateSymmetry(const in vec3 vPos, const in float fSteps) {\n    float angle = atan(vPos.x, vPos.z);\n\n    float fScale = fSteps / (PI * 2.0);\n    float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\n    float s = sin(-steppedAngle);\n    float c = cos(-steppedAngle);\n\n    return vec3(c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n}\n\n#define sabs(x, k) sqrt((x) * (x) + k)\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nvec3 carve(in vec3 p1, in vec3 p2) {\n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z > -p2.z ? p1.xy : p2.xy, -smin(-p1.z, p2.z, k));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat smax(float a, float b, float k) {\n    k *= 1.4;\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * h / (6.0 * k * k);\n}\n\nvec3 erot(vec3 p, vec3 d, float ro) {\n\treturn mix(dot(p, d) * d, p, cos(ro)) + cross(p, d) * sin(ro);\n}\n\nvec2 rot(vec2 p, float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c) * p;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h) {\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nvec3 sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n    float rba = rb - ra;\n    float baba = dot(b - a, b - a);\n    float papa = dot(p - a, p - a);\n    float paba = dot(p - a, b - a) / baba;\n    float x = sqrt(papa - paba * paba * baba);\n    float cax = max(0.0, x - ((paba < 0.5) ? ra : rb));\n    float cay = abs(paba - 0.5) - 0.5;\n    float k = rba * rba + baba;\n    float f = clamp((rba * (x - ra) + paba * baba) / k, 0.0, 1.0);\n    float cbx = x - ra - f * rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n\tfloat px = atan(p.x, p.z) * paba;\n\tfloat py = atan(p.y, p.x) * rba;\n\n    return vec3(px, py, s * sqrt(min(cax * cax + cay * cay * baba,\n                        cbx * cbx + cby * cby * baba)));\n}\n\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\nfloat opSU(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvoid mouth(in vec3 p, inout float res, uint type) {\n    switch (type) {\n        case 0u: {\n            vec3 pm = p + vec3(0., 0.38, 0.22);\n            float tooth = sdCone(pm * vec3(1., -1., 1.) + vec3(0.2, 0.15, 0.0) +\n                                     vec3(-0.13, 0.0, 0.09),\n                                 vec2(0.2, 0.1), 0.05);\n\n            vec4 umuer = sdBezier(pm + vec3(-0.02, -0.18, 0.089999974),\n                                  vec3(0.01, -0.12, 0.55), vec3(0.06, 0.19, 0.),\n                                  vec3(0.01, 0.01, -0.04));\n            umuer.x -= 0.03 + (1. - umuer.y) * 0.04;\n            umuer += noise(umuer.yzx * 100.) * 0.01 * pow(umuer.y, 3.);\n\n            float noiseier = noise(umuer.yzx * 900.) * 0.0003;\n\n            float exterrior =\n                sdEllipsoid(pm, vec3(0.19000003, 0.24000011, 0.24000005));\n            exterrior = length(pm) - 0.24;\n            exterrior = smax(exterrior, -(p.y + 0.424), 0.01);\n\n            vec4 tongue =\n                sdBezier(pm * vec3(.7, 1., 1.) + vec3(0.0, 0.0, -0.03),\n                         vec3(0.0, -0.1, 0.1), vec3(0.01, 0.20, -0.00),\n                         vec3(0.03, 0.04, -0.18));\n            tongue.x += -0.18 * (1. - tongue.y) - 0.033 * pow(tongue.y, 2.);\n            float bending_plane =\n                max((pm.y + 0.0438), (length(pm + vec3(0., 0., -0.2)) - .373));\n            tongue.x = smin(tongue.x, bending_plane, 0.057);\n            tongue += noiseier;  // * pow(umuer.y, 3);\n\n            exterrior = smax(exterrior, -umuer.x, 0.08);\n\n            res = max(res, -exterrior);\n            res = min(res, tongue.x);\n            res = min(res, tooth);\n            break;\n        };\n        case 1u: {\n            vec3 pb = vec3(abs(p.x), p.yz);\n            pb += vec3(0., 0.23, 0.38);\n\t\t\tpb = erot(pb, vec3(0.0, 0.0, 1.0), -PI / 4.);\n            pb = abs(pb) - vec3(0.1, 0.01, 0.0001);\n            float box = length(max(pb, vec3(0.)));\n            res = min(res, box);\n            break;\n        };\n    }\n}\n\nfloat topping(vec3 p) {\n    float ring = sdTorus(p + vec3(0., 0.34, 0.0), vec2(0.38, 0.1));\n\n    vec3 q = erot(p, normalize(vec3(-0.2, 1., 0.1)), 3.);\n    float arg = q.x * q.z * 100. + iTime;\n    float bumps = cos(q.y * 100.);\n    +sin(arg) * cos(arg);\n    bumps = bumps * 0.5 + 0.5;\n    bumps *= 0.01;\n    ring += bumps;\n\n    p = erot(p, vec3(0., 1., 0.), p.y * 3.);\n    float rect = sdRect(p.xz, vec2(0.5));\n\n    p = erot(p, vec3(0., 1., 0.), PI / 4.);\n    float neigh = sdRect(p.xz, vec2(0.4));\n\n    float res = opSU(rect, neigh, 0.1);\n    res += p.y + 0.2;\n    res = -opSU(-res * 0.5, -sdSphere(p, 0.5), 0.1);\n    res = smin(ring, res, 0.01);\n    /* res += fbm(p*10) * 0.03; */\n\n    return res;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nvec3 torus(in vec3 p, float radius, float thickness) {\n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\n\nfloat piggy_snout(vec3 p) {\n    vec3 po = p;\n    po.yz *= rot(PI / 2.);\n    float base =\n        sdRoundedCylinder(po, 0.03 + sabs(po.x, 0.001) * 0.2 - p.y * 0.3, 0.01, 0.05);\n    vec3 pe = vec3(abs(p.x), p.yz);\n    pe += vec3(-0.06, 0.08, 0.05);\n    float noseholes = length(pe) - 0.036;\n    base = smax(base, -noseholes, 0.03);\n    return base;\n}\n\nfloat scene(vec3 p) {\n    float t = iTime;\n    float wiggle = cos((p.y + t) * 11.) * 0.02;\n    float wigglee = cos((p.y + t + 0.05) * 11.) * 0.02;\n\n    float res = length(p) + 0.5;\n    {\n        vec3 pa = vec3(0.0, -0.4, 0.0);\n        float body = sdCappedCone(p, pa, vec3(0.), 0.3, 0.2).z - 0.1;\n        res = body; +wiggle;\n    }\n\n    {\n        vec3 pp = p + vec3(0, .5, 0);\n        pp.yz = rot(pp.yz, PI / 2.);\n        float r_plate = 0.5;\n        float plate = sdEllipsoid(pp, vec3(r_plate, r_plate, 0.07));\n        res = min(res, plate);\n    }\n\n    {\n        vec3 pe = vec3(abs(p.x), p.yz);\n        pe += vec3(-0.12, 0.05, 0.28);\n        float r_eye = 0.08;\n        float eyes = sdEllipsoid(pe, vec3(r_eye, r_eye, 0.05));\n        res = smin(res, eyes, 0.02);\n    }\n\n    {\n        vec3 pb = vec3(abs(p.x), p.yz);\n        pb += vec3(-0.17, 0.19, 0.36);\n        vec2 r_blush = vec2(0.04, 0.02);\n        float blush = sdEllipsoid(pb, vec3(r_blush, 0.02));\n        blush = max(max(blush, pb.z), -pb.z + 0.001);\n        res = min(res, blush);\n    }\n\n\n    {\n\t\tmouth(p, res, uint(step(0.5, mod(t * 0.6, 1.))));\n    }\n\n    {\n        vec3 pi = p + vec3(0., 0.12, 0.0);\n        float d = length(pi.xz);\n        float ang = atan(pi.z, pi.x) + PI / 2.;\n        float off = PI / 4. + 0.0, range = 0.1;\n        float amplifier = 1. - (smoothstep(-range, 0.5, ang + off) -\n                           smoothstep(-0.4, range, ang - off));\n        vec3 dripping =\n            sdCappedCone(pi, vec3(0.), vec3(0.0, 0.14, 0.0), 0.27 , 0.20) + 0.011*(1.-amplifier);\n        dripping.z += -0.113;\n        float waveFactor = (d > 1. ? 1. : .5);\n        float wave = sin(ang * 20. * waveFactor) * .067 +\n                     sin(ang * 40. * waveFactor + .7) * 0.038 +\n                     sin(ang * 25. * waveFactor + 1.7) * 0.027;\n        wave *= amplifier * 0.6;\n\n        vec3 icingWave = vec3(0, 0, pi.y - (wave + .03));\n        vec3 icing = carve(dripping, icingWave, .2);\n\n        res = min(res, icing.z);\n    }\n\n    {\n        vec3 po = p - vec3(0., 0.2, 0.);\n        vec4 ahoge =\n            sdBezier(po, vec3(0., -0.09, 0.), vec3(-0.03, 0.08, -0.01),\n                     vec3(-0.08, 0.01 + wigglee * 0.4, 0.));\n        ahoge.x -= 0.027 * ahoge.y + (1. - ahoge.y) * 0.008;\n        res = smin(res, ahoge.x + 0.003, 0.04);\n    }\n\n    {\n        vec3 po = p;\n        po.y += wiggle;\n        vec3 pt = vec3(abs(po.x), po.yz) + vec3(-0.17, -0.19, 0.0);\n        float scale = .1;\n        float top = topping(pt / scale) * scale;\n        res = smin(res, top, 0.03);\n    }\n\n    // Nose\n    float tt = mod(t / 2., 3.);\n    if (tt <= 1.) {\n        vec3 po = p + vec3(0.0, 0.10, 0.3);\n        vec4 base = sdBezier(po, vec3(0., 0.07, 0.0), vec3(0.0, 0.0, -0.05),\n                             vec3(0.01, 0.0, -0.2)) -\n                    0.02;\n        base.x += (base.y) * 0.01;\n        vec3 pe = vec3(abs(p.x), p.yz);\n        pe += vec3(-0.04, 0.10, 0.36);\n        float noseholes = length(pe) - 0.03;\n        base.x = smin(base.x, noseholes, 0.03);\n        res = min(res, base.x);\n    } else if (tt <= 2.) {\n        float scale = 3.5;\n        scale = 2.;\n        vec3 pn = p + vec3(0.0, 0.09, 0.34);\n        float snout = piggy_snout(pn * scale) / scale;\n        res = smin(res, snout, 0.003);\n    }\n    return res;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 camera(vec2 uv, vec3 ro, vec3 at, vec3 up, float z) {\n    vec3 f = normalize(at - ro),\n\t\tr = cross(up, f),\n\t\tu = cross(f, r),\n        c = ro + f * z,\n\t\ti = c + uv.x * r + uv.y * u;\n    return i - ro;\n}\n\nfloat height = 0.02;\nvec3 color(in vec3 p) {\n\tp.y += 0.43;\n    vec3 top = vec3(0.9921875, 0.984375, 0.25578125);\n    vec3 ring = vec3(0.6, 0.04, 0.0);\n    vec3 bottom = vec3(0.3, 0.3, 0.3);\n    bottom = mix(vec3(0.0), bottom, min(1.0, -1.0 / (p.y * 20.0 - 0.0)));\n    vec3 side = mix(bottom, ring, smoothstep(-height - 0.001, -height, p.y));\n    return mix(side, top, smoothstep(-0.01, 0.0, p.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(iResolution.x / iResolution.y, 1.);\n\n\tfloat t = iTime * 0.5;\n\n\tvec3 ro = vec3(-0., 0.2, -1.0);\n    vec3 at = vec3(0., -0.2, -0.0);\n    vec3 rd = camera(uv, ro, at, vec3(0, 1, 0), 1.);\n\t/* ro += vec3(0.01, -0.5099998, 1.1099993); */\n\n    if (0 == 0) {\n        t = 0.3;\n        ro.xz = rot(ro.xz, sin(t) * 0.3);\n        rd.xz = rot(rd.xz, sin(t) * 0.3);\n        ro.xz = rot(ro.xz, (t));\n        rd.xz = rot(rd.xz, (t));\n    }\n\n\tfloat dist = EPS.y;\n\tbool hit = false;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tif (dist >= MAX_DIST) break;\n\t\tvec3 pos = ro + rd * dist;\n\t\tfloat res = scene(pos);\n\t\tif (abs(res) < 0.001) { hit = true; break; }\n\t\tdist += res * 0.95;\n\t}\n\tvec3 pos = ro + rd * dist;\n\n\tvec3 col = vec3(0.1);\n    if (hit) {\n        vec3 nor = norm(pos);\n        float dif = clamp(dot(nor, vec3(0.57703)), 0.0, 1.0);\n        float amb = 0.5 + 0.5 * dot(nor, vec3(0.0, 1.0, 0.0));\n        col = color(pos) * amb + color(pos) * dif;\n\n\t\tcol = nor * 0.5 + 0.5;\n    }\n\n    // vec2 q = (uv + 1.) / 2.; \n    // col *= 0.5 + 0.5 * pow(20.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 1.1);\n\n     vec2 q = uv * vec2(iResolution.y / iResolution.x, 1);\n     col *= smoothstep(0.0, 1.1, 1. - length(q * 0.4));\n\n    col = pow(clamp(col, 0., 1.), vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}