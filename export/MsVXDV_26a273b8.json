{"ver":"0.1","info":{"id":"MsVXDV","date":"1466833984","viewed":184,"name":"Bloom of Doom","username":"Egomeh","description":"A result of trying out stuff I don't know about : D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    defines and consts\n*/\n# define PI           3.14159265358979323846  /* pi */\n\nconst float EPS = 0.001;\nconst int ITERATIONS = 255;\nconst float FAR = 50.0;\n\nconst vec3 lightPos = vec3(10., 10., 0.);\nconst vec3 lightColor = vec3(1., 1., 1.);\nconst float lightIntensity = 0.2;\n\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nvec3 rotateX(in vec3 p, float ang)\n{\n\tvec3 rotated = p;\n\trotated.y = p.y * cos(ang) - p.z * sin(ang);\n\trotated.z = p.y * sin(ang) + p.z * cos(ang);\n\treturn rotated;\n}\n\nvec3 rotateY(in vec3 p, float ang)\n{\n\tvec3 rotated = p;\n\trotated.x = p.x * cos(ang) + p.z * sin(ang);\n\trotated.z = p.x * -sin(ang) + p.z * cos(ang);\n\treturn rotated;\n}\n\nvec3 rotateZ(in vec3 p, float ang)\n{\n    vec3 rotated = p;\n    rotated.x = p.x * cos(ang) - p.z * sin(ang);\n    rotated.y = p.x * sin(ang) + p.z * cos(ang);\n    return rotated;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat uni(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n\nfloat query(vec3 p)\n{\n    vec3 p3, p2, p4, p5;\n    p5 = p4 = p3 = p2 = p;\n\n    float ang = sin(iTime) + p.y;\n    float ang2 = sin(iTime);\n\n\n    p2.x = mix(mod(p2.x,12.) - 6., p.x, step(20., abs(p.x)));\n    p2.z = mix(mod(p2.z,12.) - 6., p.z, step(20., abs(p.z)));\n\n    vec2 stepVar = floor(p.xz / 12.);\n\n    float steppedBlah = ( (sin(iTime * stepVar.x * .7) * sin(iTime*1.2 + stepVar.x * 3.) ) + 1.) * 2.;\n    steppedBlah += ( (sin(iTime*0.7 * stepVar.y * 4.) * sin(iTime*0.45 + stepVar.y * 4.) ) + 1.) * 2.;\n    float clampedSteppedBlah = clamp(steppedBlah, -5., 5.);\n\n    ang += steppedBlah / 10.;\n\n    p3 = rotateY(p2, ang);\n\n    float bdown = ((sin(iTime)) + 1.) * 0.5;\n    bdown *= 8.;\n\n    p4 = p3 - vec3(0., clampedSteppedBlah - bdown, 0.);\n\n\tp4.x += sin(p.y) * 2.;\n\n    p5 = p3 - vec3(0, clampedSteppedBlah + 6. - bdown, 0.);\n\n    ang2 += steppedBlah / 10.;\n    p5.x = p2.x * cos(ang2) + p2.z * sin(ang2);\n    p5.z = p2.x * -sin(ang2) + p2.z * cos(ang2);\n    \n    \n\n    float d1 = length(p4) - 1.0;\n    float d3 = sdBox(p4, 0.75 * vec3(1.,8.,0.2));\n    //d1 = smin(max(d1, d3), d3, 2.);\n    d1 = d3;\n\n    float d2 = p.y + (sin(p.x + iTime) + 1.) * 0.2\n                + (sin(p.x * 2. + iTime) + 1.) * 0.1\n                + (sin(p.x * 4. + iTime * 1.2) + 1.) * 0.1\n                + (sin(p.z * 2. + iTime) + 1.) * 0.1\n                + (sin(p.z * 4. + iTime * 2.1) + 1.) * 0.1;\n    float res = smin(d1, d2, 1.8);\n\n    float s = sdSphere(p5, exp(p.y / 10.0) - 1.) + sin(p.y * 3.);\n\n\tres = smin(s, res, 1.);\n\n    return res;\n}\n\nfloat intersect(vec3 o, vec3 r, out int iterations, out vec3 p, out bool hit)\n{\n    hit = false;\n\tfloat t = 0.0;\n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n\t\tp = o + r * t;\n        float d = query(p);\n        t += d * (0.2 + rand(p.xy) * EPS);\n        ++iterations;\n        if (d < EPS)\n        {\n            hit = true;\n        \tbreak;\n        }\n\n        if (t > FAR)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n\nvec3 gradient(vec3 p)\n{\n    vec3 px = p;\n    px.x += EPS;\n\n    vec3 py = p;\n    py.y += EPS;\n\n    vec3 pz = p;\n    pz.z += EPS;\n\n    return normalize(vec3(\n        \t\t\tquery(px) - query(p),\n        \t\t\tquery(py) - query(p),\n                    query(pz) - query(p) )\n    );\n}\n\nvec3 phong (in vec3 p, in vec3 normal, in vec3 viewDir, in vec3 matCol)\n{\n    vec3 pointToLight = ( lightPos - p );\n    vec3 lightDir = normalize(pointToLight);\n    vec3 diffuseComponent = matCol * max(0.0, dot(normal, lightDir));\n    vec3 specularComponent = vec3(1., 0., 1.) * pow(max(0.0, dot(reflect(lightDir, normal), viewDir)), 8.);\n    return diffuseComponent + specularComponent * step(0.001, dot(normal, lightDir)) + vec3(0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float theta = iTime * 0.1;\n    float add_angle = PI / 2.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    uv = uv * 2.0 - 1.0;\n    uv.y = -uv.y;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y *= -1.;\n    \n    vec3 rs = normalize(vec3(uv, 1.5) - vec3(0., 0.5, 0.));\n    vec3 r = vec3(cos( (theta + add_angle) ) * rs.x - sin( (theta + add_angle) ) * rs.z,\n                      rs.y,\n                      sin( (theta + add_angle) ) * rs.x + cos( (theta + add_angle) ) * rs.z);\n    r = normalize(r);\n\n    float x = cos(theta);\n    float y = sin(theta);\n    vec3 o = vec3(x, 0.75, y) * 15.;\n    //o = vec3(0,1., -10.);\n    vec3 pos = vec3(0.);\n    bool hit = false;\n    int iterations = 0;\n\n    float t = intersect(o, r, iterations, pos, hit);\n\n    vec3 grad = gradient(pos);\n\n    float hitCol = 1. - step (FAR, t);\n\n    vec3 atmoColor = vec3(0.2,0.32,0.95);\n\n    vec3 viewDir = rs;\n\n    vec3 matCol = mix(vec3(0.25, 0.25, 0.80), vec3(0.87, 0.67, 0.2), pos.y * 0.1);\n    vec3 col = phong(pos, grad, viewDir, matCol);\n\n    col = mix(col, atmoColor, (t / FAR)) * hitCol;\n    col += max(0., (exp(float(iterations)/float(ITERATIONS)))) * vec3(0.2, 0.4, 0.7);\n\n\n\tfragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}