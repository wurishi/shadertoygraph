{"ver":"0.1","info":{"id":"tls3Rj","date":"1556979835","viewed":138,"name":"Multipass DoF","username":"nr4","description":"Simple double-pass DoF. Sorry for the lags.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["dof","field","depth","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Multipass DoF\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 25.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = texture(iChannel0, fragCoord/iResolution.xy).w;\n    d = 5.*smoothstep(4.,8.,clamp(d,4.,8.)) // Far\n          +2.*(smoothstep(3.,1.,clamp(d,1.,3.))); // Near\n\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.+1.*clamp(d,0.,4.);\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+2.*d*vec2(i,j)*3./max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= bound*bound;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Multipass DoF\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0;\n\n// Hash function\nvoid rand(in vec2 x, out float num)\n{\n    x -= 20.;\n    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Rotation\nvoid rot(in vec3 p, out mat3 rot)\n{\n    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nfloat r;\nvoid scene(in vec3 x, out float sdf)\n{\n    // Rotate scene\n    mat3 RR;\n    rot(vec3(1.1,1.33,1.21)-.002*iTime, RR);\n    x = RR*x;\n    \n    // Add spheres\n    sdf = 10.;\n    float size = .1;\n    vec3 y = mod(x, size)-.5*size,\n        ind = (x-y)/size;\n    rand(1.e-5*ind.xy*ind.yz*ind.zx, r);\n\tsdf = length(y)-.05*(r-.85)/.6;\n    \n    // Add guard objects for debugging\n    float dr = .25;\n    y = mod(x,dr)-.5*dr;\n    float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));\n    guard = abs(guard)+dr*.1;\n    sdf = min(sdf, guard);\n}\n\nvoid normal(in vec3 x, out vec3 n)\n{\n    const float dx = 5.e-3;\n    float s;\n    \n    scene(x,s);\n    scene(x+dx*c.xyy, n.x);\n    scene(x+dx*c.yxy, n.y);\n    scene(x+dx*c.yyx, n.z);\n    n = normalize(n-s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinate setup\n    a = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n    \n    // Camera setup\n    vec3 col = c.yyy, \n        o = c.yyx + .3*iTime*c.yxy, \n        t = vec3(uv,0.) + .3*iTime*c.yxy + c.yxy,\n        dir = normalize(t-o),\n        x;\n    float d = 0., s;\n    \n    // Raymarching\n    int N = 250, i;\n    for(i=0; i<N; ++i)\n    {\n        x = o + d * dir;\n        scene(x,s);\n        if(s < 1.e-4) break;\n        d += s;\n    }\n    \n    // Illumination\n    if(i<N)\n    {\n        vec3 n,\n            l = normalize(x+c.yyx);\n        normal(x,n);\n        vec3 c1 = .5*mix(c.xxx,vec3(1.,.66,.1), smoothstep(2.,3.5,d)*(1.-smoothstep(3.5,5.,d)));\n        col = .3*c1\n            + (.3*c1)*abs(dot(l,n))\n            + (1.3*c1+.1*c.xyy)*pow(abs(dot(reflect(-l,n),dir)),3.);\n    }\n\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,d);\n}","name":"Buffer A","description":"","type":"buffer"}]}