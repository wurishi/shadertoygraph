{"ver":"0.1","info":{"id":"l33Xzn","date":"1718599046","viewed":54,"name":"realistic eclipse","username":"mashquapp","description":"Drag the moon over the sun with the mouse.\nBased on https://www.youtube.com/watch?v=t7FP_lyg1uE&t=4s\nSome math in https://www.desmos.com/3d/iyp2dansxr\n\nThe moon does move when resizing the viewport.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["eclipse","solareclipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 skyCoord(vec2 xy)\n{\n    return xy - 0.5 * iResolution.xy;\n}\n\nvec2 denormalize(vec2 xy)\n{\n    return xy * iResolution.xy;\n}\nfloat rmod(float rad) {\n    return mod(rad, 6.283185);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvSky = skyCoord(fragCoord);\n    \n    float pi = 3.14159;\n    float r1 = 45.0;\n    float r2 = 50.0;\n    vec2 sunPos = denormalize(vec2(0.0, 0.3));\n    vec2 moonPos = skyCoord(iMouse.xy);\n    float uvSunDist = length(uvSky - sunPos); // distance from pixel to sun\n    float uvMoonDist = length(uvSky - moonPos); // distance from pixel to moon\n    float dist = length(moonPos - sunPos); // distance from sun to moon\n    \n    float perimeter = sqrt((dist+r1+r2)*(-dist+r1+r2)*(dist-r1+r2)*(dist+r1-r2)); // perimeter of any triangle formed with side lengths dist, r1, and r2\n    float rDiff = r1*r1 - r2*r2;\n    float theta = atan(moonPos.y - sunPos.y, moonPos.x - sunPos.x); // direction of vector sunPos -> moonPos\n    float sunTheta = acos((dist*dist + rDiff)/(2.0*dist*r1)); // if sun is a crescent, this is the angle between vector theta and the vector sunPos -> either corner of the crescent\n    float moonTheta = acos((dist*dist - rDiff)/(2.0*dist*r2)); // if sun is a crescent, this is the angle between vector -theta and the vector moonPos -> either corner of the crescent\n    \n    float brightness = (dist + r1 <= r2)? //percent of sun exposed\n                           0.0 : \n                           (r2 + r1 <= dist)?\n                               1.0 : \n                               (dist + r2 <= r1)? \n                                   1.0 - (r2 * r2) / (r1 * r1) : \n1.0 - (r1*r1*sunTheta + r2*r2*moonTheta - 0.5*perimeter) / (pi*r1*r1); // if sun is a crescent, this is finding the area of that crescent\n    \n    vec2 rPoint = sunPos + r1 * vec2(cos(theta - sunTheta), sin(theta - sunTheta)); // if sun is a crescent, this is calculating the right-most (relative to the sun) corner of the crescent\n    vec2 lPoint = sunPos + r1 * vec2(cos(theta + sunTheta), sin(theta + sunTheta)); // if sun is a crescent, this is calculating the left-most (relative to the sun) corner of the crescent\n    if (isnan(rPoint.x)) {\n        rPoint = sunPos; \n        lPoint = sunPos;\n    }\n    \n    float crescentDist;\n    if (r2 + r1 <= dist) {                              // crescentDist represents a signed distance function to the sun for each of its shapes\n        crescentDist = uvSunDist - r1;\n    }\n    else {\n        if (dist + r2 <= r1) {\n            if (uvSunDist + uvMoonDist <= r1 + r2) {\n                crescentDist = r2 - uvMoonDist;\n            } else {\n                crescentDist = uvSunDist - r1;\n            }\n        }\n        else {\n            if (dist + r1 <= r2) {\n                crescentDist = 1.0;\n            }\n            else {\n                if (uvMoonDist < r2 && abs(rmod(rmod(atan(uvSky.y - moonPos.y, uvSky.x - moonPos.x) - pi) - theta - pi) - pi) < moonTheta) {\n                    crescentDist = r2 - uvMoonDist;\n                }\n                else {\n                    if (uvSunDist > r1 && abs(rmod(rmod(atan(uvSky.y - sunPos.y, uvSky.x - sunPos.x) - pi) - theta) - pi) > sunTheta) {\n                        crescentDist = uvSunDist - r1;\n                    }\n                    else {\n                        crescentDist = min(length(uvSky - rPoint), length(uvSky - lPoint));\n                    }\n                }\n            }\n        }\n    }\n    \n    vec3 col = (uvSunDist <= r1 && uvMoonDist > r2)? \n                   vec3(1.0) : \n                   exp(-0.0002 * (uvSunDist - r1)) * brightness * vec3(0.4, 0.56, 0.8)\n                   + vec3(0.1, 0.14, 0.2)\n                   + pow(brightness, 0.02) * min(1.0, pow(0.5, 0.03 * (0.3 + 0.2 * brightness) * crescentDist));\n    \n    if (uvMoonDist > r2 && uvSunDist > r1) {\n        col += max(0.0, 5.0 / (uvSunDist - r1) - 0.2);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}