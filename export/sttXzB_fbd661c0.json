{"ver":"0.1","info":{"id":"sttXzB","date":"1639364843","viewed":151,"name":"0000-RayCasting","username":"francislarge","description":"Left-click on canvas and move mouse to move light","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["playground"],"hasliked":0,"parentid":"NdlXRN","parentname":"000 Playground"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*************************************************\n\n Left-click on canvas and move mouse to move light cone\n \n***************************************************/\n\nstruct Square\n{\n    vec2  Position;\n    float Size;\n    float Thickness;\n};\n\nstruct FHitResult\n{\n    bool  bWasAHit;\n    float Distance;\n};\n\nconst int   TOTAL_SCENE_SQUARES  = 3;\nconst float SURFACE_DISTANCE     = 0.001;\n\nvoid  AddSquareToScene(inout Square SceneSquares[TOTAL_SCENE_SQUARES], Square SquareToAdd, inout int TotalSquares);\n\nfloat SceneSDF(vec2 RayCurrentPosition, inout Square Squares[TOTAL_SCENE_SQUARES], int ObjectsCount);\n\nFHitResult RayMarch(vec2 RO, vec2 RD, float MaxDistance, inout Square SceneSquares[TOTAL_SCENE_SQUARES], int SquaresCount);\n\nfloat GetSquare( vec2 Position, float Size, vec2 Graph )\n{\n   vec2 SquareToGraph = Graph - Position;\n   SquareToGraph = abs(SquareToGraph);\n   \n   SquareToGraph = max(SquareToGraph - Size, 0.0);\n   \n   return sign(SquareToGraph.x + SquareToGraph.y);\n}\n\nfloat GetSquare(out Square SQ, out vec2 Graph )\n{\n   return  GetSquare(SQ.Position, SQ.Size, Graph ) \n    * ( 1.0 - GetSquare(SQ.Position, SQ.Size + SQ.Thickness, Graph ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Dimension = vec2(512);\n    float AspectRatio = iResolution.x/iResolution.y;\n    \n    vec2 Graph = ( fragCoord / iResolution.xy - vec2(0.5) ) * 0.5;\n    Graph.x  = Graph.x * AspectRatio;\n    Graph *= Dimension;\n    \n    Square SceneObjects[TOTAL_SCENE_SQUARES]; int TotalObjects = 0;\n    AddSquareToScene\n    (\n        SceneObjects,\n        Square( vec2(-100, 0.0), 40.0, 2.0 ),\n        TotalObjects\n     );\n     \n     AddSquareToScene\n    (\n        SceneObjects,\n        Square( vec2(0.0, 50.0), 25.0, 2.0 ),\n        TotalObjects\n     );\n     \n      AddSquareToScene\n      (\n        SceneObjects,\n        Square( vec2(80.0, -50.0), 25.0, 2.0 ),\n        TotalObjects\n      );\n    \n    //Construct ray from mouse position\n    vec2 MousePos = ( iMouse.xy / iResolution.xy - vec2(0.5) ) * 0.5;\n    MousePos.x  = MousePos.x * AspectRatio;\n    MousePos   *= Dimension;\n    \n    float RayRotation = atan(-MousePos.y, -MousePos.x);\n    vec2  RayPosition = MousePos;\n    float RayOpening  = 40.f; //half opening\n    \n   \n    vec2 RayOrientedGraph  = Graph - RayPosition;\n    vec2 Ray_XVector = vec2( cos(RayRotation), sin(RayRotation) );\n    vec2 Ray_YVector = vec2( -Ray_XVector.y, Ray_XVector.x );\n        \n    //Get mask to exclude regions outside cone\n    RayOrientedGraph = transpose( mat2(Ray_XVector, Ray_YVector) ) * RayOrientedGraph;\n    \n    float RayConeMask = abs(radians(RayOpening)) - abs(atan(RayOrientedGraph.y, RayOrientedGraph.x));\n          RayConeMask = max(RayConeMask, 0.0); //remove negatives\n    \n    //Cone Exponenetial fade per distance increase\n    float FadeSpread = 0.00125;\n    RayConeMask = ( 1.f / ( length(RayOrientedGraph) * FadeSpread + 1.0) ) * RayConeMask;\n    \n    float SceneObjectHitMask = 1.0;\n    if( sign(RayConeMask) > 0. ) //only trace for regions within cone\n    {\n        \n        vec2 ToRayPosition = RayPosition - Graph;\n        \n        //Shadow trace\n        FHitResult HitResult = RayMarch(\n            Graph, //Ray Origin\n            normalize( ToRayPosition ), //Ray Direction\n            length( ToRayPosition ),  //Trace distance\n            SceneObjects,\n            TotalObjects\n        );\n        \n        SceneObjectHitMask = HitResult.bWasAHit ? 0.0 : 1.0;\n    }\n    \n    //Get all scene squares\n    float SquaresMask = 0.0;\n    for(int i = 0; i < TotalObjects; i++)\n    {\n        SquaresMask += GetSquare(SceneObjects[i], Graph);\n    }\n    \n    //Final mix \n    const vec3 COLOR_LIGHT   = vec3(1., 0.5, .1) ,\n               COLOR_OBJECTS = vec3(0.2, 0.9, 0.6 ) ;\n          \n    vec3 Final = COLOR_LIGHT   * (RayConeMask * SceneObjectHitMask);\n    Final     += COLOR_OBJECTS * (SquaresMask*0.125);\n    \n    //Exposure and Gamma\n    const float GAMMA    = 2.2,\n                EXPOSURE = 1.;\n                \n    Final = vec3(1.0) - exp(-Final*EXPOSURE);\n    Final = pow(Final, vec3(1./GAMMA) );\n            \n    fragColor.rgb = vec3( Final ) ;\n}\n\nFHitResult RayMarch(vec2 RO, vec2 RD, float MaxDistance, inout Square SceneSquares[TOTAL_SCENE_SQUARES], int SquaresCount)\n{    \n    float MarchDistance = 0.0;\n    \n    FHitResult HitResult = FHitResult(false, 0.);\n    \n    while( MarchDistance <= MaxDistance )\n    {\n        \n        float DistanceToScene = SceneSDF(\n                RO + RD * MarchDistance, \n                SceneSquares, \n                SquaresCount\n        );\n        \n        if(DistanceToScene < SURFACE_DISTANCE) //if current distance is close enough to surface\n        {\n            HitResult.bWasAHit = true;\n            HitResult.Distance = MarchDistance;\n            break;\n        }\n        \n        MarchDistance += DistanceToScene;\n    \n    }\n    \n    HitResult.Distance = MarchDistance;\n    \n    return HitResult;\n}\n\n\n\nfloat SceneSDF(vec2 RayCurrentPosition, inout Square Squares[TOTAL_SCENE_SQUARES], int ObjectsCount)\n{\n    float ClosestDistance = 300000000.0;\n    for(int i = 0; i < ObjectsCount; i++)\n    {\n        vec2 DistanceToRay = RayCurrentPosition - Squares[i].Position;\n    \n        vec2 DistanceToBoundary = abs(DistanceToRay) - (Squares[i].Size+Squares[i].Thickness);\n    \n        DistanceToBoundary = max(DistanceToBoundary, vec2(0.0)); \n    \n        float CurrentDistance = length(DistanceToBoundary);\n       \n        //Distance check\n        if(CurrentDistance < ClosestDistance)\n        { \n            ClosestDistance  = CurrentDistance;\n        }\n    }\n    \n    return ClosestDistance;\n}\n\nvoid AddSquareToScene(inout Square SceneSquares[TOTAL_SCENE_SQUARES], Square SquareToAdd, inout int TotalSquares)\n{\n    if(TotalSquares < TOTAL_SCENE_SQUARES)\n    {\n        SceneSquares[TotalSquares] = SquareToAdd;\n        ++TotalSquares;\n    }\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}