{"ver":"0.1","info":{"id":"MdXcWn","date":"1487653138","viewed":285,"name":"Hilbert Simplified","username":"marciot","description":"Trying to understand how the Hilbert shader works by refactoring the original code.\n\nBased on https://www.shadertoy.com/view/XljSW3","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","hilbertcurve","spacefilling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This shader is based on https://www.shadertoy.com/view/XljSW3,\n * but I have been refactoring the code in order to understand it\n * better.\n */\n\n/* The following page provides a good reference, but be careful that the\n * diagram is upside-down relative to what is implemented here.\n *\n *  https://www.fractalus.com/kerry/tutorials/hilbert/hilbert-tutorial.html\n */\n\n\n#define swap(a,b) tmp=a; a=b; b=tmp;\n\nfloat plot(in vec2 U, in vec2 dir, in float s) {\n    vec2 perpendicular = vec2(-dir.y,dir.x);\n    float thickness    = .7*s/iResolution.y;\n\n    if( dot(U,dir) > 0. ) {\n        return 1. - step(thickness, abs(dot(U,perpendicular)));\n    } else {\n\t\treturn 0.;\n    }\n}\n          \n// symU and rotU apply to vectors that range from 0 to 1\nvoid symU(inout vec2 u) {\n    u.x = 1.-u.x;\n}\n\nvoid rotU(inout vec2 u) {\n    u.xy = vec2(u.y,1.-u.x);\n}\n\n\n// symV and rotV apply to unit vectors that range from -1 to 1\n\nvoid symV(inout vec2 v) {\n    v.x= -v.x;\n}\n\nvoid rotV(inout vec2 v) {\n    v.xy = vec2(v.y,-v.x);\n}\n\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    const bool  paintQuads = false;\n    const float iter       = 4.;\n    \n    U /= iResolution.y;\n    \n    // Horizontal offset to center the figure\n    U.x -= 0.3;\n    \n    vec2 P = vec2(.5);\n    vec2 I = vec2(1,0);\n    vec2 J = vec2(0,1);\n    \n    \n    // l controls the entry into the Hilbert curve.\n    // Set to J to enter from the top; -I to enter from\n    // the left\n    vec2 l = -I;\n    \n    // r initially has no value, but gets updated\n    // inside the loop.\n    vec2 r;\n    \n    vec2 qU;\n\tvec2 tmp;\n    \n    for (float i = 0.; i < iter; i++) {\n        qU      = step(.5,U);         // select quadrant\n        bvec2 q = bvec2(qU);          // convert to boolean\n        \n        U       = 2.*U - qU;          // go to new quadrant\n        \n        // qU:               q:\n        //      0,1  | 1,1      f,t | t,t\n        //     ------|-----    -----------\n        //      0,0  | 1,0      f,f | t,f\n        \n        // l and r are adjusted based on quadrant, but I\n        // don't quite understand how they work.\n        //\n        // l:                r:\n        //       l  | -J       -J |  I\n        //     -----|-----    ----------\n        //       J  | -I        I |  J\n        \n        l = q.x ? (q.y ? -J : -I)            // node left segment\n                : (q.y ?  l :  J);\n                    \n\n        r = (q.x==q.y)?  I : (q.y ?-J:J);    // node right segment\n        \n        // the heart of Hilbert curve : \n        if (q.x) { // sym\n        \tsymU(U);\n            symV(l);\n            symV(r);\n            swap(l,r);\n       \t}\n        if (q.y) { // rot+sym\n            rotU(U); symU(U);\n            rotV(l); symV(l);\n            rotV(r); symV(r);\n       \t}\n    }\n    \n    // s controls the line thickness, it must\n    // increase with iter to keep it invariant\n    // to scale.\n    float s=pow(2., iter);\n\n    o  = vec4(0.0);\n    o += plot (U-P, l, s) * vec4(1.,0.25,0.25,1.);\n    o += plot (U-P, r, s);\n    \n\t// Paint different quadrants:\n    //\n    //    blue   |  cyan\n    //    ---------------\n    //    black  |  green\n    \n    if(paintQuads) {\n    \to += vec4(0., qU.x, qU.y,1.) * 0.15;\n    }\n}","name":"Image","description":"","type":"image"}]}