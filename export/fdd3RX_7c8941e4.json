{"ver":"0.1","info":{"id":"fdd3RX","date":"1630366831","viewed":390,"name":"Rope using Verlet Integration","username":"MarvelousBilly","description":"This doesn't really work, and I can't figure out why. It might just be because shaders are not the right fit for this kinda thing :/","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["rope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distToCircle(vec2 p, vec2 c, float r){\n    return distance(p,c)-r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 offset(vec2 p){\n    return (p);// - (vec2(0,-303)/2.) - (iResolution.xy / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 draw = vec3(0.);\n    for(int i = 0; i < amt; i++){\n        vec3 cir = texelFetch(iChannel0, ivec2(i*2,0), 0).rgb;\n        /*if(distToCircle(offset(fragCoord),cir.xy,3.) < 0.){\n            if(cir.b == 255.) //draw the points\n                draw = vec3(0.,1.,0.);\n            else\n                draw = vec3(float(i+1)/5.,0.,0.);\n        }*/\n        if(i < amt - 1){\n            vec3 seg2 = texelFetch(iChannel0, ivec2((i+1)*2,0), 0).rgb;\n\n            if(sdSegment(offset(fragCoord),cir.xy,seg2.xy) < 3.){\n                draw += vec3(0.973,0.902,0.027);\n            }\n        }\n    }\n    if(distToCircle(offset(fragCoord),obj,size) < 0.){\n        draw+=vec3(0.8);\n    }\n\n    fragColor = vec4(draw,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer which stores all the points in the scene. \n//The z coord is going to be the state; 1 for locked, 0 for unlocked.\n//The x and y coords is the position vector.\n//The position in the buffer is the order of the points.\n//But only every other pixel, as the other ones are the previous position.\n\nvec3 init(vec2 p){\n    if(p.y < 1.){\n        float locked = 0.;\n        if(int(p.x) == 0){\n            locked = 0.;\n        }\n        return vec3(5.+p.x*stickLength/2., 300.+p.y*6., locked);\n    }\n}\n\nbool limit(vec2 p){\n    return (p.x < float(amt)*2. && p.y < 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    if(limit(fragCoord)){\n        if(iFrame == 0){\n            //initialize \n            if(int(fragCoord.x) % 2 == 1){\n                fragColor = vec4(init(fragCoord-vec2(1.,0.)),1.);\n                return;\n            }\n            fragColor = vec4(init(fragCoord),1.);\n            return;\n        }\n        for(int i = 0; i < amt*2; i++){\n            vec3 col = texelFetch(iChannel0, ivec2(i,0), 0).xyz;\n            points[i].val = col.xyz; //sets all of points array\n        }\n\n        vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n        //grab the positions\n        vec2 pos = vec2(col.x,col.y);\n        //set the positions\n        vec2 prev = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(1,0), 0).xy;\n        //set the previous position (1 to the right of current pixel)\n\n        if(int(fragCoord.x) % 2 == 1){ //if i need to update previous\n            vec4 col = texelFetch(iChannel0, ivec2(fragCoord)-ivec2(1,0), 0);\n            fragColor = vec4(col.xyz,1.); //update the previous position\n            return;\n        }\n        if(col.z == 0.){ //should it move?\n            pos += pos-prev.xy; //move\n            vec2 down = vec2(0.,-1.);\n            //pos = pos * 2. - prev + (grav*down)*iTimeDelta*iTimeDelta;\n            pos += down * grav * iTimeDelta; //move down with gravity\n        }\n        if(int(fragCoord.x) == 0){\n            if(iMouse.z > 0.5){\n                col.z = 255.;\n                pos.xy = iMouse.xy;\n\n            }\n            else{\n                col.z = 0.;\n            }\n        }\n        points[int(fragCoord)].val = vec3(pos.xy,col.z);\n\n\n        for(int i = 0; i < 10; i++){\n            for(int j = 0; j < (amt*2); j++){ //for each set of lines\n                if(j < (amt * 2) - 3){\n                    vec3 posA = points[j].val;\n                    vec3 posB = points[j+2].val;\n\n                    vec2 stickCenter = (posA.xy+posB.xy)/2.;\n                    vec2 stickDir = normalize(posA.xy-posB.xy);\n\n                    if(posA.z == 0.){ //if unlocked\n                        posA.xy = stickCenter + stickDir * stickLength / 2.;\n                    }\n\n                    if(posB.z == 0.){ //if unlocked\n                        posB.xy = stickCenter - stickDir * stickLength / 2.;\n                    }\n                        \n                    points[j].val = posA;\n                    points[j+2].val = posB;\n\n                }\n            }\n                    for(int i = 0; i < amt*2; i++){ //check for collisions\n            vec2 pos = points[i].val.xy; //sets all of points array\n            if(distance(pos,obj)-size < 0.){\n                vec2 dir = normalize(pos-obj);\n                pos = obj + dir * size;\n                points[i].val.xy = pos;\n            }\n            if(pos.y < 0.){\n                points[i].val.y = 0.;\n            }\n        }\n        \n        }\n        \n\n        fragColor = vec4(points[int(fragCoord)].val,1.);\n    }\n    \n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat grav = 500.;\nfloat stickLength = 10.;\nconst int amt =63;\n\nvec2 obj = vec2(300,200);\nfloat size = 50.;\n\n\nstruct point{\n    vec3 val;\n};\npoint points[amt*2];\n","name":"Common","description":"","type":"common"}]}