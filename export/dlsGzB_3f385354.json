{"ver":"0.1","info":{"id":"dlsGzB","date":"1672020648","viewed":46,"name":"teste2","username":"b11","description":"2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\nfloat blendSDF(float sda, float sdb, float k) {\n    float h = clamp(0.5 + 0.5 * (sdb - sda) / k, 0.0, 1.0);\n    return mix(sdb, sda, h) - k * h * (1.0 - h);\n}\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\nfloat getDist(vec3 p) {\n    float planeDist = p.y+1.;   \n    //float s = sin(iTime);\n    //vec3 bp = p - vec3(3, 0.75, 7);\n    //bp.xz *= Rot(iTime); \n    //vec3 tp = p - vec3(0, 0.5, 6);\n    //tp.y -= s;    \n    //vec3 bp2 = p - vec3(-3, 0.75, 6);\n    //bp2.y -= -s; \n    //float cx = -3.0;\n    //cx -= s;    \n    //vec3 a = vec3(0, 0.3, 3);\n    //vec3 b = vec3(3, 0.3, 5);\n    //vec3 ab = normalize(b - a).zyx;\n    //ab.x = -ab.x;\n    //a -= s * ab;\n    //b -= s * ab; \n    float sd  = dSphere(p, vec4(0, 1, 6 , 1));\n    //float sd3 = dSphere(p, vec4(cx, 3, 8, 1));\n    //float sd4 = dSphere(p, vec4(-2, 3, 8, 1));    \n    float d = min(sd, planeDist); \n    return d;\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n/*vec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));  \n    return normalize(n);\n}*/\n\nvec3 getNormalFromDistanceField(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));  \n    return normalize(n);\n}\n\nvec3 getNormal(vec3 p, sampler2D bumpMap) {\n    vec2 texCoord = vec2(p.x, p.z); // calculate texture coordinates\n    vec3 bump = texture(iChannel0, texCoord).rgb; // sample bump map\n    bump = bump * 2.0 - 1.0; // convert from [0, 1] to [-1, 1] range\n    vec3 n = getNormalFromDistanceField(p); // get normal from distance field\n    n += bump; // perturb normal using bump map\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p, vec3 ro, sampler2D bumpMap) {\n    vec3 lightPos = vec3(0, 5, 6);\n   \n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p,  bumpMap);\n    vec3 r = reflect(-l,n);\n   \n    float amb = 0.1;\n    float ka = 1.0;\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float kd = 0.8;\n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    float ks = 1.0;\n    float d = rayMarch(p + 2. * n * SURF_DIST , l);\n\n    if (d < length(lightPos - p)) {\n      \n        dif *= 0.1;\n        spec *= 0.5;\n    } \n    return ka * amb + kd * dif + ks * spec;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); \n    vec3 ro = vec3(0, 2, 0); \n    \n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1));      \n      \n    \n    vec3 rd = normalize(vec3(uv, 1));\n    rd *= rotateY(sin(iTime) * 0.5);\n    //rd.yz *= Rot(PI * 10. / 180.); \n    \n    float d = rayMarch(ro, rd); \n    vec3 p = ro + rd * d;\n    float light_intensity = getLight(p, ro, iChannel0); \n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb; \n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n    vec3 color;\n  \n    if (d < MAX_DIST)  \n        color = surface_color * vec3(light_intensity);\n    else \n        color = background_color;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}