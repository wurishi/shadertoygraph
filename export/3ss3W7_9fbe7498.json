{"ver":"0.1","info":{"id":"3ss3W7","date":"1546546741","viewed":208,"name":"Architectural Volute II","username":"TLC123","description":" Still work in progress\n I intended to define it as  two points, each with a curl number, a filament width and some overall swirl radius for each point.  \nI guess some of the shapes are nice.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["volute"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"2 * 2d -> 3d  \" by TLC123. https://shadertoy.com/view/MlyfRW\n// 2019-01-04 13:16:32\n\n// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n//https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n#define E 2.71828\n\nconst float PI = acos(-1.0);\n\nfloat smin(float a, float b) {\n    const float k = 1.921;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\nfloat smax(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat spiral(vec2 p, float a, float b, float w, float angle, float rmax) {\n    //https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    //# calculate the target radius and theta\n    float r = length(p);\n    float t = atan(p.y, p.x) + angle;\n\n    //# early exit if the point requested is the origin itself\n    //# to avoid taking the logarithm of zero in the next step\n    if (r == 0.)\n        return 0.;\n\n    //# calculate the floating point approximation for n\n    //# calculate n\n    float n = floor((log(r / a) / b - t) / (2.0 * PI));\n\n    //# find the two possible radii for the closest point\n    float lower_r = a * exp(b * (t + 2.0 * PI * n));\n    float upper_r = lower_r * exp(2.0 * PI * b);\n\n    //# return the minimum distance to the target point\n    return\n    max((r - rmax),\n        (min(abs(upper_r - r), abs(r - lower_r)) - w)\n    );\n\n}\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\n\n\nfloat sdvolute( in vec2 p, in vec2 a, in vec2 b, float curla, float curlb) {\n    vec2 pa = p - a, ba = b - a, pb = p - b;\n    float bal = length(ba);\n    float pal = length(pa);\n    float pbl = length(pb);\n    float h = clamp(dot(pa, ba) / dot(ba, ba), -0., 1.);\n    float theta = atan(ba.y, ba.x);\n\n    float d1 = spiral(pa, 1., .5, 0.75, PI + .9, 6.);\n    float d2 = spiral(pb, 1., .5, 0.75, .9, 6.);\n\n    //float   dl=abs(sdLine( p, a, b )-bal*0.5)+1.;\n    // float d12mix=mix(d1,d2,smoothstep(0.,1.,smoothstep(0.,1.,smoothstep(0.,1.,h))));\n    return smin(d1, d2);\n}\n\n\n\n \n\n \n\n\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n\n    p = abs(p) - c + r;\n    if (p.x >= 0.0 && p.y >= 0.0)\n        return length(p) - r.x;\n    else\n        return max(p.x, p.y) - r.x;\n}\n\nfloat shape1(vec2 p) {\n\n    float d = 0.25 * sdvolute(p * 1.,\n        vec2(-4. + sin(iTime * 0.7) * 0.5, 1.8 + 1. * cos(iTime * 0.5)),\n        vec2(4. - sin(iTime * 0.7) * 0.5, -1.8 - 1. * cos(iTime * 0.5)),\n        sin(iTime * 0.3) * 0.75,\n        sin(iTime * 0.5) * 0.75);\n\n\n    return (d);\n}\nfloat shape2(vec2 p) {\n\n    float d = roundrect(p - vec2(-4.1, 0), vec2(4., .6), vec2(.05));\n\n\n    d = min(d, roundrect(p - vec2(-.085, 0.), vec2(.025, .8), vec2(.03)));\n    d = min(d, roundrect(p - vec2(-.185, 0.), vec2(.025, .7), vec2(.03)));\n    d = min(d, length(p - vec2(-.36, 0.)) - .4);\n\n\n\n\n    return (d);\n}\n\n\nvec2 map(vec3 p) {\n\n    p = vec3((fract(p.x / 28.)) * 28., p.y, (fract(p.z / 28.)) * 28.); // repeat\n    p = p - vec3(14, 0, 9); //translate\n\n    //p=p-vec3(10,0,10);\n\n    p.xz = abs(p.xz); //mirror\n    p = p - vec3(3.5, 0, 3.5);\n\n    //p=p-vec3(10,0,5);\n\n    float an = .66; //additional angle\n    p = vec3((p.x * cos(an) - p.z * sin(an)), p.y, (p.z * cos(an) + p.x * sin(an)));\n    float plane = abs(p.y + 6.6);//making geound floor\n\n    p = p.yxz; // orienting upright\n    p.x = -p.x; //flip\n    p.z = -p.z; //flip\n\n    float w = shape1(p.xz); //building shape on shape\n    float d = shape2(vec2(w, p.y));\n\n\n    return (d < plane) ? vec2(d, 1.0) : vec2(plane, 2.0);\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 1.1 * h / t);\n        t += h;\n        if ((h < 0.001) || (t > maxt)) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for (int i = 0; i < 170; i++) {\n        vec3 pos = ro + rd * t;\n        res = map(pos);\n        if ((res.x < kEps) || (t > kTMax)) {\n            break;\n        }\n        t += res.x * 0.5;\n\n    }\n\n    if (t < kTMax) {\n        return vec2(t, res.y);\n    } else {\n        return vec2(-1.0);\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.005, 0);\n    float dp = map(p).x;\n    return normalize(vec3(dp - map(p - e.xyy).x,\n        dp - map(p - e.yxy).x,\n        dp - map(p - e.yyx).x));\n}\n\nmat3 calcCamera(vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = cross(cw, vec3(0, 1, 0));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n    vec2 mo = vec2(0.95, -0.2);\n    if (iMouse.z > 0.5) {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2(0.4, 0.1);\n    }\n    mo += 3.14159 * 2.5;\n\n    vec3 eye = vec3(-50.0 * cos(mo.x + iTime * .13), 20.0 + 20.0 * cos(mo.y), 60.0 * sin(mo.x + iTime * .3));\n    vec3 target = vec3(0.0, 3.0, 0.0);\n\n    mat3 cam = calcCamera(eye, target);\n\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, 2.0));\n\n    vec3 col = vec3(1.0);\n\n    vec2 res = trace(eye, rd);\n    if (res.x > 0.0) {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal(pos);\n        vec3 ldir = normalize(vec3(-10.5, 20.8, 24.0));\n\n        if (res.y < 1.5) {\n            col = 0.5 + 0.5 * nor.zzx;\n            float dif = max(dot(nor, ldir), 0.0);\n            vec3 ref = reflect(rd, nor);\n            float spe = pow(clamp(dot(ref, ldir), 0.0, 1.0), 15.0);\n\n            col *= (0.3 + 0.7 * dif);\n            float edge = pow(1.0 - dot(-rd, nor), 1.1);\n            col += 0.8 * edge + spe;\n        }\n\n        float sh = calcShadow(pos, ldir, 0.1, 30.0);\n        col *= (0.5 + sh);\n    }\n\n\n\n\n    if (fract(iTime / 5.) < 0.153) {\n        // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n\n        float len = shape1(uv * 15. - vec2(0, 0));\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        fragColor = vec4(col * col, 1.0);\n    }\n    if (fract(iTime / 5.) < 0.0565) {\n        // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n        float len = shape2(uv * 5. - vec2(2, 0)) / 4.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n\n        fragColor = vec4(col * col, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}