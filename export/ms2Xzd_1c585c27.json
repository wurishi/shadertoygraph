{"ver":"0.1","info":{"id":"ms2Xzd","date":"1670775789","viewed":53,"name":"2D Gradient noise","username":"surma","description":"Noise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint esgtsa(uint s)\n{\n    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    return s;\n}\n\nmat3 translation(vec2 p) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        p.x, p.y, 1.0\n    );\n}\n\nmat3 scale(vec2 p) {\n    return mat3(\n        p.x, 0.0, 0.0,\n        0.0, p.y, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nfloat rng(vec2 uv) {\n    //return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n    float f = 1000.;\n    return float(esgtsa(esgtsa(uint(uv.x * f)) + uint(uv.y * f)))/float(1<<30) ;\n}\n\nvec2 gradient(vec2 uv) {\n    float alpha = rng(uv) * 2. * 3.1415;\n    return mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha)) * vec2(1.0, 0.0);\n    //return normalize(vec2(rng(uv), rng(uv + vec2(1.))));\n    \n}\n\nfloat gradient_noise(vec2 uv) { \n    vec2 w = smoothstep(vec2(0.), vec2(1.), fract(uv));\n    vec2 tl = floor(uv);\n    vec2 tr = tl + vec2(1.0, 0.0);\n    vec2 bl = tl + vec2(0.0, 1.0);\n    vec2 br = tl + vec2(1.0, 1.0);\n    vec2 g_tl = gradient(tl);\n    vec2 g_tr = gradient(tr);\n    vec2 g_bl = gradient(bl);\n    vec2 g_br = gradient(br);\n    \n    float v_tl = dot(g_tl, uv - tl);\n    float v_tr = dot(g_tr, uv - tr);\n    float v_bl = dot(g_bl, uv - bl);\n    float v_br = dot(g_br, uv - br);\n    \n    return mix(\n        mix(v_tl, v_tr, w.x),\n        mix(v_bl, v_br, w.x),\n        w.y\n    ) + 0.5;\n}\n\nfloat fbm_gradient_noise(vec2 uv, float num_octaves) {\n    float acc = 0.0;\n    float att = 0.5;\n    float scale = 1.;\n    for(float i = 1.; i <= num_octaves; i++) {\n        acc += gradient_noise(uv * pow(2., i - 1.)) * pow(.5, i);\n    }\n    // a*r^0 + a*r^1 + ...+ a*r^(n-1)\n    // = a * sum[i=0...n](r^i)\n    // = a * [(1-r^n) / (1 - r)]\n    float normalize_factor = (1. - pow(0.5, num_octaves+1.)) / (1. - 0.5) - 1.;\n    return acc / normalize_factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_in = fragCoord / iResolution.xy;\n\n    float s = log(iMouse.x / iResolution.x) / 2.;\n    vec2 offset = vec2(1000., 1000.);\n         \n    vec2 uv = (inverse(translation(vec2(.5)) * scale(vec2(s)) * translation(-1. * offset)) * vec3(uv_in, 1.)).xy;\n    \n\n    // Output to screen\n    vec4 white = vec4(1.);\n    vec4 black = vec4(vec3(0.), 1.);\n    vec4 uv_color = vec4(fract(uv), 0., 1.);\n    fragColor = mix(\n        mix(uv_color, black, .7), \n        white, \n        pow(fbm_gradient_noise(uv, 4.0), (iMouse.y/iResolution.y - .5) * 10.)\n    );\n}","name":"Image","description":"","type":"image"}]}