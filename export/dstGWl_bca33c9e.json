{"ver":"0.1","info":{"id":"dstGWl","date":"1714352539","viewed":53,"name":"Stochastic Tri-Planar Test","username":"soncho_E","description":"Stochastic Tri-Planar Test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stochastictriplanar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" #define TIGHT_BLEND 1\n \n float PI = 3.14159265359;\n mat3 rot;\n     \n mat3 rotationXY(vec2 angle) {\n \tvec2 c = cos(angle);\n \tvec2 s = sin(angle);\n \treturn mat3(\n \t\tc.y, 0.0, -s.y,\n \t\ts.y * s.x, c.x, c.y * s.x,\n \t\ts.y * c.x, -s.x, c.y * c.x\n \t);\n }\n \n // Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n // Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\n float hash(vec2 p) {\n    return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n }\n \n float hash3D(vec3 p) {\n    return hash(vec2(hash(p.xy), p.z));\n }\n \n vec4 sampling(vec2 p) {\n     if (length(p) <= 1.0) {\n         // normal = 3D position on unit sphere\n         vec3 n = rot * vec3(p, sqrt(1.0 - dot(p, p)));\n\n #if TIGHT_BLEND\n         vec3 a = max(vec3(0.0), abs(n) - sqrt(3.0)/3.0);\n         vec3 w = a / (a.x + a.y + a.z);\n #else\n         vec3 w = n * n;\n #endif\n         if (p.x > 0.0) {\n             vec2 g; // maximum projection\n             if (w.x > w.y && w.x > w.z)\n                 g = n.yz;\n             else if (w.y > w.z)\n                 g = n.xz;\n             else\n                 g = n.xy;\n \n             float pixDeriv = length(vec2(length(dFdx(n)), length(dFdy(n))));\n             float pixScale = 1.0 / pixDeriv;\n\n             float h = hash3D(floor(n * pixScale));\n       \n             vec2 t;\n             if (w.z > h)\n                 t = n.xy;\n             else if (w.z + w.y > h)\n                 t = n.xz;\n             else\n                 t = n.yz;\n\n             return vec4(t * 0.5 + 0.5, 0, 1);\n             //return textureGrad(iChannel0, t, dFdx(g), dFdy(g));\n         }\n         else {\n    \n             return vec4(vec3(n.xy * w.z + n.xz* w.y,+ n.yz * w.x), 1);\n             //return vec4(w, 1);\n             //return \n             //    texture(iChannel0, n.xy) * w.z + \n             //    texture(iChannel0, n.xz) * w.y + \n             //    texture(iChannel0, n.yz) * w.x;\n         }\n     }\n     else\n         return vec4(1, 1, 1, 1);\n }\n \n void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \tvec2 p = (fragCoord.xy / iResolution.xy - 0.5) * vec2(2.0 * iResolution.x / iResolution.y, 2.0);\n     rot = rotationXY(vec2(iMouse.yx / iResolution.yx) * vec2(PI, -2.0 * PI) + vec2(PI * -0.5, PI * 0.5));\n     fragColor = sampling(p);\n }","name":"Image","description":"","type":"image"}]}