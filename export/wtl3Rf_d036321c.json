{"ver":"0.1","info":{"id":"wtl3Rf","date":"1557187785","viewed":302,"name":"Logo de Game Dev Planet","username":"bitnenfer","description":"Portada de las diapositivas para la presentacion del 7 de Mayo de 2019.\n// en\nThis is the cover for the slides of a small presentation I made. This is the logo of the meetup I'll be presenting at. \"GameDev Planet\"","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The depth of field imlpementation was taken from:\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n// So all credits to the effect go to the author.\n#define USE_DOF 1\n\n#define PI 3.14159265359\n#define PI2 (PI*2.0)\n\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\treturn abs(coc) * 10.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    #if USE_DOF\n    float depth = texture(iChannel0, uv).w;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n\tfloat blurSize = getBlurSize(depth*0.6, 1.1, 0.65)*.5;\n    vec3 color = vec3(0.0);\n    float steps = 1.0;\n    \n    for (float r = 0.0; r < PI2; r += 0.1)\n    {\n    \tvec2 cs = vec2(cos(r), sin(r))*pixelSize*blurSize;\n        float colr = texture(iChannel0, uv + cs + vec2(0.0, 0.0)*pixelSize*blurSize).r;\n    \tfloat colg = texture(iChannel0, uv + cs + vec2(0.5, 0.0)*pixelSize*blurSize).g;\n    \tfloat colb = texture(iChannel0, uv + cs + vec2(-0.5, 0.0)*pixelSize*blurSize).b;\n    \n        color += vec3(colr, colg, colb) * 1.2;\n        steps += 1.0;\n    }\n    \n    fragColor = vec4(color/steps, 1.0);\n    #else\n    fragColor = vec4(texture(iChannel0, uv).rgb * 1.2, 1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Game Dev Planet\n\n#define USE_REFLECTION 0\n\n#define MATERIAL_NONE 0.0\n#define MATERIAL_FACE 1.0\n#define MATERIAL_BUTTON 2.0\n#define MATERIAL_FLOOR 3.0\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nconst vec3 E = vec3(0.0, 0.0001, 1.0);\n\nmat2 rot(float r)\n{\n    float cr = cos(r);\n    float sr = sin(r);\n    return mat2(cr, sr, -sr, cr);\n}\n\nfloat mapEyeballs(vec3 p)\n{\n    float eyeBallL = length(p + vec3(-0.3, 0.0, 0.9)) - 0.15;\n    float eyeBallR = length(p + vec3(+0.3, 0.0, 0.9)) - 0.15;\n    \n    return min(eyeBallL, eyeBallR);\n}\n\nfloat mapButtons(vec3 p)\n{\n    p += vec3(0.99, 0.51, 2.3);\n    p.xz *= rot(-0.2);\n    p.xy *= rot(-0.27);\n    float dirBtns0 = sdBox(p, vec3(0.13, 0.04, 0.02));\n    float dirBtns1 = sdBox(p, vec3(0.04, 0.13, 0.02));\n    float dirBtns = min(dirBtns0, dirBtns1) - 0.02;\n    \n    p += vec3(0.0, -0.45, -0.05);\n    const float sep = 0.1;\n    const float rad = 0.065;\n    float acBtns0 = length(p + vec3(sep, 0.0, 0.0)) - rad;\n    float acBtns1 = length(p + vec3(-sep, 0.0, 0.0)) - rad;\n    float acBtns2 = length(p + vec3(0.0, sep, 0.0)) - rad;\n    float acBtns3 = length(p + vec3(0.0, -sep, 0.0)) - rad;\n    float acBtns = min(acBtns0, min(acBtns1, min(acBtns2, acBtns3)));\n    \n    return min(dirBtns, acBtns);\n}\n\nvec2 mapButtonsAndEyeballs(vec3 p)\n{\n    float eyeBalls = mapEyeballs(p);\n    float buttons = mapButtons(p);\n    \n    return vec2(min(eyeBalls, buttons), MATERIAL_BUTTON);\n}\n\nvec2 mapFloor(vec3 p)\n{\n    float floorShape = p.y + 1.0;\n    vec3 rep = vec3(5.0, 0.0, 3.0);\n    vec3 p2 = mod(p+vec3(0.0, 0.8, 0.0), rep) - rep * 0.5;\n    \n    float box0 = sdBox(p2, vec3(0.5, 4.3, 0.5)) - 0.05;\n    \n    floorShape = min(floorShape, box0);\n    \n    return vec2(floorShape, MATERIAL_FLOOR);\n}\n\nfloat mapCable(vec3 p)\n{\n    float clip = length(p + vec3(1.9, 0.0, 0.4)) - 2.1;\n    p += vec3(0.3, -0.17, 0.9);\n    p.yz *= rot(-0.4);\n    p.xy *= rot(-0.1);\n    float torus = sdTorus(p, vec2(1.5, 0.08));\n    torus = max(torus, -clip);\n    return torus;\n}\n\nfloat mapController(vec3 p)\n{\n    p += vec3(0.9, 0.3, 2.2);\n    p.xy *= rot(3.14 / 2.0 - 0.25);\n    float cap = sdCapsule(p, vec3(0.2, 0.0, 0.0), vec3(-0.2, 0.0, 0.0), 0.3);\n    p.yz *= rot(0.2);\n    float clip0 = sdBox(p + vec3(0.0, -0.2, 0.3), vec3(0.5, 0.5, 0.2));\n    float clip1 = sdBox(p + vec3(0.0, -0.2, -0.3), vec3(0.5, 0.5, 0.2));\n    float clip = min(clip0, clip1);\n    \n    return max(cap, -clip);\n}\n\nvec2 mapFace(vec3 p)\n{\n    float scene = 1e9;\n    scene = length(p) - 1.0;\n    scene = min(scene, mapCable(p));\n    scene = min(scene, mapController(p));\n        \n    return vec2(scene, MATERIAL_FACE);\n}\n\nvec2 minMaterial(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy *= rot(-0.35);\n    vec2 faceShape = mapFace(p2);\n    vec2 buttonsAndEyeballsShape = mapButtonsAndEyeballs(p2);\n    vec2 floorShape = mapFloor(p);\n    vec2 scene = minMaterial(faceShape, buttonsAndEyeballsShape);\n    \n    scene = minMaterial(scene, floorShape);\n    \n    return scene;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n        map(p + E.yxx).x - map(p - E.yxx).x,\n        map(p + E.xyx).x - map(p - E.xyx).x,\n        map(p + E.xxy).x - map(p - E.xxy).x\n    ));\n}\n\nfloat getShadow(vec3 P, vec3 N, vec3 L) {\n    \n    float t = 0.01;\n    vec3 rd = L;\n    vec3 ro = P;\n    float shadowContrib = 1.0;\n    for (int i = 0; i < 20; i++)\n    {\n        vec2 scene = map(ro + rd * t);\n        shadowContrib = min(shadowContrib, 2.*scene.x / t);\n        t += clamp(scene.x, 0.1, 0.01);\n        if (scene.x < E.y || t > 1.0) break;\n    }\n    \n    return clamp(shadowContrib, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=0.01; t < 5.0; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<E.y)\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getPBRShading(vec3 n, vec3 v, vec3 l, vec3 albedo, float roughness, float metallic, float shadow, vec3 radiance)\n{\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    vec3 h = normalize(v + l);\n    roughness = roughness * roughness;\n    float NdotL = max(0.0, dot(n, l));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - metallic);\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01);\n\n    return (albedo * 0.08) + ((Kd * albedo / 3.14 + specularBRDF) * radiance * (NdotL * shadow));\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 p, vec3 l, float material)\n{\n    vec3 V = normalize(ro - p);\n    vec3 H = normalize(V + l);\n    vec3 N = getNormal(p);\n    vec3 color = vec3(0.0);\n    vec3 radiance = vec3(5.0, 4.0, 3.0)*3.0;\n    float shadow = softshadow(p, l, 0.01, 5.0, 50.0);\n    float atten = 0.0;\n    \n    if (material == MATERIAL_FACE)\n    {\n        color = getPBRShading(N, V, l, vec3(1.0, 0.0, 0.0), .7, 0.0, shadow, radiance);\n        atten = 0.0;\n    }\n    else if (material == MATERIAL_FLOOR)\n    {\n        float c = 0.8+mod((floor(p.x) + floor(p.z) + floor(p.y)), 2.0);\n        color = getPBRShading(N, V, l, vec3(0.3) * c, 0.6, 0.9, shadow, radiance);\n        atten = 0.2;\n    }\n    else if (material == MATERIAL_BUTTON)\n    {\n        color = getPBRShading(N, V, l, vec3(0.5), 0.2, 0.1, shadow, radiance);\n        atten = 0.3;\n    }\n    \n    #if USE_REFLECTION\n    if (atten > 0.0)\n    {\n        float t = 0.01;\n        vec3 rd = normalize(reflect(rd, N));\n        p += rd * 0.1;\n        for (int i = 0; i < 100; ++i)\n        {\n            vec2 d = map((p + rd * t));\n            if (d.x < 0.01)\n            {\n                vec3 P2 = p + rd * t;\n                vec3 N2 = getNormal(P2);\n                vec3 V2 = normalize(P2 - rd);\n                float matID2 = floor(d.y);\n                float shadow = softshadow(P2, l, 0.01, 5.0, 15.0);\n                if (matID2 == MATERIAL_FACE) \n                {\n                    color += atten * getPBRShading(N2, V2, l, vec3(1.0, 0.0, 0.0), 0.1, 0.0, shadow, radiance);\n                }\n                else if (matID2 == MATERIAL_FLOOR)\n                {\n                    float c = 0.8+mod((floor(P2.x) + floor(P2.z) + floor(P2.y)), 2.0);\n                    color += atten * getPBRShading(N2, V2, l,  vec3(0.3) * c, 0.3 * c, 0.3, shadow, radiance);\n                }\n                else if (matID2 == MATERIAL_NONE)\n                {\n                    color = vec3(0.0);\n                }\n                break;\n            }\n            t += d.x;\n            if (t > 200.0) break;\n        }\n    }\n    #endif  \n    \n    return color;\n}\n\nvec3 trace(vec3 ro, vec3 rd, out float totalDistance)\n{\n    vec3 lightDir = normalize(vec3(0.3, 1.0, -0.6));\n    vec3 fakeBounce = normalize(vec3(0.0, -0.3, 0.1));\n    vec3 radianceBounceFloor = vec3(5.0, 4.0, 3.0)*5.0;\n    vec3 radianceBounceFace = vec3(5.0, 1.0, 1.0)*2.0;\n    vec3 fakeBunce2Pos = vec3(0.0, 4.5, 2.0);\n    \n    float t = 0.0;\n    for (int i = 0; i < 400; ++i)\n    {\n        vec2 scene = map(ro + rd * t);\n        if (scene.x < E.y)\n        {\n            vec3 p = ro + rd * t;\n            vec3 color = getColor(ro, rd, p, lightDir, scene.y);            \n            vec3 V = normalize(ro - p);\n            vec3 H = normalize(V + fakeBounce);\n            vec3 N = getNormal(p);\n            vec3 dir = normalize(fakeBunce2Pos - p);\n            float atten = 0.1;\n                        \n            if (scene.y == MATERIAL_FACE)\n            {\n                color += atten * getPBRShading(N, V, fakeBounce, vec3(1.0, 0.0, 0.0), 0.7, 0.0, 1.0, radianceBounceFloor);\n            }\n            else if (scene.y == MATERIAL_FLOOR)\n            {\n                float c = 0.8+mod((floor(p.x) + floor(p.z) + floor(p.y)), 2.0);\n                color += atten * getPBRShading(N, V, dir, vec3(1.2) * c, 0.3 * c, 0.3, 1.0, radianceBounceFace);\n            }\n            else if (scene.y == MATERIAL_BUTTON)\n            {\n                color += atten * getPBRShading(N, V, fakeBounce, vec3(2.0), 0.5, 0.0, 1.0, radianceBounceFace);\n            }\n            totalDistance = t;\n            return color;\n        }\n        t += scene.x;\n        if (t > 10.0) break;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec3 ro = vec3(uv.x, uv.y, -2.7);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 3.0));\n    \n    if (iMouse.z > 0.0)\n    {\n        mat2 mx = rot(0.2 * (iMouse.x / iResolution.x * 2.0 - 1.0));\n        mat2 my = rot(0.1 * (iMouse.y / iResolution.y * 2.0 - 1.0) - 0.1);\n        ro.xz *= mx;\n        rd.xz *= mx;\n        ro.yz *= my;\n        rd.yz *= my;\n    }\n    else\n    {\n        mat2 mx = rot(sin(iTime * 0.2) * 0.1);\n        ro.xz *= mx;\n        rd.xz *= mx;    \n    }\n    \n    float totalDistance = 100.0;\n    vec3 color = trace(ro, rd, totalDistance);\n    \n    color *= pow(1.0-(totalDistance/10.0),3.0);\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    color = mix(color, vec3(0.2), pow(length(0.8 * uv / ar.x), 6.0));\n    \n    fragColor = vec4(color, totalDistance);\n}","name":"Buffer A","description":"","type":"buffer"}]}