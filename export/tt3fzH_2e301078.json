{"ver":"0.1","info":{"id":"tt3fzH","date":"1612220208","viewed":87,"name":"Genuary 2021 – 06 – Triangle Sub","username":"endymion","description":"Genuary 2021 – 06 – Triangle Subdivision","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fbm","triangle","subdivision","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n/**\n * Utils\n */\n\n// @src https://iquilezles.org/articles/distfunctions2d\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x * b.x - a.y*b.y; }\n\nfloat random(in float seed) {\n    return fract(sin(seed)*1e4);\n}\n\nfloat random(in vec2 seed) {\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 random2(vec2 seed) {\n    return fract(sin(vec2(dot(seed, vec2(127.1, 311.7)), dot(seed, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat map(in float value, in float min1, in float max1, in float min2, in float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Basic noise\n */\nfloat noise(vec2 p, float freq){\n    float unit = iResolution.x / freq;\n    vec2 ij = floor(p / unit);\n    vec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n    float a = random((ij + vec2(0., 0.)));\n    float b = random((ij + vec2(1., 0.)));\n    float c = random((ij + vec2(0., 1.)));\n    float d = random((ij + vec2(1., 1.)));\n    float x1 = mix(a,b,xy.x);\n    float x2 = mix(c,d,xy.x);\n    return mix(x1,x2,xy.y);\n}\n\n/**\n * Simplex noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n */\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n/**\n* Fractional Brownian Motion\n* @src https://thebookofshaders.com/13/\n*/\nfloat fbm(in vec2 _st, in int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(_st, 2000. + abs(1000. * sin(iTime * 0.0009)));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n/**\n * RGB to HSB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 rgb2hsb(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n/**\n * HSB to RGB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 hsb2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\n * Triangle\n * @src https://iquilezles.org/articles/distfunctions2d\n */\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(\n        min(\n            vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n            vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))\n        ),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x))\n    );\n    \n    return -sqrt(d.x) * sign(d.y);\n}\n\n/**\n * Triangular subdivision\n */\nvoid getNewTrianglePoints(in float seed, inout vec2 a, inout vec2 b, inout vec2 c) {\n    float side = random(seed) * 3.;\n    float tilt = (0.5 + sin(snoise(vec2(iTime * 0.05))) * 0.5);\n    \n    if (side < 1.) {\n        a = mix(a, b, tilt);\n    } else if (side < 2.) {\n        b = mix(b, c, tilt);\n    } else {\n        c = mix(c, a, tilt);\n    }\n}\n\n/**\n * Subdivide triangle and give color and points back\n */\nvec3 getSubTriangle(in vec2 uv, in float seed, inout vec2 a, inout vec2 b, inout vec2 c, vec3 prevColor, vec3 newColor) {\n    getNewTrianglePoints(seed, a, b, c);\n    float d = sdTriangle(uv, a, b, c);\n    vec3 color = d >= 0. ? prevColor : newColor;\n    return color;\n}\n\n/**\n * FbM colors ftw\n */\n    \nvec3 getColor(in vec2 uv, in float f, in float t, in vec3 colorA, in vec3 colorB) {\n    vec3 color = hsb2rgb(mix(\n        vec3(1, 1 ,1 ),\n        mix(\n                vec3(colorA.x, colorA.y, 0.75 + 0.25 * sin(iTime * 0.1)),\n                vec3(colorB.x, colorB.y, 0.75 + 0.25 * sin(iTime * 0.1)),\n                t * 0.5 + uv.y * 0.5\n        ),\n        clamp(f * 4.0, 0.0, 1.0)\n    ));\n    \n    return (1.5 * f) * color;\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float subs = floor(mod(iTime * 2., 30.));\n    \n    // Outer triangle bounds\n    vec2 a = vec2(0.1, 0.1);\n    vec2 b = vec2(0.1, 0.9);\n    vec2 c = vec2(0.9, 0.9);\n    \n    // FbM colors ftw\n    vec2 r = vec2(0.);\n    r.x = fbm(uv  + 0.10, 1);\n    float f = fbm(uv + r, 10);\n    f = f * 0.5 + fbm(vec2(f * 0.5), 2);\n    f = f * 0.5 + fbm(vec2(f * 0.5), 2);\n    float t = smoothstep(0., 1., abs(map(fract(iTime * .075), 0., 1., -1., 1.)));\n    \n    vec3 colors[10];\n    colors[0] = vec3(0.7, 0.725, 0.75);\n    colors[1] = vec3(0.995, 0.625, 0.75);\n    colors[2] = vec3(0.52, 0.725, 0.75);\n    colors[3] = vec3(0.7, 0.635, 0.75);\n    colors[4] = vec3(0.8, 0.725, 0.75);\n    \n    float d = sdTriangle(uv, a, b, c);\n    vec3 color = d >= 0. ? vec3(.2, .2, .2) : getColor(uv, f, t, colors[0], colors[1]);\n    \n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[1], colors[2]));\n    color = getSubTriangle(uv, 8., a, b, c, color, getColor(uv, f, t, colors[2], colors[3]));\n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[3], colors[4]));\n    color = getSubTriangle(uv, 4., a, b, c, color, getColor(uv, f, t, colors[4], colors[0]));\n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[0], colors[1]));\n    color = getSubTriangle(uv, 6., a, b, c, color, getColor(uv, f, t, colors[1], colors[2]));\n    color = getSubTriangle(uv, 7., a, b, c, color, getColor(uv, f, t, colors[2], colors[3]));\n    color = getSubTriangle(uv, 8., a, b, c, color, getColor(uv, f, t, colors[3], colors[4]));\n\n    // Output\n    fragColor = vec4(color, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}