{"ver":"0.1","info":{"id":"lddXR7","date":"1458571324","viewed":313,"name":"Aging Game of Life","username":"taitomagatsu","description":"Cells get old too!!\nControls:\n- Mouse adds cells\n- R reboots, E cleans\n- Pan: WASD\n- Zoom: Shift n Ctrl\n- Change Brush: F\n- Change Colors: Q","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["simulation","automata","cellularautomata","seed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by felix fischer marques - taitomagatsu/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/** View Layer\n\tCapa de Vista */\n\nvec2 coordsFromIndex(in float idx) {\n  return vec2(idx);\n}\n\n#define CTickLength 1.0 \n#define CShouldTick 2.0\n\n#define CCurrentPan 10.0\n\n#define CCurrentZoom 20.0\n\n#define CCurrentPalette 30.0\n\n#define Tau 6.2831853071\n\nvoid makeColour(in float t, in vec4 colPalette, out float colour)\n{\n    colour = \n        colPalette.x + colPalette.y * cos(Tau * (t * colPalette.z + colPalette.w));\n}\n\n// 1: Holy shit, this is the best default ever\n#define redPalette0 vec4(.5, .5, 1., .3)\n#define greenPalette0 vec4(.5, .5, 1., .2)\n#define bluePalette0 vec4(.5, .5, 1., .2)\n\n// 2: First dawn is purple, second dawn is gold.\n#define redPalette1 vec4(.5, .5, 1., .0)\n#define greenPalette1 vec4(.5, .5, .7, .15)\n#define bluePalette1 vec4(.5, .5, .4, .2)\n\n// 3: Dyed wool... maybe\n#define redPalette2 vec4(.8, .2, 2., .0)\n#define greenPalette2 vec4(.5, .4, 1., .25)\n#define bluePalette2 vec4(.4, .2, 1., .25)\n\n//#define redPalette4 vec4(.5, .5, 1., .0)\n//#define greenPalette4 vec4(.5, .5, 1., .1)\n//#define bluePalette4 vec4(.5, .5, 1., .2)\n\n// Makes palettes change by steps instead of smoothly.\n// I actually prefer it to be discrete.\n#define DiscreteChange 1\n\nvec4 RedPalette(float idx)\n{\n    #if DiscreteChange == 0\n    float part0 = 1. - smoothstep(.9, 1.1, idx);\n    float part1 = (1. - smoothstep(1.9, 2.1, idx)) * (1. - part0);\n    float part2 = (1. - smoothstep(2.9, 3.1, idx)) * (1. - part1) * (1. - part0);\n    \n    return redPalette0 * part0 + redPalette1 * part1 + redPalette2 * part2;\n    \n    #elif DiscreteChange == 1\n    if(idx < 1.)\n    {\n        return redPalette0;\n    }\n    else if(idx < 2.)\n    {\n        return redPalette1;\n    }\n    else\n    {\n        return redPalette2;\n    }\n    #endif\n}\nvec4 GreenPalette(float idx)\n{    \n    #if DiscreteChange == 0\n    float part0 = 1. - smoothstep(.9, 1.1, idx);\n    float part1 = (1. - smoothstep(1.9, 2.1, idx)) * (1. - part0);\n    float part2 = (1. - smoothstep(2.9, 3.1, idx)) * (1. - part1) * (1. - part0);\n    \n    return greenPalette0 * part0 + greenPalette1 * part1 + greenPalette2 * part2;\n    \n    #elif DiscreteChange == 1\n    if(idx < 1.)\n    {\n        return greenPalette0;\n    }\n    else if(idx < 2.)\n    {\n        return greenPalette1;\n    }\n    else\n    {\n        return greenPalette2;\n    }\n    #endif\n}\nvec4 BluePalette(float idx)\n{\n    #if DiscreteChange == 0\n    float part0 = 1. - smoothstep(.9, 1.1, idx);\n    float part1 = (1. - smoothstep(1.9, 2.1, idx)) * (1. - part0);\n    float part2 = (1. - smoothstep(2.9, 3.1, idx)) * (1. - part1) * (1. - part0);\n    \n    return bluePalette0 * part0 + bluePalette1 * part1 + bluePalette2 * part2;\n    \n    #elif DiscreteChange == 1\n    if(idx < 1.)\n    {\n        return bluePalette0;\n    }\n    else if(idx < 2.)\n    {\n        return bluePalette1;\n    }\n    else\n    {\n        return bluePalette2;\n    }\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 realCoords = fragCoord/iResolution.xy;\n    \n    // Zoom y pan\n    float currentZoom = \n        texture(iChannel1,coordsFromIndex(CCurrentZoom)/iResolution.xy).r;\n    vec2 currentPan = \n        texture(iChannel1,coordsFromIndex(CCurrentPan)/iResolution.xy).xy;\n   \n    float currentPalette = \n        texture(iChannel1,coordsFromIndex(CCurrentPalette)/iResolution.xy).r;\n    \n    \n    // Cambio en posiciÃ³n por Zoom y Pan\n    \n    // Delta por Zoom\n    vec2 zoomD = (realCoords * 2. - vec2(1.)) * (currentZoom - 1.) / currentZoom;\n    \n    realCoords = fract(realCoords + currentPan - zoomD);    \n    \n    \n\tvec4 currentData = texture(iChannel0, realCoords);\n    \n    float curAge = currentData.g;\n    \n    float maxAge = currentData.a;\n    \n    float debug = 0.5;\n           \n    float coef = curAge / maxAge;\n    \n    float red, green, blue;\n    makeColour(coef, RedPalette(currentPalette), red);\n    makeColour(coef, GreenPalette(currentPalette), green);\n    makeColour(coef, BluePalette(currentPalette), blue);\n    \n    vec3 trueColor = vec3(red, green, blue);\n    \n    \n    float neShine = debug + 0.5;\n    \n    \n    trueColor = curAge >= 1.0 ? trueColor * neShine : vec3(0.0);\n    \n    //trueColor = curAge >= 1.0 ? vec3(1.0) : vec3(0.0);\n    \n\tfragColor = vec4(trueColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by felix fischer marques - taitomagatsu/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/** Model Layer\n\tCapa de Modelo */\n\n#define pixel (1.0 / iChannelResolution[0].xy)\n#define brushSize 20.0\n#define saltModulus 10.0\n\n/**\tI personally recommend models 1, 6, 8 and 9.\n\tRecomiendo los modelos 1, 6, 8 y 9. */\n\n// Change this number to get different behaviour c:\n#define MODEL 6\n\n// 1 - Brian's Brain\n// 2 - Nova\n// 3 - Star Wars\n// 4 - Glisserati\n// 5 - Rake\n// 6 - Eternal (Crystal) Life\n// 7 - Eternal (Viscous) Life (IMPORTANT: epilepsy warning!)\n// 8 - Rebuild-it\n// 9 - Hustle\n#if MODEL == 1\n#define KeepAlive(X) true\n#define GiveBirth(X) (X == 2.0)\n#define maxAge 3.0\n#define seedDensity .5\n\n#elif MODEL == 2\n#define KeepAlive(X) (X >= 4.0 && X <= 8.0)\n#define GiveBirth(X) (X == 2.0 || X == 4.0 || X == 7.0 || X == 8.0)\n#define maxAge 25.0\n#define seedDensity .9\n\n#elif MODEL == 3\n#define KeepAlive(X) (X >= 3.0 && X <= 5.0)\n#define GiveBirth(X) (X == 2.0)\n#define maxAge 4.0\n#define seedDensity 1.0\n\n#elif MODEL == 4\n#define KeepAlive(X) (X == 0.0 || X == 3.0 || (X >= 5.0 && X <= 8.0))\n#define GiveBirth(X) (X == 2.0 || (X >= 4.0 && X <= 8.0))\n#define maxAge 7.0\n#define seedDensity .9\n\n#elif MODEL == 5\n#define KeepAlive(X) (X == 3.0 || X == 4.0 || X == 6.0 || X == 7.0)\n#define GiveBirth(X) (X == 2.0 || (X >= 6.0 && X <= 8.0))\n#define maxAge 6.0\n#define seedDensity .9\n\n#elif MODEL == 6\n#define KeepAlive(X) (X == 3.0 || (X >= 5.0 && X <= 8.0))\n#define GiveBirth(X) (X == 2.0 || (X >= 4.0 && X <= 8.0))\n#define maxAge 300.0\n#define seedDensity .9\n\n#elif MODEL == 7\n#define KeepAlive(X) (X >= 5.0 && X <= 8.0)\n#define GiveBirth(X) (X == 2.0 || (X >= 4.0 && X <= 8.0))\n#define maxAge 300.0\n#define seedDensity .9\n\n#elif MODEL == 8\n#define KeepAlive(X) (X == 2.0 || (X >= 4.0 && X <= 8.0))\n#define GiveBirth(X) (X == 2.0 || (X >= 4.0 && X <= 8.0))\n#define maxAge 300.0\n#define seedDensity .9\n\n#elif MODEL == 9\n#define KeepAlive(X) (X == 3.0 || (X >= 4.0 && X <= 7.0))\n#define GiveBirth(X) (X == 2.0)\n#define maxAge 60.0\n#define seedDensity 10.0\n\n#endif\n\n#define repopulationFactor .95 \n\nfloat rand(vec2 n);\nfloat noise(vec2 n);\n\nconst int Key_R = 82;\nconst int Key_E = 69;\n\n/**\tRead keyboard input\n\tToma input del teclado.*/\nbool ReadKey( int key );\n\nvoid resetBoard(out vec4 fragColor, in vec2 fragCoord, in float currentB);\n\nvec2 coordsFromIndex(in float idx);\n\nbool paintHere(in vec2 relativeCoords, in float curZoom, in float curBrush);\n \n/** Coordinates in Buffer B (for global variables) \n\tCoordenadas en el Buffer B (para variables globales)*/\n#define CTickLength 1.0 \n#define CShouldTick 2.0\n\n#define CCurrentPan 10.0\n\n#define CCurrentZoom 20.0\n#define CCurrentBrush 31.0\n\n// Test result: no afecta en nada separar los bools de paintHere.\n#define splitBools 0\n\n/**\tCaching fert activates the caching fertility optimization.\n\tIt's a WIP xD */\n#define cachingFert 0\n\n// 1 / FPS\n#define newSpeed 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /** Cell's coord and current data\n\t\tCoordenadas e informaciÃ³n actual de la celda. */\n    vec2 realCoords = fragCoord.xy / iChannelResolution[0].xy;\n    vec4 currentP = texture(iChannel0, realCoords).rgba;\n    \n    float alpha = 0.0;\n    \n    //////// Global variables of Buffer B ////////\n    //////// Variables globales del Buf B ////////\n    \n    // Not needed anymore\n    //float shouldTick = \n    //    texture(iChannel1,coordsFromIndex(CShouldTick)/iChannelResolution[1].xy).r;\n    \n    float currentZoom = \n        texture(iChannel1,coordsFromIndex(CCurrentZoom)/iResolution.xy).r;\n    vec2 currentPan = \n        texture(iChannel1,coordsFromIndex(CCurrentPan)/iResolution.xy).xy;\n    float currentBrush =\n        texture(iChannel1,coordsFromIndex(CCurrentBrush)/iResolution.xy).r;\n        \n    //////////////////////////////////////////////\n    \n    /**\tWe are bound to the clock ticking in Buffer B.\n\t\tEstamos atados al paso del reloj del Buffer B. */\n    //if(shouldTick < 0.5)\n    if(iFrame - (iFrame / newSpeed) * newSpeed != 0)\n    {\n        fragColor = currentP;\n        return;\n    }\n    \n    /**\tWe calculate the correct position of the mouse, \n\t\tgiven current zoom and pan.\n\t\tCalculamos la posiciÃ³n correcta del mouse, dados\n\t\tel zoom y pan actuales.\t*/\n   \tvec2 correctedMouse = iMouse.xy + currentPan * iChannelResolution[0].xy; \n\tcorrectedMouse -= (iMouse.xy * 2. - iChannelResolution[0].xy) * (currentZoom - 1.) / currentZoom;\n    \n    /** The mouse coords are rounded so that the brush is more symmetric.\n\t\tRedondeamos las coordenadas del mouse para que la brocha sea \n\t\tmÃ¡s simÃ©trica*/\n    correctedMouse = floor(correctedMouse);\n    \n    //distance(iMouse.xy, fragCoord)\n    \n    /**\tAre we alive?\n\t\tÂ¿Estamos vivos? */\n    float currentState = currentP.r;\n        \n    /** What age are we?\n\t\tÂ¿CuÃ¡l es nuestra edad? */\n    float currentAge = currentP.g;\n    \n    float fertileNe = 0.0;\n    float aliveNe = 0.0;\n    \n    vec2 co1, co2, co3, co4, co5, co6, co7, co8;\n    \n    /** Fract allows us to loop over the borders as if the surface\n\t\twas a torus.\n\t\tFract permite loopear sobre los bordes como si el plano \n\t\tfuese un toro.\t\t*/\n    co1 = fract(realCoords + pixel * vec2(-1, -1));\n    co2 = fract(realCoords + pixel * vec2(-1, 0));\n    co3 = fract(realCoords + pixel * vec2(-1, 1));\n    co4 = fract(realCoords + pixel * vec2(0, -1));\n    co5 = fract(realCoords + pixel * vec2(0, 1));\n    co6 = fract(realCoords + pixel * vec2(1, -1));\n    co7 = fract(realCoords + pixel * vec2(1, 0));\n    co8 = fract(realCoords + pixel * vec2(1, 1));\n    \n\t// Neighbours' data. Datos de vecinos.\n    #if cachingFert == 0\n    vec2 ne1, ne2, ne3, ne4, ne5, ne6, ne7, ne8;\n    \n    ne1 = texture(iChannel0, co1).rg;\n    ne2 = texture(iChannel0, co2).rg;\n\tne3 = texture(iChannel0, co3).rg;\n\tne4 = texture(iChannel0, co4).rg;\n\tne5 = texture(iChannel0, co5).rg;\n\tne6 = texture(iChannel0, co6).rg;\n\tne7 = texture(iChannel0, co7).rg;\n\tne8 = texture(iChannel0, co8).rg;\n\t\n    \n    #elif cachingFert == 1\n    vec3 ne1, ne2, ne3, ne4, ne5, ne6, ne7, ne8;\n    \n    ne1 = texture(iChannel0, co1).rgb;\n    ne2 = texture(iChannel0, co2).rgb;\n\tne3 = texture(iChannel0, co3).rgb;\n\tne4 = texture(iChannel0, co4).rgb;\n\tne5 = texture(iChannel0, co5).rgb;\n\tne6 = texture(iChannel0, co6).rgb;\n\tne7 = texture(iChannel0, co7).rgb;\n\tne8 = texture(iChannel0, co8).rgb;\n\t#endif\n    \n    aliveNe += ne1.r;\n    aliveNe += ne2.r;\n    aliveNe += ne3.r;\n    aliveNe += ne4.r;\n    aliveNe += ne5.r;\n    aliveNe += ne6.r;\n    aliveNe += ne7.r;\n    aliveNe += ne8.r;\n\n    float gee = .0;\n    \n    #if cachingFert == 0\n    gee = ne1.r * (2.0 - ne1.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne2.r * (2.0 - ne2.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne3.r * (2.0 - ne3.g);   \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne4.r * (2.0 - ne4.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne5.r * (2.0 - ne5.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne6.r * (2.0 - ne6.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne7.r * (2.0 - ne7.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    gee = ne8.r * (2.0 - ne8.g);    \n    fertileNe += clamp(gee, 0.0, 1.0);\n    \n    #elif cachingFert == 1\n    \n    // WIP\n    fertileNe += ne1.b;\n    fertileNe += ne2.b;\n    fertileNe += ne3.b;\n    fertileNe += ne4.b;\n    fertileNe += ne5.b;\n    fertileNe += ne6.b;\n    fertileNe += ne7.b;\n    fertileNe += ne8.b;\n    \n    float myFert = clamp(currentState * (2. - currentAge), .0, 1.);\n    \n    // Trying to cache the fertility...\n    currentP.b = myFert;\n    \n    #endif\n    \n    /** If I'm alive and deserve to live.\n    \tSi estoy vivo y merezco vivir. */\n    if(currentState > 0.0 && KeepAlive(aliveNe)/**/ && currentAge < maxAge/**/)\n    {\n        currentAge += 1.0;\n    }\n    /** If I'm alive and deserve to die.\n\t\tSi estoy vivo y merezco morir. */\n    else if(currentState > 0.0)\n    {\n        currentState = 0.0;\n        currentAge = 0.0;\n    }\n    /** If I'm alive and will be born again.\n\t\tSi estoy muerto y nacerÃ©. */\n    else if(GiveBirth(fertileNe))\n    {\n        currentState = 1.0;\n        currentAge = 1.0;\n    }\n\n    // Variable (alpha channel) used for debug and experiments c:\n    // Variable (canal alfa) usada para debuguear y hacer experimentos.\n    alpha = 1.0;\n    \n    // Reset\n    if(ReadKey(Key_R))\n    {\n        resetBoard(fragColor, fragCoord, currentP.b);\n    }\n    \n    /** We erase the screen.\n\t\tBorramos la pantalla. */\n    else if(ReadKey(Key_E))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, maxAge);\n    }\n    \n    /**\tWe paint with the mouse\n\t\tPintamos con el mouse. */\n    else if(paintHere(mod(correctedMouse, iChannelResolution[0].xy) - fragCoord, currentZoom, currentBrush) && iMouse.z > .0)\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, maxAge);\n    }\n    \n    /**\tWe go to the next clock tick.\n\t\tAvanzamos hacia la siguiente iteraciÃ³n. */\n    else\n    {\n        fragColor = vec4(currentState, currentAge, currentP.b, maxAge);\n    }\n    \n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nbool ReadKey( int key )\n{\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid resetBoard(out vec4 fragColor, in vec2 fragCoord, in float currentB)\n{\n    float taimu = iTime - float(int(iTime / saltModulus));\n    // This factor speeds up the change in the seeding blanket\n    taimu *= 3.0;\n    fragColor = vec4(vec3(noise(fragCoord + taimu / saltModulus) > repopulationFactor ? 1.0 : 0.0), maxAge);\n}\n\nvec2 coordsFromIndex(in float idx) {\n  return vec2(idx);\n}\n\n\nbool paintHere(in vec2 relativeCoords, in float curZoom, in float curBrush)\n{\n    float len_x = iChannelResolution[0].x;\n    float len_y = iChannelResolution[0].y;\n    \n    if(length(relativeCoords.x) > len_x / 2.0) {\n    \trelativeCoords.x = len_x - length(relativeCoords.x);  \n    }\n    \n    if(length(relativeCoords.y) > len_y / 2.0) {\n    \trelativeCoords.y = len_y - length(relativeCoords.y);    \n    }\n\n    #if splitBools == 1\n    if(curBrush < .9)\n    {\n        // CÃ­rculo\n        return length(relativeCoords) < brushSize / (curZoom * curZoom);\n    }\n    else if(curBrush < 1.9)\n    {\n        // Rombo\n        return (abs(relativeCoords.x) + abs(relativeCoords.y)) < brushSize / (curZoom * curZoom);\n    }\n    else if(curBrush < 2.9)\n    {\n        // Cruz\n        return abs(relativeCoords.x * relativeCoords.y) < brushSize / (curZoom * curZoom);\n    }\n    else\n    {\n        // CÃ­rculo hueco\n        return \n            length(relativeCoords) < brushSize / (curZoom * curZoom)\n            && length(relativeCoords) + 2. > brushSize / (curZoom * curZoom);\n    }\n    #elif splitBools == 0\n    return \n        ((curBrush < .9) && length(relativeCoords) < brushSize / (curZoom * curZoom))\n        \n        ||\n        \n        ((curBrush > .9 && curBrush < 1.9) && (abs(relativeCoords.x) + abs(relativeCoords.y)) < brushSize / (curZoom * curZoom))\n    \n        ||\n        \n        ((curBrush > 1.9 && curBrush < 2.9) && abs(relativeCoords.x * relativeCoords.y) < brushSize / (curZoom * curZoom))\n        \n        ||\n        \n        ((curBrush > 2.9) \n         && length(relativeCoords) < brushSize / (curZoom * curZoom)\n         && length(relativeCoords) + 2. > brushSize / (curZoom * curZoom)\n         );\n    \n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by felix fischer marques - taitomagatsu/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/** Control Layer\n\tCapa de Controlador */\n\n/** Keyboard Keys */\nconst int Key_Shift = 16;\nconst int Key_Ctrl = 17;\n\nconst int Key_A = 65;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_W = 87;\n\nconst int Key_Q = 81;\nconst int Key_F = 70;\n\n// process keyboard input\nbool ReadKey( int key )\n{\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n// Memory indexes\n#define CTickLength 1.0 \n#define CShouldTick 2.0\n\n#define CCurrentPan 10.0\n\n#define CCurrentZoom 20.0\n\n#define CCurrentPalette 30.0\n#define CCurrentBrush 31.0\n#define CCurrentModel 32.0\n\n#define CCurrentFState 40.0\n#define CCurrentQState 41.0\n\nvec2 coordsFromIndex(in float idx) {\n  return vec2(idx);//vec2(floor(idx / RAM_SIZE), floor(mod(idx, RAM_SIZE)));\n}\n\nbool isCell(in vec2 theCell, in float idx)\n{\n \tvec2 idxCell = coordsFromIndex(idx);\n   \n    return \n        theCell.x < idxCell.x + 1.0 \n        && theCell.x > idxCell.x - 1.0\n        && theCell.y < idxCell.y + 1.0 \n        && theCell.y > idxCell.y - 1.0; \n}\n\n// In FPS\n#define speed 60.0\n#define tickTime 1.0 / speed\n\n#define panSpeed 1.\n#define zoomSpeed 0.01;\n#define PaletteSpeed 0.05;\n#define BrushChangeSpeed 0.05;\n\n#define MaxZoom 1.9;\n\n#define NumPalettes 3.0;\n#define NumBrushes 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = fragCoord.xy / iResolution.xy;\n    vec4 currentP = texture(iChannel0, c).rgba;    \n    \n    float tickLength = texture(iChannel0, coordsFromIndex(CTickLength) / iResolution.xy).r;\n    float shouldTick = tickLength > tickTime ? 1.0 : 0.0;\n    \n    float curZoom = texture(iChannel0, coordsFromIndex(CCurrentZoom) / iResolution.xy).r;\n    \n    curZoom = curZoom < 0.5 ? 1.0 : curZoom;\n    \n    float curPalette = texture(iChannel0, coordsFromIndex(CCurrentPalette) / iResolution.xy).r;\n    \n    float curBrush = texture(iChannel0, coordsFromIndex(CCurrentBrush) / iResolution.xy).r;\n    \n    float curFValue = texture(iChannel0, coordsFromIndex(CCurrentFState) / iResolution.xy).r;\n    float curQValue = texture(iChannel0, coordsFromIndex(CCurrentQState) / iResolution.xy).r;\n        \n    /** What variable are we? Are we anything? \n\t\tWe calculate everything here to reduce\n\t\tbranching load.\t\t\t\t\t\t\t*/\n    \n    bool isTickL = isCell(fragCoord.xy, CTickLength);\n    bool isShouldT = isCell(fragCoord.xy, CShouldTick);\n        \n    // Which memory cell are we?\n    bool isCurPan = isCell(fragCoord.xy, CCurrentPan);\n    \n    bool isCurZoom = isCell(fragCoord.xy, CCurrentZoom);\n    \n    bool isCurPalette = isCell(fragCoord.xy, CCurrentPalette);\n    bool isCurBrush = isCell(fragCoord.xy, CCurrentBrush);\n    bool isCurModel = isCell(fragCoord.xy, CCurrentModel);\n    \n    bool isFState = isCell(fragCoord.xy, CCurrentFState);\n    bool isQState = isCell(fragCoord.xy, CCurrentQState);\n    \n    // Pan input and resolution\n    bool Right = ReadKey(Key_D);\n    bool Left = ReadKey(Key_A);\n    bool Up = ReadKey(Key_W);\n    bool Down = ReadKey(Key_S);\n    \n    float upMove = (Up && !Down) ? 1.0 : (!Up && Down) ? -1.0 : 0.0;\n    float rightMove = (Right && !Left) ? 1.0 : (!Right && Left) ? -1.0 : 0.0;\n    \n    float panModule = \n        sqrt(upMove * upMove + rightMove * rightMove);\n    \n    upMove *= panModule >= 1.0 ? panSpeed / panModule : 1.0;\n    rightMove *= panModule >= 1.0 ? panSpeed / panModule : 1.0;\n    \n    // We divide by the current zoom squared to make \n    // panning easier when close to the pixels.\n    upMove /= curZoom * curZoom;\n    rightMove /= curZoom * curZoom;\n    \n    // Zoom input and resolution\n    bool Shift = ReadKey(Key_Shift);\n    bool Ctrl = ReadKey(Key_Ctrl);\n    \n    float zoomMove = (Shift && !Ctrl) ? 1.0 : (!Shift && Ctrl) ? -1.0 : 0.0;\n    \n    zoomMove *= zoomSpeed;\n    \n    float maxZoom = MaxZoom;\n    \n    // Change palette input\n    bool isQPressed = ReadKey(Key_Q);\n    \n    float numPalettes = NumPalettes;\n    \n    float paletteSpeed = 1.0;//PaletteSpeed;\n    \n    float newCurrentPalette = isQPressed && curQValue < 0.5 ? mod(curPalette + paletteSpeed, numPalettes) : curPalette;\n    \n    // Change brush input\n    bool isFPressed = ReadKey(Key_F);\n    \n    float numBrushes = NumBrushes;\n    float brushChangeSpeed = 1.0;//BrushChangeSpeed;\n    \n    // We change the brush only if we are just pressing down on the Q key.\n    float newCurrentBrush = isFPressed && curFValue < .5 ? mod(curBrush + brushChangeSpeed, numBrushes) : curBrush;\n            \n    // Store the variables\n    if(shouldTick > 0.5 && isTickL)\n    {\n        currentP.r -= tickTime;\n    }\n    if(isTickL)\n    {\n        currentP.r += iTimeDelta;\n    }\n    if(isShouldT)\n    {\n        currentP.r = shouldTick;\n    }\n    if(isCurPan)\n    {\n        currentP.y += upMove * iTimeDelta;\n        currentP.x += rightMove * iTimeDelta;\n    }\n    if(isCurZoom)\n    {\n     \tcurrentP.r = clamp(currentP.r + zoomMove, 1.0, maxZoom);   \n    }\n    if(isCurPalette)\n    {\n     \tcurrentP.r = newCurrentPalette;   \n    }\n    if(isCurBrush)\n    {\n     \tcurrentP.r = newCurrentBrush;   \n    }\n    if(isFState)\n    {\n        currentP.r = isFPressed ? 1. : .0;\n    }\n    if(isQState)\n    {\n        currentP.r = isQPressed ? 1. : .0;\n    }\n    \n    \n    fragColor = currentP;\n}","name":"Buffer B","description":"","type":"buffer"}]}