{"ver":"0.1","info":{"id":"7sBXWy","date":"1620912211","viewed":70,"name":"Experiments in neon","username":"Waterflames","description":"Just trying out some stuff","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","test","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float x)\n{\n    return fract(sin(x)*10000.0);\n}\n\nfloat rand2(vec2 x)\n{\n    float s = dot(x, vec2(14.32168, 101.4567));\n    return fract(sin(s)*10000.0);\n}\n\nvec2 randGradient(vec2 x)\n{\n    vec2 s = vec2(dot(x, vec2(132.215454, 176.15641)),\n                  dot(x, vec2(140.5416, 137.015648)));\n    return -1. + 2.*fract(sin(s)*10000.0);\n}\n\nfloat valueNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    float bl = rand2(i + vec2(0., 0.));\n    float br = rand2(i + vec2(1., 0.));\n    float tl = rand2(i + vec2(0., 1.));\n    float tr = rand2(i + vec2(1., 1.));\n    \n    return mix(bl, br, f.x) + \n            (tl - bl) * f.y * (1. - f.x) + \n            (tr - br) * f.y * f.x;\n}\n\nfloat gradientNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 bl = randGradient(i + vec2(0., 0.));\n    vec2 br = randGradient(i + vec2(1., 0.));\n    vec2 tl = randGradient(i + vec2(0., 1.));\n    vec2 tr = randGradient(i + vec2(1., 1.));\n    \n    vec2 m = smoothstep(vec2(0., 0.), vec2(1., 1.), f);\n    \n    return mix(mix(dot(bl, f), dot(br, f - vec2(1., 0.)), m.x),\n            mix(dot(tl, f - vec2(0., 1.)), dot(tr, f - vec2(1., 1.)), m.x), m.y);\n}\n\n#define FBM_OCTAVES 11\nfloat fbm(vec2 x)\n{\n    float v = 0.;\n    float a = 0.5;\n\n    float am = 0.5;\n    float fm = 2.0;\n    \n    for(int i = 0; i < FBM_OCTAVES; ++i)\n    {\n        v += a * valueNoise(x);\n        x *= fm;\n        a *= am;\n    }\n    \n    return v;\n}\n\nconst float PI = 3.14159265;\n\nstruct Hit\n{\n    float t;\n    vec3 n;\n};\n\nbool tracePlane(inout Hit h, in vec3 p, in vec3 d, in vec3 p0, in vec3 n)\n{\n    h.t = -dot((p-p0), n)/dot(d, n);\n    h.n = n;\n    return h.t >= 0.;\n}\n\nbool traceSphere(inout Hit h, in vec3 p, in vec3 d, in vec3 p0, in float r)\n{\n    vec3 q = p - p0;\n    float a = dot(d, d);\n    float b = 2.*dot(q, d);\n    float c = dot(q, q) - (r*r);\n    \n    float disc = (b*b) - (4.*a*c);\n    if(disc >= 0.)\n    {\n        h.t = (-b + sqrt(disc))/(2. * a);\n        h.n = (p+(h.t*d) - p0)/r;\n        return true;\n    }\n    \n    return false;\n}\n\nfloat terrainHeight(vec2 p)\n{\n    //float minMod = 0.25;\n    //float m = minMod + (smoothstep(0.0, 0.5, (sin(iTime)+1.)/2.) / (1.0 + minMod));\n    //return .2+ fbm(p) * m;\n    return fbm(p);\n}\n\n#define TERRAIN_MAX_STEPS 128\nbool traceTerrain(inout Hit h, in vec3 p, in vec3 d)\n{\n    h.t = 1.;\n\n    float stepSize = 0.01;\n    float lastHeightDiff = 1.;\n    for(int i = 0; i < TERRAIN_MAX_STEPS; ++i) {\n        vec3 q = p + h.t * d;\n        float height = terrainHeight(q.xz);\n        if(q.y < height){\n            float dt = -lastHeight/(height-lastHeight);\n            float delta = 0.00001;\n            float ddx = (terrainHeight(q.xz+vec2(delta, 0.)) - height);\n            float ddy = (terrainHeight(q.xz+vec2(0., delta)) - height);\n            h.n = normalize(cross(vec3(0., ddy, delta), vec3(delta, ddx, 0.)));\n            return true;\n        }\n        lastHeight = height - q.y;\n        stepSize = 0.01 * h.t;\n        h.t += stepSize;\n    }\n    return false;\n}\n\nvec3 traceRay(vec3 p, vec3 d)\n{\n    vec3 color = mix(vec3(1,.5,.6), vec3(0.0,0.1,0.5), sqrt(d.y));\n    \n    vec3 lamp = normalize(vec3(sin(iTime), 1.0, cos(iTime)));\n    \n    float hitT = 1.0e10;\n    \n    {\n        Hit h;\n        if(traceTerrain(h, p, d) && h.t < hitT)\n        {\n            hitT = h.t;\n            vec3 hit = p+h.t*d;\n            color = vec3(dot(h.n, lamp));\n        }\n    }\n    \n    {\n        Hit h;\n        if(tracePlane(h, p, d, vec3(0.), vec3(0., 1., 0.)) && h.t < hitT)\n        {\n            hitT = h.t;\n            vec3 hit = p+h.t*d;\n            float val = fbm(vec2(fbm(hit.xz * 5. + iTime), fbm(hit.xz * 2.5 + iTime)));\n            val = ((2.*val) - .3);\n            color = vec3(val * vec3(0.2, 0.4, 0.6)*3.);\n            color = mix(color, color*1.3, h.t/10.);\n        }\n    }\n    \n    {\n        Hit h;\n        if(traceSphere(h, p, d, vec3(0. + sin(iTime)*1.5, 1.5 + (sin(iTime*2.) * 0.25), 5. + cos(iTime)), 1.) && h.t < hitT)\n        {\n            hitT = h.t;\n            color = vec3(0.5, 0., 1.) * max(0.2, dot(h.n, lamp));\n            color += vec3(0.2, 0.4, 0.6)*smoothstep(0., 1., pow(0.7-d.y, 2.));\n        }\n    }\n    \n    return color;\n}\n\nvec3 getCameraPixel(vec2 uv, float aspect)\n{\n    float focalLength = .01;\n    float fov = PI * 0.5;\n    vec3 cameraPos = vec3(0., 1., 0.);\n    \n    float width = tan(fov/2.) * focalLength;\n    float height = width * aspect;\n    vec2 coord = (uv * 2.) - 1.;\n    vec3 pixel = vec3(coord.x * width, coord.y * height, 0.);\n    pixel.z += focalLength; \n    pixel += cameraPos;\n    \n    vec3 d = normalize(pixel - cameraPos);\n    vec3 p = cameraPos;\n    return traceRay(p, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = getCameraPixel(uv, iResolution.y/iResolution.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}