{"ver":"0.1","info":{"id":"4ljcD3","date":"1510898424","viewed":378,"name":"Zero gravity swimming","username":"gaz","description":"3d","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","ragdoll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define L 0\n#define R 1\n\n#define idxCenter         0\n#define idxUpperBody      1\n#define idxNeck           2\n#define idxHead           3\n#define idxRightShoulder  4\n#define idxRightUpperArm  5\n#define idxRightLowerArm  6\n#define idxRightHand      7\n#define idxLeftShoulder   8\n#define idxLeftUpperArm   9\n#define idxLeftLowerArm  10\n#define idxLeftHand      11\n#define idxLowerBody     12\n#define idxRightHip      13\n#define idxRightUpperLeg 14\n#define idxRightLowerLeg 15\n#define idxRightFoot     16\n#define idxLeftHip       17\n#define idxLeftUpperLeg  18\n#define idxLeftLowerLeg  19\n#define idxLeftFoot      20\n#define idxModelPos      21\n#define idxNone         256\n\n\n#define tailCenter        vec3(0,0,0)\n\n#define tailUpperBody     vec3(0,1.3,0)\n#define tailNeck          vec3(0,0.4,0)\n#define tailHead          vec3(0,0.6,0)\n\n#define tailRightShoulder vec3(0.7,-0.2,-0.1)\n#define tailRightUpperArm vec3(1.2,0,0)\n#define tailRigthLowerArm vec3(1.2,0,0)\n#define tailRigthHand     vec3(0.2,0,0)\n\n#define tailLeftShoulder  tailRightShoulder*vec3(-1,1,1)\n#define tailLeftUpperArm  tailRightUpperArm*vec3(-1,1,1)\n#define tailLeftLowerArm  tailRigthLowerArm*vec3(-1,1,1)\n#define tailLeftHand      tailRigthHand*vec3(-1,1,1)\n\n#define tailLowerBody     vec3(0,-1.3,0)\n\n#define tailRightHip      vec3(0.3,0,0)\n#define tailRightUpperLeg vec3(0,-1.8,-0.1)\n#define tailRightLowerLeg vec3(0,-1.5,0)\n#define tailRightFoot     vec3(0,0,0.5)\n\n#define tailLeftHip       tailRightHip*vec3(-1,1,1)\n#define tailLeftUpperLeg  tailRightUpperLeg*vec3(-1,1,1)\n#define tailLeftLowerLeg  tailRightLowerLeg*vec3(-1,1,1)\n#define tailLeftFoot      tailRightFoot*vec3(-1,1,1)\n\n#define tailNone          vec3(0,0,0)\n\n\nvec3 pos[22] = vec3[](\n tailCenter        ,\n tailUpperBody     ,\n tailNeck          ,\n tailHead          ,\n tailRightShoulder ,\n tailRightUpperArm ,\n tailRigthLowerArm ,\n tailRigthHand     ,\n tailLeftShoulder  ,\n tailLeftUpperArm  ,\n tailLeftLowerArm  ,\n tailLeftHand      ,\n tailLowerBody     ,\n tailRightHip      ,\n tailRightUpperLeg ,\n tailRightLowerLeg ,\n tailRightFoot     ,\n tailLeftHip       ,\n tailLeftUpperLeg  ,\n tailLeftLowerLeg  ,\n tailLeftFoot      ,\n tailNone          \n);\n\n\n#define ROW int(iChannelResolution[0].y)\nmat4x3 bornMat(int idx)\n{\n    idx *=3;\n    mat3x4 m = mat3x4(0);\n    for(int i=0;i<3;i++)\n    {\n        m[i] = texelFetch(iChannel0,ivec2(idx%ROW,idx/ROW),0);\n        idx++;\n    }\n    return transpose(m);\n}\n\nvec3 modelPos()\n{\n    int idx = idxModelPos*3;\n    return texelFetch(iChannel0,ivec2(idx%ROW,idx/ROW),0).xyz;\n}\n\nvec3 transform(vec3 p, int idx)\n{\n    return (bornMat(idx) * vec4(p,1)).xyz;\n}\n\nmat3 lookat(vec3 rd) {\n\tvec3 w = normalize(rd),\n\t     u = normalize(vec3(-w.z,0,w.x));\n    return mat3(u, cross(u,w), w);\n}\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat smin(float a,float b,float k){\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return b+h*(a-b-k+k*h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec2 deCapsule( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2(length( pa - ba*h ), h);\n}\n\nfloat deRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat deUpperBody(vec3 p)\n{\n    int idx = idxUpperBody;\n    p = transform(p, idx);\n    vec3 q = p;\n    p-=pos[idx]*0.6;\n    float de=1.0;\n\tq.x=abs(q.x)-.1;\n    vec2 c = vec2(p.y, smax(length(p.xz*vec2(1,1.3)),-(length(q.xz*vec2(1.5,1)-vec2(0,-0.5))-0.5 ) ,0.25  ) ); \n   \tc.x = (c.x>0.)?pow(c.x,1.5):c.x/1.8;\n    de = min(de, length(c)-0.6);   \n    p.x = p.x-2.0*smin(0.0,p.x,0.1)-0.28;  \n    p.z -= 0.4;\n    de = smin(de, length(p)-0.2,0.3);\n    return de;\n}\n\nfloat deLowerBody(vec3 p)\n{\n    int idx = idxLowerBody;\n    p = transform(p, idx);\n    float de=1.0;\n    vec2 s = deCapsule(p, vec3(0), pos[idx]);\n    de = min(de, s.x - 0.3);\n    p-=pos[idx]*0.85;\n\tvec2 c = vec2(-p.y, length(p.xz*vec2(1,1.8))); \n    de = smin(de, length(c)-0.5,0.6);\n    //de = smax(de,-(length(p*vec3(1,0.7,0.7)-vec3(0,0.3,0.28))-0.06),0.03);\n    p.x = p.x-2.0*smin(0.0,p.x,0.02)-0.28;  \n    p.z -= -0.25;\n    p.y -= -0.15;\n    de = smin(de,length(p)-0.2,0.3);\n    return de;\n}\n\nfloat deNeck(vec3 p)\n{\n    int idx = idxNeck;\n    p = transform(p, idx);\n    vec2 de = deCapsule(p, vec3(0), pos[idx]);\n    return de.x - 0.15;\n}\n\nfloat deHead(vec3 p)\n{\n    int idx = idxHead;\n    p = transform(p, idx);\n    return deRoundBox(p-pos[idx]*0.5, vec3(0.3),0.1);\n}\n\nfloat deUpperArm(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightUpperArm:idxLeftUpperArm;\n    p = transform(p, idx);\n    vec2 de = deCapsule(p, vec3(0), pos[idx]);\n    return de.x - smoothstep(1.5,0.7,de.y)*0.2;\n}\n\nfloat deLowerArm(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightLowerArm:idxLeftLowerArm;\n    p = transform(p, idx);\n    vec2 de = deCapsule(p, vec3(0), pos[idx]);\n    return de.x - smoothstep(1.5,0.4,de.y)*0.18;\n}\n\nfloat deHand(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightHand:idxLeftHand;\n    p = transform(p, idx);\n    float de=1.0;\n    p-=pos[idx]*0.5;\n    vec2 c = vec2(p.x, length(p.yz*vec2(1,1.3))); \n   \tc.x = (c.x>0.)?pow(c.x,1.1):c.x/2.0;\n    de = min(de, length(c)-0.15); \n    //vec2 s = deCapsule(p, vec3(0,0.1,0), vec3(pos[idx].x*0.25,0.15,0.1));\n    //de = smin(de, s.x - 0.03,0.05);\n    return de;\n}\n\nfloat deUpperLeg(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightUpperLeg:idxLeftUpperLeg;\n    p = transform(p, idx);\n    vec2 de = deCapsule(p, vec3(0), pos[idx]);\n    return de.x - smoothstep(1.6,0.6,de.y)*0.3;\n}\n\nfloat deLowerLeg(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightLowerLeg:idxLeftLowerLeg;\n    p = transform(p, idx);\n    vec2 de = deCapsule(p, vec3(0), pos[idx]);\n    return de.x - smoothstep(1.6,0.6,de.y)*0.2;\n}\nfloat deFoot(vec3 p, int LR)\n{\n    int idx = (LR==R)?idxRightFoot:idxLeftFoot;\n    p = transform(p, idx);\n    p-=pos[idx]*0.45;\n    vec2 c = vec2(p.z, length(p.xy*vec2(1,1.3))); \n   \tc.x = (c.x>0.)?pow(c.x,1.5):c.x/2.0;\n    return length(c)-0.2;\n}\n\nfloat map(vec3 p)\n{\n    float len=length(p-modelPos()), r = 5.;\n    if (len>r) return len -r+ 0.001;   \n    \n    float de = 1.0;\n    de = min(de, deUpperBody(p));\n    de = smin(de, deNeck(p),0.1);\n    de = smin(de, deHead(p),0.1);\n    de = smin(de, deLowerBody(p),0.3);\n    de = smin(de, deUpperArm(p, L),0.4);\n    de = smin(de, deUpperArm(p, R),0.4);\n    de = smin(de, deLowerArm(p, L),0.03);\n    de = smin(de, deLowerArm(p, R),0.03);\n    de = smin(de, deHand(p, L),0.1);\n    de = smin(de, deHand(p, R),0.1);    \n    de = smin(de, deUpperLeg(p, L),0.1);\n    de = smin(de, deUpperLeg(p, R),0.1);\n    de = smin(de, deLowerLeg(p, L),0.05);\n    de = smin(de, deLowerLeg(p, R),0.05);\n    de = smin(de, deFoot(p, L),0.1);\n    de = smin(de, deFoot(p, R),0.1);\n    return de;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1, -1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n    \nvec3 doColor(vec3 p)\n{\n\tconst float precis = 0.001;\n \tif(deLowerLeg(p,L)<precis) return vec3(1,0.2,0);\n \treturn vec3(0.5,0.9,0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,5,8);\n    vec3 rd = normalize(vec3(p, 2));\n    vec3 ta = vec3(0,5,0);\n    \n    // camera sequence \n\tfloat phaseTime, tmpTime = mod(iTime,30.0);\n  \tint phaseNumber; \t\n  \t#define PH(n,v) if (tmpTime >= 0.0) {phaseTime = tmpTime; phaseNumber = n;}  tmpTime -= float(v);  \n    \n    PH(0, 7)\n    PH(1, 5)\n    PH(2, 5)\n    PH(3, 3)\n        \n    switch (phaseNumber) {\n    \tcase 0:\n        \tro.xz *= rotate(iTime*0.1);\n   \t\t\tbreak;\n    \tcase 1:\n        \tta.x +=3.;\n   \t\t\tro.z += -phaseTime * 4.0;\n    \t\tbreak;\n    \tcase 2:\n   \t\t\tta.y =6.0-phaseTime *0.5;\n        \tro.z -=2.0;\n    \t\t break;\n    \tcase 3: \n   \t\t\tta.x =5.0-phaseTime *1.5;\n        \tro.z -=-1.0+phaseTime * 0.2;\n     \t\tro.xz *= rotate(0.5);\n  \t\t \tbreak;\n    }    \n\n\trd = lookat(ta-ro) * rd;\n    \n\tvec3 col =vec3(0.05,0.1,0.3)- vec3(p.y*p.y)*0.5;\n    col = mix(col, texture(iChannel3, p * 0.1 - iTime * 0.005).xyz, 0.3);\n    \n    \n\tconst float maxd = 100.0, precis = 0.001;\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 128; i++)\n  \t{\n\t\tvec3 p=ro + rd * t;\n    \tt += d =map(p);\n    \tif(d < precis || t > maxd) break;\n  \t}\n  \tif(d < precis)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 bg = col;\n        col = doColor(p);\n        float dif = clamp(dot(nor, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * nor.y, 0.0);\n        float spc = pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 30.0);\n        col *= dif * amb ;\n        col += spc;\n        col = clamp(col,0.0,1.0);\n        col = pow(col, vec3(0.7));        \n    }\n    fragColor = vec4(col, 1.0);;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define idxCenter         0\n#define idxUpperBody      1\n#define idxNeck           2\n#define idxHead           3\n#define idxRightShoulder  4\n#define idxRightUpperArm  5\n#define idxRightLowerArm  6\n#define idxRightHand      7\n#define idxLeftShoulder   8\n#define idxLeftUpperArm   9\n#define idxLeftLowerArm  10\n#define idxLeftHand      11\n#define idxLowerBody     12\n#define idxRightHip      13\n#define idxRightUpperLeg 14\n#define idxRightLowerLeg 15\n#define idxRightFoot     16\n#define idxLeftHip       17\n#define idxLeftUpperLeg  18\n#define idxLeftLowerLeg  19\n#define idxLeftFoot      20\n#define idxModelPos      21\n#define idxNone         256\n\n#define modelPos vec3(0,5,0)\n\nvec4 quat(vec3 p, float a) //quaternion\n{\n    p=normalize(p);\n\treturn vec4(p*sin(a/2.0), cos(a/2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tint id = int(fragCoord.x) + int(iResolution.y) * int(fragCoord.y);\n  \tif (id > idxModelPos) discard;  \n\tvec4 Q = vec4(0,0,0,1);\n    \n  \tswitch(id)\n  \t{\n\t\tcase idxCenter:\n    \t\tQ = quat(vec3(1),(iTime)*0.3);\n      \t\tbreak;\n \t\tcase idxUpperBody:\n    \t\tQ = quat(vec3(1,0,0),sin(iTime)*0.2+0.15);\n      \t\tbreak;\n \t\tcase idxNeck:\n \t\t   \tbreak;\n   \t\tcase idxHead:\n    \t  \tbreak;\n    \tcase idxRightShoulder:\n        \tbreak;\n      \tcase idxRightUpperArm:\n        \tQ = quat(vec3(0,sin(iTime*0.3),cos(iTime*0.3)),sin(iTime*3.)*0.8);\n      \t\tbreak;\n      \tcase idxRightLowerArm:\n    \t\tQ = quat(vec3(0,1,0),abs(sin(iTime)));\n      \t\tbreak;\n      \tcase idxRightHand:\n        \tbreak;\n      \tcase idxLeftShoulder:\n        \tbreak;\n      \tcase idxLeftUpperArm:\n       \t\t//Q = quat(vec3(0,0,1),radians(-90.));\n       \t\tQ = quat(vec3(0,sin(iTime*0.3),cos(iTime*0.3)),sin(iTime*3.)*0.8);\n        \tbreak;\n      \tcase idxLeftLowerArm:\n    \t\tQ = quat(vec3(0,1,0),-abs(sin(iTime)));\n      \t\tbreak;\n      \tcase idxLeftHand:\n        \tbreak;\n      \tcase idxLowerBody:\n        \tbreak;\n      \tcase idxRightHip:\n        \tbreak;\n      \tcase idxRightUpperLeg:\n        \tQ = quat(vec3(1,0,-0.3),abs(sin(iTime+1.0)));\n        \tbreak;\n      \tcase idxRightLowerLeg:\n       \t\tQ = quat(vec3(1,0,0),-abs(sin(iTime+1.0)));\n        \tbreak;\n      \tcase idxRightFoot:\n       \t\tQ = quat(vec3(1,0,0),-0.5);\n        \tbreak;\n      \tcase idxLeftHip:\n        \tbreak;\n      \tcase idxLeftUpperLeg:\n        \tQ = quat(vec3(1,0,0.3),abs(sin(iTime)));\n        \tbreak;\n      \tcase idxLeftLowerLeg:\n       \t\tQ = quat(vec3(1,0,0),-abs(sin(iTime)));\n        \tbreak;\n      \tcase idxLeftFoot:\n       \t\tQ = quat(vec3(1,0,0),-0.5);\n        \tbreak;\n      \tcase idxModelPos:\n          \tQ.xyz = modelPos;\n       \t\tbreak;\n\t}\n\t//Q = vec4(0,0,0,1);\n    fragColor = vec4(Q);  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define idxCenter         0\n#define idxUpperBody      1\n#define idxNeck           2\n#define idxHead           3\n#define idxRightShoulder  4\n#define idxRightUpperArm  5\n#define idxRightLowerArm  6\n#define idxRightHand      7\n#define idxLeftShoulder   8\n#define idxLeftUpperArm   9\n#define idxLeftLowerArm  10\n#define idxLeftHand      11\n#define idxLowerBody     12\n#define idxRightHip      13\n#define idxRightUpperLeg 14\n#define idxRightLowerLeg 15\n#define idxRightFoot     16\n#define idxLeftHip       17\n#define idxLeftUpperLeg  18\n#define idxLeftLowerLeg  19\n#define idxLeftFoot      20\n#define idxModelPos      21\n#define idxNone         256\n\n\nint parentIdx[22] = int[](\n\tidxNone,          // idxCenter\n\tidxCenter,        // idxUpperBody\n\tidxUpperBody,     // idxNeck\n\tidxNeck,          // idxHead\n\tidxUpperBody,     // idxRightShoulder\n\tidxRightShoulder, // idxRightUpperArm\n\tidxRightUpperArm, // idxRigthLowerArm\n\tidxRightLowerArm, // idxRithHand\n\tidxUpperBody,     // idxLeftShoulder\n\tidxLeftShoulder,  // idxLeftUpperArm\n\tidxLeftUpperArm,  // idxLeftLowerArm\n\tidxLeftLowerArm,  // idxLeftHand\n\tidxCenter,        // idxLowerBody\n\tidxLowerBody,     // idxRightHip\n\tidxRightHip,      // idxRightUpperLeg\n\tidxRightUpperLeg, // idxRightLowerLeg\n\tidxRightLowerLeg, // idxRightFoot\n\tidxLowerBody,     // idxLeftHip\n\tidxLeftHip,       // idxLeftUpperLeg\n\tidxLeftUpperLeg,  // idxLeftLowerLeg\n\tidxLeftLowerLeg,  // idxLeftFoot\n\tidxNone           // idxNone\n);\n\n#define tailCenter        vec3(0,0,0)\n\n#define tailUpperBody     vec3(0,1.3,0)\n#define tailNeck          vec3(0,0.4,0)\n#define tailHead          vec3(0,0.6,0)\n\n#define tailRightShoulder vec3(0.7,-0.2,-0.1)\n#define tailRightUpperArm vec3(1.2,0,0)\n#define tailRigthLowerArm vec3(1.2,0,0)\n#define tailRigthHand     vec3(0.2,0,0)\n\n#define tailLeftShoulder  tailRightShoulder*vec3(-1,1,1)\n#define tailLeftUpperArm  tailRightUpperArm*vec3(-1,1,1)\n#define tailLeftLowerArm  tailRigthLowerArm*vec3(-1,1,1)\n#define tailLeftHand      tailRigthHand*vec3(-1,1,1)\n\n#define tailLowerBody     vec3(0,-1.3,0)\n\n#define tailRightHip      vec3(0.3,0,0)\n#define tailRightUpperLeg vec3(0,-1.8,-0.1)\n#define tailRightLowerLeg vec3(0,-1.5,0)\n#define tailRightFoot     vec3(0,0,0.5)\n\n#define tailLeftHip       tailRightHip*vec3(-1,1,1)\n#define tailLeftUpperLeg  tailRightUpperLeg*vec3(-1,1,1)\n#define tailLeftLowerLeg  tailRightLowerLeg*vec3(-1,1,1)\n#define tailLeftFoot      tailRightFoot*vec3(-1,1,1)\n\n#define tailNone          vec3(0,0,0)\n\n\nvec3 pos[22] = vec3[](\n tailCenter        ,\n tailUpperBody     ,\n tailNeck          ,\n tailHead          ,\n tailRightShoulder ,\n tailRightUpperArm ,\n tailRigthLowerArm ,\n tailRigthHand     ,\n tailLeftShoulder  ,\n tailLeftUpperArm  ,\n tailLeftLowerArm  ,\n tailLeftHand      ,\n tailLowerBody     ,\n tailRightHip      ,\n tailRightUpperLeg ,\n tailRightLowerLeg ,\n tailRightFoot     ,\n tailLeftHip       ,\n tailLeftUpperLeg  ,\n tailLeftLowerLeg  ,\n tailLeftFoot      ,\n tailNone          \n);\n\n\nmat4 moveTo(in vec3 p)\n{\n  mat4 m = mat4(1);\n  m[3].xyz = p;\n  return m;\n}\n\nmat4 fromQuat(in vec4 q)\n{\n  float xx = q.x * q.x * 2.0,\n        xy = q.x * q.y * 2.0, \n        yy = q.y * q.y * 2.0, \n        xz = q.x * q.z * 2.0,\n        yz = q.y * q.z * 2.0,\n        zz = q.z * q.z * 2.0,\n        xw = q.x * q.w * 2.0,\n        yw = q.y * q.w * 2.0,\n        zw = q.z * q.w * 2.0;\n  return mat4(\n  \t1.0 - yy - zz, xy + zw, xz - yw,0,\n  \txy - zw, 1.0 - xx - zz, yz + xw,0,\n  \txz + yw, yz - xw, 1.0 - xx - yy,0,\n  \t0,0,0,1);\n}\n\nvec4 getData (int id)\n{\n  int row = int(iChannelResolution[0].y);\n  return texelFetch(iChannel0,ivec2(id%row,id/row),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint p = int(fragCoord.x) + int(iResolution.y) * int(fragCoord.y);\n\tint idx = p / 3;\n  \tif (idx > idxModelPos) discard;\n    if (idx == idxModelPos)\n    {\n        fragColor = getData(idxModelPos);\n    }else{\n  \t\tmat4 m = fromQuat(getData(idx));  \n\t\twhile(true)\n  \t\t{\n    \t\tidx = parentIdx[idx];\n    \t\tif (idx == idxNone) break;\n    \t\tm = m*moveTo(-pos[idx]) * fromQuat(getData(idx)) ;\n  \t\t}\n    \t// center move\n   \t\tm = m*moveTo(-getData(idxModelPos).xyz);   \n    \tfragColor = vec4(transpose(m)[p%3]);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}