{"ver":"0.1","info":{"id":"XX3SRX","date":"1719399527","viewed":48,"name":"I Feel Fuzzy ðŸ¤ª","username":"Joshy20XX","description":"What's happened to my world?! It's all pulsated and noisy! ðŸ™ƒðŸ¥´\nThe Art of Code texture and displacement tutorial: https://www.youtube.com/watch?v=VaYyPTw0V84&t=154s","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beginner","tutorialexample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rtime iTime\n#define PI 3.14159265359\n#define ZERO min(iFrame, 0)\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float REFLECT_PRECISION = 0.002;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\n//X rotation\nmat3 rotX(float theta) {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, cos(theta), -sin(theta)),\n        vec3(0, sin(theta), cos(theta))\n    );\n}\n\n//Y rotation\nmat3 rotY(float theta) {\n    return mat3 (\n        vec3(cos(theta), 0, sin(theta)),\n        vec3(0, 1, 0),\n        vec3(-sin(theta), 0, cos(theta))\n    );\n}\n\n//Z rotation\nmat3 rotZ(float theta) {\n    return mat3 (\n        vec3(cos(theta), -sin(theta), 0),\n        vec3(sin(theta), cos(theta), 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//Identity matrix\nmat3 identity() {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(sdFloor(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(sdSphere(p - vec3(5. * cos(rtime)/11. * -3.1, sin(rtime)/5. * -10.0, 7), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(sdSphere(p - vec3(1. * cos(rtime)/5. * -8.5, sin(rtime)/5. * 2.0, 3), 1.), 2.5); // ID = 2.5\n  vec2 sphereMiddle = vec2(sdSphere(p - vec3(2. * cos(rtime)/8. * 4.1, sin(rtime)/5. * 1.0, 5.), 1.), 3.5); // ID = 3.5\n  \n  vec2 uv = vec2(atan(p.x, p.z)/6.2832, p.y/3.)+.5;\n  float displace = texture(iChannel1, uv).r;\n  \n  flooring -= displace * .4 * cos(rtime/1.);\n  sphereLeft -= displace * .4 * cos(rtime/1.);\n  sphereRight -= displace * .4 * cos(rtime/1.);\n  sphereMiddle -= displace * .4 * cos(rtime/1.);\n\n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  res = opU(res, sphereMiddle);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec2 rayMarch_ref(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < REFLECT_PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 getRefColor(in vec3 ro, in vec3 rd, float id, vec3 normal) {\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - ro);\n    vec3 attenuation = vec3(1.0);\n    float dif = clamp(dot(normal, lightDirection), 0.5, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.);\n    attenuation *= 0.5;\n    vec3 sceneColor = dif * attenuation;\n    vec3 difColor = vec3(0.039,0.678,1.000);\n    \n    if (id > 0.) sceneColor = dif * vec3(0.2 + .3*mod(floor(ro.x) + sin(ro.z), 2.0));\n    if (id > 1.) sceneColor = dif + 9. * vec3(1.000,0.000,0.000);;\n    if (id > 2.) sceneColor = (dif * difColor) + frensel * vec3(0.000,0.059,0.400);\n    \n    return sceneColor;\n}\n\n/* Soft shadowing component using an optimized version from IQ\nhttps://iquilezles.org/articles/rmshadows/ */\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 256 && t < maxt; i++ )\n    {\n        float h = float(map(ro + t * rd));\n        res = min(res, h/(w * t));\n        t += clamp(h, 0.009, 0.50);\n        if (res < -1.0 || t > maxt) break;\n    }\n    res = max(res, -1.0);\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n}\n\n/* Ambient Occlusion code borrowed from IQ's raymarching primitives shader\nhttps://www.shadertoy.com/view/Xds3zN */\n\nfloat raymarchAO(in vec3 p, in vec3 normal) {\n    float occlusion = 0.0;\n    float scale = 1.0;\n    \n    for (int i = ZERO; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i)/4.0;\n        float d = map(p + h * normal).x;\n        occlusion += (h - d) * scale;\n        scale *= 0.95;\n        if (occlusion > 0.35) break;\n    }\n    return clamp(1.0 - 3.0 * occlusion, 0.0, 1.0) * (0.5 + 0.5 * normal.y);\n}\n\n//Render reflection function\nvec3 renderRef(vec2 res, vec3 col, vec3 p, vec3 ro, vec3 rd, float d) {\n    // get ray direction\n    vec3 ref_Rd = rd;\n    vec3 ref_Ro = ro;\n    vec3 ref_Normal = calcNormal(p);\n    \n    //render reflection \n    ref_Ro += ref_Rd * d;\n    ref_Rd = reflect(ref_Rd, ref_Normal);\n    res = rayMarch_ref(ref_Ro + ref_Normal * .003, ref_Rd);\n    \n    //reflection display and color\n    float d_ref = res.x;\n    float ref_id = res.y; //the id of the reflected object\n    col += getRefColor(ref_Ro, ref_Rd, ref_id, ref_Normal);\n    \n    return vec3(d_ref) + col; //return reflection material\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    //Trace ray\n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n    \n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(7, 4, 1);\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    //Material properties\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.); //Render SDF with Frensel model\n    vec3 reflection = renderRef(res, col, p, ro, rd, d);\n    vec3 difColor = vec3(0.039,0.678,1.000);\n    \n    //Testing textures\n    vec3 colXZ = texture(iChannel0, p.xz *.5 + .5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz *.5 + .5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy *.5 + .5).rgb;\n    vec3 tex_normal = abs(normal);\n    vec3 r = normalize((colXY * colXZ * colYZ) * p);\n    tex_normal *= pow(tex_normal, vec3(19));\n    tex_normal /= tex_normal.x + tex_normal.y + tex_normal.z;\n    vec3 difTexture = (colYZ*tex_normal.x + colXZ*tex_normal.y + colXZ*tex_normal.z);\n    \n    // Let's draw some shadows. Technique reference in the shadowing and AO functions above\n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 10., 0.019), 0.1, 1.0);\n    float ambientOcclusion = raymarchAO(p, normal);\n    \n    if (id > 0.) col = dif * vec3(0.2 + .3*mod(floor(p.x) + sin(p.z), 2.0)); //tiled floor\n    if (id > 1.) col = (dif + difTexture) * vec3(0.780,1.000,0.957); //Front sdf sphere\n    if (id > 2.) col = (dif * difColor) + frensel * vec3(0.000,1.000,0.482); //Middle sdf sphere\n    if (id > 3.) col = (dif * difColor) * reflection + frensel * vec3(0.259,0.475,0.580); //Back sdf sphere\n    \n    col += COLOR_BACKGROUND * 0.2 * softShadow * ambientOcclusion; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(7.5, .9, 4.9); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotY((sin(1.5) * -.75) * (2. * PI));\n\n  vec3 col = render(ro, rd, uv);\n  //vec3 col = texture(iChannel0, uv).rgb;\n  //col /= normalize(col);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}