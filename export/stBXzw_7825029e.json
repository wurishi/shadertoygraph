{"ver":"0.1","info":{"id":"stBXzw","date":"1627463706","viewed":340,"name":"Triple Gyroid","username":"Kamoshika","description":"I combined three gyroids.\nThis is also an exercise in lighting for me.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightDir = normalize(vec3(-1, 2, 4));\nconst float lightPower = 20.0;\nconst vec3 lightColor = vec3(1, 1, 1) * lightPower;\nconst vec3 ambColor = vec3(1, 1, 1) * 0.2;\nconst float fogDensity = 0.05;\nconst float metal = 0.8;\nconst float f0 = 0.8;\nconst float fov = 80.;\n\nconst float PI = acos(-1.0);\nconst float PI2 = acos(-1.0) * 2.0;\n\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat sdGyroid(vec3 p) {\n    return dot(sin(p), cos(p.yzx)) + 1.3;\n}\n\nfloat map(vec3 p) {\n    float d = sdGyroid(p);\n    d = min(d, sdGyroid(p + vec3(PI, 0, 0)));\n    d = min(d, sdGyroid(p + vec3(PI, PI, 0)));\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)\n                          ));\n}\n\nfloat calcAO(vec3 rPos, vec3 ray) {\n    float totao = 0.;\n    float sca = 1.;\n    for(int i=0; i<10; i++) {\n        float hr = 0.01 + 0.02 * float(i*i);\n        vec3 aoPos = rPos + ray * hr;\n        float dd = map(aoPos);\n        float ao = clamp(hr - dd, 0., 1.);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.5;\n    return 1. - clamp(aoCoef * totao, 0., 1.);\n}\n\nfloat calcShadow(vec3 rPos, vec3 ray) {\n    float h = 0.;\n    float c = 0.001;\n    float r = 1.;\n    float shadowCoef = 0.5;\n    for(int t = 0; t<10; t++) {\n        h = map(rPos + ray * c);\n        if(h < 0.001) {\n            return shadowCoef;\n        }\n        r = min(r, h*16.0/c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 objColor(vec3 p) {\n    vec3 col = vec3(0);\n    float th = 0.5;\n    if(sdGyroid(p) < th) {\n        col = vec3(1.0, 0.1, 0.1);\n    } else if(sdGyroid(p + vec3(PI, 0, 0)) < th) {\n        col = vec3(0.1, 1.0, 0.1);\n    } else if(sdGyroid(p + vec3(PI, PI, 0)) < th) {\n        col = vec3(0.1, 0.1, 1.0);\n    }\n    return col;\n}\n\nfloat fresnelSchlick(float f0, float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\nfloat exp2InvFog(float dist, float density) {\n    float s = dist * density;\n    return exp(-s*s);\n}\n\nvec3 acesFilm(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0., 1.);\n}\n\nvec3 raymarching(inout vec3 rPos, inout vec3 ray, in int itr, inout bool hit, inout vec3 refAtt) {\n    vec3 col = vec3(0);\n    hit = false;\n    float d = 0.;\n    \n    vec3 rPos0 = rPos;\n    for(int i=0; i<100; i++) {\n        if(i >= itr) break;\n        d = map(rPos);\n        if(abs(d) < 1e-4) {\n            hit = true;\n            break;\n        }\n        rPos += ray * d;\n    }\n    \n    vec3 albedo = objColor(rPos);\n    vec3 normal = calcNormal(rPos);\n    vec3 ref = reflect(ray, normal);\n    float diff = max(dot(normal, lightDir), 0.);\n    float spec = pow(max(dot(reflect(lightDir, normal), ray), 0.), 10.);\n    float ao = calcAO(rPos, normal);\n    float shadow = calcShadow(rPos + normal * 0.005, lightDir); // memo: No shadow.\n\n    col += albedo * diff * shadow * (1. - metal) * lightColor;\n    col += albedo * spec * shadow * metal * lightColor;\n    col += albedo * ao * ambColor;\n\n    float invFog = exp2InvFog(distance(rPos0, rPos), fogDensity);\n    col = mix(vec3(1), col, invFog);\n\n    refAtt *= albedo * fresnelSchlick(f0, dot(ref, normal)) * invFog;\n    rPos += 0.01 * normal;\n    ray = ref;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    vec3 cPos = vec3(0, 0, -fract(iTime/PI2)*PI2);\n    vec3 cDir = normalize(vec3(0, 0, -1));\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    vec3 ray = normalize(uv.x*cSide + uv.y*cUp + cDir/tan(fov / 360. * PI));\n    ray *= rotate3D(iTime * 0.07 * PI, vec3(5,3,1));\n    \n    vec3 rPos = cPos;\n    bool hit = false;\n    vec3 refAtt = vec3(1);\n    \n    col += raymarching(rPos, ray, 100, hit, refAtt);\n    \n    for(int i=0; i<2; i++) {\n        //if(!hit) break;\n        col += refAtt * raymarching(rPos, ray, 50, hit, refAtt);\n    }\n    \n    col = acesFilm(col * 0.8);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}