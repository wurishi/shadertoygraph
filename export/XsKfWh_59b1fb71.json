{"ver":"0.1","info":{"id":"XsKfWh","date":"1528638990","viewed":112,"name":"Fuzzy Sets: Mandelbrot","username":"ptrgags","description":"Mixing fractals and fuzzy logic.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fuzzylogic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTER (iResolution.xy / 2.0)\n#define MAX_ITER 1024\n#define MAX_DIST 1024.0\n#define MIN_ZOOM 0.1\n#define MAX_ZOOM 0.00001\n\n// Spiral in the seahorse valley of the mandelbrot set.\n#define POINT_OF_INTEREST vec2(-0.76158, -0.0847616)\n\n// Fuzzy logic operations\n#define NOT(x) (1.0 - (x))\n#define AND min\n#define OR max\n\n// Constants for this mandelbrot set coloring\n#define HUE_FREQ 100.0\n#define NEAR_POINT 0.0001\n#define FAR_POINT 0.01\n#define WIDTH 0.005\n#define ZOOM_SPEED 0.1\n\n// Complex multiplication\nvec2 cmult(vec2 z1, vec2 z2) {\n    float real = z1.x * z2.x - z1.y * z2.y;\n    float imag = z1.x * z2.y + z1.y * z2.x;\n    return vec2(real, imag);\n}\n\n// Square a complex number.\nvec2 csqr(vec2 z) {\n    return cmult(z, z);\n}\n\n// Compute the length squared of a vector.\nfloat length_squared(vec2 x) {\n    return dot(x, x);\n}\n\n\n/**\n * This distance estimator is based on the\n * code from Inigo Quilez's article here:\n * https://iquilezles.org/articles/distancefractals\n */\nfloat mandelbrot_dist(vec2 c) {\n    vec2 z = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    \n    float dist_mask = 1.0;\n    float dist_squared = 0.0;\n    for (int i = 0; i < MAX_ITER; i++) {\n        // Compute the next derivative of the mandelbrot set sequence.\n        // dz = 2 * z * dz + 1\n        dz = 2.0 * cmult(z, dz) + vec2(1.0, 0.0);\n        \n        // Compute the next z value in the mandelbrot set sequence\n        // z = z^2 + c\n        z = csqr(z) + c;\n        \n        dist_squared = length_squared(z);\n        \n        if (dist_squared > MAX_DIST) {\n            dist_mask = 0.0;\n            break;\n        }\n    }\n    \n    // Distance estimator as described in the algorithm.\n    // d(c) = |z| * log|z| / |dz|\n    float d = sqrt(dist_squared / length_squared(dz)) * 0.5 * log(dist_squared);\n    return d;// * dist_mask;\n}\n\n// Compute a fuzzy set for distance to a point.\n// I use sigmoid-shaped boundaries with smoothstep()\n// x is the input point\n// center is the center of the distance field\n// near, far are the center of the sigmoid-like curves that divide the sets.\n// width is the width of the sigmoid-like curves\nvec3 fuzzy_dist(float dist, float near_point, float far_point, float width) {\n    float half_width = width / 2.0;\n    \n    // Make the sigmoid shapes for near and far using smoothstep()\n    float near = smoothstep(near_point + half_width, near_point - half_width, dist);\n    float far = smoothstep(far_point - half_width, far_point + half_width, dist);\n    \n    // We are at a medium distance if we are not near and not far.\n    float mid = AND(NOT(near), NOT(far));\n    \n    // Return the membership for the three categories.\n    return vec3(near, mid, far);\n}\n\n// Define where the pure values of RGB are\n// on the HSV color wheel. Convert the angle to\n// a value between 0 and 1.\n#define GREEN (120.0 / 360.0)\n#define BLUE (240.0 / 360.0)\n// Red is both at 0 degrees and 360 degrees.\n#define RED1 (0.0 / 360.0)\n#define RED2 (360.0 / 360.0)\n\n// Size of a sector \n#define SECTOR (1.0 / 6.0)\n// Slope of the trapezoid boundary\n// (rise = 1, run = 1/6)\n#define SLOPE (1.0 / SECTOR)\n\n// Calculate the trapezoidal fuzzy membership function\n// one of R, G, B, given a hue from 0.0 to 1.0.\n// For example, hue_trapezoid(hue, GREEN)\n// computes how \"green\" the hue is.\nfloat hue_trapezoid(float h, float center) {\n    // This makes an upside down V shape\n    // with maximum at 2. It's scaled\n    // to match the values in the diagram (see the link above)\n    // 2          /\\\n    //           /  \\\n    // 1        /    \\\n    //         /      \\\n    //        /        \\\n    // 0     /          \\\n    //      /      | center\n    //     /              \\\n    // -1 /                \\ \n    float triangle = 2.0 - SLOPE * abs(h - center);\n    \n    // Clamp it between 0.0 and 1.0 to turn it into \n    // a trapezoid\n    //           ____\n    // 1        /    \\ <- the top spans 120 degrees. (2/6)\n    //         /      \\\n    //        /        \\\n    // 0     /__________\\ <- the base spans 240 degrees (4/6)\n    //             | center\n    return clamp(triangle, 0.0, 1.0);\n}\n\n// Convert a hue value to an RGB vector\n// with full saturation. This asssumes\n// hue is in the range 0.0 to 1.0.\nvec3 fuzzy_hue(float hue) {\n    // Compute membership in \"green\" and \"blue\"\n    float green = hue_trapezoid(hue, GREEN);\n    float blue = hue_trapezoid(hue, BLUE);\n    \n    // Red has to be handled differently since\n    // it is both at 0 and 360 degrees. Compute\n    // two half-trapezoids and union them together.\n    float red1 = hue_trapezoid(hue, RED1);\n    float red2 = hue_trapezoid(hue, RED2);\n    float red = OR(red1, red2);\n    \n    // Return the results for each fuzzy set.\n    return vec3(red, green, blue);\n}\n\n\n// Normalized sine function from [0 to 1] instead of [-1 to 1]\nfloat norm_sin(float x) {\n    return 0.5 + 0.5 * sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - CENTER)/iResolution.y;\n    \n    float zoom = mix(MIN_ZOOM, MAX_ZOOM, norm_sin(ZOOM_SPEED * iTime));\n    \n    vec2 c = POINT_OF_INTEREST + uv * zoom;\n    \n    float dist = mandelbrot_dist(c);\n    \n    // Determine if we are \"near\", \"medium\", \"far\" to the Mandelbrot set.\n    vec3 dist_set = fuzzy_dist(dist / zoom, NEAR_POINT, FAR_POINT, WIDTH);\n    \n    // Map the distance onto a hue.\n    float hue = fract(dist / zoom * HUE_FREQ);\n    // Determine the R, G, B fuzzy sets from the hue. This vector\n    // of membership functions can be used as a color\n    vec3 color = fuzzy_hue(hue);\n    \n    // Start with a black screen\n    vec3 image = vec3(0.0);\n    \n    // Fuzzy logic time!\n    // If distance is near the mandelbrot set, color it navy\n    vec3 navy = vec3(0.0, 0.0, 0.35);\n    image = mix(image, navy, dist_set.x);\n    // If distance is medium, paint the hue color\n    image = mix(image, color, dist_set.y);\n    // If distance is far, draw a background.\n    vec3 background = texture(iChannel0, uv).rgb;\n    image = mix(image, background, dist_set.z);\n    \n    //Note: it would be more correct to compost these layers from background\n    // to foreground. However, I'm happy with how this looks.\n    \n\n    // Output to screen\n    fragColor = vec4(image, 1.0);\n}","name":"Image","description":"","type":"image"}]}