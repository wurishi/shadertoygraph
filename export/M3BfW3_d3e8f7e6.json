{"ver":"0.1","info":{"id":"M3BfW3","date":"1730321795","viewed":2074,"name":"Protein","username":"iq","description":"A protein-like structure made of 32,767 spheres. It's similar to my Kindercrasher 4 kilobytes demo from 2008 ([url]https://www.pouet.net/prod.php?which=50526[/url]) but raytraced instead of rasterized and with real ambient occlusion instead of Screen SSAO","likes":80,"published":3,"flags":32,"usePreview":0,"tags":["3d","raytracing","raycasting","molecule","denoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// precompute spheres\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    if( iFrame>2 || ip.x>=256 || ip.y>128 ) discard;\n    \n    int id = (ip.y<<8) + ip.x;\n\n    fragColor = createSphere( uint(id) );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Inigo Quilez, 2024 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work, neither as it is or altered\n// here on Shadertoy or anywhere else, in any form, including physical and digital. You\n// cannot use this Work in commercial or non-commercial products, websites or projects.\n// You cannot sell this Work and you cannot mint an NFT of it or train a neural network\n// with it without permission. I share this Work for educational purposes; you can link\n// to it, through an URL, proper attribution and unmodified screenshot, as part of your\n// educational material. If these conditions are too restrictive, please contact me and\n// we'll definitely work it out.\n\n\n// A protein-like structure made of 32,767 spheres, raytraced.\n//\n// It's similar to my Kindercrasher 4 kilobytes demo from 2008\n// (https://www.pouet.net/prod.php?which=50526), but raytraced\n// rather than rasterized and computing real ambient occlusion\n// instead of Screen Space Ambient Occlusion. So, it's running\n// in 16 years newer GPUs yet it's hundreds of times slower :)\n//\n// The code is mostly a copy of my previous BVH shader example\n// here: https://www.shadertoy.com/view/lsBSWK\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // dof\n    const float maxCoC = 0.015;       // max Circle of Confusion in screen space (0,1)\n    const float focusPlane = 1.8;    // distance to the focus plane (spherical shell)\n    const float focusRate  = 1.5;    // how quickly to defocuses\n    const ivec2 kV = ivec2(32,13);\n    float ran = texelFetch(iChannel1,ivec2(fragCoord)&1023,0).x;\n    vec4  acc = vec4(0.0);\n\tfor( int i=0; i<kV.x; i++ )\n    {\n        float rad = float(i)/float(kV.x-1);\n        float ang = 6.283185*(float(kV.y)*rad + ran);\n        vec2  off = maxCoC*sqrt(rad)*vec2(cos(ang),sin(ang));\n        vec4  tmp = textureLod(iChannel0,(fragCoord+iResolution.y*off)/iResolution.xy,0.0); \n        \n        float depth = tmp.w;\n        vec3  color = tmp.xyz;\n        float coc   = 0.0001 + maxCoC*min(1.0,focusRate*abs(depth-focusPlane)/depth);\n        if( dot(off,off) < (coc*coc) )\n        {\n            acc += vec4(color,1.0)/(coc*coc);\n        }\n    }\n    vec3 col = acc.xyz / acc.w;\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    // color grade\n    col = pow( col, vec3(0.7,0.9,1.0) );\n\n    // vignette     \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    // clamp\n    col = clamp( col, 0.0, 1.0 );\n\n    // output\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) \n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h);\n}\n\nvec3 sphNormal( in vec3 p, in vec4 sph ) \n{\n    return (p-sph.xyz)/sph.w;\n}\n\n//=====================================================================\n//\n// L0            _ 1 _\n//             _/     \\_\n//            /         \\          Down:  node *= 2\n// L1        2           3         Right: node += 1\n//         /   \\       /   \\       Up:    node /= 2\n// L2     4     5     6     7\n//       / \\   / \\   / \\   / \\\n// L3   8   9 10 11 12 13 14 15\n//\n//=====================================================================\n\n\nvec4 getSphere( in uint id )\n{\n#if 1\n    // precomputed\n    return texelFetch( iChannel2, ivec2(id&255u,id>>8), 0 );\n#else    \n    // not precomputed\n    return createSphere( id );\n#endif    \n}\n\nconst uint kMaxLevel = 14u;\nconst uint kMaxNode = 1u<<kMaxLevel;\n\n// https://iquilezles.org/articles/binarysearchsdf/\nfloat raycastFirst( in vec3 ro, in vec3 rd, out uint oID)\n{\n    float res = 1e30;\n    \n    uint nod = 1u;                              // Start at the root node\n\tfor( uint i=0u; i<=kMaxNode; i++ )\n\t{\n        vec4 sph = getSphere( nod );\n        vec2 tmp = sphIntersect( ro, rd, sph );\n        if( tmp.y>0.0 && tmp.x<res )            // If ray intersects node, and closer\n        {\n            if( nod>=kMaxNode )                 // if leaf\n            {\n                res = tmp.x;                    // then store intersection\n                oID = nod;\n                \n                for(;(nod&1u)==1u;nod>>=1);     // and resume traversal\n                if( nod==0u ) break;\n                nod++;\n            }\n            else                                // or if node isn't a leaf\n            {\n                nod <<= 1;                      // then continue down to left child\n            }\n        }\n        else                                    // But if ray doesn't intersect node\n        {\n            for(;(nod&1u)==1u;nod>>=1);         // then skip whole subtree\n            if( nod==0u ) break;\n            nod++;\n        }\n\t}\n\n    return res;\n}\n\n// https://iquilezles.org/articles/binarysearchsdf/\nfloat raycastAny( in vec3 ro, in vec3 rd )\n{\n    uint nod = 1u;\n\tfor( uint i=0u; i<=kMaxNode; i++ )\n\t{\n        vec4 sph = getSphere( nod );\n        vec2 tmp = sphIntersect( ro, rd, sph );\n        if( tmp.y>0.0 )\n        {\n            if( nod>=kMaxNode ) return 0.0;\n            nod <<= 1;\n        }\n        else\n        {\n            for(;(nod&1u)==1u;nod>>=1);\n            if( nod==0u ) break;\n            nod++;\n        }\n\t}\n    return 1.0;\n}\n\n//=====================================================================\n\n// from fizzer (link no longer exsists)\nvec3 cosineDirection( in vec3 nor, in vec2 r)\n{\n    float a = 6.2831853*r.x;\n    float u = 2.0*r.y-1.0;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)),u));\n}\n\nmat4x4 setCameraToWorld( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ro-ta);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize(cross(cp,cw));\n\tvec3 cv =          (cross(cw,cu));\n    return mat4x4( cu, 0.0, cv, 0.0, cw, 0.0, ro, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // randoms\n    vec4 r = texelFetch( iChannel1, (ip+ivec2(7,11)*iFrame)&1023, 0 );\n\n    // raster (fragCoord) to ndc space (p)\n\tvec2 off = r.xy-0.5;\n    vec2 p = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n\n    // camera\n    float an = 0.05*iTime;\n    float cr = 0.1*sin(an);\n\tvec3  ta = vec3(0.4,-0.2,1.1);\n\tvec3  ro = ta + vec3( 3.0*cos(an), 0.5, 3.0*sin(an) );\n    float fl = 2.85;\n    mat4x4 camera2world = setCameraToWorld( ro, ta, cr );\n    \n\t// ray (in world space)\n    vec3 rd = normalize( (camera2world*vec4(p,-fl,0.0)).xyz );\n    //ro = (camera2world*vec4(0.0,0.0,0.0,1.0)).xyz;\n\n    // background\n    vec3 col = vec3(0.9);\n    \n    // protein\n    uint id = 0u;\n    float t = raycastFirst( ro, rd, id );\n    if( t<1e29 )\n    {\n        // surface\n        vec4 sph = getSphere(id);\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );\n        \n        // material\n        vec3 mate = 0.5 + 0.5*sin( float(id)*0.0002 + 1.0 + vec3(0.0,3.0,4.0) );\n        if( sph.w<0.05 ) mate = vec3(1.0);\n        mate += 0.2*sin( float(id) + vec3(0.9,2.0,2.4) );\n        mate = clamp( mate, 0.0, 1.0 );\n        \n        // lighting\n        #if HW_PERFORMANCE==0\n        vec3 dir = cosineDirection(nor,r.zw);\n        float occ = (dir.y<0.0 ) ? 0.0 : raycastAny( pos+nor*0.001, dir );\n        #else\n        float occ = 0.0;\n        const int num = 4;\n        for( int i=0; i<num; i++ )\n        {\n            vec4 r = texelFetch( iChannel1, (ip+ivec2(17,13)*(iFrame*7+i))&1023, 0 );\n            vec3 dir = cosineDirection(nor,r.zw);\n            occ += (dir.y<0.0 ) ? 0.0 : raycastAny( pos+nor*0.001, dir );\n        }\n        occ /= float(num);\n        #endif\n        float dif = 0.5+0.5*nor.y;\n        vec3  ref = reflect( rd, nor );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float spe = smoothstep(-0.1,0.1,ref.y)*(0.04+0.96*pow(fre,5.0))*dif*4.0;\n        if( spe>0.001 ) spe *= raycastAny( pos+nor*0.001, ref );\n        col = mate*occ*(1.0+fre) + spe;\n    }\n\n\t// project to previous frame and average\n    mat4x4 oldCamera2World = mat4( texelFetch(iChannel0,ivec2(0,0),0),\n                                   texelFetch(iChannel0,ivec2(1,0),0),\n                                   texelFetch(iChannel0,ivec2(2,0),0),\n                                   texelFetch(iChannel0,ivec2(3,0),0) );\n    mat4x4 oldWorldToCamera = inverse(oldCamera2World);\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    // world to camera\n    vec3 cpos = (oldWorldToCamera*wpos).xyz;\n    // camera to ndc\n    vec2 npos = -fl*cpos.xy/cpos.z;\n    // ndc to raster (inverse of line 137)\n    vec2 rpos = 0.5*(iResolution.xy + iResolution.y*npos) - off - 0.5;\n    \n    // blend pixel color history\n    ivec2 ipos = ivec2(floor(rpos));\n    if( (ipos.y>0 || ipos.x>3) && iFrame>0 && t<1e29)\n    {\n        #if 1\n        vec2 fuv = rpos - vec2(ipos);\n        vec4 odata1 = texelFetch(iChannel0,ipos+ivec2(0,0),0);\n        vec4 odata2 = texelFetch(iChannel0,ipos+ivec2(1,0),0);\n        vec4 odata3 = texelFetch(iChannel0,ipos+ivec2(0,1),0);\n        vec4 odata4 = texelFetch(iChannel0,ipos+ivec2(1,1),0);\n        vec4 ocol = vec4(0.0);\n        if( abs(t-odata1.w)<0.1 ) {ocol+=vec4(odata1.xyz,1.0)*(1.0-fuv.x)*(1.0-fuv.y);}\n        if( abs(t-odata2.w)<0.1 ) {ocol+=vec4(odata2.xyz,1.0)*(    fuv.x)*(1.0-fuv.y);}\n        if( abs(t-odata3.w)<0.1 ) {ocol+=vec4(odata3.xyz,1.0)*(1.0-fuv.x)*(    fuv.y);}\n        if( abs(t-odata4.w)<0.1 ) {ocol+=vec4(odata4.xyz,1.0)*(    fuv.x)*(    fuv.y);}\n        if( ocol.w>0.001 ) col = mix( max(ocol.xyz/ocol.w,0.0), col, 0.05 );\n\t\t#else\n        col = mix( textureLod( iChannel0, (rpos+0.5)/iResolution.xy, 0.0 ).xyz, col, 0.05 );\n        #endif\n    }\n\n    // output color (or camera matrix)\n    fragColor = (ip.y==0 && ip.x<=3) ? camera2world[ip.x] : vec4( col, t );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 createSphere( in uint id )\n{\n    vec4 sphere = vec4(0.0,0.0,0.0,4.0);\n    uint levels = uint(floor(log2(float(id))));\n    for( uint i=0u; i<levels; i++ ) // i-th node in the root to id-leaf path\n    {\n        uint  b = id >> (levels-1u-i);\n        vec4  r = sin( float(b)*vec4(21.0,13.0,17.0,43.0) + vec4(0.0,2.0,1.0,3.0) );\n        float w = sphere.w*(0.73+0.2*r.w);\n        sphere = vec4( sphere.xyz + normalize(r.xyz)*(sphere.w-w), w );\n    }\n    return sphere;\n}\n","name":"Common","description":"","type":"common"}]}