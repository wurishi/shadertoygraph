{"ver":"0.1","info":{"id":"cdXGRM","date":"1685609492","viewed":72,"name":"PC G Club in Space","username":"DENFOR","description":"2022.10.15 test1    => Line 12  Font change                            => Line 624  BG (col +=c ; ad 10seconds)\n                            BG 0~10s default  10~20s mandala   20~30s Planet   30~40s gwowing   40~50s growing2\n\n                              ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/llj3zV   by Gas Giant\n// --- access to the image of ascii code c // from Fabrice ;\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel0, U/16. + fract( floor(vec2(c, 15.999-float(c/16))) / 16.))/1.5\n\n\n\nfloat shtoy(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0); \n    C(32);C(32);C(32);C(32); /*C(32);C(32);C(32); */\n     \n     //C(68);C(82);C(79);C(78); C(69);C(83);C(89);\n    //   P     C           G            C     L      u     b\n      C(80);C(67);C(32);C(71); C(32);C(67);C(76);C(117);C(98);\n     \n     C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);\n  \n    return length(T.yz)==0. ? 0. : T.x;\n}\n\n\n \n\n\n#define dirr 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\n\n#define PI 3.14159265358979\n\nconst float pi = 3.14159;\nmat3 xrot(float t)\n{    return mat3(1.0, 0.0, 0.0,\n    0.0, cos(t), -sin(t),\n    0.0, sin(t), cos(t));\n}\nmat3 yrot(float t)\n{    return mat3(cos(t), 0.0, -sin(t),\n    0.0, 1.0, 0.0,\n    sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{    return mat3(cos(t), -sin(t), 0.0,\n    sin(t), cos(t), 0.0,\n    0.0, 0.0, 1.0);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 uv (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * PI) + .5;\n    float v = asin(y) / (PI) + .5;\n    return vec2(u,v);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 map(vec3 p)\n{\n    vec2 f=(fract(p.xy) * 2.0 - 1.0) ;\n    vec3 q = vec3(f.x-0.5, f.y, p.z);\n    float br = 0.4;\n    float c = sdCylinder(  p+vec3( 0.0,0.60,-1.0), vec2(3.0,3.0)  );\n   // float b = sdCylinder(p, vec2(1.1,1.3))*br;\n    \n  //  float b= sdBox(p-vec3( 0.0,0.25, 0.0), vec3(0.65) );\n \n    float  ss = sdSphere(    p-vec3( 0.0,0.00, 0.0),1.00 )  ;\n  \n    return vec2(ss, ss);\n    \n}\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.02, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n    map(p+o.yxy).x - map(p-o.yxy).x,\n    map(p+o.yyx).x - map(p-o.yyx).x));\n}\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    vec3 p = o + r * t;\n    float d = map(p).x;\n    t += d;\n\t}\nreturn t;\n}\n\nvec4 tex(vec3 p)\n{\n    \n    \n    vec4 tx= texture(iChannel1,uv(normalize(p)));\n    \n    return (tx ) ;\n}\n\n//////////////////////////////////////////////////////  BG Data Start\nconst int star_iterations = 10;\nconst float distort_iterations = 5.0;\nconst float tex_scale = 0.025;\nconst float time_scale = 0.2;\nconst vec3 col_star = vec3( 1.0, 0.7, 0.5 );\nconst vec3 pos_star = vec3( 0.0, 9.0, 30.0 );\nconst vec3 world_up = vec3( 0.0, 1.0, 0.0 );\n\nstruct CameraInfo\n{\n    vec3 pos;\n    vec3 dir;\n    mat3 m;\n    mat3 mInv;\n};\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nvec2 field(vec2 p)\n{\n    float t = time_scale * iTime;\n\n    p.x += t;\n\n    float n = fbm( p, t );\n\n    float e = 0.25;\n    float nx = fbm( p + vec2( e, 0.0 ), t );\n    float ny = fbm( p + vec2( 0.0, e ), t );\n\n    return vec2( n - ny, nx - n ) / e;\n}\n\nvec3 distort( in vec2 p )\n{\n    for( float i = 0.0; i < distort_iterations; ++i )\n    {\n        p += field( p ) / distort_iterations;\n    }     \n    // Planet Color iChannel2~~3  //\n // vec3 s = 2.5 * texture( iChannel2, vec2( 0.0, p.y * tex_scale ) ).xyz;\n    vec3 s = 2.5 * texture( iChannel3, vec2( 0.0, p.y * tex_scale ) ).xyz;\n    return fbm( p, 0.0 ) * s;\n}\n\nvec2 map( in vec2 uv )\n{\n    uv.x *= 5.0;\n    uv.x += 0.01 * iTime;\n    uv.y *= 15.0;\n    return uv;\n}\n\nvec3 doBackgroundStars( in vec3 dir )\n{\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    \n    return f * col_star;\n}\n\nvec3 doMainStar( in vec2 uv, in vec2 sp)\n{\n    float t = atan( uv.x - sp.x, uv.y - sp.y );\n    float n = 2.0 + noise( vec3( 10.0 * t, iTime, 0.0 ) );\n    float d = length( uv - sp ) * 25.0;\n    return ( ( 1.0 + n ) / ( d * d * d ) ) * col_star;\n}\n\nfloat doCastSphere( in vec3 p, in vec3 rd )\n{\n    float b = dot( p, rd );\n    float c = dot( p, p ) - 1.0;\n    \n    float f = b * b - c;\n    if( f >= 0.0 )\n    {\n        return -b - sqrt( f );\n    }\n    return -1.0;\n}\n\nvec3 doMaterial( in vec3 pos )\n{\n    vec2 uv;\n    uv.x = atan( pos.x, pos.z );\n    uv.y = asin( pos.y );\n    return distort( map( uv ) );\n}\n\nvec3 doLighting( in vec3 n, in vec3 c, in vec3 rd, in vec3 rdc )\n{\n    vec3  l   = normalize( pos_star + 2.0 * ( pos_star - dot( pos_star, rdc ) * rdc ) );\n    float ndl = dot( n, l );\n    float ndr = dot( n, -rd );\n    float ldr = dot( l, rd );\n    float f   = max( ndl, 0.0 ) + 0.002;\n    float g   = ldr * smoothstep( 0.0, 0.1, ndr ) * pow( 1.0 - ndr, 10.0 );\n    return clamp( f * c + g * col_star, 0.0, 1.0 );\n}\n\nfloat doFlare( in vec2 uv, in vec2 dir, float s )\n{\n    float d = length( uv - dot( uv, dir ) * dir );\n    float f = 0.0;\n    f += max( pow( 1.0 - d, 128.0 ) * ( 1.0   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  64.0 ) * ( 0.5   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  32.0 ) * ( 0.25  * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  16.0 ) * ( 0.125 * s - length( uv ) ), 0.0 );\n    return f;\n}\n\nfloat doLensGlint( in vec2 uv, in vec2 c, float r, float w )\n{\n    float l = length( uv - c );\n    return length( c ) * smoothstep( 0.0, w * r, l ) * ( 1.0 - smoothstep( w * r, r, l ) );\n}\n\nvec3 render( in vec2 uv, in CameraInfo ci )\n{\n    // create view ray\n    vec3 rd  = ci.m * normalize( vec3( uv, 1.0 ) );\n    vec3 rdc = ci.m * vec3( 0.0, 0.0, 1.0 );\n    \n    // background stars\n    vec3 c = doBackgroundStars( rd );\n    \n    // main star\n    vec3 cp = ci.mInv * (pos_star - ci.pos);\n    vec2 sp = cp.xy / cp.z;\n    if( cp.z > 0. )\n    {\n        c += doMainStar( uv, sp );\n    }\n    \n    // planet\n    float t = doCastSphere( ci.pos, rd );\n    if( t > 0.0 )\n    {\n        vec3 pos = ci.pos + t * rd;\n        vec3 nor = normalize( pos );\n        c = doMaterial( pos );\n        c = doLighting( nor, c, rd, rdc );\n    }\n    \n    // lens flare\n    if( cp.z > 0.0 && sp.x > -1.0 && sp.x < 1.0 )\n    {\n        float oc = smoothstep( 0.35, 0.4, length( sp ) );\n        float f = 0.0;\n        f += doFlare( uv - sp, vec2( 1.,0. ), oc );\n        f += oc * 0.05 * doLensGlint( uv, -0.4 * sp, 0.2, 0.92 );\n        f += oc * 0.09 * doLensGlint( uv, -0.8 * sp, 0.3, 0.95 );\n        f += oc * 0.04 * doLensGlint( uv, -1.1 * sp, 0.06, 0.8 );\n        c += f * col_star;\n    }\n    \n    return c;\n}\n\nCameraInfo doCamera( in vec3 pos, in vec3 dir )\n{\n    CameraInfo ci;\n    \n    vec3 ww = dir;\n    vec3 uu = normalize( cross( ww, world_up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    mat3 m = mat3( uu, vv, ww );\n    mat3 mInv = mat3( uu.x, vv.x, ww.x,\n                      uu.y, vv.y, ww.y,\n                      uu.z, vv.z, ww.z );\n    \n    ci.pos = pos;\n    ci.dir = dir;\n    ci.m = m;\n    ci.mInv = mInv;\n    \n    return ci;\n}\n\n\n////////////////////////////////////////////////BG Planet Data END Case(1)\n\n/////////////////////////////////////////////// Bg Mandala Data  Start case(2)\n//#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvec3 saturate(vec3 col) {\n  return clamp(col, 0.0, 1.0);\n}\n\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 mod2(inout vec2 p, vec2 size)  {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\n\nfloat mandala_df(float localTime, vec2 p) {\n  vec2 pp = toPolar(p);\n  float a = TAU/64.0;\n  float np = pp.y/a;\n  pp.y = mod(pp.y, a);\n  float m2 = mod(np, 2.0);\n  if (m2 > 1.0) {\n    pp.y = a - pp.y;\n  }\n  pp.y += localTime/40.0;\n  p = toRect(pp);\n  p = abs(p);\n  p -= vec2(0.5);\n  \n  float d = 10000.0;\n  \n  for (int i = 0; i < 4; ++i) {\n    mod2(p, vec2(1.0));\n    float da = -0.2 * cos(localTime*0.25);\n    float sb = box(p, vec2(0.35)) + da ;\n    float cb = circle(p + vec2(0.2), 0.25) + da;\n    \n    float dd = max(sb, -cb);\n    d = min(dd, d);\n    \n    p *= 1.5 + 1.0*(0.5 + 0.5*sin(0.5*localTime));\n    rot(p, 1.0);\n  }\n\n  \n  return d;\n}\n\nvec3 mandala_postProcess(float localTime, vec3 col, vec2 uv) \n{\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  col = clamp(col, 0.0, 1.0);   \n  col=pow(col,mix(vec3(0.5, 0.75, 1.5), vec3(0.45), r)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=sqrt(1.0 - sin(-localTime + (50.0 - 25.0*sqrt(r))*r))*(1.0 - sin(0.5*r));\n  col = clamp(col, 0.0, 1.0);\n  float ff = pow(1.0-0.75*sin(20.0*(0.5*a + r + -0.1*localTime)), 0.75);\n  col = pow(col, vec3(ff*0.9, 0.8*ff, 0.7*ff));\n  col *= 0.5*sqrt(max(4.0 - r*r, 0.0));\n  return clamp(col, 0.0, 1.0);\n}\n\nvec2 mandala_distort(float localTime, vec2 uv) {\n  float lt = 0.1*localTime;\n  vec2 suv = toSmith(uv);\n  suv += 1.0*vec2(cos(lt), sin(sqrt(2.0)*lt));\n//  suv *= vec2(1.5 + 1.0*sin(sqrt(2.0)*time), 1.5 + 1.0*sin(time));\n  uv = fromSmith(suv);\n  modMirror2(uv, vec2(2.0+sin(lt)));\n  return uv;\n}\n\nvec3 mandala_sample(float localTime, vec2 p)\n{\n  float lt = 0.1*localTime;\n  vec2 uv = p;\n  uv *=8.0;\n  rot(uv, lt);\n  //uv *= 0.2 + 1.1 - 1.1*cos(0.1*iTime);\n\n  vec2 nuv = mandala_distort(localTime, uv);\n  vec2 nuv2 = mandala_distort(localTime, uv + vec2(0.0001));\n\n  float nl = length(nuv - nuv2);\n  float nf = 1.0 - smoothstep(0.0, 0.002, nl);\n\n  uv = nuv;\n  \n  float d = mandala_df(localTime, uv);\n\n  vec3 col = vec3(0.0);\n \n  const float r = 0.065;\n\n  float nd = d / r;\n  float md = mod(d, r);\n  \n  if (abs(md) < 0.025) {\n    col = (d > 0.0 ? vec3(0.25, 0.65, 0.25) : vec3(0.65, 0.25, 0.65) )/abs(nd);\n  }\n\n  if (abs(d) < 0.0125) {\n    col = vec3(1.0);\n  }\n\n  col += 1.0 - pow(nf, 5.0);\n  \n  col = mandala_postProcess(localTime, col, uv);;\n  \n  col += 1.0 - pow(nf, 1.0);\n\n  return saturate(col);\n}\n\nvec3 mandala_main(vec2 p) {\n\n  float localTime = iTime + 30.0;\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  const int aa = 2;\n  for(int y = 0; y < aa; ++y)\n  {\n    for(int x = 0; x < aa; ++x)\n    {\n      col += mandala_sample(localTime, p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= float(aa*aa);\n  return col;\n}\n\n\n//////////////////////////////////////////////////////  case(2)  END Mandala\n\n////////////////////////////////////////////// Case(3) Data Start Space Gwowing\n vec3 roty (vec3 pos, float angle)\n{ \n    float sa = sin(angle), ca = cos(angle);\n    return mat3(ca,0,-sa, 0,1,0, sa,0,ca) * pos;\n}\n\nfloat mapG (in vec3 p) \n{\n\tvec3 c = p; \n    float res = 0.0;\n\tfor (int i=0; i < 4; i++) \n\t{\n\t\tp = abs(p) / dot(p,p) -0.7;\n\t\tp.yz = vec2(p.y*p.y-p.z*p.z, 2.*p.y*p.z);\n\t\tres += exp(-20.0 * abs(dot(p,c)));\n\t}\n\treturn res * 0.4;\n}\n\nvec3 raymarch (vec3 ro, vec3 rd)\n{\n\tfloat t = 5.0;\n    float c = 0.0;\n\tvec3 col = vec3(0.0); \n\tfor (int i=0; i < 6; i++)\n\t{\n\t\tt += exp(c * -2.0) * 0.02;\n\t\tc = mapG(t * rd + ro);               \n\t\tcol= vec3(4.0*c, 2.0*c, 6.0*c*c*c) *0.16 + col *0.6;\n\t\tc = mapG(t*0.99 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c*c, 2.0*c*c, c) *0.16 + col *0.6;\n\t\tc = mapG(t*1.01 * rd + ro);               \n\t\tcol+= vec3(4.0*c, 18.0*c*c*c, -33.*c*c)*0.16 + col *0.6;\n        /* // blue\n\t\tcol= vec3(c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, 8.0*c) *0.16 + col *0.96;\n\t\tcol= vec3(c, 18.0*c*c*c, 8.0*c*c)*0.16 + col *0.96;\n\t\t*/\n\t}\n\treturn col*0.2;\n}\n\n\n///////////////////////////////////////////////          case(3) END\n\n///////////////////////////////////////////////          Case (4) Data Start\n\nvec3 rotateY(vec3 p, float angle)\n{\n  float sa = sin(angle),   ca = cos(angle);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n//----------------------------------------------------------------\nfloat mapGG (in vec3 p) \n{\n\tvec3 c = p; \n    float res = 0.0;\n\tfor (int i=0; i < 4; i++) \n\t{\n\t\tp = abs(p) / dot(p,p) -0.7;\n\t\tp.yz = vec2(p.y*p.y-p.z*p.z, 2.*p.y*p.z);\n\t\tres += exp(-20.0 * abs(dot(p,c)));\n\t}\n\treturn res * 0.4;\n}\n\n//----------------------------------------------------------------\nvec3 raymarchG (vec3 ro, vec3 rd)\n{\n\tfloat t = 5.0;\n    float c = 0.0;\n\tvec3 col = vec3(0.0); \n\tfor (int i=0; i < 6; i++)\n\t{\n\t\tt += exp(c * -2.0) * 0.02;\n\t\tc = mapGG(t * rd + ro);               \n\t\tcol= vec3(22.0*c*c, 2.0*c, 6.0*c*c*c) *0.16 + col *0.6;\n\t\tc = mapGG(t*0.99 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 22.0*c*c, c) *0.16 + col *0.6;\n\t\tc = mapGG(t*1.01 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 8.0*c*c, 11.*c)*0.16 + col *0.6;\n         // blue\n//\t\tcol= vec3(c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, 8.0*c) *0.16 + col *0.96;\n\t\tcol= vec3(c, 18.0*c*c*c, 8.0*c*c)*0.16 + col *0.96;\n\t\t\n\t}\n\treturn col*0.2;\n}\n\n//----------------------------------------------------------------\n\n//const float PI = 3.14159265359;\n\n//float sideCount = 1.0;  // min. number of sides\n\n//----------------------------------------------------------------\n// equal to koleidoscope, but more compact \n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n\n/////////////////////////////////////////////////        case (4) END\n\n//////////////////////////////////////////////////    case (5) Galaxy Data Start\n#define S smoothstep\n#define T iTime\n\n#if HW_PERFORMANCE==0\n#define NUMRINGS 20.\n#define MAX_BLOCKS 20.\n#else\n#define NUMRINGS 40.\n#define MAX_BLOCKS 40.\n#endif\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Hash31(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec4 Galaxy(vec3 ro, vec3 rd, float seed, float a1, float a2, float cut) {\n    \n    mat2 rot = Rot(a1);\n    ro.xy *= rot; rd.xy*=rot;\n    rot=Rot(a2);ro.yz *= rot; rd.yz*=rot;\n    \n    vec2 uv = ro.xz+(ro.y/-rd.y)*rd.xz;\n \n    seed = fract(sin(seed*123.42)*564.32);\n        \n    vec3 \n        col = vec3(0),\n        dustCol = vec3(.3, .6, 1.);\n    \n    float alpha = 0.;\n    if(cut==0. || (ro.y*rd.y<0. && length(uv)<2.5)) {\n        \n        float \n            ringWidth = mix(10.,25., seed),\n            twist = mix(.3, 2., fract(seed*10.)),\n        \tnumStars = mix(2., 15., pow(fract(seed*65.),2.)),\n        \tcontrast = fract(seed*3.),\n            flip = 1.,\n            t=T*.1*sign(seed-.5),\n            z, r, ell, n, d, sL, sN, i;\n        \n        if(cut==0.) twist = 1.;\n        \n        for(i=0.; i<1.; i+=1./NUMRINGS) {\n\n            flip *= -1.;\n            z = mix(.06, 0., i)*flip*fract(sin(i*563.2)*673.2);\n            r = mix(.1, 1., i);\n\n            uv = ro.xz+((ro.y+z)/-rd.y)*rd.xz;\n        \n            vec2 st = uv*Rot(i*6.2832*twist);\n            st.x *= mix(2., 1., i);\n\n            ell = exp(-.5*abs(dot(st,st)-r)*ringWidth);\n            vec2 texUv = .2*st*Rot(i*100.+t/r);\n            vec3 \n                dust = texture(iChannel0, texUv+i).rgb,\n                dL = pow(ell*dust/r, vec3(.5+contrast));\n\n            vec2 id = floor(texUv*numStars);\n            texUv= fract(texUv*numStars)-.5;\n\n            n = Hash31(id.xyy+i);\n\n            d = length(texUv); \n\n            sL = S(.5, .0, d)*pow(dL.r,2.)*.2/d;\n           \n            sN = sL;\n            sL *= sin(n*784.+T)*.5+.5;\n            sL += sN*S(.9999,1., sin(n*784.+T*.05))*10.;\n            col += dL*dustCol;\n\n            alpha += dL.r*dL.g*dL.b;\n\n            if(i>3./numStars)\n            col += sL* mix(vec3(.5+sin(n*100.)*.5, .5, 1.), vec3(1), n);\n        }\n\n        col = col/NUMRINGS;\n    }\n    \n    vec3 \n        tint = 1.-vec3(pow(seed,3.), pow(fract(seed*98.),3.), 0.)*.5,\n        center = vec3( exp(-.5*dot(uv,uv)*30.) ),\n        cp = ro + max(0., dot(-ro, rd))*rd;\n    \n    col *= tint;\n    \n    cp.y*= 4.;\n    center += dot(rd, vec3(rd.x, 0, rd.z))*exp(-.5*dot(cp,cp)*50.);\n    \n    col += center*vec3(1., .8, .7)*1.5*tint;\n    \n    return vec4(col, alpha);\n}\n\nvec3 Bg(vec3 rd) {\n    vec2 uv = vec2(atan(rd.x,rd.z), rd.y*.5+.5);\n\tuv *= 2.;\n    float wave = sin(rd.y*3.14+T*.1)*.5+.5;\n    wave *= sin(uv.x+uv.y*3.1415)*.5+.5;\n    return vec3(0.01*sin(T*.06),0,.05)*wave;\n}\n\n////////////////////////////////////////////////      case (5) Galaxy Data ENd\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \n    float t=iTime*3.0;\n    \n     \n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n   \t\t uv3 = uv3 * 2.0 - 1.0;\n   \t\t uv3.x *=iResolution.x/iResolution.y;    \n \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy ;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n    \n    vec2 uvs = uv*2.-1.0;\n    \n    float rot = radians(iTime * 360.0)/30.0;\n    \n     \n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \t\n    float gtimer = iTime;\n    \n    uv = uv -0.5;\n    if (gtimer>30.0) {  uv  = m * uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n    if (gtimer>60.0) {  uv  = m * -uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dirr==0 \n        GA.y +=time*speed;\n        #elif dirr==1\n        GA.y -=time*speed;\n        #elif dirr==2\n        GA.x +=time*speed;\n        #elif dirr==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n   \n    \n    \n\t float cl= (N8+N7+N6+N5+N4+N3+N2+N1)*2.0;\n \n   \n    float tm=iTime/5.0;\n    \n   \n    \n    vec3 r = normalize(vec3(uv3, 1.3));//1.5\n    vec3 o = vec3(0.0, 0.0, -2.5);\n \n    mat3 xfm = yrot(-iMouse.x*0.01)*xrot(iMouse.y*0.01)*zrot(0.);\n    xfm *= xrot(0.4*tm*3.5);// unused !\n    o *= xfm;\n    r *= xfm;\n    float tt = trace(o, r);\n    vec3 w = o + r * tt;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    vec3 lpos = o-1.8*sin(tm)  ;// remove  \n    vec3 ldel = lpos - w;\n    float llen = length(ldel);\n    ldel /= llen;\n    vec3 refl = reflect(ldel, sn);\n    float prod = max(dot(ldel,sn), 1.5)*1.5;\n    float spow = max(dot(refl,r), 0.1);\n    vec4 diff = tex(w*0.4);//0.4\n    vec4 spec = vec4(0.0);\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 500.0);\n    vec4 fc = (diff * prod + spec * spow) * fog;\n    \n    //uv3.x = uv3.x+0.2*iTime; \n    \n     vec3 tx   = 2.*texture(iChannel2,uv).xyz;\n        \n     float txty = 2.0;\n     float txtx = -4.0;           \n       \n     float intensity =1.0;\n    \n    \n    uvs = uvs -0.5;\n    if (gtimer>=32.0) {intensity =0.1+abs(2.*sin(gtimer)*2.0);}\n   \n    if (gtimer>=34.0) {uvs.y += 0.5+2.2*sin(gtimer)*0.5;}\n    if (gtimer>=44.0) {uvs.x += 0.5+2.2*sin(gtimer)*0.8;}\n    if (gtimer>=64.0) {uvs.x -= 0.5+2.2*sin(-gtimer)*0.8;}\n    \n      \n      \n  float a  = shtoy((uvs*0.9*5.*abs(sin(iTime*0.8)))-vec2(txtx-0.4,txty-4.8));//Lowerest PC G Club\n      //  a += shtoy((uvs*1.1*5.*abs(sin(iTime*0.7)))-vec2(txtx,txty-4.2));  //  mddle    PC G Club\n      //  a += shtoy((uvs*1.2*5.*abs(sin(iTime*0.6)))-vec2(txtx,txty-3.6));  //\n        a += shtoy((uvs*1.3*5.*abs(sin(iTime*0.5)))-vec2(txtx,txty-3.0));  //\n      //  a += shtoy((uvs*1.4*5.*abs(sin(iTime*0.4)))-vec2(txtx,txty-2.4));  //\n      //  a += shtoy((uvs*1.5*5.*abs(sin(iTime*0.3)))-vec2(txtx,txty-1.8));  //  middle   PC G Club\n        a += shtoy((uvs*1.6*5.*abs(sin(iTime*0.2)))-vec2(txtx-0.4,txty-1.2));//Upperest PC G Club\n\n                         \n     float final = a ;                                    // unused\n     vec3 col = mix(vec3(a*tx.r,a*tx.g,a*tx.b)*intensity,                                                    \n                             vec3(cl*cos(iTime*0.2),cl*2.,cl*(1.+0.5*cos(iTime*0.3) )),cl)  ;        // unused\n                             \n                             \n    //   fragColor = vec4(col, 1.0) ;  //  =>  transfer  Line 622\n       \n  ////////////////////////////////////////////////  BG case(1) Start\n         vec2 uv1 = gl_FragCoord.xy / iResolution.xy - 0.5;\n    uv1.x *= iResolution.x / iResolution.y;\n    \n    vec2 mm = iMouse.xy / iResolution.xy;\n    \n    // camera default movement\n    float cx = cos( 0.1 * iTime + 3.55 );\n    float sx = sin( 0.1 * iTime + 3.55 );\n    float cy = 0.;\n    \n    // camera mouse movement\n    if( iMouse.z > 0. )\n    {\n        cx = cos( 10. * mm.x );\n        sx = sin( 10. * mm.x );\n        cy = cos( 3.2 * mm.y );\n    }\n    \n    // camera position/direction\n    vec3 camPos = 2. * vec3( cx - sx, cy, sx + cx );\n    vec3 camDir = normalize( -camPos );\n\n    // render scene\n    vec3 c = render( uv1, doCamera( camPos, camDir ) );\n    //vec3 c = vec3( distort( map( uv ) ) );\n    //vec3 c = vec3( fbm( map( uv ), iTime ) );\n    \n    // gamma correction\n    c = pow( c, vec3( 0.4545 ) );       // Planet Col\n       \n       //////////////////////////////////////////// BG Case(1) END\n   if(mod(iTime,60.)>20. &&  mod(iTime,60.)<30.  ){    col += c ;  }\n   \n   //////////////////////////////////////////////// BG case(2) Mandala Start\n  if(mod(iTime,60.)>10.  && mod(iTime,60.)<20.){    \n  float time = 0.1*iTime;\n  vec2 uvM = fragCoord/iResolution.xy - vec2(0.5);  // uvM\n  uv.x *= iResolution.x/iResolution.y;\n\n\n  vec3 colM = mandala_main(uvM);                   //colM , uvM\n   \n            col += colM ;                        // Mandala color\n      }\n   /////////////////////////////////////////////////// BG case(2) END\n   \n   //////////////////////////////////////////////////     case(3) growing Start\n   if(mod(iTime,60.)>30.  && mod(iTime,60.)<40.){    \n   vec2 p = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec3 roG = roty(vec3(3.), iTime*0.2 + iMouse.x / iResolution.x);\n    vec3 uuG = normalize(cross(roG, vec3(1.0, 0.0, 0.0)));\n    vec3 vvG = normalize(cross(uuG, roG));\n    vec3 rdG = normalize(p.x*uuG + p.y*vvG - roG*0.5);\n    fragColor.rgb = log(raymarch(roG,rdG) + 1.0)*0.5;\n          col += fragColor.rgb ;\n   }\n   \n   /////////////////////////////////////////////////     case(3) END\n   \n   /////////////////////////////////////////////////     case (4) growing2  Start\n  if(mod(iTime,60.)>40.  && mod(iTime,60.)<50.){    \n   vec2 p = 2.0*(fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 mp = iMouse.xy / iResolution.xy;\n        \n    float sideCount = 1.0 + round(mp.y * 11.0);\n    \n    smallKoleidoscope(p, PI / sideCount);    \n    \n    vec3 roGG = rotateY(vec3(3.), iTime*0.2 + iMouse.x / iResolution.x); //roGG\n    vec3 uu = normalize(cross(roGG, vec3(1.0, 0.0, 0.0)));// roGG\n    vec3 vv = normalize(cross(uu, roGG));                 // roGG\n    vec3 rdGG = normalize(p.x*uu + p.y*vv - roGG*0.5);    // roGG\n    vec3 colGG = log(raymarchG(roGG,rdGG) + 1.0)*0.5;    //change  raymarchG\n        col += colGG  ;                                  // colGG\n   }\n   ////////////////////////////////////////////////        case (4) ENd\n   \n   ////////////////////////////////////////////////         case (5) Galaxy Start\n    if(mod(iTime,60.)>50.  && mod(iTime,60.)<60.){   \n   vec2 \n        uvB = (fragCoord-.5*iResolution.xy)/iResolution.y,  // uvB\n\t\tM = iMouse.xy/iResolution.xy;\n    \n    float \n        t = T*.1,\n        dolly = (1.-sin(t)*.6),\n        zoom = mix(.3, 2., pow(sin(t*.1), 5.)*.5+.5),\n        dO = 0.;\n    \n    vec3 roB = vec3(0,2,-2)*dolly;    // roB\n    roB.yz *= Rot(M.y*5.+sin(t*.5));   // roB\n    roB.xz *= Rot(-M.x*5.+t*.1);\n    vec3 up = vec3(0,1,0);\n    up.xy *=Rot(sin(t*.2));\n    vec3 \n        rdB = GetRayDir(uvB, roB, vec3(0), up, zoom),  // rdB uvB\n        colB = Bg(rdB),                                // colB\n        dirB = sign(rdB)*.5;                           // rdB dirB\n    \n    for(float i=0.; i<MAX_BLOCKS; i++) {\n    \tvec3 pB = roB+dO*rdB;                    // roB rdB\n        \n        pB.x += T*.2;\n        vec3 \n            id = floor(pB),\n            q = fract(pB)-.5,\n            rC = (dirB-q)/rdB;\t// ray to cell boundary\n        \n        float \n            dC = min(min(rC.x, rC.y), rC.z)+.0001,\t\t// distance to cell just past boundary\n        \tn = Hash31(id);\n        \n        dO += dC;\n        \n        if(n>.01) continue;\n        \n        float \n            a1 = fract(n*67.3)*6.2832,\n            a2 = fract(n*653.2)*6.2832;\n        \n        colB += Galaxy(q*4., rdB, n*100., a1, a2,1.).rgb*S(25., 10., dO);\n    }\n    \n    vec4 galaxy = Galaxy(roB, rdB, 6., 0., 0.,0.);\n\n    float \n        alpha = pow(min(1., galaxy.a*.6),1.),\n        a = atan(uvB.x,uvB.y),\n    \tsB = sin(a*13.-T)*sin(a*7.+T)*sin(a*10.-T)*sin(a*4.+T),\n    \tdB = length(uvB);     // dB uvB\n    \n    sB *= S(.0, .3, dB);    // dB\n    colB = mix(colB, galaxy.rgb*.1, alpha*.5);   // colB\n    colB += galaxy.rgb;\n    colB += max(0., sB)*S(5.0, 0., dot(roB,roB))*.03*zoom;\n    \n    colB *= S(1., 0.5, dB);     // dB\n    \n    col +=colB ;     // BigWing color\n   }\n   ////////////////////////////////////////////////         case (5) Galaxy END\n       \n       fragColor = vec4( col,1.0) ;   // fonal (END)\n       \n \n    \n}","name":"Image","description":"","type":"image"}]}