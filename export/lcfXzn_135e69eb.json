{"ver":"0.1","info":{"id":"lcfXzn","date":"1704939013","viewed":117,"name":"tiled ray march cube","username":"soggymongoose","description":"raymarch","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Hash31(vec3 n) {\n    return fract(dot(n, vec3(352.23, 632.62, 402.62))*sin(232.5223*n.x+12.4311*n.y+34.24*n.x)*cos(n.x*43.31+n.y+n.z*235.41));\n}\n\nvec2 Rot2D(vec2 p, float theta) {\n    return vec2(p.x * cos(theta) - p.y * sin(theta),p.x * sin(theta) + p.y * cos(theta));\n}\n\nfloat CubeSDF( vec3 p, float s, vec3 pos)\n{\n    p -= pos;\n    p.xzy = vec3(Rot2D(p.xz,iTime/3.),p.y);\n    p.yzx = vec3(Rot2D(p.yz,iTime/2.),p.x);\n    p.xyz = vec3(Rot2D(p.xy,iTime/4.),p.z);\n    //p.z += .05 * sin((p.x+p.y)*8.);\n    //p.x += .05 * sin((p.z-p.y)*10.);\n    //p.y += .05 * sin((p.z+p.x)*12.);\n    \n    vec3 uv = abs(p);\n    \n    return length(max(uv-vec3(s),vec3(0.)));\n}\n\nfloat sdSphere(vec3 p, float r, vec3 pos) {    \n    return length(p-pos) - r;\n}\n\n\nfloat map(vec3 p) {\n    float map;\n    \n    vec3 pos = vec3(cos(iTime/3.),sin(iTime),cos(iTime/2.));\n    //map = sdSphere(p, 1., vec3(cos(iTime/3.),sin(iTime),cos(iTime/2.)));\n    map = CubeSDF(p,.5,pos) - .2;\n    \n    return map;\n}\n\nvec3 Calc_Norm(vec3 p) {\n    vec2 e = vec2(.001,.0);\n        \n    float dx = map(p+e.xyy) - map(p-e.xyy);\n    float dy = map(p+e.yxy) - map(p-e.yxy);\n    float dz = map(p+e.yyx) - map(p-e.yyx);\n        \n    return normalize(vec3(dx,dy,dz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t; // position along the ray \n    \n        float d = map(p); // distance from scene\n    \n        t += d * .5; // march the ray - lowering d to fix artifacts\n        \n        if ((d < .001) || (t > 100.0)) break; // break loop early\n        }\n    return t;\n}\n\nfloat Calc_occ(vec3 p, vec3 vec_dir) {\n    float check;\n    \n    vec3 offs = p + vec3(.001);\n    \n    p += Calc_Norm(p) * .005;\n    float d = rayMarch(p,-1.*vec_dir);\n    \n    if (d > 100.) {check = 1.;} else {check = 0.;}\n    \n    //check = \n    \n    return check;\n}\n\nvec3 spec(vec3 rd, vec3 nor, vec3 l_pos, vec3 l_col, float n, float k, float c) {\n    return k * pow(clamp(dot(reflect(normalize(l_pos),nor),rd),0.,1.),n) * l_col + c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    vec3 col = vec3(smoothstep(-.5,2.,uv.y));\n    \n    float d = rayMarch(ro,rd);\n    \n    if (d < 100.) {\n    vec3 p = ro + rd * d;\n    vec3 nor = Calc_Norm(p);\n    \n    // Materials\n    vec3 mat = normalize(vec3(1.,1.,1.));\n    \n    p -= vec3(cos(iTime/3.),sin(iTime),cos(iTime/2.));\n    p.xzy = vec3(Rot2D(p.xz,iTime/3.),p.y);\n    p.yzx = vec3(Rot2D(p.yz,iTime/2.),p.x);\n    p.xyz = vec3(Rot2D(p.xy,iTime/4.),p.z);\n    //p.z += .05 * sin((p.x+p.y)*8.);\n    //p.x += .05 * sin((p.z-p.y)*10.);\n    //p.y += .05 * sin((p.z+p.x)*12.);\n\n    vec3 matID = floor(p*5.);\n    vec3 matUV = fract(p*5.);\n    matUV -= .5;\n    \n    mat = vec3(1.);\n    \n    if (mod(matID.x+matID.y+matID.z,2.) == 0.) {\n        mat = vec3(.9);\n    }\n    else {\n        mat = vec3(.1);\n    }\n    //mat = vec3(Hash31(matID));\n    \n    // Lights\n    vec3 l_pos_top = vec3(0.,3.,-1.);\n    float top = clamp(dot(nor,normalize(l_pos_top)),0.,1.);\n    vec3 top_col = vec3(.5,1.,1.);\n    \n    vec3 l_pos_side = vec3(3.,-3.,-3.);\n    float side = clamp(dot(nor,normalize(l_pos_side)),0.,1.);\n    vec3 side_col = vec3(1.,1.,.2);\n    \n    vec3 l_pos_back = vec3(0.,-4.,2.);\n    float back = clamp(dot(nor,normalize(l_pos_back)),0.,1.);\n    vec3 back_col = vec3(1.,.2,.2);\n    \n    float ambi = .1;\n    vec3 ambi_col = vec3(1.,1.,1.);\n    \n    vec3 ilu = vec3(0.);\n    ilu += top * top_col * (2./length(p-l_pos_top));\n    ilu += side * side_col * (2./length(p-l_pos_side));\n    ilu += back * back_col * (2./length(p-l_pos_back));\n    ilu += ambi * ambi_col;\n    \n    // add spec (Phong)\n    ilu += (2./length(p-l_pos_side)) * spec(rd,nor,l_pos_side,side_col,32.,1.,.0);\n    ilu += (2./length(p-l_pos_top)) * spec(rd,nor,l_pos_top,top_col,32.,1.,.0);\n    ilu += (2./length(p-l_pos_back)) * spec(rd,nor,l_pos_back,back_col,32.,1.,.0);\n    \n    float fres = pow(smoothstep(1.,0.,abs(dot(rd,nor))),5.); \n    ilu += fres * ilu * .5;\n    \n    //\n\n    //\n    \n    // Time varying pixel color\n    col = ilu * mat;\n    }\n    \n    col = pow( col, vec3(1.0/2.2) ); // gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}