{"ver":"0.1","info":{"id":"sdccW4","date":"1653449025","viewed":112,"name":"30 Minutes 5/24","username":"scry","description":"https://twitter.com/Scrygl/status/1529302116694560768","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","basic","shadow","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////\n#define time iTime*0.1\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nvec3 lpos(void) {\n    vec3 l = vec3(0.,0.9,3.);\n    //l.y += sin(time);\n    \n    l.x += sin(time);\n    l.z += cos(time);\n    //l.yz *= r2d(-0.2);\n    return l;\n}\n\nvec3 opRepLim( vec3 p, float c, vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat bowl(vec3 p, vec2 s, float t) {\n    return max(max(length(p)-s.x,p.y-s.y),-(length(p)-s.x+t));\n}\n\nvec4 map(vec3 p) {\n    p.yz *= r2d(-0.2);\n    vec3 o = p;\n    p.z -= 3.;\n    p.yz *= r2d(-0.2+time);\n    vec3 op = p;\n    p = opRepLim(p,0.1,vec3(2.));\n    p.xz *= r2d(time/8.);\n    p.xz = (fract(p.xz*0.3-0.5)-0.5)/0.3;\n    p = opRepLim(p,0.3,vec3(2.));\n    float d = sdBox(p,vec3(0.03));\n    d = min(d,o.y+10.9);\n    vec3 l = lpos();\n    l = l-o+vec3(0,-0.25,0);\n    d = min(d,bowl(l,vec2(0.3,-0.2),0.01));\n    //d = min(d,length(lpos()-o-vec3(0.,0.1,0.))-0.09);\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd, float s) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<100;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*s;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 100. || dS < 0.001 ) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nfloat shadow(vec3 p, vec3 n, vec2 d) {\n    float s = 0.;\n    vec3 l = lpos();\n    vec3 rd = normalize(l-p);\n    float dx = RM(p-n*0.003,rd,1.).x;\n    if ( dx > length(l-p)) {\n        s += 1.;\n    }\n    return s;\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d) {\n    vec3 col = n.yzx;\n    col *= clamp(1.-d.x*0.01,0.,1.);\n    col -= (1.-shadow(p,n,d))*0.5;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    float c = length(uv);\n    vec3 rd = normalize(vec3(uv,1.2-c));\n    vec2 d = RM(ro,rd,1.);\n    vec3 p = ro + rd*d.x;\n    vec3 n = calcNorm(p);\n    col += colo(p,n,d);\n    //col += d.xxx/10.;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}