{"ver":"0.1","info":{"id":"ltKXDD","date":"1484494973","viewed":107,"name":"fog_effect","username":"sanctify","description":"fog_effect","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fogeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 600;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=20.5; // Minimum\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(\n        \t\tmix(\n        \t\t\t\tmix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    \tmix( hash(n+157.0), hash(n+158.0),f.x),\n                    \tf.y),\n        \n               \tmix(\n                        mix( hash(n+113.0), hash(n+114.0),f.x),\n                   \t\tmix( hash(n+270.0), hash(n+271.0),f.x)\n                        ,f.y),\n        \t0.0005);\n}\n\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.15, 0.15, 0.15), vec3(0.25, 0.25, 0.25), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.55, 0.55, 0.55);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  //t = profondeur\n  //hit = je touche ou pas\n  //rA Ã  rB = zone de la profondeur dans laquelle je travaille\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  float b = (t-rA)/(rB-rA);\n    b = b*b*b;\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n      \n    // Shade object with light\n    rgb = Shade(pos, n);\n\trgb =  mix(rgb, mix(vec3(0.15, 0.15, 0.15), vec3(0.25, 0.25, 0.25), rd.y*0.5+0.5),b);\n\n  }\n    \n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}