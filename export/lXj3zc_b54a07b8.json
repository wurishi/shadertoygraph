{"ver":"0.1","info":{"id":"lXj3zc","date":"1709109682","viewed":71,"name":"A scrolling starfield 1","username":"fdgfree","description":"A starfield with stars, clouds and parallax scrolling","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932\n#define TAU (PI * 2.0)\n#define BASE_COLOR (vec3(1.0, 1.0, 1.0))\n\nfloat random_at2(in vec2 p, float offset) {\n\tp = fract(p * vec2(abs(243.13 + offset * 2.0), abs(526.14 - offset)));\n\tp += dot(p, p + 45.32);\n\treturn fract(p.x * p.y);\n}\n\nfloat random_at(vec2 uv, float offset)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412. + offset) * 6339. - offset);\n}\n\nvec2 mod_space(in vec2 id, in float subdivisions) {\n    return mod(id, subdivisions);\n}\n\nfloat frame(in vec2 where) {\n    vec2 in_chunck_pos = fract(where) - 0.5;\n\tvec2 chunck_pos = floor(where);\n    \n    vec2 wa = smoothstep(0.48, 0.5, abs(in_chunck_pos));\n    return wa.x + wa.y;\n}\n\nfloat draw_star(in vec2 where, in float size, in float flare) {\n    float d = length(where);\n    float m = (0.01 * size) / d;\n\t\n    float ray_exp = 9000.0 / size;\n    float rays = max(0.0, 1.0 - abs(where.x * where.y * ray_exp));\n    m += rays * flare;\n    \n    m *= smoothstep(0.1 * size, 0.05 * size, d);\n    \n    return m;\n}\n\nvec3 stars_layer(in vec2 where, float subdivisions) {\n\tvec3 col = vec3(0.0);\n    \n\tvec2 in_chunck_pos = fract(where) - 0.5;\n\tvec2 chunck_pos = floor(where);\n    \n    vec3 baseColor = BASE_COLOR;\n\t\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\tvec2 offset = vec2(float(x), float(y));\n\t\t\tfloat n = random_at(mod_space(chunck_pos + offset, subdivisions), 39.392 * subdivisions);\n            \n            float size = fract(n * 3263.9);\n            size *= size;\n            float flare = smoothstep(0.8, 1.0, size);\n            float d = draw_star(in_chunck_pos - offset - vec2(n, fract(n * 41.0)), size, flare);\n            \n            vec3 randomColor = vec3(fract(n * 931.45), fract(n * 2345.2), fract(n * 231.2));\n\t\t\tvec3 color = mix(BASE_COLOR, randomColor, 0.3);\n            \n            col += color * d;\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 debris_layer(in vec2 where, in float subdivisions) {\n\tvec3 col = vec3(0.0);\n\t\n\tvec2 in_chunck_pos = fract(where) - 0.5;\n\tvec2 chunck_pos = floor(where);\n\t\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\tvec2 offset = vec2(float(x), float(y));\n            \n\t\t\tfloat n = random_at(mod_space(chunck_pos + offset, subdivisions), 23.93);\n            \n            float tt = (n + iTime * (2.0 * + n - 1.0)) * TAU * 2.0;\n            vec2 time_offset = vec2(sin(tt), cos(tt)) * 0.0025 * (0.5 + fract(n * 1450.23));\n            \n            float d = smoothstep(0.013, 0.012, length(in_chunck_pos - offset - vec2(n, fract(n * 34.0)) + time_offset));\n            \n\t\t\tvec3 randomColor = vec3(fract(n * 931.45), fract(n * 2345.2), fract(n * 231.2));\n\t\t\tvec3 color = mix(BASE_COLOR, randomColor, 0.5) * 0.3 * (sin(tt) * 0.2 + 1.1);\n            \n            col += color * d;\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 smooth_noise(in vec2 where, in float subdivisions) {\n    vec2 chunck_pos = floor(mod_space(where, subdivisions));\n    vec2 in_chunck_pos = smoothstep(0.0, 1.0, fract(where));\n    return vec3(\n        mix(\n            mix(\n                random_at(mod_space(chunck_pos, subdivisions), 0.0),\n                random_at(mod_space(chunck_pos + vec2(1.0, 0.0), subdivisions), 0.0),\n                in_chunck_pos.x\n            ),\n            mix(\n                random_at(mod_space(chunck_pos + vec2(0.0, 1.0), subdivisions), 0.0),\n                random_at(mod_space(chunck_pos + vec2(1.0, 1.0), subdivisions), 0.0),\n                in_chunck_pos.x\n            ),\n            in_chunck_pos.y\n        )\n    );\n}\n\nvec3 cloud_layer(in vec2 where, in float subdivisions) {\n    vec3 col = vec3(0.0);\n    // col += smooth_noise(where * 0.5, subdivisions);\n    col += smooth_noise(where, subdivisions);\n    col += smooth_noise(where * 2.0, subdivisions) * 0.5 * vec3(0.6, 0.6, 1.0);\n    col += smooth_noise(where * 4.0, subdivisions) * 0.25 * vec3(1.0, 0.6, 0.6);\n    col += smooth_noise(where * 8.0, subdivisions) * 0.125 * vec3(1.0, 0.8, 1.0);\n    return col * col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float zoom = 10.0;\n    const float subdivisions = 40.0;\n    \n    // fragCoord = floor(fragCoord / 4.0 + 0.5) * 4.0;\n    \n    vec2 where = zoom * ((fragCoord - iResolution.xy * 0.5) / iResolution.y - 0.5);\n    \n    vec2 speed = -((iMouse.xy - iResolution.xy * 0.5) / iResolution.y) * 2.0;\n    vec3 col = vec3(0.0);\n    \n    // col += frame((where + speed * iTime / 16.0) / 16.0) * vec3(1.0, 0.0, 0.0);\n    \n    col += cloud_layer(where + speed * iTime / 16.0, subdivisions) * 0.05 - 0.03;\n    \n    col += stars_layer(where + speed * iTime / 16.0, subdivisions / 16.0) * 0.3;\n    col += stars_layer(where + speed * iTime / 8.0, subdivisions / 8.0) * 0.6;\n    col += stars_layer(where + speed * iTime / 4.0, subdivisions / 4.0);\n    \n    col += debris_layer(where + speed * iTime, subdivisions);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}