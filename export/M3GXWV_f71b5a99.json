{"ver":"0.1","info":{"id":"M3GXWV","date":"1720493896","viewed":80,"name":"i=n^-i Fractal","username":"ozazl","description":"Interpretation of infinity.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_STEPS 28\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define PI 3.14159265359\n#define FRC_ITTER 0\n\n// Define the rotation matrix in 4D\nmat4 rotationMatrix4D(float theta, float phi) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    float cosPhi = cos(phi);\n    float sinPhi = sin(phi);\n    \n    return mat4(\n        cosTheta, -sinTheta, 0.0, 0.0,\n        sinTheta, cosTheta, 0.0, 0.0,\n        0.0, 0.0, cosPhi, -sinPhi,\n        0.0, 0.0, sinPhi, cosPhi\n    );\n}\n\n// 4D inversion\nvec4 invert4D(vec4 p) {\n    return -p;\n}\n\n// Generate a 4D fractal\nvec4 generateFractal(vec4 p, float theta, float phi, int iterations) {\n    for (int i = FRC_ITTER; i < iterations; i++) {\n        mat4 rotation = rotationMatrix4D(theta, phi);\n        p = rotation * p;\n        p = abs(p) - 0.5;\n        p = rotation * invert4D(p);\n    }\n    return p;\n}\n\n// Distance estimator for the 4D fractal\nfloat getDistance(vec3 p) {\n    vec4 p4 = vec4(p, 0.0);\n    p4 = generateFractal(p4, iTime * 0.1, iTime * 0.2, 10);\n    return length(p4.xyz);\n}\n\n// Ray marching algorithm\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 1; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        \n        vec3 lightPos = vec3(2.0 * sin(iTime), 5.0, 2.0 * cos(iTime));\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n        \n        col = vec3(diff);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}