{"ver":"0.1","info":{"id":"ctsBz4","date":"1692683579","viewed":28,"name":"bmplug","username":"iyo","description":"yakwtfgo (IQ SDFs)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nconst int MAT_OBJ = 1;\nconst int MAT_BACK = 2;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness,float bias)\n{\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nvec2 GetDist(vec3 p) {\n    p.x += 3.;\n    p.x += iTime * 2.2;\n    p.y -= sin(iTime) + 1.;\n    p.z += 1.3;\n    float a =  sin(iTime);\n    float a1 = cos(iTime);\n    float plTan = (tan(p.y) + 20.) - iTime*2.;\n    vec3 pMod = vec3(p.x + a, p.y + a1, p.z + a1);\n    vec3 pSin =  .7* sin(p) + .7;\n    float link = sdLink(pSin, .2, .7, .2);\n    float gyr = sdGyroid(pSin, .8, .4, .4);\n    float d = min(link, gyr);\n    int mat = 0;\n    \n    if(d==link)\n        mat = MAT_BACK;\n  \n  else if(d==gyr)\n       mat = MAT_OBJ;\n        \n    \n    return vec2(sin(d), mat);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    //ro.yz *= Rot(-m.y*PI+1.);\n    //ro.xz *= Rot(-m.x*TAU);\n    if(iTime < 2.5)\n    {\n    ro.yz *= Rot(2.5);\n    ro.xz *= Rot(1.6);\n    }\n    else if(iTime > 2.5)\n    {\n    ro.yz *= Rot(2.5 + (iTime - 2.5)/3.);\n    ro.xz *= Rot(1.6 + (iTime - 2.5)/3.);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        int mat = int(GetDist(p).y);\n        if (mat==MAT_BACK)\n            {\n        col = vec3(n.x*.7, n.y, n. z*(12.55205));\n        col += sin(abs(dif*dif)+1.5);\n        col -= pow(dif, -1.3);\n            }\n        else if(mat==MAT_OBJ)\n        {\n        col = vec3(n.x*.7 + sin(iTime*3.), n.y + cos(iTime*3.),  n. z*(12.55205));\n        col += sin(abs(dif*dif)+1.5);\n        col = sin(min(sin(dif*col), cos(dif*col))/-1.+1.);\n        col -= dif*dif*dif;\n\n        }\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}