{"ver":"0.1","info":{"id":"WldcDn","date":"1608943598","viewed":371,"name":"Enchanted city","username":"kastorp","description":"each block is composed of 4x4x4 voxels\nuse mouse and keys to interact...  hold Z to spray material, X to dig\nfeeel free to use the stairs","likes":32,"published":1,"flags":48,"usePreview":1,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nENCHANTED CITY - BY KASTORP \n\nthis shader is a mix of the followings:\n https://www.shadertoy.com/view/wsByWV    // starting shader\n https://www.shadertoy.com/view/tsGBWy    // 124 bit encoding /decoding;  \n https://www.shadertoy.com/view/ttdyzH    // building SDF\n https://www.shadertoy.com/view/td3cWs    // rendering optimizations and textures\n\nInspired by this article (Dennis Gustafsson is a genius):\nhttps://blog.tuxedolabs.com/2018/10/17/from-screen-space-to-voxel-space.html\n\nMain technical goals are:\n -  full usage of the 124 texel bits, \n -  increase voxel resolution by 4x\n -  generate voxel map from and SDF\n\nIt takes 25 compilation time with Angle... please wait \non windows+chrome,  this cmd to reduce compilation time to 3sec:\n\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" --use-angle=gl\n\n----------------------\nCONTROLS (same as voxel game evolution):\n    drag mouse to move view and select blocks\n    WASD or arrows to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n\n    mouse double click to select/unselect a block (doesn't work well with low framerate)\n    Q + mouse button to place block \n    E + mouse button to destroy blocks \n    Z + mouse button to spray material\n    X + mouse button to dig (or shoot?)\n\tC + mouse button to select multiple blocks (hold on \"C\" to clear selection)\n\n    I to toggle inventory (hidden, simple, full)\n    mouse click on inventory to select a block type (I\n\t\n\n\tO,P to decrease/increase speed of day/night cycles   \n    k,L to decrease/increase pixel sizes \n\tT to teleport to a random location\n    Page Up/Down to increase or decrease zoom \n\tF7 enable/disable torch light diffusion (flickering on some GPUs)\n\tF8 enable/disable water flow (requires #define FLOW)\n\nCONFIGURATION:\n\tsee #define settings in \"Common\" file \n\nCREDITS:\n\tVoxel game: @fb39ca4 https://shadertoy.com/view/MtcGDH\n\tTextures: @Reinder https://www.shadertoy.com/view/4ds3WS\n\tgrass: @W23 https://www.shadertoy.com/view/MdsGzS\n\twater reflection:@Reinder https://www.shadertoy.com/view/MdXGW2\n    128 bits encoding https://www.shadertoy.com/view/4lBfRm\n\n//-----------------------------------------------------*/\n\n\n#ifdef STATS\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n#endif\n\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawInventory(vec2 c) {\n    \n    float h= (load(_inventory).r>1.?NUM_ITEM_ROWS:1.);\n\tfloat scale = floor(iResolution.y / 192.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.y - 16. * NUM_ITEMS) / 2.;\n    c.y -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.y < NUM_ITEMS * 16. && c.y >= 0. && c.x < 16.* h ) {\n        float slot = floor(c.y / 16.) + NUM_ITEMS*floor(c.x / 16.) ;\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16.* floor(selected/NUM_ITEMS),16. * mod(selected,NUM_ITEMS)));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    //fragColor = texture(iChannel3, fragCoord);\n    \n    if(load(_inventory).r>.0){   \n   \t     vec4 gui = drawInventory(fragCoord);\n   \t    fragColor = mix(fragColor, gui, gui.a);\n    }\n    \n#ifdef STATS    \n    //DISPLAY STATS IF F3 IS TOGGGLED\n    float stats = load(_stats).r;    \n    if (stats >0.5) {\n        vec3 pos = load(_pos).xyz;\n        \n\n        //POS\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 5.0, 5.0));\n\n        //ANGLE\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y -80.), vec2(8,15),  load(_angle).x, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(50., iResolution.y -80.), vec2(8,15),  load(_angle).y, 5.0, 2.0)); \n \n        //TIME\n        fragColor = mix( fragColor, vec2(1,.5).xxxx , PrintValue(fragCoord, vec2(0., iResolution.y -100.), vec2(8,15), load(_time).r, 5.0, 2.0));\n\n\n        \n        //if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        \n        //FRAMERATE, MEMORY RANGE, HEIGHT LIMIT, RAY DISTANCE\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 105.), vec2(8,15), load(_pixelSize).r, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 85.), vec2(8,15), 1./ iTimeDelta, 5.0, 1.0));\n\n#if SURFACE_CACHE>0\n        fragColor = mix( fragColor, vec2(1,.5).yxxx, PrintValue(fragCoord, vec2(0., 65.), vec2(8,15), calcLoadDist_C( iChannelResolution[2].xy), 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 45.), vec2(8,15),  heightLimit_C, 5.0, 2.0));\n#endif\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 25.), vec2(8,15),  load(_rayDistMax).r, 5.0, 2.0));\n\n    }\n\t\n    // \"BUFFER C\" DUMP\n    if(load(_stats).g>.5) {               \n        vec3 offset = floor(vec3(load(_pos).xy, 0.));\n        vec4  color= texture(iChannel2,fragCoord / iResolution.xy);\n        fragColor = color;       \n    }\n    //\"BUFFER A\" DUMP\n\n    if(load(_stats).b>.5) fragColor= texture(iChannel0, fragCoord /iResolution.xy/3.);\n\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n//----------------------------------------------------------*/\n//  MAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n#define MAX_PICK_DISTANCE 20.\n//  FAST_NOISE: use cheaper noise function \n#define FAST_NOISE\n//\tOCCLUSION: enable voxel occlusion 1=fake, 2 = samples\n#define OCCLUSION 1\n//  SUBVOXEL: enable shapes actions with keys R,F,G\n#define SUBVOXEL\n//\tSUBTEXTURE: apply texture scaled on subvoxels (more detailed but aliased)\n//#define SUBTEXTURE\n//\tTREE_DETAIL: if enabled, tree blocks are detailed with subvoxels \n#define TREE_DETAIL\n//\tTREE SIZE: height of the trees \n#define TREE_SIZE 3.\n//  GRASS_DETAIL: enable grass\n#define GRASS_DETAIL\n//  SHADOW 0.=disabled else shadow intensity\n#define SHADOW 1.\n//  fog distance \n#define FOG 150.\n//  FALLING_SAND: sand blocks fall if unstable \n//#define FALLING_SAND\n//  MAP: map rendering\n//#define MAP\n//\tHIGHLIGHT 0.=disabled else higlight of  unconnected blocks, sand with 4+ horizontal steps, cascading diamonds connected to gold\n#define HIGHLIGHT 0.\n//\tSURFACE_CACHE:  secondary cache mode with buffer C (1=surface blocks,2=heightmap,0=disabled)\n#define SURFACE_CACHE 1 \n\n//  STATS: display debug info if F3,F4,F5 keys pressed \n//#define STATS\n\n//  XRAY_MODE: fly mode, with no collisions and transparent blocks (*)\n//#define XRAY_MODE\n// \tEXCLUDE_CACHE:view only mode, with disabled buffer B \n//#define EXCLUDE_CACHE\n\n//\tWATER_FLOW: enable water flow (value= levelling distance)\n#define WATER_FLOW 250.\n\n// torch distance 0-31\n#define LTORCH 20.\n#define SURFACE 3.\n#define LOAD_TIME 40.\n//anti-aliasing samples on texture\n#define TEXTURE 3\n#define ACTIONS\n#define MIN_PIXELSIZE 2.\n#define MAX_PIXELSIZE 3.\n// flickering light from fireflies at night\n//#define FIREFLIES\n\n//------------------------------------------------------\n\n//SHARED VARIABLES\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n#define TS vec2(textureSize(iChannel3,0))\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);//_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);//_old _pick\nvar(_pickTimer, 8, varRow);  //_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\n\nvar(_map,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\nvar(_flow,24,varRow);\nvar(_textureSize,25,varRow);\nvar(_cachePos, 26, varRow);\nvar(_freeze,27,varRow);\n//old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n//BUFFER B\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(13,7);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\n\n//BUFFER C\n#if SURFACE_CACHE==1\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(6,3);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#endif\n\n\n//INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n//INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n//\nconst float N_SUBVOXEL=4.;\n// USED BY FALLING SANDS\nconst float MAX_GROUND=45.;\n\n   \n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n#if SURFACE_CACHE>0\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n#endif \n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value; //1=modified,2=selected,3=falling\n    vec2 light;\n    float life;\n    int shape;\n    float ground;\n    int buffer;\n    uvec2 mask;\n     \n};\n\n#define BITS 32.\n#define MAXUINT  0xFFFFFFFFu \n\n\n// pixel is a 128 bit mask (0-31 -> x, 32-63 -> y, 64-95 -> z, 96-127 -> w)\nuint getBit(inout uvec4 bm, uint i)\n{\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n       \n    return  (bm[bv]  &  (1u<<bi) )>0u?1u:0u;\n}\n\n//works only if n<=32u \nuint getBits(inout uvec4 bm, uint k, uint n){\n   \n    \n    uint bv = k/uint(BITS),  bi= k%uint(BITS);\n    if(n+bi<=32u){\n        //inside vec4 dimension\n        uint m = (1u<<n)-1u; \n        return (bm[bv] & (m<<bi) )>>bi;\n    }\n    else\n    {\n        //cross dimension\n        uint n1= 32u-bi, n2 = bi+n-32u;\n        uint m1 =(1u<<n1)-1u, m2= (1u<<n2)-1u;\n        return ((bm[bv] & (m1<<bi) )>>bi) \n             + ((bm[bv+1u] & m2 )<<n1);\n    }\n}\n\n// set bit value in a 128 bit mask \nvoid setBit(inout uvec4 bm, uint i, uint val){\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    bm[bv]  &= ( MAXUINT - (1u<<bi) );\n    if(val>0u)  bm[bv]  +=(1u<<bi);\n}\n\nvoid setBits(inout uvec4 bm, uint i, uint n, uint val){\n    val =clamp( val, 0u, (1u<<n)-1u) ;\n\n    //TODO REPLACE WITH A SINGLE EXPRESSION WITHOUT CYCLING\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    if(n+bi<=32u){\n        bm[bv]  &= ( MAXUINT - (((1u<<n)-1u ) <<bi) );\n        bm[bv]  +=(val<<bi);\n    }\n    else\n    {\n        for(uint j=0u; j<n;j++) \n        {\n            uint b = (val  &  (1u<<j) )>0u?1u:0u;\n            setBit(bm, i+j, b);\n        }\n    }\n}\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    uvec4 iv =  floatBitsToUint(t);\n    o.id        = float(getBits(iv,0u,6u)); \n    o.value     = int(getBits(iv,6u,2u));   \n    o.light.s   = float(getBits(iv,8u, 4u) );\n    o.light.t   = float(getBits(iv,12u, 5u));\n    o.shape     = int(getBits(iv,17u, 4u));\n\n    \n    o.life      = float(getBits(iv,32u, 9u));  \n    o.ground    = float(getBits(iv,41u, 8u));\n \n   \n    //32 bits =  31 from floatBitsToUint(...) + 1 apart\n    setBit(iv,88u,  getBit(iv,26u));\n    setBit(iv,120u, getBit(iv,27u));\n    o.mask      = uvec2(iv.zw);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tuvec4 iv = uvec4(MAXUINT);\n    setBits(iv, 0u,6u,uint(v.id));\n    setBits(iv, 6u,2u,uint(v.value));    \n    setBits(iv,8u,4u,uint(v.light.s));\n    setBits(iv,12u,5u,uint(v.light.t));\n    setBits(iv,17u,4u,uint(v.shape));    \n    setBits(iv,32u,9u,uint(v.life)); \n    setBits(iv,41u,8u,uint(v.ground));\n\n    \n    //known bug from: https://www.shadertoy.com/view/4lBfRm\n     // bit 24 cannot be used\n     // Whatever 7 desired exponent bits are, we can avoid inf, NaN, subnormal by choosing 8th appropriately.\n     //If all 7 are 0's pick 8th bit to be 1 (avoids subnormal).\n     //If all 7 are 1's, pick 8th bit to be 0 (avoids inf/NaN). \n    \n    uvec4 vmask = uvec4(0u,0u,v.mask);\n    setBit(iv,26u,getBit(vmask,88u)); //copy unusable bit to other byte\n    setBit(iv,27u,getBit(vmask,120u)); //copy unusable bit to other byte\n    iv.zw=vmask.zw;\n    setBit(iv,24u,getBits(iv,25u,7u)==0u?1u:0u);\n    setBit(iv,56u,getBits(iv,57u,7u)==0u?1u:0u);\n    setBit(iv,88u,getBits(iv,89u,7u)==0u?1u:0u);\n    setBit(iv,120u,getBits(iv,121u,7u)==0u?1u:0u);\n    \n    return uintBitsToFloat(iv);\n}\n\nfloat lightDefault(float z){\n\treturn 15.;\n\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n   // vox.rotation=0.;\n    vox.value=0;\n    vox.shape=0;\n    vox.ground=200.;\n    //vox.surface=0.;\n\tvox.id=0.;\n    vox.light.t = 0.;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.buffer=0;\n    vox.mask=uvec2(0u);\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. || vox.id==12. ||vox.id==26.)?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\n\nfloat noise(in vec2 p) {\n\tvec2 e=vec2(1.,0.), F = floor(p), f = fract(p), k = (3. - 2.*f) * f * f;\n\treturn mix(mix(hash2(F),      hash2(F+e.xy), k.x),\n\t\t\t   mix(hash2(F+e.yx), hash2(F+e.xx), k.x), k.y);\n}\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash22(F), \t\t\t  hash22(F+vec2(1.,0.)), f.x),\n\t\tmix(hash22(F+vec2(0.,1.)), hash22(F+vec2(1.)),\tf.x), f.y);\n}\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n vec2 mmin(vec2 a, vec2 b) { if (a.x < b.x) return a; return b; }\n vec2 mmax(vec2 a, vec2 b) { if (a.x > b.x) return a; return b; }\n vec2 msmin(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x - b.x)/k, 0.0, 1.0);\n    return vec2(mix(a.x, b.x, h) - k*h*(1.0 - h), a.x<b.x? a.y: b.y );\n }\n float msmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a - b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0 - h);\n }\n\nvec2 map(vec3 c) {\n        \n    vec3 p = vec3((c.x+c.z)/sqrt(2.),c.y,(c.x-c.z)/sqrt(2.))   ;\n\n    vec3 p0 =  vec3((p.x -3.) - floor((p.x+3.) /10.)*10.,p.y,(p.z -3.) - floor((p.z+3.) /10.)*10.);; \n    p0.xz=-1.70 + abs(p0.xz +1.);\n    p0.xz= vec2(p0.x+p0.z,p0.x-p0.z)/sqrt(2.)   ;\n    p0.y= .5 + p0.y*.5 + abs( p0.y -.7)*.6; \n   \n    float cv = 1.3,ch=.6;\n    vec3 p1 =  vec3(p0.x, p0.y-cv*clamp(round((p0.y-1.) /cv), -.1,5.),p0.z); //vertical repetition\n    \n    vec3 p2 = vec3(p1.x,p1.y,p1.z-ch*clamp(round(p1.z/ch),-4.,4.)); //horizontal repetition\n    \n    float b = sdCappedCylinder(p2,vec3(.5,1.,0.),vec3(-.3,1.,0.),.2); //arcs \n    b =min(b,sdBox(p2- vec3(0.1,.7,0),vec3(.4,.3,.2))); //below arcs\n    b= min(b,sdCappedCylinder(p1,vec3(0.,1.,-3.0),vec3(0.,1.,3.0),.2)); //gallery up\n    b =min(b,sdBox(p1- vec3(0,.7,0),vec3(.2,.3,3.0))); //gallery down\n    b =min(b,sdBox(p1- vec3(-1.3,.9,0),vec3(1.02,.5,2.0))); //inside\n    \n    b= max(-b,sdBox(p0- vec3(-1.1,4.3,0.),vec3(1.5,4.3,3.))); // external building\n    \n    b= min(b, sdBox(vec3(p2.x,p.y,p2.z)- vec3(1.45,.1,0.),vec3(.05,.1,.25))); //lake border\n    b= min(b, sdBox(vec3(p2.x,p.y,p2.z)- vec3(1.45,.2,0.),vec3(.02,.45,.02))); // pole\n    b= min(b, length(vec3(p2.x,p.y,p2.z)- vec3(1.45,.65,0.)) -.06  ); //lamp\n    b= min(b,sdBox(vec3(p0.x,p1.y-.3,p0.z)- vec3(-1.45,.0,0.),vec3(2.,.1,4.))); //eaves\n    b= min(b,sdBox(vec3(p0.x,p.y,p0.z)- vec3(-1.45,.0,0.),vec3(3.,.1,5.))); //floor\n    \n    b =max(b,-sdBox(vec3(p0.x,p.y,p0.z) - vec3(-2.,4.2,0.2),vec3(.7,4.2,.9))); //stairs hole\n    b =msmin(b, sdBox(vec3(p1.x,min(p1.y,p.y),p1.z) - vec3(-1.5,+1.1+p1.z*1.,0),vec3(.15,.07,1.)),.3); //stairs \n    \n   \n    //float d=sdBox(p1- vec3(-1.3,.9,0),vec3(1.02,.7,2.0));\n    float d=sdBox(p1- vec3(-1.3,1.1,0),vec3(1.0,.7,2.0));\n    b= msmin(b,p.y,d>1.6? .25:0.); //grass\n    float m = (b>=0.05? 0.: p.y<0.? (length(p0.xz-vec2(0.))>3.  && p.y >-.1?12.:  3.): p.y<.1 ?5.: d<0. && mod(p.x,1.)<.15 && mod(p.z,1.)<.2 ? 6.: d<.05?9.: d>.9 && p.y>.55 && p.y <.75? 6.:7. );\n    \n    \n    \n    return vec2(b,m);\n}\n\n\n#define remap(c) (vec3(c.x,c.z,c.y)/11. +vec3(0,-.2,0))\nvoxel getGeneratedVoxel(vec3 c,bool detail,int frame){\n\n    \tvoxel vox=newVox(c.z);\n        vec2 m = map(remap(c));\n        vox.id = m.y;\n       \n        if(!detail && m.x>0.) vox.id=0.;\n        \n        if(detail && m.x>-.05 && m.x<.07) \n        {   int n =0;\n            \n            uvec4 iv= uvec4(0u);\n            for(int k =min(0,frame); k<64;k++){\n                vec3 px= vec3(k%4,(k>>2)%4, k>>4)/4. -vec3(.375) +c;    \n                vec2 mx = map(remap(px));\n                if(mx.x<0.){ \n                     setBit(iv,uint(k),1u);\n                     n++;\n                }\n            }\n            \n            if(n>0){\n             vox.shape=4;\n             \n             vox.mask = iv.xy;\n            }else if(n<63) vox.id=0.;\n        }\n        \n        if(vox.id==3. && hash13(c*.111)>.99) {vox.id= 10.; vox.life=4.;};\n        if(vox.id==12. && c.z>=2.) vox.shape=2;\n        \n        if(c.z<=1.) vox.id=1.;\n        return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B, \n                    sampler2D iChannel_C, \n                    int frame, \n                    vec3 resolution_B, \n                    vec3 resolution_C,\n                    vec4 range_B,\n                    vec4 range_C,\n                    vec3 offset,\n                    bool detail,\n                    int caller){\n  \n#ifdef EXCLUDE_CACHE\n    return getGeneratedVoxel(voxelCoord,true,frame); \n#else    \n    \n \n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  \n        && (caller!=2 )  //comment this line to enable persistence between cache (doesn't handle resolution change)\n       ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    } \n#if SURFACE_CACHE==1    \n     else if (  frame > 0  && inRange(voxelCoord.xy,range_C)\n               &&  voxelCoord.z >= SURFACE\n         \t\t&& voxelCoord.z <heightLimit_C +SURFACE\n               // && (caller!=1) \n              \n             ) {\n        return getCachedVoxel(voxelCoord - vec3(0.,0.,SURFACE) - offset,iChannel_C,resolution_C,BUFFER_C); \n         \n    }\n#endif  \n    return getGeneratedVoxel(voxelCoord,detail,frame);\n#endif\n}\n\n#define getCVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    if(id==2)  v= getCachedVoxel(p-offset,iChannel2,iChannelResolution[2],2); \\\n    else v= getCachedVoxel(p-offset,iChannel1,iChannelResolution[1],1);}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    bool detail = id!=3|| (float(iFrame) -load(_textureSize).z>LOAD_TIME  && load(_demo).r<1.);\\\n    v= getVoxelData(p,iChannel1,iChannel2,iFrame,iChannelResolution[1],iChannelResolution[2],range_B,range_C,offset,detail,id);} \n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SPRAY 90\n#define KEY_DIG 88\n//#define KEY_ROTATE_Z 70\n//#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n//#define KEY_DUMP1 115\n//#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_FLOW 119\n#define KEY_TELEPORT 84\n#define KEY_MAP 77\n#define KEY_INVENTORY 73\n\n\n//ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n/*\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[1],BUFFER_B);\n}*/\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    return isSolidVoxel(t) * (!slope || t.shape!=4?1.:0.);\n    \n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y / 192.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.y - 16. * NUM_ITEMS) / 2.;\n    c.y -= xStart;\n    if (c.y <NUM_ITEMS * 16. && c.y >= 0. && c.x < 16.*h) {\n        float slot = floor(c.y / 16.) + NUM_ITEMS*floor(c.x / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\n/*\nbool mouseDoubleClick(){\n    \n    if(iMouse.z <1. ) {\n   \n        int changeCount=0;\n        for(int i=0;i<20;i++){\n\n            int mouseChange=          \n               (load(_old *vec2(i) + _mouse ).z>0.?0:1)\n              +(load( _old * vec2(i+1) +_mouse ).z>0.?0:1);\n\n\n            if(mouseChange==1)changeCount++;\n            if(load(_mouseBusy).r>0.) {store1(_mouseBusy,float(1.));return false;}\n                               \n            if(changeCount>2){\n                //if(load(_time).r - load(_old*vec2(i) +_time).r<1.) return false;\n                if(length(load(_mouse).xy -load(_old * vec2(i+1) +_mouse).xy)>.05) return false;\n                store1(_mouseBusy,float(1.));\n                return true;\n\n            }         \n        }\n    }\n    store1(_mouseBusy,float(0.));\n    return false; \n}\n*/\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; //texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (32./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 127./255.) *br;        \n    }\n    if (id == 2) { //DIRT\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 4) { //GRASS UP\n   \t\t\n        o.rgb = vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 5) { //ROCK\n       \n        o.rgb = vec3( 106./255., 170./255.,  64./255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n \n    }\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        /*float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);*/\n        o.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n        o.rgb*=.8;\n    }\n    if (id == 7) { //BRICK\n        o.rgb = vec3( 1.)*br; \n       \n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\t\n            o.rgb = o.rgb * br ;//* vec3(1.,1.,.9);\n\t\t}\n        \n    \t//o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { //WOOD\n        \n         o.rgb= vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {//TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103./255., 82./255.,  49./255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {//LEAF\n\t        o.rgb=  vec3(  40./255., 117./255.,  38./255.)*br;\t\t\n\t}\n    if (id == 12) {//WATER\t\t\n        o.rgb=vec3(  64./255.,  64./255., 255./255.)*br;\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\t//getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\t\n    if (id == 14) {//RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t//o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n       // if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 16) { //BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127./255., 127./255., 127./255.) *br;   \n    }\n    if (id == 17) {//DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) / 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 28) {//\t\n        o.rgb= vec3(0.74, 0.67, 0.64)*br;\n              \n\t}   \n    if (id == 20) {//\tROOF\n        o.rgb= vec3(0.94, 0.1, 0.1)*br;\n       \n\t} \n \n\n    if (id == 32) { //DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}\n\n/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<16 y<512: previous values fo variables and keys\nx<= 128 && 16<=y< 140 : textures \n\n\n*///-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<32.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,100.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n\t\t\t\tfloat map=load(_map).r;;\n                float freeze = load(_freeze).r;\n\t\t\t\tvec3 texSize=load(_textureSize).xyz;\n                    \n                if (iFrame <2  ) {\n#ifdef FAST_NOISE  \n                    pos = vec3(2952.8,10140.8,89.);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(-0.6,1.8  );                   \n#else\n                    pos = vec3(3265.5,9654.5,50.);                   \n                    angle = vec2(-2.,1.6  );\n#endif                    \n                    demo=1.;\n                    freeze=0.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;\n                    time = vec2(500.,6.);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=400.;\n                    map=1.;\n                    pixelSize=2.;\n                    texSize=vec3( TS, 0.);\n                }\n                \n                if(float(iFrame)-texSize.z >LOAD_TIME*.75 && float(iFrame)-texSize.z <LOAD_TIME*.75)  pixelSize=max(MAX_PIXELSIZE-1.,2.);\n                \n                if(float(iFrame)-texSize.z >LOAD_TIME && float(iFrame)-texSize.z <LOAD_TIME )  pixelSize=(TS.x<1025.?1.: MIN_PIXELSIZE);\n\n\n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. || iMouse.z>0. ))\n                {\n                    inventory=2.;\n                    selected=13.;\n                    map=1.;\n                    demo=0.;\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                    if(hash(iTime) <.5) pos=vec3(3221.5,10159.5,70.);\n                    else pos =vec3(hash33(pos).xy *10000.,72.); \n                       \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;                  \n                    selected = 0.;\n                    \n                }\n                \n                if(texSize.x != TS.x  ||  bool(keyDown(KEY_TELEPORT))) {\n                    texSize=vec3( TS, float(iFrame));\n                    pixelSize=max((TS.x<1025.?2.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n                if (oldMouse.z > 0. && iMouse.z > 0. && map<1.5)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n                //DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n                        bool slope=j<2;\n                        solidL[i ] += isSolidVoxel(slope,hColPos - offset + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(   bool(keyToggled(KEY_STATS))?1.:0.,0.,0.);\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                float flow = bool(keyToggled(KEY_FLOW))?1.:0.;\n                \n                map = mod( map +keyPress(KEY_MAP),3.);\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n        \n\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        //voxel t;\n                        //getCVoxel(pos -offset,t,0);\n                        //bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getMouseRay();\n                /*\n                bool dblClk =mouseDoubleClick();\n                if(dblClk){\n                    if (mousePointer.hit ) {\n                        \n                            pick.xyz = mousePointer.mapPos;\n                            pick.a = 7.;\n                  }                \n                }\n                */\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        /*else if (dblClk || bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += mousePointer.normal;                         \n                        }*/\n                        if (bool(keyDown(KEY_SPRAY))) {\n                            pick.a = 3.;\n                            pick.xyz -= mousePointer.normal*.125;\n                        }\n                        if (bool(keyDown(KEY_DIG))) {\n                            pick.a = 4.;\n                            pick.xyz += mousePointer.normal*.125;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        //pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    // NO MOUSE KEY PRESSED  \n                    //pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;                   \n                        }else timer = 0.;\n                }\n\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1. ;\n                if(freeze>.0) still= keyDown(KEY_PLACE)<.5 ;\n                \n                if(!still){\n                    texSize.z=max(texSize.z,float(iFrame)-LOAD_TIME*.8);\n                    pixelSize=max((TS.x<1025.?2.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n                vec3 cachePos =pos;\n                if(float(iFrame)-texSize.z > LOAD_TIME && freeze>0.){               \t\n                    cachePos = load(_cachePos).xyz;\n                    \n                } \n                if(abs(float(iFrame)-texSize.z - LOAD_TIME)<2. && freeze>0.){\n                    vel=vec3(0.);\n                }\n                \n                store3(_pos, pos);\n                store2(_angle, angle);\n                 store3(_cachePos, cachePos);\n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n#if SURFACE_CACHE>0\n                store4(_loadRange_C,calcLoadRange_C(pos.xy,iChannelResolution[1].xy,0.));\n#endif\n                store4(_mouse, mouse);\n                //store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n\n                store1(_map,map);\n                store1(_pixelSize,pixelSize);\n                store1(_inventory,inventory);\n                store1(_demo,demo);\n                store1(_torch,torch);\n                store1(_flow,flow);\n                store1(_freeze,freeze);\n                store3(_textureSize,texSize);               \n\n\n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n    }\n    else setTexture(fragColor,fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.|| vox.shape==4 ? 2.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.|| vox.id==12.?1.:(vox.id==11. || vox.shape==4 )? 2.:15.)); \n    \t\n    }        \n}\n\n//VOXEL MEMORY 1 - NEAR BLOCKS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#else\n   \n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {discard;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n\n    if (voxelCoord == floor(pick.xyz) || vox.value==2 )  {\n        if(vox.value==0)vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. && load(_pickTimer).r > 1.) \n        {vox.value=1; \n                vox.id = 0.; \n                vox.shape=0;  \n         \t\tvox.light.t=0.;\n         \t\tvox.life=0.;\n         \t\tvox.ground=0.;\n        }\n        else if (pick.a == 2.) \n        {\n            vox.id = getInventory(load(_selectedInventory).r);\n            if(vox.id==10.) vox.life=3.;\n            else if (vox.id==12.)vox.life=64.;\n            else vox.life=0.;               \n            vox.value=1;\n            vox.shape=0;\n        } \n        //else if (pick.a == 3. && vox.id != 10. && vox.id != 11. && vox.id != 12.)   { if(vox.shape<7) vox.shape++; else vox.shape=0;}\n        //else  if (pick.a == 4. && vox.id != 10. && vox.id != 11. && vox.id != 12.)   {if(vox.rotation<3.) vox.rotation++; else vox.rotation=0.;}\n        //else if (pick.a == 5. && vox.id != 10. && vox.id != 11. && vox.id != 12.)        { if(vox.rotation<12.) vox.rotation+=4.; else vox.rotation= mod(vox.rotation , 4.);}     \n    } \n    \n    if( pick.a == 3. && length(voxelCoord +.5 - pick.xyz)<2.  ) \n     {        \n         int n=0;\n         uvec4 iv= vox.shape==4?uvec4(vox.mask,0u,0u):vox.id!=0.?uvec4(MAXUINT):uvec4(0u);\n         for(int k =min(0,iFrame); k<64;k++){\n            vec3 px= voxelCoord+ vec3(k%4,(k>>2)%4, k>>4)/4. +vec3(.125);    \n            if(length(px- pick.xyz )<.45){ \n                 setBit(iv,uint(k),1u); n++;               \n            }\n         }\n         if(n>0) {  \n             vox.value=1;\n             vox.shape=4;\n             vox.mask = iv.xy;\n             if(vox.id==0.) vox.id = getInventory(load(_selectedInventory).r);\n         }\n     }\n    if( pick.a == 4. && length(voxelCoord +.5 - pick.xyz)<2.  && vox.id!=0.) \n     {        \n         int n=0;\n         uvec4 iv= vox.shape==4?uvec4(vox.mask,0u,0u):uvec4(MAXUINT);\n         for(int k =min(0,iFrame); k<64;k++){\n            vec3 px= voxelCoord+ vec3(k%4,(k>>2)%4, k>>4)/4. +vec3(.125);    \n            if(length(px- pick.xyz )<.45){ \n                 setBit(iv,uint(k),0u); n++;               \n            }\n         }\n         if(n>0) {  \n             vox.value=1;\n             vox.shape=4;\n             vox.mask = iv.xy;\n              if(vox.mask==uvec2(0u))\n             {\n                 vox.id=0.;\n                 vox.shape=0;\n             }\n         }\n\n     }    \n     if(voxelCoord == floor(pick.xyz)  &&  pick.a == 6. ) \n     {vox.value= 2 ;}\n    \n    if(voxelCoord == floor(pick.xyz)  &&  pick.a == 7. ) \n     {\n        if(vox.value==2) vox.value=1;\n         else vox.value=2;          \n     }\n    if(load(_pickTimer).r >1. && pick.a == 6. && vox.value==2)\n     {vox.value= 1 ;}\n\n   \t// SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=LTORCH;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,LTORCH);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n        \n        \n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    float g=MAX_GROUND;\n    \n    voxel next[9];\n    for(int j=0;j<=2;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n#ifdef WATER_FLOW            \n            // lateral voxels, random direction\n            if(j==2) {\n                int k= int(hash(iTime)*4.);// iFrame%4;\n            \tn = vec3(   (1- k/2) * (-1 +(k%2)*2), (k/2)* (-1 +(k%2)*2)  ,1-i);;\n            }\n#endif            \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n            \n            if(j!=2){\n                if(voxelCoord.z> 80.) {vox.light.s=15.;vox.light.t=0.;}\n                else  lightDiffusion(vox,temp,n);\n\n                //ELECTRICITY DIFFUSION\n                if(vox.id==17.){\n                    if(temp.id==8.) iE=10.;\n                    if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n                }\n                //GROUND DISTANCE\n                if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n                    if(voxelCoord.z <=1.) g=1.;\n                    if(temp.id!=0. && temp.id!=12. &&vox.id!=26. && temp.ground>0. )  g=min(g, temp.ground+(i+3*j==5?0.:vox.id==13.?10.:1.)); \n                }\n\n               if(temp.id==0.) air += pow(2., float(j*3+i));\n\n                //LEAFS:\n               if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }  \n            }\n        }\n    }\n      \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n    \n    //GROUND CONNECTION: blocks not connected to the ground or sand with 4+ horizontal steps\n    if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n        vox.ground=clamp(min(vox.ground+2.,g),0.,MAX_GROUND);\n                \n        //FALLING BLOCK\n#ifdef FALLING_SAND\n        if(vox.ground>=MAX_GROUND \n           && length(pos.xy-voxelCoord.xy)<load(_loadDistLimit).r -5.\n           &&  (next[5].id==0.|| next[5].id==12.)) vox.value=3;\n#endif        \n    }\n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n    if(next[5].id==0.  &&  vox.id==10.) {vox.id=0.; vox.shape=0; vox.value=0;}\n\n#ifdef WATER_FLOW\n    if(load(_flow).r>0.5) {\n    if(vox.id==0.) vox.life=0.;           \n    if(vox.id==12. || vox.id==0.){\n    \t\n        float w= vox.id==12.?vox.life:0.;\n        float w_new=w;\n        \n        float w_U  = next[2].id==12.?next[2].life:0.;//(next[2].id==0.? 0.:-1.);\n        float w_D  = next[5].id==12.?next[5].life:(next[5].id==0.? 0.:-1.);\n        float w_LU = next[6].id==12.?next[6].life:(next[6].id==0.? 0.:-1.);\n        float w_L  = next[7].id==12.?next[7].life:(next[7].id==0.? 0.:-1.);\n        float w_LD = next[8].id==12.?next[8].life:(next[8].id==0.? 0.:-1.);\n\n               \n        float OW=.0;\n        float FL=.9; // lateral flow\n        //TRANSITIONS \n     \t//porting from https://www.shadertoy.com/view/WdjBDV\n\t\t\n        \n        //RULE 1 OUT          \n        if( w>0. && w_D < WATER_FLOW && w_D>-1.) { w_new =max(0.,w +w_D -WATER_FLOW   ); }       \n        //RULE 1 IN    \n         if( w_U>0. && w<WATER_FLOW ) {w_new=min(WATER_FLOW, w + w_U);}\n\n            \n         // RULE2_OUT \n        if(w>0. && (w_LD>= WATER_FLOW*OW || w_D<0.) && (w_L < w -2. ) && w_L>=0. && w_LU <1. )\n        {w_new= w -floor(w-w_L)*FL;}\n\n        //RULE2 IN        \n        if( ( w_L >0. ) && (w_LD>=WATER_FLOW*(1.-OW*2.) || w_LD<0.) && (w<w_L-2.) && (w_U <1.))\n        {w_new  =  w + floor((w_L-w)*FL );}  \n\n\n        //INFINITE SOURCE\n        if(next[7].id==15. || next[5].id==15. || next[2].id==15. ){ w_new  =  WATER_FLOW; }\n        \n        \n    \tif(w_new >0. && vox.value==0) {vox.id=12.; vox.life= clamp(w_new,0.,WATER_FLOW);}\n    \tif(w_new <.1 &&  vox.value==0){vox.id=0.;vox.life= 0.;}\n        if( vox.value==1) {vox.value=0;}\n#ifdef SUBVOXEL\n        //surface water is half block\n        if( next[2].id!=12. && vox.id==12.){\n            if(vox.life < WATER_FLOW*.3) vox.shape=2;\n            else vox.shape=3;\n             \n        }\n        else  vox.shape=0;\n    \n#endif\n        \n    }\n\t}\n#endif\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n#ifdef FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_B - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n        } \n#endif\n    \n\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nVOXEL MEMORY 2 - SURFACE \n  mode = 1 it's just a copy of buffer B, working in a limited z range\n*/\nvoid  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.|| vox.id==12.?1.:vox.id==11.? 5.:LTORCH)); \n    \t\n    }        \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#endif\n    \n#if SURFACE_CACHE==0\n    discard;\n#elif SURFACE_CACHE==1\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    voxelCoord.z+=SURFACE;\n\t//vec4 newrange_B = calcLoadRange_B(offset.xy,iChannelResolution[1].xy,1.);\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n    //if (inRange(voxelCoord.xy,newrange_B)  ||    \n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;       \n    }\n\n    voxel vox;    \n    getVoxel( voxelCoord,vox,2);\n\n//---\n   \t// SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=LTORCH;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,LTORCH);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n        \n        \n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    float g=MAX_GROUND;\n    \n    voxel next[9];\n    for(int j=0;j<=2;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n#ifdef WATER_FLOW            \n            // lateral voxels, random direction\n            if(j==2) {\n                int k= int(hash(iTime)*4.);// iFrame%4;\n            \tn = vec3(   (1- k/2) * (-1 +(k%2)*2), (k/2)* (-1 +(k%2)*2)  ,1-i);;\n            }\n#endif            \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,3 );           \n    \t\tnext[i+3*j]= temp;\n            \n            if(j!=2){\n                if(voxelCoord.z> 80.) {vox.light.s=15.;vox.light.t=0.;}\n                else  lightDiffusion(vox,temp,n);\n\n                //ELECTRICITY DIFFUSION\n                if(vox.id==17.){\n                    if(temp.id==8.) iE=10.;\n                    if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n                }\n                //GROUND DISTANCE\n                if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n                    if(voxelCoord.z <=1.) g=1.;\n                    if(temp.id!=0. && temp.id!=12. &&vox.id!=26. && temp.ground>0. )  g=min(g, temp.ground+(i+3*j==5?0.:vox.id==13.?10.:1.)); \n                }\n\n               if(temp.id==0.) air += pow(2., float(j*3+i));\n\n                //LEAFS:\n               if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }  \n            }\n        }\n    }\n      \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n    \n    //GROUND CONNECTION: blocks not connected to the ground or sand with 4+ horizontal steps\n    if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n        vox.ground=clamp(min(vox.ground+2.,g),0.,MAX_GROUND);\n                \n        //FALLING BLOCK\n#ifdef FALLING_SAND\n        if(vox.ground>=MAX_GROUND \n           && length(pos.xy-voxelCoord.xy)<load(_loadDistLimit).r -5.\n           &&  (next[5].id==0.|| next[5].id==12.)) vox.value=3;\n#endif        \n    }\n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n    if(next[5].id==0.  &&  vox.id==10.) {vox.id=0.; vox.shape=0; vox.value=0;}\n\n#ifdef WATER_FLOW\n    if(load(_flow).r>0.5) {\n    if(vox.id==0.) vox.life=0.;           \n    if(vox.id==12. || vox.id==0.){\n    \t\n        float w= vox.id==12.?vox.life:0.;\n        float w_new=w;\n        \n        float w_U  = next[2].id==12.?next[2].life:0.;//(next[2].id==0.? 0.:-1.);\n        float w_D  = next[5].id==12.?next[5].life:(next[5].id==0.? 0.:-1.);\n        float w_LU = next[6].id==12.?next[6].life:(next[6].id==0.? 0.:-1.);\n        float w_L  = next[7].id==12.?next[7].life:(next[7].id==0.? 0.:-1.);\n        float w_LD = next[8].id==12.?next[8].life:(next[8].id==0.? 0.:-1.);\n\n               \n        float OW=.0;\n        float FL=.9; // lateral flow\n        //TRANSITIONS \n     \t//porting from https://www.shadertoy.com/view/WdjBDV\n\t\t\n        \n        //RULE 1 OUT          \n        if( w>0. && w_D < WATER_FLOW && w_D>-1.) { w_new =max(0.,w +w_D -WATER_FLOW   ); }       \n        //RULE 1 IN    \n         if( w_U>0. && w<WATER_FLOW ) {w_new=min(WATER_FLOW, w + w_U);}\n\n            \n         // RULE2_OUT \n        if(w>0. && (w_LD>= WATER_FLOW*OW || w_D<0.) && (w_L < w -2. ) && w_L>=0. && w_LU <1. )\n        {w_new= w -floor(w-w_L)*FL;}\n\n        //RULE2 IN        \n        if( ( w_L >0. ) && (w_LD>=WATER_FLOW*(1.-OW*2.) || w_LD<0.) && (w<w_L-2.) && (w_U <1.))\n        {w_new  =  w + floor((w_L-w)*FL );}  \n\n\n        //INFINITE SOURCE\n        if(next[7].id==15. || next[5].id==15. || next[2].id==15. ){ w_new  =  WATER_FLOW; }\n        \n        \n    \tif(w_new >0. && vox.value==0) {vox.id=12.; vox.life= clamp(w_new,0.,WATER_FLOW);}\n    \tif(w_new <.1 &&  vox.value==0){vox.id=0.;vox.life= 0.;}\n        if( vox.value==1) {vox.value=0;}\n#ifdef SUBVOXEL\n        //surface water is half block\n        if( next[2].id!=12. && vox.id==12.){\n            if(vox.life < WATER_FLOW*.3) vox.shape=2;\n            else vox.shape=3;\n             \n        }\n        else  vox.shape=0;\n    \n#endif\n        \n    }\n\t}\n#endif\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n#ifdef FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_B - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n        } \n#endif\n    \n\n\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    float ll=lightLevelCurve(load(_time).r);\n    return clamp( mix(vec3(0), \n                  mix(vec3(0.11, 0.11, 0.21),vec3(1.), ll ),pow(.8,  light.s)) \n                + mix(vec3(0), vec3(1., .9, .5), pow(.75, (.8+ll*.4)* (light.t)*15./LTORCH)\n            ),0., 1.);   \n\n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox) {\n#if OCCLUSION!=1\n    return vec3(vox.light , .75);\n#else \n \t//tangents:\n    vec3 s = vec3(step(.1,abs(n.y)), 1.- step( .1, abs(n.y)) ,0.                  );\n    vec3 t = vec3(step(.1,abs(n.z)), 0.                   ,1.- step(.1,abs(n.z)  ));\n    \n   //neightbours vector\n   //v[0],v[1],v[2]\n   //v[3],v[4],v[5]\n   //v[6],v[7],v[8]\n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) {            \n             getVoxel(r +n + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,3 );                     \t\n        }\n    }\n    vec2 lightm=vox.light;\n\n\n \tvec2 light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =max24(v[ids.x].light, v[ids.y].light, v[ids.z].light, v[ids.w].light);\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n   // if(opaque(v[4].id)>0.) lightm= v[4].light ;\n   \n\n        float aom, ao[4];\n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(opaque(v[ids.x].id), opaque(v[ids.y].id), opaque(v[ids.z].id));\n    }\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n   if(opaque(v[4].id)>0.) {aom*=0.75;} \n   aom  *= .8+ n.z*.2;\n    \n     \n    return vec3(lightm , aom);\n#endif    \n\n    \n}\n\n// RENDERING\n#define FISHEYE 0.\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n    float fish = 1.0 - dot(uv, uv) * FISHEYE;\n\treturn normalize(cameraDir*fish + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    bool grass;\n    bool mirror;\n    vec3 color;\n    float fresnel;\n    uint k;\n\n};\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n\n//GRASS ADAPTED FROM POLYANKA by W23\n//https://www.shadertoy.com/view/MdsGzS\n#ifdef GRASS_DETAIL\nconst int c_grassmarch_steps = 48;\nconst float c_gscale = 37.;\nconst float c_gheight = 0.4;\n//const float c_rgslope = 2. / (c_gscale * c_gheight);\n\n\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime)/100. - 0.005;\n}\n\nfloat grass_height(in vec3 p,float gheight) {\n\tfloat base_h= 0.15;\n\tfloat depth = 1. - (base_h - p.z) / gheight;\n\tvec2 gpos = (p.xy  + depth * wind_displacement(p.xy));\n\treturn base_h - noise(gpos * c_gscale) * gheight;\n}\n\n\nstruct xs_t {\n    bool hit;\n\tvec3 pos; \n\tfloat occlusion;\n    float dist;\n};\n\n\nxs_t trace_grass(vec3 o, vec3 d,vec3 mapPos,float gheight) {\n    bool hit=false;\n\tfloat L = .005;\n    //float Lmax= 1.8;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n\t\tfloat h = grass_height(pos +mod(mapPos,10.),gheight);\n\t\tfloat dh = pos.z - h;\n        if (dh < .005) {hit=true; break;}\n\t\tL += dh * 2. / (c_gscale * gheight);\n        vec3  dist = abs(pos-.5);\n        //if (L > Lmax) break;\n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion = 1. - 2.*(0. - pos.z) / gheight;\n\treturn xs_t(hit, pos + mod(mapPos,99.),  (hit)?1.:min(1.,occlusion),L);\n}\n\nvec3 shade_grass(in xs_t xs) {\n    \n\tvec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 = vec3( 106./255., 170./255.,  64./255.);\n\tvec3 col2 = vec3(.7, .73, .3)*.3;\n\tvec3 col3 = vec3(1., 1., .1);\n\tvec3 col4 = vec3(1., .4, .7);\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) *.8;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\t\n#endif\n//-----------------------------\n//water reflection: https://www.shadertoy.com/view/MdXGW2\n#define BUMPFACTOR 0.3\n#define EPSILON 0.1\n\nfloat waterHeightMap( vec2 pos ) {\n    return 0.9+.1*snoise( pos/2. +iTime/3.);\n}\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    //float a = clamp(1.0-dot(n,-d), 0.0, 1.0);   \n   // return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n    return pow( clamp( 1.0 + dot(d,n), 0.0, 1.0 ), 5.0 );\n}\n//------------------------*/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed,uvec2 mask){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI/2.*(floor(rotation/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n        \n        \n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n\n        if(shape==2){//STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.,2.,1.) )<.001) {res.hit=true; break;}\n         \n        }else if(shape==3){//STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.,2.,2.) )<.001) {res.hit=true; break;}           \n        }\n        else if(shape==4){\n        \n            uvec3 up= uvec3(pos);\n            uint k = up.x +(up.y<<2)+ (up.z<<4 );\n            \n            uvec4 iv = uvec4(mask,0u,0u);\n            bool on = getBit(iv,uint(k))>0u;\n            if(on && sdBox( pos-vec3(1.5)  ,vec3(2.) )<.001 ) {res.hit=true;res.k=k;break;}\n\n        }\n        \n#ifdef TREE_DETAIL        \n        else if(shape==8){//TREE W LEAFS\n            \n            float rand=hash13(floor(pos*3.1)+seed+.5 );\n            if( sdBox( pos-vec3(1.5)  ,vec3(2.) )<.001 && rand  >.9){\n                res.hit=true; res.vox.id= rand >.99?14.:11.;\n                break;\n             }\n    \n            //\n        }else if(shape==9){//TRUNK\n\t\t\tvec3 p=pos-vec3(2.,2.,2.);\n            //p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);\n            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}\n         \n        }\n#endif        \n\t}\n\t\n\t\n    if(res.hit){\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz \n        //relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n#endif\n\n\n\nvec3 skyColor(vec3 rayDir,bool showsun) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    if(!showsun) {sunVis=0.;moonVis=0.;}\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    res.fresnel=0.;\n    res.mirror=false;\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    //vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getVoxel( mapPos,currentVoxel,3);\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n     \n    \n    for (int i = 0; i < 1000; i++) {\n\n        \n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        fog+=1.;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,3 );\n        \n        //if(vox.ground<100.) vox.id=8.;    \n            \n     \n            \n        //GRASS\n#ifdef  GRASS_DETAIL      \n        if(vox.id==0. && vox.life>0. && rayType==1 ){\n\t\t\tvec4 vd =VoxelHitPos(mapPos,rayPos,rayDir);\n            res.rayPos= vd.xyz;\n            res.dist=vd.a;\n    \t\tvec3 relativePos = res.rayPos -mapPos;\n            \n            float grass = c_gheight*vox.life;\n           \txs_t xs = trace_grass(relativePos,rayDir,mapPos,grass);\n            \n            if (xs.hit ) {\n                \n                //color = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n            \tres.hit = true;                \n                res.vox=vox;\n                res.grass=true;\n                res.color=shade_grass(xs);\n                res.mapPos = mapPos;\n                res.water =waterDist;\n                res.normal = vec3(0,0,1);\n                res.dist+=  xs.dist ;\n    \t\t\tres.rayPos += rayDir * xs.dist ;\n                return res;\n            } \n\t\n        }\n#endif        \n       \n#ifdef SUBVOXEL        \n        if(vox.shape!=0 && vox.id!=0. ){ \n            //SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= 0.;//vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos,vox.mask);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit && rayType!=3) { \n            \t//nothing to do\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n#endif        \n        if(vox.id==14. &&rayType!=3){ //&& length(rayPos-mapPos -vec3(0.,0.,1.))<=6.){\n            //MIRROR \n                \n            vec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            rayDir*= (vec3(1.) - 2.* mask); \t\t\t\t\n            rayDir=normalize(rayDir);rayInv=1./rayDir;raySign= sign(rayDir);\n\n            sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n            vox.id=0.;\n            res.mirror=true;\n            rayPos=endRayPos;\n            continue;\n        }\n        if(vox.id==12.  ){ //vox.life < WATER && vox.life>0.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                // deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n\n                if(abs(n.z)>0.) {\n                    vec2 coord = hitWater.xy;\n                    vec2 dx = vec2( EPSILON, 0. );\n                    vec2 dy = vec2( 0., EPSILON );\n                    float bumpfactor = BUMPFACTOR ;//* (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\n                    vec3 normal = vec3( 0., 0., 1. );\n                    normal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n                    normal.y = -bumpfactor * (waterHeightMap(coord + dy) - waterHeightMap(coord-dy) ) / (2. * EPSILON);\n                    normal = normalize( normal );\n                   \n                    vec3 rayDirOld=rayDir;\n                    \n                    res.fresnel=fresnelR(rayDir, normal);\n    \t\t\t\t\n                    \n                    rayDir = refract( rayDir, normal ,0.7);\n                    if(res.fresnel>.005){\n                        rayDir = reflect( rayDirOld, normal );\n                        hitWater=vec3(0.,0.,-1.);\n                    }\n                }else if(abs(n.x)>0.) rayDir.yz*=(0.7+.4*noise(endRayPos.yz+iTime));\n                else  rayDir.xz*=(0.7+.4*noise(endRayPos.xz+iTime));\n                rayDir=normalize(rayDir);rayInv=1./rayDir;raySign=sign(rayDir);\n\n                rayPos=endRayPos;\n                sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n                               \n            }\n            subRes.hit=false;\n            //vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n\n        \n        //NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);res.fresnel=.001;}\n        \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n           \n            \n        \n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    if(hitWater.z<0.)  waterDist =0.;   //reflection\n    \n#if SURFACE_CACHE==1    \n    if(load(_stats).r>0.5){      \n        vec4 range_C1= calcLoadRange_C(rayPos.xy,iResolution.xy,1.);       \n        vec4 range_C0= load(_old +_loadRange_C );\n        if(res.hit && inRange(mapPos.xy, range_C0)  && !inRange(mapPos.xy, range_C1)) vox.id = 17.;    \n    }\n#endif\n\n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>SURFACE) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    \n    res.vox=vox;\n    res.water =waterDist;\n\n    \n    if(subRes.hit ){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        if(res.water==0.) res.dist = length(rayPos - res.rayPos);\n        res.k=subRes.k;\n#ifdef SUBTEXTURE\n        // uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t//return res;\n#endif\n    }\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit && !res.grass){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n\n#ifdef TEXTURE\n#if TEXTURE>1        \n        vec3 col=vec3(0.);\n        for(int i= min(iFrame,0);i<TEXTURE;i++) {\n            float d = min(.007 * res.dist,1.);           \n            vec2 uv = clamp(uv_txt + d* (hash33(res.rayPos*3.22 +float(i)*1.).xy-.5),0.01,.99);\n    \t\tcol += getTexture(textureId, uv).rgb;\n        }\n        res.color=col/float(TEXTURE);\n#else\n        res.color = getTexture(textureId, uv_txt).rgb;\n#endif \n#else        \n        res.color = getTexture(textureId, vec2(0.)).rgb;\n#endif        \n        \n    } \n    if(!res.hit){   \t\n         res.color = skyColor(rayDir,true);\n    ;\n    }\n    return res;\n}\n\n\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n#define NB_AO 12// Reduce if slow\n\n#if OCCLUSION==2\nvec3 randomHemisphereDirection(vec3 n,  vec3 seed) {\n    vec2 r = PI*(.5+.25* noise2(vec2(seed.xy*298.23 +seed.z*123.32))).xy;\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat calcAmbientOcclusion( vec3 ro,  vec3 n, float dMax, int maxRayDist,vec4 range_C) {\n    float val, ao = 0.;\n    vec3 n2, rd,seed=ro;\n    rayCastResults  res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .22323;\n               \n        res=rayCast(ro, rd,maxRayDist,range_C,3);\n        if (res.hit && res.dist< dMax) {\n            ao += clamp((dMax-res.dist)/dMax,0.,1.);\n        }\n    }\n    return (ao/float(NB_AO));\n}\n#endif\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec3 old_offset = floor(vec3(load(_old+_cachePos).xy, 0.));\n#if SURFACE_CACHE==1     \n   vec4 range_C= calcLoadRange_C(old_offset.xy,iChannelResolution[2].xy,0.);\n#else\n    vec4 range_C= calcLoadRange_B(old_offset.xy,iChannelResolution[1].xy,0.);\n#endif\n    //vec4 range_C = load(_old+_loadRange_C);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_C,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.01;\n        rd=sunDir;\n        maxRayDist=  inRange(rays[i].rayPos.xy, range_C) ? 75:5;\n        rt=3;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    vec3 wcolor= vec3(.03,.2,.4) //vec3(.03,.1,.60)\n        * lightmap( vec2(res.vox.light.s,res.vox.light.t)   );\n    \n    if (res.hit) {\n        \n\t\t\t\n        float shadow =mix(rays[1].hit  ?SHADOW:0.  ,SHADOW, 1.- pow(abs(dot(sunDir,vec3(0.,0.,1.))),.3)) ;\n\n        color=res.color;\n\n\n        if(rayType==1 ){\n         \n            if(res.grass) {              \n            \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );                 \n            }else{\n               #if OCCLUSION==2\n\n                \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );\n                    color*= 1. - .8*calcAmbientOcclusion( res.rayPos+res.normal*0.001, res.normal, 2.,  3, range_C) ;\n                #else\n                \n              \t\tvec3 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox);\n                  \n                    color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n                       \n                #endif\n            }\n            \n            \n           \n#ifdef ACTIONS\t\t\t\n            // SELECTION AND MOUSE OVER\n            \n            vec4 pick = load(_pick);\n            if (floor(res.mapPos) ==floor(pick.xyz) || res.vox.value==2) {\n                if(res.vox.shape==4 && length(fract(pick.xyz) -vec3(res.k%4u,(res.k>>2u)%4u, res.k>>4u)/4. -vec3(.125)  )<.125 ) color = mix(color, vec3(1), 0.5);\n                else if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n#endif            \n        }else\n        {\t\n            //MAP\n \t\t\t color *=  clamp( (res.mapPos.z-30.) /30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n          \n        }\n        \n    }\n     //else color = res.color;\n     else color   =mix( res.color, skyColor(rayDir,true),.9);\n    \n    \n    //if(res.water>0.) color *= pow( wcolor ,vec3(sqrt(res.water)/(7. + res.fresnel*1000.)));\n    if(res.water>0.) {\n        color *= pow( wcolor ,vec3(sqrt(res.water)/7.));\n        color = mix(color,wcolor, clamp(res.fresnel*500.,0.3,1.));\n         \n    }\n    else if(res.fresnel>0. ) {\n        color =mix(wcolor ,color,clamp(res.fresnel*4.,0.,.75));\n    }\n    \n    color =mix( color, skyColor(rayDir,false),clamp(exp(-1.+(res.dist-FOG)/FOG),0.,1.));\n    \n    if(res.mirror) color *= vec3(.9,.5,.5);\n\n    fragColor.rgb = color; //pow(color, vec3(1.));\n#ifdef ACTIONS    \n    if(rayType==3 ) {\n        vec3 px= res.vox.shape==4  ?vec3(res.k%4u,(res.k>>2u)%4u, res.k>>4u)/4. +vec3(.125) :vec3(0.); \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(floor(res.mapPos) +px,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n#endif     \n    //DEBUG:\n    //fragColor=vec4( (1.- res.dist /50.), (1.- res.dist /50.), res.hit?1.:0.,1.);\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n\n#define NB 8\nfloat[] \n    camx = float[]   (2944. , 2942. , 2972. , 2972., 2982., 2982.,2982. ,2944.),\n\tcamy = float[]   (10139., 10140., 10151.,10151.,10151.,10115.,10115.,10139.),\n\tcamz = float[]   (61.   , 83.   , 48.   ,5.    ,5.    ,5.    ,61.   ,61.),\n    lookx = float[]  (2970. ,2972.  , 2972. ,2952. ,2982. ,2982. ,2955. ,2970.),\n\tlooky = float[]  (10152.,10153. , 10154.,10133.,10120.,10120.,10151.,10152.),\n\tlookz = float[]  (55.   , 50.   , 44.   ,6.    ,6.    ,50.    , 50.   ,55.); \n \n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,0,1))*normalize(vec3((2.*uv-res.xy)/res.y, 3.5));\n}\n\nvoid getCam(in vec2 uv, in vec2 res, in float time, out vec3 ro, out vec3 rd) {\n       \n\tvec2 q = uv/res;\n    \n    float t = .16* time,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions  and direction\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec3 cp = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt); \n  \n    ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    rd = RD(ro, cp, uv, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n#ifdef MAP    \n    float MAP_SIZE= iResolution.y/8./pixelSize; \n    vec2 MapCenter=vec2(iResolution.x/pixelSize -MAP_SIZE , iResolution.y/pixelSize - MAP_SIZE);\n    if(abs(load(_map).r-1.) <.1 && distance(fragCoord,MapCenter)<MAP_SIZE) rayType=2;\n    if(abs(load(_map).r-2.) <.1) {\n        rayType=2;\n        MapCenter=vec2(iResolution.x/pixelSize/2. , iResolution.y/pixelSize/2.);\n    }\n    \n#endif    \n    \n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        //MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r/10.);///pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    } \n#ifdef MAP \n    else if(rayType==2){\n     \n        // MAP CAMERA\n        float cameraHeight =1500.;\n        float zoom = cameraHeight/iResolution.x/pixelSize*(load(_map).r>1.5?1.6:.4);\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=MapCenter/iResolution.xy*pixelSize;\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);    \n        vec2 angle = vec2(0.,PI);\n        if(load(_map).r>1.5){\n        \tangle=iMouse.xy/iResolution.xy*vec2(PI,-PI/3.)+vec2(0,PI);\n        }\n        cameraDir = rayDirection(angle,uv,renderResolution); \n        vec3 cameraCenterDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        cameraPos = load(_pos).xyz -cameraCenterDir* cameraHeight;\n    }       \n#endif            \n    else if(rayType==1) \n    {    \n        // MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n     \n      //DEMO VIEW     \n         if(load(_demo).r >.5)\n             getCam((fragCoord.xy- renderCenter) , renderResolution, iTime, cameraPos, cameraDir);\n                  \n    }   \n\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n    float loading= float(iFrame) -load(_textureSize).z;\n    //if(loading>LOAD_TIME +2.) fragColor=mix(fragColor,texture(iChannel3, fragCoord/iChannelResolution[3].xy ),.2);\n    if(loading<LOAD_TIME   && fragCoord.y <1. && fragCoord.x >1.  ) fragColor=vec4(1.);\n     \n    //MAP BORDER:\n#ifdef MAP\n    if(rayType==2){\n        if(load(_map).r <1.5){\n        \tif(abs(distance(fragCoord,MapCenter)-MAP_SIZE)<1.) fragColor.rgb=vec3(0.);    \n        \tif(distance(fragCoord,MapCenter + vec2(sin( load(_angle).x), -cos( load(_angle).x))*MAP_SIZE )<3.) fragColor.rgb= vec3(1.,0.,0.);\n        }\n    }\n#endif        \n    //fragColor = texture(iChannel2, fragCoord / 3. / iResolution.xy);\n}","name":"Buffer D","description":"","type":"buffer"}]}