{"ver":"0.1","info":{"id":"MlSyDh","date":"1508331197","viewed":299,"name":"Soft Storm","username":"leon","description":"Quick sketch made in 30 minutes. Training for Shader Showdown","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["storm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEPS 1./100.\n#define VOLUME_BIAS 0.01\n#define MIN_DIST 0.01\n#define STEP_DAMPING .3\n#define PI 3.14159\n#define TAU PI*2.\n#define red vec3(1.,.2,.1)\n#define orange vec3(0.972, 0.682, 0.227)\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat amod (inout vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    p.xy = vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r, 0., 1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\nfloat map (vec3 pos) {\n    float scene = 1000.;\n    float dist = length(pos)*.5;\n    dist -= iTime;\n    pos.xz *= rot(dist);\n    pos.yz *= rot(dist*.7);\n    pos.xy *= rot(dist*.5);\n    amod(pos.xz, 4.);\n    pos.x = repeat(pos.x, 1.);\n    pos.y = repeat(pos.y, 2.);\n    scene = min(scene, sdSphere(pos, .25));\n    return scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvec3 applyCamera (vec3 p) {\n    float t = iTime*.3;\n    p.xz *= rot(t);\n    p.xy *= rot(t*.7);\n    p.yz *= rot(t*.5);\n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = applyCamera(vec3(uv, -10.));\n    vec3 ray = applyCamera(normalize(vec3(uv, 1.)));\n    \n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            shade = 1.-i;\n            break;\n        }\n        dist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n        dist = max(MIN_DIST, dist);\n        pos += dist * ray;\n    }\n    vec3 normal = getNormal(pos);\n\tcolor = vec4(1);\n    color.rgb = mix(orange, red, dot(normal, vec3(0,0,1))*.5+.5);\n    color.rgb *= shade;\n}","name":"Image","description":"","type":"image"}]}