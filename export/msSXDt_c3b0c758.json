{"ver":"0.1","info":{"id":"msSXDt","date":"1671074506","viewed":74,"name":"Fork GPVM Path - week 5","username":"rockes","description":"GPVM Path Tracing Week 5\n\nLive coded in this meeting: https://www.meetup.com/graphics-programming-virtual-meetup/events/290304218/\n\nPath Tracing logic is in Buffer A.\n\nChange log:\n- Stratified sampling\n- Cornell box scene","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"ddSSDt","parentname":"GPVM Path Tracing Week 5"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tone mapping\nvec3 aces_approx(vec3 v)\n{\n\tv *= 0.6f;\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.xyz = aces_approx(fragColor.xyz);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n  * Path Tracing\n  */\n  \n#define SCENE 1\n// 0: 3 balls scene\n// 1: Cornell box\n\n// Ray\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t) {\n  return ray.origin + t * ray.direction;\n}\n\nstruct Material {\n    int type;\n    vec3 color;\n    float roughness;\n    float ior; // refraction index\n};\n\n#define METAL 0\n#define DIFFUSE 1\n#define EMISSIVE 2\n#define DIELECTRICS 3\n\n#if SCENE == 0\nMaterial materials[] = Material[](\n    Material(DIFFUSE, vec3(0.8, 0.8, 1.0), 0.0, 0.0),\n    Material(METAL, vec3(0.9, 0.9, 0.3), 0.2, 0.0),\n    Material(DIFFUSE, vec3(0.9, 0.9, 0.9), 0.0, 0.0),\n    Material(EMISSIVE, vec3(30.0, 30.0, 30.0), 0.0, 0.0),\n    Material(DIELECTRICS, vec3(0.0), 0.0, 1.5)\n);\n#else\nMaterial materials[] = Material[](\n    Material(EMISSIVE, vec3(12.0, 12.0, 12.0), 0.0, 0.0),\n    Material(DIFFUSE, vec3(.75,.25,.25), 0.0, 0.0),\n    Material(DIFFUSE, vec3(.25,.25,.75), 0.0, 0.0),\n    Material(DIFFUSE, vec3(1.0,1.0,1.0), 0.0, 0.0),\n    Material(DIFFUSE, vec3(0.75, 0.75, 0.75), 0.0, 0.0),\n    Material(DIELECTRICS, vec3(0.0), 0.0, 1.5)\n);\n#endif\n\nstruct Sphere {\n  vec3 center;\n  float radius;\n  int material_index;\n};\n\n#if SCENE == 0\nSphere spheres[] = Sphere[](\n  Sphere(vec3(-1.5, -0.5, 3.0), 0.5, 0),\n  Sphere(vec3(0.0, -0.5, 3.0), 0.5, 1),\n  Sphere(vec3(1.5, -0.5, 3.0), 0.5, 4),\n  Sphere(vec3(0.0, -101.0, 0.0), 100.0, 2),\n  Sphere(vec3(0.1, 1.0, 3.0), 0.2, 3)\n);\n#else\nSphere spheres[] = Sphere[](\n  Sphere(vec3(50,681.6-.27,81.6), 600.0, 0), // light\n  Sphere(vec3(1e3+1.0,40.8,81.6), 1e3, 1), // left\n  Sphere(vec3(-1e3+99.0,40.8,81.6), 1e3, 2), // right\n  Sphere(vec3(50.0,40.8,-1e3+170.0), 1e3, 3), // front\n  Sphere(vec3(50.0,1e3,81.6), 1e3, 4), // bottom\n  Sphere(vec3(50.0,1e3 + 85.0,81.6), 1e3, 4), // top\n  Sphere(vec3(60.0, 25.5, 220.), 16.5, 5) // glass\n);\n#endif\n\n// Scene\nvec3 background(Ray ray)\n{\n    #if SCENE == 0\n    vec3 texColor = texture(iChannel2, ray.direction).rgb;\n    return pow(texColor, vec3(2.2));\n    \n    float x = -ray.direction.x;\n    vec3 col = vec3(0.7, 0.8, 1.0) - 0.5 * x;\n    col = mix(col, vec3(0.8, 0.9, 1.0), min(exp(-10.0*x), 0.0));\n    return col;\n    #else\n    return vec3(0.0, 0.0, 0.0);\n    #endif\n}\n\nstruct HitRecord {\n  float t;\n  vec3 position;\n  vec3 normal;\n  int material_index;\n  bool front_face;\n};\n\nbool raySphereIntersection(Ray ray, int index, inout HitRecord hit)\n{\n  Sphere sphere = spheres[index];\n  float radius = sphere.radius;\n  \n  vec3 oc = ray.origin - sphere.center;\n  float a = dot(ray.direction, ray.direction);\n  float b = 2.0 * dot(oc, ray.direction);\n  float c = dot(oc, oc) - radius*radius;\n  float discriminant = b*b - 4.0*a*c;\n  \n  bool isInside = dot(oc, oc) <= radius * radius;\n  \n  if (discriminant >= 0.0) {\n    float t = isInside \n                ? (-b + sqrt(discriminant) ) / (2.0*a)\n                : (-b - sqrt(discriminant) ) / (2.0*a);\n    \n    if (t > 0.0 && t < hit.t) {\n      vec3 hitPoint = rayAt(ray, t);\n\n      hit.t = t;\n      hit.material_index = sphere.material_index;\n      hit.position = hitPoint;\n      \n      hit.normal = normalize(hitPoint - sphere.center);\n      if (isInside) hit.normal = -hit.normal;\n      hit.front_face = !isInside;\n      return true;\n    }\n    \n  }\n  return false;\n}\n\n\nbool castRay(Ray ray, inout HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); i++) {\n      hitSomething = raySphereIntersection(ray, i, hit) || hitSomething;\n    }\n    return hitSomething;\n}\n/*\n// white noise\nvec3 random_in_unit_sphere(inout uint rngState) {\n  float z = uniformFloat01(rngState) * 2.0f - 1.0f;\n  float a = uniformFloat01(rngState) * c_twopi;\n  float r = sqrt(1.0f - z * z);\n  float x = r * cos(a);\n  float y = r * sin(a);\n  return vec3(x, y, z);\n}*/\n\nvec2 noise;\n\n// blue noise\nvec3 random_in_unit_sphere(inout uint rngState) {\n  \n  float z = mod(noise.x + uniformFloat01(rngState), 1.0) * 2.0 - 1.0f;\n  float a = mod(noise.y + uniformFloat01(rngState), 1.0) * c_twopi;\n  float r = sqrt(1.0f - z * z);\n  float x = r * cos(a);\n  float y = r * sin(a);\n  return vec3(x, y, z);\n}\n\n\n// Use Schlick's approximation for reflectance.\nfloat reflectance(float cosine, float ref_idx) {\n  float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n  r0 = r0*r0;\n  return r0 + (1.0-r0)*pow((1.0 - cosine), 5.0);\n}\n\n// Path tracing\nvec3 traceRay(Ray ray, inout uint rngState)\n{\n  vec3 color = vec3(1.0);\n  \n  for (int i = 0; i < 20; ++i) {\n    HitRecord hit;\n    hit.t = 10000.0;\n  \n    if (castRay(ray, hit)) {\n      Material mat = materials[hit.material_index];\n      if (mat.type == METAL) {\n        color *= mat.color;\n        vec3 reflected = reflect(ray.direction, hit.normal);\n        reflected += normalize(random_in_unit_sphere(rngState)) * mat.roughness;\n        ray = Ray(hit.position + hit.normal * 1e-4, reflected);\n      } else if (mat.type == DIFFUSE) {\n        vec3 v = normalize( hit.normal + normalize(random_in_unit_sphere(rngState)) );\n        ray = Ray(hit.position + hit.normal * 1e-4, v);\n        color *= mat.color;// * (max(dot(v, hit.normal),0.));\n      } else if (mat.type == EMISSIVE) {\n        return color * mat.color;\n      } else if (mat.type == DIELECTRICS) {\n        float refraction_ratio = hit.front_face ? 1.0/mat.ior : mat.ior;\n        float cos_theta = min(dot(-ray.direction, hit.normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        \n        if (cannot_refract\n            || reflectance(cos_theta, refraction_ratio) > uniformFloat01(rngState)) {\n          vec3 reflected = reflect(ray.direction, hit.normal);\n          ray = Ray(hit.position - hit.normal * 1e-4, reflected);\n        } else {\n          ray = Ray(hit.position - hit.normal * 1e-4,\n            refract(ray.direction, hit.normal, refraction_ratio));\n        }\n      } else {\n        return vec3(1.0, 1.0, 0.0); // Shouldn't happen\n      }\n      \n    } else {\n      return color * background(ray);\n    }\n  }\n  return color;\n}\n\nRay generateRay(vec2 fragCoord, inout uint rngState) {\n    vec2 rotation = load(ROTATION_INDEX).xy / iResolution.x;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    #if SCENE == 0\n    vec3 ro = vec3(0.0);\n    #else\n    vec3 ro = vec3(50.0, 52.0, 295.0);\n    #endif\n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    rd *= CameraRotation(rotation);\n    return Ray(ro, rd);\n}\n\n\nvec3 finalGather(vec3 color, vec2 fragCoord) {\n    int frameCount = getFrameCount();\n    if (frameCount != 0) {\n        vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        color = mix(lastFrameColor, color, 1.0f / float(frameCount+1));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // initialize noise\n    noise = texture(iChannel3, fragCoord / vec2(textureSize(iChannel3, 0))).xy;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    #if 0\n    vec2 jitter = uniformVec2(rngState) - 0.5f;\n    Ray ray = generateRay(fragCoord + jitter, rngState);\n    vec3 col = traceRay(ray, rngState);\n    col = finalGather(col, fragCoord);\n    #else // Stratified sampling\n    const int gridWidth = 2;\n    const int count = gridWidth * gridWidth;\n    vec3 col = vec3(0);\n    for (int y = 0; y < gridWidth; ++y) {\n      for (int x = 0; x < gridWidth; ++x) {\n        int index = y * gridWidth + x;\n        vec2 jitter = (uniformVec2(rngState) - 0.5f + vec2(x, y))\n          / float(gridWidth);\n        Ray ray = generateRay(fragCoord + jitter, rngState);\n        col += traceRay(ray, rngState);\n      }\n    }\n    col = finalGather(col / float(count), fragCoord);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n  * Persistent states\n  */\n#define store(pos, value) if (all(equal(ivec2(fragCoord), (pos)))) { fragColor = (value); }\n\nvoid updateCamera(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n        store(ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    \n    vec2 prevRotation = load(PREVIOUS_ROTATION_INDEX).xy;\n    vec3 rotation = load(ROTATION_INDEX).xyz;\n\n    bool mouseButtonDown = iMouse.z > 0.0;\n    vec2 mouseCurrentPos = iMouse.xy;\n    vec2 mouseClickPos = abs(iMouse.zw);\n        \n    const float moveSpeed = 0.01;\n    \n    vec2 rotation2 = rotation.xy / iResolution.x;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n    rd *= CameraRotation(rotation2);\n    \n    if (mouseButtonDown) {\n        store(ROTATION_INDEX, vec4(prevRotation + mouseClickPos - mouseCurrentPos, 1.0, 0.0));\n    } else if (rotation.z != 0.0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(rotation.xy, 0.0, 0.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = load(ivec2(fragCoord));\n\n    bool isResolutionChanged = any(notEqual(load(RESOLUTION_INDEX).xy, iResolution.xy));\n    store(RESOLUTION_INDEX, vec4(iResolution, 0.0));\n    \n    bool atStart = iFrame == 0;\n    updateCamera(fragColor, fragCoord);\n\n    store(MOUSE_POS_INDEX, iMouse);\n    \n    bool isMouseMoved = !all(equal(load(MOUSE_POS_INDEX), iMouse));\n    bool needResetFrame = atStart || isMouseMoved || isResolutionChanged;\n    int frameCount = needResetFrame ? 0 : getFrameCount() + 1;\n    store(FRAME_COUNT_INDEX, vec4(float(frameCount), 0.0, 0.0, 0.0));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define load(pos) texelFetch(iChannel1, (pos), 0)\n\nconst ivec2 MOUSE_POS_INDEX = ivec2(0, 0);\nconst ivec2 RESOLUTION_INDEX = ivec2(1, 0);\n\nconst ivec2 FRAME_COUNT_INDEX = ivec2(0, 1);\n\nconst ivec2 PREVIOUS_ROTATION_INDEX = ivec2(2, 0);\nconst ivec2 ROTATION_INDEX = ivec2(2, 1);\n\n#define getFrameCount() int(load(FRAME_COUNT_INDEX).x)\n\nconst float c_twopi = 6.283185307179586;\n\nmat3 CameraRotation(vec2 m)\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotX * rotY;\n}\n\nvec3 lessThanV3(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n// Random\nuint pcg(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n \nfloat uniformFloat01(inout uint state)\n{\n    state = pcg(state);\n    return float(state) / 4294967296.0;\n}\n\nvec2 uniformVec2(inout uint state)\n{\n    return vec2(uniformFloat01(state), uniformFloat01(state));\n}","name":"Common","description":"","type":"common"}]}