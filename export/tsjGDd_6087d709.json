{"ver":"0.1","info":{"id":"tsjGDd","date":"1550512473","viewed":2116,"name":"church window","username":"flockaroo","description":"once more with marching ;-)\nrealtime version: [url]https://www.shaderoo.org/?shader=MZI9sA[/url]\n...also try webcam in Buffer A","likes":48,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","kdtree","subdivide","church"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// realtime version: https://www.shaderoo.org/?shader=MZI9sA\n \n#define USE_CUBEMAP\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n#define Res4 vec2(textureSize(iChannel4,0))\n\n#define ColorTex iChannel2\n//#include Include_A\n\nvec4 getCol(vec2 uv)\n{\n    #define DRes Res\n    #define SRes vec2(textureSize(ColorTex,0))\n    uv=(uv-.5)*DRes*min(SRes.x/DRes.x,SRes.y/DRes.y)/SRes+.5;\n    return texture(ColorTex,uv);\n}\n\n#define PI2 6.28318530718\n#define PI 3.14159265359\n    \n#ifndef RandTex\n#define RandTex iChannel1\n#endif\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRandSm(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(RandTex,0));\n    //vec2 fr=fract(pos-.5);\n    //vec2 uv=(pos-.7*sin(fr*PI2)/PI2)/tres.xy;\n    vec2 uv=pos/tres.xy;\n    uv=uvSmooth(uv,tres);\n    return textureLod(RandTex,uv,0.);\n}\n\nfloat getValH(vec2 pos, float lod)\n{\n    return abs(getRandSm(pos*.1).x-getRandSm(pos*.1+vec2(17.5,13.5)).x);\n}\n\nvec2 getGradH(vec2 pos,float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getValH(pos+d.xy,0.)-getValH(pos-d.xy,0.),\n        getValH(pos+d.yx,0.)-getValH(pos-d.yx,0.)\n        )/eps/2.;\n}\n\nvec3 getGlassNormal(vec2 pos)\n{\n    vec3 n = normalize(vec3(-getGradH(pos,1.4),.5));\n    return n;\n}\n\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel1,coord+.003*iTime);\n    c+=texture(iChannel1,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel1,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel1,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -4.\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// envoronment just a sky and some floor grid...\nvec4 myenv_(vec3 pos, vec3 dir, float period)\n{\n    vec3 colHor=vec3(.3,.4,.5)+.3;\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,vec3(.8,.9,1)*1.2,clamp(7.*dir.z,0.,1.));\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(.3,.4,.5)*1.5;\n    vec3 colScale=vec3(1,1,1);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec2 s;\n    float scale=1.;\n    //s=sin(floorPos.xy*PI2*.5*period);\n    //scale*=(1.-.25*exp(-s.x*s.x/.04))*(1.-.2*exp(-s.y*s.y/.04));\n    s=sin(floorPos.xy*PI2*.5/10.*period);\n    scale*=(1.-exp(-s.x*s.x/.03))*(1.-exp(-s.y*s.y/.03));\n    colFloor=mix(colFloor,colScale,1.-1.*scale)/**(1.+.4*(getRand(floorPos.xy*.001).x-.5))*/;\n    //sun\n    vec3 sun = normalize(vec3(.2,-1.,.15));\n    colFloor*=.5+1.*clamp(dot(normalize(texture(iChannel1,floorPos.xy*.3).xyz-.5+vec3(0,0,.5)),sun),0.,1.);\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    float ang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col*=.6+.4*(PI-ang)/PI;\n    col+=(1.-smoothstep(.0,.7,ang))*.2;\n    col+=(1.-smoothstep(.02,.025,ang))*.8;\n    //col=vec3((PI-ang)/PI);\n    return vec4(col,1);\n}\n\nfloat getVal(vec2 pos,float lod)\n{\n    //return textureLod(iChannel0,pos/Res,lod).w;\n    vec4 c=textureLod(iChannel0,pos/Res,lod);\n    float d=c.z;\n    float sc=c.w;\n    return (1.-pow(7.5*d*d/sc,1.));\n}\n\nvec2 getGrad(vec2 pos,float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy,0.)-getVal(pos-d.xy,0.),\n        getVal(pos+d.yx,0.)-getVal(pos-d.yx,0.)\n        )/eps/2.;\n}\n\n// inigo quilez's box distance\nfloat getDistBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat getDistLead(vec3 pos)\n{\n    vec2 uv=(pos.xy*Res.x+Res)*.5/Res;\n    vec4 c=textureLod(iChannel0,uv,0.);\n    float d=c.z/Res.x*2.;\n    //float sc=c.w/Res.x;\n    // take mipmapped version of cell scale, so we dont get jumps when raymarching\n    float sc=textureLod(iChannel0,uv,2.5).w/Res.x;\n    d=sqrt(d*d+pos.z*pos.z)-sqrt(sc)/60.;\n    //d=sqrt(d*d+pos.z*pos.z)-0.001;\n    d=max(d,getDistBox(pos,vec3(Res/Res.x,0.01)));\n    return d; \n}\n\n#define FRAME_D 0.06\n\nfloat getDistGlass(vec3 pos)\n{\n    return getDistBox(pos,vec3(Res/Res.x+FRAME_D*2.,0));\n}\n\nfloat getDistFrame(vec3 pos)\n{\n    vec2 asp=Res/Res.x;\n    float d=1000.; float d1=1000.;\n    d=min(d,abs(getDistBox(pos,vec3(asp+FRAME_D*2.,10000.))));\n    d1=min(d1,sqrt(d*d+pos.z*pos.z)-.01);\n    d=abs(getDistBox(pos,vec3(asp,10000.)));\n    vec3 s; vec2 o1;\n    o1 = asp+vec2(-.3333, FRAME_D); s=vec3(.3333,FRAME_D,10000.);\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1, 1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1, 1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1,-1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1,-1),0),s)));\n    o1 = asp+vec2( FRAME_D,-.5*asp.y); s=vec3(FRAME_D,.5*asp.y,10000.);\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1, 1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1,-1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1, 1),0),s)));\n    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1,-1),0),s)));\n    d1=min(d1,sqrt(d*d+pos.z*pos.z)-.0055);\n    return d1;\n}\n\nvec2 getDistM(vec3 pos)\n{\n    float m=-1.;\n    float d=10000.;\n    float dp;\n    vec3 rpos=pos+.005*(getRandSm(pos.xy*20.).xyz-.5);\n    dp=d; d=min(d,getDistGlass(pos)); m=(d<dp)?0.:m;\n    dp=d; d=min(d,getDistLead(pos));  m=(d<dp)?1.:m;\n    dp=d; d=min(d,getDistFrame(rpos)); m=(d<dp)?1.:m;\n    return vec2(d,m);\n}\n\nfloat getDist(vec3 pos)\n{\n    return getDistM(pos).x;\n}\n\nvec3 getGradDist(vec3 pos,float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    return vec3(\n        getDist(pos+d.xyz)-getDist(pos-d.xyz),\n        getDist(pos+d.zxy)-getDist(pos-d.zxy),\n        getDist(pos+d.yzx)-getDist(pos-d.yzx)\n        )/eps/2.;\n}\n\nfloat march(inout vec3 pos, inout vec3 dir)\n{\n    float eps = .0001;\n    float mat=-1.;\n    for(int i=0;i<50;i++)\n    {\n        vec2 dm=getDistM(pos);\n        float d=dm.x;\n        pos+=dir*d*.9;\n        if(d<eps) { mat=dm.y; break; }\n    }\n    return mat;\n}\n\nvec4 getEnv(vec3 dir) { \n    #ifdef USE_CUBEMAP    \n    return pow(texture(iChannel3,dir.zyx),vec4(1.5))*2.5;\n    #endif\n    return pow(myenv_(vec3(0),dir.xzy,2.),vec4(1.25)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCoord0=fragCoord;\n    vec2 ang=(iMouse.xy-Res*.5)/Res*PI2*2.;\n    if (iMouse.x<1.) \n     \tang=vec2(0.15,0.2);\n    ang+=.02*sin(iTime*vec2(1.3,.7));\n    vec2 cs1=sin(vec2(PI*.5,0)+ang.x);\n    vec2 cs2=sin(vec2(PI*.5,0)+ang.y);\n \tmat3 rot = \n \t     mat3(cs1.xyy*vec3(1,0,1),vec3(0,1,0),cs1.yxx*vec3(-1,0,1))\n        *mat3(vec3(1,0,0),cs2.xxy*vec3(0,1,1),cs2.xyx*vec3(0,-1,1));\n \t\n    float SC=Res.x/600.;\n    float SSC=sqrt(SC);\n    \n    float vdist=2.;\n    vdist*=/*(1.-iMouseData.z/1000.)**/1.3;\n    \n    vec2 scr=(fragCoord*2.-Res.xy)/Res.x;\n    vec3 vdir=normalize(vec3(scr,-2.));\n    \n    vec3 vpos = vec3(0,0,vdist);\n    vdir = rot*vdir;\n    vpos = rot*vpos;\n    \n    // step close to surface\n    vpos=vpos-vdir*((vpos.z*.95)/vdir.z);\n    \n    // march\n    vec3 vpos1=vpos-vdir*(vpos.z/vdir.z)+vec3(0,0,.02);\n    vec3 vpos2=vpos-vdir*(vpos.z/vdir.z)-vec3(0,0,.02);\n    float mat = -1.0;\n    if (   (abs(vpos1.x)<1.01+2.*FRAME_D || abs(vpos2.x)<1.01+2.*FRAME_D) \n        && (abs(vpos1.y)<Res.y/Res.x*1.01+2.*FRAME_D || abs(vpos2.y)<Res.y/Res.x*1.01+2.*FRAME_D) ) \n        mat = march(vpos,vdir);\n\n    vec3 n=normalize(getGradDist(vpos,1./Res.x*1.5));\n    \n    fragColor.xyz=n*.5+.5;\n    fragColor.w=1.;\n    //return;\n    \n    fragCoord = (vpos.xy*Res.x+Res.xy)*.5;\n\n    vec2 uv=fragCoord/Res;\n    bool isFrame = abs(uv-.5).x>.5 || abs(uv-.5).y>.5 ;\n    \n    vec4 col = texture(iChannel0,fragCoord/Res);\n    float leadH = getVal(fragCoord,0.);\n    float d = col.z;\n    float sc = isFrame?30.:col.w;\n    \n    vec3 ng=getGlassNormal(fragCoord*3./SSC*10./sqrt(sc));\n    // make normal point outwards on backside\n    ng.z *= (dot(ng,vdir)>0.)?-1.:1.;\n    ng=isFrame?normalize(ng*vec3(1,1,10.)):normalize(ng*vec3(1,1,1.5));\n    \n    vec3 backlight=getEnv(refract(refract(vdir,ng,.8),vec3(0,0,ng.z>0.?1.:-1.),1./.8)).xyz;\n    // this line wont work on windows... no idea why!? using conditional operator above now\n    //vec3 backlight=getEnv(refract(refract(vdir,ng,.8),vec3(0,0,sign(ng.z)),1./.8)).xyz;\n    vec3 refl     =getEnv(reflect(vdir,ng)).xyz;\n    vec3 leadrefl =getEnv(reflect(vdir,n)).xyz;\n\n    col.xyz = getCol(col.xy).xyz;\n    float br=dot(col.xyz,vec3(.3333));\n    col.xyz=clamp((col.xyz-br)*1.3+br*.9+.1,0.,1.);\n    col=isFrame?vec4(.8,.9,1,1):col;\n\n    vec3 leadcol=leadrefl*.55;\n    leadcol*=clamp(abs(vpos.z)*Res.x+.3,0.,1.);\n    //float lbr=dot(leadcol,vec3(.3333));\n    //leadcol=(leadcol-lbr)*.2+lbr;\n    \n    vec4 col2=texture(iChannel0,((fragCoord+0.*vec2(-1,1)*SC+SC*0.*sin(iTime*vec2(2,3)))/Res-.5)*1.+.5,2.7+log2(SC));\n    float d2=col2.z;\n    //backlight*=.7+1.*smoothstep(0.,8.*SC,d2)*.5*(.7+.3*texture(iChannel2,col2.xy).xyz);\n    backlight*=1.;\n\n    float ao=1.;\n    ao*=1.5-.5*clamp(d/(4.*SC),0.,1.);\n    ao*= .5+.5*clamp(d/(2.*SC),0.,1.);\n    \n    float fres=abs(dot(ng,-vdir));\n    //fres*=fres;\n    fres=1.-fres;\n    //fres*=fres;\n    fres=fres*.8+.2;\n    \n    fragColor.xyz = mix(mix(col.xyz*backlight,refl,fres),leadcol,clamp(mat,0.,1.));\n    //fragColor.xyz = backlight;\n    //fragColor.xyz = fres*refl;\n    if(mat<0.) fragColor.xyz = getEnv(vdir).xyz;\n    \n    //fragColor.xyz=vec3(mat*.3);\n    \n    //fragColor.xyz = vec3(backlight)*.5;\n    //fragColor.xyz = refl;\n    //fragColor.xyz = vec3(leadcol.xyz)*.4;\n    //fragColor.xyz = col.xyz;\n    \n    fragCoord=fragCoord0;\n    // vignetting\n    if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.-.7*dot(scc,scc);\n        vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }\n    \n    fragColor.xyz=pow(fragColor.xyz,vec3(1.35));\n    //fragColor=texture(iChannel5,fragCoord/Res);\n    \n    fragColor.w=1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// emulating multiple passes by dedicating each frame to a different pass\nconst int NumPasses = 13;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// copy every NumPasses'th frame of video to Buffer\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define iPassIndex (iFrame%NumPasses)\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec4 getCol(vec2 pos)\n{\n    vec2 tres = Res0;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res1)*min(tres.y/Res1.y,tres.x/Res1.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n\tvec4 col=texture(iChannel0,uv);\n\tvec4 bg=texture(iChannel2,((uv-.5)*.9+.5)+.05*sin(.1*iTime*vec2(2,3)),3.7+log2(Res1.x/600.));\n    col=mix(col,bg,dot(col.xyz,vec3(-.8,1.6,-.8)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iPassIndex==0)\n        fragColor=getCol(fragCoord);\n    else\n        fragColor=texture(iChannel1,fragCoord/iResolution.xy);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// recursively find min and max pixel brightness in a certain region\n// going from small scales to higher scales\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define iPassIndex (iFrame%NumPasses)\n\n//#define ResMap (vec2(512,256))\n#define ResMap min(pow(vec2(2.),floor(log2(iResolution.xy))),vec2(512,256))\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nbool getNBPixPos(ivec2 coord, int level, inout ivec2 pos1, inout ivec2 pos2)\n{\n    if (level==0) { pos1=coord*ivec2(2,1); pos2=pos1+ivec2(1,0); return coord.x<int(Res1.x)/2; }\n    \n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n    \n    ivec2 c = coord-o;\n    pos1=op+c*(dir+1);\n    pos2=pos1+dir;\n    return c.x>=0 && c.x<s.x && c.y>=0 && c.y<s.y;\n}\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nbool isBigger(vec4 c1, vec4 c2)\n{\n    return colDist(c1,c2)>0.;\n}\n\nvec4 getCol(vec2 coord)\n{\n    return texture(iChannel0,coord/Res1.xy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if( fragCoord.x>Res1.x || fragCoord.y>Res1.y ) discard;\n    if(iPassIndex==0) {vec2 coord=fragCoord; fragColor=vec4(coord,coord); return; }\n    \n    int isVert = (iPassIndex+1)&1;\n    ivec2 dir = (ivec2(0,1)+iPassIndex+1)&1;\n    \n    ivec2 coord=ivec2(fragCoord);\n\n    // copy previous pass\n    fragColor=texelFetch(iChannel1,coord,0);\n    \n    // who are the neighbours?\n    ivec2 pos1, pos2;\n    if (!getNBPixPos(coord,iPassIndex-1,pos1,pos2)) { return; }\n    \n    vec4 coordMinMax1 = texelFetch(iChannel1,pos1,0);\n    vec4 coordMinMax2 = texelFetch(iChannel1,pos2,0);\n    vec4 cmin1=getCol(coordMinMax1.xy);\n    vec4 cmin2=getCol(coordMinMax2.xy);\n    vec4 cmax1=getCol(coordMinMax1.zw);\n    vec4 cmax2=getCol(coordMinMax2.zw);\n    \n    fragColor.xy = isBigger(cmin2,cmin1)?coordMinMax1.xy:coordMinMax2.xy;\n    fragColor.zw = isBigger(cmax1,cmax2)?coordMinMax1.zw:coordMinMax2.zw;\n    // debug pass levels\n    //fragColor.xyz = vec3(0) + float(iPassIndex)/15.;\n    //fragColor.w = 1.;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// find voronoi cells\n\n// the effect is fast enough for realtime, but the video framerate is reduced due \n// to \"emulated passes\" (1 pass per frame - unfortunetely there's no passes in shadertoy)\n\n#define iPassIndex (iFrame%NumPasses)\n\n//#define ResMap (vec2(512,256))\n#define ResMap min(pow(vec2(2.),floor(log2(iResolution.xy))),vec2(512,256))\n#define PI2 6.28318530718\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nvec4 getCol(vec2 uv)\n{\n    return texture(iChannel0,uv);\n}\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nvoid getCenterScaleColor( vec2 fragCoord, inout vec2 c, inout vec2 s, inout vec4 col )\n{\n    vec2 frameCoord;\n    vec2 fact=ResMap/vec2(512,256);\n    s=iResolution.xy*vec2(.25,.25)/fact;\n    c=(floor(fragCoord/s)+.5)*s;\n    for(int i=11;i>=0;i--)\n    {\n        vec4 coordMinMax=textureLod(iChannel1,getLevelCoords(fragCoord/iResolution.xy,i,frameCoord)*Res1/Res,0.);\n        vec4 mi = getCol(coordMinMax.xy/Res1);\n        vec4 ma = getCol(coordMinMax.zw/Res1);\n        col=mix(mi,ma,1.);\n        //fragColor.xyz=vec3(0)+dot(fragColor.xyz,vec3(.3333));\n        float detail=(iMouse.x>=1.)?1./(1.+25.*iMouse.x/iResolution.x):.3/sqrt(Res.x/600.);\n        detail=.3/sqrt(Res.x/600.);\n        vec2 dir=((i&1)==1)?vec2(1,0):vec2(0,1);\n        s *= ((i&1)==0)?vec2(1,.5):vec2(.5,1);\n        c+=s*(step(vec2(0),fragCoord-c)*2.-vec2(1))*dir*.5;\n        if( abs(colDist(mi,ma))<detail /**float(i+10)/30.*/ ) break;\n    }\n}\n\nvec4 getPixRandS(vec2 pos)\n{\n    //return textureLod(iChannel2,(pos)/Res2,0.)-.5;\n    return textureLod(iChannel2,(floor(pos)+.5)/Res2,0.)-.5;\n}\n\nfloat randness = 0.5;\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRand(vec2 pos)\n{\n    return textureLod(iChannel2,uvSmooth(pos/Res2,Res2),0.);\n}\n\nvoid mainImageOld( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    //fragColor=texture(iChannel1,fragCoord/iResolution.xy);\n    //fragColor=texture(iChannel2,fragColor.xy/Res1);\n}\n\n#define sc (iResolution.x/600.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // just render a new frame every NumPasses'th fame, otherwise copy old frame\n    if (iPassIndex!=NumPasses-1) \n    {\n    \tfragColor=texture(iChannel3,fragCoord/Res);\n        return;\n    }\n    \n    vec4 r = getRand(fragCoord*1.2/sqrt(sc))-getRand(fragCoord*1.2/sqrt(sc)+vec2(1,-1)*1.5);\n    fragCoord+=3.1*sqrt(sc)*(getRand(fragCoord*.035).xy-.5+.5*(getRand(fragCoord*.1).xy-.5));\n    vec4 coords=texelFetch(iChannel1,ivec2(fragCoord.xy),0);\n    fragColor = vec4(0);\n    float sum=0.;\n    \n    vec2 c,s,c2,s2;\n    vec4 color=vec4(0);\n    getCenterScaleColor(fragCoord,c,s,color);\n    vec2 p1,p2,p3;\n    p1 = c+getPixRandS(c).xy*s*randness;\n    float d=length(fragCoord-p1);\n    vec2 cellScale=s;\n    p2 = vec2(0);\n    float d2=1000.;\n    p3 = vec2(0);\n    float d3=1000.;\n\n    vec2 dir = vec2(1,0);\n    vec2 edge = vec2(-1,-1);\n    for(int j=0;j<4;j++)\n    {\n        dir =dir.yx *vec2(1,-1);\n        edge=edge.yx*vec2(1,-1);\n        vec2 pos=c+(s*.5+.5)*edge;\n        for(int i=0;i<32;i++)\n        {\n            getCenterScaleColor(pos,c2,s2,color);\n            vec2 point=c2+getPixRandS(c2).xy*s2*randness;\n            float dact=length(fragCoord-point);\n            if (dact<d) {\n                p3=p2; d3=d2; p2=p1; d2=d; d=dact; cellScale=s2; p1=point;\n            }\n            else if (dact<d2) {\n                d3=d2; p3=p2; d2=dact; p2=point;\n            }\n            else if (dact<d3) {\n                d3=dact; p3=point;\n            }\n            pos+=(dot(c2-pos,dir)+abs(dot(s2*.5,dir))+1.)*dir;\n            if (dot(pos-c,dir)>abs(dot(s,dir)*.5)) break;\n        }\n    }\n    d=100.;\n    d=min(d,abs(dot(fragCoord-(p1+p2)*.5,normalize(p1-p2))));\n    d=min(d,abs(dot(fragCoord-(p1+p3)*.5,normalize(p1-p3))));\n    \n    fragColor.xy = p1/Res; \n    fragColor.z = d;\n    fragColor.w = length(cellScale);\n    \n    #if 0\n    float SC=Res.x/700.;\n    float SSC=sqrt(SC);\n    //fragColor.xyz = (cellColor.xyz*1.+.0)*(1.-pow(d/50./SC,1.));\n    fragColor.xyz = getCol(p1/Res).xyz*1.+.0;\n    //fragColor.xyz *= 1.2;\n    fragColor.xyz *= (1.05-.1*smoothstep(0.,16.,10.*d/sqrt(length(cellScale))));\n    fragColor.xyz *= (1.1-.2*smoothstep(0.,8.,10.*d/sqrt(length(cellScale))));\n    fragColor.xyz *= mix(1.,smoothstep(1.,3.,10.*d/sqrt(length(cellScale))),.8-.5*sqrt(length(cellScale)/100.));\n    //fragColor.xyz *= .6+.4*smoothstep(1.,3.,10.*d/sqrt(length(cellScale)));\n    //fragColor.xyz = vec3(d/50.);\n    #endif\n    // vignetting\n    /*if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.1-.5*dot(scc,scc);\n        vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }*/\n    //fragColor/=sum;\n    //fragColor.w=1.;\n    //coordMinMax=texelFetch(iChannel1,ivec2(fragCoord/Res*Res1),0);\n    \n    //vec2 co=(iMouse.y<Res.y*.5)?coordMinMax.xy:coordMinMax.zw;\n    //fragColor.xyz=vec3(0)+dot(texture(iChannel0,co/Res1).xyz,vec3(.3333));\n    \n    //fragColor=vec4(coordMinMax.xy/256.,0,1);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// backup last vid frame, so we can do lighting in image tab in realtime\n\n#define iPassIndex (iFrame%NumPasses)\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n#define Res4 vec2(textureSize(iChannel4,0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iPassIndex!=NumPasses-1) \n    {\n    \tfragColor=texture(iChannel3,fragCoord/Res);\n        return;\n    }\n   \tfragColor=texture(iChannel2,fragCoord/Res);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}