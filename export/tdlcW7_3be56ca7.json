{"ver":"0.1","info":{"id":"tdlcW7","date":"1585039461","viewed":114,"name":"My Frist Ray Marching Study","username":"jerrypoiu","description":"by JoChips","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 materialColor = vec3(0.3);\nconst float reflectAmount = 0.3;\nconst vec3 lightColor = vec3(1.5, 1.5, 1.5);\nconst vec3 lightDirection = normalize(vec3(-0.5, 0.4, -0.6));\n\n//Sphere\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n//Box\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//Scene\nfloat scene(in vec3 worldPosition)\n{\n    float result = 1.0;\n       \n    float box1 = sdBox(worldPosition - vec3(0.0, 0.5, 0), vec3(clamp(abs(sin(iTime)) * 0.15, 0.033, 0.15) + 0.11));    \n\tresult = min(result, box1);\n    \n    float sphere1 = sdSphere(worldPosition - vec3(0.0, 0.5, 0.0), 0.25);    \n\tresult = max(result, sphere1);\n     \n    float box2 = sdBox(worldPosition - vec3(0.0, 0.0, 0.0), vec3(1.0, 0.25, 1.0));\n    result = min(result, box2);\n       \n    return result;\n}\n\n//Normal\nvec3 calculateNormal(in vec3 worldPosition)\n{\n    const vec2 h = vec2(0.001, 0);\n    \n    vec3 xGradient = (scene(worldPosition + h.xyy) - scene(worldPosition - h.xyy)) /2.0f * h.xyy;\n    vec3 yGradient = (scene(worldPosition + h.yxy) - scene(worldPosition - h.yxy)) /2.0f * h.yxy;\n    vec3 zGradient = (scene(worldPosition + h.yyx) - scene(worldPosition - h.yyx)) /2.0f * h.yyx;\n\n    return normalize(xGradient + yGradient + zGradient);\n}\n\n//Shadow\nfloat calculateShadow(in vec3 worldPosition, in vec3 lightDirection, in float minLength, in float maxLength)\n{\n    for( float currentLength = minLength; currentLength < maxLength; )\n    {\n        float h = scene(worldPosition + lightDirection * currentLength);\n        \n        if(abs(h) < 0.0001)\n            return 0.0;\n        \n        currentLength += h;\n    }\n    \n    return 1.0;\n}\n\n//Ray\nfloat raycasting(in vec3 cameraPosition, in vec3 rayDirection)\n{\n    float curLength = 0.0;\n    float totalLength = -1.0;\n       \n    for( int i = 0; i < 100; i++ )\n    {\n        float h = scene(cameraPosition + rayDirection * curLength);\n        \n        if(abs(h) < 0.0001)\n        { \n           totalLength = curLength;\n           break;\n        }\n        \n        curLength += h;\n    }\n    \n    return totalLength;\n}\n\n//Render\nvec3 render(in vec3 cameraPosition, in vec3 rayDirection)\n{   \n    float totalLength = raycasting(cameraPosition, rayDirection);\n\n    if(totalLength <= -1.0)\n        return texture(iChannel0, rayDirection).xyz;\n        \n    // Variables required for lighting\n    vec3 worldPosition = cameraPosition + rayDirection * totalLength;\n    vec3 normal = calculateNormal(worldPosition);\n    vec3 refectionVector = reflect(rayDirection, normal);\n        \n    // Phong\n    vec3 ambient = vec3(0.1f);\n    vec3 diffuse = lightColor * dot(normal, lightDirection);\n\tvec3 specular = lightColor * pow(clamp(dot(refectionVector, lightDirection), 0.0, 1.0), 16.0);\n    vec3 reflectColor = texture(iChannel0, refectionVector).xyz;\n\n    // Shadow\n    float shadow = calculateShadow(worldPosition, lightDirection, 0.01, 5.0 );\n    diffuse *= shadow;\n\tspecular *= shadow;\n    \n    // Apply results\n    vec3 pixelColor = materialColor * (ambient + diffuse) + specular;\n    pixelColor += reflectColor * reflectAmount;\n    \n\treturn pixelColor;\n}\n\n//PixelShader\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera\n    vec3 cameraPosition = vec3(0.0, 0.85, -1.0);\n\tvec3 cmearaLookTarget = vec3(0.0, 0.55, 0.0);\n    vec3 cmz = normalize(cmearaLookTarget - cameraPosition);    \n    vec3 cmx = normalize(cross(vec3(0,1,0), cmz));\n    vec3 cmy = cross(cmz, cmx);\n    mat3 cameraMatrix = mat3(cmx, cmy, cmz);\n    \n    //pixelPosition\n    vec2 pixelPosition = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    //Ray direction\n    vec3 rayDirection = cameraMatrix * normalize(vec3(pixelPosition, 2.5));\n    \n    //Rendering\t\n    vec3 color = render(cameraPosition, rayDirection);\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}