{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// ------------------------ coffee cup\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nmat3 rotX(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotY(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat mapCoffeeCup(vec3 p) {\n    p -= vec3(0.5, -0.55, -0.4);\n    // Adjust based on mouse input\n    float angleX =3.0; // Map Y mouse to X-axis rotation\n    float angleY =120.0; // Map X mouse to Y-axis rotation\n\n    // Apply rotations\n    p *= rotX(angleX); \n    p *= rotY(angleY); \n    \n    // Cup body (cylinder)\n    float body = sdCylinder(p, 0.15, 0.2);\n    \n    // Cup handle (torus)\n    vec3 handlePos = p - vec3(0.15, 0.0, 0.0);\n    handlePos = handlePos * rotX(3.1415926 / 2.0);\n\n    float handle = sdTorus(handlePos, vec2(0.1, 0.03));\n    \n    // Combine body and handle\n    return min(body, handle);\n}\n\nfloat raymarchCoffeeCup(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapCoffeeCup(p);\n        if (d < 0.001 || t > 100.0) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    vec3 e = vec3(eps, 0.0, 0.0);\n\n    return normalize(vec3(\n        mapCoffeeCup(p + e.xyy) - mapCoffeeCup(p - e.xyy),\n        mapCoffeeCup(p + e.yxy) - mapCoffeeCup(p - e.yxy),\n        mapCoffeeCup(p + e.yyx) - mapCoffeeCup(p - e.yyx)\n    ));\n}\n\n// Table------------------\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat mapTable(vec3 p) {\n    vec3 tableDimensions = vec3(1.5, 0.03, 0.4); // Width, height (thickness), depth\n    float cornerRadius = 0.1; \n    return sdRoundBox(p - vec3(0.0, -0.8, -0.1), tableDimensions, cornerRadius);\n}\n\nfloat raymarchTable(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapTable(p); \n        if (d < 0.001 || t > 100.0) break;\n        t += d;\n    }\n    return t;\n}\n\n// ------------------------------------------ forest//moon//stars\n// - p:    Input coordinate\n// - wb:   Bottom width\n// - wt:   Top width \n// - yb:   Bottom y-coordinate \n// - yt:   Top y-coordinate\n// - blur: Softness of edges (controls smoothness of transitions)\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n    // Uses smoothstep for soft transitions at vertical boundaries\n    float m = smoothstep(-blur, blur, p.y - yb);\n    m *= smoothstep(blur, -blur, p.y - yt); \n    \n    p.x = abs(p.x);\n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= smoothstep(blur, -blur, p.x - w);\n    \n    return m;\n}\n\n// - uv:   Normalized coordinates\n// - col:  Base color\n// - blur: Edge softness\nvec4 Tree(vec2 uv, vec3 col, float blur) {\n    // Parameters: (uv, bottom_width, top_width, bottom_y, top_y, blur)\n    float m = TaperBox(uv, 0.03, 0.03, -0.05, 0.25, blur); //Trunk\n    m += TaperBox(uv, 0.2, 0.25, 0.25, 0.5, blur);   // Lower canopy\n    m += TaperBox(uv, 0.3, 0.15, 0.5, 0.75, blur);   // Middle canopy\n    m += TaperBox(uv, 0.25, 0.08, 0.75, 0.9, blur);  // Upper canopy\n    \n    float shadow = TaperBox(uv-vec2(0.2,0), 0.1, 0.5, 0.15, 0.25, blur);\n    shadow += TaperBox(uv+vec2(0.25,0), 0.2, 0.6, 0.45, 0.5, blur);\n    shadow += TaperBox(uv-vec2(0.25,0), 0.1, 0.5, 0.7, 0.75, blur);\n    col -= shadow * 0.8;\n    \n    return vec4(col, m);\n}\n\n// wave height\nfloat getHeight(float x) {\n    return sin(x * 0.423) + sin(x) * 0.2 + 0.2;\n}\n\nvec4 Layer(vec2 uv, float blur) {\n    vec4 col = vec4(0);    \n    // Ground generation with random variation\n    float id = floor(uv.x);\n    float n = fract(sin(id * 205.12) * 2193.3) * 2.0 - 1.0;\n    float x = n * 0.24;\n    float y = getHeight(uv.x);\n    float ground = smoothstep(blur, -blur, uv.y + y);\n    col += ground;\n    \n    y = getHeight(id + 0.5 + x); //adjust height for tree\n    uv.x = fract(uv.x) - 0.5;\n    vec4 tree = Tree((uv - vec2(x, -y)) * vec2(1, 1.0 + n * 0.3), vec3(1), blur);\n    \n    //col.rg=uv; //uv outlining\n    \n    // Blend everything    \n    col = mix(col,tree,tree.a);\n    col.a = max(ground, tree.a);\n\n    return col;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.45, 765.34));\n    p += dot(p,p+547.123);\n    return fract(p.x*p.y);\n}\n\n// SMOKE -------------\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r; // Signed distance to a sphere\n}\n\nvec2 mapSmoke(vec3 p) {\n    float minDist = 1000.0; \n    float alpha = 0.0; // transparency\n\n    float offsetX = 0.7;\n    float offsetY = -0.8;\n    float offsetZ = 0.3;\n\n    for (int i = 0; i < 100; i++) {\n        float x = 0.04 * sin(iTime * 2.5 + float(i) * 1.4) + offsetX; \n        float y = 0.3 + mod(float(i) * 1.3 + iTime * 0.4, 1.5) + offsetY;\n        float z = 0.2 * cos(iTime * 1.7 + float(i) * 1.5) + offsetZ;\n\n        vec3 spherePos = vec3(x, y, z);\n        float radius = 0.1 * sin(iTime + float(i)) - 0.06; \n        float dist = sdSphere(p - spherePos, radius);\n\n        // Calculate transparency based on sphere's height\n        float fadeStart = 0.3;\n        float fadeEnd = 0.4;\n        float heightFactor = smoothstep(fadeEnd, fadeStart, spherePos.y);\n\n        if (dist < 0.1) { \n            alpha += 0.2 * heightFactor; // Increase alpha with height fading\n        }\n\n        minDist = min(minDist, dist);\n    }\n\n    alpha = clamp(alpha, 0.0, 1.0);\n    return vec2(minDist, alpha);\n}\n\n// --------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    \n    //existing 2D scene\n    //uv.x += iTime * 0.05; //speed of the scene\n    //uv *= 5.0; // Zoom out\n    float t= iTime * 0.3; \n    float blur = 0.005;\n    \n    // STARS -------------\n    float twinkle = dot(length(sin(uv+t)),length(cos(uv*vec2(22,6.7)-t*3.0)));\n    twinkle = sin(twinkle*10.0)*0.5+0.5;\n    float stars = pow(Hash21(uv),340.0)*twinkle ;\n    vec4 col = vec4(stars);    \n\n\n    // MOON ------------------\n    float moon = smoothstep(0.1, -0.1, length(uv-vec2(-0.4,0.25))-0.15);\n    col *= 3.0-moon;\n    moon *= smoothstep(-0.01, 0.1, length(uv-vec2(-0.3,0.3))-0.15);\n    col += moon;\n\n\n    // FOREST --------------------\n    vec4 layer;\n    for(float i=0.0; i<1.0; i+=1.0/7.0) { //last param represents the layers that we / by\n        float scale = mix(20.0,1.0,i); //the first parameter controls the distance of each layer\n        blur = mix(0.05, 0.005, i);\n        layer = Layer(uv * scale + vec2(t+i*100.0,i) - M, blur); //first vec2 param controls shift of each layer\n        layer.rgb *= (1.0 - i) * vec3(0.75,0.7,1.0);\n        col = mix(col, layer, layer.a);\n    }    \n    \n    layer = Layer(uv + vec2(t,1) - M, 0.05);\n    col = mix(col, layer*0.1, layer.a);\n    \n    //COFFEE -------------\n    vec3 ro = vec3(0.0, 0.0, -2.0); // Ray origin\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n   \n    //TABLE\n    float tTable = raymarchTable(ro, rd);\n\n    if (tTable > 0.0 && tTable < 100.0) {\n        vec3 p = ro + tTable * rd;\n        vec3 normal = calcNormal(p); // Calculate surface normal\n        vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        float ambient = 0.3; \n        float lighting = ambient + diffuse;\n        col.rgb = vec3(0.5, 0.3, 0.1) * lighting; // Brown with lighting\n    }\n    \n    // Smoke\n    float tSmoke = 0.0;\n    vec3 smokeColor = vec3(1.0); // white\n    float totalAlpha = 0.0; // Initialize total alpha for blending\n\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + tSmoke * rd; // Current position along the ray\n        vec2 result = mapSmoke(p); \n        float d = result.x; \n        float alpha = result.y; \n\n        if (d < 0.01) {\n            col.rgb = mix(col.rgb, smokeColor, alpha * (1.0 - totalAlpha)); // Blend smoke color\n            totalAlpha += alpha; \n            if (totalAlpha >= 1.0) break; // Stop blending if fully opaque\n        }\n\n        tSmoke += d; // Step forward\n        if (tSmoke > 10.0) break; // Stop if ray goes too far\n    }\n\n    totalAlpha = clamp(totalAlpha, 0.0, 1.0); // Clamp accumulated alpha\n\n    float coffeeT = raymarchCoffeeCup(ro, rd);\n    if (coffeeT > 0.0 && coffeeT < 100.0) {\n        vec3 p = ro + coffeeT * rd;\n        vec3 normal = calcNormal(p); \n        vec3 color = vec3(0.9, 0.9, 0.9);\n        vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        col.rgb = mix(col.rgb, color * diffuse, 1.0);\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfyfW1","date":"1734136706","viewed":22,"name":"A train window","username":"Fireswood12","description":"Sitting at the window is a cup of hot coffee","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["scenic"],"hasliked":0,"parentid":"","parentname":""}}