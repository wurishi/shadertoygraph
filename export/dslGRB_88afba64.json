{"ver":"0.1","info":{"id":"dslGRB","date":"1666397077","viewed":179,"name":"public_Haru86_CyberpunkCity","username":"Haru86_","description":"Haru86_CyberpunkCity","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"mdlGR7","parentname":"Haru86_CyberpunkCity"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 330\n// ShaderToy --> OpenGL/GLSL Convert Preprocessor /////////////////////////////\n#define DRAW_ON_SHADERTOY\n\n#ifdef DRAW_ON_SHADERTOY\n#define _resolution iResolution\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define _time iTime\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\nconst int _RenderingTarget = 1;\nconst float _LeaveStartTime = 1.0;\n#else\nuniform float _time;\nuniform vec2 _resolution;\nuniform float _RenderingTarget;\nuniform vec3 _WorldCameraPos;\nuniform vec3 _WorldCameraCenter;\n\nuniform float _LeaveStartTime;\n\nin vec2 uv;\n#endif\n\n// Shared Preprocessor ////////////////////////////////////////////////////////\n#define pi 3.14159265\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin 0.0003\n#define tmax 30.0\n#define ldir normalize(vec3(1.0,1.0,-1.0))\n\n// Gloabal Valiable\nvec3 g_ro;\nint CameraIndex;\nfloat ln; // LoopNum\n\n// Useful Function ////////////////////////////////////////////////////////////\n\nstruct mapr // MapResult\n{\n   float d; // Distance\n   bool  hit;\n   int   m; // MaterialType\n            // 0: Debug\n            // 1: Common\n            // 2: CyberPunk\n};\n\nvoid compm(inout mapr mr,float d,int mt,bool IsMin) // CompareMap\n{\n    if(IsMin)\n    {\n        if(d<mr.d) mr = mapr(d,false,mt);\n        if(mr.d<dmin) mr.hit=true; \n    }\n    else\n    {\n        if(d>mr.d) mr = mapr(d,false,mt);\n        if(mr.d<dmin) mr.hit=true; \n    }\n}\n\nvec3 trs(vec3 p,vec3 s,vec3 r,vec3 t)\n{\n    p+=t; \n    p.yz*=rot(s.x);p.xz*=rot(s.y);p.xy*=rot(s.z);\n    p*=s;\n    \n    return p;\n}\n\nfloat modc(float a, float b){return a-b*floor(a/b);}\n\n// Noise Function /////////////////////////////////////////////////////////////\n\n// Distance Function\nfloat cube(vec3 p,vec3 s)\n{\n    return length(max(vec3(0.0), abs(p)-s));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n// https://www.shadertoy.com/view/MlfSWX\nfloat Mandel(vec3 p)\n{\n    const float mScale =  2.5;\n    const float dstFar = 30.0;\n    \n    vec4 q,q0;\n    const int nIter=30;\n    q0=vec4(p,1.0);\n    q=q0;\n    for(int n=0;n<nIter;n++)\n    {\n        q.xyz = clamp(q.xyz,-1.0,1.0)*2.0-q.xyz;\n        q*=mScale/clamp(dot(q.xyz,q.xyz), 0.5, 1.0);\n        q+=q0;\n        q.xyz+=g_ro*0.1;\n    }\n    \n    float d0 = length(q.xyz)/abs(q.w);\n    //float d0 = cube(q.xyz,vec3(1.0))/abs(q.w);\n    \n    if(CameraIndex == 0)\n    {\n        float d1 = PrCapsDf(p-g_ro,0.2,0.5);\n        return max(d0, -d1);\n    }\n    else\n    {\n        return d0;\n    }\n}\n\n// Ray Function ///////////////////////////////////////////////////////////////\nmapr map(vec3 p)\n{\n    mapr mr;\n    mr.d=1000.0;\n    mr.hit=false;\n    mr.m=-1;\n    \n    //{compm(mr,length(trs(p,vec3(1.0),vec3(0.0),vec3(0.0)))-0.5,2,true);}\n    {compm(mr, Mandel(p), 2,true);}\n    //{compm(mr,1.0+p.y /*cube(p, vec3(0.5))*/, 0, true);}\n    \n    return mr;\n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e=vec2(0.001,0.0);\n    return normalize(vec3(\n        map(p+e.xyy).d-map(p-e.xyy).d,\n        map(p+e.yxy).d-map(p-e.yxy).d,\n        map(p+e.yyx).d-map(p-e.yyx).d\n    ));\n}\n\n// Lighting ///////////////////////////////////////////\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\n// https://www.shadertoy.com/view/MsGGDK\nvec3 DrawCyberpunk(vec3 n,float t)\n{\n    vec3 h = vec3(1.0);\n    \n    vec3 c = fract(n*0.1);\n    vec3 d = abs(0.5-c)-0.5;\n    float b = 1.0,e = 0.0;\n    \n    for(int i=0;i<7;i++)\n    {\n        d = 0.5 - abs(0.5-fract(c*b))*3.0;\n        b*=3.0;\n        e = max(min(max(d.x, d.z), min(max(d.x, d.y), max(d.y, d.z))) / b, e);\n    }\n    \n    b=smoothstep(-(t*0.001+0.05), t*0.001+0.05, abs(0.5-fract(e*900.0))-0.4);\n    h=(b+0.01)*0.002*vec3(5.0,1.0,5.0);\n    \n    vec3 col = pow(h/(abs(h)+1.0), vec3(0.45));\n    \n    return col;\n}\n// https://github.com/i-saint/RaymarchingOnUnity5/blob/master/Assets/Raymarching/Raymarcher.shader\nvec2 DrawPattern(vec2 p)\n{\n    p=fract(p);\n    float r = 0.123;\n    float v=0.0,g=0.0;\n    r=fract(r*9184.928);\n    float cp,d;\n    \n    d=p.x;\n    g+=pow(clamp(1.0-abs(d), 0.0, 1.0), 1000.0);\n    d=p.y;\n    g+=pow(clamp(1.0-abs(d), 0.0, 1.0), 1000.0);\n    d=p.x - 1.0;\n    g+=pow(clamp(3.0-abs(d), 0.0, 1.0), 1000.0);\n    d=p.y - 1.0;\n    g+=pow(clamp(1.0-abs(d), 0.0, 1.0), 10000.0);\n    \n    const int ITER = 12;\n    for(int i=0; i<ITER; i++)\n    {\n      cp=0.5+(r-0.5)*0.9;\n      d=p.x-cp;\n      g+=pow(clamp(1.0-abs(d), 0.0, 1.0), 200.0);\n      if(d>0.0)\n      {\n          r=fract(r*4829.013);\n          p.x=(p.x-cp)/(1.0-cp);\n          v+=1.0;\n      }\n      else\n      {\n          r=fract(r*1239.528);\n          p.x=p.x/cp;\n      }\n      p=p.yx;\n    }\n    \n    v/=float(ITER);\n    return vec2(g,v);\n}\n\n// Main ///////////////////////////////////////////////////////////////////////\nvoid main()\n{\nif(_RenderingTarget==2) // ZTest\n{\n    gl_FragColor = vec4(vec3(0.0),1.0);\n}\nelse\n{\n#ifdef DRAW_ON_SHADERTOY\n    vec2 st=(gl_FragCoord.xy*2.-_resolution.xy)/min(_resolution.x,_resolution.y);\n#else\n    vec2 st=uv*2.0-1.0;\n    st.x*=(_resolution.x/_resolution.y);\n#endif\n    float zfactor=1.0-0.45*length(st);\n    CameraIndex = (fract(_time*0.1)<0.5)? 0 : 1;\n  \n    vec3 col = vec3(0.0),ro=vec3(0.0,0.0,1.5),ta=vec3(0.0,0.0,0.0);\n    if(CameraIndex == 0)\n    {\n        ln = 50.0;\n        \n        ro=vec3(0.0, 0.0, -5.5+mod(0.05*_time+1.0, 3.5));\n    }\n    else if(CameraIndex == 1)\n    {\n        ln = 128.0;\n        \n        ro=vec3(0.0, -5.5+mod(0.05*_time+1.0, 3.5), -5.5+mod(0.05*32.5+1.0, 3.5));\n        ta=ro+vec3(0.0,1.0,1.0);\n    }\n    \n    vec3 cdir=normalize(ta-ro),cside=normalize(cross(vec3(0.0,1.0,0.0),cdir)),\n    cup=normalize(cross(cdir,cside)),\n    rd=normalize(st.x*cside+st.y*cup+zfactor*cdir);\n    \n    //\n    g_ro = ro;\n    \n    float i=0.0,t=0.0,som=0.0,acc=0.0;mapr mr; // SumOfStep\n    for(;++i<ln;){mr=map(ro+rd*(t+=mr.d));if(mr.d<dmin||t>tmax)break;acc+=exp(-3.0*mr.d);}\n    som=i/float(ln);\n    \n    if(mr.hit)\n    {\n        if(mr.m == 0) // Debug\n        {\n            col = vec3(exp(-0.25*t));\n        }\n        else if(mr.m == 1) // Common\n        {\n            col = vec3(exp(-1.0*t));\n        }\n        else if(mr.m == 2) // Cyberpunk\n        {\n            vec3 p=ro+rd*t;\n            vec3 n = gn(p);\n            if(CameraIndex == 0)\n            {\n                col = vec3(1.0,0.8,0.6)*max(0.0, dot(normalize(vec3(1.0,-1.0,-1.0)),n));\n                col*=vec3(1.0)*max(0.0,1.0-0.5*som*som);\n            }\n            else\n            {\n                col=vec3(1.0,0.8,0.6)*15.0/i;\n            }\n            \n            float glow=0.0;\n            vec2 gp=DrawPattern(p.xz*0.5);\n            glow+=gp.x*max((modc(length(p)-_time*1.5*2.5, 10.0)-9.0)*2.5, 0.0);\n            //glow+=gp.x;\n            \n            if(gp.x<1.3){glow=0.0;}\n            // レイと垂直であるほど光らせる\n            glow+=max(1.0-abs(dot(rd,n)) - 0.4, 0.0) * 1.0;\n            vec3 glowcol=vec3(1.0,1.0,1.0)*glow*0.25;\n            \n            // reflect\n            if(CameraIndex == 0)\n            {\n                ro=p;\n                rd=reflect(rd,n);\n                t=0.1;\n                i=0.0;\n                mr=mapr(0.0,false,-1);\n                for(;++i<ln*0.5;){mr=map(ro+rd*(t+=mr.d));if(mr.d<dmin||t>tmax)break;}\n                som=i/float(ln*0.5);\n                //col+=vec3(0.0,0.0,1.0)*exp(-1.0*t)*0.1;\n                col+=vec3(1.0)*som*0.5;\n            }\n            \n            col.r=pow(col.r,2.2);\n            col.g=pow(col.g,2.2);\n            col.b=pow(col.b,2.2);\n            col=clamp(col,vec3(0.0),vec3(1.0));\n            \n            col+=glowcol;\n        }\n        \n    }\n    \n    gl_FragColor = vec4(col,1.0);\n}\n\n}","name":"Image","description":"","type":"image"}]}