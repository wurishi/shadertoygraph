{"ver":"0.1","info":{"id":"4fBBDy","date":"1729282116","viewed":156,"name":"Pre-filtered resample pipeline","username":"sh1boot","description":"A test using structured, separable blur on source image with dynamic cutoff according to the expected distortion; then sampling that without any post-filtering for anti-aliasing.\n\nHold SHIFT to see without blurring.\nPress Z to zoom.\n","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["antialiasing","prefilter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (ENABLE_ZOOM) {\n        fragCoord -= 0.5;\n        fragCoord = round(fragCoord * 0.5);\n        fragCoord += 0.5;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (texelFetch(iChannel3, ivec2(48,0), 0).x >= 0.5) {\n        fragColour = texture(iChannel0, uv);\n    } else if (texelFetch(iChannel3, ivec2(49,0), 0).x >= 0.5) {\n        fragColour = texture(iChannel1, uv);\n    } else if (texelFetch(iChannel3, ivec2(50,0), 0).x >= 0.5) {\n        fragColour = texture(iChannel2, uv);\n    } else {\n        uv = warp(uv, iTime);\n        vec2 m = fwidth(uv) * 1.4;\n        m = smoothstep(-m, m, 0.5 - abs(uv - 0.5));\n        fragColour = texture(iChannel2, uv) * m.x * m.y;\n    }\n    // linear -> sRGB\n    fragColour.xyz = pow(fragColour.xyz, gamma);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copy source texture into reference buffer A;\n// The output only changes if space or tab are pressed,\n// or if it's the very first frame.\n\n// sRGB -> linear\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (iFrame < 60 || REPOSITION || TEXTURE_CHANGE) {\n        vec2 o = (sin(iTime * vec2(0.3,0.31) + vec2(0.0, 1.6)) + 1.0) * 300.0;\n        if (ALTERNATE_TEXTURE) {\n            fragColour = texelFetch(iChannel1, ivec2(fragCoord + o) % ivec2(iChannelResolution[1].xy), 0);\n        } else {\n            fragColour = texelFetch(iChannel0, ivec2(fragCoord + o) % ivec2(iChannelResolution[0].xy), 0);\n        }\n        fragColour.xyz = pow(fragColour.xyz, 1.0/gamma);\n    } else {\n        fragColour = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// structured filter kernel size (actually twice this, plus one)\nconst int window_size = 5;\n\n// gamma correction\nconst vec3 gamma = vec3(2.4);\n\n// half tau\nconst float pi = 3.14159265358979;\n\n// Given the screen coordinate pointing to the current uv coordinate,\n// calculate the cutoff frequency for the uv coordinate which corresponds\n// to unit steps in screen coordinates.\n//\n// That is; if the distance between screen coordinates which would sample\n// adjacent texture pixels is 0.5 then adjacent screen pixels would sample\n// texture pixels 2.0 apart, meaning we're minifying by a factor of 2:1 and\n// need to cutt off frequency content above 0.5f_s and the answer is 0.5.\n// So the filter cut-off frequency works out to be just the distance\n// between screen coordinates sampling adjacent texture pixels.\n//\n// Of course it's slightly more complicated because it's a 2D problem, and\n// distortion on one axis should affect the measurement of the other axis.\n// But this seems close enough.  If you want to be more precise, edit the\n// function below.\n//\n// If the distance is more than 1.0 then we're magnifying and a cut-off of\n// 1.0 is appropriate (beyond that there's nothing but aliasing).  Also\n// clamp very small steps out of fear of numerical instability.\n//\nfloat get_filter(vec2 p, bool vertical) {\n    p = vec2(abs(dFdx(p.x)), abs(dFdy(p.y)));\n    float pd = vertical ? p.y : p.x;\n    float f_c = clamp(pd, 0.001, 1.0);\n    \n    // An all-pass filter is just going to cause trouble.  Trim it down\n    // a bit, balancing blurring of overly sharp edges against passing\n    // aliasing in extreme cases.  Want to compromise less?  Use a\n    // bigger kernel.\n    return f_c * 0.875;\n}\n\n\n#define SHIFT_DOWN (texelFetch(iChannel3, ivec2(16,0),0).x >= 0.5)\n#define SPACE_DOWN (texelFetch(iChannel3, ivec2(32,0),0).x >= 0.5)\n#define TAB_CHANGE (texelFetch(iChannel3, ivec2(9,1),0).x >= 0.5)\n#define TAB_TOGGLE (texelFetch(iChannel3, ivec2(9,2),0).x >= 0.5)\n#define X_TOGGLE   (texelFetch(iChannel3, ivec2(88,2),0).x >= 0.5)\n#define Y_TOGGLE   (texelFetch(iChannel3, ivec2(89,2),0).x >= 0.5)\n#define Z_TOGGLE   (texelFetch(iChannel3, ivec2(90,2),0).x >= 0.5)\n\n\n#define ENABLE_ZOOM       Z_TOGGLE\n#define ALTERNATE_TEXTURE TAB_TOGGLE\n#define TEXTURE_CHANGE    TAB_CHANGE\n#define REPOSITION        SPACE_DOWN\n#define BYPASS_FILTER     SHIFT_DOWN\n#define ENABLE_X_METRIC   X_TOGGLE\n#define ENABLE_Y_METRIC   Y_TOGGLE\n\nfloat sinc(float x) {\n    if (abs(x) > 0.0) {\n        x *= pi;\n        return sin(x) / x;\n    }\n    return 1.0;\n}\n\n\nfloat w(int i, float f) {\n    return sinc(float(i) * f) * sinc(float(i) / float(window_size + 1));\n}\n\n\nconst float skew = 1.8;\nfloat rolloff(float x) {\n    return atanh(x * skew) / skew;\n}\n\nfloat invrolloff(float x) {\n    return tanh(x * skew) / skew;\n}\n\nvec2 origin(float t) {\n    return sin(vec2(0.0, 1.4) + t * 0.5) * 0.4 + 0.5;\n}\n\nvec2 warp(vec2 xy, float iTime) {\n    vec2 uv = xy;\n    vec2 c = origin(iTime);\n    uv -= c;\n    float r = 1.0 * length(uv);\n    if (r > 0.01) {\n        uv *= rolloff(r) / r;\n    }\n    return uv + c;\n}\n\n// When iterating across texture space, calculate the pixel coordinates\n// which would sample from this coordinate via warp().\nvec2 unwarp(vec2 uv, float iTime) {\n    vec2 xy = uv;\n    vec2 c = origin(iTime);\n    xy -= c;\n    float r = 1.0 * length(xy);\n    if (r > 0.01) {\n        xy *= invrolloff(r) / r;\n    }\n    return xy + c;\n}\n\n// Debugging tool; map 0.5-2.0 to blue-green-red in log space, and add\n// white stripes every power of two beyond that.\nvec4 colourmap(float x) {\n    x = log2(x) * 1.0;\n    vec4 result = vec4(\n        smoothstep(0.0, 0.1, x),\n        1.0-smoothstep(0.1, .8, abs(x)),\n        smoothstep(0.0, 0.1, -x),\n        1.0\n    );\n    if (fract(x) < 0.02 || fract(x) > 0.98) {\n        result = vec4(1);\n    }\n    return result;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Apply a horizontal blur with dynamic cutoff.\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (BYPASS_FILTER) {\n        fragColour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 res = iResolution.xy;\n    float f_c = get_filter(res * unwarp(fragCoord / res, iTime), false);\n    vec4 v = vec4(0);\n    float d = 0.0;\n    for (int i = -window_size; i <= window_size; ++i) {\n        ivec2 c = ivec2(i, 0) + ivec2(fragCoord);\n        c = clamp(c, ivec2(0), ivec2(res - 1.0));\n        float weight = w(i, f_c);\n        v += weight * texelFetch(iChannel0, c, 0);\n        d += weight;\n    }\n    fragColour = v / d;\n\n    if ((int(fragCoord.y) / 4) % 3 == 1 && ENABLE_X_METRIC) {\n        fragColour = colourmap(f_c);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Apply a vertical blur with dynamic cutoff.\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (BYPASS_FILTER) {\n        fragColour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 res = iResolution.xy;\n    float f_c = get_filter(res * unwarp(fragCoord / res, iTime), true);\n    vec4 v = vec4(0);\n    float d = 0.0;\n    for (int i = -window_size; i <= window_size; ++i) {\n        ivec2 c = ivec2(0, i) + ivec2(fragCoord);\n        c = clamp(c, ivec2(0), ivec2(res - 1.0));\n        float weight = w(i, f_c);\n        v += weight * texelFetch(iChannel0, c, 0);\n        d += weight;\n    }\n    fragColour = v / d;\n\n    if ((int(fragCoord.x) / 4) % 3 == 1 && ENABLE_Y_METRIC) {\n        fragColour = colourmap(f_c);\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}