{"ver":"0.1","info":{"id":"7ltXDl","date":"1640019699","viewed":961,"name":"balls are rubbing","username":"panna_pudi","description":"no touching, no gay\nhttps://www.shadertoy.com/view/MdlGWn","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","light","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'balls are rubbing' by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nvec3 gauss(vec3 x) {\n    return 1. / sqrt(2. * PI) * exp(-(x / 0.2) * (x / 0.2));\n}\n\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// https://www.desmos.com/calculator/4vcidnhumk\nvec3 displace_area(vec3 x, float i) {\n    vec4 p = hash41(i) * 2. - 1.;\n    vec3 q = hash41(i + 10.).xyz * 2. - 1.;\n    float r = 2.;\n    return exp(-4. * length(x) * length(x)) *\n           (1. * p.x * gauss(q + p.y * r) + 1. * p.z * gauss(q + p.w * r));\n}\n\nfloat sd_sphere(vec3 p) {\n    return length(p) - 0.2;\n}\n\nconst int BALL_COUNT = 15;\nvec3 BALLS[BALL_COUNT];\n\nvec3 erot(vec3 ax, vec3 p, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid update_balls(float t) {\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        float a = float(i) / float(BALL_COUNT) * TAU + t * 0.5;\n        vec3 p = 5. * vec3(cos(a), sin(a) * cos(a), 0.);\n        p += 6. * displace_area(p, float(i));\n        \n        float orientation = PI / 4. * smoothstep(-1., 1., p.x);\n        p.yz *= rot(orientation  + 3. * PI / 4.);\n        BALLS[i] = 3. * p;\n    }\n}\n\nfloat bfield(vec3 p) {\n    float force = 0.;\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        vec3 b = p - BALLS[i];\n        float r = 10. - length(p);\n        float intensity = (smoothstep(0., 4., r) * 2.5 + 0.9) / dot(b, b);\n        /* float intensity = 1. / dot(b, b); */\n\n        force += intensity;\n    }\n\n    return 1.0 - force;\n}\n\nfloat glow_r = 0.;\nfloat glow_b = 0.;\nfloat map(vec3 p) {\n    float time = iTime;\n    float dist = 1e5;\n    vec3 off = hash41(time * 7.).xyz * 0.03;\n\n    dist = bfield(p);\n\n    // sp4ghet https://www.shadertoy.com/view/7sKXRV\n    {\n        vec3 q = p - vec3(10.0, 0.0, 0.0) + off;\n        q.yz *= rot(PI / 1.6);\n        q.xz *= rot(PI / 3.2);\n        float sp = length(q.xz - .03 * q.y * q.y) - .04;\n        glow_r += .08 / (sp * sp + .02);\n        dist = min(dist, sp);\n    }\n\n    {\n        vec3 q = p - vec3(-10.0, 0.0, 0.0) + off;\n        q.yz *= rot(PI / 0.6);\n        float sp = length(q.xz + .029 * q.y * q.y) - .001;\n        glow_b += .08 / (sp * sp + .02);\n        dist = min(dist, sp);\n    }\n\n    return dist;\n}\n\nvec3 get_normal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nvec3 sky(vec3 rd){\n    vec3 col = vec3(0.);\n    col += mix(0.12 * vec3(0.15, 0.1, 1.0), 0.1 * vec3(0.85, 0.9, 1.0),\n               0.5 + 0.5 * normalize(rd).y);\n    col += smoothstep(0.2, 1.5, dot(rd, normalize(vec3(0., -1., 0.)))) * 1.1 *\n           vec3(0.67843, 0.67451, 0.709);\n    col += smoothstep(.2, 1.0, dot(rd, normalize(vec3(10, 1, 1)))) * 0.1 *\n           vec3(0.3647, 0.2902, 0.63137);\n\n    return col;\n}\n\nvec3 trace(in vec3 ro, in vec3 rd, in float t, in float tmax) {\n    float t_prev = t;\n    vec3 accum = sky(rd);// vec3(1.);\n    for(int bounce = 0; bounce < 2; bounce++){\n        for (int i = 0; i < 25; i++) {\n            float d = map(ro + rd * t);\n            if (d < 0.01 * t) {\n                // adjust samples\n                for (int i = 0; i < 5; ++i) {\n                    float t_mean = (t_prev + t) / 2.;\n                    if (map(ro + rd * t_mean) < 0.01 * t_mean) { t = t_mean;\n                    } else { t_prev = t_mean; }\n                }\n\n                vec3 pos = ro + rd * t;\n                vec3 nor = get_normal(pos);\n\n                // bottom light\n                accum += 0.1 * clamp(0.5 - 0.5 * nor.y, 0., 1.);\n\n                float fresnel = mix(0.003, 1., pow(1. - dot(-rd, nor), 5.));\n                accum *= fresnel;\n\n                accum += 0.01 * sky(reflect(rd, nor));\n\n                ro = pos + nor * .01;\n                rd = reflect(rd, nor);\n                break;\n            }\n            t_prev = t;\n            t += d * 1.5;\n            if (t > tmax) {\n                /* accum += sky(reflect(rd, nor); */\n                return accum;\n            };\n        }\n    }\n    return accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(iResolution.x / iResolution.y, 1.);\n    \n    float time = iTime;\n\n    update_balls(time);\n\n    vec3 ro = vec3(0., 0., -26.);\n    vec3 rd = normalize(vec3(uv, 2.));\n\n    float t_max = 36.;\n    vec3 col = sky(rd);\n    col = trace(ro, rd, 0., t_max);\n\n    vec3 cglow_r = vec3(.9, .15, .1) ;\n    vec3 cglow_b =  vec3(0.1, 0.2, 0.9);\n    col += cglow_r * glow_r + cglow_b * glow_b;\n    \n    float scale = 70.;\n    float light = dot(uv, uv) * 0.5 - 1.3;\n    float dir = dot(uv * scale, normalize(vec2(-1, 1)));\n    float pix = fwidth(uv * scale).x;\n    float stripes = abs(fract(dir) - 0.5) + (light * 0.5 - 0.5);\n    col *= mix(vec3(0.), vec3(1.), smoothstep(pix, -pix, stripes));\n    \n    fragColor = vec4(pow(col, vec3(0.4545)),1.0);\n}","name":"Image","description":"","type":"image"}]}