{"ver":"0.1","info":{"id":"MdVfzy","date":"1529427049","viewed":221,"name":"Textured Box","username":"Veggiebob","description":"Textured box using distance fields. Man, do I like this program.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["distancefield","texture","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float border = 0.998;\nconst float groundHeight = -0.5;\nvec4 contrast (vec4 col, float n){\n    return 0.5+(col-0.5)*n;\n}\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box (vec4 box, vec2 pos){\n    float n = align(abs(pos.x-box.x), box.z)+align(abs(pos.y-box.y), box.w);\n    return n;\n}    \nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nbool hitBox (vec3 boxPos, vec3 boxSize, vec3 pos){//pos inside box?\n    return (pos.x>boxPos.x&&pos.y>boxPos.y&&pos.z>boxPos.z && pos.x<boxPos.x+boxSize.x&&pos.y<boxPos.y+boxSize.y&&pos.z<boxPos.z+boxSize.z);\n}\nvec4 traceBox (vec3 o, vec3 r, vec3 boxPos, vec3 boxSize){\n    vec3 p = vec3(0.);\n    float t = 0.;\n    for(int i = 0; i<128; i++){//get on the box\n        p = o+r*t;\n        float d = box3D(boxPos, boxSize, p);\n        t+=d*0.6;\n    }\n    float hitTheBox = 0.;//the side type identifier\n    vec2 xy = vec2(0.);//the place of the texture to get\n    float yDiff = abs(p.y-boxPos.y);\n    float xDiff = abs(p.x-boxPos.x);\n    float zDiff = abs(p.z-boxPos.z);\n    float bd = 0.;\n    p /= boxSize*2.;\n    //check which side it's on so that we can orient the texture correctly\n    if(yDiff<boxSize.y*border){\n        if(xDiff<=boxSize.x*border){\n    \t\txy = p.xy;\n            hitTheBox = 1.;//the xy-side\n        } else {\n            xy = p.yz;\n            hitTheBox = 2.;//the yz-side\n        }\n    } else {\n        if(zDiff<=boxSize.z*border){\n        \txy = p.xz;\n        \thitTheBox = 3.;//the xz-side (top & bottom)\n        }\n    }\n    return vec4(xy-0.5, t, hitTheBox);\n}\nfloat sphere (vec3 r, vec3 o, float radius){\n    return length(o-r)-radius;\n}\nvec4 traceSphere (vec3 o, vec3 r, vec3 pos, float radius){\n    float t = 0.0;\n    vec3 p;\n    for(int i = 0; i<32; ++i){\n        p = o+r*t;\n        float d = sphere(p, pos, radius);\n        t += d*0.5;\n    }\n    float rad = length(p-pos)/radius;//percent of radius??\n    vec2 xy = (p.xy+p.yz+p.xz)*0.2;\n    return vec4(xy, t, rad);\n}\nvec3 checkGround (vec3 o, vec3 r){\n    float t = 0.;\n    vec3 p = vec3(0.);\n    for(int i = 0; i<32; i++){\n        p = o+r*t;\n        float d = p.y-groundHeight;\n        t+=d*0.5;\n    }\n    vec2 xy = p.xz*0.2;\n    return vec3(xy, t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=6.5;\n    mouse.y*=-1.;\n    \n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = 2.7;\n    vec3 camera = vec3(cos(mouse.x)*camDist, max(mouse.y*camDist, groundHeight+0.5), sin(mouse.x)*camDist);//vec3(mouse*5., -2.);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., -mouse.y+uv.y, -sin(mouse.x+uv.x*fov)*2.);//vec3(uv+mouse, 0.)-camera;\n    ray = normalize(ray);\n    \n    //initialize box variables\n    float dist = 10000.;\n    vec3 finalCol = vec3(0.);\n    vec3 boxPos = vec3(-1.);\n    vec3 boxSize = vec3(-1.);\n    vec4 v = traceBox(camera, ray, boxPos, boxSize);\n    \n    //for each box:\n    /*\n\t>> things in all caps are things that you need to fill in <<\n\t\n\tboxPos = vec3( COORDS );\n    boxSize = vec3( SIZE );\n    v = traceBox(camera, ray, boxPos, boxSize);\n    if(v.w>0.&&v.z<dist){//hits the box\n        dist = v.z;//v.z is the distance, trust me\n    \tfinalCol = texture(TEXTURE, v.xy).rgb;//give it the nice texture\n    }\n\t\n\t>> if you want, v.w stands for the type of side it is. Check traceBox() for more info <<\n\t*/\n    //BOX: \"Contrasty Rusty\"\n    boxPos = vec3(0., 0., 0.);\n    boxSize = vec3(.3, .3, .3);\n    v = traceBox(camera, ray, boxPos, boxSize);\n    if(v.w>0.&&v.z<dist){//hits the box\n        dist = v.z;//v.z is the distance, trust me\n    \tfinalCol = contrast(texture(iChannel0, v.xy), 5.).rgb;//give it the nice texture\n    }\n    //BOX: \"The Camera Button\"\n    boxPos = vec3( -0.3, 0., 0. );\n    boxSize = vec3( 0.1 );\n    v = traceBox(camera, ray, boxPos, boxSize);\n    if(v.w>0.&&v.z<dist){//hits the box\n        dist = v.z;//v.z is the distance, trust me\n        if(v.w==2.){\n    \t\tfinalCol = texture(iChannel1, v.xy).rgb;//give it the nice texture\n        } else {\n            finalCol = texture(iChannel2, v.xy).rgb;\n        }\n    }\n    //BOX: \"The Obnoxious Copy-Cat\"\n    boxPos = vec3( sin(iTime*3.)*0.3, cos(iTime)*0.3, sin(iTime)*0.3 );\n    boxSize = vec3( 0.28 );\n    v = traceBox(camera, ray, boxPos, boxSize);\n    if(v.w>0.&&v.z<dist){//hits the box\n        dist = v.z;//v.z is the distance, trust me\n    \tfinalCol = contrast(texture(iChannel0, v.xy).rgba, 2.).rgb;//give it the nice texture\n    }\n    //BOX: \"The Ground Flat? Checker\"\n    boxPos = vec3( 0., groundHeight, 0. );\n    boxSize = vec3( 10., 0.1, 10. );\n    v = traceBox(camera, ray, boxPos, boxSize);\n    if(v.w>0.&&v.z<dist){//hits the box\n        dist = v.z;//v.z is the distance, trust me\n    \tfinalCol = texture(iChannel0, v.xy).rgb;//give it the nice texture\n    }\n    \n    \n    float fog = 1.0 / (1.0 + dist*dist*0.03);\n    vec3 tt = checkGround(camera, ray);//ground\n    if(tt.z<dist){\n        vec4 s = traceSphere(camera, ray, vec3(0.), 15.);//sky\n        if(ray.y>=0.04&&s.w<dist){\n            finalCol = texture(iChannel3, s.xy).rgb;\n            fog = 1.0 / (1.0 + dist*dist*0.3);\n            finalCol = contrast(finalCol.rgbr, 3.).rgb;\n            fog = 0.2;\n        } else {\n            finalCol = texture(iChannel2, tt.xy).rgb;\n            finalCol = contrast(finalCol.rgbr, 0.8).rgb;\n            dist = tt.z;\n            fog = 1.0 / (1.0 + dist*dist*0.03);\n        }\n    }\n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(finalCol*fog,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float total (vec3 col){\n    return col.r+col.g+col.b;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//para hacer \"Minecraft texture\"\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    if (total(col)<=1.||fract(iTime)<0.1){\n        float n = texture(iChannel1, uv).r;\n        float noise = 0.5+(n-0.5)*0.5;\n        noise = max(noise, 0.5);\n        if (uv.y>0.9-sqrt(n)*0.8+0.4){\n            col = vec3(0., 1., 0.)*noise;\n        } else {\n            col = vec3(0.5, 0.25, 0.)*noise;\n        }\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buf A","description":"","type":"buffer"}]}