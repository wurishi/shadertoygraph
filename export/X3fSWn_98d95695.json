{"ver":"0.1","info":{"id":"X3fSWn","date":"1712164963","viewed":34,"name":"Samie Bee's RDF Scene","username":"SamyBencherif","description":"This is a demonstration of Raymarch Distance Fields used to create 3D geometry within a fragment shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A hands on introduction to Raymarch Distance Fields\n// based on https://adrianb.io/2016/10/01/raymarching.html#introduction-to-raymarching\n// referenced https://www.shadertoy.com/view/ftcfWX by PrenexNormalForm\n// referenced https://www.shadertoy.com/view/Xds3zN by iq\n// Authored by Samie Bee on 2024-03-01\n\nconst float PI = 3.14159;\n\nvec3 camera_position = vec3(0., 0., -10.);\nvec3 camera_forward = vec3(0., 0., 1.); // face towards blue\nvec3 camera_up = vec3(0., 1., 0.);\n\nfloat camera_fov = 60. * PI / 180.;\n\nvec3 sunLight = vec3(-.5, -.5, 0.);\n\n// sd functions return vec4 .xyz is color and .w is distance\n\nvec4 sdSphere(vec3 p, vec3 l, float s)\n{\n    return vec4(0., 0., 0., length(p-l) - s);\n}\n\nvec4 sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return vec4(0., 0., 0., length(q) - t.y);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.w<d2.w) ? d1 : d2;\n}\n\nvec4 map(vec3 p) {\n    return opU(sdTorus(p, vec2(1, 0.2)), sdSphere(p, vec3(1.,2.,0.), 1.));\n}\n\nvec3 rot(vec3 v, float x, float y, float z)\n{\n    /* rotate vector v by x,y,z radians */\n    \n    mat3 rotx = mat3(1., 0., 0., \n                     0., cos(x), -sin(x), \n                     0., sin(x), cos(x));\n    mat3 roty = mat3(cos(y), 0., sin(y), \n                     0., 1., 0., \n                     -sin(y), 0., cos(y));\n    mat3 rotz = mat3(cos(z), -sin(z), 0., \n                     sin(z), cos(z), 0., \n                     0., 0., 1.);\n    \n    return (rotz*roty*rotx*v);\n}\n\nmat4 getFrustrumCorners()\n{\n    float aspect = iResolution.y / iResolution.x;\n    mat4 frustrumCorners;\n    float fovWHalf = camera_fov * .5;\n    float tan_fov = tan(fovWHalf);\n    vec3 camera_right = cross(camera_forward, camera_up);\n    vec3 toRight = camera_right * tan_fov / aspect;\n    vec3 toUp = camera_up * tan_fov;\n    vec3 topLeft = camera_forward - toRight + toUp;\n    vec3 topRight = camera_forward + toRight + toUp;\n    vec3 bottomRight = camera_forward + toRight - toUp;\n    vec3 bottomLeft = camera_forward - toRight - toUp;\n    \n    frustrumCorners[0] = vec4(topLeft, 0.);\n    frustrumCorners[1] = vec4(topRight, 0.);\n    frustrumCorners[2] = vec4(bottomRight, 0.);\n    frustrumCorners[3] = vec4(bottomLeft, 0.);\n    \n    return frustrumCorners;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    // epsilon - used to approximate dx when taking the derivative\n    const vec2 eps = vec2(0.001, 0.0);\n\n    // The idea here is to find the \"gradient\" of the distance field at pos\n    // Remember, the distance field is not boolean - even if you are inside an object\n    // the number is negative, so this calculation still works.\n    // Essentially you are approximating the derivative of the distance field at this point.\n    vec3 nor = vec3(\n        map(pos + eps.xyy).w - map(pos - eps.xyy).w,\n        map(pos + eps.yxy).w - map(pos - eps.yxy).w,\n        map(pos + eps.yyx).w - map(pos - eps.yyx).w);\n    return normalize(nor);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    vec4 ret = vec4(0., 0., 0., 0.);\n    \n    const int maxstep = 64;\n    float t = 0.;\n    for (int i=0; i<maxstep; i++)\n    {\n        vec3 p = ro + rd*t;\n        float d = map(p).w;\n        \n        if (d < .001)\n        {\n            // return shaded normal if we hit object\n            vec3 n = calcNormal(p);\n            ret = vec4(vec3(dot(-sunLight, n)), 1);\n            break;\n        }\n        \n        t += d;\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // spin camera based on Mouse\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float rot_x = 2.*PI*mouse.y;\n    float rot_y = 2.*PI*mouse.x;\n    float rot_z = 0.;\n    camera_position = rot(vec3(0.,0.,-10.), rot_x, rot_y, rot_z);\n    camera_forward = rot(vec3(0.,0.,1.), rot_x, rot_y, rot_z);\n    camera_up = rot(vec3(0.,1.,0.), rot_x, rot_y, rot_z);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Determine a 3D ray coming from the camera_position, display it as a color\n    mat4 corners = getFrustrumCorners();\n    vec4 topInterp = corners[0] + (corners[1] - corners[0]) * uv.x;\n    vec4 bottomInterp = corners[3] + (corners[2] - corners[3]) * uv.x;\n    vec3 ray = (topInterp + (bottomInterp-topInterp)*uv.y).xyz;\n    \n    // Output to screen\n    fragColor = vec4(ray, 1.) + raymarch(camera_position, ray);\n    \n    // Why isn't the screen blue? Aren't we looking in the <0,0,1> direction?\n}","name":"Image","description":"","type":"image"}]}