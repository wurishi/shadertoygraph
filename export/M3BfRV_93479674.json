{"ver":"0.1","info":{"id":"M3BfRV","date":"1729685949","viewed":69,"name":"red box","username":"kukuzhang","description":"red box","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","red","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 定义一个简单的正方体顶点着色器\nvec4 position(float x, float y, float z) {\n    return vec4(x, y, z, 1.0);\n}\n\n// 定义一个简单的片段着色器\nvec4 fragment(vec3 fragCoord) {\n    // 计算距离原点的距离\n    float distance = length(fragCoord);\n\n    // 根据距离计算颜色，越远越暗\n    vec3 color = vec3(0.0);\n    if (distance < 0.5) {\n        // 计算闪烁效果，使用正弦波来模拟\n        float time = iTime;\n        float intensity = sin(time * 5.0) * 0.5 + 0.5; // 0.0到1.0之间变化\n        color = vec3(intensity); // 红色光\n    }\n\n    // 返回颜色\n    return vec4(color * 2.0, 1.0); // 乘以2.0来增强颜色\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 正方体的8个顶点\n    vec4 vertices[8];\n    vertices[0] = position(-1.0, -1.0,  1.0);\n    vertices[1] = position( 1.0, -1.0,  1.0);\n    vertices[2] = position( 1.0,  1.0,  1.0);\n    vertices[3] = position(-1.0,  1.0,  1.0);\n    vertices[4] = position(-1.0, -1.0, -1.0);\n    vertices[5] = position( 1.0, -1.0, -1.0);\n    vertices[6] = position( 1.0,  1.0, -1.0);\n    vertices[7] = position(-1.0,  1.0, -1.0);\n\n    // 正方体的6个面\n    vec3 edges[12];\n    edges[0] = normalize(vertices[1].xyz - vertices[0].xyz);\n    edges[1] = normalize(vertices[2].xyz - vertices[1].xyz);\n    edges[2] = normalize(vertices[3].xyz - vertices[2].xyz);\n    edges[3] = normalize(vertices[0].xyz - vertices[3].xyz);\n    edges[4] = normalize(vertices[5].xyz - vertices[4].xyz);\n    edges[5] = normalize(vertices[6].xyz - vertices[5].xyz);\n    edges[6] = normalize(vertices[7].xyz - vertices[6].xyz);\n    edges[7] = normalize(vertices[4].xyz - vertices[7].xyz);\n    edges[8] = normalize(vertices[4].xyz - vertices[0].xyz);\n    edges[9] = normalize(vertices[5].xyz - vertices[1].xyz);\n    edges[10] = normalize(vertices[6].xyz - vertices[2].xyz);\n    edges[11] = normalize(vertices[7].xyz - vertices[3].xyz);\n\n    // 计算射线与正方体的交点\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirection = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, 1.0));\n    float tMin = 0.0;\n    float tMax = 100.0;\n    float t = 0.0;\n    vec3 hit = vec3(0.0);\n    bool hitAnything = false;\n\n    for (int i = 0; i < 6; i++) {\n        vec3 edge0 = edges[i * 2];\n        vec3 edge1 = edges[i * 2 + 1];\n        vec3 p = cross(rayDirection, edge0);\n        float det = dot(p, edge1);\n        if (abs(det) > 0.001) {\n            vec3 tvec = rayOrigin - dot(edge1, rayOrigin) * p / det;\n            float u = dot(tvec, edge0) / det;\n            if (u >= 0.0 && u <= 1.0) {\n                float v = dot(rayOrigin - edge0 * u, p) / det;\n                if (v >= 0.0 && v <= 1.0) {\n                    t = dot(rayOrigin - tvec, rayDirection) / det;\n                    if (t > tMin && t < tMax) {\n                        tMin = t;\n                        hit = rayOrigin + rayDirection * t;\n                        hitAnything = true;\n                    }\n                }\n            }\n        }\n    }\n\n    if (hitAnything) {\n        fragColor = fragment(hit);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // 背景为黑色\n    }\n}","name":"Image","description":"","type":"image"}]}