{"ver":"0.1","info":{"id":"cdKXRD","date":"1680851271","viewed":44,"name":"Fake Moire","username":"alebarbieri","description":"Trying to replicate the moire present in silk and similar textiles.\nSomething like this https://cdn.wallpapersafari.com/14/82/a3pF5w.jpg","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","displacement","lines","blackandwhite","moire","stripes","zebra","distorsion","frequencies","bnw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// pseudorandom canonical function from 'On generating random numbers, \n// with help of y= [(a+x)sin(bx)] mod 1\", W.J.J. Rey, 22nd European\n// Meeting of Statisticians and the 7th Vilnius Conference on Probability\n// Theory and Mathematical Statistics, August 1998'\n// aka the random generator everyone uses :)\n#define R(x) fract(sin(dot(x,vec2(12.9898,78.233))) * 43758.5453)\n#define PI 3.14159265\n\n// linear wiggle function\nfloat hardWiggle(float time, float frequency, float seed)\n{\n    // Update wave frequency\n    time *= frequency;\n   \n    // Generate random numbers\n    float a = R(vec2(floor(time), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(time), seed)) * 2.0 - 1.0;\n    \n    // Make sure time is a number between 0 and 1 \n    time -= floor(time);\n    \n    // Generate a number which is halfway betweeen random number a and random number b\n    return mix(a, b, time);\n}\n\n// linear wiggle function that allows details by increasing the octaves parameter\nfloat wiggle(float t, float frequency, int octaves, float seed)\n{\n    float w = 0.0;\n    \n    // Generate random numbers\n    for(int i = 1; i <= octaves; i++)\n    {\n        float f = float(i * i);\n        w += hardWiggle(t, frequency * f, seed) / f;\n    }\n    \n    return w;\n}\n\n// smooth wiggle version, super handy!\nfloat smoothwiggle(float t, float frequency, float seed)\n{\n    t *= frequency;\n    float a = R(vec2(floor(t), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(t), seed)) * 2.0 - 1.0;\n    \n    t -= floor(t);\n    \n    return mix(a, b, sin(t * t * PI / 2.0)); // fake smooth blend\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float thicknessModifier = hardWiggle(uv.y * 1., 1., 123.);\n    \n    float frequency = 20.;\n    \n    // Thickness should go from 1. to the frequency.\n    float thickness = 1.5;\n    \n    // Antialias must be a number between 0. and 0.99\n    float antialias = 0.5;\n    \n    vec2 coord = uv;\n    \n    coord.y += wiggle(uv.x * 10. + iTime * 0.3, 3., 6, 123.) * 0.1 - 0.5;\n    coord.y = mix(coord.y, coord.y + thicknessModifier, sin(coord.y * smoothwiggle(iTime, 2., 123.) * 3.));\n    coord.y *= frequency;\n\n    // In the link below it's explained the mathematical approach to create lines \n    // (see comments who link to graphtoy).\n    // https://www.shadertoy.com/view/DsVSzw\n    \n    float gradient1 = 1. - fract(coord.y);\n    float zigzag1 = (gradient1) * step(fract(coord.y * 0.5), 0.5);\n    \n    float gradient2 = fract(coord.y);\n    float zigzag2 = fract(coord.y) * step(fract((coord.y + 1.) * 0.5), 0.5);\n    \n    float zigzag = zigzag2 + zigzag1;\n    \n    vec3 col = vec3(smoothstep(1. - antialias, 1., zigzag * thickness));\n    \n    \n    fragColor = vec4(col, 1.0);\n    // fragColor = vec4(coord.yyy, 1.0);\n}","name":"Image","description":"","type":"image"}]}