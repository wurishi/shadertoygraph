{"ver":"0.1","info":{"id":"MlfXz7","date":"1435268486","viewed":591,"name":"Transparent Gyro","username":"834144373","description":"But now,I know her name....\nTry your mouse move x and y.....","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["transparent","fresnel","nbnobeautiful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//thx for shadertoy give me a more interesting world\n//The Transparent Gyro made by 834144373zhu\n//https://www.shadertoy.com/view/MlfXz7\n/////////////////////////////////////////////////\n#define time iTime\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\tca, .0, -sa,\n\t\t.0,1.0, .0,\n\t\tsa, .0, ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t1.0, .0, .0,\n\t\t .0, ca, -sa,\n\t\t .0, sa, ca);\n}\n\nvec3 rotate_z(vec3 v,float angle){\n\tfloat ca = cos(angle),sa = sin(angle);\n    return v*mat3(\n    \tca,-sa,0.,\n        sa, ca,0.,\n        0., 0.,0.\n    );\n}\n\n//distance function\nfloat toSphere(in vec3 p){\n    p = rotate_y(p,-time*0.5);\n    p.y += 0.2;\n    return length(pow(abs(p),vec3(.7,0.68,0.4)))-1.5;\n    //you can try this another DE vertion\n    //return length(pow(abs(p),vec3(.7,0.68,0.4))-vec3(.6,0.35,0.4))-1.;\n}\n\nfloat toPlane( vec3 p )\n{\n\treturn p.y;\n}\n//map the objects and return the distance\nfloat map(in vec3 p){\n    return toSphere(p);\n}\n//the object's noraml\nvec3 normal(in vec3 p){\n\tvec2 offset = vec2(0.01,0.);\n    vec3 nDir = vec3(\n    \tmap(p+offset.xyy)-map(p-offset.xyy),\n        map(p+offset.yxy)-map(p-offset.yxy),\n        map(p+offset.yyx)-map(p-offset.yyx)\n    );\n    return normalize(nDir);\n}\n//ray-marching the object and return the distance\nfloat raymarching(in vec3 pos,in vec3 p){\n    float d = 0.;\n    float distance = 1.;\n    for(int i = 0;i<64;++i){\n        distance += d;\n    \tvec3 raysphere = pos + distance*p;\n        d = map(raysphere);\n        if(d<0.02 )break;    \n    };\n    return distance;\n}\n\n/*vec3 thenewp (in vec3 pos,in vec3 p,in float an){\n\tvec3 dian = vec3(0.);\n    vec3 z = normalize(dian-pos);\n    vec3 x = normalize(cross(z,vec3(sin(an),cos(an),0.)));\n    vec3 y = normalize(cross(z,x));\n    mat3 mat = mat3(x,y,z);\n    return p*mat;//;p.x*x+p.y*y+p.z*z;\n}\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy*vec2(5.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = normalize(vec3(uv,2.));\n    \n    //camera \n    vec3 pos = vec3(0.,0.,-5.);\n    //pos = rotate_x(pos,mouse.y);\n    pos = rotate_y(pos,mouse.x);\n    //the new p\n    //vec3 pp = thenewp(pos,p,0.);\n    vec3 pp;\n    //pp = rotate_x(p,mouse.y);\n    pp = rotate_y(p,mouse.x);\n    \n    vec3 col = vec3(0.);\n    float d = raymarching(pos,pp);\n    \n    float diff,fresnel,luminance,factor;\n    \n    vec3 nDir,ref,  fra0,fra1,fra2;\n    \n    vec3 refcol,fracol;\n    \n    if(d<40.){\n    \t\n        nDir = -normal(pos+d*pp);\n        if(dot(pp,nDir) > 0.){\n            factor = (1.- iMouse.y/iResolution.y)*0.1;\n            \tfactor = pow(factor,1.1);\n            ref = normalize(reflect(pp,nDir));\n            fra0 = normalize(refract(pp,nDir,iMouse.y/iResolution.y));\n            fra1 = normalize(refract(pp,nDir,iMouse.y/iResolution.y)+factor);\n            fra2 = normalize(refract(pp,nDir,iMouse.y/iResolution.y)+2.*factor);\n            //col = nDir;\n            \n            //fork diffuse\n            diff = 0.5*max(0.,dot(nDir,normalize(vec3(0.,1.,0.))))+0.5;\n            \n            //custom fresnel\n            fresnel = pow(1.-max(0.,dot(pp,nDir)),2.);\n            refcol = texture(iChannel0,ref).rgb;\n            \t   \n            //tone-mapping\n            refcol /= vec3(1.)+refcol;\n            \n            //fracol = texture(iChannel0,fra).rgb/1.5;\n            \n            vec3 fracol = vec3(\n            \ttexture(iChannel0,fra0).r,\n                texture(iChannel0,fra1).g,\n                texture(iChannel0,fra2).b\n            );\n            //Luminance\n            luminance = dot( fracol, vec3(0.22, 0.707, 0.071));\n            fracol *= diff*luminance;\n            //gamma\n            fracol = pow(fracol,vec3(1.3));\n            \n            col = mix(fracol,refcol,fresnel);\n            \n            //tone \n            col *= 2.3*vec3(1.1,1.1,1.);\n            //col = vec3(diff);\n        }\n        else{\n            //discard;\n        }\n    }else{col = vec3(0.06);}\n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}