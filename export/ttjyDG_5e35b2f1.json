{"ver":"0.1","info":{"id":"ttjyDG","date":"1706892591","viewed":76,"name":"Radial Color Pattern","username":"mathieu_h","description":"polar coord colors\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["polarcoordcolors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(v,r)  smoothstep ( 3./R.y, 0., length(v)-r ) // antialiased draw\n#define PI 3.14159265359\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) ) // from https://www.shadertoy.com/view/ll2cDc\n#define EPSILON 0.000000001\n#define Na 1\n#define Nb 16\n\nfloat degToRad (float x) { return (x / 360.0) * 2.0 * PI;}\n\nvec2 rotate(float phi, vec2 uv)\n{\n    float x = uv.x;\n    float y = uv.y;  \n    \n    float u = cos(phi)* x - sin(phi) * y;\n    float v = sin(phi)* x + cos(phi) * y;\n    \n    return vec2(u,v);\n}\n\nfloat checker (vec2 uv , vec2 tiling)\n{\n    //UV Projection    \n    float phi =  45.0;\n    uv = rotate(degToRad(phi), uv * tiling);\n    \n    //Parameters    \n    float x = uv.x;\n    float y = uv.y;\n    float h = 0.0;\n    vec2 t = tiling;\n    \n    // Pattern\n    float w = 0.000001;\n    h = sin(x) + sin(y) + 1.0;\n    h = pow(abs(h), 1.0/w);    \n    h = clamp(h, w,1.0);\n    \n    return h; \n}\n\n\nvoid mainImage( out vec4 color, vec2 uv )\n{\n    vec2 res = iResolution.xy;\n    uv = ( uv+uv - res ) / res.y;                           \n    \n    \n    float t = .5*cos(iTime*0.5 + PI)+.5,\n          r = .5,                                    // circle radius\n          n = float(Na) + t * float(Nb-Na),           // number of dots\n          l = length(uv),                             // polar coordinates\n          a = atan(uv.y,uv.x),\n    \n     u = r * ( fract( a*n/6.283 ) - .5 ) / (n/6.283),// local coordinates in\n     v = l - r,                                      // cells along the circle\n     i = floor( a*n/6.283 );                         // dot number\n    \n    uv = vec2(u,v);\n    vec2 gridTile = 10.0 * vec2(1.0,1.0);\n    vec2 radialTile = gridTile * 1.0;\n    float m = ceil(clamp(fract(length(radialTile*uv)), 0.5,1.0) - 0.5);\n    vec4 tex = vec4(1.0) * checker(uv,gridTile);\n    color =  tex * m + (1.0-m) * (hue(i/n));                      // draw blobs\n}","name":"Image","description":"","type":"image"}]}