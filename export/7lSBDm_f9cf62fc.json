{"ver":"0.1","info":{"id":"7lSBDm","date":"1652284288","viewed":46,"name":"KatePivovarova4","username":"domisolcat","description":"z-buffer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["zbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n#define maxVert 8;\n\nconst int n=4;\nvec3 colVec[n]=vec3[n](vec3(0.5, 0.5, 0), \n                       vec3(1, 0, 0), \n                       vec3(0, 1, 0), \n                       vec3(0, 0, 1));\nvec3 BGcol=vec3(1.0, 0.5, 1.0);\n//float zVec[n]=float[n](3.0, 2.0, 1.0);\n\n\n\nint sizes[n] = int[n](3, 4, 4, 3), inds[n] = int[n](0, 3, 7, 11); const int m = 14;\nvec2 polygonsXY[m]; float polygonsZ[m];\n\nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){\n// 0 -- triangle\n    polygonsXY[0]=vec2(0.2, 0.3); \n    polygonsZ[0]=0.1; \n    polygonsXY[1]=vec2(0.8, 0.9); \n    polygonsZ[1]=0.12;\n    polygonsXY[2]=vec2(0.4, 0.7); \n    polygonsZ[2]=0.1;\n//1-- triangle\n    polygonsXY[11]=vec2(0.8, 0.5); \n    polygonsZ[11]=0.01;\n    polygonsXY[12]=vec2(0.01, 0.4); \n    polygonsZ[12]=0.21;\n    polygonsXY[13]=vec2(0.3, 0.15); \n    polygonsZ[13]=0.05;\n// 2 -- triangle\n    float w=2.0;\n    vec3 center=vec3(0.55, 0.4*sin(time*0.9)+0.5, 0.1+0.05*cos(time*w)); float r = 0.4;\n    int i; \n    float j=0.8, phi = myPi/8.0;\n    float ang=2.0*myPi/7.0; \n    vec3 tmpVec;\n    mat3 rot=mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for(i=3;i<9; i++){\n        tmpVec=rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i]=tmpVec.xy+center.xy;\n        polygonsZ[i]=tmpVec.z+center.z;\n        j=j+1.0;\n    }\n    \n// 3 -- rotated square\n    w = 2.0;\n    center=vec3(0.55, 0.5, 0.1 + 0.05*sin(time*w)); \n    r=0.55;\n    j=0.0, phi=myPi/3.0;\n    ang=2.0*myPi/4.0; \n    rot=mat3(vec3(1, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for (i = 7; i < 11; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j+1.0;\n    }\n\n// 3 -- triangle\n    /*polygonsXY[11]=vec2(0.8, 0.5); \n    polygonsZ[11]=0.01;\n    polygonsXY[12]=vec2(0.01, 0.4); \n    polygonsZ[12]=0.21;\n    polygonsXY[13]=vec2(0.3, 0.15); \n    polygonsZ[13]=0.05;*/\n    \n}\n\nvec3 sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x-offset.x;\n  float y = uv.y-offset.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return d > 0. ?  0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) : vec3(1., 1., 0.);\n}\n\n\nint leftTurn(in vec2 a, in vec2 b, in vec2 c){\n    float tmp=(c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x);\n    if (abs(tmp)<Eps) \n        return 0;\n    else \n        return tmp>0.0?1:-1;\n}\n\n\nbool inPolygon(in int ind0, in int size, \n               in vec2 vert[m], in vec2 p){\n    bool res=leftTurn(vert[ind0 + size-1], vert[ind0], p)<=0; \n    int i=ind0;\n    while(res&&(i<ind0+size-1)){\n        res=res&&(leftTurn(vert[i], vert[i+1], p)<=0); \n        i++;\n    }\n    return res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p){ \n    vec3 nrm=cross(a-b, c-b);\n    if(abs(nrm.z)<Eps) \n        return a.z;\n    else \n        return(dot(nrm, b)-nrm.x*p.x-nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=fragCoord/iResolution.xy;\n    //vec2 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float time=iTime, tmp; //iTime;\n    \n    vec2 uv2=fragCoord/iResolution.xy; // <0,1>\n    uv2-=0.5 ; \n    uv2.x*=iResolution.x/iResolution.y;\n    vec2 offset=vec2(sin(iTime*2.)*0.2, cos(iTime*2.)*0.2); // move the circle clockwise\n  \n    \n    //colVec[0]=sdfCircle(uv, .2, offset);\n    \n    initPolygons(polygonsXY, polygonsZ, time);\n    //vec3 col=BGcol;\n    vec3 col=sdfCircle(uv2, .2, offset);\n    //vec3 col=0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float z=maxZ; \n    int i;\n    for(i=0;i<n;i++){\n        if(inPolygon(inds[i], sizes[i], polygonsXY, uv)){\n            tmp=zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\n            if(tmp<z){\n                z=tmp; \n                col=colVec[i];\n                //col=colVec[i]+0.5*sin(time); \n            }\n        }\n      colVec[1]=colVec[1]+0.8*sin(time);//*vec3(1.0, 1.0, 1.0);\n      colVec[2]=colVec[2]+0.4*cos(time);//*vec3(1.0, 1.0, 1.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}