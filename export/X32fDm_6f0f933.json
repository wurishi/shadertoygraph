{"ver":"0.1","info":{"id":"X32fDm","date":"1729545086","viewed":51,"name":"Relativistic Lensing","username":"nagaoo0","description":"https://en.wikipedia.org/wiki/Gravitational_lensing_formalism","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"l3SBDW","parentname":"Gravitational lensing formalism "},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, vec2 u) {\n    // vec2 R stores the screen resolution passed to the shader.\n    vec2 R = iResolution.xy;\n    \n    // d is the initial distance from the black hole (camera distance).\n    // l is a variable used for the loop to track the updated distance.\n    float d = 5., l = d, k;\n    \n    // V is a 3D vector representing the direction from the camera to the pixel being rendered.\n    // It normalizes a vector where the x component is based on screen aspect ratio and y and z\n    // are based on the pixel coordinates (u) passed in. It simulates a ray from the camera.\n    vec3 V = normalize(vec3(.447 * R.x, R - u - u)),\n         P = vec3(-d, 0, 0),  // P is the starting point of the ray in 3D space.\n         c;                   // c is a temporary vector used later for calculations.\n\n    // This loop iterates as long as l (distance from the black hole) is within a valid range.\n    // It updates the ray's position and direction based on gravitational influence.\n    for (O *= 0.; l < d + d && l > 1.;) {\n        // k is a small step size based on the current distance.\n        k = 0.1 * l;\n        \n        // Update l to be the length (distance) of the new position vector P after moving along V.\n        l = length(P += V * k);\n        \n        // Apply gravitational lensing effect by adjusting the direction vector V.\n        // The cross product of V and P creates a perpendicular vector c.\n        // Dot product is used to project the effect of gravitational pull on V.\n        // The result is scaled based on the distance (l) raised to the power of 5.\n        V -= k * dot(c = cross(V, P), c) * P / pow(l, 5.);\n    }\n\n    // Rotate the direction vector V based on time (iTime) to animate the cubemap.\n    float angle = iTime * 0.02; // Rotation speed\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    \n    // Rotation around the Y-axis\n    mat3 rotationMatrix = mat3(\n        cosA, 0.0, -sinA,\n        0.0, 1.0, 0.0,\n        sinA, 0.0, cosA\n    );\n    \n    // Apply the rotation matrix to V\n    vec3 rotatedV = rotationMatrix * V;\n\n    // Sample the cubemap texture using the rotated vector.\n    vec3 cubemapColor = texture(iChannel0, rotatedV).rgb;\n\n    // Fade to black as we approach the center of the black hole.\n    // The closer l is to 1 (the center), the darker the color.\n    float fade = smoothstep(0.0, 1.0, l - 1.0);\n    vec3 finalColor = mix(vec3(0.0), cubemapColor, fade);\n    \n    // Output the final color.\n    O = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}