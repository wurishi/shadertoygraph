{"ver":"0.1","info":{"id":"ds3cDl","date":"1698763105","viewed":40,"name":"M1if02 2023-2024 MLeocmach","username":"Sozel","description":"Martin Leocmach p1107819","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"fl2yz3","parentname":"M1 - Ray tracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Ellipsoid{\n    vec3 r;//radius\n    int i;//Texture Id\n};\n\n // Box centrée à l'origine, alignée avec les axes\n // Elle sera placée où on veut dans l'espace grâce au fonction de rotation et translation \nstruct Box{\n    vec3 size;\n    int i;\n};\n\nstruct Cylinder{\n    vec3 a; //center 1st circle\n    vec3 b; //center 2nd circle\n    float r; //Radius\n    int i;   //Texture Id\n};\n\nstruct Capsule{\n    vec3 a;\n    vec3 b;\n    float r;\n    int i;\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    bool reflective; // true si le materiau est un miroir;\n    float coefSpeculaire; //coefficient de Phong\n    \n};\n\nconst int nbLightSources = 3;\n\n////Tools function ////////////\nvec3 ClosestPointOnLine(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ba = a-b;\n    vec3 pa = p-a;\n    \n    float sqrLenghtBa = dot(ba, ba);\n    float dotbapa = dot(pa,ba);\n    float t = dotbapa/sqrLenghtBa;\n    \n    vec3 ret = a+t*ba;\n    return ret;\n}\n\nvec3 ClosestPoint(vec3 p, vec3 a, vec3 b)\n{\n    if(dot(p-a,p-a) < dot(p-b,p-b))\n        return a;\n    return b;   \n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Hemisphere direction\n\nvec3 Hemisphere(int seed,vec3 n)\n\n{\n\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n\n    float b=fract(sin(164.19*float(seed)));\n\n   \n\n    float u=2.*3.1415*a;// Random angle\n\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n   \n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n   \n\n    return d;\n\n}\n\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n//Fonctions de transformation de ray :    //////\n//Translation, rotation, homotéthie       //////\n\n\nRay translateRay(Ray ray, vec3 direction)\n{\n    return Ray(ray.o+direction, ray.d);\n}\n\nRay rotateRay(Ray ray, float angle, vec3 axis)\n{\n    return Ray(ray.o*rotationMatrix(axis, angle), ray.d*rotationMatrix(axis, angle));\n}\n\nvec3 rotateNormal(vec3 n, float angle, vec3 axis)\n{\n    return n*rotationMatrix(axis, angle);\n}\n\nRay scaleRay(Ray ray, vec3 c,float k)\n{\n    vec3 co = ray.o-c;\n    return Ray(c + (co/k), ray.d);\n}\n\n//////////////////////////\n// Colors for materials\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\nvec3 ColorFromDistanceToOriginByAxis(vec3 p)\n{\n    float x = 0.5 + (cos(p.x)/2.);\n    float y = 0.5 + (cos(p.y)/2.);\n    float z = 0.5 + (cos(p.z)/2.);\n    return vec3(x,y,z);\n}\n\nvec3 ColorFromDistanceToOrigin(vec3 p)\n{\n    \n    float colorLength = sqrt(dot(p,p));\n    return vec3(0.5+cos(colorLength+30.)/2., 0.5+cos(colorLength)/2., 0.5+cos(colorLength+120.)/2.);\n}\n\n\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    switch (i)\n    {\n        case 0:\n            float f=Checkers(.5*p.xy);\n            vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n            return Material(col, false, 100.);\n        case 1:\n            return Material(vec3(.8,.5,.4), false, 50.);\n            break;\n        case 2:\n            return Material(vec3(.6,.1,.8), false, 200.);\n        case 3:\n            return Material(ColorFromDistanceToOriginByAxis(p), false, 100.);\n        case 4:\n            return Material(ColorFromDistanceToOrigin(p), false, 50.);\n        case 5:\n            return Material(vec3(0), true, 50.);\n        \n    }\n    return Material(vec3(0), false, 1.);\n}\n\n//return le milieu du segment p1p2\nvec3 MiddlePoint(vec3 p1, vec3 p2)\n{\n    vec3 p2p1 = p2-p1;\n    return p1+(p2p1)*0.5;\n}\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=sph.c-ray.o;\n    float b=dot(-oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.01)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid el, out Hit x)\n{\n    vec3 ocn = ray.o/el.r;\n    vec3 rdn = ray.d/el.r;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h = b*b - a*(c-1.0);\n    if(h>0.0){\n        float t = (-b-sqrt(h))/a;\n        if(t>0.1) {\n            x=Hit(t, normalize(Point(ray,t)), el.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.01)\n    {\n       \n        x=Hit(t,pl.n,pl.i);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n    vec3 vmin = -(box.size/2.);\n    vec3 vmax = box.size/2.;\n    float tmin = (vmin.x - ray.o.x) / ray.d.x;\n    float tmax = (vmax.x - ray.o.x) / ray.d.x;\n    vec3 norm = vec3(ray.o.x, 0.,0.);\n    float ttemp;\n \n    if (tmin > tmax){\n        ttemp = tmin;\n        tmin = tmax;\n        tmax = ttemp;\n    }\n \n    float tymin = (vmin.y - ray.o.y) / ray.d.y; \n    float tymax = (vmax.y - ray.o.y) / ray.d.y; \n \n    if (tymin > tymax){\n        ttemp = tymin;\n        tymin = tymax;\n        tymax = ttemp;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return false; \n \n    if (tymin > tmin){\n        tmin = tymin;\n        norm = vec3(0.,ray.o.y,0.);\n    }\n \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (vmin.z - ray.o.z) / ray.d.z; \n    float tzmax = (vmax.z - ray.o.z) / ray.d.z; \n \n    if (tzmin > tzmax){\n        ttemp = tzmin;\n        tzmin = tzmax;\n        tzmax = ttemp;\n    } \n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return false; \n \n    if (tzmin > tmin)\n    {\n        tmin = tzmin;\n        norm = vec3(0.,0.,ray.o.z);\n    }\n    if(tmin>0.1)\n    {\n        x=Hit(tmin, normalize(norm), box.i);\n        return true; \n    }\n    return false;\n\n}\n\n\n//\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3  ba = cyl.b - cyl.a;\n    vec3  oa = ray.o - cyl.a;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,ray.d);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(ray.d,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - cyl.r*cyl.r*baba;\n    float h = b*b - a*c;\n    if( h >= 0.)\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0. && y<baba && t>0.01)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-ClosestPointOnLine(p, cyl.a, cyl.b)), cyl.i);\n            return true;\n        }\n        // caps TODO\n        else\n        {\n            Plane pl;\n            if(y<=0.0)\n            {\n                pl = Plane(normalize(cyl.a-cyl.b), cyl.a, cyl.i);\n            }\n            else if(y>=baba)\n            {\n                pl = Plane(normalize(cyl.b-cyl.a), cyl.b, cyl.i);\n            }\n            Hit hit;\n            if (IntersectPlane(ray, pl, hit))\n            {\n                if(hit.t>0.01)\n                {\n                    vec3 p=Point(ray, hit.t);\n                    if((dot(p-pl.p, p-pl.p))<=cyl.r*cyl.r)\n                    {\n                        x=hit;\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x)\n{\n    vec3  ba = cap.b - cap.a;\n    vec3  oa = ray.o - cap.a;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,ray.d);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(ray.d,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - cap.r*cap.r*baba;\n    float h = b*b - a*c;\n    if( h < 0.0 ) return false;\n    \n    else\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba && t>0.01)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-ClosestPointOnLine(p, cap.a, cap.b)), cap.i);\n            return true;\n        }\n        // caps\n        vec3 oc = (y <=0.0) ? oa : ray.o - cap.b;\n        b = dot(ray.d,oc);\n        c = dot(oc,oc) - cap.r*cap.r;\n        h = b*b - c;\n        if( h>0.0)\n        {\n            t=-b-sqrt(h);\n            if(t>0.01)\n            {\n                vec3 p=Point(ray, t);\n                x=Hit(t, normalize(p+oc-ray.o), cap.i);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(-4.,3.,1.),1.,2);\n    const Sphere sph2=Sphere(vec3(-12.,-4.,2.),1.,4);\n    const Sphere sph3=Sphere(vec3(4.,-8.,5.),5.,5);\n    \n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,-1.),4);\n    \n    const Capsule cap1=Capsule(vec3(2.,5.,5.),vec3(-2.,3.,5.),1.,4);\n    const Capsule cap2=Capsule(vec3(12.,9.,0.),vec3(10.,10.,0.),1.,3);\n    \n    const Ellipsoid el1=Ellipsoid(vec3(2.,4.,2.), 4);\n    \n    const Cylinder cyl = Cylinder(vec3(2,-2.,4.), vec3(4.,4.,4.), 1.,2);\n    \n    const Box box1 = Box(vec3(2., 4., 2.), 4);\n    const Box box2 = Box(vec3(1., 1., 1.), 3);\n    \n    \n    \n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    float rotationAngle = 0.5;\n    \n    Ray rotatedRay = rotateRay(ray, t, vec3(0.,0.,1.));\n    if(IntersectSphere(rotatedRay,sph1,current) && current.t<x.t){\n        x=current;\n        x.n = rotateNormal(x.n, -t, vec3(0.,0.,1.));\n        ret=true;\n    }\n    \n    float k = cos(t)+1.5;\n    if(IntersectSphere(scaleRay(ray, sph2.c, k),sph2,current)){\n        current.t = current.t*k;\n        if(current.t < x.t){\n            x=current;\n            ret=true;\n        }\n    }\n    \n    if(IntersectSphere(ray,sph3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCapsule(translateRay(translateRay(ray, cos(t)*vec3(1.,1.,2.)), vec3(1.,-3.,2.)) ,cap1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCapsule(scaleRay(ray, cap2.a, k),cap2, current)){\n        current.t=current.t*k;\n        if(current.t < x.t) {\n            x = current;\n            ret=true;\n        }\n    }\n    \n    \n    rotatedRay = rotateRay(ray, t, vec3(1.,1.,4.));\n    if(IntersectCylinder(rotatedRay, cyl ,current)&&current.t<x.t){\n        x=current;\n        x.n = rotateNormal(x.n, -t, vec3(1.,1.,4.));\n        ret=true;\n    }\n    \n    if(IntersectBox(translateRay(ray, -vec3(1.,8.,6.)), box1, current) && current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    rotatedRay = rotateRay(ray, 90., vec3(0.,1.,1.));\n    if(IntersectBox(translateRay(rotatedRay, vec3(0.,-2.,1.)), box2, current) && current.t<x.t){\n        x=current;\n        x.n = rotateNormal(x.n, -90., vec3(0.,1.,1.));\n        ret=true;\n    }\n    \n    rotatedRay = rotateRay(translateRay(ray, -vec3(-6.,5.,5.)), t, vec3(1.,0.,0.));\n    if(IntersectEllipsoid(rotatedRay, el1, current) && current.t<x.t){\n        x=current;\n        x.n = rotateNormal(x.n, -t, vec3(1.,0.,0.));\n        ret=true;\n    }\n    \n    return ret;\n}\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n, vec3 light)\n{\n    float diff=clamp(dot(n, light),0.,1.);\n    return m.d*diff;\n}\n \n \n \nfloat AmbiantOcclusion(vec3 p, vec3 n, int N)\n{\n    if(N==0) return 1.;\n    float ao = 0.;\n    \n    for(int i=0; i<N; i++) {\n        Hit hit;\n        vec3 d = Hemisphere(i,n);\n        if(!Intersect(Ray(p, d), hit) || hit.t > 1.)\n            ao = ao+1.;\n    }\n    return ao/float(N);\n    \n}\n\n\nvec3 GetPointColor(vec3 lightSources[nbLightSources], vec3 p, vec3 n, Material mat, vec3 viewerDir)\n{\n    Hit temp;\n    const int N = 20; //nombre d'échatillon pour l'occlusion ambiante\n    //attention si N trop grand, perte drastique de fps (à partir de 30-40 environ)\n    vec3 color = vec3(0);\n    \n    \n    for(int i=0; i<nbLightSources; ++i)\n    {\n    temp.t=0.;\n        vec3 pointToLight = normalize(lightSources[i]-p);\n        vec3 halfVector = normalize(pointToLight-viewerDir);\n\n        if((!Intersect(Ray(p, pointToLight), temp)) || temp.t>sqrt(dot(lightSources[i]-p, lightSources[i]-p)))\n        { //Si on entre ici, cette lumière frappe l'objet directement\n            float specularComp = pow(abs(dot(halfVector, n)), mat.coefSpeculaire);\n            \n            color = color + specularComp + Color(mat,n, pointToLight);\n        }\n        else //légère composante diffuse même si à l'ombre, pour éviter les zones dans le noir totale (peu réaliste)\n        {\n                color = color + 0.2*Color(mat,n, pointToLight);\n        }\n    }\n        \n    return (color/float(nbLightSources))*AmbiantOcclusion(p, n, N);\n}\n\n\n// Rendering\nvec3 Shade(Ray ray)\n{   \n    // Intersect contains all the geo detection\n    Hit x, temp;\n    \n        \n    //Source lumineuse (ponctuelle)\n    \n    vec3 lightSources[nbLightSources];\n    \n    lightSources[0] = vec3(-50.,-25.,30.);\n    lightSources[1] = vec3(50.,-25.,15.);\n    lightSources[2] = vec3(-55.,75.,15.);\n\n  \n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n\n        Material mat=Texture(p,x.i);\n        vec3 color = vec3(0.,0.,0.);\n        \n        if(mat.reflective)\n        {\n            vec3 mirrorColor = GetPointColor(lightSources, p, x.n, mat, ray.d); //Material color if it wasn't reflective\n            Ray reflectedRay = Ray(p, normalize(reflect(ray.d, x.n)));\n            idx = Intersect(reflectedRay, x);\n            if(idx)\n            {\n                p = Point(reflectedRay,x.t);\n                mat = Texture(p, x.i);\n                return 0.9*GetPointColor(lightSources, p, x.n, mat, reflectedRay.d) + 0.1*mirrorColor;\n                //Couleur de l'objet touché plus une partie de la couleur du mirroir.\n                //Simule la partie de la lumière absorbée par le mirroir\n            }\n            else\n            {\n                return Background(reflectedRay.d)*0.9 + 0.1*mirrorColor;\n                //Couleur de l'objet touché plus une partie de la couleur du mirroir.\n                //Simule la partie de la lumière absorbée par le mirroir\n            }\n        }\n        \n        else\n        {\n            return GetPointColor(lightSources, p, x.n, mat, ray.d);\n        }\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}