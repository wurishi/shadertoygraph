{"ver":"0.1","info":{"id":"lcVXRy","date":"1715391170","viewed":194,"name":"GM Shaders: DDA Clean","username":"Xor","description":"A quick and dirty visualization of the DDA algorithm. This was written for an upcoming tutorial on voxels","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d","tutorial","voxel","raytrace","dda","gmshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"GM Shaders: DDA\" by @XorDev\n\n    A quick and dirty visualization of the DDA algorithm.\n    This was written for an upcoming tutorial on voxels:\n    mini.gmshaders.com\n    \n    Cleaned up version of:\n    https://www.shadertoy.com/view/Mc3XD4\n*/\n\n//Max number of DDA steps\n#define STEPS 30.0\n//Scale with resolution\n#define SCALE (10.0/res.y)\n\n//2D voxel bitmap\nbool map(vec2 p)\n{\n    return dot(sin(p+vec2(1,0)), cos(p.yx*.6)) > 0.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Resolution for scaling\n    vec2 res = iResolution.xy;\n    //Scaled coordinates\n    vec2 coord = fragCoord*SCALE;\n    \n    //Wandering target point\n    vec2 wander = (cos(iTime/vec2(1,.7))*0.2 + 0.5) * res;\n    //Start and end points that track the mouse\n    vec2 p1 = (iMouse.z>0.0 ? abs(iMouse.zw) : 0.5*res) * SCALE;\n    vec2 p2 = (iMouse.z>0.0 ? iMouse.xy      : wander ) * SCALE;\n    \n    //Ray direction\n    vec2 dir = normalize(p2 - p1);\n    //Prevent division by 0 errors\n    dir += vec2(dir.x==0.0, dir.y==0.0) * 1e-5;\n    \n    //Sign direction for each axis\n    vec2 sig = sign(dir);\n    //Voxel step size for each axis\n    vec2 stp = sig / dir;\n    \n    //Voxel position\n    vec2 vox = floor(p1);\n    //Initial step sizes to the next voxel\n    vec2 dep = ((vox-p1 + 0.5) * sig + 0.5) * stp;\n    //Adds small biases to minimize same depth conflicts (z-fighting)\n    dep += vec2(0, 1) * 1e-4;\n    \n    //Voxel intersection point\n    vec2 hit;\n    //Axis selector (either vec2(1,0) or vec2(0,1))\n    vec2 axi;\n    //Output color, starting with map\n    vec3 col = vec3(map(floor(coord))) * vec3(.3,.3,.5);\n    //Grid glow intensity\n    vec2 edge = vec2(1);\n    \n    //Loop through voxels\n    for(float i = 0.0; i<STEPS; i++)\n    {\n        //Stop if we hit a voxel\n        if (map(vox)) break;\n        //if (length(vox-floor(p2))<.5) break;\n        \n        //Select the next closest voxel axis\n        axi = step(dep, dep.yx);\n        //Compute intersection point\n        hit = p1 + dot(dep, axi) * dir;\n        //Step one voxel along this axis\n        vox += sig * axi;\n        //Set the length to the next voxel\n        dep += stp * axi;\n        \n        //Draw glowing hit points\n        col += vec3(axi,0) * (clamp(0.5*(0.1-length(hit-coord)) / SCALE + 0.5,0.0,1.0)\n        +.2*float(vox==floor(coord)));\n        //Illuminate intersecting walls (ugly code!!)\n        edge += axi*float(floor(coord - 0.5*axi*sig) == floor(hit - 0.5*axi*sig));\n        \n    }\n    //Add glowing grid lines\n    vec2 grid = max(edge-0.5*abs(fract(coord+0.5)-0.5) / SCALE, 0.0);\n    col.rg += grid;\n    \n    //Illuminate raycast line from p1 to hit point\n    vec2 pa = coord - p1;\n    vec2 ba = hit - p1;\n    float line = length(pa-ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n    col += vec3(0.3,.6,1) * clamp(0.5*(0.05-line) / SCALE+0.5,0.0,1.0);\n    col += clamp(0.5*(0.15-length(pa)) / SCALE+0.5,0.0,1.0);\n    \n    //Output with lazy color grading\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}