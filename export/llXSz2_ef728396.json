{"ver":"0.1","info":{"id":"llXSz2","date":"1439879534","viewed":351,"name":"RGB to HSV test","username":"JamesHagerman","description":"testing an HSV shader on the lights","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sensatron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Converting from HSV to RGB leads to C1 discontinuities, for the RGB components\n// are driven by picewise linear segments. Using a cubic smoother (smoothstep) makes \n// the color transitions in RGB C1 continuous when linearly interpolating the hue H.\n\n// C2 continuity can be achieved as well by replacing smoothstep with a quintic\n// polynomial. Of course all these cubic, quintic and trigonometric variations break \n// the standard (http://en.wikipedia.org/wiki/HSL_and_HSV), but they look better.\n\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// compare\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 hsl = vec3( uv.x+iTime*0.1+uv.y* (iMouse.x/iResolution.x), 1.0, 1.0-uv.y );\n\n\tvec3 rgb_o = hsv2rgb( hsl );\n\tvec3 rgb_s = hsv2rgb_smooth( hsl );\n\t\n\tvec3 rgb = mix( rgb_o, rgb_s, smoothstep( -0.2, 0.2, 0.0) ); //sin(2.0*iTime)\n\tfragColor = vec4( rgb, 1.0 );\n}","name":"","description":"","type":"image"}]}