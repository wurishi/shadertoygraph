{"ver":"0.1","info":{"id":"7dc3Wf","date":"1636798469","viewed":156,"name":"Dynamic BVH Ray Marching","username":"playbyan1453","description":"I made a non symmetrical Box SDF defined by 2 points so i could made bounding box around the triangle. Might be bad for fake ambient ocullusion and soft shadows.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bvh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 1024\n#define MIN_T 1e-4\n#define MAX_T 8.0\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\n// axis aligned box, not exact since the interior replaced\n// with expensive sdf\nfloat bboxSDF(vec3 p, vec3 a, vec3 b) {\n    return length(max(max(p - a, b - p), 0.0));\n}\n\nfloat triangleSDF(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n\n    return sqrt(\n       (sign(dot(cross(ba, nor),pa)) +\n        sign(dot(cross(cb, nor),pb)) +\n        sign(dot(cross(ac, nor),pc))<2.0)\n        ?\n        min(min(\n        dot2(ba*clamp(dot(ba, pa)/dot2(ba),0.0,1.0)-pa),\n        dot2(cb*clamp(dot(cb, pb)/dot2(cb),0.0,1.0)-pb)),\n        dot2(ac*clamp(dot(ac, pc)/dot2(ac),0.0,1.0)-pc))\n        :\n        dot(nor, pa)*dot(nor, pa)/dot2(nor));\n}\n\nfloat bounding0(vec3 p) {\n    const int vert = 3;\n    vec3 t[vert] = vec3[vert] (\n                vec3(cos(-iTime), sin(iTime), sin(-iTime)),\n                vec3(sin(iTime), sin(-iTime), sin(iTime)),\n                vec3(sin(iTime), cos(-iTime), cos(-iTime)));\n\n    vec3 bmin = vec3( 1e20);\n    vec3 bmax = vec3(-1e20);\n    \n    for(int i = 0; i < vert; i++) {\n        vec3 p = t[i];\n        bmin = min(bmin, p);\n        bmax = max(bmax, p);\n    }\n\n    float bvh = bboxSDF(p, bmax, bmin);\n    if(bvh > MIN_T) return bvh;\n    return triangleSDF(p, t[0], t[1], t[2]);\n}\n\nfloat map(vec3 p) {\n    float m = bounding0(p);\n\n    return m;\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out float iter) {\n    float t = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        if(t > MAX_T) break;\n        float d = map(ro + rd * t);\n        if(d < MIN_T) break;\n        t += d;\n        iter = float(i)/float(i+128);\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(0, 0, -6);\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    vec3 rd = normalize(uv.x * x + uv.y * y + 1.0 * z);\n\n    float i;\n    float d = raymarch(ro, rd, i);\n    vec3 p = ro + rd * d;\n\n    vec3 col = vec3(0);\n    col = vec3(sqrt(i));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}