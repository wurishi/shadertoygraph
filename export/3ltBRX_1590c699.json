{"ver":"0.1","info":{"id":"3ltBRX","date":"1613167482","viewed":202,"name":"Roman temple","username":"MatthieuJacquemet","description":"sdf temple","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["temple","day","nightcycle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n// Configuration ----------------------------------------------------------------------------------------\n\nconst int MAX_STEPS = 200; // Number of steps\nconst float EPSILON = 0.01; // Marching epsilon\nconst float FLOOR_LEVEL = -5.0; // floor height\nconst float TIME_SCALE = 0.05; // time speed\n\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0                  // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n\n// TODO: moon shadowing\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) \n{  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    // focal length\n   \tfloat le = 2.0;\n    \n    // position camera\n    ro=vec3(-40.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse pos at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, 0.51);\n    \n    m = (m*2.0 - vec2(1.0))*3.0;\n    m.y = clamp(-m.y, -PI_2 + 0.1, PI_2 - 0.1); // clamp camera y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\n// SDF COMBINATION ---------------------------------------------------------------------------\n\n// Union \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// difference \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Diff(float a,float b)\n{\n    return max(a,-b);\n}\n\n// Intersection \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Inter(float a, float b)\n{\n    return max(a,b);\n}\n\n\n\n// https://iquilezles.org/articles/distfunctionsl\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat SmoothUnion( float a, float b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat SmoothDiff( float a, float b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a+b)/k, 0.0, 1.0 );\n    return mix( a, -b, h ) + k*h*(1.0-h); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nfloat SmoothInter( float a, float b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// SDF Primitives --------------------------------------------------------------------------\n\nfloat Plane(vec3 point, vec3 nor, vec3 pos) {\n\n    return dot(point - pos, nor);\n}\n\nfloat Sphere(vec3 point, vec3 pos, float radius) {\n\n    return length(point - pos) - radius;\n}\n\nfloat Circle(vec3 point, float radius) {\n\n    vec2 p;\n    p.x = length(point.xy) - radius;\n    p.y = point.z;\n\n    return length(p);\n}\n\nfloat Box(vec3 point, vec3 box) {\n\n  vec3 q = abs(point) - box;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat Torus(vec3 point, float radius, float r) {\n    \n    return Circle(point, radius) - r; \n}\n\nfloat Segment(vec3 point, vec3 a, vec3 b) {\n\n    vec3 ba = b-a;\n    vec3 pa = point-a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    vec3 c = ba*clamp(t, 0.0, 1.0);\n    \n    return length(pa - c);\n}\n\n\nfloat Capsule(vec3 point, vec3 a, vec3 b, float radius) {\n\n    return Segment(point, a, b) - radius;\n}\n\nfloat Cylinder(vec3 point, vec3 a, vec3 b, float radius) {\n\n    float v = Diff( Capsule(point, a, b, radius),\n                    Plane(point, normalize(a-b), b));\n    \n    v = Diff(v, Plane(point, normalize(b-a), a));\n    return v;\n}\n\n\n// Returns a smooth noise in [-1,1] \n// x : Point \nfloat Noise(in vec3 x) {\n\n    vec3 p = floor(x); \n    vec3 f = fract(x); \n\n    p*=1.0;\n    f*=1.0;\n\n    f = f*f*(3.-2.*f); \n    float n = p.x+p.y*157.+113.*p.z;\n\n    float nn = mix(\n        mix(\n            mix(Hash(n+0.),   Hash(n+1.0),f.x), \n            mix(Hash(n+157.0),Hash(n+158.0),f.x),f.y\n        ), \n        mix(\n            mix(Hash(n+113.0),Hash(n+114.0),f.x), \n            mix(Hash(n+270.0),Hash(n+271.0),f.x),f.y\n        ),f.z);\n\n    return -1.0 + 2.0*nn; \n}\n\n\n// Create a column\n// len : Column's length\n// radius : Column's radius\nfloat Column(vec3 p, float len, float radius) {\n\n    const float base_height = 0.2;\n    const float top_height = 0.2;\n    const float deco0_radius = 0.3;\n    const float deco1_radius = 0.2;\n    \n    float half_base_height = base_height*0.5;\n    float half_top_height = top_height*0.5;\n\n    vec3 base_size = vec3(radius + 0.2, radius + 0.3, half_base_height);\n    vec3 top_size = vec3(radius + 0.2, radius + 0.2, half_top_height);\n\n    vec3 base_p = vec3(p.x, p.y, p.z - half_base_height - .15);\n    vec3 top_p = vec3(p.x, p.y, p.z - (len-half_top_height));\n\n    vec3 deco0_pos = vec3(0,0,base_height+deco0_radius+0.5);\n    vec3 deco1_pos = deco0_pos + vec3(0,0,deco0_radius*0.9+deco1_radius);\n\n    vec3 col_start = vec3(0,0,base_height);\n    vec3 col_end = vec3(0,0,len-top_height);\n\n    // column's base block\n    float base = Box(base_p, base_size) - 0.1;\n    float v = base;\n\n\n    float offset = pow(abs(p.z-len*0.45)*0.2,2.0)*-0.15 + 0.15;\n    float cut = pow(abs(fract(p.z*0.4 + 0.33)-0.5), 15.0)*2000.0;\n\n    float column = Cylinder(p, col_start, col_end, radius+offset-cut+0.05);\n\n    v = SmoothUnion(column, base, 0.7);\n\n\n    // loower column decoration\n    float base0_deco = Torus(p-deco0_pos, radius, deco0_radius);\n    float base1_deco = Torus(p-deco1_pos, radius, deco1_radius);\n\n    float base_deco = SmoothUnion(base0_deco, base1_deco,0.1);\n\n    v = SmoothUnion(v, base_deco,0.05);\n\n\n    // cannelure autour de la colonne\n    const float theta = PI/8.0;\n\n    float angle = atan(p.x,p.y);\n    angle = fract(angle/theta) - 0.5;\n    vec3 cp = vec3(sin(angle)*0.5, length(p.xy) - (radius+0.05)*1.3, p.z);\n    cp.y -= offset;\n\n    vec3 start = vec3(0, 0, col_start.z + 2.0*deco0_radius + 1.3);\n    vec3 end = vec3(0, 0, col_end.z - 0.6);\n    v = SmoothDiff(v, Capsule(cp, start, end, theta*radius*1.2), 0.02);\n\n\n    float top = Box(top_p, top_size);\n\n    // upper column decoration\n    vec3 top_a = vec3( top_size.x,  top_size.x, len-top_height);\n    vec3 top_b = vec3(-top_size.x,  top_size.x, len-top_height);\n    \n    vec3 tp = p;\n    tp.y = abs(tp.y);\n    top = Union(top, Cylinder(tp, top_a, top_b, top_height));\n\n    v = Union(v, top);\n\n    return v;\n}\n\n// p : Point\n// size : Size of the stairs\n// num_step : number of stair's steps\nfloat TempleStairs(vec3 p, vec3 size, int num_step) {\n\n    \n    float step_height = size.z / float(num_step);\n    float half_step_height = step_height*0.5;\n    const float k = 0.1;\n\n    vec3 step_size = size;\n    step_size.z = half_step_height - k;\n\n    vec3 pos = p;\n    pos.z -= half_step_height;\n    float v = Box(pos, step_size) - k;\n\n    for (int i=1; i<num_step; ++i) {\n        pos.z -= step_height;\n        step_size.xy -= step_height*1.5;\n        // one step\n        v = Union(v, Box(pos, step_size) - k);\n    }\n    return v;\n}\n\nfloat TempleRoof(vec3 p, vec3 size) {\n\n    size.z *= 0.5;\n    const float k = 0.1;\n\n    float top_size_x = size.x - 0.5;\n    vec3 left_normal = normalize(vec3(0,1,size.z));\n    vec3 right_normal = left_normal;\n    right_normal.y *= -1.0;\n\n    vec3 tp = p - vec3(0,0,1.9);\n\n    // left\n    float v = Plane(tp, left_normal, vec3(0,size.y,0));\n    // right\n    v = SmoothInter(v, Plane(tp, right_normal, vec3(0,-size.y,0)), k);\n    // forward\n    v = SmoothInter(v, Plane(tp, vec3(1,0,0), vec3(top_size_x,0,0)), k);\n    // backward\n    v = SmoothInter(v, Plane(tp, vec3(-1,0,0), vec3(-top_size_x,0,0)), k);\n    // underneath\n    v = SmoothInter(v, Plane(tp, vec3(0,0,-1), vec3(0,0,0)), k);\n\n    vec3 lower_part_size = size;\n\n    const float lp_h = 1.0;\n    lower_part_size.z = lp_h;\n    float lower_part = Box(p-vec3(0,0,1.12), lower_part_size) - 0.01;\n\n    float cap_z = lower_part_size.z * -0.0;\n    float cap_x = lower_part_size.x + lower_part_size.z*2.3;\n    float cap_y = lower_part_size.y + lower_part_size.z*2.3;\n\n    vec3 a = vec3( cap_x,  cap_y, cap_z);\n    vec3 b = vec3(-cap_x,  cap_y, cap_z);\n    vec3 c = vec3( cap_x, -cap_y, cap_z);\n\n    float cap_size = lower_part_size.z*3.0;\n    vec3 cap_pos = p;\n    cap_pos.xy = abs(cap_pos.xy);\n    lower_part = SmoothDiff(lower_part, Capsule(cap_pos, a, b, cap_size),0.1);\n    lower_part = SmoothDiff(lower_part, Capsule(cap_pos, a, c, cap_size),0.1);\n\n\n    return SmoothUnion(v, lower_part-0.1, 0.1);\n}\n\n// Potential field of the object -> p : point\nfloat object(vec3 p)\n{\n\n    const float stars_height = 2.0;\n    const float columns_level = FLOOR_LEVEL + stars_height;\n    const float columns_height = 12.0;\n    const float columns_radius = 0.7;\n    const float roof_level = columns_level + columns_height;\n\n    // destruction\n    vec3 destroy_pos = (p + vec3(9,0,0))*0.10 + vec3(4.4,3.7,12.09);\n    float destroy_noise = Noise(destroy_pos)*2.0;\n    // float destroy_factor = max(-p.z*0.05 + 0.1, 0.0)*10.0;\n    // destroy_noise -= destroy_factor;\n\n    // fractal destruction\n    for (int i=2; i<5; ++i) {\n        float k = float(i);\n        destroy_noise += Noise(p*k)/(15.0*k);\n    }\n\n    // columns part\n    vec3 pc = p;\n    pc.xy = fract(pc.xy*0.25) * 4.0 - vec2(2.0,2.0);\n    pc.yz -= vec2(0,columns_level);\n    \n    float columns = Column(pc, columns_height, columns_radius);\n\n    columns = Inter(columns, Box(p, vec3(11.0+columns_radius, 7.0+columns_radius, columns_height)));\n    columns = Diff(columns, Box(p, vec3(9.0-columns_radius, 5.0-columns_radius, columns_height)));\n\n    vec3 fallen_col_p = Rotate(vec3(-PI_2,1.0,-3.2), p);\n    fallen_col_p = Translate(vec3(1.0,-2.0,-10.0),fallen_col_p);\n    fallen_col_p.z = 13.0 - fallen_col_p.z;\n\n    float fallen_col = Column(fallen_col_p, columns_height, columns_radius);\n    columns = Union(columns, fallen_col);\n\n    // roof part\n    float roof = TempleRoof(p-vec3(0,0, roof_level), vec3(12.7,8.9,5));\n    float v = SmoothInter(Union(roof, columns), destroy_noise, 0.2);\n\n\n    // stairs part\n    vec3 sp = Translate(vec3(0,0,FLOOR_LEVEL), p);\n    float stairs = TempleStairs(sp,vec3(14,10,stars_height), 4);\n\n    v = Union(v, stairs);\n\n    return v;\n}\n\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : Point\nvec3 ObjectNormal(vec3 p)\n{\n    float eps = 0.002;\n    vec3 n;\n    float v = object(p);\n    n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n    n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n    n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n\n    return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        s=i;\n        vec3 p = o+t*u;\n        float v = object(p);\n        // Hit object\n        if (v < 0.0) {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON,v);\n        // Escape marched too far away\n        if (t>e)\n            break;\n    }\n    return t;\n}\n\n// Lighting --------------------------------------------------------------------\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float energy;\n    float radius;\n    float shadow_dist;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\nconst int max_light = 16;\nint num_lights = 0;\n\nPointLight lights[max_light];\n\n// Add point light to the scene\nint addPointLight(vec3 position, vec3 color, float energy, float radius, float shadow_dist)\n{ \n    lights[num_lights] = PointLight(position, color, energy, radius, shadow_dist);\n    ++num_lights;\n\n    return num_lights;\n}\n\n// Shading ---------------------------------------------------------------------\n\n\n// Get random vector in [0,1]\nvec3 Hash3(vec3 vec, in float seed)\n{\n    float x = dot(vec, vec3(12.9898,78.233,81.564));\n    float y = dot(vec, vec3(54.6515,25.445,13.848));\n    float z = dot(vec, vec3(89.5405,95.540,99.244));\n\n    const vec3 seed3 = vec3(43758.5453, 15605.8033, 84053.4468);\n\n    return fract(sin(vec3(x,y,z)*seed3)*seed);                  \n}\n\n\n\nfloat Stars(vec3 viewDir, float grid, float seed)\n{    \n    vec3 scaled = viewDir*grid;\n    vec3 local = fract(scaled);\n    vec3 cell = floor(scaled);\n\n    // Random vector and scalar for each grid cell\n    vec3 randv = Hash3(cell, seed);\n    float f = Hash(dot(randv, cell))*0.5 + 0.5;\n\n    float radius = dot(viewDir, normalize(cell+randv));\n    radius = sqrt(1.0 - radius*radius) / f*700.0;\n    radius = clamp(1.0-radius*radius, 0.0, 1.0);\n\n    return radius * pow(f,2.0)* 0.5;\n}\n\n\nvec3 SkyStars(vec3 viewDir)\n{    \n\n    const float grid = 50.0; // spacing between stars\n    float light = 0.0;\n\n    light += Stars(viewDir, grid, 123456.789);\n    light += Stars(RotateY(321.0654,viewDir), grid, 345678.912);\n    light += Stars(RotateZ(876.2523, viewDir), grid, 541214.541);\n\n    return vec3(light);\n}\n\n\n\n\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.75;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\nconst float moonAngularDiameterCos = 0.99996192303;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, DirectionalLight moon, vec3 viewDir) {\n\n    float cosTheta;\n    float moonCosTheta;\n    vec3 sunLin;\n    vec3 moonLin;\n    vec3 sunFex;\n    vec3 moonFex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, sunLin, sunFex);\n    AtmosphericScattering(moon, viewDir, cosTheta, moonLin, moonFex);\n\n    \n    vec3 texColor = moonLin + sunLin;\n    texColor += (sunFex + moonFex)*0.1;\n    texColor *= 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\nvec3 GetSkyFex(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    vec3 normal = normalize(sun.direction*1.5 + up);\n\n    AtmosphericScattering(sun, normal, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n\n// Get sky color\n// sunPosition : Sun direction\n// worldNormal : Ray direction\nvec3 Sky(DirectionalLight sun, DirectionalLight moon, vec3 viewDir, vec3 stallarViewDir) {\n\n    float sunCosTheta;\n    float moonCosTheta;\n    vec3 sunLin;\n    vec3 moonLin;\n    vec3 sunFex;\n    vec3 moonFex;\n\n    // sun scattering\n    AtmosphericScattering(sun, viewDir, sunCosTheta, sunLin, sunFex);\n\n    // moon scattering\n    AtmosphericScattering(moon, viewDir, moonCosTheta, moonLin, moonFex);\n\n\n    //nightsky\n    vec3 L0 = SkyStars(stallarViewDir) * moonFex;\n\n    \n    float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,sunCosTheta);\n    L0 += sun.energy * 19000.0 * sundisk * sunFex;\n\n    float moondisk = smoothstep(moonAngularDiameterCos,moonAngularDiameterCos+0.00002,moonCosTheta);\n    L0 += moon.energy * 20.0 * moondisk * moonFex;\n\n    vec3 texColor = (moonLin + sunLin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// n : Normal at point\n// l : Point to light vector\n// d : Max tracing distance\nfloat Shadow(vec3 p,vec3 n,vec3 l, float d)\n{\n    // float v;\n    // int s;\n    // bool h;\n    // SphereTrace(p+0.1*n,l,d,h,s);\n\n    // if (!h)\n    //  return 1.0;\n\n    // return 0.0;\n\n    const float k = 20.0;\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = object(p+t*l);\n\n        res = min(res, k * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, object(p + n * dist)) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(object(p + 2.0 * n)),0.9);\n}\n\n\n// Background color\n// r : View ray direction\n// cd : Celestial ray direction\nvec3 background(vec3 r, vec3 cd, DirectionalLight sun,  DirectionalLight moon)\n{   \n    return Sky(sun, moon, r, cd);\n\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute point light\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// light : light's data\n// specular : Specular output\nvec3 ComputePointLight(vec3 p,vec3 n, vec3 r, PointLight light, inout vec3 specular) {\n\n    vec3 l = light.position - p;\n    float distance = length(l);\n    vec3 l_nor = l/distance;\n\n    float lambertian = max(dot(n, l_nor),0.0);\n\n    if (lambertian == 0.0)\n        return vec3(0);\n\n    float attenuation =  1.0/(distance*distance + 1.0);\n    float s = 1.0;\n\n    if (distance < light.shadow_dist)\n        s = Shadow(p, n ,l_nor, distance);\n\n    vec3 c = s * light.energy * light.color * attenuation;\n\n    specular += Specular(l_nor, n, -r, 100.0) * c;\n\n    return lambertian * c;\n\n}\n\n// Compute sun light\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// color : color of light\n// shadow_dist : Max shadow tracing distance\n// specular : Specular output\nvec3 ComputeDirectionalLight(vec3 p, vec3 n, vec3 r, DirectionalLight light, inout vec3 specular) {\n\n    float s = Shadow(p, n, light.direction, light.shadow_dist);\n\n    vec3 c = light.color*s;\n\n    specular += Specular(light.direction, n, -r, 100.0) * c;\n    \n    return c*max(dot(n , light.direction), 0.0);\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// sun_dir : Sun direction\nvec3 Shade(vec3 p, vec3 n, vec3 r, DirectionalLight sun, DirectionalLight moon)\n{\n     // Point light\n    const vec3 lp = vec3(-20.0, -20.0, 10.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.3;\n\n    // Ambient occlusion\n    ambient *= AmbientOcclusion(p, n);\n\n    vec3 surface = vec3(1);\n\n    // Lambert diffuse\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n\n    // Compute all points lights\n    for (int i=0; i<num_lights; ++i) {\n\n        PointLight light = lights[i];\n\n        diffuse += ComputePointLight(p, n, r, light, specular);\n    }\n\n    // Compute sun and moon lighting\n    if (sun.direction.z > 0.0)\n        diffuse += ComputeDirectionalLight(p, n, r, sun, specular);\n\n    if (moon.direction.z > 0.0)\n        diffuse += ComputeDirectionalLight(p, n, r, moon, specular);\n\n    return (ambient + diffuse)*surface + specular;\n}\n\n\n// light scattering based on https://ijdykeman.github.io/graphics/simple_fog_shader\n// ray_dir : View ray direction\n// light_dir : View to light vector\n// ray_dist : View ray length\n// radius : radius of the light\nfloat Scatter(vec3 ray_dir, vec3 light_dir,float ray_dist, float radius)\n{\n    const float anisotropy = 0.3;\n\n    float a = dot(-light_dir, ray_dir);\n    float c = dot(light_dir, light_dir);\n    float h = 1.0/max(sqrt(c-a*a), radius);\n\n    float b = a+ray_dist;\n\n    // approximate mie scattering, but not physically accurate\n    h = pow(h, anisotropy + 1.0); \n\n    return (atan(b*h) - atan(a*h))*h;\n}\n\n// Gather in-scattering of all lights\n// rd : View ray direction\n// ro : View ray origin\n// t  : View ray length\nvec3 Scattering(vec3 rd, vec3 ro, float t) {\n\n    const float density = 0.02;\n    vec3 total_scatter = vec3(0);\n\n    for (int i=0; i<num_lights; ++i) {\n\n        PointLight light = lights[i];\n        vec3 lp = light.position;\n        float radius = light.radius;\n        vec3 lv = lp-ro;\n\n        float scatter = Scatter(rd, lv, t, radius);\n\n        total_scatter += scatter*light.color*light.energy;\n    }\n\n    return total_scatter * density;\n}\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = Gamma(color,1.0);\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n\nfloat smoothRand(float seed) {\n\n    float amplitude = 1.;\n    float frequency = 1.;\n    float y = sin((iTime+seed) * frequency);\n    float t = 0.01*(-(iTime+seed)*130.0);\n    y += sin(frequency*2.1 + t)*4.5;\n    y += sin(frequency*1.72 + t*1.121)*4.0;\n    y += sin(frequency*2.221 + t*0.437)*5.0;\n    y += sin(frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n\n    return y;\n}\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // central blue light\n    float x, y = 0.0;\n    float z = 2.0;\n\n    float r = 0.0;\n    float g = 0.5;\n    float b = 1.0;\n\n    addPointLight(vec3(x,y,z), vec3(r,g,b), 1.0, 0.3, 0.0);\n\n    // Picture in picture on\n    bool pip=true;\n\n    // Pixel\n    vec2 pixel=Pip(pxy, pip);\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n\n\n    CATCH_DEBUG(float t = SphereTrace(ro, rd, 1000.0, hit, s));\n\n    const float latitude = 0.0;\n    const float orbital_axis = 0.41015;\n    \n    // Position \n    vec3 pt = ro + t * rd;\n\n    DirectionalLight sun;\n    DirectionalLight moon;\n    \n    const float sunAzimuth = 1.5;\n    const float moonAzimuth = 1.0;\n    \n    float curr_time = iTime*TIME_SCALE + PI;\n\n    // curr_time = 6.7; // day\n    // curr_time = 9.3; // night\n    // curr_time = 1.6; // sunset\n\n    float earthRotTheta = curr_time;\n\n    mat3 celestial_rot = RotationX(earthRotTheta);\n    celestial_rot = RotationZ(earthRotTheta) * celestial_rot;\n    celestial_rot = RotationX(orbital_axis) * celestial_rot;\n\n    const vec3 sun_pos = vec3(cos(sunAzimuth), sin(sunAzimuth),0);\n    \n    float moonRotTheta = curr_time * 0.0338983;\n    mat3 moon_rot = RotationZ(moonRotTheta); // moon around earth\n    moon_rot *= RotationX(0.08970992); // moon orbit\n    vec3 moon_pos = moon_rot[0];\n\n    sun.direction = celestial_rot * sun_pos;\n    moon.direction = celestial_rot * moon_pos;\n\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    moon.energy = sunIntensity(moon.direction.z) * 5.0;\n\n    float elevation = acos(sun.direction.z) / PI_2;\n\n    vec3 rgb;\n\n    moon.color = GetSkyFex(moon)*0.005;\n    sun.color = GetSkyFex(sun)*19.0;\n    \n    // Some optimization for preventing useless shadow computation\n    if (sun.direction.z < 0.0) {\n        sun.shadow_dist = 0.0;\n        moon.shadow_dist = 100.0;\n    } else {\n        sun.shadow_dist = 100.0;\n        moon.shadow_dist = 0.0;\n    }\n\n\n    if (hit || rd.z < 0.0) {\n        vec3 n;\n\n        if (hit)\n            n = ObjectNormal(pt);\n        \n        else { // infinite ground plane \n            n = up;\n    \n            float co = rd.z;\n            float si = sqrt(1.0-co*co);\n            float ta = si/co;\n            \n            float a = ro.z - FLOOR_LEVEL;\n            float b = ta*a;\n\n            t = length(vec2(a,b));\n            pt = ro + t * rd;\n        }\n\n        // Shade object with light\n        rgb = Shade(pt, n, rd, sun, moon);\n\n        vec3 atmosphere = AtmosphericScattering(sun, moon, rd);\n        float fog = clamp(smoothstep(40.0,1000.0,t), 0.0, 1.0);\n        rgb = mix(rgb, atmosphere, fog);\n    }\n    else {\n        // Shade background\n        CATCH_DEBUG(rgb = background(rd, rd*celestial_rot, sun, moon));\n    }\n\n    // Volumetric lighting\n    rgb += Scattering(rd, ro, t);\n\n\n    // Auto exposure\n    float sun_ext = clamp(map(elevation, 0.98, 1.2, 0.0, 1.0), 0.0, 1.0);\n    sun_ext = smoothstep(0.0, 1.0, sun_ext);\n    float exposure_bias = mix(0.2, 20.0, sun_ext);\n    rgb *= exposure_bias;\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s);\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n\n    color = vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}