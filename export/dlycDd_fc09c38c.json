{"ver":"0.1","info":{"id":"dlycDd","date":"1700794460","viewed":41,"name":"Red Dotted Bobble","username":"yuchun1108","description":"an exercise piece","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float EPSILON=.001;\nconst int MAX_BALL_COUNT=16;\n\nvec4 balls[MAX_BALL_COUNT];\n\nfloat sphereSDF(vec3 samplePoint,vec3 center,float size){\n  return length(samplePoint-center)-size;\n}\n\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n  float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\n  return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nfloat sceneSDF(vec3 samplePoint){\n  float dist=MAX_DIST;\n  for(int i=0;i<MAX_BALL_COUNT;i++)\n  {\n    dist=opSmoothUnion(sphereSDF(samplePoint,balls[i].xyz * 2.,balls[i].w),dist,.8);\n  }\n  return dist;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_a,vec3 k_d,vec3 k_s,float alpha,vec3 p,vec3 eye,\nvec3 lightPos,vec3 lightIntensity){\n  vec3 N=estimateNormal(p);\n  vec3 L=normalize(lightPos-p);\n  vec3 V=normalize(eye-p);\n  vec3 R=normalize(reflect(-L,N));\n  \n  float dotLN=dot(L,N);\n  float dotRV=dot(R,V);\n  \n  if(dotLN<0.){\n    // Light not visible from this point on the surface\n    return vec3(0.,0.,0.);\n  }\n  \n  if(dotRV<0.){\n    // Light reflection in opposite direction as viewer, apply only diffuse\n    // component\n    return lightIntensity*(k_d*dotLN);\n  }\n  return lightIntensity*(k_d*dotLN+k_s*pow(dotRV,alpha));\n}\n\nvec3 illumination(vec3 k_a,vec3 k_d,vec3 k_s,float alpha,vec3 p,vec3 eye){\n  const vec3 ambientLight=.5*vec3(1.,1.,1.);\n  vec3 color=ambientLight*k_a*k_d;\n  \n  vec3 light1Pos=vec3(4.,2.,4.);\n  vec3 light1Intensity=vec3(.4,.4,.4);\n  \n  color+=phongContribForLight(k_a,k_d,k_s,alpha,p,eye,light1Pos,light1Intensity);\n  \n  return color;\n}\n\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord){\n  vec2 xy=fragCoord-size/2.;\n  float z=size.y/tan(radians(fieldOfView)/2.);\n  return normalize(vec3(xy,-z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat random (vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(int i=0; i<MAX_BALL_COUNT; i++)\n    {\n        balls[i].x = (random(vec2(0.4,i)) - .5) * 2.;\n        balls[i].z = (random(vec2(0.3,i)) - .5) * 2.;\n        balls[i].w = random(vec2(0.3,i)) * .8 + .8;\n        float y = random(vec2(0.2,i));\n        balls[i].y = sin(y * 10. + iTime) * 3.;\n    }\n\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 0., 32.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor=vec4(1.-(fragCoord.y/iResolution.y*.15+.85),0.,0.,1.);\n\t\treturn;\n    }\n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    bool isDot=length(mod(p,1.)-.5)<.3;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = vec3(.4902,.3882,.3882);\n    vec3 K_d=isDot?vec3(1.6,1.2,1.):vec3(.8118,.0902,.0902);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess=isDot?1.:2.;\n    \n    vec3 color = illumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}