{"ver":"0.1","info":{"id":"DlVGWt","date":"1694438987","viewed":130,"name":"Shitty Raytracer","username":"IntOverflow","description":"CONGRATULATIONS! YOU WON!","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["theworstraytracerevermade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0, uv);\n    fragColor = draw;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Material{\n    float refractionIndex;\n    float waveV;\n    float transparency;\n    float emitStrength;\n    float specularProb;\n    vec3 color;\n    vec3 specularColor;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    Material material;\n};\n\nstruct Triangle{\n    vec3 posA, posB, posC;\n    Material material;\n};\n\nstruct HitInfo{\n    bool didHit;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n    Material material;\n};\n\nHitInfo RaySphere(Ray ray, Sphere sphere){\n    vec3 sphereCentre = sphere.pos;\n    float sphereRadius = sphere.radius;\n    HitInfo hitInfo;\n    vec3 offsetRayOrigin = ray.origin - sphereCentre;\n    // From the equation: sqrLength(rayOrigin + rayDir * dst) = radius^2\n    // Solving for dst results in a quadratic equation with coefficients:\n    float a = dot(ray.dir, ray.dir); // a = 1 (assuming unit vector)\n    float b = 2.0 * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;\n    // Quadratic discriminant\n    float discriminant = b * b - 4.0 * a * c; \n\n    // No solution when d < 0 (ray misses sphere)\n    \n    // Distance to nearest intersection point (from quadratic formula)\n    float dst = (discriminant >= 0.0) ? (-b - sqrt(discriminant)) / (2.0 * a) : (-1.0);\n\n    // Ignore intersections that occur behind the ray\n    hitInfo.didHit = dst >= 0.0;\n    hitInfo.dst = dst;\n    hitInfo.hitPoint = ray.origin + ray.dir * dst;\n    hitInfo.normal = normalize(hitInfo.hitPoint - sphereCentre);\n    hitInfo.material = sphere.material;\n        \n    return hitInfo;\n}\n\nHitInfo RaySphereBack(Ray ray, Sphere sphere){\n    vec3 sphereCentre = sphere.pos;\n    float sphereRadius = sphere.radius;\n    HitInfo hitInfo;\n    vec3 offsetRayOrigin = ray.origin - sphereCentre;\n    // From the equation: sqrLength(rayOrigin + rayDir * dst) = radius^2\n    // Solving for dst results in a quadratic equation with coefficients:\n    float a = dot(ray.dir, ray.dir); // a = 1 (assuming unit vector)\n    float b = 2.0 * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;\n    // Quadratic discriminant\n    float discriminant = b * b - 4.0 * a * c; \n\n    // No solution when d < 0 (ray misses sphere)\n    \n    // Distance to further intersection point (from quadratic formula)\n    float dst = (discriminant >= 0.0) ? (-b + sqrt(discriminant)) / (2.0 * a) : (-1.);\n\n    // Ignore intersections that occur behind the ray\n    hitInfo.didHit = dst >= 0.0;\n    hitInfo.dst = dst;\n    hitInfo.hitPoint = ray.origin + ray.dir * dst;\n    hitInfo.normal = -normalize(hitInfo.hitPoint - sphereCentre);\n    hitInfo.material = sphere.material;\n    \n    return hitInfo;\n}\n\nHitInfo RayTriangleBack(Ray ray, Triangle tri){\n    vec3 edgeAB = tri.posC - tri.posA;\n    vec3 edgeAC = tri.posB - tri.posA;\n    vec3 normalVector = cross(edgeAB, edgeAC);\n    vec3 ao = ray.origin - tri.posA;\n    vec3 dao = cross(ao, ray.dir);\n\n    float det = -dot(ray.dir, normalVector);\n    float invDet = 1.0 / det;\n\n    // Calculate dst to triangle & barycentric coordinates of intersection point\n    float dst = dot(ao, normalVector) * invDet;\n    float u = dot(edgeAC, dao) * invDet;\n    float v = -dot(edgeAB, dao) * invDet;\n    float w = 1.0 - u - v;\n\n    // Initialize hit info\n    HitInfo hitInfo;\n    hitInfo.didHit = det >= 1E-6 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n    hitInfo.hitPoint = ray.origin + ray.dir * dst;\n    hitInfo.normal = normalize(normalVector);\n    hitInfo.dst = dst;\n    hitInfo.material = tri.material;\n    return hitInfo;\n}\n\nHitInfo RayTriangle(Ray ray, Triangle tri){\n    vec3 edgeAB = tri.posB - tri.posA;\n    vec3 edgeAC = tri.posC - tri.posA;\n    vec3 normalVector = cross(edgeAB, edgeAC);\n    vec3 ao = ray.origin - tri.posA;\n    vec3 dao = cross(ao, ray.dir);\n\n    float det = -dot(ray.dir, normalVector);\n    float invDet = 1.0 / det;\n\n    // Calculate dst to triangle & barycentric coordinates of intersection point\n    float dst = dot(ao, normalVector) * invDet;\n    float u = dot(edgeAC, dao) * invDet;\n    float v = -dot(edgeAB, dao) * invDet;\n    float w = 1.0 - u - v;\n\n    // Initialize hit info\n    HitInfo hitInfo;\n    hitInfo.didHit = det >= 1E-6 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n    hitInfo.hitPoint = ray.origin + ray.dir * dst;\n    hitInfo.normal = normalize(normalVector);\n    hitInfo.dst = dst;\n    hitInfo.material = tri.material;\n    return hitInfo;\n}\n\n// == Scene 1 ==\n\n// Spheres\n\n/**\n// Constants\n\nconst float PI = 3.1415926535897932;\nconst float FOV = 120.0;\nconst vec3 camOrig = vec3(0.0, 0.0, 0.0);\n\nconst int triCnt = 2;\nconst int sphCnt = 4;\nconst int sampPerPixel = 10;\nconst int maxBounce = 9;\nconst float redWave = 0.610;\nconst float greenWave = 0.545;\nconst float blueWave = 0.425;\n\nconst Triangle[2] sceneTri = Triangle[2](\n    Triangle(\n        vec3(1.0, -5.0, 1.0),\n        vec3(8.0, 6.0, 1.0),\n        vec3(8.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(1.0, -5.0, 1.0),\n        vec3(1.0, 6.0, 1.0),\n        vec3(8.0, 6.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    )\n);\nconst float time = 1.25;\nconst Sphere[4] sceneSph = Sphere[4](\n    Sphere(\n        vec3(-cos(time) * 2.0 + 3.0, -3.0, -2.0),\n        1.0,\n        Material(0., 0., 0., 0., 0., vec3(0.3, 0.9, 0.9), vec3(0., 0., 0.))\n    ),\n    Sphere(\n        vec3(-cos(time) * 2.0 + 3.0, -3.0, 0.0),\n        1.0,\n        Material(0., 0., 0., 0., 1.0, vec3(0.8706, 0.7216, 0.5294), vec3(1.0, 1.0, 1.0))\n    ),\n    Sphere(\n        vec3(cos(time) * 2.0 + 3.0, -1.0, 0.0),\n        1.0,\n        Material(1.0 / 1.3, 0.00459, 1.0, 0.0, 0.2, vec3(0., 0., 0.), vec3(1.0, 1.0, 1.0))\n    ),\n    Sphere(\n        vec3(1.0, 5.0, -8.0),\n        6.0,\n        Material(0., 0., 0., 60., 0., vec3(1.0, 1.0, 1.0), vec3(0., 0., 0.))\n    )\n);\n**/\n\n// == Scene 2 ==\n\n// Prism\nconst float PI = 3.1415926535897932;\nconst float FOV = 120.0;\nconst vec3 camOrig = vec3(0.0, 0.0, 0.0);\n\nconst int triCnt = 21;\nconst int sphCnt = 1;\nconst int sampPerPixel = 1;\nconst int maxBounce = 9;\nconst float redWave = 0.610;\nconst float greenWave = 0.545;\nconst float blueWave = 0.425;\n\nconst float time = 3.5;\nconst float prisSize = 0.0;\nconst vec3 prisPos = vec3(4.9, -3.0, -2.1);\nconst Material prisMat = Material(1.0 / 1.2, 0.0159, 1.0, 0.0, 0.2, vec3(0., 0., 0.), vec3(1.0, 1.0, 1.0));\n\nconst Triangle[21] sceneTri = Triangle[21]( // 21\n    // floor\n    Triangle(\n        vec3(-3.0, -5.0, 1.0),\n        vec3(-3.0, 6.0, 1.0),\n        vec3(8.0, 6.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(-3.0, -5.0, 1.0),\n        vec3(8.0, 6.0, 1.0),\n        vec3(8.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ), \n    // ceil\n    Triangle(\n        vec3(-3.0, 6.0, -4.0),\n        vec3(-3.0, -5.0, -4.0),\n        vec3(8.0, 6.0, -4.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(8.0, 6.0, -4.0),\n        vec3(-3.0, -5.0, -4.0),\n        vec3(8.0, -5.0, -4.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ), \n    // wall front\n    Triangle(\n        vec3(5.0, 6.0, -10.0),\n        vec3(5.0, -5.0, 1.0),\n        vec3(5.0, 6.0, 1.0),\n        Material(0., 0., 0., 0., 0.0, vec3(0.8706, 0.7216, 0.5294), vec3(1.0, 1.0, 1.0))\n    ),\n    Triangle(\n        vec3(5.0, 6.0, -10.0),\n        vec3(5.0, -5.0, -10.0),\n        vec3(5.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0.0, vec3(0.8706, 0.7216, 0.5294), vec3(1.0, 1.0, 1.0))\n    ),\n    // wall back\n    Triangle(\n        vec3(-1.0, -5.0, 1.0),\n        vec3(-1.0, 6.0, -10.0),\n        vec3(-1.0, 6.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(-1.0, -5.0, -10.0),\n        vec3(-1.0, 6.0, -10.0),\n        \n        vec3(-1.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    // wall left\n    Triangle(\n        vec3(-6.0, 6.0, 1.0),\n        vec3(5.0, 6.0, -20.0),\n        vec3(5.0, 6.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    // wall right\n    Triangle(\n        vec3(5.0, -5.0, -2.0),\n        vec3(-2.0, -5.0, 1.0),\n        vec3(5.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(5.0, -5.0, -2.0),\n        vec3(-2.0, -5.0, -2.0),\n        vec3(-2.0, -5.0, 1.0),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    // upper wall right\n    Triangle(\n        vec3(5.0, -5.0, -6.0),\n        vec3(-2.0, -5.0, -2.2),\n        vec3(5.0, -5.0, -2.2),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    Triangle(\n        vec3(5.0, -5.0, -6.0),\n        vec3(-2.0, -5.0, -6.0),\n        vec3(-2.0, -5.0, -2.2),\n        Material(0., 0., 0., 0., 0., vec3(0.8706, 0.7216, 0.5294), vec3(0., 0., 0.))\n    ),\n    // prism front\n    Triangle(\n        prisPos + vec3(0.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(0.0, sin(time), cos(time)),\n        prisPos + vec3(0.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisMat\n    ),\n    // prism back\n    Triangle(\n        prisPos + vec3(-1.0, sin(time), cos(time)),\n        prisPos + vec3(-1.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisMat\n    ),\n    // prism 1st wall\n    Triangle(\n        prisPos + vec3(0.0, sin(time), cos(time)),\n        prisPos + vec3(0.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time), cos(time)),\n        prisMat\n    ),\n    Triangle(\n        prisPos + vec3(0.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time), cos(time)),\n        prisMat\n    ),\n    // prism 2nd wall\n    Triangle(\n        prisPos + vec3(0.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisPos + vec3(0.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisMat\n    ),\n    Triangle(\n        prisPos + vec3(0.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisPos + vec3(-1.0, sin(time + PI * 2.0 / 3.0), cos(time + PI * 2.0 / 3.0)),\n        prisMat\n    ),\n    // prism 3rd wall\n    Triangle(\n        prisPos + vec3(0.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisPos + vec3(0.0, sin(time), cos(time)),\n        prisPos + vec3(-1.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisMat\n    ),\n    Triangle(\n        prisPos + vec3(0.0, sin(time), cos(time)),\n        prisPos + vec3(-1.0, sin(time), cos(time)),\n        prisPos + vec3(-1.0, sin(time + PI * 4.0 / 3.0), cos(time + PI * 4.0 / 3.0)),\n        prisMat\n    )\n);\nconst Sphere[1] sceneSph = Sphere[1](\n    Sphere(\n        vec3(4.0, -6.0, -2.25),\n        1.0,\n        Material(0., 0., 0., 600., 0., vec3(1.0, 1.0, 1.0), vec3(0., 0., 0.))\n    )\n);\n\n// ===\n\n// PRNG Calculations\n\n// PCG (permuted congruential generator).\n\nuint NextRandom(uint state)\n{\n    state = state * uint(747796405) + uint(2891336453);\n    uint result = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    result = (result >> 22) ^ result;\n    return result;\n}\n\nfloat RandomValue(uint state)\n{\n    return float(NextRandom(state)) / 4294967295.0; // 2^32 - 1\n}\n\n// Random value in normal distribution (with mean=0 and sd=1)\nfloat RandomValueNormalDistribution(uint state)\n{\n    // Thanks to https://stackoverflow.com/a/6178290\n    float theta = 2.0 * 3.1415926 * RandomValue(state);\n    float rho = sqrt(-2.0 * log(RandomValue(state + uint(1))));\n    return rho * cos(theta);\n}\n\n// Calculate a random direction\nvec3 RandomDirection(uint state)\n{\n    // Thanks to https://math.stackexchange.com/a/1585996\n    float x = RandomValueNormalDistribution(state);\n    float y = RandomValueNormalDistribution(state + uint(2));\n    float z = RandomValueNormalDistribution(state + uint(4));\n    return normalize(vec3(x, y, z));\n}\n\nvec2 RandomPointInCircle(uint rngState)\n{\n    float angle = RandomValue(rngState) * 2.0 * PI;\n    vec2 pointOnCircle = vec2(cos(angle), sin(angle));\n    return pointOnCircle * sqrt(RandomValue(rngState + uint(1)));\n}\n\nvec2 mod2(vec2 x, vec2 y)\n{\n    return x - y * floor(x / y);\n}\n\n// The Tracing\n\nvec3 trace(Ray ray, vec3 col, int sampleNum){\n    ray.dir = normalize(ray.dir);\n    bool inMat = false;\n    float matRefract = 0.0;\n    uint randSeed = NextRandom(uint(sampleNum + iFrame + int(float(NextRandom(uint(ray.dir.x * 12083344.0))) * ray.dir.z * ray.dir.y)));\n    for(int bounceNum = 0; bounceNum < maxBounce; bounceNum ++){\n        if(inMat){\n            HitInfo close;\n            close.dst = 10000.0;\n            close.didHit = false;\n\n            for(int i = 0; i < triCnt; i++){\n                HitInfo newHit = RayTriangleBack(ray, sceneTri[i]);\n                if(newHit.didHit && newHit.dst < close.dst){\n                    close = newHit;\n                }\n            }\n\n            for(int i = 0; i < sphCnt; i++){\n                HitInfo newHit = RaySphereBack(ray, sceneSph[i]);\n                if(newHit.didHit && newHit.dst < close.dst){\n                    close = newHit;\n                }\n            }\n\n            //col = vec3(abs(normalize(close.normal)) * 30.0);\n            //break;\n\n            if(!close.didHit){ // oopsies!\n                col = vec3(((length(ray.dir) > 0.00001) ? (40.0) : (0.0)), ((length(ray.dir) > 0.000001) ? (0.0) : (40.0)), 0.0);\n                break;\n            }\n            vec3 nextdir;\n            nextdir = refract(ray.dir, normalize(close.normal), 1.0 / matRefract);\n            ray.origin = close.hitPoint;\n            if(length(nextdir) < 0.0001){ // Total internal reflection\n                ray.dir = reflect(ray.dir, normalize(close.normal));\n                continue;\n            }\n            ray.dir = nextdir;\n            inMat = false;\n            continue;\n        }\n        HitInfo close;\n        close.dst = 10000.0;\n        close.didHit = false;\n\n        for(int i = 0; i < triCnt; i++){\n            HitInfo newHit = RayTriangle(ray, sceneTri[i]);\n            if(newHit.didHit && newHit.dst < close.dst){\n                close = newHit;\n            }\n        }\n\n        for(int i = 0; i < sphCnt; i++){\n            HitInfo newHit = RaySphere(ray, sceneSph[i]);\n            if(newHit.didHit && newHit.dst < close.dst){\n                close = newHit;\n            }\n        }\n        \n        //col = vec3(abs(normalize(close.normal)) * 30.0);\n        //break;\n        \n        if(!close.didHit){\n            col *= (-ray.dir.z + 1.0) * vec3(0.5, 0.7, 1.0) + (ray.dir.z) * vec3(1.0, 1.0, 1.0);\n            //col *= vec3(1.0, 0.0, 0.0);\n            col *= 30.0;\n            break;\n        }\n        \n        if(close.material.emitStrength > 0.001){\n            col *= close.material.color * close.material.emitStrength;\n            break;\n        }\n\n        Ray next;\n        randSeed = NextRandom(uint(iFrame) + randSeed + uint(float(NextRandom(uint(ray.dir.x * 12083344.0))) * ray.dir.z * ray.dir.y) + uint(sampleNum));\n        float rand = RandomValue(randSeed);\n        \n        //col = vec3(30.0 - distance(camOrig, close.hitPoint) * 6.0);\n        //break;\n        \n        if(rand < close.material.specularProb){\n            next.origin = close.hitPoint;\n            next.dir = reflect(ray.dir, normalize(close.normal));\n            col *= close.material.specularColor;\n            ray = next;\n            continue;\n        }\n        if(RandomValue(NextRandom(randSeed)) <= close.material.transparency){\n            ray.origin = close.hitPoint;\n            \n            // Since all we have is R, G, and B, we only need to consider the change for R, G, and B.\n            \n            float randget = RandomValue(NextRandom(uint(iFrame) + NextRandom(randSeed) + uint(float(NextRandom(uint(ray.dir.x * 12083344.0))) * ray.dir.z * ray.dir.y)));\n            \n            float wave = 0.0;\n            \n            if(randget < 0.3333){\n                wave = redWave;\n                col *= vec3(3.0, 0.0, 0.0);\n            }else if(randget < 0.6667){\n                wave = greenWave;\n                col *= vec3(0.0, 3.0, 0.0);\n            }else{\n                wave = blueWave;\n                col *= vec3(0.0, 0.0, 3.0);\n            }\n            \n            // Cauchy's stupid formula\n            matRefract = 1.0 / ( 1.0 / close.material.refractionIndex + close.material.waveV / (wave * wave));\n            \n            ray.dir = refract(ray.dir, normalize(close.normal), matRefract);\n            \n            /*if(dot(ray.dir, -close.normal) < 0.2){\n                col = vec3(0.);\n                break;\n            }*/\n            inMat = true;\n            continue;\n        }\n        next.origin = close.hitPoint;\n        next.dir = normalize(RandomDirection(randSeed) + normalize(close.normal));\n        col *= close.material.color;\n        ray = next;\n    }\n    return col;\n}\n\nconst float planeSize = 1.0; // tan(FOV / 360.0 * PI); // Angle is in degrees; to radians and divide two.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1) for x\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    Ray camRay;\n    \n    int seed = int(fragCoord.x) * 2 * sampPerPixel + int(fragCoord.y) * 2 * sampPerPixel + iFrame * (int(iResolution.x) * 2 * sampPerPixel + int(iResolution.y) * 2 * sampPerPixel);\n    \n    camRay.origin = camOrig;\n    camRay.dir = vec3(1.0, (1.0 - uv.x * 2.0) * iResolution.x / iResolution.y, 1.0 - uv.y * 2.0);\n    \n    // Grab Trace\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    for(int i = 0; i < sampPerPixel; i++){\n        vec3 offset = vec3(0.0, 2.0 / iResolution.y * RandomValue(uint(seed + i * 2)), 2.0 / iResolution.y * RandomValue(uint(seed + i * 2 + 1)));\n        camRay.dir += offset;\n        col += trace(camRay, vec3(1.0, 1.0, 1.0), seed + i * 2) / float(30.0);\n        camRay.dir -= offset;\n    }\n    \n    // HDR conversion\n    \n    // Nope. :D\n    \n    // Average with previous frames\n    // (Also undoing Gamma Correction while we're at it)\n    \n    vec4 draw = texture(iChannel0, uv) * texture(iChannel0, uv) * float(sampPerPixel);\n    \n    vec4 fin = vec4(col / (float(iFrame) + 1.0), 1.0) + draw * (float(iFrame) / (float(iFrame) + 1.0));\n    \n    // Gamma Correction\n    \n    float scale = 1.0 / float(sampPerPixel);\n    fin.x = sqrt(scale * fin.x);\n    fin.y = sqrt(scale * fin.y);\n    fin.z = sqrt(scale * fin.z);\n    \n    // Output to screen\n    fragColor = fin;\n}","name":"Buffer A","description":"","type":"buffer"}]}