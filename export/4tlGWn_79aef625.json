{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//-----------------------------\n#define time iTime\n#define EPSILON .001\n//#define lightDir lightPos\nconst int MAX_ITER = 150;\nint colorIndex = 0;\nbool bReflection = true;\nbool bShadow = true;\nvec3 lightPos = vec3(-1.5, -7.8, 23.);\nvec3 camPos = vec3(0.0, -3.6, 17.9);\nvec3 camDir = vec3(0.0, 0.0, -1.0);\nvec3 camUp  = vec3(0.0, 1.0, 0.0);\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n  float koffReflecr;    // ÐºÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ\n  vec3 color;           // Ñ†Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\n     \n};\nmat material = mat(0.0, 1.0, vec3(1.));\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir, out float object);\n//-----------------------------\n// Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ - Ð¿ÐµÑ€ÐµÑÑ‡ÐµÑ‚ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//------------------------------------------\n//------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n\n//------------------------------------------\n//----------------------------------------------------Ð¨Ð°Ñ€\nfloat distsphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------Ð¢Ð¾Ñ€\nfloat disttorus(vec3 p, vec2 t)\n{\n   vec2 q = vec2(length(p.xz) - t.x, p.y);\n   return length(q) - t.y;\n}\n//------------------------------------------Ð¡ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð±Ð»Ð¾Ðº\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n//----------------------------------------------------ÐšÑƒÐ±\nfloat distbox(vec3 p, vec3 b)\n{\n   return length(max(abs(p) - b, 0.0));\n}\n//------------------------------------------Ð¦Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nvec3 getmaterial( in vec3 p,  in float mat)\n{\n  vec3 pos = p; \n  vec3 color = vec3(1.);\n \n if(mat == 0.0)\n    color = vec3(0.5);\n  else if (mat == 1.0)\n    color = vec3(0.0, 1.0, 0.17);\n  else if(mat == 2.0)\n      color =  vec3(1.0); \n  else if(mat == 3.0)\n    color =   vec3(floor(length(floor(mod(pos, 2.0)+0.5))-0.5)); \n  else if(mat == 4.0)\n     color = vec3(1.0, 0.84, 0.91);\n  else color = vec3(1., 1.0, 0.0);   \n return color; \n}\n//------------------------------------------\n//-------------------------------------------------\nvec3 getlighting(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   float b = max(0.0, dot(normal, lightDir));\n   return b * color;\n}\n//-------------------------------------------------\n//-------------------------------------------------ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð¾ÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ñ Ð¿Ð¾ Ð¤Ð¾Ð½Ð³Ñƒ\nvec3 getlightingPhong(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n    \n    \n    vec3   l = normalize (lightDir-pos);   \n    vec3   v = normalize(camPos-pos);\n\n    vec3   n = normalize (normal);        \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = vec3(0.92, 0.98, 1.0) * pow ( max ( dot ( l, r ), 0.0 ), 32.0 );\n    \n    return diff + spec;\n}\n//-------------------------------------------------Ð¢ÐµÐ½ÑŒ\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n   float sh = 1.0;\n   float t = mint;\n   float h = 0.0;\n   for (int i = 0; i < 10; i++) {\n      if(t > maxt)\n         continue;\n      h = renderFunction(ro+rd*t);\n      sh = min(sh, k*h/t);\n      t += h;\n   }\n   return sh;\n}\n//-------------------------------------------------ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²\nvec3 colorScene(in vec3 posOnRay, in vec3 normal, in vec3 lightDir, in float numMaterial)\n{\n   vec3 color = vec3(0.0);\n   vec3 materialColor = getmaterial(posOnRay, numMaterial); \n\n    color = getlightingPhong(posOnRay, normal, lightDir, materialColor); // ÐŸÐ¾ Ð¤Ð¾Ð½Ð³Ñƒ   \n   \n   return color;\n}\n//-------------------------------------------------\nvec3 reflectColor(in vec3 posOnRay, in vec3 rayDir)\n{\n  vec3 color = vec3(1.0);\n  vec3 result_color = vec3(1.0);\n  float object = 1.0;\n  vec3 normal = vec3(1.0);\n  float k_reflectivity = 1.0;\n  vec3 lightDir ;\n    \n      for (int i = 0; i < 5; i++) \n      {\n      lightDir = normalize(lightPos - posOnRay); //ÐÐ°Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ðº ÑÐ²ÐµÑ‚Ñƒ \n      float path =  render(posOnRay, rayDir, object);\n       // Ñ‚Ð¾Ñ‡ÐºÐ°, Ð² ÐºÐ¾Ñ‚Ð¾Ñ€ÑƒÑŽ Ð¿Ñ€Ð¸ÑˆÐ»Ð¸   \n       vec3 pos = posOnRay + rayDir * path;\n       if(path < 0.0) break;\n\n       color =  getmaterial( pos,  material.typeMat);\n       normal = normalize(getNormal(pos));\n//       color =  getlighting(pos, normal, lightDir, color);\n       color =  colorScene(pos, normal, lightDir,material.typeMat);\n\n    //   result_color *= k_reflectivity * color;\n \n         result_color = mix(result_color, color, k_reflectivity);\n\n         k_reflectivity *= material.koffReflecr;\n      if(bShadow) // Ð¢ÐµÐ½ÑŒ\n      {\n         float sh = softshadow(pos, lightDir, 0.2, 20.0, 7.0); \n         result_color *= sh;       \n      }            \n          \n       if (k_reflectivity < .1) break;\n      \n       // Ð¾Ñ‚Ñ€Ð°Ð·Ð¸Ð¼ Ð»ÑƒÑ‡ Ð¸ Ð½Ð°Ñ‡Ð½ÐµÐ¼ Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¹ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\n       rayDir = normalize(reflect(rayDir, normal));\n       posOnRay = pos + rayDir * EPSILON*2.;    \n\n    }\n  \n  return result_color;\n\n}\n\n//---------------------------------------------------\n\nfloat myObject(in vec3 p)\n{\n\n vec3 pos = p; \n\n float ballMy = 1., tor = 1.0, cube = 1.0, cube1 = 1.0;\n float plan = udRoundBox(pos+vec3(0.0,-4.0,2.2), vec3(15.0,0.01,15.0),0.0);\n \n pos.y -= -4.79;\n pos.z -= -2.0;\n ballMy = distsphere(pos, 2.);\n \n vec3 pos1 = rotationCoord(pos, 7.); \n\n tor = disttorus( pos1 ,vec2(3.8, 0.79)); \n\n cube = udRoundBox(pos + vec3(-0.4, 1.35, 8.37), vec3(10., 7.0, 0.5),0.0);\n// cube = min(cube,udRoundBox(pos + vec3(-7.5, -0.6, -6.0), vec3(0.5, 4.0, 5.0),0.0));\n vec3 offset = vec3(8.69, -3.73, -5.6); \n offset.y *= sin(time );   \n cube1 = udRoundBox(pos + offset, vec3(0.5, 4.0, 7.0),0.0);\n//--------\n\n     material.typeMat = 2.0;\n     material.koffReflecr = 1.0;\n float closest = ballMy;\n float sample1 = plan;\n if (sample1 < closest) \n { // Ð¿Ð¾Ð»\n      // Ð·Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼ ÐºÐ°Ðº Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐ¸Ð¹\n      closest = sample1; \n     material.typeMat = 3.0;\n     material.koffReflecr = 0.5;\n }\n sample1 = tor;\n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 1.0;\n   material.koffReflecr = 1.0; \n } \n sample1 = cube; \n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 4.0;\n   material.koffReflecr = 0.0;  \n }\n\n sample1 = cube1; \n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 7.;\n   material.koffReflecr = 0.8; \n }  \n//--------\n\n \nreturn closest;\n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n  float result;\n  vec3 pos1 = pos;\n\n    result = myObject(pos1);    \n  return result;\n}\n\n//-------------------------------------------------\n//-------------------------------------------------ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð½Ð¾Ñ€Ð¼Ð°Ð»Ð¸  \nvec3 getNormal(in vec3 p)\n{\n  const float e = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(e,0.0,0.0)) - renderFunction(p+vec3(-e,0.0,0.0)),\n        renderFunction(p+vec3(0.0,e,0.0)) - renderFunction(p+vec3(0.0,-e,0.0)),\n        renderFunction(p+vec3(0.0,0.0,e)) - renderFunction(p+vec3(0.0,0.0,-e))\n      )\n    );\n}\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir, out float object)\n{ \n  float t = 0.0;\n\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay + t*rayDir); \n    t += object;\n    if (object < EPSILON*t) \n      { t = -t; break; } // ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ Ð¼ÐµÐ½ÑŒÑˆÐµ Ð¿Ð¾Ñ€Ð¾Ð³Ð¾Ð²Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ, Ð²Ñ‹Ñ…Ð¾Ð´Ð¸Ð¼\n    \n  }\n   return -t;\n\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  vec2 pos =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;\n  pos = -pos;\n    \n  vec3 camSide  = cross(camDir, camUp);\n  vec3 rayDir   = normalize(camSide*pos.x + camUp*pos.y + camDir);\n\n  float object   = 1.;\n  vec3 color    = vec3(1.0);\n  vec3 backColor = vec3(0.5);\n  vec3 lightDir = normalize(lightPos);\n  vec3 normal = vec3(1.0);\n\n   vec3 result_color = vec3(1.);\n//------------------------------\n\n  vec3 posOnRay = camPos;\n     // Ð²ÐµÑ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð»ÑƒÑ‡Ð°\n  float k_reflectivity = 1.;\n  float path = 0.;\n  //--------------------------- \n\n  path =  render(posOnRay, rayDir, object);   \nif(abs(object) < 0.1)\n{\n   if(!bReflection)\n   {\n   lightDir = normalize(lightPos - posOnRay); //ÐÐ°Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ðº ÑÐ²ÐµÑ‚Ñƒ \n \n       posOnRay = posOnRay + rayDir * path;\n\n       color =  getmaterial( posOnRay,  material.typeMat);\n      normal = normalize(getNormal(posOnRay));\n//      color =  colorScene(posOnRay, normal, lightDir, object.y); \n      color = getlighting(posOnRay, normal, lightDir, color);\n      if(bShadow)\n      {\n         float sh = softshadow(posOnRay, lightDir, 0.2, 20.0, 7.0); \n         color *= sh;       \n      }\n      result_color *=  color;\n      fragColor = vec4(result_color, 1.);    \n   } // Ð±ÐµÐ· Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ\n   else // Ñ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸ÐµÐ¼\n   {\n   result_color = reflectColor(posOnRay, rayDir);\n    fragColor = vec4(result_color, 1.); \n   }// Ñ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸ÐµÐ¼\n}\nelse // Ñ„Ð¾Ð½ \n{\n   fragColor = vec4(backColor, 1.); \n} \n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tlGWn","date":"1420784551","viewed":250,"name":"Reflection and shadow","username":"Lio","description":"Perhaps there is an error in the algorithm. Help fix ... :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","shadow"],"hasliked":0,"parentid":"","parentname":""}}