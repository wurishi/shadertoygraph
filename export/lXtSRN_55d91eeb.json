{"ver":"0.1","info":{"id":"lXtSRN","date":"1718861614","viewed":117,"name":"shader code 18/06","username":"avgilles","description":"fuze !","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["softshadowraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sat(a) clamp(a, 0., 1.)\n\nfloat hash11(float seed){\n\n    return fract(sin(123.456*seed)*123.456);\n}\nfloat _seed;\nfloat rand()\n{\n    return hash11(_seed++);\n}\n\n\nfloat map(vec3 p){\n    float acc =  1000000000000.;\n\n    float sphere = length(p)-1.;\n    float grid = -p.y;\n    grid-= sin(p.x *.1)*.1+sin(p.x *3.+p.z *.5)*.2 + sin(p.x*.8 + p.y*.5);\n    \n    vec3 ptube = p;\n    float rep =.5;\n    \n    ptube -= vec3(2, 0.,0.);\n    \n    float id = floor((ptube.z + rep*.5)/rep);\n    ptube.x += sin(id*.1)*1.5;\n    \n    \n    ptube.z  = mod(ptube.z + rep*.5,rep)-rep*.5;\n    \n    \n    ptube.x += (sin(iTime + ptube.y+ id*.2)*.5 \n    +sin(.5*iTime+ ptube.y*2.+id*.2)*.2) * sat(-p.y*.5);\n    float tube = length(ptube.xz)-.02;\n    \n    acc = min(acc, sphere);\n    acc = min(acc, grid);\n    acc = min(acc, tube);\n    \n    return acc;\n}\nvec3 accCol;\nfloat trace(vec3 ro, vec3 rd){\n    \n    accCol = vec3(0.);\n    \n    vec3 p = ro; \n    for (int i=0; i< 128;++i)\n    {\n        float d = map(p);\n        if(d < 0.01){\n        \n            return distance(p, ro);\n                        \n        }\n        //accCol += vec3(1.) * (1.-sat(d/.2))*.01;\n        accCol += vec3(1.) *.04 * texture(iChannel1, p.xz *.5).x;\n        \n        p+=rd*d;\n    }\n    return -1.;\n\n}\n\nvec3 getCam(vec2 uv, vec3 rd)\n{\n    vec3 right = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(rd, right));\n    \n    return normalize(rd + right*uv.x + up*uv.y);\n}\n\nvec3 offsetDOF(vec3 ro, vec3 rd){\n\n    vec3 right = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(rd, right));\n    float factor = .2;\n    return ro\n    +right*(rand()-.5)*factor\n    +up*(rand()-.5)*factor;\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(map(p))\n    - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n        ));       \n}\n\nvec3 render(vec2 uv){\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-.5,sin(iTime)*1.-3.,-15.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    ro = offsetDOF(ro, rd);\n    rd = normalize(ta-ro);    \n    rd = getCam(uv, rd);\n    \n    \n    float dist = trace(ro, rd);\n    float depth  = 100000.;\n    vec3 acc = accCol;\n    if (dist > 0.){\n        depth = dist;\n        vec3 p = ro + rd * dist;\n        vec3 n = getNorm(p);\n        \n        vec3 lightpos = -vec3(5., 5., 5.);\n        lightpos.x += sin(iTime) * 10.;\n        lightpos += 0.1*normalize(vec3(rand(),rand(),rand())-.5);\n        \n        vec3 roshadow = p+n*.01;\n        vec3 rdshadow = normalize(lightpos - roshadow);\n        float diff = sat(dot(rdshadow, n));\n        \n        float shadowdist = trace(roshadow, rdshadow);\n        \n        col = vec3(0.373, 0.361, 0.271)*texture(iChannel0, p.xz).x * diff; \n        //col = n*0.5+0.5;\n        \n        if (shadowdist > .0 && shadowdist < distance(roshadow, rdshadow)){\n            col *= 0.5;\n        }\n        \n    }\n    col += acc;\n    col = mix(col , vec3(0.1,.2,.3), 1.-exp(-depth*.08));\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime* texture(iChannel0, uv).x;\n    \n    // Time varying pixel color\n    vec3 col = render(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}