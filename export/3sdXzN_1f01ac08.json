{"ver":"0.1","info":{"id":"3sdXzN","date":"1572093875","viewed":286,"name":"ball lattice 2","username":"kabacis","description":"Variation of ball lattice but with different visualization.\nhttps://www.shadertoy.com/view/wdG3Wd\n\nSimulates a bunch of balls, with line drawn when they are sufficiently close. Line color is chosen based on `6 * angle` resulting clearly visible grain.\n","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["lattice","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 ballD(in vec2 ipos, in vec2 ballp)\n{\n    float d = distance(ipos, ballp)/BALL_SIZE;\n    return vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ballp.x > 0.0)) ;\n}\n\nfloat line(vec2 a, vec2 b, vec2 p) {\n    vec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 v =  pa - ba*h ;\n    return length(v);\n}\n\nvec2 addAngle(vec2 a, vec2 b)\n{\n    return mat2(a.x, a.y, -a.y, a.x)*b;\n}\n\nvec2 times6(vec2 a)\n{\n    vec2 t2 = addAngle(a, a);\n    vec2 t3 = addAngle(t2, a);\n    return addAngle(t3, t3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = iMouse.z > 0.0 && iMouse.x < 30.0 ? clamp(SIZE*(iMouse.y/iResolution.y), 0.01, SIZE) : 1.0;\n    vec2 fcord = fragCoord * scale + iMouse.xy * vec2(1.0, 0.3);\n    ivec2 cellIndex = ivec2(fcord / SIZE);\n    vec2 cellp = mod(fcord, SIZE * scale)/(SIZE * scale);\n\n\n    vec2 worldPos = fcord;\n    float overlaps = 0.0;\n    vec4 normSum = vec4(0.0);\n    vec4 res = vec4(0);\n    float cnt = 1.;\n    \n    //vec4 pos = vec4(0);\n    for (int x=-2; x<=2; x++) {\n        for (int y=-2; y<=2; y++) {\n            \n            ivec2 tp = max(cellIndex+ivec2(x,y), ivec2(0));\n        \tvec4 ball  = texelFetch( iChannel0, tp, 0 );\n            vec2 p = ball.xy;\n            vec2 vel = ball.zw;\n            p *= iResolution.xy;\n            \n              for (int x2=-1; x2<=1; x2++) {\n        \t\tfor (int y2=-1; y2<=1; y2++) {\n            \n                    ivec2 tp2 = max(cellIndex+ivec2(x2,y2), ivec2(0));\n                    vec4 ball2  = texelFetch( iChannel0, tp2, 0 );\n                    vec2 p2= ball2.xy;\n                    p2 *= iResolution.xy;\n                    \n                    vec2 ab = p - p2;\n                    float abl = dot(ab, ab);;\n                    float ds = (line(p, p2, fcord));\n                    if (abl < BALL_D * BALL_D * 1.1 && ds < 0.3+scale  ) {\n                        //ds = sqrt(ds);\n                    \t//float a = atan(ab.y, ab.x)+0.0;\n                        //a *= 6.0; // multiply angle by six so that everying in hexagonal lattice have the same color\n                        //vec4 color = max(vec4(sin(a), cos(a), -sin(a)-cos(a), 1.0), 0.0);\n                        //vec2 t6=times6(normalize(ab));\n                        vec2 t6 = times6(ab/(BALL_D)); // length(ab) ~ BALL_D\n                        vec4 color = max(vec4(t6.y, t6.x, -t6.x-t6.y, 1.0), 0.0);\n                        \n                        //res = mix(res, color * (1.-smoothstep(0.3, 0.3+scale, ds)), 1./cnt);\n                        //cnt += (1.-smoothstep(0.3, 0.3+scale, ds));\n                        res = max(res, color * (1.-smoothstep(0.3, 0.3+scale, ds))); // Thanks FabriceNeyret2                 \n                    }\n                }\n              }\n        }\n    }\n    fragColor = res;\n    //fragColor = res * vec4(2.0 - overlaps, 3.0 - 2.0*overlaps, 1.0, 1.0);\n    //fragColor = normSum+vec4(1.0, 1.0, 1.0,1.0)*0.5;\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 getV(in vec2 p){\n    if (p.x < 0.001 || p.y < 0.001) return vec4(0);\n\treturn texelFetch( iChannel0, ivec2(p), 0 )* vec4(iResolution.xy, 1.0, 1.0);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid sim_step( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 middle = SIZE * (fragCoord);\n    bool mouseReset = iMouse.z > 0.0 && iMouse.x >= iResolution.x - 30.0 && iMouse.y >= iResolution.y - 30.0;\n    if (iFrame == 0 || mouseReset) {\n        ivec2 iv = ivec2(fragCoord);\n        if ((iv.x + iv.y) %2 == 0 && iv.y % 2 == 0 && iv.y < H) {\n    \t\tfragColor = vec4((middle+ (rand(fragCoord)-0.5)* SIZE*0.25), 0, 0);\n        } else {\n        \tfragColor = vec4(0); // -2.0*BALL_SIZE\n        }\n    } else {\n        vec4 v = vec4(0);\n        for (int x=-1; x<=1; x++) {\n            for (int y=-1; y<=1; y++) {\n                \n                vec2 np = fragCoord + vec2(x,y);\n                vec4 p = getV(np);\n                v += float(trunc(middle/SIZE) == trunc(p.xy/SIZE)) * p;\n            }\n        }\n        if (v.x > 0.0){\n            // apply force\n            vec2 dr = vec2(0);//vec2(0.0, -0.01);\n            \n            \n            float stress = 0.0;\n            for (int x=-2; x<=2; x++) {\n                for (int y=-2; y<=2; y++) {\n\n                    if (x !=0 || y != 0) \n                    {\n                        vec4 p = getV(fragCoord + vec2(x,y));\n                        if (p.x > 0.0) {\n                            vec2 d2 = (v - p).xy;\n                            float l = length(d2);\n                            float f = BALL_D - l;\n                            if (l >= 0.001* BALL_SIZE &&  f > 0.0) {\n                                float f2 = f / (BALL_D);\n                                f2 +=  SQ_K*f2*f2;\n                                f2 *= BALL_D;\n                                vec2 force_part = E_FORCE * normalize(d2)*f2;\n                                stress += abs(force_part.x)+abs(force_part.y);\n                                dr += force_part;\n                            }\n                        }\n\n                    }\n                }\n            }\n            \n            vec2 mouseDir = v.xy - iMouse.xy * vec2(2.0, 1.3);\n            float d2 = dot(mouseDir, mouseDir);\n            dr += M * MOUSE_F *\n                max(stress, 1.0) *\n                float(iMouse.x > 30.0)*clamp(iMouse.z, 0.0, 1.0) * // mouse clicked outside zoom region\n                mouseDir * BALL_SIZE / max(d2, 0.01); //  normalize(mouseDir) / (length(mouseDir)/BALL_SIZE)\n\n            vec2 pos = v.xy;\n            float damp_k = length(dr)>0.001? DAMP_K : 1.0; // don't apply damping to freely flying balls\n            dr += G * M;\n            vec2 vel = damp_k * v.zw + dr / M;\n            vel = clamp(vel, vec2(-1.0), vec2(1.0));\n            \n            vec2 dpos = vel * VEL_LIMIT;\n\n            \n            pos += dpos;\n\n\n            v = vec4(pos, vel);\n\n            v = clamp(v, vec4(vec2(BALL_SIZE *(1.0 + sin(pos.y)*0.1),BALL_SIZE), vec2(-1.0)),\n                      \t vec4(SIZE*iResolution.xy-vec2(BALL_SIZE), vec2(1.0)));\n\n\n            fragColor = v; \n        } else {\n        \tfragColor = v;\n        }\n            \n    }\n\tfragColor /= vec4(iResolution.xy, 1.0, 1.0);//vec4(fragColor.xy/iResolution.xy, f0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sim_step(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float SIZE = 03.0;\nconst float BALL_SIZE = 0.90 * SIZE; // should be between sqrt(2)/2 and 1\nconst float BALL_D = 2.0 * BALL_SIZE; \nconst int H = 300; // Reduce this if you want to play with surface or reduce pressure at the bottom\nconst float VEL_LIMIT = 0.2 * BALL_SIZE;\nconst vec2 G = vec2(0.0, -0.003);\nconst float E_FORCE = 1.9;\nconst float M = 0.6 * BALL_SIZE;\nconst float DAMP_K = 0.98;\nconst float SQ_K = 0.0;\nconst float MOUSE_F = 0.18;\n","name":"Common","description":"","type":"common"}]}