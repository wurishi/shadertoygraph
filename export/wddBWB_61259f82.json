{"ver":"0.1","info":{"id":"wddBWB","date":"1712023621","viewed":225,"name":"Basalt Columns","username":"KJK","description":"Basalt Columns","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mapSdf(vec3 p, float t, vec3 rd);\nfloat trace(vec3 ro, vec3 dir, float t);\nvec3 mapNormal(vec3 p, float t, vec3 rd);\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color);\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color);\nvec3 rayDir(vec3 camDir, vec2 uv);\nfloat calcAO(vec3 p, vec3 nor, float t);\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps );\nvec3 render(vec2 uv, float t);\nfloat hexColumnSdf(vec3 p, float diameter, vec3 rd);\n\nconst float TAU = 6.283185307;\nvec3 ONE3 = vec3(1.0);\nvec3 ZERO3 = vec3(0.0);\nvec3 UP = vec3(0.0, 1.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 e = vec2(.75, 0.0);\n    vec3 col = render(fragCoord, iTime);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}\n\nvec3 render(vec2 uv, float t) {\n    // Normalized x coordinates (from -.5 to .5)\n    uv = (uv - iResolution.xy * .5) / iResolution.x;\n\n    vec3 camPos = vec3(.0,700.0,-700.0) * 2.0;\n    vec3 camDir = normalize(vec3(0.0, -.7, 1.0));\n    vec3 rd = rayDir(camDir, uv);\n    float dist = trace(camPos, rd, t);\n    \n    vec3 col;\n    \n    if (dist >= 0.0) {\n        vec3 hit = camPos + rd * dist;\n        vec3 nor = mapNormal(hit, t, rd);\n\n        vec3 l1pos = normalize(vec3(1.0, 2.0, .5)) * 1500.0;\n        vec3 l1col = vec3(.7, .7, 1.0) * 1000000.0;\n        vec3 l1 =  pointLight(hit, nor, l1pos, l1col) *  calcSoftShadow(hit, normalize(l1pos - hit), 0.01, 1000.0, 5.0, t, 50);\n\n        vec3 ambientLight = vec3(1.0, .7, .7) * .02;\n        vec3 l2 = directionalLight(hit, nor, -UP, ambientLight) + ambientLight;\n\n        vec3 l3pos = normalize(vec3(-1.0, 2.0, .5)) * 1500.0;\n        vec3 l3col = vec3(1.0, .8, .5) * 1000000.0;\n        vec3 l3 =  pointLight(hit, nor, l3pos, l3col) *  calcSoftShadow(hit, normalize(l3pos - hit), .01, 1000.0, 5.0, t, 50);\n\n        col = l1 + l2 + l3;\n    } else {\n        col = vec3(0.125);\n    }\n    \n    return col;\n}\n\nvec3 rayDir(vec3 camDir, vec2 uv) {\n    float fovAngle = 90.0 * TAU / 360.0;\n    float focalLength = .5 / tan(fovAngle *.5);\n    vec3 camRight = cross(UP, camDir);\n    vec3 camUp = cross(camDir, camRight);\n    vec3 rd = camDir * focalLength + uv.x * camRight + uv.y * camUp;\n    return normalize(rd);\n}\n\n// Lighting\n\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color) {\n    vec3 toLight = light - p;\n    vec3 toLightNor = normalize(toLight);\n    float distSq = dot(toLight, toLight);\n    return max(vec3(.0), dot(nor, toLightNor) * color / distSq);\n}\n\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color) {\n    return max(vec3(.0), dot(nor, dir) * color);\n}\n\n/*\nfloat calcAO(vec3 p, vec3 nor, float t) {\n    float occ = 0.0;\n    float scale = 0.02;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 3.0 * float(i);\n        float d = mapSdf(p + nor * h, t, nor);\n        occ += (h - d) * scale;\n        scale *= 0.95;\n    }\n    return clamp(1.0 - 1.0 * occ, 0.0, 1.0);\n}\n*/\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps ) {\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for( float t=mint; t<maxt; ) {\n        if (i++ > maxSteps) return res;\n        float h = mapSdf(ro + rd*t, time, rd);\n        if( abs(h)<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += ph;\n    }\n    return res;\n}\n\n// Ray Marching\n\nfloat trace(vec3 ro, vec3 rd, float t) {\n    float dist = .0;\n    for(int i = 0; i < 120; i++) {\n        float d = mapSdf(ro + rd * dist, t, rd);\n        dist += d * .5;\n        float epsilon = .01 + float(i) * 0.05;\n        if (abs(d) < epsilon) \n            return dist;\n    }\n    return -1.0;\n}\n\nfloat mapSdf(vec3 p, float t, vec3 rd) {\n    return hexColumnSdf(p, 80.0, rd);\n}\n\nvec3 mapNormal(vec3 p, float t, vec3 rd) {\n    vec2 e = vec2(1.0, .0);\n    float d = mapSdf(p, t, rd);    \n    float dx = (mapSdf(p + e.xyy, t, rd) - d) / e.x;\n    float dy = (mapSdf(p + e.yxy, t, rd) - d) / e.x;\n\tfloat dz = (mapSdf(p + e.yyx, t, rd) - d) / e.x;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// Hex stuff\n\nconst mat2 hexToUv = mat2(\n    1., .0,\n    .5, .866 // = cos(TAU/6), sin(TAU/6)\n);\n\nconst mat2 uvToHex = mat2(\n    1., .0,\n    -.577, 1.155\n); // = inverse(hexToUv)\n\nfloat hexHeight(vec2 p) {\n    p *= 2.0;\n    float r = length(p);\n    float shift = sin(atan(p.y, p.x) + iTime) * 1.5;\n    float result = r * .05 + .25 * cos(.5 * r - iTime * 5.) + shift;\n    return result * 2.0;\n}\n\nvec2 polar(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nvec2 rightCCW(vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\nfloat hexDistance(vec2 p, float apothem) {\n    const float sideOverApothem = 2. * tan(TAU / 12.);\n    const float radiusOverApothem = 1. / cos(TAU / 12.);\n    \n    float side = apothem * sideOverApothem;\n    float radius = apothem * radiusOverApothem;\n    float halfSide = side * .5;\n    \n    // Reflect into a 60 degree slice lying above the +x axis.\n    {\n        // First reflect into upper-right quadrant.\n        p = abs(p);\n        \n        // Then reflect points so they lie below the line 60 degrees CCW from +x.\n        vec2 normal = polar(TAU / 6. + TAU / 4.);\n        p -= 2. * normal * max(0., dot(p, normal));\n    }\n   \n    // Now that everything is in a 60 degree slice, we only have to think about the first edge of the hexagon.\n    vec2 edgeNormal = polar(TAU / 12.0);\n    \n    float height = dot(p, edgeNormal) - apothem;\n    if (height < .0) \n        return height; // We are inside the hex.\n    \n    // Project point on to edge and clamp to vertices if projection is outside the edge.\n    vec2 vert = vec2(radius, 0.);\n    vec2 edge = rightCCW(edgeNormal);\n    vec2 proj = vert + edge * clamp(dot(p - vert, edge), 0., side);\n    \n    return length(proj - p);\n}\n\nfloat hexColumnDist_exact(vec3 p, vec2 center) {\n    float rounding = 0.05;\n\n    float y = hexHeight(center);\n    vec2 diff = p.xz - center;\n    \n    // Reflect hex along y = x, so a corner faces the cam.\n    diff.xy = diff.yx;\n    \n    float hDiff = max(hexDistance(diff, .5) + rounding, 0.0);\n    float vDiff = max(p.y, y) - y;\n    \n    return sqrt(hDiff * hDiff + vDiff * vDiff) - rounding;\n}\n\nfloat hexColumnDist_lowerBound(vec3 p, vec2 center) {\n    float y = hexHeight(center);\n    vec2 diff = p.xz - center;\n    float hDiff = length(diff);\n    float vDiff = max(p.y, y) - y;\n    if (hDiff <= .0) \n        return vDiff - .5774;\n    return sqrt(hDiff * hDiff + vDiff * vDiff) - .5774;\n}\n\nfloat hexColumnDist(vec3 p, vec2 center, float maxDist) {\n    float lowerBound = hexColumnDist_lowerBound(p, center);\n    if (lowerBound > maxDist) \n        return lowerBound;\n    return hexColumnDist_exact(p, center);\n}\n\nfloat hexColumnSdf(vec3 p, float diameter, vec3 rd) {\n    p /= diameter;\n    vec2 p2 = p.xz;\n    vec2 skewCoord = uvToHex * p2;\n    vec2 center = floor(skewCoord) + .5;\n    float dist = 1e20;\n    const int R = 1;\n    for (int i = -R; i <= R; i++) {\n        for (int j = -R; j <= R; j++) {\n        \n            if((i == j || dot(rd.xz, vec2(i, j)) < -0.6) && i != 0) continue;\n            \n            vec2 c = hexToUv * (center + vec2(float(i), float(j)));\n            dist = min(hexColumnDist(p, c, dist), dist);\n            if (dist < 0.)\n                return dist;\n        }\n    }\n    return dist * diameter;\n}","name":"Image","description":"","type":"image"}]}