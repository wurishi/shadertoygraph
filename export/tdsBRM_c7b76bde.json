{"ver":"0.1","info":{"id":"tdsBRM","date":"1587948672","viewed":98,"name":"Very Basic FM Synth (Ver.2)","username":"Yoshimaster96","description":"I had to remove the interactibility in order for it to work, but it should generate sound now.","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["synth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.00001;\nfloat FRAME_SIZE = 0.005;\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    //Get destination pixel (time and sample level) to calculate\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float t = iTime+(uv.x*FRAME_SIZE);\n    vec2 lev = vec2((uv.y*2.0)-1.0);\n    \n    //Get source sample level\n    vec2 samp = playSong(t);\n    \n    //Get change in sample level\n    float slopCorr = (FRAME_SIZE*iResolution.y)/(2.0*iResolution.x);\n    vec2 slop = (playSong(t+EPSILON)-playSong(t-EPSILON))/(2.0*EPSILON);\n    slop *= slopCorr;\n    \n    //Calculate sample distance\n    vec2 dist = abs(samp-lev);\n    \n    //Scale distance using slope for even thickness\n    vec2 lum = vec2(1.0)-clamp(64.0*dist/sqrt(1.0+(slop*slop)),vec2(0.0),vec2(1.0));\n    \n    //Output result color\n    fragColor = vec4(lum,(lum.x+lum.y)/2.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp,float time)\n{\n    //Play song\n    return playSong(time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"float TWO_PI = 6.283185;\n\n////////////////////\n//HELPER FUNCTIONS//\n////////////////////\n\n//Calculate frequency of given MIDI note number\nfloat calcFreq(float midiNote)\n{\n    return 440.0*exp2((midiNote-69.0)/12.0);\n}\n//Calculate panning envelope (-1 is fully left, 1 is fully right)\nvec2 calcPan(float p)\n{\n    float pmin = min(p,0.0);\n    float pmax = max(p,0.0);\n    return vec2(1.0-pmax,1.0+pmin);\n}\n//Calculate ADSR envelope value\nfloat calcADSR(float time,vec2 noteRng,vec4 adsr)\n{\n    //If outside note, return 0\n    if((time<noteRng.x)||(time>(noteRng.y+adsr.w)))\n    {\n        return 0.0;\n    }\n    //Handle release section\n    else if(time>noteRng.y)\n    {\n    \t//TODO: Check and handle case where (attack+decay)>noteLen (scale release time according to envelope at note end)\n    \t//TODO: Check and handle case where attack>noteLen (scale release time according to envelope at note end)\n        float dt = (time-noteRng.y)/adsr.w;\n        return adsr.z*(1.0-dt);\n    }\n    //Handle attack section\n    else if(time<(noteRng.x+adsr.x))\n    {\n        return (time-noteRng.x)/adsr.x;\n    }\n    //Handle decay section\n    else if(time<(noteRng.x+adsr.x+adsr.y))\n    {\n        float dt = (time-(noteRng.x+adsr.x))/adsr.y;\n        return 1.0-((1.0-adsr.z)*dt);\n    }\n    //Handle sustain section\n    else\n    {\n        return adsr.z;\n    }\n}\n\n/////////////////\n//VARIOUS WAVES//\n/////////////////\n\n//NOTE THAT THESE WAVES ARE BASED ON [0,1] RATHER THAN [0,2pi]\n\n//Pulse wave\nfloat pulse(float x,float duty)\n{\n    return (2.0*step(1.0-duty,fract(x)))-1.0;\n}\n//Square wave\nfloat square(float x)\n{\n    return (2.0*step(0.5,fract(x)))-1.0;\n}\n//Triangle wave\nfloat triangle(float x)\n{\n    return mix((4.0*fract(x))-1.0,\n               (-4.0*fract(x))+3.0,\n               step(0.5,fract(x)));\n}\n//Sawtooth wave\nfloat sawtooth(float x)\n{\n    return (2.0*fract(x))-1.0;\n}\n\n////////////////\n//NOTE PLAYING//\n////////////////\n\n//Play note (you can edit this for different timbres)\nfloat playNote_InstA(float time,float midiNote,vec2 noteRng)\n{\n    //Calculate envelope for carrier/modulator waves\n    float envModulator = calcADSR(time,noteRng,vec4(0.3,0.3,0.8,0.6));\n    float envCarrier = calcADSR(time,noteRng,vec4(0.1,0.1,0.8,0.2));\n    \n    //Return result sample\n    float baseTime = TWO_PI*calcFreq(midiNote)*time;\n    return envCarrier*sin(baseTime + 2.0*envModulator*sin(4.0*baseTime));\n}\n\n//Add more instruments here\n\n////////////////\n//SONG PLAYING//\n////////////////\n\n//Write your song here\nvec2 playSong(float time)\n{\n    //Play C chord arpeggio\n    float samp = playNote_InstA(time,60.0,vec2(0.0,2.0));\n    samp += playNote_InstA(time,64.0,vec2(0.1,2.0));\n    samp += playNote_InstA(time,67.0,vec2(0.2,2.0));\n    \n    //Reduce amplitude to eliminate clipping\n    samp /= 4.0;\n    \n    //Return sample\n    return vec2(samp);\n}","name":"Common","description":"","type":"common"}]}