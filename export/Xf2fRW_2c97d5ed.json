{"ver":"0.1","info":{"id":"Xf2fRW","date":"1729470745","viewed":79,"name":"2 particles per cell with flip","username":"capslpop","description":"Trying to do flip here.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["phong","lighting","voxel","pervoxel"],"hasliked":0,"parentid":"lffBDM","parentname":"MPM Single Pass Clustering"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"3D Water Box\" by michael0884. https://shadertoy.com/view/dscfRf\n// 2023-10-16 20:53:25\n\n#define SHADOWS \n#define REFRACTION\n\n#define RADIUS 0.3\n#define NORMAL_SMOOTHNESS 0.0\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iSphere(inout Ray ray, vec4 sphere, vec3 color)\n{\n    vec3 ro = ray.ro - sphere.xyz;\n    float b = dot(ro, ray.rd);\n    float c = dot(ro, ro) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if (h > 0.) \n    {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= 0.0 && d1 <= ray.td) {\n            ray.normal = normalize(ro + ray.rd*d1);\n            ray.color = color;\n            ray.td = d1;\n        } else if (d2 >= 0.0 && d2 <= ray.td) { \n            ray.normal = normalize(ro + ray.rd*d2); \n            ray.color = color;\n            ray.td = d2;\n        }\n    }\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    Cell c = unpackCell(iChannel0, p, ivec2(iChannelResolution[0].xy));\n\n    if(c.p0.mass > 0u) iSphere(ray, vec4(c.p0.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n    if(c.p1.mass > 0u) iSphere(ray, vec4(c.p1.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\nfloat Density(vec3 p)\n{\n    return unpackCell(iChannel0, p, ivec2(iChannelResolution[0].xy)).mass;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = unpackCell(iChannel0, p, ivec2(iChannelResolution[0].xy)).mass;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(1.0))) || any(greaterThan(p, vec3(volumeSize) - 1.0))) return dens;\n        float d = Density(p);\n        dens += d * 2.0;\n        td += 2.0;\n    }\n    return dens;\n}\n\n\n#define ISO_VALUE 0.5\nfloat ParticleDensity(vec3 p)\n{\n    //vec3 p0 = floor(p);\n    //float rho = voxel(ch1, p).z;\n    //if(rho < 0.001) return rho;\n    //rho = 0.0;\n    ////if larger then compute accurate density from particles\n    //range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    //{\n    //    //load the particles \n    //    vec3 p1 = p0 + vec3(i, j, k);\n    //    //load the particles\n    //    vec4 packed = LOAD3D(ch0, p1);\n    //    Particle p0_, p1_;\n    //    unpackParticles(packed, p1, p0_, p1_);\n    //    if(p0_.mass > 0u) rho += float(p0_.mass)*GD(length(p0_.pos - p), RADIUS);\n    //    if(p1_.mass > 0u) rho += float(p1_.mass)*GD(length(p1_.pos - p), RADIUS);\n    //}\n\n    return 0.0;\n}\n\nvec3 ParticleGradient(vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec3 grad = vec3(0.0);\n\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n\n        //load the particles\n        Cell c = unpackCell(iChannel0, p1, ivec2(iChannelResolution[0].xy));\n\n        if(c.p0.mass > 0u) grad += float(c.p0.mass)*GGRAD(c.p0.pos - p, RADIUS);\n        if(c.p1.mass > 0u) grad += float(c.p1.mass)*GGRAD(c.p0.pos - p, RADIUS);\n    }\n\n    return grad;\n}\n\n\nfloat DE(vec3 p)\n{\n    return ISO_VALUE - ParticleDensity(p);\n}\n\nfloat TraceIsoSurface(Ray ray, float mint, float inside)\n{\n    const int step_count = 300;\n    float td = mint;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = ray.ro + ray.rd * td;\n        if(!all(lessThanEqual(p, vec3(volumeSize))) || !all(greaterThanEqual(p, vec3(0.))))\n        {\n            return ray.td;\n        }\n        float d = inside*4.0*DE(p);\n        if(d < 0.0)\n        {\n            return td;\n        }\n        td += d;\n    }\n    return td;\n}\n\nvec3 Background(vec3 rd)\n{\n    return 2.0*pow(texture(iChannel1,  rd.yzx).xyz, vec3(2.0));\n}\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{   \n    //return;\n\n    //if (iFrame % 32 != 31) {return;}\n\n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        //angles = vec2(0.04, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(volumeSize), vec3(volumeSize)))*0.5;\n    vec3 ro = vec3(volumeSize)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n\n    vec2 tdBox = iBox(ro - vec3(volumeSize)*0.5, rd, 0.5*vec3(volumeSize));\n    col.xyz =Background(rd);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x+0.5, 0.0);\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n        int i = 0;\n        for(; i < 200; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n            td += 2.5;\n            if(td > tdBox.y-1.0)\n            {\n                break;\n            }\n            if(ray.td < tdBox.y-1.0)\n            {\n                break;\n            }\n        }\n        \n        //col.xyz = vec3(i)/200.0;\n        //return;\n        \n        //float liq_td = TraceIsoSurface(ray, td);\n        //ray.td = min(liq_td, ray.td);\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(-ParticleGradient(p0));\n            vec3 normal1 = normalize(calcNormal(p0, 0.5).xyz);\n            normal = -normalize(mix(normal, normal1, NORMAL_SMOOTHNESS));\n            vec3 albedo = vec3(0.039,0.153,1.000);\n            float LdotN = 0.5*dot(normal, light_dir)+0.5;\n            #ifdef SHADOWS\n                float shadow_d = TraceDensity(p0+light_dir*1.0, light_dir);\n                float shadow = exp(-shadow_d) + 0.3*exp(-0.1*shadow_d);\n            #else\n                float shadow = 1.0;\n            #endif\n            vec3 refl_d = reflect(ray.rd, normal);\n            vec3 refl = Background(refl_d);\n            float K = 1. - pow(max(dot(normal,refl_d),0.), 2.);\n            K = mix(0.0, K, 0.1);\n            \n            #ifdef REFRACTION\n            vec3 refr_d = refract(ray.rd, normal, 1.0/1.33);\n            \n            float liquid_density = TraceDensity(p0, refr_d);\n            \n            vec3 liquid_color = exp(-0.5*liquid_density*vec3(0.953,0.353,0.247));\n            vec3 refr_color = Background(refr_d) * liquid_color;\n            col.xyz = 2.5*shadow*refr_color*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #else\n            col.xyz = 2.5*shadow*albedo*LdotN*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #endif\n        }\n        \n        //col.xyz = 0.01*vec3(1,1,1)*TraceDensity(ro + rd*max(tdBox.x+0.001,0.0), rd);\n    }\n    \n    col.xyz = 1.0 - exp(-2.5*pow(col.xyz,vec3(1.0/1.4)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define range(i,a,b) for(int i = a; i <= b; i++)\n#define dt 1.0\n\n// size of the volume -- cant be bigger than the max about of pixels in the buffer\n// I set it manually for simplicity\nconst ivec3 volumeSize = ivec3(64);\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define R iResolution.xy\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.741,1.000,0.580))\n\n#define initial_particle_density 1u\n#define rest_density 0.45\n#define gravity 0.01\n\n#define PRESSURE 2.5\n#define PRESSURE_RAD 0.8\n#define VISCOSITY 0.65\n#define SPIKE_KERNEL 0.5\n#define SPIKE_RAD 0.75\n\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 1.0\n#define cooling 0.0\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\nfloat cub(float x)\n{\n    return x*x*x;\n}\n\nfloat Gaussian(float r, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    return norm * exp(-0.5*sqr(r/d));\n}\n\nvec3 GaussianGrad(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return - (norm/sqr(d)) * exp(-0.5*sqr(r/d)) * dx;\n}\n\nvec4 GaussianGrad2(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return norm * exp(-0.5*sqr(r/d)) * vec4(-dx /sqr(d), 1.0);\n}\n\n#define KERNEL_POLY6_NORMALIZATION (315.0 / (64.0 * PI))\n#define KERNEL_SPIKE_NORMALIZATION (45 / PI)\n#define KERNEL_RADIUS 1.0\n\nfloat KernelPoly6(float r, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    return (r <= d) ? c * cub(sqr(d) - sqr(r)) : 0.0;\n}\n\nvec3 KernelPoly6Grad(vec3 dx, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    float r = length(dx);\n    return (r <= d) ? clamp(-6.0 * c * sqr(sqr(d) - sqr(r)), -3.0, 0.0) * dx : vec3(0.0);\n}\n\n#define GD(x, R) Gaussian(length(x),R)\n#define GGRAD(x, R) GaussianGrad(x, R)\n#define GGRAD2(x,R) GaussianGrad2(x, R)\n\nuint helperPackUnorm32x4(uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nuvec4 helperUnpackUnorm32x4(uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, 0., 1.)*255.)))); \n}\n\nvec4  unpackUnorm32x4(float a) \n{ \nreturn vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) / 255.; \n}\n\nfloat packSnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); \n}\n\nvec4  unpackSnorm32x4(float a) \n{ \nreturn clamp((vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); \n}\n\nuint helperPackUnorm32x8(uvec4 a, uvec4 b) \n{\n    return uint( \n            (a.x << 28) |\n            (a.y << 24) |\n            (a.z << 20) |\n            (a.w << 16) | \n            (b.x << 12) |\n            (b.y << 8 ) |\n            (b.z << 4 ) |\n            (b.w << 0 ) \n        ); \n}\n\nstruct uvec4x2\n{\n    uvec4 a;\n    uvec4 b;\n};\n\nuvec4x2 helperUnpackUnorm32x8(uint a) \n{\n    return uvec4x2(  \n            uvec4(\n                (a & 0xF0000000u) >> 28,\n                (a & 0x0F000000u) >> 24,\n                (a & 0x00F00000u) >> 20,\n                (a & 0x000F0000u) >> 16\n            ),\n            uvec4(\n                (a & 0x0000F000u) >> 12,\n                (a & 0x00000F00u) >> 8 ,\n                (a & 0x000000F0u) >> 4 ,\n                (a & 0x0000000Fu) >> 0\n            )\n        ); \n}\n\nfloat packUnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, 0.0, 1.0)*15.0)), \n            uvec4(round(clamp(b, 0.0, 1.0)*15.0))\n        ));\n}\n\nmat2x4 unpackUnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = vec4(um.a) / 15.0;\n    m[1] = vec4(um.b) / 15.0;\n    \n    return m;\n}\n\nfloat packSnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, -1.0, 1.0)*7.5 + 7.5)), \n            uvec4(round(clamp(b, -1.0, 1.0)*7.5 + 7.5))\n        ));\n}\n\nmat2x4 unpackSnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = (vec4(um.a) - 7.5) / 7.5;\n    m[1] = (vec4(um.b) - 7.5) / 7.5;\n    \n    return m;\n}\n\nstruct Particle \n{\n    uint mass; // move this to main cell struct??\n    vec3 pos;\n    vec3 vel;\n};\n\nstruct Cell \n{\n    Particle p0;\n    Particle p1;\n    //Particle p2;\n    //Particle p3;\n    \n    vec3 vel;\n    float mass;\n    \n    int count; // number of particles already clustered\n};\n\n// first two positions are xy on buffer then which face of the cube map is z\nvec4 getPos(sampler2D buffer, ivec3 pos, ivec2 res)\n{\n    int c = pos.x + volumeSize.y * pos.y + volumeSize.z * volumeSize.y * pos.z;\n    \n    ivec2 d = ivec2(c%int(res.x), c/int(res.x));\n    \n    return texelFetch(buffer, d, 0);\n    }\n\n// this intakes the fragment position and outputs the correct voxel coord\nvec3 getPos(vec2 fragCoord, ivec2 res)\n{\n    int c = int(fragCoord.x) + int(fragCoord.y) * res.x;\n    \n    vec3 pos = vec3(c%volumeSize.x, (c/volumeSize.x)%volumeSize.y, c/(volumeSize.x*volumeSize.y));\n\n    return pos;\n}\n\nvec4 packCell(Cell c, vec3 pos)\n{\n    vec4 info;\n    info.x = packUnorm32x8(vec4(float(c.p0.mass) / 15.0, float(c.p1.mass) / 15.0, c.p0.pos.xy - pos.xy), vec4(c.p0.pos.z - pos.z, c.p1.pos - pos));\n    info.y = packSnorm32x4(vec4(c.p0.vel, 0.0));\n    info.z = packSnorm32x4(vec4(c.p1.vel, 0.0));\n    info.w = packSnorm32x4(vec4(c.vel, c.mass / 5.0));\n\n    return info;\n}\n\nCell unpackCell(sampler2D buffer, vec3 pos, ivec2 res)\n{\n    Cell c;\n    \n    vec4 info = getPos(buffer, ivec3(pos), res);\n    \n    mat2x4 x = unpackUnorm32x8(info.x);\n    c.p0.mass = uint(x[0].x*15.0);\n    c.p1.mass = uint(x[0].y*15.0);\n    \n    c.p0.pos.xy = x[0].zw + pos.xy;\n    c.p0.pos.z = x[1].x + pos.z;\n    \n    c.p1.pos = x[1].yzw + pos.xyz;\n    \n    vec4 y = unpackSnorm32x4(info.y);\n    c.p0.vel = y.xyz;\n    \n    vec4 z = unpackSnorm32x4(info.z);\n    c.p1.vel = z.xyz;\n    \n    vec4 w = unpackSnorm32x4(info.w);\n    c.vel = w.xyz; // packet baced on max velocity based on dt\n    c.mass = w.w * 5.0;\n    \n    return c;\n}\n\nvoid Clusterize(inout Cell c, Particle p, vec3 pos) \n{\n    if (!all(equal(floor(p.pos), floor(pos))) || p.mass == 0u) {\n        return;\n    }\n    \n    if (c.count <= 1) {\n        switch (c.count) {\n        case 0:\n            c.p0.pos = p.pos;\n            c.p0.vel = p.vel;\n            c.p0.mass = p.mass;\n            break;\n        case 1:\n            c.p1.pos = p.pos;\n            c.p1.vel = p.vel;\n            c.p1.mass = p.mass;\n            break;\n        }\n        c.count++;\n        return;\n    }\n    \n    float a = distance(c.p0.pos, p.pos);\n    float b = distance(c.p1.pos, p.pos);\n    float minDist = min(a, b);\n    \n    if (minDist == a) \n    {\n        c.p0.pos = (c.p0.pos * float(c.p0.mass) + p.pos * float(p.mass)) / float(c.p0.mass + p.mass);\n        c.p0.vel = (c.p0.vel * float(c.p0.mass) + p.vel * float(p.mass)) / float(c.p0.mass + p.mass);\n        c.p0.mass += p.mass;\n    } \n    else if (minDist == b) \n    {\n        c.p1.pos = (c.p1.pos * float(c.p1.mass) + p.pos * float(p.mass)) / float(c.p1.mass + p.mass);\n        c.p1.vel = (c.p1.vel * float(c.p1.mass) + p.vel * float(p.mass)) / float(c.p1.mass + p.mass);\n        c.p1.mass += p.mass;\n    }\n}\n\nvoid SplitParticle(inout Particle a, inout Particle b) \n{    \n    a.pos = a.pos;\n    b.pos = b.pos + 0.1;\n    \n    b.vel = a.vel;\n    \n    uint newMass = a.mass / 2u;\n    a.mass -= newMass;\n    b.mass = newMass;\n}\n\nvoid SplitParticles(inout Cell c, float seed)\n{\n    if (c.p0.mass == 0u)\n    {\n        SplitParticle(c.p1, c.p0);\n    }\n    if (c.p1.mass == 0u)\n    {\n        SplitParticle(c.p0, c.p1);\n    }\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat G(vec3 d) //quadratic kernel in 3D\n{\n    vec3 f = max(1.5 - abs(d), 0.0);\n    vec3 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x * k.y * k.z;\n}\n\nvec4 textureFetchTrilinear(sampler2D tex, vec3 texCoords)\n{\n    vec3 texelPos = texCoords - 0.5;\n\n    // Get the integer coordinates of the top-left texel\n    vec3 texelCoords00 = floor(texelPos);\n\n    // Fetch the four surrounding texels\n    Cell c000 = unpackCell(iChannel0, texelCoords00, ivec2(iChannelResolution[0].xy));\n    Cell c100 = unpackCell(iChannel0, texelCoords00 + vec3(1, 0, 0), ivec2(iChannelResolution[0].xy));\n    Cell c010 = unpackCell(iChannel0, texelCoords00 + vec3(0, 1, 0), ivec2(iChannelResolution[0].xy));\n    Cell c110 = unpackCell(iChannel0, texelCoords00 + vec3(1, 1, 0), ivec2(iChannelResolution[0].xy));\n\n    Cell c001 = unpackCell(iChannel0, texelCoords00 + vec3(0, 0, 1), ivec2(iChannelResolution[0].xy));\n    Cell c101 = unpackCell(iChannel0, texelCoords00 + vec3(1, 0, 1), ivec2(iChannelResolution[0].xy));\n    Cell c011 = unpackCell(iChannel0, texelCoords00 + vec3(0, 1, 1), ivec2(iChannelResolution[0].xy));\n    Cell c111 = unpackCell(iChannel0, texelCoords00 + vec3(1, 1, 1), ivec2(iChannelResolution[0].xy));\n\n    // Calculate the interpolation factors (fractional part of the texture coordinates)\n    vec3 frac = fract(texelPos);\n\n    // Perform bilinear interpolation\n    vec4 mixX00 = mix(vec4(c000.vel, c000.mass), vec4(c100.vel, c100.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec4 mixX10 = mix(vec4(c010.vel, c010.mass), vec4(c110.vel, c110.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    vec4 mixY0 = mix(mixX00, mixX10, frac.y);\n    \n    vec4 mixX01 = mix(vec4(c001.vel, c001.mass), vec4(c101.vel, c101.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec4 mixX11 = mix(vec4(c011.vel, c011.mass), vec4(c111.vel, c111.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    vec4 mixY1 = mix(mixX01, mixX11, frac.y);\n    \n    return mix(mixY0, mixY1, frac.z);\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec3 pos)\n{\n    float s = 0.0;\n\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    float density = 0.0;\n    vec3 vel = vec3(0.0); // Initialize velocity\n    mat3x3 C = mat3x3(0.0);\n\n    if(false)\n    {\n        // Iterate over surrounding grid nodes\n        range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n        {\n            vec3 pos_ = floor(p.pos) + vec3(i, j, k);\n    \n            Cell c_ = unpackCell(iChannel0, pos_, ivec2(iChannelResolution[0].xy));\n    \n            vec3 dpos = (p.pos - 0.5) - pos_;\n            float weight = G(dpos);\n            \n            C += outerProduct(weight * c_.vel, dpos);\n            \n            vel += weight * c_.vel;\n            density += weight * c_.mass;\n        }\n    } else\n    {\n        vec4 velMass = textureFetchTrilinear(iChannel0, floor(p.pos + 0.5));\n        vel = velMass.xyz;\n        density = velMass.w;\n    }\n    \n    float w = 1.9;\n    \n    vec3 pic = vel;\n    \n    // flip:\n    vel = mix(2.0 * p.vel - vel, vel, 0.5);\n    \n    if (length(vel) > 1.0)\n    {\n        vel = normalize(vel);\n    }\n    \n    vel = (1.0 - w) * p.vel + w * vel;\n    \n    p.vel = pic;\n    \n    p.pos += dt * vel;\n    \n    // P2G    \n    float pressure = 1.0 * (density - 0.75);\n    \n    mat3 stress = mat3(-pressure);\n    \n    mat3 affine = stress; // + density * C;\n    \n    // Only update the current cell\n    vec3 dpos = vec3((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (affine * dpos + float(p.mass) * vel);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 pos = getPos(fragCoord, ivec2(iResolution.xy));\n    \n    Particle pNot = Particle(0u, vec3(pos), vec3(0.0));\n    \n    Cell c = Cell(pNot, pNot, vec3(0.0), 0.0, 0);\n    \n    if (any(greaterThan(pos, vec3(volumeSize))))\n    {\n        fragColor = packCell(c, pos);\n        return;\n    }\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        vec3 pos_ = pos + vec3(i, j, k);\n        Cell c_ = unpackCell(iChannel0, pos_, ivec2(iChannelResolution[0].xy));\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) c.vel /= c.mass;\n    \n    float cycling = 0.003;\n    \n    // gravity\n    c.vel -= vec3((sign(cos(float(iFrame) * cycling)) - 1.0) * 0.0025, 0.0, (sign(cos(float(iFrame) * cycling)) + 1.0) * 0.0025) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec3(volumeSize)/2.0) < 4.0 && iMouse.z > 1.0)\n    {\n        c.p0.mass = 1u;\n        c.p0.pos = hash33(pos + iTime) + pos;\n        \n        c.vel = vec3(0.0, 0.0, 0.5);\n    }\n    \n    //float vel = length(c.vel);\n    //c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 1.0)\n    {\n        c.vel.y = 1.0;\n    }\n    if (pos.x <= 1.0)\n    {\n        c.vel.x = 1.0;\n    }\n    if (pos.z <= 1.0)\n    {\n        c.vel.z = 1.0;\n    }\n    if (pos.x >= float(volumeSize.x) - 1.0)\n    {\n        c.vel.x = -1.0;\n    }\n    if (pos.y >= float(volumeSize.x) - 1.0)\n    {\n        c.vel.y = -1.0;\n    }\n    if (pos.z >= float(volumeSize.z) - 1.0)\n    {\n        c.vel.z = -1.0;\n    }\n    \n    fragColor = packCell(c, pos);\n}","name":"Buffer A","description":"","type":"buffer"}]}