{"ver":"0.1","info":{"id":"mlsXRj","date":"1675076253","viewed":397,"name":"Anti-repeat improved","username":"ianertson","description":"An improved version of my previous attempt at doing this.\n(It's not an improved version of iq's , but an improved version of my previous attempt)","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["noise","random","textures","repeat","tiles","albedo","antirepeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n   Another anti-tile/repeat texture function.\n   \n   My previous attempt can be found here: https://www.shadertoy.com/view/mlXXRj\n   ----------------------------------------------------------------------------\n   \n   Too bored to read this wall of text?\n   Implementation entry point is at line 130.\n   \n   ----------------------------------------------------------------------------\n \n   This is once again inspired by iq's function here: https://www.shadertoy.com/view/lt2GDd\n \n   The initial reason why I wanted to implement another version of this one,\n   was because I thought I could do something similar with just one single texture lookup.\n   However, as seen in my previous attempt; I failed doing this.\n \n   But then I noticed some problems with iq's implementation,\n   For example, try using the \"Organic 1\" texture using iq's implementation,\n   you'll see that the tiling is not very pleasing.\n   It works great for some other textures though.\n \n   So! I thought I'd try a different approach.\n   The idea is the same as the one in my previous attempt,\n   but instead of just doing one texture lookup, I do 4 lookups just like the one in iq's version.\n   However, my implementation is different and the tiling of \"Organic 1\"\n   is a bit more appealing (in my opinion).\n   \n   *********************************************************************\n   ** this is NOT a replacement for iq's version\n      it's simply another approach with a completely different result **\n   *********************************************************************\n \n   I will mention the logic again:\n \n   1. Get the ID of each texture repetition\n   2. Get a random number using the ID (one random number for each tile)\n   3. Rotate the UV coordinates by using this random number as an angle\n   4. Interpolate between neighbouring tiles to create smooth seams.\n   \n   **********************************************************************\n   \n   There's also an alternative implementation implemented below,\n   this one also adds some random sub-tiles to randomly selected parent-tiles.\n   What you're seeing on the screen is an alternation between both implementations.\n*/\n\n\n// change this to `1` to only display the simple one-layered version.\n// If set to `0`, it will alternative between the simple version and the layered version.\n#define ONLY_SHOW_SIMPLE_VERSION 0\n\n// change this to `1` to always show the layered-version.\n#define ONLY_SHOW_LAYERED_VERSION 0\n\n\n#define R iResolution.xy\n#define T (iTime)\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n// Implementation\nvec4 textureAntiRepeat(sampler2D tex, vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\n\n// Below is an alternative implementation,\n// that also adds some random sub-tiles\nvec4 textureAntiRepeatSingleLayer(sampler2D tex, vec2 uv, vec2 dx, vec2 dy) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatLayered(sampler2D tex, vec2 uv, vec2 scale) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 3.31915;\n    float self = mix(scale.x, scale.y, rand(id, seed));\n    float right = mix(scale.x, scale.y, rand(id+vec2(1.0, 0.0), seed));\n    float top = mix(scale.x, scale.y, rand(id+vec2(0.0, 1.0), seed));\n    float topRight = mix(scale.x, scale.y, rand(id+vec2(1.0, 1.0), seed));\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureAntiRepeatSingleLayer(tex, (uv*self), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*right), dx, dy), sv.x),\n        mix(textureAntiRepeatSingleLayer(tex, (uv*top), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*topRight), dx, dy), sv.x),\n        sv.y\n    );\n}\n\n/**\n* This is the entry point of the implementation.\n* \n* it has two signatures:\n*\n* 1. vec4 textureAntiRepeat(sampler2D tex, vec2 uv)\n*    - This is the simple one-layered version\n*\n* 2. vec4 textureAntiRepeat(sampler2D tex, vec2 uv, vec2 scale)\n*    - This will use the alternative version with random sub-tiles\n*/\nvec4 textureAntiRepeat(sampler2D tex, vec2 uv, vec2 scale) {\n    return textureAntiRepeatLayered(tex, uv, scale);\n}\n\n/////////////////////////////////////////////////////////////////\n\n// Ignore everything below, just for visualization\n\n\nvec3 render(sampler2D tex, vec2 uv, vec2 fc) {\n    #if ONLY_SHOW_LAYERED_VERSION == 1\n    vec3 col = textureAntiRepeat(tex, uv, vec2(0.001, 4.0)).rgb;\n    #else\n    vec3 col = textureAntiRepeat(tex, uv).rgb;\n    \n    #if ONLY_SHOW_SIMPLE_VERSION == 0\n    vec3 col2 = textureAntiRepeatLayered(tex, uv, vec2(0.001, 4.0)).rgb;\n    col = mix(col, col2, 0.5+(0.5*sin(T*1.5)));\n    #endif\n    #endif\n    float C = R.x*0.5;\n    if (iMouse.z > 0.01) C = iMouse.x;\n    if (fc.x <= C) col = texture(tex, uv).rgb;\n    float thick = 2.0;\n    if (fc.x >= C-thick && fc.x <= C+thick) col = vec3(0.0);\n    else if (fc.x >= C-(thick*1.5) && fc.x <= C+(thick*1.5)) col = vec3(1.);\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 uv = fc/R.xy;\n    uv *= 4.0 + ((0.5+(0.5*cos(T*0.25))) * 16.0);\n    vec3 colA = render(iChannel0, uv, fc);\n    vec3 colB = render(iChannel1, uv, fc);\n    vec3 colC = render(iChannel2, uv, fc);\n    vec3 colD = render(iChannel3, uv, fc);\n    vec3 col = colA;\n    \n    if (iTime > 1.0 && iFrame > 16) {\n        float cycle = mod(T*0.16, 4.5);\n        float f = 0.5;\n        col = mix(col, colB, smoothstep(1.0 - f, 1.0 + f, cycle));\n        col = mix(col, colC, smoothstep(2.0 - f, 2.0 + f, cycle));\n        col = mix(col, colD, smoothstep(3.0 - f, 3.0 + f, cycle));\n        col = mix(col, colA, smoothstep(4.0 - f, 4.0 + f, cycle));\n    }\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Just a random number generator, can be replaced with something more simple.\n// This one is a bit overkill.\n\nconst float HASH_MAP[16] = float[16](\n    0.4484410750068152, 0.5604512254151961, 0.49955284268263, 0.40679892641422355,\n    0.5180849501908357, 0.5472588115354913, 0.6766984192813609, 0.9064048675129073,\n    0.39864570212504613, 0.21022362764468383, 0.9516217965343488, 0.7301211180314449,\n    0.9928938541159735, 0.9095016245648258, 0.34485129267821846, 0.9842958980653165\n);\n#define IDX(v) (int(abs(v)*16.0) % 16)\n#define HASH(v) HASH_MAP[IDX(v)]\nfloat rand(vec2 p, float seed) {\n    p += vec2(cos(seed), sin(seed));\n    vec2 a = vec2(HASH(p.x), HASH(p.y))*10.0215;\n    vec2 b = vec2(HASH(p*a.x), HASH(p*a.y))*10.3921;    \n    return fract(20.0154*(dot(a, b) * dot(p, b)));\n}\n\n","name":"Common","description":"","type":"common"}]}