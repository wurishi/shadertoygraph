{"ver":"0.1","info":{"id":"lcV3Dt","date":"1713452329","viewed":2903,"name":"Ishigami Kouko","username":"SL0ANE","description":"头发部分想到了可以从远处反方向往相机march，这样就能通过渲染物体的“背面”使得头发只需要非常简单的sdf就能描述。\n角色来自漫画《Spirit circle-魂环-》。\n\n捏模型用到了之前的模板：\n[url=https://www.shadertoy.com/view/M32XWd]https://www.shadertoy.com/view/M32XWd[/url]","likes":109,"published":1,"flags":48,"usePreview":1,"tags":["procedural","3d","raymarching","distancefield","sdf","cartoon","manga","anime","human","girl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_DISTANCE 64.0\n# define HAIR_FAR 32.0\n# define MAX_STEP 128\n# define MAX_COLOR vec4(0.96, 0.95, 0.9, 1.0)\n# define MIN_COLOR vec4(0.3, 0.25, 0.2, 1.0)\n# define BACKGROUND_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n\n# define OUTLINE_COLOR vec4(0.0, 0.0, 0.0, 0.0)\n\n# define FRAME_RATE 12.0\n# define BLINK_THRESHOLD 0.12\n\n\n// # define SMILING        <---------------------------- 试试这个！\n\n\n// # define MODELING\n// # define SIMPLE_TEXTURE\n// # define NOHAIR\n// # define EYETEST\n// # define CROSSLINE\n// # define SHOWUV\n\n// Pre\nObjectInfo sceneBaseMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat, inout float outlineDis);\nMaterial sceneBaseMaterial(vec3 point, float len);\nvec3 getColorAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis, bool outlineHit, float disWhenHit, float lenWhenHit);\nObjectInfo sceneHairMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat);\nMaterial sceneHairMaterial(vec3 point, float len);\nvec4 getHairAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis);\n\n// Camera Config\nfloat cameraFov = 36.0f;\n\n// Outline Config\nfloat outlineStrength = 3.3;\nfloat outlineThreshold = 0.05;\n\n// Bone\n\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Root = vec3(0.0, -0.85, 8.5);\nvec4 rotationLocal_Root = vec4(0.026, 0.130, -0.003, 0.991);\nmat4 transform_Root;\n\nvec3 positionLocal_Neck = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Neck = vec4(0.0, 0.0, 0.0, 1.0);\nmat4 transform_Neck;\n\nvec3 positionLocal_Head = vec3(0.0, 0.25, -0.05);\nvec4 rotationLocal_Head = vec4(0.0, 0.0, 0.0, 1.0);\nmat4 transform_Head;\n\nvec3 positionLocal_Ear = vec3(0.64, 0.6, 0.08);\nvec4 rotationLocal_Ear = vec4(0.0, 0.383, 0.0, 0.924);\nmat4 transform_Ear;\n\nvec2 hairDir_0 = vec2(0.0, -1.0);\nvec2 hairDir_1 = vec2(0.0, -1.0);\n\n\n// Util\nfloat outlineMin(float a, float b)\n{\n    if(a > MAX_DISTANCE) return a;\n    if(b > MAX_DISTANCE) return b;\n    return min(a, b);\n}\n\n\n// Object\nstruct FacialInfo\n{\n    vec2 leftEyeBallPos;\n    float leftEyeBallScale;\n    vec2 rightEyeBallPos;\n    float rightEyeBallScale;\n    \n    float leftUpLidPos;\n    float leftDownLidPos;\n    float rightUpLidPos;\n    float rightDownLidPos;\n    \n    vec2 leftBrowStart;\n    vec2 leftBrowEnd;\n    vec2 leftBrowDir;\n    vec2 rightBrowStart;\n    vec2 rightBrowEnd;\n    vec2 rightBrowDir;\n    \n    vec2 lipStart;\n    vec2 lipEnd;\n    vec2 lipDir;\n    \n    float flushSize;\n    \n};\n\nstruct EyeInfo\n{\n    vec2 eyeballPos;\n    float eyeballScale;\n    float upLidPos;\n    float downLidPos;\n    \n    vec2 lightPos;\n    \n    vec2 browStart;\n    vec2 browEnd;\n    vec2 browDir;\n};\n\nstruct LipInfo\n{\n    vec2 lipStart;\n    vec2 lipEnd;\n    vec2 lipDir;\n};\n\nFacialInfo defaultFacialInfo = FacialInfo(\n    #ifndef SMILING\n    vec2(-0.2, 0.3),\n    0.9,\n    vec2(0.2, 0.3),\n    0.9,\n\n    0.45,\n    0.48,\n    0.45,\n    0.48,\n\n    vec2(-1.1, -0.8),\n    vec2(0.9, -0.2),\n    vec2(-0.3, -0.6),\n    vec2(1.1, -0.8),\n    vec2(-0.9, -0.2),\n    vec2(0.3, -0.6),\n\n    vec2(1.0, -0.1),\n    vec2(-1.0, -0.1),\n    vec2(0.0, 0.2),\n\n    1.3\n    \n    #else\n    vec2(0.8, 0.05),\n    1.0,\n    vec2(0.8, 0.05),\n    1.0,\n\n    0.52,\n    0.50,\n    0.52,\n    0.50,\n\n    vec2(-1.1, -0.5),\n    vec2(0.9, -0.1),\n    vec2(-0.3, -0.1),\n    vec2(1.1, -0.5),\n    vec2(-0.9, -0.1),\n    vec2(0.3, -0.1),\n\n    vec2(1.0, 0.15),\n    vec2(-1.1, 0.15),\n    vec2(0.1, -0.3),\n\n    0.7\n    #endif\n);\n\nfloat getLidSegDis(vec2 uv, float thick, float len, float bend, float angle, vec2 start, vec2 end, vec2 dir, float t)\n{\n    vec2 segStart = bezier(start, end, dir, t);\n    vec2 segTan = bezierTangent(start, end, dir, t);\n    float realTan = atan(segTan.y, segTan.x) + angle;\n    segTan = vec2(cos(realTan), sin(realTan));\n    vec2 segDir = cross(vec3(0.0, 0.0, 1.0), vec3(segTan, 0.0)).xy;\n    vec2 segEnd = segStart + len * segDir;\n    segDir = segStart + 0.5 * len * segDir;\n    segDir = segDir + normalize(segTan * sign(dot(segDir - dir, segTan))) * bend;\n    float segCurve;\n    \n    float baseDis = sdBezier(uv, segStart, segEnd, segDir, segCurve);\n    float actualDis = abs(baseDis) - mix(thick / 2.0, 0.0, segCurve);\n    \n    return actualDis;\n}\n\nvoid getEyeTexture(vec2 uv, EyeInfo info, float pixelSize, float t, inout vec3 outputColor)\n{\n    float line = outlineStrength * pixelSize / 2.0;\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 0.0);\n    return;\n    #endif\n    \n    float eyeBallLerp = sign(t) * pow(abs(t), 2.5);\n    \n    // 上眼睫毛\n    float upLidFactor = smoothstep(0.0, 1.0, info.upLidPos) * 2.0 - 1.0;\n    vec2 upLidStartCenter = triLerp(vec2(-0.59, -0.27), vec2(-0.59, 0.1), vec2(-0.59, 0.3), upLidFactor);\n    vec2 upLidEndCenter = triLerp(vec2(0.72, -0.23), vec2(0.72, 0.32), vec2(0.72, 0.48), upLidFactor);\n    vec2 upLidDirCenter = triLerp(vec2(0.3, -0.05), vec2(0.3, 0.5), vec2(0.0, 0.8), upLidFactor);\n    \n    vec2 upLidStartRight = triLerp(vec2(-0.1, -0.31), vec2(-0.1, 0.1), vec2(-0.1, 0.3), upLidFactor);\n    vec2 upLidEndRight = triLerp(vec2(1.0, -0.15), vec2(1.0, 0.33), vec2(1.0, 0.4), upLidFactor);\n    vec2 upLidDirRight = triLerp(vec2(0.36, -0.05), vec2(0.3, 0.5), vec2(0.32, 0.8), upLidFactor);\n    \n    vec2 upLidStartLeft = triLerp(vec2(0.0, -0.35), vec2(-0.1, 0.0), vec2(-0.1, 0.3), upLidFactor);\n    vec2 upLidEndLeft = triLerp(vec2(-0.1, -0.35), vec2(-0.2, 0.4), vec2(-0.2, 0.48), upLidFactor);\n    vec2 upLidDirLeft = triLerp(vec2(0.0, 0.05), vec2(-0.2, 0.5), vec2(-0.3, 0.8), upLidFactor);\n    \n    vec2 upLidStart = triLerp(upLidStartLeft, upLidStartCenter, upLidStartRight, eyeBallLerp);\n    vec2 upLidEnd = triLerp(upLidEndLeft, upLidEndCenter , upLidEndRight, eyeBallLerp);\n    vec2 upLidDir = triLerp(upLidDirLeft, upLidDirCenter, upLidDirRight, eyeBallLerp);\n    \n    float upLidCurve;\n    float upLidDis = sdBezier(uv, upLidStart, upLidEnd, upLidDir, upLidCurve);\n    float upLidThick = mix(0.0, 0.15, smoothmid(upLidCurve, 0.3));\n    \n    #ifndef SIMPLE_TEXTURE\n    \n    // 上眼小睫毛\n    \n    float upLidSegDis;\n    float upLidSeg0Dis = getLidSegDis(uv, line, 0.34, 0.05, PI * 0.4, upLidStart, upLidEnd, upLidDir, 0.2);\n    float upLidSeg1Dis = getLidSegDis(uv, line, 0.36, 0.05, PI * 0.333, upLidStart, upLidEnd, upLidDir, 0.3);\n    float upLidSeg2Dis = getLidSegDis(uv, line, 0.32, 0.05, -PI * 0.3, upLidStart, upLidEnd, upLidDir, 0.52);\n    float upLidSeg3Dis = getLidSegDis(uv, line, 0.32, 0.05, -PI * 0.35, upLidStart, upLidEnd, upLidDir, 0.6);\n    float upLidSeg4Dis = getLidSegDis(uv, line, 0.32, 0.05, -PI * 0.45, upLidStart, upLidEnd, upLidDir, 0.65);\n    \n    upLidSegDis = min(upLidSeg0Dis, upLidSeg1Dis);\n    upLidSegDis = min(upLidSegDis, upLidSeg2Dis);\n    upLidSegDis = min(upLidSegDis, upLidSeg3Dis);\n    upLidSegDis = min(upLidSegDis, upLidSeg4Dis);\n    \n    #endif\n    \n    // 上眼线\n    \n    vec2 upLidExtraStartCenter = triLerp(vec2(0.04, 0.14), vec2(0.04, 0.14), vec2(0.05, 0.2), upLidFactor);\n    vec2 upLidExtraSEndCenter = triLerp(vec2(-0.19, 0.25), vec2(-0.19, 0.2), vec2(-0.24, 0.22), upLidFactor);\n    vec2 upLidExtraSDirCenter = triLerp(vec2(-0.42, 0.24), vec2(-0.5, 0.14), vec2(-0.24, 0.14), upLidFactor);\n    \n    vec2 upLidExtraStartRight = triLerp(vec2(-0.05, 0.17), vec2(-0.05, 0.2), vec2(0.05, 0.28), upLidFactor);\n    vec2 upLidExtraEndRight = triLerp(vec2(-0.3, 0.19), vec2(-0.3, 0.23), vec2(-0.3, 0.3), upLidFactor);\n    vec2 upLidExtraDirRight = triLerp(vec2(-0.24, 0.23), vec2(-0.18, 0.14), vec2(-0.18, 0.08), upLidFactor);\n    \n    vec2 upLidExtraStartLeft = triLerp(vec2(0.1, 0.42), vec2(0.0, 0.3), vec2(0.0, 0.4), upLidFactor);\n    vec2 upLidExtraEndLeft = triLerp(vec2(0.1, 0.4), vec2(0.0, 0.2), vec2(0.0, 0.16), upLidFactor);\n    vec2 upLidExtraDirLeft = triLerp(vec2(0.1, 0.1), vec2(0.0, 0.1), vec2(0.2, 0.0), upLidFactor);\n    \n    vec2 upLidExtraStart = upLidStart + triLerp(upLidExtraStartLeft, upLidExtraStartCenter, upLidExtraStartRight, eyeBallLerp);\n    vec2 upLidExtraEnd = upLidEnd + triLerp(upLidExtraEndLeft, upLidExtraSEndCenter, upLidExtraEndRight, eyeBallLerp);\n    vec2 upLidExtraDir = upLidDir + triLerp(upLidExtraDirLeft, upLidExtraSDirCenter, upLidExtraDirRight, eyeBallLerp);\n    \n    float upLidExtraCurve;\n    float upLidExtraDis = sdBezier(uv, upLidExtraStart, upLidExtraEnd, upLidExtraDir, upLidExtraCurve);\n    float upLidExtraThick = mix(line / 5.0 * 2.0, line / 7.0 * 6.0, smoothmid(upLidExtraCurve, 0.3));\n    \n    // 下眼睫毛\n    float downLidFactor = smoothstep(0.0, 1.0, info.downLidPos) * 2.0 - 1.0;\n    vec2 downLidStartCenter = triLerp(vec2(-0.4, -0.19), vec2(-0.4, -0.36), vec2(-0.4, -0.48), downLidFactor);\n    vec2 downLidEndCenter = triLerp(vec2(0.41, -0.15), vec2(0.41, -0.32), vec2(0.41, -0.46), downLidFactor);\n    vec2 downLidDirCenter = triLerp(vec2(-0.1, -0.05), vec2(0.13, -0.5), vec2(0.0, -0.64), downLidFactor);\n    \n    vec2 downLidStartRight = triLerp(vec2(0.1, -0.21), vec2(0.1, -0.32), vec2(0.1, -0.5), downLidFactor);\n    vec2 downLidEndRight = triLerp(vec2(0.74, -0.13), vec2(0.74, -0.16), vec2(0.74, -0.3), downLidFactor);\n    vec2 downLidDirRight = triLerp(vec2(0.34, -0.15), vec2(0.34, -0.5), vec2(0.34, -0.64), downLidFactor);\n    \n    vec2 downLidStartLeft = triLerp(vec2(0.1, -0.15), vec2(0.1, -0.4), vec2(0.1, -0.44), downLidFactor);\n    vec2 downLidEndLeft = triLerp(vec2(-0.2, -0.05), vec2(-0.2, -0.1), vec2(-0.2, -0.36), downLidFactor);\n    vec2 downLidDirLeft = triLerp(vec2(0.0, -0.1), vec2(0.0, -0.4), vec2(0.0, -0.48), downLidFactor);\n    \n    vec2 downLidStart = triLerp(downLidStartLeft, downLidStartCenter, downLidStartRight, eyeBallLerp);\n    vec2 downLidEnd = triLerp(downLidEndLeft, downLidEndCenter, downLidEndRight, eyeBallLerp);\n    vec2 downLidDir = triLerp(downLidDirLeft, downLidDirCenter, downLidDirRight, eyeBallLerp);\n    \n    float downLidCurve;\n    float downLidDis = sdBezier(uv, downLidStart, downLidEnd, downLidDir, downLidCurve);\n    float downLidThick = mix(line / 2.0, line, smoothmid(downLidCurve, 0.5));\n    \n    #ifndef SIMPLE_TEXTURE\n    // 下眼小睫毛\n    \n    float downLidSegDis;\n    float downLidSeg0Dis = getLidSegDis(uv, line, 0.06, 0.01, PI * 1.2, downLidStart, downLidEnd, downLidDir, 0.76);\n    float downLidSeg1Dis = getLidSegDis(uv, line, 0.1, 0.01, PI * 1.2, downLidStart, downLidEnd, downLidDir, 0.92);\n    float downLidSeg2Dis = getLidSegDis(uv, line, 0.1, 0.01, PI * 1.2, downLidStart, downLidEnd, downLidDir, 1.08);\n    \n    downLidSegDis = min(downLidSeg0Dis, downLidSeg1Dis);\n    downLidSegDis = min(downLidSegDis, downLidSeg2Dis);\n    #endif\n    \n    // 左侧边界\n    vec2 startEdgeStart = upLidStart;\n    vec2 startEdgeEnd = downLidStart;\n    vec2 startEdgeDir = triLerp(vec2(-0.2, -0.2), vec2(-0.6, -0.2), vec2(-0.1, -0.2), eyeBallLerp);\n    startEdgeDir.y = (upLidStart.y + downLidStart.y) / 2.0;\n    float startEdgeCurve;\n    float startEdgeDis = sdBezier(uv, startEdgeStart, startEdgeEnd, startEdgeDir, startEdgeCurve);\n    \n    if(upLidDis > 0.0 && (downLidDis < 0.0 || downLidCurve < 0.0 || downLidCurve > 1.0) && startEdgeDis < 0.0)\n    {\n        // 眼球\n        vec2 ballOriginLeft = quaLerp(vec2(-0.0, 0.05), vec2(-0.2, 0.41), vec2(-0.2, 0.05), vec2(-0.2, -0.31), vec2(-0.2, 0.05), info.eyeballPos);\n        vec2 ballOriginCenter = quaLerp(vec2(0.16, 0.0), vec2(0.0, 0.36), vec2(-0.12, 0.0), vec2(0.0, -0.36), vec2(0.0, 0.0), info.eyeballPos);\n        vec2 ballOriginRight = quaLerp(vec2(0.45, 0.05), vec2(0.0, 0.25), vec2(0.15, 0.05), vec2(0.15, -0.25), vec2(0.35, 0.05), info.eyeballPos);\n        \n        vec2 ballOrigin = triLerp(ballOriginLeft, ballOriginCenter, ballOriginRight, eyeBallLerp);\n        vec2 ballSize = triLerp(vec2(-0.0, 0.42), vec2(0.38, 0.42), vec2(0.2, 0.42), eyeBallLerp) * info.eyeballScale;\n        float ballDis = sdEllipse(uv, ballOrigin, ballSize);\n        float ballOutline = 0.12 * info.eyeballScale;\n        outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, ballDis));\n        outputColor = mix(outputColor, vec3(1.0), smoothstep(-ballOutline + pixelSize, -ballOutline, ballDis));\n        \n        #ifndef SIMPLE_TEXTURE\n        \n        // 眼球排线\n        vec2 ballLineOrigin = ballOrigin + vec2(0.0, ballSize.y);\n        vec2 ballLineDirection = normalize(triLerp(vec2(0.5, 1.0), vec2(0.0, 1.0), vec2(-0.5, 1.0), eyeBallLerp));\n        \n        \n        float lineOrigin = dot(ballLineOrigin, ballLineDirection);\n        float ballLine = lineOrigin + 0.035;\n        float ballLineStep = 0.03;\n        float ballLineAccu = 0.0007;\n        float ballLineAccuAccu = 0.0003;\n        float ballLineCur = dot(uv, ballLineDirection);\n        float lineDis = 65535.0;\n        \n        if(ballDis < 0.0)\n        {\n            for(int i = ZERO; i < 12; i++)\n            {\n                ballLineAccu += ballLineAccuAccu;\n                ballLineStep += ballLineAccu * info.eyeballScale;\n                ballLine -= ballLineStep;\n            \n                lineDis = min(lineDis, abs(ballLine - ballLineCur));\n            }\n        \n            outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, lineDis - line / 6.0));\n        }\n        \n        #endif\n        \n        // 眼珠\n        vec2 irisOriginLeft = quaLerp(vec2(0.05, 0.05), vec2(-0.25, 0.41), vec2(-0.25, 0.05), vec2(-0.25, -0.31), vec2(-0.25, 0.05), info.eyeballPos);\n        vec2 irisOriginCenter = quaLerp(vec2(0.19, 0.0), vec2(0.0, 0.36), vec2(-0.15, 0.0), vec2(0.0, -0.36), vec2(0.0, 0.0), info.eyeballPos);\n        vec2 irisOriginRight = quaLerp(vec2(0.48, 0.05), vec2(0.0, 0.25), vec2(0.15, 0.05), vec2(0.15, -0.25), vec2(0.37, 0.05), info.eyeballPos);\n\n        ballOrigin = triLerp(irisOriginLeft, irisOriginCenter, irisOriginRight, eyeBallLerp);\n        ballSize = triLerp(vec2(-0.05, 0.16), vec2(0.14, 0.16), vec2(0.06, 0.16), eyeBallLerp) * info.eyeballScale;\n        ballDis = sdEllipse(uv, ballOrigin, ballSize);\n        outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, ballDis));\n        \n        #ifndef SIMPLE_TEXTURE\n        \n        // 高光\n        vec2 lightOriginLeft = quaLerp(vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), info.lightPos) * info.eyeballScale + ballOriginLeft;\n        vec2 lightOriginCenter = quaLerp(vec2(0.3, 0.0), vec2(0.0, 0.4), vec2(-0.3, 0.0), vec2(0.0, -0.4), vec2(0.0, 0.0), info.lightPos) * info.eyeballScale + ballOriginCenter;\n        vec2 lightOriginRight = quaLerp(vec2(0.18, 0.0), vec2(0.0, 0.4), vec2(-0.18, 0.0), vec2(0.0, -0.4), vec2(0.0, 0.0), info.lightPos) * info.eyeballScale + ballOriginRight;\n        \n        ballOrigin = triLerp(lightOriginLeft, lightOriginCenter, lightOriginRight, eyeBallLerp);\n        ballSize = triLerp(vec2(0.11, 0.11), vec2(0.15, 0.1), vec2(0.11, 0.1), eyeBallLerp);\n        ballDis = sdEllipse(uv, ballOrigin, ballSize);\n        \n        float lightWidth = mix(0.0, line / 1.0, clamp(1.0 - (normalize(uv - ballOrigin).x * sign(info.lightPos.x) - 0.6) / 0.35, 0.0, 1.0));\n        if(lightWidth > 0.0) outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, ballDis));\n        outputColor = mix(outputColor, vec3(1.0), smoothstep(-lightWidth + pixelSize, -lightWidth, ballDis));\n        \n        #endif\n        \n    }\n    \n    outputColor = mix(outputColor, vec3(1.0), smoothstep(pixelSize, 0.0, abs(startEdgeDis)));\n    \n    outputColor = mix(outputColor, vec3(0.0), min(smoothstep(0.0, -pixelSize, abs(upLidDis) - upLidThick), smoothstep(-pixelSize, 0.0, -upLidDis)));\n    outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, abs(upLidExtraDis) - upLidExtraThick));\n    outputColor = mix(outputColor, vec3(0.0), min(smoothstep(0.0, -pixelSize, abs(downLidDis) - downLidThick), smoothstep(pixelSize, 0.0, downLidDis)));\n    \n    #ifndef SIMPLE_TEXTURE\n    if(upLidDis < 0.0) outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, upLidSegDis));\n    if(downLidDis > 0.0) outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, downLidSegDis));\n    #endif\n    \n    // 眉毛\n    vec2 browCenter = triLerp(vec2(0.8, 1.04), vec2(0.02, 1.04), vec2(0.4, 1.04), eyeBallLerp);\n    vec2 browStart = browCenter + 0.6 * info.browStart;\n    vec2 browDir = browCenter + 0.6 * info.browDir;\n    vec2 browEnd = browCenter + 0.6 * info.browEnd;\n    float browCurve;\n        \n    float browDis = sdBezier(uv, browStart, browEnd, browDir, browCurve);\n    float browThick = mix(0.0, 0.02, smoothmid(browCurve, 0.3));\n    \n    outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, abs(browDis) - browThick));\n}\n\nvoid getNoseTexture(vec2 uv, float pixelSize, float t, inout vec3 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 1.0);\n    return;\n    #endif\n    \n    float line = outlineStrength * pixelSize / 2.0;\n    \n    vec2 noseStart = triLerp(vec2(0.3, 0.5), vec2(0.0, 0.2), vec2(-0.3, 0.5), t);\n    vec2 noseEnd = triLerp(vec2(0.5, -0.05), vec2(0.0, -0.2), vec2(-0.5, -0.05), t);\n    float noseDis = sdSegment(uv, noseStart, noseEnd);\n    vec2 vect = noseEnd - noseStart;\n    float len = length(vect);\n    float proj = dot(uv - noseStart, vect / len) / len;\n    float noseThick = mix(0.0, line, smoothmid(proj, 0.5));\n    \n    outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, noseDis - noseThick));\n}\n\nvoid getLipTexture(vec2 uv, LipInfo info, float pixelSize, float t, inout vec3 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 0.5);\n    return;\n    #endif\n    \n    t = sign(t) * pow(abs(t), 3.0);\n    \n    float line = outlineStrength * pixelSize / 2.0;\n    \n    float lipRotate = triLerp(-PI / 24.0 , 0.0, PI / 24.0, t);\n    vec2 lipOffset = triLerp(vec2(-0.3, 0.03), vec2(0.0, 0.0), vec2(0.3, 0.03), t);\n    vec2 lipDirX = vec2(cos(lipRotate), sin(lipRotate)) * triLerp(0.8, 1.0, 0.8, t);\n    vec2 lipDirY = vec2(cos(lipRotate + PI / 2.0), sin(lipRotate + PI / 2.0));\n    \n    vec2 scale = vec2(0.15, 0.15);\n    vec2 lipStart = (info.lipStart.x * lipDirX + info.lipStart.y * lipDirY) * scale + lipOffset;\n    vec2 lipEnd = (info.lipEnd.x * lipDirX + info.lipEnd.y * lipDirY) * scale + lipOffset;\n    vec2 lipDir = (info.lipDir.x * lipDirX + info.lipDir.y * lipDirY) * scale + lipOffset;\n    \n    float lipCurve;\n    float lipDis = sdBezier(uv, lipStart, lipEnd, lipDir, lipCurve);\n    float lipThick = mix(0.0, line, max(smoothmid(lipCurve, 0.05), smoothmid(lipCurve, 0.95)));\n    \n    outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, abs(lipDis) - line * 0.72));\n    \n    // outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, noseDis - noseThick));\n}\n\nvoid getScarTexture(vec2 uv, vec2 sc, float pixelSize, inout vec3 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 0.75);\n    return;\n    #endif\n    \n    float line = outlineStrength * pixelSize / 2.0;\n    float scarDis = 65535.0;\n    scarDis = min(scarDis, sdOrientedVesica(uv, vec2(-0.54, -0.4), vec2(0.54, 0.4), 0.14));\n    scarDis = smin(scarDis, sdOrientedVesica(uv, vec2(-0.3, 0.4), vec2(0.3, -0.4), 0.18), 0.08);\n    \n    outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, scarDis - line));\n    outputColor = mix(outputColor, vec3(1.0), smoothstep(0.0, -pixelSize, scarDis));\n    \n    #ifndef SIMPLE_TEXTURE\n    vec2 lineDirection = normalize(vec2(-0.54, -0.4));\n    float lineOrigin = dot(vec2(0.0), lineDirection);\n    float linePos = lineOrigin + 0.03;\n    float lineStep = 0.12;\n    float lineCur = dot(sc, lineDirection);\n    float lineDis = 65535.0;\n        \n    if(scarDis < 0.0)\n    {\n        for(int i = ZERO - 5; i <= 5; i++)\n        {\n            linePos = float(i) * lineStep;\n            lineDis = min(lineDis, abs(linePos - lineCur));\n        }\n        \n         outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, lineDis - line * 0.75));\n     }\n     #endif\n}\n\nvoid getEarTexture(vec2 uv, float pixelSize, inout vec3 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 0.75);\n    return;\n    #endif\n    \n    float line = outlineStrength * pixelSize / 2.0;\n    \n    // 这就是为什么你不应该用sub\n    float shapeDis = sdUnevenCapsule(uv, vec2(0.56, 0.34), vec2(-0.12, -0.2), 0.4, 0.36);\n    // 突起\n    float susDis = sdUnevenCapsule(uv, vec2(0.3, 0.26), vec2(-0.14, 0.18), 0.12, 0.2);\n    \n    shapeDis = ssub(shapeDis, susDis, 0.2);\n    outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, shapeDis));\n    outputColor = mix(outputColor, vec3(1.0), smoothstep(-line + pixelSize, -line, shapeDis));\n    \n    // 耳屎出来的地方\n    float holeDis = sdCircle(uv, vec2(-0.2, -0.1), 0.18);\n    holeDis = max(shapeDis, holeDis);\n    outputColor = mix(outputColor, vec3(0.0), smoothstep(pixelSize, 0.0, holeDis));\n    \n}\n\nvoid getFlushTexture(vec2 uv, float pixelSize, float flushSize, float t, inout vec3 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec3(uv * 0.5 + 0.5, 0.875);\n    return;\n    #endif\n    \n    float line = outlineStrength * pixelSize / 2.0;\n    \n    #ifndef SIMPLE_TEXTURE\n    float flushDis = sdEllipse(uv, vec2(0.0, 0.0), flushSize * vec2(0.48, 0.24));\n    float flushFade = flushSize * 0.2;\n    \n    vec2 lineDirection = normalize(vec2(-0.54, -0.8));\n    float lineOrigin = dot(vec2(0.0), lineDirection);\n    float linePos = lineOrigin + 0.03;\n    float lineStep = 0.08;\n    float lineCur = dot(uv, lineDirection);\n    float lineDis = 65535.0;\n    \n    for(int i = ZERO - 8; i <= 8; i++)\n    {\n        linePos = float(i) * lineStep;\n        lineDis = min(lineDis, abs(linePos - lineCur));\n    }\n        \n    outputColor = mix(outputColor, vec3(0.0), smoothstep(0.0, -pixelSize, lineDis - line * 0.5 * smoothstep(0.0, -flushFade, flushDis)));\n    \n    outputColor = mix(vec3(1.0), outputColor, smoothstep(pixelSize, 0.0, flushDis));\n    #endif\n}\n\nObjectInfo ear(vec3 p, mat4 sdf_transform, float pixelSize, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = DEFAULT_INFO;\n    vec3 transPoint = (sdf_transform * vec4(p, 1.0)).xyz;\n    \n    float earDis = sdUnevenCapsule(transPoint.xy, vec2(0.16, 0.1), vec2(-0.05, -0.1), 0.108, 0.08);\n    earDis = opExtrusion(transPoint, earDis, 0.005) - 0.01;\n    \n    info.dis = earDis;\n    outlineDis = info.dis;\n    \n    if(withMat)\n    {\n        if(transPoint.z < 0.0)\n        {\n            vec3 point = vec3(0.0, 0.0, 0.0);\n            float size = 0.24;\n            \n            vec3 vector = transPoint - point;\n            vec2 uv = vector.xy / size;\n            \n            getEarTexture(uv, pixelSize / size, info.material.color0.rgb);\n        }\n    }\n    \n    return info;\n}\n\nObjectInfo animeHead(vec3 p, mat4 sdf_transform, vec3 view, float pixelSize, FacialInfo facialInfo, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = DEFAULT_INFO;\n    vec3 transPoint = (sdf_transform * vec4(p, 1.0)).xyz;\n    \n    // 大致轮廓\n    float skinDis = 65535.0f;\n    \n    // 额头\n    skinDis = min(skinDis, sdEllipsoid(transPoint, vec3(0.0, 1.16, 0.04), vec3(0.72, 0.64, 0.72)));\n   \n    // 下巴\n    float jawDis = sdRoundCone(transPoint, vec3(0.0, 0.5, -0.1), vec3(0.0, 0.06, -0.45), 0.5, 0.03);\n    jawDis = smin(jawDis, sdEllipsoid(transPoint, vec3(0.0, 0.36, -0.3), vec3(0.2, 0.35, 0.2)), 0.3);\n    \n    skinDis = smin(skinDis, jawDis, 0.54);\n    \n    // 脸颊\n    skinDis = smin(skinDis, transPoint.x < 0.0 ? sdEllipsoid(transPoint, vec3(-0.24, 0.4, -0.26), vec3(0.2, 0.24, 0.25)) :\n                                               sdEllipsoid(transPoint, vec3(0.24, 0.4, -0.26), vec3(0.2, 0.24, 0.25)), 0.3);\n                                 \n    // 下颚切除\n    float jawSubDis = sdPlane(transPoint, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.928477, -0.371391));\n    jawSubDis = smin(jawSubDis, min(sdPlane(transPoint, vec3(0.0, -0.2, 0.0), vec3(0.496139, 0.868243, 0.0)),\n                                    sdPlane(transPoint, vec3(0.0, -0.2, 0.0), vec3(-0.496139, 0.868243, 0.0))), 0.1);\n    jawSubDis = smin(jawSubDis, sdPlane(transPoint, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.7071068, -0.7071068)), 0.1);\n    \n    skinDis = ssub(skinDis, jawSubDis, 0.2);\n    \n    // 鼻梁\n    float noseSubDis = sdCapsule(transPoint, vec3(-1.0, 0.7, -0.8), vec3(1.0, 0.7, -1.0), 0.08);\n    \n    skinDis = ssub(skinDis, noseSubDis, 0.58);\n    \n    // 鼻子\n    float noseDis;\n    \n    float nosePart0Dis = sdPyramid(transPoint, vec3(0.0, 0.59, -0.6),\n                                               vec3(-0.08, 0.39, -0.6),\n                                               vec3(0.0, 0.3, -0.6),\n                                               vec3(0.08, 0.39, -0.6),\n                                               vec3(0.0, 0.45, -0.75));\n                                               \n    float nosePart1Dis = sdPyramid(transPoint, vec3(0.0, 0.50, -0.6),\n                                               vec3(-0.1, 0.37, -0.6),\n                                               vec3(0.0, 0.33, -0.64),\n                                               vec3(0.1, 0.37, -0.6),\n                                               vec3(0.0, 0.45, -0.8));\n    \n    \n    noseDis = smin(nosePart0Dis, nosePart1Dis, 0.1);\n    skinDis = smin(skinDis, noseDis, 0.05);\n    \n    if(withMat)\n    {\n        vec3 viewDir = (sdf_transform * vec4(-view, 0.0)).xyz;\n        vec3 normal = viewDir;\n        normal.y = 0.0;\n        normal = normalize(normal);\n        vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n        vec3 bitangent = normalize(cross(tangent, normal));\n        \n        if(transPoint.z < -0.1)\n        {\n            // 红晕\n            float t = normal.x;\n            vec3 point = triLerp(vec3(0.36, 0.48, -0.54), vec3(0.38, 0.48, -0.54), vec3(0.38, 0.48, -0.24), t);\n            float size = 0.32;\n            vec3 vector = transPoint - point;\n            vec2 uv = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n            \n            if(transPoint.x > 0.0 && abs(uv.x) < 1.0 && abs(uv.y) < 1.0) getFlushTexture(uv, pixelSize / size, facialInfo.flushSize, t, info.material.color0.rgb);\n            \n            t = -normal.x;\n            point = triLerp(vec3(-0.36, 0.48, -0.54), vec3(-0.38, 0.48, -0.54), vec3(-0.38, 0.48, -0.24), t);\n            size = 0.32;\n            vector = transPoint - point;\n            uv = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n            uv.x = uv.x;\n            \n            if(transPoint.x < 0.0 && abs(uv.x) < 1.0 && abs(uv.y) < 1.0) getFlushTexture(uv, pixelSize / size, facialInfo.flushSize, t, info.material.color0.rgb);\n            \n            \n            // 鼻子纹理\n            size = 0.2;\n            uv = (transPoint.xy - vec2(0.0, 0.45)) / size;\n            \n            if(abs(uv.x) < 1.0 && abs(uv.y) < 1.0) getNoseTexture(uv, pixelSize / size, normal.x, info.material.color0.rgb);\n            \n            // 嘴巴纹理\n            point = vec3(0.0, 0.22, -0.59);\n            size = 0.64;\n            \n            vector = transPoint - point;\n            uv = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n            LipInfo lipInfo = LipInfo(facialInfo.lipStart, facialInfo.lipEnd, facialInfo.lipDir);\n            if(normal.z < 0.02 && abs(uv.x) < 1.0 && abs(uv.y) < 0.2) getLipTexture(uv, lipInfo, pixelSize / size, normal.x, info.material.color0.rgb);\n            \n            // 伤疤纹理\n            t = sign(normal.x) * pow(abs(normal.x), 4.0);\n            point = triLerp(vec3(-0.3, 1.14, -0.69), vec3(0.0, 1.14, -0.69), vec3(0.3, 1.14, -0.69), t);\n            size = 0.32;\n            vector = transPoint - point;\n            uv = (vector.xy) / size;\n            \n            vec2 sc = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n            \n            if(abs(uv.x) < 1.0 && abs(uv.y) < 1.0) getScarTexture(uv, sc, pixelSize / size, info.material.color0.rgb);\n            \n            // if(length(vector) < 0.05) info.material.color0 = vec4(0.0);\n            \n            if(transPoint.x > 0.0)\n            {\n                vec3 point = vec3(0.332, 0.67, -0.5);\n                float size = 0.32;\n            \n                vec3 vector = transPoint - point;\n                vec2 uv = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n            \n                EyeInfo eyeInfo = EyeInfo(facialInfo.leftEyeBallPos, facialInfo.leftEyeBallScale, facialInfo.leftUpLidPos, facialInfo.leftDownLidPos,\n                                      vec2(-1.0, 0.05),\n                                      facialInfo.leftBrowStart, facialInfo.leftBrowEnd, facialInfo.leftBrowDir);\n                if(normal.z < 0.02 && abs(uv.x) < 1.5 && abs(uv.y) < 1.5) getEyeTexture(uv, eyeInfo, pixelSize / size, normal.x, info.material.color0.rgb);\n            }\n        \n            else\n            {\n                vec3 point = vec3(-0.332, 0.67, -0.5);\n                float size = 0.32;\n            \n                vec3 vector = transPoint - point;\n                vec2 uv = vec2(dot(vector, tangent), dot(vector, bitangent)) / size;\n                uv.x = -uv.x;\n            \n                facialInfo.rightEyeBallPos *= vec2(-1.0, 1.0);\n                facialInfo.rightBrowStart *= vec2(-1.0, 1.0);\n                facialInfo.rightBrowDir *= vec2(-1.0, 1.0);\n                facialInfo.rightBrowEnd  *= vec2(-1.0, 1.0);\n            \n                EyeInfo eyeInfo = EyeInfo(facialInfo.rightEyeBallPos, facialInfo.rightEyeBallScale, facialInfo.rightUpLidPos, facialInfo.rightDownLidPos,\n                                      vec2(1.0, 0.05),\n                                      facialInfo.rightBrowStart, facialInfo.rightBrowEnd, facialInfo.rightBrowDir);\n                if(normal.z < 0.02 && abs(uv.x) < 1.5 && abs(uv.y) < 1.5) getEyeTexture(uv, eyeInfo, pixelSize / size, -normal.x, info.material.color0.rgb);\n            }\n        }\n        \n        \n        // 头发\n        float hairDis = sdPlane(transPoint, vec3(0.0, 0.4, -0.13), vec3(0.0, -0.1483405, -0.9889364));\n        hairDis = smin(hairDis, sdPlane(transPoint, vec3(0.0, 1.25, 0.05), vec3(0.0, -0.7808688, -0.6246951)), 0.1);\n        hairDis = ssub(hairDis, sdPlane(transPoint, vec3(0.0, 0.28, 0.05), vec3(0.0, 0.7808688, 0.6246951)), 0.1);\n        info.material.color0.rgb = mix(info.material.color0.rgb, vec3(0.0), smoothstep(pixelSize, 0.0, hairDis));\n        \n        #ifdef CROSSLINE\n        if(transPoint.z < -0.2)\n        {\n            float horLineDis = abs(transPoint.y - 0.45);\n            float horLineThres = mix(0.0, 0.005, pow(1.0 - abs(transPoint.x) / 0.5, 0.5));\n            \n            info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(horLineThres + 0.005, horLineThres, horLineDis));\n            \n            float verLineDis = abs(transPoint.x);\n            float verLineThres = mix(0.0, 0.005, pow(1.0 - abs(transPoint.y - 0.6) / 0.6, 0.5));\n            \n            info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(verLineThres + 0.005, verLineThres, verLineDis));\n        }\n        #endif\n    }\n    \n    info.dis = skinDis;\n    outlineDis = info.dis;\n    \n    float earOutline;\n    if(transPoint.x > 0.0) info = objectMin(info, ear(transPoint, transform_Ear, pixelSize, castShadow, withMat, earOutline));\n    else\n    {\n        vec3 transPoint_m = transPoint;\n        transPoint_m.x = -transPoint_m.x;\n        info = objectMin(info, ear(transPoint_m, transform_Ear, pixelSize, castShadow, withMat, earOutline));\n    }\n    \n    outlineDis = min(earOutline, outlineDis);\n    return info;\n}\n\nObjectInfo neck(vec3 p, mat4 sdf_transform, float pixelSize, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = DEFAULT_INFO;\n    vec3 transPoint = (sdf_transform * vec4(p, 1.0)).xyz;\n    \n    info.dis = sdCapsule(transPoint, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, 0.0), 0.18);\n    \n    outlineDis = info.dis;\n    return info;\n}\n\nObjectInfo body(vec3 transPoint, float pixelSize, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = DEFAULT_INFO;\n    \n    info.dis = sdCapsule(transPoint, vec3(-0.61, -0.4, 0.0), vec3(0.0, -0.29, 0.0), 0.28);\n    info.dis = smin(info.dis, sdCapsule(transPoint, vec3(0.61, -0.4, 0.0), vec3(0.0, -0.29, 0.0), 0.28), 0.01);\n    \n    \n    float chestDis = sdSegment(transPoint.xz, vec2(-0.55, 0.0), vec2(0.55, 0.0)) - 0.27;\n    float h = 0.3;\n    vec2 chestCoord = vec2(chestDis, abs(transPoint.y - (-0.38 - h)) - h);\n    chestDis = min(max(chestCoord.x, chestCoord.y),0.0) + length(max(chestCoord, 0.0));\n    chestDis = smin(chestDis, sdCapsule(transPoint, vec3(-0.45, -0.5, -0.1), vec3(0.45, -0.5, -0.1), 0.14), 0.3);\n    info.dis = smin(info.dis, chestDis, 0.1);\n    \n    \n    info.dis = ssub(info.dis, min(sdSphere(transPoint, vec3(0.55, 0.1, 0.0), 0.1), sdSphere(transPoint, vec3(-0.55, 0.1, 0.0), 0.1)), 0.4);\n    info.dis = ssub(info.dis, min(sdPlane(transPoint, vec3(-0.85, -0.3, 0.0), vec3(0.8944272, 0.4472136, 0.0)), sdPlane(transPoint, vec3(0.85, -0.3, 0.0), vec3(-0.8944272, 0.4472136, 0.0))), 0.1);\n    \n    float armDis = transPoint.x > 0.0 ?\n                   sdCapsule(transPoint, vec3(0.75, -0.4, 0.02), vec3(0.85, -0.9, 0.02), 0.2) :\n                   sdCapsule(transPoint, vec3(-0.75, -0.4, 0.02), vec3(-0.85, -0.9, 0.02), 0.2);\n    info.dis = smin(info.dis, armDis, 0.1);\n    \n    if(withMat)\n    {\n        float line = outlineStrength * pixelSize / 2.0 * 0.75;\n        float collarDis = sdVesicaSegment(transPoint, vec3(-0.95, -0.1, 0.0), vec3(0.95, -0.1, 0.0), 0.6);\n        info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(pixelSize, 0.0, -collarDis));\n        collarDis = sub(collarDis, sdVesicaSegment(transPoint, vec3(0.0, -0.6, -0.38), vec3(0.0, 0.2, 0.1), 0.32));\n        info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(line, line - pixelSize, abs(collarDis)));\n        \n        float stripDis = sdVesicaSegment(transPoint, vec3(-0.69, -0.1, 0.0), vec3(0.69, -0.1, 0.0), 0.58);\n        stripDis = sub(stripDis, sdVesicaSegment(transPoint, vec3(-0.55, -0.1, 0.0), vec3(0.55, -0.1, 0.0), 0.54));\n        if(abs(transPoint.x) > 0.4 || transPoint.y < -0.2) info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(pixelSize, 0.0, collarDis) * smoothstep(pixelSize, -pixelSize, stripDis));\n        \n        float collarHeight = mix(-0.28, -0.24, smoothstep(0.0, 0.4, abs(transPoint.x)));\n        info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(0.0, pixelSize, collarDis) * smoothstep(line, line - pixelSize, abs(transPoint.y - collarHeight)));\n        \n        float stripHeight = mix(-0.38, -0.34, smoothstep(0.0, 0.44, abs(transPoint.x)));\n        info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(0.0, pixelSize, collarDis) * smoothstep(0.04, 0.04 - pixelSize, abs(transPoint.y - stripHeight)));\n    }\n    \n    outlineDis = info.dis;\n    return info;\n}\n\n// Base March\nObjectInfo sceneBaseMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat, inout float outlineDis)\n{\n    float headOutline;\n    ObjectInfo headInfo = animeHead(point, transform_Head, view, pixelSize, defaultFacialInfo, castShadow, withMat, headOutline);\n    \n    float neckOutline;\n    ObjectInfo neckInfo = neck(point, transform_Neck, pixelSize, castShadow, withMat, neckOutline);\n    \n    vec3 transPoint = (transform_Root * vec4(point, 1.0)).xyz;\n    \n    float bodyOutline;\n    ObjectInfo bodyInfo = body(transPoint, pixelSize, castShadow, withMat, bodyOutline);\n    \n    ObjectInfo info = objectSmoothMinWithoutBlend(bodyInfo, neckInfo, 0.1);\n    info = objectSmoothMinWithoutBlend(headInfo, info, 0.05);\n\n    outlineDis = smin(bodyOutline, neckOutline, 0.1);\n    outlineDis = smin(headOutline, outlineDis, 0.05);\n    return info;\n}\n\nvec3 march(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float pixelSize, inout vec3 pos, inout float len)\n{\n    len = 0.0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    ObjectInfo lastSolidInfo;\n    \n    float stepDis;\n    \n    int stepCount = 0;\n    \n    float curPixelSize;\n    float disWhenHit = 65535.0;\n    float lenWhenHit;\n    float disForRealHit = 65535.0;\n    float lenForRealHit;\n    bool outlineHitFlag = false;\n    float outlineDis;\n    \n    float theta = dot(ray, front);\n    \n    int outlineHit = 0;\n\n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n        \n        lastSolidInfo = curSolidInfo;\n        curSolidInfo = sceneBaseMap(curPos, front, curPixelSize, false, false, outlineDis);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < curPixelSize)\n        {\n            break;\n        }\n        \n        if(outlineHit == 0)\n        {\n            // 第一次到范围内\n            if(outlineDis <= curPixelSize * outlineStrength) outlineHit = 1;\n            \n            float currentDis = outlineDis / curPixelSize;\n            lenWhenHit = len;\n            disWhenHit = currentDis;\n        }\n        else if(outlineHit == 1)\n        {\n            if(outlineDis > MAX_DISTANCE)\n            {\n                outlineHit = 0;\n            }\n            else if(outlineDis <= curPixelSize * outlineStrength)\n            {\n                float currentDis = outlineDis / curPixelSize;\n                \n                if(disWhenHit > currentDis)\n                {\n                    lenWhenHit = len;\n                    disWhenHit = currentDis;\n                }\n            }\n            else\n            {\n                outlineHit = 0;\n                outlineHitFlag = true;\n                if(disWhenHit < disForRealHit)\n                {\n                    disForRealHit = disWhenHit;\n                    lenForRealHit = lenWhenHit;\n                }\n            }\n        }\n\n        stepDis = dis;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    vec3 outputColor = getColorAtPos(pos, ray, front, len, screenCoord, curPixelSize, dis, outlineHitFlag, disForRealHit, lenForRealHit);\n    return outputColor;\n}\n\nMaterial sceneBaseMaterial(vec3 point, vec3 view, float pixelSize, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE) {\n        Material outMat;\n        outMat.color0 = BACKGROUND_COLOR;\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    float outlineDis;\n    return sceneBaseMap(point, view, pixelSize, false, true, outlineDis).material;\n}\n\nvec3 getColorAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis, bool outlineHit, float disWhenHit, float lenWhenHit)\n{\n    Material material = sceneBaseMaterial(pos, front, pixelSize, len, screenCoord);\n    vec4 outlineColor = vec4(0.0);\n    \n    if(outlineHit)\n    {\n        float outlineThreshold = mix(0.0, outlineStrength, clamp((len - lenWhenHit) / outlineThreshold, 0.0, 1.0));\n        outlineColor = vec4(OUTLINE_COLOR.rgb, clamp(outlineThreshold - disWhenHit - 0.25, 0.0, 1.0));\n    }\n    \n    vec3 solidColor = vec3(0.0);\n    if(material.index == 0) solidColor = material.color0.rgb;\n    else\n    {\n        solidColor = material.color0.rgb;\n    }\n    \n    return mix(solidColor, outlineColor.rgb, outlineColor.a);\n}\n\n// Hair March\nconst float stripCount = 28.0;\nconst float bangCount = 4.0;\nvoid getSideTexture(vec2 uv, float pixelSize, vec2 start, vec2 dir, vec2 end, vec2 endDiff, float widthStart, float widthEnd, inout vec4 outputColor)\n{\n    float sideCurve_0;\n    vec2 sideEnd_0 = end - endDiff / 2.0;\n    vec2 sideDir_0 = dir - endDiff / 8.0;\n    float sideDis_0 = abs(sdBezier(uv, start, sideEnd_0, sideDir_0, sideCurve_0));\n    float sideWidth_0 = mix(widthStart, widthEnd, smoothstep(0.0, 1.0, sideCurve_0));\n    sideDis_0 = sideDis_0 - sideWidth_0;\n    vec2 sideOut_0 = normalize(sideEnd_0 - start);\n    float sideCut_0 = dot(uv - sideEnd_0, sideOut_0);\n    sideDis_0 = max(sideDis_0, sideCut_0);\n    \n    \n    float sideCurve_1;\n    vec2 sideEnd_1 = end + endDiff / 2.0;\n    vec2 sideDir_1 = dir + endDiff / 8.0;\n    float sideDis_1 = abs(sdBezier(uv, start, sideEnd_1, sideDir_1, sideCurve_1));\n    float sideWidth_1 = mix(widthStart, widthEnd, smoothstep(0.0, 1.0, sideCurve_1));\n    sideDis_1 = sideDis_1 - sideWidth_1;\n    vec2 sideOut_1 = normalize(sideEnd_1 - start);\n    float sideCut_1 = dot(uv - sideEnd_1, sideOut_1);\n    sideDis_1 = max(sideDis_1, sideCut_1);\n    \n    float sideDis = min(sideDis_0, sideDis_1);\n    float factor = smoothstep(pixelSize, 0.0, sideDis);\n    \n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(0.0), factor);\n    outputColor.a = clamp(outputColor.a + factor, 0.0, 1.0);\n    \n}\nvoid getBangTexture(vec2 uv, float pixelSize, float start, float range, float width, float len, float cut, inout vec4 outputColor)\n{\n    float upperEdge = start + range;\n    float downEdge = start;\n    \n    // 侧边界限\n    float factor = smoothstep(pixelSize, 0.0, uv.x  - start - mix(range * 1.08, range, linerstep(1.0, 1.0 - len, uv.y)));\n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(0.0), factor);\n    outputColor.a = clamp(outputColor.a + factor, 0.0, 1.0);\n    \n    // 开始边界\n    factor = smoothstep(pixelSize, 0.0, uv.x - start - mix(0.0, width, linerstep(1.0 - cut, 1.0 - len, uv.y)));\n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(1.0), factor);\n    outputColor.a = clamp(outputColor.a - factor, 0.0, 1.0);\n    \n    // 下边界\n    factor = smoothstep(pixelSize, 0.0, uv.y - 1.0 + len);\n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(1.0), factor);\n    outputColor.a = clamp(outputColor.a - factor, 0.0, 1.0);\n    \n    float cutSpace = (range - width) * 0.4;\n    vec2 cutPos = vec2(width + start, 1.0 - len);\n    float cutWidth = (range - width) * 0.05;\n    float cutThres = 0.8 * len;\n    float cutDis;\n    for(int i = ZERO; i < 2; i++)\n    {\n        cutPos.x += cutSpace;\n        cutDis = sdSegment(uv, cutPos, vec2(cutPos.x, 1.0));\n       \n        factor = smoothstep(pixelSize, 0.0, cutDis - mix(cutWidth, 0.0, linerstep(1.0 - len, 1.0 - cutThres, uv.y)));\n        outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(1.0), factor);\n        outputColor.a = clamp(outputColor.a - factor, 0.0, 1.0);\n    \n        cutSpace /= 1.08;\n        cutThres *= 1.08;\n        cutWidth /= 1.08;\n    }\n}\n\nvoid getHairTexture(vec2 uv, float pixelSize, float t, float ang, inout vec4 outputColor)\n{\n    #ifdef SHOWUV\n    outputColor = vec4(uv.x, 0.0, uv.y, 1.0);\n    return;\n    #endif\n    \n    outputColor = vec4(0.0);\n    float line = outlineStrength * pixelSize / 2.0;\n    \n    vec2 uv_m = vec2(1.0 - uv.x, uv.y);\n    t = sign(t) * pow(abs(t), 2.0);\n    \n    // 长条，先整出一个大致的形状\n    float stripCoord = mix(mod(uv.x + 0.5, 1.0), smoothstep(0.0, 1.0, mod(uv.x + 0.5, 1.0)), 0.4);\n    float stripIndex = round(stripCoord * stripCount);\n    float stripPos = stripIndex / stripCount;\n    float stripWidth = 0.5 / stripCount;\n    float factor;\n    float stripFactor = 0.17;\n    float stripStart = stripCount * stripFactor;\n    float stripEnd = stripCount - stripStart;\n    if(stripIndex <= stripStart || stripIndex >= stripEnd)\n    {\n        float stripDis = sdSegment(vec2(stripCoord, uv.y), vec2(stripPos, 0.0), vec2(stripPos, 1.0)) - mix(1.4 * stripWidth, 0.4 * stripWidth, 1.0 - uv.y);\n        float factor = smoothstep(pixelSize, 0.0, stripDis);\n        outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(0.0), factor);\n        outputColor.a = clamp(outputColor.a + factor, 0.0, 1.0);\n    }\n    \n    // 砍掉尾端\n    factor = smoothstep(pixelSize, 0.0, uv.y - mix(0.45, 0.19, smoothstep(0.5, 0.0, abs(uv.x - 0.5))));\n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(1.0), factor);\n    outputColor.a = clamp(outputColor.a - factor, 0.0, 1.0);\n    \n    // 刘海\n    vec4 bangColor = vec4(0.0);\n    float bangStart = 0.0;\n    float bangRange_0 = triLerp(0.22, 0.14, 0.22, -t);\n    float bangRange_1 = triLerp(0.22, 0.14, 0.22, t);\n    float bangCut = 0.06;\n    float bangWidth_0 = triLerp(0.02, 0.04, 0.08, -t);\n    float bangWidth_1 = triLerp(0.02, 0.04, 0.08, t);\n    getBangTexture(uv, pixelSize, bangStart, bangRange_0, bangWidth_0, 0.23, bangCut, bangColor);\n    getBangTexture(uv_m, pixelSize, bangStart, bangRange_1, bangWidth_1, 0.23, bangCut, bangColor);\n    \n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, bangColor.rgb, bangColor.a);\n    outputColor.a = clamp(outputColor.a + bangColor.a, 0.0, 1.0);\n    \n    // 盖子\n    \n    vec4 sideColor = vec4(0.0);\n    float sideWidthStart = 0.02;\n    float sideWidthEnd = 0.01;\n    vec2 sideStart_0 = vec2(bangStart + bangRange_0 + (sideWidthStart + sideWidthEnd) / 2.0, 1.0);\n    vec2 sideStart_1 = vec2(bangStart + bangRange_1 + (sideWidthStart + sideWidthEnd) / 2.0, 1.0);\n    float sideOffset_0 = triLerp(0.8, 1.0, 0.8, -t) * sideWidthStart;\n    float sideOffset_1 = triLerp(0.8, 1.0, 0.8, t) * sideWidthStart;\n    vec2 sideDir_0 = vec2(sideStart_0.x + 2.0 * sideOffset_0, 0.5);\n    vec2 sideDir_1 = vec2(sideStart_1.x + 2.0 * sideOffset_1, 0.5);\n    vec2 sideEnd_0 = vec2(sideStart_0.x + -4.0 * sideOffset_0, 0.3);\n    vec2 sideEnd_1 = vec2(sideStart_1.x + -4.0 * sideOffset_1, 0.3);\n    vec2 sideDiff = vec2(0.03, -0.03);\n    \n    if(uv.x < 0.5)\n    {\n        factor = linerstep(1.0 - sideStart_0.x, 0.69, uv_m.x);\n    }\n    else\n    {\n        factor = linerstep(1.0 - sideStart_1.x, 0.69, uv.x);\n    }\n    if(factor < 1.0 && factor > 0.0)\n    {\n        float coverStart = 0.25;\n        float coverEnd = 0.26;\n                            \n        factor *= factor;\n        factor = smoothstep(pixelSize, 0.0, (1.0 - mix(coverEnd, coverStart, factor)) - uv.y);\n        outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(0.0), factor);\n        outputColor.a = clamp(outputColor.a + factor, 0.0, 1.0);\n    }\n    \n    // 侧刘海\n    getSideTexture(uv, pixelSize, sideStart_0, sideDir_0, sideEnd_0, sideDiff, sideWidthStart, sideWidthEnd, sideColor);\n    getSideTexture(uv_m, pixelSize, sideStart_1, sideDir_1, sideEnd_1, sideDiff, sideWidthStart, sideWidthEnd, sideColor);\n    \n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, sideColor.rgb, sideColor.a);\n    outputColor.a = clamp(outputColor.a + sideColor.a, 0.0, 1.0);\n    \n    // 高光\n    float specHeight = (sin(13.0 * (2.0 * PI * uv.x + ang)) * 0.6 + sin(43.0 * (2.0 * PI * uv.x + ang))) * 0.006 + 0.86;\n    factor = smoothstep(0.0, -pixelSize, abs(uv.y - specHeight) - (sin(9.0 * (2.0 * PI * uv.x + ang)) + 0.1) * line * 3.0 * smoothstep(0.04, 0.08, uv.x)  * smoothstep(0.96, 0.92, uv.x));\n    outputColor.rgb = mix(outputColor.rgb * outputColor.a, vec3(1.0), factor);\n    \n    \n}\n\nfloat getPolar(vec3 dir, vec3 front, vec3 origin, vec3 point)\n{  \n    vec3 vector = point - origin;\n    vec3 dir_y = normalize(cross(front, dir));\n    vec3 dir_x = cross(dir_y, dir);\n    \n    return atan(dot(point, dir_y), dot(point, dir_x)) / PI * 0.5 + 0.5;\n}\n\nfloat getVert(vec3 dir, vec3 origin, vec3 point, float range, float offset)\n{\n    float proj = dot(dir, point - origin);\n    return (proj + offset) / range;\n}\n\nObjectInfo animeHair(vec3 p, mat4 sdf_transform, vec3 view, float pixelSize, bool castShadow, bool withMat)\n{\n    vec3 transPoint = (sdf_transform * vec4(p, 1.0)).xyz;\n    \n    ObjectInfo upper = DEFAULT_INFO;\n    vec3 upper_0 = vec3(0.0, 1.17, 0.04);\n    vec3 upper_1 = upper_0 + vec3(0.0, 0.0, 0.1) + vec3(hairDir_0 * 1.37, 0.0);\n    float upperRad = 0.78;\n    \n    upper.dis = sdRoundCone(transPoint, upper_0, upper_1, upperRad, 0.76);\n    \n    ObjectInfo lower = DEFAULT_INFO;\n    vec3 lower_0 = upper_1;\n    vec3 lower_1 = upper_1 + vec3(0.0, 0.0, 0.1) + vec3(hairDir_1 * 1.16, 0.0);\n    float lowerRad = 0.96;\n    lower.dis = sdRoundCone(transPoint, lower_0, lower_1, 0.76, lowerRad);\n    if(withMat)\n    {\n        vec3 upperVect = upper_0 - upper_1;\n        vec3 lowerVect = lower_0 - lower_1;\n        vec3 upperDir = normalize(upperVect);\n        vec3 lowerDir = normalize(lowerVect);\n        float upperLen = (upperVect.x + upperVect.y + upperVect.z) / (upperDir.x + upperDir.y + upperDir.z);\n        float lowerLen = (lowerVect.x + lowerVect.y + lowerVect.z) / (lowerDir.x + lowerDir.y + lowerDir.z);\n        float verRange = upperLen + lowerLen + upperRad + lowerRad;\n        upper.material.t0 = getPolar(upperDir, vec3(0.0, 0.0, -1.0), upper_1, transPoint);\n        lower.material.t0 = getPolar(lowerDir, vec3(0.0, 0.0, -1.0), lower_1, transPoint);\n        \n        upper.material.t1 = getVert(upperDir, upper_1, transPoint, verRange, lowerLen + lowerRad);\n        lower.material.t1 = getVert(lowerDir, lower_1 - lowerRad * lowerDir, transPoint, verRange, 0.0);\n    }\n    \n    ObjectInfo info = objectSmoothMin(upper, lower, 0.1);\n    \n    if(withMat)\n    {\n        if(lower.dis - 0.8 > upper.dis || lower.dis - 0.1 < upper.dis && abs(upper.material.t0 - lower.material.t0) > 0.2) info.material.t0 = objectSmoothMinWithoutBlend(upper, lower, 0.1).material.t0;\n        vec3 viewDir = (sdf_transform * vec4(-view, 0.0)).xyz;\n        vec3 normal = viewDir;\n        normal.y = 0.0;\n        normal = normalize(normal);\n        \n        float verRange = upper_0.y + 0.78 - lower_1.y + 0.96;\n        \n        vec2 uv = vec2(info.material.t0, info.material.t1);\n        getHairTexture(uv, pixelSize / verRange, normal.x, atan(normal.z, normal.x), info.material.color0);\n    }\n    \n    return info;\n}\n\nObjectInfo sceneHairMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat)\n{  \n    ObjectInfo info = animeHair(point, transform_Head, view, pixelSize, castShadow, withMat);\n\n    return info;\n}\n\nvec4 marchHair(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float direction, float pixelSize, inout vec3 pos, inout float len)\n{\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    \n    float stepDis;\n    \n    int stepCount = 0;\n    \n    float curPixelSize;\n    \n    float theta = dot(ray, front);\n    \n\n    while(len < MAX_DISTANCE && len >= 0.0 && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n\n        curSolidInfo = sceneHairMap(curPos, front, curPixelSize, false, false);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < curPixelSize)\n        {\n            break;\n        }\n        \n\n        stepDis = dis * 0.9 * direction;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    pixelSize = curPixelSize;\n    vec4 outputColor = getHairAtPos(pos, ray, front, len, screenCoord, curPixelSize, dis);\n    return outputColor;\n}\n\nMaterial sceneHairMaterial(vec3 point, vec3 view, float pixelSize, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE || len < 0.0) {\n        Material outMat;\n        outMat.color0 = vec4(0.0, 0.0, 0.0, 0.0);\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    return sceneHairMap(point, view, pixelSize, false, true).material;\n}\n\nvec4 getHairAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis)\n{\n    Material material = sceneHairMaterial(pos, front, pixelSize, len, screenCoord);\n    vec4 outlineColor = vec4(0.0);\n    \n    vec4 solidColor = vec4(0.0);\n    if(material.index == 0) solidColor = material.color0;\n    else\n    {\n        solidColor = material.color0;\n    }\n    \n    return mix(solidColor, outlineColor, outlineColor.a);\n}\n\nvoid update()\n{\n    outlineStrength = max(2.0, outlineStrength * pow(iResolution.x / 800.0, 0.5));\n    float angle;\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    \n    // 根\n    angle = -sin(iTime * 0.4) * PI / 8.0f;\n    rotationLocal_Root = quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Root);\n\n    float frameTime = floor(iTime * FRAME_RATE) / FRAME_RATE;\n    float blinkFactor;\n    float blinkTimeline = 2.55 * frameTime;\n    float blinkTime = floor(blinkTimeline);\n    if(hash11(blinkTime) > BLINK_THRESHOLD) blinkFactor = -1.0;\n    else blinkFactor = -cos(fract(blinkTimeline) * 2.0 * PI);\n    \n    blinkFactor = 0.5 - blinkFactor * 0.5;\n    \n    defaultFacialInfo.rightUpLidPos = blinkFactor * defaultFacialInfo.rightUpLidPos;\n    defaultFacialInfo.rightDownLidPos = blinkFactor * defaultFacialInfo.rightDownLidPos;\n    defaultFacialInfo.leftUpLidPos = defaultFacialInfo.rightUpLidPos;\n    defaultFacialInfo.leftDownLidPos = defaultFacialInfo.rightDownLidPos;\n    \n    vec2 browOffset = mix(vec2(0.0, -0.2), vec2(0.0, 0.0), blinkFactor);\n    defaultFacialInfo.leftBrowStart += browOffset;\n    defaultFacialInfo.leftBrowEnd += browOffset;\n    defaultFacialInfo.leftBrowDir += browOffset;\n    \n    defaultFacialInfo.rightBrowStart += browOffset;\n    defaultFacialInfo.rightBrowEnd += browOffset;\n    defaultFacialInfo.rightBrowDir += browOffset;\n    \n    transform_Root = createModelInverseMat(quaternionMul(load(POINTER_ROT), rotationLocal_Root), positionLocal_Root);\n    \n    // 脖子\n    transform_Neck = createModelInverseMat(rotationLocal_Neck, positionLocal_Neck) * transform_Root;\n    \n    // 头\n    transform_Head = createModelInverseMat(rotationLocal_Head, positionLocal_Head) * transform_Neck;\n    \n    // 耳朵\n    transform_Ear = createModelInverseMat(rotationLocal_Ear, positionLocal_Ear);\n    \n    // 头发\n    angle = PI / 2.0 * 3.0 - (sin(frameTime * 3.0) * 0.5 + 0.5) * 0.04;\n    hairDir_1 = vec2(cos(angle), sin(angle));\n    \n    #ifdef EYETEST\n    // 眼睛测试\n    defaultFacialInfo.leftEyeBallPos = vec2(cos(iTime), sin(iTime));\n    defaultFacialInfo.leftUpLidPos = cos(iTime) * 0.5 + 0.5;\n    defaultFacialInfo.leftDownLidPos = cos(iTime) * 0.5 + 0.5;\n    defaultFacialInfo.leftEyeBallScale = mix(1.0, 0.6, clamp(cos(iTime), 0.0, 1.0));\n    \n    float browUp = (cos(4.0 * iTime) + 1.0) / 2.0;\n    defaultFacialInfo.leftBrowStart.y += browUp * browUp * 0.5;\n    defaultFacialInfo.leftBrowEnd.y += browUp * browUp * 0.5;\n    defaultFacialInfo.leftBrowDir.y += browUp * 0.5;\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    #ifdef MODELING\n    \n    float angle = -PI / 2.0;\n    // angle = PI / 4.0;\n    if(uv.x > 0.0) rotationLocal_Root = quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Root);\n    \n    #endif\n    update();\n    \n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray;\n    #ifdef MODELING\n    if(abs(uv.x) < 1.0 / iResolution.x)\n    {\n        fragColor = MIN_COLOR;\n        return;\n    }\n    if(uv.x < 0.0) ray = normalize(vec3(uv + vec2(0.25, 0.0), 0.5 / tanFov));\n    else ray = normalize(vec3(uv - vec2(0.25, 0.0), 0.5 / tanFov));\n    #else\n    ray = normalize(vec3(uv, 0.5 / tanFov));\n    #endif\n    \n    if(abs(uv.y) > 0.3)\n    {\n        fragColor = MIN_COLOR;\n        return;\n    }\n    \n    // 平面距离为1时，每个像素对应的大小\n    float pixelSize = 2.0 * tanFov / iResolution.x;\n    vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n    ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n    \n    vec3 pos;\n    float len;\n    \n    vec4 baseColor = vec4(march(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, pixelSize, pos, len), 1.0);\n    vec4 color = baseColor;\n    \n    #ifndef NOHAIR\n    // len作为深度使用，单独march头发\n    vec4 hairColor;\n\n    // 反面，能想出这玩意真是人才\n    float hairLen = HAIR_FAR;\n    hairColor = marchHair(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, -1.0, pixelSize, pos, hairLen);\n    if(hairLen > 0.0 && hairLen <= len) color = mix(color, hairColor, hairColor.a);\n    \n    // 正面\n    hairLen = 0.0;\n    hairColor = marchHair(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, 1.0, pixelSize, pos, hairLen);\n    if(hairLen > 0.0 && hairLen <= len) color = mix(color, hairColor, hairColor.a);\n    #endif\n    \n    color = mix(MIN_COLOR, MAX_COLOR, color);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define FAI 1.618033988749\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n# define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n# define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n# define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n# define QUA_ZERO vec4(0.0, 0.0, 0.0, 1.0)\n# define DEFAULT_INFO ObjectInfo(65535.0, Material( vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0), vec4(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 1));\n# define DEFAULT_MAT mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -8.0, 1.0)\n# define ZERO (min(iFrame,0))\n\n// Structure\nstruct Material\n{\n    vec4 color0;\n    vec4 color1;\n    vec4 color2;\n    vec3 vect0;\n    vec3 vect1;\n    vec3 vect2;\n    // #0: smoothness, fresnelPower, fresnelScale\n\tfloat t0;\n    float t1;\n    float t2;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\n// Util\nfloat linerstep(float start, float end, float t)\n{\n    return (t - start) / (end - start);\n}\nfloat smoothone(float x)\n{\n    return smoothstep(0.0, 1.0, x * 0.5 + 0.5) * 2.0 - 1.0;\n}\n\nfloat smoothmid(float x, float mid)\n{\n    return 1.0 - (x < mid ? pow((mid - x) / mid, 2.0) : pow((mid - x) / (1.0 - mid), 2.0));\n}\n\nfloat quaLerp(float right, float up, float left, float down, float center, vec2 t)\n{\n    float factor = length(t);\n    if(factor == 0.0) return center;\n    t = normalize(t) * 0.5 + 0.5;\n    return mix(center, mix(left, right, t.x) + mix(down, up, t.y), factor);\n}\n\nvec2 quaLerp(vec2 right, vec2 up, vec2 left, vec2 down, vec2 center, vec2 t)\n{\n    float factor = length(t);\n    if(factor == 0.0) return center;\n    t = normalize(t) * 0.5 + 0.5;\n    return mix(center, mix(left, right, t.x) + mix(down, up, t.y), factor);\n}\n\nfloat triLerp(float x, float y, float z, float t)\n{\n    if(t < 0.0) return mix(y, x, -t);\n    else return mix(y, z, t);\n}\n\nfloat triLerp(float x, float y, float z, float t, float smoo)\n{\n    t = mix(t, smoothone(t), smoo);\n    return triLerp(x, y, z, t);\n}\n\nvec2 triLerp(vec2 x, vec2 y, vec2 z, float t)\n{\n    return vec2(triLerp(x.x, y.x, z.x, t), triLerp(x.y, y.y, z.y, t));\n}\n\nvec2 triLerp(vec2 x, vec2 y, vec2 z, float t, float smoo)\n{\n    t = mix(t, smoothone(t), smoo);\n    return vec2(triLerp(x.x, y.x, z.x, t), triLerp(x.y, y.y, z.y, t));\n}\n\nvec3 triLerp(vec3 x, vec3 y, vec3 z, float t)\n{\n    return vec3(triLerp(x.x, y.x, z.x, t), triLerp(x.y, y.y, z.y, t), triLerp(x.z, y.z, z.z, t));\n}\n\nvec3 triLerp(vec3 x, vec3 y, vec3 z, float t, float smoo)\n{\n    t = mix(t, smoothone(t), smoo);\n    return vec3(triLerp(x.x, y.x, z.x, t), triLerp(x.y, y.y, z.y, t), triLerp(x.z, y.z, z.z, t));\n}\n\nvec3 applyTransform(vec3 origin, vec3 trans_x, vec3 trans_y, vec3 trans_z)\n{\n    return origin.x * trans_x + origin.y * trans_y + origin.z * trans_z;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = floor(curLevel + mix(offset, 0.0, curOffset));\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    curLevel = curLevel / level;\n    \n    float ddx = dFdx(curLevel);\n    float ddy = dFdy(curLevel);\n    float smoo = clamp(length(vec2(ddx, ddy)) * 0.25, 0.0, 1.0);\n    \n    return mix(curLevel, value, smoo);\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n           vec3(1.0,0.1,0.0)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nmat4 createModelMat(vec4 q, vec3 offset)\n{\n    float qx2 = q.x * q.x;\n    float qy2 = q.y * q.y;\n    float qz2 = q.z * q.z;\n\n    float qxqy = q.x * q.y;\n    float qxqz = q.x * q.z;\n    float qxqw = q.x * q.w;\n    float qyqz = q.y * q.z;\n    float qyqw = q.y * q.w;\n    float qzqw = q.z * q.w;\n    \n    return mat4(1.0 - 2.0 * (qy2 + qz2), 2.0 * (qxqy - qzqw),     2.0 * (qxqz + qyqw),     0.0,\n                2.0 * (qxqy + qzqw),     1.0 - 2.0 * (qx2 + qz2), 2.0 * (qyqz - qxqw),     0.0,\n                2.0 * (qxqz - qyqw),     2.0 * (qyqz + qxqw),     1.0 - 2.0 * (qx2 + qy2), 0.0,\n                offset.x,                offset.y,                offset.z,                1.0);\n}\n\nmat4 createModelInverseMat(vec4 q, vec3 offset)\n{\n    return createModelMat(quaternionInverse(q), vec3(0.0)) * mat4(1.0,       0.0,       0.0,       0.0,\n                0.0,       1.0,       0.0,       0.0,\n                0.0,       0.0,       1.0,       0.0,\n                -offset.x, -offset.y, -offset.z, 1.0);\n}\n\nfloat onion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat ssub(float a, float b, float k)\n{\n    float h = clamp( 0.5 - 0.5 * (b + a) / k, 0.0, 1.0 );\n    return mix(a, -b, h) + k * h * (1.0 - h);\n}\n\nfloat xor( float a, float b )\n{\n    return max( min(a,b), -max(a,b) );\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(float p, float freq, float rep, float offset)\n{\n    p += offset / freq;\n    p *= freq;\n    \n\tvec2 i = vec2(floor(p)) + vec2(0.0, 1.0);\n    i = mod(i, vec2(rep * freq));\n\tfloat f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i.x), hash11(i.y), u);\n}\n\nfloat perlin(vec2 p, vec2 freq, vec2 rep, vec2 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec4 gridSet = floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 dirSet = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, (rep * freq).xyxy);\n    \n    vec2 gridLevel_00 = hash22(gridSet.xy) * 2.0 - 1.0;\n    vec2 gridLevel_01 = hash22(gridSet.xw) * 2.0 - 1.0;\n    vec2 gridLevel_10 = hash22(gridSet.zy) * 2.0 - 1.0;\n    vec2 gridLevel_11 = hash22(gridSet.zw) * 2.0 - 1.0;\n    \n    float product_00 = dot(gridLevel_00, dirSet.xy);\n    float product_01 = dot(gridLevel_01, dirSet.xw);\n    float product_10 = dot(gridLevel_10, dirSet.zy);\n    float product_11 = dot(gridLevel_11, dirSet.zw);\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    \n    // return dirSet.x;\n    return mix(mix(product_00, product_10, t_0), mix(product_01, product_11, t_0), t_1);\n}\n\nfloat voronoi(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq);\n            vec2 r = vec2(b) - f + hash22(pos);\n            res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return pow(1.0 / res, 0.0625);\n}\n\nfloat voronoiAndHide(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias, vec2 factor, float posibility) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq) + bias;\n            vec2 r = vec2(b) - f + hash22(pos) * factor;\n            if(hash12(pos + vec2(123.0, 456.0)) < posibility) res += 0.0;\n            else res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return clamp(pow(1.0 / res, 0.0625), 0.0, 1.0);\n}\n\nfloat fbm(vec2 x, float H, vec2 freq, vec2 rep, vec2 offset, int numOctaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < numOctaves; i++ )\n    {\n        t += a * perlin(f * x, freq, f * rep, offset / freq);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis < b.dis ) return a;\n    else return b;\n}\n\nMaterial objectMix(Material a, Material b, float k)\n{\n    Material outMat = a;\n    outMat.color0 = mix(a.color0, b.color0, k);\n    outMat.color1 = mix(a.color1, b.color1, k);\n    outMat.color2 = mix(a.color2, b.color2, k);\n    outMat.vect0 = mix(a.vect0, b.vect0, k);\n    outMat.vect1 = mix(a.vect1, b.vect1, k);\n    outMat.vect2 = mix(a.vect2, b.vect2, k);\n\toutMat.t0 = mix(a.t0, b.t0, k);\n    outMat.t1 = mix(a.t1, b.t1, k);\n    outMat.t2 = mix(a.t2, b.t2, k);\n    \n    return outMat;\n}\n\nObjectInfo objectSmoothMin(ObjectInfo a, ObjectInfo b, float k)\n{\n    float h = max(k - abs(a.dis - b.dis), 0.0);\n    ObjectInfo outInfo = a;\n    float rate;\n    if(a.dis < b.dis) rate = a.dis / b.dis * 0.5;\n    else rate = 1.0 - b.dis / a.dis * 0.5;\n    outInfo.material = objectMix(a.material, b.material, rate);\n    outInfo.dis = min(a.dis, b.dis) - h * h * 0.25 / k;\n    \n    return outInfo;\n}\n\nObjectInfo objectSmoothMinWithoutBlend(ObjectInfo a, ObjectInfo b, float k)\n{\n    float h = max(k - abs(a.dis - b.dis), 0.0);\n    ObjectInfo outInfo = a;\n    if(a.dis < b.dis) outInfo.material = a.material;\n    else outInfo.material = b.material;\n    \n    outInfo.dis = min(a.dis, b.dis) - h * h * 0.25 / k;\n    return outInfo;\n}\n\nfloat opExtrusion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\n// 2D Shape\nfloat sdCircle( vec2 p, vec2 sdf_pos, float r )\n{\n    return length(p - sdf_pos) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 C, in vec2 B, out float it)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n        \n        it = t;\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; it = t.x;} else {res=dy; sgn=sy; it = t.y;}\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nvec2 bezier(vec2 start, vec2 end, vec2 dir, float t)\n{\n    float oneMinus = 1.0 - t;\n    return oneMinus * oneMinus * start + 2.0 * t * oneMinus * dir + t * t * end;\n}\n\nvec2 bezierTangent(vec2 start, vec2 end, vec2 dir, float t)\n{\n    float oneMinus = 1.0 - t;\n    return 2.0 * oneMinus * (dir - start) + 2.0 * t * (end - dir);\n}\n\nfloat sdEllipse(vec2 p, vec2 sdf_pos, vec2 ab)\n{\n    p = p - sdf_pos;\n    \n    p = abs(p);\n    if (abs(ab.x - ab.y) < 0.001) return length(p) - ab.x;\n    if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdOrientedVesica(vec2 p, vec2 a, vec2 b, float w)\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n// 3D Shape\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - sdf_rad;\n}\n\nfloat sdPlane( vec3 p, vec3 sdf_pos, vec3 sdf_normal)\n{\n    return dot(p - sdf_pos, sdf_normal);\n}\n\nfloat sdRoundCone( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad_0, float sdf_rad_1 )\n{\n    vec3  ba = sdf_pos_1 - sdf_pos_0;\n    float l2 = dot(ba,ba);\n    float rr = sdf_rad_0 - sdf_rad_1;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - sdf_pos_0;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - sdf_rad_1;\n    if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - sdf_rad_0;\n                          return (sqrt(x2*a2*il2)+y*rr)*il2 - sdf_rad_0;\n}\n\nfloat sdSphere(vec3 p, vec3 sdf_pos, float sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    return distance(transPoint, vec3(0)) - sdf_rad;\n}\n\nfloat sdVesicaSegment(vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad_0)\n{\n    vec3  c = (sdf_pos_0 + sdf_pos_1) * 0.5;\n    float l = length(sdf_pos_1 - sdf_pos_0);\n    vec3  v = (sdf_pos_1 - sdf_pos_0)/l;\n    float y = dot(p - c, v);\n    vec2  q = vec2(length(p - c - y * v),abs(y));\n    \n    float r = 0.5 * l;\n    float d = 0.5 * (r * r - sdf_rad_0 * sdf_rad_0 ) / sdf_rad_0;\n    vec3  h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + sdf_rad_0);\n \n    return length(q - h.xy) - h.z;\n}\n\n\nfloat udTriangleSqr( vec3 p, vec3 a, vec3 b, vec3 c, vec3 ba, vec3 cb, vec3 ac, vec3 pa, vec3 pb, vec3 pc, out vec3 nor)\n{\n    nor = cross( ba, ac );\n\n    return (sign(dot(cross(ba,nor),pa)) +\n          sign(dot(cross(cb,nor),pb)) +\n          sign(dot(cross(ac,nor),pc))<2.0)\n          ?\n          min( min(\n          dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n          dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n          dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n          :\n          dot(nor,pa)*dot(nor,pa)/dot2(nor);\n}\n\nfloat sdPyramid( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n    vec3 ba = b - a;\n    vec3 cb = c - b;\n    vec3 dc = d - c;\n    vec3 ad = a - d;\n    vec3 ea = e - a;\n    vec3 eb = e - b;\n    vec3 ec = e - c;\n    vec3 ed = e - d;\n  \n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 pc = p - c;\n    vec3 pd = p - d;\n    vec3 pe = p - e;\n  \n    vec3 nor0 = cross( ba, ad );\n  \n    float sd0 = (sign(dot(cross(ba,nor0),pa)) +\n                 sign(dot(cross(cb,nor0),pb)) +\n                 sign(dot(cross(dc,nor0),pc)) +\n                 sign(dot(cross(ad,nor0),pd))<3.0)\n                 ?\n                 min( min( min(\n                 dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n                 dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n                 dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n                 dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n                 :\n                 dot(nor0,pa)*dot(nor0,pa)/dot2(nor0);\n                 \n    vec3 nor1;             \n    float sd1 = udTriangleSqr(p, e, a, d, -ea, -ad, ed, pe, pa, pd, nor1);\n    \n    vec3 nor2;\n    float sd2 = udTriangleSqr(p, e, b, a, -eb, -ba, ea, pe, pb, pa, nor2);\n    \n    vec3 nor3;\n    float sd3 = udTriangleSqr(p, e, c, b, -ec, -cb, eb, pe, pc, pb, nor3);\n    \n    vec3 nor4;\n    float sd4 = udTriangleSqr(p, e, d, c, -ed, -dc, ec, pe, pd, pc, nor3);\n               \n    return sqrt(min(min(min(min(sd0, sd1), sd2), sd3), sd4));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    ivec2 ipx = ivec2(fragCoord);\n    const ivec2 MEMORY_BOUNDARY = ivec2(1, 6);\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x);\n        time = 0.0;\n        curRot = quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0)));\n\n    }\n    else\n    {\n        press = 0.0;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(time / RECOVER_TIME, 0.0, 1.0));\n        time += iTimeDelta;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n}","name":"Buffer B","description":"","type":"buffer"}]}