{"ver":"0.1","info":{"id":"MlSBDt","date":"1617234623","viewed":15365,"name":"RME4 - Crater","username":"patu","description":"crater\n#makeYourShadersPublic","likes":160,"published":1,"flags":0,"usePreview":0,"tags":["crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define getNormal getNormalHex\n\n//#define raymarch vanillaRayMarch \n#define raymarch enchancedRayMarcher \n\n#define FAR 570.\n#define INFINITY 1e32\n\n#define FOV 110.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 space;\n    vec3 color;\n};\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\ngeometry scene(vec3 p) {\n    geometry plane;\n\n    float localNoise = fbm(p / 10.) * 2.;;\n    p.y -= localNoise * .2;\n    plane.dist = p.y;\n    p.y *= 3.5;\n\n    plane.dist = smin(plane.dist, length(p) - 25., .15 + localNoise * .2);\n    plane.dist = max(plane.dist, -length(p) + 29.  + localNoise);\n    plane.materialIndex = 4.;\n    plane.space = p;\n    plane.color = vec3(1., .2, .0);\n    plane.diffuse = 0.;\n    plane.specular = 22.1;\n    \n    return plane;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\n\ngeometry enchancedRayMarcher(vec3 o, vec3 d, int maxI) {\n    geometry mp;\n    \n    float t_min = 0.001;\n    float tb = (2.1-o.y)/d.y;\n    \n    if( tb<0.0 ) { mp.dist = INFINITY; return mp; }\n    \n    t_min = tb;\n    \n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = //tan(radians (FOV) / 2.0) \n        1. /350.;\n    float functionSign = scene(o).dist < 0. ? -1. : +1.;\n    \n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = scene(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        \tstepLength = signedRadius * omega * .8;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\ngeometry vanillaRayMarch(vec3 o, vec3 d, int maxI) {\n    geometry mp;\n    \n    float l = -.1;\n    \n    for (int i = 0; i < 30; i++) {\n        if (abs(l) < 0.1 || l > 130.) {\n            break;\n        }\n        \n        mp = scene(o + d * l);\n        l += mp.dist;\n    }\n    \n    mp.dist = l;\n    return mp;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 125;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n\n    float shade = 1.;\n    float dist = 1.0;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n    \n    float tb = (8.0-ro.y)/normalize(rd).y; \n    if( tb>0.0 ) end = min( end, tb );\n    \n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = scene(ro + rd * dist).dist;\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.3), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=scene(pos).dist;\n\treturn normalize(\n        vec3(\n            scene(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                scene(pos+vec3(0,EPSILON,0)).dist-d,\n                scene(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = scene(spos).dist;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \tfloat sunSize = 1.;\n   \tfloat sunAmount = max(dot(rd, lightDir), .1);\n   \tfloat v = pow(1.2 - max(rd.y, .5), 1.1);\n   \tvec3 sky = mix(fromRGB(255,200,100), vec3(1.1, 1.2, 1.3) / 10., v);\n   \tsky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 1e4)* sunSize,1233. * sunSize);\n\n   \treturn clamp(sky, 0.0, 1.0);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\tfloat atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\tfloat diff = max(dot(sn, ld), obj.diffuse);\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\tvec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\tsceneCol += (objCol * (diff + .15) * spec * 0.1);// * atten;\n    return sceneCol;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv.y *= 1.2;\n    vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = iTime;\n    float \n        sk = sin(-t2 * .1) * 48.0, \n        ck = cos(-t2 * .1) * 48.0,\n        \n        mat = 0.;\n    \n    light = vec3(0., 7., 100.);        \n    lightDir = light;\n    \n    \n    vec3 \n        vuv = vec3(0., 1., 0. ),\n    \tro = vec3(ck, 18., sk);\n    \n    vec3\n        vrp =  vec3(0., 0., 0.),\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n\t\n    geometry tr = raymarch(ro, rd, 0);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 8.2);\n    \n    float \n        ao = getAO(hit, sn, 10.2);\n\n    noise = fbm(mod(hit + 20. + hit.yzx* 4., 40.) / 1.);\n\tvec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 4.5 / FAR));\n    } else {\n        sceneColor = sky;\n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, 1./vec4(1.2));\n\n}\n","name":"Image","description":"","type":"image"}]}