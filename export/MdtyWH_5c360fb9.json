{"ver":"0.1","info":{"id":"MdtyWH","date":"1518751862","viewed":403,"name":"simple level meter","username":"scztt","description":"A simple level meter implementation. Would be better if shadertoy provided peak information as part of it's audio buffer, but we can get enough information in a semi-efficient way to end up with a reasonable result.","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["sound","soundcloud","levelmeter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tfragColor = texture(iChannel0,uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sSSWh","filepath":"https://soundcloud.com/planet-uterus/traumprinz-b2b-dj-metatron-live-at-planet-uterus","previewfilepath":"https://soundcloud.com/planet-uterus/traumprinz-b2b-dj-metatron-live-at-planet-uterus","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float falloff = 0.2;\n    const float stepSize = 3.0;\n    const float stepSpacing = 1.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 last = texture(iChannel1, vec2(0.0, 0.0));\n    //vec4 last = te\n    \n    // Time varying pixel color\n    vec4 col;\n    col[3] = 1.0;\n    float peak = 0.0;\n    for (int i = 0; i < 30; ++i) {\n        // from audio signal\n        float val = texture(iChannel0, vec2(i, 1.0)).r;\n        val = abs(val - 0.5);\n        peak = max(peak, val);\n\n        // from fft\n        // float val = texture(iChannel0, vec2(i * 2 + 10, 0.0)).r / 5.0;\n        // peak = peak + (val / 30.0);\n    }\n\n    if (peak < last[0]) {\n        peak = (peak * falloff) + (last[0] * (1.0 - falloff));\n    }\n    peak = peak - mod(peak, stepSize / iResolution.y);\n\n    float val = (uv.y < peak) ? 1.0 : 0.1; \n\n    if (mod(fragCoord.y, stepSize) < stepSpacing) val = 0.0;\n\n    if (fragCoord.x < 4.0 && fragCoord.y < 4.0) {\n    \tcol[0] = peak;\n    \tcol[1] = peak;\n\t    col[2] = peak;\n    } else {\n        col[0] = val * 0.3;\n    \tcol[1] = val * 0.8;\n\t    col[2] = val * 0.3;\n    }\n    // Output to screen\n    fragColor = col;\n}","name":"Buf A","description":"","type":"buffer"}]}