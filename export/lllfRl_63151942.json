{"ver":"0.1","info":{"id":"lllfRl","date":"1513094355","viewed":557,"name":"Santa Claus factory","username":"iapafoto","description":"My late contribution to truchet shader set  :)\n","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["truchetautomataflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Sebastien Durand - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Inspired by (and started from) Shane shader\n// [2D Pipe Pattern] https://www.shadertoy.com/view/XlXBzl\n\n#define PI 3.141592\n#define PI_2 1.5708\n\nvec4 _CX[12] = vec4[12](\n    vec4( 1, 1,-1,-1),vec4(-1, 1, 1,-1),vec4(-1,-1, 1, 0),vec4(-1, 1,-1, 0),\n    vec4(-1, 1,-1, 0),vec4( 1, 1, 1, 2),vec4(-1,-1, 1, 0),vec4(-1, 1, 1,-1),    \n    vec4(-1,1,-PI_2,PI),vec4(1,1,-PI_2,0),vec4(-1,-1,PI_2,PI),vec4(1,-1,PI_2,0));\n\n\nfloat hash(float p){\n    return dot(vec2(p,p+1.), vec2(1.361, 113.947));\n} \n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec2 p, vec2 b ) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// By Shane\nvec2 diag(vec2 v) {\n    return clamp(1.3+sin(v), 0., 1.)*.5+ .5;     \n}\n\nvec4 state(in vec2 ip ) {\n    return texelFetch( iChannel0, ivec2(ip), 0 );\n}\n\n// centre x,y + ang1, ang2\nvec4 getPos(int sq, float t, out vec4 cx) {\n     cx = _CX[sq];\n     if (sq < 8) {\n        cx.z = (cx.w+cx.z*t)*PI_2;\n        cx.w = sq == 4 || sq == 7 ? -cx.z+PI_2 : \n               sq == 5 || sq == 6 ? -cx.z-PI_2 : cx.z+PI;\n     \treturn .5*vec4( cx.x+cos(cx.z), cx.y+sin(cx.z), \n                -cx.x+cos(cx.w),-cx.y+sin(cx.w));\n     }\n  \t return (.5-t)*vec4(cx.x,0,0,cx.y);\n}\n\n\nvoid fill(inout vec3 col, vec3 c, float d) {\n\tcol = mix(c, col, smoothstep(0.,.01, d));\n}\n\nvoid draw(inout vec3 col, vec3 c, float d, float ep) {\n\tcol = mix(c, col, smoothstep(0.,ep, abs(d)));\n}\n\nvoid drawObj(inout vec3 col, vec2 p, float a, float st) { \n    const float rW = .025;\n    float r, d, d2, dsh;    \n    \n    mat2 mr = rot(a+2.*PI*fract(hash(st)));\n    vec2 sz, psh = (p-vec2(.01,-.04))*mr;\n    \n    p *= mr;\n    \n    if (fract(hash(st+3.))<.5) {\n        sz = .03+5.*mod(vec2(hash(st), hash(st+1.)), vec2(rW,rW));\n    \td = sdBox(p, sz);\n    \tdsh = sdBox(psh, sz);\n        d2 = min(sdBox(p, vec2(sz.x-.01, .02)), sdBox(p, vec2(.02,sz.y-.01)));\n    } else {\n        r = .06+mod(hash(st),rW);\n    \td = length(p)-r;\n    \tdsh = length(psh)-r;\n        d2 = length(p)-r*.6;\n    }\n    \n    // Palette\n    vec3 c = .5*cos( 2.*PI*st + vec3(0,1,2) )+.5; \n    // Draw\n    fill(col, .5*col, dsh);\n    fill(col, c, d);\n    fill(col, c*2., d2);\n    draw(col, c*.5, d2, .02);\n    draw(col, vec3(0), d, .02);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    const float lW = .125; // Pipe width. \n    \n    float d, d1, d2,\n          time = .8*iTime,\n    \t  t = fract(time),\n    // Scale. Analogous to the field of view.\n    \t  sc = 5.7 + 1.5*cos(2.5+.15*time);\n\n\tvec2 dg, pg2,\n         uv = (fragCoord - iResolution.xy*.5)/clamp(iResolution.y, 350., 600.),\n         // Sizing the scene and moving it + Slowly rotate canvas  \n         p = 100. + uv*sc*rot(.03*time) + .2*vec2(sin(time*3.14159/16.)*2., 1.*time),\n         ip = floor(p), pg = p - ip - .5;    \n    vec4 st = state(ip);\n    int sq = int(round(st.z));\n\n    vec3 col = vec3(.35);\n\n    //  if (type == 2) col = vec3(0,0,1);\n    \n    // Inverse path anim\n    if (st.w < 0.) {\n        d = min(length(pg)-.18,abs(length(pg)-.35)-.03);\n    \tcol = mix(vec3(1,0,0), col, mix(smoothstep(0.0,.02,d),1.,min(1.,1.5*t)));\n    }\n    // Ground\n    dg = diag((pg.y + vec2(pg.x,-pg.x))*PI*20.);     \n    col *= mix(.5, 1., dg.x*dg.y);\n    \n    vec4 cc, cx, po = getPos(sq, t, cx);\n            \n    if (sq < 8) {\n        // Two arcs  || (quarter pipe)\n        cc = _CX[sq];\n        // Transformation effect\n        pg2 = (st.w < 0. && length(pg)<.45) ? pg*rot(PI_2*(1.+smoothstep(.0,.8,t))) : pg; \n        // Floor    \n        vec2 v1 = pg2 - .5*cc.xy, \n             v2 = pg2 + .5*cc.xy;       \n        d1 = length(v1) - .5;\n        d2 = length(v2) - .5;    \n        // Lines on floor\n        dg = diag((1.5*t+cc.z*vec2(atan(-v1.y, v1.x), atan(-v2.y, v2.x)*(sq>3?-1.:1.)))*PI*10.5);\n\n    } else {\n        // Vertical and horizontal pipes.\n        d1 = pg.y;\n        d2 = pg.x;\n        dg = diag((po.xw/(.5/t-1.)+pg)*PI*20.);\n    }\n    d1 = abs(d1) - lW;\n    d2 = abs(d2) - lW;\n    \n    // Draw square scene\n    draw(col, col*.3+vec3(.1), d1, .07);\n    fill(col, vec3(.7)*mix(.5, 1., dg.x), d1);\n    draw(col, vec3(.1), d1, .02);\n    drawObj(col, (pg-po.xy),cx.z, st.x);\n    draw(col, col*.3+vec3(.1), d2, .07);\n    fill(col, vec3(.7)*mix(.5, 1., dg.y), d2);\n    draw(col, vec3(.1), d2, .02);\n    drawObj(col, (pg-po.zw),cx.w, st.y); \n    if (st.w < 0.) drawObj(col, (pg-po.xy),cx.z, st.x);         \n    // Inversion circle\n    if (st.w < 0.)\n\t    draw(col, vec3(.2), length(pg)-.46, .02);\n\n    // Draw closest neigbourg object\n    ip += abs(pg.x) > abs(pg.y) ? vec2(sign(pg.x),0.) : vec2(0., sign(pg.y));\n    pg = p - ip - .5;\n    st = state(ip), \n    po = getPos(int(round(st.z)), t, cx);\n    \n    drawObj(col, pg-po.xy, cx.z, st.x); \n    drawObj(col, pg-po.zw, cx.w, st.y); \n    \n    // Rough gamma correction.\n    fragColor = vec4(pow(col,vec3(.7)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 S = vec3(1,0,-1);\nvec4[12] _PREV = vec4[12](\n    vec4(1,0,-1,0), vec4(-1,0, 1,0), vec4(0,-1,0,1), vec4( 0,1,0,-1),\n    vec4(0,1,1,0),  vec4( 0,1,-1,0), vec4(0,-1,1,0), vec4(-1,0,0,-1),\n    vec4(-1,0,0,1), vec4( 1,0,0,1), vec4(-1,0,0,-1), vec4( 1,0,0,-1)    \n);\n\nvec4 state(in vec2 ip ) {\n    return texelFetch(iChannel0, ivec2(ip), 0);\n}\n\n// Dave Hoskins's\nvec3 hash23(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n// 0:left 1:right 2:top 3:bottom\nint getSide(vec2 p) {\n    return p.y == 0. ? (p.x < 0. ? 3 : 2) : (p.y < 0. ? 1 : 0);\n}\n\n// 0:left 1:right 2:top 3:bottom\nfloat getBySide(vec4 st, int side) {\n    int sq = int(floor(st.z));\n    vec4 v = sq == 5 ? st.yxyx :\n    \t\t sq == 6 ? st.xyxy :\n             sq < 8 ?  st.yxxy : \n                       st.yyxx ;\n    return v[side];\n}\n\nvec2 getPrevObj(vec2 ip, int kind) {\n    vec4 p = _PREV[kind];\n    return vec2(getBySide(state(ip+p.xy), getSide(p.xy)),\n    \t\t\tgetBySide(state(ip+p.zw), getSide(p.zw)));\n}\n\n\nint getKind(vec2 ip) {\n    // to introduce linear elements in the flow, we need to import 2 on x and y\n\tvec3 rnd = hash23(floor(ip/2.));\n    if (rnd.z<.6) {\n    \trnd = hash23(ip);\n        rnd.z = 0.;\n    }\n    if (rnd.z<.4) { // curve\n        return (fract(dot(ip, vec2(.5))) > .25 ? 0 : 2) + (rnd.y < .5 ? 0:1);      \n    } else {\t    // linear\n        int sq = 8 + (mod(ip.y,2.)>.5 ? 0 : 1) + (mod(ip.x,2.)>.5 ? 0 : 2);\n        return rnd.x<.5 ? sq :\n        // Transform one element in special curve with inverted directions\n            sq == 9 ? 4 : sq == 8 ? 5 : sq == 11 ? 6 : 7;\n    } \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = .8*iTime;\n\n    vec2 p = fragCoord, ip = floor(p);\n\n    if (time<.5 || iFrame < 10) {\n\t\t// Init\n        fragColor = vec4(hash23(p).xy, float(getKind(ip)), floor(time));\n        \n    } else {\n        vec4 st = state(ip);\n        if (time > floor(abs(st.w)) + 1.) {\n        \tint sq = int(round(st.z));\n            st.xy = getPrevObj(ip, sq);\n            st.w = floor(time); // prochain switch\n            // switch type\n            vec3 rnd = hash23(ip + floor(time));\n            if (rnd.x>.96) {                \n\t\t\t/*\t// Possible inversion but without animation for the moment\n\t\t\t\t     if (sq == 9) st.z = 4., st.w = -st.w;\n                else if (sq == 4) st.z = 9., st.w = -st.w;\n                else*/ \n                     if (sq == 0) st.z = 1., st.w = -st.w;\n                else if (sq == 1) st.z = 0., st.w = -st.w;                \n                \n            }\n        }   \n        fragColor = st;  \n    } \n}","name":"Buf A","description":"","type":"buffer"}]}