{"ver":"0.1","info":{"id":"MlB3Dm","date":"1429520650","viewed":277,"name":"Implicit Spring","username":"huwb","description":"Gray - analytic solve. White - forward euler. Green - implicit euler. Click and drag LMB to change the damping ratio from undamped (LHS) to slightly overdamped (RHS). Move mouse to bottom of screen to reset.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dynamics","spring","damping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// MIT license, copyright 2015 Huw Bowles\n\n// Accompanying shader to blog post: http://www.huwbowles.com/spring-dynamics-production/\n\n// simple macros to pull mouse position in [0,1]\n#define MOUSEX\tiMouse.x/iResolution.x\n#define MOUSEY\tiMouse.y/iResolution.y\n\n#define HZ 30\n#define UAF 20.0\n#define SDR (MOUSEY>.1 ? MOUSEX*2.5 : .15)\n\n#define MAX_STEPS (HZ*2)\n#define DT (1./float(HZ))\n\n// use these to turn off a function\n#define NO_FN\ty = 0.;col=vec4(0.); return false;\n#define NO_FN_P\tx = y = mint = maxt = 0.; col = vec4(0.); return false;\n\n\n#define PI 3.1415927\n#define PARAMETRIC_STEPS 100\n\nvec3 errorColour( float err, float maxerror );\n\nfloat yt = .0;\nfloat vt = 0.;\nfloat y0 = .5;\nfloat yv0 = 20.0;\n\n// FORWARD EULER\nbool fn1( float x, out float y, out vec4 col )\n{\n    //NO_FN;\n    #if 1\n\tcol = vec4(1.,1.,1.,1.);\n\t\n\tif( x < 0. )\n\t{\n\t\ty = 1./0.;\n\t\treturn true;\n\t}\n\t\n    float xt = x;\n    x = 0.;\n    y = y0;\n    float yv = yv0;\n    for( int i = 0; i < MAX_STEPS; i++ )\n    {\n        float dt = DT;\n        \n        // arrive at target x\n        if( x + dt > xt )\n        {\n            dt = xt - x;\n        }\n        \n        float fprop = UAF*UAF * (yt - y);\n        float fdiff = 2.*SDR*UAF*(vt-yv);\n        \n        #if 1\n        // explicit forward euler\n        y += yv * dt;\n        yv += (fprop + fdiff) * dt;\n        #else\n        // semi implicit euler\n        yv += (fprop + fdiff) * dt;\n        y += yv * dt;\n        #endif\n        \n        x += dt;\n        \n        if( x >= xt )\n            break;\n    }\n    \n\treturn true;\n    #endif\n}\n\n// TARGET VALUE\nbool fn2( float x, out float y, out vec4 col )\n{\n    y = 0.;\n    \n    col = vec4(1.,0.,0.,1.);\n    return true;\n}\n\n// FREQUENCY GUIDE\nbool fn3( float x, out float y, out vec4 col )\n{\n\tif( x < 0. )\n\t{\n\t\ty = 1./0.;\n\t\treturn true;\n\t}\n\n    // analytic solution found by taking the transient solution of the universal oscillator\n    // equation (https://en.wikipedia.org/wiki/Harmonic_oscillator) and solving for the constants\n    // given the initial conditions - initial pos and vel. note the difference between time below\n    // (x) and generalised time on wiki (tau) - tau takes UAF into account.\n    \n    // unconditionally stable for arbitrarily large time steps - assuming no driving\n    // force that is changing!\n    \n    if( SDR > 1.0 ) // overdamped\n    {\n        // precomputed\n        float SQRT = sqrt(SDR*SDR - 1.);\n        \n        // runtime\n        float c2 = y0*(SQRT-SDR) - yv0/UAF;\n        c2 /= 2. * SQRT;\n        float c1 = y0 - c2;\n        float tau = x*UAF;\n        y = exp(-SDR*tau)*(c1*exp(tau*SQRT) + c2*exp(-tau*SQRT));\n    }\n    else if( SDR == 1.0 ) // critically damped\n    {\n        float D = y0;\n        float C = yv0 + D*UAF;\n        y = (C*x+D)*exp(-UAF*x);\n    }\n    else // under damped\n    {\n        //float C = y0;\n        //float B = (yv0 + UAF*SDR*y0) / (UAF*sqrt(1.-SDR*SDR));\n        //y = exp(-UAF*SDR*x) * (\n        //    C*cos(UAF*sqrt(1.-SDR*SDR)*x) +\n        //    B*sin(UAF*sqrt(1.-SDR*SDR)*x) );\n        \n        // precomputed\n        float USRSS = UAF*sqrt(1.-SDR*SDR);\n        float X = 1. / USRSS;\n        float Y = UAF * SDR * X;\n        float US = UAF*SDR;\n\n        // runtime\n        float C = y0;\n        float B = (X*yv0 + Y*y0);\n        y = exp(-US*x) * (\n            C*cos(USRSS*x) +\n            B*sin(USRSS*x) );\n    }\n    \n    float i = .4;\n    col = vec4(i,i,i,1.);\n    return true;\n}\n\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt );\n\n// Tan J., Liu K., Turk G., Stable Proportional-Derivative Controllers, http://www.jie-tan.net/project/spd.pdf\nbool fn4( float x, out float y, out vec4 col )\n{\n\tcol = vec4(0.,1.,0.,1.);\n\t\n\tif( x < 0. )\n\t{\n\t\ty = 1./0.;\n\t\treturn true;\n\t}\n\t\n    float xt = x;\n    x = 0.;\n    y = y0;\n    float yv = yv0;\n    for( int i = 0; i < MAX_STEPS; i++ )\n    {\n        float dt = DT;\n        \n        if( x + dt > xt )\n        {\n            dt = xt - x;\n        }\n        \n        #if 1\n        // fully implicit pd - tan et al - http://www.jie-tan.net/project/spd.pdf\n        float yn = y + yv * dt;\n        float yvn = yv + ((UAF*UAF * (yt - (y+yv*dt)) + 2.*SDR*UAF*(vt-yv)) * dt)/(1.+dt*2.*SDR*UAF);\n        y = yn;\n        yv = yvn;\n        x += dt;\n        #else\n        // semi implicit pd - zimmermann et al - https://www.cs.cmu.edu/~scoros/papers/HierarchicalControl.pdf\n        // implicit for the damping acceleration only.\n        float yn = y + yv * dt;\n        float yvn = yv +\n            (UAF*UAF * (yt - y)\n             + 2.*SDR*UAF*(vt-yv)/(1.+dt*2.*SDR*UAF)) * dt;\n        y = yn;\n        yv = yvn;\n        x += dt;\n        #endif\n        \n        if( x >= xt ) break;\n    }\n    col.a = 0.;\n\treturn true;\n}\n\nbool fn5( float x, out float y, out vec4 col )\n{\n\tfn4(x,y,col);\n    col.a = 1.;\n    return true;\n}\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n    NO_FN_P;\n}\nbool pfn2( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tNO_FN_P;\n}\n\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\n// p is in [0,1]. \nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width )\n{\n\tvec4 result = vec4(0.1);\n\t\n\tfloat thisx = xmin + (xmax-xmin)*p.x;\n\tfloat thisy = ymin + (ymax-ymin)*p.y;\n\t\n\t// compute gradient between this pixel and next (seems reasonable)\n\tfloat eps = dFdx(thisx);\n\n\tfloat alpha;\n\t\n\tvec4 axisCol = vec4(vec3(.3),1.);\n\t\n\t// axes\n\t// x\n\talpha = abs( thisy - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t// y\n\talpha = abs( thisx - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t\n\t/*\n\t// show white bars to illustrate mouse position\n\tvec4 mouseBarCol = vec4(1.);\n\talpha = abs( ymin - thisy ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEX,p.x);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\talpha = abs( xmin - thisx ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEY,p.y);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\t*/\n\t\n\t// uses iq's awesome distance to implicit https://iquilezles.org/articles/distance .\n    // i made an experimental addition - i add another gradient sample and if it is changing suddenly,\n    // take the min gradient. this helps a lot at the corners to prevent overshoot, but does not eliminate\n    // it completely. best would be to interpolate gradient along curve to (C1) smoothly change line thickness.\n\tfloat f;\n\tvec4 fcol;\n\tif( fn5( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1_; fn5( thisx - eps, f_1_, fcol ); float f_prime_1 = (f - f_1_) / eps;\n\t\tfloat f_1; fn5( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n        f_prime = abs(f_prime) < abs(f_prime_1) ? f_prime : f_prime_1;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn4( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1_; fn4( thisx - eps, f_1_, fcol ); float f_prime_1 = (f - f_1_) / eps;\n\t\tfloat f_1; fn4( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n        f_prime = abs(f_prime) < abs(f_prime_1) ? f_prime : f_prime_1;\n\t\t//float f_1; fn4( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn3( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1_; fn3( thisx - eps, f_1_, fcol ); float f_prime_1 = (f - f_1_) / eps;\n\t\tfloat f_1; fn3( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n        f_prime = abs(f_prime) < abs(f_prime_1) ? f_prime : f_prime_1;\n\t\t//float f_1; fn3( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn2( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1_; fn2( thisx - eps, f_1_, fcol ); float f_prime_1 = (f - f_1_) / eps;\n\t\tfloat f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n        f_prime = abs(f_prime) < abs(f_prime_1) ? f_prime : f_prime_1;\n\t\t//float f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn1( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1_; fn1( thisx - eps, f_1_, fcol ); float f_prime_1 = (f - f_1_) / eps;\n\t\tfloat f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n        f_prime = abs(f_prime) < abs(f_prime_1) ? f_prime : f_prime_1;\n\t\t//float f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\t\n\t// parametric curves. todo - join the dots!\n\tfloat x, mint, maxt;\n\tif( pfn1( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn1( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t// uncomment to add a second parametric plot\n\t/*\n\tif( pfn2( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn2( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t*/\n\t\n\tresult += vec4(drawNumber(xmin, vec2(0.,0.)+vec2(1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(xmax, vec2(1.,0.)+vec2(-26.,1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymax, vec2(0.,1.)+vec2(1.,-7.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymin, vec2(0.,0.)+vec2(1.,10.)/iResolution.xy, p ));\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\tfragColor = graph( uv, -.1, 2., -1., 1., .004 );\n\n\treturn;\n}\n\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}]}