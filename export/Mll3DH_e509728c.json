{"ver":"0.1","info":{"id":"Mll3DH","date":"1504204241","viewed":1003,"name":"C64 Simulation","username":"nimitz","description":"Made a while back and wasn't released due to the SID simulator not being up to par. Soundcloud to the rescue! (Music by Jeroen Tel)","likes":30,"published":1,"flags":64,"usePreview":0,"tags":["simulation","c64","minidemo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsXXDX","filepath":"https://soundcloud.com/c64-archives/jeroen-tel-s-express","previewfilepath":"https://soundcloud.com/c64-archives/jeroen-tel-s-express","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[],"code":"//C64 Simulation by nimitz (twitter: @stormoid)\n\n/*\n\tFeatures:\n\t\t-RGB to C64 palette using LAB space for color differencing\n\t\t-Auto dithering (could be improved)\n\t\t-C64 resolution and aspect ratio\n*/\n\n//#define time iTime\n\n#define C64_COLOR\n#define C64_PIXELS\n#define AUTO_DITHER\n//#define SHOW_PALETTE\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n\n//-------------------------------------------------------------------\n//---------------------------RGB to C64------------------------------\n//-------------------------------------------------------------------\n\nvec3 pal[16];  //Palette from: http://www.pepto.de/projects/colorvic/\nvoid setpal()\n{\n    pal[0]=vec3(0),pal[1]=vec3(1),pal[2]=vec3(0.4530,0.2611,0.2089),pal[3]=vec3(0.4845,0.6764,0.7286), pal[4]=vec3(0.4825,0.2829,0.5663),pal[5]=vec3(0.3925,0.5921,0.3087),\n    pal[6]=vec3(0.2500,0.1972,0.5206), pal[7]=vec3(0.7500,0.8028,0.4794),pal[8]=vec3(0.4825,0.3576,0.1837),pal[9]=vec3(0.3082,0.2691,0.0000),pal[10]=vec3(0.6405,0.4486,0.3964),\n    pal[11]=vec3(0.3125,0.3125,0.3125),pal[12]=vec3(0.4688,0.4688,0.4688),pal[13]=vec3(0.6425,0.8421,0.5587),pal[14]=vec3(0.4688,0.4159,0.7393),pal[15]=vec3(0.6250,0.6250,0.6250);\n}\n\nfloat rectify(in float f){ return mix(pow(((f + 0.055)/1.055), 2.4), f / 12.92, step(f, 0.04045))*100.; }\nfloat pivot(in float x){ return mix(pow(x,0.3333), (903.3*x + 16.)/116., step(x,216.0/24389.0)); }\n//RGB to Lab (for color differencing) https://github.com/THEjoezack/ColorMine\nvec3 rgb2lab(in vec3 c)\n{\n\tc.r = rectify(c.r);\n\tc.g = rectify(c.g);\n\tc.b = rectify(c.b);\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n\tvec3 w = normalize(vec3(1.3,1.33,1.1));\n\tc.x = pivot(c.x/w.x);\n\tc.y = pivot(c.y/w.y);\n\tc.z = pivot(c.z/w.z);\n\t\n\treturn vec3(max(0.,116.*c.y-16.), 500.*(c.x-c.y), 200.*(c.y-c.z));\n}\n\nfloat hash(in float n){return fract(sin(n)*43758.5453);}\n//Using CIE76 for color difference, mainly because it is much cheaper\nvec3 c64(in vec3 c, in vec2 p)\n{\n    c = clamp(c,.0,1.);\n    \n    vec3 hsv = rgb2lab(c);\n    float d = 100000.;\n    float d2 = 100000.;\n    vec3 c2 = vec3(0);\n    for(int i=0;i<16;i++)\n    {\n        vec3 ch = rgb2lab(pal[i]);\n        float cd = distance(hsv,ch);\n        if (cd < d)\n        {\n            d2 = d;\n            c2 = c;\n            d = cd;\n            c = pal[i];\n        }\n        else if(cd < d2)\n        {\n            d2 = cd;\n            c2 = pal[i];\n        }\n    }\n    \n    const float sclx = 320.;\n    const float scly = 200.;\n    float id = floor(p.x*sclx)*1.1+floor(p.y*scly)*2.;\n    float px = mod(floor(p.x*sclx)+floor(p.y*scly),2.);\n#ifdef AUTO_DITHER\n    float rn = hash(id);\n    if (rn < smoothstep(d2*0.96, d2*1., d*1.01) && (px ==0.))c=c2;\n#endif\n    return pow(abs(c),vec3(1.136));  //correct gamma\n}\n\n\n\n//-------------------------------------------------------------------\n//--------------------------Effects----------------------------------\n//-------------------------------------------------------------------\n\nfloat tri(in float x){return abs(fract(x)-0.5);}\n\n//from iq\nvec3 hsl2rgb(in vec3 c){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(in vec3 c){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\t\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 fx1(in vec2 p)\n{\n    return hsl2rgb(clamp(vec3(p.x,p.y,p.y),0.,1.));\n}\n\n//Plasma\nvec3 fx2(in vec2 p)\n{\n    vec3 rz = vec3(0);\n    const float q = 5.;\n    float x = sin(iTime*0.8+p.x*q)+sin(iTime+p.x*q)+sin(iTime*0.9+p.y*q)+sin(iTime*0.82+p.y*q*2.)+sin(p.x*1.+iTime*1.1)*3.;\n    rz = sin(vec3(1,2,3)*x+iTime*2.);\n    return rz;\n}\n\n//Scrollbars\nvec3 fx3(in vec2 p)\n{\n    vec3 rz = vec3(0);\n    float xx = abs(sin((p.x+p.y)*10.+iTime*5.))*abs(sin(iTime*2.+p.x+p.y));\n    rz = hsv2rgb(vec3(0.6+(p.x+p.y)*0.3+iTime*0.1,.82,5.))*xx;\n    return rz;\n}\n\n//\"Borrowed\" from: \"Fairlight - We are new\" (http://www.pouet.net/prod.php?which=56000)\nvec3 fx4(in vec2 p, in vec2 bp)\n{\n    vec3 rz = vec3(0);\n    float id = floor(p.x*80.);\n    float rn = hash(id+0.3);\n    \n    if (rn < 0.5)rz = vec3(.5,.5,0);\n    else if(rn < 0.7)rz = vec3(0,.5,0);\n   \telse rz = vec3(0.5,1.,0.5);\n        \n    rz *= step(fract(p.y*.5+iTime*0.015+rn*(iTime+10.)*0.15)+.1,0.5);\n    return rz;\n}\n\nfloat smoothfloor(in float x, in float k)\n{\n    k = clamp(k, 0., 1.);\n    float xk = x+k*0.5;\n    return floor(xk)+smoothstep(0.,k,fract(xk));\n}\n\n//Colored checkered grid  \nvec3 fx5(in vec2 p)\n{\n    p -= 0.5;\n    vec2 bp = p;\n    \n    p.y -= 0.35;\n    p = vec2(p.x/p.y, 1./p.y);\n    \n    p.y += sin(iTime*.1)*20.+27.;\n    p.x += sin(iTime*.2)*15.;\n    p*= 2.;\n    \n    vec2 q = floor(p)*20.;\n    \n    float id = q.x + q.y;\n    id *= sin(q.x*10.1+q.y*100.)*.5+.5;\n    \n    vec3 col = abs(sin(vec3(1,3,5)+id*0.01+iTime*0.5))*0.75;\n    col /= sin(.9*iTime+id)*2.;\n    \n    //separators\n    col *= smoothstep(.005,.04,abs(fract(p.x+0.5)-0.5));\n    col *= smoothstep(.01,.04,abs(fract(p.y+0.5)-0.5));\n    \n    float g = (bp.y + iTime*0.05)*30.;\n    vec3 bg = sin(vec3(1,2,3)+floor(g))*0.5+abs(sin(g-iTime*2.5)*.8);\n    col = mix(bg, clamp(col,0.,1.), smoothstep(0.089,.09,-bp.y+0.35));\n    \n    return col;\n}\n\nvec4 balls(in vec2 p, in float of)\n{\n    p *= 1.5;\n    float t = iTime*0.6+of;\n    \n    t = mod(t,4.);\n    p.x += t;\n    \n    const float scl = 7.;\n    float id = t-floor(p.x*scl)/scl+0.5;\n    if (mod(p.x,2.) > 1.)return vec4(0);\n    \n    float pd1 = exp(id+1.)*id*id*2.-.3;\n    float pd2 = exp(id+1.)*id*id*id*4.-.2;\n    \n    p.y += mix(pd1,pd2,sin(iTime*1.+of*3.)*0.5+0.5);\n    p = vec2(fract(p.x*scl)-0.5,p.y*scl);\n    \n    float rz =length(p);\n    float rz2 = rz;\n    id = clamp(id*0.4,-0.22,.04);\n    float rz3 = smoothstep(-0.1-id,.4-id,rz);\n    rz = smoothstep(0.25-id,.3-id,rz);\n    vec3 col = (abs(sin(vec3(1,2,3)+of*5.))*0.6)*(1.-rz);\n    \n    vec3 ligt = normalize(vec3(-.5,2.,.5));\n    ligt.xy *= mm2(iTime*.8);\n    vec3 nor = normalize(vec3(p,rz));\n    col += rz2*(dot(nor,ligt))*vec3(20.*(id+0.5))*(1.-rz3);\n    return vec4(col,1.-rz);\n}\n\nvec3 fx6(in vec2 p)\n{\n    vec3 col = vec3(0);\n    float rz= 1.;\n    p -= 0.5;\n    p *= mm2(iTime*.8);\n    p.x += 0.3;\n    for(float i=0.;i<6.;i++)\n    {\n        vec4 rez = balls(p,i*.1);\n        //vec4 rez = balls(p,i*(.75));\n        col = col*(1.-smoothstep(0.,1.,rez.w))+rez.rgb;\n        p.x += 0.09;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsetpal();\n    //C64 native resolution (320x200)\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 bp = p;\n    float asp = iResolution.x/iResolution.y;\n   \t\n    //Ensure 16:10 and center it\n    if(iResolution.x*.625 > iResolution.y)\n\t{\n\t\tp.x *= asp*0.625;\n\t\tp.x -= (asp*0.625-1.)*0.5;\n\t}\n\telse\n\t{\n\t\tp.y *= 1./asp*1.6;\n\t\tp.y -= (1.6/asp-1.)*0.5;\n\t}\n    \n    #ifdef C64_PIXELS\n    p.x = floor(p.x*320.)/320.;\n    p.y = floor(p.y*200.)/200.;\n    #endif\n    \n#ifdef SHOW_PALETTE\n  \tvec3 col = fx1(p);  \n#else\n    \n    //float tx = time-.5;\n    //p += (hash(tx)-0.5)*0.01*smoothstep(-.8,1.,sin(tx*3.4))*smoothstep(7.4,7.5,tx);\n    \n    //background\n    vec3 col = mix(vec3(0,0.4,1.),vec3(0.,0.2,.5),step(abs(p.y-0.5),0.4)*step(abs(p.x-0.5),0.4));\n    \n    float time = max((iTime*0.95)-3.5,0.);\n    \n    //bg transition\n    col = mix(mix(col,fx5(p),smoothstep(-.07,.07,sin(3.9+time*0.1)+0.45 )),fx6(p),clamp(smoothstep(40.,43.,time),0.,1.));\n    \n    \n    vec2 qq = p+vec2(smoothstep(0.,.6,sin(time*.28+1.7))*1.5,0)+vec2(smoothstep(40.,50.,time)*1.5,0);\n    float t= time*1. + sin(time*1.5+3.5)*1.;\n    vec2 q = qq+vec2(sin(t+1.57)*2.,sin(time))*0.2 + clamp(6.-time*0.25,0.,1.);\n    float d = max(abs(q.x-0.5),abs(q.y-0.5));\n    float sz = 0.22+sin(t)*0.1;\n    if(d < sz)\n        col = fx4(q,bp);\n    float brd = 1.-smoothstep(0.,0.01,abs(abs(d)-sz));\n    col = mix(col, sin(vec3(.3,.7,.5)+brd*2.+4.7)*1., smoothstep(0.0,.01,brd));\n    \n    \n    t += 1.8;\n    float d2 = 0.;\n    float sz2 = 0.22+sin(t)*0.1;\n    if (sz2 > sz || d > sz+0.01)\n    {\n        vec2 q = qq+vec2(sin(t+1.57)*2.,sin(time))*0.2 + clamp(3.-time*0.25,0.,1.);\n        d2 = max(abs(q.x-0.5),abs(q.y-0.5));\n        if(d2 < sz2) col = fx3(q);\n        float brd = 1.-smoothstep(0.,0.01,abs(abs(d2)-sz2));\n    \tcol = mix(col, sin(vec3(.0,.5,.5)+brd*2.+4.5)*1., smoothstep(0.0,.01,brd));\n        \n        \n        t += 1.8;\n        float sz3 = 0.22+sin(t)*0.1;\n        if (sz3 > sz2 || d2 > sz2+0.007)\n        {\n            vec2 q = qq+vec2(sin(t+1.57)*2.,sin(time))*0.2 + clamp(1.-time*0.25,0.,1.);\n            d = max(abs(q.x-0.5),abs(q.y-0.5));\n            if(d < sz3)\n                col = fx2(q);\n            float brd = 1.-smoothstep(0.,0.01,abs(abs(d)-sz3));\n    \tcol = mix(col, sin(vec3(.9,.3,.55)+brd*1.8+4.5)*1., smoothstep(0.0,.01,brd));\n        }\n    }\n    \n#endif\n    \n\t#ifdef C64_COLOR\n    col = c64(col,bp);\n    #endif\n    \n    //clip screen to 16:10\n    if (p.x > 1. || p.x <0. || p.y > 1. || p.y <0.)col = vec3(0);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}