{"ver":"0.1","info":{"id":"MffGz2","date":"1703258222","viewed":49,"name":"box and structures","username":"nayk","description":"copy past and combination","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["menger","cosmos","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*https://www.shadertoy.com/view/lslyRn# https://www.shadertoy.com/view/4sX3Rn https://www.shadertoy.com/view/4fXGzj*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvec3 r;\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat map(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 1.;\n\n\n    for (float i = 1.; i < 9.; i++) {\n      \n            pos = max(pos, -field(q,pow(1.8,i)/16.));\n     \n    }\n    \n    return pos;\n}\nfloat map2(vec3 p) {\n\n    // geo\n    \n    float fl = p.y + 1.;\n    p.xz = mod(p.xz, 5.) - 2.5;\n    \n    float b = box(p, vec3(1.));\n    return min(fl,b);\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat occ ( vec3 p, vec3 n, float ni, float L) {\n    float occ = 1.;\n    for (float i =1.; i < ni; i++) {\n        float l = i * L / ni;\n        float d = map(p + n * l);\n        occ -= max(0., l -d ) / l / ni;\n    \n    }\n    return max(0.,occ);\n\n\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\nvec4 map3( in vec3 p )\n{\n    float d = sdBox(p,vec3(0.5));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.0*iTime) );\n\tfloat off = sin( 0.00*iTime );\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    if( bb.y<bb.x ) return vec4(-1.0);\n    \n    float tmin = bb.x;\n    float tmax = bb.y;\n    \n    float t = tmin;\n    vec4 res = vec4(-1.0);\n    for( int i=0; i<64; i++ )\n    {\n        vec4 h = map3(ro + rd*t);\n\t\tif( h.x<0.002 || t>tmax ) break;\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>tmax ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    float tmax = bb.y;\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map3(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n\t\tt += clamp( h, 0.005, 0.1 );\n        if( t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(.001,0.0,0.0);\n    return normalize(vec3(\n    map3(pos+eps.xyy).x - map3(pos-eps.xyy).x,\n    map3(pos+eps.yxy).x - map3(pos-eps.yxy).x,\n    map3(pos+eps.yyx).x - map3(pos-eps.yyx).x ));\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\n    vec3 col = mix( vec3(0.0,0.0,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        \n        vec3 matcol = 0.5 + 0.5*cos(vec3(0.0,1.0,2.0)+2.0*tmat.z);\n        \n        float occ = tmat.y;\n\n        const vec3 light = normalize(vec3(1.0,0.0,0.3));\n        float dif = dot(nor,light);\n        float sha = 1.0;\n        if( dif>0.0 ) sha=softshadow( pos, light, 0.01, 64.0 );\n        dif = max(dif,0.0);\n        vec3  hal = normalize(light-rd);\n        float spe = dif*sha*pow(clamp(dot(hal,nor),0.0,1.0),16.0)*(0.04+0.96*pow(clamp(1.0-dot(hal,light),0.0,1.0),5.0));\n        \n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n        col = matcol*lin + spe*128.0;\n    }\n\n    col = 1.5*col/(1.0+col);\n    col = sqrt( col );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.02);\n\tfloat time=iTime*speed+.25;\n\n  \n    \n    // nav \n    vec3 s = vec3(0,1.5,-25);\n     // camera\n    vec3 ro = 1.1*vec3(\n 1.*sin(1.*iTime),1.0+1.0*cos(iTime*.0),0.5*cos(0.0*iTime));\n\n#if AA>1\n    #define ZERO (min(iFrame,0))\n    vec3 col2 = vec3(0.0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.0;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n        vec3 ww = normalize(vec3(0.0) - ro);\n        vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        col2 += render( ro, rd );\n    }\n    col2 /= float(AA*AA);\n#else   \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    vec3 col2 = render( ro, rd );\n#endif        \n    \n   \n    vec3 arm = vec3(0,0,1);\n   arm.xz *= rot((iTime)*0.3);\n    \n    vec3 fwd = vec3(.1,0.,5.)*-iTime;\n    s+=fwd;\n  \n    vec3 t = s + arm;\n      \n    vec3 z = normalize(t-s);\n    \n    vec3 x = normalize(cross(vec3(0,-1,0),z));\n    vec3 y = cross(x,z);  \n    r = mat3(x,y,z) * normalize(vec3(uv,1));\n    \n    vec3 p = s;\n    \n    float l;\n    \n    float L = 100.;\n    \n    for (float i = 0.; i < 100.; i++) {\n        float d = map(p) ;\n        \n        if ( d < .001) {\n            break;\n        }\n        if ( l > L) {\n            break;\n        }\n        p += r * d;\n        l += d;\n    }\n    \n    vec3 col = vec3(0);\n   \n  \n    \n    vec3 n = norm(p);\n    \n    \n    col += occ(p, n , 5., 3.);\n    \n    col = sqrt(col);\n    dir+=col+col2.xyz;\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}