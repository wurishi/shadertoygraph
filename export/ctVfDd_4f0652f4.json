{"ver":"0.1","info":{"id":"ctVfDd","date":"1702659755","viewed":33,"name":"Planet and moons","username":"Foghlaimeoir","description":"Simple raycaster to render a planet and some moons in orbit.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycast","sphere","planet","moons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_PI = 3.14159265358979323846264338327950288;\n\n// Field of View:\nconst float FOV = 60.0 * M_PI/180.0;\n\nconst int MAX_NUM_SPHERES = 2;\nvec3 spherePos[MAX_NUM_SPHERES];\nfloat sphereRadius[MAX_NUM_SPHERES];\n\n//----------------------------------------------------------------------------//\n\nbool TestRayAgainstSphere(in vec3 rayStart, in vec3 rayDir,\n                          in vec3 spherePos, in float sphereRadius,\n                          inout vec3 hitPos, inout vec3 normal)\n{\n    vec3 camPosPrime = rayStart - spherePos;\n    float d = dot(rayDir, camPosPrime);\n    float disc = d*d - dot(camPosPrime, camPosPrime) + sphereRadius*sphereRadius;\n    if(disc > 0.0)\n    {\n        // Ray intersects sphere, get t-value of the intersection.\n        float sigma = -d - sqrt(disc);\n        \n        // Use to get the intersection point in world space and obtain the\n        // surface normal.\n        hitPos = rayStart + sigma*rayDir;\n        normal = normalize(hitPos - spherePos);\n\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\n//----------------------------------------------------------------------------//\n\nvoid UpdatePlanets(in float iTime)\n{\n    spherePos[0] = vec3(0.0, 0.0, 5.0);\n    sphereRadius[0] = 1.0;\n    \n    // Moons:\n    float fTime = iTime/1.0;\n    float orbitalRadius = 2.0;\n    spherePos[1] = vec3(orbitalRadius*sin(-fTime) + spherePos[0].x,\n                        0.0,\n                        orbitalRadius*cos(-fTime) + spherePos[0].z);\n    sphereRadius[1] = 0.2;\n}\n\n//----------------------------------------------------------------------------//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 outputCol = vec4(0.0, 0.0, 0.0, 1.0);\n    float fragDepth = 1e10;\n    \n    // Position planetary system.\n    UpdatePlanets(iTime);\n    \n    // Update position of Sun to simulate orbiting seen from perspective of\n    // parent planet.\n    float planetOrbitRadius = 100.0;\n    float orbitalSpeed = -0.1;\n    vec3 lightPos = vec3(planetOrbitRadius*sin(orbitalSpeed*iTime) - spherePos[0].x,\n                         0.0,\n                         planetOrbitRadius*cos(orbitalSpeed*iTime) - spherePos[0].z);\n\n    // Camera position and position of centre of near clip plane.\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camForward = vec3(0.0, 0.0, 1.0);\n    vec3 camRight = vec3(1.0, 0.0, 0.0);\n    vec3 camUp = vec3(0.0, -1.0, 0.0);\n\n    // Assume distance of 1 unit from camera to screen in order to compute\n    // screen coordinates in world space.\n    float screen_hw = tan(0.5*FOV);\n    float screen_hh = screen_hw * float(iResolution.y)/float(iResolution.x);\n\n    // World space coordinates of top-left pixel of screen.\n    vec3 screenPos_0 = camPos + camForward - screen_hw*camRight + screen_hh*camUp;\n\n    // And now for this particular pixel.\n    vec3 screenPos = screenPos_0 + fragCoord.x*2.0*screen_hw/float(iResolution.x)*camRight\n                        - fragCoord.y*2.0*screen_hh/float(iResolution.y)*camUp;\n\n    // Define rays through each pixel in the near clip plane.\n    vec3 rayDir = normalize(screenPos - camPos);\n\n    // Test ray for intersection with sphere.\n    vec3 hitPos;\n    vec3 normal;\n    for(int i = 0; i < MAX_NUM_SPHERES; i++)\n    {\n        if(TestRayAgainstSphere(camPos, rayDir, spherePos[i], sphereRadius[i], hitPos, normal))\n        {\n            // Lighting.\n            vec3 hitPosToLight = lightPos - hitPos;\n            vec3 reflectedLightDir = normalize(reflect(hitPosToLight, normal));\n\n            float diffuse = 0.8*max(dot(normalize(hitPosToLight), normal), 0.0);\n            float specular = 0.15*pow(max(dot(reflectedLightDir, rayDir), 0.0), 32.0);\n\n            float ambient = 0.1;\n\n            // Depth test.\n            if(length(hitPos - camPos) < fragDepth)\n            {\n                fragDepth = length(hitPos - camPos);\n                outputCol.rgb = vec3(diffuse + specular + ambient);\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = outputCol;\n}","name":"Image","description":"","type":"image"}]}