{"ver":"0.1","info":{"id":"7lyyRw","date":"1661174973","viewed":127,"name":"Curve Inflation Fork","username":"Tilmann","description":"A mix of https://www.shadertoy.com/view/7tyyzW and https://www.shadertoy.com/view/7tVyRW with a lot of averaging to reduce the noise.\n\nThere are three randomization modes:\n- random seed per location\n- fixed seeds\n- random seed per location and frame","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","pde"],"hasliked":0,"parentid":"7tyyzW","parentname":"Curve Inflation: Walk on Spheres"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on iq's https://www.shadertoy.com/view/7tVyRW\n\nfloat map( in vec3 pos )\n{\n    float d = -dist(pos.xy, iFrame);\n    if(d < 0.0)\n    {\n        vec2 tpos = pos.xy * vec2(iResolution.y/iResolution.x,1.) + .5;\n        float h = sqrt(texture(iChannel0, tpos).x);\n        return abs(pos.z)-h; // WARNING, NOT AN EXACT DISTANCE!!\n    }\n    return sdBox( vec2(d,pos.z), vec2(0.001,0.0));\n}\n\n/*\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.003, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n*/\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.01;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n  \n    // camera movement\t\n\tfloat an  = iMouse.z > .5 ? TAU * (.25 + iMouse.x / iResolution.x) : iTime + 1.0;\n\tfloat an2 = iMouse.z > .5 ? TAU * (.25 + iMouse.y / iResolution.y * .5) : 0.0;\n\tvec3 ro = vec3( 1.*cos(an)*cos(an2), sin(an2), 1.*sin(an)*cos(an2));\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        vec3 col = vec3(0.0);\n\n        // bounding sphere\n        vec2 tmima = iSphere( ro, rd, vec4(0.0,0.05,0.0,0.65) );\n        if( tmima.y>0.0 )\n        {\n            // raymarch inside bounding sphere\n            float t = max(tmima.x,0.0);\n            for( int i=0; i<256; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( abs(h)<0.001 || t>tmima.y ) break;\n                t += h;\n            }\n\n            // shading/lighting\t\n            if( t<tmima.y )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n                vec3 lig = vec3(0.57703);\n                float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n                //if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n                float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n                col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n            }\n            \n            //col+=0.25; // show bounding sphere\n        }\n        \n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int walk_iterations = 16;\nconst float epsilon = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    maybe_srand(1, iFrame, ivec2(fragCoord));\n\n    float u = 0.0;\n    vec2 p = fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5);\n    for(int i = 0;i<walk_iterations;i++)\n    {\n        float R = dist(p, iFrame);\n        if( R < epsilon) break;\n        u += R*R;\n        p += R*randomOnCircle();\n    }\n    fragColor = vec4(u, 0, 0, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530\n\n// https://iquilezles.org/articles/intersectors/\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// https://www.shadertoy.com/view/4llXD7\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for any given shape\n    p.x = abs(p.x);\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n    return (s<0.0) ? length(p)-r :\n           (p.x<w) ? h - p.y     :\n                     length(p-vec2(w,h));\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvec3 colormap(in float d)\n{\n  vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\nfloat get_t(in int frame)\n{\n  return 20.*fract(float(frame)*0.005);\n}\n\n// https://www.shadertoy.com/view/7tyyzW\nfloat dist(in vec2 xy, in int frame)\n{\n // return -sdCircle( xy , 0.5);\n  //return -min(\n  //  sdCircle( xy , 0.25),\n  //  sdBox(xy,vec2(0.5,0.125)));\n  float d = sdCircle( xy+vec2(0.,0.02) , 0.4);\n  \n  float t = get_t(frame);\n  \n  if(int(t)>3)\n  {\n    d = min(min(d,\n      max(sdCutDisk( xy , 0.48, 0.0),-sdCutDisk( xy , 0.42, 0.0))),\n      sdBox(xy+vec2(0.,-0.05),vec2(0.5,0.125)));\n  }\n  float x = xy.x;\n  switch(int(t))\n  {\n    default:\n    case 5:\n      float s = min(t-5.0,1.);\n      float th = mix(1.570796,0.2,3.*s*s-2.*s*s*s);\n      d = max(d, -sdArc( vec2(xy.x,-xy.y-0.07), vec2(cos(th),sin(th)), 0.2, 0.02));\n    case 4:\n    case 3:\n      x = abs(x);\n    case 2:\n      d = max(d, -sdCircle( vec2( x ,xy.y)-vec2(0.125,0.12) , 0.06));\n    case 1:\n    case 0: break;\n  }\n  return -d;\n  /*return -max(max(d, \n      -sdCircle( vec2(abs(xy.x),xy.y)-vec2(0.18,0.17) , 0.07)\n      ),\n      -sdArc( vec2(xy.x,-xy.y-0.07), vec2(cos(0.2),sin(0.2)), 0.2, 0.02)\n      );*/\n}\n\n\n// rand() stuff\nint   seed = 1;\nvoid  srand(int s) { seed = s; }\nint   randi(void)  { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat randf(void)  { return float(randi())/32767.0; }\nvec2  randOnCircle(void) { float an=6.2831853*randf(); return vec2(cos(an),sin(an)); }\n// hash to initialize the random sequence (copied from Hugo Elias)\nint hash(int n) { n = (n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n// --------------------------------------\n\nvec2 randomOnCircle( void ) {\n    float theta = TAU * randf();\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 onCircle(in float theta) {\n    theta *= TAU;\n    return vec2(cos(theta), sin(theta));\n}\n\nvoid maybe_srand(int seed_offset, int frame , ivec2 q) {\n    int seed = seed_offset;\n    switch(frame/200 % 3){\n        case 2: seed += hash(frame);\n        case 0: seed += hash(q.x + hash(q.y));\n    }\n    srand(seed);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int samples = 16;\nconst float epsilon = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    maybe_srand(2, iFrame, ivec2(fragCoord));\n\n    vec2 p0 = fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5);\n    float u = 0.0;\n    vec2 w = randomOnCircle();\n    float angle = TAU/float(samples);\n    vec2 sc = vec2(sin(angle),cos(angle));\n    mat2 rot = mat2(sc.y, -sc.x, sc.x, sc.y);\n    \n    float R = dist(p0, iFrame);\n    if(R > epsilon)\n    for(int i = 0;i<samples;i++)\n    {\n        vec2 p = p0;\n        u += R*R;\n        p += R*w;\n        w *= rot;\n        ivec2 pi = ivec2(p*iResolution.y + .5*iResolution.xy);\n        u += texelFetch(iChannel0, pi, 0).x;\n    }\n    fragColor = vec4(u / float(samples), 0, 0, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int samples = 16;\nconst float epsilon = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    maybe_srand(3, iFrame, ivec2(fragCoord));\n    \n    vec2 p0 = fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5);\n    float u = 0.0;\n    vec2 w = randomOnCircle();\n    float angle = TAU/float(samples);\n    vec2 sc = vec2(sin(angle),cos(angle));\n    mat2 rot = mat2(sc.y, -sc.x, sc.x, sc.y);\n    \n    float R = dist(p0, iFrame);\n    if(R > epsilon)\n    for(int i = 0;i<samples;i++)\n    {\n        vec2 p = p0;\n        u += R*R;\n        p += R*w;\n        w *= rot;\n        ivec2 pi = ivec2(p*iResolution.y + .5*iResolution.xy);\n        u += texelFetch(iChannel0, pi, 0).x;\n    }\n    fragColor = vec4(u / float(samples), 0, 0, 1);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const int samples = 16;\nconst float epsilon = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    maybe_srand(4, iFrame, ivec2(fragCoord));\n\n    vec2 p0 = fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5);\n    float u = 0.0;\n    vec2 w = randomOnCircle();\n    float angle = TAU/float(samples);\n    vec2 sc = vec2(sin(angle),cos(angle));\n    mat2 rot = mat2(sc.y, -sc.x, sc.x, sc.y);\n    \n    float R = dist(p0, iFrame);\n    if(R > epsilon)\n    for(int i = 0;i<samples;i++)\n    {\n        vec2 p = p0;\n        u += R*R;\n        p += R*w;\n        w *= rot;\n        ivec2 pi = ivec2(p*iResolution.y + .5*iResolution.xy);\n        u += texelFetch(iChannel0, pi, 0).x;\n    }\n    fragColor = vec4(u / float(samples), 0, 0, 1);\n}","name":"Buffer D","description":"","type":"buffer"}]}