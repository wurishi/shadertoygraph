{"ver":"0.1","info":{"id":"wtXcWl","date":"1593390081","viewed":75,"name":"raycasting analytic sphere","username":"IXshader","description":"sphere using simple raytracing method","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["newbiecodes1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nbool intersectSphere(vec3 ro , vec3 rd)\n{\n    //sphere position\n    vec3 center = vec3(0.0,0.0,-3.0);\n   \t//sphere radius\n    float radius = 2.0;\n    \n  \t/* We use the implicit equation of sphere x^2 + y^2 + z^2 = r^2 in 3D;\n\t   using center c transform to (x-c)^2 + (y-c)^2 + (z-c)^2 = r^2;\n  \t   using parametric equation of ray: ray_origin(ro) + ray_direction(rd) * t;\n\t    x = Xo + Xd*t;\n\t\ty = Yo + Yd*t;\n\t\tz = Zo + Zd*t;\n       vector form of sphere: (Xo + Xd*t -c)^2 + (Yo + Yd*t -c)^2 + (Zo + Zd*t -c)^2 = r^2\n\t\t   \n      after simplifying we get quadratic equation in t with coefficients as follows:\n\n      A = Xd^2+Yd^2+Zd^2;\n\t  B = 2 * (Xd * (Xo - Xc)) + (Yd* (Yo - Yc)) + (Zd * (Zo - Zc))\n\t  C = (Xo - Xc)^2 + (Yo - Yc)^2 + (Zo - Zc)^2 - r^2;\n\t\t\n      t1 = -B + sqrt(B^2 - 4AC) / 2A;\n      t2 = -B - sqrt(B^2 - 4AC) / 2A;\n\t \n\n     */\n    \n    float A = dot(rd,rd);\n    float B = 2.0 * (dot(rd,(ro - center)));\n    float C = dot((ro-center),ro-center) - radius*radius;\n    \n    //never use sqrt \n    //try and see for yourself\n    //understand the answer for this issue \n    float discriminant = B*B - (4.0*A*C);\n    \n    if(discriminant > 0.0)\n    {\n\t\treturn true;\n    }\n    else\n    {\n\t\treturn false;\n    }\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //re scale from -1 to 1\n    uv = -1.0 + 2.0 * uv;  \n    //horizontal width of viewport should be matched to window coordinates(more wider than tall)\n    uv.x *= iResolution.x/iResolution.y;\n   \n    \n    //fake camera\n    vec3 rayOrigin = vec3(0.0,0.0,4.0);\n    vec3 rayDirection = normalize(vec3(uv.xy,-2.0));\n    \n    \n    \n  \tvec3 col = vec3(0.0);\n    \n    if(intersectSphere(rayOrigin,rayDirection))\n    {\n\t\tcol = vec3(1.0,0.0,0.0);\n    }\n    else\n    {\n        //some linear interpolation\n\t\tcol = mix(vec3(0.0,0.89,0.9),vec3(1.0),vec3(uv.y));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}