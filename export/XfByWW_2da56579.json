{"ver":"0.1","info":{"id":"XfByWW","date":"1722293910","viewed":97,"name":"Cellular Clockwork","username":"thedarkbunny","description":"Now with corners!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//constant for rotation\n#define TAU 6.2831853\n\n//Number of seconds per revolution, float\n#define SCALE 10.\n//Number of passes in main loop, int\n#define PASSES 15\n//Pixel threshold for dropout, float\n#define SMALL 5.\n\n//Colors (subject to change; we're doing a new pattern\n#define C_BASE vec3(0.,0.,0.25)\n#define C_DOT vec3(0.5,0.,1.)\n#define C_HI1 vec3(1.,1.,1.)\n#define C_HI2 vec3(0.,1.,1.)\n\n//states for main loop\n#define S_UNBOUND 0\n#define S_INT_ROOT 1\n#define S_EXT_CORNER 2\n#define S_EXT_EDGE 3\n#define S_GAP 4\n\n\n\nvec2 cmult(vec2 p, vec2 q){return vec2(p.x*q.x-p.y*q.y,p.x*q.y+p.y*q.x);}\n\nvec2 csqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec3 cdt(in vec3 a, in vec3 b, in vec3 c, in bool pos){\n\tfloat z = 2.*sqrt(a.z*b.z+a.z*c.z+b.z*c.z)*(pos?1.:-1.);\n\tvec3 d = vec3(0.,0.,a.z+b.z+c.z+z);\n\t//Parallel lines have three solutions, and we can't handle that.\n    if(a.z == 0.){\n        vec3 d = vec3(0.,0.,b.z+c.z+2.*sqrt(b.z*c.z));\n        //d.xy = (b.xy*b.z + c.xy*c.z)/(b.z+c.z);\n        float sa = (b.z+c.z)/(b.z*c.z);\n        float sb = (d.z+c.z)/(d.z*c.z);\n        float sc = (d.z+b.z)/(d.z*b.z);\n        float ss = (sa+sb+sc)/2.;\n        float ta = sqrt(ss*(ss-sa)*(ss-sb)*(ss-sc));\n        float th = ta/sa*2.;\n        float bp = sqrt(sb*sb-th*th)/sa;\n        d.xy = b.xy*bp+c.xy*(1.-bp);\n        d.xy += (pos?1.:-1.)*(c.yx-b.yx)*vec2(1.,-1.)*ta/sa/sa*2.;\n        //d.xy = d.xy + (c.yx-b.yx)*vec2(1.,-1.)*b.z*b.z*c.z*c.z*sqrt((d.z*b.z + d.z*c.z + b.z*c.z)/(d.z*d.z*b.z*b.z*c.z*c.z))/(b.z+c.z)/(b.z+c.z);\n        return d;\n    }\n  \n  \n    if(d.z == 0.){\n        //A line.  Can't find the center if it doesn't have one.\n        return d;\n    }\n    if(z == 0.){\n        //the easy way results in 0/0.  Time for the hard way.\n        d.xy = (a.z*a.xy + b.z*b.xy + c.z*c.xy + 2.*csqrt(cmult(a.xy,b.xy)*a.z*b.z + cmult(a.xy,c.xy)*a.z*c.z + cmult(b.xy,c.xy)*b.z*c.z)*(pos?1.:-1.) )/d.z;\n        return d;\n    }\n    float s = a.z+b.z+c.z+d.z;\n    d.xy = -(a.z*a.xy*(2.*a.z-s)+b.z*b.xy*(2.*b.z-s)+c.z*c.xy*(2.*c.z-s))/(d.z*(2.*d.z-s));\n    return d;\n}\n\nbool inTri(in vec3 a, in vec3 b, in vec3 c, in vec3 p) {\n  a.z = 0.;\n  b.z = 0.;\n  c.z = 0.;\n  p.z = 0.;\n  a -= p;\n  b -= p;\n  c -=p;\n  float u = cross(b, c).z;\n  float v = cross(c, a).z;\n  float w = cross(a, b).z;\n  if (u*v < 0.) {\n      return false;\n  }\n  if (u*w < 0.) {\n      return false;\n  }\n  return true;\n}\n\nbool hitDot(in vec3 p, in vec3 a){\n    return length(p.xy-a.xy)*a.z < 1.;\n}\n\nvec3 mapDot(in vec3 p, in vec3 a, in float oInv){\n    p.xy = (p.xy-a.xy)*a.z;\n    oInv *= a.z;\n    float q = (1.-length(p.xy))/(abs(oInv)+0.05);\n    q = 1.- (1.-q)*(smoothstep(1.0,0.9,length(p.xy)));\n    p.z = min(p.z,sqrt(q)*1.05+.003);\n    //p.z = sqrt(p.z*p.z+(1.-length(p.xy))/a.z);\n    \n    \n    \n    return p;\n}\n\n\nfloat proj(vec2 a, vec2 b){\n    return dot(a,b)/dot(b,b);\n}\n\nvec3 roDot(vec3 a,float s){\n    vec3 o = a;\n    float ts = iTime*TAU/SCALE*s/2.;\n    ts += (1.-cos(ts*12.))/8.;\n    o.xy = cmult( a.xy, vec2( sin(ts) , cos(ts) ) );\n    return o;\n}\n\nfloat distDot(in vec3 p, in vec3 a){\n    return length(p.xy-a.xy)-1./a.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\t//vec3 for Reasons(TM)\n\tvec3 uvr = vec3((fragCoord-iResolution.xy*0.5)*2./min(iResolution.x,iResolution.y),3.);\n\n\tint state = S_UNBOUND;\n\t\n\t//Aspect ratio, needed for rectangle splitting.\n\tfloat rr = iResolution.x/iResolution.y;\n    \n    //uvr += vec3(rr,1.,0.)*3.;\n    //uvr.xy /= 4.;\n\t\n\t//Curvature of the last circle we passed through.\n    float inv = 1.;\n\n\t//Bounding circles\n\t//(only pa is allowed to be non-positive on use, and pd/pe are for results)\n    vec3 pa = vec3(0.);\n    vec3 pb = vec3(0.);\n    vec3 pc = vec3(0.);\n    vec3 pd = vec3(0.);\n    vec3 pe = vec3(0.);\n\t\n\tfloat pdm,dir; //used in some flows.\n    \n    \n    vec3 backoff = uvr;\n    float oinv = inv;\n\t\n\tfor(int i=0;i<PASSES;i++){\n        if(abs(inv)*SMALL > min(iResolution.x,iResolution.y)){\n            break;\n        }\n        backoff = uvr;\n        oinv = inv;\n\t\tswitch (state) {\n\t\t\tcase S_UNBOUND: //we're out in the wild somewhere, let's find out where\n\t\t\t\t//Always landscape, just to be sure.\n\t\t\t\tif(rr < 1.){\n\t\t\t\t\t//rotate 90deg and flip aspect ratio.\n\t\t\t\t\tuvr = uvr.yxz * vec3(1.,-1.,1.);\n\t\t\t\t\trr = 1./rr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//number of squares we can fit in here\n\t\t\t\t//(with a 5% fudge factor)\n\t\t\t\tfloat spans = floor(rr+0.05);\n\t\t\t\t//size of our leftover chunks\n\t\t\t\tfloat wings = (rr-spans)/2.;\n\t\t\t\t\n\t\t\t\t//check to see if we're outside the square bounds\n\t\t\t\tif (abs(uvr.x) > spans){\n\t\t\t\t\t//if yes, zoom into that wing and repeat.\n\t\t\t\t\tuvr.x -= (spans+wings)*sign(uvr.x);\n\t\t\t\t\tuvr.xy /= wings;\n\t\t\t\t\tinv /= wings;\n\t\t\t\t\trr = wings;\n\t\t\t\t\t//state is still unbound, no need to change.\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(spans-abs(uvr.x) > 1.){\n\t\t\t\t\t\tstate = S_EXT_EDGE;\n                        //we'll need to define bounds after resolving to a square.\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//Corner has known bounds.  Don't bother setting them.\n\t\t\t\t\t\tstate = S_EXT_CORNER;\n\t\t\t\t\t}\n\t\t\t\t\t//resolve to square.\n\t\t\t\t\tuvr.x = fract( (uvr.x+spans)/2. )*2.-1.;\n\t\t\t\t\t//if we're in a main circle, update state.\n\t\t\t\t\tif(length(uvr.xy) < 1.){\n\t\t\t\t\t\tstate = S_INT_ROOT;\n\t\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\t}else if(state == S_EXT_EDGE){\n                        //Probably don't need this, but just in case...\n\t\t\t\t\t\tpa = vec3(0.);\n\t\t\t\t\t\t//Main circle and one off to one side.\n\t\t\t\t\t\tpb = vec3(0.,0.,1.);\n\t\t\t\t\t\tpc = vec3(2.*sign(uvr.x),0.,1.);\n                    }\n                    \n                    \n\t\t\t\t}\n\n                \n                \n                break;\n\t\t\tcase S_INT_ROOT: //Inside a circle but we haven't done anything yet.\n\t\t\t\t//Check B and C (we know we're in A)\n\t\t\t\t//Root-to-root requires no state change\n\t\t\t\tif(hitDot(uvr,pb)){\n\t\t\t\t\tuvr = mapDot(uvr,pb,inv);\n\t\t\t\t\tinv *= pb.z;\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hitDot(uvr,pc)){\n\t\t\t\t\tuvr = mapDot(uvr,pc,inv);\n\t\t\t\t\tinv *= pc.z;\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//OK, let's generate the new circles and go from there.\n\t\t\t\tpd = cdt(pa,pb,pc,false);\n\t\t\t\tpe = cdt(pa,pb,pc,true);\n        \n\t\t\t\t//Only one of them is useful.  Figure out which one.\n\t\t\t\tpdm = max(pa.z,max(pb.z,pc.z));\n\t\t\t\tif(pd.z <= pdm){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(pe.z - pd.z > 0.1){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(length(uvr.xy-pe.xy) < length(uvr.xy-pd.xy)){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}\n\t\t\t\t//Did we hit our new circle?\n\t\t\t\tif(hitDot(uvr,pd)){\n\t\t\t\t\tuvr = mapDot(uvr,pd,inv);\n\t\t\t\t\tif(pa.z == 0.){\n\t\t\t\t\t\tinv *= -pd.z;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinv *= -pd.z*sign(pa.z);\n\t\t\t\t\t}\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//We didn't hit a circle, let's figure out where we are.\n\t\t\t\t\n\t\t\t\t//We hit a gap! Yey!\n\t\t\t\tif(inTri(pb,pc,pd,uvr)){\n\t\t\t\t\tpa = pd;\n\t\t\t\t\tstate = S_GAP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//We're on an edge.  Less yey.\n\t\t\t\t//Get the ray perpendicular to pd's\n\t\t\t\t//position on the circle,\n\t\t\t\t//oriented so that positive is toward pc\n\t\t\t\tvec2 bcr = pc.xy-pb.xy;\n\t\t\t\tbcr -= pd.xy*proj(pd.xy,bcr);\n\t\t\t\t//Which direction our point is in.\n\t\t\t\t//Can't be zero, or we'd have hit pd.\n\t\t\t\tdir = proj(uvr.xy-pd.xy,bcr);\n\t\t\t\tif(dir > 0.){ //keep pc\n\t\t\t\t\tpb = pd;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{ //keep pb\n\t\t\t\t\tpc = pd;\n\t\t\t\t\tbreak;\t\t\t\t\n\t\t\t\t}\n\t\t\tcase S_EXT_CORNER: //We're in a corner, and it sucks.\n\t\t\t\tpa = vec3(0.); //There's an edge somewhere.\n\t\t\t\tpb = vec3(0.,0.,1.); //And a main circle.\n\t\t\t\t//Corner circle is weird.\n\t\t\t\tpc = vec3(vec2(2.*sqrt(2.)-2.)*sign(uvr.xy), 2.*sqrt(2.) + 3.);\n\t\t\t\t//Check for a hit...\n\t\t\t\tif(hitDot(uvr,pc)){\n\t\t\t\t\tstate = S_INT_ROOT;\n\t\t\t\t\tuvr = mapDot(uvr,pc,inv);\n\t\t\t\t\tinv *= -pc.z;\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//We didn't hit it.  Are we in a smaller corner?\n\t\t\t\tif( sign(uvr.xy-pc.xy) == sign(uvr.xy) ){\n\t\t\t\t\t//Yes. :(\n\t\t\t\t\tuvr.xy = (uvr.xy-pc.xy)*pc.z;\n                    inv *= pc.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//We're on an outside edge.\n\t\t\t\t//That's a problem for the next iteration.\n\t\t\t\tstate = S_EXT_EDGE;\n\t\t\t\tbreak;\n\t\t\tcase S_EXT_EDGE: //Out on a flat edge.\n\t\t\t\tpa = vec3(0.); //Just in case.\n\t\t\t\t//Generate new circles...\t\t\t\t\n\t\t\t\tpd = cdt(pa,pb,pc,false);\n\t\t\t\tpe = cdt(pa,pb,pc,true);\n\t\t\t\t//...and find the useful one\n\t\t\t\tpdm = max(pa.z,max(pb.z,pc.z));\n\t\t\t\tif(pd.z <= pdm){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(pe.z - pd.z > 0.1){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(length(uvr.xy-pe.xy) < length(uvr.xy-pd.xy)){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}\n                \n                /*/debug\n                if(i > 2){\n                fragColor = vec4(sin(length(uvr.xy-pb.xy)*50.),sin(length(uvr.xy-pc.xy)*50.),sin(length(uvr.xy-pd.xy)*50.),0.);\n                return;\n                }\n                //*/\n\t\t\t\t//Did we hit our new circle?\n\t\t\t\tif(hitDot(uvr,pd)){\n\t\t\t\t\tstate = S_INT_ROOT;\n\t\t\t\t\tuvr = mapDot(uvr,pd,inv);\n\t\t\t\t\tinv *= -pd.z;\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//Check for gap.\n\t\t\t\tif(inTri(pb,pc,pd,uvr)){\n\t\t\t\t\tpa = pd;\n\t\t\t\t\tstate = S_GAP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//No gap, check edge.\n\t\t\t\t//Since it's a flat edge, we can cheat.\n\t\t\t\tdir = 0.;\n\t\t\t\tif(abs(uvr.x) < abs(uvr.y)){\n\t\t\t\t\tdir = (uvr.x-pd.x)*(pc.x-pb.x);\n\t\t\t\t}else{\n\t\t\t\t\tdir = (uvr.y-pd.y)*(pc.y-pb.y);\n\t\t\t\t}\n\t\t\t\tif(dir > 0.){ //keep pc\n\t\t\t\t\tpb = pd;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{ //keep pb\n\t\t\t\t\tpc = pd;\n\t\t\t\t\tbreak;\t\t\t\t\n\t\t\t\t}\n\t\t\tcase S_GAP: //Between three bounding circles.  Easy mode.\n\t\t\t\t//Generate new circles...\t\t\t\t\n\t\t\t\tpd = cdt(pa,pb,pc,false);\n\t\t\t\tpe = cdt(pa,pb,pc,true);\n\t\t\t\t//...and find the useful one\n\t\t\t\tpdm = max(pa.z,max(pb.z,pc.z));\n\t\t\t\tif(pd.z <= pdm){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(pe.z - pd.z > 0.1){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}else if(length(uvr.xy-pe.xy) < length(uvr.xy-pd.xy)){\n\t\t\t\t\tpd = pe;\n\t\t\t\t}\n\t\t\t\t//Did we hit our new circle?\n\t\t\t\tif(hitDot(uvr,pd)){\n\t\t\t\t\tstate = S_INT_ROOT;\n\t\t\t\t\tuvr = mapDot(uvr,pd,inv);\n\t\t\t\t\tif(pa.z == 0.){\n\t\t\t\t\t\tinv *= -pd.z;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinv *= -pd.z*sign(pa.z);\n\t\t\t\t\t}\n\t\t\t\t\tpa = vec3(0.,0.,-1.);\n\t\t\t\t\tpb = vec3(0.,-0.5,2.);\n\t\t\t\t\tpc = vec3(0.,0.5,2.);\n\t\t\t\t\tuvr = roDot(uvr,inv);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inTri(pb,pc,pd,uvr)){\n\t\t\t\t\tpa = pd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inTri(pa,pc,pd,uvr)){\n\t\t\t\t\tpb = pd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inTri(pa,pb,pd,uvr)){\n\t\t\t\t\tpc = pd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//This is a thing that Should Not Happen.\n\t\t\t\t//So we're alerting on it.\n\t\t\t\t//fragColor = vec4(1.);\n\t\t\t\t//return;\n\t\t} //end of switch, on to the next iteration.\n        \n        /*/\n        if(i == PASSES-1){\n            fragColor = vec4(float(state%2),float((state/2)%2),float(state/4),0.);\n            return;\n        }\n        //*/\n        \n\t} //end of iteration, on to the actual rendering.\n    \n    //backoff = uvr;\n        \n    if(abs(inv)*SMALL > min(iResolution.x,iResolution.y)){\n        uvr = backoff;\n        inv = oinv;\n    }\n    \n    inv = round(inv);\n    \n    \n    /*\n\n    float run = uvr.z/1.5;\n    //float depth = ((log(abs(inv)+1.)/log(max(iResolution.x,iResolution.y))+1.)-1.)*1.5;\n    float depth = (  log(abs(inv))  /  log(max(iResolution.x,iResolution.y))  );\n    float edge = length(uvr.xy);\n    float cycleTime = fract(iTime/SCALE);\n    \n    float breath = cos(cycleTime*TAU)/3.+2./3.;\n    \n    float starLev = fract(abs(inv)/7.)*7.;\n    float starBreath = cos((cycleTime+starLev/7.)*TAU*6.)/2.+0.5;\n    \n    vec3 hi = mix(C_HI1,C_HI2,breath);\n    //vec3 peak = mix(C_DOT,hi,(1.-edge)*(1.-edge));\n    //vec3 twinkle = mix(peak,C_DOT,starBreath);\n    \n    vec3 dc = mix(C_DOT,hi,run);\n    \n    float pulse = starBreath/2.+0.5;\n    \n    //depth*smoothstep(1.0,0.9,edge)\n    \n    vec3 col = mix(C_BASE,dc,sqrt(depth)*smoothstep(pulse,pulse/2.,edge));\n    */\n    \n    float cycleTime = fract(iTime/SCALE);\n    \n    \n    vec3 base_col = vec3(-1.,1.,cos(inv+cycleTime*TAU));\n    \n    float rz = clamp(sqrt(uvr.z),0.1,0.9);\n\n    vec3 col = (base_col*0.05+rz);\n    \n    \n    \n    \n    \n    //depth*smoothstep(1.0,0.9,edge)\n    //vec3 col = vec3(,run,0.);\n    //col = col * (1.-col)*4.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}