{"ver":"0.1","info":{"id":"dtVyzz","date":"1699909308","viewed":199,"name":"Support Function Ray Casting","username":"kastorp","description":"no SDF or intersector here...\npress bar to toggle perspective on/off, A to toggle computation cost, B to toggle shadows ","likes":27,"published":1,"flags":16,"usePreview":0,"tags":["raycast","minkowski","mpr","hull","gjk","supportfunction"],"hasliked":0,"parentid":"wstyRB","parentname":"Ray vs Support Function"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Support Function Ray Casting\n//-------------------------------------------------------------\n// credits: https://www.shadertoy.com/view/wstyRB by encypruon \n//------------------------------------------------------------\n\n#define R iResolution.xy\n#define SHADOW\n#define TOLERANCE 1e-6\n#define ITERATIONS 30\n#define VAXIS vec3(0,1,0)\n\nstruct obj{\n    vec3 c; //center\n    vec3 b; //bounding box\n    mat3 rm; //rotation matrix \n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 4=segment)\n};\n\n\nstruct simplex{\n    vec3 a,b,c,d; //simplex\n};\n\n\n//-------------------\nmat3 aa2m(vec4 aa){\n    float c =cos(aa.w), s = sin(aa.w), t =1. - c;\n    return outerProduct(aa.xyz,aa.xyz)*t +\n        + mat3 ( c, -aa.z*s, aa.y*s, aa.z*s, c, -aa.x*s, -aa.y*s, aa.x*s, c);\n}\nvec4 m2aa(mat3 m) {//singularities not handled\n    #define mm(a,b) (m[a][b] - m[b][a]) \n    return vec4(normalize(vec3(mm(2,1), mm(0,2), mm(1,0))),\n                acos(( m[0][0] + m[1][1] + m[2][2] - 1.)/2.)); \n}\n//-------------\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\nvec3 supNgon(vec3 d, float n,float v, float h)\n{\n    \n    float a = atan(d.y, d.x);\n    float f = 6.2830 / n;\n    a = (floor(a/f)+.5)*f;\n    return vec3(vec2(cos(a), sin(a))*h, v);\n}\n\nvec3 support(vec3 dir, obj o){\n    const float h=(sqrt(5.)-1.)*.5,h2=h*h;\n    vec3 s= vec3(0);\n    dir=dir*o.rm;\n    switch (o.s) {\n        default:\n        case 0:\n             s= sign(dir)*o.b; //BOX (default)\n             break;\n        case 1: \n             s= normalize(dir*o.b)*(o.b); //ELLIPSOID\n             break;\n        case 2: // CYLINDER\n             s=  supMax( dir,        \n                vec3(normalize(dir.xy)*o.b.x, o.b.y), \n                vec3(normalize(dir.xy)*o.b.x, -o.b.y) \n            );\n            break;\n        case 3: // CONE\n            s=  supMax( dir,        \n                vec3(normalize(dir.xy)*o.b.x, o.b.z) ,\n                vec3(0,0, -o.b.z)\n            );\n            break;\n        case 4: //SEGMENT\n              s=  supMax( dir,o.b ,-o.b) +normalize(dir)*.01; \n              break;\n        case 5: //TETRAHEDRON\n              s=  supMax(dir,\n                          supMax( dir,vec3(o.b),vec3(o.b.x,-o.b.yz)),\n                          supMax( dir,vec3(-o.b.x,o.b.y,-o.b.z),vec3(-o.b.xy,o.b.z))\n                      );\n              break;\n        case 7: //ICOSAHEDRON\n                //h=0.  Tetradecahedron\n              s=  o.b/(1.+h)* supMax(dir,\n                         sign(dir)*vec3(1.,1.+h,0),\n                         supMax(dir, sign(dir)*vec3(0,1.,1.+h),sign(dir)*vec3(1.+h,0,1.))\n                      );\n              break;\n        case 6: //DODECAHEDRON\n               //h=1. romboid dodecahedron                      \n              s=  o.b/(1.+h)* supMax(dir,\n                         supMax(dir, sign(dir)*(1.),sign(dir)*vec3(1.+ h,1.-h2,0)),\n                         supMax(dir, sign(dir)*vec3(0,1. +h,1.-h2),sign(dir)*vec3(1.-h2,0,1.+ h))\n                      );\n             break;\n        case 8: //LOWPOLY SPHERE\n             float a = atan(dir.z, length(dir.xy));\n             float f = 6.2830 / 16.;\n             a = (floor(a/f)+.5)*f;\n             s=  supNgon(dir,16.,sin(a)*o.b.z,cos(a)*o.b.x);                \n             break;\n    }   \n    return s *transpose(o.rm)+ o.c ;\n} \n\n\n\n// adapted from:  https://www.shadertoy.com/view/wstyRB\n//  Casts ray in rd direction from ro, estimates depth and normal \nbool rayVsSupport( obj o,vec3 ro, vec3 rd,out float depth, out vec3 normal , out int it)\n{   \n    vec3 dir, tmp;   \n    simplex _s;\n       \n    //RX=horizontal axis, RY=vertical axis    \n    vec3 rx =normalize(cross(rd,VAXIS)),ry=cross(rx,rd);\n    mat3 rmai=mat3(rx,ry,rd), rma=transpose(rmai); \n    //switch to local coordinates\n    ro*=rmai;\n    rd=vec3(0,0,1);\n    o.c*=rmai; \n    o.rm= rma*o.rm ;  \n    o.c =  cross(cross(rd,ro-o.c),rd); \n    \n    #define perp2d(v)  ((v).yx*vec2(-1,1))  //(cross(v,vec3(0,0,-1)).xy) \n    _s.a=support(vec3(1., 0., 0.),o);\n    if (_s.a.x < 0.) return false;\n    _s.b=support(vec3(-_s.a.xy, 0.),o);\n    if (dot(-_s.a.xy, _s.b.xy) <= 0.) return false;\n    \n    dir = vec3(perp2d(_s.b-_s.a),0.);\n    if (dot(dir.xy, _s.a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = _s.a; _s.a = _s.b; _s.b = tmp;\n    }\n    _s.c=support(dir,o);\n    if (dot(_s.c.xy, dir.xy) <= 0.)\n        return false;\n    \n    for (int i = 0;; ++i)\n    {\n         it++;\n        if (i == 6) return false;\n        if (dot(dir.xy = perp2d(_s.c-_s.a), _s.c.xy) < 0.)\n            {_s.b = _s.c;}\n        else if (dot(dir.xy = perp2d(_s.b-_s.c), _s.c.xy) < 0.)\n             {_s.a = _s.c;}\n        else break; // Origin in triangle -> intersection!\n        \n        _s.c=support(dir,o);    \n        if (dot(_s.c.xy, dir.xy) <= 0.)\n            return false;\n    }\n  \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        it++;\n        dir = normalize(cross(_s.b-_s.a, _s.c-_s.a));\n        //dir*=-1.; // uncomment to get exit point\n        _s.d=support(dir,o);\n\n        if (abs(dot(dir, _s.d) - dot(dir, _s.a)) < TOLERANCE)break;\n\n        // xd = origin left of xd line\n        bool ad = dot(perp2d(_s.d-_s.a), _s.d.xy) > 0.;\n        bool bd = dot(perp2d(_s.d-_s.b), _s.d.xy) > 0.;\n        bool cd = dot(perp2d(_s.d-_s.c), _s.d.xy) > 0.;\n\t\t\n        // Choose triangle that intersects z-axis furthest in z direction\n        if (ad && !bd) {_s.c = _s.d;}\n        else if (bd && !cd) {_s.a = _s.d;}\n        else if (cd && !ad) {_s.b = _s.d;}\n        else break; // Should not happen\n\n\t}\n\n    normal = normalize(cross(_s.b-_s.a, _s.c-_s.a));\n    depth = _s.a.z + dot(_s.a.xy, normal.xy)/normal.z ;\n    normal*=rma;\n    \n    return true;\n}\n\n    \n\nbool trace(vec3 ro, vec3 rd,bool pers,vec2 uv, out vec3 nor, out vec3 pos, out float dist, out int id,out int iter){\n    bool hit=false;\n\n    //THE SCENE:\n     mat3 nr=aa2m(vec4(1,0,0,0.)), //0° rotation\n          pr=aa2m(vec4(1,0,0,3.1416/2.)),//180° rotation\n          pr2=pr*aa2m(vec4(0,0,1,3.1416/4.*iTime));\n          //vec4 aa2=m2aa(pr2); pr2=aa2m(aa2); //check conversion ok\n     obj[] o =  obj[](\n        //center, bounding box, rotation,shape,color\n        obj( vec3(-.3,.35,0), vec3(.15),nr,8), //lowpoly sphere\n        obj( vec3(-.3,0.,0), vec3(.1,.2,.1),nr,0), //box\n        obj( vec3(.3,-.15,0.0),  vec3(.15,.05,.15), nr,1), //ellipsoid\n        obj( vec3(0,-.1,0),  vec3(.1), nr,5), //tetrahedron\n        obj( vec3(0,-.3,0.0),  vec3(.9,.1,.9), nr,0), //base\n        obj( vec3(0,0,-.3),  vec3(.1,.2,.2), pr,2), //cylinder\n        obj( vec3(0,0,.3),  vec3(.1,0,.2), pr,3), //cone\n        obj( vec3(0,-.2,0),  vec3(.4,.4,.0), pr,4), // segment 1\n        obj( vec3(0,-.2,0),  vec3(.4,-.4,.0), pr,4), //segment 2\n        obj( vec3(0, .35,.3),  vec3(.15), pr2,6), //dodecahedron\n        obj( vec3(0, .35,-.3),  vec3(.15), pr2,7) //hexahedron\n    );\n    \n    dist=1e5; \n    \n    vec3 rx =normalize(cross(rd,VAXIS)),\n         ry =cross(rx,rd);\n   \n    vec3 ro2=ro;\n    if(pers){\n            \n        rd=normalize(rd+uv.x*rx+uv.y*ry); \n    }else{\n        rd=-normalize(ro);\n        ro2= uv.x*rx+uv.y*ry;\n    }\n    \n    for(int i=min(0,iFrame);i<o.length();i++){\n          vec3 n,p; int it;\n          float d=-1e5;\n           obj oo=o[i];\n            int res= int(rayVsSupport(oo,ro2,rd,d, n,iter));\n            d= pers?  (dot(oo.c-ro2,rd) -d):\n                        (dot(oo.c,rd) -d) ;\n            p =ro2 + d*rd;\n            res=  d >0.|| res==0 ? res: 2;\n\n          if( (pers? res==1 :res!=0) ){\n              d=length(p-ro);\n              hit=true;\n              if(d<dist){nor=n;pos=p;id=i; dist=d;}     \n          }\n    }\n    return hit;\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 uv = (I - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 M = iMouse.z>0.?(iMouse.xy - 0.5 * iResolution.xy) / iResolution.y:vec2(iTime*.2,0.5);\n    \n    vec3 ro = vec3(0,M.y+.5,0. )+ 1.*vec3(cos(M.x*3.14),0,sin(M.x*3.14));\n    bool pers=texelFetch(iChannel3,ivec2(32,2),0).x<.5;\n    O=vec4(0);\n    vec3 rd0=-normalize(ro);  \n    \n    vec3 nor,pos;\n    float dist; int iter=0,id;\n    bool hit=trace(ro,rd0,pers,uv,nor,pos,dist,id,iter);\n    \n    if (hit){\n       vec3 ld=normalize(vec3(1,1,1.5));\n       float gr = max(max(sin(pos.x*62.8),sin(pos.y*62.8)),sin(pos.z*62.8));\n       vec3 col= .3*cos(vec3(0,2,4)+ float(id)*6./8.)+.6;\n       O = vec4(col,1.) * (.6+ smoothstep(1.,1.-min(fwidth(gr),.1),gr)*.1 - dot(nor,ld)*.3);\n               \n       if(texelFetch(iChannel3,ivec2(66,2),0).x<.5){\n            bool sh =dot(nor,ld)>=-0. || trace(pos+ld*TOLERANCE,ld,true,vec2(0),nor,pos,dist,id,iter);\n            if(sh )O*=.5;\n       }\n    } \n    if(texelFetch(iChannel3,ivec2(65,2),0).x>.5){\n        //debug cost\n        O=vec4( iter)/70.;\n    }\n   \n}","name":"Image","description":"","type":"image"}]}