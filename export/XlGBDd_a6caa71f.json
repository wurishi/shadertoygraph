{"ver":"0.1","info":{"id":"XlGBDd","date":"1544459400","viewed":225,"name":"VoronoiSorting","username":"Falko","description":"I tried to speed up computations involving randomly distributed points by presorting them and assigning them to grid cells. Then each pixel can perform computations only with those points in closeby cells. Voronoi noise as example application.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","sorting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int nEdge = 16;\nconst int nMols = nEdge*nEdge;\nconst int nBins = 8;\nconst float radius = 0.01;\n\n\nfloat random(float x){     \n    return fract(sin(x*127.123)*433758.177);\n    }\n\n\n\nvec4 getDisk(int i){\n    return texelFetch(iChannel0, ivec2(i,0), 0);\n}\n\n\n\nint binarySearch(float binID){\n    //binary search of sorted buffer\n \tint b0 = 0;\n    int b1 = nMols-1;\n    int bMid;\n    float currentID;\n    \n    while(b0<b1){\n        bMid = (b0+b1)/2;\n        currentID = getDisk(bMid).z;\n        \n        if(currentID-binID>0.1){\n            b0 = bMid+1;\n        }\n        else if(currentID-binID<-0.1){\n         \tb1 = bMid-1;   \n        }\n        else{\n            return bMid;\n        }\n    }\n    \n    return -1;\n}\n\n\n\n\n\n\n\n\n\n\nvec2 move(vec2 center, float angle){\n    //return perturbed position\n    vec2 disp = 0.01*sin(10.0*iTime+113.237*random(center.x))\n        \t\t\t* vec2(cos(angle), sin(angle));\n \treturn center + disp;   \n}\n\nvec2 swap(vec2 v){\n \tfloat temp = v.x;\n    v.x = v.y;\n    v.y = temp;\n    return v;\n}\n\nvec2 closest(vec2 uv, int m, float binPixel, vec2 minDist){\n    //find distances of closest two points\n    vec2 position;\n    float binID;\n    vec4 Disk;\n    float dist;\n    \n    int i = 0;\n    Disk = getDisk(m+i);\n    binID = Disk.z;\n    \n    while(abs(binID-binPixel)<0.1 && m+i<nMols){\n        position = move(Disk.xy, Disk.w);\n        dist = length(uv-position);\n        minDist.y = min(dist, minDist.y);\n        if(minDist.y<minDist.x){\n            minDist = swap(minDist);\n        }\n        \n        i += 1;\n    \tDisk = getDisk(m+i);\n    \tbinID = Disk.z;\n    }\n    \n    i = -1;\n    Disk = getDisk(m+i);\n    binID = Disk.z;\n    while(abs(binID-binPixel)<0.1 && m+i>-1){\n        position = move(Disk.xy, Disk.w);\n        dist = length(uv-position);\n        \n        minDist.y = min(dist, minDist.y);\n        if(minDist.y<minDist.x){\n            minDist = swap(minDist);\n        }\n        \n        i -= 1;\n    \tDisk = getDisk(m+i);\n    \tbinID = Disk.z;\n    }\n    \n    //distance to outer circle\n    minDist.y = min(abs(length(uv-0.5)-0.4), minDist.y);\n    if(minDist.y<minDist.x){\n            minDist = swap(minDist);\n    }\n    \n    return minDist;\n    \t\n}\n\nvec3 drawVoronoi(vec2 uv, float pixSize){\n    \n    vec3 color = vec3(1.0);\n   \n    if(length(uv-0.5)>0.38+pixSize){\n        return color;\n    }\n    \t\n    vec2 centerCorner = floor(uv*float(nBins)+0.5);\n    vec2 corner;\n    vec2 overflow;\n    \n    float binPixel;\n    int m;\n    \n    vec2 minDist = vec2(1000.0);\n    for(float i = 0.0; i>=-1.0; i--){\n        for(float j = 0.0; j>=-1.0; j--){\n            corner = centerCorner + vec2(i, j);\n            corner = mod(corner, float(nBins));\n\n            binPixel = corner.x*float(nBins) + corner.y;\n            \n            m = binarySearch(binPixel);\n            \n            if(m>=0){\n               \tminDist = closest(uv, m, binPixel, minDist);\n\n            }\n        }\n    }\n    float f = 1.6*abs(minDist.x-minDist.y);\n    float s = smoothstep(0.38, 0.38+pixSize, length(uv-0.5));\n    return mix(color*(f*float(nEdge)), color, s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //integer texture coordinates\n    ivec2 texCoord = ivec2(fragCoord-0.5);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tfloat pixSize = 1.0/iResolution.y;\n \n    if (abs(uv.x)>1.0){\n        discard;\n    }\n    else{\n        uv = 0.5*(1.0+uv);\n        vec3 color = drawVoronoi(uv, pixSize);\n        \n        fragColor = vec4(color,1.0);\n        }\n     \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int nEdge = 16;\nconst int nMols = nEdge*nEdge;\nconst int nBins = 8;\nconst int frameEndSort = 300;\nconst int frameStartSort = 2;\n\n//initialization and parallel sorting first buffer\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> uint(4));\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> uint(15));\n    return seed;\n}\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\n\n\nfloat bin(vec2 position){\n \t  \tvec2 lowerEdge = floor(position*float(nBins));\n   \t\treturn lowerEdge.x*float(nBins)+lowerEdge.y;\n}\n\nvec4 maxOp(vec4 Disk0, vec4 Disk1){\n    if(Disk0.z>Disk1.z){\n     \treturn Disk0;\n    }\n    else{\n        return Disk1;\n    }\n    \n}\n\nvec4 minOp(vec4 Disk0, vec4 Disk1){\n    if(Disk0.z<Disk1.z){\n     \treturn Disk0;\n    }\n    else{\n        return Disk1;\n    }\n    \n}\n\nvec4 sort(int index){\n    vec4 Disk0 = texelFetch(iChannel0,\n                            ivec2(index, 0),\n    \t                      0);\n    \n    vec4 Disk1;\n    \n    if(mod(float(index), 2.0)==0.0){\n        Disk1 = texelFetch(iChannel0,\n                           ivec2(index+1, 0),\n                           0);\n        return maxOp(Disk0, Disk1);\n    }\n    else{\n        Disk1 = texelFetch(iChannel0,\n                           ivec2(index-1, 0),\n                           0);\n        return minOp(Disk0, Disk1);\n    }\n}\n\n\nvec2 genPositionCircular(uint seed){\n    uint r = wangHash(seed);\n    vec2 position;      \n    position.x = float(r) * (1.0 / 4294967296.0);\n    r = wangHash(r);\n    position.y = float(r) * (1.0 / 4294967296.0);\n    \n    position = asin(sin(position));\n    int i = 0;\n    while(length(position-0.5)>0.4 && i<20){\n     \tr = wangHash(r);\n        position.x = float(r) * (1.0 / 4294967296.0);\n    \tr = wangHash(r);\n        position.y = float(r) * (1.0 / 4294967296.0);  \n        position = asin(sin(position));\n        i +=1;\n    }\n    \n    return position;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    ivec2 texCoord = ivec2(fragCoord-0.5);\n    uint seed = uint(texCoord.x+13);\n    \n    if(texCoord.y>0 || texCoord.x>=nMols){\n       \tdiscard;\n    }\n    else{\n        if(iFrame<frameStartSort){\n            vec2 position = genPositionCircular(seed);\n            float angle = float(wangHash(seed)) * (1.0 / 4294967296.0);\n            fragColor = vec4(position, \n                             bin(position), \n                             asin(sin(angle))*2.0*pi());\n        }\n        else if(iFrame<frameEndSort){\n            \n         \tfragColor =  sort(texCoord.x);  \n        }\n        else{\n            discard;\n        }\n        \n    }        \n            \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int nEdge = 16;\nconst int nMols = nEdge*nEdge;\nconst int nBins = 8;\nconst int frameEndSort = 300;\nconst int frameStartSort = 2;\n\n//parallel sorting second buffer\n\nvec4 maxOp(vec4 Disk0, vec4 Disk1){\n    if(Disk0.z>Disk1.z){\n     \treturn Disk0;\n    }\n    else{\n        return Disk1;\n    }\n    \n}\n\nvec4 minOp(vec4 Disk0, vec4 Disk1){\n    if(Disk0.z<Disk1.z){\n     \treturn Disk0;\n    }\n    else{\n        return Disk1;\n    }\n    \n}\n\n\n\nvec4 sort(int index){\n    vec4 Disk0 = texelFetch(iChannel0,\n                            ivec2(index, 0),\n                            0);\n    vec4 Disk1;\n    if(index == 0 || index == nMols-1){\n     \treturn Disk0; \n    }\n    else if(mod(float(index), 2.0)==0.0){\n        Disk1 = texelFetch(iChannel0,\n                           ivec2(index-1, 0),\n                           0);\n        return minOp(Disk0, Disk1);\n    }\n    else{\n        Disk1 = texelFetch(iChannel0,\n                           ivec2(index+1, 0),\n                           0);\n        return maxOp(Disk0, Disk1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 texCoord = ivec2(fragCoord-0.5);\n    \n    \n    if(texCoord.y>0 || texCoord.x>=nMols){\n       \tdiscard;\n    }\n    else{\n        if(iFrame<frameStartSort){\n            \n        \tfragColor = texelFetch(iChannel0,\n                                   texCoord,\n                                   0);\n        }\n        else if(iFrame<frameEndSort){\n            \n         \tfragColor =  sort(texCoord.x);  \n        }\n        else{\n            discard;\n        }\n    }\n   \n}","name":"Buffer B","description":"","type":"buffer"}]}