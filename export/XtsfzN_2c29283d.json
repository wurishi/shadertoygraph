{"ver":"0.1","info":{"id":"XtsfzN","date":"1511298173","viewed":253,"name":"Basic 3D Shader","username":"PeterTheGreat","description":"First 3D Shadertoy!\n\nChange MOUSE_INPUT on line 7 to true to use the horizontal position of the cursor to change the number of points drawn between vertices.","likes":10,"published":1,"flags":64,"usePreview":0,"tags":["3d","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsjXzz","filepath":"https://soundcloud.com/omnitica/spacebard1","previewfilepath":"https://soundcloud.com/omnitica/spacebard1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define PHI 1.61803398875\n#define EPSILON .0001\n//If MOUSE_INPUT is set to true, the x coordinate of the mouse determines the \n// number of points drawn between the verticies. If false, the number of points\n// will cyclically change over time.\n#define MOUSE_INPUT false\n\n#define DrawPoint(A,D,P,r) smoothstep( r, r - .01, length(cross(P-A, D)) / length(D) )\n#define DistToLine(A1,D1,A2,D2) abs( dot(A2 - A1, cross(D1, D2))) / length(cross(D1, D2))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int CUBE_SIZE = 20; \n\n    vec3 cube[] = vec3[](\n    \tvec3(.5, .5, .5),\n    \tvec3(.5, .5, -.5),\n    \tvec3(.5, -.5, .5),\n    \tvec3(.5, -.5, -.5),\n    \tvec3(-.5, .5, .5),\n    \tvec3(-.5, .5, -.5),\n    \tvec3(-.5, -.5, .5),\n    \tvec3(-.5, -.5, -.5),\n    \tvec3(0., .5 * PHI, .5 / PHI),\n    \tvec3(0., .5 * PHI, -.5 / PHI),\n    \tvec3(0., -.5 * PHI, .5 / PHI),\n    \tvec3(0., -.5 * PHI, -.5 / PHI),\n    \tvec3(.5 / PHI, 0, .5 * PHI),\n    \tvec3(.5 / PHI, 0, -.5 * PHI),\n    \tvec3(-.5 / PHI, 0, .5 * PHI),\n    \tvec3(-.5 / PHI, 0, -.5 * PHI),\n    \tvec3(.5 * PHI, .5 / PHI, 0),\n    \tvec3(.5 * PHI, -.5 / PHI, 0),\n    \tvec3(-.5 * PHI, .5 / PHI, 0),\n    \tvec3(-.5 * PHI, -.5 / PHI, 0)\n    );\n    \n\tvec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 origin = 7. * vec3(2.5 * sin(t / 2.), 1.5 + sin(t / .8) / 2., -2.5 * sin(t / (PI / 3.)));\n    \n    vec3 cameraFocus = vec3(0.);\n    \n    float zoom = 5. + sin(t) / 3.;\n    \n    vec3 f = normalize(cameraFocus - origin);\n    vec3 r = vec3(f.z, 0., -f.x);\n    vec3 u = cross(f, r);\n    \n    vec3 center = origin + f * zoom;\n    vec3 i = center + uv.x * r + uv.y * u;\n    vec3 direction = i - origin;\n    \n    vec3 point = vec3(0. + cos(t), 0., 1. + sin(t));\n    \n    float radius = .03;\n    \n    float d = 0.;\n    \n    float numDots;\n    if (MOUSE_INPUT)\n        numDots = floor(iMouse.x * .06);\n    else\n        numDots = 26. + round(25. * sin(t / 5.));\n   \n    for (int i = 0; i < CUBE_SIZE; ++ i)\n        for (int j = 0; j < CUBE_SIZE; ++ j)\n            if (i != j && (abs(length(cube[i] - cube[j]) - 1. / PHI) < EPSILON) && DistToLine(origin, direction, cube[i], cube[j] - cube[i]) < radius)\n                for (float k = 0.; k < numDots; ++ k)\n                    if (d < 1.)\n                        d += DrawPoint(origin, direction, (k * cube[i] + (numDots - k) * cube[j]) / numDots, radius) / 15.;\n    \n    d += .25;\n    \n    uv *= 15. / zoom;\n    fragColor = vec4(vec3(d), 0.) / 2.;\n    \n    if (d > .3)\n    \tfragColor += d * vec4(uv,0.5+0.5*sin(iTime),1.0) / 2.;\n}","name":"Image","description":"","type":"image"}]}