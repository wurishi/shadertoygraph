{"ver":"0.1","info":{"id":"DldcDH","date":"1699171241","viewed":42,"name":"Edge Detection Canny & Sobel","username":"Fuergu","description":"reference:\nhttps://www.shadertoy.com/view/dtcSzM\nhttps://www.shadertoy.com/view/wl2cW3","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*****************************************************\nInteraction enabled\n\nChange source image in Buffer A, not here.\n\n*****************************************************/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float textureWidth = 1.0 / 3.0;\n    int textureIndex = int(uv.x * 3.0);\n    vec2 texCoord = vec2((uv.x * 3.0 - float(textureIndex)) * textureWidth, uv.y);\n    \n\n    \n    // separate into 3 part\n    vec4 color;\n    if (textureIndex == 0) {\n        color = texture(iChannel1, texCoord); // Gaussian filter\n    } else if (textureIndex == 1) {\n        color = texture(iChannel2, texCoord); // Sobel \n    } else if (textureIndex == 2) {\n        color = texture(iChannel3, texCoord); // Canny \n    }\n    // Full screen display of selected area\n    if (iMouse.w>0. && textureIndex == int(iMouse.x/iResolution.x * 3.0)) {\n        texCoord = vec2(uv.x, uv.y * iResolution.y / iResolution.x);\n    }\n    if(iMouse.z>0. && int(abs(iMouse.z)/iResolution.x * 3.) ==0)\n    {\n    color=texture(iChannel1, uv);\n    }\n    if(iMouse.z>0. && int(abs(iMouse.z)/iResolution.x * 3.) ==1)\n    {\n    color=texture(iChannel2, uv);\n    }\n    if(iMouse.z>0. && int(abs(iMouse.z)/iResolution.x * 3.) ==2)\n    {\n    color=texture(iChannel3, uv);\n    }\n    // 输出纹素颜色\n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gaussian filter\n// Actual kernel width is (2*k + 1)\nconst int k = 2;\nconst float stddev = 1.;\n\nconst float expCoef = 0.15915494309189535;\nvec4 guassianFilter(sampler2D channel, ivec2 coord) {\n\n    //adjust position (unneccesary when using image)\n    coord.x*=2;\n    coord.x+=30;\n    coord.y+=1035;\n    \n    int width = (2*k + 1);\n    vec4 total = vec4(0.0);\n    for (int i = 1; i <= width; i++) {\n        for (int j = 1; j <= width; j++) {\n            float mag = float((i-(k+1))*(i-(k+1)) + (j-(k+1))*(j-(k+1)));\n            float coefficient = (expCoef/(stddev*stddev))*exp(-mag/(2.0*(stddev*stddev)));\n            total += coefficient * texelFetch(channel, (coord + ivec2(i-(k+1),j-(k+1))) % textureSize(channel, 0), 0);\n        }\n    }\n    return total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = guassianFilter(iChannel0, ivec2(fragCoord));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sobel operator\nfloat toGray(vec4 color) {\n    return 0.2126*color.x + 0.7152*color.y + 0.0722*color.z;\n}\n\nconst mat3 sobelMatrixX = mat3(\n   1.0, 2.0, 1.0,\n   0.0, 0.0, 0.0,\n   -1.0, -2.0, -1.0\n);\nconst mat3 sobelMatrixY = mat3(\n   1.0, 0.0, -1.0,\n   2.0, 0.0, -2.0,\n   1.0, 0.0, -1.0\n);\nvec2 sobel(sampler2D channel, ivec2 coord) {\n    vec2 g = vec2(0.0);\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 coef = vec2(sobelMatrixX[i][j],sobelMatrixY[i][j]);\n            g += coef*toGray(texelFetch(channel, coord+ivec2(i-1,j-1), 0));\n        }\n    }\n    return g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color = vec4(sobel(iChannel1, ivec2(fragCoord)).x,sobel(iChannel1, ivec2(fragCoord)).y,0.,0.);\n    if(iMouse.z>0.){\n    Color.x*=iMouse.x/iResolution.x;\n    Color.y*=iMouse.y/iResolution.y;\n    }else{\n    Color.x*=cos(iTime)*1.2;\n    Color.y*=sin(iTime)*1.2;\n    }\n    fragColor=Color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Thresholding and edge tracking\n// Threshold values range from 0-1\n\n// sets RGB based on edge angle\n#define COLOR_ANGLE 0\n#define OUTLINE_COL 0.0f,0.5f,1.0f\n\nbool hasStrong(sampler2D channel, ivec2 coord) {\n    bool strong = false;\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(0,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,0), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,0), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(0,1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,1), 0).x > 0.5);\n    return strong;\n}\n\nbool threshold(float angle, sampler2D channel, ivec2 coord) {\n    if (angle < 22.5 || angle >= 157.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,0), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,0), 0));\n        return current >= left && current >= right;\n    } else if (angle < 67.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,-1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,1), 0));\n        return current >= left && current >= right;\n    } else if (angle < 112.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(0,-1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(0,1), 0));\n        return current >= left && current >= right;\n    } else if (angle < 157.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,-1), 0));\n        return current >= left && current >= right;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 sobel = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    float mag = length(sobel.xy);\n    float angle = 57.2957795131*abs(atan(sobel.y,sobel.x));\n    \n    bool isMax = threshold(angle, iChannel2, ivec2(fragCoord));\n    vec4 thresholded = vec4(0.0,0.0,0.0,1.0);\n    if (iMouse.z>0.){\n        if (isMax && mag >= 0.5*iMouse.y/iResolution.y) {\n            thresholded = vec4(1.0);\n        } else if (isMax && mag >= .5*iMouse.x/iResolution.x && hasStrong(iChannel3, ivec2(fragCoord))) {\n            thresholded = vec4(1.0);\n        }\n    }\n    else{\n        if (isMax && mag >= .4) {\n            thresholded = vec4(1.);\n        } else if (isMax && mag >= .4 && hasStrong(iChannel3, ivec2(fragCoord))) {\n            thresholded = vec4(1.);\n        }\n    }\n    \n    #if COLOR_ANGLE\n        vec3 outlineCol = vec3(sin(angle), sin(angle + 2.0f*M_PI/3.0f),sin(angle + 2.f*M_PI/3.0f * 2.0f));\n\t#else\n        vec3 outlineCol = vec3(OUTLINE_COL);\n    #endif\n    //highlight edges of different direction\n    outlineCol/=(angle)/110.;\n    // Output to screen\n    fragColor = vec4(outlineCol*float(thresholded),1.);   \n}","name":"Buffer C","description":"","type":"buffer"}]}