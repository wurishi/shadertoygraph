{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//http://mrl.nyu.edu/~perlin/flownoise-talk/#17\n\n\nvec4 dnoise(vec3 p);\n\nvec4 quat_rotation( float half_angr, vec3 unitVec );\n\nvec2 screen_uv;\nvec4 quat;\n\nfloat Checker2(vec2 uv)\n{\n\tfloat s = sin(uv.x)*cos(uv.y);\n\t//s = s*s*s*s*s;\n\treturn s;\n}\n\nvec4 FlowNoise(vec3 uvw, vec2 uv)\n{\n\tvec4 n = vec4(0.);\n\n\tfloat f = 1.;\n\tfloat a = 1.;\n\t\t\t\n\tfloat lac = 2.13;\n\t\n#if 0\t\n\tfor (int i=0; i<5; i++)\n\t{\t\n\t\t//offsetting swirl angle relative to position seems to flow along the gradient\n\t\tfloat ang = iTime*.4;//+uv.y*0.5;\n\t\t\n\t\tang *= Checker2(uvw.xy*0.0125);\n\t\t\n\t\tvec3 ax = normalize(vec3(1,1,1)); \n//\t\tvec3 ax = texture(iChannel0,vec2(float(i)*0.1,0.)).xyz*2.-1.;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\n\t\tfloat e = 0.1;//*f;\n\t\t\n\t\t//advect by going back in domain along noise gradient\n\t\tvec4 dn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\t\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t}\n#else\n\tvec3 ax = normalize(vec3(1,1,1)); \n\tfloat e = 0.1;//*f;\n\tfloat ang;\n\tvec4 dn;\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t\n#endif\n\t\n\treturn n;\n}\n\t\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tuv.x *= iResolution.x/iResolution.y;\t\n\tuv.y = 1. - uv.y;\n\tscreen_uv = uv;\n\t\n\tfloat t = iTime*0.8;\n\tvec3 uvw = vec3(uv*1.15+vec2(0.,t),t*0.5);\n\n\n\tvec4 d = FlowNoise(uvw,uv);\n\tfloat de = d.w;\n\tde = length(d.xyz)*.15+.2-d.w*.2;\n\tvec3 n = FlameColour(de);\n\n\t\n\tfragColor = vec4(vec3(n),1.0);\n}\n\nvec4 quat_rotation( float half_angr, vec3 unitVec )\n{\n    float s, c;\n    s = sin( half_angr );\n    c = cos( half_angr );\n    return vec4( unitVec*s, c );\n}\n\nvec3 quat_times_vec(vec4 q, vec3 v)\n{\n\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n/* Created by Nikita Miropolskiy, nikat/2013\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/XsX3zB).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) \n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\tr = r-0.5;\n\n\t\n\t//rotate for extra flow!\n\tr=quat_times_vec(quat,r);\n\t\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec4 dnoise(vec3 p) \n{\n\t /* 1. find current tetrahedron T and its four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t vec3 s = floor(p + (p.x+p.y+p.z)*F3);\n\t vec3 x = p - s + (s.x+s.y+s.z)*G3;\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \t\t \n\t /* calculate surflet weights */\n\t vec4 w;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\t\t//aka t0,t1,t2,t3\n\t vec4 w2 = w*w;\t\t\t\t//aka t20,t21,t22,t23\n\t vec4 w4 = w2*w2;\t\t\t//aka t40,t41,t42,t43\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec3 g0 = random3(s);\n\t vec3 g1 = random3(s + i1);\n\t vec3 g2 = random3(s + i2);\n\t vec3 g3 = random3(s + 1.0);\n\t \n\t vec4 d;\n\t /* calculate surflet components */\n\t d.x = dot(g0, x);\t\t//aka graddotp3( gx0, gy0, gz0, x0, y0, z0 )\n\t d.y = dot(g1, x1);\n\t d.z = dot(g2, x2);\n\t d.w = dot(g3, x3);\n\t \n\t //derivatives as per\n\t //http://webstaff.itn.liu.se/~stegu/aqsis/flownoisedemo/srdnoise23.c\n\t vec4 w3 = w*w2;\n\t vec4 temp = w3*d;\n\t vec3 dnoise = temp[0]*x;\n\t     dnoise += temp[1]*x1;\n\t     dnoise += temp[2]*x2;\n\t\t dnoise += temp[3]*x3;\n\t\t dnoise *= -8.;\n\t\t dnoise += w4[0]*g0+w4[1]*g1+w4[2]*g2+w4[3]*g3;\n\t\t dnoise *= 52.; //???\n\t\t \n\t d *= w4;\t//aka n0,n1,n2,n3\n\t \n\tfloat n = (d.x+d.y+d.z+d.w)*52.;\n\t\n\treturn vec4(dnoise,n);\n}\n\n//http://www.csee.umbc.edu/~olano/s2002c36/ch02.pdf\n// t = 0.6 - (u^2+v^2+w^2)\n// if (t>0) 8 t^4 else 0\n\t","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23Wc","date":"1394705121","viewed":4818,"name":"FlowNoiseFire","username":"Antonalog","description":"firey flow noise..Took nikat's simplex noise, added analytic derivatves, couldn't resist making yet another fire effect.","likes":88,"published":1,"flags":0,"usePreview":1,"tags":["noise","fire","flow"],"hasliked":0,"parentid":"","parentname":""}}