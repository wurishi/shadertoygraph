{"ver":"0.1","info":{"id":"4tGfRd","date":"1543731899","viewed":570,"name":"TAA w/ Dynamic Scene.","username":"slembcke","description":"A novice attempt at TAA with dynamic elements. Some params in \"Common\", Scene in \"Buffer A\", TAA in \"Buffer B\", resolve and gamma in \"Image\".","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["taa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Magnifier lens.\n    if(length(fragCoord - iMouse.xy) < 200.0){\n        fragCoord = (fragCoord - iMouse.xy)/4.0 + iMouse.xy;\n    }\n    \n    // Sample from the buffer.\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 accum = texture(iChannel0, uv);\n    \n    // Resolve.\n    float i = pow(accum.r/accum.a, GAMMA_CORRECTION);\n\tfragColor = vec4(i, i, i, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 scroll_bottom(int n){\n    float t = float(n)/100.0;\n    return 100.0*vec2(cos(t), sin(t));\n}\n\nvec2 scroll_top(int n){\n    float t = -float(n)/50.0;\n    return 50.0*vec2(cos(t), sin(t));\n}\n\n// Red is b/w intensity\n// Green/Blue will be velocity when I get to moving objects?\n// Alpha is the total blend weight.\nvec4 scene_func(vec2 jitteredCoord){\n    vec4 pixel;\n    \n    {\n        vec2 scroll0 = scroll_bottom(iFrame);\n        vec2 uv2 = 2.0*fract((jitteredCoord + scroll0)/32.0) - 1.0;\n\t    float dist = step(0.0, sin(20.0*length(uv2)));\n\t\t\n        vec2 offset = scroll0 - scroll_bottom(iFrame - 1);\n        pixel = vec4(dist, offset, 1.0);\n    }{\n        vec2 scroll0 = scroll_top(iFrame);\n        vec2 uv2 = 2.0*fract((jitteredCoord + scroll0)/256.0) - 1.0;\n        float mask = 1.0 - step(0.5, length(uv2));\n\t\t\n        vec2 offset = scroll0 - scroll_top(iFrame - 1);\n        pixel = mix(pixel, vec4(step(0.0, sin(60.0*length(uv2))), offset, 1.0), mask);\n    }\n    \n    return pixel;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Render scene.\n    vec2 jitteredCoord = fragCoord + jitter(iFrame);\n    fragColor = scene_func(jitteredCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// I stole this from: https://www.shadertoy.com/view/MtVGWz\n// This can be done in 4 bilinear samples instead:\n// http://www.decarpentier.nl/2d-catmull-rom-in-4-samples\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 uv, vec2 texSize )\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / (w1 + w2);\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\nvoid bounds(in vec2 fragCoord, inout float min_bound, inout float max_bound){\n    float value = texture(iChannel0, fragCoord/iResolution.xy).r;\n    min_bound = min(min_bound, value);\n    max_bound = max(max_bound, value);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 unjitter = jitter(iFrame);\n    vec4 scene = SampleTextureCatmullRom(iChannel0, (fragCoord - unjitter)/iResolution.xy, iResolution.xy);\n    \n    // Calculate bounds for clamping history based on 3x3 cross.\n    float min_bound = 1.0, max_bound = 0.0;\n    bounds(fragCoord + vec2(-1,  0), min_bound, max_bound);\n    bounds(fragCoord + vec2( 1,  0), min_bound, max_bound);\n    bounds(fragCoord + vec2( 0, -1), min_bound, max_bound);\n    bounds(fragCoord + vec2( 0,  1), min_bound, max_bound);\n    \n\t// Reproject coord into previous frame and clip.\n\tvec2 prevUV = (fragCoord + scene.gb)/iResolution.xy;\n\tvec4 accum = SampleTextureCatmullRom(iChannel1, prevUV, iResolution.xy);\n\tvec2 clip = step(0.0, prevUV) - step(1.0, prevUV);\n\taccum *= clip.x*clip.y;\n    \n    // TODO the Inside doc says to clip, not clamp.\n    // Seems to work passably anyway?\n    accum.r = clamp(accum.r, min_bound, max_bound*accum.a);\n\t\n\t// Blend with previous frames.\n\t// Simple exponential decay seems to work ok.\n\tfragColor = DECAY_FACTOR*accum + scene;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nLooks much better with gamma correction disabled.\nNot sure if that means I did something wrong. :-\\\n\n90% of my info for this came from the Inside GDC presentation.\nhttp://twvideo01.ubm-us.net/o1/vault/gdc2016/Presentations/Pedersen_LasseJonFuglsang_TemporalReprojectionAntiAliasing.pdf\n*/\n\n#define DECAY_FACTOR 0.8\n//#define DECAY_FACTOR 0.0 // Disable AA\n\n#define GAMMA_CORRECTION (1.0/2.2)\n//#define GAMMA_CORRECTION (1.0) // Disable gamma correction\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst vec2 JITTER = vec2(0.7548776662466927, 0.5698402909980532);\nvec2 jitter(int n){return fract(JITTER*vec2(n)) - 0.5;}\n","name":"Common","description":"","type":"common"}]}