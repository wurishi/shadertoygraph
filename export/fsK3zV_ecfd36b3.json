{"ver":"0.1","info":{"id":"fsK3zV","date":"1632760225","viewed":247,"name":"Colouring Box","username":"shau","description":"A box. inspired by echo - FabriceNeyret2","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * inspired by echo - FabriceNeyret2\n * https://www.shadertoy.com/view/Xty3Wz\n */\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .005\n#define FAR 200.\n\n#define AT mod(T*8.0,1.0)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nfloat transition()\n{\n    float at = mod(T,60.0);\n    return smoothstep(14.0,16.0,at)*smoothstep(36.0,34.0,at);\n}\n\n//IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 map(vec3 p) \n{\n    p.x += AT;\n    vec2 fl = floor(p.xy)+0.5;\n    vec2 fr = fract(p.xy)-0.5;    \n    p.xy = fr;\n    p.yz *= rot(1.570579*transition());\n    float t = sdBox(p,vec3(0.4));\n    return vec4(t,vec3(fl,0.0));\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec4 march(vec3 ro, vec3 rd) \n{\n    vec3 id  = vec3(0);\n    float t = 0.0;   \n    for (int i=ZERO; i<100; i++)\n    {\n        vec4 ns = map(ro + rd*t);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.yzw;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec4(t,id);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float at = mod(T,60.0);\n    vec3 pc = vec3(0),\n         la = vec3(0),\n         lp = vec3(7,10,-20),\n         ro = vec3(3.7+sin(3.0+T*0.3)*14.0,2.0+sin(T*0.2)*5.0,-30);\n    \n    ro.z += smoothstep(8.0,13.0,at)*smoothstep(48.0,43.0,at)*25.0 - \n            smoothstep(17.0,25.0,at)*smoothstep(36.0,30.0,at)*15.0;\n    vec3 rd = camera(U,ro,la,1.4);\n    \n    vec4 s = march(ro,rd);\n    if (s.x>0.0)\n    {\n        vec3 p = ro + rd*s.x;\n        vec3 n = normal(p);\n        vec3 ld = normalize(lp-p);\n        float ao = AO(p,n);\n        float sh = calcSoftshadow(p+n*EPS,ld,EPS,10.0,0);\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),32.0);\n        float fres = pow(clamp(dot(n,rd)+1.0,0.0,1.0),4.0);\n        vec2 fl = floor(p.xy)+0.5;\n        vec3 col = texture(iChannel0,fl*0.00625+vec2(0.5)).xyz;\n        vec3 bgCol = mix(vec3(0.01),vec3(0.5),transition());\n        p.x += AT;\n        float lc = length(s.yzw-p);\n        pc = bgCol*max(0.0,dot(ld,n));\n        pc += texture(iChannel1,reflect(rd,n)).xyz*(fres+spec)*\n                      smoothstep(18.0,3.0,abs(ro.z));\n        pc += col/(1.0+lc*lc*lc*lc*lc*60.0); \n        pc *= ao*sh;\n        pc *= exp(-0.05*length(p.xy));\n    }\n    \n    //rendered particle buffer\n    //pc = texture(iChannel0,U/R).xyz;\n    \n    C = vec4(pow(pc,vec3(0.3545)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//PARTICLE MANAGEMENT\n \nvec4 leadPos(vec4 p, float t)\n{\n    vec4 np = p;\n    np.x = sin(t*0.3)*0.44*cos((-0.7+t)*0.3);\n    np.y = sin(t*1.3)*0.2*cos((1.7+t)*0.7);\n    np.zw = np.xy-p.xy;    \n    return np;\n}\n\nvec4 wingPos(vec4 p, vec2 u, float t)\n{\n    vec4 np = p;\n    vec2 h2 = (hash22(u)-0.5)*vec2(4.5,2.5);\n    np.x = sin(t*h2.x*0.5)*(0.34+u.x*0.01);\n    np.y = sin(t*h2.y)*0.18;\n    np.zw = np.xy-p.xy;\n    return np;\n}\n\nvoid mainImage( out vec4 C, vec2 U)\n{\n   vec4 buff = (iFrame==0) ? vec4(0.0) :texture(iChannel0,U/R);\n   C = vec4(0);\n   \n   if (ivec2(U)==ivec2(0))\n   {\n       //lead position\n       C = leadPos(buff,T);\n   }\n   else if (ivec2(U).y==1)\n   {\n       //wing position\n       C = wingPos(buff,U,T);\n   }\n   else if (ivec2(U).y==2)\n   {\n       //bursts\n       float at = floor(mod(float(iFrame),500.0+U.x*100.0));\n       vec2 h2 = hash22(0.31+U*T);\n       float start = 130.0+U.x*80.0;\n       if (at==start)\n       {\n           vec4 wing = texelFetch(iChannel0,ivec2(U.x,1),0);\n           C = vec4(wing.xy,0.0,h2.y*1.0);       \n       }\n       else if (at>start && at<300.0+U.x*50.0)\n       {\n           buff.x -= scroll;\n           buff.z += buff.w*0.007;\n           C = buff;\n       }\n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T iTime\n#define ZERO (min(iFrame,0))\n\n#define scroll 0.2/60.0 \n\n//dave hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 PT(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1) * t + vec3(0, .33, .67)));}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER PARTICLES\n//particles rendered multiple timess per frame in velocity direction\n//for smoother trails\n//i found this trick in Homecomputer by nimitz\n//https://www.shadertoy.com/view/XdVGWt\n\n#define rad 0.005\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 6.283185/repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nvec3 renderParticle(vec4 p, vec2 uv, float r, float c)\n{\n    vec3 col = vec3(0.0);\n    for (float i=0.0; i<9.0; i++)\n    {\n        p.xy += p.zw*i*0.016;;\n        col += PT((T+c)*c*0.1)*smoothstep(r+0.001,r,length(p.xy-uv));\n    }\n    return col;\n}\n\nvec3 renderBurst(vec4 p, vec2 uv, float r)\n{\n    vec3 col = vec3(0.0);\n    uv -= p.xy;\n    pModPolar(uv,11.0);\n    for (float i=0.0; i<9.0; i++)\n    {\n        col += PT((T+p.w)*p.w*0.5)*smoothstep(r+0.001,r,length(uv-vec2(p.z,0.0)));\n    }\n    return col;\n}\n\nvec3 renderScene(vec2 uv)\n{\n    //lead particle\n    vec3 col = renderParticle(texelFetch(iChannel0,ivec2(0),0),\n                              uv,\n                              0.008,\n                              0.2);\n    //wing particles and bursts\n    for (int i=0; i<9; i++)\n    {\n        col += renderParticle(texelFetch(iChannel0,ivec2(i,1),0),\n                              uv,\n                              0.005,\n                              float(i)*0.3); \n        vec4 burst = texelFetch(iChannel0,ivec2(i,2),0);\n        if (burst!=vec4(0.0))\n        {\n            col += renderBurst(texelFetch(iChannel0,ivec2(i,2),0),\n                               uv,\n                               0.002);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 C, vec2 U)\n{\n    vec2 uv = (U-R*0.5)/R.y; \n    vec4 buff = texture(iChannel1,U/R+vec2(scroll,0.0));\n    \n    vec3 col = vec3(0.0);\n    col += renderScene(uv);\n    col += buff.xyz*0.95;\n    \n    //clear colours from edges\n    col *= smoothstep(0.9,0.8,abs(uv.x));\n    col *= smoothstep(0.5,0.45,abs(uv.y));\n    \n    C = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}