{"ver":"0.1","info":{"id":"fsXSz2","date":"1619010172","viewed":150,"name":"Cotton Candy on a Cone","username":"inspirnathan","description":"Celebrate with some cotton candy! Yum ðŸ˜‹","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","volumetric","stars","cotton","candy","cottoncandy","inspirnathan","victory","celebrate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlsSzB","filepath":"https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended","previewfilepath":"https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** Cotton Candy on a Cone by inspirnathan (Nathan Vaughn)\n** \n** Resources/Credit:\n** Cone SDF: https://iquilezles.org/articles/distfunctions\n** Volumetric ray marching and hsv: \"Cloudy spikeball\" (https://www.shadertoy.com/view/MljXDw) by Duke\n** Victory background, particle effect, and vignette: \"Ice cream\" (https://www.shadertoy.com/view/MdfBDf) by Koltes\n** Stars: \"Gold Stars\" (https://www.shadertoy.com/view/XtdcR7) by ChrisK\n** Music: https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265;\n\nvec3 hsv(float h, float s, float v) {\n  return mix(vec3(1.), clamp((abs(fract(h + vec3(3., 2., 1.)/3.) * 6. - 3.) - 1.), 0., 1.), s) * v;\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n  vec2 uv = (p.xy + vec2(31.0,0.0) * p.z * p.z) + f.xy;\n  vec2 rg = textureLod( iChannel0, (uv + 0.5)/256.0, 0.0 ).yx * .45;\n  return -1.0 + 2.4 * mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p * .06125) * .5 + pn(p * .125) * .25 + pn(p * .25) * .125;\n}\n\nfloat cottoncandy(vec3 p) {\n   p.y -= 0.8;\n   p.z += 6.;\n   p *= rotateY(iTime * .5) * rotateX(PI/2.);\n   return length(p) - 1.35 + fpn(p * 50.) * 0.3;\n}\n\nfloat cone( vec3 p)\n{\n  vec3 offset = vec3(0, -.62, 0.);\n  vec2 c = vec2(.5, .1);\n  float h = 0.5;\n  p = (p - offset) * -1.;\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat star( vec2 uv, vec2 p, float r ) {\n    vec2 o = uv - p;\n    float theta = atan(o.y/o.x) + iTime + 3.14159265 * float(o.x < 0.0);\n    r *= 1.0 + sin(theta * 5.0) * 0.2;\n    float d = r - distance(uv, p);\n    return clamp(d * iResolution.y, 0.0, 1.0);\n}\n\nvec3 calcConeNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * cone(p + e.xyy) +\n      e.yyx * cone(p + e.yyx) +\n      e.yxy * cone(p + e.yxy) +\n      e.xxx * cone(p + e.xxx));\n}\n\n// normal ray marching\nfloat rayMarchCone(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = cone(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  vec3 normal = calcConeNormal(ro);\n  \n  return depth;\n}\n\n// volumetric ray marching loop\nvec3 rayMarchCottonCandy(vec3 p, vec3 d) {\n   d = normalize(d); \n\n   float ld = 0.;\n   float td = 0.;\n   float w = 0.;\n   \n   vec3 tc = vec3(0.05);\n\n   float r = 0., l = 0., b = 0.;\n\n   for (float i = 0.; (i < 1.); i += 1./64.) {\n     if(!((i < 1.) && (l >= 0.001 * r) && (r < 50.) && (td < .95))) {\n       break;\n     }\n\n     l = cottoncandy(p) * 0.5;\n\n     const float h = .05;\n     ld = (h - l) * step(l, h);\n     w = (1. - td) * ld;   \n\n     tc += w * hsv(350./360., .545, 1.) * hsv(w * 7. - 0.4, 1. - w * 16., .9);\n     td += w *.6;\n\n     td += 1./300.;\n\n     l = max(l, 0.03);\n\n     p += l * d *.6;\n     r += l;\n   }  \n    \n   tc *= 1. / exp( ld * 1. ) * 1.75;\n   \n   return tc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((fragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   vec3 tc = rayMarchCottonCandy(p, d);\n   float cone = rayMarchCone(p, d);\n   \n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   float a = atan(uv.y + .8, uv.x) / (2. * PI) * 40. + iTime; // spinny background\n   vec3 bg = mix(hsv(325./360., .641, .918), hsv(225./360., .641, .5), step(.5, fract(a))) * 2.; // colors of background\n   vec3 col = bg;\n   \n   if (cone > MAX_DIST) col = bg;\n   else {\n     vec3 normal = calcConeNormal(p + d * cone);\n     vec3 fakeLightDirection = normalize(vec3(1,2,9));\n     float shading = clamp(dot(normal, fakeLightDirection), 0.4, 1.);\n     col = vec3(shading)*vec3(0,1,1)*1.35;\n   }\n\n   if (length(tc) > 1.4) col = tc;\n\n   vec2 uv01 = fragCoord.xy / iResolution.xy;\n   vec2 v = uv01 * (1. - uv01);\n   \n   float t = iTime;\n   vec3 ro = p;\n   vec3 rd = d;\n   \n   // particles\n    for(float i=0.; i<40.; i++){\n        vec4 h = fract(sin(i + vec4(0.,3.,5.,8.)) * 1e4);\n        h.y = fract(h.y - t * .1);\n        vec3 p = (h.xyz - .5) * 5.;\n        p.xz *= rotate2d(t * .5);\n        float l = star(uv01, cross(p - ro, rd).xy, (abs(cos(t)) + .2)*.1);\n        col += l*hsv(h.w,1.,1.)*3.;\n    }\n   \n   col = sqrt(col) *pow(v.x * v.y * 20., .6); // vignette\n      \n   fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}