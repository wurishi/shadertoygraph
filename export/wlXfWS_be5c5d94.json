{"ver":"0.1","info":{"id":"wlXfWS","date":"1597586319","viewed":1049,"name":"#845 - Daily Experiments","username":"sixclones","description":"One more day.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","experiments","daily"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* SDF of a torus from Inigo Quilez\n  https://iquilezles.org/articles/distfunctions\n*/\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n/* scene definition\n  mainly defining a torus and deform radius and thickness of it */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p; // save value of `p` before rotating it\n  \n  // some rotations\n  p.xy = rotate2d(p.xy, t);\n  float angle = P * S(0.25, 0.75, abs(2.0 * fract(t / P) - 1.0));\n  p.yz = rotate2d(p.yz, angle - QP);\n  \n  // combine cos/sin and `p` to deform the radius\n  float r = map01(sin(t\n    + 2.0 * (_p.x + _p.z)\n    + HP * cos(-t + p.y)\n    ), 1.25, 1.5); // radius\n  \n  // switch between `p.x` and `p.y` to deform thickness\n  float mixer = S(0.125, 0.875, abs(2.0 * fract(t / TP) - 1.0));\n  // combine cos/sin and `p` to deform the thickness\n  float t = map01(cos(-t\n    + 2.5 * mix(_p.x, _p.y, mixer)\n    + P * sin(-t\n      + 2.0 * _p.z\n      + TP * sin(t + 0.25 * (_p.x + _p.y + _p.z))\n    )), 0.55, 0.65); // thickness\n  \n  float torus = torusSDF(p, vec2(r, t));\n  \n  return torus;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\n  vec3 color = vec3(0.07, 0.05, 0.08);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      // use normales as color and switch the channels, instead of classical `.rgb` use `.brg` for a fresher render\n      color = 0.5 * computeNormal(pos).brg + 0.5;\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}