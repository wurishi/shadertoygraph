{"ver":"0.1","info":{"id":"l3XczX","date":"1726505382","viewed":32,"name":"Gordei_HW2","username":"GISwarm","description":"Shader with textures for graphics and shape-forming","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","phong","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// utils\n\nfloat random(vec2 p) {\n    vec2 K1 = vec2(\n        23.14069263277926,\n        2.665144142690225\n    );\n    return fract(cos(dot(p,K1)) * 12345.6789);\n}\n\nfloat max3(float a, float b, float c) {\n    return max(a, max(b, c));\n}\n\nfloat max4(float a, float b, float c, float d) {\n    return max(max(a, b), max(c, d));\n}\n\nfloat max6(float a, float b, float c, float d, float e, float f) {\n    return max(max3(a, b, c), max3(d, e, f));\n}\n\nfloat min3(float a, float b, float c) {\n    return -max3(-a, -b, -c);\n}\n\nfloat min4(float a, float b, float c, float d) {\n    return -max4(-a, -b, -c, -d);\n}\n\nfloat min6(float a, float b, float c, float d, float e, float f) {\n    return -max6(-a, -b, -c, -d, -e, -f);\n}\n\nfloat maxvec3(vec3 a) {\n    return max3(a.x, a.y, a.z);\n}\n\nvec3 mirror(in vec3 target, in vec3 axis) {\n    vec3 axis_normalized = axis * dot(target, axis) / length(axis);\n    return 2.0 * axis_normalized - target;\n}\n\nvec3 clamp_color(in vec3 color) {\n    return vec3(\n        max(0.0, min(1.0, color[0])),\n        max(0.0, min(1.0, color[1])),\n        max(0.0, min(1.0, color[2]))\n    );\n}\n\nfloat remainder(float a, float b) {\n    b = abs(b);\n    a -= float(int(a / b)) * b;\n    if (a < 0.0) a += b;\n    return a;\n}\n\nfloat remainder(float a) { return remainder(a, 1.0); }\n\n\n\n// sdf for primitives\n\nfloat sdf_sphere(in vec3 pos, vec3 center, float radius) {\n    return length(pos - center) - radius;\n}\n\nfloat sdf_semispace(in vec3 pos, in vec3 point, in vec3 norm) {\n    return dot(point - pos, norm) / length(norm);\n}\n\nfloat sdf_box(in vec3 pos, vec3 corner, vec3 up, vec3 right, vec3 far) {\n    return max6(\n        sdf_semispace(pos, corner, up),\n        sdf_semispace(pos, corner + up, -up),\n        sdf_semispace(pos, corner, right),\n        sdf_semispace(pos, corner + right, -right),\n        sdf_semispace(pos, corner, far),\n        sdf_semispace(pos, corner + far, -far)\n    );\n}\n\n// sdf for objects\n\nfloat sdf_wall(in vec3 pos) {\n    vec3 CENTER = vec3(0, 45, 0);\n    vec3 NORM = vec3(0, 1, 0);\n    return sdf_semispace(pos, CENTER, NORM);\n}\n\nfloat sdf_road(in vec3 pos) {\n    vec3 CORNER = vec3(-200, 45, -40);\n    vec3 UP = vec3(0, -5, 0);\n    vec3 RIGHT = vec3(0, 0, 80);\n    vec3 FAR = vec3(400, 0, 0);\n    return sdf_box(pos, CORNER, UP, RIGHT, FAR);\n}\n\nfloat sdf_ball(in vec3 pos) {\n    vec3 CENTER = vec3(5, -5, 15);\n    float RADIUS = 3.0;\n    return sdf_sphere(pos, CENTER, RADIUS);\n}\n\nfloat sdf_melon(in vec3 pos) {\n    vec3 CENTER = vec3(-15, -5, 15);\n    float RADIUS = 5.0;\n    return sdf_sphere(pos, CENTER, RADIUS) + dot(sin((pos - CENTER) * 2.0), vec3(1.0, 1.0, 1.0)) / 20.0;\n}\n\nfloat sdf_box(in vec3 pos) {\n    vec3 CORNER = vec3(0, 0, 10);\n    vec3 UP = vec3(8.0, 8.0, 0.0);\n    vec3 RIGHT = vec3(-8.0, 8.0, 0.0);\n    vec3 FAR = vec3(0.0, 0.0, 8.0);\n    return sdf_box(pos, CORNER, UP, RIGHT, FAR);\n}\n\n\nfloat sdf_cheese(in vec3 pos) {\n    vec3 CORNER = vec3(-13.2, -2.7, 6);\n    vec3 UP = vec3(3.0, 0.0, 1.5);\n    vec3 RIGHT = vec3(0.0, 2.0, 0.0);\n    vec3 FAR = vec3(-1, 0.0, 2.0);\n    vec3 CENTER = vec3(-12, -4, 7);\n    float RADIUS = 3.0;\n    return max(sdf_sphere(pos, CENTER, RADIUS), sdf_box(pos, CORNER, UP, RIGHT, FAR));\n}\n\n// sdf for scene\n\nfloat sdf(in vec3 pos) {\n    return min6(sdf_wall(pos), sdf_road(pos), sdf_ball(pos), sdf_melon(pos), sdf_box(pos), sdf_cheese(pos));\n}\n\nvec3 sdf_normal(vec3 point) {\n    float DELTA = 0.001;\n    return vec3(\n        (sdf(vec3(point[0]+DELTA, point[1], point[2])) - sdf(vec3(point[0]-DELTA, point[1], point[2]))) / 2.0 / DELTA,\n        (sdf(vec3(point[0], point[1]+DELTA, point[2])) - sdf(vec3(point[0], point[1]-DELTA, point[2]))) / 2.0 / DELTA,\n        (sdf(vec3(point[0], point[1], point[2]+DELTA)) - sdf(vec3(point[0], point[1], point[2]-DELTA))) / 2.0 / DELTA\n    );\n}\n\n\n\n// normal - sdf or texture\n\nvec3 get_normal(vec3 point) {\n    float dist = sdf(point);\n    if (dist == sdf_road(point) && point.x + point.z > -10.0) {\n        // TASK PART 3 - texture for normals\n        return vec3(texture(iChannel3, vec2(remainder(point.z / 40.0), remainder(point.x / 40.0))));\n    } else {\n        return sdf_normal(point);\n    }\n}\n\n\n\n// colors for objects\n\nvec3 col_wall(in vec3 pos) {\n    return vec3(texture(iChannel0, vec2(remainder(pos.x / 100.0), remainder(pos.z / 100.0))));\n}\n\nvec3 col_road(in vec3 pos) {\n    return vec3(texture(iChannel1, vec2(remainder(pos.z / 40.0), remainder(pos.x / 40.0))));\n}\n\nvec3 col_box(in vec3 pos) {\n    // TASK PART 2 - triplanar projection\n    vec3 CORNER = vec3(0, 0, 10);\n    vec3 UP = vec3(8.0, 8.0, 0.0);\n    vec3 RIGHT = vec3(-8.0, 8.0, 0.0);\n    vec3 FAR = vec3(0.0, 0.0, 8.0);\n    vec3 CENTER = CORNER + (UP + RIGHT + FAR) / 2.0;\n    \n    vec3 norm = get_normal(pos);\n    vec3 closest_plane_normal = vec3(\n        (norm.x == maxvec3(norm)) ? 1.0 : 0.0,\n        (norm.y == maxvec3(norm)) ? 1.0 : 0.0,\n        (norm.z == maxvec3(norm)) ? 1.0 : 0.0\n    );\n    vec3 pro_base_1 = normalize(vec3(1, 1, 1));\n    vec3 pro_base_2 = cross(pro_base_1, closest_plane_normal);\n    vec3 v_to_pro = pos - CENTER;\n    float texture_x = dot(v_to_pro, pro_base_1) / length(pro_base_1) / 4.0;\n    float texture_y = dot(v_to_pro, pro_base_2) / length(pro_base_2) / 4.0;\n    return vec3(texture(iChannel1, vec2(texture_x, texture_y)));\n}\n\n\n// col for scene\n\nvec3 col(in vec3 pos, in vec3 ray) {\n//return get_normal(pos);\n    float MIN_STEP = 0.00001;\n    float dist = sdf(pos);\n    if (dist == sdf_wall(pos)) {\n        return col_wall(pos);\n    } else if (dist == sdf_road(pos)) {\n        return col_road(pos);\n    } else if (dist == sdf_box(pos)) {\n        return col_box(pos);\n    } else {\n        return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n\n\n\n\n// lights\n\nconst int LIGHTS_DIRECTIONAL_AMOUNT = 4;\nvec3[LIGHTS_DIRECTIONAL_AMOUNT] LIGHTS_DIRECTIONAL_DIRECTION = vec3[](\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.5, 1.0, 2.0),\n    vec3(-1.0, 1.0, 0.0),\n    vec3(3, 1.0, -2.0)\n);\nvec3[LIGHTS_DIRECTIONAL_AMOUNT] LIGHTS_DIRECTIONAL_COLOR = vec3[](\n    vec3(0.5),\n    vec3(1.0, 0.0, 0.0) * 0.5,\n    vec3(0.3, 0.3, 0.85) * 0.5,\n    vec3(0.0, 1.0, 0.0) * 0.5\n);\n\n\n\n// raytracing\n\nvec3 trace(vec3 position, in vec3 ray, out bool hit) {\n    float SDF_STEP = 0.8;\n    float MAX_STEP = 1000.0;\n    float MIN_STEP = 0.00001;\n    hit = true;\n    vec3 ray_step = ray / length(ray);\n    for (int i = 0; i < 500; ++i) {\n        float step_size = sdf(position);\n        \n        if (step_size < 0.0) break;\n        if (step_size < MIN_STEP) return position;\n        if (step_size > MAX_STEP) break;\n        \n        position += step_size * ray_step * SDF_STEP;\n    }\n    hit = false;\n    return vec3(0.0);\n}\n\n\n\n// calculating Phong color\n\nvec3 get_color(in vec3 point, in vec3 ray) {\n    vec3 AMBIENT_LIGHT = vec3(0.4, 0.4, 0.4);\n    float DIFFUSE_VAL = 0.3;\n    float SPEC_POW = 20.0;\n    float SPEC_VAL = 0.8;\n    vec3 norm = get_normal(point);\n    vec3 mirrored_ray = -mirror(ray, norm);\n    // ambient\n    vec3 result = AMBIENT_LIGHT;\n    // diffuse\n    for (int i = 0; i < LIGHTS_DIRECTIONAL_AMOUNT; ++i) {\n        vec3 light_direction = LIGHTS_DIRECTIONAL_DIRECTION[i];\n        vec3 light_color = LIGHTS_DIRECTIONAL_COLOR[i];\n        float cos_angle = dot(-light_direction, norm) / length(light_direction) / length(norm);\n        if (cos_angle > 0.0) {\n            // check shadow\n            bool shadow = false;\n            trace(point-light_direction*0.01, -light_direction, shadow); // TODO separate sdfs? or how to cast ray\n            if (!shadow) result += cos_angle * DIFFUSE_VAL * light_color;\n        }\n    }\n    // specular\n    for (int i = 0; i < LIGHTS_DIRECTIONAL_AMOUNT; ++i) {\n        vec3 light_direction = LIGHTS_DIRECTIONAL_DIRECTION[i];\n        vec3 light_color = LIGHTS_DIRECTIONAL_COLOR[i];\n        if (dot(-light_direction, norm) > 0.0) {\n            float cos_angle = abs(dot(-light_direction, mirrored_ray)) / length(light_direction) / length(mirrored_ray);\n            // check shadow\n            bool shadow = false;\n            trace(point-light_direction*0.01, -light_direction, shadow); // TODO separate sdfs? or how to cast ray\n            if (!shadow) result += pow(cos_angle, SPEC_POW) * SPEC_VAL * light_color;\n        }\n    }\n    // apply texture\n    result *= col(point, mirrored_ray);\n    // return result\n    return result;\n}\n\n\n\n// main logic\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // position\n    vec2 mouse = iMouse.xy / iResolution.xy - vec2(0.0, 0.5);\n    vec3 position = 30.0 * vec3(sin(mouse.x * 6.28), cos(mouse.x * 6.28) * sin(-mouse.y * 6.28), cos(mouse.x * 6.28) * cos(-mouse.y * 6.28));\n    //position *= 0.0;\n    // ray\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = vec3(uv[0], uv[1], 1.0);\n    ray /= length(ray);\n    mat3 camera = mat3(\n        1, 0, 0,\n        0, cos(-mouse.y * 6.28), -sin(-mouse.y * 6.28),\n        0, sin(-mouse.y * 6.28), cos(-mouse.y * 6.28)\n    ) * mat3(\n        cos(mouse.x * 6.28), 0, sin(mouse.x * 6.28),\n        0, 1, 0,\n        -sin(mouse.x * 6.28), 0, cos(mouse.x * 6.28)\n    );\n    ray *= -camera;\n    \n    vec3 result_color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 10; ++i) {\n        bool hit = false;\n        vec3 point = trace(position, ray, hit);\n        float current_color_power = pow(2.0, float(-i) * 2.0);\n        if (hit) {\n            vec3 color = clamp_color(get_color(point, ray));\n            result_color += color * current_color_power;\n            position = point - ray * 0.01; // TODO separate sdfs? or how to cast ray\n            ray = -mirror(ray, get_normal(point));\n        } else {\n            // TASK PART 1 - texture for skybox\n            result_color += vec3(texture(iChannel2, ray)) * current_color_power;\n        }\n    }\n    fragColor = vec4(result_color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"float cosinus(in vec3 x, in vec3 y) {\n    return dot(x, y) / length(x) / length(y);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 result = vec3(0.0);\n    \n    // sun\n    float sun_power = sin(iTime) * 4.0 + 10.0;\n    vec3 sun_position = vec3(sin(iTime), cos(iTime), 0.0);\n    float sun_light = cosinus(rayDir, sun_position);\n    if (sun_light >= 0.0) {\n        float sun_power = pow(sun_light, sun_power);\n        result += sun_power;\n        if (sin(iTime / 2.0) <= 0.0) result = vec3(0.0); // COMMENT THIS IF WANT DARK SUN\n    }\n    \n    // blue sky\n    float rest_light = 3.0 - length(result);\n    rest_light = sqrt(result.b*result.b + rest_light) - result.b;\n    result += rest_light * vec3(0.1, 0.1, 0.6);\n    \n    // time of day\n    result *= sin(iTime / 2.0);\n    \n    fragColor = vec4(result, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 result = vec3(0.0);\n    result += vec3(\n        abs(sin(uv.x * 20.0)),\n        0.5,\n        abs(sin(uv.y / 5.0))\n    );\n    \n    \n    result = normalize(result);\n    fragColor = vec4(result, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}