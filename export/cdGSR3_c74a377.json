{"ver":"0.1","info":{"id":"cdGSR3","date":"1728562653","viewed":111,"name":"eyes x 20  [p3]","username":"valalalalala","description":"Wrked with a reference image outside of shadertoy, did some animation tweaks using sliders and custom uniforms. I think the results are fair, but the performance is pretty lousy. Still, learned a lot and I continue to leverage the work in other projects.","likes":5,"published":1,"flags":24,"usePreview":0,"tags":["character"],"hasliked":0,"parentid":"cl2SRK","parentname":"eyes x 20  [p2]"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"       ///////////////////////////////////////////////////////////////////\n     //                                                               ////\n    // \"twenty eyes [p3]\"                                            // //\n   //                                                               //  //\n  // This is as far as I got. It was fun and I learned a lot       //   //\n //                                                               //    //\n///////////////////////////////////////////////////////////////////     //\n//                                                               //    ///\n// Creative Commons Attribution-NonCommercial-ShareAlike         //   //\n// 3.0 Unported License                                          //  //\n//                                                               // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                             ////\n//                                                               ///\n///////////////////////////////////////////////////////////////////\n\nfloat tTime, bTime, dTime, oTime; // .2, 2x and 4x clocks\nfloat hackx,hacky;\n\n/////////////////////////////////////////////////////////////////////\n\nconst int EYE = 1;\nconst int FACE = 2;\nconst int LIPS = 3;\nconst int LIDS = 4;\nconst int HAIR = 5;\nconst int BODY = 6;\n\n// 10 is fine details like hair variation, freckles, subsurface and iris details\n#define LOD 9\n//#define length langth\n\n/////////////////////////////////////////////////////////////////////\n\n\n// polynomial smooth min (k = 0.1); iq\nfloat smin( float a, float b, float k ){\n        //return min(a,b);\n//if(keyToggle(13,iChannel1)) return min(a,b);\n\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b ) {\n    return smin( a, b, .1 );\n}\n\nfloat smax(float a, float b, float k){\n        return -smin(-a, -b, k);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b, vec3 r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    vec3 o = (ab*t + a);\n    \n    \n    vec3 f = length( o - p ) - r;\n    return min( f.x, min( f.y, f.z ) );\n    \n    \n    vec3 l = vec3(\n        abs( o.x - p.x ) - r.x,\n        abs( o.y - p.y ) - r.y,\n        abs( o.z - p.z ) - r.z\n    );\n    \n    return min( l.x, min( l.y, l.z ) );\n    \n    //return length((ab*t + a) - p) -r;\n}\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p) -r;\n}\n\n//based off fLineSegment + madness wtf?\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2, float power ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2, pow( t, power ) );\n    return length((ab*t + a) - p) -r;\n}\n\nfloat bulgo(vec3 p, vec3 a, vec3 b, float r1, float r2, float kook ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = 4. * pow( t * 1.1 - kook, 2. ); // thickest is around 1/3 to 2/3.. good for thigh... but cankles...\n    return length((ab*t + a) - p) - mix( r1, r2 * 1.1, r );\n}\n\nfloat flinor(vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n    return bulgo( p, a, b, r1, r2, .35 );\n}\n\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2,t );// pow( t, power ) );\n    return length((ab*t + a) - p) -r;\n}\n\nfloat linor(vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p) -r;\n}\n\n// https://www.shadertoy.com/view/MltcDB\nfloat ellipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n        return (length(p / r) - 1.) * (length(p / r)) / lg;\n}\n\nfloat sphere( vec3 p, vec3 center, float radius ) {\n    return length( p - center ) - radius;\n}\n\nvec3 nextJoint( vec3 a, vec3 d, float l ) {\n    return a + l * normalize( d );\n}\n\nfloat limbo( vec3 p, vec3 a, vec3 b, float l, float r ) {\n    return linor( p, a, b, r, r );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat eyeDistance( vec3 p, float pad ) {\n    vec3 center = V000;\n    float ed = 3e3;\n\n    float e = .01;\n    float apart = 13.0;\n    \n    p.y -= .1;\n           \n    // hacky rotation\n    p.y -= e * 14.;\n    p.z -= p.y * -.08 - .26 * abs( abs( p.x ) - .07 ) + .31;\n\n    vec3 pl = p - x3( apart * e );        \n    vec3 pr = p + x3( apart * e );\n\n    // this will gives 18 of the 20 eyes\n    pl.xy = REPLIM( pl.xy, e * 2.2, vec2(1.),vec2(+1.));\n    pr.xy = REPLIM( pr.xy, e * 2.2, vec2(1.),vec2(+1.));   \n\n    ed = min( ed, sphere( pl, center, e * pad ) );\n    ed = min( ed, sphere( pr, center, e * pad ) );\n    \n    // finally we have 20 eyes to put into our head!\n    p.x = abs( abs( p.x ) - 9. * e );\n    p.z += .012;\n    ed = min( ed, sphere( p, center, e * pad ) );\n\n    return ed;\n}\n\nfloat eyeDistance( vec3 p ) {\n    return eyeDistance( p, 1. );\n}\n\nfloat lipDistance( vec3 p, float thickness ) {\n    p.x *= .985;\n    p.z -= .15 * p.y;\n    p.y += .054;\n    \n    vec3 px = p; \n    px.x = abs( px.x );\n\n    vec3 up = px;\n    up.y += up.x * .22;\n\n    vec3 dn = px;\n    dn.y -= dn.x * .14 - .01;\n\n    float upl = ellipsoid( up - vec3( .014, .064, .268 ), vec3( .032, .019, .04 ) * thickness * 1.00 );\n    float dnl = ellipsoid( dn - vec3( .000, .042, .266 ), vec3( .053, .021, .04 ) * thickness * 1.05 );\n    \n    return smin( upl, dnl, .0047 );\n}\n\nfloat lipDistance( vec3 p ) {\n    return lipDistance( p, 1.5 );\n}\n\nfloat neckDistance( vec3 p ) {\n    return linor( p, vec3( ZED, .00, -.20 ), vec3( ZED, -.4, -.24 ), .18, .22 );\n}\n\n// huge depth to MltcDB\nfloat faceDistance( vec3 p ) {\n    vec3 og = p;\n\n    vec3 px = p; \n    px.x = abs( px.x );\n        \n    float frq = 1.75;\n\n    float d =    sphere( p,  vec3( ZED,  .480,  .020 ), .270 );  // front of head  \n    d = smin( d, sphere( p,  vec3( ZED,  .440, -.220 ), .280 ), .1 * frq ); // back of head\n    d = smin( d, sphere( px, vec3( .15,  .130,  .220 ), .030 ), .24 * frq ); // cheek\n    d = smin( d, sphere( px, vec3( .05,  -.01,  .05 ), .07 ), .18 * frq ); // jaw\n    d = smin( d, sphere( p,  vec3( ZED, -.110,  .220 ), .024 ), .16 * frq ); // chin\n\n    vec3 e = px; e.x -= .21 * e.y; e.z += .09 * e.y; // rotate a bit\n    d = smin( d, ellipsoid( e - vec3( .21, .24, -.06 ), vec3( .03, .1, .08 ) ), .013 * frq); // ears    \n\n    vec3 b = p; b.z -= .15 * b.y;\n    d = smin( d, ellipsoid( b - vec3( ZED, .04, .23 ), vec3( .080, .091, .07) ), .01 * frq); // mouth barrel\n    d = smin( d, lipDistance( og, .95 ), .01 * frq ); // bring in lips\n\n    // still needs work \n    float nostrils = sphere( px, vec3( .025, .12, .30 ), .02 );\n    float bridge   = linor( p,   vec3( ZED, .30, .27 ), vec3( ZED, .12, .34 ), .02, .03, 2. );\n    float nose     = smin( nostrils, bridge, .04 );\n    d = smin(d, nose, .05 );\n    \n    float brows = sphere( px, vec3( .11, .35, .21 ), .044 );\n\n    d = smin( d, brows, .15 );\n\n    float neck = neckDistance( og );\n    d = smin( d, neck, .1 *frq); \n    \n    // eyesockets and blinking\n    float eye = eyeDistance( p, mix( .98, 1., .5 + bTime ) );\n\n    \n    return d;\n}\n\nfloat eyebrowDistance( vec3 p ) {\n    vec3 px = p;\n    px.x = abs( px.x );\n\n    vec3 p1 = vec3( .047, .290, .31 );\n    vec3 p2 = vec3( .100, .310, .32 );\n    vec3 p3 = vec3( .150, .313, .31 );\n    vec3 p4 = vec3( .172, .308, .29 );\n\n    float d1 = linor( px, p1, p2, .008, .006, 1. );\n    float d2 = linor( px, p2, p3, .006, .005, 2. );\n    float d3 = linor( px, p3, p4, .005, .004, 3. );\n\n    return min( d1, min( d2, d3 ) );\n}\n\nfloat hairDistance( vec3 p ) {\n    vec3 px = p;\n    px.x = abs( p.x );\n\n    float eb = eyebrowDistance( p );\n\n    #if LOD >= 10 \n    float t = triangle( 888. * ( p.x + p.y * .3 - abs(p.z) * .2 ) ) ; \n    \n    float h = 1. + t * .001;\n    #else\n        float h = 1.;\n    #endif\n\n    float front1 = sphere( p,  vec3( ZED, .50,  .01), .28 );\n    float front2 = sphere( px, vec3( .10,  .46,  .04), .18 );\n    //float front2 = sphere( px, vec3( .13,  .5,  .08), .18 );\n    float front = smin( front1, front2, .1 );\n\n    float back= sphere( p,  vec3( ZED,  .440, -.210 ), .30 );\n    float hr = smin( front, back, .1);\n    \n    float dt = oTime ;//sign( dTime ) * pow( dTime, 2. ) -.;\n    \n    float y = p.y - .55;\n    y = y * y * (3.0 - 2.0 * y) * .3;\n    \n    vec3 bop = vec3( y * dt * .5, p.x * dt * .2, y * dt * .1 );\n\n    #if LOD >= 10 \n    h = .98 + .02 * abs( triangle( 444. * ( p.x - bop.x ) ) ); \n    #endif\n    \n    float p1 = sphere( p, vec3( ZED, .48, -.48 ) + bop, .12 * h );\n    float p2 = sphere( p, vec3( ZED, .32, -.54 ) + bop, .08 * h );\n    float p3 = sphere( p, vec3( ZED, .18, -.56 ) + bop, .08 * h );\n    float p4 = sphere( p, vec3( ZED, .04, -.54 ) + bop, .07 * h );\n    float p5 = sphere( p, vec3( ZED,-.08, -.52 ) + bop, .06 * h );\n\n    float pn = min( p1, min( p2, min( p3, min( p4, p5 ) ) ) );\n\n    float pm = .02;\n    pn = smin( p1, smin( p2, smin( p3, smin( p4, p5, pm ), pm ), pm ), pm );\n    \n    hr = min( pn, hr );\n    \n    return min( hr, eb );\n}\n\nfloat armDistance( vec3 p, float t, float o ) {\n    const float len1 = .9, len2 = .7, len3 = .2;\n\n    const float r1 = .14, r2 = r1 * .72, r3 = r2 * .70, r4 = .03;\n\n    float v = abs( t );/// + .01; // ZED weirdness \n    ///t = sign( t ) * v;\n\n    vec3 d1 = norm( .26, .00 * t - .90, 1.10 * t + .00 );   \n    vec3 d2 = norm( .02, .30 * t - .05, 0.10 * v + .05 );\n    vec3 d3 = norm( .04, .25 * t - .00, 0.20 * v + .00 );\n    d3.x -= .2;\n    vec3 d4 = d3; d4.x += .2; d4.z -= len3;\n    \n    //const vec3 a = vec3( .58, .70, -.46 ); \n    const vec3 a = vec3( .51, .77, -.40 ); \n\n    vec3 b = a + len1 * d1;\n    vec3 c = b + len2 * d2;\n    vec3 d = c + len3 * d3;\n    vec3 e = d + len3 * d4;\n    \n    float a1 = linor( p, a, b, r1, r2 );\n    float a2 = linor( p, b, c, r2, r3 );\n    float arm = smin( a1, a2, .03 );\n      \n    // hands are a pita... have some gross weird mittens instead\n    float palm    = linor( p, c, d, r3, r3 * 1.4 );\n    float fingers = linor( p, d, e, r3 * 1.4, r3 );\n    float hand    = min( palm, fingers );\n\n    return smin( arm, hand, .003 );\n}\n\nfloat legDistance( float sofar,  vec3 p, float t, float o ) {\n    const float len1 = 1.4, len2 = 1.4, len3 = .5;\n\n    const float r1 = .27, r2 = r1 * .71, r3 = r2 * .68, r4 = .05;\n    const vec3 a = vec3( .32, -.75, -.15 ); \n\n    t = o;\n    float v = abs(t);\n    vec3 d1 = norm( .0 , .00 * t - .90, 1.10 * t + .00 );   \n    vec3 d2 = norm( .0 , .30 * t - .05, 0.10 * v + .05 );\n    vec3 d3 = norm( .0 , .25 * t - .00, 0.20 * v + .00 );\n    d2.yz *= -1.;\n    d3 = d2; d3.yz = d3.zy; d3.z *= -1.;\n\n    vec3 b = a + len1 * d1;\n    vec3 c = b + len2 * d2;\n    vec3 d = c + len3 * d3;\n    \n    float v1 = flinor( p, a, b, r1, r2 );\n    //float v2 = bulgo( p, b, c, r2 * .9, r3, .22 );\n    float v2 = bulgo( p, b, c, r2 * .9, r3, .13 );\n    float v3 = flinor( p, c, d, r3, r4 ); // feet need a lot of work...\n\n    //return min( v2, min( sofar, v1 ) );\n    \n    float svalue = .02;\n        v2 = smin( v2, sphere( p, b + .08 * V101.yzz, .12 ), svalue );\n    \n    return smin( v3, smin( v2, smin( v1, sofar, .02 ), svalue ), svalue );\n    return smin( v3, smin( v2, smin( v1, sofar, .004 ), svalue ), svalue );\n}\n\nfloat bodyDistance( vec3 p ) {    \n    vec3 og = p;\n   \n    float t = sign( oTime ) * ( abs( oTime ) + .01 );\n    float o = sign( dTime ) * ( abs( dTime ) + .01 );\n    float m = mix( o, t, .5 );\n\n    \n    // shoulder wiggle\n    float shoulder_wiggle = .2;\n    p.x -= shoulder_wiggle * og.z * t;\n    p.z += shoulder_wiggle * og.x * t;\n    \n    // bit out of phase\n    vec3 pb = og;\n    pb.x -= shoulder_wiggle * .05 * og.z * m;\n    pb.z += shoulder_wiggle * .05 * og.x * m;\n    pb.x = abs( pb.x );\n\n\n    // hip wiggle \n    float hip_wiggle = .2;\n    vec3 ph = og;\n    ph.x -= hip_wiggle * og.z * o;\n    ph.z += hip_wiggle * og.x * o;\n    \n    vec3 pm = mix( ph, p, .5 );\n    \n    vec3 px = p;\n    px.x = abs( px.x );\n\n    //////////////////////////////////\n\n    // upper torso\n    \n    vec3 q = p; q.z += .12 * q.y ; // tilt forward some\n    float d = ellipsoid( q - vec3( ZED, .74, -.26 ), vec3( .52, .40, .25 ) ); // upper \n    \n    q = p; q.z += .10 * q.y; // tilt a little less...\n        float ribs = ellipsoid( q - vec3( ZED, .20, -.18 ), vec3( .42, .43, .30 ) );\n    d = smin( d, ribs, .21 ); \n  \n        float neck = neckDistance( og ) ;/// idk- vec3( ZED, 1.3, -.08 ) ), .1 ); // neck\n    d = smin( d, neck, .1 ); // neck\n\n        float shoulders = sphere( px, vec3( .46, .84, -.36 ), .17 );\n    d = smin( d, shoulders, .12 + .03); // shoulders\n  \n    // arms\n    float am = .04;\n    d = smin( d, armDistance( p * V101.zzz, dTime, oTime ), am );\n    d = smin( d, armDistance( p * V101.xzz, oTime, dTime ), am );\n\n    // B\n\n    float b1 = sphere( px, vec3( .18, .60, -.10 ), .10 );\n    float b2 = sphere( px, vec3( .24, .45, .0 ), .20 );\n    d = smin( d, b1, .22 );\n    d = smin( d, b2, .10 );\n\n    q = pm; q.z -= .03 * ( q.y - .6 ); // tilt back a bit\n    float belly = ellipsoid( q - vec3( ZED, -.44, -.16 ), vec3( .50, .44, .34 ) );\n\n    d = smin( d, belly, .12 ); \n\n    float hips = ellipsoid( q - vec3( ZED, -.62, -.12 ), vec3( .54, .34, .32 ) );\n    d = smin( d, hips, .1 ); \n\n    // legs\n    \n    q = ph; \n    q.x = abs( q.x );\n    q.x += .18 * q.y ;\n    float bt = ellipsoid( q - vec3( .10, -.77, -.30 ), vec3 ( .33 ) );\n    d = smin( d, bt, .15 );\n\n    d = legDistance( d, ph * 1.000000, dTime, oTime );\n    d = legDistance( d, ph * V101.xzz, oTime, dTime );\n\n    return d;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped mapEyes( vec3 p ) {\n    vec3 center = .0*vec3( tTime, V000.yz );\n    float ed = eyeDistance( p );\n    return Mapped( ed, EYE, center );\n}\n\nMapped mapFace( vec3 p ) {\n    return Mapped( faceDistance( p ), FACE, V000 );\n}\n\nMapped mapLips( vec3 p ) {\n    return Mapped( lipDistance( p ), LIPS, V000 );\n}\n\nMapped mapLids( vec3 p ) {\n    return Mapped( eyeDistance( p, 1.01 * mix( .98, 1., .5 + bTime ) ), LIDS, V000 );\n}\n\nMapped mapHair( vec3 p ) {\n    return Mapped( hairDistance( p ), HAIR, V000 );\n}\n\nMapped mapBody( vec3 p ) {\n    return Mapped( bodyDistance( p ), BODY, V000 );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped map( vec3 p ) {\n    p -= y3( .55 );\n\n    vec3 head = p - y3( 1.45 );\n    head *= 1.2; // somehow this all got off :-/\n    head.z += .1;\n\n    //head sway in time \n    float dt = sign( dTime ) * pow( dTime, 2. );\n    vec3 bop = vec3( .2 * head.y * dt, -.2 * head.x * dt, dt );\n    head.xy += bop.xy;\n\n    Mapped face = mapFace( head );\n    Mapped eyes = mapEyes( head );\n    Mapped lips = mapLips( head );\n    Mapped lids = mapLids( head );\n    Mapped hair = mapHair( head );\n    Mapped body = mapBody( p - vec3( ZED, .2, .1 ) );\n\n    Mapped m = face;\n    mino( m, eyes );\n    mino( m, eyes );\n    mino( m, lips );\n    mino( m, lids );\n    mino( m, hair );\n    mino( m, body );\n\n    return m;\n}\n\nMAP_TIME\n\nvec3 subo( vec3 p ) {\n    // https://www.shadertoy.com/view/MdXSzX\n    #define TRANSMISSION_RANGE_ .15\n    #define TRANSMISSION_RANGE .88\n    vec3 lightDir1 = normalize(vec3(3,1,-2));//normalize( V101.xzx );\n    vec3 lightDir2 = normalize(vec3(-3,1,-2));//normalize( V101.zzx );\n    vec3 lightCol1 = vec3(1.1,1,.9)*1.4;\n    vec3 lightCol2 = vec3(.8,.4,.2)*2.0;\n\n    // And sub surface scattering too! Because, why not?\n    float transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?\n    float transmission1 = map( p + lightDir1*transmissionRange ).depth/transmissionRange;\n    float transmission2 = map( p + lightDir2*transmissionRange ).depth/transmissionRange;\n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n    return subsurface;\n}\n\nvec3 eyeColor( float radius, float angle, float force ) {    \n    const vec3 iris_middle = vec3( .33, .33, .66 );\n    const vec3 iris_inner = vec3( .66, .33, .88 );\n    const vec3 iris_outer = vec3( .11, ZED, .11 );\n    \n    vec3 color = iris_middle;\n    if ( float( LOD ) + force < 10. ) return color;\n\n    float iR = radius;\n    float iA = angle;\n    \n    float nz = noise(  7.7 * vec2( iR, iA ) );\n    float iT = triangle( 8.8 * ( iA + nz + tTime ) );\n    \n    float iB = mix( pow( 4. * nz , 2. ), iT, iT + nz ); // ridges    \n    \n    float inner = smoothstep(0.1, 0.7, iR);\n    float outer = smoothstep(0.72, 1.05, iR);\n    \n    color = mix( color, iris_outer, outer );\n    color = mix( iris_inner, color, inner );\n    color *= 2.* mix( .33, 1., iB );\n    return color;\n}\n\n// help from https://www.shadertoy.com/view/3t2Szh\nvec3 eyeColor( in Ray ray, in Marched marched, in vec3 n, in vec3 look ) {\n    vec3 p = marched.p;\n    vec3 center = marched.mapped.center;\n\n    // these 3 magic numbers are strongly tied :-/\n    float iris = .95;\n    float pupil = iris * mix( 1.05, 1.04, clamp( tTime, ZED, EINS ) );   \n    \n    vec3 on = normalize( look - center );\n    float angle = dot( n, on );\n    \n    if ( angle < ZED || angle < iris ) return vec3( 2.2 * dot( n, -ray.dir ) );\n    if ( angle > pupil ) return V000;\n    \n    float iR = ( pupil - angle ) / ( pupil - iris );\n    float iA = atan( n.x - on.x, n.y - on.y );\n      \n    return eyeColor( iR, iA, ZED );\n}\n\nvec3 eyes20( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n\n    float t = iTime *.4;\n    \n    tTime = triangle( t * .2 );\n    bTime = triangle( t * 2. );\n    dTime = triangle( t * 4. );\n    oTime = triangle( t * 4. + .25 * TAU );\n    \n    dTime = sign( dTime ) * ( .01 + abs( dTime ) );\n    oTime = sign( oTime ) * ( .01 + abs( oTime ) );\n    \n    hackx = iMouse.x / iResolution.x;\n    hacky = iMouse.y / iResolution.y;\n  \n    vec3 color;\n    Ray ray = rayToggle( env, makeRay( env ), iChannel1 );\n    Marched marched = march( ray );\n\n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 q = p + vec3( marched.mapped.center.xy, ZED );\n        \n        vec3 n = mapNormal( p, marched.depth );\n        float l = dot( n, -ray.dir );\n\n        l = .5+ .5 * l;\n        float l2 = l * l;\n        \n        switch ( int( marched.mapped.type ) ) {\n            case EYE:\n                color = eyeColor( ray, marched, n, vec3( env.ms, 1. ) );\n                #if LOD >= 11\n                    vec3 rDir = reflect( ray.dir, n );\n                    float fresnel = saturate( pow( EINS + l, 5. ) );\n\n                    float subsurface = .11;\n                    float reflection = .33;\n\n                    color = mix( color, subo( p ), subsurface );\n                    //color = mix( color, texture( iChannel0, rDir ).rgb, reflection * fresnel );\n                #endif\n                break;\n            case FACE:\n                color = vec3( .9, .8, .6 );\n                #if LOD >= 10 \n                    float spk = noise( 88.*( q.xy + q.z * .5 ) );\n                    spk = spk*spk*(3.-2.*spk);\n                    color = mix( color, .77 * color, spk );\n                    color *= l * l;\n                    color = mix( color, subo( p ), .11 );\n                #else\n                    color *= l * l;\n                #endif\n                \n                break;\n            case LIPS:                \n                color = l * l * vec3( .5, .04, .05 );\n                break;\n            case LIDS:\n                color = l * l * l * vec3( .7, .6, .8 );\n                break;\n            case HAIR:\n                color =  l * l * .33 * vec3( .7, .6, .8 );\n                                //color.r += .8;\n                break;\n            case BODY: \n                color = mix(vec3(.11), vec3(.33)+abs(n), l2) * l2;\n                break;\n        }\n   \n        \n    } else {\n        float r = length( env.uv );\n        float i = ( r - .22 ) / .77;\n        \n        float l = triangle(iTime * .33);\n        r /= .77 + l;\n        \n        color = .22 * l * mix( V000, \n            mix( \n                eyeColor( i, atan( env.uv.y, env.uv.x ), 100. ), \n                V101.zzz * 3.3 * invert( r - .44 ),\n                step( .8, r )\n            ),\n            step( .22, r ) \n        );\n    }\n    \n    return color;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 result, in vec2 st ) { \n    result = vec4( eyes20( st ), 0. );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS ), V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 8.;//.7;//5.\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\nvec3 x3( float x ) { return vec3( x, V000.yz ); }\nvec3 y3( float y ) { return vec3( ZED, y, ZED ); }\nvec3 z3( float z ) { return vec3( V000.xy, z ); }\n\nvec3 norm( float x, float y, float z ) {\n    return normalize( vec3( x, y, z ) );\n}    \n\n/////////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n\n// more iq magic...\n#define REPLIM(p,s,limmin,limmax) ((p)- (s)*clamp(round((p)/(s)),-limmin,limmax))\n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \n\nvec2 hash( in vec2 p ) {\n    return vec2( triangleHash( p.xy ), triangleHash( p.yx ) );\n}\n\nfloat noise_iq( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 p ) {\n    return noise_iq( p );\n}\n\nvec4 fbm( vec2 uv ) {\n    vec4 f = vec4( noise( uv * 1. ), noise( uv * 2. ), noise( uv * 4. ), .0 );\n    f.w = dot( f.xyz, vec3( 1., .5, .25 ) );\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#define qcos( x ) triangle( x )\n#define qsin( x ) triangle( x + TAU * .25 )\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nmat2 rotate2dmat( float c, float s ) {\n    return mat2( c, -s, s, c );\n}\n\nmat2 rotate2d( in float angle ) {\n    vec2 t = trig( angle );\n    return rotate2dmat( t.x, t.y );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\nvec2 order( vec2 p ) {\n    return vec2( min( p.x, p.y ), max( p.x, p.y ) );\n}\n\nfloat langth( vec3 p ) {\n    return dot( order( abs( p ) ), vec3( 0.25, 0.51, 0.79 ) ) * 1.06 + -0.0011;\n    //return dot( order( abs( p ) ), vec3( 0.25, 0.49, 0.74 ) ) * 1.11 + -0.0020;\n    //return dot( order( abs( p ) ), vec3( .2, .4, .9 ) );\n}\n\nfloat langth( vec2 p ) {\n    return dot( order( abs( p ) ), vec2( 0.41, 0.88 ) ) * 1.06 + -0.0004;\n    //return langth( vec3( ZED, p ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvec2 pow2(vec2 v, float f) {\n    return vec2(pow(v.x, f), pow(v.y,f));\n}\n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n \n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n \n    float md = step( 3e-3, env.iMouse.z + env.iMouse.w );\n    vec2 ims = 2.*( env.iMouse.xy / env.iResolution.xy - .5 );\n    vec2 tms = vec2(triangle(env.iTime*.2));\n    env.ms = mix(tms, ims, md); \n    \n\n    \n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI );\n    \n    //t=t*.0+1.;\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 2.88 ), t.x );\n    const float zoom = .125;//.25;\n    \n    \n    vec3 idk = vec3( env.uv, EINS );\n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * idk - eye * zoom );;\n\n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n// 1 is front, 2 is left, 3 is top\nRay rayToggle( in ShadEnv env, in Ray ray, in sampler2D keyboardChannel ) {\n    float v = VIEW_DISTANCE;\n    if ( keyToggle( 49, keyboardChannel ) ) {\n        // 1: front\n        env.ms *= .0;\n        ray = makeRay( env, v );\n    } else \n    if ( keyToggle( 50, keyboardChannel ) ) {\n        // 2: left side\n        env.ms = vec2( -.5, .0 );\n        ray = makeRay( env, v );\n    } else \n    if ( keyToggle( 51, keyboardChannel ) ) {\n        // 3: top\n        ray.eye = v * V101.yzy;\n        ray.dir = normalize( vec3( env.uv.x, EINS, -env.uv.y ) - ray.eye );\n    } else\n    if ( keyToggle( 52, keyboardChannel ) ) {\n        // 4: 3 quarter\n        env.ms = vec2( -.25, .12 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 53, keyboardChannel ) ) {\n        // 5: back\n        env.ms = vec2( 1., .0 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 54, keyboardChannel ) ) {\n        // 6: back 3/4\n        env.ms = vec2( -.75, .1 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 55, keyboardChannel ) ) {\n        // 7: right side\n        env.ms = vec2( .5, .0 );\n        ray = makeRay( env, v );\n    }\n    \n    return ray;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    int type;\n    vec3 center; // for eyes\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -1, V000); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side;\n    marched.depth += marched.mapped.depth;\n        \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n    return MARCH_CONTINUE;\n}\n\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 triangle_tone(float frequency, float time) {\n    time = fract(time);\n    float f = TAU * frequency * time;\n    float decay = exp(-6.6*time);\n    float t = mix(triangle(f), triangle(f+.22), fract(f));\n    return vec2(t) * decay;\n}\n\nvec2 mainSound( int samp, float time ) {\n    return .11 * max(vec2(-1.),min(vec2(1.), .0\n        + triangle_tone(222., time * 1.11 - .111)\n        + triangle_tone(333., time * .555 + .010)  \n        + triangle_tone(444., time * .222 + .111)\n        + triangle_tone(666., time * .121 + .222)\n        + triangle_tone(999., time * .060 + .333)\n    ));\n}","name":"Sound","description":"","type":"sound"}]}