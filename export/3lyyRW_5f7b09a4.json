{"ver":"0.1","info":{"id":"3lyyRW","date":"1611493037","viewed":32,"name":"2d illumination","username":"okdalto","description":"2d illumination","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","illumination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 mousePos;\n\nfloat trace(vec2 p, inout vec3 col){\n    float dist = 1e9;\n    vec2 uv = (p + 1.0) * 0.5;\n    uv *= uv;\n\n    float d1 = sdCircle(p - mousePos, 0.05);\n    //float d1 = sdBox(p - mousePos, vec2(0.1, 0.1));\n    if(dist > d1){\n        col = vec3(3.0, 0.2, 0.8);\n        dist = d1;\n    }\n    \n    p -= vec2(0.0, sin(uv.x * 4.0 + iTime) * 0.3);\n    vec2 c = vec2(0.4, 0.4);\n    vec2 l = vec2(2.0, 1.0);\n    vec2 q = p-c*clamp(round(p/c),-l,l);\n\n    vec2 circlePos = vec2(sin(iTime * 1.3), cos(iTime * 1.3)) * 2.0 * sin(iTime * 0.5);\n\n    //float d3 = sdBox(p - mousePos, vec2(0.5, 0.5));\n    float d3 = sdCircle(p - mousePos, 0.3);\n    float d2 = sdCircle(q, 0.05);\n    \n    float d23 = opSmoothSubtraction(d3, d2, 1.2) - 0.2;\n    \n    \n    d2= abs(d3) - 0.1;\n    if(dist > d23){\n        col = vec3(uv.x*0.2, uv.y*0.2, 0.05);\n        dist = d23;\n    }\n    \n    /*\n    if(dist > max(d2, -d3)){\n        col = vec3(0.1, 0.08, 0.05);\n        dist = max(d2, -d3);\n    }\n    */\n\n    /*\n    //float d4 = sdBox(p, vec2(1.2, 0.6));\n    float d4 = sdRoundBox(p, vec2(1.4, 0.65), vec4(0.55));\n    d4 = abs(d4) - 0.05;\n    d4 = opSmoothSubtraction(sdBox(p - vec2(.0, .0), vec2(0.6, 1.0)), d4, 0.1);\n    \n    if(dist > d4){\n        col = vec3(0.05, 0.05, 0.1);\n        dist = d4;\n    }\n    */\n    \n    /*\n    vec2 addPos = vec2(sin(iTime * 1.3), cos(iTime * 1.3)) * 0.1;\n    //float d5 = sdCircle(p - circlePos + addPos, 0.1);\n    float d5 = sdCircle(p - circlePos + addPos, 0.1);\n    if(dist > d5){\n        col = vec3(0.1, 1.0, 0.2);\n        //col = vec3(0.1, 0.2, 0.2);\n        dist = d5;\n    }\n    */\n    \n    \n    \n    return dist;\n}\n\n\n\nvec2 getNormal(vec2 p){\n    vec3 temp = vec3(0.0);\n    vec2 eps = vec2(1e-3, 0);\n    return normalize(vec2(\n        trace(p + eps.xy, temp) - trace(p - eps.xy, temp),\n        trace(p + eps.yx, temp) - trace(p - eps.yx, temp)\n        )\n    );\n}\n\n/*\nint refr(float ix, float iy, float nx, float ny, float eta, inout vec2 r) {\n    float idotn = ix * nx + iy * ny;\n    float k = 1.0f - eta * eta * (1.0f - idotn * idotn);\n    if (k < 0.0f)\n        return 0; // Total internal reflection\n    float a = eta * idotn + sqrt(k);\n    r.x = eta * ix - a * nx;\n    r.y = eta * iy - a * ny;\n    return 1;\n}\n*/\n\nint refr(vec2 I, vec2 N, float ior, inout vec2 R, inout vec2 bias) { \n    float cosi = dot(I, N); \n    float etai = 1.0, etat = ior; \n    vec2 n = N;\n    \n    if (cosi < 0.0) { \n        cosi = -cosi;\n        bias = -bias;\n    } else { \n        float temp = etai;\n        etai = etat;\n        etat = temp;\n        n = -n;\n    } \n    float eta = etai / etat; \n    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    if(k < 0.0){\n        bias = -bias;\n        R = normalize(reflect(I, n));\n        return 0;\n    }else{\n        R = eta * I + (eta * cosi - sqrt(k)) * n;\n        return 1;\n    }\n} \n\n\n#define lightStep 5\n#define marchStep 32\n\nvec3 march(vec2 p, vec2 dir){\n    vec3 col;\n    vec2 newDir = dir;\n    vec2 lightPos = p;\n    for(int j = 0; j < lightStep; j++){\n        vec3 tempCol = vec3(0.0);\n        float trvlDist = 0.0;\n            for(int i = 0; i < marchStep; i++){\n                float dist = trace(lightPos, tempCol);\n                float absDist = abs(dist);\n                if(absDist < 1e-4){\n                    //float sgn = (sign(dist) - 0.5) * 2.0;\n                    \n                    //col += tempCol;\n                    col += (tempCol * exp(float(-trvlDist * 3.0)) );\n                    //lightPos += newDir * 0.2;\n                    //col += (tempCol);\n\n                    //lightPos += newDir * 1e-3;\n                    vec2 n = getNormal(lightPos);\n                    \n                    /*\n                    if (refr(newDir.x, newDir.y, n.x, n.y, 0.5, newDir) == 1){\n                        lightPos -= n * 1e-3;\n                    }else{\n                        lightPos += n * 1e-3;\n                    }\n                    */\n                    vec2 bias = n * 1e-3;\n                    \n                    refr(newDir, n, 1.6, newDir, bias);\n                    lightPos += bias;\n                    //newDir = normalize(refract(newDir, n, 0.1));\n                    //lightPos -= n * 1e-3;\n                    //newDir = normalize(reflect(sgn * newDir, n));\n                    break;\n                }else if(trvlDist > 1e+1){\n                    break;\n                }\n                lightPos += newDir * absDist;\n                trvlDist += absDist;\n            }\n\n    }\n    return col;\n}\n\n/*\nfloat trace(vec3 col, vec2 o, vec2 d, int depth) {\n    float t = 1e-3f;\n    float sgn = trace(o, col) > 0.0f ? 1.0f : -1.0f;\n    float eta = 0.8;\n    for (int i = 0; i < 64 && t < 5.0f; i++) {\n        vec2 xy = o + d * t;\n        float r = trace(o, col);\n        if (r * sgn < 1e-3) {\n            vec3 sum = col;\n            if (depth < 3) {\n                float nx, ny, rx, ry, refl = 1.0;\n                vec2 n = getNormal(xy) * sgn;\n                if (eta > 0.0f) {\n                    if (refract(dx, dy, nx, ny, sign < 0.0f ? eta : 1.0f / eta, &rx, &ry))\n                        sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);\n                    else\n                        refl = 1.0f; // Total internal reflection\n                }\n                if (refl > 0.0f) {\n                    reflect(dx, dy, nx, ny, &rx, &ry);\n                    sum += refl * trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1);\n                }\n            }\n            return sum;\n        }\n        t += r.sd * sign;\n    }\n    return 0.0f;\n}\n*/\n\n\nfloat rand (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n\n#define steps 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized128 pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= (iResolution.x/iResolution.y);\n    mousePos = (iMouse.xy/iResolution.xy - 0.5) * 2.0;\n    mousePos.x *= (iResolution.x/iResolution.y);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    for(int i = 0; i < steps; i++){\n        float t = (float(i) + rand(uv+float(i)+iTime)) / float(steps) * 2. * 3.1415;\n        //float t = (float(i) + rand(uv + iTime + float(i))) / float(steps) * 2.0 * 3.141592;\n        vec2 dir = vec2(cos(t), sin(t));\n        col += march(uv, dir);\n    }\n    col /= float(steps);\n    \n\t// coloring\n    col = pow(col, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(getNormal(uv), 0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}