{"ver":"0.1","info":{"id":"4scSRX","date":"1460445782","viewed":106,"name":"multiColorTest","username":"ypn","description":"multiColorObj","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n#define t iTime\n#define res iResolution.xy\n\nvec3 cpos = vec3(0.0, 5.0, 5.0);\nvec3 cdir = normalize(-cpos);\nvec3 cside = vec3(1.0, 0.0, 0.0);\nvec3 cup  = cross(cside, cdir);\nvec3 light = normalize(vec3(0.6, 0.6, 1.0));\n\nconst int nObj = 4;\nvec3 o[4];\nvec3 c[4];\n\n\nfloat smoothen(float d1, float d2) {\n    float k = 1.5;\n    return -log(exp(-k * d1) + exp(-k * d2)) / k;\n}\n\nfloat sphere(vec3 p) {\n    return length(p) - 0.5;\n}\n\n\nfloat plane(vec3 p) {\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 4.0;\n}\n\n\nfloat dist(vec3 p){\n    float d = 1000.0;\n    for (int i = 0; i < nObj; i ++) {\n        d = min(d, sphere(p + o[i]));\n    }\n    d = min(d, plane(p));\n    return d;\n}\n\n\nvec3 norm(vec3 p){\n\tvec2 d = vec2(0.001, 0.0);\n    float di = dist(p);\n\treturn normalize(vec3(di - dist(p - d.xyy), di - dist(p - d.yxy), di - dist(p - d.yyx)));\n}\n\nfloat shadow(vec3 o, vec3 d){\n    o += norm(o) * 0.001;\n\tfloat len = 0.0, lev = 1.0;\n\tfor(float t = 0.0; t < 32.0; t++){\n\t\tfloat di = dist(o + d * len);\n\t\tif (di < 0.001){ return 0.5;}\n\t\tlev = min(lev, di  * 8.0 / min(len, 1.0));\n\t\tlen += di;\n\t}\n\treturn max(0.5, lev) ;\n}\n\nvec3 phong(vec3 p, vec3 ray) {\n    vec3 n = norm(p);\n    vec3 diffuse = vec3(1.);\n    for (int i = 0; i < nObj; i ++) {\n        float d = sphere(p + o[i]);\n        if (d < 0.001) {\n            diffuse = c[i];\n        }\n    }\n    vec3 amb = vec3(0.1);\n    \n    return diffuse * clamp(dot(light, n), 0.0, 1.0)\n\t\t+ pow(clamp(dot(normalize(light - ray), n), 0.0, 1.0), 128.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - res) / min(res.x, res.y);\n\tvec3 ray = normalize(cside * p.x + cup * p.y + cdir * 2.0);\n\n    o[0] = vec3(0.0);\n    o[1] = vec3(0.5, 0.5, 0.0);\n    o[2] = vec3(0.0, -0.5, 0.5);\n    o[3] = vec3(0.5, 0.0, 0.5);\n    c[0] = vec3(1.0);\n    c[1] = vec3(1.0, 1.0, 0.0);\n    c[2] = vec3(0.0, 1.0, 1.0);\n    c[3] = vec3(1.0, 0.0, 1.0);\n    \n\tfloat len = 0.0, di;\n\tvec3 rhead = cpos;\n\tfor(int i = 0; i < 64; i++){\n\t\tdi = dist(rhead);\n        if (abs(di) < 0.001) {\n            break;\n        }\n\t\tlen += di;\n\t\trhead = cpos + len * ray;\n\t}\n\n\tvec3 color;\n\tif(abs(di) < 0.001){\n        color = phong(rhead, ray) * shadow(rhead, light);\n\t} \n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}