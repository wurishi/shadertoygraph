{"ver":"0.1","info":{"id":"3tlSDN","date":"1563203532","viewed":231,"name":"Nodes, Lines and Nodes","username":"Ytomi","description":"test","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec3 Repeat(vec3 p){\n    return mod(p,4.)-2.;\n}\n\nfloat N31(vec3 p)\n{\n    return fract(sin(dot(p.xyz, vec3(12.9898, 78.233, 56.787))) * 43758.5453);\n}\n\nvec3 N33(vec3 p)\n{\n    float n = N31(p);\n    return vec3(fract(n*cos(p.x)), fract(n*sin(p.y)), fract(n*cos(p.z)));\n}\n\nstruct fracpos{\n    vec3 fp;\n    vec3 id;\n};\n\nfracpos GetFracPos(vec3 p){\n    vec3 fp = mod(p,4.)-2.;\n    vec3 id = floor(p/4.);\n    return fracpos(fp,id);\n}\n\nvec3 SphereCenterLocalPos(vec3 id, vec3 offs){\n    vec3 s = vec3(0.,0.,0.);\n    vec3 n = N33(id+offs);\n    s += vec3(cos(iTime*n.x*2.),sin(iTime*n.y),cos(iTime*n.z))*1.8;\n    return s + offs*4.0;\n}\n\nfloat LineDist(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa - ba * t)-r;\n}\n\nfloat LineRadius(vec3 p,vec3 q){\n    return 1./(length(p-q)*30.);\n    //return (1.-(smoothstep(0.,4., length(p-q))))*.1;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\n\nfloat GetDist(vec3 p){\n    fracpos pos = GetFracPos(p);\n    \n    vec3 q[27];\n    int i = 0;\n    for (int z = -1; z <= 1; z++){\n        for (int y = -1; y <= 1; y++){\n            for (int x = -1; x <= 1; x++){\n                q[i] = SphereCenterLocalPos(pos.id, vec3(x,y,z));\n                i++;\n            }\n\n        }\n    }\n    \n    float sphereDist = length(pos.fp-q[13])-.1;\n    \n    float lineDistMin = 100.;\n    float minLength = 3.;\n    \n\tlineDistMin = length(q[13] - q[4]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[4], LineRadius(q[13], q[4]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[22]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[22], LineRadius(q[13], q[22]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[12]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[12], LineRadius(q[13], q[12]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[14]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[14], LineRadius(q[13], q[14]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[10]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[10], LineRadius(q[13], q[10]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[16]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[16], LineRadius(q[13], q[16]))) : lineDistMin;\n    \n                                            \n    float d = smoothMin(sphereDist,lineDistMin,20.);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = min(min(min((step(0.0, rd.x) - fract(p.x)) / rd.x, (step(0.0, rd.z) - fract(p.z)) / rd.z), (step(0.0, rd.y) - fract(p.y)) / rd.y) + 0.01, GetDist(p));\n        dO += dS;\n        if(dO>MAX_DIST||dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 m = vec2(.01,0.);\n    return normalize(vec3(\n        GetDist(p+m.xyy)-GetDist(p-m.xyy),\n        GetDist(p+m.yxy)-GetDist(p-m.yxy),\n        GetDist(p+m.yyx)-GetDist(p-m.yyx)));\n}\n\nfloat GetLight(vec3 p){\n    vec3 LightPos = vec3(0,10,6);\n    LightPos.z += iTime*5.;\n    vec3 l = normalize(LightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d =RayMarch(p + n*SURF_DIST,l);\n    if(d<length(LightPos-p)) dif *= 1.;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.,0.,iTime*5.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,3.));\n    vec3 col = vec3(0.);\n    \n    float dO = RayMarch(ro,rd);\n    vec3 p = ro + rd*dO;\n    float dS = GetDist(p);\n\t\n    if(dS<.1){\n        col = vec3(GetLight(p));\n    }else{\n        col = vec3(1.);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}