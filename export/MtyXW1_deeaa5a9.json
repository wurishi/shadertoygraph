{"ver":"0.1","info":{"id":"MtyXW1","date":"1484152716","viewed":196,"name":"Phong Lighting","username":"sakib","description":"Simple phong shading","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["phong","lighting","sphere","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************************************************************\nPhong Shading\n\nAuthor : Sakib Saikia 1/11/2017\n********************************************************************/\n\n#define PI 3.141592\n\nvec3 spherePos = vec3(0.0,0.0,0.0);\nfloat sphereRadius = 1.0;\nvec3 albedo = vec3(1.0,0.0,0.0);\nvec3 bgColor = vec3(0.6,0.6,0.6);\nvec3 eye = vec3(0.0,0.0,-2.0);\nvec3 ambient = vec3(0.02);\nvec3 spec = vec3(1.0);\nfloat gloss = 50.0;\n\n// Rotate light over unit sphere using polar coordinates\nvec3 getLightDir()\n{\n    float azimuth = 0.25 * PI;\n    float zenith = 0.5 * PI + iTime;\n    return vec3(cos(azimuth) * sin(zenith), sin(azimuth) * sin(zenith), cos(zenith));\n}\n\n// Construct inverse LookAt matrix. Convert from view space to world space\n// eyePos \t- eye/camera position in World Space\n// v \t\t- LookAt position in world space\nmat3 invLookAt(vec3 eyePos, vec3 v)\n{\n    vec3 worldUpDir = vec3(0.0,1.0,0.0);\n    vec3 viewLookDir = normalize(v - eyePos);\n    vec3 viewRightDir = normalize(cross(worldUpDir, viewLookDir));\n    vec3 viewUpDir = normalize(cross(viewLookDir, viewRightDir));\n    \n    return mat3(viewRightDir, viewUpDir, viewLookDir);\n}\n\n// Sphere ray trace\n// p - ray trace origin in world space\n// d - ray direction in world space\n// o - sphere origin in world space\n// r - sphere radius\n// See : http://www.cs.virginia.edu/~gfx/Courses/2008/AdvancedGraphics/lectures/lecture07_implicit.pdf\nfloat rayTrace(vec3 p, vec3 d, vec3 o, float r)\n{\n    vec3 op = p - o;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d, op);\n    float c = dot(op, op) - r * r;\n    \n    float t = b*b - 4.0*a*c;\n    if(t >= 0.0)\n    {\n        return (-b - sqrt(t))/(2.0 * a);\n    }\n    else\n    {\n        return -1.0;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelColor = bgColor;\n    \n    // NDC\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Inverse View matrix\n    mat3 viewMat = invLookAt(eye, spherePos); \n    \n    // Ray direction in world space\n    vec3 rayDir = viewMat * normalize(vec3(p.xy, 0.75));\n    \n    // Ray trace!\n    float t = rayTrace(eye, rayDir, spherePos, sphereRadius);\n    \n    if(t > 0.0)\n    {\n        vec3 pos = eye + t * rayDir;\n        vec3 n = normalize(pos - spherePos);\n        vec3 l = normalize(getLightDir());\n        vec3 v = normalize(-eye);\n        vec3 r = reflect(l, n);\n        \n        // -- Ambient \n        pixelColor = albedo * ambient;\n        \n        // -- Diffuse \n    \tpixelColor += albedo * max(dot(n, l), 0.0);\n        \n        // -- Specular\n        // Use clamp() instead of max() as dot product between normalized vectors\n        // can be above 1.0 due to floating point imprecision. pow() can make those errors worse.\n        // See iq's comment here https://www.shadertoy.com/view/XtGXW1\n        pixelColor += spec * pow(clamp(dot(r,v), 0.0, 1.0), gloss);\n    }\n    \n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(pixelColor,gamma),1.0);\n}","name":"Image","description":"","type":"image"}]}