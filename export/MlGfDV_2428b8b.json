{"ver":"0.1","info":{"id":"MlGfDV","date":"1544318562","viewed":749,"name":"Raymarching with FXAA","username":"edo_m18","description":"Raymarching with FXAA. This is just FXAA demo.\nFXAA code refer that -> https://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fxaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FXAA_SPAN_MAX = 8.0;\nconst float FXAA_REDUCE_MUL = 1.0 / 8.0;\nconst float FXAA_SUBPIX_SHIFT = 1.0 / 4.0;\n\n#define FxaaInt2 vec2\n#define FxaaFloat2 vec2\n//#define FxaaTexLod0(t, p) textuer2DLod(t, p, 0.0)\n//#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#define FxaaTexLod0(t, p) texture(t, p)\n#define FxaaTexOff(t, p, o, r) texture(t, p + o * r)\n\nvec3 FxaaPixelShader(\n    vec4 posPos, // Output of FxaaVertexShader interpolated accross screen.\n    sampler2D tex, // Input texture.\n    vec2 rcpFrame) // Constant { 1.0 / frameWidth, 1.0 / frameHeight }\n{\n    #define FXAA_REDUCE_MIN (1.0 / 128.0)\n    \n    vec3 rgbNW = FxaaTexLod0(tex, posPos.zw).xyz;\n    vec3 rgbNE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1, 0), rcpFrame.xy).xyz;\n    vec3 rgbSW = FxaaTexOff(tex, posPos.zw, FxaaInt2(0, 1), rcpFrame.xy).xyz;\n    vec3 rgbSE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1, 1), rcpFrame.xy).xyz;\n    vec3 rgbM = FxaaTexLod0(tex, posPos.xy).xyz;\n    \n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    \n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM = dot(rgbM, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(FxaaFloat2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(FxaaFloat2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * rcpFrame.xy;\n    \n    vec3 rgbA = (1.0 / 2.0) * (\n        FxaaTexLod0(tex, posPos.xy + dir * (1.0 / 3.0 - 0.5)).xyz +\n        FxaaTexLod0(tex, posPos.xy + dir * (2.0 / 3.0 - 0.5)).xyz);\n    \n    vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (\n        FxaaTexLod0(tex, posPos.xy + dir * (0.0 / 3.0 - 0.5)).xyz +\n        FxaaTexLod0(tex, posPos.xy + dir * (3.0 / 3.0 - 0.5)).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n    {\n        return rgbA;\n    }\n    else\n    {\n        return rgbB;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord.xy / R.xy;\n    \n    vec4 c = vec4(0.0);\n    vec2 rcpFrame = vec2(1.0 / R.x, 1.0 / R.y);\n    vec2 texCoord = uv;\n    vec4 posPos = vec4(texCoord, texCoord - rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT));\n    c.rgb = FxaaPixelShader(posPos, iChannel0, rcpFrame);\n    // c.rgb = 1.0 - texture(tex, posPos.xy).rgb;\n    c.a = 1.0;\n    \n    fragColor = c;\n    \n    // Non FXAA ver.\n    // vec4 m = texture(iChannel0, uv);\n    // fragColor = m;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPS 0.01\n\nvec3 cameraPos = vec3(0.0, 2.0, 1.5);\nvec4 plane = vec4(0.0, 1.0, 0.0, 2.0);\nvec3 lightDir = vec3(1.0, 1.0, 1.0);\nvec3 skyCol = vec3(0, 0.745, 0.9);\n\nconst float heightFactor = 3.0; // height factor. will multiply to texture texel.\n\nfloat distPlane(in vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) * n.w;\n}\n\nfloat distFunc(in vec3 p)\n{\n    float d = distPlane(p, plane);\n    vec4 tex = texture(iChannel0, mod(p.xz * 0.2, 1.0));\n    tex *= heightFactor;\n\treturn d - tex.x;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const float e = EPS;\n    const vec3 dx = vec3(e, 0, 0);\n    const vec3 dy = vec3(0, e, 0);\n    const vec3 dz = vec3(0, 0, e);\n    \n    float d = distFunc(p);\n    \n    return normalize(vec3(\n    \td - distFunc(p - dx),\n    \td - distFunc(p - dy),\n    \td - distFunc(p - dz)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - R.xy) / min(R.x, R.y);\n    \n    vec2 uv = (fragCoord.xy * 2.0 - R.xy) / min(R.x, R.y);\n    \n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec3 origin = cameraPos;\n    float t = iTime * 0.01;\n    const float cd = 3.0;\n    const float sp = 2.0;\n    float x = cos(t * sp) * cd;\n    float z = sin(t * sp) * cd;\n    \n    vec3 target = vec3(0, 2.5, 0);\n    \n    vec3 cPos = origin + vec3(x, 0, z);\n    //vec3 cDir = normalize(vec3(m.x, -m.y, -1.0));\n    vec3 cDir = normalize(cPos - target);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    float targetDepth = 1.3;\n    \n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    const int maxSteps = 128;\n    \n    float d = 0.0;\n    float depth = 0.0;\n    vec3 pos;\n    \n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        pos = cPos + ray * depth;\n        d = distFunc(pos) * 0.1;\n        \n        if (d <= EPS)\n        {\n            break;\n        }\n        \n        depth += d;\n    }\n    \n    if (d <= EPS)\n    {\n        vec3 n = getNormal(pos);\n        float diff = dot(n, normalize(lightDir));\n        float fog = 1.0 - exp(-depth * 0.12);\n        col = mix(vec3(diff), skyCol, fog);\n    }\n    else\n    {\n        col = skyCol;\n    }\n    \n\n    // Output to the buffer\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}