{"ver":"0.1","info":{"id":"tdsyDl","date":"1585874647","viewed":194,"name":"[Mandelbrot Set] TIA","username":"RaySoldier","description":"I was just playing around with the TIA (triangle-inequality-average) coloring method for the Mandelbrot Set and I saw this and just had to post it.\n\nFull description in shader.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","triangle","fire","color","fractals","set","average","cool","inequality"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nI was just playing around with the TIA (triangle-inequality-average) coloring method for\nthe Mandelbrot Set and I saw this and just had to post it.\n\nA full implementation and description of TIA can be found here:\nhttps://en.wikibooks.org/wiki/Fractals/Iterations_in_the_complex_plane/triangle_ineq\n\nIn this image, I combined TIA with regular escape-time coloring to create a fire effect.\n\nNote: TIA is very inconsistent, even though this part of the Mandelbrot Set looks cool,\nother parts are either impossible to see or oversaturated. This makes TIA very difficult\nto use in moving pictures.\n\nLocation: -0.749007 + 0.099852i zoomed in by 10000x\n\nThis image is at the limit of what my floating-point hardware can handle, zooming in any\nfurther would result in artifacts.\n\n*/\n\n#define MAX_DWELL 5000\n#define BAILOUT 1000000.0\n#define AA 3\n\nvec3 HSVtoRGB(vec3 hsv){\n    \n    hsv.x = mod(hsv.x, 1.0)*6.0;\n    int i = int(floor(hsv.x));\n    float f = mod(hsv.x, 1.0);\n    float p = hsv.z * (1.0 - hsv.y);\n    float q = hsv.z * (1.0 - hsv.y * f);\n    float t = hsv.z * (1.0 - hsv.y * (1.0 - f));\n    \n    switch(i){\n        case 0:\n        \treturn vec3(hsv.z, t, p);\n        case 1:\n        \treturn vec3(q, hsv.z, p);\n        case 2:\n        \treturn vec3(p, hsv.z, t);\n        case 3:\n        \treturn vec3(p, q, hsv.z);\n        case 4:\n        \treturn vec3(t, p, hsv.z);\n        case 5:\n        \treturn vec3(hsv.z, p, q);\n    }\n}\n\nvec3 iterate(vec2 c){\n \t\n    vec2 z = vec2(0.0);\n    \n    int i = MAX_DWELL;\n    \n    float ac = length(c);\n    \n    float sum = 0.0;\n    float sum2 = 0.0;\n    \n    for(int n = 0; n < MAX_DWELL; n++){\n    \t\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        \n        float az = length(z);\n        \n        if(az > BAILOUT){\n            i = n;\n            break;\n        }\n        \n        sum2 = sum;\n        \n        if(n != 0 && n != MAX_DWELL - 1){\n            float d = length(z - c);\n            float m1 = abs(d - ac);\n            float m2 = d + ac;\n            \n            sum += (az - m1) / (m2 - m1);\n        }\n    }\n    \n    if(i == MAX_DWELL) return vec3(0.0);\n    \n    sum /= float(i);\n    sum2 /= float(i - 1);\n    \n    float f = 1.0 / log(2.0) * (log(log(BAILOUT)) - log(log(length(z))));\n    \n    float tia = sum2 + (sum - sum2) * (f + 1.0);\n    tia = sin(tia * 1.57079632679);\n    \n    float esc = float(i) + f;\n    \n    return pow(tia, 12.0) * HSVtoRGB(vec3((log(esc)) / 20.0 - 0.16, 1.0, 1.0)) * pow(log(esc), 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 col = vec3(0.0);\n    \n    for(float dx = 0.0; dx < 1.0; dx += 1.0/float(AA)){\n    \tfor(float dy = 0.0; dy < 1.0; dy += 1.0/float(AA)){\n     \t\t\n    \t\tvec2 c = ((fragCoord + vec2(dx, dy)) * 2.0 - iResolution.xy)/iResolution.y;\n            \n            c = c * 0.0001 + vec2(-0.749007, 0.099852);\n            \n            col += iterate(c);\n    \t}\n    }\n    \n    col /= float(AA * AA);\n    col *= 5.0;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}