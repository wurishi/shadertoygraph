{"ver":"0.1","info":{"id":"NsdcD4","date":"1655103214","viewed":539,"name":"SDF tracing framework II","username":"fancyzero","description":"SDF tracing framework  with materials","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["sdftracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"sdf tracing framework \" by fancyzero. https://shadertoy.com/view/NljfRw\n// 2022-05-25 11:40:20\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n//set to 2 for better quality\n#define AA 1  \n#endif\n\n\n#define ZERO (min(iFrame,0))\n//for debug purpose, very slow\n#define DRAW_RAYS \n\n\n#define STEPS 50\n#define MAT_GLASS 0\n#define MAT_MILK 1\n#define MAT_FRAME 2\n\n#define MAX_SEGMENTS 8\n\nconst float stopEps = 0.01;\n#define advance  4.0\n//;//.0;\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat FresnelRef(float b, float c) \n{\n    return .5 * (pow(tan(b - c) / tan(b + c), 2.) + sqrt(sin(b - c)) / sqrt(sin(b + c))); \n}\n\nvec2 Snell( float n1, float n2, float t1) \n{ \n\n    float t2 = asin(n1 / n2 * sin(t1)); \n    \n    float R = FresnelRef(abs(t1), abs(t2)); \n    return vec2(t2, 1.-clamp(R,0.,1.));\n}\n\n\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n    float bL = length(lE - lS);\n    if ( bL < 0.00001)\n        return 10000.0;\n    vec3 bD = (lE - lS) / bL;\n    vec3 tD = lS - rP;\n    float aDb = dot(rD, bD);\n    \n    float aDt = dot(rD, tD);\n    float bDt = dot(bD, tD);\n    float u = (aDt - bDt * aDb) / (1.- aDb * aDb);\n    float v = max(min(u * aDb - bDt, bL), 0.);\n    u = max(min(v * aDb + aDt, 1e6), 0.);\n    return length((rP + rD * u) - (lS + bD * v));\n}\n\n\n\nvec4 drawLine(vec3 start, vec3 dir, vec3 a, vec3 b , vec4 color, vec4 fragColor)\n{\n    float d = RayLineSegmentDistance(start, dir, a, b);\n    return mix( color, fragColor, smoothstep(0.0,8./iResolution.y,d));\n\n}\n \n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\n    //float aa = length(p+vec3(0.5,0,0)) - 1.;\n    //float bb = length(p-vec3(0.5,0,0)) - 1.;\n    //return min(aa,bb);\n    b-=vec3(r);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n\nmat3x3 LookAt( vec3 src, vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target-src);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3x3(right, up, forward);\n}\n\n\nstruct TraceResult\n{\n    vec3 pos;\n    float d;\n    float iters;\n    float lastD;\n    float traveled;\n    bool hit;\n    int material;\n};\n\nfloat sdSphere(vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat map( vec3  p, out int materialID)\n{\n    float r = 0.1;//mix(0.01,0.5,smoothstep(-1.,1.,sin(iTime)));\n\n    \n    float d1 = sdRoundBox(p + vec3(0, 0., 0), vec3(1. ,1,0.75) , 0.01);\n    float d3 = sdRoundBox(p - vec3(0, 0.1, 0), vec3(.95 ,1.05,0.70) , r);\n    float d0 = sdRoundBox(p + vec3(0, 0., 0), vec3(.9 ,1.,0.65), r);\n    \n    \n    float d2 = 100000.;\n    \n    for ( int i = 0; i < 30; i++ )\n    {       \n        vec3 pp = hash(uvec3(i*42, iDate.z*31854.,i*693));\n        vec3 qq = hash(uvec3(i*853, i*354,i*883));\n        float z = mix(-0.9,0.9,pp.y);\n        float rr = mix(0.3,0.6,qq.x);\n        float y = mix(0.8,1.1,qq.y);\n        d2 = smin(d2,sdSphere( p - vec3(sin(iTime*pp.x*3.+pp.z*10.),y,z), rr),0.4);\n    }\n\n    \n    float d4 = max( d1, -d3);\n    float d5 = max( d0,-d2);\n    if ( d4 < d5 )\n    materialID = 0;\n    else\n    materialID = 1;\n    return min(d4,d5);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    int dummy;\n    float eps = 0.05;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e,dummy);\n    }\n    return normalize(n);\n}\n\n\nTraceResult trace( vec3 start, vec3 dir, float maxLength)\n{\n    TraceResult tr;\n    tr.hit = false;\n    tr.pos = start;\n    float traveled = 0.;\n    int i = 0;\n    vec3 colorFade = vec3(1);\n    int matID = 0;\n    for ( i = 0; i < STEPS; i++ )\n    {\n        \n        float d = map(tr.pos,matID);\n        \n        tr.lastD = sign(d);\n        if ( abs(d) < stopEps)\n        {\n            tr.d = length(start-tr.pos);\n            \n            tr.iters = float(i)/float(STEPS);\n            tr.material  = matID;\n            tr.hit = true;\n            return tr;\n        }\n        tr.pos += dir*abs(d);\n        traveled += abs(d);       \n        if ( traveled > maxLength )\n            break;\n        \n        \n    }\n    tr.traveled = traveled;\n    tr.material = matID;\n    tr.iters = -1.;//float(i);\n    return tr;\n}\n\n\nconst float airIOR = 1.0;\nconst float glassIOR = 1.5;\n\nstruct Segment\n{\n    vec3 start;\n    vec3 end;\n    vec3 color;\n    float intensity;\n    float iters;\n    bool hit;\n    bool inside;\n    vec3 n;\n    int material;\n};\n\n\n\nSegment[MAX_SEGMENTS] rayTrace( vec3 start, vec3 dir, int depth, out int validSegments )\n{\n    dir = normalize(dir);\n    Segment[MAX_SEGMENTS] segments;\n    \n    validSegments = 0;\n    float iorA = 1.5;\n    float iorB = 1.;\n    \n    for( int i = 0; i < MAX_SEGMENTS-1; i++ )\n    {\n        TraceResult tr = trace(start, dir, 10.);\n\n        segments[i].start = start;\n        segments[i].end = tr.pos;\n        segments[i].hit = tr.hit;\n        segments[i].iters = tr.iters;\n        segments[i].n = getNormal(tr.pos);\n        segments[i].inside = tr.lastD < 0.;\n        segments[i].material = tr.material;\n\n\n        vec3 n = segments[i].n;\n        \n        \n        if ( i == 0)\n        {\n            vec2 snell = Snell( iorB, iorA, acos(dot(dir,-n)));\n            segments[MAX_SEGMENTS-1].start = tr.pos;\n            segments[MAX_SEGMENTS-1].end = reflect(dir, n) + tr.pos;\n            segments[MAX_SEGMENTS-1].intensity = 1.-snell.y;\n        }        \n        \n        if (tr.hit)\n            validSegments ++ ;\n        else\n            return segments;        \n\n        vec3 newDir = vec3(0);\n\n        if ( tr.lastD > 0. )\n        {\n            newDir = refract(dir,n,iorB/iorA);\n            \n        }\n        else\n        {\n            newDir = refract(dir,-n,iorA/iorB);\n\n        }\n        \n        \n        if ( dot(newDir,newDir) < 0.0001) //total internal reflection\n        {\n            newDir = reflect(dir, -n);\n            start = tr.pos + newDir * stopEps*advance;//tr.lastD*n*stopEps*advance;\n        }\n        else\n        {\n        \n            start = tr.pos -n * tr.lastD* stopEps*advance;//-tr.lastD*n*stopEps*advance;\n        }\n        dir = newDir;\n        \n    }\n\n\n      \n    return segments;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n float nearPlane = 0.1;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 txtUV = uv;\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if (iFrame == 0 )\n        mousePos = vec2(0.6,0.2);\n\n    vec3 cam = vec3(4., 4., 4.);\n    \n    float fov = 45.0/180.*3.14159;\n    float aspect = iResolution.y / iResolution.x;\n    float w = nearPlane * tan(fov);\n    float h = aspect * w;\n\n    vec3 vlt = vec3(-w / 2., -h / 2., nearPlane);\n    vec3 vrb = vec3(w / 2., h / 2., nearPlane);\n\n    \n    float theta = mousePos.x * 4.*3.14+1.5;\n    float phi = (1.-mousePos.y)*3.14*2.+1.5;\n    cam = vec3(cos(theta) * sin(phi),\n           cos(phi),\n            sin(theta) * sin(phi)) * 7.6;\n    vec4 allColor = vec4(0.);\n    for ( int m =0; m < AA; m++ )\n    {\n        for ( int k =0; k < AA; k++ )\n        {\n            float ox = 1./iResolution.x/float(AA)*float(m);\n            float oy= 1./iResolution.y/float(AA)*float(k);\n            vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x+ox), mix(vlt.y, vrb.y, uv.y+oy), nearPlane);\n\n            rayDir = normalize(rayDir);\n\n            mat3x3 rot = LookAt(cam, vec3(0., 0., 0.), vec3(0., 1., 0.));\n            rayDir = normalize(rot * rayDir);\n\n\n\n            int validSegments;\n            Segment[MAX_SEGMENTS] segments = rayTrace(cam, rayDir, 0, validSegments);    \n            vec4 bg = texture(iChannel0, ( rayDir) );\n            vec4 box = vec4(0.);\n            //segments[5] contains the reflected fraction of the first bounce\n            if (validSegments > 0)\n            {\n                \n                vec3 lightAbsorp = vec3(1);           \n                for (int i=0; i < validSegments; i++ )\n                {\n                    if ( segments[i].material == 1 )\n                    {\n                        float l = length(segments[i].end - segments[i].start);\n                        lightAbsorp = vec3(exp(-l*vec3(0.0,8,0.8))); \n                    }\n                }\n                fragColor =  texture(iChannel0, normalize(segments[validSegments-1].end-segments[validSegments-1].start)) *(1.- segments[MAX_SEGMENTS-1].intensity);\n                fragColor.xyz *= lightAbsorp;\n                fragColor += (texture(iChannel0 , normalize(segments[MAX_SEGMENTS-1].end-segments[MAX_SEGMENTS-1].start)))*segments[MAX_SEGMENTS-1].intensity;\n            }\n            else \n            {\n                fragColor = bg;\n            }\n            \n\n            allColor += fragColor;\n        }\n     }  \n    \n    fragColor = allColor/float(AA*AA);    \n    \n    \n#if defined DRAW_RAYS        \n    uv = fragCoord / iResolution.xy;\n    vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x), mix(vlt.y, vrb.y, uv.y), nearPlane);\n    mat3x3 rot = LookAt(cam, vec3(0., 0., 0.), vec3(0., 1., 0.));\n    rayDir = normalize(rot * rayDir);\n    \n    \n    int validSegments = MAX_SEGMENTS;\n    for (int j = 0; j < DEBUG_RAY_COUNT; j++ )\n    {\n        Segment[MAX_SEGMENTS] segments ;\n        for ( int i = 0; i < MAX_SEGMENTS; i++ )\n        {\n            segments[i].start = texelFetch( iChannel1, ivec2(i*2+0,j),0).xyz;\n            segments[i].end = texelFetch( iChannel1, ivec2(i*2+1,j),0).xyz;\n        }\n            for( int i = 0; i <min(MAX_SEGMENTS-2,validSegments+1); i++ )\n            {\n                vec4 lineColor = mix( vec4(0.059,0.902,0.114,1), vec4(0.933,0.067,0.486,1), float(i)/float(validSegments+1));\n                fragColor = drawLine(cam,rayDir, segments[i].start, segments[i].end,lineColor,fragColor);\n                //fragColor = drawLine(cam,rayDir, segments[i].end, segments[i].end+segments[i].n*0.1,vec4(1,0,1,1),fragColor);\n            }\n    }\n\n    //fragColor = drawLine(cam,rayDir, segments[5].start, segments[5].end,vec4(0.5,0.5,0.5,1.),fragColor);\n\n#endif    \n\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n#define ZERO (min(iFrame,0))\n//for debug purpose, very slow\n//#define DRAW_RAYS \n\n\n#define STEPS 50\n#define MAT_GLASS 0\n#define MAT_MILK 1\n#define MAT_FRAME 2\n\n#define MAX_SEGMENTS 8\n\nconst float stopEps = 0.01;\n#define advance  4.0\n//;//.0;\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat FresnelRef(float b, float c) \n{\n    return .5 * (pow(tan(b - c) / tan(b + c), 2.) + sqrt(sin(b - c)) / sqrt(sin(b + c))); \n}\n\nvec2 Snell( float n1, float n2, float t1) \n{ \n\n    float t2 = asin(n1 / n2 * sin(t1)); \n    \n    float R = FresnelRef(abs(t1), abs(t2)); \n    return vec2(t2, 1.-clamp(0.,1.,R));\n}\n\n\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n    float bL = length(lE - lS);\n    if ( bL < 0.00001)\n        return 10000.0;\n    vec3 bD = (lE - lS) / bL;\n    vec3 tD = lS - rP;\n    float aDb = dot(rD, bD);\n    \n    float aDt = dot(rD, tD);\n    float bDt = dot(bD, tD);\n    float u = (aDt - bDt * aDb) / (1.- aDb * aDb);\n    float v = max(min(u * aDb - bDt, bL), 0.);\n    u = max(min(v * aDb + aDt, 1e6), 0.);\n    return length((rP + rD * u) - (lS + bD * v));\n}\n\n\n\nvec4 drawLine(vec3 start, vec3 dir, vec3 a, vec3 b , vec4 color, vec4 fragColor)\n{\n    float d = RayLineSegmentDistance(start, dir, a, b);\n    return mix( color, fragColor, smoothstep(0.008,0.01,d));\n\n}\n \n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\n    //float aa = length(p+vec3(0.5,0,0)) - 1.;\n    //float bb = length(p-vec3(0.5,0,0)) - 1.;\n    //return min(aa,bb);\n    b-=vec3(r);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n\nmat3x3 LookAt( vec3 src, vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target-src);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3x3(right, up, forward);\n}\n\n\nstruct TraceResult\n{\n    vec3 pos;\n    float d;\n    float iters;\n    float lastD;\n    float traveled;\n    bool hit;\n    int material;\n};\n\nfloat sdSphere(vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat map( vec3  p, out int materialID)\n{\n    float r = 0.1;//mix(0.01,0.5,smoothstep(-1.,1.,sin(iTime)));\n\n    \n    float d1 = sdRoundBox(p + vec3(0, 0., 0), vec3(1. ,1,0.75) , 0.01);\n    float d3 = sdRoundBox(p - vec3(0, 0.1, 0), vec3(.95 ,1.05,0.70) , r);\n    float d0 = sdRoundBox(p + vec3(0, 0., 0), vec3(.9 ,1.,0.65), r);\n    \n    \n    float d2 = 100000.;\n    \n    for ( int i = 0; i < 30; i++ )\n    {       \n        vec3 pp = hash(uvec3(i*42, iDate.z*31854.,i*693));\n        vec3 qq = hash(uvec3(i*853, i*354,i*883));\n        float z = mix(-0.9,0.9,pp.y);\n        float rr = mix(0.3,0.6,qq.x);\n        float y = mix(0.8,1.1,qq.y);\n        d2 = smin(d2,sdSphere( p - vec3(sin(iTime*pp.x*3.+pp.z*10.),y,z), rr),0.4);\n    }\n\n    \n    float d4 = max( d1, -d3);\n    float d5 = max( d0,-d2);\n    if ( d4 < d5 )\n    materialID = 0;\n    else\n    materialID = 1;\n    return min(d4,d5);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    int dummy;\n    float eps = 0.05;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e,dummy);\n    }\n    return normalize(n);\n}\n\n\nTraceResult trace( vec3 start, vec3 dir, float maxLength)\n{\n    TraceResult tr;\n    tr.hit = false;\n    tr.pos = start;\n    float traveled = 0.;\n    int i = 0;\n    vec3 colorFade = vec3(1);\n    int matID = 0;\n    for ( i = 0; i < STEPS; i++ )\n    {\n        \n        float d = map(tr.pos,matID);\n        \n        tr.lastD = sign(d);\n        if ( abs(d) < stopEps)\n        {\n            tr.d = length(start-tr.pos);\n            \n            tr.iters = float(i)/float(STEPS);\n            tr.material  = matID;\n            tr.hit = true;\n            return tr;\n        }\n        tr.pos += dir*abs(d);\n        traveled += abs(d);       \n        if ( traveled > maxLength )\n            break;\n        \n        \n    }\n    tr.traveled = traveled;\n    tr.material = matID;\n    tr.iters = -1.;//float(i);\n    return tr;\n}\n\n\nconst float airIOR = 1.0;\nconst float glassIOR = 1.5;\n\nstruct Segment\n{\n    vec3 start;\n    vec3 end;\n    vec3 color;\n    float intensity;\n    float iters;\n    bool hit;\n    bool inside;\n    vec3 n;\n    int material;\n};\n\n\n\nSegment[MAX_SEGMENTS] rayTrace( vec3 start, vec3 dir, int depth, out int validSegments )\n{\n    dir = normalize(dir);\n    Segment[MAX_SEGMENTS] segments;\n    \n    validSegments = 0;\n    float iorA = 1.5;\n    float iorB = 1.;\n    \n    for( int i = 0; i < MAX_SEGMENTS-1; i++ )\n    {\n        TraceResult tr = trace(start, dir, 10.);\n\n        segments[i].start = start;\n        segments[i].end = tr.pos;\n        segments[i].hit = tr.hit;\n        segments[i].iters = tr.iters;\n        segments[i].n = getNormal(tr.pos);\n        segments[i].inside = tr.lastD < 0.;\n        segments[i].material = tr.material;\n\n\n        vec3 n = segments[i].n;\n        \n        \n        if ( i == 0)\n        {\n            vec2 snell = Snell( iorB, iorA, acos(dot(dir,-n)));\n            segments[MAX_SEGMENTS-1].start = tr.pos;\n            segments[MAX_SEGMENTS-1].end = reflect(dir, n) + tr.pos;\n            segments[MAX_SEGMENTS-1].intensity = 1.-snell.y;\n        }        \n        \n        if (tr.hit)\n            validSegments ++ ;\n        else\n            return segments;        \n\n        vec3 newDir = vec3(0);\n\n        if ( tr.lastD > 0. )\n        {\n            newDir = refract(dir,n,iorB/iorA);\n            \n        }\n        else\n        {\n            newDir = refract(dir,-n,iorA/iorB);\n\n        }\n        \n        \n        if ( dot(newDir,newDir) < 0.0001) //total internal reflection\n        {\n            newDir = reflect(dir, -n);\n            start = tr.pos + newDir * stopEps*advance;//tr.lastD*n*stopEps*advance;\n        }\n        else\n        {\n        \n            start = tr.pos -n * tr.lastD* stopEps*advance;//-tr.lastD*n*stopEps*advance;\n        }\n        dir = newDir;\n        \n    }\n\n\n      \n    return segments;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ( int(fragCoord.y) > DEBUG_RAY_COUNT)\n    return;\n float nearPlane = 0.1;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 txtUV = uv;\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if (iFrame == 0 )\n        mousePos = vec2(0.6,0.2);\n\n    vec3 cam = vec3(4., 4., 4.);\n    \n    float fov = 45.0/180.*3.14159;\n    float aspect = iResolution.y / iResolution.x;\n    float w = nearPlane * tan(fov);\n    float h = aspect * w;\n\n    vec3 vlt = vec3(-w / 2., -h / 2., nearPlane);\n    vec3 vrb = vec3(w / 2., h / 2., nearPlane);\n\n    \n    float theta = mousePos.x * 4.*3.14+1.5;\n    float phi = (1.-mousePos.y)*3.14*2.+1.5;\n    cam = vec3(cos(theta) * sin(phi),\n           cos(phi),\n            sin(theta) * sin(phi)) * 7.6;\n    vec4 allColor = vec4(0.);\n\n    \n    \n\n    uv = fragCoord / iResolution.xy;\n   \n    \n    int validSegments = 0;\n    int j = int(fragCoord.y);\n    \n    vec3 start = vec3(1,2,-0.333/2.) + vec3(0.4,0,0)*float(j/3)+vec3(0,0,0.2)*float(j%3);\n\n\n    \n    vec3 dir = normalize(vec3(-1,-1,0));\n    \n    Segment[MAX_SEGMENTS] segments = rayTrace(start, dir, 0, validSegments);\n    \n    int x = int(fragCoord.x);\n    if ( x %2 == 0 )\n        fragColor.xyz = segments[x/2].start;\n    else\n        fragColor.xyz = segments[x/2].end;\n\n\n}\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DEBUG_RAY_COUNT 9","name":"Common","description":"","type":"common"}]}