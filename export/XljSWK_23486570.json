{"ver":"0.1","info":{"id":"XljSWK","date":"1446652629","viewed":277,"name":"CSG Lichtspiel","username":"MacSlow","description":"Trying out some things like different colors/materials per object, skipping lights for receiving shadows...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Basic raymarching-renderer\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red   = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst int MAX_STEPS = 64;\nconst float epsilon = 0.0001;\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nmat4 rotX (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0,   c,   s, 0.0),\n                     vec4 (0.0,  -s,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat opIntersect (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat sphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec3 n)\n{\n    return length (p.xz - n.xy) - n.z;\n}\n\nfloat wavyfloor (vec3 p, vec4 n)\n{\n    float tm = iTime;\n    return dot (p.xyz, n.xyz) + n.w - .1 * sin (4. * p.x) * cos (4. * p.z);\n}\n\nfloat csgdice (vec3 p)\n{\n    float d1 = .0;\n    float d2 = .0;\n\n    // dice with holes\n    mat4 m = trans (vec3 (.0, .0, .0));\n    mat4 m1 = rotX (90.) * trans (vec3 (.35, .5, 2.75));\n    mat4 m2 = trans (vec3 (.35, .2, .5));\n    d1 = opIntersect (box (opTransf (p, m), vec3 (.55), .0),\n                      sphere (opTransf (p, m), .7));\n    d2 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)),\n                     d1);\n    d1 = opSubtract (cylinder (opTransf (p, m2), vec3 (.35, .5, .35)),\n                     d2);\n    m1 = rotZ (90.) * trans (vec3 (1.25, -.35, .5));\n    d2 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)), d1);\n\n    return d2;\n}\n\nfloat map (vec3 p, inout int index, bool withoutlights)\n{\n    float d = .0;\n    float ground = .0;\n    float dicea = .0;\n    float diceb = .0;\n    float lighta = .0;\n    float lightb = .0;\n    float t = iTime;\n\n    // floor\n    ground = wavyfloor (p, normalize (vec4 (.0, -1., .0, 1.)));\n\n    // first dice\n    mat4 m = rotX (30. * t) * rotY (40. * t) * rotZ (50. * t) * trans (vec3 (.0, .5, 1.));\n    dicea = csgdice (opTransf (p, m));\n\n    // second dice\n    m = rotX (40. * t) * rotY (50. * t) * rotZ (30. * t) * trans (vec3 (-2., .5, 1.));\n    diceb = csgdice (opTransf (p, m));\n\n    d = min (ground, min (dicea, diceb));\n\n    // \"lightsources\"\n    if (!withoutlights) {\n        m = trans (vec3 (.0, .5, 1.));\n        lighta = sphere (opTransf (p, m), .05);\n        m = trans (vec3 (-2., .5, 1.));\n        lightb = sphere (opTransf (p, m), .05);\n        d = min (d, min (lighta, lightb));\n        if (d == lighta || d == lightb) {\n            index = 4;\n        }\n    }\n\n    // assign \"color/material\"-index\n    if (d == ground) {\n        index = 1;\n    } else if (d == dicea) {\n        index = 2;\n    } else if (d == diceb) {\n        index = 3;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec3 e = vec3 (.0001, .0, .0);\n    int index = 0;\n\n    vec3 n = vec3 (map (p + e.xyy, index, false) - map (p - e.xyy, index, false),\n                   map (p + e.yxy, index, false) - map (p - e.yxy, index, false),\n                   map (p + e.yyx, index, false) - map (p - e.yyx, index, false));\n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    int index = 0;\n    for (int i = 0; i < 64; i++) {\n        d = map (ro + rd * t, index, true);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d*.75;\n    }\n    return s;\n}\n\nvec4 shade (vec3 p, vec4 color)\n{\n\t// animate the light-sources a bit\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (.0, -.5, -1.);\n    vec3 lPos1 = vec3 (4. * cos (radians (1.)), -4., 4. * sin (radians (1.)));\n    vec3 lPos2 = vec3 (2., -.5, -1.);\n\n    vec4 lCol = white;\n    vec3 n = normal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    vec4 lInt0 = lCol * max (dot (n, lDir0), .0);\n    vec4 lInt1 = lCol * max (dot (n, lDir1), .0);\n    vec4 lInt2 = lCol * max (dot (n, lDir2), .0);\n    vec4 col = shadow (p+.001*normalize (lPos0 - p), normalize (lPos0 - p), .001, 64.) * .7 * lInt0 * color;\n    col += shadow (p+.001*normalize (lPos1 - p), normalize (lPos1 - p), .001, 64.) * .7 * lInt1 * color;\n    col += shadow (p+.001*normalize (lPos2 - p), normalize (lPos2 - p), .001, 64.) * .7 * lInt1 * color;\n\n    return col;\n}\n\nmat3 camera (vec3 eye, vec3 aim, float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nfloat march (vec3 ro, vec3 rd, float pixelSize, inout int index)\n{\n    bool forceHit = true;\n    float infinity = 10000.0;\n    float t_min = .00001;\n    float t_max = 100.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = .5;\n    float lastd = .0;\n    float stepSize = .0;\n    int mindex = 0;\n    float sign = map (ro, mindex, false) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t, index, false);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = .25;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n\treturn candidate;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (8. * mouse.x + 25.) * 9.,\n\t\t\t\t\t -6.,\n\t\t\t\t\t sin (8. * mouse.x + 25.) * 9.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    vec2 uv = vec2 (-.75 + fragCoord.x / iResolution.y, .5 - fragCoord.y / iResolution.y);\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (uv, 1.8));\n    vec4 bg = vec4 (.0);\n    float pixelSize = 1. / iResolution.x;\n    int index = 0;\n    float t = march (ro, rd, pixelSize, index);\n    vec4 color;\n    if (index  == 1) {\n\t    color = mix (shade (ro + rd * t, white), bg, length (rd * t) / 30.);\n    } else if (index == 2) {\n    \tcolor = mix (shade (ro + rd * t, red), bg, length (rd * t) / 30.);\n    } else if (index == 3) {\n    \tcolor = mix (shade (ro + rd * t, green), bg, length (rd * t) / 30.);\n    } else if (index == 4) {\n    \tcolor = white;\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}