{"ver":"0.1","info":{"id":"dsGBRd","date":"1698518303","viewed":44,"name":"2d fbm simplex noise","username":"DeltaT","description":"doesn't look great with low number of octaves (triangle pattern is quite visible)\nbut looks better than perlin with high number of octaves","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","fbm","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float influence(vec2 v) {\n    v *= 1.1547005; // 1/sqrt(0.75)\n    float d = clamp(1.-dot(v, v), 0., 1.);\n    return d*d*d;\n}\n\nvec2 hash22(vec2 p) { // hash function taken from shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 v, int seed) {\n    const mat2 unskew = mat2(1., 0., -0.5773503, 1.1547005); // -(1/sqrt(0.75))/2 and 1/sqrt(0.75)\n    const mat2 skew = mat2(1., 0., 0.5, 0.8660254); // sqrt(0.75)\n    \n    vec2 v1 = unskew*v;\n    vec2 grid = floor(v1);\n    float s = float(seed)*3.14159;\n    float c = fract(v1).x + fract(v1).y < 1. ? 0. : 1.;\n    vec2[3] tri = vec2[3](grid+vec2(-c+1., c), grid+vec2(c, -c+1.), grid+vec2(c)); // verts on right angled triangle\n    vec2[3] rand = vec2[3](hash22(tri[0]+s), hash22(tri[1]+s), hash22(tri[2]+s));\n    vec2[3] corners = vec2[3](v-skew*tri[0], v-skew*tri[1], v-skew*tri[2]);\n    return 2.*(\n        dot(rand[0], corners[0])*influence(corners[0])\n      + dot(rand[1], corners[1])*influence(corners[1])\n      + dot(rand[2], corners[2])*influence(corners[2])\n    );\n}\n\nfloat fbm(vec2 coord, int numOctaves) {\n    float a = 1.;\n    float f = 1.;\n    float m = 1.;\n    float result = 0.;\n    \n    for (int i = 0; i < numOctaves; i++) {\n        result += noise(coord*f, i)*a;\n        a /= 2.;\n        f *= 2.;\n        m += a;\n    }\n    return result/m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 2.;\n    float time = clamp(iTime, 0., 8.);\n    float noise = mix(fbm(uv, int(time)), fbm(uv, int(time)+1), fract(time));\n    \n    fragColor = vec4(vec3(noise+0.5), 1);\n}","name":"Image","description":"","type":"image"}]}