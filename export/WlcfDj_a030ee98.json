{"ver":"0.1","info":{"id":"WlcfDj","date":"1621398228","viewed":503,"name":"2D Particle Sandbox","username":"oneshade","description":"An old shader I was working on.","likes":17,"published":3,"flags":32,"usePreview":0,"tags":["2d","simulation","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float Dt) {\n    vec2 p0 = p - o, p1 = v * Dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Draw particles\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int id=0; id < PARTICLES; id++) {\n        Particle p = loadParticle(id);\n        vec3 color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), p.radius / 0.025);\n        fragColor.rgb += color * movingDisk(uv, p.pos, p.radius, p.vel, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Settings\n#define PARTICLES 200\n\n#define GRAVITY 0.00001\n#define DECAY 0.8\n#define dt 1.0\n\n#define EPSILON 0.001\n\n// Utilities\nstruct Particle {\n    int id;\n    vec2 pos;\n    vec2 vel;\n    float mass;\n    float radius;\n};\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Initialize\nvec4 initParticle(in ivec2 addr) {\n    if (addr.x < PARTICLES) {\n        float x = float(addr.x) + iDate.w;\n        if (addr.y == 0) return vec4(Hash12(x + 274.937) - 0.5, 0.0, 0.0);\n        if (addr.y == 1) return vec4((Hash12(x + 385.583) - 0.5) * 0.001, 0.0, 0.0);\n        if (addr.y == 2) return vec4(max(0.1, Hash11(x + 858.938) * 0.25), 0.0, 0.0, 0.0);\n        if (addr.y == 3) return vec4(max(0.01, Hash11(x + 374.497) * 0.025), 0.0, 0.0, 0.0);\n        return vec4(0.0);\n    }\n\n    return vec4(0.0);\n}\n\n// Load/store\n#define loadParticle(pid)                                \\\n    Particle(pid,                                        \\\n             texelFetch(iChannel0, ivec2(pid, 0), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 1), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 2), 0).x,  \\\n             texelFetch(iChannel0, ivec2(pid, 3), 0).x)  \\\n\nvec4 storeParticle(in Particle p, in ivec2 addr) {\n    if (addr.y == 0) return vec4(p.pos, 0.0, 0.0);\n    if (addr.y == 1) return vec4(p.vel, 0.0, 0.0);\n    if (addr.y == 2) return vec4(p.mass, 0.0, 0.0, 0.0);\n    if (addr.y == 3) return vec4(p.radius, 0.0, 0.0, 0.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Force particles to stay within boundaries\nvec2 constrain(in vec2 pos, in vec2 constraints, in float radius) {\n    constraints -= radius - EPSILON;\n    return clamp(pos, -constraints, constraints);\n}\n\nParticle updateParticle(in Particle p, in vec2 constraints) {\n    vec2 f = vec2(0.0); // Force vector (all forces get added into it)\n    f.y -= GRAVITY;\n\n    float t = iTime * 10.0;\n    f += vec2(cos(t), sin(t)) * 0.0001;\n\n    // Boundary collisions\n    if (abs(p.pos.x) > constraints.x - p.radius) {\n        p.vel.x *= -1.0;\n        p.vel *= DECAY;\n    }\n\n    if (abs(p.pos.y) > constraints.y - p.radius) {\n        p.vel.y *= -1.0;\n        p.vel *= DECAY;\n    }\n\n    // Particle-particle collisions\n    for (int id=0; id < PARTICLES; id++) {\n        if (id != p.id) {\n            Particle p2 = loadParticle(id);\n            vec2 dir = p.pos - p2.pos;\n            float dist = length(dir);\n            float rsum = p.radius + p2.radius;\n            if (dist < rsum) {\n                vec2 n = dir / dist;\n                p.pos -= n * (dist - rsum);\n                vec2 pn = n.yx * vec2(-1.0, 1.0);\n                p.vel = dot(p2.vel, n) * n + dot(p.vel, pn) * pn; // How to account different masses?\n            }\n        }\n    }\n\n    // Update\n    p.vel += f / p.mass * dt;\n    p.pos = constrain(p.pos + p.vel * dt, constraints, p.radius);\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 constraints = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = initParticle(iFragCoord);\n    if (iFrame > 0) {\n        if (iFragCoord.x < PARTICLES && iFragCoord.y < 4) {\n            Particle p = loadParticle(iFragCoord.x);\n            p = updateParticle(p, constraints);\n            fragColor = storeParticle(p, iFragCoord);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}