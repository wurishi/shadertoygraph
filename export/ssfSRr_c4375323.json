{"ver":"0.1","info":{"id":"ssfSRr","date":"1618180248","viewed":256,"name":"2D raymarching example","username":"sver","description":"Basic example of ray marching","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","sdf","triangle","line","circle","rasterization","segment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float epsilon;\nconst int cC = 4;\nconst int lC = 1;\nconst int tC = 1;\nconst int qC = 2;\n\nstruct Circle {\n    vec2 center;\n    float radius;\n    vec3 col;\n};\n\nstruct Line {\n    vec2[2] v;\n    vec3 col;\n};\n\nstruct Triangle {\n    vec2[3] v;\n    vec3 col;\n};\n\nstruct Quad {\n    vec2[4] v;\n    vec3 col;\n};\n\nstruct Scene {\n    Circle[cC] cs;\n    Line[lC] ls;\n    Triangle[tC] ts;\n    Quad[qC] qs;\n} scene;\n\nfloat isRay(vec2 uv, vec2 orig, vec2 dir, float len) {\n    vec2 u = uv - orig;\n    if (dot(normalize(u), dir) < 0.0 || length(uv - orig) > len) return 0.0;\n    return smoothstep(epsilon, 0., abs(u.y * dir.x - u.x * dir.y));\n}\n\nfloat isLineSegment(vec2 uv, vec2 v[2]) {\n    return isRay(uv, v[0], normalize(v[1] - v[0]), length(v[1]-v[0])) ;\n}\n\nbool isPointRightOfLine(vec2 point, vec2 v[2]) {\n    vec2 l = v[0] - v[1];\n    vec2 N =  normalize(vec2(-l.y, l.x));\n    return dot(N, normalize(point - v[0])) > 0.0;\n}\n\nfloat isCirleOutline(vec2 uv, vec2 cen, float r) {\n    float t = length(uv - cen);\n    return smoothstep(epsilon, 0., abs(t-r));\n}\n\nbool isCircle(vec2 uv, vec2 cen, float r) {\n    return length(uv - cen) < r;\n}\n\nfloat isTriangleOutline(vec2 uv, vec2 v[3]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = isLineSegment(uv, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[2], v[0]);\n    return max(t, isLineSegment(uv, l));\n}\n\nbool isTriangle(vec2 uv, vec2 v[3]) {\n    vec2 l1[2] = vec2[2](v[0], v[1]);\n    vec2 l2[2] = vec2[2](v[1], v[2]);\n    vec2 l3[2] = vec2[2](v[2], v[0]);\n    return isPointRightOfLine(uv, l1)\n        && isPointRightOfLine(uv, l2)\n        && isPointRightOfLine(uv, l3);\n}\n\nfloat isQuadOutline(vec2 uv, vec2 v[4]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = isLineSegment(uv, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[2], v[3]);\n    tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[3], v[0]);\n    return max(t, isLineSegment(uv, l));\n}\n\nbool isQuad(vec2 uv, vec2 v[4]) {\n    vec2 l1[2] = vec2[2](v[0], v[1]);\n    vec2 l2[2] = vec2[2](v[1], v[2]);\n    vec2 l3[2] = vec2[2](v[2], v[3]);\n    vec2 l4[2] = vec2[2](v[3], v[0]);\n    return isPointRightOfLine(uv, l1)\n        && isPointRightOfLine(uv, l2)\n        && isPointRightOfLine(uv, l3)\n        && isPointRightOfLine(uv, l4);\n    \n}\n\nfloat distToLineSeg(vec2 orig, vec2 v[2]) {\n    vec2 pa = orig - v[0];\n    vec2 ba = v[1] - v[0];\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n\nfloat distToTriangle(vec2 orig, vec2 v[3]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = distToLineSeg(orig, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[2], v[0]);\n    return min(t, distToLineSeg(orig, l));\n}\n\nfloat distToQuad(vec2 orig, vec2 v[4]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = distToLineSeg(orig, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[2], v[3]);\n    tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[3], v[0]);\n    return min(t, distToLineSeg(orig, l));\n}\n\nfloat closestDist(vec2 orig) {\n   float t = 9999.0, tt;\n   for (int i = 0; i < scene.cs.length(); i++) {\n       tt = pow(length(orig - scene.cs[i].center) - scene.cs[i].radius, 2.0);\n       t = min(t, tt);\n   }\n   \n   for (int i = 0; i < scene.ls.length(); i++) {\n       tt = distToLineSeg(orig, scene.ls[i].v);\n       t = min(t,tt);\n   }\n   \n   for (int i = 0; i < scene.ts.length(); i++) {\n       tt = distToTriangle(orig, scene.ts[i].v);\n       t = min(t,tt);\n   }\n   \n   for (int i = 0; i < scene.qs.length(); i++) {\n       tt = distToQuad(orig, scene.qs[i].v);\n       t = min(t,tt);\n   }\n   \n   return min(sqrt(t) - epsilon, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    epsilon = 1.5/iResolution.y;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.9);\n    vec2 origin = vec2(0);\n    float d = iTime/2.0;\n    vec2 dir = vec2(sin(d),cos(d));\n    if (iMouse.z > 0.0) {\n        vec2 mouse = (iMouse.xy / iResolution.xy * 2.0 - vec2(1.0)) ;\n        dir = normalize(mouse - origin);\n    } \n    Circle cs[cC] = Circle[cC](\n        Circle(vec2(0.6, 0.3), 0.02, vec3(0.3, 0.5, 0.2)),\n        Circle(vec2(-0.1, 0.2), 0.01, vec3(0.6, 0.3, 0.3)),\n        Circle(vec2(-0.5, -0.4), 0.07, vec3(0.1, 0.7, 0.5)),\n        Circle(vec2(0.4, -0.3), 0.05, vec3(0.5, 0.8, 0.9))\n    );\n    Line ls[lC] = Line[lC](\n        Line(vec2[2](vec2(0.4, 0.2), vec2(0.3, -0.2)), vec3(0.1, 0.5, 0.8))\n    );\n    Triangle ts[tC] = Triangle[tC](\n        Triangle(vec2[3](vec2(-0.4, 0.0), vec2(-0.3, 0.1),  vec2(-0.25, 0.05)), vec3(0.2, 0.5, 0.3))\n    );\n    Quad qs[qC] = Quad[qC](\n        Quad(vec2[4](vec2(-0.5, -0.05),vec2(-0.4, -0.2), vec2(-0.5, -0.25), vec2(-0.6, -0.15)), vec3(0.3, 0.3, 0.7)),\n        Quad(vec2[4](vec2(0.0, 0.5), vec2(0.1, 0.4), vec2(0.05, 0.35), vec2(-0.05, 0.45)), vec3(0.9, 0.1, 0.7))\n    );\n    \n    scene.cs = cs;\n    scene.ls = ls;\n    scene.ts = ts;\n    scene.qs = qs;\n    for (int i = 0; i < cs.length(); i++){\n        if (isCircle(uv, cs[i].center, cs[i].radius)) col = mix(col, cs[i].col, 0.3);\n        col = mix( col, cs[i].col , isCirleOutline(uv, cs[i].center, cs[i].radius));\n    }\n    for (int i = 0; i < ls.length(); i++){\n        col = mix(col, ls[i].col, isLineSegment(uv, ls[i].v));\n    }\n    for (int i = 0; i < ts.length(); i++){\n        if (isTriangle(uv, ts[i].v)) col = mix(col, ts[i].col, 0.3);\n        col = mix(col, ts[i].col, isTriangleOutline(uv, ts[i].v));\n    }\n    for (int i = 0; i < qs.length(); i++){\n        if (isQuad(uv, qs[i].v)) col = mix(col, qs[i].col, 0.3);\n        col = mix(col, qs[i].col, isQuadOutline(uv, qs[i].v));\n    }\n    \n    vec2 curPos = origin + dir * 0.1;\n    float len = length(dir * 0.1);\n    for (int i = 0; i < 20; i++) {\n        float r = closestDist(curPos);\n        col = mix( col, vec3(0), isCirleOutline(uv, curPos, r));\n        if (r < epsilon) break;\n        curPos += dir * r;\n        len += r;\n    }\n    \n    col = mix( col, vec3(0), isRay(uv, origin, dir, len));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}