{"ver":"0.1","info":{"id":"cslGRl","date":"1666643858","viewed":97,"name":"Basic voronoi and worley noise","username":"legoushque","description":"My versions of classic algorithms. There are first closest, second closest and third closest points here.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141526\n#define T iTime*TAU*0.1\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 hash22(vec2 p){\n    return vec2(\n        fract(sin(dot(p, vec2(15.12312, 7.12312))*TAU*3.) * 46814.2848),\n        fract(sin(dot(p, vec2(8.4124, 19.23123))*TAU*3.) * 58383.7594))-0.5;\n\n}\n\nvec3 hash23(vec2 p){\n    return vec3(\n        fract(sin(dot(p, vec2(15.12312, 7.12312))*TAU*3.) * 46814.2848),\n        fract(sin(dot(p, vec2(8.4124, 19.23123))*TAU*3.) * 58383.7594),\n        fract(sin(dot(p, vec2(10.4124, 15.23123))*TAU*3.) * 23383.7594));\n\n}\n\n//returns vec3(first closest, second closest, third closest)\nvec3 worley(vec2 uv, float rotation, float distortion){\n    vec2 id = floor(uv),\n         gv = fract(uv); \n    float first = 100.;\n    float second = 100.;\n    float third = 100.;\n    vec2 minid;\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++){\n        vec2 cords = vec2(i, j);\n        cords += id+0.5;\n        cords += Rot(rotation)*hash22(cords)*distortion;\n        float curdist = length(uv - cords);\n        if(curdist < first){\n            third = second;\n            second = first;\n            first = curdist;\n            minid = id+vec2(i, j);\n        } else if(curdist < second){\n            third = second;\n            second = curdist;\n            \n        } else if(curdist < third){\n            third = curdist;\n        }\n    }\n    return vec3(first, second, third);\n}\n\n// return coordinates of nearest diagram point\nvec2 voronoi(vec2 uv, float rotation, float distortion){\n    vec2 id = floor(uv),\n         gv = fract(uv);\n    float first = 100.;\n    vec2 minid;\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++){\n        vec2 cords = vec2(i, j);\n        cords += id+0.5;\n        cords += Rot(rotation)*hash22(cords)*distortion;\n        float curdist = length(uv - cords);\n        if(curdist < first){\n            first = curdist;\n            minid = id+vec2(i, j);\n        } \n    }\n    return minid;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n       \n    uv *= 7.;\n    \n    vec3 distances = worley(uv, T, cos(T)*0.5+0.5);\n    vec3 vor = hash23(voronoi(uv, T, cos(T)*0.5+0.5));\n    \n         \n    vec3 col = smoothstep(-0.2, 1.1, vec3(vor)) * ( 1. - smoothstep(0.1, 1.5, distances.y)) ;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}