{"ver":"0.1","info":{"id":"sscyDj","date":"1654074296","viewed":123,"name":"Repeating line arealight","username":"panna_pudi","description":" [latexpage]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Exploring shortcuts I can make with area lights\n// Based on: https://www.elopezr.com/rendering-line-lights/\n\n// Current questions I have:\n// Can I make the computation cheaper?\n// What is the optimal way to render lights sources itself?\n// Linearly Transformed Cosines are pretty, but require a big LUT >:v\n\n#define sat(x) clamp(x, 0.0, 1.0) \n\nconst float pi = acos(-1.);\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nbool intersect_plane(vec3 ro, vec3 rd, vec3 pn, out vec3 hit) {\n    float d = -dot(ro, pn) / dot(rd, pn);\n    hit = ro + rd * d;\n    return d >= 0.0;\n}\n\nvec3 mrp_diffuse(vec3 P, vec3 A, vec3 B, out float t) {\n    vec3 PA = A - P, PB = B - P, AB = B - A;\n    float a = length(PA), b = length(PB);\n    t = sat(a / (b + a));\n\treturn A + AB * t;\n}\n\nvec3 mrp_specular(vec3 P, vec3 A, vec3 B, vec3 R, out float t) {\n    vec3 PA = A - P, PB = B - P, AB = B - A;\n\n    float t_num = dot(R, A) * dot(AB, R) + dot(AB, P) * dot(R, R) -\n                  dot(R, P) * dot(AB, R) - dot(AB, A) * dot(R, R);\n    float t_denom = dot(AB, AB) * dot(R, R) - dot(AB, R) * dot(AB, R);\n    t = sat(t_num / t_denom);\n\n    return A + AB * t;\n}\n\nfloat compute_falloff(vec3 position, vec3 light_position) {\n    float d = distance(position, light_position);\n    return 1.0 / (d * d);\n}\n\nvec3 segment_light(vec3 ro, vec3 rd,\n                   vec3 hit, vec3 plane_normal,\n                   vec3 light_start, vec3 light_end) {\n    vec3 litSurface = vec3(0.0);\n    vec3 finalLightColor = vec3(0.0);\n\n    vec3 A = light_start;\n    vec3 B = light_end;\n    vec3 P = hit;\n    \n    float light_intensity = 3.7;\n    vec3 surface_reflection = reflect(-rd, plane_normal);\n\n    {\n        float t = 0.0;\n        vec3 diffuseMRP = mrp_diffuse(hit, A, B, t);\n\n        finalLightColor = mix(vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), t);\n\n        vec3 lightVector = diffuseMRP - hit;\n        lightVector = normalize(lightVector);\n\n        float NdotL = sat(dot(plane_normal, lightVector));\n\n        float falloff = compute_falloff(hit, diffuseMRP);\n        \n        vec3 surface_albedo = vec3(1.0, 1.0, 1.0);\n        litSurface += (surface_albedo / pi) * finalLightColor\n                      * light_intensity * falloff * NdotL;\n    }\n\n    {\n        float t = 0.0;\n        vec3 specularMRP =\n            mrp_specular(hit, A, B, surface_reflection, t);\n\n        vec3 lightVector = specularMRP - hit;\n        lightVector = normalize(lightVector);\n\n        float NdotL = sat(dot(plane_normal, lightVector));\n\n        vec3 H = normalize(-rd + lightVector);\n\n        float NdotH = sat(dot(plane_normal, H));\n\n        float falloff = compute_falloff(hit, specularMRP);\n        \n        float surface_roughness = 0.0;\n        litSurface += vec3(pow(NdotH, pow(1000.0, 1.0 - surface_roughness)))\n                    * finalLightColor * light_intensity * falloff * NdotL;\n    }\n\n    return litSurface;\n}\n\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float time = iTime;\n    \n    vec3 ro = vec3(-3., 8., -4.);\n    // ro.xz *= rot(-time);\n    vec3 target = vec3(0.);\n    mat3 cam = get_cam(ro, target);\n    vec3 rd = cam * vec3(uv, 1.);\n    \n    vec3 plane_norm = vec3(0., 1., 0.);\n    \n    vec3 hit;\n    bool intersect = intersect_plane(ro, rd, plane_norm, hit);\n\n    float c = 9.;\n    float center = floor((hit.x + c / 2.) / c) * c;\n \n    vec3 light_start = vec3(-3.5, 2.0, 0.0);\n    vec3 light_end = vec3(3.5, 2.0, 0.0);\n    \n    light_start.xz *= rot(time);\n    light_end.xz *= rot(time);\n    \n    light_start += vec3(center, 0.0, 0.0);\n    light_end += vec3(center, 0.0, 0.0);\n \n    vec3 col = vec3(0.0);\n    if (intersect) {\n\n        vec3 light = segment_light(ro, rd, hit, plane_norm,\n                                   light_start, light_end);\n                                   \n        float neighbour = ((hit.x > center) ? 1.0 : -1.0) * c;\n        light_start += vec3(neighbour, 0., 0.);\n        light_end += vec3(neighbour, 0., 0.);\n        light += segment_light(ro, rd, hit, plane_norm,\n                               light_start, light_end);\n\n        col = light;\n    }\n    \n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}