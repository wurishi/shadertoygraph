{"ver":"0.1","info":{"id":"lXK3Dc","date":"1718533126","viewed":149,"name":"Dyson sphere","username":"ukeshet","description":"For Freeman","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal","star","planet","dust","starlight","starcluster","ism","dysonsphere","freemandyson"],"hasliked":0,"parentid":"M3jSWy","parentname":"ISM"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Dyson sphere (DS) demo: FF, from a one-planet system to infrared endstate.\n//\n// Background ISM (interstellar medium): https://www.shadertoy.com/view/M3jSWy \n// (including dust lanes but excludig transients), itself based on @Kali's Star \n// nest (https://www.shadertoy.com/view/XlfGRj) but distance-independent colors.\n//\n// Milky Way optical background based on @Cewein's A concept for starmap \n// (https://www.shadertoy.com/view/4csGWr), modified for optical resemblance.\n// If the MW does not show, drag mouse to one of the four conrners. \n\n#define MilkyWay\n#define ISM\n#define Dyson\n\nvoid mainImage(out vec4 O,vec2 C) {   \n\n    O*=0.; T=iTime; T1=T-7.; // simulation time, DS time\n    vec2 R=iResolution.xy, M=iMouse.xy/R, i=.1-.2*M, uv=C/R-.5; uv.y*=R.y/R.x; \n    float fa=1., s=.1, ii=length(i), x=.05*T*ii+.25, dm, c, pa, a, aa, r, j;\n    vec3 p, ro, dir, dr=vec3(1), Or=dr*.7, v; dr.xy = .8*uv*mat2(i,-i.y,i)/ii;\n    ro=vec3(0,0,-5.6); ro.yz*=RM(M.y*PI+PI2)*RM(1.56); ro.xz*=RM(-M.x*TAU+.25); \n    dir=Dir(uv, ro); // different origin (ro/Or) and dir (dir/dr) for MW/ISM.\n\n    #ifdef MilkyWay\n    O = MW(.8*RM(1.1)*dir.xy, vec2(sin(2.5)*.1+.5,0), vec2(0,sin(1.5)*.1+.5), \n           vec2(1.2,.1), vec2(.2,1.1), vec3(2.,.9,.7), .03*vec4(0,0,1,1), 1.9, \n           vec4(.3,.3,.3,0));\n    #endif\n\n    #ifdef ISM\n    for (Or+=vec3(2.*x,x,-2); r<23.; r++, fa*=.8, s+=.1) { // ISM\n       p = abs(.85-mod(Or+s*dr*.5,1.7));\n       for(a=pa=j=0.; j++<19.;) \n           a += abs(pa-(pa=length(p=abs(p)/dot(p,p)-.56)));\n       dm=max(0.,.5-.001*(aa=a*a)); \n       c = .5+.5*tanh(5.*cos(1e8*s));\n       v += (fa*=r>8.?-.8-dm:1.)+.0006*s*vec3(c,min(.4,c),1.-c)*a*aa*fa; \n    } \n    O += vec4(.01*mix(vec3(length(v)),v,.9),1);\n    #endif\n\n    #ifdef Dyson\n    s = RaM(ro, dir);\n    if(s<D) {  // within stellar system\n        aa = length(p = ro+dir*s);\n        a = dot(Norm(p), -p/aa);\n        if (aa<.1)\n            v=vec3(1,1,.6); // star\n        else {\n            if (a>0.)\n                if (aa<.9)\n                    v = vec3(0,.5,.7); // ocean planet\n                else \n                    v = vec3(.5,.4,.1)*(a*.5+.5); // DS interior\n            else \n                v = .2*vec3(1.-exp(.25*(20.-T1)),0,0); // DS exterior\n        }\n        O = vec4(v,1);\n    }\n    else {\n        v = smin(.3,.05/length(uv),.2)*vec3(1.,.8,.3); // scattered starlight: \n        if (length(uv)<asin(1./5.6) || T1<0.) // is isotropic\n            O.xyz += v; \n        else  // in rays approximated at a few normal planes\n            for (r=.99; r<1.012; r+=.01)\n                if (DS(normalize(ro+r*dir*length(ro)/cos(length(uv))))>.003)\n                    O.xyz += v/3.; \n    }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.1415927\n#define TAU 6.2831853\n#define PI2 1.5707963\n#define S 100\n#define D 25.\n\nfloat T, T1; // Simulation time, DS time\n\nmat2 RM(float a) { // Rotation matrix\n    vec2 cs=sin(vec2(PI2,0)+a);\n    return mat2(cs,-cs.y, cs);\n}\n\nfloat smin(float a, float b, float k) { // Smooth minimum (for k>0)\n    return mix(b,a,b=clamp(.5+.5*(b-a)/k, 0., 1.))-k*b*(1.-b);\n}\n\nfloat DS(vec3 p) { // Evolving gyroid-based Dyson sphere\n    if (T1<0.5)\n        return 100.;\n    float sc = .3*T1*T1;\n    p*=sc; p.xz *= RM(T1);\n    return .2*abs(dot(sin(p), cos(p.zxy)))/sc-.0015;            \n}\n\nfloat SD(vec3 p) { // signed distance for stellar system \n    return min( min(smin(abs(length(p)-1.)-.02, DS(p), -.02),      // DS\n                    length(p-.7*vec3(cos(3.*T),0,sin(3.*T)))-.02), // planet\n                length(p)-.06);                                    // star\n}\n\nvec3 Norm(vec3 p) { // Surface normal\n    vec2 e = vec2(.001, 0);    \n    return normalize(SD(p)-vec3(SD(p-e.xyy),SD(p-e.yxy),SD(p-e.yyx)));\n}\n\nvec3 Dir(vec2 uv, vec3 p) { // Ray direction\n    vec3 r = normalize(cross(vec3(0,1,0), p=-normalize(p)));\n    return normalize(p + uv.x*r + uv.y*cross(p,r));\n}\n\nfloat RaM(vec3 ro, vec3 rd) { // Ray march\n\tfloat d, dS=1.;\n    for(int i; i++<S && d<D && abs(dS)>.001; d+=(dS=SD(ro + rd*d)));\n    return d;\n}\n\n// The following MW code is modified from A concept for starmap by @Cewein, \n// https://www.shadertoy.com/view/4csGWr; see comments therein.\n\nvec2 hash22(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.+2.*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec2 p) { // based on @drift's www.shadertoy.com/view/4tdSWr\n    const float K1 = .366025404; // (sqrt(3)-1)/2; Perlin-noise consts.\n    const float K2 = .211324865; // (3-sqrt(3))/6;\n    vec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.,.0) : vec2(.0, 1.);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2.*K2;\n    vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n    h*=h; \n    vec3 n = vec3(dot(a, hash22(i)), dot(b, hash22(i+o)), dot(c, hash22(i+1.)));\n    return dot(h*h*n, vec3(70.));\n}\n\nfloat fbm(vec2 n, float amp, float res) {\n    float tot; \n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    for (int i; i++<7; amp*=res) {\n        tot += (.1+noise(n))*amp;\n        n = m*n;\n    }\n    return abs(tot);\n}\n\nfloat sdEllipse(vec2 p, vec2 a, vec2 b) { \n    vec2 ab = vec2(length(a), length(b));\n    p = abs(p*mat2(a/ab.x, b/ab.y));\n    vec2 q = ab*(p-ab); // The following is based on @iq (Inigo Quilez)\n    float w = (q.x<q.y) ? PI2:.0;\n    for (int i; i<4; i++) {\n        vec2 cs = vec2(cos(w), sin(w));\n        vec2 u = ab*vec2(cs.x, cs.y);\n        vec2 v = ab*vec2(-cs.y, cs.x);\n        w += dot(p-u, v)/(dot(p-u, u) + dot(v, v));\n    }\n    float d = length(p - ab*vec2(cos(w), sin(w)));\n    p/=ab;\n    return (dot(p, p)>1.0) ? d : -d;\n}\n\nvec4 MW(vec2 uv, vec2 a, vec2 b, vec2 fA, vec2 fB, vec3 fP, vec4 c, float I, vec4 g) {\n    float d = -sdEllipse(uv, a*RM(fA.y)*fA.x, b*RM(fB.y)*fB.x);\n    return mix(c, g, I*smoothstep(-.1, .4, d)*fbm(uv*fP.x, fP.y, fP.z));\n}\n","name":"Common","description":"","type":"common"}]}