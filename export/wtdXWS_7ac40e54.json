{"ver":"0.1","info":{"id":"wtdXWS","date":"1581642654","viewed":148,"name":"Penrose Fourier 2","username":"rory618","description":"Computing the fourier transform of a penrose tiling using a montecarlo integral. This one really cranks along since there is no fft like factorization at all, not even horizontal/vertical factoring.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","spectrum","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = 1e2*vec4(texture(iChannel0,i/R.xy).xy/float(iFrame),0,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define R iResolution\n#define pi 3.14159\n#define tao 6.28318\n#define phi 1.6180339\n#define rot(x) cos((x) - vec2(0,pi/2.))\n#define rot20(x) rot((x)*tao/20.)\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\nfloat sdLine(vec2 uv, vec2 a, vec2 abn){\n    vec2 x = uv-a;\n    vec2 r = abn.yx*vec2(-1,1);\n    return dot(r, x - abn * dot(x, abn));\n}\n\nvec4 samplePenrose( vec2 uv )\n{\n    float s = 1.;\n    \n    \n    int type = 0;\n    \n    float angle = atan(uv.y,uv.x);\n    angle = mod(angle + tao/10.,tao/5.) - tao/10.;\n    angle = abs(angle);\n    uv = length(uv) * cos(angle - vec2(0,pi/2.));\n    vec4 r = vec4(0);\n    if(sdLine(uv, rot20(2.), rot20(6.)) > 0. ){\n    \n        for(int i = 0; i < 10; i++){\n            float d0 = sdLine(uv, vec2(1./phi,0), rot20(8.) );\n            float d1 = sdLine(uv, vec2(1./phi,0), rot20(3.) );\n            float d2 = sdLine(uv, rot20(2.), rot20(9.));\n            float d3 = sdLine(uv, rot20(2.), rot20(4.));\n            s *= phi;\n\n            if(d0 > 0.){\n                type = 1;\n                uv.y = d0 * phi;\n                uv.x = d1 * phi;\n            } else {\n                type = 0;\n                uv.x = d2 * phi;\n                uv.y = abs(d3) * phi;\n            }\n        }\n    \treturn vec4(uv,type,s);\n    } else {\n        return vec4(0);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    int seed = int(i.x) + int(i.y)*634561 + iFrame*7658765-643543;\n    vec2 uv = ((i + (rand2(seed)-.5)) *2.-R.xy)/R.y * 150.;\n    o = texture(iChannel0,i/R.xy);\n    \n    for(int k = 0; k < 100; k++){\n        seed = int(i.x) + int(i.y)*634561 + iFrame*7658765 + k*643543 ;\n\n        vec2 r = randn(rand2(seed))*.2;        //Exponential window, turns points into blobs\n        \n        //vec2 r = (rand2(seed)-.5)*2.;        //Effectively no window, draw infintessimal dots\n        \n        vec2 c = rot(tao * (r.x * uv.x + r.y * uv.y));\n        vec4 s = samplePenrose(r);\n        o.xy += mat2(c.xy,-c.y,c.x) * s.zz/400.;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}