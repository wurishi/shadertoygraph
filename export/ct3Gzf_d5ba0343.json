{"ver":"0.1","info":{"id":"ct3Gzf","date":"1682883855","viewed":67,"name":"worley+perlin","username":"jakecariello","description":"as the name says :)\n\nworley noise binary mask + perlin noise RGB color masks ... all as fcn of time","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","color","worley","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define S(a, b, x) smoothstep(a, b, x)\n\n// START of Classic Perlin 3D Noise \n// by Stefan Gustavson\n//\nvec4 permute(vec4 x) {\n    return mod(((x*34.)+1.)*x, 289.);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.); // Integer part + 1\n    Pi0 = mod(Pi0, 289.);\n    Pi1 = mod(Pi1, 289.);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.); // Fractional part - 1.\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.;\n    vec4 gy0 = fract(floor(gx0) / 7.) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.));\n    gx0 -= sz0 * (step(0., gx0) - 0.5);\n    gy0 -= sz0 * (step(0., gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.;\n    vec4 gy1 = fract(floor(gx1) / 7.) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.));\n    gx1 -= sz1 * (step(0., gx1) - 0.5);\n    gy1 -= sz1 * (step(0., gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\n// END of Perlin Noise Code\n\n\n// START Voronoi code. from https://www.shadertoy.com/view/ll3GRM\n// vec2 to vec2 hash.\nvec2 hash2(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*.75 + .25; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if-statements,\"\n// but the clever bit at the end came from Fabrice.\n//\n// Using a bit of science and art, Fabrice came up with the following formula to produce a more \n// rounded, evenly distributed, cellular value:\n\n// d1, d2, d3 - First, second and third closest points (nodes).\n// val = 1./(1./(d2 - d1) + 1./(d3 - d1));\n//\nfloat voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(2.); // 1.4, etc.\n    \n    float r = 0.;\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n\t\t\to = vec2(x, y);\n            o += hash2(g + o) - p;\n            \n\t\t\tr = dot(o, o);\n            \n            // 1st, 2nd and 3rd nearest squared distances.\n            d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n            d.y = max(d.x, min(d.y, r)); // 2nd.\n            d.x = min(d.x, r); // Closest.\n                       \n\t\t}\n\t}\n    \n\td = sqrt(d); // Squared distance to distance.\n    \n    // Fabrice's formula.\n    return min(2./(1./max(d.y - d.x, .01) + 1./max(d.z - d.x, .01)), 1.);\n    // Dr2's variation - See \"Voronoi Of The Week\": https://www.shadertoy.com/view/lsjBz1\n    //return min(smin(d.z, d.y, .2) - d.x, 1.);\n    \n}\n\nvec2 hMap(vec2 uv){\n    \n    // Plain Voronoi value. We're saving it and returning it to use when coloring.\n    // It's a little less tidy, but saves the need for recalculation later.\n    float h = voronoi(uv*6.);\n    \n    // Adding some bordering and returning the result as the height map value.\n    float c = smoothstep(0., fwidth(h)*2., h - .09)*h;\n    //c += (1.-smoothstep(0., fwidth(h)*3., h - .22))*c*.5; \n    \n    // Returning the rounded border Voronoi, and the straight Voronoi values.\n    return vec2(c, h);\n    \n}\n\n// END Voronoi code.\n\n\n// START worley+perlin by Jake Cariello. (c) 2023\n\nconst vec2 u2 = vec2(1.0, 1.0);\nconst vec3 u3 = vec3(u2, 1.0);\nconst vec4 u4 = vec4(u3, 1.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // PERLIN\n    float perlinR = S(0.0, 0.05, cnoise(vec3(uv * 2., sin(iTime / 3.))));\n    float perlinG = S(0.0, 0.05, cnoise(vec3(uv * 2., sin(iTime / 4. + 999.))));\n    float perlinB = S(0.0, 0.05, cnoise(vec3(uv * 2., sin(iTime / 5. - 999.))));\n\n    // WORLEY\n    vec2 worley = hMap(uv * 1.);\n    float worleyMask = S(0.1, 0.2, worley.x);\n\n    // Output to screen\n    //vec3 baseColor = vec3(sin((PI / 2.) * uv) + worley.y / 2., 1.0);\n    vec3 baseColor = vec3(pow(perlinR, 1.), pow(perlinG, 2.), 2. * pow(perlinB, 4.));\n    fragColor = vec4(baseColor * worleyMask, 1.0);\n}\n\n// END worley+perlin by Jake Cariello.","name":"Image","description":"","type":"image"}]}