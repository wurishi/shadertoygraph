{"ver":"0.1","info":{"id":"DlcBWH","date":"1701171904","viewed":23,"name":"Test raymarching 123456","username":"manhbeo8adc","description":"phong lighting + raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define SPEC_STRENGTH 10.\n\nfloat SdfSphere(vec4 s, vec3 p){\n    return length(p - s.xyz) - s.w;\n}\n\nfloat SmoothStep(float a, float b){\n    float k = 1.;\n    float h = clamp((b - a) / k + .5, 0., 1.);\n    float m = h * (1. - h);\n    return h * a + (1. - h) * b - m * .5;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s1 = vec4(0, -abs(sin(iTime)) * 2. + 1.5, 6, 1);\n    float sphere1 = SdfSphere(s1, p);\n    \n    vec4 s2 = vec4(abs(sin(iTime)) * 2., 1, 6, 1);\n    float sphere2 = SdfSphere(s2, p);\n    vec4 s3 = vec4(-abs(sin(iTime)) * 2., 1, 6, 1);\n    float sphere3 = SdfSphere(s3, p);\n    \n    float blend23 = SmoothStep(sphere2, sphere3);\n    \n    return SmoothStep(sphere1, blend23);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetLight(vec3 ro, vec3 rd){\n    vec3 lightPos = vec3(10, 7, 3);\n    vec3 lightColor = vec3(0.47, 0.81, 0.83);\n    vec3 modelColor = vec3(0.83, 0.47, 0.64);\n    \n    // rotate light position\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 10.;\n\n    float d = RayMarch(ro, rd);\n    if(d >= MAX_DIST) return lightColor * 0.05;\n    vec3 p = ro + rd * d;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(l, n);\n    vec3 v = normalize(p - vec3(0,1,0));\n    \n    float dif = max(0.,dot(n, l));\n    float dotvr = max(0., dot(v, r));\n    float spec = max(0., pow(dotvr, SPEC_STRENGTH));\n    float val = dif + spec * 0.2;\n    val = pow(val, 2.2);\n    val = max(0., val);\n    return val * modelColor + lightColor * 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    col = GetLight(ro, rd);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}