{"ver":"0.1","info":{"id":"llcSz8","date":"1478568236","viewed":10427,"name":"Kelp Forest","username":"BigWIngs","description":"Use the mouse to look around. \nIf you want to see just the fish you can set the FISH_ONLY define to true. \nThe full effect brings my titan card to it's knees on fullscreen. To get a decent framerate you can turn the bubbles and the kelp off.","likes":174,"published":1,"flags":64,"usePreview":1,"tags":["raymarching","sss","distanceestimation","ocean","underwater","bubbles","fish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MdjGDR","filepath":"https://soundcloud.com/etheredm/hollywood-principle-breathing-underwater-ether-remix","previewfilepath":"https://soundcloud.com/etheredm/hollywood-principle-breathing-underwater-ether-remix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Kelp Forest\" by Martijn Steinrucken aka BigWings - 2016\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// SONG : Hollywood Principle - Breathing Underwater (Ether Remix)\n\n// Use these to change the effect\n\n#define FISH_ONLY false\n#define FISH true\n#define KELP true\n#define BUBBLES true\n\n#define INVERTMOUSE 1.\n\n#define MAX_STEPS 200\n#define CAM_DEPTH 30.\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 bg; // global background color\n\nfloat dist2(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } \nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*134.324); }\n\nvec3 hash31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat fmin( float a, float b, float k, float f, float amp) {\n\t// 'fancy' smoothmin min.\n    // inserts a cos wave at intersections so you can add ridges between two unioned objects\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float scale = h*(1.0-h);\n\treturn mix( b, a, h ) - (k+cos(h*pi*f)*amp*k)*scale;\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nvec3 opTwist( vec3 p, float a )\n{\n    float  c = cos(a*p.y*pi);\n    float  s = sin(a*p.y*pi);\n    mat2   m = mat2(c,-s,s,c);\n    \n    p.xz = m*p.xz;\n    return vec3(p);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nmat3 RotMat(vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float b;\t// bump\n    float m; \t// material\n    float a;\t// angle\n    float a2;\n    \n    float d1, d2, d3, d4, d5;\t// extra distance params you can use to color your object\n    \n    vec3 p;\t\t// the offset from the object center\n    \n    vec3 s1;\t// more data storage\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\nfloat SkipCell(rc q, vec3 rd) {\n\t// returns a distance so that we skip the current cell and end up in the next cell\n    \n    vec3 r;\t// ray that will bring us to the next cell\n    if(rd.x<0.) r.x = -(q.p.x+q.h.x); else r.x = (q.h.x-q.p.x);\n    if(rd.y<0.) r.y = -(q.p.y+q.h.y); else r.y = (q.h.y-q.p.y);\n    if(rd.z<0.) r.z = -(q.p.z+q.h.z); else r.z = (q.h.z-q.p.z);\n    vec3 steps = r/rd;\n    \n    return length(min(min(steps.x, steps.y), steps.z)*rd)+.01;// add a little bit so we for sure end up in the next cell\n}\n\nvec3 background(vec3 r) {\n\tfloat x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 upCol = vec3(.15, .25, .6)*7.;\n    \n    float u = dot(r, up)*.5+.5;\n    \n    vec3 col = mix(upCol*.05, upCol, u*u);\n    \n    float t = iTime*4.;\t\t\t\t// add god rays\n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.03;\n    \n    return col;\n}\n\nfloat WaterSurface(vec3 r) {\n    \n    float u = dot(r, up);\n    \n    vec2 p = r.xz*(CAM_DEPTH/r.y)*3.; \n    \n    float t = iTime*5.;\n    \n    float bump = sin(p.x*2.+t+sin(p.y*.73+t));\n    bump += sin(p.x*1.43+t)*.5;\n    \n    bump += sin(p.x*1.21-t+sin(p.y*.3-t*.34));\n    bump += sin(p.x*.43-t)*.5;\n    \n    bump += sin(p.y*.81-t+sin(p.x*.334-t*.34));\n    bump += sin(p.y*.63-t)*.5;\n    \n    bump *= u*S(9., 1., u);\n    bump *= S(.5, 1., u)*.05;\n\n    return bump;\n}\n\nvec3 Caustics(vec3 p) {\n    float t = iTime*2.;\n    \n    float s1 = sin(p.x*5.+t)*.5+.5;\n    float s2 = sin(p.z*5.+t)*.5+.5;\n    float s3 = sin(p.x*s1+p.z*s2*.1+t*.32)*.5+.5;\n    \n    float c = pow(s1*s2, 2.);\n    \n\treturn c*vec3(1., 1., .9);\n}\n    \nvec3 Scales(vec2 uv, float seed) {\n    // returns a scale info texture: x = brightness y=noise z=distance to center of scale\n    vec2 uv2 = fract(uv);\n    vec2 uv3 = floor(uv);\n    \n    float rDist = length(uv2-vec2(1., .5));\n    float rMask = S(.5, .45, rDist);\n    float rN = N2(uv3.x, uv3.y+seed);\n    vec3 rCol = vec3(uv2.x-.5, rN, rDist);\n     \n    float tDist = length(uv2-vec2(.5, 1.));    \n    float tMask = S(.5, .45, tDist);\n    float tN = N2(uv3.x, uv3.y+seed);\n    vec3 tCol = vec3(1.*uv2.x, tN, tDist);\n    \n    float bDist = length(uv2-vec2(.5, 0.));\n    float bMask = S(.5, .45, bDist);\n    float bN = N2(uv3.x, uv3.y-1.+seed);\n    vec3 bCol = vec3(uv2.x, bN, bDist);\n    \n    float lDist = length(uv2-vec2(.0, .5));\n    float lMask = S(.5, .45, lDist);\n    float lN = N2(uv3.x-1., uv3.y+seed);\n    vec3 lCol = vec3(uv2.x+.5, lN, lDist);\n    \n    vec3 col = rMask*rCol;\n    col = mix(col, tCol, tMask);\n    col = mix(col, bCol, bMask);\n    col = mix(col, lCol, lMask);\n    \n    return col;\n}\n\nde Fish(vec3 p, vec3 n, float camDist) {\n    // p = position of the point to be sampled\n    // n = per-fish random values\n    // camDist = the distance of the fish, used to scale bump effects\n    \n    p.z += sin(p.x-iTime*2.+n.x*100.)*mix(.15, .25, n.y);\n    p.z = abs(p.z);\n   \n    float fadeDetail = S(25., 5., camDist);\n    \n    vec3 P;\n    \n    float dist;\t\t// used to keep track of the distance to a certain point\n    float mask;\t\t// used to mask effects\n    float r;\n    vec2 dR;\n    \n    float bump=0.; // keeps track of bump offsets\n    \n    float lobe = scaleSphere(p-vec3(-1., 0., 0.25), vec3(1., 1., .5), .4);\n    float lobe2 = scaleSphere(p-vec3(-1., 0., -0.25), vec3(1., 1., .5), .4);\n    \n    vec3 eyePos = p-vec3(-1., 0., 0.4);\n    float eye = scaleSphere(eyePos, vec3(1., 1., .35), .25);\n    float eyeAngle = atan(eyePos.x, eyePos.y);\n    \n    float snout = scaleSphere(p-vec3(-1.2, -0.2, 0.), vec3(1.5, 1., .5), .4);\n    P = p-vec3(-1.2, -0.6, 0.);\n    P = P*RotMat(vec3(0., 0., 1.), .35);\n    float jawDn = scaleSphere(P, vec3(1., .2, .4), .6);\n    float jawUp = scaleSphere(P-vec3(-0.3, 0.15, 0.), vec3(.6, .2, .3), .6);\n    float mouth = fmin(jawUp, jawDn, 0.03, 5., .1);\n    snout = smin(snout, mouth, 0.1);\n    \n    float body1 = scaleSphere(p-vec3(.6, -0., 0.), vec3(2., 1., .5), 1.);\n    float body2 = scaleSphere(p-vec3(2.4, 0.1, 0.), vec3(3., 1., .4), .6); \n\n    P = p-vec3(-1., 0., 0.);\n    \n    float angle = atan(P.y, P.z);\n    vec2 uv = vec2(remap01(-2., 3., p.x), (angle/pi)+.5); // 0-1\n    vec2 uv2 = uv * vec2(2., 1.)*20.;\n    \n    vec3 sInfo = Scales(uv2, n.z);\n    float scales = -(sInfo.x-sInfo.z*2.)*.01;\n    scales *= S(.33, .45, eye)*S(1.8, 1.2, eye)*S(-.3, .0, p.x);\n    \n    // gill plates\n    P = p-vec3(-.7, -.25, 0.2);\n    P = P * RotMat(vec3(0., 1., 0.), .4);\n    float gill = scaleSphere(P, vec3(1., .9, .15), .8);\n    \n    // fins\n    float tail = scaleSphere(p-vec3(4.5, 0.1, 0.), vec3(1., 2., .2), .5);\n    dR = (p-vec3(3.8, 0.1, 0.)).xy;\n    r = atan(dR.x, dR.y);\n    \n    mask = B(0.45, 2.9, .2, r) * S(.2*.2, 1., L2(dR));\n    \n    bump += sin(r*70.)*.005*mask;\n    tail += (sin(r*5.)*.03 + bump)*mask;\n    tail += sin(r*280.)*.001*mask*fadeDetail;\n    \n    float dorsal1 = scaleSphere(p-vec3(1.5, 1., 0.), vec3(3., 1., .2), .5);\n    float dorsal2 = scaleSphere(p-vec3(0.5, 1.5, 0.), vec3(1., 1., .1), .5);\n    dR = (p-vec3(0.)).xy;\n    r = atan(dR.x, dR.y);\n    dorsal1 = smin(dorsal1, dorsal2, .1);\n    \n    mask = B(-.2, 3., .2, p.x);\n    bump += sin(r*100.)*.003*mask;\n    bump += (1.-pow(sin(r*50.)*.5+.5, 15.))*.015*mask;\n    bump += sin(r*400.)*.001*mask*fadeDetail;\n    dorsal1 += bump;\n    \n    float anal = scaleSphere(p-vec3(2.6, -.7, 0.), vec3(2., .7, .1), .5);\n    anal += sin(r*300.)*.001;\n    anal += sin(r*40.)*.01;\n    \n    \n    // Arm fins\n    P = p-vec3(0.7, -.6, 0.55);\n    dR = (p-vec3(0.3, -.4, 0.6)).xy;\n    r = atan(dR.x, dR.y);\n    P = P*RotMat(lf, .2);\n    P = P*RotMat(up, .2);\n    mask = B(1.5, 2.9, .1, r); \t\t\t// radial mask\n    mask *= S(.1*.1, .6*.6, L2(dR));\t\t\t// distance mask\n \tfloat arm = scaleSphere(P, vec3(2., 1., .2), .2);\n    arm += (sin(r*10.)*.01 + sin(r*100.)*.002) * mask;\n   \n    // Breast fins\n    P = p-vec3(0.9, -1.1, 0.2);\n    P = P*RotMat(fw, .4);\n    P = P*RotMat(lf, .4);\n    dR = (p-vec3(0.5, -.9, 0.6)).xy;\n    r = atan(dR.x, dR.y);\n    mask = B(1.5, 2.9, .1, r); \t\t\t// radial mask\n    mask *= S(.1*.1, .4*.4, L2(dR));\n    float breast = scaleSphere(P, vec3(2., 1., .2), .2);\n    breast += (sin(r*10.)*.01 + sin(r*60.)*.002)*mask;\n    \n    \n    de f;\n    f.p = p;\n    f.a = angle;\n    f.a2 = eyeAngle;\n    f.d4 = length(eyePos);\n    f.m = 1.;\n    \n    f.d1 = smin(lobe, lobe2, .2);\t\t\t\t\t\t\t\t\t\t\t\t// d1 = BODY\n    f.d1 = smin(f.d1, snout, .3);\n    f.d1 += 0.005*(sin(f.a2*20.+f.d4)*sin(f.a2*3.+f.d4*-4.)*SIN(f.d4*10.));\n    f.d1 = smin(f.d1, body1, .15);\n    f.d1 = smin(f.d1, body2, .3);\n    f.d1 += scales*fadeDetail;\n    f.d1 = fmin(f.d1, gill, .1, 5., 0.1);\n    \n    float fins = min(arm, breast);\n    fins = min(fins, tail);\n    fins = min(fins, dorsal1);\n    fins = min(fins, anal);    \n        \n    f.d = smin(f.d1, fins, .05);\n    f.d = fmin(f.d, eye, .01, 2., 1.);\n    f.d *= .8;\n    \n    f.d2 = dorsal1;\n    f.d3 = tail;\n    f.d5 = mouth;\n    f.b = bump;\n    \n    f.s1 = sInfo;\n    \n    return f;\n}\n\nde Kelp(vec3 p, vec3 n) {\n\tde o;\n    \n    p = opTwist(p, floor(n.y*10.)/40.);\n    o.d = udRoundBox(p, vec3(mix(.1, .7, n.x), 40., .01), .005);\n    \n    o.d *=.6;\n    o.m=3.;\n    \n    return o;\n}\n\nde SmallBubbles(rc q, vec3 p, vec3 n) {\n\t// q = repeated coord\n    // p = world pos\n    // n = per-bubble random values\n    \n    de o;\n    o.m=2.;\n   \n    float t = iTime*2.;\n    \n    n -= 0.5;\n    \n    float s = fract((n.x+n.y+n.z)*100.);\n    s = pow(s, 4.);\n    float size = mix(.05, .7, s)*.5;\n    \n    vec3 pos;\n    \n    pos.x = sin((t+n.y)*twopi*(1.-s)*3.)*n.x*s;\n    \n    o.d = sdSphere(q.p, pos, size);\n    \n    p.y += t;\n    p *= 7.;\n    \n    n *= twopi;\n    o.d += (sin(p.x+n.x+t)+sin(p.y+n.y)+sin(p.z+n.z+t))*s*.05;\n    \n    o.d*=.8;\n    return o;\n}\n\nde map( vec3 p, vec3 rd) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    de o;\n    o.d = 1000.;\n    \n    float t = iTime;\n    \n    if(FISH_ONLY) {\n       p.x += 1.5;\n       o = Fish(p, vec3(0.), 0.); \n    } else {\n        rc q;\n        vec3 n;\n        \n        if(FISH) {\n            q = Repeat(vec3(p.x+t, p.y, p.z), vec3(11.5, 4.5, 2.5)); // make fishies move forward\n            n = hash31(q.id.x+q.id.y*123.231+q.id.z*87.342);\n\n            float camDist = length(p);\n            if(n.x>.95) \n                o = Fish(q.p, n, camDist);\n            else\n                o.d = SkipCell(q, rd);\n        }\n        \n        if(KELP) {\t\t\t\t\t\t\t\t\t\t\n            q = Repeat(vec3(p.x+sin(t+p.y*.2)*.5, p.y, p.z), vec3(2., 40., 2.)); // make kelp sway\n            n = hash31(q.id.x+q.id.z*765.);\n\n            de kelp;\n            if(n.z*S(7., 10., length(q.id)) > .9)\n                kelp = Kelp(q.p, n);\n            else \n                kelp.d = SkipCell(q, rd);\n\n            if(kelp.d<o.d) o=kelp;\n        }\n        \n        if(BUBBLES) {\t\t\t\t\t\t\t\t\t\t// Map kelp\n            p.y -= t*4.;\t\t\t// sway with the water\n\t\t\t\n            p.y += 40.;\n            q = Repeat(p, vec3(4., 4., 4.));\n            n = hash31(q.id.x+q.id.y*1234.5234+q.id.z*765.);\n\t\t\t\n            de bubbles;\n            if(n.z*S(2., 5., length(q.id)) > .95)\n                bubbles = SmallBubbles(q, p, n);\n            else \n                bubbles.d = SkipCell(q, rd);\n\n            if(bubbles.d<o.d) o=bubbles;\n        }\n        \n    }\n    \n    return o;\n    \n}\n\nde map( in vec3 p){return map(p, vec3(1.));}\n\nde castRay( in vec3 ro, in vec3 rd ) {\n    // returns a distance and a material id\n    \n    float dmin = 1.0;\n    float dmax = 100.0;\n    \n\tfloat precis = 0.002;\n    \n    de o;\n    o.d = dmin;\n    o.m = -1.0;\n    \n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    de res = map( ro+rd*o.d, rd );\n        if( res.d<precis || o.d>dmax ) break;\n        \n        float d = o.d;\n        o = res;\n        o.d += d;\n    }\n\n    if( o.d>dmax ) o.m=-1.0;\n    \n    return o;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, nor ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\n\nvec3 FishMaterial(de o, vec3 nor, float fresnel, float spec, float occ, vec3 amb, vec3 ref, float u, vec3 pos) {\n   vec3 finCol = vec3(1., .5, .25);\n        \n        float dorsalMask = (1.-sat(o.d2*15.))*B(-.3, 3., .1, o.p.x);\n        float finMask = o.d1*2.;\n        float spikeMask = pow(o.b*50., 2.);\n        float dorsalTrans = sat(finMask*spikeMask*dorsalMask*3.);\n        float tailMask = S(3.8, 5.2, o.p.x);\n        float tailTrans = tailMask*(1.-pow(max(1.-(o.b*100.+0.5), 0.), 3.));\n        float translucency = (dorsalTrans+tailTrans+o.d1*3.);\n        translucency *= u+.2;\n        \n        float bodyMask = sat(1.-(o.d1-.01)*50.);\n        vec3 topCol = vec3(.5, .5, .5);\n        vec3 bottomCol = vec3(1.3);\n        float w = sin(o.p.x*5.)*.1;\n \t\tvec3 bodyCol = mix(topCol, bottomCol, S(.4, -.2, o.p.y)+(o.s1.y-.5)*.5);\n        \n        float camo = SIN(o.d4*5.);\n        camo *= SIN(o.d2*10.);\n        \n        float headMask = S(.8, 1., o.d3);\n        vec3 headCol = mix(vec3(1.2), topCol,  S(0., .5, o.d4)*S(1.1, .5, o.d4));\n        headCol += 0.1*(sin(o.a2*20.+o.d4)*sin(o.a2*3.+o.d4*-4.)*SIN(o.d4*10.));\n        \n        headCol += (1.-fresnel)*ref.b*.2;\n        vec3 mouthCol = vec3(1.3);\n        headCol = mix(headCol, mouthCol, (1.-S(.0, .2, o.d5)));\n        \n    \tvec3 col = vec3(1.);\n        col = mix(col, col*mix(bodyCol, headCol, headMask), bodyMask);\n        col *= camo*.5+.5;\n        \n       \tvec3 eyeColor = vec3(.8, .6, .2);\n        eyeColor += sin(o.a2*2.*pi+.345)*sin(o.a2*pi)*.1;\n       \n        float eyeMask = S(.27, .25, o.d4);\n        eyeColor *= S(.13, .15, o.d4);\n        eyeColor *= S(.25, .19, o.d4)+.25;\n        eyeColor += spec;\n        \n        col = mix(col, eyeColor, eyeMask);\n        \n        vec3 ambient = mix(amb, vec3(occ), .5);   \n        col *= ambient;\n        \n        col = mix(col, bg*finCol, translucency);\t// add light through fins\n        \n        float dif = clamp( dot( nor, up ), 0., 1.0 );\n        col += Caustics(pos)*dif*S(-20., 1., pos.y);\n    \n    return col;\n}\n\nvec3 BubbleMaterial(de o, float fresnel, float spec, vec3 ref) {\n    vec3 col = ref;\n    \n    return col;\n}\n\nvec3 KelpMaterial(de o, float fresnel, vec3 amb, vec3 ref, float u, vec3 pos) {\n\tvec3 kelpColor = vec3(1., .5, .2);\n    vec3 col = amb;\n    vec3 transColor = kelpColor*bg*1.3;\n    col = mix(col, transColor, fresnel);\n    col += Caustics(pos)*.2;\n    col *= sat(u*2.);\n    \n    return col;\n}\n\n\nvec4 render( in vec3 ro, in vec3 rd, float depth ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(ro,rd);\n\n    vec3 pos = ro + o.d*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 r = reflect( rd, nor );\n    vec3 amb = background(nor);\t\t// the background in the direction of the normal\n    vec3 ref = background(r);\t\t// the background in the direction of the reflection vector\n\n    float fresnel = sat(dot(rd, -nor));\n\n    float occ = calcAO( pos, nor );\n    float lookUp = dot(rd, up)*.5+.5;\t\t// 1 when looking straight up, 0 when looking straight down\n\n    float spec = pow(sat(dot(r, up)), 20.);\n   \n    \n    if( o.m==1. )\n        col = FishMaterial(o, nor, fresnel, spec, occ, amb, ref, lookUp, pos);\n    else if(o.m==2.)\n    \tcol = BubbleMaterial(o, fresnel, spec, ref);\n    else if(o.m==3.)\n       col = KelpMaterial(o, fresnel, amb, ref, lookUp, pos);\n    \n    \n    float backContrast = max(S(.9, .70, lookUp), S(30., 25., o.d)); \n    col *= backContrast;\n    \n    float fog = S(0., 60., o.d);\n    col = mix(col, bg, fog);\n\n    return vec4( col, o.m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if(m.x==0. &&m.y==0.) m = vec2(.96, .6);\n\tfloat t = iTime;\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    vec3 camPos = vec3(0., 0., 0.);\n    vec3 pos = vec3(0., INVERTMOUSE*10.*cos((m.y)*pi), -10.)*rotX;\n   \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    bg = background(cam.ray.d);\n\n    vec4 info = render(cam.ray.o, cam.ray.d, 0.);\n  \n    vec3 col;\n    if(info.w==-1.) \n        col = bg+WaterSurface(cam.ray.d); \n    else \n        col = info.rgb;\n    \n    fragColor = vec4(col, .1);\n}","name":"Image","description":"","type":"image"}]}