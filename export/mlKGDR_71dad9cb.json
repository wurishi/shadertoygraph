{"ver":"0.1","info":{"id":"mlKGDR","date":"1683831015","viewed":43,"name":"RayMarchingMugs","username":"CEDipEngineering","description":"Ray marghing mugs with phong shading.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.1415\n\n\nfloat sdSphere(vec3 p, float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n    if (obj2.a < obj1.a) return obj2;\n    return obj1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 rotationZ(float theta){\n    return mat3(\n        cos(theta) , 0.0, -sin(theta), // primera coluna\n        0.0 , 1.0 , 0.0,\n        sin(theta), 0.0, cos(theta) // segunda coluna\n    );\n}\n\nmat3 rotationX(float theta){\n    float ct = cos(theta);\n    float st = sin(theta);\n    return mat3(\n        1.0, 0.0, 0.0, // primera coluna\n        0.0, ct , st ,\n        0.0, -st, ct // segunda coluna\n    );\n}\n\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat mug(vec3 p){\n    float exterior = sdCappedCylinder(p - vec3(2.5, 0, -2), 1.5, 1.5);\n    float handle = sdLink(p - vec3(1, 0, -2), 0.2, 1.1, 0.2);\n    float interior_cut = sdCappedCylinder(p - vec3(2.5, 0.1, -2), 1.6, 1.2);\n    return max(min(exterior, handle), -interior_cut);\n}\n\nvec4 sdScene(vec3 p) {\n    p.z -= 0.5;\n    p = rotationZ(iTime/2.0)*p;\n    vec4 mugRight = vec4(vec3(0.1, 0.9, 0.3), mug(p - vec3(0.5, 0, 0)));\n    vec4 mugLeft = vec4(vec3(0.7, 0.2, 0.1), mug(p - vec3(-5.5, 0, 0)));\n    vec4 co = minWithColor(mugLeft, mugRight);\n    return co;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    vec4 co;\n    for (int i = 0; i < 255; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.a;\n        if (co.a < 0.001 || depth > end) break;\n    }\n    return vec4(co.rgb, depth);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).a +\n        e.yyx * sdScene(p + e.yyx).a +\n        e.yxy * sdScene(p + e.yxy).a +\n        e.xxx * sdScene(p + e.xxx).a);\n}\nmat4 look_at(vec3 eye, vec3 at, vec3 up) {\n    vec3 w = normalize(at - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat4(\n        vec4(u, 0.0),\n        vec4(v, 0.0),\n        vec4(-w, 0.0),\n        vec4(vec3(0.0), 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.0, 5.0, 15.0);\n    mat4 view = look_at(ro, vec3(0.0, -PI/6.0, -3.0), vec3(0.0, 1.0, 0.0));\n    vec3 rd = normalize(vec3(uv, -1));\n    rd = normalize((view * vec4(rd, 1.0)).xyz);\n    \n    vec4 co = rayMarch(ro, rd, 0.01, 100.0);\n    \n    if (co.a > 100.0) col = vec3(0.6);\n    else {\n        vec3 p = ro + rd * co.a;\n        vec3 normal = calcNormal(p);\n        vec3 lightPos = vec3(-2.0*sin(iTime), 2, 5);\n        vec3 lightDir = normalize(lightPos - p);\n        float ambient = 0.3;\n        float difuse = clamp(dot(normal, lightDir),ambient,1.);\n        col = difuse * co.rgb;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}