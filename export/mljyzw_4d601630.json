{"ver":"0.1","info":{"id":"mljyzw","date":"1691615003","viewed":428,"name":"Cloudy SDF Shapes","username":"pixelbeat","description":"More primitives added to the map.\n\nOriginal: https://www.shadertoy.com/view/WdXGRj","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["volume","raymarch","cloud"],"hasliked":0,"parentid":"WdXGRj","parentname":"Cloudy Shapes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original: https://www.shadertoy.com/view/WdXGRj\n// by kaneta\n\n\n// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\n\n\nmat3 m = mat3(0.00, 0.80, 0.60,\n  -0.80, 0.36, -0.48,\n  -0.60, -0.48, 0.64);\n  \nfloat hash(float n)\n{\n  return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n  float res = mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n      mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n      mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n  return res;\n}\n\nfloat fbm(vec3 p)\n{\n  float f;\n  f = 0.5000 * noise(p); p = m * p * 2.02;\n  f += 0.2500 * noise(p); p = m * p * 2.03;\n  f += 0.12500 * noise(p); p = m * p * 2.01;\n  f += 0.06250 * noise(p);\n  return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n// iq's smin\nfloat smin(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdCross(in vec3 p, in float s)\n{\n  float da = max(abs(p.x), abs(p.y));\n  float db = max(abs(p.y), abs(p.z));\n  float dc = max(abs(p.z), abs(p.x));\n  return min(da, min(db, dc)) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sdBlob(in vec3 p, in float r)\n{\n  vec3 v1 = p * 6.0;\n  return 0.05 * (r + 0.5 * (length(dot(v1, v1)) - 0.51 * (cos(4. * v1.x) + cos(4. * v1.y) + cos(4. * v1.z))));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n\n  vec2 d = vec2(\n    length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n    p.z - h.y);\n\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdBoxFrame(vec3 p, vec3 b, float e)\n{\n  p = abs(p) - b;\n  vec3 q = abs(p + e) - e;\n\n  return min(min(\n      length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n      length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n    length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat map(in vec3 p)\n{\n  vec3 q = p - vec3(0.0, 0.5, 1.0) * iTime;\n  float f = fbm(q);\n  float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n  float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n  float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n  float cross = 1. - sdCross(p * 2.0, 0.35) + f * 3.5;\n  float blob = 1. - sdBlob(p, 6.0) + f * 3.5;\n  float cappedTorus = 1. - sdCappedTorus(p * 2.0, vec2(2., -0.05), 0.5, 0.125) + f * 3.5;\n  \n  vec3 a = vec3(1.0, 1.0, 0.0);\n  float sr1 = 0.1 + 0.5;\n  vec3 b = vec3(-0.5, -0.5, 0.5);\n  float sr2 = 0.0025;\n  \n  float cone = 1. - sdRoundCone(p, vec3(5.0, 0.5, 0.5), vec3(-5.0, 0.5, 0.5), 0.5 + 0.025, 0.00025) + f * 3.5;\n  \n  float hex = 1. - sdHexPrism(p, vec2(2., 0.5)) + f * 3.5;\n  float s3 = 1.0 - smin(smin(\n      length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n      length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n    length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n\n  float t = mod(stepUp(iTime, 4.0, 1.0), 8.0); // Change the modulus to 8 because we have 8 segments.\n\n  float d = mix(s1, s2, clamp(t, 0.0, 1.0));\n  d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\n  d = mix(d, cross, clamp(t - 2.0, 0.0, 1.0));\n  d = mix(d, cone, clamp(t - 3.0, 0.0, 1.0));\n  d = mix(d, hex, clamp(t - 4.0, 0.0, 1.0));\n  d = mix(d, s3, clamp(t - 5.0, 0.0, 1.0));\n  d = mix(d, s1, clamp(t - 6.0, 0.0, 1.0)); // Add back to s1, as in the original sequence.\n\n  return min(max(0.0, d), 1.0);\n}\n\nfloat map2(in vec3 p)\n{\n    vec3 q = p - vec3(0.0, 0.5, 1.0) * iTime;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float cone = 1. - sdRoundCone(p, vec3(5.0, 0.5, 0.5), vec3(-5.0, 0.5, 0.5), 0.5 + 0.025, 0.00025) + f * 3.5;\n    \n    float t = mod(stepUp(iTime, 4.0, 1.0), 4.0);  // Adjusted the modulus to 4 since we have 4 segments.\n\n    float d = mix(s1, s2, clamp(t, 0.0, 1.0));\n    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, cone, clamp(t - 2.0, 0.0, 1.0));\n    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));  // Return back to s1, as specified.\n\n    return min(max(0.0, d), 1.0);\n}\n\n\n\nfloat jitter;\n\n#define MAX_STEPS 56\n#define SHADOW_STEPS 3\n#define VOLUME_LENGTH 16.\n#define SHADOW_LENGTH 1.\n\n// Reference\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n  float density = 0.;\n\n  float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n  float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n  vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n  vec4 sum = vec4(0., 0., 0., 1.);\n\n  vec3 pos = p + ray * jitter * stepLength;\n\n  for (int i = 0; i < MAX_STEPS; i++)\n  {\n    if (sum.a < 0.1) {\n      break;\n    }\n    float d = map(pos);\n\n    if (d > 0.001)\n    {\n      vec3 lpos = pos + light * jitter * shadowStepLength;\n      float shadow = 0.;\n\n      for (int s = 0; s < SHADOW_STEPS; s++)\n      {\n        lpos += light * shadowStepLength;\n        float lsample = map(lpos);\n        shadow += lsample;\n      }\n\n      density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n      float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n      sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n      sum.a *= 1. - density;\n\n      sum.rgb += exp(-map(pos + vec3(0, 0.25, 0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n    }\n    pos += ray * stepLength;\n  }\n\n  return sum;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = normalize(cross(cu, cw));\n  return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  jitter = hash(p.x + p.y * 57.0 + iTime);\n  vec3 ro = vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0);\n  vec3 ta = vec3(0.0, 1., 0.0);\n  mat3 c = camera(ro, ta, 0.0);\n  vec3 ray = c * normalize(vec3(p, 1.75));\n  vec4 col = cloudMarch(ro, ray);\n  vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n\n  float sundot = clamp(dot(ray, normalize(vec3(1.0, 2.0, 1.0))), 0.0, 1.0);\n  result += 0.4 * vec3(1.0, 0.7, 0.3) * pow(sundot, 4.0);\n\n  result = pow(result, vec3(1.0 / 2.2));\n\n  fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}