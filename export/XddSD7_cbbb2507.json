{"ver":"0.1","info":{"id":"XddSD7","date":"1459763977","viewed":396,"name":"Dynamic resolution interferences","username":"waterhead","description":"Just some simple test pattern for some dynamic coordinate space tiling. Just subdivides continous coordinate space into dynamically sized squares and renders some circular interferences into it, in order to show the varying grid size.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","interference","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float MAX_DIMENSION = max(iResolution.x, iResolution.y);\n    float U_OFFSET = -0.5;\n    float V_OFFSET = -0.5 * iResolution.y / iResolution.x;\n\n    \n    // init some arguments for animation, like rotation, zoom and stuff:\n    float rotation = sin(0.31 * iTime);\n    float pelSize = (1.000001 - (cos(iTime * 0.23) * 0.5 + 0.5)) * 20.0;\n    float zoom = pelSize / MAX_DIMENSION;\n    float zoomH = 0.5 * zoom;\n\n    // grab UV and center\n    vec2 uv = vec2(fragCoord.x / MAX_DIMENSION + U_OFFSET,\n                   fragCoord.y / MAX_DIMENSION + V_OFFSET);\n\n    // apply rotation\n    float sinA = sin(rotation);\n    float cosA = cos(rotation);\n    vec2 pnt = vec2(uv.x * cosA - uv.y * sinA - zoomH,\n                    uv.y * cosA + uv.x * sinA - zoomH);\n    \n    vec2 offsetUV = floor((pnt + zoom) / zoom) * zoom;\n    \n    vec3 color = vec3(0.0);\n   \n    for(float i = 0.0; i < 4.0; i++) {\n        // move circle center to to somehwere\n        vec2 center = vec2( 0.3 * sin(iTime * 0.13 + i * 1.5707963267948966),\n                            0.3 * cos(iTime * 0.17 + i * 1.5707963267948966));\n        \n        // grab distance to center...\n        float distance = length(center - offsetUV);\n\n        // ...and create some color based on distance:\n        color.x += sin(distance * (201.0)) * 1.0;\n        color.y += sin(distance * (167.0)) * 2.0;\n        color.z += sin(distance * (123.0)) * 4.0;\n    }\n\n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}