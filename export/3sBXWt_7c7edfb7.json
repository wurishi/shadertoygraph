{"ver":"0.1","info":{"id":"3sBXWt","date":"1555231777","viewed":159,"name":"Smooth living noise","username":"AlexK","description":"Based on https://www.shadertoy.com/view/3d2SWc \nScalable procedural noise, that also continuously evolve in time.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","life"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TIMESCALE = 0.5;\nconst float DETALIZATION = 1.8;\n\nfloat[] seed = float[](.25, .5,\n                     .75, 1.) ;\n\n\nfloat rnd(float seed){\n\treturn fract((1. - cos((seed + 21.2313662551) * 37.6447205633))/2.);\n}\n\nvec2 color(vec2 uv, float col, int i, float r){\n    int x = int(uv.x * 2.)%2;\n    int y = int(uv.y * 2.)%2;\n\n    float c;\n    \n    float r1 = rnd(float(i));\n    float r2 = rnd(seed[y * 2 + x]);\n    \n    float r3 = rnd((r1 + r2) * r);\n    \n    \n    c = (col + r3 + col * (r3 - 0.5) * 0.6) * 1.2 ;\n    \n\treturn vec2(c, r3);\n}\n\nfloat l_norm(vec2 v, float p){\n\treturn pow(pow(abs(v.x), p) + pow(abs(v.y), p), 1./p);\n}\n\nfloat gen_map(float init, vec2 n_uv, int iters, float seed, float time, float bol){\n    float val = init;\n    float r = seed;\n    float inn = time;\n    \n    n_uv = n_uv * 0.5;\n    \n\tfor (int i=0;i<iters;i++){\n        n_uv = mod(n_uv, 1.);\n        \n        vec2 res = color(n_uv, inn, i+1, r);\n     \tfloat bal = bol / pow(float(i+1), 1.);\n        \n        inn = res[0];\n        r = res[1];\n        \n        float val_tot = (bal + cos(inn)) / pow(float(i + 1), 0.4) /2.;\n        val_tot = val_tot * max(0., 1. - pow(l_norm(vec2(.25,.25) - mod(n_uv, 0.5), 3.)*4., 0.85));\n        val += val_tot / pow(float(i+1), 1. / DETALIZATION);\n        \n        n_uv = n_uv * 2.;\n    }\n    \n    return val;\n}\n\n\nvec2 du(float seed){\n\tfloat m_s = rnd(seed);\n    float x_s = rnd(m_s+100.) * 2. - 1.;\n    float y_s = rnd(m_s+200.) * 2. - 1.;\n    \n    return vec2(x_s, y_s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv -= vec2(1.1, 0.6);\n    \n    // Starting at 200000x zoom and move it to 1x over period of 30s\n    float zoom = 1. / min(1., mix(0.000005, 1., pow((1. + iTime) / 30., 5.)));\n    uv = uv / zoom;\n    \n    uv += vec2(1.1, 0.6);\n    uv.y = 1. - uv.y;\n    uv.x += -0.4;\n        \n    float inn = iTime * 0.2; \n    vec2 n_uv = uv;\n    float r = 1.;\n    \n    // Reduce number of iterations as zoom value became smaller (not necessary, just a demonstration of persistence)\n    int iters = int(max(9.,mix(24., 9., pow((1. + iTime) / 30., 5.) )));\n    \n    float val_1 = gen_map(0.3, uv + du(1.)*0.01, iters, 1., 30. + (0.0 + iTime) * TIMESCALE, 0.);\n    float val_2 = gen_map(0.3, uv + du(2.)*0.01, iters, 1., 30. + (0.2 + iTime) * TIMESCALE, 0.);\n    float val_3 = gen_map(0.3, uv + du(3.)*0.01, iters, 1., 30. + (0.4 + iTime) * TIMESCALE, 0.); \n    float val_4 = gen_map(0.3, uv + du(4.)*0.01, iters, 1., 30. + (0.8 + iTime) * TIMESCALE, 0.); \n    \n    //float val = (val_1 + val_2 + val_3 + val_4) / 4.;\n    \n    float val = 0.;\n    val = val * val + val_1 * (1.-val);\n    val = val * val + val_2 * (1.-val);\n\tval = val * val + val_3 * (1.-val);\n    val = val * val + val_4 * (1.-val);\n\n    // Output to screen\n    \n    vec3 col = vec3(val, val, val);\n    //if (col.r <0.4) col = vec3(0.4, 0., 0.);\n    if (uv.x<0. || uv.x>1.) col = vec3(0., 0., 0.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}