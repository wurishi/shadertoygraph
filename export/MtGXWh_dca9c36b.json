{"ver":"0.1","info":{"id":"MtGXWh","date":"1484080373","viewed":1595,"name":"Portal Pool","username":"4DICE7","description":"My first shader - an attempt to create an abstract portal to another dimension!\n\nIterations of pulsing, breathing circles that draw inwards.\n\nDrawing upon the code described by 'phil' at https://www.shadertoy.com/view/ltBXRc","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["circle","sinusoid","vortex","portal","calm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* My first shader - an attempt to create an abstract portal to another dimension!\n*\n* Drawing upon the code described by 'phil' at https://www.shadertoy.com/view/ltBXRc\n**/\n\n\n/**\n* Applies smooth displacement to the circumference of the circle.\n**/\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.;\n}\n\n/**\n* Draws a circle with smooth variation to its circumference over time. \n* @rad - the radius of the circle\n* @width - how thick the circle is\n* @index - what circle is currently being drawn? Currently, every odd circle is drawn with opposing displacement for effect\n**/\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width, float index) {\n    vec2 diff = center-uv;\n    float len = length(diff);\n    float scale = rad;\n\tfloat mult = mod(index, 2.) == 0. ? 1. : -1.; \n    len += variation(diff, vec2(rad*mult, 1.0), 7.0*scale, 2.0);\n    len -= variation(diff, vec2(1.0, rad*mult), 7.0*scale, 2.0);\n    float circle = smoothstep((rad-width)*scale, (rad)*scale, len) - smoothstep((rad)*scale, (rad+width)*scale, len);\n    return vec3(circle);\n}\n\n/**\n* A ring consists of a wider faded circle with an overlaid white solid inner circle. \n**/\nvec3 paintRing(vec2 uv, vec2 center, float radius, float index){\n     //paint color circle\n    vec3 color = paintCircle(uv, center, radius, 0.075, index);\n    //this is where the blue color is applied - change for different mood\n    color *= vec3(0.3,0.85,1.0);\n    //paint white circle\n    color += paintCircle(uv, center, radius, 0.015, index);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //define our primary 'variables'\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    const float numRings = 20.;\n    const vec2 center = vec2(0.5);\n    const float spacing = 1. / numRings;\n    const float slow = 30.;\n    const float cycleDur = 1.;\n    const float tunnelElongation = .25;\n    float radius = mod(iTime/slow, cycleDur);\n    vec3 color;\n\n    //this provides the smooth fade black border, which we will mix in later\n    float border = 0.25;\n    vec2 bl = smoothstep(0., border, uv); // bottom left\n    vec2 tr = smoothstep(0., border, 1.-uv); // top right\n    float edges = bl.x * bl.y * tr.x * tr.y;\n\n    //push in the left and right sides to make the warp square\n    uv.x *= 1.5;\n    uv.x -= 0.25; \n    \n    //do the work\n    for(float i=0.; i<numRings; i++){\n   \t\tcolor += paintRing(uv, center, tunnelElongation*log(mod(radius + i * spacing, cycleDur)), i ); //these are the fast circles\n        color += paintRing(uv, center, log(mod(radius + i * spacing, cycleDur)), i); //these are essentially the same but move at a slower pace\n    }\n\n    //combined, these create a black fade around the edges of our screen\n    color = mix(color, vec3(0.), 1.-edges); \n    color = mix(color, vec3(0.), distance(uv, center));\n    //boom!\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}