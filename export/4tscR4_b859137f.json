{"ver":"0.1","info":{"id":"4tscR4","date":"1503723643","viewed":526,"name":"Proceudual Landscape(jp comment)","username":"sw","description":"based on:\nhttps://www.shadertoy.com/view/4tlSDS\n\nadd japanese comment.\n\nほぼすべての行に日本語のコメントを足しました。\n理解が深めやすいかも?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["landscape","proceudual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cosNoise(in vec2 pos){\n    return 0.5*(sin(pos.x) + sin(pos.y));\n}\n\nconst mat2 m2 = mat2(0.8, -0.6,\n                     0.6, 0.8); \n\nfloat map(in vec3 pos){// pos:レイの位置\n//  return length(pos - vec3(0.0,0.0,-2.0)) -1.0;\n    vec2 q = pos.xz * 0.5; // 山々の感覚を広げる\n    float h = 0.0;\n\n    float s = 0.5;  // noiseの量\n    for(int i = 0; i<10; i++){\n        h += s*cosNoise(q);   // xzから高さを求める\n        s *= 0.5;            // noiseの量を減らす 減らすことで山の先端の細さを作ってる\n        q = m2 * q * 1.7;    // 回転することでボコボコさせる\n    }\n    \n    h *= 3.0;   // 山を高くする\n  \n    return pos.y - h;   // レイの位置から高さを引く　判定側で山のほうが高かったら衝突しているとみなす\n}\n\n\n\n// ノーマルの計算\nvec3 calcNormal(in vec3 pos){\n    vec3 nor;\n    vec2 e = vec2(0.01,0.0);\n    nor.x = map(pos + e.xyy) - map(pos - e.xyy);    //少しだけずらしたときにあたる場所をもとめて　差分からノーマルを作成\n    nor.y = map(pos + e.yxy) - map(pos - e.yxy);\n    nor.z = map(pos + e.yyx) - map(pos - e.yyx);\n    return normalize(nor);\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd){ // ro:カメラの座標 rd:ライトベクトル\n    //ライト方向にレイを飛ばして、衝突したら影にする\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0; i <64; i++){\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n       res = min( res, max(h,0.0)*164.0/t );\n        if(res< 0.0001) break;\n        t+=h*0.5;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy; //解像度の比\n    vec2 q = -1.0 + 2.0*p;                  // 解像度の比を-1~1にまとめた\n    q.x *= 1.777;                           // x方向を大きく　なぜ1.777?\n \n    vec3 ro = vec3(0.0, 1.65, -iTime);      // カメラのポジション\n    vec3 rd = normalize( vec3(q, -1.0));    // レイの方向\n    \n    vec3 col = vec3(0.7, 0.8, 1.0);         // 初期カラー\n    col *= 1.0 -0.5 *rd.y;                  // 上ほど色を落としている\n    float tmax =40.0;                       // 探索最大距離　４０以上奥になにかあっても打ち切られる\n    float t = 0.0;                          // レイを伸ばしていく係数\n    \n    for(int i=0; i<256; i++){               // 256回レイを進めていく \n        vec3 pos = ro + rd*t;               // カメラ位置からレイ方向にｔ分だけ移動する\n        float h = map(pos);                 // レイ方向にある一番近い山の面までの距離を取得\n        if(h < 0.001 || t > tmax) break;    // 0.001以下だったらそこに山の面がある　tmax以上だったらなにもない\n        \n        t += h*0.5;                         // 山の面までの半分の距離分だけレイをすすめる\n    }\n    \n    vec3 light = normalize(vec3(1.0,0.1,-0.5)); // ライトベクトル\n    \n    if(t < tmax){   // 山の面に衝突している\n        vec3 pos = ro + t*rd;   // 山の面の座標\n        vec3 nor = calcNormal(pos); // 法線を計算\n        float sha = calcShadow(pos + nor *0.1,light); // 影を計算\n\n        float dif = clamp (dot(nor,light), 0.0,1.0);  // lumbert拡散照明によるライティング\n        vec3 lig = vec3(2.0, 1.5,1.0)*dif *sha;       // ライト色*ライティング*影\n        lig += vec3(0.1,0.2,0.3)*nor.y *2.0;          // 上方向ほど色を明るめに\n        \n        // 法線による色変化　上に向いているほど色をつけている\n        vec3 mate = vec3(0.2, 0.3, 0.3)*0.5; \n        mate = mix(mate, vec3(0.2,0.15,0.1), smoothstep(0.7,0.9,nor.y));\n        col = lig * mate;\n        \n        float fog = exp(-0.002 *t * t); // fog\n        col *= fog;\n        col += ((1.0 - fog)*vec3(0.5,0.6,0.7));\n    }\n    \n    // gamut for monitor\n    col = sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}