{"ver":"0.1","info":{"id":"sl3BDl","date":"1663975448","viewed":316,"name":"Dark Star","username":"myth0genesis","description":"Just messing around with the concept of a 4D gyroid approximation (actually not a gyroid, but using the same approximation formula for one extended to 4 dimensions).","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ray","raymarch","sun","raymarched","marching","star","4d","march","gyroid","dark","marched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022 myth0genesis\n// Dark Star\n// Just seeing where traveling through the 4th dimension can take me\n\nconst mat3 m3 = mat3( 0.33338, 0.56034, -0.71817,\n                     -0.87887, 0.32651, -0.15323,\n                      0.15162, 0.69596,  0.61139) * 1.93;\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, s,\n                -s, c);\n}\n\nfloat smoothestStep(float edge0, float edge1, float x) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    float x2 = x * x;\n    return x2 * x2 * (x * (x * (x * -20.0 + 70.0) - 84.0) + 35.0);\n}\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n// my favorite fBm function by nimitz, with some 4D modifications\nfloat gyroidFBM4D(vec4 p, float cl) {\n    float d = 0.0;\n    p *= 0.016;\n    float z = 2.0;\n    float trk = 1.0;\n    float dspAmp = 0.1;\n    for (int i = 0; i < 5; i++) {\n        \n        // 4D swizzles!!\n        // this makes the noise and motion isotropic\n        // by allowing the layers of noise\n        // to also move through a 4th dimension\n        p += sin(p.zwyx * 0.75 * trk) * dspAmp;\n        d -= abs(dot(cos(p), sin(p.wxyz)) * z);\n        \n        z *= 0.57;\n        trk *= 1.5;\n        \n        // if you're not lazy like me, you can solve\n        // for planar rotations below\n        // (or any transformations where unit vector lengths are constant)\n        // in 4D and multiply every p channel with a 4D \"rotation\" matrix\n        // or you can dispense with the above-mentioned constraint\n        // and make a 4D skewing or scaling matrix, too\n        p.xyz *= m3;\n        \n        // let movement be variable per layer\n        p.w -= iTime * 0.4;\n    }\n    return (cl - d * 15.0);\n}\n\nfloat getDist(vec3 p) {\n    float d = gyroidFBM4D(vec4(p, 0.0), sphereSDF(p, vec3(0.0), 400.0));\n    return d * 0.5;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out float ns) {\n    float dO = 0.0;\n    float numSteps = 0.0;\n    for(int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        numSteps++;\n        if (dO > 1000.0 || abs(dS) < 0.01) break;\n    }\n    \n    // output the number of steps when hit (free glow)\n    // try to keep bands at each end of the spectrum\n    // close together with a high-order polynomial\n    ns = smoothestStep(0.1, 1.0, numSteps * 0.022);\n    \n    return dO;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, -1000.0);\n    float stepCol;\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    mat2 rot = rotate(iTime * 0.1);\n    rd.xz *= rot;\n    ro.xz *= rot;\n    \n    float d = rayMarch(ro, rd, stepCol);\n    vec3 p = ro + rd * d;\n    \n    col = vec3(stepCol, stepCol * 0.45, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}