{"ver":"0.1","info":{"id":"lt2cDd","date":"1510755633","viewed":209,"name":"Energy orbs","username":"frostbyte","description":"Just a test scene with some energy orbs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighting","energy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define C_SMALL 0.000001\n#define C_NUM_SPHERES 3\n#define C_SPHERE_RADIUS 15.0\n#define C_ENERGY_COLOR vec3(0.2, 0.65, 1.0)\n\n#define PI 3.1415\n\n#define TONEMAP_GAMMA 2.2\n\nconst vec3 g_cameraPosition = vec3(0,5,-10);\nvec3 g_spherePositions[C_NUM_SPHERES];\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nfloat luminance(vec3 color)\n{\n\treturn dot(vec3(0.299, 0.587, 0.114), color);\n}\n\nvec3 tonemap_reinhard(vec3 color)\n{\n   color *= 16.0;\n   color = color / (1.0+color);   \n   return pow(color, vec3(TONEMAP_GAMMA));\n}\n\nfloat schlick(float F0, vec3 dir, vec3 normal)\n{\n\treturn F0 + (1.0 - F0) * pow( (1.0 - max(0.0, dot(dir, normal))), 5.0);\n}\n\nvec4 traceSphere(vec3 ray, vec3 dir, vec3 center)\n{\n \tvec4 result;\n    \n    float t = sphere(ray, dir, center, C_SPHERE_RADIUS);\n    if (t >= 0.0)\n    {\n        vec4 color = vec4(C_ENERGY_COLOR, 1.0);\n        vec3 wpos = ray + dir * t;        \n        vec3 N = normalize(center - wpos);\n        vec3 R = reflect(-N, dir);\n        \n        float rimVal = max(0.5, (1.0 - max(0.0, dot(dir, N)) ) );\n        vec3 rim = C_ENERGY_COLOR * rimVal;\n        vec3 reflection = texture(iChannel3, R).xyz * 0.25;\n        \n        // make it a bit stronger at rim\n        float rimMultiplier = smoothstep(0.2, 1.0, rimVal * rimVal) * 16.0;\n        \n        // inv rim\n        float darkRim = pow(1.0 - rimVal, 1.5);\n        \n    \tresult = vec4(darkRim * (rim * rimMultiplier + reflection * rim), 1.0);\n        \n        // soft clip it with the ground\n        float t = smoothstep(1.0, 0.0, wpos.y);\n        result = mix(result, vec4(0), t);\n    }\n    \n    return result;\n}\n\nvec4 traceFloor(vec3 ray, vec3 dir)\n{\n    vec4 result;\n    \n    const vec3 N = vec3(0,1,0);\n    const vec3 P = vec3(0,0,0);\n    \n    float d = dot(N, dir);\n    \n    float t = dot(P - ray, N) / d;\n    if (t >= 0.0)\n    {\n        vec3 wpos = ray + t * dir;\n        vec2 floorUv = wpos.xz / 16.0;\n        \n        vec3 reflectionVector = reflect(dir, N);\n        vec4 floorTexture = texture(iChannel0, floorUv);\n        vec3 floorAlbedo = floorTexture.rgb;\n                               \n        // reflection                \n        float floorReflectivity = pow(floorAlbedo.r, 16.0);\n        float floorRoughness = floorAlbedo.r;\n        float F = schlick(floorReflectivity, normalize(ray - wpos), N);\n        vec3 floorReflection = texture(iChannel1, reflectionVector).rgb;\n        \n        // calculate normal map\n        const vec2 texelSize = vec2(1.0 / 512.0, 1.0 / 512.0);\n        \n        float me = luminance(texture(iChannel0, floorUv).xyz);\n        float n = luminance(texture(iChannel0,vec2(floorUv.x,floorUv.y+texelSize.y)).xyz);\n        float s = luminance(texture(iChannel0,vec2(floorUv.x,floorUv.y-texelSize.y)).xyz);\n        float e = luminance(texture(iChannel0,vec2(floorUv.x+texelSize.x,floorUv.y)).xyz);\n        float w = luminance(texture(iChannel0,vec2(floorUv.x-texelSize.x,floorUv.y)).xyz);         \n        vec3 tanZ = vec3(0.0, (n-s), 1.0);\n\t\tvec3 tanX = vec3(1.0, (e-w), 0.0);\n        vec3 floorNormal = normalize(cross(tanZ, tanX));\n        \n        // lambertian\n        vec3 totalLighting;\n        for (int i=0; i<C_NUM_SPHERES; i++)\n        {\n        \tvec3 L = normalize(g_spherePositions[i] - wpos);\n            float D = distance(g_spherePositions[i], wpos);\n            float NdotL = max(0.0, dot(L, floorNormal));\n            float attenuation = 1.0 - clamp(D / (C_SPHERE_RADIUS * 1.45), 0.0, 1.0);\n            \n            totalLighting += attenuation * NdotL * C_ENERGY_COLOR;\n        }\n        \n        result.rgb = floorAlbedo * totalLighting + floorReflection * F * totalLighting;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    g_spherePositions[0] = vec3(5.0 * cos(iTime/3.0), 6.0 + sin(iTime), 15.0 + 5.0 * cos(iTime/5.0 + PI));\n    g_spherePositions[1] = vec3(6.0 * sin(iTime/4.0 + PI*0.5), 6.0 - sin(iTime * 2.0 + PI/2.0), 40.0 + 4.0 * sin(iTime/4.0));\n    g_spherePositions[2] = vec3(4.0 * cos(iTime/2.0 - PI*0.5), 6.0 + cos(iTime / 2.0 - PI*2.0), 100.0 + 6.0 * cos(iTime/2.0));\n    \n    \n    vec3 rayOrigin = g_cameraPosition;\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    \n    vec4 color = traceFloor(rayOrigin, rayDir);\n    \n    for (int i=0; i<C_NUM_SPHERES; i++)\n    {\n        float uvx = uv.x + iTime * 0.25;\n        float uvy = uv.y + cos(iTime * 0.25) * 0.5;\n        vec2 noiseUv = vec2(uvx, uvy) * 0.04;\n        vec3 noise = texture(iChannel2, noiseUv).xyz * 2.0 - 1.0;\n        vec3 sphereRayDir = normalize(rayDir + noise * 0.01);\n        \n    \tvec4 sphereColor = traceSphere(rayOrigin, sphereRayDir, g_spherePositions[i]);\n        color.rgb += sphereColor.rgb;        \n    }\n   \n    color.rgb = tonemap_reinhard(color.rgb);\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}