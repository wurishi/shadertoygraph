{"ver":"0.1","info":{"id":"wlVGWz","date":"1579315745","viewed":105,"name":"Palette Sandbox Controls - WIP","username":"Eggy42","description":"Work in progress adding controls to palette visualizer. \n\nhttps://www.shadertoy.com/view/wlyGzh","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sandbox based on IQ's procedural pallete example:\n// Pallette Sandbox based on IQ's example:\n//\n// https://www.shadertoy.com/view/ll2GD3\n// https://iquilezles.org/articles/palettes\n// The MIT License\n// Copyright Â© 2015 Inigo Quilez\n\n// ====== cut/paste here ======\n//      A Component  R     G     B   (Y shift)\n#define pal_a vec3( 0.50, 0.50, 0.50 )  \n//      B Component  R     G     B   (amplitude)\n#define pal_b vec3( 0.50, 0.50, 0.50 )  \n//      C Component  R     G     B   (period)\n#define pal_c vec3( 1.00, 0.70, 0.40 )  \n//      D Component  R     G     B   (phase)\n#define pal_d vec3( 0.00, 0.15, 0.20 )  \n\nvec3 pal( in float t )\n{\n    return pal_a + pal_b*cos( 6.28318*(pal_c*t+pal_d) );\n}\n// ====== cut/paste end here ======\n\n// ----\n// GLSL Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n// And TimoKinnunen\n// https://www.shadertoy.com/view/lt3GRj\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value, float digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord*iResolution.xy) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ----\n\n#define FONT_SIZE vec2(20., 25.)\n#define MAX_DIGITS 2.\n#define MAX_DECIMALS 2.\n\n// storage register/texel addresses\nconst ivec2 txA_X = ivec2(0,0);\nconst ivec2 txA_Y = ivec2(1,0);\nconst ivec2 txA_Z = ivec2(2,0);\nconst ivec2 txB_X = ivec2(3,0);\nconst ivec2 txB_Y = ivec2(4,0);\nconst ivec2 txB_Z = ivec2(5,0);\nconst ivec2 txC_X = ivec2(6,0);\nconst ivec2 txC_Y = ivec2(7,0);\nconst ivec2 txC_Z = ivec2(8,0);\nconst ivec2 txD_X = ivec2(9,0);\nconst ivec2 txD_Y = ivec2(10,0);\nconst ivec2 txD_Z = ivec2(11,0);\n\nvec3 pal2( in float t, vec3 A, vec3 B, vec3 C, vec3 D)\n{\n    return clamp(A + B*cos( 6.28318*(C*t+D)), 0., 1.);\n}\n\nfloat loadValue( in ivec2 register )\n{\n    vec4 v = texelFetch( iChannel0, register, 0 );\n    return v.z + (v.y*100.) * ((v.x == 1.) ? -1. : 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float thickness = .015;\n    \n    // Load vars\n    vec3 A = vec3(loadValue(txA_X), loadValue(txA_Y), loadValue(txA_Z));\n    vec3 B = vec3(loadValue(txB_X), loadValue(txB_Y), loadValue(txB_Z));\n    vec3 C = vec3(loadValue(txC_X), loadValue(txC_Y), loadValue(txC_Z));\n    vec3 D = vec3(loadValue(txD_X), loadValue(txD_Y), loadValue(txD_Z));\n    \n    // Animate\n    p.x += 0.05*iTime;\n        \n    // Default color\n    vec3 col = vec3(0);\n    \n    // Band\n    float f = fract(p.y*4.0);\n    \n    // Curve for B\n    col = vec3(0, 0, smoothstep(thickness+.01, thickness, abs(pal2(p.x,A,B,C,D).z-f)));\n    \n    // Curve for G\n    if( p.y>(1./4.) ) {\n\t    col = vec3(0, smoothstep(thickness+.01, thickness, abs(pal2(p.x,A,B,C,D).y-f)), 0);\n    }\n    // Curve for R\n    if( p.y>(2./4.) ) {\n\t    col = vec3(smoothstep(thickness+.01, thickness, abs(pal2(p.x,A,B,C,D).x-f)), 0, 0);\n    }\n    \n    // Compute palette color\n    if( p.y>(3./4.) ) col = pal2(p.x,A,B,C,D);\n    \n    float digit = 0.;\n    // Print RED values\n    digit = PrintValue(fragCoord, vec2(0.,0.66), FONT_SIZE, A.x, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(1.0, 0.5, 0.5), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.61), FONT_SIZE, B.x, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(1.0, 0.5, 0.5), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.56), FONT_SIZE, C.x, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(1.0, 0.5, 0.5), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.51), FONT_SIZE, D.x, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(1.0, 0.5, 0.5), digit);\n    \n    // Print GREEN values\n    digit = PrintValue(fragCoord, vec2(0.,0.41), FONT_SIZE, A.y, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.2, 0.5, 0.2), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.36), FONT_SIZE, B.y, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.2, 0.5, 0.2), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.31), FONT_SIZE, C.y, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.2, 0.5, 0.2), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.26), FONT_SIZE, D.y, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.2, 0.5, 0.2), digit);\n\n    // Print BLUE values\n    digit = PrintValue(fragCoord, vec2(0.,0.16), FONT_SIZE, A.z, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.5, 0.5, 1.0), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.11), FONT_SIZE, B.z, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.5, 0.5, 1.0), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.06), FONT_SIZE, C.z, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.5, 0.5, 1.0), digit);\n    digit = PrintValue(fragCoord, vec2(0.,0.01), FONT_SIZE, D.z, MAX_DIGITS, MAX_DECIMALS);\n\tcol = mix( col, vec3(0.5, 0.5, 1.0), digit);\n\n    \n    // Borders\n    col = mix(col, vec3(.5), vec3(step( .5-thickness*.2, abs(f-0.5))));\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Runs the state machine and stores values in BufferA\n// Most of this is derived from IQ's Bricks Game\n// https://www.shadertoy.com/view/MddGzf\n\n//      A Component  R     G     B   (Y shift)\n#define pal_a vec3( 0.50, 0.50, 0.50 )  \n//      B Component  R     G     B   (amplitude)\n#define pal_b vec3( 0.50, 0.50, 0.50 )  \n//      C Component  R     G     B   (period)\n#define pal_c vec3( 1.00, 0.70, 0.40 )  \n//      D Component  R     G     B   (phase)\n#define pal_d vec3( 1.00, 0.15, 0.20 )  \n\n// storage register/texel addresses\nconst ivec2 txA_X = ivec2(0,0);\nconst ivec2 txA_Y = ivec2(1,0);\nconst ivec2 txA_Z = ivec2(2,0);\nconst ivec2 txB_X = ivec2(3,0);\nconst ivec2 txB_Y = ivec2(4,0);\nconst ivec2 txB_Z = ivec2(5,0);\nconst ivec2 txC_X = ivec2(6,0);\nconst ivec2 txC_Y = ivec2(7,0);\nconst ivec2 txC_Z = ivec2(8,0);\nconst ivec2 txD_X = ivec2(9,0);\nconst ivec2 txD_Y = ivec2(10,0);\nconst ivec2 txD_Z = ivec2(11,0);\n\n// Unpack a vec4 at a texel into a signed float -99.99 to 99.99\nfloat loadValue( in ivec2 register )\n{\n    vec4 v = texelFetch( iChannel0, register, 0 );\n    return v.z + (v.y*100.) * ((v.x == 1.) ? -1. : 1.);\n}\n\n// Pack a vec4 at a texel into a signed float -99.99 to 99.99\nvoid storeValue( in ivec2 register, in float value, inout vec4 fragColor, in ivec2 p )\n{\n    float s = (value<0.) ? 1. : 0.;\n    float f = fract(abs(value));\n    float i = fract(floor(abs(value))/100.);\n    fragColor = (p==register) ? vec4(s,i,f,0.) : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute state outside of the data area\n    if( fragCoord.x > 13. || fragCoord.y > 1. ) discard;\n    \n    // No idea what this does...\n    ivec2 ipx = ivec2(fragCoord-0.5);\n\n    // Load game state\n    float A_X = loadValue(txA_X);\n    float A_Y = loadValue(txA_Y);\n    float A_Z = loadValue(txA_Z);\n    float B_X = loadValue(txB_X);\n    float B_Y = loadValue(txB_Y);\n    float B_Z = loadValue(txB_Z);\n    float C_X = loadValue(txC_X);\n    float C_Y = loadValue(txC_Y);\n    float C_Z = loadValue(txC_Z);\n    float D_X = loadValue(txD_X);\n    float D_Y = loadValue(txD_Y);\n    float D_Z = loadValue(txD_Z);\n    \n    // Initialize the state\n    if( iFrame < 10 ) {\n        A_X = pal_a.x;\n        A_Y = pal_a.y;\n        A_Z = pal_a.z;\n        B_X = pal_b.x;\n        B_Y = pal_b.y;\n        B_Z = pal_b.z;\n        C_X = pal_c.x;\n        C_Y = pal_c.y;\n        C_Z = pal_c.z;\n        D_X = pal_d.x;\n        D_Y = pal_d.y;\n        D_Z = pal_d.z;\n    }\n    \n    // Mouse info\n   \tvec2 mxy = iMouse.xy / iResolution.xy;\n\tvec2 mzw = iMouse.zw / iResolution.xy;\n    float mdistx = mzw.x - mxy.x;\n    float mdisty = mzw.y - mxy.y;\n\n    // Mouse controls\n    if (mzw.y>(3./4.)) {\n\t\t// Do nothing over the palette\n    } else if (mzw.y>(2./4.)) {\n        // Red component\n\t    A_X = mdisty;\n    \tD_X = mdistx;\n    } else if (mzw.y>(1./4.)) {\n\t    A_Y -= mdisty;\n    \tD_Y += mdistx;\n    } else if (mzw.y>(0./4.)) {\n\t    A_Z -= mdisty;\n    \tD_Z += mdistx;\n    }\n\n    // Store state\n    fragColor = vec4(0.0);\n    storeValue(txA_X, A_X, fragColor, ipx);\n    storeValue(txA_Y, A_Y, fragColor, ipx);\n    storeValue(txA_Z, A_Z, fragColor, ipx);\n    storeValue(txB_X, B_X, fragColor, ipx);\n    storeValue(txB_Y, B_Y, fragColor, ipx);\n    storeValue(txB_Z, B_Z, fragColor, ipx);\n    storeValue(txC_X, C_X, fragColor, ipx);\n    storeValue(txC_Y, C_Y, fragColor, ipx);\n    storeValue(txC_Z, C_Z, fragColor, ipx);\n    storeValue(txD_X, D_X, fragColor, ipx);\n    storeValue(txD_Y, D_Y, fragColor, ipx);\n    storeValue(txD_Z, D_Z, fragColor, ipx);\n}","name":"Buffer A","description":"","type":"buffer"}]}