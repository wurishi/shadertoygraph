{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//-----------------------------\n#define time iTime\n#define EPSILON .001\n\nconst int MAX_ITER = 250;\nvec3 lightDir       = normalize(vec3(-1.6, -7., -6.4)); \nint typeFigura = 0; \nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n     \n};\nmat materialMy = mat(0.0);\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\n//-----------------------------\nvec3 rotationCoord(vec3 n)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time * 0.1;//tmpTime;//\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//----------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//----------------------------------------------------\nfloat trunCapsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h * 2. );\n    return max(length(p) - r ,  abs(p.z)- h * 0.5);\n}\n//--------------------------------------------------\nfloat sdHeart(in vec3 pos, in float r, in float d) \n{\n    pos = -pos; \n    pos.x = abs(pos.x);\n    pos.xy = sqrt(1.2)* 0.2 *mat2(1.,-1.,1.,1.)*pos.xy;\n    float hr = trunCapsuleY(pos-vec3(r, 0, 0), r, d);\n    return hr;\n}\n//---------------------------------------------\nfloat pTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//---------------------------------------------\nfloat distMat(inout float curDist, float dist, in float typeMat)\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------\n    float param = 0.5;  \nvec3 map(vec3 p)\n{\n  //  float param = 0.5;  \n    float of = texture( iChannel1, vec2( .01, .25 ) ).x;\n    param *= of;\n    return 0.8 * (0.6 + 0.4 *cos(p * param));\n}\n//--------------------------------------------------\n float a = -0.2;\n float b = 10.;//10.0;\nvec3 offSize(vec3 p)\n{\n// float b =10.0;    \n    float of = texture( iChannel1, vec2( .01, .25 ) ).x;\n    a *= of;    \n    \n float y = a * cos( b * p.x) + b * sin(a * p.x);\n p.y += y;\n return p;\n\n}\n//--------------------------------------------------\nfloat myObject(in vec3 p)\n{\n\n   float d =  1.0;\n   materialMy.typeMat = 0.0;\n\n   vec3 pos = p;\n   pos += vec3(0., -0.5, 10.);\n\n   pos = rotationCoord(pos);  \n   if(typeFigura == 0)\n   {\n      pos *= map(pos);   \n      d =  distMat(d,   sdHeart(pos, 2.2, 3.3),  1.0);        \n   }\n   else\n   {\n   \t  pos *= offSize(pos);\n      d =  distMat(d,   pTorus(pos, vec2(190., 135)),  1.0);           \n       \n   }\n    return d; \n}\n//-------------------------------------------------\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( 0.1, 0., 0. );\n   vec3 nor = vec3(\n       renderFunction(p+e.xyy) - renderFunction(p-e.xyy),\n       renderFunction(p+e.yxy) - renderFunction(p-e.yxy),\n       renderFunction(p+e.yyx)- renderFunction(p-e.yyx));\n   return normalize(nor);  \n\n}\n//----------------------------------------------------------------------\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec4 color = vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  vec3 lightPos1 = normalize(lightDir);  \n  normal = normalize(getNormal(hitPos));  \n  float diffuse = max(0.0, dot(normal, -lightPos1)) * 0.5 + 0.5;\n \n  float specular = 0.0;   \n      if (dot(normal, -lightPos1) < 0.0) \n         specular = 0.0;\n     else \n         specular = pow(max(0.0, dot(reflect(-lightPos1, normal), normalize(ro - hitPos))), 5.0);\n\n//----------------------------------\n   if (materialMy.typeMat == 0.0) \n  {\n     color =  texture(iChannel0, rd);\n     diffuse = 1.0;\n   } \n   else if (materialMy.typeMat == 1.0) \n   {\n \n   color = vec4(1.74, 0.87, 0., 1.);\n   vec3 col = vec3(1.);\n   vec3 newRd = reflect(rd, normal);\n   vec3 mirror = texture(iChannel0, newRd).rgb * 0.5;\n   col = mirror  + pow(0.48, 2.2);\n   color.rgb *= col * diffuse + specular; \n   } \n    ro = hitPos;\n  return color ;\n}\n\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\nbool glowed = false;\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n    float d = renderFunction(posOnRay + t*rayDir); \n    if (d < 0.01 || d > 10.) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;                  \n    float t = time* 0.1;\n    vec3 camP = vec3(0., 4., 35.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(camDir + pos.x * u + pos.y * v);  \n  vec4 color    = vec4(1.0);\n  vec3 normal   = vec3(1.0);\n\n//------------------------------\n   \n  vec3 posOnRay = camP; \n  float path = 0.;\n  //--------------------------- \n     path =  render(posOnRay, rayDir);  \n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     fragColor =  color;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtX3zl","date":"1424238623","viewed":162,"name":"broken heart","username":"Lio","description":"experimenting with forms","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distortion","reflect"],"hasliked":0,"parentid":"","parentname":""}}