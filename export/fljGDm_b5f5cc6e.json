{"ver":"0.1","info":{"id":"fljGDm","date":"1624341865","viewed":687,"name":"2d voxel raymarching w/ LODs","username":"asherville","description":"Playing around with voxel raymarching and LODs\nHold space to draw walls and shift to erase them\nCan zoom in/out in Common \nlooks better in fullscreen\nCubemap related functions from https://www.shadertoy.com/view/fdSXRc, including the T0() and T() macros","likes":25,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","mouse","voxel","lod","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void sampleCubemap(vec2 p, out float size, out bool inShape){\n    vec4 t = cubeFetch0(p);\n    inShape = t.x>0.5;\n    size = t.g;\n}\n\n\nbool inBounds(vec2 p){\n\n    return all(greaterThan(p,vec2(0.0)))&&all(lessThan(p,vec2(1024.0)));\n}\n\n//incorrect sdf but it works\nfloat sdGrid(in vec2 coords, in float gridSize, in float gridWidth){\n\n    vec2 grid = abs(mod(coords,gridSize)-gridSize*0.5);\n    \n    return min(grid.x,grid.y)-gridWidth;\n}\n\n\n// too tired to figure out perfect antialiasing\n// just multiplied random things together until it looked ok\nvoid drawSDF(inout vec3 col, vec3 pcol, float d, float r){\n\n    float psize = 1.0/iResolution.y;\n\n    d = ((d-r/zoom*psize*1024.0)*zoom);\n\n    col = mix(pcol,col,smoothstep(-psize,psize,d));\n}\n\n//fixed an issue where the raymarching would break if the ray was pointing straight down\nfloat sign11(float x){\n\n    return x < 0.0 ? -1.0 : 1.0;\n}\n\n\n//slow and poorly optimized\n\n//not fully tested, may give incorrect results in edge cases\n\nvec2 trace(vec2 ro, vec2 rd, vec2 coord, inout vec3 points){\n\n    vec2 p = ro;\n    vec2 s = vec2(sign11(rd.x),sign11(rd.y));\n    vec2 s01 = max(s,0.0);\n    vec2 ird = 1.0/rd;\n    float voxelSize;\n    vec2 tMax;\n    float lod;\n    bool inside;\n    \n    for(int i = 0; i < steps; i++){\n        \n        //sample the size of the largest empty LOD and a boolean for if we are inside a solid voxel\n        sampleCubemap(p,voxelSize,inside);  \n\n        //hit something / went out of bounds, return current position\n        if(inside){return p;}\n        if(!inBounds(p)){return p;}\n\n        //intersect the xy lines\n        tMax = ird*(voxelSize*s01-mod(p,voxelSize));\n\n        //step by the shorter distance\n        p+=rd*min(tMax.x,tMax.y);\n\n        //draw points \n        drawSDF(points,vec3(1.0),distance(coord,p),2.0);\n        \n        //which line is intersected\n        vec2 mask = step(tMax.xy,tMax.yx);\n\n        //normal\n        vec2 n = s * mask;\n        \n        //move off of line into next voxel\n        p += n*0.0001;\n    }\n\n    //return the current position\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = viewportToCube(fragCoord);\n    vec2 m = viewportToCube(iMouse.xy);\n\n    //coord is outside of the cubemap face, return black\n    if(!inBounds(p)){ fragColor = vec4(0); return; }\n    \n    bool inside;\n    \n    //the size of the current voxel\n    float lodSize;\n    \n    //sample the size of the voxel and a boolean for if the pixel is inside a solid voxel\n    sampleCubemap(p,lodSize,inside);\n    \n    //get the lod level of the current voxel from its size\n    float lod = log2(lodSize);\n    \n    //color based on largest empty LOD\n    vec3 col = vec3(lod+2.0)/float(lods);\n    \n    //color the solid voxels cyan\n    if(inside){col = vec3(0.0,0.6,0.6);}\n\n    //ray origin\n    vec2 pos = rayOrigin;\n    \n    //ray direction\n    vec2 d = normalize(m-pos);\n\n\n    #ifdef showGrid\n        \n        //distance from p to grid with size of lodSize\n        float grid = sdGrid(p+lodSize*0.5,lodSize,0.0);\n        \n        //dont draw the grid over solid voxels\n        if(!inside)drawSDF(col,vec3(0.0,0.0,0.0),grid,0.5);\n    #endif\n    \n    //initialize a vec3 for the trace function to draw points to\n    vec3 points = vec3(0.0);\n    \n    //distance to a line segment from the ray origin to the mouse\n    float s2 = sdSegment(p,pos,trace(pos,d,p,points));\n    \n    \n    //draw the line segment in red\n    drawSDF(col,vec3(1.0,0.0,0.0),s2,1.0);\n    \n    //add the points to the color\n    col += points;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 p, in vec3 rayOri, in vec3 rayDir )\n{\n\n    //discard sides of the cubemap that we are not using\n    int side = cubeFaceIndex(rayDir);\n    if(side != 0)discard;\n    \n    //last frame\n    vec4 last = cubeFetch0(p);\n    \n    //mouse position on cubemap\n    vec2 m = viewportToCube(iMouse.xy);\n    \n    bool mouseCircle = (1.0-step(15.0/zoom,distance(m,p)))>0.5;\n    \n    bool space = texelFetch(iChannel2,ivec2(32, 0), 0).x > 0.0;\n    bool shift = texelFetch(iChannel2,ivec2(16, 0), 0).x > 0.0;\n\n    bool mask = mouseCircle && space;\n\n    //clear space around ray origin\n    if(distance(p,rayOrigin)<50.0/zoom)mask = false; \n\n    mask = mask || (last.r>0.5);\n    \n    //erase\n    if(shift&&mouseCircle){mask = false;}\n    \n    //hacky attempt to identify the first loaded frame\n    //this was just the first attempt to work, i will look for a better method later\n    bool firstFrame = (last.z < 0.5) && (iChannelResolution[0].x > 1023.0);\n    \n    //if on the first frame, generate some initial walls\n    if(firstFrame){\n        mask = texture(iChannel3,p/1024.0).g+distance(p,rayOrigin)*0.0005<0.1;\n        fragColor = vec4(mask,lods,1.0,1.0); return;\n    }\n    \n    int largestEmptyLOD = lods;\n    \n    //find the largest empty LOD (one frame behind)\n    for(int i = 0; i <= lods; i++){\n    \n        if(cubeFetch0Lod(p, i).r>0.0){largestEmptyLOD = max(i-1,0); break;}\n    }\n    \n    //the size of the largest empty LOD\n    float size = exp2(float(largestEmptyLOD));\n    \n    \n    // Output to cubemap\n    fragColor = vec4(mask,size,last.z,1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"//settings\n\n    //world space ray origin based on zoom level\n    #define rayOrigin vec2(512,float(800-512)/zoom+512.0)\n    \n    //max number of raymarching steps\n    #define steps 50\n\n    //zoom, 1.0 is fully zoomed out\n    #define zoom 10.0\n\n    //comment out to hide the grid\n    #define showGrid\n\n    //number of lods\n    #define lods 10\n\n\n//based on / from https://www.shadertoy.com/view/fdSXRc\n#define cubeRes 1024.0\n   //like texelFetch()\n#define cubeFetch0(p) texture(iChannel0,cubeRd0((floor(p)+0.5)/cubeRes))\n\n#define cubeFetch0Lod(p,l) textureLod(iChannel0,cubeRd0((floor( (p)/float(1<<l) ) * float(1<<l) +.5 * float(1<<l))/1024.0),float(l))\n\n\nvec3 cubeRd0(vec2 uv)\n{\n    // convert range 0 to 1 to -1 to 1\n    vec2 c = 2.0 * uv.yx - 1.0f;\n    return vec3(1.0f, -c);\n}\n//from https://en.wikipedia.org/wiki/Cube_mapping\nint cubeFaceIndex(vec3 rd)\n    {\n    vec3 ard = abs(rd);\n    bvec3 mask = greaterThan(rd,vec3(0.0));\n\n    float maxAxis, uc, vc;\n\n    // POSITIVE X\n    if (mask.x && ard.x >= ard.y && ard.x >= ard.z) {\n\n    return 0;\n    }\n    \n    // NEGATIVE X\n    if (!mask.x && ard.x >= ard.y && ard.x >= ard.z) {\n\n    return 1;\n    }\n    \n    // POSITIVE Y\n    if (mask.y && ard.y >= ard.x && ard.y >= ard.z) {\n\n    return 2;\n    }\n    \n    // NEGATIVE Y\n    if (!mask.y && ard.y >= ard.x && ard.y >= ard.z) {\n\n    return 3;\n    }\n    \n      // POSITIVE Z\n    if (mask.z && ard.z >= ard.x && ard.z >= ard.y) {\n\n    return 4;\n    }\n    \n    // NEGATIVE Z\n    else {\n\n    return 5;\n    }\n\n}\n\n//other defines\n    \n    #define vRes iChannelResolution[1].xy\n    #define viewportToCube(pos) (((pos-.5*vRes)/vRes.y)/zoom*1024.0+512.0)\n\n\n//from iq\n\n    float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n    {\n        vec2 pa = p-a, ba = b-a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h );\n    }","name":"Common","description":"","type":"common"}]}