{"ver":"0.1","info":{"id":"NsBSzG","date":"1620426306","viewed":321,"name":"jumpflood  EquiAngular","username":"Carandiru","description":"applying the jfa algorithm for lighting (emission only no occulders)\n\nfixed. use  |<  to reset.","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["2d","lighting","jfa"],"hasliked":0,"parentid":"7dBXDw","parentname":"jumpflood monte carlo take 2"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// jumpflood lights​ (research) EquiAngular\n// http://bit.ly/supersinfulsilicon\n\n// EquiAngular sampling reduces the whole thing to a gradient between\n// the 2 most dominant colors. doh!\n\n// jumpflood lights by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NsBSzG\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// really nice article referenced by samuelbigos :\n// @ https://samuelbigos.github.io/posts/2dgi1-2d-global-illumination-in-godot.html\n\n// jumpflood shader template taken from:\n// https://www.shadertoy.com/view/MstBWX\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = textureLod(iChannel0,fragCoord/iResolution.xy,0.0);\n    fragColor = vec4(data.xyz, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n\n//--------------------------------------------------\n\nvec4 JFAStep(vec2 fragCoord, int level)\n{\n    // current data in texture on fragCoord position\n    vec4 ret = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    // big number so any real distance will be smaller than that\n    float curDist = 999999999.;\n    \n    // that means the current data contains info of a nearby seed\n    if( ret != vec4(0.) )\n    {\n        vec2 seedCoord;\n\t\tvec3 seedColor;\n        \n        DecodeData(ret, seedCoord, seedColor);\n        \n        curDist = distance(fragCoord, seedCoord);\n    }\n    \n    vec2 offset = vec2(exp2(max(0., float(JFA_MAX_STEPS - level) ) ) );\n    \n    for(int x = -1; x <= 1; x++)\n    {\n    \tfor(int y = -1; y <= 1; y++)\n        {\n\t\t\tvec4 read = texture(iChannel0, (fragCoord + vec2(x,y)*offset)/iChannelResolution[0].xy );\n            if( read != vec4(0.) )\n            {\n                vec2 coord;\n                vec3 color;\n                \n                DecodeData(read, coord, color);\n                \n                float dist = distance(coord, fragCoord);\n                \n                if( dist < curDist)\n                {\n                    ret = read;\n                }\n            }\n        }\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    // Create seeds\n    if(iFrame == 0)\n    {\n\t\tif(Rand(fragCoord) > (1.- SEED_CHANCE))\n        {\n            fragColor = EncodeData(fragCoord, RandColor(fragCoord));\n        }\n        else\n        {\n            fragColor = vec4(0.);\n        }\n        \n    }\n    else\n    {\n        //if(mod( float(iFrame), FRAME_DELAY) == 0.)\n        {\n        \tfragColor = JFAStep(fragCoord, iFrame );\n            \n        }\n        //else\n        {\n          //  fragColor = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n        }\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// jumpflood shader template taken from:\n// https://www.shadertoy.com/view/MstBWX\n\n#define MARCH_STEPS 10   // SEEMS LESS IS BETTER ???\n\n#define SEED_CHANCE .00009\n#define JFA_MAX_STEPS 10\n#define FRAME_DELAY 1.0\n\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// copied the random functions...\n//============================================================\n// returns 0..1\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\n//============================================================\nvec3 RandColor (vec2 co)\n{\n    return vec3\n    (\n        Rand(co),\n        Rand(co*2.143),\n        Rand(co*3.163)\n\t);\n}\n\n// Putting coordinate encoded in the color\nvec4 EncodeData(vec2 coord, vec3 color)\n{\n\tvec4 ret = vec4(0.);\n\tret.xy = coord;\n    ret.z = floor(color.x * 255.)*256. + floor(color.y * 255.);\n    ret.w = floor(color.z * 255.);\n\treturn ret;\n}\n\n// Getting the coordinate out of the color\nvoid DecodeData(in vec4 data, out vec2 coord, out vec3 color )\n{\n\tcoord = data.xy;\n    color.x = floor(data.z/256.)/255.;\n    color.y = mod(data.z,256.)/255.;\n    color.z = mod(data.w,256.)/255.;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// jumpflood lights​ (research)\n// http://bit.ly/supersinfulsilicon\n\n// jumpflood lights by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NsBSzG\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// jumpflood shader template taken from:\n// https://www.shadertoy.com/view/MstBWX\n\nvec2 random(vec2 uv) \n{\n   return textureLod(iChannel1, (uv * iResolution.xy) / 1024.0f, 0.0f).rg;\n}\n\nfloat sample_distance_color(in vec2 uv, out vec3 seedColor) {\n\n    vec2 seedCoord;\n\n    vec4 read = textureLod(iChannel0, uv, 0.0f);\n    \n    DecodeData(read, seedCoord, seedColor);\n    \n    return(distance(uv, seedCoord/iResolution.xy));\n}\n\n//*****************************************************************************\n//modification by Carandiru for single sample optimization + no tan or atan usage\n// https://www.shadertoy.com/view/3sVfWy\nvoid sampleEquiAngularSingle(\n\tin vec2 ro,\n    in vec2 rd,\n\tin float Xi,\n\tin vec2 lightPos,\n\tout float dist_to_sample,\n\tout float pdf)\n{\n\tvec2 ld = lightPos - ro;\n    \n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(ld, rd);\n\n    float thetaA = -dot(normalize(ld), rd);\n    vec2 hd = (ro + delta*rd) - lightPos;\n    float thetaB = dot(normalize(hd), rd);\n\t\n    // get distance this point is from light\n\tfloat D = length(hd);\n    \n\t// take sample\n\tfloat t = D*(mix(thetaA, thetaB, Xi));\n\tdist_to_sample = delta/t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\nvec4 map( in vec2 p )\n{\n    vec4 sampling;\n    \n    sampling.a = sample_distance_color(p, sampling.rgb);\n    \n    return sampling;\n}\n\nvec2 randomInCircle( in vec2 p )\n{\n    return normalize(random(p) * 2.0f - 1.0f);\n}\n    \n// WoS\nvec3 march( in vec2 ro )\n{\n    vec3 color;\n    vec2 p = ro;\n        \n\tfor( int i=0; i<MARCH_STEPS; ++i )\n    {\n        float dist_to_sample, pdf;\n        \n        float Xi = (1.0/float(MARCH_STEPS))*(float(i));\n        \n        vec2 lightPos = textureLod(iChannel0, p, 0.0f).xy;\n        vec2 rd = -randomInCircle((p + float(iFrame)));\n        \n        sampleEquiAngularSingle(p, rd, Xi, lightPos, dist_to_sample, pdf);\n        \n        vec4 h = map(ro + rd * 0.01f * (dist_to_sample + (pdf * FOUR_PI * float(MARCH_STEPS))));\n        //if( h.a<0.001 ) break;\n        \n        color += h.rgb;\n        p = p + h.a*rd;\n    }\n    \n    return color / float(MARCH_STEPS);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec3 col = march(p);\n        \n    // montecarlo\n    vec4 data = textureLod(iChannel2,p,0.0);\n    fragColor = vec4(mix(col, data.rgb, 0.9f),1.0);    \n}","name":"Buffer B","description":"","type":"buffer"}]}