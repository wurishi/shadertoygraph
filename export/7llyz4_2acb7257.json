{"ver":"0.1","info":{"id":"7llyz4","date":"1647594176","viewed":84,"name":"wheeeeee","username":"JuanDeager","description":"spiral","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 200u\n\n#define PI (3.141592653)\n#define TWO_PI (2.0 * PI)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // rotate the UV for the lolz\n    float t = iTime * .25;\n    mat2 rot = mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n    uv = (rot * (uv - 0.5)) + 0.5;\n\n    // accumulate color based on proximity to samples\n    vec3 color = vec3(0, 0, 0);\n    for (uint i = 0u; i < SAMPLES; i++)\n    {\n        // normalized in [0, 1] for the sake of convenience\n        vec2 xi;\n        xi.x = float(i) / float(SAMPLES);\n        xi.y = float(i) / float(SAMPLES) * PI;\n        xi.y = log(xi.y);\n        \n        // convert to polar\n        float r = xi.x * 0.5;\n        float theta = xi.y * TWO_PI;\n        \n        // snap back to cartesian\n        vec2 point = vec2(0.5) + vec2(r * cos(theta), r * sin(theta));\n        color += 1.0 - smoothstep(0.0, .005, distance(uv, point));\n    }\n    \n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}