{"ver":"0.1","info":{"id":"lcGSzy","date":"1719257235","viewed":26,"name":"SH3 Ambient Lighting","username":"Tech_","description":"bsdfs are cool","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bsdf"],"hasliked":0,"parentid":"l3f3zH","parentname":"Chandrasekhar Interfaced BRDF"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int COEFFICIENT_SAMPLES = 1000;\nconst int SH_COUNT = 9;\n\nvec3 EvaluateSH3(vec3 dir)\n{    \n    // Generating SH Coefficients\n    vec3[SH_COUNT] _SH;\n    \n    for (int i = 0; i < COEFFICIENT_SAMPLES; i++)\n    {\n        vec3 rD = UniformSphereSample(fract(Hash22(vec2(i) * PHI)));\n    \n        float coefficients[] = float[](\n             0.282095,\n             0.488603 * rD[1],\n             0.488603 * rD[2],\n             0.488603 * rD[0],\n             1.092548 * rD[0] * rD[1],\n            -1.092548 * rD[1] * rD[2],\n             0.315392 * (3.0 * rD[2] * rD[2] - 1.0),\n            -1.092548 * rD[0] * rD[2],\n             0.546274 * (rD[0] * rD[0] - rD[1] * rD[1])\n        );\n        \n        vec3 Li = texture(iChannel0, rD).rgb;\n        \n        for (int i = 0; i < SH_COUNT; i++)\n        {\n            _SH[i] += Li * coefficients[i] * 4.0 * PI / float(COEFFICIENT_SAMPLES);\n        }\n    }\n\n    // Evaluating SH3\n    vec3 x  = _SH[0] *  0.282095;\n         x += _SH[1] *  0.488603 * dir[1];\n         x += _SH[2] *  0.488603 * dir[2];\n         x += _SH[3] *  0.488603 * dir[0];\n         x += _SH[4] *  1.092548 * dir[0] * dir[1];\n         x += _SH[5] * -1.092548 * dir[1] * dir[2];\n         x += _SH[6] *  0.315392 * (3.0 * dir[2] * dir[2] - 1.0);\n         x += _SH[7] * -1.092548 * dir[0] * dir[2];\n         x += _SH[8] *  0.546274 * (dir[0] * dir[0] - dir[1] * dir[1]);\n         \n    return max0(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    \n    vec2 gridRes = vec2(1.0, 1.0);\n    float gridAr = gridRes.y / gridRes.x;\n    vec2 grid = fract(coord * gridRes);\n    vec2 gridID = floor(coord * gridRes);\n    vec2 gridCoord = (grid - 0.5) / min(vec2(ar / gridAr, gridAr / ar), 1.0);\n    gridCoord = gridCoord * 2.0;\n\n    vec3 rayDir    = vec3(0.0, 0.0, -1.0);\n    vec3 rayOrigin = vec3(2.0 * gridCoord, 10.0);\n    \n    float lightAngle = PI * 0.65 + iTime * 0.3;\n    vec3  lightPos   = vec3(-cos(lightAngle), 0.8, sin(lightAngle)) * 10.0;\n    \n    vec3  center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.6;\n    \n    float intersection = IntersectSphere(rayOrigin - center, rayDir, radius);\n    \n    if (intersection > 0.0)\n    {\n        vec3 hitPos   = rayOrigin + intersection * rayDir;\n        vec3 normal   = normalize(hitPos - center);\n        vec3 lightDir = normalize(lightPos + center - hitPos);\n        \n        vec3 scattering = EvaluateSH3(normal);\n        \n        fragColor = vec4(LinearTosRGB(scattering * INV_PI * 0.5), 0.0);\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float EPS = 1e-6;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / (x))\n#define max0(x) max(x, 0.0)\n#define maxEPS(x) max(x, EPS)\n\nfloat pow2(float x) { return x * x; }\nvec2  pow2(vec2  x) { return x * x; }\nvec3  pow2(vec3  x) { return x * x; }\n\nfloat pow3(float x) { return x * x * x; }\nvec2  pow3(vec2  x) { return x * x * x; }\nvec3  pow3(vec3  x) { return x * x * x; }\n\nfloat pow4(float x) { return pow2(pow2(x)); }\nvec2  pow4(vec2  x) { return pow2(pow2(x)); }\nvec3  pow4(vec3  x) { return pow2(pow2(x)); }\n\nfloat pow5(float x) { return pow3(x) * pow2(x); }\nvec2  pow5(vec2  x) { return pow3(x) * pow2(x); }\nvec3  pow5(vec3  x) { return pow3(x) * pow2(x); }\n\nfloat avg(vec3 x) { return rcp(3.0) * (x.x + x.y + x.z); }\n\nconst float PI = radians(180.0);\nconst float TAU = 2.0 * PI;\nconst float INV_PI = rcp(PI);\nconst float PHI = (1.0 + sqrt(5.0)) / 2.0;\n\nstruct ComplexVec3\n{\n    vec3 r;\n    vec3 i;\n};\n\n// https://en.wikipedia.org/wiki/Refractive_index (0C, 1atm)\nComplexVec3 airIOR = ComplexVec3(vec3(1.000293), vec3(0.0));\n\nstruct MaterialData \n{\n    vec3 albedo;\n    float roughness;\n    bool isMetal;\n    vec3 f0;\n    float porosity;\n    float subsurface;\n    float ao;\n    float emissive;\n    float opacity;\n    ComplexVec3 ior;\n};\n\nstruct CoatingLayer\n{\n    vec3 f0;\n    ComplexVec3 ior;\n    float roughness;\n    vec3 sigmaS;     // Scattering coefficient\n    vec3 sigmaT;     // Absorption coefficient\n    vec3 rho;        // Scattering albedo\n    float thickness; // [m]\n};\n\nMaterialData MaterialFromCoat(CoatingLayer coat)\n{\n    return MaterialData(\n        vec3(1.0),\n        coat.roughness,\n        false,\n        coat.f0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        coat.ior\n    );\n}\n\n// Complex Math\nComplexVec3 ComplexAdd(ComplexVec3 a, ComplexVec3 b)\n{\n    ComplexVec3 c;\n    c.r = a.r + b.r;\n    c.i = a.i + b.i;\n    return c;\n}\n\nComplexVec3 ComplexAdd(ComplexVec3 a, float b)\n{\n    return ComplexVec3(a.r + b, a.i);\n}\n\nComplexVec3 ComplexSub(ComplexVec3 a, float b)\n{\n    return ComplexVec3(a.r - b, a.i);\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r * b.r - a.i * b.i;\n    c.i = a.i * b.r + a.r * b.i;\n    return c;\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, float b) \n{\n    return ComplexVec3(a.r * b, a.i * b);\n}\n\nComplexVec3 ComplexDiv(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    vec3 denom = b.r * b.r + b.i * b.i;\n    c.r = (a.r * b.r + a.i * b.i) / denom;\n    c.i = (a.i * b.r - a.r * b.i) / denom;\n    return c;\n}\n\nComplexVec3 ComplexSub(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r - b.r;\n    c.i = a.i - b.i;\n    return c;\n}\n\nComplexVec3 ComplexSub(float a, ComplexVec3 b) \n{\n    return ComplexVec3(a - b.r, b.i);\n}\n\nvec3 ComplexAbs(ComplexVec3 num) \n{\n    return sqrt(num.r * num.r + num.i * num.i);\n}\n\nComplexVec3 ComplexSqrt(ComplexVec3 num) \n{\n    ComplexVec3 c;\n    vec3 absNum = ComplexAbs(num);\n    c.r =               sqrt(max(absNum + num.r, 0.0) * 0.5);\n    c.i = sign(num.i) * sqrt(max(absNum - num.r, 0.0) * 0.5);\n    return c;\n}\n\nComplexVec3 ComplexPow2(ComplexVec3 num)\n{\n    ComplexVec3 c;\n    c.r = num.r * num.r - num.i * num.i;\n    c.i = 2.0 * num.r * num.i;\n    return c;\n}\n\nfloat IORToF0(float ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nvec3 IORToF0(vec3 ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nfloat F0ToIOR(float f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\nvec3 F0ToIOR(vec3 f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\n/*\n    From https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n*/\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = saturate(color);\n\n    return color;\n}\n\nvec3 EvaluateLSICurve(vec3 x, float l, float s, float i)\n{\n    vec3 a = pow(x / l, vec3(2.0 * rcp(s)));\n    return i * pow(a / (a + 1.0), vec3(0.5 * s)) + (1.0 - i);\n}\n\n#define tonemapConfiguration TONEMAP_CINEMATIC\nvec3 TonemapPrism(vec3 color)\n{\n    /*\n        Custom parameterized tone.\n        Can yield a variety of different desired looks.\n\n        ~ Tech\n    */\n\n    const mat2x3 TONEMAP_CINEMATIC = mat2x3(\n        0.25085, 1.37, 0.95,\n        0.31357, 1.62, 1.00\n    );\n\n    const mat2x3 TONEMAP_NEUTRAL = mat2x3(\n        0.325, 1.0, 0.3,\n        0.813, 1.0, 1.0\n    );\n\n    vec3 toe       = EvaluateLSICurve(color, tonemapConfiguration[0][0], tonemapConfiguration[0][1], tonemapConfiguration[0][2]);\n    vec3 shoulder  = EvaluateLSICurve(color, tonemapConfiguration[1][0], tonemapConfiguration[1][1], tonemapConfiguration[1][2]);\n\n    return toe * shoulder;\n}\n\n/* https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code */\nfloat IntersectSphere(vec3 rayPos, vec3 rayDir, float radius)\n{\n    float b = dot(rayPos, rayDir);\n    float c = dot(rayPos, rayPos) - radius * radius;\n\n    if (c > 0.0 && b > 0.0) return -1.0;\n\n    float d = b * b - c;\n\n    if (d < 0.0)    return -1.0;\n    if (d > b * b)  return -b + sqrt(d);\n\n    return -b - sqrt(d);\n}\n\n/* https://www.shadertoy.com/view/4djSRW */\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 UniformSphereSample(vec2 hash) \n{\n    hash = vec2(hash.x * TAU, hash.y * 2.0 - 1.0);\n    return vec3(vec2(sin(hash.x), cos(hash.x)) * sqrt(1.0 - pow2(hash.y)), hash.y);\n}\n\nvec3 UniformHemisphereSample(vec3 vector, vec2 hash) \n{\n    vec3 dir = UniformSphereSample(hash);\n    return dot(dir, vector) < 0.0 ? -dir : dir;\n}\n\nvec3 LinearTosRGB(vec3 x)\n{\n\tvec3 sRGBLo = x * 12.92;\n\tvec3 sRGBHi = pow(abs(x), vec3(1.0 / 2.4)) * 1.055 - 0.055;\n\treturn mix(sRGBHi, sRGBLo, step(x, vec3(0.0031308)));\n}\n\nvec3 SRGBToLinear(vec3 x)\n{\n    vec3 linearLo = x / 12.92;\n    vec3 linearHi = pow((x + 0.055) / 1.055, vec3(2.4));\n    return mix(linearHi, linearLo, step(x, vec3(0.04045)));\n}","name":"Common","description":"","type":"common"}]}