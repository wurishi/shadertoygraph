{"ver":"0.1","info":{"id":"7sKBzz","date":"1657600005","viewed":3206,"name":"Relativistic Space Drive","username":"Amirk","description":"Boost the rocket and see how things should appear according to special relativity. Look around with mouse. Recently I explored relativity in a Youtube video with this shader: https://www.youtube.com/watch?v=Ix1XlxF66Zk","likes":28,"published":1,"flags":48,"usePreview":1,"tags":["relativity","lorentz","eventhorizon","acceleration","retardation","hyperbolicmotion","rinddler"],"hasliked":0,"parentid":"fdcfD8","parentname":"Rinddler Horizon"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Relativistic Space Drive\" by Amirk. https://shadertoy.com/view/7sKBzz\n// 2023-09-26 03:58:36\n\n/*\nNotice that, if you boost forward with constant proper acceleration\nthe objects in front actually seem to recede further away at first, \nbefore halting and then coming towards extremely rapidly.\nThe apparent speed may look faster than light but that is an\n\"optical effect\" due to retardation.\n\nThe biggest challenge, compared to classical dynamics\n(galilean transformations), was that, it is not enough to know\nour/rocket's position and velocity after certain boosts. \nLorentz transforms do not commute so we have to keep track of \nthe cumulative total transformation from all the boosts we have \nmade along the way. \nThis is done in Buffer A.\n*/\n\n\n//comment this if you do not want the delayed view.\n#define RETARD 1.\n\n#define MAX_ITER 1500.\n#define MAX_DIST 70.\n#define SURF .0001\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\nvec3 SIZE= vec3(.1); \n\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\n\nfloat halo=0.;\nfloat cylinder;   \nfloat cylinder2; \nfloat cylinder3;\nfloat cylinder4;\n\n\n\nvec3 color( float s){\n    return vec3(1) - vec3(1.,1.,0)*smoothstep(.0,1., s)-\n            vec3(0.,.6,.6)*smoothstep(0.,1., -s);\n}\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel0, ivec2(1,0), 0 );\n    vec4 cam=vec4(-1,0,0,0);\n    if(m!=vec2(0)){\n        cam.xy*=rot((m.y-.5)*PI);\n        cam.xz*=rot(-(m.x-.5)*2.*PI);    \n    }\n    //position+=TransformMatrix*cam;\n}\n\n\nfloat sdBox(vec4 p , vec3 s){\n    float time=p.w;\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes\n    p.yz*=rot(p.w*.5);\n    p.xyz= abs(p.xyz)-s;\n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.05,.05));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner);\n}\n\n\nfloat getDist(vec4 q){\n    float dist= sdBox(q,SIZE);\n    \n    //the cylinders:\n    float len= 3.;\n    float d= 4.;\n    float s=.5;\n    q.x-=d;\n    cylinder= sdCylinder(q.zxy, vec2(s,len*s));\n    q.x+=2.*d;\n    cylinder2= sdCylinder(q.zxy, vec2(s,len*s));\n    q.x-=d;\n    q.z-=d;\n    cylinder3= sdCylinder(q.xzy, vec2(s,len*s));\n    q.z+=2.*d;\n    cylinder4= sdCylinder(q.xzy, vec2(s,len*s));\n    \n    dist = min(dist,cylinder);\n    dist = min(dist,cylinder2);\n    dist = min(dist,cylinder3);\n    dist = min(dist,cylinder4);\n    \n    return dist;\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n        \n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nvoid getMaterial(vec4 p){\n    if(cylinder<5.*SURF){\n        p.yz*=rot(p.w*.5);\n        col=vec3(2,0,.2)*sin(atan(p.y,p.z)*10.)*sin(atan(p.y,p.z)*10.);\n        }\n    else if(cylinder2<5.*SURF){\n         p.yz*=rot(p.w*.5);\n        col=vec3(.2,1,0)*sin(atan(p.y,p.z)*10.)*sin(atan(p.y,p.z)*10.);\n    }else if(cylinder3<5.*SURF){\n        p.xy*=rot(p.w*.5);\n        col=vec3(1,0,1)*sin(atan(p.y,p.x)*10.)*sin(atan(p.y,p.x)*10.);;\n    }else if (cylinder4<5.*SURF){\n        p.xy*=rot(p.w*.5);\n        col=vec3(0,.2,1)*sin(atan(p.y,p.x)*10.)*sin(atan(p.y,p.x)*10.);;\n    }// else col= vec3(1);\n}\n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n           for(int j=1; j<=4; j++)\n              M[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n    }\n    return M;\n}\n\n\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\n\n\nfloat dfRocketBody(vec3 p)\n{\n        \n    vec3 p2 = p;\n   \n    angularRepeat(PI*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, (rot(PI*-.125)*( p2.xz+vec2(-.7,0))).y);\n    d = max(d, (rot(PI*-.25*.75)*(p2.xz+vec2(-0.95,0))).y);\n    d = max(d, (rot(PI*-.125*.5)*( p2.xz+vec2(-0.4,0))).y);\n    d = max(d, (rot(PI*.125*.25)*( p2.xz+vec2(+0.2,0))).y);\n    d = max(d, (rot(PI*.125*.8)*( p2.xz+vec2(.5,0))).y);\n    \n    d = max(d,-.8-p.x);\n    \n    d -= .5;\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    \n    p.yz*=rot(position.w*(1.+10.*boost.w));\n    vec3 pFins = p;\n    angularRepeat(PI*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.5,.0,.0);\n    pFins.xz*=rot(-PI*.25);\n    float scale = 1.0-pFins.z*.6;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat Jet(vec3 p)\n{\n    float d= length(p.yz);\n    if(p.x>0.2)d=20.;\n    \n    return d-p.x*.05;\n}\n\nfloat df(vec3 p)\n{           \n    if(boost.xz!=vec2(0)){\n        p.xz*=rot(-atan(orientation.z,orientation.x));\n        }\n     \n    \n        \n    float proxy = mBox(p,vec3(4.5,.8,.8));\n    if (proxy>1.)\n    \treturn proxy;\n    float dRocketBody=   dfRocketBody(p);\n    float dRocketFins=   dfRocketFins(p);\n    float dJet=  Jet(p);\n    if(boost.w==1.&&dJet<dRocketFins*5.&&dJet<.4){\n    halo+=.7;\n    }\n    \n    return min(dRocketBody,dRocketFins);\n}\n\nvec3 nf(vec3 p)\n{\n    \n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvoid rocket (inout vec3 color, in vec3 pos, in vec3 dir) {\n    \n        \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist  = df(pos);\n       \tpos  += dist*dir;\n        tdist+=dist;\n        if (dist<0.00001||dist>7.0)break;\n    }\n    \n    vec3 normal = nf(pos);\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    if(boost.xz!=vec2(0)){\n        pos.xz*=rot(-atan(orientation.z,orientation.x));\n    }    \n    \n    \n        \n    vec3 materialColor = vec3(0);\n    vec3 blueColor = vec3(.1,.4,.9);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n       \n    \n    float r = dot(pos.yz,pos.yz);\n   \n    \n    if (dRocketBody<dRocketFins)\n    {\n    \n        if (pos.x<-.85)\n            if (pos.x<-1.2)\n                materialColor = blueColor + vec3(0.03 / r);\n            else\n                materialColor = vec3(.7,.1,.7);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.7,.1,.7) ;\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.7,.1,.7);\n        if (length (pos - 0.1 * vec3(0.0, normal.yz)) > length (pos)) { \n\n            materialColor -= vec3(.9,.3,1.5) * min(0.2, pos.x + 1.3) / r;\n        }\n    }   \n    \n    if (dist<.1) color =  ao*materialColor;\n}\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 pos = vec2(.0,.9);\n    float FontSize = 6.;\n    vec2 U = ( uv - pos)*64.0/FontSize;\n   C(85);C(115);C(101);C(32);C(109);C(111);C(117);C(115);C(101);C(43);C(97);C(114);C(114);C(111);C(119);C(32);\n   \n   C(107);C(101);C(121);C(115);\n   C(32);C(32);C(32);C(32);\n   float gam = fourvel.w/c;\n   C(115);C(112);C(101);C(101);C(100);C(32)\n   ;C(46);C(48+int(floor(10.*length(fourvel.xyz)/gam))); C(99);\n   return O.xxxx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMatrix=getTransform();\n    updatePos();\n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    RO=position;\n    float zoom= 1.;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    //what we actually see as light reaches our eyes:\n    #ifdef RETARD \n        lookAt = vec4(c, 0, 0, -1);\n    #else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n     #endif\n     \n    if(m!=vec2(0)){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n    \n    //adding the rocket on top\n    vec3 r_color = vec3 (0);\n    vec3 cam=vec3(-7,1.5,0);\n    \n    if(m!=vec2(.5)){\n        cam.xy*=rot((m.y-.5)*PI);\n        cam.xz*=rot(-(m.x-.5)*2.*PI);        \n    }           \n    rocket (r_color, cam, ray.xyz);\n    \n    if (length (r_color) > 0.0) {\n        fragColor.xyz = r_color;\n    }else{ \n    \n    \n    \n    //ray direction from moving coords to stationary coords:\n    rd= TransformMatrix*ray; \n    //some rescaling for accuracy:\n    \n    #ifdef RETARD\n        rd.xyz=normalize(rd.xyz);\n        rd.w=-RETARD;\n    #else\n       rd=normalize(rd); \n    #endif    \n    \n   /* //just some helpfull scaling factors for raymarching:\n    if(RETARD>0.){\n         vv= max(0., -dot(fourvel.xyzw, rd.xyzw));\n    }else{\n         vv= abs(dot(fourvel.xyzw, rd.xyzw));\n    }\n    */\n    \n    \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          \n          col=color(dot(normalize(rd.xyz), fourvel.xyz));\n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=length(d*rd)*.2;\n          col*=dif*dif;            \n      \n    }\n\n    col.xyz+=text(fragColor, fragCoord).xyz;\n\n\n    fragColor = vec4(col,1.0)+halo*halo*vec4(.4,.2,1,1);\n    \n   }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n\n//t is the proper time in rockets moving frame (counted in frames so\n//fps would not affect the physics)\n#define dt iTimeDelta\n\n#define PI 3.14159265359\n\nconst float c=1.;//Not sure if everything works if you change c.\n\nfloat gamma(float b){\n\n    return pow(1.-b*b,-.5);\n}\n\n//for infinitesimal lorentz transforms it is faster to use this generator:\nmat4 LorentzGenerator(vec3 e){\n     float cc=c*c;\n        \n     return mat4(0 ,0  , 0 , -e.x/cc ,\n                0,   0,  0 ,  -e.y/cc ,\n                 0, 0,   0,   -e.z/cc  , \n                 -e.x, -e.y  , -e.z ,0);                            \n}\n\nmat4 Lorentz(vec3 v){\n     float beta= length(v)/c;\n     float gamma = gamma(beta);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\n\n\nvec2 m= vec2(.5);\n\nvec3 handleKeyboard() {     \n    if(iMouse.z!=0.){\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=(left + up + right + down) ;\n   \n    // steer with mouse\n       // acceleration.xy*=rot((m.y-.5)*PI);\n        acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x>7.|| fragCoord.y>7. ) discard;\n    //coordinates of the boost are in rockect coordinates\n    vec3  boost=vec3(0,0,0);\n    vec3 orientation=vec3(1,0,0);\n    \n    boost = handleKeyboard();\n    orientation = texelFetch( iChannel0, ivec2(6, 6), 0).rgb;\n    \n    \n    //orientation is for the rockets alignment\n    orientation +=(boost-orientation)*.01;\n    if(ivec2(fragCoord)==ivec2(6,6))\n             fragColor= vec4(orientation,0);\n             \n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n                                           \n    \n    if(boost==vec3(0)){ //if no keys are pressed we just copy from the previous frame\n        \n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(5, 5), 0).rgb,0);\n        }else if(ivec2(fragCoord)==ivec2(1,0)){\n            fragColor= texelFetch( iChannel0, ivec2(1, 0), 0)\n                        +dt*texelFetch( iChannel0, ivec2(0, 0), 0);\n        }\n        if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 vec4 fourvel = TransformMat*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(1,0)){\n            fragColor= vec4(0);\n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(boost,0);\n            }else if(ivec2(fragCoord)==ivec2(6,6)){\n            fragColor= vec4(orientation,0);\n            }\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n        }\n    }else{\n        boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w; //to scale boost according to speed\n        //next the boost transform\n        mat4 NextBoost= Lorentz(-boost*dt);//mat4(1)+LorentzGenerator(-boost*dt); // \n                        \n        if(iFrame>10){\n                for(int j=1; j<=4; j++){\n                     TransformMat[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n                 }  \n        }\n    \n        //how to transform to stationary coords\n        TransformMat*=NextBoost;\n        vec4 fourvel =TransformMat*vec4(0,0,0,1);\n        \n        if(ivec2(fragCoord)==ivec2(0,0)){\n             fragColor= fourvel;          \n        }else if(ivec2(fragCoord)==ivec2(1,0)){\n             vec4 fourPos=texelFetch( iChannel0, ivec2(1, 0), 0);\n             fourPos+=dt*fourvel;\n             fragColor= fourPos;\n        }\n        else if(ivec2(fragCoord)==ivec2(5,5)){\n             fragColor= vec4(boost,1);\n        }else{\n            //StoreMatrix:\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n       }\n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this buffer keeps track of rockets four-position\n//represented in \"stationary coordinates\"\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // four position represented in stationary coords:\n    vec4 pos = texelFetch( iChannel1, ivec2(0, 0), 0);\n   \n    // fourvel represented in stationary coords:\n    vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n   // float gamma=fourvel.w/c;\n    \n    \n    \n    //four position represented in stationary coordinates:\n    pos += fourvel*dt;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = pos;\n}","name":"Buffer B","description":"","type":"buffer"}]}