{"ver":"0.1","info":{"id":"3tsBD7","date":"1596910677","viewed":119,"name":"Assembly shaderjam 2020","username":"Exca","description":"Shader made during second shaderjam slot of Assembly <3 Demoscene -event.\n\nDoesnt look exactly like in bonzomatic but close enough.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["assembly","shaderjam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Simplex noise & distance functions by iq\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 mmin(vec2 a, vec2 b)\n{\n  return a.x<b.x?a:b;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n  return mix(b,a,h)-k*h*(1.0-h);\n}\n\nvec2 dist(vec3 p, float fftAdvance, vec3 move, float fftBass)\n{\n  float xp = sin(fftAdvance*0.5)*0.2;\n  float yp = sin(fftAdvance*0.75+0.5)*0.1;\n  \n  float h1 = texture( iChannel0, vec2(p.x, p.z)*0.06+vec2(xp,yp)+iTime*0.01).r*(5.+fftAdvance);\n  float h2 = texture( iChannel0, vec2(p.x, p.z)*0.06+vec2(xp,yp)-iTime*0.05).r*(5.+fftAdvance);\n  float h = mix(h1,h2,0.5)*0.5;\n  h*=0.4+fftAdvance*1.5;\n  \n  vec2 ground = vec2(h-p.y, 0.);\n  \n  vec2 sky = vec2( (h+9.)+p.y, 2.);\n  \n  vec3 off1 = vec3(\n    sin(iTime*0.361)*1.5,\n    cos(iTime*0.4621)*0.5+1.,\n    sin(iTime*0.87565)*1.7\n  )*(fftAdvance*7.+0.8);\n  vec3 off2 = vec3(\n    sin(iTime*0.989)*2.0,\n    cos(iTime*0.4564)*0.5+1.,\n    sin(iTime*0.123)*1.7\n  )*(fftAdvance*9.+0.8);\n  vec3 off3 = vec3(\n    sin(iTime*0.86799)*0.5,\n    cos(iTime*0.23156)*0.5+1.,\n    sin(iTime*0.4568749)*1.7\n  )*(fftAdvance*8.+0.8);\n  vec3 off4 = vec3(\n    sin(iTime*0.879)*0.5,\n    cos(iTime*0.546)*0.25+1.,\n    sin(iTime*0.465)*0.7\n  )*(fftAdvance*10.+0.8);\n  \n  float spikeRad = (sin(p.x*10.1+fftBass*7.)+cos(p.y*1.1+fftAdvance*25.))*fftAdvance*5.;\n  \n  float sphere1 = sdSphere(p-move+off1,spikeRad+ 0.25+fftAdvance*6.25+fftBass*0.1);\n  float sphere2 = sdSphere(p-move+off2,spikeRad+ 0.35+fftAdvance*5.25+fftBass*0.1);\n  float sphere3 = sdSphere(p-move+off3,spikeRad+ 0.4+fftAdvance*7.25+fftBass*0.1);\n  float sphere4 = sdSphere(p-move+off4,spikeRad+ 0.25+fftAdvance*2.25+fftBass*0.1);\n  \n  sphere1 = smin(sphere1,sphere2, fftBass*1.2+1.5); \n  sphere1 = smin(sphere1,sphere3, fftBass*1.2+1.5); \n  sphere1 = smin(sphere1,sphere4, fftBass*1.2+1.5); \n  \n  vec2 sphere = vec2( sphere1, 1.);\n  \n  return mmin(sky,mmin(sphere, ground));\n}\n\nfloat light(vec3 p, vec3 rd, float fftAdvance, vec3 move, float fftBass)\n{\n  vec2 eps = vec2(0., 0.001);\n  vec2 d1 = dist(p+eps.yxx,fftAdvance,move, fftBass);\n  vec2 d2 = dist(p-eps.yxx,fftAdvance,move, fftBass);\n  vec2 d3 = dist(p+eps.xyx,fftAdvance,move, fftBass);\n  vec2 d4 = dist(p-eps.xyx,fftAdvance,move, fftBass);\n  vec2 d5 = dist(p+eps.xxy,fftAdvance,move, fftBass);\n  vec2 d6 = dist(p-eps.xxy,fftAdvance,move, fftBass);\n  \n  vec3 n = normalize(  vec3( d1.x- d2.x ,d3.x-d4.x, d5.x-d6.x));\n  \n  return max(0., dot(-rd,n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  vec2 noAspectUv = uv;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  \n  //uv = vec2(gid.x / density , gid.y / density );\n  \n  vec3 camera = vec3(0, -2.5, -6) + vec3(\n    sin(iTime*0.1)*5.,\n    (sin(iTime*0.256)*1.8),\n    sin(iTime*0.11)*4.\n  );\n  \n  camera = normalize(camera)*7.;\n  vec3 target = vec3(0.);\n  vec3 forward = normalize( target - camera);\n  float fov = .5;\n  \n  float tmod = mod(iTime, 10.);\n  if(tmod < 10.)\n    fov = 1.;\n  else if(tmod < 20.)\n    fov = 0.15;\n  else if(tmod < 30.)\n    fov = 2.;\n  \n  camera*=(0.35+fov);\n  vec3 move = vec3(0., 0.,iTime)*10.;\n  \n  target += move;\n  camera += move;\n  \n  vec3 up = normalize( cross(forward, vec3(0., 1.,0.)));\n  vec3 right = normalize( cross(forward, up));\n  vec3 raydir = normalize( vec3( uv.x * up + uv.y*right + fov*forward));\n  \n  float t = 0.;\n  vec3 col = vec3(0.);\n  \n  float fftAdvance = texture(iChannel1, vec2(0.1,0.5)).r*0.1;\n  float fftBass = texture(iChannel1, vec2(0.04,0.5)).r*0.05;\n  \n  vec3 light1 = normalize( vec3( 0, 1., 0.3));\n  vec3 light2 = normalize( vec3( 0, -1., 0.3));\n  \n  vec3 lava = vec3(1., 0.4,0.0);\n  vec3 sky = vec3(0.2, 0.5,0.7);\n  \n  vec3 p = vec3(0.);\n  for(int i = 0; i < 100; i++)\n  {\n    p = camera + raydir * t;\n    vec2 d = dist( p,fftAdvance, move,fftBass);\n    if(d.x < 0.001)\n    {\n      if(d.y < 0.5)\n      {\n        float hp = smoothstep(0.1, 0.8, p.y*p.y*p.y); \n        \n        float fft = texture(iChannel1, vec2(mod(p.z*0.2 -2.15 * iTime*0.1+fftAdvance, 0.5),0.5)).r*1.;\n        \n        col = lava*hp*(1.+fft);\n        \n      }\n        \n      else if(d.y < 1.5)\n      {\n        float fft = texture(iChannel1, vec2(mod(p.z*0.02 +fftAdvance, 0.08),0.5)).r*1.;\n        \n        col = \n          vec3(1.,0.5,0.)*light(p, light2,fftAdvance, move,fftBass)+\n          vec3(0.2,0.2, 0.4)*light(p, light1,fftAdvance, move,fftBass);\n          \n        col *= (1.+fft*.50);\n      }\n      \n      else if(d.y < 2.5)\n      {\n        float hp = smoothstep(4.0, 4.45, p.y*p.y*p.y); \n        \n        float fft = texture(iChannel1, vec2(mod(p.z*0.2 -2.15 * iTime*0.1+fftAdvance, 0.5),0.5)).r*0.5;\n        \n        col = sky*hp*(1.0+fft);\n        \n      }\n      break;\n    }\n    if(t > 100.)\n    {\n      break;\n    }\n    t+=d.x;\n  }\n  \n  col = mix(col, mix( lava, sky, -p.y*0.2),t/30.);\n  \n  col *= smoothstep(90., 30., t);\n  \n  \n  float density = 15.;\n  \n  vec2 gid = floor( uv * density);\n  vec2 guv = (fract(uv*density)-vec2(0.5))*2.;\n  \n  float cd = length(guv);//max(abs(guv.x), abs(guv.y));\n  float cs = 1.0;\n  float circ = smoothstep( -0.1, 0.0, cs-cd) -\n              smoothstep(0.15, 0.3, cs-cd)*1.2 +\n              smoothstep(0.3, 0.35, cs-cd)*1.0;\n  \n  \n  \n  \n  col *= (1.-0.03*noise(uv*3.+122.*p.xz));\n  col+=0.051*noise(uv*iResolution.xy+iTime);\n  circ = .5;\n  \n  float vinj = 1.-(smoothstep(0.35,1.0,length(noAspectUv)))*(1.2+fftBass*2.);\n  \n  col = col *(circ+fftBass+mix(1., circ, 0.5));\n  \n  col *= vinj;\n    \n  fragColor =vec4( col,1.);\n}","name":"Image","description":"","type":"image"}]}