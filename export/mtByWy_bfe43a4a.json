{"ver":"0.1","info":{"id":"mtByWy","date":"1692234883","viewed":34,"name":"Ray-Torus (2d slice)","username":"Envy24","description":"See Image tab header.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","ray","torus","intersection"],"hasliked":0,"parentid":"cljcR3","parentname":"Ray-Hemisphere (2d slice)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Scene defined in 3d, but you see just a slice for some z value.\n    Mouse.y changes z coordinate for slice.\n    \n    Debug:\n        Lower left dot - last executed branch (case),\n        Lower right dot - picked root (if any).\n        \n    In 3d: https://www.shadertoy.com/view/dlSyzt\n*/\n\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 2.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n \nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    bool hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n    int hitted_idx;\n};\nvec3 debug_color = vec3(0);\nvec3 root_color = vec3(0);\n\n// Ray-Object intersection routines.\nfloat g = 1., h = 0.2;\nHIT ray_torus_int(RAY ray, float g, float h)\n{\n    // Torus definition:\n    // Equation: (x*x + y*y + z*z + g*g - h*h)^2 = 4*g*g*(x*x + y*y)\n    // Primitive constrains:\n    //    pos = vec3(0), g > 0, h > 0\n    //    XZ plane cut torus to two equal parts.\n    HIT hit;\n  \n    // To make equations smaller.\n    float a = ray.position.x, b = ray.direction.x,\n          c = ray.position.y, d = ray.direction.y,\n          e = ray.position.z, f = ray.direction.z;\n  \n    /**\n    // Camera in torus?\n    float aa = (a*a+c*c+e*e+g*g-h*h),\n          bb = 4.*g*g*(a*a+c*c);\n    \n    if (aa*aa - bb < 0.)\n    {\n        debug_color = vec3(0,1,1);\n        \n        hit.hit_something = false;\n        hit.hit_dist = 9e5;\n        return hit;\n    }\n    /**/\n\n    float A = b*b + d*d + f*f,\n          B = 2.*(a*b + c*d + e*f),\n          C = a*a + c*c + e*e + g*g - h*h,\n          D = 4.*g*g*(b*b + d*d),\n          E = 8.*g*g*(a*b + c*d),\n          F = 4.*g*g*(a*a + c*c);\n          \n    float coefs[5] = float[5]( \n        A*A,\n        2.*A*B,\n        2.*A*C + B*B - D,\n        2.*B*C - E,\n        C*C - F );\n    vec2 roots[4];\n       \n    int num = solve4(roots, coefs);\n    \n    if (num == 0)\n    {\n        debug_color = vec3(1,0,0);\n        \n        hit.hit_something = false;\n        hit.hit_dist = 9e5;\n        return hit;\n    }\n    \n    float min_sq_d = 9e5, c_root;\n    vec3 c_hp, cam = ray.position;;\n    for (int r = 0; r < num; ++r)\n    {\n        if (roots[r].y > 1e-5 || roots[r].x < 0.) continue;\n        \n        vec3 hp = ray.position + ray.direction * roots[r].x;\n        vec3 diff = hp - ray.position;\n        float sq_d = dot(diff, diff);\n        \n        if (min_sq_d > sq_d)\n        {\n            min_sq_d = sq_d;\n            c_root = roots[r].x;\n            c_hp = hp;\n        }\n    }\n        \n    debug_color = vec3(0,0,1);\n    \n    hit.hit_something = true;\n    hit.hit_point = c_hp;\n    hit.hit_dist = c_root;\n    hit.hp_normal = normalize(c_hp - normalize(vec3(c_hp.xy, 0))*g);\n    \n    //int r = 0;\n    //hit.hit_point = ray.position + ray.direction * roots[r].x;\n    //hit.hit_dist = roots[r].x;\n  \n    return hit;\n}\n\nfloat implicit(float x, float y, float z) \n{   \n    float a = (x*x+y*y+z*z+g*g-h*h),\n          b = 4.*g*g*(x*x+y*y);\n    \n    return a*a - b;\n}\nfloat implicitAA( in vec3 P )\n{\n    float coverage = 0., // You can cheat and set this variable to some negative value.\n          th = 6.,        // thickness\n          c = implicit(P.x, P.y, P.z) >= 0. ? 1. : -1.; // only sign\n    \n    vec2 ps = vec2(0.35*SCENE_SCALE/iResolution.y); // affects thickness and artifacts\n   \n    // Supersampling.\n    for (float y = -th; y <= th; y += 1.)\n        for (float x = -th; x <= th; x += 1.)\n        {\n            vec3 p = P + vec3(x, y, 0)*vec3(ps, 0);\n            float n = implicit(p.x, p.y, p.z);\n            \n            /* 1. Filled shape *\n            coverage += n >= 0.0 ? 0.0 : 1.0;\n            /* 2. Shape contour */\n            n = n >= 0.0 ? 1. : -1.;\n            coverage += c == n ? 0. : 1.;\n            /**/\n        }\n  \n    // Convert coverage into intensity (.35 is arbitrary weight for AA).\n    return smoothstep(0., th*th, coverage*0.35);\n}\n \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :  \n              map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    // Z for slice.\n    float //z_coord = 0.;\n          z_coord = MP.y;\n          \n    // Draw 2d slice.\n    vec3 point3d = vec3(NDC, z_coord);\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(NDC, vec2(0), 0.02)));\n    \n    color = mix(color, vec3(0,0,1), implicitAA(point3d));\n\n    \n    // Ray position, direction.\n    float T = iTime * 0.2;\n    vec3 //r_orig = vec3(0),//vec3(MP, z_coord),\n         //r_orig = vec3(-0.5, -1.6, z_coord),\n         r_orig = vec3(sin(iTime)*2., -1.6, z_coord),\n         //r_orig = vec3(2. * cos(T), 2. * sin(cos(T*2.5)), z_coord),\n         //r_orig = vec3(MP, z_coord),\n         r_dir = normalize(vec3(0.5, -0.2, z_coord) - r_orig);\n         //r_dir = normalize(vec3(MP, z_coord) - r_orig);\n         \n    color = mix(color, vec3(0.5), SMAA(diskSDF(NDC, r_orig.xy, 0.03)));  \n    color = mix(color, vec3(0.7), SMAA(segmentSDF(NDC, r_orig.xy, (r_orig+r_dir*100.).xy, 0.)));\n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF(NDC, r_orig.xy, (r_orig+r_dir).xy, 0.)));\n    \n    // Intersection.\n    RAY ray = RAY(r_orig, r_dir);\n    HIT hit = ray_torus_int(ray, g, h);\n    \n    // Color for last executed branch.\n    color = mix(color, debug_color, SMAA(diskSDF(NDC, vec2(-4, -2), 0.1)));\n    \n    if (hit.hit_something == true)\n    {\n        color = mix(color, root_color, SMAA(diskSDF(NDC, vec2(-3, -2), 0.1)));\n    \n        color = mix(color, vec3(0, 0.5, 0.5), SMAA(diskSDF(NDC, hit.hit_point.xy, 0.03)));\n        color = mix(color, vec3(0, 0.5, 0.5), SMAA(arrowSDF(NDC, hit.hit_point.xy, hit.hit_point.xy + hit.hp_normal.xy, 0.)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0475, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0475 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n/*\n    Returns number of real roots.\n*/\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(Q) * cosh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(abs(Q)) * sinh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n/*\n     Returns number of real roots.       \n*/\nint solveQuartic(\n    inout vec2 roots[4],\n    in float coefs[5])\n{\n    float A3 = coefs[1] / coefs[0],\n          A2 = coefs[2] / coefs[0],\n          A1 = coefs[3] / coefs[0],\n          A0 = coefs[4] / coefs[0];\n\n    float C = A3 * 0.25,\n          b2 = A2 - 6. * C * C,\n          b1 = A1 - 2. * A2 * C + 8. * C * C * C,\n          b0 = A0 - A1 * C + A2 * C * C - 3. * C * C * C * C;\n\n    float cb = b2,\n          cc =  (b2 * b2) * 0.25 - b0,\n          cd = -(b1 * b1) * 0.125;\n           \n    vec2 roots_[3];\n    float coefs_[4] = float[4]( 1., cb, cc, cd );\n    int num = solveCubicForReal(roots_, coefs_);\n\n    float m = 0.;\n    for (int r = 0; r < num; ++r)\n    {\n        if (roots_[r].x < 0.) continue;\n        m = roots_[r].x;\n        break;\n    }\n\n    float sigma = b1 > 0. ? 1. : -1.,\n           R = sigma * max(0., sqrt(m * m + b2 * m + (b2 * b2) * 0.25 - b0));\n           //R = sigma * sqrt(m * m + b2 * m + (b2 * b2) * 0.25 - b0); // In original\n\n    vec2 Roots[4];   \n    Roots[0].x =  sqrt(m * 0.5) - C + sqrt(-(m + b2) * 0.5 - R),\n    Roots[1].x =  sqrt(m * 0.5) - C - sqrt(-(m + b2) * 0.5 - R),\n    Roots[2].x = -sqrt(m * 0.5) - C + sqrt(-(m + b2) * 0.5 + R),\n    Roots[3].x = -sqrt(m * 0.5) - C - sqrt(-(m + b2) * 0.5 + R);\n    \n    num = 0;\n    int w_idx = 0;\n    for (int r = 0; r < 4; ++r)\n    {\n        if (isnan(Roots[r].x) == true) continue;\n\n        roots[w_idx++].x = Roots[r].x; ++num;\n    }\n    \n    return num;\n}\n/* \n    Returns number of real roots.       \n*/\nint solve4(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {\n        return solveQuartic(roots, coef);\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[1], coef[2], coef[3]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\nfloat findQuarticRootNewtonRaphson(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n        x -= f / dfdx;          \n        dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootHybrid(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\n/*  Unstable.\n    Returns number of real roots.       \n*/\nint solve4n(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {           \n        // Find first root.\n        //float x = findQuarticRootNewtonRaphson(0.01, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootHalley(0.01, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootBisection(-5.0, 5.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootRegulaFalsi(-1.1, 10.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootSecant(.1, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        float x = findQuarticRootHybrid(-10.0, 1., coef[0], coef[1], coef[2], coef[3], coef[4]);\n              x = findQuarticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n\n        /* No real roots? */\n        if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) \n        { \n            x = findQuarticRootHybrid(-1., 10., coef[0], coef[1], coef[2], coef[3], coef[4]);\n            x = findQuarticRootNewtonRaphson(-x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n                  \n            // Still no real roots?\n            if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) { return 0; }\n        }\n        /**/\n\n        roots[0].x = x;\n\n        // Convert equation to form: (x-r0)(axxx+bxx+cx+d)=0\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[0],\n            coef[1] + coef[0] * x,\n            coef[2] + coef[1] * x + coef[0] * x * x,\n            coef[3] + coef[2] * x + coef[1] * x * x + coef[0] * x * x * x\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[1] = roots_[0]; roots[2] = roots_[1]; roots[3] = roots_[2];\n\n        return num + 1;\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[2], coef[3], coef[4]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\nfloat poly4(vec4 p, float x) {\n    return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    const float TOL = 1e-4;\n\n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n\n    ////////////////////////////////////////////////////////////\n    // check for quadruple root\n    \n    float x = -p/4.;\n    \n    if (abs(poly4(coeffs, x)) < TOL &&\n        abs(q - 6.*x*x) < TOL) {\n        roots = vec4(x);\n        return bvec4(true);\n    }\n\n    ////////////////////////////////////////////////////////////\n    // check for triple root\n    \n    float d = 9.*p*p - 24.*q;\n    \n    if (d >= 0.) {\n\n        float x1 = -p/4. - sqrt(d)/12.;\n        float x2 = -p/4. + sqrt(d)/12.;\n        \n        float px1 = abs(poly4(coeffs, x1));\n        float px2 = abs(poly4(coeffs, x2));\n        \n        x = px1 < px2 ? x1 : x2;\n\n        float y = -p - 3.*x;\n        \n        roots = vec4(max(x,y),x,x,min(x,y));\n        \n        if (min(px1, px2) < TOL &&\n            abs(poly4(coeffs, y)) < TOL &&\n            abs(r + x*x*x + 3.*x*x*y) < TOL) {\n            \n            return bvec4(true);\n\n        }\n\n    }\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= -TOL) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= -TOL);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= -TOL);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= -TOL);\n    bool E_ok = R_ok && (foo - bar >= -TOL);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}","name":"Common","description":"","type":"common"}]}