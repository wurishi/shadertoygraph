{"ver":"0.1","info":{"id":"3sdfzX","date":"1605732778","viewed":65,"name":"RaymarchedFractal","username":"3ncryp73d","description":"A raymarched mandelbulb","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3x3 eulerAnglesToRotationMatrix(vec3 theta)\n{\n    // Calculate rotation about x axis\n    mat3x3 R_x = mat3x3(\n        1,       0,              0,\n        0,       cos(theta.x),   -sin(theta.x),\n        0,       sin(theta.x),   cos(theta.x)\n        );\n    \n    // Calculate rotation about y axis\n    mat3x3 R_y = mat3x3(\n    \tcos(theta.y),    0,      sin(theta.y),\n        0,               1,      0,\n        -sin(theta.y),   0,      cos(theta.y)\n    );\n    \n    // Calculate rotation about z axis\n    mat3x3 R_z = mat3x3(\n        cos(theta.z),    -sin(theta.z),      0,\n        sin(theta.z),    cos(theta.z),       0,\n        0,               0,                  1\n    );\n    \n    \n    // Combined rotation matrix\n    mat3x3 R = R_z * R_y * R_x;\n    return R;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 pow_vec3(vec3 v, float n)\n{\n    float r = length(v);\n    float phi = atan(v.y/v.x);\n    float theta = acos(v.z/r);\n    \n    return pow(r,n)*vec3(sin(n*theta)*cos(n*phi),\n                         sin(n*theta)*sin(n*phi),\n                         cos(n*theta));\n}\n\nfloat sdf_bulb(vec3 pos, float p) \n{\n    int n = 0;\n    vec3 v = pos;\n    float l_dv = 1.;\n    for (int i = 0; i<50; i++)\n    {\n        v = pow_vec3(v, p) + pos;\n        l_dv *= p*length(v);\n        if (length(v) > 5.)\n        {\n            n = i;\n            break;\n        }\n    }\n    \n    return length(v)*log(length(v))/l_dv;\n}\n\nfloat sdf(vec3 pos)\n{\n\tif (length(pos) < 2.)\n    {\n        return 0.7 * sdf_bulb(pos, 6.); //sin(iTime/5.) * 10. + 13.);\n    }\n    return(length(pos) - 1.5);\n}\n\nvec4 normalAndDistance(vec3 pos, float filterSize)\n{\n    vec3 d = vec3(filterSize, 0., 0.);\n    float o = sdf(pos);\n    float dx = sdf(pos+d.xyy)-sdf(pos-d.xyy);\n    float dy = sdf(pos+d.yxy)-sdf(pos-d.yxy);\n    float dz = sdf(pos+d.yyx)-sdf(pos-d.yyx);\n    \n    return vec4(normalize(vec3(dx, dy, dz)), o);\n}\n\nvoid castRay(in vec3 o, in vec3 d, out float ao, out vec4 nd, out vec4 lt, out float shadow)\n{\n    float t = 0.005 * rand(d.xy);\n    vec3 lastLoc = o;\n    int n0 = 1000;\n    ao = 1.;\n    \n    float minShadow = 0.002;\n    \n    for (int i = 0; i<n0; i++) {\n        \n        lastLoc = o + t*d;\n        float dist = sdf(lastLoc);\n        t += max(dist, 0.);\n        \n        minShadow = (t < 0.02) ? minShadow : min(minShadow, dist/t);\n        \n        if (dist<=0.00001 || dist > 100.)\n        {\n            ao = pow(float(n0 - i)/ float(n0-1), 3.);\n            break;\n        }\n    }\n    \n    \n    nd = normalAndDistance(lastLoc, t/iResolution.x*2.);\n    \n    lt = vec4(lastLoc, t);\n    shadow = minShadow/0.002;\n}\n\nvec3 blackbody(float t){\n    // http://en.wikipedia.org/wiki/Planckian_locus\n\n    const vec4 vx = vec4( -0.2661239e9, -0.2343580e6, 0.8776956e3, 0.179910   );\n    const vec4 vy = vec4( -1.1063814,   -1.34811020,  2.18555832, -0.20219683 );\n    //vec4 vy = vec4(-0.9549476,-1.37418593,2.09137015,-0.16748867); //>2222K\n    float it = 1. / t;\n    float it2= it * it;\n    float x = dot( vx, vec4( it*it2, it2, it, 1. ) );\n    float x2 = x * x;\n    float y = dot( vy, vec4( x*x2, x2, x, 1. ) );\n    float iy = 1./y;\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    const mat3x2 xzTosrgb = mat3x2(\n         3.2404542,-0.4985314,\n        -0.9692660, 0.0415560,\n         0.0556434, 1.0572252\n    );\n    const vec3 yTosrgb = vec3(-1.5371385, 1.8760108, -0.2040259);\n    \n    vec3 srgb = vec2( x*iy, iy-(x*iy+1.) )* xzTosrgb + yTosrgb;\n\n    return max( srgb, 0. );\n}\n\nvoid getColor(in vec3 pos, in vec3 normal, out vec4 emit, out vec4 diff)\n{\n    diff.xyz = vec3(1.);// mix(vec3(.7, .3, .3), vec3(.8, .7, 1.), smoothstep (1.1, 1.2, length(pos.xyz)));\n    //float t = 1.3 * max(0., 1. - smoothstep (0.4, .7, length(pos.xyz)));\n    \n    emit.xyz = vec3(0.);// 5. * t*t * blackbody(1200. + t*6000.);\n}\n\nvec3 refractionVec(vec3 n, vec3 v, float IOR)\n{\n    vec3 compN = n*dot(n, v);\n    return normalize((v - compN)/IOR - compN);\n}\n\nvec3 reflectionVec(vec3 n, vec3 v)\n{\n    vec3 compN = n*dot(n, v);\n    return normalize(v - 2.*compN);\n}\n\nfloat fresnel(vec3 normal, vec3 camera, float IOR)\n{\n    vec3 n = normalize(normal);\n    vec3 v = normalize(camera);\n    vec3 vr = refractionVec(normal, camera, IOR);\n    \n    float di = dot(n,v);\n    float dt = dot(n, -vr);\n    \n    float facS = (di*IOR - dt) / (di*IOR + dt);\n    float facP = (dt*IOR - di) / (dt*IOR + di);\n    \n    return facS*facS + facP*facP;\n}\n\nvec3 ambient(vec3 dir)\n{\n    return 0.5*normalize(dir)+vec3(0.5);\n}\n\n\nvec3 sampleAmbientDiffuse(vec3 dir)\n{\n    vec3 a = normalize(cross(dir, vec3(1., 0., 0.)));\n    vec3 b = normalize(cross(dir, a));\n    \n    vec3 sum = vec3(0.);\n    \n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 8; j++)\n    \t{\n            float alpha = float(j) / 4. * 3.141;\n            vec3 add = (float(i+1) / 8.)*(sin(alpha)*a+cos(alpha*b));\n            sum += ambient(dir+add*6.);\n        }\n    }\n    \n    sum /= 64.;\n    \n    return sum + vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx*2.0f - vec2(1., iResolution.y / iResolution.x);\n    \n    \n    vec3 dir = normalize(vec3(-0.7, uv));\n    \n    dir *= eulerAnglesToRotationMatrix(vec3(0., -0.9, 0.));\n    dir *= eulerAnglesToRotationMatrix(vec3(0., 0., .1*iTime));\n    \n    vec3 o = vec3(2.,0.,0.);\n        \n    o *= eulerAnglesToRotationMatrix(vec3(0., -0.9, 0.));\n    o *= eulerAnglesToRotationMatrix(vec3(0., 0., .1*iTime));\n    \n    vec3 lightVec = normalize(vec3(0.5, 0.5, 1.)) * eulerAnglesToRotationMatrix(vec3(0., 0., -.2*iTime));;\n    \n    float ao;\n    vec4 nd;\n    vec4 lt;\n    \n    float shadow = 0.;\n    \n    castRay(o, dir, ao, nd, lt, shadow);\n    \n    \n    \n    if(nd.w < 0.001) {\n        float _1;\n        vec4 nd2;\n        vec4 _2;\n        castRay(lt.xyz+lightVec*.002, lightVec, _1, nd2, _2, shadow);\n        shadow = float(nd2.w > 1.) * shadow;\n    }\n    \n    vec3 refl = reflectionVec(nd.xyz, normalize(lt.xyz - o));\n    \n    vec4 emit;\n    vec4 diff;\n    \n    vec3 ambientDiff = sampleAmbientDiffuse(normalAndDistance(lt.xyz, lt.w/iResolution.x*7.).xyz); //vec3(0.2, 0.5, 0.7);\n    vec3 light = vec3(2., 2., 1.8);\n    \n    getColor(lt.xyz, nd.xyz, emit, diff);\n    \n    //fragColor = vec4(1.-exp(-t/3.)); \n    fragColor = mix((ao * vec4(ambientDiff, 1.)\n                 + shadow * vec4(light, 1.) * max(0., mix(dot(nd.xyz, lightVec), 1., 0.2))\n        ) * diff, vec4(ambient(refl), 1), fresnel(nd.xyz, lt.xyz - o, 1.6)) + emit;\n    \n    //fragColor.xyz = ambient(refl);//vec3(fresnel(nd.xyz, lt.xyz - o, 1.6)) * ambient(refl);\n    \n    fragColor = 0.5*log(mix(fragColor, vec4(ambient(lt.xyz - o), 1.), float(nd.w > 0.01))*3.+.5);\n    \n}","name":"Image","description":"","type":"image"}]}