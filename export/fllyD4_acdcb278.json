{"ver":"0.1","info":{"id":"fllyD4","date":"1649338605","viewed":48,"name":"CLICK FORMS","username":"muss61","description":"Shape-changing spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["forms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////DEMIR MUSTAFA/////////////\n\n#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\nbool tourne = false;\n// o + d *dist : pour calculer un point précis\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n    int id; // l'id pour récupérer la forme cliqué\n};\n// création de structure pour chaque forme\nstruct Sphere{\n    vec3 pos;\n    float taille;\n    vec3 col;\n};\nstruct Octahe{\n    vec3 pos;\n    float taille;\n    vec3 col;\n};\nstruct Cylindre{\n    vec3 pos;\n    float ra;\n    float rb;\n    float h;\n    vec3 col;\n};\nfloat add( float sd1, float sd2){\n\n    return min(sd1,sd2);\n}\nvec3 hash31(float p) {\n    return fract(sin(vec3(1275.231,4461.7,7182.423)*p)*43758.543123);\n}\n// création d'un tableau pour chaque forme\nSphere spheres[5];\nOctahe octahes[5];\nCylindre cylindres[5];\n\nint quelObj[5];// tableau pour voir quelle forme à été cliqué, et quelle forme va prendre quelle représentation\n/////////////////// Création de la fonction des formes et \n///////////////////les fonctions des surfaces corresondante\n\n//////// Sphere\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nSurface sphere (in vec3 p, in vec3 col, float taille,int id){\n    return Surface(sdSphere(p,taille), col,id);\n}\n\n// octahe\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nSurface octahe (in vec3 p, in vec3 col, float taille,int id){\n    return Surface(sdOctahedron(p,taille), col,id);\n}\n// cylindre\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nSurface cylindre (in vec3 p, in vec3 col, float ra,float rb,float h,int id){\n    return Surface(sdRoundedCylinder(p,ra,rb,h), col,id);\n}\n// fonction d'initialisation des valeurs de tableau\nvoid initialize(){\n    \n        spheres[0].pos = vec3(0.,0.,0.);\n        spheres[1].pos = vec3(10.,0.,0.);\n        spheres[2].pos = vec3(-10.,0.,0.);\n        spheres[3].pos = vec3(0,0.,10.);\n        spheres[4].pos = vec3(0.,0.,-10.);\n\n\n        spheres[0].taille = 3.*(abs(sin(0.7*iTime)+cos(0.7*iTime)));\n        spheres[1].taille = 2.;\n        spheres[2].taille = 2.;\n        spheres[3].taille = 2.;\n        spheres[4].taille = 2.;\n\n\n        spheres[0].col = vec3(1.1*cos(iTime*1.5),0.5,0.*cos(iTime*1.));\n        spheres[1].col = vec3(0.1,0.5,1.);\n        spheres[2].col = vec3(1.1,0.5,1.); \n        spheres[3].col = vec3(1.1,1.5,1.);\n        spheres[4].col = vec3(1.0,1.2,1.2);  \n      \n        octahes[3].pos = vec3(0,0.,10.);\n        octahes[3].taille =2.;\n        octahes[3].col = vec3(1.1,1.5,1.);\n        \n        cylindres[1].pos = vec3(10.,0.,0.);\n        cylindres[1].ra = 1.2;\n        cylindres[1].rb = 1.2;\n        cylindres[1].h = 1.2;\n        cylindres[1].col = vec3(0.1,0.5,1.);\n        \n        cylindres[2].pos = vec3(-10.,0.,0.);\n        cylindres[2].col = vec3(1.1,0.5,1.); \n}\nSurface scene(in vec3 p) {\n    vec3 MAX = vec3(2.,2.,2.);\n    vec3 t = p*6.;\n    \n    float test = (-0.9)*cos(t.x)*sin(t.y)*cos(t.z);\n\n    float v1 = cos(t.x)*cos(t.y)*cos(t.z)/5.;\n    float v2 = (sin(t.x)+sin(t.y))/10.;\n    Surface s = Surface(20.,vec3(2.,1.1,0.2),10);\n    \n    \n    for(int i=0;i<5;++i){\n        Surface temp;\n        // on ajoute la surface correspondant à la valeur dans quelObj[i]\n        if(quelObj[i] == 0){\n            if(i == 0){\n                 temp = sphere(p+spheres[i].pos+test*cos(iTime),spheres[i].col,spheres[i].taille,i);\n            }else{\n                temp = sphere(p+spheres[i].pos,spheres[i].col,spheres[i].taille,i); \n            }\n\n            if(temp.t < s.t){\n                s = temp;\n            } \n        }else if(quelObj[i] == 1){\n            if(i == 0){\n                 temp = octahe(p+octahes[i].pos+test*cos(iTime),octahes[i].col,octahes[i].taille,i);\n            }else{\n                temp = octahe(p+octahes[i].pos,octahes[i].col,octahes[i].taille,i); \n            }\n\n            if(temp.t < s.t){\n                s = temp;\n            } \n        }else if(quelObj[i] == 2){\n            if(i == 0){\n                 temp = cylindre(p+cylindres[i].pos+test*cos(iTime),cylindres[i].col,cylindres[i].ra,cylindres[i].rb,cylindres[i].h,i);\n            }else{\n                temp = cylindre(p+cylindres[i].pos,cylindres[i].col,cylindres[i].ra,cylindres[i].rb,cylindres[i].h,i); \n            }\n\n            if(temp.t < s.t){\n                s = temp;\n            } \n        }\n    }\n    return s;\n   \n}\n\nvec3 scale( in vec3 p, in vec3 f){\n return p*f;\n}\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c,s.id);// s.id, l'id cliqué\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(1.),-1);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 30.;\n    float d = DP/2.;\n    vec3 ro;\n    if(tourne == false){\n        ro = vec3(15.,6.,15.); \n    }else{\n        ro  = vec3(20.*cos(2.*iTime),5.,14.*sin(2.*iTime)); \n    }\n  \n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 90.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*R.y/R.x + zf*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(100.*cos(iTime));\n    float s = 10.;//*cos(iTime);\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),-2.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff+ ks*spec;\n    \n}\n/// fonction de changement de forme de la forme cliqué\nvoid changeSphere(int idForme){\n       vec3 t = spheres[idForme].pos*6.;\n       float test = (0.9)*cos(t.x)*cos(t.y)*cos(t.z);\n       if(idForme == 0){\n       \n           spheres[idForme].col =1.5 + 1.5*cos(iTime+vec3(0,1,2));\n           spheres[idForme].taille = abs(4.*cos(iTime));\n           \n           cylindres[1].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           cylindres[1].h = abs(2.*cos(iTime)); \n           cylindres[1].rb = abs(5.*cos(iTime)); \n          \n           cylindres[2].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           cylindres[2].ra = abs(2.*cos(iTime)); \n\n           \n           octahes[3].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           octahes[3].taille = abs(2.*cos(iTime));\n           \n           spheres[4].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           spheres[4].taille = abs(2.*cos(iTime));\n           \n           tourne= true;\n ////// On change la valeur dans le tableau quelObj, pour lors de la création\n ////// crée la forme en fonction de la valeur enregistré\n           quelObj[0] = 0;\n           quelObj[1] = 2;\n           quelObj[2] = 2;\n           quelObj[3] = 1;\n           quelObj[4] = 0;\n           \n        }else if(idForme == 1){\n        \n           cylindres[idForme].col =1.0 + 2.0*cos(iTime+vec3(2,1,2));\n           cylindres[idForme].h = abs(2.*cos(iTime)); \n           cylindres[idForme].rb = abs(5.*cos(iTime)); \n           \n           quelObj[idForme] = 2;\n            \n        }else if(idForme == 2){\n\n           cylindres[idForme].col =0.8 + 1.*cos(iTime+vec3(2,1,2));\n           cylindres[idForme].ra = abs(4.*cos(iTime)); \n           cylindres[idForme].pos = vec3(10.*cos(iTime),10.*sin(iTime*2.),10.*cos(iTime*2.));\n           quelObj[idForme] = 2;\n           \n        }else if(idForme == 3){\n        \n           octahes[idForme].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           octahes[idForme].taille = abs(5.*cos(iTime));  \n           octahes[idForme].pos = vec3(0.,10.*cos(iTime),10.);\n\n           quelObj[idForme] = 1;\n           \n        }else if(idForme == 4){\n        \n           spheres[idForme].col =0.5 + 0.5*cos(iTime+vec3(0,1,2));\n           spheres[idForme].taille = abs(3.*cos(iTime));\n           spheres[idForme].pos = vec3(10.*cos(iTime),10.*cos(iTime),-10.*cos(iTime));\n\n           quelObj[idForme] = 0;\n        }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n\n    vec2 m = (iMouse.xy/R.xy)*2.-1.;\n    \n    \n    initialize();\n   // quand je met le spheres ici ça marche\n   // quand je le met après la march ça ne marche pas\n   \n    bool touche = true;\n   \n    if(iMouse.z > 0.0){ // button click\n        \n       touche = true;\n       Ray rCli = camRay(vec2(m.x,m.y));// envoie du rayon de l'endroit ou ma souris à cliqué     \n       Surface scli = march(rCli);// récupère la surface que le rayon et en contact\n       int idSurCli = scli.id;// récupère l'id de la surface cliqué\n       \n        changeSphere(idSurCli);\n        \n        // dessiner la scene après les modifications des formes\n        Ray r = camRay(uv);\n        Surface s = march(r);\n        \n        vec3 c = 0.2 + 0.2*(uv.xyx+vec3(0.3,1,2));\n        if(s.t<DIST_MAX) {\n            c = shade(s,r);\n        }\n    \n        fragColor = vec4(c,1.);\n    }else{\n    \n        vec3 c = 0.4 + 0.4*(uv.xyx+vec3(1,1,2));;\n        Ray r = camRay(uv); // on projette le rayon de tout les pixel, pour récupérer l'endroit ou on a cliqué\n        Surface s = march(r); \n    \n        if(s.t<DIST_MAX) {\n            c = shade(s,r);\n        }\n    \n        fragColor = vec4(c,1.);\n    }\n   \n}","name":"Image","description":"","type":"image"}]}