{"ver":"0.1","info":{"id":"Ddy3zD","date":"1678272966","viewed":495,"name":"Meander Belts","username":"wutzhuhn","description":"Inspired by Harold Fisk's 1944 \"Mississippi River Meander Belt\" maps.\nSee: [url]https://www.google.com/search?q=Harold+Fisk+1944+Mississippi+River+Meander+Belt+maps[/url]\n\nAll the glitches due to my busted quadratic bezier implementation are ~aesthetic~.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["bezier","pattern","drawing","paper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 red    = vec3(0.816, 0.325, 0.227);\nconst vec3 green  = vec3(0.584, 0.639, 0.38);\nconst vec3 blue   = vec3(0.498, 0.588, 0.49);\nconst vec3 yellow = vec3(0.843, 0.725, 0.353);\nconst vec3 white  = vec3(0.91,  0.804, 0.596);\nconst vec3 black  = vec3(0.125, 0.098, 0.078);\n\n// fewer belts = more fps. Max is 32.\n#define NUM_BELTS 32\n\nfloat rand(float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\n// Helper function that returns 1 if f is between\n// lo and hi, and 0 otherwise. The transition between\n// 0 and 1 is smoothed to about 2 pixels.\nfloat high_between(float f, float lo, float hi) {\n  float d = 2.0 / iResolution.x;\n  float rad = (hi - lo) / 2.0;\n  float mid = (lo + hi) / 2.0;\n  return smoothstep(-d, d, rad - abs(f - mid));\n}\n\nfloat pattern(int i, vec2 p) {\n  i = i % 4;\n  float s = (p.x - p.y) / sqrt(2.0);\n  if (0 == i) {\n    return high_between(mod(s, 0.03), 0.2 * 0.03, 0.55 * 0.03);\n  }\n  if (1 == i) {\n    float m = mod(s, 0.03);\n    return high_between(m, 0.1 * 0.03, 0.3 * 0.03)\n         + high_between(m, 0.5 * 0.03, 0.8 * 0.03);\n  }\n  if (2 == i) {\n    return high_between(mod(s, 0.01), 0.2 * 0.01, 0.65 * 0.01);\n  }\n  if (3 == i) {\n    mat2 rot = sqrt(2.0) / 2.0 * mat2( 1.0, -1.0,\n                                       1.0,  1.0);\n    vec2 dot_center = transpose(rot) * round(rot * p * 100.0) / 100.0;\n    float dot_radius = mix(rand(dot_center.x + dot_center.y), 1.0, 0.8) * 0.003;\n    return high_between(length(dot_center - p), dot_radius, 100.0);\n  }\n  return 0.0;\n}\n\nconst vec3 fg_colors[8] = vec3[](blue,    red,  green, green, yellow,  blue,   red, green);\nconst vec3 bg_colors[8] = vec3[]( red, yellow, yellow,  blue,  white, white, white, white);\n\nfloat cbrt(float f) {\n  return sign(f) * pow(abs(f), 1.0 / 3.0);\n}\nfloat bezier(vec2 a, vec2 b, vec2 c, vec2 p) { // from https://www.shadertoy.com/view/lsdBDS\n    vec2  ny     = normalize(a - 2.0 * b + c);\n    vec2  nx     = vec2(ny.y, -ny.x);\n    float xa     = dot(a - b, ny) / dot(a - b, nx) / 2.0;\n    float xc     = dot(c - b, ny) / dot(c - b, nx) / 2.0;\n    float scale  = (xa - xc) / dot(a - c, nx);\n    vec2  vertex = a - (nx * xa + ny * xa * xa) / scale;\n    vec2  p2 = (p - vertex) * mat2(nx, ny) * scale;\n    float min_x = min(xa, xc);\n    float max_x = max(xa, xc);\n    float l = 0.5 - p2.y;\n    float e = -(l * l * l / 27.0);\n    float dis = p2.x * p2.x * 0.25 - 4.0 * e;\n    if (0.0 <= dis) {\n        float f = p2.x * 0.25 + sign(p2.x) * sqrt(dis) * 0.5;\n        float qx = clamp(cbrt(f) + cbrt(e / f), min_x, max_x);\n        return length(vec2(qx, qx * qx) - p2) / scale;\n    }\n    float r3p = sqrt(p2.y - 0.5) * (2.0 / sqrt(3.0));\n    float ac = acos(-1.5 * p2.x / (l * r3p)) / 3.0;\n    float qx0 = clamp(r3p * cos(ac              ), min_x, max_x);\n    float qx1 = clamp(r3p * cos(ac - 4.188790205), min_x, max_x);\n    vec2 d0 = vec2(qx0, qx0 * qx0) - p2;\n    vec2 d1 = vec2(qx1, qx1 * qx1) - p2;\n    return sqrt(min(dot(d0, d0), dot(d1, d1))) / scale;\n}\nfloat segment(vec2 a, vec2 b, vec2 p) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // (0,0) at the center, -1 left, 1 right, -1 bottom, 1 top.\n  vec2  p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\n  // add two levels of noise to the pixel position:\n  // 1. some coarse noise to make the likes look more hand-drawn.\n  p += vec2(sin(p.x * 64.0 + p.y * 128.0) * 0.000625,\n            sin(p.y * 64.0 + p.x *  32.0) * 0.000625);\n  // 2. some fine noise to make the edges look more like ink on paper. \n  p += vec2(rand(p.x * 31.0 + p.y * 87.0) * 0.001,\n            rand(p.x * 11.0 + p.y * 67.0) * 0.001);\n\n  float outline = 0.0;\n  float id = -1.0;\n  for (int i = 0; i < NUM_BELTS; ++i) {\n    float t = iTime + float(i * 16) + 1024.0;\n    vec2 p0 =      vec2(-1.5,              sin(t * 0.02));\n    vec2 p1 =      vec2( sin(t*0.1) * 0.1, sin(t * 0.07) * 0.7);\n    vec2 p2 =      vec2( 1.5,              sin(t * 0.03));\n    vec2 c0 = p1 + vec2(-0.5,              sin(t * 0.13) * 0.5);\n    vec2 c1 = 2.0 * p1 - c0;\n    float dist = min(\n        bezier(\n          p.x < p1.x ? p0 : p1,\n          p.x < p1.x ? c0 : c1,\n          p.x < p1.x ? p1 : p2,\n          p),\n        segment(\n          p1,\n          p.x < p1.x ? c1 : c0,\n          p));\n\n#if 1\n    vec2 p3 = p0 - vec2(1.0 - sin(t * 0.025), 1.0 - sin(t * 0.027)) * 0.05;\n    vec2 p4 = p1 + vec2(      sin(t * 0.014),       sin(t * 0.032)) * 0.05;\n    vec2 p5 = p2 + vec2(1.0 - sin(t * 0.014), 1.0 - sin(t * 0.032)) * 0.05;\n    vec2 c2 = p4 + vec2(-1.0,                       sin(t * 0.13))  * 0.5;\n    vec2 c3 = 2.0 * p4 - c0;\n    float dist2 = min(\n        bezier(\n          p.x < p4.x ? p3 : p4,\n          p.x < p4.x ? c2 : c3,\n          p.x < p4.x ? p4 : p5,\n          p),\n        segment(\n          p4,\n          p.x < p4.x ? c3 : c2,\n          p));\n    dist = min(dist, dist2 + 0.01);\n#endif\n    dist *= sin(p.x * 10.0 + sin(p.y)) * 0.2 + 1.0;\n\n    float fill   = high_between(dist, -1.0,   0.025);\n    float border = high_between(dist,  0.022, 0.028);\n    id      = mix(id, float(i), fill);\n    outline = mix(outline, border, fill);\n  }\n  vec3 fg = 0.0 <= id ? fg_colors[int(id)/4] : white;\n  vec3 bg = 0.0 <= id ? bg_colors[int(id)/4] : white;\n  vec3 color = mix(mix(fg, bg, pattern(int(id), p)), black, outline);\n\n  // Some noise to make it look more paper-y\n  color *= 0.95 + rand(p.x + p.y) * 0.1;\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}