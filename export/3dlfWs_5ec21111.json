{"ver":"0.1","info":{"id":"3dlfWs","date":"1589581525","viewed":3034,"name":"STARRY NIGHT","username":"alro","description":"Use mouse to look around.","likes":118,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","clouds","sky","volumetric","stars","moon","night","dithering","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Starry night sky with moonlit clouds.\n//See https://www.shadertoy.com/view/3sffzj for clouds\n\n//Blue noise dithering based on:\n//https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n//https://www.shadertoy.com/view/WsfBDf\n\n//BufferA: \tTracking view direction and resolution change.\n//BufferB: \tRed & Green: Perlin-Worley atlas, \n//\t\t\tBlue: cloud map\n//\t\t\tAlpha: moon texture.\n\n//EDIT: Better multiple scattering approximation\n\n//Comment to see banding that the blue noise hides.\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\n//Size of cloud AABB.\n#define CLOUD_EXTENT 1000.0\n\n//Uncomment for fewer ray marching steps and better performance.\n//#define FAST\n\n#ifdef FAST\n\t#define STEPS_PRIMARY 32\t\n\t#define STEPS_LIGHT 8\n#else\n\t#define STEPS_PRIMARY 64\n\t#define STEPS_LIGHT 10\n#endif\n\n\n//Uncomment to animate moon azimuth.\n//#define ANIMATE_MOON\n\nconst float moonSpeed = 0.1;\nfloat moonDistance = 100.0;\nfloat moonSize = 8.0;\n\nfloat moonLocation = 4.5;\nfloat moonHeight = 0.25;\n\nconst vec3 lightColour = vec3(0.65, 0.8, 1.0);\n\nconst vec3 skyColour = 0.1 * vec3(0.32, 0.65, 1.0);\n\nconst float starCount = 20000.0;\nconst float flickerSpeed = 6.0;\n\nconst float shapeSpeed = -5.0;\nconst float detailSpeed = -10.0;\n\nconst float power = 100.0;\nconst float densityMultiplier = 0.075;\n\nconst float shapeSize = 0.05;\nconst float detailSize = 0.3;\n\nconst float shapeStrength = 0.7;\nconst float detailStrength = 0.2;\n\nconst float cloudStart = 0.0;\nconst float cloudEnd = CLOUD_EXTENT;\n\nconst vec3 minCorner = vec3(-CLOUD_EXTENT, cloudStart, -CLOUD_EXTENT);\nconst vec3 maxCorner = vec3(CLOUD_EXTENT, cloudEnd, CLOUD_EXTENT);\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 5e-7);\n\treturn pow(radius/dist, intensity);\t\n}\n\n\n//Get Cartesian coordinates from spherical.\nvec3 getStarPosition(float theta, float phi){\n\treturn normalize(vec3(\tsin(theta)*cos(phi),\n               \t\t\t\tsin(theta)*sin(phi),\n               \t\t\t\tcos(theta)));\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat rand(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nbool isActiveElevation(float theta, float level){\n    return sin(theta) > rand(vec2(theta, level));\n}\n\nfloat getDistToStar(vec3 p, float theta, float phi){\n    vec3 starPos = getStarPosition(theta, phi);\n    return 0.5+0.5*dot(starPos, p);\n}\n\n//Get star colour from view direction.\nfloat getStars(vec3 rayDir){\n    \n    //acos returns a value in the range [0, PI].\n    //The theta of the original view ray.\n    float theta = acos(rayDir.z);\n\n    //Extent of each level.\n    float width = PI/starCount;\n    \n    //The level on which the view ray falls.\n    float level = floor((theta/PI)*starCount);\n    \n    //The theta of the level considered.\n    float theta_;\n    //Random angle of the star on the level.\n    float phi_;\n    \n    float stars = 0.0;\n    float dist;\n    \n    //Variable to keep track of neighbouring levels.\n    float level_;\n    \n    float rnd;\n    \n    //For a set number of layers above and below the view ray one,\n    //accumulate the star colour.\n    for(float l = -10.0; l <= 10.0; l++){\n        \n    \tlevel_ = min(starCount-1.0, max(0.0, level+l));\n        theta_ = (level_+0.5)*width;\n\n        //Uniformly picked latitudes lead to stars concentrating at the poles.\n        //Make the likelyhood of rendering stars a function of sin(theta_)\n        if(!isActiveElevation(theta_, 0.0)){\n            continue;\n        }\n        \n        rnd = rand(PI+theta_);\n        phi_ = TWO_PI*rand(level_);\n        dist = getDistToStar(rayDir, theta_, phi_);\n        \n        stars += getGlow(1.0-dist, rnd*8e-7, 2.9 + (sin(rand(rnd)*flickerSpeed*iTime)));\n    }\n    \n    return 0.05*stars;\n}\n\nvec3 getSkyColour(vec3 rayDir, float mu){\n    \n    float stars = 0.0;\n    \n    //Render stars only above the horizon.\n    if(rayDir.y > 0.0){\n        //Swap Y and Z axis to be consistent with notation.\n    \tvec3 dir = rayDir.xzy;\n    \tstars = getStars(dir);\n    }\n    \n    //Return stars plus a blue colour with a brighter haze around the moon. \n    return stars + mix(0.2*skyColour, 0.5*skyColour, pow(mu, 8.0));\n}\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersections(vec3 start, vec3 dir, float radius){\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n\tfloat d = (b*b) - 4.0*a*c;\n\tif (d < 0.0){\n        return vec2(1e5, -1e5);\n\t}\n\treturn vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));\n}\n\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n//Compute the near and far intersections using the slab method.\n//No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getCloudIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n\tvec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\t\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n    \n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n\nfloat getPerlinWorleyNoise(vec3 pos){\n    //The cloud shape texture is an atlas of 6*6 tiles (36). \n    //Each tile is 32*32 with a 1 pixel wide boundary.\n    //Per tile:\t\t32 + 2 = 34.\n    //Atlas width:\t6 * 34 = 204.\n    //The rest of the texture is black.\n    //The 3D texture the atlas represents has dimensions 32 * 32 * 36.\n    //The green channel is the data of the red channel shifted by one tile.\n    //(tex.g is the data one level above tex.r). \n    //To get the necessary data only requires a single texture fetch.\n    const float dataWidth = 204.0;\n    const float tileRows = 6.0;\n    const vec3 atlasDimensions = vec3(32.0, 32.0, 36.0);\n\n    //Change from Y being height to Z being height.\n    vec3 p = pos.xzy;\n\n    //Pixel coordinates of point in the 3D data.\n    vec3 coord = vec3(mod(p, atlasDimensions));\n    float f = fract(coord.z);  \n    float level = floor(coord.z);\n    float tileY = floor(level/tileRows); \n    float tileX = level - tileY * tileRows;\n\n    //The data coordinates are offset by the x and y tile, the two boundary cells \n    //between each tile pair and the initial boundary cell on the first row/column.\n    vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n    vec2 pixel = coord.xy + offset;\n    vec2 data = texture(iChannel1, mod(pixel, dataWidth)/iChannelResolution[1].xy).rg;\n    return mix(data.x, data.y, f);\n}\n\n//Read cloud map.\nfloat getCloudMap(vec3 p){\n    vec2 uv = 0.5+0.5*(p.xz/(2.0*CLOUD_EXTENT));\n    return texture(iChannel1, uv).b;\n}\n\nfloat clouds(vec3 p, out float cloudHeight, bool sampleDetail){\n    if(!insideAABB(p)){\n    \treturn 0.0;\n    }\n\n    cloudHeight = saturate((p.y - cloudStart)/(cloudEnd-cloudStart));\n    float cloud = getCloudMap(p);\n\n    //If there are no clouds, exit early.\n    if(cloud <= 0.0){\n      return 0.0;\n    }\n\n    //Sample texture which determines how high clouds reach.\n    float height = cloud;\n    \n    //Round the top of the cloud. From \"Real-time rendering of volumetric clouds\". \n    cloud *= saturate(remap(cloudHeight, 0.8*height, height, 1.0, 0.0));\n\n    //Animate main shape.\n    p += vec3(shapeSpeed * iTime);\n    \n    //Get main shape noise, invert and scale it.\n    float shape = 1.0-getPerlinWorleyNoise(shapeSize * p);\n    shape *= shapeStrength;\n\n    //Carve away density from cloud based on noise.\n    cloud = saturate(remap(cloud, shape, 1.0, 0.0, 1.0));\n\n    //Early exit from empty space\n    if(cloud <= 0.0){\n      return 0.0;    \n    }\n    \n    //Animate details.\n    p += vec3(detailSpeed * iTime, 0.0, 0.5 * detailSpeed * iTime);\n    \n    float detail = getPerlinWorleyNoise(detailSize * p);\n\tdetail *= detailStrength;\n    \n\t//Carve away detail based on the noise\n\tcloud = saturate(remap(cloud, detail, 1.0, 0.0, 1.0));\n    return densityMultiplier * cloud;\n}\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0/(4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//https://twitter.com/FewesW/status/1364629939568451587/photo/1\nfloat multipleOctaves(float extinction, float mu, float stepL){\n\n    float luminance = 0.0;\n    const float octaves = 4.0;\n    \n    //Attenuation\n    float a = 1.0;\n    //Contribution\n    float b = 1.0;\n    //Phase attenuation\n    float c = 1.0;\n    \n    float phase;\n    \n    for(float i = 0.0; i < octaves; i++){\n        //Two-lobed HG\n        phase = mix(HenyeyGreenstein(-0.1*c, mu), HenyeyGreenstein(0.3*c, mu), 0.7);\n        luminance += b * phase * exp(-stepL * extinction * a);\n        //Lower is brighter\n        a *= 0.25;\n        //Higher is brighter\n        b *= 0.5;\n        c *= 0.5;\n    }\n    return luminance;\n}\n\n//Get the amount of light that reaches a sample point.\nfloat lightRay(vec3 org, vec3 p, float mu, vec3 lightDirection){\n\n\tfloat lightRayDistance = CLOUD_EXTENT*1.5;\n    float distToStart = 0.0;\n    \n    getCloudIntersection(p, lightDirection, distToStart, lightRayDistance);\n        \n    float stepL = lightRayDistance/float(STEPS_LIGHT);\n\n\tfloat lightRayDensity = 0.0;\n    \n    float cloudHeight = 0.0;\n\n\t//Collect total density along light ray.\n\tfor(int j = 0; j < STEPS_LIGHT; j++){\n\t\n\t\tbool sampleDetail = true;\n\t\tif(lightRayDensity > 0.3){\n\t\t\tsampleDetail = false;\n\t\t}\n\t\t//Reduce density of clouds when looking towards the light for more luminous clouds.\n\t\tlightRayDensity += mix(1.0, 0.75, mu) * \n            clouds(p + lightDirection * float(j) * stepL, cloudHeight, sampleDetail);\n\t}\n\n\tfloat beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\n\t\n\t\n    //Return product of Beer's law and powder effect depending on the \n    //view direction angle with the light direction.\n\treturn mix(beersLaw * 2.0 * (1.0-(exp(-stepL*lightRayDensity*2.0))), beersLaw, 0.5+0.5*mu);\n}\n\n//Get the colour along the main view ray.\nvec3 mainRay(vec3 org, vec3 dir, vec3 lightDirection, \n             out float totalTransmittance, float mu, vec3 lightColour, float offset){\n    \n\t//Variable to track transmittance along view ray. \n    //Assume clear sky and attenuate light when encountering clouds.\n\ttotalTransmittance = 1.0;\n\n\t//Default to black.\n\tvec3 colour = vec3(0.0);\n    \n    //The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n    //The length of the intersection.\n    float totalDistance = 0.0;\n\n    //Determine if ray intersects bounding volume.\n\t//Set ray parameters in the cloud layer.\n\tbool renderClouds = getCloudIntersection(org, dir, distToStart, totalDistance);\n\n\tif(!renderClouds){\n\t\treturn colour;\n    }\n    \n    //Sampling step size.\n    float stepS = totalDistance / float(STEPS_PRIMARY); \n    \n    //Offset the starting point by blue noise.\n    distToStart += stepS * offset;\n    \n    //Track distance to sample point.\n    float dist = distToStart;\n\n    //Initialise sampling point.\n    vec3 p = org + dist * dir;\n    \n    vec3 moonLight = lightColour * power;\n\n   \t//Combine backward and forward scattering to have details in all directions.\n\tfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n\n\tfor(int i = 0; i < STEPS_PRIMARY; i++){\n\n        //Normalised height for shaping and ambient lighting weighting.\n        float cloudHeight;\n\n        //Get density and cloud height at sample point\n        float density = clouds(p, cloudHeight, true);\n\n        //Scattering and absorption coefficients.\n        float sigmaS = 1.0;\n        float sigmaA = 0.0;\n\n        //Extinction coefficient.\n        float sigmaE = sigmaS + sigmaA;\n\n        float sampleSigmaS = sigmaS * density;\n        float sampleSigmaE = sigmaE * density;\n\n        //If there is a cloud at the sample point.\n        if(density > 0.0 ){\n\n            //Constant lighting factor based on the height of the sample point.\n            vec3 ambient = lightColour * mix((0.0), (0.2), cloudHeight);\n\n            //Amount of sunlight that reaches the sample point through the cloud \n            //is the combination of ambient light and attenuated direct light.\n            vec3 luminance = 0.2 * ambient + moonLight * phaseFunction * \n                \t\t\t lightRay(org, p, mu, lightDirection);\n\n            //Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            //Beer-Lambert.\n            float transmittance = exp(-sampleSigmaE * stepS);\n\n            //Better energy conserving integration\n            //\"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            //by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            //Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            //If ray combined transmittance is close to 0, nothing beyond this sample \n            //point is visible, so break early.\n            if(totalTransmittance <= 0.01){\n                totalTransmittance = 0.0;\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t//Step along ray.\n\t\tp = org + dir * dist;\n\t}\n\n\treturn colour;\n}\n\n//From Scratchpixel\n//Assume normalised vectors.\nbool getPlaneIntersection(vec3 org, vec3 ray, vec3 planePoint, vec3 normal, out float t){\n    float denom = dot(normal, ray); \n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - org; \n        t = dot(p0l0, normal) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\n//Get the moon texture.\nvec3 getMoon(vec3 cameraPos, vec3 rayDir, vec3 moonDirection, out bool covered){\n    \n    vec2 uv = vec2(0);\n    covered = false;\n    \n    //Get the texture coordinates.\n    //The moon is a disk on a plane perpendicular to the moon direction vector. \n    //The texture coordinates of this plane are two perpendicular vectors u and v \n    //which are also perpendicular to the plane normal.\n    //As the moon is always facing the camera, we want u to be tangent to constant latitudes\n    //and v to be tangent to constant longitudes. We first find the point p0 that\n    //defines the plane. We then find a point p1 where a ray r1 offset in elevation \n    //from the moon direction r0 hits the moon plane. Vector v is then the normalised vector \n    //p1-p0 and u can be found by cross(r0, v).\n    \n    vec3 p0 = cameraPos + moonDirection * moonDistance;\n    vec3 offsetDir = normalize(vec3(cos(moonLocation), moonHeight+0.01, sin(moonLocation)));\n\n    float t = 0.0;\n    getPlaneIntersection(cameraPos, offsetDir, p0, moonDirection, t);\n    \n    vec3 p1 = cameraPos + offsetDir * t;\n    vec3 v = normalize(p1-p0);\n    vec3 u = normalize(cross(moonDirection, v));\n    \n    if(getPlaneIntersection(cameraPos, rayDir, p0, moonDirection, t)){\n    \t//Where view ray hits the plane.\n        vec3 p = cameraPos + rayDir * t;\n        \n        //Is point larger than the specified radius.\n        if(length(p - p0) > moonSize){\n        \treturn vec3(0);\n        }\n        \n        uv = vec2(dot(p, u), dot(p, v));\n        uv /= (2.0*moonSize);\n        \n        covered = true;\n    \treturn texture(iChannel1, uv+0.5).aaa;\n    }\n   \n\treturn vec3(0);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(55.0, fragCoord);\n   \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = vec3(-CLOUD_EXTENT*0.4, cloudEnd * 0.7, CLOUD_EXTENT*0.4);\n    vec3 targetDir = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n    //---------------------------------------------------\n    \n\t#ifdef ANIMATE_MOON\n    \tmoonLocation = moonLocation + moonSpeed * iTime;\n\t#endif\n    \n    vec3 lightDirection = normalize(vec3(cos(moonLocation), moonHeight, sin(moonLocation)));\n    \n    //Alignment of view and light directions.\n    float mu = 0.5+0.5*dot(rayDir, lightDirection);\n    \n  \tfloat offset = 0.0;\n    \n    #ifdef DITHERING\n    //Sometimes the blue noise texture is not immediately loaded into iChannel2\n    //leading to jitters.\n    if(iChannelResolution[2].xy == vec2(1024)){\n        //From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n        //Get blue noise for the fragment.\n        float blueNoise = texture(iChannel2, fragCoord / 1024.0).r;\n\n    \t//Blue noise texture is blue in space but animating it leads to white noise in time.\n        //Adding golden ratio to a number yields a low discrepancy sequence (apparently),\n    \t//making the offset of each pixel more blue in time (use fract() for modulo 1).\n        //https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n        offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n    }\n    #endif\n    \n    //Get sky colour and stars. \n    //Offset mu with blue noise to get rid of bands in the haze gradient.\n    vec3 background = getSkyColour(rayDir, 0.05*offset+mu);\n\n    if(mu > 0.85){\n        bool covered = false;\n        vec3 moonColour = getMoon(vec3(0), rayDir, lightDirection, covered);\n        if(covered){\n        \tbackground = moonColour;\n        }\n    }\n    \n    //Get the glow around the moon (without offsetting with blue noise).\n    background += lightColour * \n        saturate((getGlow(1.0-mu, 0.5*(1.0-cos(atan(moonSize/moonDistance))), 2.0)));\n    \n    \n\tfloat totalTransmittance = 1.0;\n\n    float exposure = 0.5;\n    vec3 colour = exposure * mainRay(cameraPos, rayDir, lightDirection, \n                                     totalTransmittance, dot(rayDir, lightDirection), lightColour, offset); \n\n    colour += background * totalTransmittance;\n   \n    //Tonemapping\n    colour = ACESFilm(colour);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n   \n    //Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set view direction.\n\n#define EPS 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(3.5, 2.5)*mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = max(-0.999, min(0.999, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer C\n        if(fragCoord == vec2(0.5, 0.5)){\n            //Set value at first frames\n            if(iFrame < 5){\n                newMouse = vec4(0.1, 0.07, 0.0, 0.0);\n                \n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store view direction in the second pixel of Buffer A\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information\n            vec3 targetDir = vec3(sin(newMouse.x), newMouse.y, -cos(newMouse.x));\n            fragColor = vec4(targetDir, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A\n        if(fragCoord == vec2(0.5, 2.5)){\n            \n            float resolutionChangeFlag = 0.0;\n            \n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Create a Perlin-Worley texture atlas for cloud shape carving.\n//Runs only once in the first frame.\n//Based on https://github.com/sebh/TileableVolumeNoise/blob/master/main.cpp\n\n//The atlas is a 6*6 grid of 32*32 tiles with a single layer of halo cells around each tile. \n\n//TODO: Assumes a size of at least 204*204. Make it work with any reasonable resolution.\n\n#define PERLIN_WORLEY 0\n#define WORLEY 1\n\nvec3 modulo(vec3 m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n#define SIZE 8.0\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = modulo(p3, SIZE);\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat gradientNoise(vec3 p){\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n    \n    /*\n    * For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u \n    * is an integer and g is in [-1, 1]. This is the equation for a line with slope g which \n    * intersects the x-axis at u.\n    * For N dimensional noise, use dot product instead of multiplication, and do \n    * component-wise interpolation (for 3D, trilinear)\n    */\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\n\nfloat getPerlinNoise(vec3 pos, float frequency){\n\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\n\tfor(int oct = 0; oct < 3; oct++){\n\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p);\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= 2.0;\n\t}\n\n\treturn saturate(sum / weightSum);\n}\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - (0.5 + 0.5 * hash(mod(tp, numCells)));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - saturate(d);\n}\n\n#define NUM_CELLS 2.0\n\n//Return the 3D coordinate corresponding to the 2D atlas uv coordinate.\nvec3 get3Dfrom2D(vec2 uv, float tileRows){\n    vec2 tile = floor(uv);\n    float z = floor(tileRows * tile.y + tile.x);\n    return vec3(fract(uv), z);\n}\n\nfloat getTextureForPoint(vec3 p, int type){\n\tfloat res;\n    if(type == PERLIN_WORLEY){\n        \n        //Perlin-Worley.\n        float perlinNoise = getPerlinNoise(p, SIZE);\n        res = perlinNoise;\n\n        //Special weights from example code.\n        float worley0 = worley(p, NUM_CELLS*2.0);\n        float worley1 = worley(p, NUM_CELLS*8.0);\n        float worley2 = worley(p, NUM_CELLS*14.0);\n\n        float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        res = remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n        \n\t}else{\n\n        //Worley\n        float worley0 = worley(p, NUM_CELLS);\n        float worley1 = worley(p, NUM_CELLS*2.0);\n        float worley2 = worley(p, NUM_CELLS*4.0);\n        float worley3 = worley(p, NUM_CELLS*8.0);\n\n        float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n\t\tfloat FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n\t\tfloat FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n        res = FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n\t}\n    \n\treturn res;\n}\n\nvoid setMoonTexture(vec2 fragCoord, inout vec4 col){\n    //Write moon texture to alpha channel.\n    vec2 uv_ = fragCoord/iResolution.xy;\n    vec2 uv = uv_;\n    vec3 p = vec3(uv, 0.0);\n    \n    //Mix some noises together for a blotchy texture.\n    float base = getPerlinNoise(p, 2.6);\n\tfloat worley = worley(p, 2.0);\n    col.a = saturate(remap(base, 0.45*worley, 1.0, 0.0, 1.0));;\n}\n\nvoid setCloudMap(vec2 fragCoord, inout vec4 col){\n    //Write cloud map in the blue channel.\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\n    //A constant height centre with raised edges like a shallow bowl.\n    float dist = 0.72;\n    uv *= 3.5;\n    dist = max(dist, smoothstep(0.0, 1.0, length(uv)));\n\n    col.b = dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    bool resolutionChanged = (texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x == 1.0);\n    \n    if(iFrame < 1 || length(texelFetch(iChannel1, ivec2(0), 0).rgba) == 0.0){\n       \tvec4 col = vec4(0);\n        \n        //32 with 1 pixel on either side.\n        float tileSize = 34.0;\n        float padWidth = 1.0;\n        float coreSize = tileSize - 2.0 * padWidth;\n        float tileRows = 6.0;\n        float tileCount = tileRows * tileRows;\n        vec2 tile = floor((fragCoord.xy - 0.5) / tileSize);\n\n        bool padCell = false;\n        if(mod(fragCoord.x, tileSize) == 0.5 || mod(fragCoord.x, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n        if(mod(fragCoord.y, tileSize) == 0.5 || mod(fragCoord.y, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n\n        bool startPadX = false;\n        bool endPadX = false;\n        bool startPadY = false;\n        bool endPadY = false;\n        if(fragCoord.x == tile.x * tileSize + 0.5){\n            startPadX = true;\n        }\n        if(fragCoord.y == tile.y * tileSize + 0.5){\n            startPadY = true;\n        }\n        if(fragCoord.x == (tile.x + 1.0) * tileSize - 0.5){\n            endPadX = true;\n        }\n        if(fragCoord.y == (tile.y + 1.0) * tileSize - 0.5){\n            endPadY = true;\n        }\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 pixel;\n        vec2 uv;\n        \n        if(!padCell){\n            pixel = fragCoord.xy - padWidth - padding;\n            uv = vec2(pixel.xy/coreSize);\n        }else{\n            pixel = fragCoord.xy - padWidth - padding;\n            if(startPadX){\n                pixel.x += coreSize;\t\n            }\n            if(startPadY){\n                pixel.y += coreSize;\t\n            }\n            if(endPadX){\n                pixel.x -= coreSize;\t\n            }\n            if(endPadY){\n                pixel.y -= coreSize;\t\n            }\n            uv = vec2(pixel.xy/coreSize);\n        }\n        \n        vec3 p_ = get3Dfrom2D(uv, tileRows);\n        vec3 p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l\n        float worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l\n        float worleyNoise = getTextureForPoint(p, WORLEY);\n        col.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, tileRows * tileRows);\n        p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l+1\n        worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l+1\n        worleyNoise = getTextureForPoint(p, WORLEY);\n        col.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        //Unused cells\n        if(gl_FragCoord.x > tileRows * tileSize || gl_FragCoord.y > tileRows * tileSize){\n            col = vec4(0);\n        }\n\n        setCloudMap(fragCoord, col);\n        setMoonTexture(fragCoord, col);\n\n    \tfragColor = col;\n        \n    }else{\n        \n        vec4 oldData = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgba;\n        \n        if(resolutionChanged){\n            setCloudMap(fragCoord, oldData);\n        \tsetMoonTexture(fragCoord, oldData);\n        }\n    \t\n        fragColor = oldData;\n        \n        \n    }\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2020 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI 2.0*PI\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n","name":"Common","description":"","type":"common"}]}