{"ver":"0.1","info":{"id":"7ddfWl","date":"1657478971","viewed":140,"name":"spinning wordcel (detailed)","username":"lahwran","description":"\noriginal: Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space\nmy modification: animating several dimensions of warping with sin(), to show additional dimensions of variation that are nearby in representation space","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractalcineshader"],"hasliked":0,"parentid":"tsXBzS","parentname":"fractal pyramid"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// if false, renders deeper into the fog. not slow on my 3090, good luck!\n#define LOW_QUALITY true\n\n// details of above:\n#define MARCH_STEPS (LOW_QUALITY ? 48. : 128.)\n#define MARCH_SLOWDOWN (LOW_QUALITY ? 1.5 : 3.)\n#define FOG_DENSITY (LOW_QUALITY ? 200. : 700.)\n\n\n// animate the animation: the speed speeds up and slows down over time\n#define GLOBAL_FREQ_DIVISOR (pow(2., 1.8*(sin(iTime/40.0))+6.0))\n//#define DISTANCE_BIAS_MODULATION 1.0\n#define DISTANCE_BIAS_MODULATION (4.*(1.0-0.5*(   sin(iTime*min(20./GLOBAL_FREQ_DIVISOR, 30.0))   -0.5)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 palette(float d){\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    // INNERMOST CORE HERE: here's where we do the matrix multiply. it's a rotation!\n    return p*mat2(c,s,-s,c);\n}\n\nfloat distance_map(vec3 point3d){\n    // number of fold iterations to do. animated by time: 4, 8, 12, 16.\n    int foldcount = 4 + (int(iTime/6.) & 3) * 4;\n    // each fold iter, get current \n    for( int iter = 0; iter<foldcount; ++iter){\n        float t = sin(iTime*0.003*(1.0+0.3*sin(iTime*0.01))*float(iter))+sin(iTime*0.01)*float(iter)+iTime*0.02;\n        point3d.xz =rotate(point3d.xz,t);\n        point3d.xy =rotate(point3d.xy,t*1.89);\n        point3d.xz =abs(point3d.xz);\n        point3d.xz-=.5;\n\t}\n\treturn dot(sign(point3d),point3d)/5.;\n}\n\nvec4 raymarch (vec3 ray_origin, vec3 ray_direction){\n    // Trace, starting from 0 distance from camera...\n    float trace = 0.; // trace: distance from camera to querypoint\n    vec3 col = vec3(0.);\n    // keeping track of how close we are to the surface of the 3d object...\n    float distnce;\n    for(float i =0.; i<MARCH_STEPS; i++){\n        // for 64 steps of tracing, check querypoints...\n\t\tvec3 querypoint = ray_origin + ray_direction*trace;\n        // ...and get the distance from each querypoint on the ray to the object...\n        distnce = distance_map(querypoint);\n        // if we're close to the object, we hit it. \"close\" is animated, to show the volume of the object.\n        // The animation was hand tuned to be slow enough to perceive sometimes and way too fast other times,\n        // to build intuitions for different vision system neurons.\n        // sorry epileptics\n        if((distnce/DISTANCE_BIAS_MODULATION)<0.025){\n            break;\n        }\n        if(distnce>100.){\n        \tbreak;\n        }\n        // accumulate fog as we march.\n        col+=palette(length(querypoint)*.1)/(FOG_DENSITY*(distnce));\n        // jump forward by the current distance estimate: the key trick of the signed distance field tracing algorithm!\n        // cut the distance in half so we don't fuck up. Increases resolution a lot, but slower.\n        trace+=distnce/MARCH_SLOWDOWN;\n    }\n    return vec4(col,1./(distnce*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv: position in screenspace\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ray_origin = vec3(0.,0.,-50.);\n    ray_origin.xz = rotate(ray_origin.xz,iTime*0.1);\n    vec3 camera_forward = normalize(-ray_origin);\n    vec3 camera_sideways = normalize(cross(camera_forward,vec3(0.,1.,0.)));\n    vec3 camera_up = normalize(cross(camera_forward,camera_sideways));\n    \n    // universe_uv: position in 3d space\n    vec3 universe_uv = ray_origin+camera_forward*3. + uv.x*camera_sideways + uv.y*camera_up;\n    \n    vec3 ray_direction = normalize(universe_uv-ray_origin);\n    \n    vec4 col = raymarch(ray_origin,ray_direction);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/","name":"Image","description":"","type":"image"}]}