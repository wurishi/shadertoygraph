{"ver":"0.1","info":{"id":"XllXWr","date":"1436242314","viewed":115,"name":"Tet shadows","username":"ryanmichael","description":"Moving tet that casts shadows","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadows","tet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Struct to bind bool toggle with an intersection point for geometry processing\nstruct iPoint\n{\n\tvec3 point;\n    vec3 normal;\n    bool intersected;\n};\n\n//P is ray initial point. d is ray direction. ABC are tri vertices\niPoint rayTriangleTest( vec3 P, vec3 d, vec3 A, vec3 B, vec3 C )\n{\n    iPoint returnPoint;\n    returnPoint.intersected = false;\n    \n\t//Cull faces where normals are opposing - make sure winding order is right\n\tvec3 triNorm = normalize(cross( B - A, C- A ));    \n\n    //Back face and parallel check\n    if( dot(d,triNorm) <= 0.0 )\n        return returnPoint;\n     \n    //Ray-plane intersection\n    float dPlane = dot(triNorm,A);\n    \n\tfloat t = (dPlane - dot(triNorm,P))/ dot(d,triNorm);\n    \n    //Plane intersection point\n    vec3 Q = P + t*d;\n    \n    float a = dot(triNorm,cross(B-A,Q-A));\n    float b = dot(triNorm,cross(C-B,Q-B));\n    float c = dot(triNorm,cross(A-C,Q-C));\n\n    if( a >= 0.0 && b >= 0.0 && c >= 0.0 )\n    {\n        returnPoint.point = Q;\n        returnPoint.normal = triNorm;\n        returnPoint.intersected = true;\n    }\n    \n    return returnPoint; \n}\n\n\n\nvec3 tetVert0 = vec3( 0.0, 0.0, 0.0);\nvec3 tetVert1 = vec3( 1.0, 0.0, 0.0);\nvec3 tetVert2 = vec3( 0.0, 1.0, 0.0);\nvec3 tetVert3 = vec3( 0.0, 0.0, 1.0);\n\nvec3 tetCenter = vec3( 0.25, 0.25, 0.25 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    //Scale matrix\n    mat4 S = mat4( iResolution.x/10.0, 0.0, 0.0, 0.0,\n                  \t0.0, iResolution.x/10.0, 0.0, 0.0,\n                  \t0.0, 0.0, iResolution.x/10.0, 0.0,\n                 \t0.0, 0.0, 0.0, 1.0);\n    \n    mat4 preT = mat4( 1.0, 0.0, 0.0, 0.0,\n                  \t0.0, 1.0, 0.0, 0.0,\n                  \t0.0, 0.0, 1.0, 0.0,\n                 \t- tetCenter.x, -tetCenter.y, -tetCenter.z, 1.0);\n    \n    float r1Rotate = 0.3 * iTime;\n    \n    mat4 R1 = mat4( cos(r1Rotate), -sin(r1Rotate), 0.0, 0.0,\n                   \tsin(r1Rotate), cos(r1Rotate), 0.0, 0.0,\n                   0.0, 0.0, 1.0, 0.0,\n                   0.0, 0.0, 0.0, 1.0 );\n    \n    float r2Rotate = 0.5 * iTime;\n   \n    \n    mat4 R2 = mat4( cos(r2Rotate), 0.0, -sin(r2Rotate), 0.0,\n                   0.0, 1.0, 0.0, 0.0,\n                   \tsin(r2Rotate), 0.0, cos(r2Rotate), 0.0,\n                   0.0, 0.0, 0.0, 1.0 );    \n    \n    mat4 postT = mat4( 1.0, 0.0, 0.0, 0.0,\n                  \t0.0, 1.0, 0.0, 0.0,\n                  \t0.0, 0.0, 1.0, 0.0,\n                 \tiResolution.x/2.0, iResolution.y/2.0, iResolution.x/4.0*sin(iTime), 1.0);\n\n\ttetVert0 = (postT * R2 * R1 * S * preT * vec4( tetVert0, 1.0)).xyz;\n\ttetVert1 = (postT * R2 * R1 * S * preT * vec4( tetVert1, 1.0)).xyz;\n\ttetVert2 = (postT * R2 * R1 * S * preT * vec4( tetVert2, 1.0)).xyz; \n    tetVert3 = (postT * R2 * R1 * S * preT * vec4( tetVert3, 1.0)).xyz;\n \n    \n    \n    //World space position of background canvas\n\tvec3 canvas = vec3( fragCoord.x, fragCoord.y, -iResolution.x/2.0 );\n        \n    //Camera position\n    vec3 cam = vec3( iResolution.x/2.0,iResolution.y/2.0, iResolution.x/2.0 );\n    \n    //Light source vectors\n    vec3 L1Pos = vec3( iResolution.x/4.0,iResolution.y/4.0, iResolution.x );\n    vec3 L1Color = vec3(0.6, 0.5, 0.5);\n    \n    vec3 L2Pos = vec3( iResolution.x,iResolution.y/2.0, iResolution.x/2.0 );\n    vec3 L2Color = vec3(0.5, 0.5, 0.6);        \n    \n    vec3 Lamb = vec3( 0.4 );\n    \n    //Tet colors\n    vec4 tetColor0 = vec4( 0.85, 0.85, 0.0, 1.0 );\n    vec4 tetColor1 = vec4( 0.0, 0.85, 0.85, 1.0 );\n    vec4 tetColor2 = vec4( 0.85, 0.0, 0.85, 1.0 );\n    vec4 tetColor3 = vec4( 0.75, 0.75, 0.75, 1.0 );\n\n    //Ray from canvas to camera\n    vec3 R = normalize( cam - canvas );\n    \n    bool intersects = false;\n\n    iPoint triTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );\n\n    if( triTest0.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest0.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest0.normal, L1 );\n        \n\n       \tvec3 V = normalize( cam - triTest0.point );\n        vec3 L2 = normalize( L2Pos - triTest0.point );\n        vec3 R2 = 2.0 * dot( triTest0.normal, L2 ) * triTest0.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor0;       \n   \n        return;\n    }\n  \n    iPoint triTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n  \n    if( triTest1.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest1.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest1.normal, L1 );\n\n        vec3 V = normalize( cam - triTest1.point );\n        vec3 L2 = normalize( L2Pos - triTest1.point );\n        vec3 R2 = 2.0 * dot( triTest1.normal, L2 ) * triTest1.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor1;        \n   \n        return;\n    }\n \n    iPoint triTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    \n    if( triTest2.intersected == true )\n    {\n        \n        \n        vec3 L1 = normalize( L1Pos - triTest2.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest2.normal, L1 );\n        \n       \tvec3 V = normalize( cam - triTest2.point );\n        vec3 L2 = normalize( L2Pos - triTest2.point );\n        vec3 R2 = 2.0 * dot( triTest2.normal, L2 ) * triTest2.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor2;\n                                                                    \n   \n        \n        return;\n    }\n    \n\n    iPoint triTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triTest3.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest3.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest3.normal, L1 );\n        \n        vec3 V = normalize( cam - triTest3.point );\n        vec3 L2 = normalize( L2Pos - triTest3.point );\n        vec3 R2 = 2.0 * dot( triTest3.normal, L2 ) * triTest3.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor3;        \n   \n        return;\n    }    \n  \n\n    //Shadows\n    \n    //First light\n    R = L1Pos - canvas;\n    iPoint triShadowTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );    \n    iPoint triShadowTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n    iPoint triShadowTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    iPoint triShadowTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triShadowTest0.intersected == true || \n       triShadowTest1.intersected == true ||\n       triShadowTest2.intersected == true || \n       triShadowTest3.intersected == true )\n    {\n        L1Color = vec3(0.0);\n    }\n    \n    //Second light\n    R = L2Pos - canvas;\n    triShadowTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );    \n    triShadowTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n    triShadowTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    triShadowTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triShadowTest0.intersected == true || \n       triShadowTest1.intersected == true ||\n       triShadowTest2.intersected == true || \n       triShadowTest3.intersected == true )\n    {\n        L2Color = vec3(0.0);\n    }    \n    \n    vec2 uv = vec2(fragCoord.x,-fragCoord.y) / iResolution.xy;\n    fragColor = texture( iChannel0, uv ) * vec4(L1Color + L2Color + Lamb,1.0);\n    \n    return;\n}","name":"","description":"","type":"image"}]}