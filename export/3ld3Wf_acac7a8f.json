{"ver":"0.1","info":{"id":"3ld3Wf","date":"1577808521","viewed":132,"name":"newYearJapan","username":"migizo","description":"happy new year 2020!!\n","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mlj3RR","filepath":"https://soundcloud.com/kawayoo/foq4p7be9z0s","previewfilepath":"https://soundcloud.com/kawayoo/foq4p7be9z0s","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BPM 140.0\n#define AUDIO_SEC_FIRSTBANG 0.5\n#define EPS 0.01\n\n/* Let's play iChannel0 audio*/\n\nconst vec3 white = vec3(0.92, 0.92, 0.9);\nconst vec3 blue = vec3(0, 0.5, 1);\nconst vec3 red = vec3(1, 0, 0);\n\nfloat audio_time = 0.0;\n\nvec3 bg_color = white;\nfloat perBeat4 = 60.0 / BPM;\nfloat beat4 = 0.0;\nfloat bar = 0.0;\nfloat fft;\n\nconst vec3 deltaX = vec3(EPS, 0, 0);\nconst vec3 deltaY = vec3(0, EPS, 0);\nconst vec3 deltaZ = vec3(0, 0, EPS);\n\n//---------------------------------------------\n// random\n//---------------------------------------------\nfloat random(vec2 uv){\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 uv){\n    uv = vec2( dot(uv,vec2(127.1,311.7)),\n                   dot(uv,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(uv)*43758.5453123);\n}\n\n//---------------------------------------------\n// noise\n//---------------------------------------------\nfloat blockNoise(vec2 uv, vec2 res) {\n    return random(floor(uv * res));\n}\n\nfloat valueNoise(vec2 uv, vec2 res) {\n    uv *= res;\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    float lb = random(iuv + vec2(0, 0));\n    float rb = random(iuv + vec2(1, 0));\n    float lt = random(iuv + vec2(0, 1));\n    float rt = random(iuv + vec2(1, 1));\n\n    vec2 u = fuv * fuv * (3.0 - 2.0 * fuv);\n    \n    float b = mix(lb, rb, u.x);\n    float t = mix(lt, rt, u.x);\n    return mix(b, t, u.y);\n}\n\nfloat perlinNoise(vec2 uv, vec2 res) {\n    uv *= res;\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec2 lb = random2(iuv + vec2(0, 0));\n    vec2 rb = random2(iuv + vec2(1, 0));\n    vec2 lt = random2(iuv + vec2(0, 1));\n    vec2 rt = random2(iuv + vec2(1, 1));\n\n    vec2 u = fuv * fuv * (3.0 - 2.0 * fuv);\n    \n    vec2 lb_dir = fuv - vec2(0, 0);\n    vec2 rb_dir = fuv - vec2(1, 0);\n    vec2 lt_dir = fuv - vec2(0, 1);\n    vec2 rt_dir = fuv - vec2(1, 1);\n\n    float b = mix(dot(lb, lb_dir), dot(rb, rb_dir), u.x);\n    float t = mix(dot(lt, lt_dir), dot(rt, rt_dir), u.x);\n    return mix(b, t, u.y) + 0.5;\n}\n\nfloat fbm(vec2 uv, vec2 res, int num) {\n    float f = 0.0;\n    float oct = 1.0;\n    float per = 0.5;\n    for (int i = 0; i < num; i++) {\n    \tf += per * perlinNoise(uv, res * oct);\n        per *= 0.5;\n        oct *= 2.0;\n    }\n    return f;\n}\n\n//---------------------------------------------\n// 2D shape\n//---------------------------------------------\nfloat rect(vec2 uv, vec2 pos, vec2 size, vec2 fade) {\n    float w;\n    w = smoothstep(size.x + fade.x, size.x, length(pos.x - uv.x));\n    w *= smoothstep(size.y + fade.y, size.y, length(pos.y - uv.y));\n\treturn w;\n}\n\nfloat circle(vec2 uv, vec2 pos, float radius, float fade) {\n    return smoothstep(radius + fade, radius, length(pos - uv));\n}\n\nfloat wave(vec2 uv, float line_width) {\n    line_width *= 0.5;\n   \tfloat fft = texelFetch( iChannel0, ivec2(uv.x * 512.0, 1), 0 ).x; \n     return step(fft-line_width, uv.y) * step(uv.y, fft+line_width);\n}\n\n//---------------------------------------------\n// distance functions (for ray marching)\n//---------------------------------------------\n\nfloat sdPlane(vec3 p){\n  vec4 n = vec4(0.0, 1.0, 0.0, 1.0);\n  float h = fbm(p.xz + vec2(iTime), vec2(0.2), 4) * fft * 5.0;\n  return dot(p - h, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 ) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ) {\n  p.y += iTime * 10.0;\n\n  p = mod(p, 24.0) - 12.0;\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n \nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat distFunc(vec3 p) {\n    float plane = sdPlane(p);\n    float cappedCone = sdCappedCone(p, 8.0, 10.0, 1.0);\n    float roundCone = sdRoundCone(p, 0.8, 0.5, 2.0);\n    float box = sdBox(p - vec3(0, 0, 10), vec3(100.0, 100.0, 100.0));\n    return min(plane, min(cappedCone, max(box, roundCone)));\n}\n\nvec3 distFuncNormal(vec3 p) {\n    \treturn normalize(vec3(distFunc(p + deltaX) - distFunc(p - deltaX),\n                          distFunc(p + deltaY) - distFunc(p - deltaY),\n                          distFunc(p + deltaZ) - distFunc(p - deltaZ)\n                         ));\n}\n\nvec3 distFuncColor(vec3 p, float dist) {\n    float plane = sdPlane(p);\n    float cappedCone = sdCappedCone(p, 8.0, 10.0, 1.0);\n    float box = sdBox(p - vec3(0, 0, 10), vec3(100.0, 100.0, 100.0));\n    float roundCone = sdRoundCone(p, 0.8, 0.5, 2.0);\n\n    if (abs(dist - plane) < EPS) {\n        return vec3(0.5, 1, 0);\n    }\n    else if (abs(dist - cappedCone) < EPS){\n        vec3 n = distFuncNormal(p);\n        return (p.y + sin(p.x * 5.0) * 0.5 * fft > 5.0) ? white : blue;\n    }\n    else if(abs(dist - roundCone) < EPS) {\n        return vec3(0.3, 0, 0.3);\n    }\n}\n\nfloat genShadow(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t = 0.0; t < 50.0; t++){\n        h = distFunc(ro + rd * c);\n        if(h < 0.001){\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 color = bg_color;\n    \n    vec3 light_pos = vec3(5, 2, -5);\n    \n    float depth = 0.0;\n    const int maxRayStep = 128;\n    for (int i = 0; i < maxRayStep; i++) {\n    \tfloat dist = distFunc(ro);\n        if (dist < EPS) {\n            vec3 light_dir = normalize(light_pos - vec3(0));\n            vec3 normal = distFuncNormal(ro);\n      \t\tcolor = vec3(dot(normal, light_dir)) * distFuncColor(ro, dist);\n        }\n        depth += dist;\n        ro += rd * dist;   \n    }\n    return color;\n}\n\n//---------------------------------------------\n// main\n//---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iChannelTime[0] < AUDIO_SEC_FIRSTBANG) audio_time = 0.0;\n    else audio_time = iChannelTime[0] - AUDIO_SEC_FIRSTBANG;\n        \n    vec2 uv1 = (fragCoord.xy * 2.0 - iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec2 uv0 = uv1 * 0.5 +0.5;\n        \n    beat4 = mod(audio_time, perBeat4) * (1.0 / perBeat4);\n    bar = mod(audio_time, perBeat4 * 4.0) * (1.0 / (perBeat4 * 4.0));\n    float perBar = perBeat4 * 4.0;\n\n    int camera_num = 4;\n    int camera_id = int(floor(mod(audio_time, perBeat4 * 4.0 * float(camera_num)) / perBeat4 / float(camera_num)));\n\tfft = texelFetch( iChannel0, ivec2(uv0.x * 512.0, 1), 0 ).x; \n\n    float noiseAmount = fft * 0.1;\n    \n    vec3 col;\n    float theta = (atan(uv1.y, uv1.x) + 3.1412) / 6.2824;\n    theta = fract(theta + bar);\n    float sun_circle = step(length(vec2(0.5) - uv0), 0.2 + 0.02 * fft);\n    float sun_shower = floor(fract(theta * 5.0) * 2.0);\n    bg_color = (sun_circle + sun_shower) > 0.5 ? red : white;\n\n    // intro\n    vec3 target_pos = vec3(0, 8, 0);\n    vec3 camera_pos_0 = vec3(0, 5, -30);\n    vec3 camera_pos_1 = vec3(10, 5, -20);\n    vec3 camera_pos_2 = vec3(0, 2, -50);\n    vec3 camera_pos_3 = vec3(0, 20, -20);\n\n    vec3 camera_pos = camera_pos_0;\n\t\n    if (camera_id == 0) {\n \t\tfloat f1 = fbm(uv0 + vec2(0), vec2(2), 1);\n        float f2 = fbm(uv0 + vec2(5.34, 3.35) + 4.0 * f1 + iTime, vec2(2), 1);\n\n        float f3 = fbm(uv0 + f2 * 4.0, vec2(2.0), 1);\n        f3 = f3 * f3 * f3 + f3 * f3 * 0.6 + f3 * 0.5;\n        uv1.y += pow(f3 + fft, 1.0) * bar * 2.0;\n\n    }\n    \n    if (audio_time < perBar) {\n        col = mix(white, red, circle(uv0, vec2(0.5),  0.05, beat4 * fft * 0.05));\n    }\n    else {\n        if (camera_id == 0) camera_pos = mix(camera_pos_0, camera_pos_1, bar);\n        if (camera_id == 1) camera_pos = mix(camera_pos_1, camera_pos_2, bar);\n        if (camera_id == 2) camera_pos = mix(camera_pos_2, camera_pos_3, bar);\n        if (camera_id == 3) camera_pos = mix(camera_pos_3, camera_pos_0, bar);  \n        \n        vec3 camera_dir = normalize(target_pos - camera_pos);\n        vec3 camera_up = normalize(cross(camera_dir, vec3(1, 0, 0)));\n        vec3 camera_right = normalize(cross(camera_dir, camera_up));\n\n        vec3 ray_pos = camera_pos;\n        vec3 ray_dir = normalize(camera_dir + uv1.x * camera_right + uv1.y * camera_up);\n\n        col = trace(ray_pos, ray_dir);\n    }\n\n    if (camera_id == 2) col = vec3(1.0) - col;\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}