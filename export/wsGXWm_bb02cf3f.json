{"ver":"0.1","info":{"id":"wsGXWm","date":"1574165972","viewed":639,"name":"Stereographic projection","username":"tomoe","description":"The sphere without the top point is projected onto the complex plane. The deformation is given by moebius transformation.","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","moebiustransformation","complexfunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define EPSILON 1e-2\n#define INFTY 1e6\n\n// complex numbers\nconst vec2 c1 = vec2(1.0, 0.0); //1\nconst vec2 c0 = vec2(0.0); //0\n\nconst float sphereSize = 1.0;\n\n// coordinate change \nvec2 xy2pol(vec2 z) {   //(Re(z),Im(z))->(arg,rad)\n    return vec2(atan(z.x, z.y), length(z));\n}\nvec2 pol2xy(vec2 z) {   //(arg,rad)->(Re(z),Im(z))\n    return vec2(z.y * cos(z.x), z.y * sin(z.x));\n}\n\n// operations of complex numbers\nvec2 cMult(vec2 z, vec2 w) {    //z*w\n    return vec2(z.x * w.x - z.y * w.y, z.y * w.x + z.x * w.y);\n}\nvec2 cPow(vec2 z, float n) {    //z^n\n    z = xy2pol(z);\n    z = vec2(n * z.x, pow(z.y, n));\n    return pol2xy(z);\n}\nvec2 cConj(vec2 z) {    //bar{z}\n    return vec2(z.x, - z.y);\n}\nvec2 cInv(vec2 z) { //z^{-1}\n    return (1.0 / pow(length(z), 2.0)) * cConj(z);\n}\n\n// geometry\nfloat sphereSDF(vec3 p) {\n    return length(p) - sphereSize ;\n}\nfloat planeSDF(vec3 p) {\n    return abs(p.y);\n}\nfloat sceneSDF(vec3 p) {\n    return min(planeSDF(p), sphereSDF(p));\n}\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nfloat hitSphere(vec3 camPos, vec3 ray) {\n    return length(camPos) * sin(getAngle( - camPos, ray)) - sphereSize;\n}\nfloat hitPlane(vec3 camPos, vec3 ray) {\n    return dot(vec3(0.0, 1.0, 0.0), ray);\n}\nfloat hitScene(vec3 camPos, vec3 ray) {\n    return min(hitPlane(camPos, ray), hitSphere(camPos, ray));\n}\nfloat getDist2Plane(vec3 camPos, vec3 ray) {\n    float ang = getAngle(vec3(0.0, - 1.0, 0.0), ray);\n    float dist = abs(camPos.y);\n    if (hitPlane(camPos, ray) < 0.0) {\n        return dist / cos(ang);\n    } else {\n        return INFTY;\n    }\n}\nfloat getDist2Sphere(vec3 camPos, vec3 ray) {\n    float ang = getAngle( - camPos, ray);\n    float dist = length( - camPos);\n    if (hitSphere(camPos, ray) < 0.0) {\n        return dist * cos(ang) - sqrt(pow(dist * cos(ang), 2.0) - pow(dist, 2.0) + pow(sphereSize, 2.0));\n    } else {\n        return INFTY;\n    }\n}\nfloat getDist2Scene(vec3 camPos, vec3 ray) {\n    return min(getDist2Plane(camPos, ray), getDist2Sphere(camPos, ray));\n}\nvec3 getNormal(vec3 p) {\n    float d = EPSILON;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p)\n    ));\n}\nmat3 rotX(float theta) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(theta), cos(theta),\n        0.0, - cos(theta), sin(theta)\n    );\n}\nmat3 rotY(float theta) {\n    return mat3(\n        sin(theta), 0.0, cos(theta),\n        0.0, 1.0, 0.0,\n        - cos(theta), 0.0, sin(theta)\n    );\n}\nfloat fct(vec2 z) {    \n    return pow(cos(z.x * PI), 2.0) + pow(sin(z.y * PI), 2.0);\n}\n// fct(x+iy)=cos^2(x*PI)+sin^2(y*PI)\n// cases where 1<value<2\n// 0<x<0.5: x<y<1-x or 1+x<y<2-x \n// 0.5<x<1: 1-x<y<x or 2-x<y<1+x\n// 1<x<1.5: x<y<3-x or x-1<y<2-x\n// 1.5<x<2: x-1<y<x or 2-x<y<x-1\n\nvec2 moebius(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) {\n    return cMult((cMult(a, z) + b), (cMult(c, z) + d));\n}\n// moebius(a,b,c,d,z)=(az+b)/(cz+d)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // fragment position\n    vec2 pixPos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 camPos = vec3(0.0, 0.0, 1.9);\n    vec3 camDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camSide = cross(camDir, camUp);\n    float targetDepth = 1.0;\n    float theta = 3.2 * PI / 4.0;\n    camPos = rotX(theta) * camPos;\n    camDir = rotX(theta) * camDir;\n    camUp = rotX(theta) * camUp;\n    \n    // ray\n    vec3 ray = normalize(camSide * pixPos.x + camUp * pixPos.y + camDir * targetDepth);\n\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);;\n    if (hitScene(camPos, ray) < 0.0) {\n        vec3 rayPos = camPos + getDist2Scene(camPos, ray) * ray;\n        vec3 top = vec3(0.0, sphereSize, 0.0);\n        vec3 top2Sph = rayPos- top ;\n        float ang = getAngle( - top, top2Sph);\n        vec3 planePos = sphereSize / (length(top2Sph) * cos(ang)) * top2Sph;\n        float t = 0.5 * iTime;\n        vec2 a = pol2xy(vec2(0.5 * t, 0.5 + 0.47 * sin(t)));\n        vec2 b = c1 * cos(t);\n        vec2 c = c0;\n        vec2 d = c1;\n        \n        fragColor = mix(\n            vec4(vec3(0.0), 1.0),\n            vec4(1.0), \n            step(1.0, fct(moebius(a, b, c, d, planePos.xz))));\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } \n}","name":"Image","description":"","type":"image"}]}