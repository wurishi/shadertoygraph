{"ver":"0.1","info":{"id":"MfGSRz","date":"1714851034","viewed":86,"name":"Delaunay via natural neighbours","username":"mrboggieman","description":"Creation of Voronoi and Delaunay mesh via natural neighbours (closest points that contribute to the Voronoi cell divisions). Drag mouse to control one of the points.\nKeys:\n '1' - toggle Voronoi Mesh\n '2' - toggle Delaunay Mesh\n '3' - toggle fill","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["voronoi","delaunay","naturalneighbours"],"hasliked":0,"parentid":"Mf3SDs","parentname":"Voronoi via natural neighbours"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This example works by forming Voronoi cells for each point via polygon splitting\n// Extension of https://www.shadertoy.com/view/MfGSRz\n// Each pixel then finds the nearest point and their neighbours and the closest lines are draw\n// Note: the Delaunay mesh may not contain the convex hull mesh lines, it is based solely on the Voronoi\n\n// utils\nconst float EPSILON = 0.0001;\n\nstruct Line {\n   vec2 a;\n   vec2 b;\n};\n\nfloat det2(in vec2 a, in vec2 b) {\n    //return (a.x * b.y) - (a.y * b.x);\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closestPointOnLine(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nbool pointInsideLine(in Line line, in vec2 pos) {\n    return det2(pos - line.a, line.b - line.a) < 0.0;\n}\n\nint intersectLines(in Line line1, in Line line2, out vec2 collision) {\n    float c = det2(line1.a, line1.b);\n    float d = det2(line2.a, line2.b);\n    float e = det2(line1.a - line1.b, line2.a - line2.b);\n\n    if (abs(e) < EPSILON) {\n        return 0;\n    }\n\n    collision = vec2(\n        det2(vec2(c, line1.a.x - line1.b.x), vec2(d, line2.a.x - line2.b.x)) / e,\n        det2(vec2(c, line1.a.y - line1.b.y), vec2(d, line2.a.y - line2.b.y)) / e\n    );\n\n    // ensure the collision point is in the 0-1 range of our line (must be more efficient way of doing this)\n    if ((dot(collision - line1.a, line1.b - line1.a) < -EPSILON) || (distance(collision, line1.a) > distance(line1.a, line1.b) + EPSILON)) {\n        return 0;\n    }\n\n    return int(sign(e));\n}\n\nfloat distanceToLine(in Line line, in vec2 pos) {\n    return distance(closestPointOnLine(line, pos), pos);\n}\n\nfloat distanceToLineSegment(in Line line, in vec2 pos) {\n    return distance(clamp(closestPointOnLine(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\n// DEMO\nstruct Point {\n    vec2 pos;\n    vec3 colour;\n};\n\nPoint[] points = Point[](\n  Point(vec2(0.25, 0.25), vec3(0.9, 0.1, 0.3)),\n  Point(vec2(1.5, 0.25), vec3(0.1, 0.9, 0.2)),\n  Point(vec2(0.75, 0.25), vec3(0.9, 0.8, 0.2)), \n  Point(vec2(1.25, 0.5), vec3(0.1, 0.2, 1.0)),\n  Point(vec2(0.9, 0.8), vec3(0.8, 0.3, 0.4)),\n  Point(vec2(0.75, 0.5), vec3(0.9, 0.1, 0.7)),\n  Point(vec2(1.25, 0.75), vec3(0.9, 0.7, 0.6)),\n  Point(vec2(0.5, 0.75), vec3(0.3, 0.4, 0.2)),\n  Point(vec2(1.1, 0.15), vec3(0.7, 0.4, .2))\n);\n\nconst int NUM_POINTS = points.length();\n\nconst int MAX_LINES = NUM_POINTS; // limit of the number of lines in each voronoi cell polygon\n\nconst float LINE_THICKNESS = 0.0015;\nconst float VERTEX_SIZE = 0.02;\nconst float VERTEX_FILL_SIZE = 0.015;\n\nstruct AreaLine {\n    Line line;\n    int index;\n};\n\nstruct LineVec {\n    AreaLine[MAX_LINES] lines;\n    int count;\n};\n\n// this methods cuts lines up and produces a new polygon with the cutting line\n// line segments on the negative side of the line are discarded\n// note: the order of lines is not preserved, the cutting line direction is inverted\nLineVec slicePolygon(in LineVec lines, in AreaLine cutting_line) {\n    AreaLine[MAX_LINES] new_lines;\n    int num_new_lines = 0;\n    vec2 in_point;\n    vec2 out_point;\n    bool has_in_point;\n    bool has_out_point;\n    \n    for (int i=0; i<lines.count; i++) {\n        vec2 intersection;\n        AreaLine line = lines.lines[i];\n        int dir = intersectLines(line.line, cutting_line.line, intersection);\n\n        switch (dir) {\n            case 0:\n                // determine if the line is inside or outside by checking the center of the line\n                if (!pointInsideLine(cutting_line.line, mix(line.line.a, line.line.b, 0.5))) {\n                    new_lines[num_new_lines] = line;\n                    num_new_lines++;\n                }\n                break;\n            case -1:\n                // break the line into two keeping the first part\n                new_lines[num_new_lines] = AreaLine(Line(line.line.a, intersection), line.index);\n                num_new_lines++;\n                \n                in_point = intersection;\n                has_in_point = true;\n                break;\n            case 1:\n                // break the line into two keeping the second part\n                new_lines[num_new_lines] = AreaLine(Line(intersection, line.line.b), line.index);\n                num_new_lines++;\n\n                out_point = intersection;\n                has_out_point = true;\n                break;\n        }\n    }\n    \n    if (has_in_point && has_out_point) {\n        new_lines[num_new_lines] = AreaLine(Line(in_point, out_point), cutting_line.index);\n        num_new_lines++;\n    }\n\n    return LineVec(new_lines, num_new_lines);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float pixel_size = 1.5/iResolution.y;\n\n    // allow dragging one of the points\n    if (length(iMouse.xy) > 10.0) {\n        points[4].pos = iMouse.xy / iResolution.y;\n    }\n    \n    // find the closest point index\n    vec2 closest;\n    float closest_distance = 2.0;\n    int closest_index = 0;\n\n    for (int i=0; i<NUM_POINTS; i++) {\n        vec2 pos = points[i].pos;\n        float dist = distance(uv, pos);\n        \n        if (dist < closest_distance) {\n            closest = pos;\n            closest_distance = dist;\n            closest_index = i;\n        }\n    }\n    \n    vec3 col = vec3(0.5);\n\n    // fill the voronoi cell (can just use the closest index for this)\n    if (texelFetch(iChannel0, ivec2(51, 2), 0).r < 1.0) {\n        col = points[closest_index].colour;\n    }\n    \n    //draw the points as dots with the fill colour\n    for (int i=0; i<NUM_POINTS; i++) {\n        Point point = points[i];\n        \n        col = mix(col, vec3(0.0), smoothstep(pixel_size, 0.0, distance(point.pos, uv) - VERTEX_SIZE));\n        col = mix(col, point.colour, smoothstep(pixel_size, 0.0, distance(point.pos, uv) - VERTEX_FILL_SIZE));\n    }\n\n    float width = iResolution.x/iResolution.y;\n    float height = 1.0;\n\n    vec2[] vertices = vec2[](\n        vec2(0.0, 0.0),\n        vec2(0.0, height),\n        vec2(width, height),\n        vec2(width, 0.0)\n    );\n\n    // for the voronoi cell shape clip with all of the points tangents\n    LineVec voronoi_lines;\n    voronoi_lines.count = 4;\n    voronoi_lines.lines[0] = AreaLine(Line(vertices[0], vertices[1]), -1);\n    voronoi_lines.lines[1] = AreaLine(Line(vertices[1], vertices[2]), -1);\n    voronoi_lines.lines[2] = AreaLine(Line(vertices[2], vertices[3]), -1);\n    voronoi_lines.lines[3] = AreaLine(Line(vertices[3], vertices[0]), -1);\n\n    for (int i = 0; i < NUM_POINTS; i++) {\n        //create a line to split the voronoi cell using the line tangent\n        vec2 pos = mix(points[i].pos, closest, 0.5);\n        vec2 tangent_dir = vec2(pos.y - closest.y, closest.x - pos.x);\n        AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), i);\n\n        // slice the voronoi by the tangent of the neighbour\n        voronoi_lines = slicePolygon(voronoi_lines, split_line);\n    }\n\n    // draw the lines of the voronoi cell\n    if (texelFetch(iChannel0, ivec2(49, 2), 0).r < 1.0) {\n        for (int i=0; i<voronoi_lines.count; i++) {\n            Line line = voronoi_lines.lines[i].line;\n            col = mix(col, vec3(0.0), smoothstep(pixel_size, 0.0, distanceToLineSegment(line, uv) - LINE_THICKNESS));\n        }\n    }\n    \n    // for drawing the delaunay triangulation will need to check primary and secondary neighbours\n    if (texelFetch(iChannel0, ivec2(50, 2), 0).r < 1.0) {\n        for (int i=0; i<voronoi_lines.count; i++) {\n            int index = voronoi_lines.lines[i].index;\n            \n            // skip boundary line\n            if (index == -1) {\n                continue;\n            }\n            \n            Point neighbour = points[index];\n            \n            // create the voronoi for the neighbour\n            LineVec neighbour_voronoi_lines;\n            neighbour_voronoi_lines.count = 4;\n            neighbour_voronoi_lines.lines[0] = AreaLine(Line(vertices[0], vertices[1]), -1);\n            neighbour_voronoi_lines.lines[1] = AreaLine(Line(vertices[1], vertices[2]), -1);\n            neighbour_voronoi_lines.lines[2] = AreaLine(Line(vertices[2], vertices[3]), -1);\n            neighbour_voronoi_lines.lines[3] = AreaLine(Line(vertices[3], vertices[0]), -1);\n\n            for (int j = 0; j < NUM_POINTS; j++) {\n                //create a line to split the voronoi cell using the line tangent\n                vec2 pos = mix(points[j].pos, neighbour.pos, 0.5);\n                vec2 tangent_dir = vec2(pos.y - neighbour.pos.y, neighbour.pos.x - pos.x);\n                AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), j);\n\n                // slice the voronoi by the tangent of the neighbour\n                neighbour_voronoi_lines = slicePolygon(neighbour_voronoi_lines, split_line);\n            }\n\n            // we need to go through all of the lines of the other neighbours\n            for (int j=0; j<neighbour_voronoi_lines.count; j++) {\n                int secondary_index = neighbour_voronoi_lines.lines[j].index;\n                \n                // skip boundary line\n                if (secondary_index == -1) {\n                    continue;\n                }\n\n                Line secondary_line = Line(neighbour.pos, points[secondary_index].pos);\n                \n                col = mix(col, vec3(1.0), smoothstep(pixel_size, 0.0, distanceToLineSegment(secondary_line, uv) - LINE_THICKNESS));\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}