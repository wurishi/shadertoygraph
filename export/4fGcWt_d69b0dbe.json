{"ver":"0.1","info":{"id":"4fGcWt","date":"1732511926","viewed":33,"name":"Diamond-Wave-Test","username":"adras","description":"Diamond-Wave-Test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= vec2(0.5, 0.5); // Center the coordinates\n    uv.x *= iResolution.x / iResolution.y; // Correct for aspect ratio\n    uv *= 2.0;\n\n    // Parameters for wave oscillations\n    float freqMultiplier = 20.0;\n    float timeMultiplier = 8.0;\n    float time = iTime;\n\n    // Rotation angles for 3 axes\n    float angleX = time * 0.0+3.14/2.0+0.13; // Rotation around X-axis\n    float angleY = time * 0.0; // Rotation around Y-axis\n    float angleZ = time * 0.0; // Rotation around Z-axis\n\n    // Define 3D vertices for the double pyramid\n    vec3 vertices[6];\n    vertices[0] = vec3(-0.5, -0.5, 0.0); // Bottom-left of the base\n    vertices[1] = vec3(0.5, -0.5, 0.0);  // Bottom-right of the base\n    vertices[2] = vec3(0.5, 0.5, 0.0);   // Top-right of the base\n    vertices[3] = vec3(-0.5, 0.5, 0.0);  // Top-left of the base\n    vertices[4] = vec3(0.0, 0.0, 1.0);   // Top apex\n    vertices[5] = vec3(0.0, 0.0, -1.0);  // Bottom apex\n\n    // Rotation matrices\n    mat3 rotateX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angleX), -sin(angleX),\n        0.0, sin(angleX), cos(angleX)\n    );\n\n    mat3 rotateY = mat3(\n        cos(angleY), 0.0, sin(angleY),\n        0.0, 1.0, 0.0,\n        -sin(angleY), 0.0, cos(angleY)\n    );\n\n    mat3 rotateZ = mat3(\n        cos(angleZ), -sin(angleZ), 0.0,\n        sin(angleZ), cos(angleZ), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    // Apply rotations to all vertices\n    for (int i = 0; i < 6; i++) {\n        vertices[i] = rotateZ * (rotateY * (rotateX * vertices[i]));\n    }\n\n    // Perspective projection: flatten 3D to 2D\n    vec2 projectedVertices[6];\n    for (int i = 0; i < 6; i++) {\n        float perspective = 1.0 / (1.5 - vertices[i].z); // Simple perspective factor\n        projectedVertices[i] = vertices[i].xy * perspective;\n    }\n\n    // Flattened edge array (pairs of vertices)\n    vec2 edges[24];\n    edges[0] = projectedVertices[0]; edges[1] = projectedVertices[4]; // Base to top apex\n    edges[2] = projectedVertices[1]; edges[3] = projectedVertices[4];\n    edges[4] = projectedVertices[2]; edges[5] = projectedVertices[4];\n    edges[6] = projectedVertices[3]; edges[7] = projectedVertices[4];\n    edges[8] = projectedVertices[0]; edges[9] = projectedVertices[5]; // Base to bottom apex\n    edges[10] = projectedVertices[1]; edges[11] = projectedVertices[5];\n    edges[12] = projectedVertices[2]; edges[13] = projectedVertices[5];\n    edges[14] = projectedVertices[3]; edges[15] = projectedVertices[5];\n    edges[16] = projectedVertices[0]; edges[17] = projectedVertices[1]; // Central square\n    edges[18] = projectedVertices[1]; edges[19] = projectedVertices[2];\n    edges[20] = projectedVertices[2]; edges[21] = projectedVertices[3];\n    edges[22] = projectedVertices[3]; edges[23] = projectedVertices[0];\n\n    // Draw wave-lines along the edges\n    float lineThickness = 0.02; // Thickness of the lines\n    float colorIntensity = 0.0; // Composite intensity for coloring\n\n    for (int i = 0; i < 24; i += 2) {\n        // Start and end points of the line segment\n        vec2 start = edges[i];\n        vec2 end = edges[i + 1];\n\n        // Parametric equation for the line\n        float t = dot(uv - start, normalize(end - start)) / length(end - start);\n\n        // Projection of uv onto the line\n        vec2 proj = mix(start, end, clamp(t, 0.0, 1.0));\n\n        // Distance from uv to the line\n        float dist = length(uv - proj);\n\n        // Add wave oscillation along the line\n        float wave = sin(freqMultiplier * t + timeMultiplier * time);\n        dist -= wave * lineThickness * 0.5; // Oscillating effect\n\n        // Accumulate color intensity for lines within thickness\n        colorIntensity += smoothstep(lineThickness, 0.0, dist);\n    }\n\n    // Final color based on wave intensity\n    fragColor = vec4(colorIntensity, colorIntensity * 0.5, 1.0 - colorIntensity, 1.0);\n}","name":"Image","description":"","type":"image"}]}