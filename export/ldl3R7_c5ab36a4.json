{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Built from the basics of'Clouds' Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Edited by NeoNusso into \"Cyclonic Sphere\"\n\n#define time (iTime + 23.0)\nconst vec3 backc_top=vec3(0.1,0.2,0.2);\nconst vec3 backc_bot=vec3(0.0,0.0,0.0);\nconst vec3 mainc=vec3(0.2,0.0,0.2);\nconst float timeScale = 0.2;\nconst float  PI = 3.14159265;\n/*math**********************************************/\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\nfloat fbm( vec3 p )\n{\n\tconst mat3 m = mat3( 0.00,  0.90,  0.60,\n              -0.90,  0.36, -0.48,\n              -0.60, -0.48,  0.34 );\n    float f;\n    f  = 1.300*noise( p ); p = m*p*2.02;\n    f += 0.7500*noise( p ); p = m*p*2.03;\n    f += 0.3000*noise( p ); p = m*p*2.01;\n    f += 0.0800*noise( p ); p = m*p*2.01;\n    return f;\n}\n/*shape**********************************************/\n// from https://iquilezles.org/articles/distfunctions\nfloat lengthSphere(vec3 v,float r)\n{\n\treturn length(v) - r;\n}\nvec3 opTwistY( vec3 p, float rad_twist)\n{\n    float c = cos(rad_twist*p.y);\n    float s = sin(rad_twist*p.y);\n    mat2  m = mat2(c,-s,s,c);\n\tvec2  xz = m*p.xz;\n    return  vec3(xz.x, p.y,xz.y );\n}\n//*Raymarching Functions***************************************************************/\n//====================\n// distanceFunction\n//====================\nfloat distanceFunction(vec3 p)\n{\n\treturn lengthSphere(p,3.6 ) ;\n}\n//Normal\nvec3 getNormal(vec3 p, float t)\n{\n\tfloat e = 0.001*t;\n    vec3  eps = vec3(e,0.0,0.0);\n    return -normalize( vec3(\n    \tdistanceFunction(p+eps.xyy) - distanceFunction(p-eps.xyy),\n\t\tdistanceFunction(p+eps.yxy) - distanceFunction(p-eps.yxy),\n\t\tdistanceFunction(p+eps.yyx) - distanceFunction(p-eps.yyx)\n\t\t));\n}\n//====================\n// 3dmap\n//====================\nvec4 map3d( in vec3 p )\n{\n\tfloat d = 0.2 - abs(p.y)*pow(length(p.xz),pow(abs(cos(time*timeScale)),0.5))*0.2;\n\n\tfloat f= fbm(p - vec3(.5,0.8,0.0)*iTime*4.0);\n\td += 4.0 * f;\n\td = clamp( d, 0.0, 1.0 );\n\t\n\treturn vec4( mix( vec3(0.4,0.1,0.1), \n\t\t\t\t  vec3(1.0,1.0,1.0),\n\t\t\t\t  d * 0.9), d);\n}\n//*Shading Functions*************************************************/\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n\tvec3 lightv=normalize(light-pt);\n\tfloat diffuse=dot(normal,lightv);\n\tvec3 refl=-reflect(lightv,normal);\n\tvec3 viewv=normalize(prp-pt);\n\tfloat rim = max(0.0, 1.0-dot(viewv,normal));\n\tfloat specular=pow(max(dot(refl,viewv),0.0),spec);\n\treturn (max(diffuse*0.5,0.0))*color+ambLight+specular;\n}\n//*Render Functions*************************************************/\nfloat raymarching(\n  in vec3 camPos,\n  in vec3 rayDir,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  out int objfound)\n{ \n\tconst vec3 e=vec3(0.1,0,0.0);\n\tfloat s=startf;\n\tvec3 c,p,n;\n\tfloat f=startf;\n\tobjfound=1;\n\tfor(int i=0;i<256;i++){\n\tif (abs(s)<precis||f>maxd||i>maxite) break;\n\t\tf+=s;\n\t\tp=camPos+rayDir*f;\n\t\ts=distanceFunction(p);\n\t}\n\tif (f>maxd) objfound=-1;\n\treturn f;\n}\n//RenderOpaque\nvec4 render(\n\tin vec3 camPos,\n\tin vec3 rayDir,\n\tin int maxite,\n\tin float precis,\n\tin float startf,\n\tin float maxd,\n\tin vec3 background,\n\tin vec3 light,\n\tin float spec,\n\tin vec3 ambLight)\n{ \n\n\tint objfound=-1;\n\tfloat f=raymarching(camPos,rayDir,maxite,precis,startf,maxd,objfound);\n\tif (objfound>0){\n\t\tvec3 p=camPos+rayDir*f;\n\t\tvec3 n = getNormal(p, f);\n\t\treturn \n\t\tvec4(\n\t\t\tphong(p,camPos,n,light,mainc,spec,ambLight),\n\t\t\tf);\n\t}\n\tf=maxd;\n\treturn vec4(background,f);\n}\n\n//RenderVolume\nvec4 renderRaymarchAccumulate( in vec3 camPos, in vec3 rayDir , vec4 base, float dstep)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tfloat f = 0.0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfor(int i=0; i<120; i++)\n\t{\n\t\tif (f > base.w || sum.a > 0.8 ) continue;\n\t\tp = camPos + f*rayDir;\n\t\tvec4 col = map3d( opTwistY( p,0.5*cos(time*timeScale))  );\n\t\tcol.a *= dstep;\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n    \tf += max(0.1,dstep*f);\n\t}\n\tsum.xyz /= (0.003+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n//*Camera Functions*************************************************/\nvec3 camera(\n  in vec3 camPos,\n  in vec3 camAt,\n  in vec3 camUp,\n  in float focus,\n  in vec2 pixel)\n{\n\tvec2 vPos=-1.0+2.0*pixel/iResolution.xy;\n\tvec3 camDir=normalize(camAt-camPos);\n\tvec3 u=normalize(cross(camUp,camDir));\n\tvec3 v=cross(camDir,u);\n\tvec3 scrCoord=camPos+camDir*focus+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n\treturn normalize(scrCoord-camPos);\n}\nvec3 prp_mouse(){\n\t float mx=iMouse.x/iResolution.x*PI*2.0;\n\t float my=-((iMouse.y+1.0)/iResolution.y*0.07 - 0.035)*PI;\n\t return vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; //Trackball style camera pos\n}\n//*Main***************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 camUp  =vec3(0,1,0);\n\tconst vec3 camAt  =vec3(0.0,0.0,0.0);\n\tconst float focus=1.5;\n\tvec3 camPos = camAt+prp_mouse()*2.0;\n\tvec3 rayDir= camera(camPos,camAt,camUp,focus,fragCoord);\n\tvec3 light= camPos+vec3(0.0,15.0,0.0);\n\n\tconst float maxe=0.01;\n\tconst float startf=0.1;\n\tconst float spec=8.0;\n\tconst vec3 ambi=vec3(0.0,0.2,0.2);\n\t\n\tfloat latitude = 0.5+0.5+rayDir.y;\n\tvec3 back =mix(backc_bot,backc_top,latitude*latitude);\n\n\tvec4 c1=render(camPos,rayDir,16,maxe,startf,40.0,back,light,spec,ambi);\n\tvec4 res = renderRaymarchAccumulate( camPos, rayDir, c1,0.03 );\n\t\n\tvec3 col = mix( c1.xyz, res.xyz, res.w*1.2);\n\tfragColor=vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldl3R7","date":"1366642898","viewed":1099,"name":"Cyclonic Sphere","username":"NeoNusso","description":"I wanted to express some strong stream.\nI got the idea from IQ's 'Clouds' and Dave_Hoskins's 'Star Nursery'.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}