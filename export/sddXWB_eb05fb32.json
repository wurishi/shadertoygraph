{"ver":"0.1","info":{"id":"sddXWB","date":"1633899428","viewed":108,"name":"I messed up but it looks cool #2","username":"ninofiliu","description":"Attempted to compute some normals as part of my quest to code some raymarched lightning, I must have messed up somewhere but hell, might as well push the glitch to its limit","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getRay(vec2 fragCoord, vec3 camera, vec3 lookAt) {\n    const float zoom = 1.5;\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    vec3 c = normalize(lookAt - camera);\n    vec3 u = vec3(c.y, -c.x, 0.0);\n    vec3 v = normalize(vec3(c.z*c.x, c.z*c.y, c.x*c.x+c.y*c.y));\n    return normalize(c + (uv.x * u + uv.y * v) / zoom);\n}\n\nbool isInSphere(vec3 camera, vec3 ray, vec3 center, float radius) {\n    float d = distance(camera, center);\n    float dp = dot(ray, center-camera);\n    return dp*dp > d*d-radius*radius;\n}\n\nfloat getDS(vec3 marcher) {    \n    // plane\n    float d = marcher.z;\n    \n    // main sphere\n    d = min(d, distance(marcher, vec3(0.0, 0.0, 0.5)) - 1.0);\n    \n    // surrounding spheres\n    int nb = 8;\n    for (int i = 0; i < nb; i++) {\n        float angle = radians(360.0 * float(i) / float(nb));\n        vec3 center = vec3(cos(angle), sin(angle), 0.0);\n        d = min(d, distance(marcher, center) - 0.4);\n    }\n    \n    return d;\n}\n\nvec3 march(vec3 camera, vec3 ray) {\n    const int MAX_STEPS = 50;\n    const float MIN_DISTANCE = 0.05;\n    const float MAX_DISTANCE = 20.0;\n    \n    vec3 marcher = camera;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float ds = getDS(marcher);\n        if (ds < MIN_DISTANCE || ds > MAX_DISTANCE) { break; }\n        marcher += ds * ray;\n    }\n    return marcher;\n}\n\nvec3 normal(vec3 camera, vec3 ray) {\n    vec3 m0 = march(camera, ray);\n    vec2 d = vec2(0.0, 0.02);\n    vec3 m1 = march(camera, normalize(ray + d.yxx));\n    vec3 m2 = march(camera, normalize(ray + d.xyx));\n    vec3 m3 = march(camera, normalize(ray + d.xxy));\n    return normalize(3.0*m0 - (m1+m2+m3));\n}\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 camera = vec3(4.0*vec2(cos(iTime), sin(iTime)), 0.75);\n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    vec3 ray = getRay(fragCoord, camera, lookAt);\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n    fragColor.rgb += normal(camera, ray);\n}","name":"Image","description":"","type":"image"}]}