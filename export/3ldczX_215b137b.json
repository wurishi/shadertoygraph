{"ver":"0.1","info":{"id":"3ldczX","date":"1609632369","viewed":74,"name":"AnimatedFractalTrip","username":"mamont92","description":"my test fractal shader, my 1.2kb demo porting to GLSL \n\nhttps://github.com/mamont-92/fractal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","trip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ANIMATED \n\n//----------begin------complex lib------------------\n#define complex vec2\n\nfloat cSqrt(complex val)\n{\n    return sqrt(val.x * val.x + val.y * val.y);\n}\n\nfloat cabs(complex cval)\n{\n    return sqrt(cval.x * cval.x + cval.y * cval.y);\n}\n\n\ncomplex cFromPolar(float angle, float len)\n{\n    return complex(len * sin(angle), len * cos(angle));\n}\n\ncomplex cPow(complex cValue, complex cPower)\n{\n    float ln_x1y1 = log( cabs(cValue) );\n    float a = atan( cValue.y, cValue.x );\n    \n    float e1 = exp( cPower.x *  ln_x1y1 - cPower.y * ln_x1y1);\n    float a_y2ln_x1y1 = cPower.x * a + cPower.y * ln_x1y1;\n    return cFromPolar( a_y2ln_x1y1, e1 );\n}\n//----------end------complex lib------------------\n\n//----------begin------palette lib------------------\n\n#define color vec4\n\nconst int palette_red_width   = 23; \nconst int palette_green_width = 13; \nconst int palette_blue_width  = 9; \n\nconst int palette_red_shift   = 7; \nconst int palette_green_shift = 1; \nconst int palette_blue_shift  = 3; \nconst int palette_max_colors  = 65536;\n\nANIMATED int palette_shift = 0;\n\ncolor colorFromPalettenInxed( int index )\n{\n    int redVal = (index + palette_red_shift) % palette_red_width;\n    int greenVal = (index + palette_green_shift) % palette_green_width;\n    int blueVal = (index + palette_blue_shift) % palette_blue_width;\n\n    float rVal = abs (float(redVal) / (float(palette_red_width) * 0.5) - 1.0 ) ;\n    float gVal = abs (float(greenVal) / (float(palette_green_width) * 0.5) - 1.0 ) ;\n    float bVal = abs (float(blueVal) / (float(palette_blue_width) * 0.5) - 1.0 ) ;\n    \n    return color(rVal, gVal, bVal, 1.0f);\n}\n//----------end------palette lib------------------\n\n//----------begin------fractal lib------------------\n\nconst complex fractal_constant  = complex(1.0f, 0.0f);\n\nconst complex fractal_start_power = complex(1.2f, 0.0f);\nconst complex fractal_end_power = complex(8.0f, 0.0f);\n\nconst float   fractal_start_scale = 2.5f;\nconst float   fractal_end_scale = 1.5f;\n\nconst int     fractal_max_iterations = 20;\nconst float   fractal_max_value_range = 50.0f;\n\nANIMATED complex fractal_power = fractal_start_power;\nANIMATED float   fractal_scale = fractal_start_scale;\n\ncomplex complexForCoords(vec2 coords) \n{\n    complex z = coords * fractal_scale;\n    \n    bool needContinue = true;\n    for (int i = 0; (i < fractal_max_iterations) && needContinue; i++)\n    {\n        z = cPow (z, fractal_power);\n        z = z + fractal_constant;\n        float z_abs = cabs(z);\n        \n        needContinue = ( abs(z.x) < fractal_max_value_range ) \n                        || (abs(z.y) < fractal_max_value_range)\n                        || (z_abs < fractal_max_value_range) ;\n    }\n    \n    return z;\n}\n\ncolor colorForComplex(complex cVal)\n{\n    float cVal_abs  = cabs(cVal);\n    float indexValue = log(cVal_abs) * 1.7f;\n    int index = int(indexValue) % 65536;\n    \n    return colorFromPalettenInxed(index + palette_shift);\n}\n//----------end------fractal lib------------------\n\n//----------begin------screen lib------------------\n\nvec2 getScreenNDC(vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy;\n    float aspectRatio = float( iResolution.x ) / float( iResolution.y );\n    vec2 ndc = screenUV * 2.0 - vec2(1.0);\n    ndc.x *= aspectRatio;\n    \n    return ndc;\n}\n//----------end------screen lib------------------\n\n//----------begin------animation lib------------------\n\nconst float animation_palette_time_scale = 10.0;\nconst float animation_fractal_time_scale = 0.3;\n\nfloat timeCoeff(float timeScale)\n{\n    return sin(iTime * timeScale) * 0.5 + 0.5;\n}\n\nvoid animation_update()\n{\n    palette_shift = int(iTime * animation_palette_time_scale) % palette_max_colors;\n    \n    fractal_scale = mix(fractal_start_scale, fractal_end_scale, timeCoeff(animation_fractal_time_scale) );\n    fractal_power = mix(fractal_start_power, fractal_end_power, timeCoeff(animation_fractal_time_scale) );\n}\n\n//----------end------animation lib------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    animation_update();\n    vec2 screenNDC = getScreenNDC( fragCoord );\n    complex fractalValue = complexForCoords( screenNDC );\n    fragColor = colorForComplex( fractalValue );\n\n}","name":"Image","description":"","type":"image"}]}