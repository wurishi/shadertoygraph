{"ver":"0.1","info":{"id":"3stGRf","date":"1569008024","viewed":118,"name":"second shader ,click on it","username":"Newbobplus","description":"Second shader ever.\nMessy af, i got lazy towards the end.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nfloat seed = 6.;\nfloat LABY_STEP_SPACING = .07;\nfloat LABY_STEP_RADIUS = .04;\n\nconst float CURSOR_RADIUS = .05;\nconst float CIRCLE_BLUR = .02;\nconst float LABYRINTH_RADIUS = .48;\nconst float CENTER_RADIUS = .07;\n\nconst float BRANCH_WIDTH = .005;\n\nfloat circle(float radius, float blur, float dist){\n    return smoothstep(radius + blur, radius, dist);\n}\n\nfloat slice(float turn, float width, float dist){\n    float a = ceil(dist - turn);\n    float b = ceil(dist - turn - width);\n    return clamp(a - b, 0., 1.);   \n}\n\nfloat remap(float value, float minA, float maxA, float minB, float maxB){\n\treturn minB + (value - minA) * (maxB - minB) / (maxA - minA);   \n}\n\nfloat _rand(float s){\n    float r = s;\n    r *= cos(r * r);\n    r = fract(r) * 3.;\n    return r * r;\n}\n\n//I know exactly what i'm doing.\nfloat rand(float s){\n\tint c = int(ceil(_rand(s)));\n    float r = s;\n    for(int i = 0; i < c; i++){\n   \t\tr = _rand(r);\n    }\n    return fract(r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = 6. + floor(iTime / 5.);\n    \n    vec2 recRes = 1. / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 mouse = iMouse.xy;\n    if(mouse.x + mouse.y == 0.) mouse = iResolution.xy * .5;\n    \n    vec2 m = mouse * recRes;\n    vec2 cursorUv = (uv - m) * vec2(ratio, 1.);\n    float cursorDist = length(cursorUv);\n    \n    vec3 cursor = vec3(circle(CURSOR_RADIUS, CIRCLE_BLUR, cursorDist));\n    \n    vec2 centerUv = (uv - vec2(.5)) * vec2(ratio, 1.);\n    float centerDist = length(centerUv);\n    \n    vec3 labyrinth = vec3(0., 0., circle(CENTER_RADIUS, CIRCLE_BLUR, centerDist));\n    int steps = int((LABYRINTH_RADIUS - CENTER_RADIUS) / (LABY_STEP_RADIUS + LABY_STEP_SPACING));\n    float r = CENTER_RADIUS + float(steps) * (LABY_STEP_RADIUS + LABY_STEP_SPACING);\n    float scale = LABYRINTH_RADIUS / r;\n    float stepRadius = LABY_STEP_RADIUS * scale;\n    float stepSpacing = LABY_STEP_SPACING * scale;\n    \n    float angularDist = atan(centerUv.x, centerUv.y);\n    angularDist = remap(angularDist, -PI, PI, 0., 1.);\n    \n    for(int i = 1; i < steps + 1; i++){\n        float c = circle(CENTER_RADIUS + float(i) * (stepRadius + stepSpacing), CIRCLE_BLUR, centerDist);\n        c -= circle(CENTER_RADIUS + float(i) * stepSpacing + float(i-1) * stepRadius, CIRCLE_BLUR, centerDist);\n        labyrinth += c;\n        float b = circle(CENTER_RADIUS + float(i) * stepSpacing + float(i-1) * stepRadius, CIRCLE_BLUR, centerDist);\n        float br = CENTER_RADIUS + float(i-1) * (stepRadius + stepSpacing);\n        b -= circle(br, CIRCLE_BLUR, centerDist);\n        float t = rand(seed+rand(float(i)) * .1);\n        labyrinth += slice(t, BRANCH_WIDTH / br, angularDist) * b;\n    }\n    float e = circle(CENTER_RADIUS + float(steps + 1) * stepSpacing + float(steps) * stepRadius, CIRCLE_BLUR, centerDist);\n    float er = CENTER_RADIUS + float(steps) * (stepRadius + stepSpacing);\n    e -= circle(er, CIRCLE_BLUR, centerDist);\n    float es = slice(.6, BRANCH_WIDTH / er * 4., angularDist) * e;\n    labyrinth += vec3(0., es, 0.);\n    \n    vec3 background = vec3(.5, .1, 0.5);\n    \n    vec3 rect = vec3(0.);\n    if(uv.x > .9 && uv.x < .95 && uv.y < 1. - mod(iTime/5., 1.)) rect = vec3(1.);\n    \n    vec3 col = background * clamp(ceil(length(background)) - length(labyrinth), 0., 1.);\n    col += labyrinth;\n    col = col * clamp(length(col) - length(cursor), 0., 1.) ;\n    col +=  vec3(1., 0., 0.) * length(cursor) * ceil(length(labyrinth));\n    col += rect;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}