{"ver":"0.1","info":{"id":"ldVGWy","date":"1456273870","viewed":1081,"name":"ShadertOX","username":"dine909","description":"Naughts and Crosses - the code needs heavily optimised, and the AI needs to play a bit more randomly, but the annoying factor is there.<br/><br/>I was going to add scores, but my GPU fan told me otherwise.","likes":25,"published":1,"flags":32,"usePreview":1,"tags":["2d","game","font","pencil","paper","statemachine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//by dine909\n\n\n#define PI 3.14159265359\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //    discard;\n    vec2 uv = (0.5+fragCoord.xy) / iResolution.xy;\n    vec2 auv=vec2(uv.x*iResolution.x/iResolution.y,uv.y);\n\n    vec3 col=.9*vec3(1.,.9,.85)+rand(auv)*0.03;\n    vec4 ink=vec4(0.,.7,.9,0.15);\n    ink.rgb+=col*0.02;\n\n    col=mix(col,ink.rgb,1.-clamp(2.6+cos(auv.y*PI*32.)*(1.9+rand(auv)*0.3),0.,1.));\n\n    col=mix(col,ink.bar,clamp((.8+(distance(auv.x,0.2)*-90.))*(1.+rand(auv)*0.5),0.,1.));\n    vec4 tex=vec4(0.,0.,0.,1.);\n    tex=sign(fragCoord.y-4.)*texture(iChannel0,uv);\n    col=mix(col,vec3(0.25)+rand(uv)*0.2,clamp(tex.r*0.7,0.,1.)*(.8+rand(auv+tex.rg)*0.3));\n\n    //    col.rgb=mix(tex.rgb,col,tex.a);\n\n    col*=clamp((.7/inversesqrt(2.4-distance(vec2(0.5),uv))),0.,1.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//by dine909\n\n//#define DEBUG_ERASE\n//#define USE_DISCARD\n\n#ifdef\tDEBUG_ERASE\n#ifndef DEBUG_DRAW\n#define DEBUG_DRAW\n#endif\n#endif\n\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n#define PI 3.14159265359\n\n#define ftime (float(iFrame))\n#define asrat (iResolution.x/iResolution.y)\nvec2 gamepos=vec2(.22,0.);\n\nfloat fres=(0.);\nvec2 cpos=vec2(0.);\n\n\nfloat opU( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\nvec2 rand2 (in vec2 seed){\n    return vec2(rand(seed.xy+iTime),rand(seed.yx+iTime));\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nmat3 loadMat3( in vec2 re )\n{\n    mat3 mo;\n    mo[0]=texture( iChannel0, (0.5+vec2(re.x,0.)) / iChannelResolution[0].xy, -100.0 ).xyz;\n    mo[1]=texture( iChannel0, (0.5+vec2(re.x,1.)) / iChannelResolution[0].xy, -100.0 ).xyz;\n    mo[2]=texture( iChannel0, (0.5+vec2(re.x,2.)) / iChannelResolution[0].xy, -100.0 ).xyz;\n    return mo;\n}\nvoid storeValue( in vec2 re, in mat3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,vec2(re.x,0.)) > 0.0 ) ? vec4(va[0],0.) : fragColor;\n    fragColor = ( isInside(fragCoord,vec2(re.x,1.)) > 0.0 ) ? vec4(va[1],0.) : fragColor;\n    fragColor = ( isInside(fragCoord,vec2(re.x,2.)) > 0.0 ) ? vec4(va[2],0.) : fragColor;\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nconst vec2 txTime=\t\t\tvec2(0,0);\nconst vec2 txShaderState=\tvec2(1,0);\nconst vec2 txPen=\t\t\tvec2(2,0);\nconst vec2 txDrawState=\t\tvec2(3,0);\nconst vec2 txGameState=\t\tvec2(4,0);\nconst vec2 txBoard=\t\t\tvec2(5,0);\n\nvec4 shaderState=vec4(0.);\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n\n    vec2 or2=rand2(p)*0.00225;\n    p+=or2;\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    return  (1.-d);\n}\nvoid pencil(inout float col,in float d)\n{\n    float aares=clamp(antiAlias(smoothstep(((d)), .995, 0.)),0.,1.);\n    col=max(col,clamp(aares,0.,1.));\n\n}\nvoid plot(int id,vec2 uv, vec2 p,inout vec4 pen, inout vec3 col)\n{\n    pen.z=float(id)!=pen.w?0.:1.;\n\n    if(pen.z!=0.){\n        p+=rand2(vec2(iTime,float(iFrame)))*0.0052;\n        uv-=gamepos+shaderState.zw;\n        float d=line(uv,p,pen.xy);//distance(p,uv);\n        pencil(col.r,d);\n    }\n    else pen.z=1.;\n    pen.w=float(id);\n    pen.xy=p;\n}\nfloat fontTime=0.;\n#define CLINE(_p,_a,_b,_s) ((step(_s,fontTime))*line(_p,_a,_b))\n\nvoid char_S(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s,startc++));cpos.x+=20.0*s.x;}\nvoid char_h(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s,startc++));cpos.x+=19.0*s.x;}\nvoid char_a(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s,startc++));cpos.x+=19.0*s.x;}\nvoid char_d(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s,startc++));cpos.x+=19.0*s.x;}\nvoid char_e(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s,startc++));cpos.x+=18.0*s.x;}\nvoid char_r(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s,startc++));cpos.x+=13.0*s.x;}\nvoid char_t(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s,startc++));cpos.x+=12.0*s.x;}\nvoid char_o(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s,startc++));cpos.x+=19.0*s.x;}\nvoid char_y(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s,startc++));cpos.x+=16.0*s.x;}\n/*\nvoid char_u(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s,startc++));cpos.x+=19.0*s.x;}\nvoid char_m(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s,startc++));cpos.x+=30.0*s.x;}\nvoid char_w(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s,startc++));cpos.x+=22.0*s.x;}\n*/\nvoid char_O(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s,startc++));cpos.x+=22.0*s.x;}\nvoid char_X(vec2 uv,vec2 s,inout float startc){vec2 p=uv-cpos;fres=opU(fres,CLINE(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s,startc++));fres=opU(fres,CLINE(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s,startc++));cpos.x+=20.0*s.x;}\n\n\nfloat evalDrawState(inout vec4 drawState)\n{\t\n\n    float t=ftime-drawState.y;\n    bool changeState= t>=60.;    \n    drawState.x=changeState?0.:drawState.x;\n    return clamp(t,0.,60.);\n}\n//Nice state macros because readability.\n#define GS_TEST_STATE(_x) \t(gameState.x==_x)\n#define DR_TEST_STATE(_x) \t(drawState.x==_x)\n#define GS_SET_STATE(_x) \t(gameState.x=_x)\n#define DR_SET_STATE(_x,_y) \t(drawState=vec4(_x,ftime,_y))\n\nconst float GS_CLEAR=\t\t\t\t1.;\n\nconst float GS_INTRO1=\t\t\t\t10.;\nconst float GS_INTRO2=\t\t\t\t11.;\nconst float GS_INTRO3=\t\t\t\t12.;\nconst float GS_INTRO4=\t\t\t\t13.;\nconst float GS_SETUP=\t\t\t\t\t14.;\n\nconst float GS_COMPUTER_MOVE=\t\t2.;\nconst float GS_USER_MOVE=\t\t\t3.;\nconst float GS_GAME_OVER=\t\t\t4.;\nconst float GS_RESET=\t\t\t\t5.;\n\nconst float DR_DRAW_GRID=\t\t1.;\nconst float DR_DRAW_O=\t\t\t2.;\nconst float DR_DRAW_X=\t\t\t3.;\nconst float DR_DRAW_WIN=\t\t4.;\nconst float DR_ERASE=\t\t\t5.;\nconst float DR_SHADERTOY=\t\t10.;\nconst float DR_SHADERT=\t\t\t11.;\nconst float DR_SHADERTOX=\t\t12.;\nconst float DR_NAMES=\t\t\t13.;\n\n\nvoid setMat(inout mat3 m,vec2 p,float v)\n{\n    for(int x=0;x<3;x++){\n        vec3 tm=m[x];\n\n        if((int(p.x)==(x)) )\n        {\n            if(p.y==0.)tm.x=v;\n            if(p.y==1.)tm.y=v;\n            if(p.y==2.)tm.z=v;\n            m[x]=tm;\n            return;\n        }\n\n    }\n}\nfloat getMat(inout mat3 m,vec2 p)\n{\n    for(int x=0;x<3;x++){\n        for(int y=0;y<3;y++){\n            if((int(p.x)==(x)) && (int(p.y)==(y)))\n            {\n                return m[x][y];\n            }\n        }\n    }\n    return 0.;\n}\nbool checkWin(in mat3 board,float checkPlay,inout vec2 move,out int wid){\n    bool _set=false;\n    int rmove=int(mod(floor(rand(iDate.zw)*9.),9.));\n    vec2 defmove=vec2(-1.);\n    #define DEFMOVE(_x) if(defmove.x==-1. && _x>=rmove) defmove=move\n    wid=-1;\n    for(int x=0;x<3;x++){\n        float win=0.;\n        for(int y=0;y<3;y++){\n            float bxy=board[x][y];\n            win+=bxy;                \n\n            if(bxy==0.) {\n                move=vec2(float(x),float(y));\n\n            }\n            if(y==2 && win==checkPlay){\n                wid=x;\n                _set=true;\n                break;\n            }\n        }\n        if(_set) break;\n    }\n    if(!_set){\n        float win=0.;\n        for(int x=0;x<3;x++){\n            float bxy=board[2-x][x];\n            win+=bxy;                \n\n            if(bxy==0.) {\n                move=vec2(float(2-x),float(x));\n\n            }\n            if(x==2 && win==checkPlay){\n                wid=6;\n                _set=true;\n                break;\n            }\n        }\n    }\n    if(!_set){\n        for(int y=0;y<3;y++){\n            float win=0.;\n            for(int x=0;x<3;x++){\n                float bxy=board[x][y];\n                win+=bxy;                \n\n                if(bxy==0.) {\n                    move=vec2(float(x),float(y));\n\n                }\n                if(x==2 && win==checkPlay){\n                    wid=3+y;\n                    _set=true;\n                    break;\n                }\n            }\n            if(_set) break;\n        }\n    }\n    if(!_set){\n        float win=0.;\n        for(int x=0;x<3;x++){\n            float bxy=board[x][x];\n            win+=bxy;                \n\n            if(bxy==0.) {\n                move=vec2(float(x),float(x));\n\n            }\n            if(x==2 && win==checkPlay){\n                wid=7;\n                _set=true;\n                break;\n            }\n        }\n    }\n    //if(!_set) move=defmove;\n    return _set;\n\n}\nbool doMove(inout mat3 board,inout vec4 drawState,float player,vec2 move)\n{\n    bool valid=false;\n    int wid;\n    if(player==GS_COMPUTER_MOVE){\n        if(!checkWin(board,2.,move,wid))\n            checkWin(board,-2.,move,wid);\n\n        setMat(board,move,1.);\n        DR_SET_STATE(DR_DRAW_X,vec2(0.5,0.5)+(move-1.)*0.3);\n        valid= true;\n    }else{\n        if(getMat(board,move)==0.){\n            setMat(board,move,-1.);\n            DR_SET_STATE(DR_DRAW_O,vec2(0.5,0.5)+(move-1.)*0.3);\n            valid= true;\n        }\n\n    }\n\n\n\n    return valid;\n}\nvec2 rotatePoint(vec2 pt,vec2 piv,float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    vec2 p=pt-piv  ;\n    return vec2(p.x * c - p.y * s,p.x * s + p.y * c)+piv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool clear=true;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 muv = iMouse.xy / iResolution.xy;\n    vec2 auv=vec2(uv.x*asrat,uv.y);\n    vec2 amuv=vec2(muv.x*asrat,muv.y);\n\n    vec3 col=texture(iChannel0,uv).rgb;\n\n    vec4 pen=\t\t\tvec4(0.);\n    vec4 drawState=\t\tvec4(0.);\n    vec4 gameState=\t\tvec4(0.);\n    vec4 timeState=\t\tvec4(0.);\n    shaderState=\tvec4(0.);\n    mat3 board=\t\t\tmat3(0.);\n\n    shaderState=loadValue(txShaderState);\n\n    if(iFrame>0 && shaderState.xy==iResolution.xy){\n        pen=loadValue(txPen);\n        drawState=loadValue(txDrawState);\n        gameState=loadValue(txGameState);\n        timeState=loadValue(txTime);\n        board=loadMat3(txBoard);\n        clear=false;\n    }\n\n    shaderState.xy=iResolution.xy;\n\n\n    if(clear) GS_SET_STATE(GS_INTRO1);\n\n    float rtime=evalDrawState(drawState);\n    if(drawState.x==0.){\n        if(!GS_TEST_STATE(GS_RESET))\n        {       \n            int wid=-1;\n            vec2 move;\n            if(!checkWin(board,3.,move,wid))\n                checkWin(board,-3.,move,wid);\n            #ifdef DEBUG_ERASE\n            if(GS_TEST_STATE(GS_COMPUTER_MOVE)){\n                wid=7;\n                gameState.z=0.5;\n\n            }\n            #endif\n            if(gameState.y==9. || wid>-1)\n            {\n                gameState.w=float(wid);\n                GS_SET_STATE(GS_GAME_OVER);\n                gameState.z+=.5;\n\n            }\n        }\n\n        if(GS_TEST_STATE(GS_CLEAR)){\n\n            DR_SET_STATE(DR_DRAW_GRID,vec2(0.));\n            GS_SET_STATE(fract(gameState.z)==0.?GS_COMPUTER_MOVE:GS_USER_MOVE);\n\n        } else if(GS_TEST_STATE(GS_COMPUTER_MOVE)){\n            if(doMove(board,drawState,GS_COMPUTER_MOVE,vec2(0.)))\n            {\n                GS_SET_STATE(GS_USER_MOVE);\n                gameState.y+=1.;\n            }\n\n        } else  if(GS_TEST_STATE(GS_USER_MOVE)){\n            if(iMouse.z>0.5)\n            {\n                vec2 move=(clamp(floor(5.*(0.2+(amuv-gamepos)))-2.,0.,2.));\n                if(doMove(board,drawState,GS_USER_MOVE,move))\n                {\n                    GS_SET_STATE(GS_COMPUTER_MOVE);\n                    gameState.y+=1.;\n                }\n            }else{\n           #ifdef USE_DISCARD\n                 discard;\n\t\t\t#endif\n            }\n        }else if(GS_TEST_STATE(GS_GAME_OVER)){\n            if(gameState.w!=-1.)\n            {\n                DR_SET_STATE(DR_DRAW_WIN,vec2(0.5));               \n            }\n\n            GS_SET_STATE(GS_RESET);\n        } else if(GS_TEST_STATE(GS_RESET)) {\n            //            clear=true;\n            board=mat3(0.);\n            gameState.xy=vec2(0.);\n\n            shaderState.zw=0.05*rand2(-iDate.wz);\n            DR_SET_STATE(DR_ERASE,vec2(0.));  \n            GS_SET_STATE(GS_CLEAR);\n        } else \n            if(GS_TEST_STATE(GS_INTRO1)) {\n                DR_SET_STATE(DR_SHADERTOY,vec2(0.));\n                GS_SET_STATE(GS_INTRO2);\n            } else \n                if(GS_TEST_STATE(GS_INTRO2)) {\n                    DR_SET_STATE(DR_SHADERT,vec2(0.));\n                    GS_SET_STATE(GS_INTRO3);\n                } else \n                    if(GS_TEST_STATE(GS_INTRO3)) {\n                        DR_SET_STATE(DR_SHADERTOX,vec2(0.));\n                        GS_SET_STATE(GS_INTRO4);\n                    } else \n                        if(GS_TEST_STATE(GS_INTRO4)) {\n                            DR_SET_STATE(DR_ERASE,vec2(0.));  \n                            GS_SET_STATE(GS_CLEAR);\n                            //                            GS_SET_STATE(GS_SETUP);\n                        }\n        /*else \nif(GS_TEST_STATE(GS_SETUP)) {\nDR_SET_STATE(DR_NAMES,vec2(0.));  \nGS_SET_STATE(GS_CLEAR);\n}\n*/    \n    }\n\n    if(DR_TEST_STATE(DR_DRAW_O))\n    {\n        rtime=smoothstep(0.,60.,rtime);\n        plot(1,auv-drawState.zw,0.1*vec2(sin(rtime*PI*2.),cos(rtime*PI*2.)),pen,col);\n    }\n\n    if(DR_TEST_STATE(DR_DRAW_X)){\n        vec2 st=vec2(-.1,.1);\n        if(rtime<30.)\n            plot(2,auv-drawState.zw,mix(st.xy,st.yx,clamp(smoothstep(0.,30.,rtime),0.,1.)),pen,col);\n        else  \n            plot(3,auv-drawState.zw,mix(st.yy,st.xx,clamp(smoothstep(30.,60.,rtime),0.,1.)),pen,col);\n    }\n    if(DR_TEST_STATE(DR_DRAW_WIN))\n    {\n        #define CSIZE 11.\n        vec2 offset=vec2(0.);\n        float rot=gameState.w<3.?0.:CSIZE;\n        vec2 po=auv-drawState.zw;\n        if(gameState.w>=6.){\n            po=rotatePoint(po,gamepos,PI/(gameState.w==6.?4.:-4.));\n        }else{\n            offset+=gameState.w<3.?vec2((gameState.w-1.)*0.3,0.):vec2(0.,(gameState.w-4.)*0.3);\n        }\n        po=po;\n        rtime=0.25+smoothstep(0.,60.,rtime);\n        plot(10,po,offset+0.05*vec2((rot+1.)*sin(rtime*PI*2.),\n                                    (CSIZE-rot+1.)*cos(rtime*PI*2.)),pen,col);\n    }\n\n    if(DR_TEST_STATE(DR_DRAW_GRID)){\n        vec4 st=vec4(1./3.,.1,2./3.,.9);\n        if(rtime<15.)\n            plot(2,auv,mix(st.xw,st.xy,clamp(smoothstep(0.,15.,rtime),0.,1.)),pen,col);\n        else if(rtime<30.) \n            plot(3,auv,mix(st.zw,st.zy,clamp(smoothstep(15.,30.,rtime),0.,1.)),pen,col);\n            else if(rtime<45.)\n                plot(4,auv,mix(st.yx,st.wx,clamp(smoothstep(30.,45.,rtime),0.,1.)),pen,col);\n                else  if(rtime<60.)\n                    plot(5,auv,mix(st.yz,st.wz,clamp(smoothstep(45.,60.,rtime),0.,1.)),pen,col);\n\n                    }\n    if(DR_TEST_STATE(DR_ERASE)){\n\n        rtime=smoothstep(0.,60.,rtime);\n        vec2 po=auv-gamepos;\n        float sm=sin(rtime*PI*5.)*0.77;//-0.05;\n        vec2 ep=vec2(sm,rtime);\n        float nd=clamp((.4+distance(po,ep))+.15,0.1,1.);\n\n        // float nd=(distance(po,ep)<0.055?.56:1.);\n        //col.r*=0.94;\n        col*=nd;\n        #ifdef DEBUG_ERASE\n        plot(100,po,ep,pen,col);\n\n        col.g=clamp(1.-nd,0.,1.);\n        //   col.b+=(sm2<0.5?1.:0.)*clamp(1.-nd,0.,1.);\n        #endif \n    }\n    if(DR_TEST_STATE(DR_SHADERTOY)){\n        fontTime=(ftime-drawState.y)*3.;\n        vec2 s=vec2(0.0055);    \n        cpos=vec2(0.27 ,0.46);\n        float sc=0.;\n        char_S(auv,s,sc);\n        char_h(auv,s,sc);\n        char_a(auv,s,sc);\n        char_d(auv,s,sc);\n        char_e(auv,s,sc);\n        char_r(auv,s,sc);\n        char_t(auv,s,sc);\n        char_o(auv,s,sc);\n        char_y(auv,s,sc);\n        pencil(col.r,fres);\n\n    }\n    if(DR_TEST_STATE(DR_SHADERT)){\n        rtime=smoothstep(0.,60.,rtime);\n        vec2 po=auv;\n        float sm=sin(rtime*PI*5.)*0.15;\n        vec2 ep=vec2(sm,rtime*0.2)+vec2(1.12,0.41);\n        float nd=(distance(po,ep)<0.055?.56:1.);\n\n        col*=clamp(nd,0.,1.);\n\n        #ifdef DEBUG_ERASE\n        plot(100,po,ep,pen,col);\n\n        col.g=clamp(1.-nd,0.,1.);\n        //   col.b+=(sm2<0.5?1.:0.)*clamp(1.-nd,0.,1.);\n        #endif \n    }\n    if(DR_TEST_STATE(DR_SHADERTOX)){\n        fontTime=(ftime-drawState.y);\n        vec2 s=vec2(0.0055);    \n        cpos=vec2(.93 ,0.46);\n        float sc=0.;\n        char_O(auv,s,sc);\n        char_X(auv,s,sc);\n        pencil(col.r,fres);\n\n    }\n    /*\nif(DR_TEST_STATE(DR_NAMES)){\nfontTime=(ftime-drawState.y)*2.;\nvec2 s=vec2(0.0035);    \ncpos=vec2(1.4 ,0.9);\nfloat sc=0.;\nchar_m(auv,s,sc);\nchar_e(auv,s,sc);\n\n\ncpos=vec2(1.4 ,0.6);\nchar_d(auv,s,sc);\nchar_r(auv,s,sc);\nchar_a(auv,s,sc);\nchar_w(auv,s,sc);\n\n\ncpos=vec2(1.4 ,0.3);\nchar_y(auv,s,sc);\nchar_o(auv,s,sc);\nchar_u(auv,s,sc);\npencil(col.r,fres-0.001);\n\n}\n*/\n    #ifdef DEBUG_DRAW\n    float a=0.;\n    #else\n    float a=1.;\n    #endif    \n    fragColor = clear?vec4(0.,0.,0.,1.):vec4(col,a);\n\n    storeValue( txTime, \t\ttimeState,      fragColor, fragCoord );\n    storeValue( txShaderState, \tshaderState,    fragColor, fragCoord );\n    storeValue( txPen, \t\t\tpen,     \t\tfragColor, fragCoord );\n    storeValue( txDrawState, \tdrawState,      fragColor, fragCoord );\n    storeValue( txGameState, \tgameState,      fragColor, fragCoord );\n    storeValue( txBoard, \t\tboard,      \tfragColor, fragCoord );\n\n}","name":"Buf A","description":"","type":"buffer"}]}