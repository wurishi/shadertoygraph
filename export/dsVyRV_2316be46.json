{"ver":"0.1","info":{"id":"dsVyRV","date":"1696352884","viewed":67,"name":"3d wannabe fractal","username":"Korifeyi","description":"gotta learn a lot about lightning","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0.75, 3.2);\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 90;\nconst float eps      = 0.01;\nconst int ITERATIONS = 15;\nconst float EXP = 5.0;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0 + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat juliaBulb ( vec3 p )\n{\n    vec3 z = p;\n    vec3 d = vec3(1.0);\n    float r = 0.0;\n    float b = 10000.0;\n    for (int i = 0; i < ITERATIONS; ++i) {\n        d = EXP * pow(r, EXP-1.0) * d + 0.5;\n        if (r > 0.0) {\n            float phi = atan(z.z, z.x);\n            phi *= EXP;\n            float theta = acos(z.y / r);\n            theta *= EXP;\n            r = pow(r, EXP);\n            z = vec3(cos(phi)*cos(theta), sin(theta), sin(phi)*cos(theta)) * r;\n        }\n        z += vec3(0.5, -1.5, 0.0);\n        r = length(z);\n        b = min(r, b);\n        if (r >= 2.0) {\n            break;\n        }\n    }\n    return r * log(r) * 0.45 / length(d);\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    return juliaBulb ( p );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   return juliaBulb ( q );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir * 1.0;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.25);\n    mat3 m     = rotateX ( 5.0*mouse.y ) * rotateY ( 5.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n    //vec3 fcol = vec3(0.0);\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n        vec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 50.0 );\n\t\tvec3 q = p * m;\n\t\tcolor = vec4 ( nl );\n        vec3 tx = getTriplanarWeights ( n );\n        vec4 cx = texture ( iChannel0, q.yz );\n        vec4 cy = texture ( iChannel0, q.zz );\n        vec4 cz = texture ( iChannel0, q.xy );\n        color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 35./iResolution.y;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    vec4 texColor = texture(iChannel0, xy);\n    float t = sin(iTime*.01)*.05+.05;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float angle = iTime*0.05;\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    mat2 rotationMatrix = mat2( c, s,\n                               \t-s,  c);\n    \n    vec2 pivot = vec2( 0.5, 0.5);\n \n    uv = rotationMatrix * ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    //fragColor = vec4(col, 1.0);\n    fragColor += vec4(smoothstep(e,-e, length(col)-.75) -col, 1.0) - fragColor;\n}","name":"Buffer A","description":"","type":"buffer"}]}