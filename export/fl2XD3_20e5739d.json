{"ver":"0.1","info":{"id":"fl2XD3","date":"1628938122","viewed":88,"name":"mf audio visualizer","username":"momie","description":"my fourth audio visualizer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reuse some code to calculate ray direction from shader created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI = 3.14159265;\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat dFn(vec3 p){\n    const float div = 7.;\n    const float an = 2.*PI/div;\n    float index = round(atan(p.y,p.x)/an);\n    float pick = (index+1.)/div;\n    vec4 spect = texture(iChannel0, vec2(pick,0.));\n    float angrot = index*an;\n    vec3 q = p;\n    q.xy = mat2(cos(angrot),-sin(angrot),\n                sin(angrot), cos(angrot))*q.xy;\n\n    float r = 1.5;\n    float lenxy = r*spect.x ;\n    float d = sdSphere( abs(q) - vec3(lenxy, 0, .5*sqrt(pow(r,2.) - lenxy)), .2*lenxy );\n    float d2 = sdSphere( p , 1. );\n    return smoothMin(d, d2, 20.0);\n}\n\nvec3 norm(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        dFn(p + vec3(  d, 0.0, 0.0)) - dFn(p + vec3( -d, 0.0, 0.0)),\n        dFn(p + vec3(0.0,   d, 0.0)) - dFn(p + vec3(0.0,  -d, 0.0)),\n        dFn(p + vec3(0.0, 0.0,   d)) - dFn(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 march(vec2 p){\n            \n    vec4 spect = texture(iChannel0, vec2(0,0.));\n    spect = spect-.5;\n    \n    float rotate = spect.x*.5*PI + 1.5*iTime;\n    vec3 target = vec3( 0.0, 0.0, 0.0 );\n    float r = 5.;\n    vec3 cPos = target + vec3( r*cos(rotate), 1.5*cos(.3*rotate), r*sin(rotate) );\n    mat3 direction = setCamera( cPos, target, 0. );\n    float fl = 2.0;\n    vec3 ray = direction * normalize( vec3(p,fl) );\n    \n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 64; i++){\n        distance = dFn(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen*.5;\n    }\n    \n    vec4 col = vec4(0);\n    if(abs(distance) < 0.001){\n        vec3 normal = norm(rPos);\n        float diff = clamp(dot(lightDir, normal), 0., 1.0);\n        col = vec4(vec3(1.007*normal), 1.0);\n    }else{\n        col += vec4(0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4)), 0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = march(p);\n}","name":"Image","description":"","type":"image"}]}