{"ver":"0.1","info":{"id":"3tSyWV","date":"1595346450","viewed":823,"name":"time warp","username":"Carandiru","description":"practice fork of the coolest laser shader originally @  https://www.shadertoy.com/view/3tK3WK","likes":21,"published":3,"flags":0,"usePreview":0,"tags":["noise","fog","warp","laser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// Fork of \"test laser\" by jojobavg. https://shadertoy.com/view/3tK3WK\n// 2020-07-21 13:23:20\n// practice fork of the coolest laser shader originally @  https://www.shadertoy.com/view/3tK3WK\n\n// Using code from\n\n// Inigo Quilez for the primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n    const vec3 step = vec3(110.0, 241.0, 171.0);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n                        random(n + dot(step, vec3(1,0,0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,0))),\n                        random(n + dot(step, vec3(1,1,0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0,0,1))),\n                        random(n + dot(step, vec3(1,0,1))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,1))),\n                        random(n + dot(step, vec3(1,1,1))),\n                        u.x),\n                u.y),\n            u.z);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere(in vec3 p, in vec2 uv) {\n  vec3 truc = vec3(p.x,p.y,0.0);\n  return length(truc)-1.0;\n}\n\nfloat fog(in vec3 p, vec3 centerPos, float scale,float radius ) {\n  \n  float x=(noise((p+(time*1.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float y=(noise((p+(time*1.0+5.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float z=(noise((p+(time*1.0+3.5)*2.0)*0.2)*2.0-1.0)*15.0;\n  p+=vec3(x,y,z);\n\treturn max((noise(p*scale)+noise(p*2.0*scale)*0.5+\n              noise(p*3.0*scale)*0.33+\n              noise(p*4.0*scale)*0.25)*0.4807,0.0)*5.0;\n}\n  \n\nfloat map(vec3 p, vec2 uv){\n  return sphere(p,uv);\n  }\n\n \nfloat mapHyper(vec3 p){ \n  return fog(p,vec3(0,0,0),0.5,0.1);\n  }  \n\n  \nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p){\nreturn udQuad(p,\n              vec3(5, 0, 100.0),\n              vec3(-5.0, 0, 100.0), \n              vec3(-5.0,   (cos(time*0.5))*0.5f, -100.0),\n              vec3(5.0,  (cos(time*0.5))*0.5f, -100.0));\n  }\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n  vec2 uv = fragCoord / iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  vec3 s=vec3(0.0,0.0,-100.0);\n  vec3 t=vec3(0.0,0.0,0.0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*3.14);\n  \n  vec3 p=s;\n  float dd=0.0;\n  float bn = textureLod(iChannel0, uv, 0.0).r;\n  p += r * bn*(23.0f/255.0f);\n    \n  float c = 0.0f;\n  float f = 0.0f;\n     \n  for(int i=0; i<512; ++i) {\n    float d=map(p,uv);\n    float d2=map3(p)*((cos(15.0*p.y+iTime) * 0.5f + 0.5f));\n   float mH=mapHyper(p)+(1.0f - 0.25f*(d*0.5f+0.5f));\n      \n    float l = 0.0f;\n    l+=pow((mH+bn*(23.0f/255.0f))*0.06f, 4.0);\n    l+=pow(mH*0.9, 4.0)*smoothstep(1.0, 0.1, sin(20.0f*p.x+iTime*4.0f))*clamp(0.025-d2,0.0,1.0)*0.02;\n      \n    c += abs(l);\n      f += mH*0.00175f*c;\n\n    if( d>0.0000 ){ break;}\n    p+=r*(0.1);\n    dd+=0.1;\n  }\n   \n  vec3 color = viridis((1.0f - exp(-f - c)) * 0.95f);\n  fragColor = vec4( color * vec3(c), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}","name":"Common","description":"","type":"common"}]}