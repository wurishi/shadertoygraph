{"ver":"0.1","info":{"id":"wscGDN","date":"1568567217","viewed":158,"name":"Paraboloid SDF (bound)","username":"Blake447","description":"Demo for a signed distance function I personally derived. It evaluates the tangent line at the current point and calculates the distance to that. Comments are left over from julia set raymarcher, will clean up later","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distanceestimation","paraboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// and a float2 function as well\nvec2 float2(float x, float y)\n{\n \treturn vec2(x, y);   \n}\n\n// A method for intersecting two lines in R-two.\nvec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb)\n{\n\tfloat buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);\n\tvec2 intersection = float2(buffer, sa*(buffer - A.x) + A.y);\n\treturn intersection;\n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    // find the distance to the center\n    vec3 v = pos - center;\n    \n    // return that, minus the radius\n    return length(v) - radius;\n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n// Bound paraboloid SDF as a rotations of a parabola in 2D space. When outside, it\n// evaluates a tangent line with the same x-coord as the raymarched point, then finds\n// the minimum distance to that.\n\n// when inside, it makes a coord between the point with the matching y-coord, and the point\n// with the matching x-coord, then finds the minimum distance to that.\nfloat paraboloid(vec3 Point, vec3 Center)\n{\n\n    // Transform into polar coordinates\n\tfloat h = sqrt(dot(Point.xz - Center.xz, Point.xz - Center.xz));\n\tfloat k = (Point.y-Center.y);\n\n    // Calculate point A\n\tvec2 A = float2(h, k);\n\n\t// Calculate the point on the curve at h\n\tvec2 r_of_h = float2(h, h*h);\n\n\t// Calculate the slope of the curve at h\n\tfloat t_of_h = 2.0 * h;\n\n\t// Calculate the slope of the normal of tangent line through (h,k)\n\tfloat n_of_h = -1.0 / t_of_h;\n\n\t// Calculate the intersection of the line normal to the tangent through (h,k) and the tangent line itself through (h, f(h))\n\tvec2 t_int_n = intersectionOfTwoLines(r_of_h, t_of_h, A, n_of_h);\n\n\tvec2 P = float2(h, h*h);\n\tvec2 Q = float2(sqrt(k), k);\n\n\tfloat s_of_P2Q = (P.y - Q.y) / (P.x - Q.x);\n    float n_of_P2Q = -1.0 / s_of_P2Q;\n\n\tvec2 R = intersectionOfTwoLines(P, s_of_P2Q, A, n_of_P2Q);\n\n\n\tfloat dist = distance(A, t_int_n);\n\n\tif (k > r_of_h.y)\n\t{\n\t\tdist = -distance(A, R);\n\t}\n\n\treturn dist;\n}\n\n// Distance estimation for the scene\nfloat DE(vec3 p, vec3 c)\n{\n    vec3 p1_center = vec3(-1.5, -1.0, 0.0);\n    vec3 p2_center = vec3(1.5, -1.0, 0.0);\n    \n    vec3 c1_center = vec3(1.5, -1.0, 0.0);\n    \n    float p1 = paraboloid(p * vec3(1.0, -1.0, 1.0), p1_center);\n    float p2 = paraboloid(p * vec3(1.0, -1.0, 1.0), p2_center); \n    \n    float c1 = dSphere(p, c1_center, 1.5);\n    \n    float left = p1;\n    float right = max(c1, -p2);\n    \n    float d1 = min(left, right);\n        \n\t//float d1 = paraboloid(p * vec3(1.0, -1.0, 1.0), c);   \n\tfloat d2 = (p.y-c.y) - 0.5;\n    \n    float d = max(d1, -d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 60;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 4.0;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.001;\n    \n    const bool HIDE_BACKGROUND = true;\n    \n    \n    \n    // Define the center of the julia set\n    vec3 sdf_center = vec3(0.0, -1.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    //// Define the Camera position\n    //vec3 cam_pos = vec3(0,0,-2);\n    \n    //// Define the forward, up, and right vectors (needs rework)\n    //vec3 forward = normalize(vec3(0,0,1));\n    //vec3 up = normalize(vec3(0,1,0));\n    //vec3 right = normalize(vec3(1,0,0));\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - sdf_center, ray, 3.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    float min_dist = 1.0;\n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, sdf_center);\n        \n        min_dist = min(dist, min_dist);\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - sdf_center, p-sdf_center) > 27.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n    \n        // determine if we hit the fractal or not\n    float hit = step(dist, EPSILON);\n    \n    // calculate the brightness based on iterations used\n\tfloat di = (1.0 - (float(j) + (dist / EPSILON)*hit) / float(ITERATIONS));\n    float glow = 1.0 - (min_dist / 1.0);\n    \n\t//di = (di * hit) + (glow*(1.0-hit));\n    if (HIDE_BACKGROUND)\n    {\n    \tdi *= hit;\n    }\n\n    \n    \n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    //vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    \n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n}","name":"Image","description":"","type":"image"}]}