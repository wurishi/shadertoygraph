{"ver":"0.1","info":{"id":"ft3GWr","date":"1635955035","viewed":112,"name":"Angular Lighting 2","username":"spalmer","description":"more simple lit balls using cross product haxx rendered without any ray marching or equation root solving.\nalthought it does take a few sqrts per ball, here.\nSupports blending, fake depth of field","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lighting","shading","blend","normal","perspective","cross"],"hasliked":0,"parentid":"Nlc3z7","parentname":"Angular Lighting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Angular Lighting https://shadertoy.com/view/Nlc3z7\n// fork of Angular Distance https://shadertoy.com/view/sdGXzK\n\n// obtains view space normal estimate from cross product\n\n// no actual marching or root solving!\n\n// only loop here is brute-force iterating over all the balls\n// but could easily do something more clever there.\n\n// no shadows... it's not really intended for full lighting,\n// it's just a trick, really; if you go much further,\n// may as well do full ray-tracer or ray-marcher.\n\n// Have basic blending and defocus functioning.\n// Really it's just a bunch of composited sprites!\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy; float ry = min(r.x, r.y);\n    vec3 d = normalize(vec3((.5*r - p) / ry, -1)), normal = -.1*d, cp = vec3(0);\n    float N = 16., nearest = 9e9\n    , radius = .7, cov = .0; \n    for (float i = 1.; i > 0.; i -= 1./N) {\n        // point a in view coordinates, skipping transformation  ;)\n        // can actually do some of this in world coordinates (bounding test)\n        // but cannot do the normal there easily.  \n        // TODO Could try transforming L to world... \n        // it basically is in world already though since view not rotated here!\n        vec3 a = vec3(0,0,-9) + vec3(3.*sin(vec3(0,11,7) + .12*iTime + vec3(3,4,5) * .08*iTime + 6.28*i)); // animate dot pos relative eye\n        vec3 v = cross(d, a);\n        float aa = dot(a, a) // squared distance to point\n        , vv = dot(v, v);\n    //    if (dot(a, d) > 0.) // only if not behind camera! not needed here.. they never go behind camera\n        if (vv < radius * radius) { // only if hits ball!\n            float vl = sqrt(vv)   // need sqrt per ball    :(\n            , ve = vl - radius\n            , al = sqrt(aa);  // make that 2 sqrt per ball   :((\n            vec3 n = v / radius;\n            n.xy = -n.yx * vec2(-1,1); // un-cross-ify\n            n.z = sqrt(max(0., 1. - dot(n.xy, n.xy))); // compute normal.  3 sqrt per ball?  wah!   :(((\n            float z = al - n.z * radius\n            , focalplane = 10.\n            , defocus = min(1., abs(al - focalplane) * .05)\n            , newcov = min(1., -ve * r.y / al // antialias edge coverage\n                / (1. + defocus * ry/40.) // depth of field blur\n                );\n            if (z < nearest) { // keep nearest to camera!\n                cp = a;\n                nearest = z;\n                // if not completely covering pixel,\n                // blend over, keep some background\n                normal = mix(normal, n, newcov);\n            } else { // behind\n                newcov = max(0., newcov);\n                // if foreground edge was low coverage,\n                // should be able to see this through blur,\n                // so blend behind.\n                normal = mix(normal, n, (1.-cov) * newcov);\n            }\n            cov = mix(cov, 1., newcov);\n        }\n    }\n    normal = normalize(normal);\n    vec3 lp = vec3(0,2.*sin(.5*iTime),-9), l = normalize(lp - cp); //vec3 l = normalize(vec3(.6,.5,.7)); // point or directional light?\n    float nl = max(.04, dot(normal,l)); // diffuse lighting\n    vec3 c = vec3(nl * cov);\n    c *= mix(vec3(1), normal * .5 + .5, cos(.2*iTime)*cos(.2*iTime)); // show normals sometimes\n    vec3 lx = cross(d, lp); float ll = dot(lx, lx);\n    float cl = 1.2 * exp2(-6. * ll);  // halo to show light position\n    if (dot(lp, lp) > nearest*nearest)\n        cl *= 1.-cov;\n    c += cl;\n    o = vec4(pow(c, vec3(1./2.2)), 1);\n}","name":"Image","description":"","type":"image"}]}