{"ver":"0.1","info":{"id":"WsyXWc","date":"1575116991","viewed":2607,"name":"Dilation/Erosion filter","username":"tort32","description":"Morphology spatial operations with a shaped kernel in grayscale space\nhttps://en.wikipedia.org/wiki/Dilation_(morphology)\nhttps://en.wikipedia.org/wiki/Erosion_(morphology)","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["filter","imageprocessing","convolution","dilation","errosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int kernelRadius = 35;\n\nfloat convolute(vec2 uv, vec2 size, int radius) {\n    vec2 invSize = 1.0 / size;\n    float invKR = 1.0 / float(radius);\n    float acc = 0.0;\n    float w = 0.0;\n    for(int i = -radius; i <= radius; ++i) {\n        for(int j = -radius; j <= radius; ++j) {\n            vec2 rxy = vec2(ivec2(i, j));\n            vec2 kuv = rxy * invKR;\n            vec2 texOffset = uv + rxy * invSize;\n            float kernel = texture(iChannel1, vec2(0.5f) + kuv).x;\n            float tex = texture(iChannel0, texOffset).x;\n            acc += kernel * tex;\n            w += kernel;\n    \t}\n    }\n    return acc / w;\n}\n\nfloat dilate(vec2 uv, vec2 size, int radius) {\n    vec2 invSize = 1.0 / size;\n    float invKR = 1.0 / float(radius);\n    float acc = 0.0;\n    float w = 0.0;\n    for(int i = -radius; i <= radius; ++i) {\n        for(int j = -radius; j <= radius; ++j) {\n            vec2 rxy = vec2(ivec2(i, j));\n            vec2 kuv = rxy * invKR;\n            vec2 texOffset = uv + rxy * invSize;\n            float kernel = texture(iChannel1, vec2(0.5f) + kuv).x;\n            float tex = texture(iChannel0, texOffset).x;\n            float v = tex + kernel;\n            if(v > acc) {\n                acc = v;\n                w = kernel;\n            }\n    \t}\n    }\n    return acc - w;\n}\n\nfloat erose(vec2 uv, vec2 size, int radius) {\n    vec2 invSize = 1.0 / size;\n    float invKR = 1.0 / float(radius);\n    float acc = 1.0;\n    float w = 0.0;\n    for(int i = -radius; i <= radius; ++i) {\n        for(int j = -radius; j <= radius; ++j) {\n            vec2 rxy = vec2(ivec2(i, j));\n            vec2 kuv = rxy * invKR;\n            vec2 texOffset = uv + rxy * invSize;\n            float kernel = texture(iChannel1, vec2(0.5f) + kuv).x;\n            float tex = texture(iChannel0, texOffset).x;\n            float v = tex - kernel;\n            if(v < acc) {\n                acc = v;\n                w = kernel;\n            }\n    \t}\n    }\n    return acc + w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 size = iResolution.xy;\n    vec2 uv = fragCoord / size;\n    \n    // Double TexX coordinate for side-by-side preview\n    uv.x *= 2.0;\n    size.x *= 0.5f;\n\n    // Time varying pixel color\n    \n    float v = texture(iChannel0, uv).x;\n    \n    // Preview Kernel\n    //if(uv.y > 0.5) v = texture(iChannel1, uv).x;\n    \n    // Process image\n    if(uv.x > 1.0) {\n    \t//v = convolute(uv, size, kernelRadius);\n    \tv = dilate(uv, size, kernelRadius);\n        //if(uv.x > 1.0) v = erose(uv, size, kernelRadius);\n    }\n    \n    vec3 col = vec3(v);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generate kernel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float dx = 2.0 * (uv.x - 0.5);\n    float dy = 2.0 * (uv.y - 0.5);\n    float r = (dx * dx + dy * dy);\n    r = clamp(1.0 - r, 0.0, 1.0);\n    \n    vec3 col = vec3(r);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}