{"ver":"0.1","info":{"id":"M3BBDt","date":"1730171316","viewed":75,"name":"\"simple\" raytracer","username":"eliasmb","description":"текст на испанском языке","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, vec2 U) {\n  vec3 col = texture(iChannel0, U / iResolution.xy).rgb;\n  col = fromLinear(col);\n  O = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// math\nconst float PI = 3.1415926535;\nconst float PI2 = 2. * PI;\n\n\n// random number generator\nuint rngState;\nuint pcg() {\n  uint state = rngState * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  rngState = (word >> 22u) ^ word;\n  return rngState;\n}\nfloat random() {\n  return float(pcg()) * exp2(-32.);\n}\n// normalized random (https://github.com/SebLague/Ray-Tracing/blob/Episode01/Assets/Scripts/Shaders/RayTracing.shader)\nfloat normalRandom() {\n  float theta = PI2 * random();\n  float rho = sqrt(-2. * log(random()));\n  return rho * cos(theta);\n}\nvec3 randomDir() {\n  return normalize(vec3(normalRandom(), normalRandom(), normalRandom()));\n}\n\n// structure for storing materials and collision results\nstruct Material {\n  vec3 color;\n  float emission;\n  float roughness;\n};\nstruct HitInfo {\n  bool didHit;\n  float dst;\n  vec3 hitPoint;\n  vec3 normal;\n  vec2 uv;\n  Material mat;\n};\n\n// functions for texturing\nvec2 sphereUV(vec3 n) {\n  // thank you, randomdudewhocodes\n  return vec2(atan(n.z, n.x) + PI, acos(-n.y)) / vec2(PI2, PI);\n  /*\n  vec2 a = atan(n.xy, n.zz);\n  return a * .1591549431 + .5;\n  */\n}\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvec2 planeUV(vec3 n, vec3 q) {\n  vec3 b1, b2;\n  if(n.z < .0) {\n    float a = 1. / (1. - n.z);\n    float b = n.x * n.y * a;\n    b1 = vec3(1. - n.x * n.x * a, -b, n.x);\n    b2 = vec3(b, n.y * n.y * a - 1., -n.y);\n  } else {\n    float a = 1. / (1. + n.z);\n    float b = -n.x * n.y * a;\n    b1 = vec3(1. - n.x * n.x * a, b, -n.x);\n    b2 = vec3(b, 1. - n.y * n.y * a, -n.y);\n  }\n  return vec2(dot(b1, q), dot(b2, q));\n}\n\n// functions to detect intersection between ray and shapes (https://iquilezles.org/articles/intersectors/)\nbool raySphere(vec3 ro, vec3 rd, vec4 s, inout HitInfo h) {\n  vec3 off = ro - s.xyz;\n  float a = dot(rd, rd);\n  float b = 2. * dot(rd, off);\n  float c = dot(off, off) - s.w * s.w;\n  float delta = b * b - 4. * a * c;\n  if(delta >= .0) {\n    float dst = (-b - sqrt(delta)) / (2. * a);\n    if(dst > MIN_DIST && (!h.didHit || dst < h.dst)) {\n      h.didHit = true;\n      h.dst = dst;\n      h.hitPoint = ro + rd * dst;\n      h.normal = normalize(h.hitPoint - s.xyz);\n      h.uv = sphereUV(h.normal);\n      return true;\n    }\n  }\n  return false;\n}\n\nbool rayPlane(vec3 ro, vec3 rd, vec4 p, inout HitInfo h) {\n  float dst = -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n  if(dst > MIN_DIST && (!h.didHit || dst < h.dst)) {\n    h.didHit = true;\n    h.dst = dst;\n    h.normal = p.xyz * (dot(rd, p.xyz) <= 0. ? 1. : -1.);\n    h.hitPoint = ro + rd * dst;\n    h.uv = planeUV(p.xyz, h.hitPoint);\n    return true;\n  }\n  return false;\n}\n\n// transform x,y coordinates into a checkerboard texture\nbool chess(vec2 uv) {\n  uv = floor(uv);\n  return mod(uv.x + uv.y, 2.) == .0;\n}\n\n// main scene\nHitInfo rayScene(vec3 ro, vec3 rd) {\n  HitInfo h;\n  // checkered infinite plane\n  if(rayPlane(ro, rd, vec4(0, 1, 0, 1), h)) {\n    float a = chess(h.uv * 2.) ? 1. : .6;\n    h.mat = Material(vec3(a), .0, 1.);\n  }\n  \n  #if SCENE == 0\n  bool a = raySphere(ro, rd, vec4(-2.2, 1, 0, 2), h);\n  bool b = raySphere(ro, rd, vec4(2.2, 1, 0, 2), h);\n  if(a || b) {\n    vec3 rust = sqrt(texture(iChannel1, h.uv).rgb);\n    h.mat = Material(rust, .0, .0);\n  }\n  \n  if(raySphere(ro, rd, vec4(0, -.5, 0, .5), h)) {\n    h.mat = Material(vec3(1), 1., .0);\n  }\n  \n  #elif SCENE == 1\n  // light\n  if(raySphere(ro, rd, vec4(4, -.25, 2, .75), h)) {\n    h.mat = Material(vec3(1, 0, 0), 1., 1.);\n  }\n  if(raySphere(ro, rd, vec4(-.9, -.25, -1, .75), h)) {\n    h.mat = Material(vec3(0, 1, 0), 1., 1.);\n  }\n  if(raySphere(ro, rd, vec4(-4, -.25, 2, .75), h)) {\n    h.mat = Material(vec3(0, 0, 1), 1., 1.);\n  }\n  // checkered sphere\n  if(raySphere(ro, rd, vec4(-2.85, 0, 0, 1), h)) {\n    bool a = chess(h.uv * 20.);\n    vec3 col = a ? vec3(1) : vec3(1, .1, 0);\n    h.mat = Material(col, .0, .7);\n  }\n  // mirror sphere\n  if(raySphere(ro, rd, vec4(2.08, 1, 0, 2), h)) {\n    vec3 rust = sqrt(texture(iChannel1, h.uv).rgb);\n    h.mat = Material(rust, .0, .0);\n  }\n  #endif\n  \n  return h;\n}\n\n// basic horizon effect\nvec3 environment(vec3 rd) {\n  vec3 a = vec3(1, .2, .1);\n  vec3 b = vec3(.2, .25, .4);\n  return mix(a, b, .5 + rd.y * .5);\n}\n\nvec3 rayTrace(vec3 ro, vec3 rd) {\n  vec3 incoming = vec3(0);\n  vec3 color = vec3(1);\n  for(int i = 0; i < BOUNCES; i++) {\n    HitInfo h = rayScene(ro, rd);\n    if(!h.didHit) {\n      incoming += toLinear(environment(rd)) * color;\n      break;\n    }\n    \n    ro = h.hitPoint + h.normal * ORIGIN_NUDGE;\n    \n    vec3 dd = normalize(h.normal + randomDir());\n    vec3 sd = reflect(rd, h.normal);\n    rd = normalize(mix(sd, dd, h.mat.roughness * h.mat.roughness));\n    \n    incoming += h.mat.color * h.mat.emission * color;\n    color *= h.mat.color;\n  }\n  return clamp(incoming, .0, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n  vec2 R = iResolution.xy;\n  \n  // initialize pcg state\n  uint pixelIndex = uint(U.x) + uint(U.y) * uint(R.x);\n  rngState = pixelIndex + uint(iFrame) * uint(R.x) * uint(R.y);\n  \n  // camera\n  vec2 jitter = vec2(random(), random()) - .5;\n  vec2 uv = (2. * (U + jitter) - R) / R.y;\n  \n  vec3 ro = vec3(0, 1.5, 9);\n  vec3 rd = normalize(vec3(uv, -1.73));\n  \n  vec3 col = rayTrace(ro, rd);\n  \n  vec4 old = texture(iChannel0, U / R);\n  float alpha = (old.a == .0 || iMouse.w > .0) ? 1. : (1. / (1. + (1. / old.a)));\n  col = mix(old.rgb, col, alpha);\n  \n  O = vec4(col, alpha);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SCENE        0\n#define BOUNCES      50\n#define MIN_DIST     .001\n#define ORIGIN_NUDGE .001\n\n// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl (Tynach)\nvec3 fromLinear(vec3 linearRGB) {\n  bvec3 cutoff = lessThan(linearRGB, vec3(.0031308));\n  vec3 higher = 1.055 * pow(linearRGB, vec3(.4166666666)) - .055;\n  vec3 lower = linearRGB * 12.92;\n  return mix(higher, lower, cutoff);\n}\nvec3 toLinear(vec3 sRGB) {\n  bvec3 cutoff = lessThan(sRGB, vec3(.04045));\n  vec3 higher = pow((sRGB + .055) * .9478672986, vec3(2.4));\n  vec3 lower = sRGB * .773993808;\n  return mix(higher, lower, cutoff);\n}","name":"Common","description":"","type":"common"}]}