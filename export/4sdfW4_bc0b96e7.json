{"ver":"0.1","info":{"id":"4sdfW4","date":"1525172558","viewed":176,"name":"number (or anything) printer","username":"akhgary","description":"a simple digit printer using table of tables. each row in this table is itself a table.\nfor example row 5 contains a table for digit 5, and row 11 contains a table for negative sign.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["text","number","numbers","map","string","digit","table","digits","show","print"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ==========================================\n// Digit printer\n//\n// the table contains twoelve 5x6 tables.\n// a 5x6 grid contains fair amount of detail \n// for mapping letters and more symbols as well.\n//\n// the grid size and patterns was taken from a calculator :P\n//\n// ==========================================\n//\n// if you want to add more characters, for example \"A\"\n//\n// 0###0\n// #000#\n// #000#\n// #####\n// #000#\n// #000#\n//\n// write the bitmask for it and convert them to base 10.\n//\n// 01110 = 14\n// 10001 = 17\n// 10001 = 17\n// 11111 = 31\n// 10001 = 17\n// 10001 = 17\n//\n// then put them in the table from bottom to top.\n//\n// 17, 17, 31, 17, 17, 14\n//\n// number of row in the table indicates the index of this character.\n//\n// ==========================================\n// rectangle drawing:\n// https://thebookofshaders.com/07/\n// ==========================================\n\n// display properties\nconst float scale = 1.;\nconst bool separator = false;\n\n// number properties\nconst float width = 0.5;\nconst float height = 0.5;\nconst float spacing = 0.1;\nconst int decimals = 2;\nconst vec2 position = vec2(0);\nconst bool putCenter = true;\n\n// table properties\nconst int columns = 5;\nconst int rows = 6;\nconst int tableCol = 6;\nint[] table = int[](\n14, 17, 25, 21, 19, 14, // 0\n14,  4,  4,  4, 12,  4, // 1\n31,  8,  4,  2, 17, 14, // 2\n14, 17,  1,  6,  1, 31, // 3\n 2, 31, 18, 10,  6,  2, // 4\n14, 17,  1, 30, 16, 31, // 5\n14, 17, 17, 30, 16, 14, // 6\n 4,  4,  4,  2,  1, 31, // 7\n14, 17, 17, 14, 17, 14, // 8\n14,  1, 15, 17, 17, 14, // 9\n12, 12,  0,  0,  0,  0, // .\n 0,  0, 31,  0,  0,  0, // -\n 4,  4, 31,  4,  4,  0);// +\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\n//    print(uv, center, width, height, index)\nfloat print(vec2 uv, vec2 c, float w, float h, int ind)\n{\n    float r = 0.;\n    vec2 wh = vec2(w/float(columns),h/float(rows));\n    vec2 o =  vec2(w,h)/2.; // origin\n    vec2 bmin=c-o, bmax=c+o; // min and max boundaries\n    \n    // no need to render ouside boundaries.\n    if(uv.x<bmin.x||uv.y<bmin.y|| \n       uv.x>bmax.x||uv.y>bmax.y) return 0.;\n    \n    c = bmin; // move center to the origin\n    for(int row=0;row<rows;row++){\n        int map = table[ind*tableCol+row];\n        for(int col=0;col<columns;col++){\n            vec2 p0 = c+wh*vec2(col,row), p1 = p0+wh;\n            vec2 lb = step(p0,uv);\n            vec2 ub = 1.-step(p1,uv);\n            \n            int shift = columns-col-1;\n            if(((map&(1<<shift))>>shift)==1) \n                r += lb.x*lb.y*ub.x*ub.y;\n        }\n    }\n    return r;\n}\n\nfloat printNumber(vec2 uv, vec2 c, float w, float h, float num, int decN, float spacing, bool center)\n{\n    w*=iResolution.y/iResolution.x; // keep aspect ratio\n    spacing*=iResolution.y/iResolution.x;\n    \n    float r = 0.;\n    bool neg = num<0.; num=abs(num);\n    float cd = float(decN);\n    float cn = max(ceil(log(num)/log(10.)),1.);\n    float dec = fract(num)*pow(10.,float(decimals));\n    \n    if(center) // move to origin\n    {\n        c.x += (cn+cd-1.)*(w+spacing)/2.;\n        if(decN>0) c.x+=spacing;\n        if(neg)c.x+=(w+spacing)/2.;\n    }\n    else\n    {\n        c.x += (cn+cd-1.)*(w+spacing)+w;        \n        if(decN>0) c.x+=spacing*2.;\n        if(neg)c.x+=w+spacing;\n    }\n        \n    // print fractions\n    for(int i=0;i<decN;i++,dec/=10.){\n        int val = int(mod(dec,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(decN>0) // print dot separator\n    {\n        c.x+=spacing;\n        r += print(uv, c, w, h, 10);\n        c.x-=w;\n    }\n    // print whole part\n    for(int i=0;i<int(cn);i++,num/=10.){\n        int val = int(mod(num,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(neg) r+=print(uv, c, w, h, 11); // print sign\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    vec3 col = vec3(0);\n    \n    col += printNumber(uv,position,width,height,iTime,decimals,spacing,putCenter);\n    \n    if(separator)\n        if(uv.x<0.02&&uv.x>-0.02) \n            col = vec3(0.5,0,0);\n    \n    fragColor = vec4(col*(.5+.5*cos(iTime+uv.xyx+vec3(0,2,4))),1.0);\n}","name":"Image","description":"","type":"image"}]}