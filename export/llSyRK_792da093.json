{"ver":"0.1","info":{"id":"llSyRK","date":"1509172093","viewed":150,"name":"De Rham Curves 3","username":"rory618","description":"perform a search on mapping of [0,1] to an x,y on the curve to find the closest point.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A : slider management (this is not required)\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.625,0.375,.5,0.5); //Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = textureLod(iChannel0,vec2(0),0.0);\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n\n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define scale 1.\n#define shift vec2(0)\n\n#define d0 mat3(1,0,0,0,a,d,0,b,e)\n#define d1 mat3(1,0,0,a,1.-a,l,b,-b,n)\n\n#define R (iResolution.xy)\n#define iter 12\n\nfloat d,e,l,n,a,b;\n\nvec2 DeRham(float t){\n    int f = int(t * float(2<<iter));\n    vec2 z = vec2(f&1,0);\n    f /= 2;\n    for(int i = 0; i < iter; i++){\n        \n        z=(vec3(1,z)*(1==(f&1)?d1:d0)).yz;\n    f /= 2;\n        \n    }\n    \n    return z;\n}\n\nvec4 processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel1,vec2(0,0));\n\td  = (sliderVal[2]+sliderVal[0])*2.0-2.;\n\te  = (sliderVal[1]-sliderVal[3])*2.0;\n\tl  = (sliderVal[2]-sliderVal[0])*2.0;\n\tn  = (sliderVal[1]+sliderVal[3])*2.0-2.;\n    \n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n    \treturn texture(iChannel1,fragCoord.xy/iResolution.xy);\n    }\n    return vec4(0);\n}\n\nfloat hash( in float n ) { return fract(sin(n)*43758.5453123 + iTime); }\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    float light = 0.0;\n    processSliders(I);\n    \n    vec2 uv = vec2(I)/R*scale-shift;;\n    vec2 t = iMouse.x==0.?vec2(.5,.5):iMouse.xy/R*scale-shift;\n    \n    a=texelFetch(iChannel2,ivec2(77,2),0).x==0.?.5:t.x;\n    b=texelFetch(iChannel2,ivec2(77,2),0).x==0.?1.:t.y;\n\n\tfloat r = hash( dot(I.xy,vec2(113.0,317.0)) );\n    float p = .5;\n\tfloat dm = 9e9;\n    float s = .5;\n    float col = 0.;\n    \n    vec2 z = DeRham( p );\n    float dc = length(((z*scale-shift)-uv)*R);\n    vec2 zu;\n    vec2 zd;\n    for(int i = 0; i < 16; i++){\n        \n        float pr = p + (r-.5) * s;\n        vec2 zr = DeRham( pr );\n        zu = DeRham( p + s * (.90+.2*r));\n        zd = DeRham( p - s * (.90+.2*r));\n        \n        r = hash(r+.432*float(i));\n        \n        float dr = length(((zr*scale-shift)-uv)*R);\n        float du = length(((zu*scale-shift)-uv)*R);\n        float dd = length(((zd*scale-shift)-uv)*R);\n        \n        float mn = min(dc,min(dr,min(du,dd)));\n        \n        if(mn==dr){\n            z = zr;\n            p = pr;\n        } else \n        if(mn==du){\n            z = zu;\n            p = p+s;\n        } else if(mn==dd) {\n            z = zd;\n            p = p-s;\n        }\n        \n        dc = mn;\n        \n        s = .73*dc/(R.y);\n        \n\t    dm = min(dm,mn);\n    }\n    \n    \n\tcol += (1.-.5*dm);\n\n    col = max(0.,col);\n    \n    \n    col += exp(-.12*length(((DeRham( .5+.5*sin(.2*iTime) )*scale-shift)-uv)*R));\n    \n    \n    \n    o = vec4( col, col, col, 1.0 );\n    \n    \n    \n    vec4 cSlider = processSliders(I);\n    o.xyz = mix(o.xyz,cSlider.rgb,cSlider.a);\n    o = mix(o, texelFetch(iChannel0, ivec2(I),0),.75 );\n}","name":"Buf B","description":"","type":"buffer"}]}