{"ver":"0.1","info":{"id":"3dXSDH","date":"1551132995","viewed":2357,"name":"[twitch] Corroded Beasts","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl","likes":70,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fractal(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat map(vec3 p) {\n\n  \n  float t1 = time;\n  float o = noise(p*3.0 + t1*0.2);\n  p += (noise(p*10.0 + t1*0.7)-0.5)*0.1;\n  p += tunnel(p);\n  \n  float s=10.0;\n  p.xy = (fract(p.xy/s-0.5)-0.5)*s;\n\n  vec3 p1=p;\n  p1.xy *= rot(p.z*0.2+sin(p.z*1.8)*0.2 + t1*0.1);\n  \n  p1=moda(p1.xzy, 5.0, 0.0);\n  float d = cyl(p1.xz-vec2(1,0),0.0+o*0.3-0.1)+0.1;\n  \n  vec3 p2=p;\n  p2.xy *= rot(p.z*1.2+sin(p.z*0.8)*0.3 + t1*0.13);\n  \n  p2=moda(p2.xzy, 9.0,sin(p2.z)*0.9);\n  float d2 = cyl(p2.xz-vec2(1.3,0),0.05);\n  \n  d=smin(d, d2, 0.9);\n  \n  return d;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat dots(vec3 p, float j) {\n  float v=0.0;\n  \n  p*=4.0+1.0*sin(j);\n  p.x += rnd(floor(p.y));\n\n  p*=PI;\n  v += clamp(0.1-length(vec2(sin(p.x),cos(p.y))),0.0,1.0)*10.3;\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-3);\n  vec3 t=vec3(0,0,0);\n  float t2 = time*0.5;\n  s.x += sin(t2*0.7)*0.5;\n  s.y += sin(t2*0.9)*0.5;\n\n  s.z += t2;\n  t.z += t2;\n  s -= tunnel(s);\n  t -= tunnel(t);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  int i=0;\n  float mask=1.0;\n  float d = 10000.0;\n\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(; i<MARCH_STEPS; ++i) {\n    d=map(p);\n    if(abs(d)<0.001) {\n      mask=0.0;\n      break;\n    }\n    p+=r*d*dither;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n\n  float aodist=0.7;\n  float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  float diff = fractal(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  float len = length(p-s);\n  col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  vec3 col2 = vec3(0);\n  for(int j=1; j<PART_COUNT; ++j) {\n    float dist = float(j) * 0.2/r.z;\n    if(dist>len) break;\n    vec3 vp = vec3(s.x,s.y,0) + r*dist;\n    vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n    \n    col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  }\n  col += col2 * back;\n\n  col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}