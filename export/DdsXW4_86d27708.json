{"ver":"0.1","info":{"id":"DdsXW4","date":"1668901117","viewed":205,"name":"Double Bubble","username":"stb","description":"This shader produces the correct inner wall between two touching circles.\nFor use in bubble modeling.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["2d","circle","bubble","surface","minimal","diagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tDouble Bubble\n\t2022 stb\n    \n    This shader produces the correct inner surface (cap) between two touching circles of differing radii.\n    For use in bubble modeling.\n    \n    Not golfed... at all :D A lot of this can be simplified, even without golfing I'm sure.\n    \n    Here's the basic idea (I hope this makes sense):\n    1) Find an intersection point between two touching circles.\n    2) Find the common angle between the circles at the point of intersection (short line with two free\n    ends in the drawing).\n    3) Find a new point of intersection by extending a line from the circle-circle intersection,\n    perpendicular to the direction in step 2), to the common axis between both circle centers.\n    4) Calculate the distance from the new intersection point to the circle-circle intersection point.\n    Now you have the new circle's center and radius.\n    \n    ~~~\n    \n    Edit: Cleaned up the code, removed unused stuff, added more guide lines and comments, and made the\n    line thickness resolution-independent.\n    \n    Edit 2: It now works on only one axis, since nothing more needed. Added new line guides and a new\n    dashed line function (WIP). More comments to help clarify things. Previous code is included at the bottom.\n    \n*/\n\n\n/** Circle Definitions **/\n\n// circle centers (along x-axis)\n#define PointA  -.5\n#define PointB  .4\n\n// circle radii\n#define RadiusA 1.\n#define RadiusB .69 // (don't make this equal to Radius A)\n\n\n/** Drawing Functions **/\n\n// circle function\nfloat circle(vec2 p, vec2 o, float r) {\n    return abs(length(p-o)-r);\n}\n\n// Self-contained line function. Not the best; not the worst (maybe).\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = normalize(p1-p0);\n    float l = .5 * length(p1-p0);\n    p -= p0;\n    if(length(p0-p1)>0.) {\n        p = mat2(d.y, d.x, -d.x, d.y) * p;\n        p.y = max(0., abs(p.y-l)-l);\n    }\n    return length(p);\n}\n\nfloat lineDashed(in vec2 p, vec2 p0, vec2 p1, float freq) {\n    return max(fract(freq*dot(p-p0,normalize(p0-p1))+.5)-.5, line(p, p0, p1));\n}\n\n\n/** Vital Function **/\n\n// find an intersection point between 2 circles (two are possible, only one is used)\n// 1st point, 1st radius, 2nd point, 2nd radius\nvec2 Get_CC_Intersection(vec2 p0, float r0, vec2 p1, float r1) {\n\tfloat d = length(p1-p0);\n\tfloat a = (r0*r0-r1*r1+d*d) / (2.*d);\n\tfloat h = sqrt(r0*r0-a*a);\n\tvec2 p2 = p0 + a * (p1-p0) / d;\n\treturn vec2(p2.x + h*(p0.y-p1.y) / d, p2.y - h*(p0.x-p1.x) / d);\n}\n\n\n/** Main **/\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = 3. * (fc-res/2.) / res.y;\n    \n    \n    //~~ Circle Definitions (positions & radii) ~~//\n    \n    vec2 P0 = vec2(PointA, 0.), P1 = vec2(PointB, 0.);\n    float R0 = RadiusA, R1 = RadiusB;\n        \n    // mouseplay for circle #2\n    if(iMouse.z>0.) P1.x = 3. * (iMouse.x-res.x/2.)/res.y;\n    \n    \n    //~~ Calculations ~~//\n    \n    // get an intersection point from two touching circles\n    vec2 IP = Get_CC_Intersection(P0, R0, P1, R1);\n    \n    \n    \n\n    // direction between 1st circle & intersection point\n    vec2 PIP0 = normalize(IP-P0);\n\n    // direction between 2nd circle & intersection point\n    vec2 PIP1 = normalize(IP-P1);\n\n    // Trace direction. It's the average of PIP0 & PIP1. It will be rotated 90 degrees later.\n    vec2 TrDir = normalize(PIP0+PIP1);\n\n    // invert TrDir if R1>R0\n    if(R1>R0) TrDir = -TrDir;\n\n\n    //~~ Goal: the center & radius of the interior curved wall ~~//\n\n    // wall center (finds x-intercept from circ-circ intersection to x-axis)\n    vec2 WC  = vec2(IP.x+IP.y/TrDir.x*TrDir.y, 0.);\n\n    // wall radius\n    float WR = length(p-WC)-length(WC-IP);\n   \n    \n    //~~ Drawing ~~//\n    \n    float f = 1.;\n    \n    // line thickness\n    float th = 2. / res.y;\n    \n    // outline for both circles\n    float outline = min(length(p-P0)-R0, length(p-P1)-R1);\n    f = abs(outline) - 5. * th;\n    \n    // 1st & 2nd circles\n    f = min(f, circle(p, P0, R0)-th);\n    f = min(f, circle(p, P1, R1)-th);\n    \n    // 1st & 2nd circle centers\n    f = min(f, circle(p, P0, 2.*th)-2.*th);\n    f = min(f, circle(p, P1, 2.*th)-2.*th);\n    \n    // x-axis (extending through circle centers)\n    f = min(f, line(p, vec2(-3., 0.), vec2(3., 0.))-th);    \n    \n    \n    // dashed lines extending from centers of circles to an intersection they share\n    f = min(f, lineDashed(p, P0, IP, .015/th)-th);    \n    f = min(f, lineDashed(p, P1, IP, .015/th)-th);\n\n    // if radii are not equal\n    if(R0!=R1) {\n        // dashed line between circles at point of intersection\n        f = min(f, lineDashed(p, IP+.65*TrDir, IP-.65*TrDir, .04/th)-th);    \n\n        // dashed line from intersection of circles, extending to x-axis\n        f = min(f, lineDashed(p, IP, WC, .1/th)-th);    \n\n        // curved line joining the cicles (the entire point of this shader)\n        float f2 = WR;\n        f = min(f, abs(max(f2, outline))-5.*th);\n\n        // curved line again, but showing the full circle\n        f = min(f, circle(p, WC, length(WC-IP))-th);\n\n        // curved line center\n        f = min(f, circle(p, WC, 2.*th)-2.*th);\n    }\n    // if radii are equal\n    else {\n        // since we can't intersect a parallel line, I just extend the guide line to the right\n        if(length(P1-P0)<R0+R1)\n            f = min(f, lineDashed(p, IP, IP+vec2(9, 0), .1/th)-th);    \n        \n        // the curved wall is now just a line\n        f = min(f, line(p, IP, vec2(IP.x, -IP.y))-5.*th); \n    }\n\n    // antialising for all lines\n    float aa = 4./res.y;\n    f = smoothstep(-aa, aa, f);\n\n    \n    //~~ Output ~~//\n\tfo = vec4(vec3(f), 1.);\n}\n\n/*\n// sanity check stuff\n\n// find the intersection of 2 lines\nvec2 LineLine_Intersect(vec2 A, vec2 B, vec2 C, vec2 D) {\n    float MAB = (A.y-B.y) / (A.x-B.x);\n    float MCD = (C.y-D.y) / (C.x-D.x);\n    float IAB = B.y - MAB * B.x;\n    float ICD = D.y - MCD * D.x;\n    float IX = (ICD-IAB) / (MAB-MCD);\n    return vec2(IX, MAB * IX + IAB);\n}\n    vec2 WC = LineLine_Intersect(P0, P1, IP, IP-vec2(TrDir.y, -TrDir.x));\n*/\n\n\n/*\n// previous code\n/*\n\n\tDouble Bubble\n\t2022 stb\n    \n    This shader produces the correct curved line (it must have a real name) between two touching circles\n    of differing radii. For use in bubble modeling.\n    \n    Not golfed... at all :D A lot of this can be simplified, even without golfing I'm sure.\n    \n    Here's the basic idea (I hope this makes sense):\n    1) Find an intersection point between two touching circles.\n    2) Find the common angle between the circles at the point of intersection (short line in the drawing).\n    3) Find a new point of intersection by extending a line from the circle-circle intersection,\n    perpendicular to the direction in step 2), to the common axis between both circle centers.\n    4) Calculate the distance from the new intersection point to the circle-circle intersection point.\n    Now you have the new circle's center and radius.\n    \n    ~~~\n    \n    Edit: Cleaned up the code, removed unused stuff, added more guide lines and comments, and made the\n    line thickness resolution-independent.\n    \n*/\n\n/*\n// you can play with the circle centers and radii\n#define PointA  vec2(-.5, -.25)\n#define PointB  vec2(.35, 0.)\n#define RadiusA 1.\n#define RadiusB .69 // (don't make this equal to Radius A)\n\n// circle function\nfloat circle(vec2 p, vec2 o, float r) {\n    return abs(length(p-o)-r);\n}\n\n// Self-contained line function. Not the best; not the worst (maybe).\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = normalize(p1-p0);\n    float l = .5 * length(p1-p0);\n    p -= p0;\n    if(length(p0-p1)>0.) {\n        p = mat2(d.y, d.x, -d.x, d.y) * p;\n        p.y = max(0., abs(p.y-l)-l);\n    }\n    return length(p);\n}\n\n// find the intersection of 2 lines\nvec2 LineLine_Intersect(vec2 A, vec2 B, vec2 C, vec2 D) {\n    float MAB = (A.y-B.y) / (A.x-B.x);\n    float MCD = (C.y-D.y) / (C.x-D.x);\n    float IAB = B.y - MAB * B.x;\n    float ICD = D.y - MCD * D.x;\n    float IX = (ICD-IAB) / (MAB-MCD);\n    return vec2(IX, MAB * IX + IAB);\n}\n\n// find an intersection point between 2 circles (two are possible, only one is used)\n// 1st point, 1st radius, 2nd point, 2nd radius\nvec2 CC_GetIntersectionPoint(vec2 p0, float r0, vec2 p1, float r1) {\n\tfloat d = length(p1-p0);\n\tfloat a = (r0*r0-r1*r1+d*d) / (2.*d);\n\tfloat h = sqrt(r0*r0-a*a);\n\tvec2 p2 = p0 + a * (p1-p0) / d;\n\treturn vec2(p2.x + h*(p0.y-p1.y) / d, p2.y - h*(p0.x-p1.x) / d);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = 3. * (fc-res/2.) / res.y;\n    \n    // circle positions\n    vec2 P0=PointA, P1=PointB;\n    float R0 = RadiusA, R1=RadiusB;\n        \n    // allow mouseplay for circle #2\n    if(iMouse.z>0.) P1 = 3.*(iMouse.xy-res/2.)/res.y;    \n\n    // get an intersection point from two touching circles\n    vec2 IP = CC_GetIntersectionPoint(P0, R0, P1, R1);\n    \n    // direction between 1st circle & intersection point\n    vec2 PIP0 = normalize(IP-P0);\n    \n    // direction between 2nd circle & intersection point\n    vec2 PIP1 = normalize(IP-P1);\n    \n    // Trace direction. It's the average of PIP0 & PIP1. It will be rotated 90 degrees later.\n    vec2 TrDir = (PIP0+PIP1) / 2.;\n\n    // invert TrDir if R1>R0\n    if(R1>R0) TrDir = -TrDir;\n\n    // interior wall origin (from circles intersection to axis between circles)\n    vec2 WP = LineLine_Intersect(P0, P1, IP, IP-vec2(TrDir.y, -TrDir.x));\n        \n    float f = 1.;\n    \n    // line thickness\n    float th = 2. / res.y;\n    \n    //drawing\n    \n    // outline for both circles\n    float outline = min(length(p-P0)-R0, length(p-P1)-R1);\n    f = abs(outline)-5.*th;\n    \n    // 1st circle\n    f = min(f, circle(p, P0, R0)-th);\n    \n    // 1st circle center\n    f = min(f, circle(p, P0, 2.*th)-2.*th);\n    \n    // 2nd circle\n    f = min(f, circle(p, P1, R1)-th);\n    \n    // 2nd circle center\n    f = min(f, circle(p, P1, 2.*th)-2.*th);\n    \n    // axis between circle centers\n    f = min(f, line(p, P0+32.*(P0-P1), P1+32.*(P1-P0))-th);    \n    \n    // axis between circles at point of intersection\n    f = min(f, line(p, IP+.75*TrDir, IP-.75*TrDir)-th);    \n    \n    // line from intersection of circles, extending to axis\n    f = min(f, line(p, IP, WP)-th);    \n    \n    // curved line joining the cicles (the entire point of this shader)\n    float f2 = (length(p-WP)-length(WP-IP));\n    f = min(f, abs(max(f2, outline))-5.*th);\n    \n    // curved line again, but showing the full circle\n    f = min(f, circle(p, WP, length(WP-IP))-th);\n    \n    // curved line center\n    f = min(f, circle(p, WP, 2.*th)-2.*th);\n\n    float aa = 4./res.y;\n    f = smoothstep(-aa, aa, f);\n\n    // output\n\tfo = vec4(vec3(f), 1.);\n}\n\n/*\n\n// POV-Ray code\n\n#version 3.7;\n\nglobal_settings{\n\tassumed_gamma 1.0\n\tcharset utf8\n}\n\n#default{ finish{ambient 1} }\n\n#declare CScale = 2.5;\n\ncamera{\n\torthographic\n\tright x*2 up y*2\n\tlocation -z*2\n\tlook_at 0\n\tscale CScale\n}\n\nbackground{rgb 0}\n\n#declare Lth = 2 * CScale / image_width;\n\n\n// macros\n\n// macro to find intersection of 2 lines\n#macro LineLine_Intersect(A, B, C, D)\n\t#local MAB = (A.y-B.y) / (A.x-B.x);\n\t#local MCD = (C.y-D.y) / (C.x-D.x);\n\t#local IAB = B.y - MAB * B.x;\n\t#local ICD = D.y - MCD * D.x;\n\t#local IX = (ICD-IAB) / (MAB-MCD);\n  (<IX, MAB * IX + IAB, 0>)\n#end\n\n// gets an intersection point between 2 circles (two are possible, only one is used)\n// 1st point, 1st radius, 2nd point, 2nd radius\n#macro CC_GetIntersectionPoint(p0, r0, p1, r1)\n\t#local d = vlength(p1-p0);\n\t#local a = (r0*r0-r1*r1+d*d) / (2*d);\n\t#local h = sqrt(r0*r0-a*a);\n\t#local p2 = p0 + a * (p1-p0) / d;\n\t(<p2.x + h*(p0.y-p1.y) / d, p2.y - h*(p0.x-p1.x) / d>)\n#end\n\n// gets the intersection angle between 2 circles, requires an intersection point\n#macro CC_GetIntersectionAngle(p0, p1, ip)\n\t#local t0 = vnormalize(ip-p0);\n\t#local t1 = vnormalize(ip-p1);\n\t#local t0 = <-t0.y, t0.x>;\n\t#local t1 = <t1.y, -t1.x>;\n\t(degrees(acos(min(1, vdot(vnormalize(t0), vnormalize(t1))))))\n\t//(VAngleD(t0, t1))\n#end\n\n\n// declare circle points and radii\n#declare P0 = <-.5, -.25>;\n#declare R0 = 1;\n#declare P1 = <.35, 0>;\n#declare R1 = .69;\n\n// get an intersection point and intersection angle\n#declare IP = CC_GetIntersectionPoint(P0, R0, P1, R1);\n#declare IA = CC_GetIntersectionAngle(P0, P1, IP);\n\n// get origin and radius for interior bubble wall\n\n// set up trace variables\n#declare PIP0 = vnormalize(IP-P0);\n#declare PIP1 = vnormalize(IP-P1);\n#declare TrDir = (PIP0+PIP1) / 2;\n\n// invert TrDir if R1>R0\n#if(R1>R0) #declare TrDir = -TrDir; #end\n\n// interior wall origin\n#declare WP = LineLine_Intersect(P0, P1, IP, IP-<TrDir.y, -TrDir.x, 0>);\n\n// visualization\n\n// \"merged\" circles and common vector\nunion{\n\ttorus{R0, Lth\n\t\trotate x*90\n\t\ttranslate P0\n\t\tclipped_by{\n\t\t\tsphere{WP, vlength(WP-IP) inverse}\n\t\t}\n\t}\n\ttorus{R1, Lth\n\t\trotate x*90\n\t\ttranslate P1\n\t\tclipped_by{\n\t\t\tsphere{WP, vlength(WP-IP)}\n\t\t}\n\t}\n\tcylinder{P0, P1, Lth}\n\tcylinder{P0-10*vnormalize(P0-P1), P1+10*vnormalize(P0-P1), Lth/2 pigment{rgb y/4}}\n\tpigment{rgb y/4+z}\n}\n\n// \"discarded\" circle segments\nunion{\n\ttorus{R0, Lth/2\n\t\trotate x*90\n\t\ttranslate P0\n\t\tclipped_by{\n\t\t\tsphere{WP, vlength(WP-IP)}\n\t\t}\n\t}\n\ttorus{R1, Lth/2\n\t\trotate x*90\n\t\ttranslate P1\n\t\tclipped_by{\n\t\t\tsphere{WP, vlength(WP-IP) inverse}\n\t\t}\n\t}\n\tpigment{rgb (y/4+z)/8}\n}\n\n// angle\ntext{\n\tttf \"arialbd\"\n\tconcat(str(IA, 0, 2), chr(176))\n\t1 0\n\tscale .1 * CScale\n\ttranslate CScale * -(x+y) * .95\n\tpigment{rgb x/2}\n}\n\n// circle intersection to circle origins\ncylinder{IP, IP-PIP0, Lth/2 pigment{rgb x/2}}\ncylinder{IP, IP-PIP1, Lth/2 pigment{rgb x/2}}\n\n// midpoint of the above\ncylinder{IP, IP-TrDir, Lth/2 pigment{rgb x+y/2}}\n\n// circle intersection to interior wall origin\ncylinder{IP, WP, Lth/2 pigment{rgb x+y}}\n\n// interior wall\ntorus{\n\tvlength(WP-IP), Lth\n\trotate x*90\n\ttranslate WP\n\tclipped_by{\n\t\tsphere{P0, R0}\n\t}\n\tpigment{rgb y/4+z}\n}*/\n","name":"Image","description":"","type":"image"}]}