{"ver":"0.1","info":{"id":"ll2SDw","date":"1444305939","viewed":272,"name":"Follow the mouse test","username":"Sleicreider","description":"I am a noob\nTest code","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\nstruct Rect\n{\n    float width;\n    float height;\n    float x;\n    float y;\n    vec3  color;\n    float rotation;\n    \n    vec2 csys; //it's own coordinate system\n};\n    \nRect CreateRect(float width, float height, float x, float y, vec3 color)\n{\n    Rect rect;\n    \n    rect.width = width;\n    rect.height = height;\n    rect.x = x;\n    rect.y = y;\n    rect.color = color;\n    \n    return rect;\n}\n\nvoid DrawRect(inout Rect rect,vec2 p, inout vec3 pix)\n{\n   \tfloat dx = p.x - rect.x;\n    float dy = p.y - rect.y;\n    \n    dx = cos(rect.rotation)*(p.x - rect.x) + sin(rect.rotation)*(p.y - rect.y);\n    dy = -sin(rect.rotation)*(p.x - rect.x) + cos(rect.rotation)*(p.y - rect.y);\n    \n    float fL = - rect.width/2.;  //far left\n    float fR = + rect.width/2.;  //far right\n    float fT = + rect.height/2.; //far top\n    float fB = - rect.height/2.; //far bottom\n\n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,dx);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,dx);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,dy);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,dy);\n    \n    float d = 0.005;\n    \n    if(dx > fL-d && dx < fR+d \n    && dy < fT+d && dy > fB-d)\n    {\n        pix = mix(pix,rect.color,del);\n    }\n    \n    rect.csys = vec2(dx,dy);\n}\n\nvoid AddRectTo(Rect rect,Rect target, inout vec3 pix)\n{\n    vec2 p = target.csys;\n    \n    float fL = rect.x - rect.width/2.;\n    float fR = rect.x + rect.width/2.;\n    float fT = rect.y + rect.height/2.;\n    float fB = rect.y - rect.height/2.;\n    \n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,p.x);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,p.x);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,p.y);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,p.y);\n    \n    float d = 0.005;\n    \n    if(p.x > fL-d && p.x < fR+d \n    && p.y < fT+d && p.y > fB-d)\n    {\n\t\tpix = mix(pix,rect.color,del);\n    }\n}  \n\nfloat GetMouseFollowRotationAngle(Rect r1, vec2 m)\n{\n    float cx = r1.x;\n    float cy = r1.y;\n\tfloat tx = m.x;\n    float ty = m.y;\n    \n    float nx = tx-cx;\n    float ny = ty-cy;\n    \n    float distance = sqrt(pow(nx,2.) + pow(ny,2.));\n    \n    float new_angle = atan(ny,nx);\n    \n    //if(ty < 0.) { new_angle = asin((ty-cy)/distance); }\n    \n    return new_angle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.*vec2(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n        vec2 m = 2.*vec2(iMouse.xy - .5*iResolution.xy)/iResolution.y;\n\n    Rect r1 = CreateRect(0.5,0.5,0.,.0,vec3(1.));  \n    r1.rotation = GetMouseFollowRotationAngle(r1,m);\n    \n    vec3 bg = vec3(0.);\n    vec3 pixel = bg;\n    \n    DrawRect(r1,r,pixel);\n    \n    Rect r1_sub = CreateRect(.1,.1,0.2,0.,vec3(0.,0.,1.));\n    AddRectTo(r1_sub,r1,pixel);\n    \n    fragColor = vec4(pixel,1.);\n}\n","name":"","description":"","type":"image"}]}