{"ver":"0.1","info":{"id":"DdcyR2","date":"1695222620","viewed":31,"name":"My space dividing 2","username":"gest","description":"No description","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n#endif\n\n\n//-------------------функции расстояний до объектов\n\nfloat dfBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat dfBall(vec3 p, float R) {\n\treturn length(p) - R;\n}\n\nfloat dfCyl(vec2 p, float R) {\n\treturn length(p) - R;\n}\n\nfloat dfBefore(float p, float h) {\n\treturn p - h;\n}\nfloat dfAfter(float p, float h) {\n\treturn -p + h;\n}\n\n\n#define ID_FIG1 1.0\n#define ID_FIG2 2.0\n#define ID_FIG3 3.0\n#define ID_FIG4 4.0\n\nfloat glow = 0.;\nfloat calcGlow = 1.;\n\nfloat map(vec3 p, inout Object object) {\n    vec3 q;\n\t\n\tobject = Object(1e6, 0.);\n\t\n\n\tq = p;\n\t\n\t//Повторение вдоль Z\n\tfloat cidZ = replica(q.z, 2.5); //id ячейки\n\tcidZ = round(mod(cidZ, 7.)); //Ограничиваем ID\n\tfloat anglesCount = cidZ+3.; //Число разбиений зависит от ячейки\n\tfloat dir = 1.; //Направление вращения\n\tfloat cidA = 0.; //id сектора\n\t\t\n\n\tObject FIG1 = Object(1e6, ID_FIG1);\n\t{\n\t\tq.x -= 0.0;\n\t\tdir =  modi(int(cidA), 2)==0 ? 1. : -1.;\n\t\tcidA = replicaAngle(q.xz, anglesCount, 0.25 * u_time*dir);\n\t\tq.x -= 0.25;\n\t\tFIG1.distance = dfCyl(q.xy, 0.05);\n\t}\n\tobject = OR(object, FIG1);\n\n\t\t\n\tObject FIG2 = Object(1e6, ID_FIG2);\n\t{\n\t\tq.x -= 0.05;\n\t\tdir = modi(int(cidA), 2)==0 ? 1. : -1.;\n\t\tcidA = replicaAngle(q.xy, anglesCount, 0.5 * u_time*dir);\n\t\tq.x -= 0.125;\n\t\tFIG2.distance = dfCyl(q.xz, 0.04);\n\t}\n\tobject = OR(object, FIG2);\n\t\n\t\n\tObject FIG3 = Object(1e6, ID_FIG3);\n\t{\n\t\tq.x -= 0.025;\n\t\tdir = modi(int(cidA), 2)==0 ? 1. : -1.;\n\t\tcidA = replicaAngle(q.xz, anglesCount, 1.0 * u_time*dir);\n\t\tq.x -=0.0625;\n\t\tFIG3.distance = dfCyl(q.xy, 0.025);\n\t}\n\tobject = OR(object, FIG3);\n\t\t\n\n\tObject FIG4 = Object(1e6, ID_FIG4);\n\t{\n\t\tq.x -= 0.0125;\n\t\tdir = modi(int(cidA), 2)==0 ? 1. : -1.;\n\t\tcidA = replicaAngle(q.xy, anglesCount, 2.0 * u_time*dir);\n\t\tq.x -=0.03125;\n\t\tFIG4.distance = dfCyl(q.xz, 0.0125);\n\t}\n\tobject = OR(object, FIG4);\n\n\t#if 1\n\t\tglow += 0.01/pow(FIG1.distance,1.1)*calcGlow;\t\n\t#else\n\t\tif (object.id==ID_FIG2) glow += 0.01/pow(FIG3.distance,1.8)*calcGlow;\n\t#endif\n\t\n    return object.distance;\n}\n\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(map(p) - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n\t));\n}\n\nfloat rayMarch(inout Ray ray) {\n    ray.distance = ray.near;\n\tfloat steps = 1.;\n    for(int i=0; i<200; i++) {\n        ray.position = ray.origin + ray.direction*ray.distance;\n        ray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance<ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += ray.object.distance*ray.swing;\n        if(ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n\treturn steps;\n}\n\nvec3 lighting(Ray ray, vec3 lightPos, vec3 mColor) {\n\tvec3 lightDir = normalize(lightPos - ray.position);\n\t\n\tfloat sh = 1.;\n\t#if 0\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin  \t= ray.position;\n\t\t\tray1.direction \t= lightDir;\n\t\t\tray1.steps\t\t= 50.;\n\t\t\tray1.far\t\t= 0.5;\n\t\t}\n\t\trayMarch(ray1);\n\t\tsh = ray1.hit ? 0.1 : 1.;\n\t#endif\n\n\tfloat atten = 1.;// / pow(ray.distance,2.0);\n\tfloat ambient = 0.1;\n\tfloat diffuse = max(dot(ray.normal, lightDir), 0.);\n\tfloat specular = pow(max(0.0, dot(reflect(ray.direction, ray.normal), lightDir)),8.0);\n\treturn (mColor * (ambient + diffuse*0.9) + specular) * atten * sh;\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv-0.5;\n\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5, 0.5);\n\n\tvec3 angle = vec3(\n\t\t-mix(-90., 90., mouse.y),\n\t\t mix(-180.,180.,mouse.x),\n\t\t 0.\n\t);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 60.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0, 0.6, u_time*0.25-2.);\n\t\tcam.target  = cam.origin + vec3(0, -0.6, 2.4);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 5.;\n\t\tray.epsilon = 0.0001;\n\t\tray.swing\t= 0.4; //0.8 + 0.1 * rnd(uv)\n\t\tray.steps \t= 200.;\n\t\t\n\t\trotateOrigin(ray.direction, radians(angle));\n\t}\n\tcalcGlow = 1.;\n\tfloat steps = rayMarch(ray);\n    \n    vec3 col = vec3(0.0);\n\n\tif(ray.distance<ray.far) {\n\t\tcalcGlow = 0.;\n\t\tray.normal = mapNormal(ray.position, ray.epsilon*10.);\n\t\t\n\t\tvec3 lightPos = cam.origin/* + vec3(0.5)*/;\n\t\t\n\t\tvec3 mColor = vec3(0.1,0.6,1);\n\t\tif (ray.object.id == ID_FIG1) mColor = vec3(1,0.0,0.1);\n\n//\t\tif (ray.object.id != ID_FIG1) \n\t\t\tcol = lighting(ray, lightPos, mColor);\n\n\t}\n\n\n\tfloat fog = smoothstep( ray.far * 0.8, 0.0, ray.distance ); \n\tvec3 fogCol = vec3(0.0);\n\tcol = mix( col, fogCol, 1.0 - fog );\n\n\tcol += 0.045* glow * vec3(1,0.0,0.1);// vec3(0.1,0.6,1);\n\t\n\tcol = pow( col, vec3(0.4545) );\n\t\n    gl_FragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--------------------------Для совместимости с GLSL ES 3.00\n\nint modi(int x, int y) {\n\treturn int(mod(float(x),float(y)));\n}\n/*\nfloat round(float x) {\n\treturn floor(x + 0.5);\n}\n*/\n//--------------------------Камера и луч\nconst float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//Колебание/размер шага приближения, поворот (-1 для прозрачности)\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------Функции позиционирования объектов сцены\nvoid translate(inout vec3 p, vec3 dist) {\n\tp = p - dist;\n}\nvoid translate(inout vec2 p, vec2 dist) {\n\tp = p - dist;\n}\nvoid translate(inout float p, float dist) {\n\tp = p - dist;\n}\n\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\nvoid rotateX(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(r,0,0));\n\tp = tMat * p;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,r,0));\n\tp = tMat * p;\n}\nvoid rotateZ(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,0,r));\n\tp = tMat * p;\n}\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Размножение. Возвращает центр ячейки с id=0.\nfloat replica(inout float p, float d) {\n    float id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\n\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nfloat replicaLimit(inout float p, float d, float ida, float idb) {\n\tfloat id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec2 replicaLimit(inout vec2 p, vec2 d, vec2 ida, vec2 idb) {\n\tvec2 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec3 replicaLimit(inout vec3 p, vec3 d, vec3 ida, vec3 idb) {\n\tvec3 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nfloat replicaAngle(inout vec2 p, float n, float off) {\n\tfloat a = 2.* PI /n;\n\t//polar\n\tp = vec2(atan(p.y, p.x), length(p.xy));\n\tfloat id = floor(mod(p.x + 0.5*a + off, 2.*PI)/a);\n    p.x = mod(p.x + 0.5*a + off, a) - 0.5*a;\n\tp = p.y * vec2(cos(p.x),sin(p.x));\n\treturn id;\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n//Мягкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 - 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) - k*h*(1.-h);\n}\n//Мягкое умножение / Пересечение / И (k==0 без)\nfloat AND(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}