{"ver":"0.1","info":{"id":"WlV3zD","date":"1578426079","viewed":114,"name":"A Simple Raymarched Sphere","username":"TheCreator","description":"This is my second raymarching shader. I used a tutorial to create a slightly deviated version. The link for it can be found at the top of the code.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","beginner","second"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMy second attempt at raymarching. I think I am finally starting to grasp the concept.\nUsing this tutorial, I was able to create this neat animating sphere: http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nI used variables with clear names to make the code easier to understand & read for people new to raymarching.\nHave fun messing around in here!\n\n-TheCreator, 07/01/2020\n\n*/\n\n\n\n/*\n\nJust a utility method I created to avoid code duplication. \nAllows me to control a cos curve's parameters for color changes over time\n\n*/\nfloat cosiTime(float centerValue, float intensity, float offset) {\n    return centerValue + intensity * cos(iTime + offset);\n}\n\n\n\n/*\n\nSigned distance functions (short: SDFs) are functions which describe the shapes in a raymarched scene with math.\nOpposed to that are meshes made out of trianges, which most 3D games rely on today.\n\nYou can find a list of functions for describing different shapes here: https://iquilezles.org/articles/distfunctions\n\n*/\nfloat sphereSDF(vec3 samplePos, vec3 spherePos, float radius) {\n    return length(samplePos - spherePos) - radius;\n}\n\n\n\n/*\n\nThe SDF for all objects in the world. Currently only a sphere with animated displacement is being rendered.\n\n*/\nfloat worldSDF(vec3 samplePos) {\n    float displacement = sin(cosiTime(4.0, 3.0, 0.0) * samplePos.x) * sin(cosiTime(5.0, 2.0, 2.0) * samplePos.y) * sin(cosiTime(3.0, 4.0, 3.0) * samplePos.z) * 0.25;\n    float sphere0 = sphereSDF(samplePos, vec3(0.0), 1.0);\n    \n    return sphere0 + displacement;\n}\n\n\n\n/*\n\nThis function determines the surface normal. I don't fully understand how it works just yet.\n\n*/\nvec3 estimateNormal(vec3 pos) {\n    vec3 smallStep = vec3(0.001, 0.0, 0.0);\n    \n    float gradientX = worldSDF(pos + smallStep.xyy) - worldSDF(pos - smallStep.xyy);\n    float gradientY = worldSDF(pos + smallStep.yxy) - worldSDF(pos - smallStep.yxy);\n    float gradientZ = worldSDF(pos + smallStep.yyx) - worldSDF(pos - smallStep.yyx);\n    \n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n    \n    return normalize(normal);\n}\n\n\n\n/*\n\nThe actual raymarch function. Takes a ray origin and a ray direction and marches along the ray using a\ntechnique called \"sphere tracing\". The code checks for the nearest object using the world SDF and then\nmoves the next point that is checked to the edge of that sphere, ensuring the checked position is\neither outside of the object or on the edge of it. This continues until the ray hits an object\nor the maximum number of steps is reached. I might flesh out this explaination in the future, however\ntutorials online with an illustration can explain sphere tracing far better than a thousand words ever could.\n\n*/\nvec3 raymarch(vec3 rayOrigin, vec3 rayDir) {\n    float marchedDist = 0.0;\n    int maxSteps = 128;\n    float minHitDist = 0.001;\n    float maxTraceDist = 1000.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        vec3 marchPos = rayOrigin + marchedDist * rayDir;\n        \n        float sphereTraceDist = worldSDF(marchPos);\n        \n        if(sphereTraceDist < minHitDist) {\n            vec3 normal = estimateNormal(marchPos);\n            \n            //Manually set light position for now\n            vec3 lightPos = vec3(2.0, -5.0, 3.0);\n            vec3 directionToLight = normalize(marchPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n            \n            return vec3(cosiTime(0.5, 0.5, 0.0), cosiTime(0.5, 0.5, 2.0), cosiTime(0.5, 0.5, 4.0)) * diffuseIntensity;\n        }\n        \n        if(marchedDist > maxTraceDist) {\n            return vec3(0.0);\n        }\n        \n        marchedDist += sphereTraceDist;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, -2.0);\n    vec3 rayDirection = vec3(uv, 1.0);\n\n    vec3 col = raymarch(cameraPos, rayDirection);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}