{"ver":"0.1","info":{"id":"ws2SRt","date":"1554742843","viewed":86,"name":"Ray tracing moving spheres","username":"mrExalight","description":"example of ray tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 screenResolution = vec2(800.,800.);\nconst float FOV = 30.;\n#define farPlane 300.0\n\nstruct Light{\n\tvec3 m_position;\n    vec3 m_color;\n    float r;\n};\n\nLight light;\n\nstruct Material{\n\tvec3 m_color;\n    float kd;\n    float ks;\n};\n\nstruct Camera{\n    vec3 m_position;\n    vec3 m_up;\n    vec3 m_right;\n    vec3 m_forward;\n};\n\nstruct Ray{\n    vec3 m_origin;\n    vec3 m_direction;\n};\n\nstruct Sphere{\n\tvec3 m_position;\n    float r;\n    Material m_material;\n};\n    \nstruct Plane{\n\tvec3 m_position;\n    vec3 m_normal;\n    Material m_material;\n};\n    \nstruct Intersection{\n    Ray ray;\n    float t;\n    vec3 m_normal;\n    Material m_material;\n};\n    \nIntersection miss = Intersection(Ray(vec3(0),vec3(0)), farPlane,vec3(0), Material(vec3(0.),0.,0.)); \n    \nvec3 normalSphere(Sphere sphere, vec3 hitPoint){\n\treturn normalize(hitPoint - sphere.m_position);\n}\n\n    \nIntersection Intersection_sphere(Sphere sphere, Ray ray){\n\n    float t0,t1;\n    vec3 L = sphere.m_position - ray.m_origin; \n    float tca = dot(L,ray.m_direction);\n    float d2 = dot(L,L) - tca * tca;\n    float radius2 = pow(sphere.r,2.);\n    if (d2 > radius2) return miss; \n    float thc = sqrt(radius2 - d2); \n    t0 = tca - thc; \n    t1 = tca + thc; \n    \n    t0=(t0>t1)?t1:t0;\n    if(t0<0.){\n        t0=t1;\n        if(t0<0.)\n     \t\tt0 = farPlane;\n    }\n    \n    float t = t0;\n\tif(t==farPlane)\n        return miss;\n    else{\n        vec3 hitPoint = ray.m_origin + ray.m_direction * t;\n    \treturn Intersection(ray,t,normalSphere(sphere,hitPoint),sphere.m_material);\n    }\n}\n\nIntersection Intersection_plane(Plane plane, Ray ray){\n    float t = farPlane;\n    float denom = dot(plane.m_normal, -ray.m_direction);\n    if(denom > 1e-6){\n    \tvec3 p0l0 = plane.m_position - ray.m_origin;\n        t = abs(dot(p0l0,plane.m_normal))/denom;\n    }\n    if(t==farPlane)\n        return miss;\n    else\n    \treturn Intersection(ray,t,plane.m_normal,plane.m_material);\n}\n\nCamera CreateCamera(vec3 position, vec3 lookAt){\n\tvec3 forward = normalize(lookAt - position);\n    vec3 right = normalize(cross(forward,vec3(0,1,0)));    \n    vec3 up = normalize(cross(right,forward));\n    \n    return Camera(position,up,right,forward);\n}\n\nRay\tcreateRay(Camera camera, vec2 uv){\n    vec3 rayDir = normalize(camera.m_forward+camera.m_right*uv.x+camera.m_up*uv.y);\n\treturn Ray(camera.m_position,rayDir);\n}\n\n\nRay createShadowRay(Intersection intersection){\n\tvec3 hitPoint = intersection.ray.m_origin + intersection.ray.m_direction * intersection.t;\n    vec3 direction = light.m_position - hitPoint;\n    return Ray(hitPoint,direction);\n}\n\nIntersection trace(Ray ray){\n\tMaterial materialSphere = Material(vec3(1,1,1),.7,.3);\n    Sphere sphere = Sphere(vec3(cos(iTime)*2.,(cos(iTime) / 2. + .5)*2.,sin(iTime)),1.,materialSphere);\n    \n    Material materialSphere2 = Material(vec3(1,1,1),.7,.3);\n    Sphere sphere2 = Sphere(vec3(cos(-iTime)*2.,(-cos(-iTime) / 2. + .5)*2.,sin(-iTime)),1.,materialSphere);\n    \n    int nb_Sphere = 2;\n    Sphere spheres[2];\n    spheres[0]= sphere;\n    spheres[1]= sphere2;\n    \n    Material materialPlane = Material(vec3(0,.2,.6),.7,.0);\n    Plane plane = Plane(vec3(0,-1,0),vec3(0,1,0),materialPlane);\n    \n    int nb_Plane = 1;\n    Plane planes[1];\n    planes[0]= plane;\n    \n    Intersection intersection = miss;\n    \n    for(int i = 0; i < nb_Sphere; i++){\n    \tIntersection tmp_intersection = Intersection_sphere(spheres[i], ray);\n        if(tmp_intersection == miss)\n            continue;\n        else{\n        \tif(tmp_intersection.t < intersection.t)\n                intersection = tmp_intersection;\n        }\n        \n    }\n    \n    for(int i = 0; i < nb_Plane; i++){\n    \tIntersection tmp_intersection = Intersection_plane(planes[i], ray);\n        if(tmp_intersection == miss)\n            continue;\n        else{\n        \tif(tmp_intersection.t < intersection.t)\n                intersection = tmp_intersection;\n        }\n        \n    }\n    return intersection;\n}\n\nvec3 shade(Intersection intersection){\n    \n    vec3 Color = vec3(0.);\n    \n    vec3 hitPoint = intersection.ray.m_origin + intersection.ray.m_direction * intersection.t;\n    vec3 dir = normalize(light.m_position - hitPoint);\n    \n\tRay shadowRay = Ray(hitPoint+dir*pow(10.,-4.),dir);\n    \n    Intersection shadowIntersection = trace(shadowRay);\n    if(shadowIntersection == miss){\n        vec3 Id = intersection.m_material.m_color * intersection.m_material.kd * light.m_color * max(0.,dot(intersection.m_normal,dir));\n\t\tColor += Id;\n        \n        \n        vec3 Is = intersection.m_material.ks * light.m_color * pow(max(0.,dot(-intersection.ray.m_direction,reflect(-dir,intersection.m_normal))),100.);\n        \n        Color += Is;\n    }\n    return Color;\n    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    Camera camera = CreateCamera(vec3(0,1.5,3),vec3(0,.5,0));\n  \tvec3 Color = vec3(0.0);\n    light = Light(vec3(10.,5,10.),vec3(1.),2.);\n\t//light = Light(vec3(10.,5,10.),vec3(1.),2.);\n    \n    // Normalized pixel coordinates (from 0 to 1)  \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.25,0);\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n\n    Ray ray = createRay(camera, uv);\n    Intersection intersection = trace(ray);\n    \n    if(intersection == miss){\n        Color += texture(iChannel0, ray.m_direction.xyz ).xyz;\n    }else{\n    \tColor += shade(intersection);\n\n\n        bool isReflect = true;\n        if(isReflect){\n            Intersection reflectIntersection = intersection;\n            for(int i = 1; i < 5; i++){\n                vec3 hitPoint = reflectIntersection.ray.m_origin + reflectIntersection.ray.m_direction * reflectIntersection.t;\n                vec3 reflectDir = normalize(reflect(reflectIntersection.ray.m_direction,reflectIntersection.m_normal));\n                Ray reflectRay = Ray(hitPoint+reflectDir*pow(10.,-4.),reflectDir);\n\n                reflectIntersection = trace(reflectRay);\n\t\t\t\tvec3 tmp_Color = vec3(0);\n                if(reflectIntersection == miss){\n                    tmp_Color = 0.1*texture(iChannel0, reflectDir.xyz).xyz;\n                }else{\n                    tmp_Color = shade(reflectIntersection);\n                }\n                \n                Color += tmp_Color ;//* (1.- abs(dot(reflectIntersection.m_normal,-reflectRay.m_direction)));\n            }\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(Color,1.0);\n}","name":"Image","description":"","type":"image"}]}