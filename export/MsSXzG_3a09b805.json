{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n * |===============================================|\n * |         GT         |   DERIVATIVES ADDITION   |\n * |===============================================|\n * |  NORMALS ADDITION  |   DERIVATIVES BLENDING   |\n * |===============================================|\n */\n\n// normalmap texture\nvec3 textureNormal(vec2 uv) {\n    uv = fract(uv) * 3.0 - 1.5;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    ret = ret * 0.5 + 0.5;    \n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.98,dot(uv,uv)));\n}\n\n// normals combine: normals addition\nvec3 combineNormals0(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    return normalize(n0 + n1) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives addition\nvec3 combineNormals1(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    n0 = vec3(n0.xy + n1.xy, n0.z * n1.z);\n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives blending\nvec3 combineNormals2(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\tn0 = vec3(n0.xy * n1.z + n1.xy * n0.z, n0.z * n1.z);    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: GT\nvec3 combineNormals3(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\t\n    mat3 m = mat3(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),n1);\n    m[1] = normalize(cross(m[2],m[0]));\n    m[0] = normalize(cross(m[1],m[2]));\n    n0 = m * n0;\n    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color;\n    vec2 time = vec2(sin(iTime * 0.1), cos(iTime * 0.1));\n    vec3 n0 = textureNormal(uv + time);\n    vec3 n1 = textureNormal((uv - time) * 2.0 + vec2(0.25));\n    \n    // combine normals\n    if(uv.x < 0.0) {\n        if(uv.y > 0.0) {\n    \t\tcolor = combineNormals3(n0,n1);\n        } else {\n            color = combineNormals0(n0,n1);\n        }\n    } else {\n        if(uv.y > 0.0) {\n        \tcolor = combineNormals1(n0,n1);\n        } else {            \n        \tcolor = combineNormals2(n0,n1);\n        }\n    }\n    \n    // borders\n    color += max(smoothstep(0.01,0.005,abs(uv.x)),0.0);\n    color += max(smoothstep(0.01,0.005,abs(uv.y)),0.0);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSXzG","date":"1413133351","viewed":1034,"name":"Normalmap combining","username":"TDM","description":"normals combining techniques","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["normals","combiner"],"hasliked":0,"parentid":"","parentname":""}}