{"ver":"0.1","info":{"id":"3ddyRl","date":"1601511728","viewed":791,"name":"Simple bytecode interpreter","username":"castano","description":"One shader to rule them all.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["interpreter","bytecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple bytecode interpreter.\n\n// Registers:\n// 0-15 = user registers?\n// 16   = time\n// 17  = fragCoord\n// 18  = iResolution\n// ...\n// 32+ = constants\n#define R(reg) (reg)\n#define C(idx) (32+idx)\n\n// Instructions:\nconst int MOV = 0;\nconst int ADD = 1;\nconst int SUB = 2;\nconst int MUL = 3;\nconst int DIV = 4;\nconst int SIN = 5;\nconst int COS = 6;\nconst int SQR = 7;\nconst int RSQ = 8;\nconst int PCK = 9; // 0.5 * x + 0.5\n\n\n#if 0\n\n// Default shader.\nconst int instructions[] = int[](\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    R(0), DIV, R(17), R(19),\n    R(1), DIV, R(18), R(20),\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    R(0), ADD, R(0), R(16),\n    R(1), ADD, R(1), R(16),\n    R(1), ADD, R(1), C(2),\n    R(2), ADD, R(0), C(4),\n\n    R(0), COS, R(0), 0,\n    R(1), COS, R(1), 0,\n    R(2), COS, R(2), 0,\n\n    R(0), PCK, R(0), C(3),\n    R(1), PCK, R(1), C(3),\n    R(2), PCK, R(2), C(3),\n\n    R(3), MOV, C(1), 0\t   \t// A = 1\n);\n\nconst float constants[] = float[](0.0f, 1.0f, 2.0f, 0.5f, 4.0f);\n\n#else\n\n// Old school plasma.\nconst int instructions[] = int[](\n    \n    R(16), MUL, R(16), C(4),\t// float time = iTime * 0.5;\n    \n    R(3), SIN, R(16), 0,\t\t// float s = sin(time);\n    R(4), COS, R(16), 0,\t\t// float c = cos(time);\n    \n    R(5), MUL, R(17), R(3),\t\t// float x1 = 0.5 + 0.5 * sin(dot(fragCoord.xy, vec2(s,c)) * 0.02 + time);\n    R(6), MUL, R(18), R(4),\n    R(5), ADD, R(5), R(6),\n    R(5), MUL, R(5), C(5),\n    R(5), ADD, R(5), R(16),\n    R(5), COS, R(5), 0,\n    R(5), PCK, R(5), 0,\n    \n    // vec2 center = 0.5 * iResolution.xy * vec2(1.0-s,1.0+c);\n    R(6), SUB, C(1), R(3),\n    R(7), ADD, C(1), R(4),\n    R(6), MUL, R(19), R(6),\n    R(7), MUL, R(20), R(7),\n    R(6), MUL, R(6), C(4),\n    R(7), MUL, R(7), C(4),\n    \n    // float x2 = 0.5 + 0.5 * cos(length(fragCoord.xy - center) * 0.03);\n\tR(6), SUB, R(17), R(6),\n    R(7), SUB, R(18), R(7),\n    R(6), MUL, R(6), R(6),\n    R(7), MUL, R(7), R(7),\n    R(6), ADD, R(6), R(7),\n    R(6), SQR, R(6), 0,\n    R(6), MUL, R(6), C(6),\n    R(6), COS, R(6), 0,\n    R(6), PCK, R(6), 0,\n    \n    // float x = PI * (x1 + x2) + time;\n    R(5), ADD, R(5), R(6),\n    R(5), MUL, R(5), C(3),\n    R(5), ADD, R(5), R(16),\n\n    R(0), COS, R(5), 0,\t// float r = 0.5 + 0.5 * cos(x);\n    R(0), PCK, R(0), 0,\t\n    R(1), SIN, R(5), 0, // float g = 0.5 + 0.5 * sin(x);\n    R(1), PCK, R(1), 0,\n    R(2), PCK, R(3), 0, // float b = 0.5 + 0.5 * s;\n    \n    R(3), MOV, C(1), 0\t   \t// A = 1\n);\n\nconst float constants[] = float[](0.0f, 1.0f, 2.0f, 3.14159265, 0.5f, 0.02f, 0.03f);\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init registers.\n    float reg[32];\n    \n    // Load these into registers. Ideally iTime, iResolution would be constants.\n    reg[16] = iTime;\n    reg[17] = fragCoord.x;\n    reg[18] = fragCoord.y;\n    reg[19] = iResolution.x;\n    reg[20] = iResolution.y;\n\n    // Execute instructions.\n    for (int i = 0; i < instructions.length(); i += 4) {\n        int dst = instructions[i+0];\n        int inst = instructions[i+1];\n        int src0 = instructions[i+2];\n        int src1 = instructions[i+3];\n        \n        float a = (src0 < 32) ? reg[src0] : constants[src0-32];\n        float b = (src1 < 32) ? reg[src1] : constants[src1-32];\n        \n        if (inst == MOV) \t\treg[dst] = a;\n        else if (inst == ADD)   reg[dst] = a + b;\n        else if (inst == SUB)   reg[dst] = a - b;\n        else if (inst == MUL)   reg[dst] = a * b;\n        else if (inst == DIV)   reg[dst] = a / b;\n        else if (inst == SIN)   reg[dst] = sin(a);\n        else if (inst == COS)   reg[dst] = cos(a);\n        else if (inst == SQR)   reg[dst] = sqrt(a);\n        else if (inst == RSQ)   reg[dst] = 1.0/sqrt(a);\n        else if (inst == PCK)   reg[dst] = a * 0.5 + 0.5;\n    }\n\n    // Output to screen.\n    fragColor = vec4(reg[0], reg[1], reg[2], reg[3]);\n}\n","name":"Image","description":"","type":"image"}]}