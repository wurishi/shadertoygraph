{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MAX_STEPS 100\n#define MAX_STEP_DISTANCE 100.\n#define MINIMUM_SURFACE_DISTANCE .001\n\n#define CAMERA_RADIUS 5.\n#define CAMERA_ANGLE_MODIFIER 7.\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct Shape {\n    vec3 pos;\n    float dist;\n};\n\n#define CASTLE_WALLS_OFFSET 1.5\n\nvoid offsetAndRepeatTower(out Shape target) {\n    target.pos.xz = abs(target.pos.xz);\n    target.pos.xz -= CASTLE_WALLS_OFFSET;\n}\n\nvoid constructTower(out Shape towerBase, out Shape towerTop, out Shape towerIntersection, in vec3 p) {\n    float yOffset = .6;\n    towerTop.pos.y -= yOffset;\n    towerIntersection.pos.y -= yOffset;\n\n    offsetAndRepeatTower(towerTop);\n    offsetAndRepeatTower(towerIntersection);\n    offsetAndRepeatTower(towerBase);\n\n    // Top\n    float topScale = mix(1., 2., smoothstep(1., -.25, p.y));\n    towerTop.pos.xz *= topScale;\n\n    // Top - Boolean\n    towerTop.dist = sdBox(towerTop.pos, vec3(.45,.15,.45)) / topScale;\n    towerIntersection.dist = sdBox(towerIntersection.pos, vec3(.3,.45,.3));\n\n    // Base\n    float baseScale = mix(1., 2., smoothstep(-.25, 1., towerBase.pos.y));\n    towerBase.pos.xz *= baseScale;\n\n    towerBase.dist = sdBox(towerBase.pos, vec3(.5)) / baseScale;   \n}\n\nvoid offsetAndRepeatWallX(out Shape target) {\n    target.pos.x = abs(target.pos.x);\n    target.pos.x -= CASTLE_WALLS_OFFSET;\n}\n\nvoid offsetAndRepeatWallZ(out Shape target) {\n    target.pos.z = abs(target.pos.z);\n    target.pos.z -= CASTLE_WALLS_OFFSET;\n}\n\nvoid constructWallX(out Shape wall, in vec3 p) {\n    offsetAndRepeatWallX(wall);\n\n    float scaleMultiplier = CASTLE_WALLS_OFFSET;\n\n    wall.pos *= vec3(\n        1.,\n        1.,\n        1. / scaleMultiplier    \n    );\n\n    wall.dist = sdBox(wall.pos, vec3(.05,.4,.8)) / scaleMultiplier;\n}\n\nvoid constructWallZ(out Shape wall, in vec3 p) {\n    offsetAndRepeatWallZ(wall);\n\n        float scaleMultiplier = CASTLE_WALLS_OFFSET;\n\n    wall.pos *= vec3(\n        1. / scaleMultiplier,\n        1.,\n        1.\n    );\n\n    wall.dist = sdBox(wall.pos, vec3(.8,.4,.05));\n}\n\nfloat getSDFSceneDistance(vec3 p) {\n    Shape towerBase;\n    towerBase.pos = p - vec3(0, .5, 0);\n    \n    Shape towerTop;\n    towerTop.pos = towerBase.pos;\n\n    Shape towerIntersection; \n    towerIntersection.pos = p - vec3(0,1,0);\n    \n    constructTower(\n        towerBase,\n        towerTop,\n        towerIntersection,\n        p\n    );\n\n    float towerUnionDist = max(towerTop.dist, -towerIntersection.dist); \n    float towerDist = min(towerUnionDist, towerBase.dist);\n\n    Shape wallX;\n    wallX.pos = p - vec3(0,.4,0);;\n\n    Shape wallZ;\n    wallZ.pos = p - vec3(0,.4,0);\n\n    constructWallX(wallX, p);\n    constructWallZ(wallZ, p);\n\n    float wallDist = min(wallX.dist, wallZ.dist);\n\n    float planeDist = p.y;\n    \n    float dist = min(wallDist, planeDist);\n    dist = min(dist, towerDist);\n    \n    return dist;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distanceFromOrigin = 0.0;\n    \n    for(int i=0; i < MAX_STEPS; i++) {\n    \tvec3 p = rayOrigin + rayDirection * distanceFromOrigin;\n        float dist = getSDFSceneDistance(p);\n        distanceFromOrigin += dist;\n\n        if(distanceFromOrigin > MAX_STEP_DISTANCE || dist < MINIMUM_SURFACE_DISTANCE) {\n            break;\n        }\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getSDFSceneDistance(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getSDFSceneDistance(p-e.xyy),\n        getSDFSceneDistance(p-e.yxy),\n        getSDFSceneDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p) {\n    vec3 lightPosition = vec3(0, 3, 3);\n\n    vec3 lightVector = normalize(lightPosition-p);\n    vec3 normal = getNormal(p);\n    \n    float diffuse = clamp(dot(normal, lightVector), 0., 1.);\n    float distanceFromOrigin = rayMarch(p + normal * MINIMUM_SURFACE_DISTANCE * 2., lightVector);\n\n    if(distanceFromOrigin < length(lightPosition - p)) diffuse *= .5;\n    \n    return diffuse;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 color = vec3(0);\n\n    vec3 camera = vec3( \n        CAMERA_RADIUS * cos(CAMERA_ANGLE_MODIFIER * mouse.x), \n        3.0, \n        CAMERA_RADIUS * sin(CAMERA_ANGLE_MODIFIER * mouse.x)\n    );\n\n    vec3 lookAt = vec3(0, 1, 0);\n\n    mat4 view = viewMatrix(camera, lookAt, vec3(0, 1, 0));\n  \n    vec3 viewDirection = normalize(vec3(st, -1.0));\n    viewDirection =  (view * vec4(viewDirection, 0.0)).xyz;\n    \n    vec3 rayOrigin = camera;\n    vec3 rayDirection = viewDirection;\n\n    float distanceFromOrigin = rayMarch(camera, viewDirection);\n    \n    vec3 p = rayOrigin + rayDirection * distanceFromOrigin;\n    \n    float diffuse = diffuseLight(p);\n    color = vec3(diffuse);\n    \n    color = pow(color, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lXdyzH","date":"1734753383","viewed":34,"name":"Castle with Sphere Tracing 🏰","username":"phillipjk","description":"This is a work in progress. \n\nWorking with SDFs and Sphere Tracing, an experiment to make a castle. All of the shapes in this scene derive from the `sdBox` function. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","castle"],"hasliked":0,"parentid":"","parentname":""}}