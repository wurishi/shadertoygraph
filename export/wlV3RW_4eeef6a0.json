{"ver":"0.1","info":{"id":"wlV3RW","date":"1578766361","viewed":146,"name":"?XAA","username":"SigSegOwl","description":"some txaa-like filter, but also based on edge detection.\nbasically just blurs at the detected edge.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["detection","antialiasing","edge","txaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//left right comparison\n//left just unprocessed buffer A\n//right shows the anti aliased version\n//top shows only the detected edge\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;                    \n\tvec2 uvMouse = iMouse.xy/iResolution.xy; \n    \n    \n    if(uv.y > uvMouse.y){\n\t\tfloat w = texture(iChannel1, uv).w;\n        fragColor = vec4(w, w, w, 1.0);   \n        return;\n\t}\n    \n    //left\n\tif(uv.x < uvMouse.x){\n\t\tfragColor = texture(iChannel0, uv);  \n        \n\t}\n    //right\n    else{    \n       fragColor = texture(iChannel1, uv);   \n    }\n    if(uv.x > uvMouse.x - 0.002 && uv.x < uvMouse.x + 0.002){\n    \tfragColor = vec4(1.0,1.0,1.0,1.0);\n\t}        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//just filling buffer A for easier testing...\n\n//A Sphere on the Floor from\n//https://www.shadertoy.com/view/XllSRN\n\n\n//#define video\n\n\n#ifdef video\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    fragColor = texture(iChannel1, uv);\n}\n#endif\n\n#ifndef video\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define X_AXIS vec3(1, 0, 0)\n#define Y_AXIS vec3(0, 1, 0)\n#define Z_AXIS vec3(0, 0, 1)\n\nstruct Material\n{\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat shininess;\n};\n\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n\tMaterial material;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Intersection\n{\n\tbool hit;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 forward;\n\tvec3 up;\n\tvec3 right;\n};\n\nstruct Spotlight\n{\n\tvec3 position;\n\tvec3 direction;\n\tfloat angle;\n};\n\nIntersection raySphereIntersection(in Ray ray, in Sphere sphere)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tvec3 centerToOrigin = ray.origin - sphere.center;\n\tfloat dotProduct = dot(ray.direction, centerToOrigin);\n\tfloat squareRootTerm = pow(dotProduct, 2.0) - pow(length(centerToOrigin), 2.0) + pow(sphere.radius, 2.0);\n\tif (squareRootTerm < 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = (-dotProduct) - sqrt(squareRootTerm);\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = normalize(i.position - sphere.center);\n\ti.material = sphere.material;\n\ti.hit = true;\n\treturn i;\n}\n\nIntersection rayPlaneIntersection(in Ray ray, in Plane plane)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tfloat dotProduct = dot(ray.direction, plane.normal);\n\tif (dotProduct == 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = dot(plane.point - ray.origin, plane.normal)/dotProduct;\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = plane.normal;\n\ti.material = plane.material;\n\ti.hit = true;\n\treturn i;\n}\n\nvec3 blinnPhong(in vec3 lightPosition, in vec3 cameraPosition, in vec3 objectPosition, in vec3 objectNormal, in Material material)\n{\n\tvec3 fromObjectToLight = normalize(lightPosition - objectPosition);\n\tfloat lambertian = dot(fromObjectToLight, objectNormal);\n\tfloat specularIntensity = 0.0;\n    \n    if (lambertian > 0.0) // = diffuseIntensity > 0.0\n    {\n        vec3 fromObjectToCamera = normalize(cameraPosition - objectPosition);\n        vec3 halfwayVector = normalize(fromObjectToLight + fromObjectToCamera);\n        float specTmp = max(dot(objectNormal, halfwayVector), 0.0);\n        specularIntensity = pow(specTmp, material.shininess);\n    }\n    \n    return lambertian * material.diffuseColor + specularIntensity * material.specularColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Declare constants\n    const int RaysPerFragment = 1;\n\tconst vec3 BallColorOne = vec3(1, 0, 0);\n\tconst vec3 BallColorTwo = vec3(1, 1, 1);\n\tconst int BallSegmentCount = 3;\n\tconst float BallSegmentTransitionFactor = 0.05;\n\tconst float DistanceFromBall = 50.0;\n\tconst float PlaneTextureSize = 12.0;\n\tconst float SpotlightSoftness = 0.2;\n\t\t\n\t// Define our sphere\n\tSphere s;\n\ts.center = vec3(0, 0, 0);\n\ts.radius = 12.0;\n\ts.material.specularColor = vec3(0, 0, 0);\n\ts.material.shininess = 10.0;\n\t\n\t// Define our plane\n\tPlane p;\n\tp.point = s.center - vec3(0, s.radius, 0);\n\tp.normal = Y_AXIS;\n\tp.material.specularColor = vec3(1, 1, 1);\n\tp.material.shininess = 1000.0;\n\t\n\t// Define our spotlight\n\tSpotlight spotlight;\n\tspotlight.position = vec3(10.0, 20.0, 10.0);\n\tspotlight.direction = normalize(s.center - spotlight.position);\n\tspotlight.angle = PI / 5.0;\n\t\n\t// Define our camera\n\tCamera camera;\n\tfloat cameraRotationValue = sin(0.33 * -iTime) * 2.0;\n\tcamera.position = s.center + vec3(cos(cameraRotationValue) * DistanceFromBall, DistanceFromBall, sin(cameraRotationValue) * DistanceFromBall);\n\t\n\tvec3 targetPosition = s.center;\n\tcamera.forward = normalize(targetPosition - camera.position);\n\tcamera.right = cross(Y_AXIS, camera.forward);\n\tcamera.up = cross(camera.forward, camera.right);\n\t\n\t// To antialias our image, we cast multiple rays per fragment and \"average\" the result.\n\tvec3 accumulatedColor = vec3(0, 0, 0);\n\tfloat accumulatedSignificance = 0.0;\n\t\n\tfor (int i = 0; i < RaysPerFragment; ++i)\n\t{\n\t\tfloat t = float(i) / float(RaysPerFragment);\n\t\t\n\t\tfloat significance = (1.0 - t);\n\t\t\n\t\tvec2 fragCoordOffset = vec2(cos(t * TWO_PI) * t, sin(t * TWO_PI) * t);\n\t\tvec2 uv = 2.0 * (fragCoord + fragCoordOffset) / iResolution.xy - 1.0;\n\t\tuv.x *= iResolution.x / iResolution.y;\n\t\t\n\t\tRay r;\n\t\tr.origin = camera.position;\n\t\tr.direction = normalize(camera.forward + camera.right * uv.x + camera.up * uv.y);\n\t\t\n\t\tfloat percentLit = 1.0;\n\t\t\n\t\tIntersection intersection = raySphereIntersection(r, s);\n\t\t// If our ray hit the sphere...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tvec2 flattenedNormal = normalize(vec2(intersection.normal.x, intersection.normal.z));  \n\t\t\tfloat polarCoordinate = atan(flattenedNormal.y, flattenedNormal.x);\n\t\t\tpolarCoordinate += PI; // polarCoordinate is now between (0, 2*PI)\n\t\t\tpolarCoordinate = pow(sin(float(BallSegmentCount) * polarCoordinate), 2.0); // polarCoordinate is now between (0, 1)\n\t\t\t\n\t\t\tfloat smoothFactor = smoothstep(0.5 - BallSegmentTransitionFactor, 0.5 + BallSegmentTransitionFactor, polarCoordinate);\n\t\t\tintersection.material.diffuseColor = BallColorOne * smoothFactor + BallColorTwo * (1.0 - smoothFactor);\n\t\t}\n\t\t// If the ray didn't hit the sphere, test to see if it hits the plane.\n\t\telse\n\t\t{\n\t\t\tintersection = rayPlaneIntersection(r, p);\n\t\t\t\n\t\t\tif (intersection.hit == true)\n\t\t\t{\n\t\t\t\tvec3 fromPointToIntersection = intersection.position - p.point;\n\t\t\t\tvec2 textureCoordinates = vec2(dot(fromPointToIntersection, X_AXIS), dot(fromPointToIntersection, Z_AXIS)) * (1.0 / PlaneTextureSize);\n\t\t\t\t\n\t\t\t\tintersection.material.diffuseColor = texture(iChannel0, textureCoordinates).xyz;\n\t\t\t\t\n\t\t\t\t// We cast a ray from the intersection point back to the light to test whether this position lies in shadow.\n\t\t\t\tRay shadowRay;\n\t\t\t\tshadowRay.origin = intersection.position;\n\t\t\t\tshadowRay.direction = normalize(spotlight.position - intersection.position);\n\t\t\t\t\n\t\t\t\tIntersection shadowIntersection = raySphereIntersection(shadowRay, s);\n\t\t\t\tif (shadowIntersection.hit == true)\n\t\t\t\t{\n\t\t\t\t\tpercentLit = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec3 objectColor = vec3(0, 0, 0);\n\t\t\n\t\t// If the ray hit the sphere or the plane...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tif (percentLit > 0.0)\n\t\t\t{\n\t\t\t\tvec3 fromLightToObject = normalize(intersection.position - spotlight.position);\n\t\t\t\tfloat angleFromLightToObject = acos(dot(fromLightToObject, spotlight.direction));\n\t\t\t\t\n\t\t\t\t// Smoothstep softens the edges of the spotlight\n\t\t\t\tpercentLit = smoothstep(-SpotlightSoftness, SpotlightSoftness, spotlight.angle - angleFromLightToObject);\n\t\t\t\t\n\t\t\t\tobjectColor = blinnPhong(spotlight.position, camera.position, intersection.position, intersection.normal, intersection.material);\n\t\t\t}\n\t\t\t\n\t\t\tobjectColor = max(objectColor * percentLit, intersection.material.diffuseColor * 0.0025);\n\t\t\tobjectColor *= clamp((60000.0 / pow(distance(s.center, intersection.position), 2.0)), 0.0, 1.0);\n\t\t}\n\t\t\n\t\taccumulatedColor += objectColor * significance;\n\t\taccumulatedSignificance += significance;\n\t}\n\t\n\taccumulatedColor /= accumulatedSignificance;\n\taccumulatedColor = pow(accumulatedColor, vec3(1.0/2.2)); // Gamma correction\n\tfragColor = vec4(accumulatedColor, 1.0);\n}\n#endif","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// horizontal blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 off = 1.0 / iResolution.xy;\n    \n    vec4 blur = \n        0.2 * texture(iChannel0, uv) +   \n        0.2 * texture(iChannel0, uv + vec2(+off.x * 2.0, 0.0)) +      \n        0.2 * texture(iChannel0, uv + vec2(+off.x, 0.0)) +                                             \n        0.2 * texture(iChannel0, uv + vec2(-off.x, 0.0)) +      \n        0.2 * texture(iChannel0, uv + vec2(-off.x * 2.0, 0.0))\n\t;\n\n    \n\tfragColor = vec4(blur);   \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// vertical + horizontal blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 off = 1.0 / iResolution.xy;\n    \n    vec4 blur = \n        0.5 * texture(iChannel0, uv)  + \n        0.125 * texture(iChannel0, uv + vec2(0.0, +off.y * 2.0)) +      \n        0.125 * texture(iChannel0, uv + vec2(0.0, +off.y)) +                                             \n        0.125 * texture(iChannel0, uv + vec2(0.0, -off.y)) +      \n        0.125 * texture(iChannel0, uv + vec2(0.0, -off.y * 2.0))\n\t;\n\n    \n\tfragColor = vec4(blur);   \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 off = 1.0 / iResolution.xy;\n    \n    vec4 psp0 = texture(iChannel1, uv);\n    \n\n    vec4 sp0 = texture(iChannel0,uv); \n    \n    vec3 blur = texture(iChannel2,uv).xyz;\n\n    // diff to previous frame\n    float change = clamp(abs(length(blur - psp0.xyz) * 2.0) - 0.1, 0.0, 1.0);\n    // temporal effect\n    float mixed = clamp(mix(change, psp0.w, 0.2) * 1.5, 0.0, 1.0);\n    \n\n    vec3 tempmix = mix(sp0.xyz, psp0.xyz, mixed);\n    vec3 aa = mix(tempmix, blur.xyz, mixed);\n    \n\tfragColor = vec4(aa, mixed);   \n}","name":"Buffer D","description":"","type":"buffer"}]}