{"ver":"0.1","info":{"id":"tdjXRd","date":"1554811220","viewed":154,"name":"Pathtracing the Mandelbulb","username":"StormCreeper","description":"Mandelbulb pathtracer","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fractalraymarchingmandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .005\n#define PI 3.1415926535\n\n#define rotY iMouse.x / iResolution.x * 6.3 \n#define rotX iMouse.y / iResolution.y * 1.5 - 0.4\n\nvec3 lightPos = vec3(0, 0, 0);\n\nuint rngState;\n\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n} \nfloat RandomFloat01() {\n    return float(wang_hash(rngState)) / 4294967296.0;\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat DE(vec3 pos, inout float iter) {\n    int Iterations = 10;\n    \n    float Bailout = 2.;\n    float Power = 8.0;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n        iter = float(i);\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat ray_plane_intersection(vec3 origin, vec3 direction, vec3 porigin, vec3 normal) {\n\tfloat denom = dot(normal, direction);\n\tif(denom < 1e-6) {\n\t\tvec3 p0l0 = porigin - origin;\n\t\tfloat t = dot(p0l0, normal) / denom;\n\t\tif(t > 0.) {\n\t\t\tvec3 new_pos = origin + t * direction;\n\t\t\tif(length(new_pos - porigin) > 8.) return -1.;\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn -1.;\n}\n\nfloat GetDist(vec3 p, inout float iter) {\n    float mde = DE(p, iter);\n    return mde;\n}\nvec3 getFractColor(float n) {\n    if(n == 0.0) return vec3(0.8);\n\tvec3 col = vec3(0);\n    float l = 1./log(2.);\n    col.x = 1.2*sqrt((1.-cos(l*n))/2.);\n    col.y = sqrt((1.-cos(1./(3.*sqrt(2.))*l*n))/2.);\n    col.z = sqrt((1.-cos(1./(7.*pow(3., 1./8.))*l*n))/2.);\n    \n    return col;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float n1 = 10000.;\n    float iter = 0.;\n    int i = 0;\n    for(i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, iter);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) {\n           \tif(dS < SURF_DIST)\n\t\t\t\tn1 = 1.;\n            break;\n        }\n        \n        if(n1> dS) n1 = dS;\n    }\n    return vec3(dO, iter, float(i));\t\n}\n\nvec3 GetNormal(vec3 p) {\n    float iter = 0.;\n\tfloat d = GetDist(p, iter);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = vec3(d) - vec3(\n        GetDist(p-e.xyy, iter),\n        GetDist(p-e.yxy, iter),\n        GetDist(p-e.yyx, iter));\n    \n    return normalize(n);\n}\n\nfloat traceRay(vec3 ro, vec3 rd, inout bool plane, inout float n) {\n    vec3 data = RayMarch(ro, rd);\n\n    float d = data.x;\n    n = data.y;\n\n    float dp = ray_plane_intersection(ro, rd, vec3(0, -1, 0), vec3(0, 1, 0));\n\n    if(dp < d && dp > 0.) {\n        d = dp;\n        n = 0.;\n        plane = true;\n    }\n    \n    return d;\n}\nvec3 ortho(vec3 v) {\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getPathColor(vec3 ro, vec3 rd, mat4 rotView) {\n    vec3 lightDir = normalize(vec3( -1, 1, -1));\n    \n    vec3 col = vec3(1);\n    \n    for(int i=0; i<4; i++) {\n\n        bool plane = false;\n        float n;\n        \n        float d = traceRay(ro, rd, plane, n);\n        \n        vec3 p = ro + rd * d;\n        \n        if(d < MAX_DIST) {\n            col *= getFractColor(n);\n            \n            vec3 norm = vec3(0, 1, 0);\n        \n            if(!plane) norm = GetNormal(p);\n\n            ro = p + SURF_DIST * norm * 2.;\n\n            rd = normalize(norm + vec3(RandomFloat01(), RandomFloat01(), RandomFloat01()) * 2. - vec3(1));\n        \n        } else {\n            vec3 sky = texture(iChannel1, rd).xyz * 0.7;\n            return col * (sky + pow(max(0., dot(rd, lightDir)), 128.) * 60.);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tseed = iTime;\n    rngState = uint(uint(gl_FragCoord.x) * uint(1973) + uint(gl_FragCoord.y) * uint(9277) + uint(tseed * 100.) * uint(26699)) | uint(1);\n    \n    \n    mat4 rotView = rotationX(rotX) * rotationY(rotY);\n    \n    vec2 uv = (fragCoord + vec2(RandomFloat01(), RandomFloat01())-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = (vec4(0, 0, -1.8, 0) * rotView).xyz;\n    \n    float n = 1.0;\n    \n    vec3 color = vec3(0);\n    for(int i=0; i<int(n); i++) {\n        vec3 rd = (vec4(normalize(vec3(uv.x, uv.y, 0.6)), 0) * rotView).xyz;\n        color += getPathColor(ro, rd, rotView) / n;\n    }\n    vec4 lastColor = texture(iChannel0, fragCoord / iResolution.xy).rgba;\n    \n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    float blend = (lastColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastColor.a));\n    color = mix(lastColor.rgb, color, blend);\n    \n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}