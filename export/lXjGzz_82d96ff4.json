{"ver":"0.1","info":{"id":"lXjGzz","date":"1708148944","viewed":102,"name":"bad 3D noise tests","username":"int_45h","description":"testing 3D noise and raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST .001\n#define MAX_DIST 100.\n#define STEPS 80\n#define FOV 60.\n#define ar iResolution.y/iResolution.x\n\nvec2 sd_plane(vec3 p, float id)\n{\n    return vec2(\n        dot(normalize(vec3(0.,1.,0.)), p)+10.,\n        id\n    );\n}\n\nvec2 sd_sphere(vec3 p, float r, float id)\n{\n    return vec2(length(p)-r, id);\n}\n\nvec2 get_dist(vec3 p)\n{\n    float noise = fbm3D(p+vec3(iTime*.05), 4)*.5;\n    //float noise = perlin3D(p+vec3(iTime*.05))*.5;\n    vec2 sphere = sd_sphere(p-vec3(0.,0.,5.),1.,.5) + noise;\n    //vec2 sphere = sd_sphere(p-vec3(0.,0.,5.),1.,.5);\n    return sphere;\n}\n\nvec3 get_color(vec3 p)\n{\n    vec2 k = vec2(1,-1);\n    return normalize(\n        k.xyy*get_dist(p+k.xyy).x +\n        k.yyx*get_dist(p+k.yyx).x +\n        k.yxy*get_dist(p+k.yxy).x +\n        k.xxx*get_dist(p+k.xxx).x\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 get_normals(vec3 p)\n{\n    float e = .001;\n    vec2 k = vec2(1,-1);\n \n    return normalize(\n        k.xyy*get_dist(p+k.xyy*e).x +\n        k.yyx*get_dist(p+k.yyx*e).x +\n        k.yxy*get_dist(p+k.yxy*e).x +\n        k.xxx*get_dist(p+k.xxx*e).x\n    );\n}\n\nfloat get_shadow(vec3 p, vec3 l, float k)\n{\n    vec3 o = p;\n    vec3 d = l;\n    float t = 0.;\n    float res = 1.;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float dist = max(get_dist(o+d*t).x,0.);\n        if (dist < MIN_DIST)\n            return 0.;\n        \n        res = min(k*dist/t, res);\n        if (t > MAX_DIST)\n            break;\n        \n        t += dist;\n    }\n    \n    return res;\n}\n\n\nvec4 raycast(vec2 uv)\n{\n    uv = uv*2.-1.;\n    uv *= vec2(1.,ar)*tan((FOV*PI/180.)*.5);\n    \n    vec3 o = vec3(0.);\n    vec3 d = normalize(vec3(uv,1.));\n    float t = 0.;\n    \n    vec4 col = vec4(.0,.0,.1,1.);\n    float m = MAX_DIST;\n    \n    for (int i=0;i<STEPS;i++)\n    {\n        vec3 p = o+d*t;\n        vec2 dist = get_dist(p);\n        t += dist.x;\n        \n        if (dist.x < MIN_DIST)\n        {\n            if (dist.y < 1.)\n            {\n                //vec3 n = get_normals(p);\n                vec3 n = get_color(p);\n                vec3 l = vec3(cos(iTime)+5., sin(iTime)+5., 3.)-p;\n                float a = length(l);\n                a = 40./(a*a);\n            \n                l = normalize(l);\n                vec3 col = n*.5+.5;\n                vec3 k_d = vec3(.5,.8,.6)*max(dot(n,l),0.)*a;\n                //k_d *= get_shadow(p+n*.001*2., l, 32.);\n                vec3 k_a = vec3(.5);\n                return vec4(col*(k_d+k_a), 1.);\n                //return vec4(n*.5+.5, 1.);\n            }\n            if (dist.y < 2.)\n            {\n                return vec4(.1,.2,.2,1.);\n            }\n        }\n        \n        if (dist.x < m)\n            m = dist.x;\n        \n        if (t > MAX_DIST)\n            break;\n    }\n    \n    m = sqrt(m*2.);\n    vec4 glow = max(vec4(.5,.8,.9,1.)*(1.-m), vec4(0.));\n    return col + glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    //vec4 color = vec4(perlin3D(vec3(uv * vec2(8., 6.), iTime)));\n    //color = color*.5+.5;\n    vec4 color = raycast(uv);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\nfloat hash12(vec2 seed)\n{\n    vec3 p3  = fract(vec3(seed.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 direction(vec2 seed)\n{\n    float t = hash12(seed)*2.*PI;\n    return vec2(cos(t), sin(t));\n}\n\nvec2 direction2D_z(vec3 p)\n{\n    float r = hash12(p.xy);\n    float t = r*r*4.*PI*p.z;\n    return vec2(cos(t), sin(t));\n}\n\n// Taken from https://www.shadertoy.com/view/slB3z3\nvec3 direction3D(vec3 p)\n{\n    int h = int(hash13(p)*15.) & 15;\n    \n    switch (h & 15) { // look at the last four bits to pick a gradient direction\n    case 0: return vec3(1, 1, 0);\n    case 1: return vec3(-1, 1, 0);\n    case 2: return vec3(1, -1, 0);\n    case 3: return vec3(-1, -1, 0);\n    case 4: return vec3(1, 0, 1);\n    case 5: return vec3(-1, 0, 1);\n    case 6: return vec3(1, 0, -1);\n    case 7: return vec3(-1, 0, -1);\n    case 8: return vec3(0, 1, 1);\n    case 9: return vec3(0, -1, 1);\n    case 10: return vec3(0, 1, -1);\n    case 11: return vec3(0, -1, -1);\n    case 12: return vec3(1, 1, 0);\n    case 13: return vec3(-1, 1, 0);\n    case 14: return vec3(0, -1, 1);\n    case 15: return vec3(0, -1, -1);\n    }\n}\n\nfloat fade(float x)\n{\n    float x_3 = x*x*x;\n    return x_3*(6.*x*x-15.*x+10.); //6t5-15t4+10t3\n}\n\nfloat fade2(float x)\n{\n    return x*x*(3.-2.*x);\n}\n\nfloat perlin(vec2 uv)\n{\n    vec2 uv_grid = floor(uv);\n    vec2 uv_cell = fract(uv);\n    \n    // Direction vectors\n    vec2 d0 = normalize(direction(uv_grid + vec2(0.,0.)));\n    vec2 d1 = normalize(direction(uv_grid + vec2(0.,1.)));\n    vec2 d2 = normalize(direction(uv_grid + vec2(1.,0.)));\n    vec2 d3 = normalize(direction(uv_grid + vec2(1.,1.)));\n    \n    // Distance to the edge of the cell\n    vec2 i0 = uv_cell - vec2(0.,0.);\n    vec2 i1 = uv_cell - vec2(0.,1.);\n    vec2 i2 = uv_cell - vec2(1.,0.);\n    vec2 i3 = uv_cell - vec2(1.,1.);\n    \n    // Fade\n    uv_cell.x = fade(uv_cell.x);\n    uv_cell.y = fade(uv_cell.y);\n    \n    // Dot products\n    return mix(\n        mix(dot(d0,i0),dot(d2,i2),uv_cell.x),\n        mix(dot(d1,i1),dot(d3,i3),uv_cell.x),\n        uv_cell.y\n    );\n}\n\nfloat perlin3D(vec3 p)\n{\n    vec3 uv_grid = floor(p);\n    vec3 uv_cell = fract(p);\n    \n    // Direction vectors\n    vec3 d0 = (direction3D(uv_grid + vec3(0.,0.,0.)));\n    vec3 d1 = (direction3D(uv_grid + vec3(0.,1.,0.)));\n    vec3 d2 = (direction3D(uv_grid + vec3(1.,0.,0.)));\n    vec3 d3 = (direction3D(uv_grid + vec3(1.,1.,0.)));\n    vec3 d4 = (direction3D(uv_grid + vec3(0.,0.,1.)));\n    vec3 d5 = (direction3D(uv_grid + vec3(0.,1.,1.)));\n    vec3 d6 = (direction3D(uv_grid + vec3(1.,0.,1.)));\n    vec3 d7 = (direction3D(uv_grid + vec3(1.,1.,1.)));\n    \n    // Distance to the edge of the cell\n    vec3 i0 = uv_cell - vec3(0.,0.,0.);\n    vec3 i1 = uv_cell - vec3(0.,1.,0.);\n    vec3 i2 = uv_cell - vec3(1.,0.,0.);\n    vec3 i3 = uv_cell - vec3(1.,1.,0.);\n    vec3 i4 = uv_cell - vec3(0.,0.,1.);\n    vec3 i5 = uv_cell - vec3(0.,1.,1.);\n    vec3 i6 = uv_cell - vec3(1.,0.,1.);\n    vec3 i7 = uv_cell - vec3(1.,1.,1.);\n    \n    // Fade\n    uv_cell.x = fade2(uv_cell.x);\n    uv_cell.y = fade2(uv_cell.y);\n    uv_cell.z = fade2(uv_cell.z);\n    \n    // Dot products\n    float g0 = dot(d0,i0);\n    float g1 = dot(d1,i1);\n    float g2 = dot(d2,i2);\n    float g3 = dot(d3,i3);\n    float g4 = dot(d4,i4);\n    float g5 = dot(d5,i5);\n    float g6 = dot(d6,i6);\n    float g7 = dot(d7,i7);\n    \n    float p1 = mix(g0,g2,uv_cell.x);\n    float p2 = mix(g1,g3,uv_cell.x);\n    float p3 = mix(g4,g6,uv_cell.x);\n    float p4 = mix(g5,g7,uv_cell.x);\n    \n    float p5 = mix(p1,p2,uv_cell.y);\n    float p6 = mix(p3,p4,uv_cell.y);\n    \n    return mix(p5,p6,uv_cell.z);\n}\n\nfloat perlinFake3D(vec3 p)\n{\n    vec3 uv_grid = floor(p);\n    vec3 uv_cell = fract(p);\n    \n    // Direction vectors\n    vec2 d0 = normalize(direction2D_z(vec3(uv_grid.xy + vec2(0.,0.),p.z)));\n    vec2 d1 = normalize(direction2D_z(vec3(uv_grid.xy + vec2(0.,1.),p.z)));\n    vec2 d2 = normalize(direction2D_z(vec3(uv_grid.xy + vec2(1.,0.),p.z)));\n    vec2 d3 = normalize(direction2D_z(vec3(uv_grid.xy + vec2(1.,1.),p.z)));\n    \n    // Distance to the edge of the cell\n    vec2 i0 = uv_cell.xy - vec2(0.,0.);\n    vec2 i1 = uv_cell.xy - vec2(0.,1.);\n    vec2 i2 = uv_cell.xy - vec2(1.,0.);\n    vec2 i3 = uv_cell.xy - vec2(1.,1.);\n    \n    // Fade\n    uv_cell.x = fade2(uv_cell.x);\n    uv_cell.y = fade2(uv_cell.y);\n    \n    // Dot products\n    return mix(\n        mix(dot(d0,i0),dot(d2,i2),uv_cell.x),\n        mix(dot(d1,i1),dot(d3,i3),uv_cell.x),\n        uv_cell.y\n    );\n}\n\nfloat value(vec2 uv)\n{\n    vec2 uv_grid = floor(uv);\n    vec2 uv_cell = fract(uv);\n    \n    // Assign noise value to cells\n    float tl = hash12(uv_grid + vec2(0.,0.));\n    float tr = hash12(uv_grid + vec2(0.,1.));\n    float bl = hash12(uv_grid + vec2(1.,0.));\n    float br = hash12(uv_grid + vec2(1.,1.));\n    \n    // Interpolate between them\n    return mix(\n        mix(tl, bl, uv_cell.x),\n        mix(tr, br, uv_cell.x),\n        uv_cell.y\n    );\n}\n\nfloat fbm3D(vec3 p, int octaves)\n{\n    float amp = 1.;\n    float s = 1.;\n    \n    float n = 0.;\n    \n    for (int i=0;i<octaves;i++)\n    {\n        n += perlin3D(p*s)*amp;\n        s *= 2.;\n        amp *= .5;\n    }\n    \n    return n;\n}\n","name":"Common","description":"","type":"common"}]}