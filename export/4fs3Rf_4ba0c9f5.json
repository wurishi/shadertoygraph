{"ver":"0.1","info":{"id":"4fs3Rf","date":"1703300775","viewed":43,"name":"Improved Vector Visualization","username":"myth0genesis","description":"This is just the result of optimizing an earlier shader in order to be able to use it as a terminal background.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","grid","color","tracing","realtime","infinite","trace","cast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\n\nconst int maxcells = 45;\nconst float linflloff = 0.03;\nconst float capsLen = 0.45;\nconst float capsRad = 0.05;\n\nmat2 nRotxy;\nmat2 nRotyz;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nvec2 vecNoise(vec4 p0) {\n    p0 *= 0.03;\n    vec4 p1 = p0 * 1.23 + vec4(1385.382, 2769.299, 7631.838, 5173.371);\n    p0 += sin(p0.zwyx) * 1.1;\n    p1 += sin(p1.zwyx) * 1.1;\n    float d0 = dot(cos(p0), sin(p0.wxyz));\n    float d1 = dot(cos(p1), sin(p1.wxyz));\n    return vec2(d0, d1) * 1.7;\n}\n\nfloat capIntersect(vec3 ro, vec3 rd, float l, float ra, vec3 offs) {\n    ro -= offs + vec3(0.5);\n    ro.yz *= nRotyz;\n    ro.xy *= nRotxy;\n    rd.yz *= nRotyz;\n    rd.xy *= nRotxy;\n    float rdy2 = rd.y * rd.y;\n    float baba = l * l;\n    float baoa = l * ro.y;\n    float a = baba * (1.0 - rdy2);\n    float rdro = dot(rd.xz, ro.xz);\n    float br = baba * rdro;\n    float h = baba * (br * rdro - a * dot(vec3(ro.xz, -ra), vec3(ro.xz, ra)));\n\n    if(h >= 0.0) {\n        float t = (-br - sqrt(h)) / a;\n        float y = l * (ro.y + t * rd.y);\n        if(y > 0.0 && y < baba) return t;\n        vec3 oc = (y <= 0.0) ? ro : ro - vec3(0.0, l, 0.0);\n        float b = dot(rd, oc);\n        float c = dot(oc, oc) - ra * ra;\n        h = b * b - c;\n        if(h > 0.0) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 offst) {\n    vec3 pRes = (-ro + offst) / rd;\n    float md = min(min(pRes.x, pRes.y), pRes.z);\n    return vec4(vec3(equal(pRes, vec3(md))), md);\n}\n\nvec2 rayTraceDDA(inout vec3 ro, vec3 rd, vec3 id, vec3 rdsgn, out bool ih, out vec3 pf) {\n    bool plnht = false;\n    vec3 mf = max(rdsgn, 0.0);\n    vec3 qo = id + mf;\n    vec4 hRes = iPlane(ro, rd, qo);\n    pf = hRes.xyz;\n    float ns = 0.0;\n    float dO = capIntersect(ro, rd, capsLen, capsRad, id);\n    plnht = hRes.w > 0.0;\n    ih = dO > 0.0;\n    ro = (plnht && !ih) ? (ro + rd * hRes.w) : ro;\n    \n    return vec2(dO, hRes.w);\n}\n\nvec3 getNormal(vec3 p, vec3 offs) {\n    p -= offs + vec3(0.5);\n    p.yz *= nRotyz;\n    p.xy *= nRotxy;\n    float l = capsLen;\n    float r = capsRad;\n    float h = clamp(p.y / l, 0.0, 1.0);\n    return (p - vec3(0.0, h * l, 0.0)) / r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float tm = iTime * 3.0;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = (all(equal(iMouse.xy, vec2(0.0)))) ? (vec2(0.5)) : (-iMouse.xy / iResolution.xy);\n    \n    vec3 ro = vec3(0.0, 0.0, iTime);\n    mat2 rmxz = rot2D(m.x * tau + pi);\n    mat2 rmyz = rot2D(m.y * tau + pi);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n    vec3 col = vec3(0.0);\n\n    vec3 sgn = sign(rd);\n    bool inthit = false;\n    vec3 id = floor(ro);\n    vec3 plnmask;\n    vec2 mRes = vec2(0.0);\n    float td = 0.0;\n    vec2 ns = vec2(0.0);\n    \n    for (int i = 0; i < maxcells; i++) {  \n        ns = vecNoise(vec4(id, tm)) * tau;\n        nRotyz = rot2D(ns.x);\n        nRotxy = rot2D(ns.y);\n        \n        mRes = rayTraceDDA(ro, rd, id, sgn, inthit, plnmask);\n        td += mRes.y;\n        if (inthit) break;\n        \n        id += sgn * plnmask;\n    }\n    \n    vec3 p = ro + rd * mRes.x;\n    vec3 n = getNormal(p, id);\n    vec3 lpos = vec3(1.0, 2.0, 0.0);\n    lpos.yz *= nRotyz;\n    lpos.xy *= nRotxy;\n    float dif = dot(n, normalize(lpos)) * 0.45 + 0.55;\n    \n    vec3 bc = cos(ns.x + ns.y + vec3(0.0, tau, 2.0 * tau) / 3.0) * 0.5 + 0.5;\n    \n    dif = pow(dif, 0.4545);\n    col = inthit ? (bc * dif * max(1.0 - td * linflloff, 0.0)) : col;\n    col *= 0.75;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}