{"ver":"0.1","info":{"id":"DlcfRr","date":"1700846972","viewed":83,"name":"Stripey Torus Interior Rainbow","username":"tekano","description":"Loved the torus from  fb39ca4 added a rainbow effect using chat GPT 4 because I cannot code for toffee.  wasnt easy, took me at least half an hour to coax the right code out.   probly can be done much more efficiently but this was what I was aiming for","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// source here https://www.shadertoy.com/view/MsX3Wj\n\n// ShaderToy GLSL Fragment Shader Code\n\nconst float PI = 3.14159265358979323846264;\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; // Adjust for performance\n\n// Function to generate a continuous rainbow spectrum\nvec3 rainbowColor(float angle) {\n    // Normalize the angle to [0, 1]\n    float normalized = fract(angle / (2.0 * PI));\n\n    // Generate the rainbow spectrum based on the normalized angle\n    float red = 0.5 + 0.5 * cos(2.0 * PI * normalized);\n    float green = 0.5 + 0.5 * cos(2.0 * PI * (normalized - 0.333));\n    float blue = 0.5 + 0.5 * cos(2.0 * PI * (normalized - 0.666));\n\n    return vec3(red, green, blue);\n}\n\nvec2 rotate2d(vec2 v, float a) {\n    return vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n    return -sdTorus(p, vec2(4.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float threshold) {\n    for (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n        float dist = distanceField(pos);\n        if (abs(dist) < threshold) break;\n        pos += dist * dir;\n    }\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 cameraPos = vec3(0.0, 0.0, -3.8);\n    \n    vec3 cameraDir = vec3(0.0, 0.0, 0.5);\n    vec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n    vec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n    vec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n    \n    vec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n    \n    float majorAngle = atan(rayPos.z, rayPos.x);\n    float minorAngle = atan(rayPos.y, length(rayPos.xz) - 4.0);\n    \n    float edge = mod(8.0 * (minorAngle + majorAngle + iTime) / PI, 1.0);\n    float stripe = edge < 0.7 ? smoothstep(edge, edge+0.03, 0.5) : 1.0-smoothstep(edge, edge+0.03, 0.96);\n\n    vec3 color = rainbowColor(minorAngle + majorAngle + iTime);\n    vec3 finalColor = stripe > 0.1 ? color : vec3(0.0);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}