{"ver":"0.1","info":{"id":"XstBzf","date":"1526217438","viewed":304,"name":"Circle packing 2-Layers loopless","username":"akhgary","description":"Layer 2 is an approximation by a modulated sin wave.\n\nprobably there is an square root-ish algorithm for exact coordinates, but i could not figure that out.\n\nwho wants to go for layer 3? :)","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["circle","ball","plot","draw","rolling","circlepacking","loopfree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Loop free circle packing. \n\n// My play ground\n// https://www.desmos.com/calculator/pndtbj27ny\n//\n// thanks to user https://www.shadertoy.com/user/FabriceNeyret2\n// for his great help. i didnt know desmos is such a great tool!\n\n// Hue taken from https://www.shadertoy.com/view/4tlBWB\n\n#define tau 6.28318\n#define pi 3.14159\n\nconst vec2 C = vec2(0);\t// center\nconst float R = .2;\t\t// radius\n\nconst float t = asin(.5);\t// angle to tangent point between two circles in layer 1\nconst float tc = t*2.; \t\t// angle to center of circles in layer 1\n\nvec3 hue( in vec3 c ){\n\treturn c.z*(1.-c.y*smoothstep(2.,1.,abs(mod(c.x*6.+vec3(0,4,2),6.) -3.)));\n}\n\nfloat circle(vec2 xy, vec2 c, float r, bool fill){\n    float dist = length(xy-c)-r;\n    return 1.-smoothstep(-3./iResolution.y,2./iResolution.y,fill?dist:abs(dist));\n}\n\nmat2 rotate(float th){\n    return mat2(cos(th),-sin(th),sin(th),cos(th));\n}\n\nfloat layer0(vec2 xy){\n    return circle(xy, C, R, false);\n}\n\nvec3 layer1(vec2 xy, float ph){\n\tfloat n = tau/tc;\t\t\t\t\t\t// number of circles\n    vec2 zw = rotate(ph-t)*(xy-C); \t\t\t// plane rotation\n    float i = floor(atan(zw.y,zw.x)/tc);\t// angular coordinates to index\n    vec2 c = vec2(cos(i*tc+ph),sin(i*tc+ph))*2.*R+C; // center\n    vec3 hsl = vec3(i/n+.9,1.,.8);\t\t\t\t \t // coloring\n    return circle(xy,c,R,true)*hue(hsl);\n}\n\nvec3 layer2_half(vec2 xy, float k, float ph0, float ph){\n    float n = tau/t;\t\t\t\t\t// number of circles\n    vec2 zw = rotate(ph-t+k*t)*(xy-C);\t// plane rotation\n    float mad = 4.*R;\t\t\t\t\t// max distance\n    float mid = mad*cos(t); \t\t\t// min distance\n    float j = k+2.*floor((atan(zw.y,zw.x))/tc);\t\t        // angular coordinates to index\n    float r = mid+abs(cos(pi/2.*((ph-ph0)/t+j)))*(mad-mid); // approximated radius\n    vec2 c = vec2(cos(j*t+ph),sin(j*t+ph))*r+C; // center\n    vec3 hsl = vec3(j/n,1.,.5); \t\t\t\t// coloring\n    return circle(xy,c,R,true)*hue(hsl);\n}\n\nvec3 layer2(vec2 xy, float ph0, float ph){\n    return layer2_half(xy,0.,ph0,ph)+ // 6 even 0,2,4,6,8,10\n           layer2_half(xy,1.,ph0,ph); // 6 odd  1,3,5,7,9,11\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float ph1 = sin(iTime*2.)+iTime/2., ph2 = cos(iTime+pi/3.)-iTime/3.;\n    xy=rotate(iTime)*(xy-C)+C;\n\tvec3 col = layer0(xy)\n         \t + layer1(xy, ph1)\n        \t + layer2(xy, ph1, ph2);\n    \n    fragColor = vec4(1.-col,1.0);\n}","name":"Image","description":"","type":"image"}]}