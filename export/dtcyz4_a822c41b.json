{"ver":"0.1","info":{"id":"dtcyz4","date":"1698937976","viewed":78,"name":"glass queen","username":"Efim","description":"https://iquilezles.org/articles/distfunctions/\nhttps://en.wikipedia.org/wiki/Refraction\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["glass","chess","queen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.283185\n\nconst float dist_infin = 9.0;\n#define nn 128\nconst float eps = 0.001;\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xy), p.z );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//https://iquilezles.org/articles/smin/\n// polynomial smooth min 1 (k=0.1)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 pos )\n{\n\n    vec3 pos1 = pos - vec3(0., 0., 0.85);  //shift\n    //vec3 pos1 = pos;\n    float d1 = sdSphere(pos1 - vec3(0., 0., -1.6), 0.15);\n    float d2 = sdSphere(pos1 - vec3(0., 0., -1.79), 0.05);\n    d1 = smin(d1, d2, 0.02);\n    d2 = sdCappedCone(pos1-vec3(0.0, 0.0, -1.45), 0.15, 0.25, 0.13);\n    d1 = smin(d1, d2, 0.01);\n\n    d2 = sdCappedCylinder(pos1 - vec3(0., 0.0, -1.3), 0.2, 0.13);\n    d1 = smin(d1, d2, 0.01);\n\n    d2 = sdEllipsoid(pos1 - vec3(0., 0.0, -1.3), vec3(0.22, 0.22, 0.02));\n    d1 = smin(d1, d2, 0.02);\n    d2 = sdTorus(pos1 - vec3(0., 0.0, -1.2), vec2(0.18, 0.05));\n    d1 = smin(d1, d2, 0.01);\n    d2 = sdCappedCone(pos1-vec3(0.0, 0.0, -0.8), 0.5, 0.13, 0.25);\n    d1 = smin(d1, d2, 0.02);\n\n\n    d2 = sdRoundedCylinder(pos1 - vec3(0.0, 0.0, -0.1), 0.17, 0.05, 0.15);\n    d1 = min(d1, d2);\n    d2 = sdEllipsoid(pos1 - vec3(0., 0.0, -0.1), vec3(0.5, 0.5, 0.2));\n    d1 = smin(d1, d2, 0.05);\n    d2 = sdRoundedCylinder(pos1 - vec3(0.0, 0.0, 0.07), 0.25, 0.01, 0.02);\n    d1 = smin(d1, d2, 0.02);\n    return d1;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map(pos + k.xyy*h ) + \n                      k.yyx*map(pos + k.yyx*h ) + \n                      k.yxy*map(pos + k.yxy*h ) + \n                      k.xxx*map(pos + k.xxx*h ) );\n}\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n/*\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\nvec2 lonlat (vec3 p)\n{\n    float lon = aafi(p.xy)/TAU;\n    float lat = aafi(vec2(p.z, length(p.xy)))/PI;\n    return vec2(1.0-lon, lat);\n}\n*/\n\nHIT plane(vec3 ro, vec3 rd, vec3 po, vec3 nor)\n{\n    float t = dot(nor, (po - ro)) / dot(nor, rd);\n    if (t < 0.0)\n        return hit_inf;\n    vec3 pos = ro + t*rd;\n    return HIT(t, nor, pos);    \n    \n}\nvec3 skycol(vec3 rd)\n{\n    //vec2 fon = lonlat(rd); //get longitude and latitude\n    //return  texture(iChannel0, fon).rgb;\n    return  texture(iChannel0, rd).rgb;\n}\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nHIT cyl3D(vec3 ro, vec3 rd, float t, float h1, float h2)\n{\n    float a = ro.x;\n    float b = rd.x;\n    float c = ro.y;\n    float d = rd.y;\n    float e = ro.z;\n    float f = rd.z;\n    \n    //https://github.com/flightphone/shaderty/blob/master/staples_polynomial.py\n    //for generate this expression used python script staples_polynomial.py\n\n    float a0 = 1.*a*a + 1.*c*c-1.*t*t;\n    float a1 = 2.*a*b + 2.*c*d;\n    float a2 = 1.*b*b + 1.*d*d;\n\n    //https://github.com/flightphone/shaderty/blob/master/staples_polynomial.py\n\n    vec2 roots = vec2(dist_infin);\n    int nroots = quadratic(a2, a1, a0, roots); //cubic(a3, a2, a1, a0, roots);\n        \n    float dist = dist_infin;\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    for (int i = 0; i < 2; i++)\n    {\n        if (i >= nroots)\n            break;\n        if (roots[i] < 0.0)\n            continue;\n        vec3 p = ro + roots[i]*rd;\n        if (p.z < h2 || p.z > h1)    \n            continue;\n        if (roots[i] < dist)    \n        {\n            dist = roots[i];\n            pos = p;\n        }\n    }\n    /*\n    if (dist < dist_infin)\n    {\n        nor = vec3(0.+2.*pos.x, 0.+2.*pos.y, 0.);\n        nor = normalize(nor);\n    }\n    */\n    vec3 nr = vec3(0., 0., -1.);\n    HIT giper = plane(ro, rd, vec3(0., 0., h2), nr);\n    if (giper.dist < dist && length(giper.pos.xy) <= t)\n    {\n        dist = giper.dist;\n        nor = nr;\n        pos = giper.pos;\n    }\n\n    nr = vec3(0., 0., 1.);\n    giper = plane(ro, rd, vec3(0., 0., h1), nr);\n    if (giper.dist < dist && length(giper.pos.xy) <= t)\n    {\n        dist = giper.dist;\n        nor = nr;\n        pos = giper.pos;\n    }\n\n    return HIT(dist, nor, pos);\n    \n}\n\nHIT giper3D(vec3 ro, vec3 rd)\n{\n\n    float t  = 0.;\n    for (int i = 0; i < nn; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        if (h < eps || t >= dist_infin)\n            break;\n        t += h;  \n    }    \n\n    if (t >= dist_infin)\n        return hit_inf;\n      \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n    //return HIT(t + giper.dist, nor, pos);\n    return HIT(t, nor, pos);\n}\n\n/*\nvec3 calccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.3, 1.0);\n    return col;   \n}\n*/\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(0.0, 1.0, 1.0)); //light\n    vec3 light2 = normalize(vec3(0.0, 1.0, -1.0)); //light\n    float t = iTime/4.;\n    vec2 m = vec2(0.0, 0.0);\n    //if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n        //t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 2.1); // camera\n    //ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    \n    \n    const float fl = 1.5; // focal length\n    \n    mat3 rota  = rotateX(PI/2.0)*rotateZ(m.x*TAU)*rotateX(-m.y*PI);\n    mat3 rota_1  = rotateX(m.y*PI)*rotateZ(-m.x*TAU)*rotateX(-PI/2.0);\n    mat3 sky = rotateY(t);\n    //mat3 sky = rotateZ(t)*rotateX(PI/2.0);\n    \n    vec3 tot = vec3(0.0);\n    \n    \n        //antiblick\n        for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ )\n        {\n            float dist = dist_infin;\n            vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n            vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n            vec3 col = skycol(sky*rd); \n            \n            \n            HIT giper = cyl3D(rota*ro, rota*rd, 0.6, 1., -1.);\n            if (giper.dist >= dist_infin)\n            {\n                tot += col;\n                continue;\n            }\n            \n                        \n            giper = giper3D(rota*ro, rota*rd);\n            if (giper.dist < dist)\n            {\n                \n                vec3 nor = rota_1*giper.nor;\n                float dif = clamp( dot(nor,light), 0.2, 1.0 );\n                float amb = 0.5 + 0.5*dot(nor,light2);\n                \n                vec3 tx = vec3(80./255.,200.0/255.,120.0/255.);\n                tx = tx*amb + tx*dif;\n                \n                //refract\n                float n12 = 1.2;\n                vec3 rd1 = refract(rd, nor, n12);\n                vec3 ro1 = ro + giper.dist * rd + 0.7 * dist_infin * rd1;\n                rd1 = -rd1;\n                giper = giper3D(rota*ro1, rota*rd1);\n                if (giper.dist < dist_infin)\n                {\n                    nor = rota_1*giper.nor;\n                    ro1 = ro1 + rd1 * giper.dist;\n                    rd1 = refract(-rd1, -nor, 1.0/n12);\n                    \n                    vec3 tx2 = skycol(sky*rd1); \n                    col = mix(tx, tx2, 0.6);\n                }\n                else\n                    col = tx;\n\n            }\n            \n            // gamma        \n            //col = sqrt( col );\n            tot += col;\n        }\n        //antiblick\n        tot /= float(AA*AA);\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}