{"ver":"0.1","info":{"id":"ctfXWM","date":"1674821678","viewed":124,"name":"Rose Petals Rain","username":"LoganOracio","description":"vbeh ghjf gzeuig yuai fzyqlf ezqfyk gqz","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["wtf","beeeeeeeaaaaaaans"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nuvec4 murmurHash43(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec4 hash43(vec3 src) {\n    uvec4 h = murmurHash43(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n// Some of the Ray Marching stuff taken from mrange:\n\n// CC0: Wednesday messing around\n#define MAX_RAY_LENGTH  1000.0\n#define MAX_RAY_MARCHES 200\n#define TOLERANCE       0.0001\n#define NORM_OFF        0.0001\n\nint g_hit     = 0;\n\nconst float raymarchFactor = 0.5;\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(k*-a)+exp(k*-b))/k;\n}\nfloat df(vec3 p) {\n    vec4 rand = hash43(floor(p/3.0));\n    mat4 rot = rotationMatrix(rand.xyz*2.0-1.0,rand.w*15.0+iTime);\n    vec3 pm = mod(p,3.0)-1.5+(hash43(rand.yzw).xyz-0.5)*0.8;\n    pm = (rot*vec4(pm,1.0)).xyz;\n    pm.x += pnoise(pm.yz*0.7)*1.0;\n    pm.x += pnoise(pm.yz*32.0)*0.002;\n    pm.x += pnoise(pm.yz*64.0)*0.001;\n    pm.x += pnoise(pm.yz*128.0)*0.0005;\n    pm.y+=min(pow(abs(pm.z)*0.7,1.5),1.0);\n    return smax(length(pm)-1.0,abs(pm.x)-0.05,10.0);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti) {\n  float t = ti;\n  int i = 0;\n  vec2 dti = vec2(1e10,0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t + pow(t,2.0)*vec3(0.0,-0.001,0.0));\n    if (d < TOLERANCE) g_hit = 1;\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    if (d<dti.x) { dti=vec2(d,t); }\n    t += raymarchFactor*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; }\n  return t;\n}\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 render(vec2 p) {\n  \n  vec3 ro = vec3(iTime+1.5,iTime+1.5,iTime);\n  vec3 la = ro+vec3(1.0,1.0,1.0);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,0.0,1.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 0.5;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n  \n  g_hit = -1;\n  float t = rayMarch(ro, rd, 1.0);\n  int hit = g_hit;\n  \n  \n  vec4 col = vec4(0.0);\n  if (hit==1) {\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    //vec3 r = reflect(rd, n);\n    \n    col.xyz = pow(max(0.0,dot(n,-rd)),10.0)*vec3(0.3,0.15,0.15)+(1.0-abs(dot(n,vec3(0.333,0.333,0.333)))+0.08)*vec3(0.8,0.08,0.06);\n    col = mix(col, vec4(0.), .7*smoothstep(5.,40.,t));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}