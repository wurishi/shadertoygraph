{"ver":"0.1","info":{"id":"4tdyRj","date":"1533207486","viewed":1983,"name":"Happy Plant 3","username":"lnae","description":"Last one :)\n\nmore plants :\nhttps://www.shadertoy.com/view/4t3cDM\nhttps://www.shadertoy.com/view/4ltyD4\n\n","likes":86,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","watercolor","npr","plant","cactus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define STEPS 100.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.004\n\nfloat hash(vec3 p){\n\treturn fract(123456.789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise(vec3 p){\n\tvec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 c = floor(p);\n  \n    return mix(mix(mix(hash(c), hash(c + vec3(1., 0., 0.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 0.)), hash(c + vec3(1., 1., 0.)), f.x),\n               \t   f.y),\n               mix(mix(hash(c + vec3(0., 0., 1.)), hash(c + vec3(1., 0., 1.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 1.)), hash(c + vec3(1., 1., 1.)), f.x),\n               \t   f.y),\n               f.z);  \n}\n\nfloat fbm(vec3 p){\n\tvec3 pos = 10. * p;\n    float c = 0.5;\n    float res = 0.;\n    for(int i = 0; i < 4; i++){\n        pos.xy = rot(2.) * pos.xy;\n        pos = pos * 2. + 2.;\n    \tres += c * noise(pos);\n        c /= 2.;\n    }\n    return res;\n}\n\n\nvec2 repeat(vec2 pos, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(pos.y, pos.x) , t) - 0.5 * t;\n    float r = length(pos);\n    return r * vec2(cos(angle), sin(angle));\n}\n\n\nfloat distScene(in vec3 pos, out int object, out float colorVariation){\n    \n    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.22;\n    \n    float f = noise(100. * pos);\n    float sf = smoothstep(0.4, 0.5, f);\n    \n    //floor\n    float dist = pos.y;\n    object = 0;\n    colorVariation = 0.;\n    \n    //pot\n    vec3 p = pos;\n    p.y -= 0.155;\n    float distPot = length(p) - 0.2;\n    distPot = smoothmax(distPot, p.y - 0.097, 0.01);\n    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);\n    distPot = max(distPot, -(p.y + 0.15));\n    dist = min(dist, distPot);\n    \n    if(dist == distPot){\n        object = 1;\n        float anglev = acos(p.y / 0.2);\n        colorVariation = 0.9 * smoothstep(0.1, 0.2, 0.5 * sin(5. * sin(10. * anglev)) + 0.3 * (f - 0.5)) + 0.1 * sf;   \n    }\n    \n    //ground\n    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);\n    dist = min(dist, distGround);\n    \n    if(dist == distGround){\n        object = 2;\n        colorVariation = 0.;\n    }\n    \n    //anim\n    pos.y *= 1. + 0.0075 * sin(5. * iTime);\n    f = noise(100. * pos);\n    sf = smoothstep(0.4, 0.5, f);\n    \n\t//cactus\n    p = pos;\n    p.y -= 0.31;\n    float radout = 0.1;\n    float radin = 0.03;\n    float distPlant = length(vec2(length(p.xz) - radin, p.y)) - radout;\n    \n    float angleh = atan(p.z, p.x); \n    float rh = length(p.xz);\n    float t = 14.;\n    float div = 2. * PI / t;\n    float qh = floor(angleh / div);\n    angleh += 0.15 * p.y / radout;\n    angleh = mod(angleh, div) - 0.5 * div;\n    \n    p.x = rh * cos(angleh);\n    p.z = rh * sin(angleh);\n    \n    distPlant -= 0.01 * (0.5 + 0.5 * cos(t * angleh));\n    \n   \tvec3 pr = p - vec3(radin, 0., 0.);\n    float anglev = atan(pr.y, pr.x);\n    float att = abs(anglev);\n    float rv = length(pr.xy);\n    float qv = floor(anglev / (0.5 * div));\n    anglev = mod(anglev, 0.5 * div) - 0.25 * div;\n    p.x = rv * cos(anglev);\n    p.y = rv * sin(anglev);\n    \n    p -= vec3(radout + 0.01, 0., 0.);\n    float bumpRad = max(0.001, 0.005 - 0.0025 * att * att);\n    distPlant = smoothmin(distPlant, length(p) - bumpRad, 0.008);\n    \n    vec3 pSpike = p - vec3(bumpRad, 0., 0.);\n    pSpike.yz = rot(1.5 * hash(10. * vec3(qv, qh, t))) * pSpike.yz;\n    pSpike = abs(pSpike);\n    float spikeRad = 0.;//0.0015 - 0.001 * att * att;\n    float distSpike = length(pSpike.yz) - spikeRad;\n    pSpike.xz = rot(0.4 + 0.075 * sin(5. * iTime)) * pSpike.xz;\n    pSpike.xy = rot(0.4 + 0.075 * sin(5. * iTime)) * pSpike.xy;\n    distSpike = min(distSpike, length(pSpike.yz) - spikeRad);\n    distSpike = 1.75 * smoothmax(distSpike, length(pSpike) - 0.0375 + 0.01 * att * att, 0.025);\n    distPlant = min(distPlant, distSpike);\n    \n    dist = min(dist, distPlant);\n    \n    if(dist == distPlant){\n        object = 3;\n        colorVariation = cos(t * angleh) * cos(t * anglev) + 0.9 * (f - 0.5);\n        colorVariation = 0.5 + 0.5 * (smoothstep(0.5, 0.9, colorVariation) - smoothstep(0.55, 0.95, -colorVariation));\n        colorVariation = 0.8 * colorVariation + 0.2 * sf;\n    }\n    \n    //flower\n    p = pos;\n    p.y -= 0.31 + radout + 0.005;\n    \n    vec3 pLayer = p;\n    float radius = 0.075;\n    float np = 7.;\n    pLayer.xz = repeat(pLayer.xz, np);\n    pLayer.xy = rot(0.99 - 0.01 * sin(5. * iTime)) * pLayer.xy;\n    pLayer.y = abs(pLayer.y);\n    pLayer.z = smoothabs(pLayer.z, 0.01);\n    float distFlower = length(pLayer - vec3(0.4 * radius, -0.68 * radius, -0.67 * radius)) - radius;\n    \n    pLayer = p;\n    pLayer.xz = rot(PI / np) * pLayer.xz;\n    pLayer.xz = repeat(pLayer.xz, np);\n    pLayer.xy = rot(0.7 - 0.01 * sin(5. * iTime)) * pLayer.xy;\n    pLayer.y = abs(pLayer.y);\n    pLayer.z = smoothabs(pLayer.z, 0.01);\n    radius = 0.09;\n    distFlower = 1.3 * min(distFlower, length(pLayer - vec3(0.4 * radius, -0.68 * radius, -0.67 * radius)) - radius);\n    \n    dist = min(dist, distFlower);\n    if(dist == distFlower){\n    \tobject = 4;\n        colorVariation = smoothstep(0., 0.75, length(pLayer / radius));\n    }\n               \n    return 0.5 * dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),\n                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 inkColor = vec3(0.15, 0.25, 0.4);\n    vec3 col = inkColor;\n    \n    //raymarch\n    vec3 eye = vec3(0., 0., 5);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o, c);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o, c);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    float f = fbm(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(10., 5., 5.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        //paper\n        if(o == 0) col = 1. - 0.025 * vec3(smoothstep(0.6, 0.2, fbm(vec3(uv * 6.,1.))));\n        //pot\n        if(o == 1) col = mix(vec3(0.63, 0.63, 0.85), vec3(1.), 0.8 * c);\n        if(o == 2) col = vec3(0.6, 0.6, 0.6);\n        //plant\n        if(o == 3){\n            col = mix(vec3(0.3, 0.7, 0.6),vec3(0.85, 0.95, 0.7), c);\n\t\t\tshine = 5.;\n        }\n        //flower\n        if(o == 4){\n        \tcol = mix(vec3(0.85, 0.95, 0.7), vec3(0.96, 0.6, 0.85), c);\n            shine = 5.;\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        float diff = dot(normalize(normal + 0.2 * vec3(f - 0.5)), l);\n        diff = smoothstep(0.4, 0.5, diff + 0.3 * f);\n        if(o != 0) col = mix(col, vec3(0.1, 0.3, 0.75), 0.3 * (1. - diff));\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.6, spec + 0.5 * f);\n        col += 0.01 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline + 0.9 * f);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}