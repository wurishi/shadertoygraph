{"ver":"0.1","info":{"id":"Nsf3Dr","date":"1616717203","viewed":113,"name":"sphere_motion_blur23","username":"edwardbraed","description":"simple realization 'motion blur'","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["motionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 direct_blur(sampler2D tex, vec2 uv, vec2 d, int k)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    d *= s;\n    vec2 b = -0.5 * d * float(k - 1);\n    vec3 avg = vec3(0.0);\n    for(int x = 0; x < k; x++)\n        avg += texture(tex, uv + b + d * float(x)).rgb;\n    return avg / float(k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // motion blur compute\n    vec2 vel = vec2(VEL_X * 5.0, 0.0);\n    vec3 col = direct_blur(iChannel0, uv, vel, 32);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 0.5\n#define COLOR vec3(1.0, 0.8, 0.5)\n#define BACKGROUND_COLOR vec3(0.6 , 0.4, 0.2)\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, vec3 lv, float g)\n{\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            vec3 tmp = normalize(lv);\n            float l = dot(tmp, normalize(pos));\n            return vec4(COLOR * max(l, 0.1), 1.0);\n        }\n        \n        t += d;\n    }\n    \n    return vec4(BACKGROUND_COLOR * g, 1.0);\n}\n\n//thanks - me :) https://www.shadertoy.com/view/tscBW2\nfloat double_waves(vec2 p, vec2 s, float w, float t)\n{\n    #define m_p 3.14155\n    #define norm(a) (a + 1.0) * 0.5\n    p *= s * m_p;\n    p += norm(sin(p.y * w - t));\n    return norm(sin(p.x - t)  - p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    \n    // aspect ratio for correction rays..\n    vec2 aspect = calcAspect(iResolution.xy);\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y) * aspect,\n                   1.0);\n    \n    rd.x += VEL_X;\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(1.0, 0.5, -1.0);\n    \n    // background gradient\n    float g = 1.8 - abs(double_waves(uv - 0.5, vec2(2.0, 2.5), 1.2, iTime * 0.3));\n    \n    fragColor = raymarch(ro, rd, lv, g);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define VEL_X sin(iTime * 2.0) * sin(iTime * 3.0) * sin(iTime * 5.0) * iResolution.x / 1400.0","name":"Common","description":"","type":"common"}]}