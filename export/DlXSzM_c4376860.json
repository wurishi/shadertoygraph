{"ver":"0.1","info":{"id":"DlXSzM","date":"1674445685","viewed":238,"name":"Kirby Go","username":"devshaww","description":"Kirby jumping in a dream world","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["cartoon","pink","kirby"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------------------------------Copyright Declaration------------------------------\n// This project is strongly based on Inigo Quilez's project Happing Jumping\n// https://www.shadertoy.com/view/3lsSzf\n\n//---------------------------------------NOTICE--------------------------------------\n// To see waterfall texture, you would have to load custom textures using console\n// by executing the 2 following lines\n// gShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/0s7mrlje6xgl0kr/displacement.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/bqrco6zi2yl6x5i/uniformclouds.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n// AND: waterfall is set at z=-20.0, so as Kirby jumps forward, waterfall does disappear.\n//      code of toon shading part is commented in render method, and you can uncomment it to see the result.\n//---------------------------------------NOTICE--------------------------------------\n\n// github: https://github.com/wongzingji/KirbyGo\n\n// #if HW_PERFORMANCE==0\n// #define AA 1\n// #else\n#define AA 1  // Set AA to 1 if your machine is too slow\n// #endif\n\n\n////////////////////////////////\n// add elements\n// waterfall texture\nvec3 wftexel(vec2 uv, float time)\n{\n    //vec3 bd = vec3(0.66,0.196,0.188);\n    //vec3 td = vec3(0.463,0.188,0.165);\n    //vec3 bl = vec3(1.0,1.0,1.0);\n    //vec3 tl = vec3(0.9,0.757,0.737);\n    vec3 bd = vec3(0.35,0.07,0.06);\n    vec3 td = vec3(0.121,0.02,0.012);\n    vec3 bl = vec3(198.0/255.0,121.0/255.0,121.0/255.0);\n    vec3 tl = vec3(0.772,0.376,0.32);\n    \n    float threshold = 0.55;\n    \n    vec2 uv2 = uv * vec2(1.6,1.0);\n\n    // displacement\n    vec2 displ = texture(iChannel1, uv2 + iTime / 5.0).xy;\n    displ = (displ*2.0-1.0) * 0.04;  // displacement amount\n    \n    // noise\n    float noise = texture(iChannel0, vec2( uv.x*2.0, uv.y*0.2 + iTime/5.0 ) + displ).r;\n    noise = round(noise*5.0)/5.0;\n    \n    vec3 col = mix(mix(bd,td,uv.y),mix(bl,tl,uv.x),noise);\n    col = mix(vec3(1.0), col, step(threshold,uv.y+displ.y));\n    return col;\n}\n\n// watersurface\nvec3 watersurf(vec2 uv, float time)\n{   \n    uv *= vec2(3.0,3.0);\n    float freq = 4.0;\n    float amp = 1.0;\n    float n = 0.0;\n    vec2 g, gsum = vec2(0.0);\n\n    for (int i=0; i<5; i++) {\n        n += amp*psrdnoise(uv*freq+gsum*0.14, vec2(0.0), 8.0/freq*iTime, g);\n        gsum += g*amp;\n        freq *=2.0;\n        amp *= 0.5;\n    }\n\n    vec3 mixcolor = mix(vec3(0.463,0.188,0.165), vec3(0.35), -n*0.35+0.5);\n    return mixcolor;\n}\n\n// mushroom\nfloat head( in vec3 p )\n{\n    // top\n    float d3 = sdEllipsoid( p+vec3(0.0,2.1,0.0), vec3(0.35,0.2,0.35) );\n    d3 -= 0.03*(0.5+0.5*sin(11.0*p.z)*cos(9.0*p.x));\n    //d3 -= 0.05*exp(-128.0*dot(p.xz,p.xz));\n    \n    // interior\n    float d4 = sdSphere( p+vec3(0.0,2.3,0.0), 0.35 );\n\td4 += 0.005*sin( 20.0*atan(p.x,p.z) );\n\n    // substract\n    return smax( d3, -d4, 0.02 );\n    //return d3;\n}\n\nvec4 mapMushroom(vec3 p)\n{\n    vec2 objXY = vec2(0., 0.);\n    // objID: 7.0, 8.0\n    // stem\n    float h = clamp(p.y+1.2,0.0,1.0);\n    vec3 o = 0.12 * sin( h*3.0 + vec3(0.0,2.0,4.0) );\n    o = o*4.0*h*(1.0-h) * h;\n    \n    float c = cos(0.6*p.x+p.y+0.5);\n    float s = sin(0.6*p.x+p.y+0.5);\n    mat2 rot = mat2(c,s,-s,c);\n    vec3 q = p+vec3(0.0,1.9,0.0)-o*vec3(1.0,0.0,1.0);\n    q.xz = rot*q.xz;\n\n    float d1 = sdSegment( q, vec3(-0.15,0.0,0.0), vec3(-0.11,1.45,0.00) ).x;\n    d1 -= 0.06;\n    d1 -= 0.1*exp(-16.0*h);\n    vec4 res = vec4(d1, 8.0, objXY);\n\n    // head\n    float d2 = head( p + vec3(0.06,-1.5,0.0));\n    vec4 res2 = vec4(d2, 7.0, objXY);\n\n    // mix head and stem\n    //d1 = smin( d1, d3, 0.2 );\n    //d1 *= 0.75; \n    res = opU(res2, res);\n        \n    return res;\n}\n\n// waterfall\nvec4 sdWaterfall( in vec3 pos )\n{\n    vec2 objXY = vec2(0.,0.);\n    vec3 q = pos - vec3(0.0,0.6,-10.0);\n    float mw = 100.5;  // waterfall width\n    float mh = 4.0;\n    float hgap = 0.0; // height difference between boxbehind and waterfall\n    float mate = 9.0; // set default material number to waterfall\n\n    float d = sdRoundBox(q,vec3(mw,mh,0.3),0.1); // waterfall\n    float d2 = sdRoundBox(q-vec3(0.0,-2.0*hgap,-0.2),vec3(mw,mh-hgap,0.2),0.2); // box behind\n    \n    if(d > d2)\n    {\n        mate = 12.0;  // boxbehind\n    }\n    d = min(d,d2);\n   \n    return vec4(d,mate,objXY);\n}\n\n// pond\nvec4 sdPond( in vec3 pos )\n{\n    vec2 objXY = vec2(0.0,0.0);\n    vec3 q = pos-vec3(-2.2,-0.05,7.3);\n    float w = 0.8; // width/height of pond border\n    float h = 0.08;\n    // outside box\n    float d1 = sdRoundBox(q,vec3(w,h,w),0.0);\n    \n    // inside box\n    float d2 = sdRoundBox(q,vec3(w-0.2,h+0.01,w-0.2),0.0);\n    d1 = max(d1,-d2);\n    \n    // water surface\n    q.y += 0.04;\n    //float d3\n    float d3 = sdRoundBox(q,vec3(w,0.06+0.02*sin(3.0*iTime),w),0.0);\n    \n    return d1 > d3 ? vec4(d3,10.0,objXY) : vec4(d1,11.0,objXY);\n}\n\nvec2 sdFloor(in vec3 pos, float atime)\n{\n    float floorHeight = -0.1\n                                     - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5 = fract(atime+0.05);\n    //float k = length(pos.xz-cen.xz);\n    float k = length(pos.xz);\n    float t2 = t5*15.0-6.2831 - k*3.0;\n    floorHeight -= 0.1*exp(-k*k)*sin(t2)*exp(-max(t2,0.0)/2.0)*smoothstep(0.0,0.01,t5);\n    float dFloor = pos.y - floorHeight;\n\n    return vec2(floorHeight,dFloor);\n}\n\nfloat sdCloud(vec3 p)\n{\t\n\tp.x -= iTime;\t\t// translate with time\n\t//p += snoise(p*0.5)*1.0;\t// domain warp!\n\t\n\tvec3 q = p -vec3(p.x*0.4-p.z*0.5,10.0,p.z*0.5);\n\t// repeat on grid\n\tq.xz = mod(q.xz - vec2(2.5), 5.0) - vec2(2.5);\n    q.y *= 2.0;\t// squash in y\n\tfloat d = length(q) - _SphereRadius;\t// distance to sphere\n\n\t// offset distance with noise\n\t//p = normalize(p) * _SphereRadius;\t// project noise point to sphere surface\n\tp.y -= iTime*0.3;\t// animate noise with time\n\td += fbm(p*_NoiseFreq) * _NoiseAmp;\n\treturn d;\n}\n\n#define ZERO (min(iFrame,0))\n//////////////////////////////// \n//OLD:vec2->NEW:vec4(add relative coordinate)\nvec4 map( in vec3 pos, float atime )\n{\n    //Defalut return value\n    vec2 objXY = vec2(0.,0.); \n    vec4 res = vec4(-1.,-1., objXY);\n    \n    //yMove\n    float t = fract(atime); //[0,1]\n    float bounceWave = 4.0*t*(1.0-t);\n    float yMove = pow(bounceWave,2.0-bounceWave) + 0.1;\n    \n    //zMove\n    float zMove = 0.7*(floor(atime) + pow(t,0.7) -1.0);\n        \n     //xMove\n    float tt = abs(fract(atime*0.5)-0.5)/0.5;\n    float xMove = 0.5*(-1.0 + 2.0*tt);\n     \n    vec3 cen = vec3( xMove, yMove, zMove);\n    \n    //Coordinate\n    vec3 basic = pos-cen; \n    basic.xy = rotMat(-xMove*0.3) * basic.xy;\n    \n    float ttt = abs(fract((atime+0.5)*0.5)-0.5)/0.5;\n    float bodyMove = 0.5*(-1.0 + 2.0*ttt);\n    basic.xz = rotMat(bodyMove*1.) * basic.xz;\n    \n    vec3 symmBody =  vec3(  abs(basic.x), basic.yz);\n \n    \n    //body\n    float sy = 0.9 + 0.1*bounceWave;\n    float compress = 1.0-smoothstep(0.0,0.4,bounceWave);\n    sy = sy*(1.0-compress) + compress;\n    float sx = 1./sy;\n    \n    float dBody = sdEllipsoid( basic , vec3(0.2, 0.2, 0.2) );\n\n    //arm\n    vec3 armPos = vec3(0.2, 0., 0.);\n    float dArm = sdSphere( symmBody - armPos, 0.07);\n    \n    dBody = smin(dBody, dArm, 0.03);\n    \n    //mouth\n    {\n    float smell = 23.* basic.x*basic.x;\n    vec3 mouthPos = vec3(0., -0.03 +smell, 0.17);\n    float dMouth = sdEllipsoid( basic - mouthPos, vec3(0.1, 0.11, 0.15)*0.3 );\n    \n    dBody = smax(dBody, -dMouth, 0.01);\n    \n    vec2 frontBody= vec2(-1., -1.);    \n    if (basic.z > 0.){frontBody = symmBody.xy;}\n\n    vec4 bodyObj = vec4(dBody, 2.0, frontBody);\n    res = bodyObj;\n    }\n    \n    // leg\n    {\n    float sy = 0.5 + 0.3*bounceWave;\n    float compress = 1.0-smoothstep(0.0,0.4,bounceWave);\n    sy = sy*(1.0-compress) + compress;\n    float sx = 1./sy;\n    \n    vec3 legPos = vec3(0.11, -0.17, 0.05);\n    legPos = symmBody - legPos;\n    legPos.y += 0.2* legPos.x*legPos.x;\n    \n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    legPos.xz =rotMat(-1.0) * legPos.xz;\n    legPos.xy =rotMat(t6*sign(basic.x)) * legPos.xy;\n        \n    float dleg = sdEllipsoid( legPos, vec3(0.43, 0.18, 0.28)*0.3 );\n    vec4 legObj = vec4(dleg, 3.0,objXY);\n    \n    res = opU(res, legObj);\n    }\n    \n    \n    //eye\n    vec3 eyePos = vec3(0.06, 0.05, 0.19-2.*basic.y*basic.y);\n    eyePos = symmBody - eyePos;\n    \n    eyePos.xz = rotMat(0.32)*eyePos.xz;\n    \n    float ss = min(1.,mod(atime,3.1));\n    float sss = 1.- (smoothstep(0.,0.1,ss)-smoothstep(0.18,0.4,ss));\n    \n    float dEye = sdEllipsoid( eyePos, vec3(0.15, 0.3*sss+0.001, 0.03*sss+0.001)*0.2 );\n    vec4 eyeObj = vec4(dEye, 4.0, eyePos.xy);\n    res = opU(res, eyeObj);\n    \n    \n    // ground\n    vec2 floorData = sdFloor(pos, atime);\n    float floorHeight = floorData.x;\n    float dFloor = floorData.y;\n    vec2 floorObj = vec2(dFloor, 0.0);\n    \n    // bubbles\n    vec3 bubbleArea = vec3( mod(abs(pos.x),3.0),pos.y,mod(pos.z+1.5,3.0)-1.5);\n    \n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    \n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    \n    //smoothly  change the size when fly\n    float siz = 4.0*fy*(1.0-fy);\n    float dTree = sdEllipsoid( bubbleArea-vec3(2.0,y,0.0), rad*siz );\n\n    float bubbleTexture = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2, sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z))); \n    //dTree += 0.01 * bubbleTexture;\n\n    \n    dTree *= 0.6;\n    dTree = min(dTree,2.0);\n    vec2 treeObj = vec2(dTree,1.0);\n\n    vec2 res2 = smin( floorObj, treeObj, 0.32 );\n    //vec4 floorObj = vec4(dFloor, 1.0, objXY);\n    \n    res = opU(res, vec4(res2,objXY));\n    \n    //donuts\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-floorHeight-0.02, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    \n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    \n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.9);\n    \n    if (ra < 0.001)\n    {\n        ra = -0.1;\n    }\n\n    vec4 donutObj;\n    vec4 creamObj;\n\n    float angle = -1.2*fid;\n    vp.xy = rotMat(angle) * vp.xy;\n\n    float dDonut = sdDonut(vp, 0.24*ra)/fs;\n    float dCream = sdCream(vp, 0.24*ra)/fs;\n    //float dCandy = sdSphere( vp, 0.35*ra )/fs;\n    donutObj = vec4(dDonut, 5.0, objXY);\n    creamObj = vec4(dCream, 6.0, objXY);\n\n    res = opU(res, donutObj);\n    res = opU(res, creamObj);\n    }\n\n    // mushroom\n    {\n    vec3 q = pos;\n    q.xz = mod(q.xz - vec2(2.5), 5.0) - vec2(2.5); // repeat\n    q.y -= 1.05;\n    vec4 mushroomObj = mapMushroom(q);\n    res = opU(res, mushroomObj);\n    }\n\n    // waterfall\n    {\n    vec3 q = pos;\n    vec4 wfObj = sdWaterfall(q);\n    res = opU(res,wfObj);\n    }\n    \n    // pond\n    {\n    vec3 q = pos;\n    vec4 pondObj = sdPond(q);\n    res = opU(res,pondObj);\n    }\n\n    return res;\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0, 0., 0.);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    // vec2 e = vec2(0.0005,0.0);\n    // return normalize( vec3( \n    //     map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n\t// \tmap( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n\t// \tmap( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x ) );\n\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);    \n}\n\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcTransmittance(vec3 ro, vec3 rd, float tmin, float tmax, float atten, float time)\n{\n    const int MAX_DEPTH = 4;\n    float hitPoints[MAX_DEPTH];\n    int depth = 0;\n    \n    for (float t = tmin; t < tmax;)\n    {\n        float h = abs(map(ro + t * rd, time).x);\n        if (h < 1e-5) { hitPoints[depth++] = t; t += 0.01; };\n        if (depth >= MAX_DEPTH) break;\n        t += h;\n    }\n    \n    float thickness = 0.0;\n    for (int i = 0; i < depth - 1; i += 2) thickness += hitPoints[i+1] - hitPoints[i];\n    \n    return vec3(1.0) * exp(-atten * thickness * thickness);\n}\n\n// maps position to color\nvec4 calcVolume(vec3 p)\n{\n\tfloat d = sdCloud(p);\n\tvec4 c = mix(innerColor, outerColor, smoothstep(0.5, 1.0, d));\n\tc.rgb *= smoothstep(-1.0, 0.0, p.y)*0.5+0.5;\t// fake shadows\n\tfloat r = length(p)*0.04;\n\tc.a *= exp(-r*r);\t// fog\n\treturn c;\n}\n\nfloat sampleLight(vec3 pos, vec3 sun_lig)\n{\n\tconst int _LightSteps = 8;\n\tconst float _ShadowDensity = 1.0;\n\tvec3 lightStep = (sun_lig * 2.0) / float(_LightSteps);\n\tfloat t = 1.0;\t// transmittance\n\tfor(int i=0; i<_LightSteps; i++) {\n\t\tvec4 col = calcVolume(pos);\n\t\tt *= max(0.0, 1.0 - col.a * _ShadowDensity);\n\t\t//if (t < 0.01)\n\t\t\t//break;\n\t\tpos += lightStep;\n\t}\n\treturn t;\n}\n\nvec4 castRayVolume(vec3 rayOrigin, vec3 rayStep, vec4 sum, out vec3 pos)\n{\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tvec4 col = calcVolume(pos);\n#if 0\n\t\t// volume shadows\n\t\tif (col.a > 0.0) {\n\t\t\tcol.rgb *= sampleLight(pos, normalize( vec3(0.6, 0.35, 0.5) )); // sun_dir\t\n\t\t}\n#endif\t\t\n\t\t\n#if 0\n\t\tsum = mix(sum, col, col.a);\t// under operator for back-to-front\n#else\t\n\t\tcol.rgb *= col.a;\t\t// pre-multiply alpha\n\t\tsum = sum + col*(1.0 - sum.a);\t// over operator for front-to-back\n#endif\n\t\t\n#if 0\n\t\t// exit early if opaque\n        \tif (sum.a > _OpacityThreshold)\n            \t\tbreak;\n#endif\t\t\n\t\tpos += rayStep;\n\t\t//rayStep *= 1.01;\n\t}\n\treturn sum;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time, vec2 uv )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    vec3 hitPos;\n    col += castRayVolume(ro, rd*0.7, vec4(0.0), hitPos).rgb; // rd*stepSize\n\n    \n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec2 objXY = res.zw;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if (res.y > 11.5)  // box behind waterfall 12\n        {\n            col = vec3(0.66,0.196,0.188);\n        }\n        else if (res.y > 10.5) // pond border 11\n        {\n            //vec3 bd = vec3(0.66,0.196,0.188);\n            //vec3 td = vec3(0.463,0.188,0.165);\n            //vec3 bl = vec3(1.0,1.0,1.0);\n            //vec3 tl = vec3(0.9,0.757,0.737);\n            col = vec3(0.463,0.188,0.165);\n        }\n        else if (res.y > 9.5) // water surface 10\n        {\n            col = watersurf(uv, time);\n        }\n        else if (res.y > 8.5) // waterfall 9\n        {\n            col = wftexel(uv, time);\n        }\n        else if (res.y > 7.5) // mushroom stem\n        {\n            col = vec3(0.6706, 0.2, 0.0549);   \n            col = mix( col, 0.6*vec3(0.2078, 0.098, 0.1059), 0.92*(1.0-smoothstep(0.1,0.5,pos.y)) );\n        }\n        else if (res.y > 6.5)\n        {\n            col = vec3(0.76,0.26,0.3); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col *= 3.0*noise(pos.xy);\n\n             vec2 q = vec2(0.);\n            q.x = fbm( pos.xy);\n            q.y = fbm( pos.xy + vec2(1.0));\n\n            vec2 r = vec2(0.);\n            r.x = fbm( pos.xy + 1.0*q + vec2(1.7,9.2));\n            r.y = fbm( pos.xy + 1.0*q + vec2(8.3,2.8));\n\n            float f = fbm(pos.xy+r);\n            vec2 g = vec2(f);\n            \n            vec3 color = vec3(0.0);\n            color = mix(vec3(0.681,0.858,0.920),\n                        vec3(0.967,0.156,0.573),\n                        clamp((f*f)*4.312,0.992,1.0));\n\n            color = mix(color,\n                        vec3(0.300,0.034,0.134),\n                        clamp(length(q),0.0,1.0));\n\n            color = mix(color,\n                        vec3(1.000,0.700,0.315),\n                        clamp(length(r.x),0.0,1.0));\n            \n            col *= vec3((f*f*f+0.7*f*f*f*f+3.068*f*f)*color*5.0);\n        }\n        else if (res.y > 5.5)  //donuts\n        {\n            col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.13*cos((id.x*11.1+id.y*37.341) + vec3(1.0,1.0,1.0) );\n             col = max(col,0.0);\n            //col = vec3(0.639,0.302,0.549);\n          \n        }\n        else if (res.y > 4.5)  //candy\n        {\n            col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n        }\n        else if( res.y>3.5 ) // eye\n        {  // todo: return relative coordinate instead of absolute\n            vec3 black = vec3(0.0);\n            vec3 blue = vec3(0.0,0.0,1.0);\n            col = (1.0 - vec3(smoothstep(-0.2,0.,objXY.y))) * blue;\n            \n            vec2 ab = vec2(0.0,0.02);\n             float eyeBall = pow(objXY.x-ab.x,2.0)/1. + pow(objXY.y-ab.y,2.0)/4.;\n             if (eyeBall < 0.0002){col = vec3(1.0);}\n            \n        } \n        else if( res.y>2.5 ) // leg\n        { \n            col = vec3(0.4,0.0,0.02);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = vec3(0.5,0.07,0.1);\n            if (objXY.x > -0.5){\n            \n                vec3 bodyCol = vec3(0.5,0.07,0.1);\n                vec3 blusherCol = vec3(0.686,0.031,0.067);\n                vec3 mouthCol = vec3(0.561,0.020,0.047);\n\n                vec2 ab = vec2(0.12,-0.02); \n                float blusher = pow(objXY.x-ab.x,2.0)/4. + pow(objXY.y-ab.y,2.0)/1.;\n                col = mix(blusherCol, bodyCol, smoothstep(0.0001, 0.0002, blusher));\n                \n                float mouth = pow(objXY.x,2.0)/4. + pow(objXY.y-12.*pow(objXY.x, 2.0)+0.04,2.0)/4.;\n                if (mouth < 0.00015){col = mouthCol;}\n               }\n        } else if (res.y>0.5) // bubble\n        {\n            col = bubble_mat.diffuseAlbedo;\n        } \n        else // ground\n        {\n            col = vec3(0.3961, 0.2118, 0.2196);\n            \n            float wave = sqrt(1.0-pow(fract(pos.x+pos.y*2.0+pos.z*0.5), 2.0)) + pow(pos.x*pos.x, 0.33);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,wave));\n            col += 0.6*wave*vec3(0.1529, 0.0902, 0.1098);\n            col *= vec3(0.6392, 0.4431, 0.4431);            // vec3(0.06,0.06,0.02)\n            \n            // stronger light\n            ks = 0.5 + pos.y*0.15;\n        }\n        \n        // lighting (sun, sky, bounce)\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = step(castRay( pos+0.001*nor, sun_lig,time ).y,0.0);\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n        lin += sky_dif*vec3(0.50,0.70,1.00);\n        lin += bou_dif*vec3(0.40,1.00,0.40);\n        \n        if (res.y>0.5 && res.y<1.5)\n        {\n            // translucency\n            float t = clamp(0.5, 0.2, 1.0);\n            lin *= t*calcTransmittance(pos+nor*vec3(0.01), sun_lig, 0.01, 10.0, 2.0, time);\n            lin += (1.0 - t) * calcTransmittance(pos+nor*vec3(0.01), rd, 0.01, 10.0, 0.5, time);\n        }\n\n        col = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        // toon shading: uncomment the following lines to see result\n        //float param = 0.1;\n        //float sun_dif_toon = floor(sun_dif/param);\n        //col *= sun_dif_toon*param;\n        //col += 0.1;    // brightness adjustment\n        if (res.y>0.5 && res.y<1.5)\n        {\n            col += lin * bubble_mat.specularAlbedo * pow(max(0.0, dot(reflect(sun_lig,nor),rd)), 4.0);\n            col = mix( col, vec3(0.3961, 0.2118, 0.2196), 0.92*(1.0-smoothstep(0.1,0.5,pos.y)) );\n        }\n\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec2 uv = (fragCoord+o)/min(iResolution.x, iResolution.y);\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n        float time = iTime;\n#endif\n        //float time = 1.;\n        time *= 0.7;\n\n        // camera\t  \n        float forwardWave = sin(0.5*time);\n        float smoothForward = 0.7*(-1.+time*1.0 - 0.4*forwardWave); \n        \n        \n        ////////////////////////****V2.0***********************///////////////////\n        //float rotx = 2.5 + (iMouse.y / iResolution.y)*4.0;\n        //float roty = 2.5 + (iMouse.x / iResolution.x)*4.0;\n        //vec3  ta = vec3( 0.0, 0.65, smoothForward);\n        //float zoom = 1.0;\n        //vec3  ro = ta + zoom*normalize(vec3(cos(roty), cos(rotx), sin(roty))); \n        ///////////////////////****************************//////////////////////\n        \n        float an_x = 10.*iMouse.x/iResolution.x;\n        float an_y = 10.*iMouse.y/iResolution.y;\n    vec3  ta = vec3( 0.0, 0.65, smoothForward);\n        vec3  ro = ta + vec3( 1.5*cos(an_x), 1.5*cos(an_y), 1.5*sin(an_x) ); \n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.03 //weight\n                    *sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0.0, 1.0,0.0); \n        vec3 cu = normalize( cross(cw,cp) ); \n        vec3 cv =          ( cross(cu,cw) ); \n\n\n        vec3 rd = normalize( p.x*cu + p.y*cv + 1.8*cw );\n\n        vec3 col = render( ro, rd, time, uv );\n\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n    #if AA>1\n        }\n        tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// parmas\nstruct Material\n{\n    vec3 \tdiffuseAlbedo;\n    vec3 \tspecularAlbedo;\n    float \tspecularPower;\n};\nMaterial stem_mat = Material(vec3(0.8196, 0.3922, 0.2078), vec3(0.3), 8.0);\nMaterial bubble_mat = Material(vec3(0.7529, 0.4824, 0.6039), vec3(0.3), 8.0);\n\n// cloud params\nconst int _VolumeSteps = 64;\nconst float _StepSize = 0.05; \nconst float _Density = 0.1;\nconst float _OpacityThreshold = 0.95;\n\nconst float _SphereRadius = 1.2;\nconst float _NoiseFreq = 0.5;\nconst float _NoiseAmp = 2.0;\n\nconst vec4 innerColor = vec4(0.7, 0.7, 0.7, _Density);\nconst vec4 outerColor = vec4(1.0, 1.0, 1.0, 0.0);\n\n\n//utils\n// Smooth Min\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Smooth Max\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nmat2 rotMat(float rot)\n{\n    float cc = cos(rot);\n    float ss = sin(rot);\n    return mat2(cc, ss, -ss, cc);\n}\n\n///////////////////////////////////\n//sdf\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n//Donuts\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdDonut(vec3 p, float rad) {\n    float d1 = sdTorus(p, vec2(rad, rad/1.5));\n\treturn d1;\n}\n\nfloat sdCream(vec3 p, float rad) {\n    float f = 0.0;\n    f += sin(p.x * 1.1*16. + p.z * 1.2*3.) * 1.;\n    f += sin(p.x * 2.5*3.) * 0.5;\n    f += sin(p.z * 4.*3.) * 0.25;\n    f /= 8.0;\n    \n    float d2 = abs(p.y*7. + f + 2.0) - 2.3;\n    \n    float d1 = sdDonut(p,  rad);\n    float d = max(d1, -d2);\n    \n\treturn d ;\n}\n\n////////////////////////////////\n// noise\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n     //return mod289(((x*34.0)+1.0)*x);\n}\n// 2D\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\t  \n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\n// noise for water surface\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n//----\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 hsv2rgb( float h, float s, float v )\n{\n\treturn (\n\t\t(\n\t\t\tclamp(\n\t\t\t\tabs( fract( h + vec3( 0.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0\n\t\t\t,\t0.0\n\t\t\t,\t1.0\n\t\t\t) - 1.0\n\t\t) * s + 1.0\n\t) * v;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,vec2(12.9898,78.633)))*43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * f * f *(3.0 - 2.0 * f);  //+2.0*sin(u_time/10.0)\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                   -sin(0.5), cos(0.5));\n  \n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * (4.5) + shift;\n        a *= 0.45;\n    }\n    return v;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f = 0.5000*snoise( p ); p = p*2.02;\n    f += 0.2500*snoise( p ); p = p*2.03;\n    f += 0.1250*snoise( p ); p = p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n","name":"Common","description":"","type":"common"}]}