{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Feature Options - (Comment out to disable)\n#define PARTICLES // Slow, disable for decent speedup\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//\n//\n//\n//\n\nfloat sphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat cylinder(vec3 p, float c)\n{\n\treturn length(p.xz) - c;\n}\n\nfloat repeat(float pos, float c)\n{\n\treturn mod(pos, c) - c * 0.5;\n}\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle), s = sin(angle);\n\treturn vec2(pos.x*c + pos.y*s, pos.y*c - pos.x*s);\n}\n\nfloat spikes(vec3 pos)\n{\n\tvec3 s1 = vec3(pos.xy, pos.z);\n\tvec3 s2 = vec3(rotate(pos.xy, 1.047), pos.z);\n\tvec3 s3 = vec3(rotate(pos.xy, 2.094), pos.z);\n\tvec3 s4 = vec3(rotate(s2.yz, -1.047), s2.x).zxy;\n\tvec3 s5 = vec3(rotate(s3.yz,  1.047), s3.x).zxy;\n\tvec3 s6 = vec3(rotate(pos.yz, 1.047), pos.x).zxy;\n\t\n\tfloat ss = 0.06;\n\t\n\tfloat c = min(\n\t\tmin(\n\t\t\tmin(cylinder(s1, ss), cylinder(s2, ss)),\n\t\t\tmin(cylinder(s3, ss), cylinder(s4, ss))\n\t\t),\n\t\tmin(cylinder(s5, ss), cylinder(s6, ss))\n\t);\n\t\n\tfloat s = sphere(pos, 1.3);\n\t\n\treturn min(max(c, s),max(c-0.1, s+0.2));\n}\n\nfloat chains(vec3 pos, float instance)\n{\n\tfloat t = iTime * 0.4 + instance * 10.0;\n\tfloat c = sqrt(1.0 - clamp(pos.y + 3.6, 0.0, 3.0) * 0.33);\n\tvec3 cp = pos + vec3(sin(pos.y*1.1+t) * c * 0.3, cos(pos.y*0.9) * 0.3, 0.0);\n\treturn max(cylinder(cp, 0.02 * pow(sin(pos.y*25.0),2.0) + 0.02), pos.y);\n}\n\nfloat map(vec3 pos)\n{\n\tfloat instance = floor(pos.z / 6.0 + 0.5);\n\t\n\tif (pos.x > 0.0) pos.z += 3.0; // Left vs Right\n\tpos.x -= 3.0 * sign(pos.x);\n\t\n\t// Repeat into distance\n\tvec3 rp = vec3(\n\t\tpos.x,\n\t\tpos.y,\n\t\trepeat(pos.z, 6.0)-2.0\n\t);\n\t\n\t// Make different heights\n\trp.x += sin(instance * 17.0 + iTime * 0.9) * 0.05;\n\trp.y += sin(instance * 10.0) * 0.4 + pow(cos(instance * 17.0 + iTime), 2.0) * 0.08;\n\t\n\tfloat minesSpikes = spikes(vec3(rotate(rp.xy, sin(instance)*0.2), rp.z));\n\tfloat minesMain = sphere(rp, 1.0);\n\t\n\treturn min(min(chains(rp, instance), minesMain), minesSpikes);\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec2 eps = vec2(0.001, 0.0);\n\tfloat dx = map(pos+eps.xyy)-map(pos-eps.xyy);\n\tfloat dy = map(pos+eps.yxy)-map(pos-eps.yxy);\n\tfloat dz = map(pos+eps.yyx)-map(pos-eps.yyx);\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 trace(vec3 rayPos, vec3 rayDir, vec2 pixel)\n{\n\tvec3 dustCol = vec3(0.2, 0.18, 0.15);\n\tvec3 fogCol = vec3(0.05, 0.1, 0.15) * pow(rayDir.z + 0.04, 8.0);\n\tvec3 lightPos = rayPos-vec3(0.0, 1.0, 0.0);\n\t\n\tfloat fog = 0.0;\n\tfloat t = 0.0;\n\t\n\tfloat spec = 0.0;\n\tvec4 col = vec4(0.0);\n\tvec2 uv = vec2(0.0);\n\t\n\tfor (int i = 0; i < 40; i++)\n\t{\n\t\tvec3 pos = rayPos+rayDir*t;\n\t\tfloat h = map(pos);\n\t\t\n\t\tif (h < 0.005)\n\t\t{\n\t\t\tvec3 v = normalize(pos-rayPos); // View\n\t\t\tvec3 l = normalize(pos-lightPos); // Light\n\t\t\tvec3 n = normal(pos);\n\t\t\tfloat strength = pow(l.z + 0.08, 32.0);\n\t\t\tfloat d = max(-dot(n, l) * strength, 0.0);\n\t\t\t\t\n\t\t\tspec = pow(max(-dot(reflect(l, n), v), 0.0), 10.0) * strength;\n\t\t\tuv = n.xy;\n\t\t\tcol = vec4(vec3(0.4) * d, max(1.0 - fog, 0.0));\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (fog > 0.995) \n\t\t{\n\t\t\tt = 1e5;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tt += h * 0.9;\n\t\tfog += h * 0.055 + 0.005;\n\t}\n\t\n\tfloat particle = 0.0;\n\tfloat scatter = 0.0;\n\t\n\t#ifdef PARTICLES\n\tfloat wt = snoise(vec3(pixel, iTime)) * 0.05 + 0.1;\n\tfor (int i = 0; i < 50; i++)\n\t{\n\t\tvec3 pos = rayPos+rayDir*wt;\n\t\t\t\n\t\tvec3 lightDiff = lightPos-pos;\n\t\tfloat lightDist = length(lightDiff);\n\t\tfloat n = max(snoise(pos*vec3(5.0, 5.0, 5.0)), 0.0);\n\t\t\n\t\tfloat lightStrength = smoothstep(-0.7, -0.9, normalize(lightDiff).z);\n\t\tif (lightStrength > 0.0) scatter += 1.0 / lightDist * lightDist * 0.02 * lightStrength;\n\t\tparticle += pow(smoothstep(0.85, 0.95, n), 32.0) * 0.5 * lightStrength;\n\t\t\n\t\twt += 0.1;\n\t\tif (wt >= t) break;\n\t}\n\t#endif\n\t\n\tvec3 tex = texture(iChannel0, uv).rgb;\n\treturn mix(fogCol, col.rgb*tex+vec3(spec*(smoothstep(0.43, 0.52, tex.b)+0.15)), col.a) + dustCol*particle;\n}\n\nvec3 camera(vec2 px)\n{\n\tvec2 rd = (px / iResolution.yy - vec2(iResolution.x/iResolution.y*0.5-0.5, 0.0)) * 2.0 - 1.0;\n\tvec3 rayDir = normalize(vec3(rd.x*0.5, rd.y*0.5, 1.0));\n\t\n\tfloat x = sin(iTime*1.0) * 0.1 + 0.1;\n\tfloat y = cos(iTime*1.0) * 0.05 - 1.1;\n\tvec3 rayPos = vec3(x, y, iTime);\n\t\n\treturn trace(rayPos, rayDir, px);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(pow(camera(fragCoord.xy), vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xss3zN","date":"1364899272","viewed":2307,"name":"Minefield","username":"vanburgler","description":"Submarine navigating between naval mines. The whole scene is ray-marched. Played around with repetition and CSG operations\n\nv1.1: Add variation between mines, animation of mines and chains and option to switch off particles","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","volumetric"],"hasliked":0,"parentid":"","parentname":""}}