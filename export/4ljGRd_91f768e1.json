{"ver":"0.1","info":{"id":"4ljGRd","date":"1431467551","viewed":20124,"name":"Annotated Ray Tracing","username":"Polytonic","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":136,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\n// lamp hanging from the ceiling. Light is constantly being emitted from the\n// lamp in the form of light rays, which bounce around the room until they hit\n// your eye. Ray tracing follows a similar concept by simulating the path of\n// light through a scene, except in reverse. There is no point in doing the math\n// for light rays you cannot see!\n\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\n// ray from the camera through each pixel on screen. If the ray collides with\n// geometry in the scene, create new rays that perform the same process for both\n// reflection, as in a mirror, and refraction, as in through water. Repeat\n// to your satisfaction.\n\n// Having worked extensively with OpenCL in the past, this seemed like a good\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\n// line-by-line explanation, I decided to write a parallel ray tracer with\n// extensive annotations. The results are below ...\n\n// ![screenshot](/uploads/raytracer.png)\n\n// I start with a simple ray definition, consisting of an origin point and a\n// direction vector. I also define a directional light to illuminate my scene.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 direction;\n};\n\n// In real life, objects have many different material properties. Some objects\n// respond very differently to light than others. For instance, a sheet of paper\n// and a polished mirror. The former exhibits a strong *diffuse* response;\n// incoming light is reflected at many angles. The latter is an example of a\n// *specular* response, where incoming light is reflected in a single direction.\n// To model this, I create a basic material definition. Objects in my scene\n// share a single (RGB) color with diffuse and specular weights.\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\n// To render the scene, I need to know where a ray intersects with an object.\n// Since rays have infinite length from an origin, I can model the point of\n// intersection by storing the distance along the ray. I also need to store the\n// surface normal so I know which way to bounce! Once I create a ray, it loses\n// the concept of scene geometry, so one more thing I do is forward the surface\n// material properties.\nstruct Intersect {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\n// The last data structures I create are for objects used to fill my scene. The\n// most basic object I can model is a sphere, which is defined as a radius at\n// some center position, with some material properties. To draw the floor, I\n// also define a simple horizontal plane centered at the origin, with a normal\n// vector pointing upwards.\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 normal;\n    Material material;\n};\n\n// At this point, I define some global variables. A more advanced program might\n// pass these values in as uniforms, but for now, this is easier to tinker with.\n// Due to floating point precision errors, when a ray intersects geometry at a\n// surface, the point of intersection could possibly be just below the surface.\n// The subsequent reflection ray would then bounce off the *inside* wall of the\n// surface. This is known as self-intersection. When creating new rays, I\n// initialize them at a slightly offset origin to help mitigate this problem.\nconst float epsilon = 1e-3;\n\n// The classical ray tracing algorithm is recursive. However, GLSL does not\n// support recursion, so I instead use an iterative approach to control the\n// number of light bounces.\nconst int iterations = 16;\n\n// Next, I define an exposure time and gamma value. At this point, I also create\n// a basic directional light and define the ambient light color; the color here\n// is mostly a matter of taste. Basically ... lighting controls.\nconst float exposure = 1e-2;\nconst float gamma = 2.2;\nconst float intensity = 100.0;\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\n\n// For a Static Light\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n\n// For a Rotating Light\n// Light light = Light(vec3(1.0) * intensity, normalize(\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\n//                      1.0 + 4.0 * sin(iTime))));\n\n// I strongly dislike this line. I needed to know when a ray hits or misses a\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\n// the ray misses all geometry and instead hits the sky box. In a language that\n// supports dynamic return values, I could `return false`, but that is not an\n// option in GLSL. In the interests of making progress, I created an intersect\n// of distance zero to represent a miss and moved on.\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\n// intersection is relatively straightforward. For reflection purposes, a ray\n// either hits or misses, so I need to check for no solutions, or two solutions.\n// In the latter case, I need to determine which solution is \"in front\" so I can\n// return an intersection of appropriate distance from the ray origin.\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\n// Since I created a floor plane, I likewise have to handle reflections for\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\n// intersection. I only care about the intersect for the purposes of reflection,\n// so I only check if the quotient is non-zero.\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\n// In a *real* ray tracing renderer, geometry would be passed in from the host\n// as a mesh containing vertices, normals, and texture coordinates, but for the\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\n// input ray and iterate through all geometry to determine intersections.\nIntersect trace(Ray ray) {\n    const int num_spheres = 3;\n    Sphere spheres[num_spheres];\n\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\n    // scene definition, but soon found performance was abysmal on very large\n    // spheres. I kept the general format, modified to fit my data structures.\n\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\n\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\n    // with the plane, then loop through all spheres back-to-front.\n\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\n    for (int i = 0; i < num_spheres; i++) {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n            intersection = sphere;\n    }\n    return intersection;\n}\n\n// This is the critical part of writing a ray tracer. I start with some empty\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\n// using an input ray, and continue to fire new rays until the iteration depth\n// is reached, at which point I return the total sum of the color values from\n// computed at each bounce.\nvec3 radiance(Ray ray) {\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for (int i = 0; i <= iterations; ++i) {\n        Intersect hit = trace(ray);\n\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\n        // trace returns an intersection with either a diffuse or specular\n        // coefficient, then it has encountered a surface of a sphere or plane.\n        // Otherwise, the current ray has reached the ambient-colored sky box.\n\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\n\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\n            // to determine the Fresnel specular contribution factor, a measure\n            // of how much incoming light is reflected or refracted. I compute\n            // the Fresnel term and use a mask to track the fraction of\n            // reflected light in the current ray with respect to the original.\n\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;\n\n            // I handle shadows and diffuse colors next. I condensed this part\n            // into one conditional evaluation for brevity. Remember `epsilon`?\n            // I use it to trace a ray slightly offset from the point of\n            // intersection to the light source. If the shadow ray does not hit\n            // an object, it will be a \"miss\" as it hits the skybox. This means\n            // there are no objects between the point and the light, at which\n            // point I can add the diffuse color to the fragment color since the\n            // object is not in shadow.\n\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\n                       * hit.material.color.rgb * hit.material.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n\n            // After computing diffuse colors, I then generate a new reflection\n            // ray and overwrite the original ray that was passed in as an\n            // argument to the radiance(...) function. Then I repeat until I\n            // reach the iteration depth.\n\n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n        } else {\n\n            // This is the other half of the tracing branch. If the trace failed\n            // to return an intersection with an attached material, then it is\n            // safe to assume that the ray points at the sky, or out of bounds\n            // of the scene. At this point I realized that real objects have a\n            // small sheen to them, so I hard-coded a small spotlight pointing\n            // in the same direction as the main light for pseudo-realism.\n\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\n            color += mask * (ambient + spotlight); break;\n        }\n    }\n    return color;\n}\n\n// The main function primarily deals with organizing data from OpenGL into a\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\n// the fragment coordinates by the viewport resolution. I then offset that by a\n// fixed value to re-center the coordinate system.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\n    // For each fragment, create a ray at a fixed point of origin directed at\n    // the coordinates of each fragment. The last thing before writing the color\n    // to the fragment is to post-process the pixel values using tone-mapping.\n    // In this case, I adjust for exposure and perform linear gamma correction.\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}\n\n// If all goes well, you should see an animated scene below!\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\n\n// This was my first foray into ray tracing. Originally, I wanted to write this\n// using the OpenGL Compute Shader. That was harder to setup than I originally\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\n// before deciding to just sit down and start programming.\n\n// All things considered, this is a pretty limited ray tracer. Some low hanging\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\n// latter involves finding a quality random number generator. Maybe a summer\n// project before I start working ...\n","name":"","description":"","type":"image"}]}