{"ver":"0.1","info":{"id":"XdtBWX","date":"1615813983","viewed":147,"name":"Rubbish Path Tracer","username":"tomkel","description":"path tracing experiments","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 resolution =  iResolution.xy;\n\tvec2 uv = fragCoord.xy / resolution;\n    \n    fragColor = sqrt(texture( iChannel1, uv ) / float(iFrame+1));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 sphere( vec3 spherepos, float r, float d, vec3 raypos )\n{\n    return vec4( distance( spherepos, raypos ) - r,d,0,1.0); \n}\n\nvec4 emissive( vec3 spherepos, float r, vec3 raypos )\n{\n    return vec4( distance( spherepos, raypos ) - r,0.0,10.0,0.0); \n}\n\n\nvec4 box( vec3 position, vec3 lengths, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    \n    float d0 = max( p.x - lengths.x, -p.x - lengths.x );\n    float d1 = max( p.y - lengths.y, -p.y - lengths.y );\n    float d2 = max( p.z - lengths.z, -p.z - lengths.z );\n    return vec4( max( d0, max(d1,d2 )), 1.0,0, 1.0);\n}\n\nvec4 cylinder( vec3 position, vec2 dim, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    return vec4( max( length( p.xz ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y)), 1.0,0,1.0);\n}\n\nvec4 stage( vec3 p, float w, float r )\n{\n\n    float d0 = min( -p.x + 100.0, p.x + 100.0 );\n    float d1 = min( -p.y + 100.0, p.y + 10.0);\n    float d2 = min( -p.z + 100.0, p.z + 100.0);\n    return vec4( min( d0, min(d1,d2 )), 0.0,0, 1.0);\n}\n\nvec4 smin( vec4 o0, vec4 o1 )\n{\n    if ( o0.x < o1.x )\n    { \n        return o0;\n    }\n    \n    return o1;\n}\n\n\nvec3 randomDir(vec3 normal, vec2 offset )\n{\n    vec2 i = float(iTime) * offset;\n  \tvec4 s = texture( iChannel0, i) * vec4(2.0,2.0,1.0,0)  - vec4(1.0,1.0,0.0,0.0);\n   \n    vec3 v = normalize( s.xyz );\n    vec3 t;\n    \n    if ( abs(normal.x) > abs(normal.y))\n    {\n        t = normalize(vec3( normal.z, 0, -normal.x ));\n    }\n    else\n    {\n        t = normalize(vec3( 0, -normal.z, normal.y ));\n    }\n    \n    vec3 b = normalize( cross( t, normal ));\n\n\n    \n    return  v.z * normal + (b * v.y + t * v.x);\n}\n\n\nvec4 sdf( vec3 raypos )\n{\n    return smin( sphere( vec3( 20.0, 15.0, -40), 20.0, 0.0,  raypos ),\n           smin( sphere( vec3( -15, -5, -10), 5.0, 0.0, raypos ),\n           smin( sphere( vec3( 0, 0.0, -20 ), 10.0, 1.0, raypos ),\n           smin( emissive( vec3( 0,30.0,-10), 4.0, raypos ),\n           stage( raypos, -10.0, 10000.0 )\n                   )\n               )\n           )\n    );\n    \n}\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ).x - sdf( raypos - vec3( delta,0,0 ) ).x;\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ).x - sdf( raypos - vec3( 0,delta,0 ) ).x;\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ).x - sdf( raypos - vec3( 0,0,delta ) ).x;\n    return vec3( dx,dy,dz );\n}\n\n\nvec4 getDiffuse( float d )\n{\n   return ((1.0-d) * vec4( 1.0,1.0,1.0,1.0) + d * vec4( 1.0,0.0,0.0,1.0) *d) / 3.1412;\n}\n\nvec4 bounce0(    vec3 ray, \n                 vec3 origin,\n                 float ep)\n{\n    vec3 p = origin + ray * 2.0;\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 sd = sdf(p);\n        float step =sd.x;\n        if ( step  <  ep )\n        {\n           return sd.z * vec4(1.0,1.0,1.0,0);\n        }\n        \n        p += ray * step;\n    } \n    return vec4(0,0,0,1.0);\n   \n}\n\n\nvec4 bounce1( vec3 ray, \n                 vec3 origin,\n                 float ep, vec2 offset )\n{\n    vec3 p = origin + ray * 2.0;\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 sd = sdf(p);\n        float step =sd.x;\n        if ( step  <  ep )\n        {\n            if ( sd.z > 0.0 )\n            {\n                 return sd.z * vec4(1.0,1.0,1.0,0.0);\n            }\n            else\n            {\n           \t\tvec3 normal = normalize( grad( p, 0.1 ) );\n           \t\tvec3 r = randomDir(normal, offset * 13.0);\n           \t\tvec4 ref = bounce0( r, p, 0.1 ); \n           \t\tfloat prb = clamp( dot(r,normal), 0.0,1.0) / (1.0/(2.0 * 3.142));\n           \n           \t\treturn getDiffuse( sd.y ) *  prb * ref ;\n                \n            }\n        }\n        \n        p += ray * step;\n    } \n    return vec4(0,0,0,1.0);\n   \n}\n\n\nvec4 march( vec3 ray, vec3 origin, float ep, vec2 offset )\n{\n    vec3 p = origin;\n    vec3 eye = normalize( ray );\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 step = sdf(p);\n        if ( step.x  <  ep )\n        {\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            vec3 r = randomDir(normal,offset);\n            vec4 ref = bounce1( r, p, 0.1, offset ); \n             float prb = clamp( dot(r,normal), 0.0,1.0) / (1.0/(2.0 * 3.142));\n            return getDiffuse( step.y ) * ref *  prb;\n           \n        }\n        \n        p += ray * step.x;\n    }\n    \n    return vec4(0.0,0,0,1);\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution =  iResolution.xy;\n\tvec2 uv = fragCoord.xy / resolution;\n    \n    float aspect = resolution.y / resolution.x;\n    \n    vec3 origin = vec3(7.0, 2, -20.0) ;// + iMouse.y / resolution.y * 100.0);\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n\n    \n    ray = rotatevecY( ray, 16.0); //iMouse.x / resolution.x * 8.0 );\n    origin = rotatevecY( origin,  16.0 ); //iMouse.x / resolution.x * 8.0  );\n\n    \n   vec4 last = texture(iChannel1, uv );\n    \n\tfragColor = march( ray, origin, 0.25, uv) + last;\n}","name":"Buffer A","description":"","type":"buffer"}]}