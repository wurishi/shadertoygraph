{"ver":"0.1","info":{"id":"MXSSzt","date":"1713290458","viewed":93,"name":"Stencil Numbers","username":"jbsiraudin","description":"Yet another font numbers shader, based on the Scelet AF font https://aurekfonts.github.io/?font=SceletAF","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","numbers","font","digits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jean-Baptiste Siraudin @2024\n// Yet another font numbers library\n// Based on the Scelet AF font https://aurekfonts.github.io/?font=SceletAF\n\n// Various code pieces come from iq's 2D sdf library, aka the Bible:\n// https://iquilezles.org/articles/distfunctions2d\n\n// ----------------------------\n// ---------SDF SHAPES---------\n// ----------------------------\n\n// CIRCLE - CARTESIAN COORDINATES\n// Can be centered anywhere on the screen\n// p (coord of the point), center (coord of the center of the circle), r (desired radius of the circle)\nfloat sdCircle(in vec2 p, in vec2 center, in float r)\n{\n    return length(p-center)-r;\n}\n\n// SEGMENT - CARTESIAN COORDINATES\n// Segment defined by two point\n// p (coord of the point), a & b (the two points defining the segment)\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\n// ARC - CARTESIAN COORDINATES\nfloat sdArc( in vec2 p, in float angle, in float ra, in float rb)\n{\n    // sc is the sin/cos of the arc's aperture\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n\n// ----------------------------\n// ---------SDF NUMBERS--------\n// ----------------------------\n\nfloat n0(in vec2 p, in float scale, in float w)\n{\n    float angle = degToRad*mix(80., 85., scale);\n    float a = sdArc(vec2(p.x, abs(p.y)), angle, scale, w*scale*sW);\n    return fill(a);\n}\n\nfloat n1(in vec2 p, in float scale, in float w)\n{\n    float a = sdSegment(p, scale*vec2(0.15, 1.), scale*vec2(0.15, -1.));\n    float b = sdSegment(p, scale*vec2(0.15, 1.), scale*vec2(-0.25, 0.6));\n    return stroke(union(a, b), w*scale);\n}\n\nfloat n2(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*45.;\n    float angle2 = degToRad*135./2.;\n    \n    float r = 0.55;\n    vec2 p1 = r*sc(PI/2.-2.*angle2);\n    \n    float a = sdArc(rotate((p - scale*vec2(0., 1.-r)), -angle - varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p - scale*vec2(0., 1.-r)), angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    float c = sdSegment(p, scale*(vec2(-r,-1.)+mix(0.3, 0.2, scale)*vec2(1.)), scale*(p1+vec2(0., 1.-r)));\n    float d = sdSegment(p, scale*vec2(-r, -1.), scale*vec2(r, -1.));\n    \n    float sd = union(a, union(b, abs(c)-w*scale*sW));\n    \n    return fill(sd)+stroke(d, w*scale); \n}\n\nfloat n3(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*90.;\n    float angle2 = degToRad*45.;\n    \n    float r = 0.5;\n    vec2 p_ = vec2(p.x, abs(p.y)) - scale*vec2(0., 1.-r);\n    \n    float a = sdArc(rotate(p_, -varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate(p_, 3.*angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    return fill(union(a, b));\n}\n\nfloat n4(in vec2 p, in float scale, in float w)\n{\n    float r = 0.65;\n    float r2 = 0.4;\n    vec2 p1 = scale*vec2(-r, -0.5);\n    float a = sdSegment(p, p1, vec2(abs(p1.x), p1.y));\n    float b = sdSegment(p, p1 + scale*mix(0.3, 0.2, scale)*vec2(1.), scale*vec2(r2, 0.9));\n    float c = sdSegment(p, scale*vec2(r2, -1.), scale*vec2(r2, 0.9 - mix(0.5, 0.35, scale)));\n    \n    return stroke(union(b, union(a, c)), w*scale);\n}\n\nfloat n5(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*36.;\n    float angle2 = degToRad*225./2.;\n    \n    float r = 0.65;\n    float r2 = 0.35;\n    vec2 p1 = -vec2(0., 1.-r) + r*sc(degToRad*135.);\n    vec2 p2 = vec2(-r2, 1.);\n    \n    float a = sdArc(rotate((p + scale*vec2(0., 1.-r)), -degToRad*145. + varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p + scale*vec2(0., 1.-r)), angle2 - degToRad*45. - varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    float c = sdSegment(p, scale*p1, scale*p1 + scale*(p2-p1)*mix(0.6, 0.75, scale));\n    float d = sdSegment(p, scale*p2, scale*mirror(p2));\n    \n    float sd = union(a, union(b, abs(c)-w*scale*sW));\n    \n    return fill(sd)+stroke(d, w*scale);\n}\n\n\nfloat n6(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*90.;\n    float angle2 = degToRad*60.;\n    \n    float r = 0.65;\n    vec2 p1 = -vec2(0., 1.-r) + r*sc(degToRad*150.);\n    \n    float a = sdArc(rotate((p + scale*vec2(0., 1.-r)), degToRad*90. - varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p + scale*vec2(0., 1.-r)), degToRad*180. + angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    float c = sdSegment(p, scale*p1, scale*(p1+1.22*sc(degToRad*60.)));\n    \n    float sd = union(b, abs(c)-w*scale*sW);\n    \n    return fill(a) + fill(sd);\n}\n\nfloat n7(in vec2 p, in float scale, in float w)\n{\n    float r = 0.6;\n    float r2 = 0.45;\n    vec2 p1 = scale*vec2(-r, 1.);\n    \n    float a = sdSegment(p, scale*vec2(-r, 1.), scale*vec2(r, 1.));\n    float b = sdSegment(p, scale*vec2(-r2, -1.), scale*vec2(r2, 0.9 - mix(0.3, 0.2, scale)));\n    \n    return stroke(union(b, a), w*scale);\n}\n\nfloat n8(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(20., 10., scale);\n    float angle = degToRad*180.;\n    \n    float r = 0.5;\n    vec2 p_ = vec2(p.x, abs(p.y)) - scale*vec2(0., 1.-r);\n    float a = sdArc(rotate(p_, angle), angle - varAngle, r*scale, w*scale*sW);\n    \n    return fill(a);\n}\n\nfloat n9(in vec2 p, in float scale, in float w)\n{\n    return n6(-p, scale, w);\n}\n\nfloat digit(in vec2 p, in int n, in float scale, in float w)\n{\n    //for debugging spacing\n    //float r = stroke(sdCircle(p, vec2(0.), scale), 2.);\n    float r=0.;\n    if(n == 0)\n\t{\n\t\treturn r+n0(p, scale, w);\n\t}\n\tif(n == 1)\n\t{\n\t\treturn r+n1(p, scale, w);\n\t}\n\tif(n == 2)\n\t{\n\t\treturn r+n2(p, scale, w);\n\t}\n\tif(n == 3)\n\t{\n\t\treturn r+n3(p, scale, w);\n\t}\n\tif(n == 4)\n\t{\n\t\treturn r+n4(p, scale, w);\n\t}\n\tif(n == 5)\n\t{\n\t\treturn r+n5(p, scale, w);\n\t}\n\tif(n == 6)\n\t{\n\t\treturn r+n6(p, scale, w);\n\t}\n\tif(n == 7)\n\t{\n\t\treturn r+n7(p, scale, w);\n\t}\n\tif(n == 8)\n\t{\n\t\treturn r+n8(p, scale, w);\n\t}\n\tif(n == 9)\n\t{\n\t\treturn r+n9(p, scale, w);\n\t}\n\n\treturn 0.;\n}\n\n//Length of a number in digits from https://www.shadertoy.com/view/4dc3zr\nint numberLength(float n)\n{\n\treturn int(ceil(max(log(n) / log(10.), 0.)));\n}\n\nfloat number(in vec2 p, in float n, in int minChar, in float scale, in float w)\n{\n    float r = 0.;\n\tint l = numberLength(n);\n    float it = pow(10., -float(minChar));\n    \n\tfor(int i = minChar; i >= 0; i--)\n\t{\n\t\tint d = int(floor(mod(n * it,10.)));\n\t\t\n        if (i >= l)\n        {\n            d = 0;\n        }\n        \n        \n        if(n > it || i == 0 || i >= l)\n\t\t{\n            vec2 pos = p - 2.3*scale*vec2(minChar-i,0);\n\t\t\tr += digit(pos, d, scale, w);\n\t\t}\n        \n        it *= 10.;\n\t}\n    \n    return r;\n}\n\nfloat offsetByDigit(in int n)\n{\n    if(n == 0)\n    {\n        return 1.2;\n    }\n    if (n == 1)\n    {\n        return 0.4;\n    }\n    \n    return 0.8;\n}\n\n// attempt at improved and adaptative spacing\nfloat numberAlt(in vec2 p, in float n, in int minChar, in float scale, in float w)\n{\n    float r = 0.;\n\tint l = numberLength(n);\n    float offset = -1.*scale;\n    float it = pow(10., -float(minChar));\n    \n\tfor(int i = minChar;i >= 0;i--)\n\t{\n\t\tint d = int(floor(mod(n * it,10.)));\n        \n        if (i >= l)\n        {\n            d = 0;\n        }\n        \n        if(n > it || i == 0 || i >= l)\n\t\t{\n\t\t\toffset += offsetByDigit(d)*scale;\n            r += digit(p - offset*vec2(1.,0.), d, scale, w);\n            offset += offsetByDigit(d)*scale;\n\t\t}\n        \n        it *= 10.;\n\t}\n    \n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        \n    float scale = 0.1;\n    float w = .03*iResolution.x;\n    float a = 0.;\n    \n\t// Scene 1\n    for(int i = 0;i <= 9;i++)\n\t{\n        a += digit(p + vec2(1. - 2.*scale*float(i), -0.5), i, scale, w);\n    }\n    \n    a += number(p + vec2(1., 0.), iTime*100., 8, scale, w);\n    a += numberAlt(p + vec2(1., 0.5), iTime*100., 8, scale, w);\n    \n    a = clamp(a, 0., 1.);\n\tvec3 col = mix(vec3(grey*grey), vec3(0.), a);\n\tfragColor = vec4(sqrt(col), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 240/255 = the grey of the player bar in shadertoy\nconst float grey = 0.94117647058;\n\n// ----------------------------\n// SOME CONSTANTS AND MACROS\n// ----------------------------\n// Some classics:\n#define degToRad 0.01745\n#define PI 3.14159265359\n\n// Base value for Stroke Width\n#define sW 1.0/iResolution.x\n\n// pixelWidth, used for antialiasing drawing\n#define pW 1.0/iResolution.y\n\n// -- Antialiased drawing functions --\n// Takes an sdf and fill it or trace a stroke on it\n// N weights the \"blur\" on the edges = it's our antialiasing technique here\n// N may vary according to what looks best for each sdf! (but it's mostly 4.)\n#define N 4.\n#define fill(sdf) smoothstep(N*pW, 0., sdf)\n#define stroke(sdf, e) smoothstep(N*pW, 0., abs(sdf)-e*sW)\n\n#define union(sdf1, sdf2) min(sdf1, sdf2)\n\n// -- Coordinates manipulation --\n#define mirror(p) vec2(abs(p.x), p.y)\n\n#define rotate(p, t) vec2(cos(t)*p.x-sin(t)*p.y, sin(t)*p.x+cos(t)*p.y)\n#define sc(x) vec2(cos(x), sin(x))\n\n","name":"Common","description":"","type":"common"}]}