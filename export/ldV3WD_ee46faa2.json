{"ver":"0.1","info":{"id":"ldV3WD","date":"1454609387","viewed":198,"name":"Julia Sets Along the Cardioid","username":"jessec","description":"Rudimentary as all hell, but an interesting animation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Jesse Connell - 2016\n// - with some suggestions by Fabrice NEYRET\n// - using logging/debugging tool from cyangreen here: https://www.shadertoy.com/view/3dyyRh\n\n#define CS(a) vec2(cos(a), sin(a))\nconst float ESCAPE = 250.;\nconst float BAILOUT = 4.;\nconst int SMOOTH_ITERS = 8;\nconst bool SMOOTH = false;\nconst float SMOOTH_C0 = pow(2., float(SMOOTH_ITERS+1));\nconst float SMOOTH_C1 = 6.*pow(2., float(SMOOTH_ITERS));\n\n#define R iResolution.xy\n\nvec2 cardioid(float t) {\n\treturn CS(t)/2. - CS(t+t)/4.; \n}\n\nvec2 julia_coord()\n{\n    return cardioid(iTime * 2.2)*0.93;\n}\n\n\nvec2 normXY(vec2 xy) { return 2.4*(xy - R*.5)/min(R.x, R.y); }\n\nvoid julia(inout vec2 z, out float i, in vec2 c) {\n    for(i = 0.; i < ESCAPE; i += 1.)\n    {\n        if (length(z) > BAILOUT)\n        {\n            break;\n        }\n        vec2 zz = z*z;\n        z = mat2(z, -z.y, z.x)*z + c;\n    }\n\n    if (i > 0.)\n    {\n        // length(z) now in (2,6)\n        //\n        // Iterate the function N times and this will now be between\n        // 2^(N+1) and (6*2^N), so you can take result's length,\n        // subtract 2^(N+1), and divide by (6*2^N) to get value in\n        // (0,1) I think?\n        for (int k = 0; k < SMOOTH_ITERS; ++k)\n        {\n            z = mat2(z, -z.y, z.x)*z + c;\n        }\n        float zadj = (length(z) - SMOOTH_C0)/SMOOTH_C1;\n        //i += zadj;\n    }\n}\n\n\n#if 0\nvec3 getColor(in vec2 z, in float i)\n{\n    \n    col = mix(col RED, \n    vec3 rgb = 0.5-cos(m*0.25*iTime*sqrt(vec3(0.1,0.1,0.15)))*0.5;\n\treturn vec4(rgb,0.2);\n}\n#endif\n\nvoid do_julia(out vec2 z, out float i, in vec2 xy, in vec2 c)\n{\n    julia(xy, i, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = julia_coord();\n    float i;\n    vec2 z = normXY(fragCoord);\n\n    do_julia(z, i, z, c);\n    \n    fragColor = getColor(z, i);\n\n//    fragColor = mix(fragColor, GREEN, printNumber(fragCoord, 1.0));\n        \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// From: https://www.shadertoy.com/view/3dyyRh\n\n\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n\n\nfloat printNumber(vec2 fragCoord, float number) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -4; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) a[c++] = 10; // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}","name":"Common","description":"","type":"common"}]}