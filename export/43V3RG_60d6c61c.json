{"ver":"0.1","info":{"id":"43V3RG","date":"1717822863","viewed":53,"name":"Pink Panther Cell Division","username":"plasmo310","description":"I made an animation using the Julia set.\nMy friend said it looked like the 'cell division of the Pink Panther', so I added eyes.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","julia","simulation","mandelbrot","juliaset","fractals","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // color settings\n    vec3 colBlack = vec3(0.0);\n    vec3 colYellow = vec3(0.867, 0.910, 0.247);\n    vec3 colPink = vec3(0.95, 0.55, 0.65);\n\n    // uv position (0.0~1.0)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // background color\n    vec3 ret = vec3(1.0, 0.3, 0.8) - vec3(0.35, 0.2, 0.0) * cos(5.0*iTime+uv.xyx);\n    \n    // get julia draw parameter\n    JuliaParameter parameter = getJuliaParameter(iFrame, iTime);\n    \n    // grid position (-maxGridX~maxGridX)\n    float maxGridX = parameter.maxGridX;\n    float maxGridY = maxGridX*(iResolution.y/iResolution.x);\n    float gridPosX = mix(-maxGridX, maxGridX, uv.x);\n    float gridPosY = mix(-maxGridY, maxGridY, uv.y);\n    \n    // draw julia\n    vec2 z = vec2(gridPosX, gridPosY);\n    vec2 c = parameter.constComplex;\n    ret = mix(ret, colBlack, 1.0 - checkJulia(z, c));\n    \n    // draw panther eyes\n    float eyeAlpha = parameter.eyeAlpha;\n    if (eyeAlpha > 0.0)\n    {\n        vec2 r = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float eyeRadius = 0.1;\n        float innerEysRadius = eyeRadius*0.35;\n        vec2 eyeRightCenter = parameter.eyeRightCenter;\n        vec2 eyeLeftCenter = parameter.eyeLeftCenter;\n\n        ret = mix(ret, colYellow, eyeAlpha*circle2d(r, eyeRadius, eyeRightCenter));\n        ret = mix(ret, colYellow, eyeAlpha*circle2d(r, eyeRadius, eyeLeftCenter));\n        ret = mix(ret, colBlack, eyeAlpha*circle2d(r, innerEysRadius, eyeRightCenter+vec2(0.0, -0.02)));\n        ret = mix(ret, colBlack, eyeAlpha*circle2d(r, innerEysRadius, eyeLeftCenter+vec2(0.0, -0.02)));\n\n        float angleL = -0.26;\n        float angleR = 0.26;\n        mat2 rotL = mat2(cos(angleL), -sin(angleL), sin(angleL), cos(angleL));\n        mat2 rotR = mat2(cos(angleR), -sin(angleR), sin(angleR), cos(angleR));\n        ret = mix(ret, colPink, eyeAlpha*halfTopCircle2d(rotR*(r-eyeRightCenter), eyeRadius, vec2(0.0)));\n        ret = mix(ret, colPink, eyeAlpha*halfTopCircle2d(rotL*(r-eyeLeftCenter), eyeRadius, vec2(0.0)));\n    }\n\n    // output to screen\n    fragColor = vec4(ret, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n// ease functions\nfloat easeOutQuart(float x)\n{\n    return 1.0 - pow(1.0-x, 4.0);\n}\nfloat easeOutCubic(float x)\n{\n    return 1.0 - pow(1.0-x, 3.0);\n}\n\n// draw circle2d (0.0 ~ 1.0)\nfloat circle2d(vec2 r, float radius, vec2 center)\n{\n    float blur = 0.005;\n    return 1.0 - smoothstep(radius-blur, radius+blur, length(r-center));\n}\nfloat halfTopCircle2d(vec2 r, float radius, vec2 center)\n{\n    if ((r-center).y < 0.0) {\n        return 0.0;\n    }\n    return circle2d(r, radius, center);\n}\n\n// complex functions\nvec2 addComplex(vec2 z0, vec2 z1)\n{\n    return vec2(z0.x+z1.x, z0.y+z1.y);\n}\nvec2 mulComplex(vec2 z0, vec2 z1)\n{\n    return vec2(z0.x*z1.x - z0.y*z1.y, z0.x*z1.y + z0.y*z1.x);\n}\nfloat sqlMagnitude(vec2 z)\n{\n    return z.x*z.x + z.y*z.y;\n}\n\n// check julia function\nfloat checkJulia(vec2 z, vec2 c)\n{\n    float count = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        z = addComplex(mulComplex(z, z), c);\n        if (sqlMagnitude(z) > 10.0)\n        {\n            return easeOutCubic(count/25.0); // convergence level\n        }\n        count+=1.0;\n    }\n    return 1.0;\n}\n\n// julia type\nconst int JULIA_TYPE_SPIRAL = 0;\nconst int JULIA_TYPE_LOOP = 1;\n\n// julia settings\nstruct JuliaSettings\n{\n    int type;\n    float maxGridX;\n    float speed;\n    float minRe;\n    float minIm;\n    float maxRe;\n    float maxIm;\n    float eyeRotLength;\n};\n\nconst int JULIA_SETTINGS_LENGTH = 6;\nconst JuliaSettings[JULIA_SETTINGS_LENGTH] JULIA_SETTINGS = JuliaSettings[]\n(\n    JuliaSettings(JULIA_TYPE_SPIRAL, 5.0, 3.5, 0.05,  0.05,  0.05,  0.05, 0.0),\n    JuliaSettings(JULIA_TYPE_SPIRAL, 2.0, 2.0, 0.7,   0.7,   0.7,   0.7,  0.65),\n    JuliaSettings(JULIA_TYPE_LOOP,   2.5, 3.5, 0.32,  0.25,  0.28, -0.25, 0.0),\n    JuliaSettings(JULIA_TYPE_SPIRAL, 2.0, 4.5, 0.35, -0.35,  0.5,   0.5,  0.6),\n    JuliaSettings(JULIA_TYPE_SPIRAL, 2.2, 5.0, 0.5,   0.5,   0.65,  0.65, 0.7),\n    JuliaSettings(JULIA_TYPE_LOOP,   3.0, 4.0, 0.1,  -0.15,  0.28,  0.25, 0.0)\n);\n\nconst int LOOP_FRAME = 300;\nconst float CHANGE_FADE_TIME = 0.35;\n\n// julia parameter\nstruct JuliaParameter\n{\n    float maxGridX;\n    vec2 constComplex;\n    \n    // panther eyes\n    float eyeAlpha;\n    vec2 eyeLeftCenter;\n    vec2 eyeRightCenter;\n};\n\n// get eye center position\nvec2 getEyeCenter(int frame, float time, float radian, float rotLength, bool isReverse)\n{\n    // rotate eye position\n    if (rotLength > 0.0)\n    {\n        float eyeRadian = radian > 0.0 ? radian+0.4*PI : radian-0.4*PI;\n        vec2 eyeCenter = rotLength * vec2(cos(eyeRadian), sin(eyeRadian));\n        if (isReverse)\n        {\n            eyeCenter *= -1.0;\n        }\n        return eyeCenter;\n    }\n    \n    // standard position\n    vec2 faceCenter = vec2(0.0, 0.1 * (sin(2.0*time) + 1.0) / 2.0);\n    vec2 eyeCenter = faceCenter + vec2(-0.17, 0.03);\n    if (isReverse)\n    {\n        eyeCenter *= vec2(-1.0, 1.0);\n    }\n    return eyeCenter;\n}\n\n// get julia draw parameter by frame info\nJuliaParameter getJuliaParameter(int frame, float time)\n{\n    int currentIndex = int(frame/LOOP_FRAME) % JULIA_SETTINGS_LENGTH;\n    int prevIndex = abs((currentIndex-1) % JULIA_SETTINGS_LENGTH);\n    JuliaSettings currentSettings = JULIA_SETTINGS[currentIndex];\n    JuliaSettings prevSettings = JULIA_SETTINGS[prevIndex];\n    \n    // fade mix ratio\n    float progress = mod(float(frame), float(LOOP_FRAME))/float(LOOP_FRAME);\n    float mixRatio = smoothstep(0.0, CHANGE_FADE_TIME, progress);\n    mixRatio = easeOutQuart(mixRatio);\n    \n    // radian\n    float prevRadian = sin(prevSettings.speed*time)*2.0*PI;\n    float currentRadian = sin(currentSettings.speed*time)*2.0*PI;\n    float radian = mix(prevRadian, currentRadian, mixRatio);\n    \n    // re, im range\n    float minRe = mix(prevSettings.minRe, currentSettings.minRe, mixRatio);\n    float minIm = mix(prevSettings.minIm, currentSettings.minIm, mixRatio);\n    float maxRe = mix(prevSettings.maxRe, currentSettings.maxRe, mixRatio);\n    float maxIm = mix(prevSettings.maxIm, currentSettings.maxIm, mixRatio);\n    \n    // calculate const complex by julia type\n    vec2 constComplex = vec2(0.0);\n    int juliaType = currentSettings.type;\n    if (juliaType == JULIA_TYPE_SPIRAL)\n    {\n        float cosRatio = cos(radian);\n        float sinRatio = sin(radian);\n        constComplex = vec2(\n            mix(minRe, maxRe, abs(cosRatio))*cosRatio, \n            mix(minIm, maxIm, abs(sinRatio))*sinRatio\n        );\n    }\n    else if (juliaType == JULIA_TYPE_LOOP)\n    {\n        float ratio = (sin(radian/2.0) + 1.0) * 0.5;\n        constComplex = vec2(\n            mix(minRe, maxRe, abs(ratio)),\n            mix(minIm, maxIm, abs(ratio))\n        );\n    }\n    \n    // calculate eye position\n    float eyeAlpha = smoothstep(60.0, 240.0, float(frame));\n    vec2 prevEyeRightCenter = getEyeCenter(frame, time, radian, prevSettings.eyeRotLength, false);\n    vec2 prevEyeLeftCenter = getEyeCenter(frame, time, radian, prevSettings.eyeRotLength, true);\n    vec2 currentEyeRightCenter = getEyeCenter(frame, time, radian, currentSettings.eyeRotLength, false);\n    vec2 currentEyeLeftCenter = getEyeCenter(frame, time, radian, currentSettings.eyeRotLength, true);\n    vec2 eyeRightCenter = mix(prevEyeRightCenter, currentEyeRightCenter, mixRatio);\n    vec2 eyeLeftCenter = mix(prevEyeLeftCenter, currentEyeLeftCenter, mixRatio);\n    \n    float maxGridX = mix(prevSettings.maxGridX, currentSettings.maxGridX, mixRatio);\n    return JuliaParameter(\n        maxGridX,\n        constComplex,\n        eyeAlpha,\n        eyeLeftCenter,\n        eyeRightCenter\n    );\n}\n","name":"Common","description":"","type":"common"}]}