{"ver":"0.1","info":{"id":"X3XGzf","date":"1707743055","viewed":233,"name":"Atmosphere with Sky-View LUT","username":"LaoBro","description":"This is the actual camera view of https://www.shadertoy.com/view/l3XGR8","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["sky","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 SimpleCamera(vec2 uv, float UpAngle, float z)\n{   \n    float ForwardAngle = UpAngle + pi / 2.0;\n    vec3 Up = vec3(0.0, cos(UpAngle), sin(UpAngle));\n    vec3 Forward = vec3(0.0, cos(ForwardAngle), sin(ForwardAngle));\n    vec3 Right = vec3(1.0, 0.0, 0.0);\n    vec2 xy = uv - 0.5;\n    xy.x *= iResolution.x;\n    xy.y *= iResolution.y;\n    return normalize(Right * xy.x + Up * xy.y +  Forward * z);\n}\n\nvec3 TransmittanceFromTexture(float radius, float angle) {\n    vec2 uv = muR2uv(angle, radius, iResolution.xy);\n    return texture(iChannel1, uv).xyz;\n}\n\nvec3 SampleSkyViewLut(vec3 RayDirection)\n{\n    float ViewRadius = length(ViewPosition);\n    float Vhorizon = sqrt(ViewRadius * ViewRadius - BottomRadius2);\n\tfloat CosBeta = Vhorizon / ViewRadius;\t\t\t\t// GroundToHorizonCos\n\tfloat Beta = acos(CosBeta);\n\tfloat ZenithHorizonAngle = pi - Beta;\n    \n    vec3 SunDirection = GetSunDirection(iTime);\n    vec3 Up = ViewPosition / ViewRadius;\n    vec3 Right = cross(SunDirection, Up);\n    vec3 Forward = cross(Up, Right);\n\n    float CosRayUp = dot(RayDirection, Up);\n    float RayUpRadian = acos(CosRayUp);\n\n    float u, v;\n\n    if (RayUpRadian > ZenithHorizonAngle) //ground\n    {\n        v = RayUpRadian - ZenithHorizonAngle;\n        v /= Beta;\n        v = sqrt(v);\n        v = 0.5 - v * 0.5;\n\n    }\n    else // sky\n    {\n        v = RayUpRadian;\n        v /= ZenithHorizonAngle;\n        v = 1.0 - v;\n        v = sqrt(v);\n        v = 0.5 + v * 0.5;\n    }\n\n    float CosRayForward = dot(RayDirection, Forward);\n    float CosRayRight = dot(RayDirection, Right);\n    float RayForwardRadian = acos(CosRayForward / sqrt(CosRayRight * CosRayRight + CosRayForward * CosRayForward));\n\n    u = RayForwardRadian/ pi;\n\n    vec3 Color = texture(iChannel0, vec2(u, v)).xyz;\n\n    float CosRaySun = dot(RayDirection, SunDirection);\n    float CosSunUp = dot(SunDirection, Up);\n    \n    //Simple sun\n    if (CosRaySun > SunCosAngle && RayUpRadian < ZenithHorizonAngle)\n    {\n        Color += TransmittanceFromTexture(ViewRadius, CosSunUp) * sunIntensity;\n    }\n\n\n    return Color;\n\n}\n\n//ACES approximation\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) \n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 RayDirection = SimpleCamera(uv, -0.2, 600.0);\n    vec3 Color = SampleSkyViewLut(RayDirection);\n\n    Color = Color * ACESInputMat;    \n    Color = RRTAndODTFit(Color);    \n    Color = Color * ACESOutputMat;\n    Color = pow(Color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(Color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.141592;\n// Use Megametre as units, so scattering and absorption Coefficient are 10^6 time larger than actual\nconst float BottomRadius = 6.360;\nconst float AtmosphereThickness = 0.1;\nconst float TopRadius = BottomRadius + AtmosphereThickness;\nconst float BottomRadius2 = BottomRadius * BottomRadius;\nconst float TopRadius2 = TopRadius * TopRadius;\nconst float H = sqrt(TopRadius2 - BottomRadius2);\nconst float rayleighScaleHeight = 8.5e-3;\nconst float mieScaleHeight = 1.2e-3;\nconst vec3 rayleighScatteringCoefficient = vec3(5.8, 13.5, 33.1) * 1.0;\nconst float mieScatteringCoefficient = 3.996 * 5.0;\nconst float mieAbsorptionCoefficient = 4.440 * 1.0;\nconst float mieExtinctionCoefficient = mieScatteringCoefficient + mieAbsorptionCoefficient;\nconst float ozoneCenter = 2.5e-2;\nconst float ozoneWidth = 2.5e-2;\nconst vec3 ozoneAbsorptionCoefficient = vec3(0.650, 1.881, 0.085) * 2.0;\nconst vec3 earthAlbedo = vec3(0.3);\nconst float SunCosAngle = 0.99995;\nconst float sunIntensity = 16.0;\nconst vec3 ViewPosition = vec3(0.0, BottomRadius + 0.4e-3, 0.0);\n\nvec3 GetSunDirection(float iTime){\n    float Suny = (cos(iTime * 0.2 + 2.1) + 0.8) * 0.3;\n    float Sunz = sqrt(1.0 - Suny * Suny);\n    return vec3(0.0, Suny, Sunz);\n}\n\nbool IntersectCircle(float ViewRadius, float CosAngle, out float StartDistance, out float EndDistance) {\n    float Offset = -ViewRadius * CosAngle;\n    float ViewRadius2 = ViewRadius * ViewRadius;\n    float Ray2Center2 = ViewRadius2 - Offset * Offset;\n    if (Ray2Center2 > TopRadius2) {\n        return false;\n    }\n    float TopHalfLength = sqrt(TopRadius2 - Ray2Center2);\n    EndDistance = TopHalfLength + Offset;\n    StartDistance = max(0.0, Offset - TopHalfLength);\n    return true;\n}\n\nvoid IntersectCircleInside(float ViewRadius, float CosAngle, out float TriangleHeight2, out float StartWidth, out float EndWidth) {\n    StartWidth = ViewRadius * CosAngle;\n    float ViewRadius2 = ViewRadius * ViewRadius;\n    TriangleHeight2 = ViewRadius2 - StartWidth * StartWidth;\n    EndWidth = sqrt(TopRadius2 - TriangleHeight2);\n}\n\nvoid IntersectDoubleCircle(float ViewRadius, float CosAngle, out float StartDistance, out float EndDistance) {\n    float Offset = -ViewRadius * CosAngle;\n    float ViewRadius2 = ViewRadius * ViewRadius;\n    float Ray2Center2 = ViewRadius2 - Offset * Offset;\n    float BottomHalfLength = sqrt(BottomRadius2 - Ray2Center2);\n    float TopHalfLength = sqrt(TopRadius2 - Ray2Center2);\n    StartDistance = max(0.0, Offset - TopHalfLength);\n    EndDistance = Offset - BottomHalfLength;\n}\n\nbool IntersectDoubleCircleInside(float ViewRadius, float CosAngle, out float EndDistance) {\n    float Offset = -ViewRadius * CosAngle;\n    float ViewRadius2 = ViewRadius * ViewRadius;\n    float Ray2Center2 = ViewRadius2 - Offset * Offset;\n    if (Ray2Center2 < BottomRadius2 && CosAngle < 0.0) {\n        float BottomHalfLength = sqrt(BottomRadius2 - Ray2Center2);\n        EndDistance = Offset - BottomHalfLength;\n        return true;\n    }\n    else {\n        float TopHalfLength = sqrt(TopRadius2 - Ray2Center2);\n        EndDistance = TopHalfLength + Offset; \n        return false;\n    }\n}\n\nvec3 GetDensity(float height) {\n    return vec3(exp(-height / vec2(rayleighScaleHeight, mieScaleHeight)), 1.0 - min(abs(height - ozoneCenter) / ozoneWidth, 1.0));\n}\n\nvec3 Density2Extinction(vec3 Density) {\n    return rayleighScatteringCoefficient * Density.x + mieExtinctionCoefficient * (Density.y + 0.0) + ozoneAbsorptionCoefficient * Density.z;\n}\n\nvec3 Extinction2Transmittance(vec3 Extinction, float SegmentLength) {\n    return exp(-Extinction * SegmentLength);\n}\n\nfloat distToExitAtmosphere(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + TopRadius2;\n    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat unitRange2texCoord(float x, float tex_size) {\n    return .5 / tex_size + x * (1. - 1. / tex_size);\n}\n\nfloat texCoord2unitRange(float u, float resolution) { \n    return (u - 0.5f / resolution) * (resolution / (resolution - 1.0f)); \n}\n\nvoid uv2muR(vec2 uv, out float mu, out float r, vec2 tex_size) {\n    float x_mu  = texCoord2unitRange(uv.x, tex_size.x);\n    float x_r   = texCoord2unitRange(uv.y, tex_size.y);\n    float rho = H * x_r;\n    r = sqrt(rho * rho + BottomRadius2);\n    float d_min = TopRadius - r;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    mu = d == 0.0 ? 1. : (H * H - rho * rho - d * d) / (2. * r * d);\n    mu = clamp(mu, -1., 1.);\n}\n\nvec2 muR2uv(float mu, float r, vec2 tex_size) {\n    float rho   = sqrt(r * r - BottomRadius2);\n    float d     = distToExitAtmosphere(mu, r);\n    float d_min = TopRadius - r;\n    float d_max = rho + H;\n    float x_mu  = (d - d_min) / (d_max - d_min);\n    float x_r   = rho / H;\n        \n    return vec2(\n        unitRange2texCoord(x_mu, tex_size.x),\n        unitRange2texCoord(x_r, tex_size.y)\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int SampleCount = 32;\n\nvec3 ComputeTransmittanceLut(float mu, float r) {\n    float TriangleHeight2, StartWidth, EndWidth;\n    IntersectCircleInside(r, mu, TriangleHeight2, StartWidth, EndWidth);\n    float SampleLength = (EndWidth - StartWidth) / float(SampleCount);\n\tfloat TriangleWidth = StartWidth + SampleLength * 0.5;\n    vec3 TotalDensity = vec3(0.0);\n\tfor (int i = 0; i < SampleCount; i++) {\n        float SampleRadius = sqrt(TriangleHeight2 + TriangleWidth * TriangleWidth);\n        float SampleHeight = SampleRadius - BottomRadius;\n        TotalDensity += GetDensity(SampleHeight);\n        TriangleWidth += SampleLength;\n    }\n    vec3 TotalExtinction = Density2Extinction(TotalDensity);\n    return Extinction2Transmittance(TotalExtinction, SampleLength);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 1) {\n       \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    float mu, r;\n    uv2muR(uv, mu, r, iResolution.xy);\n    fragColor = vec4(ComputeTransmittanceLut(mu, r), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int SqrtRayCount = 8;\nconst int RayCount = SqrtRayCount * SqrtRayCount;\nconst int SampleCount = 32;\n\nvec3 TransmittanceFromTexture(float radius, float angle) {\n    vec2 uv = muR2uv(angle, radius, iResolution.xy);\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 ComputeMultipleScatteringLut(float CosSunUp, float ViewRadius) {\n    vec3 RayOrigin = vec3(0.0, ViewRadius, 0.0);\n    vec3 SunDirection = vec3(sqrt(1.0 - CosSunUp * CosSunUp), CosSunUp, 0.0);\n    vec3 Luminance = vec3(0.0);\n    vec3 TransferFactor = vec3(0.0);\n    float UniformPhase = 1.0 / (4.0 * pi);\n    for (int i = 0; i < RayCount; i++) {\n\n        float z = (float(i) + 0.5) / float(RayCount);\n        float xyLength = sqrt(1.0 - z * z);\n        float Longitude = z * float(SqrtRayCount) * pi * 2.0;\n        vec3 RayDirection = vec3(sin(Longitude) * xyLength, cos(Longitude) * xyLength, z);\n\n        float EndDistance, SampleCosSunUp;\n        bool HitGround = IntersectDoubleCircleInside(ViewRadius, RayDirection.y, EndDistance);\n        float SampleLength = EndDistance / float(SampleCount);\n        float CurrentDistance = SampleLength * 0.5;\n        vec3 RayLight, RayLightTransferFactor, SunTransmittance, SampleUp = vec3(0.0);\n        vec3 ViewTransmittance = vec3(1.0);\n        for (int j = 0; j < SampleCount; j++) {\n            vec3 SamplePosition = RayOrigin + CurrentDistance * RayDirection;\n            float SampleRadius = length(SamplePosition);\n            float SampleHeight = SampleRadius - BottomRadius;\n            vec3 SampleDensity = GetDensity(SampleHeight);\n\n            SampleUp = SamplePosition / SampleRadius;\n            SampleCosSunUp = dot(SampleUp, SunDirection);\n            SunTransmittance = TransmittanceFromTexture(SampleRadius, SampleCosSunUp);\n            vec3 SampleScattering = rayleighScatteringCoefficient * SampleDensity.x + mieScatteringCoefficient * SampleDensity.y;\n            vec3 Inscattering = SunTransmittance * SampleScattering * UniformPhase;\n\n            vec3 SampleExtinction = Density2Extinction(SampleDensity);\n            vec3 SampleTransmittance = Extinction2Transmittance(SampleExtinction, SampleLength);\n            vec3 NextViewTransmittance = ViewTransmittance * SampleTransmittance;\n            vec3 IntegralViewTransmittance = (ViewTransmittance - NextViewTransmittance) / SampleExtinction;\n\n            RayLight += IntegralViewTransmittance * Inscattering;\n            RayLightTransferFactor += IntegralViewTransmittance * SampleScattering;\n            CurrentDistance += SampleLength;\n            ViewTransmittance = NextViewTransmittance;\n        }\n        Luminance += RayLight;\n        TransferFactor += RayLightTransferFactor;\n        if (HitGround) {\n                Luminance += ViewTransmittance * SunTransmittance * (earthAlbedo / pi) * SampleCosSunUp;\n            }\n\n    }\n    //Luminance = Luminance * IsotropicPhase / float(RayCount);\n    //TransferFactor = TransferFactor * IsotropicPhase / float(RayCount);\n    //vec3 Color = Luminance / (1 - TransferFactor);\n    //sum of geometric sequence\n    vec3 Color = Luminance / (float(RayCount) - TransferFactor); \n    return Color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 1) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    float ViewHeight = uv.y * AtmosphereThickness;\n    float ViewRadius = BottomRadius + ViewHeight;\n    float CosSunUp = uv.x * 2.0 - 1.0;\n    vec3 Color = ComputeMultipleScatteringLut(CosSunUp, ViewRadius);\n    fragColor = vec4(Color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int SampleCount = 32;\n\nvec3 transmittanceFromTexture(float radius, float angle) {\n    vec2 uv = muR2uv(angle, radius, iResolution.xy);\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 MultipleScatteringContributionFromTexture(float height, float angle) {\n    float u = (angle + 1.0) * 0.5;\n    float v = height / AtmosphereThickness;\n    return texture(iChannel1, vec2(u, v)).xyz; \n}\n\nfloat RayleighPhase(float angle) {\n    return 3.0 / (16.0 * pi) * (1.0 + (angle * angle));\n}\n\nfloat MiePhase(float angle) {\n    const float g = 0.8;\n    const float g2 = g * g;\n    float Alpha = 1.0 + g2 - 2.0 * g * angle;\n    return 3.0 * (1.0 - g2) * (1.0 + angle * angle) / (8.0 * pi * (2.0 + g2) * Alpha * sqrt(Alpha));\n}\n\n//ACES approximation\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) \n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float ViewRadius = length(ViewPosition);\n    float Vhorizon = sqrt(ViewRadius * ViewRadius - BottomRadius2);\n\tfloat CosBeta = Vhorizon / ViewRadius;\t\t\t\t// GroundToHorizonCos\n\tfloat Beta = acos(CosBeta);\n\tfloat ZenithHorizonAngle = pi - Beta;\n    float StartDistance, EndDistance;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv = vec2(texCoord2unitRange(uv.x, iResolution.x), texCoord2unitRange(uv.y, iResolution.y));\n    float coordx = uv.x * pi;\n    float coordy = uv.y * 2.0 - 1.0;\n    coordy *= coordy;\n    if (uv.y < 0.5) {\n        coordy = 1.0 - coordy;\n        coordy = coordy * ZenithHorizonAngle;\n        if (! IntersectCircle(ViewRadius, cos(coordy), StartDistance, EndDistance)) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n    }\n    else {\n        coordy = ZenithHorizonAngle + coordy * Beta;\n        IntersectDoubleCircle(ViewRadius, cos(coordy), StartDistance, EndDistance);\n    }\n    float y = cos(coordy);\n    float lengthxz = sin(coordy);\n    float x = sin(coordx) * lengthxz;\n    float z = cos(coordx) * lengthxz;\n    vec3 RayDirection = vec3(x, y, z);\n  \n    vec3 SunDirection = GetSunDirection(iTime);\n\n    vec3 Up = ViewPosition / ViewRadius;\n    float CosSunUp = dot(SunDirection, Up);\n    float SinSunUp = sqrt(1.0 - CosSunUp * CosSunUp);\n    float CosSunRay = y * CosSunUp + z * SinSunUp;\n\n    SunDirection = vec3(0,CosSunUp, SinSunUp);\n\n    vec3 RayleighPhase = rayleighScatteringCoefficient * RayleighPhase(CosSunRay);\n    float MiePhase = mieScatteringCoefficient * MiePhase(CosSunRay);\n    float SampletLength = (EndDistance - StartDistance) / float(SampleCount);\n    vec3 ViewTransmittance = vec3(1.0);\n    float CurrentDistance = SampletLength * 0.5 + StartDistance;\n    vec3 Luminance = vec3(0.0);\n\n    for (int i = 0; i < SampleCount; i++) {\n        vec3 SamplePosition = vec3(0.0, ViewRadius, 0.0) + CurrentDistance * RayDirection;\n        float SampleRadius = length(SamplePosition);\n        vec3 SampleUp = SamplePosition / SampleRadius;\n        float SampleCosSunUp = dot(SunDirection, SampleUp);\n        float SampleHeight = SampleRadius - BottomRadius;\n        vec3 SampleDensity = GetDensity(SampleHeight);\n\n        vec3 SunTransmittance = transmittanceFromTexture(SampleRadius, SampleCosSunUp);\n        vec3 Inscattering = SunTransmittance * (SampleDensity.x * RayleighPhase + SampleDensity.y * MiePhase);\n        Inscattering += MultipleScatteringContributionFromTexture(SampleHeight, SampleCosSunUp) * (rayleighScatteringCoefficient * SampleDensity.x + mieScatteringCoefficient * SampleDensity.y);\n\n        vec3 SampleExtinction = Density2Extinction(SampleDensity);\n        vec3 SampleTransmittance = Extinction2Transmittance(SampleExtinction, SampletLength);\n        vec3 NextViewTransmittance = ViewTransmittance * SampleTransmittance;\n        vec3 IntegralViewTransmittance = (ViewTransmittance - NextViewTransmittance) / SampleExtinction;\n\n        Luminance += IntegralViewTransmittance * Inscattering;\n        CurrentDistance += SampletLength;\n        ViewTransmittance = NextViewTransmittance;\n    }\n\n    vec3 Color = Luminance * sunIntensity;\n    fragColor = vec4(Color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}