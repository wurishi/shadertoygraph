{"ver":"0.1","info":{"id":"lscXRM","date":"1458251111","viewed":405,"name":"3D Raytraced Pong","username":"aaecheve","description":"3D pong in a cornell box. Click and move mouse to control paddle. Reset game with R key.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","cornellbox","pong","games","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float infinity = 1e10;\n\nvec4 readMemory(vec2 coords)\n{\n    return texture(iChannel0, (coords + 0.5)/iChannelResolution[0].xy);\n}\n\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  int materialIndex;\n};\n\nstruct Material {\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n  float reflectivity;\n};\n\nstruct Light {\n  vec3 position;\n  vec4 color;\n};\n\nstruct Ray {\n  vec3 position;\n  vec3 direction;\n};\n\nstruct Camera {\n  vec3 position;\n};\n\nstruct Scene {\n  vec4 ambient;\n  vec4 background;\n};\n\nconst int numberOfSpheres = 6;\nconst int numLights = 2;\nconst int numberOfMaterials = 8;\nconst int maxNumberOfReflections = 2;\n\nSphere spheres[numberOfSpheres];\nMaterial materials[numberOfMaterials];\nLight lights[numLights];\nCamera camera = Camera(vec3(0.5, 0.5, 1.5));\nScene scene = Scene(vec4(0.1,0.1,0.1,1), vec4(0,0,0,1));\n\n\n//ray-sphere intersection\nfloat intersect(Ray ray, Sphere sphere)\n{\n  float a = dot(ray.direction, ray.direction);\n  float b = dot(ray.position - sphere.position, ray.direction);\n  float c = dot(ray.position - sphere.position, ray.position - sphere.position) - sphere.radius*sphere.radius;\n\n  float discr = b*b - a*c;\n  if(discr < 0.0)\n    return infinity;\n\n  discr = sqrt(discr);\n  float t0 = (-b - discr) / a;\n  float t1 = (-b + discr) / a;\n\n  float tMin = min(t0, t1);\n  if(tMin < 0.0)\n    return infinity;\n\n  return tMin;\n\n}\n\n//shadows\nbool isInShadow(vec3 p, Sphere sphere, Light light)\n{  \n  float lightDistance = distance(light.position, p);\n  vec3 shadowDir = normalize(light.position - p);\n  Ray shadowRay = Ray(p + 0.1 * shadowDir, shadowDir);    \n  float tShadow = intersect(shadowRay, sphere);\n  if(!isinf(tShadow) && tShadow < lightDistance)\n\treturn true;\n  \n  return false;\n}\n\nbool isInOtherSphereShadow(vec3 p, Sphere thisSphere, Light light)\n{\n\tfor(int i=0; i<numberOfSpheres; i++)\n\t{\n\t\tif(isInShadow(p, spheres[i], light))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n//blinn-phong shading\nvec4 blinnPhongShading(vec3 p, vec3 n, Sphere sphere, Material material)\n{\n  //Material material\t= materials[0];\n  vec3 v = camera.position - p;\n  v = normalize(v);\n \n  vec4 shadedColor = scene.ambient * material.diffuse;\n  for(int i=0; i<numLights; i++)\n  {\n\tvec4 lightColor = lights[i].color;\n\tif(isInOtherSphereShadow(p, sphere, lights[i]))\n\t\tlightColor = vec4(0,0,0,1);\n    vec3 l = lights[i].position - p;\n    l = normalize(l);  \n    vec3 h = v + l;\n    h = normalize(h);\n\n    shadedColor = shadedColor + lightColor * (max(0.0,dot(n,l)) * material.diffuse + pow(max(0.0,dot(n,h)), material.shininess) * material.specular);\t  \n  }\n  return shadedColor;\n}  \n\n\n\nvec4 rayTrace(Ray ray)\n{\n  vec4 accumulatedColor = vec4(0,0,0,1);\n  float frac = 1.0;\n  for(int i=0; i < maxNumberOfReflections + 1; i++)\n  {\n\t  float tMin = infinity;\n\t  int sphereMin = -1;\n      Sphere sphere = spheres[0];\n      Material material = materials[0];\n\t  for(int i=0; i<numberOfSpheres; i++)\n\t  {\t\n\t\tfloat t = intersect(ray, spheres[i]);\n\t\tif(t < tMin)\n\t\t{\n\t\t\ttMin = t;\n\t\t\tsphereMin = i;\n            sphere = spheres[i];\n            material = materials[i];\n\t\t}\n\t  }\n\n\t  if(!isinf(tMin))\n\t  {\n\t\tvec3 p = ray.position + tMin*ray.direction;\n\t\tvec3 n = normalize(p - sphere.position);\n\t\tMaterial mat = materials[0];\n\t\tvec4 localColor = blinnPhongShading(p, n, sphere, material);\n\t\taccumulatedColor += localColor * frac;\n\t\tif(mat.reflectivity > 0.0)\n\t\t{\n\t\t\tray.position = p;\n\t\t\tray.direction = normalize(reflect(ray.direction, n));\n\t\t\tfrac *= mat.reflectivity;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t  }  \n\t \n\t  accumulatedColor += scene.background * frac;\n  }\n  return accumulatedColor;\n}\n\nvoid init()\n{ \n  materials[0] = Material(vec4(0.156,0.126,0.507,1), vec4(1,1,1,1), 100.0, 0.3);   // Blue specular\n  materials[1] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[2] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[3] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[4] = Material(vec4(0.639, 0.06, 0.062, 1), vec4(0,0,0,1), 1.0, 0.5);   // Red\n  materials[5] = Material(vec4(0.156, 0.426, 0.107, 1), vec4(0,0,0,1), 1.0, 0.5);  // Green\n  \n\n  lights[0] = Light(vec3(0.5,0.99,0.5),  vec4(0.8,0.7,0.6,1));\n  lights[1] = Light(vec3(0.5,0.99,-0.5),  vec4(0.2,0.2,0.2,1));\n\n  spheres[0] = Sphere(vec3(0.35, 0.24, -0.72), 0.2, 0); //Blue sphere\n  spheres[1] = Sphere(vec3(0.5, 0.5, -1004), 1000.0, 2); //Back wall\n  spheres[2] = Sphere(vec3(0.5, 1001.1, -0.5), 1000.0, 2); //Ceiling\n  spheres[3] = Sphere(vec3(0.5, -1000.1, -0.5), 1000.0, 2); //Floor\n  spheres[4] = Sphere(vec3(1001.1, 0.5, -0.5), 1000.0, 4); //Right wall\n  spheres[5] = Sphere(vec3(-1000, 0.5, -0.5), 999.9, 3); //Left wall\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Read data\n  vec4 data = readMemory(vec2(0,0));\n  vec3 pos = data.xyz;\n  float lost = data.w;\n  \n    \n  //Initialize elements\n  init();\n\n  //Light movement \n  lights[0].position = vec3(0.5, 0.5, 1.0); \n\t\t  \t\t  \n  //Object movement\n  spheres[0].position = pos;\n\t   \t\n  //Raytrace objects\n  vec2 pixelCoords = fragCoord.xy / iResolution.y;\n  vec3 pixel = vec3(pixelCoords - vec2(0.5,0), 0);\n  Ray ray = Ray(camera.position, normalize(pixel - camera.position));\n  fragColor = rayTrace(ray);\n    \n  float size = 0.1;\n  vec2 normMouse = iMouse.xy/ iResolution.y;  \n  if (distance(pixelCoords, normMouse) < size)\n  {\n      fragColor = fragColor * vec4(0.75,0.75,0.0,1.0);\n  }\n  if(lost == 1.0)\n  {\n      fragColor.g = 0.0;\n      fragColor.b = 0.0;\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_LEFT\t37.5/256.0\n#define KEY_UP\t\t38.5/256.0\n#define KEY_RIGHT\t39.5/256.0\n#define KEY_DOWN\t40.5/256.0\n#define KEY_R\t82.5/256.0\n\nvec4 readMemory(vec2 coords)\n{\n    return texture(iChannel0, (coords + 0.5)/iChannelResolution[0].xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Read data\n    vec4 data1 = readMemory(vec2(0,0));\n    vec3 pos = data1.xyz;\n    float lost = data1.w;\n    \n    vec4 data2 = readMemory(vec2(1,1));\n    vec3 dir = data2.xyz;\n    float speed = data2.w;\n    \n    //Set initial values\n    if(pos.x == 0.0 && pos.y == 0.0 && pos.z == 0.0)\n       pos = vec3(0.5,0.5,0.5);\n    if(dir.x == 0.0 && dir.y == 0.0 && dir.z == 0.0)\n       dir = vec3(0.5,0.1,-1.0); \n    if(speed == 0.0)\n        speed = 0.02;\n    \n    //Reset\n    float kR = texture( iChannel1, vec2(KEY_R,0.0) ).x;\n    if (kR > 0.5) {\n        pos = vec3(0.5,0.5,0.5);\n        dir = vec3(0.5,0.1,-1.0); \n        speed = 0.02;\n        lost = 0.0;\n    }\n    \n    //Bounce\n    if(pos.z < -4.0)\n        dir.z = 1.0;\n    if(pos.x < 0.0)\n        dir.x = 1.0;\n    if(pos.x > 1.0)\n        dir.x = -1.0;\n    if(pos.y < 0.0)\n        dir.y = 1.0;\n    if(pos.y > 1.0)\n        dir.y = -1.0;\n    \n    //Paddle\n    vec2 normMouse = iMouse.xy/ iResolution.y;\n    float size = 0.1;\n    if(pos.z > 0.0 && pos.z <0.5)\n        if (distance(pos.xy + vec2(0.5,0.0), normMouse) < size)\n        {\n            dir.x += 1.0* (pos.x + 0.5 - normMouse.x);\n            dir.y += 1.0* (pos.y - normMouse.y);\n        \tdir.z = -1.0;\n            speed = speed + 0.001;\n        }\n    \n    if (pos.z > 0.5)\n    {\n        lost = 1.0;\n        speed = 0.0;\n    }\n    \n    //dir = normalize(dir);\n    //Update positions\n    pos += speed * dir;   \n    \n    \n    //Write data\n    if(fragCoord.x < 1.0 && fragCoord.y < 1.0) \n    \tfragColor = vec4(pos.x, pos.y, pos.z, lost);\n    else if(fragCoord.x < 2.0 && fragCoord.y < 2.0) \n    \tfragColor = vec4(dir.x, dir.y, dir.z, speed);\n    else\n       discard;\n}","name":"Buf A","description":"","type":"buffer"}]}