{"ver":"0.1","info":{"id":"MtGSzV","date":"1484969985","viewed":255,"name":"droste_effect","username":"DimitryK","description":"Learning the Droste effect algorithm from www.josleys.com/article_show.php?id=82 ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://www.shadertoy.com/view/XssXWr - using this to understand if I am on the right track\n// Why these specific values?\n#define R1 0.1\n#define R2 1.0\n// 2PI\n#define PI2 6.28318530718\n\nvec2 droste2(in vec2 uv) {\n    //math from www.josleys.com/article_show.php?id=82\n    \n    // cartesian coordinates -> polar coords, (r, theta) = ( sqrt(x*x + y*y), atan(y/x) )\n    vec2 polar = vec2(length(uv),atan(uv.y,uv.x));\n    // transform z-> log(z/R1)\n    polar.x = log(polar.x/R1);\n    // ratio for the radia\n    float ratio = log(R2/R1);\n    // alpha = atan(log(r2/r1)/2pi)\n    float alpha = atan(ratio/PI2);\n    // lets make a rotation matrix\n    // remember that GLSL is right handed...\n    mat2 digamma = mat2(cos(alpha), sin(alpha),\n              \t\t\t-sin(alpha), cos(alpha));\n    // Rotate\n    vec2 beta = digamma * polar;\n    // Still don't get why we are adjusting this by the alpha... Looking at the math, this seems to be the isolation of\n    // the complex plane without the rotation in the form of e^ia since B = Fe^ia, e^ia = B/F...\n    beta = beta/cos(alpha);\n    // This is where we are duplicating, but I still don't understand how...\n    // Ok, I think I got it - we are shifting by the width of the transformed strip\n    // where the R2 radius circle ends up being a line on log(r2/r1). So we want to move up until we hit that width,\n    // then start again\n    beta.x = mod(beta.x, log(R2/R1));\n    // And lets twist this bad boy with the exponentiation and convert it back to cartesian coords.\n    // Polar -> Cartesian: (x,y) = r*(cos(theta), sin(theta))\n    // And also scale back by R1 \n    beta = R1 * exp(beta.x) * vec2(cos(beta.y), sin(beta.y));\n    return beta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from https://www.shadertoy.com/view/XssXWr\n    float t = exp(-0.3*iTime);\n    vec2 uv = droste2(t*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y);\n    ////////////////////////////////////////////////\n    vec4 col = length(uv) <=1.0 && length(uv) >=0.9 ? vec4(vec3(0.),1.0) : vec4(vec3(1.),1.0);\n    vec4 tex = min(texture(iChannel0, .5 + .5*uv), col);\n\tfragColor = tex;\n}","name":"Image","description":"","type":"image"}]}