{"ver":"0.1","info":{"id":"DsKGWw","date":"1678640930","viewed":143,"name":"Fibonacci Distribued Soft shadow","username":"Poisson","description":"A shader showing my fibonnaci distribution soft shadow method, more efficient than montecarlo soft shadows.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","shadow","sphere","raytraced","ao","sampling","occlusion","aa","ambient","soft","pbr","fibonacci","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2 // antialiasing\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if (h<0.) return -1.;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// sphere shadow function\nfloat sphShadow(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n   \n    return b>0. ? 1. : step(h,0.);\n}\n\n// sphere soft shadow function\n// k is the softness of the shadow\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {        \n    float dgr = 1.+sqrt(5.); // double of the golden ration\n    \n    float res = 0.; // final result\n    for (int i=0; i<64; i++) { // 64 samples\n        float t = float(i)/64.; // i between 0 and 1\n        float a = acos(1.-2.*t); // angle 1\n        float b = 3.141592*dgr * float(i); // angle 2\n\n        // offset\n        vec3 off = vec3(sin(a)*cos(b),\n                        sin(a)*sin(b),\n                        cos(a));\n                \n        vec3 rrd = normalize(rd + k*off); // new ray direction\n        \n        res += sphShadow(ro, rrd, sph);\n    }\n    res /= 64.;\n    \n    return res;\n}\n\n// sphere occlusion\n// thanks to iq: https://www.shadertoy.com/view/4d2XWV\nfloat sphOcclusion(vec3 p, vec3 n, vec4 sph) {\n    vec3 r = sph.xyz - p;\n    float l = length(r);\n    return dot(n,r) * sph.w*sph.w/(l*l*l);\n}\n\n// sphere\nconst vec4 sph = vec4(0,0,0,.5);\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0); // background\n        \n    float t = 1e10; // final distance\n    vec3 n; // normal\n    float occ, sha = 1.; // occlusion and shadow\n    \n    const vec3 lig = vec3(.57735); // light direction\n    \n    // sphere\n    float t1 = sphIntersect(ro, rd, sph);\n    if (t1>0.) {\n        t = t1;\n        vec3 p = ro + rd*t;\n        n = (p - sph.xyz) / sph.w;\n        occ = .5+.5*n.y; // plane occlusion        \n    }\n    \n    // plane\n    float t2 = (-.5-ro.y) / rd.y;\n    if (t2>0. && t2<t) {\n        t = t2;\n        vec3 p = ro + rd*t;\n        n = vec3(0,1,0);\n        occ = 1.-sphOcclusion(p, n, sph); // sphere occlusion\n        \n        float k = .25+.25*sin(2.*iTime); // shadow softness\n        sha = sphSoftShadow(p, lig, sph, k); // sphere shadow\n    }\n    \n    if (t<1e10) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        \n        float dif = clamp(dot( n, lig), 0., 1.); // diffuse light\n        float bac = clamp(dot(-n, lig), 0., 1.); // bac light\n        float bou = .5-.5*n.y; // bounce light\n                \n        col = vec3(0);\n        col += vec3(1,.8,.6) * dif*sha; // direct light\n        col += .25*vec3(1,.8,.6) * occ*(.5+bac)*bou; // indirect light\n        col += .2*vec3(.3,.6,1) * occ; // sky light\n        \n        col = mix(col, vec3(0), 1.-exp(-t*t*.02)); // fog\n    }\n    \n    return 1.5*col/(1.+col); // tonemapping\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float an = .2*iTime + m.x*3.141592; // camera xz rotation\n    vec3 ro = vec3(2.5*sin(an),1,2.5*cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        vec3 col = render(ro, rd); // render\n\n        col = pow(col, vec3(.4545)); // gamma correction\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}