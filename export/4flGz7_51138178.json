{"ver":"0.1","info":{"id":"4flGz7","date":"1702904419","viewed":31,"name":"ki-1","username":"tono","description":"1217","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["picture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define repeat(p, span) mod(p, span) - (0.5 * span)\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a), s =sin(a);\n    return mat2(c, s, -s, c);\n}\n#define pi acos(-1.)\n#define pi2 acos(-1.)*2.\n\n// r is splited number.\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    // \"+ pi / r\" means shortcut of \"+ ((pi2 / r) * 0.5)\".\n    // so we want to get half angles of circle splitted by r.\n\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    // floor(a / n) means calculating ID.\n\n    return p * rot(-a);\n}\n\n#define line(a,b,c) step(a,b) * step(b+c,a)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p = floor(p * 700.)/700.;\n    p *= rot(pi/3.);\n    p *= 3.;\n    p = repeat(p,3.);\n\tvec3 color = vec3(0.6,0.,.1);\n    vec2 puv = p;\n    \n    puv = pmod(puv , 14.);\n    puv.y -= 0.2;\n    float pet = sdUnevenCapsule(puv.xy , .01, .1,.4);\n    vec3 petal = step(pet,0.03) * step(0.01,pet) * vec3(1.,1.,0.);\n    float circle = length(p) - 0.12;\n    vec3 circ = step(circle,0.03) * step(0.01,circle) * vec3(1.);\n    \n    float c2r = 0.73;\n    float circle2 = length(p) - c2r + sin(atan(p.x,p.y)*33.)/140.;\n    vec3 circ2 = step(circle2,0.03) * step(0.01,circle2) * vec3(1.);\n    \n    float c2noise = step(noise(p*65.*length(p)),0.5) * step(0.,length(p)-c2r) * step(length(p)-c2r-0.1,0.);\n    vec3 c2noiseCol = c2noise * vec3(1.);\n    \n    vec2 mp = p;\n    mp = abs(mp)-34.;\n    mp *= rot(pi/4.);\n    mp = repeat(mp,1.8);\n    mp = abs(mp) - 1.1;\n    mp *= rot(6.3);\n    mp =abs(mp) - .63;\n    float c3 = sdMoon(mp,0.01,0.3,0.3);\n    c3 = step(c3,0.11) * step(0.1,c3);\n    vec3 c3col = c3 * vec3(1.);\n    \n    color += petal+ circ + circ2 + c2noiseCol + c3col;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}