{"ver":"0.1","info":{"id":"tl3GWN","date":"1576342067","viewed":195,"name":"Raytraced checker ground","username":"jetp250","description":"Messing around with raytracing","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define FLOOR_REFLECTANCE 0.5\n#define MAX_BOUNCES 10\n\n// Returns the distance from the ray origin to the sphere surface\nfloat raySphereIntersect(vec3 rayStart, vec3 rayDir, vec3 spherePos, float sphereRadius) {\n    vec3 toRayStart = rayStart - spherePos;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, toRayStart);\n    float c = dot(toRayStart, toRayStart) - (sphereRadius * sphereRadius);\n\t\n    float discriminant = b * b - 4.0 * a* c;\n    \n    if (discriminant < 0.0) { // No solutions, can't take sqrt of negative numbers\n        return -1.0;\n    }\n    \n\treturn (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nstruct Ray {\n  vec3 rs;\n  vec3 rd;\n};\n\nstruct Sphere {\n\tvec3 pos;\n    float r;\n};\n    \nstruct Hit {\n    Ray ray;\n    bool wasHit;\n    vec4 color;\n};\n    \nHit getSky(Ray ray) { \n    vec4 col4 = texture(iChannel0, ray.rd);\n    return Hit(ray, false, vec4(col4.rgb, 1.0));\n}\n\nHit getGround(Ray ray) {\n    if (ray.rd.y > 0.0) {\n\t\treturn getSky(ray);\n    }\n   \n    // Based on the assumption that 'ray.rd.y' is the sine of the ray's pitch\n    float distance = ray.rs.y / (-ray.rd.y);\n    vec3 pos = ray.rs + distance * ray.rd;\n\n    // either 0.0 or 1.0\n   \tfloat checker = mod(floor(pos.x) + floor(pos.z), 2.0);\n    \n    float tileContrast = .2;\n    float brightness = .2;\n    \n    float groundColor = (checker - .5) * tileContrast + brightness;\n    \n    vec3 reflected = reflect(ray.rd, vec3(0.0, 1.0, 0.0));\n    \n   \treturn Hit(Ray(pos, reflected), true, vec4(vec3(groundColor), FLOOR_REFLECTANCE));\n}\n\nHit raycast(Ray ray, vec3 camera) {\n\tSphere sphere = Sphere(camera + vec3(sin(iTime * 0.8),0.5 - sin(iTime),4.0 + cos(iTime)), 1.0);\n    float t = raySphereIntersect(ray.rs, ray.rd, sphere.pos, sphere.r);\n    if (t > -1.0) {\n    \tvec3 pos = ray.rs + t * ray.rd;\n        \n        if (pos.y > 0.0) {\n            vec3 normal = normalize(pos - sphere.pos);\n            vec3 reflected = reflect(ray.rd, normal);\n\n            return getGround(Ray(pos, reflected));\n        }\n    }\n    \n    return getGround(ray);\n}\n\nRay getRayForUV(vec2 uv) {\n    vec3 ro = vec3(0.0, 1.0, 0.0 + iTime * .8);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    float pitch = sin(iTime) * .25;\n    float yaw = sin(iTime*0.4) * 0.4;\n    \n    float ys = sin(yaw);\n    float yc = cos(yaw);\n    float ps = sin(pitch);\n    float pc = cos(pitch);\n    \n    // Rotate around X axis\n    rd = vec3(\n        rd.x,\n        rd.y * pc - rd.z * ps,\n        rd.y * ps + rd.z * pc\n    );\n\n    // Rotate around Y axis\n    rd = vec3(\n        rd.x * yc + rd.z * ys,\n        rd.y,\n        -rd.x * ys + rd.z * yc\n    );\n    \n    return Ray(ro, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\tRay originalRay = getRayForUV(uv);\n\n    // Antialiasing samples\n    vec2 samples[] = vec2[] (\n        vec2(0.058824, 0.419608),\n        vec2(0.298039, 0.180392),\n        vec2(0.180392, 0.819608),\n        vec2(0.419608, 0.698039),\n        vec2(0.580392, 0.298039),\n        vec2(0.941176, 0.058824),\n        vec2(0.698039, 0.941176),\n        vec2(0.819608, 0.580392)\n    );\n        \n    vec3 colorAcc = vec3(0.0);\n    for (int i = 0; i < samples.length(); ++i) {\n        vec3 newRayDir = originalRay.rd + vec3(samples[i] * 0.002, 0.0); // TODO rotate offsets properly?\n        Ray ray = Ray(originalRay.rs, newRayDir);\n\n        float left = 1.0;\n        \n        for (int j = 0; j < MAX_BOUNCES; ++j) {\n        \tHit hit = raycast(ray, originalRay.rs);\n            \n            vec4 color = hit.color;\n            \n            float amt = left * color.w;\n            colorAcc += color.rgb * amt;\n            \n            left -= amt;\n            ray = hit.ray;\n            \n            if (!hit.wasHit)\n                break;\n        }\n    }\n    \n    fragColor = vec4(colorAcc / float(samples.length()), 1.0);\n}","name":"Image","description":"","type":"image"}]}