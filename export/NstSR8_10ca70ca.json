{"ver":"0.1","info":{"id":"NstSR8","date":"1632612976","viewed":404,"name":"Cast Voxels March Sub-Objects","username":"jt","description":"Fork of [url]https://www.shadertoy.com/view/4dX3zl[/url] Branchless Voxel Raycasting by fb39ca4.\nExperimenting with different ray-[b]marched[/b] subobjects. Using the elegant tiny core-loop but had to re-introduce branching (break).","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raycasting","voxel","fork","dda","textured","subobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// fork of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// raymarching subobjects addon by jt\n\n// tags: 3d, raymarching, raycasting, voxel, dda, textured, subobjects, fork\n\n#define pi 3.1415926\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdMixed(vec3 p, int id)\n{\n    if(id == 0) return sdSphere(p, 0.5);\n    if(id == 1) return sdBox(p, vec3(0.4));\n    return 0.0;\n}\n\nbool getVoxel(ivec3 c) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));\n    //float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define MAX_ITER 200u\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(vec3 ro, vec3 rd, float tmin, float tmax, int id)\n{\n    uint i;\n    float t;\n    for(t = tmin, i = 0u; t < tmax && i < MAX_ITER; i++)\n    {\n        float h = sdMixed(ro + rd * t, id);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, int id )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, id) +\n                     k.yyx * sdMixed(p + k.yyx * h, id) +\n                     k.yxy * sdMixed(p + k.yxy * h, id) +\n                     k.xxx * sdMixed(p + k.xxx * h, id));\n}\n\nvec4 process_subobject(vec3 ro, vec3 rd, float tmin, float tmax, int id)\n{\n    float d = march(ro, rd, tmin, tmax, id);\n    vec3 n = normal(ro + rd * d, id);\n    return vec4(n, d);\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 I )\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = -pi/4.0 + pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : /* 1.5 * */ pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -20.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n    \n    //ray_pos.z -= 0.0;\n\n    ray_dir = normalize(ray_dir);\n\n    vec3 color = vec3(0.0);\n    vec4 result = vec4(vec3(0.0), MAX_DIST);\n\n    {\n        vec3 deltaDist = 1.0 / abs(ray_dir);\n        ivec3 rayStep = ivec3(sign(ray_dir));\n        ivec3 mapPos = ivec3(floor(ray_pos));\n        vec3 sideDist = (sign(ray_dir) * (vec3(mapPos) - ray_pos) + (sign(ray_dir) * 0.5) + 0.5) * deltaDist;\n\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to prevent crash\n        {\n            if (getVoxel(mapPos))\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection(ray_pos - vec3(mapPos) - vec3(0.5), ray_dir, vec3(0.5) ); // bounding box\n                if(min(abs(mapPos.x), min(abs(mapPos.y),abs(mapPos.z))) > 5) // explicit sky-box (letting loop run-out without hitting a wall causes blocky artifacts)\n                    break;\n                //result = process_subobject(ray_pos - vec3(mapPos) - vec3(0.5), ray_dir, bounds.x, bounds.y, i > 10 ? 1 : 0);\n                result = process_subobject(ray_pos - vec3(mapPos) - vec3(0.5), ray_dir, bounds.x, bounds.y, texture(iChannel0, 0.1 * vec3(mapPos)).x < 0.5 ? 0 : 1);\n                if(result.w > 0.0 && result.w < bounds.y)\n                {\n                    color = vec3(1.0);\n                    //color *= 0.5 + 0.5 * normalize(result.xyz);\n                    vec3 dst = ray_pos + ray_dir * result.w;\n                    //color *= texture(iChannel0, dst).xyz;\n                    color *= vec3(0.5 + 0.5 * checker(dst));\n\n                    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n                    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n                    color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n                    break;\n                }\n            }\n\n            // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n            bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n    }\n\n    vec3 ambient = vec3(0.1);\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}