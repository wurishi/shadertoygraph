{"ver":"0.1","info":{"id":"XdjyR1","date":"1490881952","viewed":197,"name":"Live coding session #2","username":"rohtie","description":"Result from a jam session I had today with jazz/noise musician Jo David Meyer Lysne.\n\nIchannel0 was originally attached to microphone, but I replaced it with one of the stock songs to visualize the effects.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(1.25, 0.41, 0.15),\n    vec3(2.7, 1.0, 0.95),\n    vec3(1.0)\n);\n\nMaterial defaultMaterial2 = Material(\n    vec3(0.25, 3.41, 0.1),\n    vec3(7.7, 1.0, 0.15),\n    vec3(3.0)\n);\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a) {\n    return mat2(-sin(a), cos(a),\n                 cos(a), sin(a));\n}\n\nvec3 triPlanar(sampler2D tex, vec3 normal, vec3 p) {\n    vec3 cX = texture(tex, p.yz).rgb;\n    vec3 cY = texture(tex, p.xz).rgb;\n    vec3 cZ = texture(tex, p.xy).rgb;\n\n    vec3 blend = abs(normal);\n    blend /= blend.x + blend.y + blend.z + 0.001;\n\n    return blend.x * cX + blend.y * cY + blend.z * cZ;\n}\n\nfloat box( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat cylinder( vec3 p, vec3 c ) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p) {\n    float time = mod(iTime, 20.0);\n    \n    if (time < 10.0 ) {\n        //p.yz *= rotate(sin(7.5 + iTime) * 0.5);\n        vec3 q = p;\n        q.x = mod(q.x, 0.2);\n        q.y = mod(q.y, 0.5 + sin(iTime));\n        //q.z = mod(q.z, 0.5);\n\n\n\n        float x = length(q) - 0.1;\n\n\n        p.xz *= rotate(iTime * 0.25);\n        p.xy *= rotate(iTime * 0.1);\n\n        return min(x, length(p) - texture(iChannel0, p.xy + 0.5).r * (4.0 + sin(iTime * 0.5)));\n    }\n    else if (time < 15.0) {\n        //p.x += iTime * 0.01;\n        //p *= mod(p, 0.03);\n\n        p.y -= 0.75;\n\n        p.xyz +=  texture(iChannel0, vec2(p.x * p.z + 0.5, 0.0)).r * 5.0;\n\n        float a = length(p - sin(iTime * 4.0)) - 0.75;\n        float b = length(p - vec3(cos(iTime * 3.0), 0.25, 0.0)) - 0.5;\n        float c = length(p - vec3(0.0, sin(iTime), 1.0)) - 0.55;\n        float d = length(p - vec3(1.0, 0.0, sin(iTime) * 1.0) - 1.25);\n\n        return min(smin(d, smin(c, smin(a, b, 1.0), 1.0), 1.0) - 1.0, p.y - 0.5);\n    }\n}\n\nbool isSameDistance(float distanceA, float distanceB, float eps) {\n    return distanceA > distanceB - eps && distanceA < distanceB + eps;\n}\n\nbool isSameDistance(float distanceA, float distanceB) {\n    return isSameDistance(distanceA, distanceB, 0.0001);\n}\n\nMaterial getMaterial(vec3 p) {\n    float distance = map(p);\n\n    float time = mod(iTime, 20.0);\n    \n    if (time < 10.0 ) {\n    \treturn defaultMaterial;\n    }\n    else if (time < 15.0) {\n    \treturn defaultMaterial2;\n    }\n    \n    \n    /*\n    if (isSameDistance(distance, hat(p))) {\n        return hatMaterial;\n    }*/\n\n    return defaultMaterial;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(p + extraPolate.xyy),\n        map(p + extraPolate.yxy),\n        map(p + extraPolate.yyx)\n    ) - map(p));\n}\n\nfloat intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n\n    float distance = 0.0;\n\n    float currentDistance = 1.0;\n\n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        vec3 p = rayOrigin + rayDirection * distance;\n\n        currentDistance = map(p);\n\n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return -1.0;\n    }\n\n    return distance;\n}\n\nvec3 light = normalize(vec3(10.0, 20.0, 2.0));\n\nvoid mainImage( out vec4 o, in vec2 p ) {\n\to.rgb = vec3(0.0);\n    \n    float time = mod(iTime, 20.0);\n    \n    if (time < 5.0) {\n        p = (p / iResolution.xy) - 0.5;\n        p.x *= iResolution.x / iResolution.y;\n\n\n        vec2 q = p;\n\n\n        p.x -= sin(texture(iChannel0, vec2(p.y + 0.5, 0.0)).r * 5.0 + time * 0.5) * p.y * 2.0;\n        p.y += tan(time) * 0.01;\n\n        float a = length(p) - 0.5;\n        float result = smoothstep(0.09, 0.1, a);\n\n        o.rgb = vec3(0.0) + texture(iChannel0, vec2(p.x + 0.5, p.y)).r * 2.0 + vec3(0.0, 0.0, p.y + sin(iTime)) + result;\n        o.rgb /= texture(iChannel1, p).rgb * 4.75;\n    }\n    else if (time < 10.0) {\n        p /= iResolution.xy;\n        p = 2.0 * p - 1.0;\n        p.x *= iResolution.x / iResolution.y;\n\n        vec3 cameraPosition = vec3(0.0, 0.5, 3.0);\n        vec3 rayDirection = normalize(vec3(p, -1.0));\n\n        float distance = intersect(cameraPosition, rayDirection);\n\n        vec3 col = vec3(0.0);\n\n        if (distance > 0.0) {\n            vec3 p = cameraPosition + rayDirection * distance;\n            vec3 normal = getNormal(p);\n            Material material = getMaterial(p);\n\n            col += material.ambient;\n            col += material.diffuse * max(dot(normal, light), 0.0);\n\n            vec3 halfVector = normalize(light + normal);\n            col += material.specular * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n\n            float att = clamp(1.0 - length(light - p) / 5.0, 0.0, 1.0); att *= att;\n            col *= att;\n\n            col *= vec3(smoothstep(0.25, 0.75, map(p + light))) + 0.5;\n        }\n\n        col /= tan(iTime * 4.0);\n\n\n        col += (col / texture(iChannel1, p.xy).rgb * 1.0) * 0.25;\n\n        o.rgb = col;        \n    }\n    else if (time < 15.0) {\n        p /= iResolution.xy;\n        p = 2.0 * p - 1.0;\n        p.x *= iResolution.x / iResolution.y;\n\n        vec3 cameraPosition = vec3(0.0, 0.5, 3.0);\n        vec3 rayDirection = normalize(vec3(p, -1.0));\n\n        float distance = intersect(cameraPosition, rayDirection);\n\n        vec3 col = vec3(1.0, 0.0, 0.0);\n\n        if (distance > 0.0) {\n            vec3 p = cameraPosition + rayDirection * distance;\n            vec3 normal = getNormal(p);\n            Material material = getMaterial(p);\n\n            col += material.ambient;\n            col += material.diffuse * max(dot(normal, light), 0.0);\n\n            vec3 halfVector = normalize(light + normal);\n            col += material.specular * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n\n            float att = clamp(1.0 - length(light - p) / 5.0, 0.0, 1.0); att *= att;\n            col *= att;\n\n            col *= vec3(smoothstep(0.25, 0.75, map(p + light))) + 0.5;\n        }\n\n        col.r += (p.y + 0.25) * 2.0;\n\n        o.rgb = col;\n    }\n    else if (time < 20.0) {\n        p = (p / iResolution.xy) - 0.5;\n        p.x *= iResolution.x / iResolution.y;\n\n        vec2 q = p;\n\n\n        p.x += texture(iChannel0, vec2((0.5 - p.x) * 0.25, 0.0)).r;\n\n        p.x = mod(p.x, 0.2);\n\n        float result = abs(p.x) * 4.0;\n        result = max(result, p.y + texture(iChannel0, vec2((q.x + 0.75) * 0.1, 0.0)).r);\n\n        result = smoothstep(0.49, 0.7, result);\n\n        o.rgb = vec3(0.0) + result + vec3(q.x * p.x - 0.2, 0.0, result * p.y) - (result - 1.0) * texture(iChannel0, vec2(q.x, q.y)).rgb * 1.75;\n        o.rgb += texture(iChannel1, q * texture(iChannel0, vec2(q.x * 0.2, 0.0)).r).rgb * 0.25;\n        o.r += (length(q) - 0.4) * 1.5;\n\n        p.x *= p.y;\n        p *= rotate(iTime) * 0.15;\n\n        o.rbg -= texture(iChannel1, p * (30.0 + sin(time) * texture(iChannel0, vec2(0.0, 0.0)).r)).rgb;\n\n        o.g *= sin(time);\n    }\n}","name":"Image","description":"","type":"image"}]}