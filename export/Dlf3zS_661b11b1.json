{"ver":"0.1","info":{"id":"Dlf3zS","date":"1671894812","viewed":84,"name":"Raytracer by ChatGPT","username":"joteakus","description":"Oh my goodness me it works kind of\nrequired 2 modifications (moving function and renaming and defining iCamera as camera)\nBy ChatGPT","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["airaytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray-sphere intersection function\nfloat intersectSphere(vec3 o, float r, vec3 p, vec3 d)\n{\n    // Calculate the coefficients of the quadratic equation\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, p - o);\n    float c = dot(p - o, p - o) - r*r;\n\n    // Calculate the discriminant\n    float discriminant = b*b - 4.0*a*c;\n\n    // Check for real roots\n    if (discriminant < 0.0)\n        return -1.0;\n\n    // Calculate the intersection points\n    float t1 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0*a);\n\n    // Return the smallest positive root\n    if (t1 > 0.0)\n        return t1;\n    else if (t2 > 0.0)\n        return t2;\n    else\n        return -1.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 camera = vec3(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Generate a ray from the camera position\n    vec3 ray = normalize(vec3(uv*2.0-1.0, 1.0));\n\n    // Check for intersection with a sphere\n    vec3 o = vec3(0.0, 0.0, 4.0); // sphere center\n    float r = 0.5; // sphere radius\n    float t = intersectSphere(o, r, camera, ray);\n    if (t > 0.0)\n    {\n        // Calculate the intersection point\n        vec3 p = camera + ray * t;\n\n        // Calculate the surface normal\n        vec3 n = normalize(p - o);\n\n        // Calculate the diffuse lighting\n        vec3 l = normalize(vec3(1.0, 1.0, -0.5)); // light direction\n        float d = max(dot(n, l), 0.0);\n\n        // Set the fragment color\n        fragColor = vec4(d, d, d, 1.0);\n    }\n    else\n    {\n        // No intersection, set the fragment color to black\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nOriginal code by ChatGPT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Generate a ray from the camera position\n    vec3 ray = normalize(vec3(uv*2.0-1.0, 1.0));\n\n    // Check for intersection with a sphere\n    vec3 o = vec3(0.0, 0.0, 0.0); // sphere center\n    float r = 0.5; // sphere radius\n    float t = intersectSphere(o, r, iCamera, ray);\n    if (t > 0.0)\n    {\n        // Calculate the intersection point\n        vec3 p = iCamera + ray * t;\n\n        // Calculate the surface normal\n        vec3 n = normalize(p - o);\n\n        // Calculate the diffuse lighting\n        vec3 l = normalize(vec3(1.0, 1.0, 1.0)); // light direction\n        float d = max(dot(n, l), 0.0);\n\n        // Set the fragment color\n        fragColor = vec4(d, d, d, 1.0);\n    }\n    else\n    {\n        // No intersection, set the fragment color to black\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n// Ray-sphere intersection function\nfloat intersectSphere(vec3 o, float r, vec3 p, vec3 d)\n{\n    // Calculate the coefficients of the quadratic equation\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, p - o);\n    float c = dot(p - o, p - o) - r*r;\n\n    // Calculate the discriminant\n    float discriminant = b*b - 4.0*a*c;\n\n    // Check for real roots\n    if (discriminant < 0.0)\n        return -1.0;\n\n    // Calculate the intersection points\n    float t1 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0*a);\n\n    // Return the smallest positive root\n    if (t1 > 0.0)\n        return t1;\n    else if (t2 > 0.0)\n        return t2;\n    else\n        return -1.0;\n}\n\n*/","name":"Common","description":"","type":"common"}]}