{"ver":"0.1","info":{"id":"Dtcczj","date":"1699392678","viewed":38,"name":"Swirly Dirly","username":"tylerj","description":"A swirly dirly shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","swirl","spiral","vortex","portal","twist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// built for the Ello gif contest:\n// https://ello.co/medialivexello/post/gif-exhibition\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\n// from iq / bookofshaders\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = -iTime * 0.15;\n    \n    //////////////////////////////////////////////////////\n    // Create tunnel coordinates (p) and remap to normal coordinates (uv)\n    // Technique from @iq: https://www.shadertoy.com/view/Ms2SWW\n\t// and a derivative:   https://www.shadertoy.com/view/Xd2SWD\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\t\t// normalized coordinates (-1 to 1 vertically)\n    vec2 uvOrig = p;\n    // added twist by me ------------\n    float rotZ = time * 2.5;\n    p *= mat2(cos(rotZ), sin(rotZ), -sin(rotZ), cos(rotZ));\n\t//-------------------------------\n    float a = atan(p.y,p.x);\t\t\t\t\t\t\t\t\t\t\t\t// angle of each pixel to the center of the screen\n    float rSquare = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\t// modified distance metric (http://en.wikipedia.org/wiki/Minkowski_distance)\n    float rRound = length(p);\n    float r = rRound; \t\t\t// interp between round & rect tunnels\n    vec2 uv = vec2( 0.3/r + time, a/3.1415927 );\t\t\t\t\t\t\t// index texture by (animated inverse) radious and angle\n    //////////////////////////////////////////////////////\n\n    // subdivide to grid\n    uv += vec2(0., 1. * sin(time + uv.x * 1.2));\t\t\t// pre-warp\n    uv /= vec2(1. + 0.0002 * length(uvOrig));\n    vec2 uvDraw = fract(uv * 12.);\t\t\t\t\t\t\t// create grid\n\n    // draw lines\n\tfloat col = cubicPulse(0.5, 0.06, uvDraw.x);\n    col = max(col, cubicPulse(0.5, 0.06, uvDraw.y));\n        \n    // darker towards center, light towards outer\n    col = col * r * 0.4;\n    //col += 0.15 * length(uvOrig);\n    fragColor = vec4(vec3(1. - col, 1. - col, 1. - col), 1.);\n}","name":"Image","description":"","type":"image"}]}