{"ver":"0.1","info":{"id":"dtfBR7","date":"1692827522","viewed":60,"name":"00GraphicsClassLesson03","username":"foodini","description":"I'm using this as an intro point in a class on computer graphics. The intent is to show people how to create cool shapes, then work backward from there to help them understand raymarching. It's always best to get people fiddling as early as possible.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","interview"],"hasliked":0,"parentid":"DdVXRy","parentname":"Inquisition Start Point - WIP"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Things to have a student do:\n// * MAKE IT PRETTY! I'm color blind, so you're going to have to fix the colors yourself!!!\n// * Explain why the ground plane has blinking band in the distance. Why does it bend\n//   near the object? How might it be reduced? How might it be elimininated (almost)\n//   entirely with minimal computational cost?\n// * Write a function that can be used to recenter any object to <0.5, 0.5, 0.5>\n//   * Use this function to get rid of the hard-coded offset in map_ground_plane\n//   * Instance the recentered object. (In-person only.)\n// * Make the object reflective. GLSL has a reflect() function.\n// * How would you support lots of unrelated objects, each with their own shading \n//   functions? What are the advantages/drawbacks of doing a trace of the whole world\n//   in one loop, versus having one loop for each compound object?\n// * Multiple light sources? If you put several light sources close enough together,\n//   it can look like you have \"soft\" shadows.\n\nconst float PI = 3.141592657;\n\nfloat map_composite_object( in vec3 p) {\n    //p = mod(p, 10.0) - 5.0;\n    if(false) {\n        float dist = sdf_sphere(p - vec3(1.0,0.0,0.0), 1.5);\n        //return hard_intersection(dist, sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5));\n        //return hard_subtraction(sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5), dist);\n        return smooth_union(\n            dist, \n            sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5),\n            0.1);\n    }\n    \n    if(true) {\n        float dist;\n        float dn;\n        float sphere_r;\n        vec3 sphere_pos;\n        sphere_pos = vec3(sin(iTime), cos(iTime*1.2), .7*sin(iTime*0.6));\n        sphere_r = 0.5 + 0.3*sin(iTime*9.0);\n        dist = sdf_sphere(p-sphere_pos, sphere_r);\n        \n        sphere_pos = vec3(-0.5*sin(2.7*iTime), 1.2*cos(iTime*0.5), .2*sin(iTime*1.3));\n        sphere_r = 0.6 + 0.2*sin(iTime*3.6);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.57*sin(1.3*iTime), 0.74*cos(iTime*7.5), .475*sin(iTime*6.3));\n        sphere_r = 0.49 + 0.355*sin(iTime*6.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.75*sin(3.14*iTime), 1.77*cos(iTime*5.29), .392*sin(iTime*3.98));\n        sphere_r = 0.73 + 0.297*sin(iTime*5.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.23*sin(1.19*iTime), 0.53*cos(iTime*0.92), .297*sin(iTime*0.95));\n        sphere_r = 0.35 + 0.297*sin(iTime*0.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        return dist;\n    }\n    \n    if(false) {\n        return smooth_subtraction(\n            sdf_rounded_box(p, vec3(1.0), 0.425),\n            sdf_sphere(p, 1.74),\n            0.2);\n    }\n    if(false) {\n        float dist = hard_intersection(\n            hard_subtraction(\n                sdf_rounded_box(p, vec3(1.0), 0.425),\n                sdf_sphere(p, 1.74)),\n            sdf_sphere(p, 1.9));\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n        return dist;\n    } \n    if(true) {\n        float mod_time = mod(iTime, 22.0);\n        float dist = sdf_rounded_box(p, vec3(1.0), 0.425);\n        if(mod_time < 2.0) return dist;\n        dist = hard_subtraction(dist, sdf_sphere(p, 1.74));\n        if(mod_time < 4.0) return dist;\n        dist = hard_intersection(dist, sdf_sphere(p, 1.9));\n\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        if(mod_time < 6.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 8.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 10.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 12.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        if(mod_time < 14.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 16.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 18.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 20.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n\n        return dist;\n    }\n}\n\nfloat map_ground_plane( in vec3 p) {\n    return p.y + 2.0;\n}\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\nbool is_shadowed(in vec3 p, in vec3 normal, in vec3 light_pos) {\n    float distance_travelled = 0.0;\n    \n    // p is already very close to a surface. If we just check to see how far from\n    // that surface we are and assume we've hit it when d<0.001, we'll always think\n    // we've hit it in the first iteration. What happens if this value is too small?\n    p += normal * 0.002;\n    vec3 light_dir = light_pos - p;\n    float dist_to_light = length(light_dir);\n    //normalize light_dir:\n    light_dir /= dist_to_light;\n    \n    for(int iterations = 0; iterations < 150; iterations++) {\n        float d = map_composite_object(p);\n        distance_travelled += d;\n        if(distance_travelled > dist_to_light) {\n            return false;\n        }\n        if(d < 0.001) {\n            return true;\n        }\n        p += d * light_dir;\n    }\n    \n    // you could make an argument to go either way... true is probably better.\n    return true;\n}\n    \n// MAKE VERY SURE THAT normal IS NORMALIZED (length == 1.0)\nvec3 lighting(in vec3 p, in vec3 normal, in vec3 light_col, in vec3 light_pos, in vec3 surface_col) {\n    if(is_shadowed(p, normal, light_pos)) {\n        return vec3(0.0);\n    }\n    vec3 light_dir = normalize(light_pos - p);\n    float diffuse_brightness = dot(normal, light_dir);\n    return diffuse_brightness * light_col * surface_col;\n}\n\n// Nothing says the light_col is limited to values <= 1.0!!!\nvec3 light_col = vec3(0.6, 1.0, 0.9);\nvec3 light_pos = vec3(2.0, 5.0, 2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 8.0;\n    vec3 camera_position = vec3(\n        sin(iTime/2.0) * camera_distance_from_origin,\n        0.0,\n        cos(iTime/2.0) * camera_distance_from_origin);\n    vec3 camera_lookat_point = vec3(0.0, 0.0, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a \"reverse photon\" travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n\n    for(int iterations=0; iterations<250; iterations++) {\n        float comp_dist = map_composite_object(current_position);\n        float plane_dist = map_ground_plane(current_position);\n        float dist = min(comp_dist, plane_dist);\n        current_position += dist * ray_direction;\n        if(dist < 0.001) {\n            vec3 diffuse_col;\n            if(comp_dist < plane_dist) {\n                vec3 normal = calc_normal(current_position);\n                diffuse_col = lighting(current_position, normal, light_col, light_pos, vec3(1.0));\n            } else {\n                // Compute the ground plane color intensity:\n                vec3 c = vec3(0.9 + 0.05*cos(current_position.x) + 0.05*cos(current_position.z));\n                diffuse_col = lighting(current_position, vec3(0.0, 1.0, 0.0), light_col, light_pos, c);\n\n            }\n            fragColor.rgb = diffuse_col;\n            return;\n        } else if (dist > 10.0) {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n    }\n    \n    // This is our error case. We didn't hit anything, but we iterated so long that we\n    // had to give up. \n     fragColor.g = fract(iTime) < 0.5 ? 0.5 : 0.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hard_union( float d0, float d1 ) {\n    return(min(d0, d1));\n}\n\nfloat hard_subtraction( float d0, float d1 ) {\n    return(max(d0, -d1));\n}\n\nfloat hard_intersection( float d0, float d1 ) {\n    return(max(d0, d1));\n}\n\nfloat smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n\n// LOOK AT https://iquilezles.org/articles/distfunctions/ for the best SDF reference\n// anywhere.\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n","name":"Common","description":"","type":"common"}]}