{"ver":"0.1","info":{"id":"XclfWN","date":"1723797104","viewed":17,"name":"Discrete Winding number","username":"alpers_shadertoy","description":"Yellow=Inside\nBlue=Outsite\nwinding number for 2D polygons","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2dpointcontainment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isPointInTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p0;\n    vec2 e2 = p - p0;\n\n    float u = dot(e0, e0);\n    float v = dot(e0, e1);\n    float w = dot(e1, e1);\n    float u1 = dot(e0, e2);\n    float v1 = dot(e1, e2);\n\n    float D = u * w - v * v;\n    float s = (u * v1 - v * u1) / D;\n    float t = (w * u1 - v * v1) / D;\n\n    return (s >= 0.0) && (t >= 0.0) && (s + t <= 1.0);\n}\n\n// Function to compute the angle between two vectors\nfloat angleBetween(vec2 a, vec2 b) {\n    float cosTheta = dot(a, b) / (length(a) * length(b));\n    return acos(clamp(cosTheta, -1.0, 1.0));\n}\n\nfloat signedAngle(vec2 a, vec2 b) {\n    return atan(a.x * b.y - a.y * b.x, dot(a,b));\n}\n\nconst int NUM_VERT = 6;\nconst int NUM_TRI = 12;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the vertices of the non-convex polygon\n    vec2 vertices[NUM_VERT];\n    vertices[0] = vec2(0.1, 0.1);\n    vertices[1] = vec2(0.9, 0.1);\n    vertices[2] = vec2(0.5, 0.5);\n    vertices[3] = vec2(0.9, 0.9);\n    vertices[4] = vec2(0.1, 0.9);\n    vertices[5] = vec2(0.3, 0.3);\n\n    // Define the indices of the triangles\n    int indices[NUM_TRI] = int[NUM_TRI](\n        0, 1, 5,  // First triangle\n        1, 2, 5,  // Second triangle\n        2, 3, 5,\n        5, 3, 4   // Third triangle\n        \n    );\n\n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Check if the fragment is inside any of the triangles\n    bool insideTri = false;\n    for (int i = 0; i < NUM_TRI; i += 3) {\n        vec2 v0 = vertices[indices[i]];\n        vec2 v1 = vertices[indices[i + 1]];\n        vec2 v2 = vertices[indices[i + 2]];\n\n        if (isPointInTriangle(uv, v0, v1, v2)) {\n            insideTri = true;\n            break;\n        }\n    }\n\n    // Calculate the sum of solid angles\n    float angleSum = 0.0;\n    for (int i = 0; i < NUM_VERT; i += 1) {\n        vec2 v0 = vertices[i] - uv;\n        vec2 v1 = vertices[(i + 1) % NUM_VERT] - uv;\n\n        float angle = signedAngle(v0, v1);\n        angleSum += angle;\n    }\n\n    // Check if the sum of angles is approximately 2 * PI\n    // bool insideAngle = abs(angleSum - 2.0 * 3.14) < 0.003186;\n    angleSum = abs(angleSum/(2.0*3.14));\n\n    // Color the pixel based on whether it's inside the polygon\n    fragColor = vec4(0.07, 0.414, 0.728, 1.0);\n    if(angleSum > 0.01)\n        fragColor = vec4(1.,0.756, 0.03,1.0);\n}","name":"Image","description":"","type":"image"}]}