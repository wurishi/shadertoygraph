{"ver":"0.1","info":{"id":"tsjczc","date":"1587118187","viewed":142,"name":"Voronoi Noise - Max","username":"MaxitoSama","description":"Trying to understand and replicate the voronoi noise form my TFG","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","voronoise","voronoinoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define octaves 8\n\n//Random Values between 0 & 1\nvec2 Random(vec2 c)\n{\n    //Non Correlated coords\n\tfloat x = fract(sin(dot(c ,vec2(12.9898,78.233))) * 43758.5453);\n    float y = fract(sin(dot(c+0.5 ,vec2(12.9898,78.233))) * 43758.5453);\n    \n\treturn vec2(x,y);\n}\n\nfloat PreNoise(vec2 fragCoord,float frequency)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv * 10.0*frequency;\n    \n    vec2 tile = floor(uv);\n    float centerDistance = 100.0;\n    float borderDistance = 100.0;\n    vec2 center = vec2(0.0);\n\n    \n    //Searching the distance to the nearest center\n    for(int i=-1; i<2 ; ++i)\n    {\n        for(int j=-1;j<2;++j)\n        {\n            vec2 tempTile=tile+vec2(i,j);\n            vec2 tempCenter = tempTile+Random(tempTile);\n            float tempDist = length(tempCenter-uv);\n            \n            if(tempDist<centerDistance)\n            {\n                centerDistance=tempDist;\n                center = tempCenter;\n            }\n        }\n    }\n    \n    return centerDistance;\n}\n\nfloat Test(vec2 fragCoord, float frequency) //https://www.shadertoy.com/view/Mld3Rn uses just one loop\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv * 10.0 * frequency;\n    \n    vec2 g = floor(uv), tile; uv -= g;\n\t\n\tvec3 d = vec3(10); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n            //Position\n\t\t\ttile = vec2(x, y);\n            \n            // Distance to random center\n            tile += Random(g + tile) - uv;\n            \n            //Absolute ditsnce\n\t\t\td.z = length(tile); \n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n\t\t}\n\t}\n\t\n    //return max(d.y/1.2 - d.x*1., 0.)/1.2;\n    return d.y - d.x; \n    //return 1.-d.x; // etc.\n}\n\nfloat Noise(vec2 fragCoord,float frequency)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv * 10.0*frequency;\n    \n    vec2 tile = floor(uv);\n    float centerDistance = 100.0;\n    float borderDistance = 100.0;\n    vec2 center = vec2(0.0);\n\n    \n    //Searching the distance to the nearest center\n    for(int i=-1; i<2 ; ++i)\n    {\n        for(int j=-1;j<2;++j)\n        {\n            vec2 tempTile=tile+vec2(i,j);\n            vec2 tempCenter = tempTile+Random(tempTile);\n            float tempDist = length(tempCenter-uv);\n            \n            if(tempDist<centerDistance)\n            {\n                centerDistance=tempDist;\n                center = tempCenter;\n            }\n        }\n    }\n    \n    //Searching the distance to the nearest border\n    for(int i=-1; i<2 ; ++i)\n    {\n        for(int j=-1;j<2;++j)\n        {\n            vec2 tempTile=tile+vec2(i,j);\n            vec2 tempCenter = tempTile+Random(tempTile);\n            \n            vec2 tempDist = tempCenter-uv;\n            vec2 closeDiff = center-uv;\n        \t\n            float check = length(tempCenter - center);\n            \n            if(check>0.0001)\n            {\n                vec2 toCenter = (closeDiff + tempDist)/2.0;\n                vec2 cellDiff = normalize(tempDist-closeDiff);\n                float edgeDistance = dot(toCenter,cellDiff);\n                \n                if(borderDistance>edgeDistance)\n                {\n                \tborderDistance=edgeDistance;\n                }\n            }\n        }\n    }\n            \n    return borderDistance;\n}\n\n//Accumulative noise\nvec3 Voronoi(vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    float a =0.5;\n    float f=1.0;\n    \n   \tfor(int i=0; i<octaves;i++)\n   \t{\n    \tcolor += a*Test(fragCoord,f);\n        a*=0.5;\n        f*=2.0;\n   \t}\n    \n    return color;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time varying pixel color\n    //vec3 col = vec3(Test(fragCoord,1.0));\n    vec3 col = Voronoi(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}