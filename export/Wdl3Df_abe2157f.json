{"ver":"0.1","info":{"id":"Wdl3Df","date":"1547685157","viewed":348,"name":"Montecarlo Path Tracer v1","username":"psicomante","description":"Simple Montecarlo Path Tracer with Ray Marched geometry via SDF.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by roberto pesando - psicomante/2018\n// URL: http://rbps.it\n// Twitter: @psicomante\n// Minimal Montecarlo Path Tracer with adjustable parameters.\n\n// Modify Subsamples and bounces.\n#define SUBSAMPLES 20\n#define BOUNCES 5\n\n// Internal\n#define MAXVALUE 100.\n#define EPSILON 0.0001\n#define MAX_DIST 100.\n#define MAX_MARCHING_STEPS 200\n\n#define INVPI 0.31830988618\n#define PI 3.1415926535897932384626433832795\n#define PID4 0.78539816339\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct Sphere {\n\tvec3 c;\n\tfloat r;\n\tvec3 color;\n};\n\nstruct Camera {\n\tvec3 o;\n\tvec3 f;\n};\n\nstruct RayHit {\n\tfloat t;\n\tvec3 point;\n\tvec3 normal;\n\tvec3 color;\n};\n\nvec2 seed;\nvec2 uv;\n\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 getSample(vec3 p,vec3 d) {\n\tvec3 unitSphereP = 2.*vec3(rand2n(), rand2n().x) - 1.;\n\n\treturn (p + d + normalize(unitSphereP)) - p;\n}\n\n/***\n * Signed Distance Functions\n */\nfloat planeSDF(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n/**\n * Signed distance function for a cube\n */\nfloat boxSDF(vec3 p, vec3 bb) {\n    vec3 d = abs(p) - bb;\n\treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\n/**\n * Signed distance function for a sphere with center and radius passed as struct\n */\nfloat sphereSDF(vec3 p, Sphere s) {\n    return length(p - s.c) - s.r;\n}\n\nfloat sceneSDF(vec3 p) {\n    float sp_a = sphereSDF(p, Sphere(vec3(0., 0., 0.), 0.28, vec3(1., 1., 1.)));\n    float box = boxSDF(p + vec3(0.,.3, 0.), vec3(0.5, 0.1, 0.5));\n\n    float obj = min(sp_a, box);\n    return obj;\n}\n\nfloat rayMarch(Ray r) {\n    float t = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(r.o + t * r.d);\n        if (dist < EPSILON) {\n\t\t\treturn t;\n        }\n        t += dist;\n        if (t >= MAX_DIST || i == MAX_MARCHING_STEPS - 1) {\n            return MAX_DIST;\n        }\n    }\n    return t;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getBackground(in vec3 direction) {\n    vec3 color = vec3(0.1, 0.7, 1.0);\n    \n    vec3 bgDirection = normalize(vec3(0., .0, -1.0));\n    float bgVal = max(0.0, dot(bgDirection, direction));\n    return mix(color, vec3(1.0, 1.0, 1.0), bgVal);\n}\n\nvec3 render(Ray r) {\n\t//vec3 luminance = (1.0 - sh)*vec3(1., 1., 1.) + sh*vec3(0.313, 0.647, 0.815);\n\tvec3 background = vec3(0.0);\n\tvec3 luminance = vec3(1.0);\n\n\tRayHit hit;\n\thit.t = MAXVALUE;\n\n\tbool h=false;\n\tfloat bounces=0.;\n\tvec3 hitPoint;\n\tvec3 normal;\n\n\tfor (int i = 0; i < BOUNCES; i++) {\n\t\tfloat d = rayMarch(r);\n\n\t\tif (d > MAX_DIST - EPSILON) {\n\t\t\tfloat sh = (r.d.y + 1.0)*0.5;\n\t\t\treturn getBackground(r.d)*luminance*(1.0 - sh)*vec3(1., 1., 1.) + sh*vec3(1., 1., 1.);\n\t\t}\n\n\t\thitPoint = r.o + d*r.d;\n\t\tnormal = estimateNormal(hitPoint);\n\t\t// secondary rays;\n\t\t// change origin and direction\n\t\tr.o = hitPoint + normal*EPSILON;\n\t\tr.d = normalize(getSample(r.o, normal));\n\n\t\tluminance *= 0.15;\n\t}\n\n\treturn luminance;\n}\n\n\n\nvoid demo(in vec2 fragCoord, inout vec4 fragColor, in vec2 u_resolution, in float u_time) {\n\tfloat ar = u_resolution.x/u_resolution.y;\n\tuv = fragCoord.xy / u_resolution * 2.0 - 1.0;\n\tuv.x*=ar;\n\tuv *= tan(PI/4.);\n\n\tvec2 pixelSize = 2. / u_resolution;\n\n\tseed = uv;\n\tseed *= cos(u_time) * 753.0;\n\n\t// camera def\n\tfloat cd = 1.; \t\t\n\tvec3 eye = vec3(0., 0., 2.);\n\teye = vec3(sin(u_time*.2)*cd, cos(PI/4.), cos(u_time*0.2)*cd);\n\tvec3 target = vec3(0.,0.,0.);\n\tvec3 up = vec3(0., 1., 0.);\n\n\tvec3 w = normalize(eye - target);\t// forward axis, positive z behind camera\n    vec3 u = normalize(cross(w, up));\t// left camera axis\n    vec3 v = normalize(cross(u,w));\t\t// up \n    mat4 cam2world = mat4(\n        vec4(u, 0.0),\n        vec4(v, 0.0),\n        vec4(-w, 0.0),\n        vec4(vec3(0.), 1.)     // the object coordinates and camera position are in world coordinates, don't need translation\n    );\n\n    vec4 p = vec4(uv + rand2n()*pixelSize,1.,1.0);   // Point in Image Plane, related to Camera Space\n    vec4 rayTarget = cam2world * p;\n\n    // primary ray\n    Ray pr = Ray(eye, normalize(rayTarget.xyz - eye));\n\n\tvec3 color = vec3(0.);\n\n\tfor (int i = 0; i < SUBSAMPLES; i++) {\n\t\tcolor += render(pr);\n\t}\n\n\tcolor /= float(SUBSAMPLES);\t\t// average the sample\n\tfragColor = vec4(color, 1.0);\t// output color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    demo(fragCoord, fragColor, iResolution.xy, iTime);\n}","name":"Image","description":"","type":"image"}]}