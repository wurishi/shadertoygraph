{"ver":"0.1","info":{"id":"M3l3WS","date":"1707899999","viewed":64,"name":"gene resync","username":"jyn","description":"playing with ladyhavoc's circle rendering: https://www.shadertoy.com/view/M3fGDB","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["art","doublehelix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 img = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    int passes = 6 + 1;\n    for( int i = 1; i < passes; i++ ) {\n        float iter = float(i) / float(passes);\n        uv -= vec2(iter * 0.5, 0.0) * (i % 2 == 0 ? 1.0 : -1.0);\n        img += texture(iChannel0, uv).rgb * (iter * 0.6);\n    }\n    \n    fragColor = vec4(vec3(img), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hacked anti-aliased circle by ladyhavoc\n// https://www.shadertoy.com/view/M3fGDB\nfloat LHCircle( vec2 uv, float r, float pixelate )\n{\n    float radius = iResolution.y * r / pixelate * r;\n    vec2 center = iResolution.xy * 0.5 / pixelate;\n    vec2 pos = floor(uv / pixelate + vec2(0.5));\n\n    // this calculates the horizontal and vertical pixel coverage\n    // using the core ideas of oldschool span rendering of circles,\n    // where the x range of a row is 1.0 - y*y, and conversely the y\n    // range of a column is 1.0 - x*x (both are equivalent methods of\n    // drawing a circle), it turns out that a lot of the math for\n    // relative pixel distance cancels out and becomes just a dot\n    // product however, i.e. we want the squared length of rel\n    vec2 rel = (pos - center);\n    // dot product will give us the squared length of rel, which is\n    // in the range 0..radius*radius, but we want 0..radius, so we\n    // divide by radius, which can look funny next to this 1+radius\n    // but is completely intentional, they are of the same magnitude\n    // due to the divide\n    float v = (1.0 + radius - dot(rel, rel) / radius);\n    // use 0.5 multiplier for radius when calculating the coverage,\n    // because we're measuring the whole pixel, not the pixel center\n    return clamp(v * 0.5, 0.0, 1.0);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    for( int k = 0; k < 2; k++ ) {\n        vec2 pos_j_start = vec2(-iResolution.x / 2.0, -iResolution.y / 2.0);\n        int num_instances = 7;\n        for( int j = 1; j < num_instances; j++ ) {\n            float iter_j = float(j) / float(num_instances - 1);\n            vec2 pos_j = pos_j_start;\n            pos_j += vec2(iter_j * (iResolution.x / 2.0), 0.0);\n            int num_circles = 32 + int((1.0 + 0.5 * sin(iTime * 1.0))  * float(j));\n            for( int i = 1; i < num_circles; i++ ) {\n                float iter = float(i) / float(num_circles);\n                vec2 pos = (uv * iResolution.xy)\n                    + vec2(cos(iTime * 0.5432) * 0.1,\n                        iter * iResolution.y)\n                    + vec2(-abs(sin(iTime * iter * 0.832)) * float(i) * 4.0, 0.0);\n                pos += vec2(abs(cos(iTime * 0.132\n                    * sin(iTime * 0.00002))\n                    * iResolution.y / 1.0),\n                    cos(sin(iTime * iter_j) * iTime * 128.0) * 2.0);\n                float circ = LHCircle(\n                  pos + pos_j,\n                  0.05 + iter * 0.1,\n                  1.0 + abs(sin(iTime * 0.23432) * sin(iTime * 0.342)) * 8.0);\n                col += (0.25 + iter_j * iter) * vec3(circ) * vec3(0.1 + float(k), iter_j, iter);\n            }\n        }\n        uv = vec2(1.0 - uv.x, uv.y);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}