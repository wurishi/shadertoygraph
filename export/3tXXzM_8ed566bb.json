{"ver":"0.1","info":{"id":"3tXXzM","date":"1562404780","viewed":905,"name":"Heightfield Slice Renderer","username":"TekF","description":"Quick and dirty heightfield renderer so I have a base I can use for testing terrain generation stuff. Sharing because it might be useful to others.","likes":21,"published":3,"flags":32,"usePreview":1,"tags":["heightfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float heightScale = .1;\nconst int numSlices = 200;\n#define WRAP 0\n#define PERSPECTIVE 0\nconst float cameraOrbitSpeed = .1; // radians per second\n\n// cheap and nasty lighting - can get better results by baking lighting in the height field\nconst vec3 lightDirection = vec3(1,1,1);\nconst vec3 lightTint = vec3(1);\nconst vec3 shadeTint = vec3(.1);\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCooord )\n{\n    float cameraOrbitTime = iTime*cameraOrbitSpeed;\n    vec3 cameraPosition = vec3(cos(cameraOrbitTime),0,sin(cameraOrbitTime))*2. + vec3(0,.8,0);\n    vec3 cameraTarget = vec3(0);\n    \n    vec3 cameraK = normalize(cameraTarget-cameraPosition);\n    vec3 cameraI = normalize(cross(vec3(0,1,0),cameraK));\n    vec3 cameraJ = cross(cameraK,cameraI);\n    \n    vec2 screenPosition = (fragCooord-iResolution.xy*.5)/iResolution.x;\n    #if (PERSPECTIVE)\n    \t// perspective\n    \tvec3 ray = vec3(screenPosition,1);\n    #else\n    \t// orthographic\n    \tvec3 ray = vec3(0,0,1);\n    \tcameraPosition += (cameraI*screenPosition.x + cameraJ*screenPosition.y) * 1.5;\n    #endif\n    \n    ray = ray.x*cameraI + ray.y*cameraJ + ray.z*cameraK;\n    ray = normalize(ray);\n\n    fragColour = vec4(.5);\n    \n    for ( int i=0; i < numSlices; i++ )\n    {\n        float f = numSlices > 1 ? float(i)/float(numSlices-1) : 0.5;\n        f = 1. - f; // from top to bottom!\n        \n        // intersect ray with horizontal plane at top of height field\n        vec3 position = cameraPosition + ray*((f-.5)*heightScale-cameraPosition.y)/ray.y;\n\n        vec2 uv = position.xz;\n\n        uv = uv*vec2(iResolution.y/iResolution.x,1)+.5;\n\n\t\t#if WRAP\n        \tvec4 tap = textureGrad(iChannel0,fract(uv),dFdx(uv),dFdy(uv)); // tile with corrected filtering\n        #else\n        \tvec4 tap = texture(iChannel0,uv);\n        \tif ( min(uv.x,uv.y) < 0. || max(uv.x,uv.y) > 1. ) tap.w = -1.;\n        #endif\n        \n        if ( tap.w > f )\n        {\n        \tfragColour = tap;\n\t\t    fragColour.rgb = pow(fragColour.rgb,vec3(2.2));\n            \n            // estimate dot product with surface normal\n            float sampleDistance = 1./iResolution.x;\n            vec3 lightDir = normalize(lightDirection);\n            \n            vec2 sampleOffset = vec2(0,sampleDistance);\n            vec2 positionX = position.xz + sampleOffset.yx;\n            vec2 positionZ = position.xz + sampleOffset.xy;\n            vec2 uvX = positionX;\n            uvX = uvX*vec2(iResolution.y/iResolution.x,1)+.5;  // todo: put this in a function\n            float heightX = textureGrad(iChannel0,fract(uvX),dFdx(uv),dFdy(uv)).w;\n            vec2 uvZ = positionZ;\n            uvZ = uvZ*vec2(iResolution.y/iResolution.x,1)+.5;\n            float heightZ = textureGrad(iChannel0,fract(uvZ),dFdx(uv),dFdy(uv)).w;\n            \n            float height = tap.w * heightScale;\n            heightX *= heightScale;\n            heightZ *= heightScale;\n            \n            // construct a 3D normal, I think ^ that 2D trick doesn't work\n            vec3 n = normalize(\n                \tcross( vec3(positionZ,heightZ).xzy - vec3(position.xz,height).xzy,\n                \t\t   vec3(positionX,heightX).xzy - vec3(position.xz,height).xzy )\n                );\n            \n            float light = max(0.,dot(n,lightDir));\n                          \n            fragColour.rgb *= mix( shadeTint, lightTint, light );\n            \n            break;\n        }\n    }\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = texture(iChannel0,fragCoord/iResolution.x).xyzy;\n    fragColour.rgb = mix( fragColour.rgb, vec3(1), .2 );\n}","name":"Buffer A","description":"","type":"buffer"}]}