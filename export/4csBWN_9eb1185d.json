{"ver":"0.1","info":{"id":"4csBWN","date":"1725299622","viewed":34,"name":"Cobra MK III","username":"Espeset","description":"Mostly Harmless","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["game","space","c64","metal","elite","3dmodel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int VERTEX_COUNT = 12, FACE_COUNT = 20;\nvec3 vertices[VERTEX_COUNT] = vec3[VERTEX_COUNT](vec3(0,15,0),vec3(16,-0.5,32.5),vec3(-16,-0.5,32.5),vec3(16,-15,-32.5),vec3(-16,-15,-32.5),vec3(-44,10,-32.5),vec3(-60,-3,-13),vec3(-65,-3,-32.5),vec3(44,10,-32.5),vec3(60,-3,-13),vec3(65,-3,-32.5),vec3(0,15,-32.5));\nconst int faces[] = int[](1,0,8,2,0,1,3,1,9,4,2,1,4,1,3,4,7,6,5,0,2,5,2,6,6,2,4,7,5,6,8,0,11,8,11,5,8,5,7,8,7,4,8,4,3,8,3,10,9,1,8,9,8,10,9,10,3,11,0,5);\n\nfloat intersectTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 n) {\n    vec3 e1 = v1 - v0, e2 = v2 - v0, p = cross(rd, e2), q = cross(ro - v0, e1);\n    float d = dot(e1, p), u = dot(ro - v0, p) / d, v = dot(rd, q) / d;\n    n = normalize(cross(e1, e2));\n    return (abs(d) < 1e-8 || u < 0. || u > 1. || v < 0. || u + v > 1.) ? -1. : dot(e2, q) / d;\n}\n\nfloat traceRay(vec3 ro, vec3 rd, out vec3 n) {\n    float minT = 1e4;\n    for(int i = 0; i < FACE_COUNT; i++) {\n        vec3 fn; float t = intersectTriangle(ro, rd, vertices[faces[i*3]], vertices[faces[i*3+1]], vertices[faces[i*3+2]], fn);\n        if(t > 0. && t < minT) { minT = t; n = fn; }\n    }\n    return minT;\n}\n\nvec3 reflect_random(vec3 I, vec3 N) {\n    return normalize(reflect(I, N) + (vec3(fract(sin(dot(gl_FragCoord.xy + vec2(12.9898, 78.233), vec2(12.9898, 78.233))) * 43758.5453), fract(sin(dot(gl_FragCoord.xy + vec2(93.9898, 67.345), vec2(67.345, 93.9898))) * 43758.5453), fract(sin(dot(gl_FragCoord.xy + vec2(54.1234, 32.6789), vec2(32.6789, 54.1234))) * 43758.5453)) - 0.5) * 0.08);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(sin(iTime*0.124)*50., cos(iTime*0.0534)*30., 170.+sin(iTime*0.2)*50.), rd = normalize(vec3(uv, -1));\n    float sy = sin(iTime * 0.5), cy = cos(iTime * 0.5), sx = sin(iTime * 0.3), cx = cos(iTime * 0.3);\n    for(int i = 0; i < VERTEX_COUNT; i++) { vec3 p = vertices[i]; p = vec3(cy * p.x + sy * p.z, p.y, -sy * p.x + cy * p.z); vertices[i] = vec3(p.x, cx * p.y - sx * p.z, sx * p.y + cx * p.z); }\n    vec3 normal; float t = traceRay(ro, rd, normal);\n    if(t < 1e4) fragColor = pow(texture(iChannel1, reflect_random(rd, normal)),vec4(2.5)); else fragColor=smoothstep(0.5,1.,texture(iChannel0, uv*mat2(cos(iTime*0.005), -sin(iTime*0.005), sin(iTime*0.005), cos(iTime*0.005)))) + vec4(sin(fragCoord.x + fragCoord.y + iTime*1.8)) * step(0.99, fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453));\n}","name":"Image","description":"","type":"image"}]}