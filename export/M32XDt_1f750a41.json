{"ver":"0.1","info":{"id":"M32XDt","date":"1711255880","viewed":59,"name":"particle_noise","username":"yufengjie","description":"particle noise position","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pix;\n\nfloat random(float v) {\n    return fract( sin(v) * 143758.5964);\n    //return fract(sin(v)*4563.1254);\n}\n\nfloat noise2(float v) {\n    float i = floor(v);\n    float f = fract(v);\n    float u = f * f * (3.0 - 2.0 * f );\n    return mix(random(i), random(i+1.), u);\n}\n\n// p屏幕坐标 c圆中心坐标 r半径\nfloat getCircle(vec2 p, vec2 c, float r) {\n    float dist = distance(c, p);\n    return smoothstep(r + 4. * pix, r, dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ixy = iResolution.x / iResolution.y;\n    pix = 1./iResolution.y; // 归一化的单位屏幕像素尺寸\n    vec3 fin_c = vec3(0.);\n    \n    float time = iTime;\n    float total = 30.;\n    for(float i=0.;i<total;i+=1.){\n        float px = (noise(i + 10. + time) * 0.8 + 0.1) * ixy;\n        float py = (noise(i + 20. + time)) * 0.8 + 0.1;\n        float pval = noise(i);\n\n        \n        vec3 color = palette(pval);\n        float r = pval * 10.*pix + 2.*pix;\n\n        float circle = getCircle(uv, vec2(px,py), r);\n        fin_c = mix(fin_c, color, circle);\n        //fin_c += circle * color;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(fin_c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 palette(float t) {\n  vec3 a = vec3(1.000,0.500,0.500);\n  vec3 b = vec3(0.500,0.500,0.500);\n  vec3 c = vec3(0.750,1.000,0.667);\n  vec3 d = vec3(0.800,1.000,0.333);\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n","name":"Common","description":"","type":"common"}]}