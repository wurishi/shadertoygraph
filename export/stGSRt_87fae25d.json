{"ver":"0.1","info":{"id":"stGSRt","date":"1641212625","viewed":46,"name":"Shader-Studies: Patterns","username":"LeyMB","description":"A simple shader I made as part of my studies to improve my shader knowledge. It combines several layers of subdividing/tiling the screen to create a moving pattern. Part of my practice of what I learned on the book of shaders: https://thebookofshaders.com","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many thanks to Patricio Gonzalez Vivo & Jen Lowe for their tutorials on thebookofshaders.com\n// Their website is an invaluable resource when starting out with learning shaders and has helped me greatly\n\n// DrawBox function taken from here: https://thebookofshaders.com/09/\nfloat DrawBox(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nvec3 DrawShape(vec2 fragCoord, int numCorners)\n{\n    float pi = 3.14159265358979;\n\n    float angle = atan(fragCoord.x, fragCoord.y) + pi;\n    float radius = 2.0 * pi/float(numCorners);\n\n    float dist = cos(floor(0.5 + angle / radius) * radius - angle) * length(fragCoord);\n\n    return vec3(1.0-smoothstep(.4,.41,dist));\n}\n\nvec2 MakeGrid(vec2 FragCoord, vec2 RowColumn, vec2 Resolution)\n{\n   vec2 st = gl_FragCoord.xy/Resolution;\n\n   st *= RowColumn;\n   st = fract(st);\n\n   return st;\n}\n\nvec2 rotate(vec2 Coord, float _angle){\n    Coord -= 0.5;\n    Coord =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * Coord;\n    Coord += 0.5;\n    return Coord;\n}\n\nvec3 DrawRect(vec2 fragCoord, vec2 width)\n{\n    // bottom-left\n    vec2 bl = step(width, fragCoord);\n    float pct = bl.x * bl.y;\n\n    // top-right\n    vec2 tr = step(width, 1.0 - fragCoord);\n    pct *= tr.x * tr.y;\n\n    return vec3(pct);\n}\n\nvec2 Tiling(vec2 FragCoord, float Zoom, float Offset, float RowOffset){\n    FragCoord *= Zoom;\n\n    // offsetting\n    FragCoord.x += step(1., mod(FragCoord.y, RowOffset)) * Offset;\n\n    return fract(FragCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 color = vec3(0.0);\n\n    vec2 st = MakeGrid(fragCoord, vec2(3.0), iResolution.xy);\n\n    // Tiling\n    vec2 Tile = Tiling(st, 5.0, cos(iTime), 2.0);\n    Tile = rotate(Tile, 3.14159265358979 * 0.25);\n    Tile = rotate(Tile, cos(iTime) * 3.14159265358979 * 0.25);\n\n    // draw tile box\n    color += vec3(DrawBox(Tile, vec2(0.9), 0.01)) * vec3(0.1, 0.1, 0.1);\n\n    // draw red squares\n    float AmountRotations = 0.25;\n    st = rotate(st, sin(iTime) * 3.14159265358979 * AmountRotations);\n\n    color += vec3(DrawBox(st,vec2(0.7),0.01)) * vec3(0.5, 0.0, 0.0);\n\n    // subdivide again\n    vec2 subdiv = MakeGrid(st, vec2(6.0), iResolution.xy);\n    subdiv = rotate(subdiv, -sin(iTime) * 3.14159265358979 * AmountRotations);\n    color += vec3(DrawBox(subdiv,vec2(0.7),0.01)) * vec3(0.0, 0.5, 0.0);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}