{"ver":"0.1","info":{"id":"McycRw","date":"1732046183","viewed":34,"name":"pen es","username":"jinx_fragment","description":"tutoriao","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 a = vec3(0.7,0.1,0.1);\n    vec3 b = vec3(0,1,0.5);\n    vec3 c = vec3(2,0.2,0.3);\n    vec3 d = vec3(0.31,0.73,0.666);\n    \n    //Multiplicar pelo aspect ratio da tela pra nao distorcer o efeito dependendo do tamanho da tela\n    //Trocar o range de (-0.5,0.5) pra (-1,1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //Salva ele localmente pra mexer nele depois\n    vec2 uv0 = uv;\n    \n    //Seta o codigo pra adicionar iteracoes depois\n    vec3 finalColor = vec3(0.0);\n    \n    //iterar várias vezes o cálculo\n    for (float i = 0.0; i< 3.0;i++){\n    \n        //Fractaliza tudo\n        uv = fract(uv);\n    \n        //Colocar o centro da tela no (0,0)\n        uv = uv - 0.5;\n    \n        //Muda o raio\n        //Graphtoy pra ver as funcoes\n        float decimal = length(uv) * exp(length(uv0));\n    \n        //Repete o padrão várias vezes, precisa dividir depois pra manter a forma original\n        //A variavel iTime pega o tempo de runtime\n        decimal = sin(decimal * 8.0 + iTime)/8.0;\n    \n        //Valores positivos saem pra fora e negativos entram pra dentro, ao fazer o abs você so pega os positivos\n        decimal = abs(decimal);\n        //decimal = -decimal;\n    \n        //Binariza o gradiente, valores menores ou maiores que 0.1 vão automaticamente pra 0\n        //decimal = step(0.1,decimal);\n    \n        //Também binariza valores menores e maiores, mas agora cria um gradiente nos valores intermediários\n        //decimal = smoothstep(0.0,0.1,decimal);\n    \n        //Como nossa range é de -1,1 , colocar 0.1 na binarização coloca mais valores no gradiente\n        //Valores maiores aumentam o brilho\n        decimal = 0.01/decimal;\n    \n        //Colocando cor\n        //vec3 col = vec3(uv,0.8);\n        //Colocar o i aqui aumenta a variação de cores com as iteracoes\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.8,a,b,c,d);\n    \n        finalColor += col * decimal;\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Função pré pronta\n//iquilezles.org/articles/palettes\n//dev.thi.ng/gradients\n    \n    vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) \n    {\n        return a + b*cos(6.28318*(c*t+d));\n    }","name":"Common","description":"","type":"common"}]}