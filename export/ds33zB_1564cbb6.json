{"ver":"0.1","info":{"id":"ds33zB","date":"1677457264","viewed":143,"name":"InfernalWashingMachine","username":"pb","description":"volumetric version of previous shader - more interesting eh?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tol = .31;\nvec3 ro;\n\n\nconst float an = .001;\nconst float cw = cos(an);\nconst float sw = sin(an);\n\n\nmat2 rot(float an) { float cc=cos(an),ss=sin(an); return mat2(cc,ss,-ss,cc); }\n\nfloat wheel(vec3 p) {\n    \n    \n    vec4 q = vec4(p , 15. );  \n    \n    \n    vec4 jc = q; \n    \n    float ww = 9.;\n    \n    \n    float i=0.;\n    float scale = 1.27;\n    \n    for (;i<11.;i++){\n        \n        if ( q.x > 1. )  q.x = 2. - q.x;\n        else if ( q.x < -1.) q.x = -2. - q.x;\n        \n        if ( q.y > 1. )  q.y = 2. - q.y;\n        else if ( q.y < -1.) q.y = -2. - q.y;\n        \n        if ( q.z > 1. )  q.z = 2. - q.z;\n        else if ( q.z < -1.) q.z = -2. - q.z;\n        \n        if ( q.w > 1. )  q.w = 2. - q.w;\n        else if ( q.w < -1.) q.w = -2. - q.w;\n        \n        float lz1 = length(q.xyz);\n  \n        float lzz1;\n        \n        float tt=iTime/4.;\n        \n        if ( lz1 < .66 ) { q.xyz *= 4.; ww *= 4.; q.xy = rot( tt )*q.xy; }\n        else if ( lz1 < 1.6) { q.xyz = q.xyz/(lzz1=lz1*lz1); ww *= lzz1; q.xy = rot(-tt)*q.xy; }\n       \n \n        q = scale * q + jc/2.;\n        \n        ww *= scale;\n    \n      \n    }\n    \n    return (length(q))/ ww;\n    \n\n}\n\n\nvec2 scene(vec3 p) {\n\n    return vec2(  max( wheel(p), -(length(p-ro)-1.48 ) ) ,  1.);\n}\n\n\nvec3 march( vec3 ro, vec3 rd) {\n\n    float dist = 1e6,  totDist=0.,  distFac=1.;\n    \n    vec3 p = ro;\n    \n    vec3 color = vec3(0);\n    \n    for (float i=0.; i<10.; i++) {\n    \n        dist = scene(p).x;\n  \n        p += dist * rd;\n        \n        totDist += dist;\n        \n        color += vec3( dist, dist*dist/2.,0.) * exp(-totDist/i);\n        \n    }\n    \n    return color; \n}\n\n\n\nvoid mainImage0( out vec4 O, in vec2 U )\n{\n\n    U = (2.*U - iResolution.xy) / iResolution.y *2.;\n    \n    vec3 rd = normalize( vec3(U, 5.) );\n    \n    \n    ro = vec3(0.,0., -3.98);\n    \n    vec3 color = march( ro, rd );\n    \n    \n    O = vec4( pow(color,vec3(.5)), 1);\n\n}\n\n\n//thanks Faabrice\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"}]}