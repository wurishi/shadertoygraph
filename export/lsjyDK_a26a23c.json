{"ver":"0.1","info":{"id":"lsjyDK","date":"1493903060","viewed":177,"name":"Testing Ray Marching","username":"AceClover","description":"From here: https://www.shadertoy.com/view/XsB3Rm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["testingraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct result{\n float dist;\n vec3 color;\n};\n\n// ray marching\nconst int max_iterations = 256;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat myTime;\n\nvec3 getColor(float _material){\n     \tif(_material == 0.0){\n         \treturn vec3(1, 0, 1);   \n        }\n        else  if(_material == 1.0){\n         \treturn  vec3(1, 1, 0);   \n        }\n        else if(_material == 2.0){\n         \treturn vec3(1, 0, 0);   \n        }\n        else if(_material == 3.0){\n         \treturn vec3(0, 1, 0);   \n        }\n        else if(_material == 4.0){\n         \treturn vec3(0, 0, 2);   \n        }\n       else if(_material == 5.0){\n         \treturn vec3(0.2, 1, 0.5);   \n        }\n    \n    return vec3(0);\n}\n\n\n// iq's distance function\nresult sdSphere( vec3 pos, float r, float _m ) {\n\treturn result( length( pos ) - r, getColor(_m)) ;\n}\n\nresult sdBox( vec3 p, vec3 b, float _m ) {\n  vec3 d = abs(p) - b;\n  return result(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), getColor(_m));\n}\n\n\n\nresult minWithMaterial(float _d1, float _m1, float _d2, float _m2){\n    if(_d1 < _d2){\n     return result(_d1, getColor(_m1));   \n    }\n    return result(_d1, getColor(_m2));\n}\n   \n    \nresult minWithMaterial(vec2 _o1, vec2 _o2){\n    return minWithMaterial(_o1.x, _o1.y, _o2.x, _o2.y);\n}\n\nresult minWithMaterial(float _d1, float _m1, vec2 _o2){\n    return minWithMaterial(_d1, _m1, _o2.x, _o2.y);\n}\n\nresult minWithMaterial(vec2 _o1, float _d2, float _m2){\n    return minWithMaterial(_o1.x, _o1.y, _d2, _m2);\n}\n\nresult minWithMaterial(result a, result b){\n    if(a.dist < b.dist){\n        return a;\n    }\n    return b;\n}\n\n\n\nfloat k = 10.0;\nresult smin( float _d1, float _m1, float _d2, float _m2, bool blend)\n{\n    float res = exp( -k*_d1 ) + exp( -k*_d2 );\n    float d = -log( res )/k;\n    return result(d, abs(_d1-d) > abs(_d2-d) ? getColor(_m2) : getColor(_m1));\n}\n\nresult smin( vec2 a, vec2 b, bool blend )\n{\n    return smin(a.x, a.y,b.x, b.y, blend);\n}\n\nresult smin( vec2 a, float b, float _m2, bool blend )\n{\n    return smin(a.x, a.y,b, _m2, blend);\n}\n\nresult smin( float a, float _m1, vec2 b, bool blend )\n{\n    return smin(a, _m1,b.x, b.y, blend);\n}\n\nresult smin(result a, result b, bool blend){   \n    \n    float res = exp( -k*a.dist ) + exp( -k*b.dist );\n    float d = -log( res )/k;    \n    vec3 color;\n    \n    if( abs(a.dist-d) > abs(b.dist-d) ){\n    \t color =  (a.color*(1.0-a.dist/(a.dist + b.dist))) + (b.color*(a.dist/(a.dist + b.dist)));    \n    }\n    else{ \n        color =  (b.color*(1.0-b.dist/(a.dist + b.dist))) + (a.color*(b.dist/(a.dist + b.dist)));    \n    }\n    \n    if(blend){ \n        return result(d, color);    \n    }\n    else{\n        return result(d, abs(a.dist-d) > abs(b.dist-d) ? b.color :a.color);    \n    }\n}\n\nresult smin(result a, result b){ \n    return smin(a,b,false);  \n}\n\nresult myMax( float _d1, float _m1, float _d2, float _m2 )\n{\n    if(_d1 > _d2){\n        return result(_d1, getColor(_m1));\n    }\n    return result(_d2, getColor(_m2));\n}\n\nresult myMax( vec2 a, vec2 b )\n{    \n    return myMax(a.x, a.y, b.x, b.y);\n}\n\nresult myMax( vec2 a, float b, float _m2 )\n{\n    return myMax(a.x, a.y,b, _m2);\n}\n\nresult myMax( float a, float _m1, vec2 b )\n{\n    return myMax(a, _m1,b.x, b.y);\n}\n\nresult myMax(result a, result b){   \n    if(a.dist > b.dist)\n \t\treturn  result(a.dist, (a.color*(1.0-a.dist/(a.dist + b.dist))) + (b.color*(a.dist/(a.dist + b.dist))));\n    return  result(b.dist, (b.color*(1.0-b.dist/(a.dist + b.dist))) + (a.color*(b.dist/(a.dist + b.dist))));    \n}\n\n// get distance in the world\nresult dist_field( vec3 pos ) {\n        \n    result box = sdBox( pos, vec3(0.5) + sin(myTime*2.0)/35.0, 4.0);    \n    box = myMax( box.dist, 4.0, -sdSphere( pos, 0.6, 0.0).dist +  cos(myTime*3.0)/35.0, 4.0 );\n    \n    result sphereInside = sdSphere( pos + vec3( sin(myTime*4.0) ,0.0,0.0), 0.25 ,1.0) ;    \n    \n    result boxVerticalInside =  sdBox( pos + vec3(0.0, cos(myTime*4.0),0.0), vec3(0.25),2.0) ;\n    boxVerticalInside = minWithMaterial(boxVerticalInside,sdSphere( pos + vec3(0.0, cos(myTime*4.0),0.0), 0.3 + sin(myTime*5.0)*0.015 ,3.0));    \n    \n    result boxHorizontalLoop =  sdBox( pos + vec3(cos(myTime*4.0),0.0, sin(myTime*4.0)), vec3(0.25) ,3.0) ;\n   \n    \n    boxHorizontalLoop = myMax(boxHorizontalLoop.dist,boxHorizontalLoop.color.x, -sdSphere( pos + vec3(cos(myTime*4.0),0.0, sin(myTime*4.0)), 0.3 + sin(myTime*5.0)*0.015, 0.3 ).dist, 0.3);        \n            \n    result sphereVerticalLoop =  sdBox( pos + vec3(0.0, sin(myTime*4.0), cos(myTime*4.0)), vec3(0.25) ,4.0) ;\n    sphereVerticalLoop = myMax(sphereVerticalLoop.dist, 5.0, sdSphere( pos + vec3(0.0, sin(myTime*4.0), cos(myTime*4.0)), 0.3 + sin(myTime*5.0)*0.015, 0.3 ).dist, 0.3);    \n  \n    \n  \treturn smin(box, smin(sphereInside, smin(boxVerticalInside, smin(boxHorizontalLoop,sphereVerticalLoop))));\n\n    //return minWithMaterial(box, minWithMaterial(sphereInside, minWithMaterial(boxVerticalInside, minWithMaterial(boxHorizontalLoop,sphereVerticalLoop))));\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ).dist - dist_field( pos - dx ).dist,\n\t\t\tdist_field( pos + dy ).dist - dist_field( pos - dy ).dist,\n\t\t\tdist_field( pos + dz ).dist - dist_field( pos - dz ).dist\t\t\t\n\t\t)\n\t);\n}\n\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 _material ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \t\t\n\t\tfinal +=  (_material*0.5) + light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n\n// ray marching\nresult ray_marching( vec3 origin, vec3 dir, float start, float end ) {    \t\n    float depth = start;  \n\tfor ( int i = 0; i < max_iterations; i++ ) {        \n        vec3 p = origin + dir * depth;        \n        \n        result evaluate = dist_field( p );        \n        \n\t\tfloat dist =evaluate.dist / length( gradient( p ) );\n        \n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn result(depth, evaluate.color);\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn result(end, evaluate.color);\n\t\t}\n\t\t\n\t}\n\n\treturn result(end, getColor(-1.0));\n}\n\n\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n        myTime = iTime/2.0;\n    \n        \n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 +sin(myTime) *0.0 );\n    \n    \n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n    \n    // ray marching\n\tresult depth = ray_marching( eye, dir, 0.0, clip_far );          \n    \n\tif (  depth.dist >= clip_far ) {\n\t\tfragColor = vec4( 0.3, 0.4, 0.5, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth.dist;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye, depth.color ), 1.0 );\n    \n}","name":"Image","description":"","type":"image"}]}