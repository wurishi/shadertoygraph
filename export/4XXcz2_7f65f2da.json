{"ver":"0.1","info":{"id":"4XXcz2","date":"1726509010","viewed":41,"name":"Disgusting SDF worm","username":"stevegamer","description":"Made using sdf, tried to make it scary using textures.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sdf","metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nconst float shape_tolerance = 1.0; // (0; inf) how smooth will shape transition be\nconst float color_mix_sharpness = 10.; // (1; inf) how sharp will color transition\nconst float trefoil_size = 6.0; // how big the whole thing is\nconst float radius = 0.5;\n\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n\nconst int n_spheres = 24;\nsphere spheres[n_spheres] = sphere[](\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0))\n);\n\nconst bool metal_reflection = false;\n\n\nstruct light{\n    vec3 position;\n    float strength;\n    vec3 color;\n};\n\nconst int n_lights = 1;\nlight lights[n_lights] = light[](\n    light(vec3(0, 0, -100.0), 10000.0, vec3(1, 1, 1))\n);\n\nvec3 grad(in vec3 point, in float delta);\n\nfloat sphere_sdf(in vec3 point, in vec3 center, in float radius) {\n    return length(point - center) - radius;\n}\n\n// Color weight field - determines how much of a shape's color should be used.\nfloat sphere_cwf(in vec3 point, in vec3 center, in float radius) {\n    return pow(color_mix_sharpness, radius - (length(point - center)));\n}\n\nfloat sdf(in vec3 point) {\n    float sum = 0.0;\n    for (int i = 0; i < n_spheres; ++i) {\n        float dist = sphere_sdf(point, spheres[i].center, spheres[i].radius);\n        sum += exp2(-dist / shape_tolerance);\n    }\n    return -shape_tolerance * log2(sum);\n}\n\nvec3 get_sphere_texture_color(in sphere sph, in vec3 point) {\n    point -= sph.center + vec3(2.0);\n    point /= 20.0;\n    vec3 normal = normalize(abs(point * 20.0 + vec3(2.0)));\n    vec3 result = normal.x * texture(iChannel0, point.yz).rgb +\n    normal.y * texture(iChannel0, point.xz).rgb +\n    normal.z * texture(iChannel0, point.xy).rgb;\n    return result * 1.5;\n}\n\nvec3 base_color(in vec3 point) {\n    vec3 color_num = vec3(0, 0, 0);\n    vec3 color_denom = vec3(0, 0, 0);\n    for (int i = 0; i < n_spheres; ++i) {\n        float cwf = sphere_cwf(point, spheres[i].center, spheres[i].radius);\n        color_num += get_sphere_texture_color(spheres[i], point) * cwf;\n        color_denom += cwf;\n    }\n    return color_num / color_denom;\n}\n\nbool traceRay(in vec3 ray, in vec3 pos, out vec3 impact_point) {\n    while (true) {\n        float dist = abs(sdf(pos));\n    \n        if (dist < 0.01) {\n            impact_point = pos;\n            return true;\n        }\n        \n        if (dist > 100.0) {\n            return false;\n        }\n        \n        pos += ray * dist;\n    }\n}\n\nvec3 grad(in vec3 point, in float delta) {\n    vec3 dx = vec3(delta, 0, 0);\n    vec3 dy = vec3(0, delta, 0);\n    vec3 dz = vec3(0, 0, delta);\n    float y0 = sdf(point);\n    return (vec3(sdf(point+dx), sdf(point+dy), sdf(point+dz)) - vec3(y0, y0, y0)) / delta;\n}\n\n\nvec3 diffuse(in vec3 point, in vec3 base_color) {\n    vec3 normal = normalize(grad(point, 0.0001));\n    vec3 result = vec3(0, 0, 0);\n    \n    for (int i = 0; i < n_lights; ++i) {\n        vec3 lightray = lights[i].position - point;\n        float intensity = lights[i].strength / pow(length(lightray), 2.0);\n        result += max(dot(normal, normalize(lightray)), 0.0) * intensity * lights[i].color;\n    }\n    result *= base_color;\n    return result;\n}\n\nvec3 specular(in vec3 eye, in vec3 point, in vec3 base_color) {\n    vec3 normal = normalize(grad(point, 0.0001));\n    vec3 eye_ray = normalize(eye - point);\n    vec3 result = vec3(0, 0, 0);\n    \n    for (int i = 0; i < n_lights; ++i) {\n        vec3 lightray_refl = -reflect(lights[i].position - point, normal);\n        float intensity = lights[i].strength / pow(length(lightray_refl), 2.0);\n        float powered = pow(max(dot(eye_ray, normalize(lightray_refl)), 0.0), 20.0);\n        result += powered * intensity * lights[i].color;\n    }\n    \n    if (metal_reflection) {\n        result *= base_color;\n    }\n    return result;\n}\n\nvoid positionSpheres() {\n    for (int i = 0; i < n_spheres; ++i) {\n        //float t = iTime + PI * float(i) / float(n_spheres);\n        float t = iTime + PI * float(i) / float(n_spheres);\n        spheres[i].center = vec3(trefoil_size * cos(3.0 * t) * sin(t) + sin(2.0 * t) * 0.2,\n                                 trefoil_size * cos(3.0 * t) * cos(t) + sin(t) * 0.2,\n                                 36.0 + 30.0 * sin(t * 0.5 + PI / 4.));\n    }\n}\n\nvec3 skybox_color(in vec3 direction) {\n    return texture(iChannel1, direction).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    positionSpheres();\n\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    vec3 camera = vec3(0, 0, -1);\n    vec3 ray = normalize(vec3(uv, 0) - camera);\n    vec3 surface_point;\n    vec3 color;\n    if (traceRay(ray, camera, surface_point)) {\n        vec3 base = base_color(surface_point);\n        vec3 normal = normalize(grad(surface_point, 0.0001));\n        vec3 skyray = reflect(ray, normal);\n        color = specular(camera, surface_point, base) + diffuse(surface_point, base);\n    } else {\n        color = skybox_color(ray);\n    }\n    \n    fragColor = vec4(color ,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// code stolen from here: https://www.shadertoy.com/view/lsf3WH\n\n// 0: integer hash\n// 1: float hash (aliasing based) (don't do this unless you live in the year 2013)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n#endif\n\nfloat noise( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    #if METHOD==0\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n    #else\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n    #endif\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p;\n\t\n\tfloat f = 0.0;\n\n    uv *= 8.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\n\tf = 0.5 + 0.5*f;\n\t\t\n\t\n\tfragColor = vec4( f*0.6, f*0.6, 0., 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float base = 1. - max(0., dot(rayDir, vec3(0., 0., 1.)));\n    float dist = sqrt(dot(rayDir.xy, rayDir.xy));\n    float veins = sin(atan(rayDir.y / rayDir.x) * 14. + 0.4 * sin(40.0 * dist + 3.5 * iTime));\n    veins = max(0., veins);\n    \n    float col = base * veins;\n    \n    fragColor = vec4(0.15, 0.05, 0., 1.0) + vec4(col, col / 7.0, 0., 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}