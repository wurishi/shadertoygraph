{"ver":"0.1","info":{"id":"lcj3z3","date":"1705356542","viewed":33,"name":"Semiconductor","username":"Chromaney","description":"An attempt at learning different raymarching techniques. Some intended effects had to be cut to keep FPS reasonable.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader \"Semiconductor\" by Chromaney.\n// Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An attempt at learning different raymarching techniques.\n// Some intended effects had to be cut to keep FPS reasonable.\n\n// Change VIEW_SCALE values (0+ to 1 floats) to make render area smaller for performance concerns.\n\n#define VIEW_SCALE vec2(1.0, 1.0)\n\n#define M_PI 3.1415926536\n\n#define RM_MAX_ITER 100\n#define RM_MAX_DIST 40.0\n#define RM_PROX_DIST 0.001\n#define RM_SURF_EPS 0.7\n\n#define NORM_COORD_STEP 0.001\n#define NORM_COORD_STEP_VEC vec3(NORM_COORD_STEP, 0.0, 0.0)\n\n#define FOG_COLOR vec3(0.5, 0.7, 0.7)\n#define LIGHT_DIR vec3(0.0, 1.0, 0.0)\n// ^ already normalized\n\n#define LATTICE_STEP vec3(5.0, 15.0, 5.0)\n#define LATTICE_BASE_DIST min(LATTICE_STEP.x, min(LATTICE_STEP.y, LATTICE_STEP.z))\n#define ITEM_BASE_SIZE (0.25 * LATTICE_BASE_DIST)\n// ^ should account for all shapes with rotation\n\n#define ROT_MTX(ang) mat2(cos(ang), -sin(ang), sin(ang), cos(ang))\n// ^ applied from right\n\nfloat sphereShellSDF(vec3 pos, vec2 r){\n    // centered on vec3(0.0)\n    return (abs(length(pos) - r.x) - r.y);\n}\n\nfloat octahedronSDF(vec3 pos, float a){ // approximation\n    // centered on vec3(0.0)\n    pos = abs(pos);\n    return ((pos.x + pos.y + pos.z - a) * 0.57735027);\n}\n\nvec2 sceneDistField(vec3 pos){\n    // returns vec2(distance_to_scene, object_type)\n    \n    vec3 latticeBlock = floor(pos / LATTICE_STEP);\n    vec2 res = vec2(1.0e6, -0.5);\n    \n    // can't reduce the amount of checked blocks because of asymmetries between them\n    vec3 blockMiddle = (latticeBlock + 0.5) * LATTICE_STEP;\n    for (float idX = -1.0; idX < 1.5; idX += 1.0){\n        for (float idZ = -1.0; idZ < 1.5; idZ += 1.0){\n            vec3 blockShift = vec3(idX, 0, idZ);\n            vec2 curBlockXZ = latticeBlock.xz + blockShift.xz;\n            float curBlockXZSum = curBlockXZ.x + curBlockXZ.y + 0.5;\n            float objType = mod(curBlockXZSum, 2.0);\n            float mvtDir = objType * 2.0 - 2.0;\n            float wrapPosYShift = mvtDir * fract(\n                iTime * (mod(curBlockXZSum, 4.0) / 4.0) / LATTICE_STEP.y + \n                curBlockXZ.x / 3.0) * LATTICE_STEP.y;\n            // ^ mod part can't be zero since sampled only at integer points\n            vec3 wrapPos = pos - blockMiddle - blockShift * LATTICE_STEP;\n            wrapPos.zx *= ROT_MTX(curBlockXZ.x - curBlockXZ.y + mvtDir * iTime);\n            for (float dY = -LATTICE_STEP.y; dY < 1.5 * LATTICE_STEP.y; dY += LATTICE_STEP.y){\n                wrapPos.y = pos.y + wrapPosYShift - blockMiddle.y - dY;\n                // ^ trying to replace with \"wrapPos.y += LATTICE_STEP.y\" causes octahedrons to disappear\n\n                float dist;\n                if (objType < 1.0){ // cut sphere\n                    float mainSphereDist = sphereShellSDF(wrapPos, ITEM_BASE_SIZE * vec2(1.0, 0.15));\n                    float cutSphereDist = sphereShellSDF(\n                        abs(wrapPos) - 0.95 * vec3(1.0, 1.0, 1.0) * ITEM_BASE_SIZE, \n                        ITEM_BASE_SIZE * vec2(1.0, 0.1));\n                    dist = max(mainSphereDist, -cutSphereDist);\n                } else { // octahedron\n                    dist = octahedronSDF(wrapPos, ITEM_BASE_SIZE * 1.75);\n                } // no empty blocks\n\n                if (dist < res.x){\n                    res.x = dist;\n                    res.y = objType;\n                }\n            }\n        }\n    }\n    \n    return res;\n}\n\nvec3 sceneNorm(vec3 pos){\n    float sdfShX = sceneDistField(pos + NORM_COORD_STEP_VEC.xzy).x;\n    float sdfShY = sceneDistField(pos + NORM_COORD_STEP_VEC.yxz).x;\n    float sdfShZ = sceneDistField(pos + NORM_COORD_STEP_VEC.zyx).x;\n    return normalize(vec3(sdfShX, sdfShY, sdfShZ) - sceneDistField(pos).x);\n}\n\nvec4 rayMarch(vec3 origin, vec3 dir){\n    float dist = 0.0;\n    float objType = -0.5;\n    \n    for (int iter = 0; iter < RM_MAX_ITER; iter ++){\n        vec3 pos = origin + dir * dist;\n        vec2 sceneDistFieldRes = sceneDistField(pos);\n        float curStep = sceneDistFieldRes.x;\n        dist += curStep;\n        objType = sceneDistFieldRes.y;\n        if (abs(curStep) < RM_PROX_DIST){\n            break;\n        }\n        if (dist > RM_MAX_DIST){\n            break;\n        }\n    }\n    \n    vec3 pos = origin + dir * dist;\n    \n    vec3 curSceneNorm = sceneNorm(pos);\n    float diffLightVal = max(curSceneNorm.y, 0.0); // simplified from dot(curSceneNorm, LIGHT_DIR)\n    vec3 halfway = normalize(LIGHT_DIR + (origin - pos));\n    float surfColorCoeff = dot(curSceneNorm, dir);\n    // ^ technically, should be -dir, but is squared later\n    surfColorCoeff *= surfColorCoeff;\n    \n    float reflLightVal = 0.0;\n    vec3 baseCol = vec3(0.6, 0.2, 1.0); // default for cubes\n    \n    if (objType < 0.0){\n        // infinity / object not reached (infinity picks up properties as well, so needs fog now)\n        diffLightVal = 1.0;\n        baseCol = FOG_COLOR;\n    } else if (objType < 1.0){ // cut sphere\n        reflLightVal = pow(max(dot(halfway, curSceneNorm), 0.0), 200.0);\n        baseCol = vec3(1.0, 0.1 + 0.5 * surfColorCoeff, 0.1); // shortened from mix\n    } else { // octahedron\n        reflLightVal = pow(max(dot(halfway, curSceneNorm), 0.0), 10.0);\n    } // no empty blocks\n    reflLightVal *= clamp(diffLightVal / 0.2, 0.0, 1.0);\n    \n    diffLightVal = diffLightVal * 0.75 + 0.25; // so that bottom surfaces also have color\n    vec3 col = FOG_COLOR * baseCol * (diffLightVal + reflLightVal);\n    // ^ fog color acts as light color as well\n    \n    return vec4(col, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uvExtent = 0.5 * VIEW_SCALE * iResolution.xy / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    if ((abs(uv.x) < uvExtent.x) && (abs(uv.y) < uvExtent.y)){\n        uv /= min(VIEW_SCALE.x, VIEW_SCALE.y);\n        \n        vec2 mousePos = iMouse.xy;\n        if (iMouse.z == 0.0){\n            mousePos = vec2(0.5, 0.5) * iResolution.xy;\n        }\n        mat2 rotXZ = ROT_MTX((mousePos.x / iResolution.x * 2.0 - 1.0) * M_PI);\n        mat2 rotYZ = ROT_MTX((mousePos.y / iResolution.y * 1.0 - 0.5) * M_PI);\n\n        vec3 camPos = vec3(0.0, 0.0, -5.0);\n        camPos.yz *= rotYZ;\n        camPos.xz *= rotXZ;\n        vec3 rayDir = normalize(vec3(uv, 1.0));\n        rayDir.yz *= rotYZ;\n        rayDir.xz *= rotXZ;\n\n        vec4 rmRes = rayMarch(camPos, rayDir);\n        col = rmRes.xyz;\n\n        float normDist = min(rmRes.w / RM_MAX_DIST, 1.0);\n        normDist = 1.0 - exp(-normDist * (RM_MAX_DIST / 10.0));\n        col = mix(col, FOG_COLOR, normDist);\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}