{"ver":"0.1","info":{"id":"ddjSRm","date":"1670099430","viewed":223,"name":"conservation of energy","username":"Carandiru","description":"a demonstration of the conservation of energy.\nhttps://www.feynmanlectures.caltech.edu/fml.html","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["automata","cellular","physics","energy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// a demonstration of the conservation of energy.\n//\n// Feynman Lectures (Inspiring Teacher):\n// https://www.feynmanlectures.caltech.edu/fml.html\n//\n//\n\n\n\n\n// boxmapping / triplanar projection - https://www.shadertoy.com/view/MtsGWH - iq\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat map( in vec3 p )\n{\n    return length(p-vec3(0.0,1.0,0.0))-1.0;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// quality stars\n#define scale (0.72)\n#define star_maximum_luminance (10000.0)\n#define distance_maximum_out (150.0)\n\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\nuvec3 murmur3( in uvec3 u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\nvec3 unorm(uvec3 n) { return(fract(vec3(n) * (1.0 / float(0xffffffffU)))); }\n\nvec3 hash33(in vec3 m) \n{\n    uvec3 mu = floatBitsToUint(m * GOLDEN_RATIO) | 0x1u;\n\n    mu = murmur3(mu);\n\n    return(1.0f - unorm(mu));\n}\n\nfloat rand(in vec3 st) {\n  vec3 r = hash33(st) * GOLDEN_RATIO_ZERO;\n  return fract(r.z * 111.111111 * 111.111111 + r.y * 111.111111 + r.x);\n}\n\nfloat pixel_stars(in vec3 st, in float t) {\n  float r = rand(round(st));\n  return 0.000001 + smoothstep(0.995*t, 1.0, r);\n}\n\nfloat stars(in vec3 st, in float t) {\n  return(pixel_stars(st, t));\n}\n\nfloat background(vec3 dir, float d)\n{\n    d = 1.0f / (1.0f + d*d);\n    \n    float den = abs(dir.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n    \n    float n = stars(scale * (dir*(1.0 - d)*iResolution.y), 1.0f - den);\n    \n\t\n\treturn d * star_maximum_luminance * pow(n*0.95f+den,22.0);\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // camera movement\t\n        float an = 0.2*iTime;\n        vec3 ro = vec3( 2.5*sin(an), 2.0, 2.5*cos(an) );\n        vec3 ta = vec3( 0.0, 1.0, 0.0 );\n        \n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        \n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 1.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float h = map(pos);\n            if( h<0.001 ) break;\n            t += h;\n            if( t>tmax ) break;\n        }\n        \n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + rd*t;\n            vec3 nor = calcNormal( pos, 0.001 );\n            float occ = clamp(0.4 + 0.6*nor.y, 0.0, 1.0);\n            col = boxmap( iChannel0, 0.5*pos, nor, 3.0 ).xyz;\n\n            float light = exp(-col.z);\n           \n            col = col*col;       \n            col *= occ;\n            \n            col = col + col * ((col * (1.0f - occ))*10000.0f) * light;\n            \n        }\n        else {\n            col = vec3(background(rd, distance_maximum_out + length(rd * t)));\n        }\n        \n        // to gamma space\n        col = sqrt( col );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    float dither = textureLod(iChannel1, fragCoord.xy / 1024.0f, 0.0).r;\n    \n    tot = tot + dither / 17.0f;\n    \n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// a demonstration of the conversation of energy.\n//\n// Feynman Lectures (Inspiring Teacher):\n// https://www.feynmanlectures.caltech.edu/fml.html\n//\n//\n\n\n#define kinetic x\n#define thermal y\n#define light z\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 src = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 0)).rgb;\n\n    uv += vec2(cos(iTime), -1.0f) * 2.0f * src.kinetic * (4.0f * abs(cos(src.thermal * 2.0f * PI) + sin(src.light * 2.0f * PI)) / length(iResolution.xy));\n    \n    vec3 t = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).rgb;\n    vec3 b = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0,-1)).rgb;\n    vec3 l = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0)).rgb;\n    vec3 r = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 0)).rgb;\n    \n    vec4 variants = vec4(hash12(uv, VARIANT_0), hash12(uv, VARIANT_1), hash12(uv, VARIANT_2), hash12(uv, VARIANT_3));\n\n    vec3 energy = vec3(0);\n    \n    energy.kinetic += t.kinetic * variants.x * 0.25f;\n    energy.kinetic += b.kinetic * variants.y * 0.25f;\n    energy.kinetic += l.kinetic * variants.z * 0.25f;\n    energy.kinetic += r.kinetic * variants.w * 0.25f;\n    \n    float variant_average = (variants.x + variants.y + variants.z + variants.w) * 0.25f;\n    \n    // kinetic loss & gain //\n    src.kinetic = src.kinetic * variant_average + energy.kinetic;  \n    \n    src.thermal = src.thermal * variant_average + max(0.0f, src.kinetic - 1.0f); // kinetic excess --> thermal\n    src.light   = src.light   * variant_average + max(0.0f, src.thermal - 1.0f); // thermal excess --> light\n    src.kinetic = src.kinetic + max(0.0f, src.light - 1.0f);                     // light excess --> kinetic\n    \n    src = clamp(src, 0.0f, 1.0f); // clamp output after energy is distributed\n    \n    vec3 color;\n\n    color = src;\n    \n    if (iFrame < 4) {\n        color = textureLod(iChannel1, uv, 0.0f).rgb;\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define HASH_SEED (0xC211F3DDu)\n#define PI (3.14159265358979323846)\n#define VARIANT_SRC 0.5f\n\n#define VARIANT_0 0.01f\n#define VARIANT_1 0.49f\n#define VARIANT_2 0.51f\n#define VARIANT_3 0.99f\n\nuint baseHash(in uvec2 p, in uint variant)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = variant * HASH_SEED + p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(in vec2 x, in float variant)  // 0 ... 1 in, 0 ... 1 out\n{\n    uint n = baseHash(uvec2(x * float(0xffffffffU)), uint(variant * float(0xffff)));\n    return float(n)*(1.0/float(0xffffffffU));\n}","name":"Common","description":"","type":"common"}]}