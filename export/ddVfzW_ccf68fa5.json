{"ver":"0.1","info":{"id":"ddVfzW","date":"1698004923","viewed":37,"name":"Interpolation Across a Plane","username":"BinoAl","description":"Proof-of-concept for a heatmap renderer that won't drive me into a fit of pedantry; Details are in the code comments for the curious.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","temperature","heatmap","gis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Heatmaps are constantly misapplied; The data being used is almost always treated as a \"heat source\",\n//  where everything fades back to the neutral color further from data points. In some cases, IE those\n//  based on visualizing frequency of finite incidences, this is perfectly okay. However, in others,\n//  such as my use-case of creating building floorplans with temperatures overlaid on top, this is\n//  utter nonsense. If every data point is a sample across a continous field, then you need to\n//  interpolate values for it to have any meaning whatsoever. Otherwise, you end up with cases like\n//  a field of high temperatures at every sensor, where temperatures allegedly go back to normal between\n//  each heat source.\n\n//This is only an example of the interpolation between three points; In practice, this would be applied\n//  to individual triangles, constructed using Delaunay triangulation.\n\n//Some lightly modified code taken from Stack Overflow to quickly see if a point is within a triangle, since\n//  I evidently slept through geometry\n//https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\nfloat pSign(vec2 uv, vec3 p1, vec3 p2)\n{\n    return (uv.x - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (uv.y - p2.y);\n}\n\nbool pointInTriangle(vec2 uv, vec3 v1, vec3 v2, vec3 v3)\n{\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n\n    d1 = pSign(uv, v1, v2);\n    d2 = pSign(uv, v2, v3);\n    d3 = pSign(uv, v3, v1);\n\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\n//Take the average of each point's temp (Scaled to 0-1) and weight it based on proximity to the source of the reading\n//Probably not being done in the ideal way at the moment?\n//Need to tinker more in another environment to validate against data, instead of eyeballing colors\nfloat scaledTempAtPt(vec2 uv, vec3 pt1, vec3 pt2, vec3 pt3) {\n    float dist1 = distance(uv, pt2.xy) + distance(uv, pt3.xy) - distance(pt2.xy, pt3.xy);\n    float dist2 = distance(uv, pt1.xy) + distance(uv, pt3.xy) - distance(pt1.xy, pt3.xy);\n    float dist3 = distance(uv, pt1.xy) + distance(uv, pt2.xy) - distance(pt1.xy, pt2.xy);\n    float totalWeight = dist1 + dist2 + dist3;\n    float weightN = 1.0 / totalWeight;\n    float weightedAverageTemp = (pt1.z * dist1 * weightN) + (pt2.z * dist2 * weightN) + (pt3.z * dist3 * weightN);\n    return weightedAverageTemp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Test Temps (x,y,scaledTemp)\n    //Using a simple case with 3 colors; In practice, this would be applied to\n    //  a triangle component in a mesh made using Delaunay triangulation, where\n    //  the three points are the vertices along with their temperatures, scaled 0-1\n    \n    //The below are static points\n    //vec3 pt1 = vec3(0.1, 0.9, 0.95);\n    //vec3 pt2 = vec3(0.2, 0.1, 0.0);\n    //vec3 pt3 = vec3(0.8, 0.8, 0.60);\n    \n    //The below points are set up to cycle through temps\n    //vec3 pt1 = vec3(0.8, 0.4, (sin(iTime*1.1)+1.0)*0.5);\n    //vec3 pt2 = vec3(0.1, 0.1, (sin(iTime*1.3)+1.0)*0.5);\n    //vec3 pt3 = vec3(0.3, 0.7, (sin(iTime*1.7)+1.0)*0.5);\n    \n    //Just for fun, the below points will change both location and temp\n    vec3 pt1 = vec3((sin(iTime*0.11)+1.0)*0.5, (cos(iTime*0.13)+1.0)*0.5, (sin(iTime*1.1)+1.0)*0.5);\n    vec3 pt2 = vec3((cos(iTime*0.17)+1.0)*0.5, (sin(iTime*0.19)+1.0)*0.5, (sin(iTime*1.3)+1.0)*0.5);\n    vec3 pt3 = vec3((sin(iTime*0.23)+1.0)*0.5, (cos(iTime*0.27)+1.0)*0.5, (sin(iTime*1.7)+1.0)*0.5);\n    \n    //Gradient colors for our temps\n    //rgb(255,159,62), rgb(168,255,163), rgb(93,255,255)\n    vec3 warmCol = vec3(1, 0.62, 0.24);\n    vec3 neutCol = vec3(0.66, 1.0, 0.64);\n    vec3 coolCol = vec3(0.422, 1.0, 1.0);\n    \n\n    //Don't bother calculating colors or setting them anywhere outside of the triangle\n    if (!pointInTriangle(uv, pt1, pt2, pt3)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        //Grab our scaled temperature for the pixel, and then get our color out of it\n        float tempScale = scaledTempAtPt(uv, pt1, pt2, pt3);\n        vec3 thisColor;\n        if (tempScale < 0.5) {\n            thisColor = mix(coolCol, neutCol, tempScale*2.0);\n        } else {\n            thisColor = mix(neutCol, warmCol, (tempScale-0.5)*2.0);\n        }\n        fragColor = vec4(thisColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}