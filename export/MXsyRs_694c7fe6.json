{"ver":"0.1","info":{"id":"MXsyRs","date":"1726609721","viewed":32,"name":"Realistic Raytracing 3","username":"the0neboy","description":"A medium complex raytracer im working on that has reflection and refraction and uses wavelengths to include dispersion. Takes a little to render and if you don't have a high end graphics card then decrease the samples on line 6 or vice versa.","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["raytracing","reflection","refraction","globalillumination","rendering","dispersion","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA 2.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float l = max(max(col.r, col.g), col.b);\n    if (l > 1.) col /= l;\n    \n    col = pow(col, vec3(1./GAMMA));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--------------------------------------------------\nstruct TraceData {\n    float t;\n    vec3 normal;\n    int matIndex;\n};\nvec4 Sphere(vec3 ro, vec3 rd, vec3 ce, float r) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = r*r - dot( qc, qc );\n    if( h<0.0 ) return vec4(-1.); // no intersection\n    h = sqrt(h);\n    vec2 dist = vec2(-b-h, -b+h);\n    vec3 normal = normalize(ro + rd*dist.x - ce);\n    \n    float t = dist.x;\n    if (dist.x < 0.) {\n        t = dist.y;\n        normal = -normalize(ro + rd*t - ce);\n    }\n    \n    return vec4(normal, t);\n}\nvec4 Box(vec3 ro, vec3 rd, vec3 ce, vec3 b) \n{\n    ro -= ce;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec4(-1.); // no intersection\n    vec3 normal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    normal *= -sign(rd);\n    float t = tN;\n    if (tN < 0.) {\n        t = tF;\n    }\n    \n    return vec4(normal, t);\n}\n//DATA----------------------------------------------\nvoid set_int(ivec2 p, int value, vec2 fragCoord, int id, out vec4 fragColor) {\n    if (int(fragCoord.x) == p.x && int(fragCoord.y) == p.y) {\n        if (id==0) fragColor.x = float(value)*.0001;\n        else if (id==1) fragColor.y = float(value)*.0001;\n        else if (id==2) fragColor.z = float(value)*.0001;\n        else fragColor.w = float(value)*.0001;\n    }\n}\nint get_int(ivec2 p, sampler2D tex, int id) {\n    vec4 c = texelFetch(tex, p, 0);\n    if (id==0) return int(c.x*1e4);\n    if (id==1) return int(c.x*1e4);\n    if (id==2) return int(c.x*1e4);\n    return int(c.w*1e4);\n}\n//--------------------------------------------------\nTraceData rayMin(TraceData A, TraceData B) {\n    if (A.t < B.t) return A;\n    return B;\n}\nTraceData rayMax(TraceData A, TraceData B) {\n    if (A.t > B.t) return A;\n    return B;\n}\n//--------------------------------------------------\nvec3 triplanar(sampler2D tex, vec3 n, float k) {\n    vec3 A = pow(abs(dot(vec3(1., 0., 0.), n)), k)*texture(tex, n.yz).rgb;\n    vec3 B = pow(abs(dot(vec3(0., 1., 0.), n)), k)*texture(tex, n.zx).rgb;\n    vec3 C = pow(abs(dot(vec3(0., 0., 1.), n)), k)*texture(tex, n.xy).rgb;\n    return (A+B+C)*.33333;\n}\n//--------------------------------------------------\nfloat g(const float x, const float a, const float b, const float c)\n{\n    float d = x - a;\n    d *= (x < a) ? b : c;\n    return exp(-0.5 * d * d);\n}\nvec3 wl2xyz_CIE1931(const float w){\n    float x = 1.056 * g(w, 599.8, 0.0264, 0.0323) + 0.362 * g(w, 442.0, 0.0624, 0.0374) - 0.065 * g(w, 501.1, 0.049, 0.0382);\n    float y = 0.821 * g(w, 568.8, 0.0213, 0.0247) + 0.286 * g(w, 530.9, 0.0613, 0.0322);\n    float z = 1.217 * g(w, 437.0, 0.0845, 0.0278) + 0.681 * g(w, 459.0, 0.0385, 0.0725);\n    return vec3(x,y,z);\n}\nconst mat3 XYZ_WGRGB = mat3( 1.4628067, -0.1840623, -0.2743606,\n                            -0.5217933,  1.4472381,  0.0677227,\n                             0.0349342, -0.0968930,  1.2884099);\nvec3 wl_rgb(float w)\n{\n    return wl2xyz_CIE1931(w) * XYZ_WGRGB;\n}\nfloat presence(vec3 A, vec3 B, float k) {\n    return pow(dot(A,B)/dot(A,vec3(1.)), k);\n}\n//--------------------------------------------------\nfloat hash31(inout vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tuint n = (q.x ^ q.y ^ q.z) * 1597334673U;\n    float v = float(n) * 2.328306437080797e-10;\n    p += fract(vec3(v)*74235.11)*591.59;\n\treturn v;\n}\nvec3 hash33(inout vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x ^ q.y ^ q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n    vec3 v = vec3(q) * 2.328306437080797e-10;\n    p += fract(v*73216.11)*961.69;\n\treturn v;\n}\nvec3 randomNormal(inout vec3 p) {\n    vec3 hash1 = hash33(p);\n    vec3 hash2 = hash33(p);\n    \n    vec3 theta = 6.28318531*hash1;\n    vec3 rho = sqrt(-2.*log(hash2));\n    return normalize(rho*cos(theta));\n}\nTraceData objToTraceData(vec4 obj, int matIndex) {\n    if (obj.w < 0.) obj.w = 1e20;\n    \n    return TraceData(obj.w, obj.xyz, matIndex);\n}\n\nvec3 getRay(vec3 ro, vec3 wo, vec2 uv, float z) {\n    float t = tan(z*3.14159/180.);\n    vec3 f = normalize(wo-ro),\n        r = normalize(cross(vec3(0,1,0),f)),\n        u = cross(f,r),\n        i = f+r*uv.x*t+u*uv.y*t,\n        d = normalize(i);\n    return d;\n        \n}\nvec2 Rot2D(vec2 p, float t) {\n    return vec2(\n        p.x*cos(t)-p.y*sin(t),\n        p.x*sin(t)+p.y*cos(t)\n    );\n}\nvec3 Rot3D(vec3 p, float pitch, float yaw) {\n    p.zy = Rot2D(p.zy, pitch);\n    p.xz = Rot2D(p.xz, yaw);\n    return p;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 1000.\n#define MAX_BOUNCES 10\n#define FOV 60.\n\n#define STACK_FRAMES 1\n#define SAMPLES 100\n#define PRESENCE_POWER 1.\n\n#define SUN_DIR normalize(vec3(5., 3., 2.))\n\nstruct Material {\n    vec3 color;\n    float emission;\n    float smoothness;\n    float metallic;\n    float transparency;\n    float IOR;\n};\n\nTraceData trace(vec3 ro, vec3 rd, inout bool hit) {\n    TraceData dat = TraceData(1e20, vec3(0.), 0);\n    \n    TraceData obj1 = objToTraceData(Box(ro, rd, vec3(.7, .5, 0.), vec3(.5)), 0);\n    TraceData obj2 = objToTraceData(Sphere(ro, rd, vec3(-.7, .5, 0.), .5), 1);\n    TraceData box = objToTraceData(Box(ro, rd, vec3(0., -.2, 0.), vec3(10., .2, 10.)), 2);\n    TraceData light = objToTraceData(Sphere(ro, rd, vec3(0., 1., 1.3), .06), 3);\n    \n    dat = rayMin(obj1, obj2);\n    dat = rayMin(dat, box);\n    dat = rayMin(dat, light);\n    \n    if (dat.t <= MAX_DIST) hit = true;\n    return dat;\n}\nMaterial getMaterial(int id, vec3 p, vec3 n) {\n    Material mat;\n    if (id == 0) {\n        mat.color = vec3(0.737,0.918,0.941);\n        mat.emission = 0.;\n        mat.metallic = 0.;\n        mat.smoothness = 1.;\n        mat.transparency = 1.;\n        mat.IOR = 1.3;\n    }\n    if (id == 1) {\n        mat.color = vec3(0.631,0.867,0.659);\n        mat.metallic = 1.;\n        mat.smoothness = .9;\n    }\n    if (id == 2) {\n        mat.color = vec3(1.000,1.000,1.000);\n        if (mod(floor(p.x)+floor(p.z),2.)==0.) mat.color = vec3(.7, .7, .7);\n    }\n    if (id == 3) {\n        mat.color = vec3(1.000,1.000,1.000);\n        mat.emission = 300.;\n    }\n    return mat;\n}\nvec3 sky(vec3 rd) {\n    #if 0\n    return texture(iChannel0, rd).rgb;\n    #else\n    return vec3(0.);\n    #endif\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv, int seed) {\n    vec2 q1 = fract(uv*195.44)*1915.22;\n    vec3 state = vec3(q1, iTime*195.11 + 1564.5123*float(seed));\n    \n    float wavelength = hash31(state)*320.+380.;\n    vec3 col = wl_rgb(wavelength);\n    vec3 incomingLight = vec3(0.);\n    bool inside = false;\n    bool first = true;\n    \n    for (int i = min(iFrame,0); i < MAX_BOUNCES; i++) {\n        bool hit;\n        TraceData dat = trace(ro, rd, hit);\n        float t = dat.t;\n        \n        if (hit) {\n            vec3 normal = dat.normal;\n            vec3 r = reflect(rd, normal);\n            Material mat = getMaterial(int(dat.matIndex), ro + rd*t, normal);\n            \n            int reflectType = 0;\n            if (hash31(state) <= mat.transparency) {\n                reflectType = 2;\n            } else {\n                if (hash31(state) <= mat.metallic) {\n                    reflectType = 1;\n                }\n            }\n\n            if (reflectType == 0) {\n                float fresnel = pow(clamp(1. - dot(r, normal), 0., 1.), 3.)*mat.smoothness;\n                ro = ro + rd*t + normal*.0001;\n\n                if (clamp(hash31(state), .01, 1.) > fresnel) {\n                    float consumeChance = 1. - presence(col, mat.color, PRESENCE_POWER);\n                    if (hash31(state) < consumeChance) {\n                        break;\n                    }\n                    incomingLight += col*mat.emission;\n\n                    rd = normalize(randomNormal(state) + normal);\n                } else {\n                    rd = r;\n                }\n            } else if (reflectType == 1) {\n                float consumeChance = 1. - presence(col, mat.color, PRESENCE_POWER);\n                if (hash31(state) < consumeChance) {\n                    break;\n                }\n                incomingLight += col*mat.emission;\n\n                ro = ro + rd*t + normal*.0001;\n                rd = normalize(randomNormal(state)*(1.-mat.smoothness) + r);\n            } else if (reflectType == 2) {\n                float consumeChance = 1. - presence(col, mat.color, PRESENCE_POWER);\n                if (hash31(state) < consumeChance) {\n                    break;\n                }\n                incomingLight += col*mat.emission;\n                \n                float IOR = mat.IOR;\n                IOR += 10760.*(IOR-1.)/(wavelength*wavelength);\n                \n                ro = ro + rd*t;\n                float rindex = !inside ? 1./IOR : IOR;\n                vec3 refracted = refract(rd, normal, rindex);\n                if (refracted == vec3(0.)) {\n                    rd = r;\n                    ro += normal*.0001;\n                } else {\n                    rd = normalize(randomNormal(state)*(1.-mat.smoothness) + refracted);\n                    ro -= normal*.0001;\n                    inside = !inside;\n                }\n            }\n        } else {\n            vec3 skycol = sky(rd);\n            float consumeChance = 1. - presence(col, skycol, PRESENCE_POWER);\n            if (hash31(state) < consumeChance) {\n                break;\n            }\n            incomingLight += col;\n            \n            if (i == 0) return skycol;\n            else break;\n        }\n    }\n    \n    return incomingLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m2 = iMouse.xy/iResolution.xy;\n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y*4.;\n    \n    vec3 ro = vec3(0.,0.,3.2);\n    ro = Rot3D(ro,-m.y,-m.x);\n    vec3 rd = getRay(ro, vec3(0.,0.,0.), uv, FOV);\n    \n    vec3 col = vec3(0.);\n    float stepsize = 1./float(SAMPLES);\n    for (int j = min(iFrame,1)-1; j < SAMPLES; j++) {\n        col += render(ro, rd, uv, j+1)*stepsize;\n    }\n    \n    #if STACK_FRAMES\n    vec3 prevcol = texelFetch(iChannel3, ivec2(fragCoord), 0).rgb;\n    int startFrame = get_int(ivec2(0,1), iChannel3, 3);\n    int totalFrames = iFrame-startFrame;\n    \n    if (startFrame != iFrame-2) {\n        col = (prevcol*float(totalFrames)+col)/float(totalFrames+1);\n    }\n    #endif\n    fragColor = vec4(col,1.);\n    #if STACK_FRAMES\n    vec2 prevm = vec2(\n        texelFetch(iChannel3, ivec2(0,0), 0).w,\n        texelFetch(iChannel3, ivec2(1,0), 0).w\n    );\n    if (length(prevm-m2) > .0001) {\n        set_int(ivec2(0,1), iFrame, fragCoord, 3, fragColor);\n    } else {\n        set_int(ivec2(0,1), startFrame, fragCoord, 3, fragColor);\n    }\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        fragColor.w = m2.x;\n    }\n    if (int(fragCoord.x) == 1 && int(fragCoord.y) == 0) {\n        fragColor.w = m2.y;\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 prevm = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n    \n    int startFrame = get_int(ivec2(1,0), iChannel0, 0);\n    \n    if (length(prevm-m) > .0001) {\n        set_int(ivec2(1,0), iFrame, fragCoord, 0, fragColor);\n    } else {\n        set_int(ivec2(1,0), startFrame, fragCoord, 0, fragColor);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        fragColor.xy = m;\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}