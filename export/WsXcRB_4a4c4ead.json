{"ver":"0.1","info":{"id":"WsXcRB","date":"1584996410","viewed":238,"name":"Space Vortex","username":"sevanetrebchenko","description":"This is my thought process with understanding and implementing ray-marching, using https://www.youtube.com/watch?v=2te8heN4CHo as a resource. Toggle between reflective and/or textured surfaces of the sphere at the top of the file to see different effects!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection","transparency","refraction","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Original idea published by NuSan - this shader is my rendition. Thank you!\n * https://www.twitch.tv/nusan_fx\n * https://www.youtube.com/channel/UCdiiD1ukw39XTRj9h6LKCeQ\n *\n * https://www.shadertoy.com/view/Wsy3zm <------ Original shader\n *\n */\n\n// Readability\n#define globalTime iTime\n#define viewportResolution iResolution\n\n// Enable this if you want the sphere to have a more detailed surface texture\n#define texturedSurface  \n\n/*\n * Enable this if you want the sphere to have a reflective surface\n *\n * WARNING: Surface normals are calculated without taking surface texture into account. Rays may bleed \n * through in places where the surface texture comes into direct view of the camera. Works best when the\n * sphere surface is not textured. :^)\n */\n#define reflectiveSurface    \n\n/*************************************************************************************************************\n * Returns a rotation matrix that rotates an object by 'angle' degrees counter-clockwise.                    *                                                                                                  \n*************************************************************************************************************/\nmat2 rotate2D(float angle) {\n  return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\n/*************************************************************************************************************\n * Calculates the result of a given number raised to an integer power. Most of the power calls use integer   *\n * values, and this is to avoid expensive pow calls.\t\t\t\t\t\t\t\t\t\t\t\t\t     *                                                                                                 \n*************************************************************************************************************/\nfloat integerPower(float number, int power)\n{\n  float result = 1.0;\n    \n  for (int i = 0; i < power; ++i) {\n    result *= number;   \n  }\n    \n  return result;\n}\n/*************************************************************************************************************\n *  Smooth Minimum Functions:                                                                                *\n *    Resources                                                                                              *\n *    - http://www.viniciusgraciano.com/blog/smin/                                                           *\n *    - https://iquilezles.org/articles/smin                                                     *\n *                                                                                                           *\n * The polynomial smooth minimum function smoothly interpolates between two values start and end, when they  *\n * are within 'range' of each other or taking the minimum of a and b when they are not. This is especially   *\n * useful for modeling organic connections between objects where smoothing of edges blends the two volumes   *\n * nicely (instead of hard unions).                                                                          *\n*************************************************************************************************************/\nfloat smoothMin(float start, float end, float range) {\n  float h = clamp(0.5 + 0.5 * (start - end) / range, 0.0, 1.0);\n  return mix(start, end, h) - range * h * (1.0 - h);\n}\n\nvec3 smoothMin(vec3 start, vec3 end, float range) {\n  vec3 h = clamp(0.5 + 0.5 * (start - end) / range, 0.0, 1.0);\n  return mix(start, end, h) - range * h * (1.0 - h);\n}\n\n/*************************************************************************************************************\n * Random Functions:                                                                                         *\n *                                                                                                           *\n * Return randomized numbers based on a seed.                                                                *\n*************************************************************************************************************/\nfloat randomValue(float seed) {\n  return fract(sin(seed * 164.469) * 784.295); \n}\n\nvec3 randomValueVec3(float seed) {\n  return fract(sin(seed * vec3(134.342, 428.647, 689.147)) * vec3(541.389, 748.674, 168.189));\n}\n\n/*************************************************************************************************************\n * Returns a random color based on the input seed.                                                           *\n*************************************************************************************************************/\nvec3 randomColor(float seed) {\n  vec3 baseColor = randomValueVec3(seed);\n  \n  // Here color manipulation can be done to alter the base color.\n  baseColor /= max(max(baseColor.x, baseColor.y), baseColor.z);\n  baseColor += vec3(0.5);\n  \n  return baseColor;\n}\n\n/*************************************************************************************************************\n * Returns a random value based on the UV coordinate to use in noise calculation.                            *\n*************************************************************************************************************/\nfloat ditherUV(vec2 uv) {\n  return fract(dot(sin(uv * 524.681 + uv.yx * 851.294), vec2(384.914)));\n}\n\n// Function declaration for use below\nfloat signedDistance(vec3);\n\n/*************************************************************************************************************\n * Normal Estimation of a Signed Distance Field:                                                             *\n *   Resources                                                                                               *\n *   - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/                              *\n *                                                                                                           *\n * To estimate the normal of a surface we don't know the direct equation of, we take the gradient. The       *\n * gradient of a function tells us in which direction to move from a given point to most quickly increase a  *\n * value of the function. At a point directly on a surface, the gradient evaluation will be 0, as that is    *\n * where the function is defined. On the inside of that surface, the gradient goes negative (move in the     *\n * opposite direction to increase the function value). On the outside of the surface, the gradient is        *\n * positive. Hence, the direction at the surface that will bring you from negative to positive most rapidly  *\n * will be orthogonal vector to the surface. We can use this vector as the normal of the surface.            *\n*************************************************************************************************************/\nvec3 estimateNormal(vec3 ray) {\n  /*\n   * This number represents the transparency of the surface of the sphere. As this number approaches 0, the \n   * more apparent the diffraction of the light ray through the solid will be.\n   */\n  #ifdef reflectiveSurface\n    float refractionConstant = 0.1;\n  #else\n    float refractionConstant = 0.0001;\n  #endif\n\n  // Sample along the x axis at the point of contact.\n  float positiveXStep = signedDistance(vec3(ray.x + refractionConstant, ray.y, ray.z));\n  float negativeXStep = signedDistance(vec3(ray.x - refractionConstant, ray.y, ray.z));\n\n  // Sample along the y axis at the point of contact.\n  float positiveYStep = signedDistance(vec3(ray.x, ray.y + refractionConstant, ray.z));\n  float negativeYStep = signedDistance(vec3(ray.x, ray.y - refractionConstant, ray.z));\n\n  // Sample along the z axis at the point of contact.\n  float positiveZStep = signedDistance(vec3(ray.x, ray.y, ray.z + refractionConstant));\n  float negativeZStep = signedDistance(vec3(ray.x, ray.y, ray.z - refractionConstant));\n\n  // Calculate the gradient\n  return normalize(vec3(positiveXStep - negativeXStep,\n                        positiveYStep - negativeYStep,\n                        positiveZStep - negativeZStep));\n}\n\n/*************************************************************************************************************\n * Rotate the camera look-at and ray direction vectors to give the appearance of rotation.                   *\n*************************************************************************************************************/\nvoid RotateCameraVector(inout vec3 toRotate) {\n  float cameraRotationSpeed = 0.3; // Speed at which the camera gets rotated around the sphere\n  float rotationAngle = globalTime * cameraRotationSpeed;\n  \n  // This rotates the vector around the horizontal axis and vertical axis, respectively.\n  toRotate.xz *= rotate2D(rotationAngle);\n  toRotate.yz *= rotate2D(rotationAngle);\n}\n\n/*************************************************************************************************************\n * Creates a sphere in the center of the screen with the provided radius length.                             *\n*************************************************************************************************************/\nfloat sphere(vec3 currentRayPosition, float sphereRadius) {\n\n  /* \n   * We return the radius subtracted from the length of the current ray because we want to skip all rays that \n   * have a position that's located within the radius of the sphere. We will check this condition within the\n   * ray mapping function.\n   */\n  return length(currentRayPosition) - sphereRadius;\n}\n\n/*************************************************************************************************************\n * Returns a manipulated ray direction to randomize the explosion effect. It takes the current position of   *\n * the ray and random values for the rotation speed and explosion starting time. Notice that we are not      *\n * modifying the ray itself.                                                                                 *\n*************************************************************************************************************/\nvec3 explosionManipulation(vec3 rayPosition, float rotationSpeed, float explosionSpeed) {\n  float finalDistanceVariation = 14.0;  // Final separation distance between particles of the volume.\n  float initialDistanceVariation = 0.0; // Initial separation distance between particles of the volume.\n  float slowingFactor = 0.5;            // Slowing factor of the explosion as it reaches its peak volume.\n  int particleMultiplier = 3;           // Number of times particles get duplicated.\n\n  /*\n   * This number represents the range between two particles at which to begin smoothing - the higher this \n   * number is, the more distance there can be between two object volumes for their edges to begin blending \n   * together.\n   */\n  float smoothStrength = 6.0;\n    \n  /*\n   * We smoothly interpolate between values [0, 18] to add variation to the separation distance between \n   * volumes. This is what gives the explosions the separation as their lifetime goes on.\n   */\n  float distanceVariation = smoothstep(0.0, 1.0, fract(explosionSpeed)) * (finalDistanceVariation);\n  float separationDistance = initialDistanceVariation + distanceVariation;\n  \n  for (int i = 0; i < particleMultiplier; ++i) {\n    /*\n     * Here we rotate the individual particles along pre-determined axes. The rotation is slightly different \n     * each time to give more randomization to the explosion formations.\n     */\n    rayPosition.xy *= rotate2D((rotationSpeed + float(i)) * 0.79);\n    rayPosition.yz *= rotate2D((rotationSpeed + float(i)) * 0.47);\n\n    /*\n     * Based on the desired smoothing strength between each individial particle, we smooth the intersections \n     * using the smoothMin function. In places where spheres intersect, metaball-like structures are created \n     * for blending sphere volumes. \n     * \n     * To give volume to the explosion, we smooth between the ray's current position and the negative of the \n     * ray's current position. This smooths the ray towards the center so that, upon spawning, the ray is \n     * more like a coherent mass and not a bunch of individual particles. As the explosion grows apart, this \n     * smoothing gets weaker and weaker, eventually breaking apart when the distances between the positions \n     * get too large.\n     */\n    rayPosition = smoothMin(rayPosition, -rayPosition, -smoothStrength);\n\n    /*\n     * After we are done modifying the position for this iteration, we increase the separation between \n     * particles to expand the explosion volume. However, we don't want to do this indefinitely, so we slow \n     * the expansion down as the explosion reaches peak lifetime.\n     */\n    rayPosition -= separationDistance;\n    separationDistance *= slowingFactor;\n  }\n  \n\n  // We return the ray position after all the modifications done above.\n  return rayPosition;\n}\n\nfloat explosionSpeed = 0.25; // How fast the explosion happens     \n\n/*************************************************************************************************************\n * Receives the current ray position and returns its distance from the camera. The timeOffset variable       *\n * represents the time offset between different explosions. This is done to sync up the starts and ends of   *\n * the explosions for one to start when the other finishes.                                                  *\n *                                                                                                           *\n * Returns the current distance from the eye of the camera of the passed ray after manipulations.            *\n*************************************************************************************************************/\nfloat explode(vec3 currentRayPosition, float offset) {\n  float explosionTorque = 0.035;                               // Speed of rotation of explosion particles\n  float explosionTimer = globalTime * explosionSpeed + offset; // Timer for both explosions\n  float rotationTimer1 = globalTime * 0.13 + 924.141;          // Rotation timer for the first explosion\n  float rotationTimer2 = globalTime * 0.17 + 372.423;          // Rotation timer for the second explosion\n  float explosionVolume = 2.3;                                 // How much volume explosions have\n  \n  /*\n   * Rotate the ray's position around the same axis of rotation as the rotation of the sphere. This gives the \n   * spiraling effect as the explosion expands.\n   */\n  currentRayPosition.xz *= rotate2D(currentRayPosition.y * explosionTorque);\n  currentRayPosition.xy *= rotate2D(currentRayPosition.z * explosionTorque);\n\n  /*\n   * To reduce uniformity between explosions, set off two rays with slightly different values and \n   * interpolate between them. \n   */\n  vec3 resultingRayDirection1 = explosionManipulation(currentRayPosition, rotationTimer1, explosionTimer);\n  vec3 resultingRayDirection2 = explosionManipulation(currentRayPosition, rotationTimer2, explosionTimer);\n\n  /*\n   * This number represents the strength of the brightness fade explosions have after they have reached their \n   * peak. The explosion timer value increases as globalTime continues, which causes the brightness reduction \n   * of the explosion to increase as well. This is purposefully done so that the explosion simmers out as it \n   * passes it's peak lifetime, reducing it's brightness to 0. Without this, explosions would simply blink \n   * out of existence.\n   */\n  float particleFade = 1.0 - integerPower(fract(explosionTimer), 6);  \n\n  /*\n   * Calculate the distance of the ray from the eye of the camera. Since we have volumetric exploding\n   * particles with their sizes fading out to nothing after the explosion is finished, we have to account \n   * for this variation in distance.\n   */\n  float distanceRay1 = length(resultingRayDirection1) - explosionVolume * particleFade;\n  float distanceRay2 = length(resultingRayDirection2) - explosionVolume * particleFade;\n  \n  // Since we computed two rays, we take the smooth minimum to organically interpolate between them. \n  return smoothMin(distanceRay1, distanceRay2, -1.0);\n}\n\n\n/* \n * This value is for the transparency of the color at the ray position. Every iteration through the mapping \n * loop, this color will be added to depending on the distance from the position of the camera eye to the \n * surface. The closer the ray is to the surface, the more value gets added. \n */\nfloat colorTransparency1 = 0.0;\nfloat colorTransparency2 = 0.0;\n\n/*\n * Declaring the starting positions of each explosion here. These will be changed within main before they\n * go through the signed distance function in the scene.\n */\nvec3 firstPosition = vec3(0.0, 0.0, 0.0);\nvec3 secondPosition = vec3(0.0, 0.0, 0.0);\n\n/*\n * If the current ray needs to be reflected, this will be set to true after the ray passes through the signed \n * distance function in our scene.\n */ \nbool refraction = false;\n\n\n/*************************************************************************************************************\n * Receives the current ray position and defines the scene's signed distance field. Returns the minimum      *\n * signed distance from the camera.                                                                          *\n*************************************************************************************************************/\nfloat signedDistance(vec3 rayPosition) {\n  \n  float sphereRadius = 17.0; // Radius of the sphere in the center\n  \n  // We set off two explosions and get both ray distances. One explosion starts right after the other.\n  float closestDistance1 = explode(rayPosition + firstPosition, 0.0);\n  float closestDistance2 = explode(rayPosition + secondPosition, 0.5);\n  \n\n  // These values are tuned to balance color exposure and brightness.\n  colorTransparency1 += 0.65 / (1.85 + abs(closestDistance1));\n  colorTransparency2 += 0.65 / (1.85 + abs(closestDistance2));\n  \n  \n  // Create ripples on the surface of the sphere\n  #ifdef reflectiveSurface\n    #ifdef texturedSurface\n      float resolution = 0.8;        // Surface texture resolution per unit area of space\n      float ridgeDepth = 0.5;        // How deep ridges dig into the surface of the sphere\n      float ridgeShattering = 0.15;  // Difference in height between adjacent surface squares\n      \n      \n      // Offset the current ray position slightly to create grooves.\n      rayPosition += smoothstep(0.0, ridgeDepth, sin(rayPosition.yzx * resolution)) * ridgeShattering;\n    #endif\n  #else\n    #ifdef texturedSurface\n      float resolution = 0.5;        // Surface texture resolution per unit area of space\n      float ridgeDepth = 0.5;        // How deep ridges dig into the surface of the sphere\n      float ridgeShattering = 0.1;   // Difference in height between adjacent surface squares\n      \n      // Offset the current ray position slightly to create grooves.\n      rayPosition += smoothstep(0.0, ridgeDepth, sin(rayPosition.yzx * resolution)) * ridgeShattering;\n    #endif\n  #endif\n  \n  /*\n   * This creates a sphere with a radius sphereRadius centered at (0, 0) in the world space. Any rays that \n   * end inside of this sphere get cut off (return the intersection between the ray and the sphere surface). \n   * This ensures nothing is inside of the sphere.\n   */\n  float shapeCenterDistance = sphere(rayPosition, sphereRadius);\n  \n  /*\n   * We want the smallest distance away from the position of the camera eye. This means this position is the \n   * closest, and we want to render this ray.\n   */\n  float explosionVolumeDistance = min(abs(closestDistance1), abs(closestDistance2));\n\n  /*\n   * We know if the ray has gone entirely through the sphere if the distance from the position of the camera\n   * eye to the surface of the sphere is less than the distance to the explosion. In this case, these rays \n   * will be diffracted through the surface of the sphere at the rendering stage.\n   */\n  refraction = shapeCenterDistance < explosionVolumeDistance;\n  \n  /* \n   * Again, we want the smallest distance away from the position of the camera eye. This means this resulting \n   * ray is closer, and needs to be rendered before anything else that may be behind it.\n   */\n  return min(explosionVolumeDistance, shapeCenterDistance);\n}\n\n/*************************************************************************************************************\n * SHADER MAIN                                                                                               *\n*************************************************************************************************************/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  /*\n   * Get the pixel UV coordinates in a range from [0 to 1] on both x and y, center (0, 0) at the center of \n   * the display, and normalize UV coordinates to cover the entire range of the native display resolution.\n   */\n  vec2 uv = vec2(fragCoord.x / viewportResolution.x, fragCoord.y / viewportResolution.y) - 0.5;\n  uv /= vec2(viewportResolution.y / viewportResolution.x, 1);\n    \n  /* \n   * Attempt at a slight optimization - we don't need to render pixels that are outside of the screen space.\n   * Any pixels that have UV coordinates that are not within the circle with UV coordinate radius 0.6 will   \n   * most likely never see color, and should be discarded.\n   */\n  if (length(uv) > 0.6) {\n\tdiscard;\n  }\n  \n  // Set the camera's eye position 'z' units away from the center of the shader world space. In this case, 65.\n  vec3 cameraPosition = vec3(0.0, 0.0, -65);   \n  \n  /*\n   * Set the starting position for each ray to be the eye of the camera. The rays are angled based on\n   * the UV coordinate of the current pixel being rendered. It's important to note that the camera eye \n   * position is along the negative z-axis, while the direction of the ray is positive (away from the camera \n   * eye position).\n   */\n  vec3 rayPosition = cameraPosition;   \n  vec3 rayDirection = normalize(vec3(uv, 1.0));\n  \n  /*\n   * RotateCameraVector(rayPosition)\n   *\n   *   In this scene, there is no 'camera' object, rather only a vector which represents the camera's look-at \n   *   vector. To see the sphere from different angles, we must rotate the position of the camera eye around \n   *   the sphere. This is achieved by the first rotation call. However, if only this is done, the sphere will\n   *   begin to rotate around the camera's eye position, as we are just rotating where the camera's look at \n   *   vector is pointing. \n   *\n   * RotateCameraVector(rayDirection)\n   *\n   *   Since the camera's look-at vector and the direction of the ray are OPPOSITE, it's easy to position the \n   *   sphere in the center of the screen again by rotating the direction of the ray in the exact same way as \n   *   we did with the look-at vector. With the rotation call, we constantly angle the ray direction towards \n   *   the sphere.\n   *     \n   * This results in a floating camera effect - the eye of the camera is constantly rotating around the \n   * sphere, with the rays being accurately projected towards the direction of the sphere. Without the \n   * following two calls, the sphere in the center will remain completely still.\n   */\n  RotateCameraVector(rayPosition);\n  RotateCameraVector(rayDirection);\n\n  /*\n   * This number represents the variation in starting position of the explosions along each axis. The higher \n   * this number is, the further away from the center the explosion starts from.\n   */\n  float startingDistanceFromSphereCenter = 0.0;\n  \n  /*\n   * Random seeds for explosion positions. The second explosion position is offset so that explosions have \n   * different colors.\n   */\n  float firstSeed = floor(globalTime * explosionSpeed);\n  float secondSeed = floor(globalTime * explosionSpeed + 0.5);\n  \n  /*\n   * Calculate the randomized explosion position and center it around the position of the sphere. Add desired \n   * level of deviation away from the sphere center to the explosion position.\n   */\n  firstPosition.xy = (randomValueVec3(firstSeed) - 0.5).xy * startingDistanceFromSphereCenter;\n  secondPosition.xy = (randomValueVec3(secondSeed) - 0.5).xy * startingDistanceFromSphereCenter;\n  \n  /*\n   * Move the explosion position slightly behind the sphere by moving it back along the direction from the \n   * camera's eye position to the center of the sphere.\n   */\n  firstPosition = 6.0 * normalize(rayPosition);\n  secondPosition = 6.0 * normalize(rayPosition);\n  \n  // Randomize the explosion colors to make them different from one another.\n  vec3 firstColor = randomColor(firstSeed + 352.729);\n  vec3 secondColor = randomColor(secondSeed + 12.856);\n\n  /* \n   * This is the minimal distance from the surface of the object that is considered 'close enough'. If the \n   * distance between the ray and the surface is less than this, we can consider the ray to have reached \n   * the surface of the volume.\n  */\n  float distanceThreshold = 0.001;\n    \n  /*\n   * This is the starting color of all rays. In places where the ray should be colored, this will be handled \n   * within the ray marching loop.\n   */\n  vec3 outColor = vec3(0.0);\n  \n  /* \n   * This represents the total number of steps the ray-marcher can take to get to the desired surface. \n   * Increasing or this number results in more exposed and blown-out colors because the color values can be \n   * added to for more iterations. This often results in values peaking and distorting. For the same reason, \n   * decreasing the number of steps has a similar effect, except colors become dimmer and duller.\n   *\n   * Optimization for compile times - prevent the compiler from unraveling the loop.\n  */\n  float totalSteps = 90.0 + min(globalTime, 0.0);\n\n  \n  /*\n   * Calculate noise frequency based on the desired amount of noise. Increasing the frequency will result \n   * in more noisy output.\n   */ \n  float noiseFrequency = 0.2;\n  float noise = mix(1.0, ditherUV(uv), noiseFrequency);\n  \n  /* \n   * This is the main ray-marching loop.\n   * \n   * Ray marching iterates towards a surface, calculating remaining distance to said surface until the \n   * distance is sufficiently small or the step limit (totalSteps) has been reached, whichever happens first. \n  */\n  for (float currentMarchStep = 0.0; currentMarchStep < totalSteps; ++currentMarchStep) {\n    \n    /*\n     * Here we calculate the remaining distance of the current light ray from the surface by using the map \n     * function.\n     *\n     * When the explosion reaches it's peak point, parts of the surface will begin to experience higher \n     * levels of rotational torque and lose volume. You can see this begin to happen towards the edges of the \n     * explosion. When this happens, even the smallest ray marches can step entirely through the surface, \n     * giving it a much more transparent feel. Noise is applied to the entire explosion to minimize the \n     * distraction factor of this effect.\n    */\n    float distanceToSurface = abs(signedDistance(rayPosition)) * noise;\n    \n\n    // The ray-marcher has reached a point that we consider 'close enough' to the surface.\n    if (distanceToSurface < distanceThreshold) {\n        \n      /* \n\t   * Only do this check if we need to.\n\t   */\n      #if defined(reflectiveSurface) || defined(texturedSurface)\n        if (refraction) {\n\n          // Estimate the normal of the sphere at the point of contact of the ray by using gradients.\n          vec3 normal = estimateNormal(rayPosition);\n\n          /*\n           * In order to create the scattering effect of the rays, we simply reflect the current ray POSITION \n           * over the normal. Since they are sufficiently close to each other with smaller values of the \n           * diffraction constant, this results in only minor adjustments to the position of the ray \n           * (i.e. scattering). \n           *\n           * If complete reflection is desired, we achieve this effect by reflecting the ray DIRECTION over the \n           * normal. This inverts the direction of the ray to move away from the surface, creating a reflective \n           * effect. It is important to note that a larger diffraction coefficient is necessary to see clearer \n           * reflections.\n           */\n          #ifdef reflectiveSurface\n            rayDirection = reflect(rayDirection, normal);\n          #else\n            rayPosition = reflect(-rayPosition, normal); \n          #endif\n        }\n      #endif\n      \n      /*\n       * Since we have detected that this ray has already hit the solid's surface, we slow the speed of the \n       * ray down to a constant value. Ultimately, this number describes the speed of marching the ray has \n       * when it is inside the surface. The HIGHER this number is, the more TRANSPARENT rays' intersections \n       * with the surface will be (with a higher speed the ray simply marches directly through the surface). \n       *\n       * As the value of distanceToSurface approaches 0, the position of the current ray will not change \n       * until the ray-marching iterations run out. This results in mostly OPAQUE colors of the explosions' \n       * surface.\n       */\n      distanceToSurface = 0.05;\n    }\n    \n\n    // Apply a small amount of color to this pixel for this iteration of the ray-marching.\n    outColor += integerPower(colorTransparency1 * 0.013, 4) * firstColor;\n    outColor += integerPower(colorTransparency2 * 0.013, 4) * secondColor;\n    \n    /*\n     * The ray marches toward the surface at a variable rate, based on the result from out mapping function \n     * call. If this ray hasalready reached the surface, the ray instead moves at a constant rate to create \n     * a transparency effect.\n    */\n    rayPosition += rayDirection * distanceToSurface;\n  }\n  \n  // Make the final colors brighter!\n  outColor += pow(outColor, vec3(1.05));\n\n  // OUTPUT FINAL PIXEL COLOR\n  fragColor = vec4(outColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}