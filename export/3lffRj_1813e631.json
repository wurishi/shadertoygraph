{"ver":"0.1","info":{"id":"3lffRj","date":"1597347180","viewed":315,"name":"Raytraced Fractal Cube","username":"athibaul","description":"I wanted a photorealistic render of this fractal but I didn't have enough RAM to load the OBJ file in Blender, so here it is with a homemade raytracing engine.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tFRACTAL CUBE\n\n\tThis shader raytraces a cube-shaped fractal.\n\n\t- Raytracing is done by computing collision with individual cubes.\n\t- Diffuse shading only, but with \n\n\tFuture prospects:\n\t- Implement a more efficient voxel-based ray algorithm\n\t(https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf)\t\n\t- Multiple importance sampling\n\n*/\n\n// Just display the buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\nCHANGELOG OF VERSION 05\n\nAdd SubCube intersection\nAdd naive ChaosCube intersection implementation!\nAdd improvement to ChaosCube implementation \n\tby checking intersection with the full cube\nFix bug when checking intersection with the main cube\nAdd tentative faster ChaosCube implementation!\nChange colors and setting for a nicer render\nFix wrong coloring when too many bounces\nImprove performance by using better cube collision test\n(https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf)\n(not a big improvement in fact 9fps -> 10fps)\n\n*/\n\n\n// Ray length bounds\n#define T_MIN 1.0e-5\n#define T_MAX 1.0e5\n// When in need for a small value...\n#define EPS 1.e-6\n\n// Integer values to represent a material type\n#define EMISSION 1\n#define DIFFUSE 2\n\n// Maximal number of diffuse bounces per ray\n#define NUM_BOUNCES 6\n// Samples per frame\n#define NUM_SAMPLES 1\n\n// Number of successive subdivisions of the fractal\n#define CUBE_ORDER 9\n\n#define SORT(a,b) if(a>b){float tmp=a;a=b;b=tmp;}\n\n\nstruct Ray\n{\n    vec3 origin; vec3 direction; \n};\nstruct Intersection\n{\n    vec3 position; vec3 normal;\n    vec3 color; int type;\n};\n    \n    // A SubCube is the cube of size 2^{-n} located\n    // from position (i,j,k)/2^n to (i+1,j+1,k+1)/2^n,\n    // where i,j,k are three integers between 0 and 2^n-1.\nstruct SubCube\n{\n    ivec3 ijk; int n;\n};\n// A CCHitResult is used in the depth-first exploration \n// of the ChaosCube.\nstruct CCHitResult\n{\n    SubCube sc; float t; vec3 normal;\n};\n        \n\nbool isInSquare(vec2 point, float eps){\n    return (eps <= point.x && point.x <= 1.0-eps) &&\n     \t   (eps <= point.y && point.y <= 1.0-eps);\n}\n\nbool isInCube(vec3 point, float eps){\n    // A positive value of eps shrinks the cube\n    // A negative value enlarges it\n    return (eps <= point.x && point.x <= 1.0-eps) &&\n     \t   (eps <= point.y && point.y <= 1.0-eps) &&\n     \t   (eps <= point.z && point.z <= 1.0-eps);\n}\n\n/*\n// Old algorithm for cube intersection\n// Tests intersection with the three nearest faces one after the other\nfloat cubeIntersection(Ray r, inout vec3 normal, float eps){\n    // Test intersection with the unit cube [0,1]^3\n    // Return smallest positive t such that `origin + t*direction` intersects.\n    \n    // If we are inside the cube, we're done\n    if(isInCube(r.origin, eps)){\n        return 0.;\n    }\n    \n    \n    // Otherwise, test collision with the three nearest faces\n    // (we can't see the others)\n    \n    float t = T_MAX;\n    \n    // Test collision with face \"x=c\"\n    float c = r.origin.x < 0.5 ? 0.0 : 1.0;\n    float tx = (c - r.origin.x) / (r.direction.x);\n    vec3 inXPlane = r.origin + tx * r.direction;\n    if(T_MIN < tx && tx < t && isInSquare(inXPlane.yz, eps)){\n        t = tx;\n        normal = c==0.0 ? vec3(-1.0, 0.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    }\n        \n    // Test collision with \"y=c\"...\n    c = r.origin.y < 0.5 ? 0.0 : 1.0;\n    float ty = (c - r.origin.y) / (r.direction.y);\n    vec3 inYPlane = r.origin + ty * r.direction;\n    if(T_MIN < ty && ty < t && isInSquare(inYPlane.xz, eps)){\n        t = ty;\n        normal = c==0.0 ? vec3(0.0, -1.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    }\n    \n    // ...and \"z=c\"\n    c = r.origin.z < 0.5 ? 0.0 : 1.0;\n    float tz = (c - r.origin.z) / (r.direction.z);\n    vec3 inZPlane = r.origin + tz * r.direction;\n    if(T_MIN < tz && tz < t && isInSquare(inZPlane.xy, eps)){\n        t = tz;\n        normal = c==0.0 ? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0);\n    }\n    \n    return t;\n}*/\n\n\nfloat cubeIntersection(Ray r, inout vec3 normal, float eps){\n    // Shorter algorithm inspired by\n    // https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf\n    \n    if(isInCube(r.origin, eps))\n        return 0.;\n    \n    vec3 t0 = (-r.origin)/r.direction;\n    vec3 t1 = (1. - r.origin)/r.direction;\n    vec3 normalSign = -sign(r.direction);\n    SORT(t0.x,t1.x);\n    SORT(t0.y,t1.y);\n    SORT(t0.z,t1.z);\n    float tcmin = max(t0.x, max(t0.y, t0.z));\n    float tcmax = min(t1.x, min(t1.y, t1.z));\n    if(tcmin >= tcmax || tcmax < T_MIN)\n        return T_MAX;\n    if(T_MIN < tcmin && tcmin < T_MAX)\n        normal = normalSign * vec3(equal(t0, vec3(tcmin)));\n        return tcmin;\n    return T_MAX;\n}\n\n\nfloat cubeIntersection(Ray r, inout vec3 normal){\n    return cubeIntersection(r, normal, EPS);\n}\n\n// This function determines the shape of the fractal\nbool isAdmissible(SubCube sc)\n{\n    // Does this SubCube contain any point from the ChaosCube ?\n    // It does unless the binary representations of i,j,k\n    // have repeating digits at the same position.\n    int i=sc.ijk.x, j=sc.ijk.y, k=sc.ijk.z;\n    /*int i1,j1,k1;\n    for(int a=0; a<sc.n-1; a++){\n        i1=i>>1, j1=j>>1, k1=k>>1;\n        if((i&1) == (i1&1) && (j&1)==(j1&1) && (k&1)==(k1&1))\n            // Repeating digits \n            return false;\n        i=i1;j=j1;k=k1;\n    }\n    return true;\n\t*/\n    \n    // Shorter version using only bitwise operations\n    int i1=i>>1, j1=j>>1, k1=k>>1;\n    // Detect if there are repeated digits at the same position\n    // sharedRepeats contains 1's where any digit has changed\n    // and 0's where all digits remain the same\n    int sharedRepeats = (i^i1) | (j^j1) | (k^k1);\n    int ones = ((1<<(sc.n-1))-1);\n    // If sharedRepeats has n trailing ones, we're good.\n    return (sharedRepeats & ones) == ones;\n        \n}\n\nfloat subCubeIntersection(SubCube sc, Ray r, inout vec3 normal)\n{\n    // Test intersection of ray with the given SubCube\n    // by scaling the ray to a space where the\n    // cube is [0,1]^3.\n    Ray other;\n    other.direction = r.direction;\n    other.origin = r.origin * float(1 << sc.n) - vec3(sc.ijk);\n    \n    float t = cubeIntersection(other, normal);\n    if (T_MIN < t && t < T_MAX)\n    \treturn t / float(1 << sc.n);\n    return t;\n}\n\nfloat chaosCubeIntersection(int n, Ray r, inout vec3 normal)\n{\n    // Test intersection with ChaosCube of order n.\n    // /!\\ Naive method, only for very low orders. /!\\\n    // /!\\ Complexity 8^CUBE_ORDER. /!\\\n    \n    \n    SubCube sc;\n    sc.n = n;\n    float d = T_MAX; // Temporary distance\n    float t = T_MAX; // Best found distance\n    vec3 curNormal; // Temporary normal\n    \n    \n    // First, check that we intersect the full cube (enlarged)\n    if(cubeIntersection(r, curNormal, -EPS) >= T_MAX)\n        return T_MAX;\n    \n    // Then, try to intersect all small cubes.\n    for(int i=0; i<1<<n; i++){\n        for(int j=0; j<1<<n; j++){\n            for(int k=0; k<1<<n; k++){\n                sc.ijk = ivec3(i,j,k);\n                if(isAdmissible(sc)){\n                    d = subCubeIntersection(sc, r, curNormal);\n                    if(d < t){\n                        t = d;\n                        normal = curNormal;\n                    }\n                }\n            }\n        }\n    }\n    return t;\n}\n\nCCHitResult[CUBE_ORDER*4] stack;\nfloat chaosCubeIntersection2(int n, Ray r, inout vec3 normal)\n{\n    // More advanced method for intersecting the ChaosCube\n    // Uses depth-first exploration, and stores info in the \"stack\".\n    // Computes fewer ray-cube collisions.\n    \n    // TODO: implement a more efficient version making use of the\n    // voxel-octree structure of the fractal.\n    \n    CCHitResult cur, sub;\n    vec3 curNormal;\n    float t;\n    stack[0] = CCHitResult(SubCube(ivec3(0), 0), 0., vec3(0));\n    int top=0;\n    \n    while(top >= 0){\n        cur = stack[top];\n        top--;\n        if(cur.sc.n == n && cur.t < T_MAX){\n            // We found the high-order sub-cube!\n            normal = cur.normal;\n            return cur.t;\n        }\n        // Test all the sub-sub-cubes\n        for(int m=0; m<8; m++){\n            sub.sc = SubCube(2*cur.sc.ijk + ivec3(m&1,(m&2)>>1,(m&4)>>2),\n                             cur.sc.n+1);\n            if(!isAdmissible(sub.sc))\n                continue;\n            t = subCubeIntersection(sub.sc, r, curNormal);\n            if(t>=T_MAX)\n                continue;\n            sub.t = t;\n            sub.normal = curNormal;\n            // Put this sub-sub-cube on the stack, below those with a lower t.\n            top++;\n            int z=top;\n            while(z>0 && sub.t > stack[z-1].t){\n                // Push up all the guys that are closer to the source of the ray\n                stack[z] = stack[z-1];\n                z--;\n            }\n            stack[z] = sub;\n        }\n    }\n    return T_MAX;\n}\n/*\nfloat sphereIntersection(Ray r, inout vec3 normal){\n    // Test intersection with the unit sphere\n    \n    float a2 = dot(r.origin, r.origin),\n        d2 = dot(r.direction, r.direction),\n        ad = dot(r.origin, r.direction);\n    \n    // If we are inside the sphere, we're done\n    if(a2 <= 1. - 5.*EPS){\n        return 0.;\n    }\n    \n    // Otherwise, solve the quadratic equation\n    float determinantPrime = ad*ad\n        - (a2 - 1.) * d2;\n    \n \tif(determinantPrime <= EPS)  // No intersection\n        return T_MAX;\n    \n    float t = - ad - sqrt(determinantPrime); // Smallest solution\n    \n    if(T_MIN < t && t < T_MAX){\n    \tnormal = normalize(r.origin + t * r.direction);\n    \treturn t;\n    } else\n        return T_MAX;\n}\n*/\n\n\n\nfloat planeIntersect(Ray r, inout vec3 normal){\n    // Collision with the horizontal plane\n    float t = - (r.origin.z+2e-5) / r.direction.z;\n    if(T_MIN < t && t < T_MAX){\n        // We hit the plane !\n        normal = vec3(0.0, 0.0, 1.0);\n        return t;\n    }\n    return T_MAX;\n}\n    \n    \n    \nfloat sceneIntersect( Ray r, inout Intersection intersec ) {\n    // The general method to detect collision of one ray with the scene.\n    // Returns the distance t travelled by the ray, and\n    // additionnal info in the Intersection object.\n    float t = T_MAX;\n    vec3 normal;\n    \n    /*float d = cubeIntersection(r, normal);*/\n    float d = chaosCubeIntersection2(CUBE_ORDER, r, normal);\n    if(d < t){\n        t = d;\n        intersec.normal = normal;\n        intersec.type = DIFFUSE;\n        intersec.color = vec3(0.8, 0.75, 0.7); // light grey\n    }\n    \n    /*\n    d = sphereIntersection(r, normal);\n    if(d < t){\n        t = d;\n        intersec.normal = normal;\n        intersec.type = DIFFUSE;\n        intersec.color = vec3(0.2, 0.6, 0.1); // green\n    }\n\t*/\n    \n    \n    d = planeIntersect(r, normal);\n    if(d < t){\n        t = d;\n        intersec.normal = normal;\n        intersec.type = DIFFUSE;\n        intersec.color = vec3(0.47,0.09,0.19); // Bordeaux\n        \n        /*\n        // Except in one square!\n    \tintersec.position = r.origin + t * r.direction;\n        if(isInSquare(intersec.position.xy - vec2(0.5,1.25), EPS)){\n            intersec.color = vec3(0., 0.5, 0.9);\n        }*/\n\t\t\n    }\n    \n    if(t >= T_MAX){\n        // Sky light\n        intersec.normal = -r.direction;\n        intersec.color = dot(r.direction,\n                             vec3(0.5, -0.5, 0.5)) > 0.5 ? vec3(3.5) : vec3(0.5,0.6,0.7);\n        intersec.type = EMISSION;\n    }\n    \n    intersec.position = r.origin + t * r.direction;\n    return t;\n}\n\n\nvec3 CalculateRadiance( Ray ray, int bounces, inout int seed){\n    // The raytracing algorithm itself.\n    // This method cares about bouncing rays around and calculating\n    // the resulting color.\n    Intersection intersect;\n    \n    float t = sceneIntersect(ray, intersect);\n    \n    if(intersect.type == EMISSION){\n    \treturn intersect.color;\n    } else if(intersect.type == DIFFUSE) {\n        vec3 diffuse = intersect.color;\n        // The actual raytracing is done here!\n        while(bounces > 0 && length(diffuse) > EPS){\n            vec3 newDir = randomUnitInHemisphere(seed, intersect.normal);\n            Ray bouncedRay = Ray(intersect.position, newDir);\n            t = sceneIntersect(bouncedRay, intersect);\n            if(intersect.type == EMISSION){\n                // If we meet a light source, we stop\n                diffuse *= intersect.color;\n                break;\n            } else {\n                // Otherwise we bounce again\n                diffuse *= intersect.color;\n            }\n            bounces--;\n        }\n        if(bounces==0) // Didn't find a light source!\n            return vec3(0);\n        return diffuse;\n    } else {\n        // Other intersection type?\n        return vec3(0.,1.,1.);\n    }\n    \n    \n}\n\nRay cameraRayNonrandom(vec2 fragCoord,\n                       vec3 camPos,\n                       vec3 camForward,\n              \t\t   float angleOfView) {\n    /* In which direction should we shoot a ray from the camera ? */\n    \n    // Camera's orthonormal basis\n    vec3 forward = camForward;\n    vec3 absUp = vec3(0.0, 0.0, 1.0);\n    vec3 up = normalize(absUp - dot(forward, absUp) * forward);\n    vec3 right = cross(forward, up);\n    \n    // Local coords go from -1.0 to 1.0 in y.\n    vec2 localCoord = (fragCoord - (iResolution.xy/2.0)) / (iResolution.y/2.0);\n    // angleOfView is the vertical half-angle in degrees\n    float aovFactor = tan(angleOfView * 3.1415926/180.0);\n    \n    vec3 direction = normalize(forward / aovFactor \n                     + localCoord.x * right \n                     + localCoord.y * up);\n    \n    return Ray(camPos, direction);\n}\n    \nRay cameraRay(vec2 fragCoord, vec3 camPos, vec3 camTarget,\n              float angleOfView, // in degrees\n              float aperture, // for depth of field\n              vec2 focusPoint, // coordinates in pixels\n              inout int seed) {\n    /* In which direction should we shoot a ray from the camera ?\n\n\tIncludes a depth-of-field effect.\n\t*/\n    \n    // Find 3D position of the focus target\n    vec3 trueForward = normalize(camTarget-camPos);\n    Ray focusRay = cameraRayNonrandom(focusPoint, camPos, trueForward, angleOfView);\n    //Ray focusRay = Ray(camPos, trueForward);\n    Intersection intersect;\n    float focusDistance = sceneIntersect(focusRay, intersect);\n    //focusDistance = clamp(focusDistance, 0.1, T_MAX);\n    // New \"center of screen\"\n    vec3 focusTarget = camPos + focusDistance * trueForward;\n    \n    \n    // randomize camera position for depth of field\n    vec3 camPosRand = camPos + randomInSphere(seed) * aperture;\n    // but make sure whatever is at the focus distance remains in focus\n    vec3 focusForward = normalize(focusTarget - camPosRand);\n    \n    // Jitter pixel position for antialiasing\n    fragCoord.x += random(seed)-0.5;\n    fragCoord.y += random(seed)-0.5;\n    \n    return cameraRayNonrandom(fragCoord, camPosRand, focusForward, angleOfView);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pick a camera position\n    float theta = 4.;\n    // float theta = 4. + iTime*0.1; // Move camera around for a blurry mess\n    vec3 cubeCenter = vec3(0.5);\n    vec3 camPos = vec3(3.*sin(theta/2.), 3.*sin(theta/3.), 1. * sin(theta/2.)) + cubeCenter;\n    camPos.z = abs(camPos.z);\n    vec3 camTarget = cubeCenter;\n    vec2 focusPoint = vec2(0.5, 0.5) * iResolution.xy; // Screen-space location of focus point\n    \n    // RNG seed\n    int seed = 22695477*int(fragCoord.x) + 19*int(fragCoord.y) + 96827 * iFrame;\n    //int seed = iFrame;\n    \n    // Do the raytracing: take a bunch of samples\n    vec3 pxColor = vec3(0.);\n    Ray camRay;\n    for(int i=0; i<NUM_SAMPLES; i++){\n        camRay = cameraRay(fragCoord, camPos, camTarget, 10., 0.05, focusPoint, seed);\n        pxColor += CalculateRadiance(camRay, NUM_BOUNCES, seed);\n    }\n    vec4 new = vec4(pxColor/float(NUM_SAMPLES), 1.0);\n    \n    // Blend the new picture with the old one\n    vec4 old = texture(iChannel0, fragCoord / iResolution.xy);\n    float frame = float(iFrame);\n    if (frame > .5)\n    \tfragColor = ((frame - 1.0) * old + new) / frame;\n    else \n        fragColor = new;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat random(inout int seed){\n    seed = (48271 *seed + 1) % 0xffffff;\n    return fract(float(seed)/float(1<<10));\n}\n\nfloat noise(float p){\n    p = fract(p * .6173);\n    p *= p + 47.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 randomInSphere(inout int seed){\n    vec3 co;\n    int bailout = 10;\n    co.x = 2.*random(seed)-1.;\n    co.y = 2.*random(seed)-1.;\n    co.z = 2.*random(seed)-1.;\n    while(length(co) > 1. && bailout>0){\n    \tco.x = 2.*random(seed)-1.;\n    \tco.y = 2.*random(seed)-1.;\n    \tco.z = 2.*random(seed)-1.;\n        bailout--;\n    }\n    if(length(co) > 1.){\n        return normalize(co);\n    }\n    return co;\n}\n\nvec3 randomUnit(inout int seed){\n    return normalize(randomInSphere(seed));\n}\n\nvec3 randomUnitInHemisphere(inout int seed, vec3 normal){\n    vec3 co = randomUnit(seed);\n    if(dot(co, normal) >= 0.)\n        return co;\n    return -co;\n        \n}","name":"Common","description":"","type":"common"}]}