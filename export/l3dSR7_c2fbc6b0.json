{"ver":"0.1","info":{"id":"l3dSR7","date":"1718873887","viewed":124,"name":"Grass Plain","username":"Timbrhoggvandi","description":"Just testing some raymarched grass with quadratic shape and constant arc length.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Mostly done with this for now, might add specular lighting and write better AO later\n\n#define PI 3.1415926535897932384626433832795\n#define E 2.718281828459045235360287471352\n\n/* RAYMARCH SETTINGS */\n#define VERTICAL_FOV 1.0\n#define MAX_ITERATIONS 512\n#define MAX_DISTANCE 70.0\n#define HIT_DISTANCE 0.1\n#define BOUNDING_BOX_BUFFER 0.05\n#define MAX_STEP 999.0\n\n/* GRASS SETTINGS*/\n#define REPETITION_PERIOD 0.125\n#define GRASS_LENGTH_MIN 0.4\n#define GRASS_LENGTH_RANGE 0.25\n#define GRASS_WIDTH 0.2\n#define TILT_RANGE 0.15\n#define ROTATION_RANGE 0.05\n\n/* LIGHTING AND COLOR */\n#define SUN_DIRECTION normalize(vec3(-0.2, 1, -0.3))\n#define COL_SUNLIGHT vec3(1.0, 1.0, 0.97)\n#define ID_GRASS 0\n#define ID_GROUND 1\n#define ID_SKY 2\n#define COL_GRASS vec3(0.19,1.0,0.19)\n#define COL_GROUND vec3(0.055,0.043,0.027)\n#define COL_SKY vec3(0.396,0.788,0.984)\n\nstruct RaymarchInfo {\n    vec3 point;\n    float rayDistance;\n    int matId;\n    bool hit;\n};\n\nstruct MapInfo {\n    vec4 coord;\n    float dist;\n    int matId;\n};\n\nstruct GrassInfo {\n    vec4 localCoord;\n    float dist;\n};\n\n// Not good hash functions. They're fast though\nfloat hash12(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*513.324765);\n}\n\nvec2 hash22(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*vec2(319.6731201, 193.83039));\n}\n\nvec2 rotate2D(vec2 p, float angle) {\n    return vec2(p.x*cos(angle) - p.y*sin(angle), p.x*sin(angle) + p.y*cos(angle));\n}\n\nfloat getTilt(vec2 point) {\n    float tilt = cos(0.5*point.x+0.25*sin(point.y - iTime) - iTime);\n    return 0.75*tilt*tilt - 0.07;\n}\n\nfloat getRotation(vec2 point) {\n    return 2.3*cos(0.15 * point.x + 0.1*iTime) + 2.0*sin(0.18 * point.y + 0.11*iTime) + 0.1 * cos(2.2*iTime);\n}\n\n// iteration count for newton raphson method\n#define ITERATION_COUNT 4\n// finds a solution to a cubic for the form y = x^3 + px + q\nfloat newtonRaphson(float p, float q) {\n    float x = 0.5;\n    for(int i = 0; i < ITERATION_COUNT; i++) {\n        float y = x*x*x + p*x + q;\n        // performance impact of checking early exit condition outweights gains for low iteration count\n        #if (ITERATION_COUNT) > 4\n            if(abs(y) < 0.001) {\n                break;\n            }\n        #endif\n        float tangent = 3.0*x*x + p;\n        x = x - y/tangent;\n    }\n    return x;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdV(vec3 point, float w1, float w2) {\n    return min(sdCapsule(point, vec3(-w1/2.0, 0.0, 0.0), vec3(w1/2.0, 0.0, w2/2.0), w2/10.0),\n               sdCapsule(point, vec3(-w1/2.0, 0.0, 0.0), vec3(w1/2.0, 0.0, -w2/2.0), w2/10.0));\n}\n\nGrassInfo sdGrassBlade(vec3 point, float tilt, float l, float w, float crossSectionRotation) {\n    point /= l;\n    \n    // find minimum distance to  x = a*y^2\n    // by finding root of distance squared's derivative\n    float tiltSquared = tilt*tilt;\n    float a = tiltSquared*4.0;\n    float p = (2.0 - 4.0*tilt*point.x) / a;\n    float q = (-2.0*point.y) / a;\n    float y = newtonRaphson(p, q);\n    \n    // find arc length at the point of minimum distance, and y where the arc length is 1\n    // arc length of x = a * y^2 is approximated as (a^2 / 2.0 - 0.03*a^3) * y^3 + y\n    float aArc = tiltSquared/2.0 - 0.03*tiltSquared*tilt;\n    float arcLen = point.y + aArc*point.y*point.y*point.y;\n    arcLen = min(1.0, max(0.0, arcLen));\n    // approximation found using least squares regression\n    float arc1y = (1.0 - 0.39336943*abs(tilt) + 0.0540685*tiltSquared + 0.1227849*sqrt(abs(tilt)));\n    \n    // limit curve to arc between 0 and 1\n    y = max(y, 0.0);\n    y = min(y, arc1y);\n    \n    float x = tilt * y * y;\n    \n    vec3 closestPoint = vec3(x, y, 0) - point;\n    closestPoint.xy = rotate2D(closestPoint.xy, atan(2.0*tilt*y));\n    closestPoint.xz = rotate2D(closestPoint.xz, crossSectionRotation);\n    \n    w *= (1.0 - pow(arcLen, 1.4));\n    \n    GrassInfo grassInfo;\n    grassInfo.dist = l*sdV(closestPoint, w/5.0, w) - 0.001;\n    w = max(w, 0.001);\n    grassInfo.localCoord = vec4(closestPoint.x, arcLen, closestPoint.z, w);\n    \n    return grassInfo;\n}\n\nGrassInfo evalDomain(vec3 point, vec2 id) {\n    vec2 translation = 0.01 + (REPETITION_PERIOD-0.02) * hash22(id);\n    vec2 globalCellCoord = REPETITION_PERIOD * id + translation;\n    \n    float tilt = getTilt(globalCellCoord) + TILT_RANGE * cos(hash12(id+13.23) + 0.8*iTime);\n    float rotation = getRotation(globalCellCoord) + ROTATION_RANGE * cos(hash12(id+31.9132) + iTime);\n    float crossSectionRotation = 2.0*PI*hash12(71.8349+id) - rotation;\n    float l = GRASS_LENGTH_MIN + hash12(6.21875+id) * GRASS_LENGTH_RANGE;\n    float w = GRASS_WIDTH * l;\n    \n    point.xz -= globalCellCoord;\n    point.xz = rotate2D(point.xz, rotation);\n    GrassInfo grassInfo = sdGrassBlade(point, tilt, l, w, crossSectionRotation);\n    return grassInfo;\n}\n\nGrassInfo sdGrassField(vec3 point, float maxDist) {\n    GrassInfo closestGrass;\n    \n    vec2 id = point.xz;\n    float tilt = getTilt(id);;\n    float rotation = getRotation(id);\n    \n    float yBound = point.y / (GRASS_LENGTH_MIN + GRASS_LENGTH_RANGE + 0.19);\n    id.xy -= vec2(cos(rotation), -sin(rotation)) * yBound * yBound * tilt;\n    id = floor(id / REPETITION_PERIOD - 0.5);\n    \n    closestGrass.dist = maxDist;\n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n            GrassInfo grassInfo = evalDomain(point, id + vec2(i,j));\n            if(grassInfo.dist < closestGrass.dist) {\n                closestGrass = grassInfo;\n            }\n        }\n    }\n    \n    return closestGrass;\n}\n\nMapInfo map(vec3 point, float maxDist) {\n    MapInfo mapInfo = MapInfo(vec4(point,0), 999.0, ID_SKY);\n    \n    float tilt = getTilt(point.xz);\n    float maxLength = GRASS_LENGTH_MIN + GRASS_LENGTH_RANGE;\n    \n    mapInfo.dist = point.y - maxLength * (1.0 - 0.39336943*abs(tilt) + 0.0540685*tilt*tilt + 0.1227849*sqrt(abs(tilt)));\n    \n    if(mapInfo.dist < BOUNDING_BOX_BUFFER) {\n        GrassInfo grassInfo = sdGrassField(point, maxDist);\n        mapInfo.dist = grassInfo.dist;\n        mapInfo.matId = ID_GRASS;\n        mapInfo.coord = grassInfo.localCoord;\n    }\n    \n    float groundPlane = length(point.y);\n    if(groundPlane < mapInfo.dist) {\n        mapInfo.dist = groundPlane;\n        mapInfo.matId = ID_GROUND;\n        mapInfo.coord = vec4(point,0);\n    }\n    \n    return mapInfo;\n}\n\n// returns info about where the ray hits as well as the near miss with the most pixel coverage\nRaymarchInfo[2] raymarch(vec3 ro, vec3 rd, int maxIterations, float maxDistance, out float coverage) {\n    RaymarchInfo[2] info;\n    info[0].point = ro;\n    info[0].rayDistance = 0.0;\n    info[0].matId = ID_SKY;\n    info[0].hit = false;\n    \n    MapInfo mapInfo;\n    MapInfo prevMapInfo = MapInfo(vec4(ro,0), 999.0, ID_SKY);\n    float prevRayDist = 0.0;\n    vec3 prevPoint = ro;\n    \n    //float pixelScale = tan(VERTICAL_FOV/(2.0*iResolution.y));\n    float pixelScale = tan(VERTICAL_FOV/(iResolution.y));\n    coverage = 0.0;\n    float totalCoverage = 0.0;\n    \n    for(int i = 0; i < maxIterations; i++) {\n        mapInfo = map(info[0].point, max(REPETITION_PERIOD*0.1*info[0].rayDistance, 0.05));\n        \n        float pixelSize = info[0].rayDistance * pixelScale;\n        \n        if(mapInfo.dist < pixelSize*HIT_DISTANCE) {\n            info[0].hit = true;\n            info[0].matId = mapInfo.matId;\n            break;\n        }\n        \n        if(info[0].rayDistance > maxDistance) {\n            break;\n        }\n        \n        if(mapInfo.dist > prevMapInfo.dist) {\n            float tempCoverage = 0.5*max((pixelSize - prevMapInfo.dist)/pixelSize - totalCoverage, 0.0);\n            totalCoverage += tempCoverage;\n            if(tempCoverage > coverage) {\n                coverage = tempCoverage;\n                info[1] = RaymarchInfo(prevPoint, prevRayDist, prevMapInfo.matId, true);\n            }\n        }\n        \n        prevMapInfo = mapInfo;\n        prevRayDist = info[0].rayDistance;\n        prevPoint = info[0].point;\n        \n        info[0].rayDistance += mapInfo.dist;\n        info[0].point = ro + info[0].rayDistance*rd;\n    }\n    \n    return info;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.00001;\n    return normalize(\n        e.xyy * map(p + e.xyy, MAX_STEP).dist +\n        e.yyx * map(p + e.yyx, MAX_STEP).dist +\n        e.yxy * map(p + e.yxy, MAX_STEP).dist +\n        e.xxx * map(p + e.xxx, MAX_STEP).dist);\n}\n\n\n// this ambient occlusion isn't great, rewrite at some point\nfloat ambientOcclusion(vec3 point) {\n    float ao = 1.0;\n    float d = 0.02;\n    float scale = 0.25;\n    vec3 normal = calcNormal(point);\n    for(float i = 0.0; i < 4.0; i++) {\n        float distField = map(point + d * normal, MAX_STEP).dist;\n        ao -= scale * (d - distField)/d;\n        d += 0.05;\n    };\n    \n    return clamp(ao, 0.0, 1.0);\n}\n\n\nfloat shadow(vec3 point, vec3 lightDirection, float lightDistance, float penumbraCoefficient) {\n    float light = 1.0;\n    float rayDist = 0.0;\n    point += 0.01*calcNormal(point);\n    for(int i = 0; i < 32; i++) {\n        float dist = map(point + lightDirection*rayDist, MAX_STEP).dist;\n        if(dist < 0.05*HIT_DISTANCE) {\n            light = 0.0;\n            break;\n        }\n        light = min(light, penumbraCoefficient*dist/rayDist);\n        rayDist += max(dist, 0.01);\n        if(rayDist > lightDistance) {\n            return light;\n        }\n    }\n    return light;\n}\n\nfloat valueNoise(vec2 coord) {\n    vec2 f = fract(coord);\n    vec2 i = floor(coord);\n    \n    vec2 a = f * f * (3.0 - 2.0 * f);\n    \n    float v00 = hash12(i);\n    float v10 = hash12(i + vec2(1, 0));\n    float v01 = hash12(i + vec2(0, 1));\n    float v11 = hash12(i + vec2(1, 1));\n    \n    return mix(\n        mix(v00, v10, f.x),\n        mix(v01, v11, f.x),\n        f.y);\n}\n\nfloat fbm(vec2 coord, int octaves) {\n    float scale = 0.45;\n    float sum = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        sum += scale * valueNoise(coord);\n        scale *= 0.6;\n        coord /= 0.42;\n    }\n    return sum;\n}\n\nvec3 lighting(RaymarchInfo info, vec3 rd) {\n    vec3 col;\n    vec3 colApprox;\n    vec3 normOffset = vec3(0);\n    MapInfo mapInfo = map(info.point, MAX_STEP);\n    float distanceScale = exp2(-0.1*info.rayDistance);\n    switch(info.matId) {\n        case ID_GRASS:\n            col = COL_GRASS;\n            col *= mix(0.65, 0.65 - 0.35*cos(2.0*PI*mapInfo.coord.z/mapInfo.coord.w) + 0.15*cos(20.0*mapInfo.coord.z/mapInfo.coord.w), distanceScale);\n            col *= 0.25 + 0.75*mapInfo.coord.y;\n            colApprox = COL_GRASS * 0.55;\n            break;\n        case ID_GROUND:\n            col = COL_GROUND;\n            col *= fbm(mapInfo.coord.xz*15.0, 5);\n            colApprox = COL_GROUND * 0.7;\n            break;\n        case ID_SKY:\n            col = COL_SKY;\n            col -= 0.5*rd.y;\n            break;\n    }\n    vec3 colUnlit = col*0.05;\n    if(info.hit) {\n        vec3 normal = calcNormal(info.point);\n        vec3 directLight = COL_SUNLIGHT*clamp(dot(SUN_DIRECTION, normal), 0.0, 1.0);\n        directLight *= shadow(info.point, SUN_DIRECTION, 100.0, 12.0);\n        \n        vec3 indirectLight = vec3(0.05,0.11,0.05)*ambientOcclusion(info.point);\n        \n        vec3 normApprox = normalize(vec3(1.0, getTilt(info.point.xz), 0.0));\n        normApprox.xz = rotate2D(normApprox.xz, getRotation(info.point.xz));\n        vec3 directLightApprox = COL_SUNLIGHT*((abs(dot(normApprox, SUN_DIRECTION)) + 0.2) * 0.6);\n        directLight = mix(directLightApprox, directLight, distanceScale);\n        \n        vec3 indirectLightApprox = vec3(0.05,0.11,0.05)*0.5;\n        indirectLight = mix(indirectLightApprox, indirectLight, distanceScale);\n        \n        col = mix(colApprox, col, distanceScale);\n        \n        vec3 light = directLight + indirectLight;\n        col = col*light;\n        vec3 atmosphere = exp2(-0.0035*info.rayDistance*vec3(1,1.5,2));\n        col = mix(vec3(0.8), col, atmosphere);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 1.2, 0);\n    vec3 rd = normalize(vec3(uv, 1.0 / tan(0.5 * VERTICAL_FOV)));\n    rd.yz = rotate2D(rd.yz, 0.3*PI*iMouse.y/iResolution.y);\n    rd.xz = rotate2D(rd.xz, 2.0*PI*iMouse.x/iResolution.x);\n    \n    float coverage;\n    RaymarchInfo[2] info = raymarch(ro, rd, MAX_ITERATIONS, MAX_DISTANCE, coverage);\n    \n    vec3 col = lighting(info[0], rd);\n    \n    // mix with nearest miss to reduce aliasing, similar to https://www.shadertoy.com/view/ctVBRG\n    if(coverage > 0.0) {\n        vec3 nearMissCol = lighting(info[1], rd);\n        col = mix(col, nearMissCol, coverage);\n    }\n    \n    // Blurs everything, but makes it slightly less aliasy at least\n    col = mix(col, texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz, 0.4);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}