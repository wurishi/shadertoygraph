{"ver":"0.1","info":{"id":"ldScWh","date":"1491874956","viewed":354,"name":"Turbo Cross","username":"hclarke","description":"based off guil's marble: https://www.shadertoy.com/view/MtX3Ws\nand kali's star nest: https://www.shadertoy.com/view/XlfGRj","likes":6,"published":1,"flags":96,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(in vec3 pos) {\n\tfloat cross = sdBox(pos-vec3(0.0,-0.5,0.0),vec3(1.2,0.3,0.3));  \n    cross = min(cross,sdBox(pos, vec3(0.3,1.5,0.3)));\n    cross = max(cross,-sdBox(pos,vec3(0.2,1.4,0.2)));\n    cross = max(cross,-sdBox(pos-vec3(0.0,-0.5,0.0),vec3(1.1,0.2,0.2)));\n    return cross;\n}\n\nfloat pnorm(vec3 v, float p) {\n    vec3 one = vec3(1.,1.,1.);\n    vec3 pv = pow(abs(v),p*one);\n \treturn pow(dot(pv,one),1./p);\n}\n\nvoid rotate(inout vec2 v, vec2 rot) {\n \tv = v*rot + v.yx * vec2(rot.x,-rot.y);\n}\nfloat calc_dist(vec3 p, vec3 c,vec2 rx, vec2 ry, vec2 rz) {\n\n    rotate(c.yz,rx);\n    rotate(c.xy,rz);\n    rotate(c.xz,ry);\n    return exp(-100. * abs(dot(p,c)));\n}\nvec3 map(in vec3 p, vec2 rx, vec2 ry, vec2 rz) {\n\t\n\tvec3 res = vec3(0,0,0);\n\tp *= .8;\n    vec3 c = p;\n    \n    \n\tfor (int i = 0; i < 2; ++i) {\n        //p =.6*abs(p)/dot(p,p) -.6;\n        p = abs(p)-.4;\n        \n        //p.yz= csqr(p.yz);\n        p=p.zxy;\n        res.x += calc_dist(p,c,rx,ry,rz);\n        res.y += calc_dist(p,c,ry,rz,rx);\n        res.z += calc_dist(p,c,rz,rx,ry);\n        \n\t}\n\treturn res*0.9;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, vec2 rx, vec2 ry, vec2 rz)\n{\n   \tvec3 one3 = vec3(1.,1.,1.);\n    float t = tminmax.x;\n    \n    vec3 col= vec3(0.);\n    vec3 c = one3 * 0.;\n    for( int i=0; i<64; i++ )\n\t{ \n        vec3 a = step(t,one3*tminmax.y);\n        t+=0.02;//*exp(-2.0*c.x);\n        vec3 pos = ro+t*rd;\n        a *= step(scene(pos),0.0);\n        t += max(0.,scene(pos));\n        c= map(pos, rx, ry, rz);\n        \n        col = mix(col, .99*col+ .08*c, a);\n    }\n    \n    vec3 c0 = vec3(.99,.0,.0);\n    vec3 c1 = vec3(.99,.1,.0);\n    vec3 c2 = vec3(.99,.3,.0);\n    \n    return c0 * col.x + c1 * col.y + c2 * col.z;\n}\n\n\n// Star Nest by Pablo RomÃ¡n Andrioli\n// This content is under the MIT License.\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.100\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.550\n\nvec3 stars(vec3 from, vec3 dir) {\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    return v * 0.005;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*1.5;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n    \n    \n\n    // camera\n\n    vec3 ro = vec3(4.);\n    vec4 starSpeed = texture(iChannel0, vec2(.5,.25));\n    float starLen = 1.-starSpeed.z;\n    vec3 starCol = stars(ro+vec3(0,0,1)*starSpeed.w, normalize(vec3(p.xy, starLen)));\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.3*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm;\n    \n    tmm.x = -3.0;\n    tmm.y = 100.0;\n    float ax = texture(iChannel0, vec2(0.25, 0.25)).x;\n    float ay = texture(iChannel0, vec2(0.5, 0.25)).x+1.;\n    float az = texture(iChannel0, vec2(0.75, 0.25)).x+2.;\n    vec2 rx = vec2(sin(ax),cos(ax));\n    vec2 ry = vec2(sin(ay),cos(ay));\n    vec2 rz = vec2(sin(az),cos(az));\n    vec3 col = raymarch(ro,rd,tmm, rx, ry, rz)*4.;\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    col += starCol * max(vec3(0,0,0),vec3(1,1,1)-col);\n    fragColor = vec4( col, 1.0 );\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtX3Ds","filepath":"https://soundcloud.com/lazerhawk/lazerhawk-overdrive","previewfilepath":"https://soundcloud.com/lazerhawk/lazerhawk-overdrive","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 old = texture(iChannel1, uv);\n    vec4 sound = texture(iChannel0, uv);\n    vec4 new = vec4(0,0,0,1);\n    fragColor = vec4(old.x + sound.x*iTimeDelta, sound.x, 0.,1.);\n    fragColor.z = old.z + (sound.x-old.z)/(0.9/iTimeDelta);\n    fragColor.w = old.w + fragColor.z * iTimeDelta;\n}","name":"Buffer A","description":"","type":"buffer"}]}