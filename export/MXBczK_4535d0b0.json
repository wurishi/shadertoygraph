{"ver":"0.1","info":{"id":"MXBczK","date":"1727924016","viewed":64,"name":"Drought","username":"Locust42","description":"A project done for my high school English class. This was my first experience with raymarching and creating a landscape. Feedback and tips are greatly appreciated!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This project is meant to represent the opening scene of the Grapes of Wrath by John Steinbeck.\n * After the last rains have left Oklahoma, the conditions of the dust bowl get worse and worse.\n * The plants begin to die, the sky is covered in dust, and the Earth begins to crack. \n *\n * I wanted to explore this in my shader using the technique of raymarching. Basically, the raymarching \n * algorithm works by sending out rays, analogous to \"lines-of-sight\" from your eyes, and checking them \n * against mathematical equations that define shapes. If the equations return a value of zero, then we \n * know that there is something in our line of sight and we should draw a pixel there.\n *\n * What I find really artistically interesting about raymarching is that a few rays and intersections\n * define the entire world, the same way that in a book it's only a few words that define the entire world.\n *\n * This is my first experience with raymarching and obviously I'm not very good at it, yet. Still, I tried\n * to integrate my \"happy accidents\" into the art. For example, I used the messed up shadows caused by\n * me not knowing how to calculate the lighting properly to create cracks in the ground.\n *\n * Sources:\n *     https://blog.maximeheckel.com/posts/painting-with-math-a-gentle-study-of-raymarching/\n *     https://thebookofshaders.com/\n *     https://iquilezles.org/\n *     https://www.youtube.com/watch?v=BFld4EBO2RE\n *     https://www.shadertoy.com/view/4ttSWf\n */\n\n#define MAX_STEPS 100\n#define MAX_DIST 250.0\n#define SURFACE_DIST 0.01\n\n/* Credit Maxime Heckel\n *\n * Samples a texture and uses the derivatives of the \n * differences of the value to define random noise.\n */\nvec3 noised(vec2 pos) {\n    vec2 grid = floor(pos);          \n    vec2 frac = fract(pos);\n    vec2 smoothing = frac * frac * (3.0 - 2.0 * frac);\n\n    float nBL = textureLod(iChannel0, (grid + vec2(0.0, 0.0)) / 256.0, 0.0).x; // Bottom-left\n    float nBR = textureLod(iChannel0, (grid + vec2(1.0, 0.0)) / 256.0, 0.0).x; // Bottom-right\n    float nTL = textureLod(iChannel0, (grid + vec2(0.0, 1.0)) / 256.0, 0.0).x; // Top-left\n    float nTR = textureLod(iChannel0, (grid + vec2(1.0, 1.0)) / 256.0, 0.0).x; // Top-right\n\n    float noiseVal = nBL + \n                     (nBR - nBL) * smoothing.x + \n                     (nTL - nBL) * smoothing.y + \n                     (nBL - nBR - nTL + nTR) * smoothing.x * smoothing.y;\n\n    vec2 grad = 6.0 * frac * (1.0 - frac) * \n                (vec2(nBR - nBL, nTL - nBL) + \n                (nBL - nBR - nTL + nTR) * smoothing.yx);\n                \n    return vec3(noiseVal, grad);\n}\n\n/* Credit Maxime Heckel\n *\n * Layers increasingly detailed noise on top of\n * itself at a decreasing amplitude. New layers\n * have more variation in the noise, but change\n * the overall shape less.\n *\n * Finally I also sample some more noise to lower\n * the height of the terrain in places so that the\n * messed up shadows look like cracks in the ground.\n */\nfloat terrain(vec2 position) {\n  vec2 noisePosition = position * 0.06;\n  float height = 0.0;\n  float amplitude = 7.5;\n  vec2 displacement = vec2(0.0);\n  float scale = 2.75;\n  \n  mat2 rotationMatrix = mat2(.8,-.6,.6,.8);\n\n  for(int i = 0; i < 6; i++ ) {\n    vec3 noiseSample = noised(noisePosition);\n    displacement += noiseSample.yz;\n    height += amplitude * noiseSample.x / (dot(displacement, displacement) + 1.0);\n    amplitude *= -0.30;\n    height *= .85;\n    noisePosition = rotationMatrix * noisePosition * scale;\n  }\n  \n  return height * 3.0 + 0.2 * 1.0/(0.1 * iTime + 1.5) * step(0.3, texture(iChannel1, position * 0.005).x);\n}\n\n/* Credit Maxime Heckel\n * \n * A simple function that calculates the distance\n * that we use in our raymarching function to \n * represent how far from the camera shapes are.\n */\nfloat scene(vec3 position)\n{\n    float terrainDist = position.y - terrain(position.xz);\n    return terrainDist;\n}\n\n/* Credit Inigo Quilez (qtd. in Maxime Heckel)\n *\n * Approximates the gradient of the terrain\n * so that we can use it to calculate lighting.\n */\nvec3 getNormal(vec3 position) \n{\n    float epsilon = 0.01;\n    return normalize(vec3(\n        scene(vec3(position.x + epsilon, position.y, position.z)) - scene(vec3(position.x - epsilon, position.y, position.z)),\n        scene(vec3(position.x, position.y + epsilon, position.z)) - scene(vec3(position.x, position.y - epsilon, position.z)),\n        scene(vec3(position.x, position.y, position.z + epsilon)) - scene(vec3(position.x, position.y, position.z - epsilon))\n    ));\n}\n\n/* Credit Maxime Heckel\n *\n * Implements the raymarch algorithm.\n * We shoot out a bunch of rays from the origin\n * and proceed to move them closer to the objects\n * in the scene to see where we need to render them.\n */\nfloat raymarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float depth = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // marches the ray\n        vec3 position = rayOrigin + rayDir * depth;\n        float sceneDist = position.y - terrain(position.xz);\n        depth += sceneDist;\n        \n        if(depth > MAX_DIST || sceneDist < SURFACE_DIST)\n        { break; }\n    }\n    \n    return depth;\n}\n\n/* Credit Inigo Quilez\n *\n * Models the way light travels through the atmosphere.\n * This gives us a sense of depth in the shader and\n * also allows me to represent the dust that begins to \n * cover everything and obscure vision.\n */\nvec3 fog(vec3 col, float blend)\n{\n    vec3 attenuation = exp(-blend * 0.0025 * vec3(1.4, 1.2, 0.86) * abs((sin(iTime * 0.02) * 7.5)) - 0.2);\n    return attenuation * col + (1.0 - attenuation) * vec3(0.55, 0.55, 0.55);\n}\n\n/* Credit Inigo Quilez (qtd. in Maxime Heckel)\n *\n * Calculates the distance to a surface and\n * \"uses that to soften\" the edges of the shadows \n  * that we draw.\n */\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = scene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/* Credit Inigo Quilez\n *\n * Colors the sky a slightly deeper blue the higher up we look.\n * Uses random noise to create clouds.\n */\n \nvec3 sky(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 color = vec3(0.5, 0.6, 0.7) - 0.4 * rayDir.y;\n    \n    float cloudDist = (2500.0 - rayOrigin.y)/rayDir.y;\n    if (cloudDist > 0.0)\n    {\n        vec2 uv = (rayOrigin + rayDir * cloudDist).xz;\n        float cloudNoise = terrain(uv * 0.001 + iTime);\n        color = mix(color, vec3(1.0), smoothstep(0.15, 0.25, 0.05 * cloudNoise));\n    }\n    \n    return color;\n}\n\n/* Credit Maxime Heckel\n * \n * Does the actual work of drawing colors on to the screen and\n * brings everything together and calls all our other functions.\n * It also calculates the grass coverage and makes it decrease\n * and the grass grow more yellow as it dies.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1). Centered at the origin.\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 rayOrigin = vec3(0.0, 10.0, 5.0);\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    \n    vec3 lightPos = vec3(0.0, 20.0, -50.0);\n    \n    float dist = raymarch(rayOrigin, rayDir);\n    vec3 position = rayOrigin + rayDir * dist;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float grassCoverage = -0.1/iTime + 0.99;\n    \n    if (dist < MAX_DIST)\n    {\n        vec3 normal = getNormal(position);\n        vec3 lightDir = normalize(lightPos - position);\n        \n        float diffuse = max(dot(normal, lightDir), 0.0);\n        float shadows = softShadow(position, lightDir, 0.1, 5.0, 64.0);\n  \n        col = vec3(1.2, 0.6, 0.5); \n        col *= (1.0 - smoothstep(grassCoverage, grassCoverage + 0.01, normal.y)) +\n              smoothstep(grassCoverage, grassCoverage + 0.01, normal.y) * mix(vec3(0.3, 0.7, 0.2), vec3(0.9, 0.7, 0.5), iTime/20.0);\n        col *= diffuse * shadows;\n        col = fog(col, 50.0);\n    } else {\n        col = fog(sky(rayOrigin, rayDir), 50.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}