{"ver":"0.1","info":{"id":"XltGDl","date":"1472444643","viewed":935,"name":"Spaceballs / greebles","username":"LukeRissacher","description":"So, I see your Schwartz is as big as mine... an attempt at \"greebles\", little randomized bumps to create surface detail on high-tech things. ","likes":37,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","greeble","randomized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DEPTH = 50.0;\n\n\nfloat Rand(vec2 pos) {\n\treturn textureLod(iChannel0, pos / 64.0, 0.0).r;\n}\n\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\n\nfloat BoxDistance(vec3 localPos, vec3 size) {\n\tvec3 dist = abs(localPos) - 0.5 * size;\n\treturn max(dist.x, max(dist.y, dist.z));\n}\n\n\nfloat ShapeDistanceAt(vec3 pos, vec2 gridPos) {\n\n    // Start with the underlying plane\n\tfloat dMin = pos.y;\n\n\t// Randomize sub-shape based on grid pos\n\tvec3 gridCenter = vec3(gridPos.x + 0.5, 0.5, gridPos.y + 0.5);\n\tfloat rand = Rand(gridCenter.xz);\n\n\t// ... vanes (2 widths)\n\tif (rand < 0.2) {\n\t\tgridCenter.xy -= vec2(0.4, 0.7);\n\t\tpos.x = floor(pos.x) + mod(pos.x, 0.10);\n        float width = 0.4;\n        if (rand < 0.1) {\n        \twidth = 0.8;\n        }\n\t\tfloat dBox = BoxDistance(pos - gridCenter, vec3(0.09, 0.8, width));\n\t\tdMin = min(dMin, dBox);\n\t}\n\n\t// ... little box\n\telse if (rand < 0.4) {\n        \n\t\tgridCenter.y -= 0.35 + 0.4 * (rand - 0.25);\n\t\tfloat dBox = BoxDistance(pos - gridCenter, vec3(0.9, 0.2, 0.6));\n\t\tdMin = min(dMin, dBox);\n\n\t\t// ... antenna greebles\n\t\tfloat modStep = 0.5;\n\t\tfor (int i = 0; i < 3; i++) {\n            \n            // ... an attempt at randomizing x & z without another rand lookup\n\t\t\tvec3 greeblePos = gridCenter;\n\t\t\tgreeblePos.x += 1.0 * ((mod(rand, modStep) / modStep) - 0.5);\n\t\t\tmodStep *= 0.5;\n\t\t\tgreeblePos.z += 0.5 * ((mod(rand, modStep) / modStep) - 0.5);\n\t\t\tmodStep *= 0.5;\n\t\t\tfloat dGreeble = BoxDistance(pos - greeblePos, vec3(0.04, 1.3, 0.04));\n\t\t\tdMin = min(dMin, dGreeble);\n\t\t}\n\t}\n\n\t// ... big flat box\n\telse if (rand < 0.94) {\n\t\tgridCenter.y -= 0.3 + 0.5 * (rand - 0.5);\n\t\tfloat dBox = BoxDistance(pos - gridCenter, vec3(1.0, 0.2, 1.0));\n\t\tdMin = min(dMin, dBox);\n\n\t\t// ... box greebles\n\t\tfloat modStep = 0.5;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvec3 greeblePos = gridCenter;\n\t\t\tgreeblePos.x += 0.65 * ((mod(rand, modStep) / modStep) - 0.5);\n\t\t\tmodStep *= 0.5;\n\t\t\tgreeblePos.z += 0.65 * ((mod(rand, modStep) / modStep) - 0.5);\n\t\t\tmodStep *= 0.5;\n\t\t\tfloat height = 0.3 + 0.4 * mod(float(i + 1) * rand, modStep) / modStep;\n\t\t\tfloat dGreeble = BoxDistance(pos - greeblePos, vec3(0.45, height, 0.45));\n\t\t\tdMin = min(dMin, dGreeble);\n\t\t}\n\t}\n\n\t// ... sphere\n\telse {\n\t\tgridCenter.y -= 0.95;\n\t\tfloat dSphere = length(pos - gridCenter) - 0.6;\n\t\tdMin = min(dMin, dSphere);\n\t}\n\n\treturn dMin;\n}\n\n\n// Scene distance function.\nfloat SceneDistance(vec3 pos) {\n\n\t// Limit ship height (build up front in steps)\n    pos.z += 3.0;\n    float height = 1.95 + clamp(floor(-pos.z / 6.0), 0.0, 1.35);\n\tif (abs(pos.x) > height || pos.z > 0.0) {\n\t\treturn MAX_DEPTH;\n\t}\n\n\t// Ignore details until ray gets close\n\tfloat objectTopDist = pos.y - 1.0;\n\tif (objectTopDist > 0.2) {\n\t\treturn objectTopDist;\n\t}\n\n\t// We're close: check adjacent shapes in view dir\n\tvec2 gridPos = floor(pos.xz);\n\tfloat dist = \n\t\tmin(\n\t\t\tmin(\n\t\t\t\tShapeDistanceAt(pos, gridPos), \n\t\t\t\tShapeDistanceAt(pos, gridPos + vec2(0, 1))\n\t\t\t),\n\t\t\tmin(\n\t\t\t\tShapeDistanceAt(pos, gridPos + vec2(1, 0)), \n\t\t\t\tShapeDistanceAt(pos, gridPos + vec2(-1, 0))\n\t\t\t)\n\t\t);\n\n\treturn dist;\n}\n\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.005) {\n        \treturn depth;\n        }\n        depth += 0.99 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.02;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\t// Set up view\n    vec3 eyePos = vec3(-0.2, 7.0, -3.0 - 1.5 * iTime);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * radians(45.0)) * 0.5 * iResolution.y));\n\trayDir.xz = Rotate(rayDir.xz, radians(-43.0));\n\trayDir.xy = Rotate(rayDir.xy, radians(-90.0));\n    \n    \n    // Do the raymarch; if we hit...\n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n\n\t\t// ... normal \n        vec3 pos = eyePos + rayDir * depth;\n        vec3 normal = SceneNormal(pos);\n\n\t\t// ... ambient occlusion\n\t\tfloat ao = 0.0;\n\t\tconst float AO_STEP = 0.07;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfloat stepDist = float(i) * AO_STEP;\n\t\t\tvec3 aoPos = pos - stepDist * rayDir;\n\t\t\tfloat aoDist = SceneDistance(aoPos);\n\t\t\tao += 5.2 * (1.0 / float(i + 1)) * (stepDist - aoDist);\n\t\t}\n\t\tao = clamp(1.0 - ao, 0.0, 1.0);\n\n\t\t// ... texturing\n        float tex = 0.0;\n        float texScale = 1.0;\n        for (int i = 0; i < 4; i++) {\n            tex += texture(iChannel0, pos.xz * texScale * 0.08).r / texScale;\n            texScale *= 2.0;\n        }\n        tex /= 1.5;\n\n        // ... lighting\n        vec3 lightDir = normalize(vec3(0.5, 0.8, -0.6));\n        float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0) * 1.4;\n    \tvec3 lightViewHalf = normalize(lightDir - rayDir);\n    \tfloat specular = 0.8 * pow(clamp(dot(normal, lightViewHalf), 0.0, 1.0), 25.0);\n        float distanceFade = pow(1.0 - depth / MAX_DEPTH, 2.0);\n\t\tfloat value = (diffuse + specular) *  distanceFade * ao * mix(0.5, 1.0, tex);\n        value *= clamp(iTime * 0.1, 0.0, 1.0);\n    \tfragColor.rgb = value * vec3(0.75, 0.85, 1.0);\n    }\n    \n    // If we didn't hit...\n    else {\n        \n        // ... sky gradient + stars\n        vec2 uv = fragCoord / iResolution.y;\n        float star = texture(iChannel0, Rotate(0.01 * fragCoord, radians(20.0))).r;\n        if (star < 0.90) {\n        \tstar = 0.0;\n        }\n        else {\n            star = (star - 0.90) * 10.0;\n        }\n        fragColor.rgb = vec3(0.05, 0.0, 0.15) + star;\n        fragColor.rgb *= abs(uv.y - 0.5);\n    }\n\t\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// Note freq's\nconst float A0=27.5, Bb0=29.13524, B0=30.86771, C1=32.7032, Db1=34.64783, D1=36.7081, Eb1=38.89087, \n    E1=41.20344, F1=43.65353, Gb1=46.2493, G1=48.99943, Ab1=51.91309, A1=55.0, Bb1=58.27047, \n    B1=61.73541, C2=65.40639, Db2=69.29566, D2=73.41619, Eb2=77.78175, E2=82.40689, F2=87.30706, \n    Gb2=92.49861, G2=97.99886, Ab2=103.8262, A2=110.0, Bb2=116.5409, B2=123.4708, C3=130.8128, \n    Db3=138.5913, D3=146.8324, Eb3=155.5635, E3=164.8138, F3=174.6141, Gb3=184.9972, G3=195.9977, \n    Ab3=207.6523, A3=220.0, Bb3=233.0819, B3=246.9417, C4=261.6256, Db4=277.1826, D4=293.6648, \n    Eb4=311.127, E4=329.6276, F4=349.2282, Gb4=369.9944, G4=391.9954, Ab4=415.3047, A4=440.0, \n    Bb4=466.1638, B4=493.8833, C5=523.2511, Db5=554.3653, D5=587.3295, Eb5=622.254, E5=659.2551, \n    F5=698.4565, Gb5=739.9888, G5=783.9909, Ab5=830.6094, A5=880.0, Bb5=932.3275, B5=987.7666, \n    C6=1046.502, Db6=1108.731, D6=1174.659, Eb6=1244.508, E6=1318.51, F6=1396.913, Gb6=1479.978, \n    G6=1567.982, Ab6=1661.219, A6=1760.0, Bb6=1864.655, B6=1975.533, C7=2093.005, Db7=2217.461, \n    D7=2349.318, Eb7=2489.016, E7=2637.02, F7=2793.826, Gb7=2959.955, G7=3135.963, Ab7=3322.438, \n    A7=3520.0, Bb7=3729.31, B7=3951.066;\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nfloat Rand1d(float pos) {\n    return texture(iChannel0, vec2(pos / 64.0, pos / 4096.0)).r;\n} \n\nfloat SmoothRand1d(float pos, float stepSize) {\n    pos /= stepSize;\n    float intPart = floor(pos); \n    float fractPart = fract(pos); \n    float thisSample = Rand1d(intPart);\n    float nextSample = Rand1d(intPart + 1.0);\n    return Cubic(thisSample, nextSample, fractPart);\n}\n\nfloat AhdEnvelope(float t, float attackTime, float holdTime, float decayTime) {\n\tfloat attackAmp = clamp(t / attackTime, 0.0, 1.0);\n    float decayAmp = clamp((attackTime + holdTime + decayTime - t) / decayTime, 0.0, 1.0);\n    return attackAmp * decayAmp;\n}\n\nfloat CombStrings(float time, float freq, float brightness, float breathiness) {\n    float samp = 0.0;\n    float combDelay = 1.0 / freq;\n    float combFeedback = mix(0.999, 0.7, pow(breathiness, 0.5));\n    float combAmp = 1.0;\n    float totalAmp = 0.0;\n    float freqMultiplier = mix(10.0, 300.0, brightness);\n    for (int i = 0; i < 32; i++) {\n        samp += SmoothRand1d(time - combDelay * float(i), \n            (1.0 / (freqMultiplier * freq))) * combAmp;\n        totalAmp += combAmp;\n        combAmp *= combFeedback;\n    }\n    return clamp(samp / totalAmp, 0.0, 1.0);\n}\n\nvec2 CombStringsStereo(float time, float freq, float brightness, float breathiness) {\n    return vec2(\n        CombStrings(time + 0.0, freq, brightness, breathiness),\n        CombStrings(time + 0.1, freq, brightness, breathiness)\n    );\n}\n\nvec2 mainSound( in int samp,float time) {\n    \n    float noteLength = 0.5;\n    float noteTime = mod(time / noteLength, 34.0);\n    \n    // 0..8: silence\n    float amp1 = 0.0;\n    float amp2 = 0.0;\n    if (noteTime < 8.0) { \n    }\n    // 8..16: 1st bar\n    else if (noteTime < 16.0) {\n        amp1 = AhdEnvelope(noteTime - 8.0, 1.0, 1.0, 3.0);\n    }\n    // 16..24: 2nd bar\n    else if (noteTime < 24.0) {\n        float barTime = noteTime - 16.0;\n        amp1 = AhdEnvelope(barTime, 1.0, 0.0, 2.5);\n        amp2 = AhdEnvelope(barTime - 1.0, 0.5, 0.5, 3.0);\n    }\n    // 24..32: 3rd bar\n    else {\n        float barTime = noteTime - 24.0;\n        amp1 = AhdEnvelope(barTime, 1.0, 0.0, 2.5) +\n            AhdEnvelope(barTime - 2.0, 1.0, 4.5, 2.5);\n        amp2 = AhdEnvelope(barTime - 1.0, 0.5, 0.5, 1.0);\n    }\n    \n    amp1 = 0.40 * amp1 * amp1;\n    amp2 = 0.40 * amp2 * amp2;\n   \n    // Synthesize\n    float highAmp = 0.7;\n    vec2 lowStrings1 = CombStringsStereo(time, Bb1, 0.020, 0.7) * amp1; \n    vec2 lowStrings2 = CombStringsStereo(time, B1, 0.020, 0.7) * amp2; \n    vec2 midStrings1 = CombStringsStereo(time, F2, 0.035, 0.08) * amp1 * highAmp;\n    vec2 midStrings2 = CombStringsStereo(time, Gb2, 0.035, 0.08) * amp2 * highAmp;\n    vec2 highStrings1 = CombStringsStereo(time, Db3, 0.03, 0.07) * amp1 * highAmp;\n    vec2 highStrings2 = CombStringsStereo(time, D3, 0.03, 0.07) * amp2 * highAmp;\n    vec2 rumble = 0.1 * vec2(\n        SmoothRand1d(time + 0.0, 0.0018), \n        SmoothRand1d(time + 0.1, 0.0018)\n    );\n    \n    // Mix\n    vec2 mixOut = rumble + \n        lowStrings1 + lowStrings2 + \n        midStrings1 + midStrings2 + \n        highStrings1 + highStrings2;\n    return mixOut;\n    \n}","name":"Sound","description":"","type":"sound"}]}