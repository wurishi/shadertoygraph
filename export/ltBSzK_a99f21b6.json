{"ver":"0.1","info":{"id":"ltBSzK","date":"1444958725","viewed":2484,"name":"learning Ray Sphere Intersection","username":"edwinz","description":"Simple ray sphere intersection by ray tracing. After I learn from these awesome people's code...&lt;br/&gt;I still didn't get how to set the uv and set the camera in a general way... Is there anyone can give me some explanation about these magic math?","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3draytracingtutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learn from \n// https://www.shadertoy.com/view/XsB3Rm\n// https://www.shadertoy.com/view/ldS3DW\n// https://www.shadertoy.com/view/MllSRj\n// You guys awesome!\nconst int max_iteration = 255;\nconst float epsilon = 0.001;\nconst float clip_far = 1000.0;\n\n// GLOBALY Define Sphere\nvec4 sph1 = vec4( 0.0, 1.0, 0.0, 1.0 );\nvec4 sph2 = vec4( 2.0, 2.0, 0.0, 1.0);\n\nstruct sphere{\n    vec4 pos;\n    float rad;\n};\n\nsphere a;\n\n// Thanks for IQ's ray sphere instruction\n// https://iquilezles.org/blog/?p=2411\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph, in float rad) {\n\t// This is relating directly to parametric equation\n    // where we define a function xyz = ro + t*rd\n    // solving the quadradic equation below\n \tvec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float t = b*b - c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    return t;\n\n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nvec3 Gradient( vec3 pos){\n    vec3 eps = vec3( epsilon, 0.0, 0.0 );\n\treturn pos;\n    \n}\n\nfloat iPlane(in vec3 ro, in vec3 rd) {\n\t// equation of a plane, y=0 = ro.y + t*rd.y\n    return -ro.y/rd.y;\n}\n\nfloat Intersect( in vec3 ro, in vec3 rd, out float res_t){\n\tres_t = clip_far;\n    float id = -1.0; // id means the idx for identifying the obj type of intersection\n    float tsph1 = iSphere(ro, rd, sph1, 1.0);\n    if(tsph1 > 0.0){\n        res_t = tsph1;\n        id = 1.0;\n    }\n    float tsph2 = iSphere(ro, rd, sph2, 1.0); \n    if(tsph2 > 0.0 && tsph2 < res_t){\n        res_t = tsph2;\n        id = 2.0;\n    }\n    float tpla = iPlane(ro, rd);\n    if(tpla >0.0 && tpla < res_t){ // if I interesect with t and this is before the sphere\n\t\tres_t = tpla;\n        id = 0.0;\n    }\n    \n     return id;\n}\n\n// good method\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, -dot(rd, light));\n\tfloat sky = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\n\n// Camera rotation\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = -normalize( cross(cw,cp) );\n\tvec3 cv = -normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Rendering\nvec3 radiance(in vec3 ro, in vec3 rd){\n\t // Intersect contains all the geo detection\n    float t;\n\tfloat idx = Intersect(ro, rd, t);\n    \n    // Compute light\n    vec3 light = normalize(vec3(sin(iTime), 0.57703, cos(iTime)));    \n    vec3 col = vec3(0.3, 0.3, 0.3);\n    if( idx == 1.0){\n        // sphere1\n        vec3 p = ro + t*rd;\n        vec3 n = nSphere(p, sph1);\n        float diff = clamp(dot(n, light),0.0,1.0);\n        float ao = 0.5 + 0.5*n.y; // ambient oclusion trick\n        col = vec3( 0.9, 0.6, 0.3 )*diff*ao + vec3(0.1,0.2,0.4)*ao; \n        col = sqrt(col);\n        \n    } else if(idx == 2.0){\n        // sphere2\n        vec3 p = ro + t*rd;\n        vec3 n = nSphere(p, sph2);\n        float diff = clamp(dot(n, light),0.0,1.0);\n        float ao = 0.5 + 0.5*n.y; // ambient oclusion trick\n        col = vec3( 0.9, 0.6, 0.3 )*diff*ao + vec3(0.1,0.2,0.4)*ao; \n        col = sqrt(col);\n       \n    }else if (idx == 0.0){\n        // Ground\n        vec3 p = ro + t*rd;\n        vec3 n = vec3(0.0, 1.0, 0.0);\n        // compute checkboard\n        float f = checkersGradBox( 0.5*p.xz );\n        \n        // setting the oppsite rd\n        vec3 bgcol = background(iTime, -rd);\n        float diff = clamp(dot(n,bgcol),0.0,1.0);\n        // ambient oclusion trick\n        float amb1 = smoothstep(0.0, 2.0*sph1.w*sph1.y, length(p.xz-sph1.xz)); // ambient oclusion trickk\n        float amb2 = smoothstep(0.0, 2.0*sph2.w*sph2.y, length(p.xz-sph2.xz)); // ambient oclusion trickk\n        col = vec3(amb1*0.1 + amb2*0.1 + diff) + f * vec3(0.1);\n        col = sqrt(col);\n        \n    } else {\n        // Sky and sun\n        vec3 p = vec3(0.0, 0.0, 0.0);\n        vec3 bgcol = background(iTime, rd);\n        vec3 n = normalize(p - (ro+rd*t));\n\t\trd = reflect(rd, n);\n\t\tcol = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n\t\tcol = mix(bgcol, col, step(0.0, t));       \n    } \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv are the pixel coordinates, from 0 to 1\n\t//vec2 uv = (fragCoord.xy / iResolution.xy);\n    // tan(radians(x)) here is for changing FOV\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y * tan(radians(22.5));\n    \n    //Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    (iMouse.z == 0.0) ?  mouse = vec2(0.0,.85) : mouse = mouse;       \n  \n   \t// Camera\n    // NEED TO DO UNDISTORT\n  \t// Don't understand this rd setting\n   \t // camera\n    vec3 ro = 10.0*normalize(vec3(sin(3.0*mouse.x), 0.4*mouse.y, cos(3.0*mouse.x)));\n\tvec3 ta = vec3(0.0, 1.5, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n     // ray\n    vec3 rd = ca * normalize( vec3(uv.xy,1.2));\n    \n    // render\n    vec3 col = radiance(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n   \n}","name":"Image","description":"","type":"image"}]}