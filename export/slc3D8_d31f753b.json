{"ver":"0.1","info":{"id":"slc3D8","date":"1636067384","viewed":92,"name":"Continuous Random Bézier Motion","username":"Qendolin","description":"Orbs along random, continuous bézier curves.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["bezier","orb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// More options in Buffer A\n\n// Enable dithering\n#define DITHER\n// Dither pattern channel index (1 - bayer, 2 - blue noise, 3 - white noise)\n#define DITHER_CHAN 1\n// Dither pattern channel name\n#define DITHER_CHAN_NAME iChannel1\n// Down-res factor\n#define PIXEL_SCALE 3.\n// Enable dither pattern jitter\n#define DITHER_JITTER\n// Jitter every n frames\n#define DITHER_JITTER_FRAMES 6\n// Bits per channel\nconst ivec3 COLOR_BITS = ivec3(3,3,3);\nconst vec3 COLORS = vec3(1<<COLOR_BITS.r-1,1<<COLOR_BITS.g-1,1<<COLOR_BITS.b-1);\n\n// shitty rand bc I don't care\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat stepRound(float step, float x) {\n\tif(fract(x) > step) return ceil(x);\n    else return floor(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scaled fragCoord\n    vec2 txCoord = floor(fragCoord/PIXEL_SCALE)*PIXEL_SCALE;\n    vec2 uv = txCoord/iResolution.xy;\n    vec3 inCol = texture(iChannel0, uv).rgb;\n#ifndef DITHER\n    fragColor.rgb = inCol;\n#else\n    vec2 ditherRes = iChannelResolution[DITHER_CHAN].xy;\n    vec2 ditherCoord = floor(fragCoord/PIXEL_SCALE);\n  #ifdef DITHER_JITTER\n    int jitterFrame = (iFrame%30)/DITHER_JITTER_FRAMES;\n    ditherCoord += ditherRes * vec2(rand(vec2(jitterFrame,0)), rand(vec2(0,jitterFrame)));\n  #endif\n    float ditherVal = texelFetch(DITHER_CHAN_NAME, ivec2(mod(ditherCoord, ditherRes)), 0).r;\n    \n    fragColor.r = stepRound(ditherVal, inCol.r*COLORS.r) / COLORS.r;\n    fragColor.g = stepRound(ditherVal, inCol.g*COLORS.g) / COLORS.g;\n    fragColor.b = stepRound(ditherVal, inCol.b*COLORS.b) / COLORS.b;\n#endif  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GAMMA_CORRECT 1.55\n#define BRIGHT_CORRECT -0.01\n#define ORB_COUNT 30\n\n#define TAU 6.28318530718\n\n\n// Credit: https://newbedev.com/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n    return x;\n}\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash(v.x ^ hash(v.y)); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct(uint m) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat(m);       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random(float x) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random(vec2  v) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// returns the point on the curve at [t]\nvec2 toBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    float t2 = t * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    return (p0 * one_minus_t2 * one_minus_t + p1 * 3.0 * t * one_minus_t2 + p2 * 3.0 * t2 * one_minus_t + p3 * t2 * t);\n}\n\nfloat drawOrb(vec2 p, float s, float speed, float size) {\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n\n    float t = iTime*speed+s;\n    // current time step, when it changes the positions change too\n    float n = floor(t);\n    // fraction of current time step\n    float f = t-n;\n    \n    float hadleDist = 0.5;\n    \n    // 1. pick random positions for p0 and p3\n    // 2. pick a random distance and direction for the handles p1 and p2\n    //    and use that as an offset from p0 and p3\n    // 3. use -handle(n-1) for p1 and handle(n) for p2 so that there are\n    //    no sharp direction changes when n changes\n    \n    // n*3 + 0..3 is the key to make the bezier curve connected\n    // n=1:\n    //      p0: vec2(random(3), random(3.5))\n    //      p3: vec2(random(6), random(6.5))\n    // n=2:                 |-----------|--------- same values for the last point of n and the first of n+1\n    //      p0: vec2(random(6), random(6.5))\n    //      p3: vec2(random(9), random(9.5))\n    vec2 p0 = vec2(random(n*3. + 0. + s), random(n*3. + 0.5 + s)) * 1.1 - 0.05;\n    vec2 p3 = vec2(random(n*3. + 3. + s), random(n*3. + 3.5 + s)) * 1.1 - 0.05;\n    \n    // n*3 - 1 is the same as (n-1)*3 + 2 to ensure handle continuity\n    // angle\n    float p1a =              random(n*3. - 1.  + s) * TAU;\n    // distance\n    float p1d = -hadleDist * random(n*3. - 0.5 + s);\n    vec2 p1 = p0 + p1d * vec2(cos(p1a), sin(p1a));\n    \n    float p2a =              random(n*3. + 2.  + s) * TAU;\n    float p2d = hadleDist *  random(n*3. + 2.5 + s);\n    vec2 p2 = p3 + p2d * vec2(cos(p2a), sin(p2a));\n\n    vec2 bz = toBezier(p0, p1, p2, p3, f);\n    // inspired by https://www.shadertoy.com/view/Nl3GWr\n    float d = distance(p, bz*aspect) / size;\n    return (1. / pow(d, GAMMA_CORRECT)+BRIGHT_CORRECT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 p = uv * aspect;\n    \n    for(int i = 0; i < ORB_COUNT; i++) {\n        float seed = random(float(i));\n        \n        // orbs can dissapear for a while\n        float hide = clamp((0.4+sin(iTime/5.+seed*TAU))*10., 0., 1.);\n        if(hide == 0.) continue;\n        \n        // magic numbers like 1.1675 can be any number\n        float hue = random(seed*1.1675) + fract(iTime/12.);\n        float sat = 0.9 * random(seed*1.7151) * (1. + sin(iTime/7.+seed*TAU));\n        float size = random(seed*1.5125) * 0.04 + 0.01;\n        size = max(size + 0.02 * sin(iTime/17.+seed*TAU), 0.01);\n        float speed = 0.05 * (1. - size/0.07);\n        vec3 col = hsl2rgb(vec3(hue, 0.5+sat, 0.7));\n        float v = drawOrb(p, seed, speed, size);\n        v *= hide;\n        fragColor.rgb += col * v;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}