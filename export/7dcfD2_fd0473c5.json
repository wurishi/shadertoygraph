{"ver":"0.1","info":{"id":"7dcfD2","date":"1657213502","viewed":122,"name":"Newton3D","username":"pb","description":"newton's method in 3d, no reference to roots though, volumetric color accumulated along rays by taking \"Newton\" steps in 3d and doing stuff differently than the 2d complex newton fractal","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","newtonsmethod","volumetriccolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define newton_iter 7.\nfloat timefac;\n\nvec3 newton_color( vec3 p ) {\n\n    p = mod(p-2.,4.)-2.;\n    vec3 q, color=vec3(0.); mat3 dq;\n    for (float i=0.;i<newton_iter;i++) {\n    \n        //you can plug and play with your own \n        //vector functions and derivatives here\n        float pxx=p.x*p.x,pyy=p.y*p.y,pzz=p.z*p.z;\n        //vector function\n        q = vec3(p.y*pyy, p.z*pzz, p.x*pxx) - vec3(-3.1);\n        //matrix of partial derivatives\n        dq = mat3( 0.,0.,3.*pxx,\n                   3.*pyy,0.,0.,\n                   0.,3.*pzz,0.);\n                   \n        p -= (1.-timefac)*inv3d(dq) * q;  //the \"Newton Step\"\n        \n        if ( p.x*p.y > 0. ) color.x++;\n        if ( p.y*p.z > 0. ) color.y++;\n        if ( p.z*p.x > 0. ) color.z++;\n    }\n    \n    return color/newton_iter;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float mt = mod(iTime,30.);\n    vec3 ro = vec3(0.,0.,0.);\n\n    if (mt > 12. ) {\n        float t1 = 3.;\n        float tt = mod( (mt-12.)/3.,2.*t1);\n    \n        timefac = tt;\n        if ( tt>t1 ) timefac = t1 - mod(tt,t1);\n    }\n    else if (mt>2.) {\n    \n        float xx = sin( (mt-2.)/2.*1.2);\n        ro = vec3(-xx,-xx,-xx );\n    \n    }\n    \n    \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y/3.*(1.+timefac);\n    \n    vec3 rd = normalize( vec3(uv,-1.4) );\n    \n    vec3 p = ro;\n    \n    //get oriented to the good place using angle axis rotation\n    //overkill here but I wanted to code it\n    rd = angle_axis_rotation(rd, vec3(1.,0.,0.), -.65);\n    rd = angle_axis_rotation(rd, vec3(0.,1.,0.), .8);\n    \n    vec3 color = vec3(0.);\n    float totdist = 0.;\n    float stepsize = .015*(1.+timefac/5.);\n    \n    //doing raymarch not measuring any distances but accumulating\n    //color along the path, more of a volumetric density kind of thing\n    for (float i=0.; i<80.; i++) {\n    \n        totdist += stepsize;\n        float tt = totdist*totdist; tt*=tt;\n        color += newton_color(p) / (1.+tt);\n        p += stepsize * rd;\n    }\n    \n    color = cos(color/32.);\n    color *= color;\n    \n    fragColor = vec4(color,1.);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define too_small 1e-8\n\n//common math objects everyone knows about and can use freely\n\nvec3 angle_axis_rotation( vec3 v, vec3 k, float a ) {\n\n    //rotates vector:v around axis: k (normalized) by angle:a\n    //https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n    //Euler already knew it though..\n    \n    //Please use it, Abuse it!\n    float cc=cos(a), ss=sin(a);\n    \n    return v*cc + cross(k,v)*ss + k*dot(k,v)*(1.-cc);\n}\n\n\nmat3 inv3d( mat3 a ) {\n\n    //good ol' fashioned inverse of 3x3 matrix\n    //Please use it, Abuse it!\n\n    //determinant\n    float det = \n        a[0][0] * a[1][1] * a[2][2] \n      + a[1][0] * a[2][1] * a[0][2]\n      + a[2][0] * a[0][1] * a[1][2]\n      - a[2][0] * a[1][1] * a[0][2]\n      - a[1][0] * a[0][1] * a[2][2]\n      - a[0][0] * a[2][1] * a[1][2];\n \n    if ( abs(det) < too_small ) \n    { det = sign(det) * 1./too_small; }\n    else { det = 1./det; }\n\n    return det * \n    mat3( a[1][1]*a[2][2]-a[2][1]*a[1][2], a[2][0]*a[1][2]-a[1][0]*a[2][2], a[1][0]*a[2][1]-a[2][0]*a[1][1],\n          a[2][1]*a[0][2]-a[0][1]*a[2][2], a[0][0]*a[2][2]-a[2][0]*a[0][2], a[2][0]*a[0][1]-a[0][0]*a[2][1],\n          a[0][1]*a[1][2]-a[1][1]*a[0][2], a[1][0]*a[0][2]-a[0][0]*a[1][2], a[0][0]*a[1][1]-a[1][0]*a[0][1] );\n\n}\n\n\n","name":"Common","description":"","type":"common"}]}