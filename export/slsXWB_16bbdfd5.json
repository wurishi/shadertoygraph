{"ver":"0.1","info":{"id":"slsXWB","date":"1626481011","viewed":144,"name":"Ursuppe","username":"joeydee","description":"experimental Frühstücksmüsli @ t_verdauung(0.5f)\n(a quick'n'dirty hack and proof of concept how to create some organic procedural patterns)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","perlin","organic","microscope","hangover"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//just experimenting ...\n//gtz joeydee\n\n\n//std 2d noise\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n//std 2d interpolated noise\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float res = mix(\n        mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x),\n        mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);\n    return res;\n}\n\n//std 3d noise\nfloat rand(vec3 n) {\n    return fract(sin(dot(n, vec3(12.9898, 4.1414,7.5531))) * 43758.5453);\n}\n\n//std 3d interpolated noise\nfloat noise(vec3 p){\n    vec3 ip = floor(p);\n    vec3 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float a0=rand(ip);\n    float a1=rand(ip + vec3(1.0, 0.0, 0.0));\n    float a2=rand(ip + vec3(0.0, 1.0, 0.0));\n    float a3=rand(ip + vec3(1.0, 1.0, 0.0));\n    float ares = mix(\n        mix(a0, a1, u.x),\n        mix(a2, a3, u.x), u.y);\n    float b0=rand(ip + vec3(0.0, 0.0, 1.0));\n    float b1=rand(ip + vec3(1.0, 0.0, 1.0));\n    float b2=rand(ip + vec3(0.0, 1.0, 1.0));\n    float b3=rand(ip + vec3(1.0, 1.0, 1.0));\n    float bres = mix(\n        mix(b0, b1, u.x),\n        mix(b2, b3, u.x), u.y);\n    return mix(ares,bres,u.z);\n}\n\n//somewhat perlin noise\nfloat perlin(vec2 p){\n    int numOctaves=8;\n    float H=1.2;\n    float t = 0.0;\n    for (int i = 0; i < numOctaves; i++)\n    {\n        float f = pow(2.0, float(i));\n        float a = pow(f, -H);\n        t += a * noise(f * p);\n    }\n    return t; \n}\n\n          \n//organic dots\nfloat dotNoise(vec2 p, float d){\n    float res=noise(p*50.0+100.0)*d;\n    res*=noise(p*70.0+10.0)*d;\n    res*=noise(p*90.0+50.0)*d;\n    res=1.0-res*res*res*res;\n    return clamp(res,0.0,1.0);\n}\n\nfloat dotNoise(vec3 p, float d){\n    float res=noise(p*50.0+100.0)*d;\n    res*=noise(p*70.0+10.0)*d;\n    res*=noise(p*90.0+50.0)*d;\n    res=1.0-res*res*res*res;\n    return clamp(res,0.0,1.0);\n}\n\n//turbulence lookup vector\nvec2 turbulence(vec2 p, float s, float w){\n    return vec2(p.x+perlin(p*s+12345.0)*w,p.y+perlin(p*s+67890.0)*w);\n}\n\n//a simple gradient lookup\nfloat grad1(float f, float k){\n     return 1.0-pow( 4.0*f*(1.0-f), k ); \n}\n\n//a simple color lookup\nvec3 colmap(float h, float t, float g){\n     return vec3(h+t,h*(1.0+g),h-t); \n}\n\n\n//experimenteller statischer Flockenbrei\nfloat organicShice(vec2 p){\n    float hue=0.7;\n    hue*=dotNoise(p*0.3+300.0, 1.4)*0.3+0.7;                      //large dots\n    hue*=dotNoise(turbulence(p,20.0,0.2)*0.3+300.0, 1.3)*0.5+0.5; //turbulence dots\n    hue*=perlin(turbulence(p, 10.0, 0.5)*20.0)*0.3+0.7;           //turbulence perlin\n    hue*=grad1(dotNoise(p*0.5, 1.3), 10.0)*0.6+0.4;               //hollow dots\n    hue*=dotNoise(p, 1.2)*0.7+0.3;                                //small dots\n    hue*=(perlin(p*15.0))*0.4+0.6;                                //perlin\n    return hue;\n}\n\n//Frühstücksmüsli @ t_verdauung(0.5f)\nfloat movingOrganicShice(vec2 p){\n    float hue=0.7;\n    vec3 p3=vec3(p,iTime*0.003);//depth offset\n    vec2 o=vec2(sin(iTime*0.3)*0.4+iMouse.x*0.01,iTime*0.2+iMouse.y*0.01);//moving\n    vec3 o3=vec3(o,0);\n    hue*=dotNoise(((p3+o3*0.1)*2.0)*0.3+300.0, 1.4)*0.3+0.7;                        //large dots\n    hue*=dotNoise(iTime*0.005+turbulence(p+o*0.134,20.0,0.2)*0.2+300.0, 1.3)*0.5+0.5; //turbulence dots\n    hue*=perlin(iTime+turbulence(p+o*0.12, 10.0, 0.5)*20.0)*0.3+0.7;                //turbulence perlin\n    hue*=grad1(dotNoise((p3+o3*0.13)*0.5, 1.3), 10.0)*0.6+0.4;                      //hollow dots\n    hue*=dotNoise((p+o*0.11), 1.2)*0.7+0.3;                                         //small dots\n    hue*=dotNoise((p+o*0.12)+1000.0, 1.3)*0.6+0.4;                                   //more dots\n    hue*=(perlin((p+o*0.05)*15.0))*0.4+0.6;                                         //perlin\n    return hue;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = fragCoord/iResolution.xx;\n\n    // Output to screen\n    //fragColor = vec4(colmap(organicShice(p),-0.2,0.4), 1.0);                                      //static example\n    fragColor = vec4(colmap(movingOrganicShice(p),-cos(iTime*0.1+0.9)*0.3,sin(iTime*0.007+0.5)*0.5), 1.0);  //dynamic example\n}\n\n\n","name":"Image","description":"","type":"image"}]}