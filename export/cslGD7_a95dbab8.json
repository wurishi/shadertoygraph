{"ver":"0.1","info":{"id":"cslGD7","date":"1666235201","viewed":152,"name":"Industrial Embankment Structure","username":"jt","description":"Working on a structure that smoothly connects voxels by ramps and (inverse) cones and somewhat resembles hydraulic engineering.","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["architecture","construction","structure","industrial","hydraulic","embankment","engineering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/mdX3W4 industrial embankment by jt\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// efficient voxel tracing based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy) which implements DDA based on http://lodev.org/cgtutor/raycasting.html\n// Basic functionality (intersection & raymarching primitives) based on iq's https://iquilezles.org/articles/distfunctions\n\n// Industrial Embankment Structure - written 2022 by Jakob Thomsen\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Working on a structure that smoothly connects voxels by ramps and (inverse) cones and somewhat resembles hydraulic engineering.\n\n// tags: architecture, construction, structure, industrial, hydraulic, embankment, engineering\n\n// TODO: exact distance for ridges (if possible)\n// TODO: simplify inverted cones\n// TODO: fix flickering on bounding-box\n\n//#define ISOMETRIC_VIEW\n\n#define pi 3.1415926\n\n#define EPSILON 0.001\n\n#define MAX_DIST 1000.0\n\n\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x)\n{\n    return float(triple32(x)) / float(0xffffffffU);\n}\n\nuint uhash(ivec2 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y)));\n\n    // TEST\n    if(v.xy == ivec2(0,0)) return 1u;\n    if(v.xy == ivec2(1,0)) return 1u;\n    if(v.xy == ivec2(0,1)) return 1u;\n    if(v.xy == ivec2(-1,2)) return 1u;\n    return 0u;\n}\n\nbool bhash(ivec2 v)\n{\n    return (uhash(v) & 1u) != 0u;\n}\n\nfloat hash(ivec2 v)\n{\n    return float(triple32(uint(v.x) + triple32(uint(v.y)))) / float(0xffffffffU);\n}\n\n//float hash(uvec2 v)\n//{\n//    return float(uhash(v)) / float(0xffffffffU);\n//}\n/*\nuint uhash(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n*/\n// modified https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 s )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST);\n    return vec2( tN, tF );\n}\n\n// primitives from https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec2 p)\n{\n    vec2 q = abs(p) - 1.0;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdBox(vec3 p)\n{\n    vec3 d = abs(p) - 1.0;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n\n// modified https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, float r, float h0, float h1 )\n{\n    p.z -= h0;\n    vec2 q = vec2(r,h1-h0);\n\n    vec2 w = vec2( length(p.xy), p.z );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\n    return sqrt(d)*sign(s);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat tetrahedron(vec3 p, float size, float roundness) // by iq (add a bit of roundness makes false alarms go away!)\n{\n    p.xyz = p.xzy;\n\n    const float k = sqrt(2.0);\n\n    p *= size;\n\n    p.xz = abs(p.xz);\n\n    float m = 2.0*p.z - k*p.y - 1.0;\n\n    p = (m>0.0) ? p : vec3(p.z,-p.y,p.x);\n\n    float s1 = clamp(p.x,0.0,1.0);\n    float s2 = clamp((p.x-p.y*k-p.z+2.0)/4.0,0.0,1.0);\n\n    m = 2.0*p.z - k*p.y - 1.0;\n\n    float d = sign(m)*sqrt((sign(p.y*k+p.z+1.0)+sign(2.0-3.0*p.x-k*p.y-p.z)<1.0)\n                  ?\n                  min( dot2(vec3(s1,-k*0.5,0)-p),\n                       dot2(vec3(s2, k*0.5-k*s2,1.0-s2)-p) )\n                  :\n                  m*m/6.0 );\n\n    return d / size - roundness;\n}\n\nfloat sdWedge0(vec2 p)\n{\n    float a = sdBox(p);\n    p = vec2(-p.x+p.y,p.x+p.y+2.)*.5; // rotate, scale, shift\n    float b = sqrt(2.0)*sdBox(p);\n    return max(a, b);\n}\n\nfloat sdWedge1(vec2 p)\n{\n    float a = sdBox(p);\n    p = vec2(p.x+p.y,-p.x+p.y+2.)*.5; // rotate, scale, shift\n    float b = sqrt(2.0)*sdBox(p);\n    return max(a, b);\n}\n\nfloat sdWedgeW(vec3 p)\n{\n    vec2 w = vec2(sdWedge0(p.xz), abs(p.y) - 1.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdWedgeE(vec3 p)\n{\n    vec2 w = vec2(sdWedge1(p.xz), abs(p.y) - 1.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdWedgeS(vec3 p)\n{\n    vec2 w = vec2(sdWedge1(p.yz), abs(p.x) - 1.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdWedgeN(vec3 p)\n{\n    vec2 w = vec2(sdWedge0(p.yz), abs(p.x) - 1.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat cone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x/c.y,-1.0);\n\n    vec2 w = vec2( length(p.xy), p.z );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat circle( vec3 p, float r )\n{\n    return length(vec2(length(p.xy)-r,p.z));\n}\n\nfloat halfspace(vec3 p)\n{\n    return p.z;\n}\n\nfloat cylindrical_hollow(vec3 p, float r)\n{\n    return\n        p.z -2.+length(p.xy)< 0.0 ? max(halfspace(p), -cone(vec3(0,0,-2)-p, vec2(1), 50.0)) :\n        length(p.xy) >= r ? halfspace(p) :\n        circle(p, r);\n}\n\nvec2 Union(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersect(vec2 a, vec2 b)\n{\n    return a.x > b.x ? a : b;\n}\n\n// Transformed https://www.shadertoy.com/view/XsdBW8 helix 1 by FabriceNeyret2\n// to a hyperbolic paraboloid:\n//  * adjust number of rotations\n//  * replace bounding cylinder by bounding unit box\n//  * adjust rotation angle to match diagonals\n//  * straighten-out intersection of helix with box-wall to line\n// Unfortunately not an exact euclidean sdf.\nfloat approx_hyperbolic_paraboloid(vec3 q) // https://www.shadertoy.com/view/DdX3zr approx hyperbolic paraboloid sdf by jt\n{\n    float t = sdBox(q, vec3(1,1,1)); // bounding box\n    t = max(t, abs(sin(atan(q.y,q.x)-q.z*0.95/*???*//sqrt(1.+q.z*q.z/2.)))/3./*noglitch*/ * min(1.,length(q.xy))); // hyperbolic paraboloid\n    //t = max(t, abs(sin(atan(q.y,q.x)-q.z*pi/4.0))/3. * min(1.,length(q.xy))); // original helix\n    return t;\n}\n\nvec2 sdMixed(vec3 p, ivec3 cell) // returns distance & material\n{\n    vec2 res = vec2(MAX_DIST, 0.0);\n\n    if(cell.z != 0) return res;\n\n    bvec2 offset = bvec2(cell & 1);\n    cell = cell >> 1;\n\n    if(!offset.x && !offset.y) // center\n    {\n        bool h = bhash(cell.xy+ivec2(0,0));\n        if(h) res = Union(res, vec2(sdBox(p, vec3(0.5)), 13.56));\n    }\n    if(offset.x && !offset.y) // west-east connection\n    {\n        bool h0 = bhash(cell.xy+ivec2(0,0));\n        bool h1 = bhash(cell.xy+ivec2(1,0));\n        //if(h0 && h1) res = Union(res, vec2(sdSphere(p, 0.5), 3.));\n        if(h0 && h1) res = Union(res, vec2(sdBox(p, vec3(0.5)), 13.56));\n        if(!h0 && h1) res = Union(res, vec2(sdWedgeE(p*2.0)/2.0, 13.56));\n        if(h0 && !h1) res = Union(res, vec2(sdWedgeW(p*2.0)/2.0, 13.56));\n    }\n    if(!offset.x && offset.y) // south-north connection\n    {\n        bool h0 = bhash(cell.xy+ivec2(0,0));\n        bool h1 = bhash(cell.xy+ivec2(0,1));\n        //if(h0 && h1) res = Union(res, vec2(sdSphere(p, 0.5), 3.));\n        if(h0 && h1) res = Union(res, vec2(sdBox(p, vec3(0.5)), 13.56));\n        if(!h0 && h1) res = Union(res, vec2(sdWedgeS(p*2.0)/2.0, 13.56));\n        if(h0 && !h1) res = Union(res, vec2(sdWedgeN(p*2.0)/2.0, 13.56));\n    }\n    if(offset.x && offset.y) // diagonal\n    {\n        bool h00 = bhash(cell.xy+ivec2(0,0));\n        bool h10 = bhash(cell.xy+ivec2(1,0));\n        bool h01 = bhash(cell.xy+ivec2(0,1));\n        bool h11 = bhash(cell.xy+ivec2(1,1));\n        // center\n        if(h00 && h10 && h01 && h11) res = Union(res, vec2(sdBox(p, vec3(0.5)), 13.56));\n        // corner\n        if(h00 && !h10 && !h01 && !h11) res = Union(res, vec2(sdCone(p+vec3(+1,+1,0)/2.0,1.0,0.5,-0.5),13.56));\n        if(!h00 && h10 && !h01 && !h11) res = Union(res, vec2(sdCone(p+vec3(-1,+1,0)/2.0,1.0,0.5,-0.5),13.56));\n        if(!h00 && !h10 && h01 && !h11) res = Union(res, vec2(sdCone(p+vec3(+1,-1,0)/2.0,1.0,0.5,-0.5),13.56));\n        if(!h00 && !h10 && !h01 && h11) res = Union(res, vec2(sdCone(p+vec3(-1,-1,0)/2.0,1.0,0.5,-0.5),13.56));\n        // edge\n        if(!h00 && !h10 && h01 && h11) res = Union(res, vec2(sdWedgeS(p),13.56));\n        if(h00 && h10 && !h01 && !h11) res = Union(res, vec2(sdWedgeN(p),13.56));\n        if(!h00 && h10 && !h01 && h11) res = Union(res, vec2(sdWedgeE(p),13.56));\n        if(h00 && !h10 && h01 && !h11) res = Union(res, vec2(sdWedgeW(p),13.56));\n        // diagonal\n        mat3 R = mat3(vec3(sqrt(0.5),sqrt(0.5),0),vec3(-sqrt(0.5),sqrt(0.5),0), vec3(0,0,1));\n        //if(!h00 && h10 && h01 && !h11) res = Union(res, vec2(sdSphere(p, 0.5), 3.));\n        if(false)\n        {\n            if(false)\n            {\n                if(!h00 && h10 && h01 && !h11) res = Union(res, vec2( tetrahedron(p*R, sqrt(2.0), 0.0), 13.56)); // not the exact shape but looks ok from outside\n                if(h00 && !h10 && !h01 && h11) res = Union(res, vec2( tetrahedron(R*p, sqrt(2.0), 0.0), 13.56)); // not the exact shape but looks ok from outside\n            }\n            else\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    float d0 = min(sdCone(p+vec3(+1,-1,0)/2.0,1.0,0.5,-0.5),sdCone(p+vec3(-1,+1,0)/2.0,1.0,0.5,-0.5));\n                    float d1 = max(cylindrical_hollow(p*2.0+vec3(+1,+1,-1),1.0)/2.0,cylindrical_hollow(p*2.0+vec3(-1,-1,-1),1.0)/2.0);\n                    res = Union(res, vec2((d0+d1)/2.0,13.56)); // inexact\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    float d0 = min(sdCone(p+vec3(+1,+1,0)/2.0,1.0,0.5,-0.5),sdCone(p+vec3(-1,-1,0)/2.0,1.0,0.5,-0.5));\n                    float d1 = max(cylindrical_hollow(p*2.0+vec3(+1,-1,-1),1.0)/2.0,cylindrical_hollow(p*2.0+vec3(-1,+1,-1),1.0)/2.0);\n                    res = Union(res, vec2((d0+d1)/2.0,13.56)); // inexact\n                }\n            }\n        }\n        else\n        {\n            if(true)\n            /*\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    res = Union(res, vec2(min(sdCone(p+vec3(+1,-1,0)/2.0,1.0,0.5,-0.5),sdCone(p+vec3(-1,+1,0)/2.0,1.0,0.5,-0.5)),13.56));\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(min(sdCone(p+vec3(+1,+1,0)/2.0,1.0,0.5,-0.5),sdCone(p+vec3(-1,-1,0)/2.0,1.0,0.5,-0.5)),13.56));\n                }\n            }*/\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    mat3 R = mat3(0,-1,0,1,0,0,0,0,1);\n                    res = Union(res, vec2(approx_hyperbolic_paraboloid((R*p).xzy*2.0)/2.0, 13.56)); // bound\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(approx_hyperbolic_paraboloid((p).xzy*2.0)/2.0, 13.56)); // bound\n                }\n            }\n            else\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    res = Union(res, vec2(max(cylindrical_hollow(p*2.0+vec3(+1,+1,-1),1.0)/2.0,cylindrical_hollow(p*2.0+vec3(-1,-1,-1),1.0)/2.0), 13.56)); // bound\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(max(cylindrical_hollow(p*2.0+vec3(+1,-1,-1),1.0)/2.0,cylindrical_hollow(p*2.0+vec3(-1,+1,-1),1.0)/2.0), 13.56)); // bound\n                }\n            }\n        }\n        //if(h00 && h10 && h01 && !h11)  res = Union(res, vec2(sdSphere(p, 0.5), 3.));\n        if(h00 && h10 && h01 && !h11)  res = Union(res, vec2(cylindrical_hollow(p*2.0+vec3(-1,-1,-1),1.0)/2.0, 13.56));\n        if(!h00 && h10 && h01 && h11)  res = Union(res, vec2(cylindrical_hollow(p*2.0+vec3(+1,+1,-1),1.0)/2.0, 13.56));\n        if(h00 && !h10 && h01 && h11)  res = Union(res, vec2(cylindrical_hollow(p*2.0+vec3(-1,+1,-1),1.0)/2.0, 13.56));\n        if(h00 && h10 && !h01 && h11)  res = Union(res, vec2(cylindrical_hollow(p*2.0+vec3(+1,-1,-1),1.0)/2.0, 13.56));\n    }\n\n    res = Union(res, vec2(halfspace(p+vec3(0,0,0.5)), 3.));\n\n    return res;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n// raymarch subobject\nvec2 march(vec3 ro, vec3 rd, float tmin, float tmax, ivec3 cell)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        vec2 res = sdMixed(ro + rd * t, cell);\n        if(res.x < EPSILON)\n            return vec2(t, res.y);\n        t += res.x;\n    }\n    return vec2(MAX_DIST, 0.0);\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, ivec3 cell)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, cell).x +\n                     k.yyx * sdMixed(p + k.yyx * h, cell).x +\n                     k.yxy * sdMixed(p + k.yxy * h, cell).x +\n                     k.xxx * sdMixed(p + k.xxx * h, cell).x);\n}\n\n// voxel with environment (3x3x3) slow!\nfloat sdMixedWithEnv(ivec3 cell, vec3 offset)\n{\n    float d = MAX_DIST;\n    // naive method: 3x3x3 voxels\n    for(int z = -1; z <= +1; z++)\n    {\n        for(int y = -1; y <= +1; y++)\n        {\n            for(int x = -1; x <= +1; x++)\n            {\n\n    // kastorp's optimization: traverse only 2x2 tiles (instead of 3x3),\n    // chosen depending on where in the tile the current point is located.\n    //ivec3 oo = -ivec3(step(vec3(0), offset));\n    //for(int z = oo.y; z <= oo.z+1; z++)\n    //{\n    //    for(int y = oo.y; y <= oo.y+1; y++)\n    //    {\n    //        for(int x = oo.x; x <= oo.x+1; x++)\n    //        {\n                d = min(d, sdMixed(offset - vec3(x, y, z), cell + ivec3(x, y, z)).x);\n            }\n        }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\n// https://iquilezles.org/articles/distfunctions\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12*float(i) / 4.0;\n        ivec3 cell = ivec3(floor(pos + h*nor));\n        //uint id = getVoxelIndex(cell);\n        //float d = SDF_Voxel(pos + h*nor - vec3(cell) - vec3(0.5), id);\n        float d = sdMixedWithEnv(cell, pos + h*nor - vec3(cell) - vec3(0.5));\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);\n}\n\n#define MAX_GRID_STEPS 64\n\nstruct result\n{\n    float dist;\n    ivec3 cell;\n    float material;\n};\n\nresult voxelray(vec3 ro, vec3 rd, ivec3 ext)\n{\n    result res;\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            res.dist = 1.0;\n            res.material = 10.0;\n            return res;\n        }\n    }\n*/\n    vec3 dd = 1.0 / abs(rd);\n    ivec3 rs = ivec3(sign(rd));\n    res.dist = MAX_DIST;\n    res.cell = ivec3(floor(ro));\n    res.material = 0.0;\n\n    vec3 sd = (sign(rd) * (vec3(res.cell) - ro) + (sign(rd) * 0.5) + 0.5) * dd; // Setup of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n\n    for (int i = 0; i < MAX_GRID_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on some systems\n    {\n        //if (any(greaterThan(sign(rd) * vec3(res.cell), vec3(ext)))) break; // proceed until ray LEAVES level-box (but ENTER is OK, so level can be seen from outside)\n        if(all(lessThanEqual(abs(res.cell), ivec3(ext)))) // inside (odd)\n        //if(all(greaterThanEqual(res.cell, -ext)) && all(lessThan(res.cell, ext))) // inside (even)\n        {\n            //uint idx = getIdx(res.cell);\n            //if(idx > 0u) // skip empty voxels\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection( ro - vec3(res.cell) - vec3(0.5), rd, vec3(0.5) ); // bounding box\n\n                //if(idx != 0u)\n                {\n                    vec2 r = march(ro - vec3(res.cell) - vec3(0.5), rd, bounds.x, bounds.y, res.cell);\n\n                    if(r.x >= bounds.x && r.x <= bounds.y)\n                    {\n                        if(r.x >= 0.0) // required to catch corner-cases when ray starts in wall behind camera (duplicate close objects bug)\n                        {\n                            res.dist = r.x;\n                            res.material = r.y;\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        //else\n        //    return res;\n\n        // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n        //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec3 mask = lessThanEqual(sd.xyz, min(sd.yzx, sd.zxy));\n        sd += vec3(mask) * dd;\n        res.cell += ivec3(vec3(mask)) * rs;\n    }\n\n    return res;\n}\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.05);\n    my = (iMouse.y > 10.0) ? my : 1.25*pi / 2.0;\n\n    mat2 yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0, -12.5);\n    mat2 pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz = pitch * ro.yz;\n    ro.xy = yaw * ro.xy;\n    ro += 0.5; // center odd grid\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = pitch * rd.yz;\n    rd.xy = yaw * rd.xy;\n#ifdef ISOMETRIC_VIEW\n    {\n        ro = vec3(10,10,10)+8.0*vec3(+1,-1,0)*ndc.x+8.0*vec3(-1,-1,1)*ndc.y;\n        rd = normalize(-vec3(1,1,1));\n        // NOTE: rotation looks wrong in isometric view due to lack of perspective\n        //mat3 yaw = mat3(vec3(cos(mx), sin(mx),0.0), vec3(-sin(mx), cos(mx),0.0),vec3(0,0,1));\n        //ro = yaw * ro;\n        //rd = yaw * rd;\n    }\n#endif\n    ivec3 ext = ivec3(15,15,0);\n\n    vec3 color = vec3(0.0);\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            fragColor = vec4(0,0,0.5,1.0);\n            return;\n        }\n    }\n*/\n    result res = voxelray(ro, rd, ext);\n    /*\n    {\n        // p.z = o.z+d.z*t\n        // p.z-o.z = d.z*t\n        // (p.z-o.z)/d.z = t\n        float t = (0.5-ro.z)/rd.z;\n        if(t < res.dist)\n        {\n            res.dist = t;\n            res.material = 5.0;\n        }\n    }\n    */\n    if(res.dist < MAX_DIST)\n    {\n\n        vec3 lightdir = normalize(vec3(1.0,-2.0, 3.0));\n\n        vec3 dst = ro + rd * res.dist;\n\n        vec3 n = normal(dst - vec3(res.cell) - vec3(0.5), res.cell);\n\n        //color = vec3(1.0); // plain\n        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n        color = 0.2 + 0.2 * sin(res.material * 2.0 + vec3(0.0, 1.0, 2.0)); // color scheme from iq's primitives\n\n        float diffuse = max(dot(lightdir, n), 0.0);\n        vec3 hal = normalize(lightdir - rd);\n        float specular = pow(clamp( dot(n, hal), 0.0, 1.0), 16.0);\n             specular *= diffuse;\n             specular *= 0.04+0.96*pow(clamp(1.0-dot(hal,lightdir),0.0,1.0),5.0);\n        color += 5.00 * specular * vec3(1.30,1.00,0.70);\n\n        //color = 0.5 + 0.5 * vec3(texture(iChannel0, 0.1 * vec3(cell))); // some random colors to improve visualization\n      //color = 0.5 + 0.5 * hash33(0.1 * vec3(res.cell)); // some random colors to improve visualization\n\n        //color *= texture(iChannel0, dst).xyz;\n        //color *= vec3(0.5 + 0.5 * checker(dst * 8.0));\n        //color *= vec3(0.5 + 0.5 * checker(dst));\n        color *= vec3(0.5 + 0.5 * checker(vec3(dst.xy,0.0)));\n        //color *= vec3(0.5 + 0.5 * blob(dst));\n        //color *= 0.5 + 0.5 * vec3(texture(iChannel0, dst)); // 3d texture\n        //color *= 0.5 + 0.5 * hash33(dst); // 3d texture\n\n        //vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n      //color *= mix(fogcolor, color, exp(-res.dist * res.dist / 200.0)); // fog for depth impression & to suppress flickering\n\n        //float ao = calcAO(ro + rd * res.dist, n);\n        float ao = 1.0; // disabled\n        result shadow = voxelray(dst + n * 0.01, lightdir, ext);\n        float brightness = 0.1 * ao + diffuse * step(MAX_DIST, shadow.dist);\n\n        color *= brightness;\n    }\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}