{"ver":"0.1","info":{"id":"WsdBWB","date":"1605898181","viewed":83,"name":"Procedural reflection map","username":"hong1991","description":"Just an experiment in reading \"Texturing and Modeling: A Procedural Approach, 3rd edition\" Chap 2.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spline","reflectionmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// colors\n#define BROWN vec3(0.1307,0.0609,0.0355)\n#define BLUE0 vec3(0.4274,0.5880,0.9347)\n#define BLUE1 vec3(0.1221,0.3794,0.9347)\n#define BLUE2 vec3(0.1090,0.3386,0.8342)\n#define BLUE3 vec3(0.0643,0.2571,0.6734)\n#define BLUE4 vec3(0.0513,0.2053,0.5377)\n#define BLUE5 vec3(0.0326,0.1591,0.4322)\n#define BLACK vec3(0,0,0)\n\n/* Coefficients of basis matrix. */\n#define CROO -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nvec3 spline(in float x, in vec3 knots[13]) {\n    // knot_num should setted as the length of knots, \n    // you can achieve that by implement spline function using macro\n    const int KnotNum = 13;\n    \n    x = x*float(KnotNum-3);\n    int startIndex = int(x);\n    vec3 knot0 = knots[startIndex++];\n    vec3 knot1 = knots[startIndex++];\n    vec3 knot2 = knots[startIndex++];\n    vec3 knot3 = knots[startIndex];\n               \n    vec3 c0, c1, c2, c3;\n\tc0 = CROO*knot0 + CR01*knot1 + CR02*knot2 + CR03*knot3;\n\tc1 = CR10*knot0 + CR11*knot1 + CR12*knot2 + CR13*knot3;\n\tc2 = CR20*knot0 + CR21*knot1 + CR22*knot2 + CR23*knot3;\n\tc3 = CR30*knot0 + CR31*knot1 + CR32*knot2 + CR33*knot3;\n    \n    x = fract(x);\n    return ((c0*x+c1)*x+c2)*x+c3;\n}\n\nvec3 SphereMapColor(vec3 dir) {\n    // Time varying pixel color\n    const vec3 colors[13] = vec3[13](BROWN, BROWN, BROWN, BROWN, BROWN, BROWN, \n                                    BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLACK);\n    return spline(dir.y*0.5+0.5, colors);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};  \nfloat IntersectRaySphere(Ray ray, Sphere sphere) {\n    vec3 p = ray.origin - sphere.center;\n    float p1 = -dot(p, ray.dir);\n    float delta = p1*p1 - dot(p, p) + sphere.radius*sphere.radius;\n    if (delta < 0.0) return -1.0;\n    float p2 = sqrt(delta);\n    return p1 > p2 ? p1-p2 : p1+p2;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 1.5));\n    \n    Ray ray = Ray(vec3(0, 0, 0), dir);\n    \n    Sphere s = Sphere(vec3(0.0, 0.0, 5.0), 2.0);\n    float t = IntersectRaySphere(ray, s);\n\n    vec3 col = vec3(0);\n    if (t < 0.0) {\n        col = SphereMapColor(dir);\n    } else {\n        vec3 intersect = ray.origin + t*ray.dir;\n        vec3 normal = normalize(intersect - s.center);\n        vec3 refl = dir - 2.0*dot(dir, normal)*normal;\n        col = SphereMapColor(refl);\n    }\n    \n    // gamma correction\n    col = pow(col, vec3(0.45));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}