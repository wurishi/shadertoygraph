{"ver":"0.1","info":{"id":"XX2yRt","date":"1727587077","viewed":117,"name":"normalize.fm","username":"gam0022","description":"「WebGL 総本山 + normalize.fm あわせて１３周年感謝祭」夜の部 Shader Jamsで書いたシェーダーです。\n\nhttps://sn13.peatix.com/view\n\nI created 4 scenes using only the geometry of the normalize.fm logo.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","livecoding","normalizefm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define saturate(x) clamp(x, 0., 1.)\n#define VOL 0.0\n#define SOL 1.0\n#define phase(x) (floor(x) + .5 + .5 * cos(TAU * .5 * exp(-5. * fract(x))))\n\nfloat beat, beatTau, beatPhase;\nfloat scene;\n\nvec4 map(vec3 p);\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n    if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid pmod(inout vec2 p, float s) {\n    float n = TAU / s;\n    float a = PI / s - atan(p.x, p.y);\n    a = floor(a / n) * n;\n    rot(p, a);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0, .0005);\n    return normalize(map(p).x - vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\nvec3 pal(float h) {\n    vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0.0, 0.33, 0.67) + h));\n    return mix(col, vec3(1), 0.1 * floor(h));\n}\n\nvec3 evalLight(vec3 p, vec3 normal, vec3 view, vec3 light, vec3 baseColor, float metallic, float roughness) {\n    vec3 ref = mix(vec3(0.04), baseColor, metallic);\n    vec3 h = normalize(light + view);\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / PI;\n    float eps = 6e-8;\n    float m = clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, eps, 1.0 / eps);\n    vec3 specular = ref * pow(max(0.0, dot(normal, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * max(0.0, dot(light, normal));\n}\n\nfloat sdN(vec3 p, float z) {\n    rot(p.xy, -0.07 * TAU);\n    if (p.x < 0.) p.y = -p.y;\n    p.x = abs(p.x);\n    float w = 0.13;\n    float h = 0.07;\n    float s = 4.;\n    float a = w / h / s * p.y;\n    return min(sdBox(p, vec3(0.2, h, z)),\n\t\t\t sdBox(p - vec3(0.25 - a, h * (s - 1.), 0), vec3(w - a, h * s, z)));\n}\n\nvec4 map(vec3 pos) {\n    vec4 m = vec4(1);\n\n    if (scene == 0.) {\n        vec3 p = pos;\n        rot(p.xz, beatTau / 8.);\n        U(m, sdN(p, 0.1), SOL, 10., 1.);\n    } else if (scene == 1.) {\n        vec3 p = pos;\n        float a = 2.;\n        rot(p.xz, beatTau / 32.);\n        p -= 0.5 * a;\n        p = mod(p, a) - 0.5 * a;\n        rot(p.xz, beatTau / 8.);\n        U(m, sdN(p, 0.1), SOL, 10., 1.);\n    } else if (scene == 2.) {\n        vec3 p = pos;\n        float a = 4.;\n        p -= 0.5 * a;\n        vec3 grid = floor(p / a);\n        p = mod(p, a) - 0.5 * a;\n        pmod(p.xy, 8.);\n        rot(p.xz, beatTau / 8. + dot(vec3(10.2), grid));\n        p.y -= 1.1 + 0.7 * cos(beatTau / 32.);\n\n        float e = saturate(cos(beatTau / 2. + TAU * pos.z / 16.));\n        if (e > 0.5) {\n            U(m, sdN(p, 0.1), VOL, 10. * e, 0.);\n        } else {\n            U(m, sdN(p, 0.1), SOL, 20., fract(dot(grid, vec3(0.2))));\n        }\n    } else {\n        vec3 p = pos;\n        float a = 2.;\n        p = mod(p, a) - 0.5 * a;\n        vec3 of = vec3(0.32, 0, 0);\n        p -= of;\n        float s = 1.;\n        for (int i = 0; i < 3; i++) {\n            p = abs(p + of) - of;\n            U(m, sdN(p * 2., 0.01) / 2., VOL, 1., 0.4);\n            rot(p.xz, TAU * 0.8);\n            rot(p.zy, TAU * 0.2 + beatPhase + pos.z * 0.1);\n        }\n\n        float scale = 1.05;\n        s *= scale;\n        p *= scale;\n\n        float e = saturate(cos(beatTau + TAU * pos.z / 16.));\n        U(m, sdN(p, 0.02) / s, VOL, 4. * e, 0.);\n        U(m, sdN(p, 0.1) / s, SOL, 1., 10.);\n    }\n    return m;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec4 m = map(p);\n        float d = m.x;\n        if (m.y == SOL) {\n            t += d * 0.5;\n            if (d < t * 0.001) {\n                vec3 n = normal(p);\n                col += evalLight(p, n, -rd, normalize(vec3(1, 1, -1)), vec3(1), 0.7, 0.5) * pal(m.w) * m.z;\n                break;\n            }\n        } else {\n            t += abs(d) * 0.5 + 0.01;\n            col += saturate(0.001 * pal(m.w) * m.z / abs(d));\n        }\n    }\n    col = mix(vec3(0), col, exp(-0.01 * t));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    beat = time * 145. / 60.;\n    beatTau = beat * TAU;\n    beatPhase = phase(beat);\n    float len = 8.;\n    scene = floor(mod(beat, len * 4.) / len);\n\n    vec3 ro = vec3(0, 0, -1);\n    if (scene >= 2.) ro = vec3(0, 0, beat);\n    float fl = 1.;\n    if (scene <= 1.) fl = 0.7;\n    vec3 rd = vec3(uv, fl);\n    rd = normalize(rd);\n    vec3 col = render(ro, rd);\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}