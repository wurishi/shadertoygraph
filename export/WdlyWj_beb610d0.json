{"ver":"0.1","info":{"id":"WdlyWj","date":"1614541172","viewed":76,"name":"Symmetry click and drag toy","username":"sadf","description":"Click and drag for kaleidoscopic effect. This was inspired by the Symmetry of Things by Conway et al.\n\nPush left and right keys to toggle symmetry modes.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float get_togglestate(int);\n\n\n/* Draw a cyan line in the y direction and a magenta one in the x direction.\n * Their intersection moves with the mouse.\n */\nvec4 draw_lines(vec2 xy) {\n    const float thickness = .2;\n    const float sharpness = 40.;\n\n    // Did we get any user input yet?\n    bool untouched = iFrame < 2 || iMouse.zw == vec2(0.);\n\n    // Ensure an interesting thumbnail.\n    vec2 mouse =  untouched ? vec2(.4) : to_devicecoord(iMouse.xy, iResolution);\n    xy -= mouse;\n\n    return vec4(((abs(xy) - thickness) * sharpness).xy, 1., 0.);\n}\n\n\n/* Test the hexagonal coordinate system: highlight at (0,0), increase red\n * with x, increase green with y.\n */\nvec4 testpattern(vec2 xy) {\n    vec3 col = vec3(smoothstep(0., c_sqrt3, xy), 0.5);\n    col += inversesqrt(length(xy)*80.);\n\n    return vec4(col, 0.);\n}\n\n\n/* 1, 2, 3, or 6 depending on keyboard toggles.\n */\nfloat get_rotation() {\n    float fac2 = 1. + get_togglestate(c_key_left);\n    float fac3 = 1. + 2.*(1. - get_togglestate(c_key_right));\n\n    return fac2*fac3;\n}\n\n\n/* Toggles between 0. and 1. when key is pressed.\n */\nfloat get_togglestate(int keycode) {\n    return texelFetch(iChannel1, ivec2(keycode, 2), 0).x;\n}\n\n\n/* Entry point.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = to_squarecoord(fragCoord, iResolution);\n\n    uv *= c_scale;\n\n    vec2 xy = hexgrid(uv);\n\n    xy = rotate(xy, get_rotation());\n\n    fragColor = draw_lines(xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float c_scale = 4.;\nconst float c_sqrt3 = sqrt(3.);\nconst int c_key_left = 37;\nconst int c_key_right = 39;\n\n\n/* Turn plane coordinates into hexagonal tiling coordinates, with (0, 0) \n * in the center of each hexagonal tile.\n */\nvec2 hexgrid(vec2 uv) {\n    const vec2 rect = vec2(3.0, c_sqrt3);\n    const vec2 rectcenter = rect/2.;\n\n\n    // Superpose two rectangular grids with particular dimensions.\n    vec2 grid1 = mod(uv - rectcenter, rect) - rectcenter;\n    vec2 grid2 = mod(uv, rect) - rectcenter;\n\n    // Select the grid of which the center is closest to uv.\n    return dot(grid1, grid1) <= dot(grid2, grid2) ?\n        grid1 :\n        grid2;\n}\n\n\n/* Warp the coordinate system by rotating it, effecting radial symmetry.\n */\nvec2 rotate(vec2 coord, float n) {\n    float dist = length(coord);\n    float rad = atan(coord.x, coord.y);\n    \n    rad *= n;\n    \n    return dist*vec2(sin(rad), cos(rad));\n}\n\n\n/* Compute  coordinate from (0, 0) to (1, 1) from pixel coordinates.\n */\nvec2 to_buffercoord(vec2 uv, vec3 res) {\n    return uv / res.xy;\n}\n\n\n/* Compute device coordinates (-1, -1) to (1, 1) from pixel coordinates.\n */\nvec2 to_devicecoord(vec2 uv, vec3 res) {\n    return (2.*uv - res.xy) / res.xy;\n}\n\n\n/* Compute square device coordinates from pixel coordinates. Square coordinates\n * have (0, 0) at the center and the larger axis goes from -1 to 1. The smaller axis\n * goes through a smaller range, depending on aspect ratio.\n */\nvec2 to_squarecoord(vec2 uv, vec3 res) {\n    float resMax = max(res.x, res.y);\n    return (2.*uv - res.xy) / resMax;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* work in progress for drawing. */\n\nconst float drawradius = 2.;\n\n\n/* Draw buffer; entry point.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = to_buffercoord(fragCoord, iResolution);\n    vec4 old_color = texture(iChannel0, uv);\n\n    vec2 mousexy = iMouse.xy;\n\n    vec2 diff = fragCoord - mousexy;\n    bool within_radius = dot(diff, diff) <= drawradius*drawradius;\n\n    if (within_radius) {\n        fragColor = vec4(1.);\n\n    } else {\n        fragColor = old_color;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}