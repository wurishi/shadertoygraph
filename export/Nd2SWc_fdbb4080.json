{"ver":"0.1","info":{"id":"Nd2SWc","date":"1621173420","viewed":582,"name":"Large scale Flocking (analysis)","username":"kastorp","description":"debugging & tuning my favourite shader by michael0884 [url]https://shadertoy.com/view/tsScRG[/url]\n","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["particles","sort"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Large scale Flocking (analysis) by Kastorp\n// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n//---------------------------------------------------------------------------------\n// Trying to to maximize the % of visibile moving particles  (displayed with gauge)\n//    colors: RED=velocity, GREEN=connections, BLUE=density \n//    buffer A: particle physics\n//    BUFFER B: particle connections \n//    BUFFER C: position closest particles\n//    BUFFER D: dump ghost particles\n//    \n//    with N8 defined: each particle has 8 connections (default is 4)\n//---------------------------------------------------------------------------------\n\nGETTERS\n\n#ifndef VORONOI\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{   \n        fragColor=vec4(0);\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    float d0 = 0.;\n    bool ghost;\n    for(int i = ZERO; i<4; i++)\n    {\n        if(nb[i]<0) continue;\n        vec4 pi = getParticle(nb[i],ghost);\n        \n        d0 = distance(pos/ZOOM,pi.xy)*ZOOM/2.;\n        fragColor.xyz += exp(-d0*d0*2. )*vec3(.1,.4,1.);   //DISTANCE    \n        \n        float dv= sdSegment( pos/ZOOM, pi.xy, pi.xy - 3.*pi.zw);        \n        fragColor.x +=  step(dv,.2) *length(pi.zw)*.6; //VELOCITY  \n        \n        float md=0.;\n        //CONNECTIONS\n        #ifdef N8  \n            ivec4[2] nb = getNeighbor2(nb[i]);\n            for(int n = ZERO; n < 2; n++)\n            for(int j = ZERO; j < 4; j++)\n            {\n            \n                vec2 pn=getParticle(nb[n][j],ghost).xy;\n                float dv= sdSegment( pos/ZOOM, pi.xy,pn ); \n                fragColor.y += smoothstep(0.5,.2,dv) *.1*(1.- exp(-d0*d0*.2) );\n                md= max(md,distance(pi.xy,pn));\n                \n            }\n           \n        #else\n            ivec4 nb = getNeighbor(nb[i]);\n            for(int j = ZERO; j < 4; j++)\n            {\n                vec2 pn=getParticle(nb[j],ghost).xy;\n                 float dv= sdSegment( pos/ZOOM, pi.xy,pn ); \n                fragColor.y +=  smoothstep(0.5,.2,dv) *.1*(1.- exp(-d0*d0*1.) );\n                md= max(md,distance(pi.xy,pn));\n            }\n        #endif\n         fragColor.z *= .5 +.5*smoothstep(8.,7.,md); \n    }\n    \n    \n    //gauge\n    if(all(lessThan(pos,vec2(N.x,5)))) {\n        float s = textureLod(iChannel3, vec2(pos/iResolution.xy),5.).x,\n               ss = smoothstep(s+.01,s-.01,pos.x/float(N.x));\n        fragColor=mix(vec4(.5),vec4(1,1,0,0),ss);\n     }\n  \n    //mouse closest particle\n    float d = 0.;   \n    ivec4 nbm = getClosest(ivec2(iMouse.xy/ZOOM));\n    for(int i = 0; i<4; i++)\n    {\n        if(nbm[i]<0) continue;\n        vec4 pi = getParticle(nbm[i],ghost);\n        \n        d += exp(-distance(pos/ZOOM,pi.xy)*3.);\n     }\n    fragColor += 5.*vec4(4,3,2,1)*d;\n \n\n}\n\n#else\n// Voronoi display\n\nfloat Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n    vec4 pi3 = getParticle(nb[3],ghost);\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM/2.;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM/2.;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM/2.; \n    float d3 = distance(pos/ZOOM,pi2.xy)*ZOOM/2.; \n      \n    float df =min(2./(1./max(d1 - d0, .001) + 1./max(d2 - d0, .001)), 1.);\n    df*= step(d0,size.y/40.);\n    return df;\n}\n\n\nvec2 hMap(vec2 uv){    \n    float h = Voronoi(uv);   \n    float c = smoothstep(0., fwidth(h)*2., h - .09)*h;\n    c += (1.-smoothstep(0., fwidth(h)*3., h - .22))*c*.5;     \n    return vec2(c, h);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 p = fragCoord /ZOOM*2.;\n    \n    vec2 c = hMap(p);       \n    vec3 col = vec3(.8, .05, .05)*c.x; // Red base.\n   \n    // Apply the bump - or a powered variation of it - to the color for a bit of highlighting.\n    vec2 c2 = hMap(p + 2.);\n    float b = max(c2.x - c.x, 0.)*1.;\n    col += vec3(.5, .7, 1)*(b*b*.5 + b*b*b*b*.5);\t \n    \n    // Basic gamma correction\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define NP 60000. //number of particles,  must be <=  (iResolution.x)^2\n#define NGH 200 // number of ghosts scanned each frame\n#define dt 1.5 // time interval;  dt<0.5 => 1% ghosts,  dt>2. => 50% ghosts\n#define ZOOM 2. // 1.= full resolution 2.=half resolution with faster movement and lower max density\n#define DIST 2.5 //average dist\n//#define N8  //interact with 8 particles (default is with 4 particle)\n//#define VORONOI //voronoi display, better with few particles\n\n//-----------------------\n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size (iResolution.xy/ZOOM)\n#define mouse (iMouse/ZOOM)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(texel(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\n\nconst int tot_n = N.x*N.y;\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\n//Iq SDF functions\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0);\n    bool ghost;\n   \tvec4 p1 = getParticle(pid,ghost);\n    float d = distance(p1.xy,p0.xy);\n    \n    \n    float sc=  DIST, \n          fd = 0.8/(1.+d/sc) - 4.*exp(-d/sc);\n    \n    vec2 flocking_force =(p1.zw - p0.zw)/(1.+1.*d);\n    \n    vec2 interaction = normalize(p1.xy-p0.xy)*fd;\n    return flocking_force*0.4 + interaction*0.10;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\nU=vec4(0);\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos); \n        //this pixel value\n        U = texel(iChannel0, pos);\n        U.xy=abs(U.xy);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n#ifdef N8       \n   \t\tivec4[2] cp = getNeighbor2(id);\n   \t  \n        vec2 F = Fv(U, cp[0].x) +\n            \t Fv(U, cp[0].y) +\n            \t Fv(U, cp[0].z) +\n                 Fv(U, cp[0].w) +\n                 Fv(U, cp[1].x) +\n            \t Fv(U, cp[1].y) +\n            \t Fv(U, cp[1].z) +\n                 Fv(U, cp[1].w);\n#else\n   \t\tivec4 cp = getNeighbor(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w);\n#endif\n\n        if(iMouse.z > 0.) \n        {\n            float d = distance(mouse.xy, U.xy);\n            if(d<size.y*.3) F += 2.*normalize(mouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += (0.5*F)*dt;\n        \n        //random force field\n        U.zw +=.02*dt* ( -2. * texture(iChannel3, 0.6*U.xy/size).xy + 1.);\n        \n        //U.zw = normalize(U.zw);\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n\n         \n        \n        U.xy = mod(U.xy, size);\n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n#ifndef N8\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //closest in 4 directions\n    if(dx.x > abs(dx.y) && (d.x > dtemp) )\n    {\n            d.x = dtemp;\n        \tu.x = utemp;\n    }\n    else if(dx.x < -abs(dx.y) && (d.y > dtemp) )\n   {     \n            d.y = dtemp;\n        \tu.y = utemp;\n        \n    }\n    else if(dx.y > abs(dx.x) && (d.z > dtemp) )\n    {    \n            d.z = dtemp;\n        \tu.z = utemp;\n        \n    }\n    else if(dx.y <-abs(dx.x) && (d.w > dtemp) )\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \nU=vec4(0);\n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n#else\n\n//sorting closest 8 particles \n\nuvec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //this particle position\nuint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(uint utemp)\n{\n    if(utemp == tid || utemp >=65536u) return; \n     if(  any(equal(u[0], uvec4(utemp))) ||  any(equal(u[1], uvec4(utemp)))) return;\n     \n       \n   \tvec4 part = getParticle(int(utemp),ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n     \n\n    //sorting\n    if(d[0].x > dtemp )\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);         \n        d[0] = vec4(dtemp, d[0].xyz);\n        u[0] = uvec4(utemp, u[0].xyz);\n    }\n    else if(d[0].y > dtemp && dtemp > d[0].x)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n         \n        d[0].yzw = vec3(dtemp, d[0].yz);\n        u[0].yzw = uvec3(utemp, u[0].yz);\n    }\n    else if(d[0].z > dtemp && dtemp > d[0].y)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n        \n        d[0].zw = vec2(dtemp, d[0].z);\n        u[0].zw = uvec2(utemp, u[0].z);\n    }\n    else if(d[0].w > dtemp && dtemp > d[0].z)\n    {\n  \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n          \n        d[0].w = dtemp;\n        u[0].w = utemp;\n    }\n     \n    else if(d[1].x > dtemp && dtemp > d[0].w)\n    {\n        d[1] = vec4(dtemp, d[1].xyz);\n        u[1] = uvec4(utemp, u[1].xyz);\n\n    }   \n    else if(d[1].y > dtemp && dtemp > d[1].x)\n    {\n        d[1].yzw = vec3(dtemp, d[1].yz);\n        u[1].yzw = uvec3(utemp, u[1].yz);\n    }\n    else if(d[1].z > dtemp && dtemp > d[1].y)\n    {\n        d[1].zw = vec2(dtemp, d[1].z);\n        u[1].zw = uvec2(utemp, u[1].z);\n    }\n    else if(d[1].w > dtemp && dtemp > d[1].z)\n    {\n        d[1].w = dtemp;\n        u[1].w = utemp;\n    }\n\n}\n\n\nvoid sortneighbor(int id)\n{\n    ivec4[2] nb = getNeighbor2(id);\n    for(int n=min(iFrame,0);n<2;n++)\n    for(int j = min(iFrame,0); j < 4; j++)\n    {\n        sort(uint(nb[n][j]));\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = uvec4[2](uvec4(65536u),uvec4(65536u));\n    \n    d = vec4[2](vec4(1e10),vec4(1e10)); \n   \n    tid = uint(id);\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = ZERO; i < NGH + ZERO; i++)\n    {\n \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(uint(id)); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(uint(nc[i])); \n    }\n    \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n1= ZERO;n1<2;n1++)\n    for(int i =ZERO; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(int(nb[n1][i])); \n         ivec4[2] nbb = getNeighbor2(nb[n1][i]);\n         for(int n2=ZERO;n2<2;n2++)\n        for(int j = ZERO; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[n2][j]); \n        }\n    }\n    \n\n\n    \n   \n    U = uintBitsToFloat(u[0]+(u[1]*65536u));\n}\n\n\n#endif","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id,ghost).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n#ifdef N8  \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n = ZERO; n < 2; n++)\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[n][j]);\n    }\n#else\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n#endif\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\nU=vec4(0);\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    /* \n    // random sort skipped, use particle random sort instead\n    for(int i = 0; i < 100; i++)\n    {\n        //int id=hash(ivec4(p, iFrame, i)).x%tot_n;\n        int id=(iFrame*100+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort    \n    }\n    */\n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    // if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )  u = ivec4(0); \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// ghost particles dump\nGETTERS\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{   \n    fragColor=vec4(0.);    \n\n    if(all(lessThan(pos,vec2(N)))) {\n        vec4 p = texel(iChannel0,pos);\n        if(p.x<0. || p.y<0.) fragColor=vec4(1.);\n        \n     }else discard;\n    \n\n}","name":"Buffer D","description":"","type":"buffer"}]}