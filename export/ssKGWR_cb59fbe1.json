{"ver":"0.1","info":{"id":"ssKGWR","date":"1631369800","viewed":481,"name":"3D SDF Visualizer","username":"harry7557558","description":"Debugging an SDF, try to use a previous volume rendering shader to visualize its discontinuity.\n\nmouse-able","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["volume","sdf","debug","discontinuity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Debugging an SDF, visualize its discontinuity\n\n// orange-blue: SDF isosurfaces\n// red-black: discontinuity (high numerical gradient)\n// green-pink: surface gradient lower/higher than 1\n\n#define PI 3.1415926\n\n\n// a debugging SDF, heavily inspired by iq's Snail\nfloat mapShell(in vec3 p0) {\n    p0 -= vec3(1.3, 0, 0);\n    vec3 p = p0;\n\n    const float b = 0.17;\n\n    float r = length(p.xy);\n    float a = mix(0.0, 0.8, smoothstep(0.0, 1.0, 0.5*(r-0.6)));\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;\n    float t = atan(p.y, p.x);\n \n    float n = (log(r)/b-t)/(2.0*PI);\n    n = min(n, 0.0);\n\n    float n0 = floor(n), n1 = ceil(n);\n    float x0 = exp(b*(t+2.0*PI*n0));\n    float x1 = exp(b*(t+2.0*PI*n1));\n    float r0 = 1.0*x0;\n    float r1 = 1.0*x1;\n\n    float h0 = p.z + 0.4*(x0-1.0);\n    float h1 = p.z + 0.4*(x1-1.0);\n    float d0 = length(vec2(x0-r,h0)) - r0;\n    float d1 = length(vec2(x1-r,h1)) - r1;\n\n    float d, dx, dy;\n    if (d0 < 0.0) d = d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0 && d1<-d0) d = -d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0) d = d1, dx = x1-r, dy = h1;\n    else if (d0 < d1) d = d0, dx = x0-r, dy = h0;\n    else d = d1, dx = x1-r, dy = h1;\n\n    d += 0.002*r*sin(40.*t);\n    d += 0.002*r*sin(40.*atan(dy,dx));\n\n    d = abs(d)-0.1*r;\n    d = max(d, p0.x);\n    return d;\n}\n\n// test SDF\nfloat mapTest(vec3 p) {\n    vec3 r = vec3(1.5,1.0,0.6);\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2+0.1*sign(p.x+p.y+p.z);\n}\n\nfloat sdf(in vec3 p) {\n    //return mapTest(p);\n    return mapShell(p);\n}\n\nvec3 sdfGrad(in vec3 p, in float e) {\n\tfloat a = sdf(p+vec3(e,e,e));\n\tfloat b = sdf(p+vec3(e,-e,-e));\n\tfloat c = sdf(p+vec3(-e,e,-e));\n\tfloat d = sdf(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n// raymarching parameters\nconst vec3 BoxRadius = vec3(2.0, 2.0, 2.0);\n#define STEP 0.01\n#define MAX_STEP 120.\n\n\n// rendering parameters\n#define FIELD_EMISSION 0.3\n#define DISCONTINUITY_OPACITY 0.1\n#define SURFACE_GRADIENT 10.0\n\n// light direction as global variable\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n// colormaps - https://www.shadertoy.com/view/NsSSRK\nvec3 colorSdf(float t) {\n  float r = .385+.619*t+.238*cos(4.903*t-2.61);\n  float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 colorNormal(float t) {\n  float r = .529-.054*t+.55*cos(5.498*t+2.779);\n  float g = .21+.512*t+.622*cos(4.817*t-1.552);\n  float b = .602-.212*t+.569*cos(5.266*t+2.861);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\n\n// modified from a volume rendering demo\n// https://github.com/harry7557558/Graphics/blob/master/raytracing/webgl_volume/fs-source.glsl\nvec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) / step_count;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old, v;\n    for (t = t0; t < t1; t += dt) {\n        v = sdf(ro+rd*t);\n        vec3 col = colorSdf(0.5+0.5*sin(8.0*PI*v));\n        //float grad = length(sdfGrad(ro+rd*t,dt));\n        float grad = t==t0 ? 0.0 : abs(v-v_old)/dt;\n        float grad_abs = (1.0-grad)/dt;\n        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));\n        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v < 0.0) break;\n        v_old = v;\n    }\n    if (v > 0.0) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = sdf(ro+rd*t);\n            if (v*v_old<0.0) break;\n        }\n    }\n    vec3 grad = sdfGrad(ro+rd*t, 1e-3);\n    vec3 col = colorNormal(0.5+0.5*tanh(SURFACE_GRADIENT*(0.5*length(grad)-0.5)));\n    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);\n    return totcol + col * totabs;\n}\n\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set camera\n    float rx = iMouse.z>0. ? 3.14*(iMouse.y/iResolution.y)-1.57 : 0.3;\n    float rz = iMouse.z>0. ? -iMouse.x/iResolution.x*4.0*3.14 : -0.6;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec3 ro = 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // calculate pixel color\n    light = normalize(w+0.5*u+0.1*v);\n\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = render(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}