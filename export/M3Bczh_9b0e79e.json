{"ver":"0.1","info":{"id":"M3Bczh","date":"1727799340","viewed":33,"name":"Raymarching shape shifting","username":"Sabiri","description":"Morphing some SDF shapes","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;  \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec3 tt = vec3(t, 0.);\n  vec3 q = vec3(vec2(length(p.xz) - tt.x , p.y), 0.0);\n  return (length(q.xyz) - t.y);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, \n       ba = b - a;\n  \n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return (length( pa - ba * h ) - r) ;\n}\n\nfloat sdMorphIt( vec3 p)\n{\n  float maxMorph = 1.;\n  float time = iTime;\n  float morphValue = 0.0;\n  float morphValue1 = 0.0;\n  float morphStep = sin(iTime);\n\n  morphValue = clamp(sin(iTime), 0., maxMorph);\n  morphValue1 = clamp(cos(iTime), 0., maxMorph);\n\n  vec2 t = vec2(0.36, 0.2);\n  \n  vec3 b = vec3(.3);\n  vec3 a = vec3(0.,0.4,0.0);\n  vec3 bb = vec3(0.,-0.4,0.0);\n  \n  float torus = sdTorus(p, t) * morphValue; // first\n  float capsule = sdCapsule(p, a, bb, 0.2) * (maxMorph - max(morphValue1,morphValue));  // second\n  float box = sdBox(p, b) * (morphValue1);  // third\n\n  float m = torus + capsule + box;\n\n  return m;  \n}\n\nvec3 gradientNormal(vec3 p)\n{\n    vec2 h = vec2(0.0001, 0.); // Small rate of change that would simulate lim h->0\n\n    return (\n        vec3\n        (\n            (sdMorphIt(p + h.xyy) - sdMorphIt(p))/(h.x),\n            (sdMorphIt(p + h.yxy) - sdMorphIt(p))/(h.x),\n            (sdMorphIt(p + h.yyx) - sdMorphIt(p))/(h.x)\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 mous = iMouse.xy/iResolution.xy - 0.5;\n    mous.x *= iResolution.x/iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 cam = vec3(0.,0., -1.5);\n    vec3 raydir = vec3(uv, 1.);\n\n    vec3 col = vec3(0.2);\n    vec3 boxPos = vec3(vec4(0., 0., 0., 1.0)).xyz;\n\n    vec3 spherePos = vec3(0.);\n    vec3 spherePos1 = vec3(mous.x, mous.y,0.);\n    vec3 pos = cam;\n    float d = 1.;\n    float r = 0.2;\n    vec3 lightPos = vec3(0.0, sin(iTime) * 0.5, 0.2);\n\n    float eps = 0.000001;\n    float angle = iTime/2.;\n    \n    mat4 matxyz =   mat4\n                    (\n                        1.,0.,0., boxPos.x,\n                        0.,1.,0., boxPos.y,\n                        0.,0.,1., boxPos.z,\n                        0.,0.,0., 1.\n                    )*\n                    mat4\n                    (\n                        1.,0.,0., -boxPos.x,\n                        0.,1.,0., boxPos.y,\n                        0.,0.,1., boxPos.z,\n                        0.,0.,0., 1.\n                    )\n                    * \n                    mat4\n                    (\n                        cos(angle),-sin(angle),0., 0.,\n                        sin(angle),cos(angle),0., 0.,\n                        0.,0.,1., 0.,\n                        0.,0.,0., 1.\n                    )\n                    * \n                    mat4\n                    (\n                        1, 0,0., 0.,\n                        0.,sin(angle),cos(angle), 0.,\n                        0.,cos(angle),-sin(angle), 0.,\n                        0.,0.,0., 1.\n                    )* \n                    mat4\n                    (\n                        1.,0.,0., -boxPos.x,\n                        0.,1.,0., -boxPos.y,\n                        0.,0.,1., -boxPos.z,\n                        0.,0.,0., 1.\n                    );\n    \n    // Raymarching                \n    for (int i = 0; i < 140; i++)\n    {\n        d = 1.0;\n\n        float dist = sdfSphere(pos - spherePos, r);\n\n        vec3 torus = vec3(\n                            vec4((pos - boxPos),1.)\n\n                            *matxyz\n\n                            ).xyz;\n        float dist3 = sdMorphIt(torus);\n\n        float k = 0.01;\n\n        d = min(d, dist3);\n        \n        if (d <= eps)\n        {\n            if (d == dist3)\n            {\n                  col = gradientNormal(torus);                  \n            }\n        }\n            \n       \n        pos += (raydir) * d;\n        \n    }\n   \n    // Output to screen \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}