{"ver":"0.1","info":{"id":"NdKGWV","date":"1632219038","viewed":2349,"name":"simple sphere raymarching","username":"drschizzo","description":"use RIGHT,UP,LEFT arrows to toggle lights\nuse mouse to move the main light","likes":23,"published":1,"flags":16,"usePreview":0,"tags":["raymarchingwip"],"hasliked":0,"parentid":"sdGGRG","parentname":"simple spheres raytracing"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lin2sRGB(x) ( x <= .0031308 ? (x)*12.92 : 1.055*pow(x,1./2.4) - .055 )\n\n\n#define NO_DFDX_\n\nconst float ANIM_SPEED=2.;\n\n//need to be multiple of 4\nconst int NB_TOTAL_SPHERES=32;\n\n\nconst float SEED=42.42;\n\n\nconst int NB_SPHERES=NB_TOTAL_SPHERES/4;\nconst int PLANE_ID=NB_SPHERES*4+1;\n\nconst float sqrt_sp=sqrt(float(NB_SPHERES));\nconst int MAX_STEP=100;\nconst float MIN_DIST=.001;\nconst float MAX_DIST=30.;\n\nconst float planeZ=-4.5;\n\n\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\n\nstruct Light{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nstruct Hit{\n    float dist;\n    vec4 objId;\n    vec3 pos;\n    vec3 normal;    \n};\n\n//  from DAVE HOSKINS\nvec3 N13(float p) {\n    p=p*SEED;\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat map01(float min,float max, float val){\n    return val=clamp((val-min)/(max-min),0.,1.);\n}\n\nvec4 getSphere(int nb, float t){\n    float a=(7./sqrt_sp);\n    float ox=-a*(sqrt_sp/2.)+a/2.;\n    float b=(5./sqrt_sp);\n    float oy=-b*(sqrt_sp/2.)+b/2.;\n    \n    float x_offset=mod(float(nb),sqrt_sp);\n    float y_offset=floor(float(nb)/sqrt_sp);\n    float x=ox+x_offset*a;\n    float y=oy+y_offset*b;\n    float z=-6.+3.*(abs(sin(t*2.+b*float(nb))));\n    float w=min(b/1.5,1.2)*pow((1.-(-z-3.)/3.),2.);\n    return vec4(x,y,z,w);\n}\n\n\nvec4 getSphere(int nb){\n    return getSphere(nb,iTime/ANIM_SPEED);\n}\n\n//from https://iquilezles.org/articles/smin\nvec2 sminN( float a, float b, float k, float n )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\n\n\n\nHit getDist(vec3 p){\n    int idOffset=0;\n    if(p.x<0. && p.y>0.)\n        idOffset=NB_SPHERES;\n    if(p.x>0. && p.y>0.)\n        idOffset=NB_SPHERES*2;\n    if(p.x>0. && p.y<0.)\n        idOffset=NB_SPHERES*3;\n        \n    p.x=abs(p.x)-4.;\n    p.y=abs(p.y)-3.;\n    \n    float dist=MAX_DIST;\n    int objId=-1;\n    int sphereId=0;\n    vec2 smoothDist;\n    float sphereSmoothMix=0.;\n    for(int i=0;i<NB_SPHERES;i++){\n        vec4 sphere=getSphere(i);\n        float d=length(p-sphere.xyz)-sphere.w;\n        smoothDist=sminN(dist,d,1.,2.);\n        \n         if(d<.5 ){\n            // if(sphereId!=-1)\n            sphereSmoothMix=smoothDist.y;\n\n\n            sphereId=objId;           \n\n        }\n\n        if(d<dist){\n            objId=i+idOffset;\n\n        }\n        \n        dist=smoothDist.x;\n\n    }\n    float dPlane=p.z-planeZ;\n    smoothDist=sminN(p.z-planeZ,dist,.5,2.);\n    vec2 smoothDistMask=sminN(p.z-planeZ,dist,1.4,3.);\n\n    sphereId=objId;           \n\n\n    if(dPlane<dist){\n        objId=PLANE_ID;\n    }\n\n    dist=smoothDist.x;\n\n    return Hit(dist,vec4(objId,sphereId,smoothDistMask.y,sphereSmoothMix),vec3(0),vec3(0));\n}\n\n\n//from https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float d = getDist(ro + rd*t).dist;\n        if( d<MIN_DIST )\n            return 0.0;\n        res = min( res, k*(d*.05)/t );\n        t += d;\n    }\n    return res;\n}\n\n\nvec3 getNormal(vec3 pos){\n    vec2 e=vec2(.01,0);\n    float dist=getDist(pos).dist;\n    vec3 n=vec3(\n        dist-getDist(pos-e.xyy).dist,\n        dist-getDist(pos-e.yxy).dist,\n        dist-getDist(pos-e.yyx).dist);\n    return normalize(n);\n}\n\nHit rayMarch(vec3 o,vec3 ray){\n    float totalDist=0.;\n    Hit hit;\n    for(int i=0;i<MAX_STEP;i++){\n        vec3 p=o+totalDist*ray;\n        hit=getDist(p);\n        totalDist+=hit.dist;\n        if(hit.dist<MIN_DIST||totalDist>MAX_DIST) break ;\n    }\n    if(totalDist<MAX_DIST){\n        vec3 pos=o+ray*totalDist;\n        return Hit(totalDist,hit.objId,pos,getNormal(pos));\n    }\n    else{\n        return Hit(totalDist,vec4(-1),vec3(0),vec3(MAX_DIST));\n    }\n    \n}\n\nvec3 shadePixel(vec3 pos, vec3 n, Light light,vec3 viewDir){\n\n    float intensity=1./pow(length(pos-light.pos),2.)*light.intensity;\n    float diffuse=dot(normalize(light.pos-pos),n);\n    float shadow=softshadow( pos, light.pos, 0.01, 1., 5.);\n    diffuse=clamp(diffuse,0.,1.)*shadow;\n    float specLvl = 65.;\n\n\n    vec3 r=normalize(light.pos-viewDir-pos);\n    float spec=pow(max(dot(n, r),0.), specLvl)*shadow;\n    \n    float ret=diffuse;\n    ret +=  spec;\n\n    return ret*intensity*light.color;\n}\n\n\n#ifndef NO_DFDX\nvec2 texNormalMap(vec2 uv,sampler2D tex,float intensity)\n{\n    vec2 texelPixelRatio=iResolution.xy/iChannelResolution[0].xy;\n    float height = length(texture(tex, uv))*intensity;\n    return vec2(dFdx(height), dFdy(height))*texelPixelRatio;\n\n}\n\n#else\n\nvec2 texNormalMap(vec2 uv, sampler2D tex, float intensity)\n{\n    intensity=1.01;\n    float e = .004;\n    float dist=length(texture(tex, uv))*intensity;\n    float dist_nx=length(texture(tex, uv+vec2(1.,0.)*e));\n    float dist_px=length(texture(tex, uv+vec2(-1.,0.)*e));\n\n    float distx=mix(dist_nx,dist_px,.5)-dist;\n    \n    float dist_ny=length(texture(tex, uv+vec2(0,1)*e));\n    float dist_py=length(texture(tex, uv+vec2(0,-1.)*e));\n\n    \n    float disty=mix(dist_ny,dist_px,.5)-dist;    \n    return normalize(\n    vec2(distx, disty));\n}\n\n#endif\n\n\nvec3 computeLighting(Light[3] lights, vec3 hitPos,vec3 n,vec3 ray){\n    vec3 col=vec3(0.);\n    for(int i=0;i<3;i++){\n        vec3 shadingColor=shadePixel(hitPos,n,lights[i],ray);\n        \n        col+=shadingColor;\n   }\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=iTime/ANIM_SPEED;\n    \n    vec2 mousePos=((iMouse.xy-.5*iResolution.xy)/iResolution.y);\n\n    //camera model from https://www.youtube.com/watch?v=PBxuVlp7nuM\n    vec3 camera=vec3(mousePos*2.,8);\n    vec3 lookAt=vec3(0);\n    float zoom=1.;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    \n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    \n    \n    bool disableLight1=texelFetch( iChannel1, ivec2(KEY_LEFT,2),0 ).x>0.;\n    bool disableLight2=texelFetch( iChannel1, ivec2(KEY_RIGHT,2),0 ).x>0.;\n    bool disableLight3=texelFetch( iChannel1, ivec2(KEY_UP,2),0 ).x>0.;\n\n    Light lights[]=Light[](Light(vec3(mousePos*20.,10.),disableLight3?0.:100.,vec3(1.,1.,1.)),\n                           Light(vec3(-8,3.,8.),disableLight1?0.:100.,vec3(1.,.8,0.)),\n                           Light(vec3(8,-3.,8.),disableLight2?0.:150.,vec3(0.,0.,1.)));\n\n\n     \n    Hit hit=rayMarch(camera,ray);\n    vec4 colPlan,colSphere;\n    if(int(hit.objId.x)==PLANE_ID){\n        vec3 n=normalize(vec3(texNormalMap(hit.pos.xy/10.,iChannel3,30.*(1.+pow(hit.objId.z*2.,2.))),1.));\n        vec3 col=computeLighting(lights,hit.pos,n,ray);\n        vec4 maskColor=vec4(vec3(clamp(hit.objId.z,0.,1.)),1.)*2.;\n        vec4 mixColor=vec4(N13(float(hit.objId.y)+1.),1.)*maskColor+(vec4(length(texture(iChannel0,hit.pos.xy/10.).rgb)*(1.-maskColor)));\n        colPlan =vec4(col.xyz*mixColor.xyz,1.0);\n\n    }\n    if(int(hit.objId.y)!=-1 && int(hit.objId.x)!=PLANE_ID){\n        vec3 col=computeLighting(lights,hit.pos,hit.normal,ray);\n        vec3 colsp1=N13(float(hit.objId.x)+1.);\n        vec3 colsp2=N13(float(hit.objId.y)+1.);\n        vec3 colsp=colsp2+clamp(hit.objId.w,0.,1.);\n        colSphere = vec4(col.xyz*length(texture(iChannel2,hit.normal.xy).rgb)*colsp,1.0);\n        //colSphere=vec4(vec3(hit.objId.w),1.);\n    }\n    \n    fragColor=colPlan+colSphere;\n   //gamma correction\n    fragColor.r=lin2sRGB(fragColor.r);\n    fragColor.g=lin2sRGB(fragColor.g);\n    fragColor.b=lin2sRGB(fragColor.b);\n    \n    \n}","name":"Image","description":"","type":"image"}]}