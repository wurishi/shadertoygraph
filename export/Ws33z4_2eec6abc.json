{"ver":"0.1","info":{"id":"Ws33z4","date":"1570190891","viewed":89,"name":"Doodle#1 - AdditiveColoring","username":"xx3000","description":"Doodle #1: Additive colors","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct SphereData\n{\n\tvec3 pos;\n    vec3 color;\n\tfloat radius;\n    float innerRadius;\n    vec2 fuzzyness;\n    vec3 movX;\n    vec3 movY;\n};\n\n  #define SPHERECOUNT 3  \n    \n    /*\n    SphereData spheres[SPHERECOUNT] = SphereData[SPHERECOUNT] \n    (SphereData(vec3(0.5,0.5,0),vec3(0.3,0.5,1),0.2,0.005, vec3(1,1,1), vec3(3,1,1)),\n     SphereData(vec3(0.5,0.5,0),vec3(1,0.3,0.5),0.2,0.005, vec3(3,1,1), vec3(1,1,1)),\n     SphereData(vec3(0.5,0.5,0),vec3(0.5,1.0,0.3),0.2,0.005, vec3(2,1,1), vec3(2.5,1,1))\n    );\n*/\nSphereData spheres[SPHERECOUNT] = SphereData[SPHERECOUNT] \n    (SphereData(vec3(0.78,0.4,0),vec3(0.0,0.0,1),0.2,0.1,vec2(0.2,0.001), vec3(0.6,0.0,0.1), vec3(0.5,1,0.1)),\n     SphereData(vec3(0.78,0.4,0),vec3(1,0.0,0.0),0.2,0.1,vec2(0.2,0.001), vec3(0.4,0,0.1), vec3(0.6,1,0.1)),\n     SphereData(vec3(0.78,0.4,0),vec3(0.0,1.0,0.0),0.2,0.1,vec2(0.2,0.001), vec3(0.5,0,0.1), vec3(0.4,1,0.1))\n    );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0,0,0);\n\n    for(int i = 0 ; i < SPHERECOUNT; ++i)\n    {\n        SphereData sphere = spheres[i];\n        float sphereRadius = sphere.radius + (sin(iTime * sphere.movX.y)*0.1+0.2);\n        float innerRadius = sphereRadius - sphere.innerRadius;\n        float sphereFuzzyness = sphere.fuzzyness.x;\n        float sphereFuzzynessInner = sphere.fuzzyness.y;\n        vec3 sphereCol = sphere.color;\n        vec3 pos = sphere.pos;\n\n        pos.x = pos.x + ((sin(iTime * sphere.movX.x)*0.5+1.0) * sphere.movX.z)*iResolution.x/iResolution.y;\n        pos.x *= sin(iTime *0.3)*0.5+1.0;\n        \n        pos.y = pos.y + ((sin(iTime * sphere.movY.x)*0.5+1.0) * sphere.movY.z);\n        pos.y *= sin(iTime* 1.5 *0.3)*0.5+1.0;\n        \n        float smoothed = smoothstep(sphereFuzzyness,-sphereFuzzyness,distance(uv, pos.xy)-sphereRadius) *\n            smoothstep(sphereFuzzynessInner,-sphereFuzzynessInner,innerRadius - distance(uv, pos.xy));\n        \n        col = mix(col,col+sphereCol,smoothed );\n        col = clamp(col,0.0,1.0);\n    }\n  \n    \n    //vec3 col2 = texture(iChannel0,uv).xyz;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}