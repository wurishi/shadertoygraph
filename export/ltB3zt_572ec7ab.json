{"ver":"0.1","info":{"id":"ltB3zt","date":"1431610190","viewed":7728,"name":"BadLand","username":"kuvkar","description":"Use mouse to control target position.\n\nAttempted to make \"inverse kinematics\" in shader. I'm turning each joint towards the target slightly at each iteration. It works ok-ish i think. \n","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["2d","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define inf 999999.0\n\nvec2 rotate(vec2 point, float angle)\n{\n    float x = point.x; float y = point.y;\n    point.x = x * cos(angle) - y * sin(angle);\n    point.y = y * cos(angle) + x * sin(angle);\n    return point;\n}\n\nbool box2d(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    \n    bool x = (w - uv.x) > 0.0 && (-w - uv.x) < 0.0;\n    bool y = (h - uv.y) > 0.0 && (-h - uv.y) < 0.0;\n    \n    return x && y;\n}\n\nvec2 angletovec(float angle)\n{\n    float xn = cos(angle);\n    float yn = sin(angle);\n    return vec2(xn, yn);\n}\n\nstruct Joint\n{\n    vec2 pos;\n    float w;\n    float h;\n    float angle;\n};\n\nvec2 endPoint(in Joint j)\n{\n    return j.pos + vec2(cos(-j.angle), sin(-j.angle)) * j.w * 2.0;\n}\n    \nbool drawJoint(in Joint j, vec2 uv)\n{\n    return box2d(j.pos, uv, vec2(-j.w, 0.0), j.angle, j.w, j.h);\n}\n\nvoid rotateJoint(inout Joint j1, in vec2 target, float amount)\n{\t\n    vec2 ep = j1.pos;\n    vec2 targetv = normalize(target - ep);\n    targetv.y *= -1.0;\n    // which way to turn?\n    // construct a vector normal to direction and check sign of dot product\n    float an = (j1.angle) + PI * 0.5;\n    vec2 norm = angletovec(an);\n    float turn = dot(norm, targetv);\n    float dir = turn > 0.0 ? 1.0 : -1.0;\n    \n    // turn\n    vec2 fwd = angletovec(j1.angle);\n    float d = clamp(dot(fwd, targetv), -1.0, 1.0);\n    float turnangle = acos(d);\n      \n    j1.angle += turnangle * dir * amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    float aspect = iResolution.x / iResolution.y;\n    uv.y /= aspect;\n    \n    float mx = iMouse.x / iResolution.x;\n    float my = iMouse.y / iResolution.y;\n    vec2 target = vec2(mx, my);\n    target -= vec2(0.5);\n    target.y /= aspect;\n\n    if(iMouse.wz == vec2(0.0))\n    {\n        target = vec2(sin(iTime) * 0.45, 0.1 + cos(iTime) * 0.15);\n    }\n    \n    const int JOINTS = 7;\n    Joint j[JOINTS];\n\t\n    j[0].pos = vec2(-0.0, -0.3);\n    j[0].w = 0.05;\n    j[0].h = 0.02;\n    j[0].angle = -PI * 0.5;\n    float fj = float(JOINTS);\n    \n    for (int i = 1; i < JOINTS; ++i)\n    {\n        j[i].pos = endPoint(j[i - 1]);\n        float r = (fj - float(i)) / fj;\n        j[i].w = 0.03;\n        j[i].h = 0.01 * r;\n    \tj[i].angle = -PI * 0.5;    \n    }\n\tconst int iter = 5;\n    const float weight = 0.35;\n    \n    for (int x = 0; x < iter; ++x)\n    {\t\n        for (int i = JOINTS - 1; i >= 1; --i)\n        {\n            j[i].pos = endPoint(j[i - 1]);\n            rotateJoint(j[i], target, weight * (float(i) / float(iter)));\n        }\n    }\n    \n    for (int i = 1; i < JOINTS; ++i)\n    {\n       j[i].pos = endPoint(j[i - 1]);\n    }\n\n    bool b = false;\n    for (int i = 0; i < JOINTS; ++i)\n    {\n        b = b || drawJoint(j[i], uv);\n    }\n    \n    fragColor = vec4(0.7, 0.1, uv.y + 0.3, 0.0);\n    fragColor -= vec4(b ? 1.0 : 0.0);\n    fragColor = max(fragColor, 0.0);\n    if(sin(uv.x * 17.0) * 0.01 - uv.y > 0.20)\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    // target \"light\";\n    fragColor += 1.0 - smoothstep(length(uv - target), 0.0, 0.01);;\n    \n}","name":"","description":"","type":"image"}]}