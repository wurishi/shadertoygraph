{"ver":"0.1","info":{"id":"ll2SzG","date":"1445222488","viewed":125,"name":"Ray Marching - CIS565","username":"arizonat","description":"Ray Marching for CIS565","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Acknowledgements:\n// Mostly from/based off of IQ's code at: https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Xds3zN\n\n//#define DEBUG_ITER\n//#define DEBUG_DIST\n//#define HEIGHT_MAP\n\nvec3 camPos = vec3(3.0,3.0,3.0);\n\nfloat lengthn(vec2 x, float n){\n\treturn pow(pow(x.x,n)+pow(x.y,n), 1.0/n);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    c = normalize(c);\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(lengthn(p.xz,8.0)-t.x,p.y);\n  return lengthn(q,8.0)-t.y;\n}\n\n//----------------------------------------------------------------------\n\n// rotation code from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotation(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 transpose(mat4 m){\n    mat4 mt;\n    for(int i = 0; i < 4; i++){\n        for (int j = 0; j < 4; j++){\n        \tmt[i][j] = m[j][i];\n        }\n    }\n    return mt;\n}\n\nvec3 opTx(vec3 pos, vec3 axis, float angle, vec3 translation){\n    vec3 pos2;\n    mat4 rot = rotation(axis, angle);\n    pos2 = (transpose(rot)*vec4(pos,1.0)).xyz;\n    pos2 -= translation;\n    return pos2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU(\n                \tvec2( sdPlane(pos), 4.0 ),\n\t            \tvec2( sdSphere(pos-vec3( 0.0,0.25, 0.0), 0.25 ), 4.0)\n               );\n    vec3 posEllipsoid = opTx(pos, vec3(0.0,0.0,1.0), 0.2, vec3(1.0,1.0,0.0));\n    vec3 posBox = opTx(pos, vec3(0.0,1.0,0.0), 0.3, vec3(1.0,1.0,-1.0));\n    \n    res = opU(res, vec2(sdEllipsoid(posEllipsoid, vec3(0.2,0.4,0.2)),1.0));\n    \n    res = opU(res, vec2(sdTorus(pos - vec3(-1.5,0.5,0.0),vec2(0.4,0.2)), 3.0));\n    res = opU(res, vec2(sdCylinder(pos - vec3(-1.0,0.0,0.0), vec3(0.01,1.0,0.2)), 2.0));\n    res = opU(res, vec2(sdBox(posBox, vec3(0.2,0.2,0.2)), 2.0));\n    res = opU(res, vec2(sdTorus88(pos, vec2(0.5,0.1)), 1.0));\n    return res;\n}\n\nvec4 naiveCastRayHeightMap(in vec3 ro, in vec3 rd, in sampler2D iChannel){\n    float tmax = 20.0;\n    float tmin = 1.0;\n    float dt = 0.002;\n    const int max_iter = 4000;\n    \n    float t = tmin;\n    float m = -1.0;\n    \n    //vec3 pos = ro + rd*t;\n    vec3 pos;\n    vec4 color;\n    float h;\n    \n\tint iter;\n    for (int i=0; i<max_iter; i++){\n        pos = ro + rd*t;\n        color = texture(iChannel, (pos.xz + 0.7) / 6.0);\n        h = 0.2989*color.r + 0.5870*color.g + 0.1140*color.b;\n        h = h*0.2;\n\n        //h = 1.0/h;\n        //h = color.x\n        \n        if (h >= pos.y){\n            m = color.x;\n        \tbreak;\n        }\n        t += dt;\n\t\titer = i;\n    }\n\n    return vec4(iter,color.xyz);\n}\n\nvec3 naiveCastRay(in vec3 ro, in vec3 rd){\n    float tmax = 20.0;\n    float tmin = 1.0;\n    float dt = 0.005;\n    const int max_iter = 2000;\n    \n    float t = tmin;\n    float m = -1.0;\n    \n    vec2 res = map(ro + rd*t);\n\tint iter;\n    for (int i=0; i<max_iter; i++){\n        res = map(ro + rd*t);\n        if (t > tmax || res.x < 0.0) break;\n        t += dt;\n        m = res.y;\n\t\titer = i;\n    }\n\n    if (res.x > 0.0){\n        m = -1.0;\n    }\n    return vec3(t,m,iter);\n}\n\nvec3 castRayOverRelaxation( in vec3 ro, in vec3 rd )\n{\n    float k = 1.4;\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    int iter;\n    for(int i=0; i<50; i++ )\n    {\n        vec2 hx = map(ro + rd*t);\n        vec2 dt = k*hx;\n        vec2 hy = map(ro+rd*(t+dt.x));\n        \n        dt = float((hy.x >= dt.x))*dt + float((1.0-float(hy.x >= dt.x)))*hx;\n        \n        //if(!(hy.x >= dt.x)){\n        //    dt = hx;\n        //}\n        \n        if( dt.x<precis || t>tmax ) break;\n        \n        t += dt.x;\n        m = dt.y;\n        iter = i;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, iter );\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.0001;\n    float t = tmin;\n    float m = -1.0;\n    int iter;\n    for(int i=0; i<50; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n        m = res.y;\n        iter = i;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, iter );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nfloat calcAmbOcc(in vec3 pos, in vec3 nor)\n{\n    // Heavily based on IQ's implementation\n    // Takes in the surface position and normal, tries several small steps\n    // along the surface normal and finds the amount occluded\n    float occ = 0.0;\n    float offset_amount = 1.0/100.0;\n    float dec = 1.0;\n    for (int i = 0; i<15; i++)\n    {\n        vec3 occ_pos = pos + nor*float(i)*offset_amount;\n        float dist = map(occ_pos).x;\n        occ += (dist-float(i)*offset_amount)*dec;\n        dec *= 0.9;\n    }\n    return clamp(1.0+4.0*occ,0.0,1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.01;\n    float tmax = 2.0;\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 getColor(float m){\n\n    if (m == 1.0){\n        return vec3(1.0,0.0,0.0);\n    } else if (m == 2.0){\n        return vec3(0.0,1.0,0.0);\n    } else if (m == 3.0){\n        return vec3(0.0,0.0,1.0);\n    } else {\n        return vec3(1.0,1.0,1.0);\n    }\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0); // Sky color\n    \n    vec3 res = castRayOverRelaxation(ro,rd);\n    //vec3 res = castRay(ro,rd);\n    //vec3 res = naiveCastRay(ro, rd);\n    \n    float t = res.x;\n    float m = res.y;\n    if( m>-0.5 )  // Ray intersects a surface\n    {\n        vec3 pos = ro + t*rd; // surface position\n        vec3 nor = calcNormal( pos ); // surface normal\n        vec3 light = normalize( vec3(0.6, 0.7, 0.5) ); // direction of the light\n        \n        //col = vec3(0.5,0.5,0.5);\n        //TODO: This color method is slow due to branch divergence\n        col = getColor(m)*0.5;\n\n        // Diffuse shading + ambient occlusion + soft shadows  \n        vec3 brdf = vec3(0.0);\n        \n        float diffuse = clamp( dot( nor, light ), 0.0, 1.0 );\n        diffuse *= softshadow( pos, light );\n        brdf += diffuse;\n        \n        float occ = calcAmbOcc( pos, nor );\n\t\tfloat amb = clamp( nor.y, 0.0, 1.0 );\n        brdf += amb*occ;\n\n\t\tbrdf += 0.3;\n\t\tcol = col*brdf;\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n    float time = 15.0 + iTime;\n\n    // camera\t\n    //vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ro = vec3( -0.5+3.5*cos( 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(6.0*mo.x) );\n    //ro += vec3(0.0,4.0,0.0);\n    //camPos += vec3(mo.x,mo.y,0.0);\n    //vec3 ro = vec3(3.0+mo.x, 3.0+mo.y, 3.0);\n    //vec3 ro = camPos;\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\t\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\n    #ifdef DEBUG_DIST\n    vec3 col = vec3(1.0);\n    vec3 t = naiveCastRay( ro, rd );\n    col = col * (t.x/20.0);\n    #endif\n    \n    #ifdef DEBUG_ITER\n    vec3 col = vec3(1.0);\n    //vec3 t = castRayOverRelaxation( ro, rd );\n    //vec3 t = castRay( ro, rd );\n    vec3 t = naiveCastRay( ro, rd);\n    //col = col * (t.z/50.0);\n    //col = col * (t.z/4000.0);\n    col = col * (t.z/350.0);\n    #endif\n    \n    #ifdef HEIGHT_MAP\n    vec3 col = vec3(1.0);\n    vec4 t = naiveCastRayHeightMap(ro,rd,iChannel0);\n    if (t.x < 3999.0){\n    \tcol = t.yzw;\n    }\n    #endif\n    \n    #ifndef HEIGHT_MAP\n    #ifndef DEBUG_DIST\n    #ifndef DEBUG_ITER\n    vec3 col = render(ro, rd);\n    #endif\n    #endif\n    #endif\n\n\n    //col = pow( col, vec3(0.4545) ); // Gamma correct\n\n    fragColor=vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}