{"ver":"0.1","info":{"id":"Mt3fRj","date":"1541437803","viewed":65,"name":"Alien Squid (With Color)","username":"rlarp","description":"squid with color","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["color","alien","squid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nstruct Shape{ // Basic Shape Constructor\n  float dist;\n  vec4 color;\n};\n    \n// Utility Functions\n   \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 getPolarUV(in vec2 uv)\n{\n    float angle = atan(uv.y, uv.x);\n    angle += PI;\n    angle /= (2.*PI);\n    \n    float dist = distance(vec2(0.), uv);\n    \n    return vec2(angle, dist);\n}\n\nfloat mixColors(float r, float v, float z){\n    return clamp(0.5 + 0.5 * (v-r) / z, 0., 1.); \n}\n\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Main Character (The Squid) \n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.); \n    \n  vec3 p = c; // Base\n  vec3 b = c; // Body\n  vec3 a1 = c; // Arm 1 Sect 1\n  vec3 a12 = c; // Arm 1 Sect 2 \n  vec3 a2 = c; // Arm 2 Sect 1 \n  vec3 a22 = c; // Arm 2 Sect 2 \n  vec3 a3 = c; // Arm 3 Sect 1\n  vec3 a32 = c; // Arm 3 Sect 2 \n  vec3 a4 = c; // Arm 4 Sect 1\n  vec3 a42 = c; // Arm 4 Sect 2 \n  vec3 e1 = c; // Eye 1 \n  vec3 e2 = c; // Pupil\n  vec3 w1 = c; // Wheel inside \n  vec3 w2 = c; // Wheel outside \n  vec3 h = c; // Hat \n  vec3 t = c; // Tentacles\n    \n    \n  // Body\n  vec4 bColor = vec4(1.0, 0.0, 0.3, 0.);  // \n  float body = fBox(b+vec3(0.0, -1.5, 0.0), vec3(0.8, 1.2, 0.75)); // Makes a box (called body) at point p of size = 1.\n    \n  // Base\n  vec4 baColor = vec4(1.0, 0.0, 0.0, 1.0); // \n  float base = fBox(p+vec3(0.0, 0.3, 0.0), vec3(0.55, 0.65, 0.75)); // Makes a box for the base\n    \n  // Eye Outside \n  vec4 e1Color = vec4(0.,0.,0., 0.); // BLACK\n  float eye1 = sdEllipsoid(e1+vec3(0.0,-1.0, 0.4), vec3(.5, abs(sin(iTime))*.5, .6));\n   \n  // Eye Inside\n  vec4 e2Color = vec4(1., 1., 1., 1.); \n  float eye2 = fSphere(e2+vec3((sin(iTime)*0.2), -1.0, 0.5), 0.15); \n   \n  // Note: I intiially had wheels hence the wheels here; I might still implement them later.   \n    \n  // Wheel Outside\n  //float wheel1 = fSphere(w1+vec3(0.0,2.,0.0), 1.0); \n \n  // Wheel Inside\n  //float wheel2 = fSphere(w2+vec3(0.0,sin(iTime)+2.,sin(iTime*0.1)+0.5), 0.4);  \n  \n  // Arm 1\n  vec4 a1Color = vec4(0.,0.,1.,1.);\n  float arm1 = fBox(a1+vec3(1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a12.xy *= rot(radians(45.)); \n  vec4 a12Color = vec4(0.,0.,1.,1.); \n  float arm12 = fBox(a12+vec3(1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 2\n  vec4 a2Color = vec4(0., 0., 1., 1.);\n  float arm2 = fBox(a2+vec3(1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a22.xy *= rot(radians(45.)); \n  vec4 a22Color = vec4(0.,0., 1., 1.); \n  float arm22 = fBox(a22+vec3(1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Arm 3\n  vec4 a3Color = vec4(0., 0., 1., 1.);\n  float arm3 = fBox(a3+vec3(-1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a32.xy *= rot(radians(-45.)); \n  vec4 a32Color = vec4(0., 0., 1., 1.);\n  float arm32 = fBox(a32+vec3(-1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 4\n  vec4 a4Color = vec4(0., 0., 1., 1.);\n  float arm4 = fBox(a4+vec3(-1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a42.xy *= rot(radians(-45.)); \n  vec4 a42Color = vec4(0., 0., 1., 1.);\n  float arm42 = fBox(a42+vec3(-1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Hat\n  vec4 hColor = vec4(1.,1.,1.,1.); \n  float hat = fSphere(h-vec3(0.,2.7,0.0), 0.55); \n    \n  // Tentacles\n  vec4 tColor = vec4(sin(iTime), 0.2, sin(iTime)-0.5, 1.); \n  t.x = abs(t.x)-.15; // Mirror\n  t.x = abs(t.x)-0.15; // Mirror again\n  t.xy *= rot(radians(180.)); // Rotates it to face the other way\n  t.x += sin(t.y * 10. - iTime * 4.) * (1. - t.y) * .03; // Animates the tentacles\n  // float tentacles = fCone(t+vec3(0., 0.5, 0.), 0.4, 3.); // Animates the tentacles\n  float tentacles = fCone(t+vec3(0., -0.55, 0.), 0.4, 2.); \n      \n    \n  shape.dist = max(body, -eye1); // Adds the box and eye (difference)\n  shape.dist = min(shape.dist, eye2); // Use shape.dist after two shapes \n  shape.dist = min(shape.dist, base); \n  //shape.dist = min(shape.dist, wheel1); \n  //shape.dist = max(shape.dist, -wheel2); \n  shape.dist = min(shape.dist, arm1); \n  shape.dist = min(shape.dist, arm12); \n  shape.dist = min(shape.dist, arm2); \n  shape.dist = min(shape.dist, arm22); \n  shape.dist = min(shape.dist, arm3);\n  shape.dist = min(shape.dist, arm32);\n  shape.dist = min(shape.dist, arm4);\n  shape.dist = min(shape.dist, arm42);\n  shape.dist = min(shape.dist, tentacles); \n  shape.dist = fOpUnionColumns(shape.dist,hat, 1., 5.); // Creates the hat ilke effect\n  \n  shape.color = mix(bColor, baColor, mixColors(base, body, 0.0));\n  shape.color = mix(shape.color, baColor, mixColors(body, shape.dist, 0.0));\n  shape.color = mix(shape.color, e1Color, mixColors(eye1, shape.dist, 0.0));\n  shape.color = mix(shape.color, e2Color, mixColors(eye2, shape.dist, 1.0));\n  shape.color = mix(shape.color, a1Color, mixColors(arm1, shape.dist, 0.0));\n  shape.color = mix(shape.color, a12Color, mixColors(arm12, shape.dist, 1.0));\n  shape.color = mix(shape.color, a2Color, mixColors(arm2, shape.dist, 0.0)); \n  shape.color = mix(shape.color, a22Color, mixColors(arm22, shape.dist, 1.0));\n  shape.color = mix(shape.color, a3Color, mixColors(arm3, shape.dist, 0.0));\n  shape.color = mix(shape.color, a32Color, mixColors(arm32, shape.dist, 1.0));\n  shape.color = mix(shape.color, a4Color, mixColors(arm4, shape.dist, 0.0));\n  shape.color = mix(shape.color, a42Color, mixColors(arm42, shape.dist, 1.0));\n  shape.color = mix(shape.color, tColor, mixColors(tentacles, shape.dist, 1.0));\n  shape.color = mix(shape.color, hColor, mixColors(hat, shape.dist, 0.5)); \n    \n    \n  return shape;\n}\n\nShape background(vec3 b){ // Creates the background (circle and box) \n   Shape shape;\n   shape.dist = 1000.;\n   shape.color = vec4(1.0); \n  //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.);  \n   vec3 g = b; // Ground\n   vec3 g1 = b; // Ground 1\n    \n   g.xz *= rot(b.y*0.2+iTime);\n   vec4 gColor = vec4(5., 8., 1., 1.);\n   float ground = fSphere(g-vec3(0.,-12.75, 0.0), 10.); \n   vec4 hColor = vec4(1., 1., 1., 1.); \n   float holder = fBox(g1-vec3(.0, -5., .0), vec3(100., .5, 0.));\n    \n   shape.dist = min(ground, holder);\n   shape.color = mix(gColor, hColor, mixColors(holder, ground, 0.0));\n    \n    return shape; \n  \n}\n\n\nShape map(vec3 c){ // Maps everything together (the Background and Character) \n  Shape face = character(c);\n  Shape ground = background(c);\n  face.dist = min(face.dist, ground.dist); \n  face.color = mix(face.color*2., ground.color, mixColors(ground.dist, face.dist, 0.5)); \n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Camera, dimensions, etc \n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.5);\n   // vec3 cam = vec3(-sin(iTime)*0.3-0.5, sin(iTime)+2., sin(iTime)-10.); \n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}","name":"Image","description":"","type":"image"}]}