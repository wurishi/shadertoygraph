{"ver":"0.1","info":{"id":"cdfBDH","date":"1688661406","viewed":44,"name":"Line-circle intrersection parame","username":"Envy24","description":"Solution in desmos: https://www.desmos.com/calculator/ui80zx6lla\nIntersection between line and circle, when both defined parametrically.\ns(t) = c + r * (cos(t), sin(t)), c - center, r - radius\nl(t) = c + f * t, c - center, f - forward direction","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["line","intersection","circle","parametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Use mouse to drag viewport.\n\n    3d version: https://www.shadertoy.com/view/NtsXz4#\n    This shader helps to understand how zFocalLength (from Blender perspective camera) affects zoom.\n    \n    Resulting image resolution is w=1., h = num_of_rays, where ray color represent pixel color.\n    Also notice that placing viewport after scene is not an error. You still get an image.\n    Placing viewport left of camera still get intersection, because \n*/\n\n#define SCENE_SCALE               ( 4. )\n#define ORIGIN                    ( vec2(0,0) )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec2 line_sphere_intersection(\n    vec2 ray,\n    vec2 ray_dir,\n    vec2 sphere,\n    float r)\n{\n    float a = ray_dir.y,\n          b = -ray_dir.x,\n          c = sign(a)*sqrt(a*a+b*b), // sqrt(a*a+b*b) == 1 for normalized vectors\n          phi = atan(-b/a),\n          numer0 = ray_dir.x*(sphere.y-ray.y),\n          numer1 = ray_dir.y*(sphere.x-ray.x),\n          t0 = acos( (numer0-numer1) / (r*c) ) - phi,\n          t1 = acos( (numer1-numer0) / (r*c) ) - phi + 3.141592;\n             \n    return vec2(t0, t1);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n    \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC)*0.5; color -= y_axis(NDC)*0.5;\n         color -= cellsSDF(NDC)*0.2;\n    \n    float radius = 1.;\n    vec2 sphere = vec2(0,0),\n         ray = iMouse.xy == vec2(0) ? vec2(cos(iTime)*sin(0.3*iTime), sin(iTime)) * 3. : MP,//vec2(-2,0),\n         look_at = vec2(1,1), // or sphere\n         ray_dir = normalize(look_at - ray);        \n         \n    color = mix(color, vec3(1,0,0), SMAA(abs(diskSDF_L2(NDC, sphere, radius))));    \n    color = mix(color, vec3(0,1,0), SMAA(segmentSDF_L2(NDC, ray-ray_dir*99., ray+ray_dir*99., 0.)));\n    color = mix(color, vec3(0,0,0), SMAA(diskSDF_L2(NDC, ray, 0.04)));\n    color = mix(color, vec3(0,0,1), SMAA(arrowSDF_L2(NDC, ray, ray+ray_dir, 0.)));\n    \n    vec2 t = line_sphere_intersection(ray, ray_dir, sphere, radius);\n    color = mix(color, vec3(0,0,0), SMAA(diskSDF_L2(NDC, sphere + radius*vec2(cos(t.x), sin(t.x)), 0.04)));\n    color = mix(color, vec3(0,0,0), SMAA(diskSDF_L2(NDC, sphere + radius*vec2(cos(t.y), sin(t.y)), 0.04)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// Points exactly at point E.\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}