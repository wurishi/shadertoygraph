{"ver":"0.1","info":{"id":"NtdBR7","date":"1663006352","viewed":92,"name":"Raymarching Intro","username":"alexw5408","description":"Introduction to raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265351;\nconst float height = 2.0;\n\nvec4 sphere = vec4(0, 1.5, 6, 1);\n\nvec3[] lightPositions = vec3[](\n    vec3(-2, height, 6),\n    vec3(0, height, 4),\n    vec3(2, height, 6),\n    vec3(0, height, 8)\n);\n\nfloat hitDist = 0.001;\nfloat maxDist = 100.0;\nint maxSteps = 100;\n\nfloat getDist (vec3 p) {\n    float distanceSphere = length(p - sphere.xyz) - sphere.w;\n    float distancePlane = p.y;\n    float d = min(distanceSphere, distancePlane);\n    return d;\n}\n\nfloat rayMarch (vec3 ro, vec3 rd) {\n    float distanceOrigin = 0.0;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 position = ro + rd * distanceOrigin;\n        float distanceScene = getDist(position);\n        distanceOrigin += distanceScene;\n        \n        if (distanceScene < hitDist || distanceOrigin > maxDist) break;\n    };\n    \n    return distanceOrigin;\n}\n\nvec3 getNormal (vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.00001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat getLight (vec3 point) {\n    float diffuse = 0.0;\n    \n    for (int i = 0; i < lightPositions.length(); i++) {\n        vec3 lightPos = lightPositions[i];\n        vec3 lightVector = lightPos - point;\n        vec3 lightNormal = normalize(lightVector);\n        vec3 normal = getNormal(point);\n        \n        float newDiffuse = clamp(dot(lightNormal, normal), 0.0, 1.0) / length(lightVector);\n        float hitDistance = rayMarch(point + normal * hitDist * 2.0, lightNormal);\n        \n        if (hitDistance < length(lightPos - point)) newDiffuse *= 0.1;\n        \n        diffuse += newDiffuse;\n    };\n    \n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 cameraPos = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.xy, 1));\n    \n    // Updating light position\n    float floatLength = float(lightPositions.length());\n    \n    for (int i = 0; i < lightPositions.length(); i++) {\n        float offset = -pi + 2.0 * float(i) / floatLength * pi;\n        // float offset = 1.0 / float(lightPositions.length()) * float(i);\n        // float offset = -1.0 + 1.0 / float(lightPositions.length()) * float(i);\n        lightPositions[i].xz = sphere.xz + vec2(sin(iTime + offset), cos(iTime + offset)) * 2.0;\n    };\n    \n    float d = rayMarch(cameraPos, rayDirection);\n    \n    vec3 point = cameraPos + rayDirection * d;\n    \n    vec3 col = vec3(0.25, 1, 1) * getLight(point);\n    col = pow(col, vec3(.4545)); // Gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}