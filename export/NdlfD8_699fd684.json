{"ver":"0.1","info":{"id":"NdlfD8","date":"1646096740","viewed":134,"name":"Soft LoS using a Penumbra LUT","username":"WorkingJoe","description":"Soft shadows in 2D using raycasts and radial blur weighted by a LUT for a penumbra. Click anywhere to cast the shadows. Light bleeds some distance into the occluders, allowing their textures to show through.\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"sdlfR8","parentname":"Soft LoS, look into occluders"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This final shader combines all the earlier results.\n// The shadow map from buffer C is sampled using polar coordinates to draw the shadows\n// To allow visibility into the occluders, the shadows on top of occluders are decreased some distance from the hit point\n// The blurred raycast texture in buffer D is used to smoothen the effect on top of occluders. This allows a lower ray \n// step count.\n\n// The performance here might look bad, but this is due to shadertoy limitations. Some notes on the performance:\n// -The shader for Buffer B should be used once to create an LUT, but here is generated continually.\n// -The raycast has to be called on an 1xN texture, with a pixel for each ray. Here it's called for all pixels, meaning that all columns\n//  do the same raycast again\n// -It is possible to have the light texture at a resolution smaller than the final image. Using less rays (less wide lightmap X) will not\n//  affect looks too much since the polar texture can be sampled linearly. This results in a radial blur, which is alright.\n\n// ########################## CONSTS ##########################\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// TAU, 2*Pi\nconst float M_TAU = 6.28318530717958647692528676655900577;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// ########################## INPUT PARAMS ##########################\n\n// Maximum length of the raycasts\nconst float rayLength = 1.25f;\n\n// Bias used to convert the noise to an occlusion map\nconst float bias = 0.5f;\n\n// Distance into objects that is seen\nconst float inDist = .05f;\n\n// Strength of the falloff near the view range end\nconst float sightFalloff = 4.f;\n\n// ########################### MAIN BODY ###########################\n\n// Classic function to calculate noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 a = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 p = iMouse.xy/iResolution.xy;\n    \n    // demo\n    if(p==vec2(0.,0.)) p = vec2(.450f, .467f) + vec2(0.326*cos(.1*M_TAU*iTime), 0.357*sin(.1*M_TAU*iTime));\n\n    vec2 norm = a*(p-uv);\n\n    // Calculate the polar coordinates\n    float theta = 0.5f+0.5f*M_1_PI*atan(norm.y,norm.x);    \n    \n    float dist = length(norm);\n\n    // Sample the shadow map using the polar coordinates\n    float shadow = texture(iChannel0, vec2(theta, dist/rayLength)).r*rayLength;\n    \n    // draw the geometry\n    float geom = texture(iChannel0, uv).g;\n    \n    // Reduce the shadow some distance into occluders\n    float dist_occluder = dist-texture(iChannel3, vec2(theta,0.0f)).r*rayLength; \n    if(geom < bias){ shadow = max(0., dist_occluder)/inDist;}\n    \n    // Darken edge of viewrange\n    shadow += max(0., 1.-sightFalloff*(1.-dist));\n    \n    // Combine the results\n    fragColor = vec4(0.5f-0.5f*shadow, 1.0-geom-shadow, 0.3*(1.-geom), 1.0f);\n    // fragColor = texture(iChannel0, uv); // uncomment to see the polar lightmap (R) and occlusion map (G)\n    // fragColor = texture(iChannel1, uv); // uncomment to see the penumbra LUT\n    // fragColor = texture(iChannel2, uv); // uncomment to see the raycast LUT (R) and occlusion map (G)\n    // fragColor = texture(iChannel3, uv); // uncomment to see the blurred raycast LUT\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// This shader does two things\n// Firstly it creates the occlusion map and stores this in the green channel.\n// Secondly it casts rays from the mouse position in all directions. This is done by stepping \n//\n// In practice this only has to be done for the number of rays you need. You'll have a 1xN\n// texture where each pixel casts a ray. \n// In this shadertoy it's done for each pixel based on the x coordinate as well, but this means\n// that each column does the same calculation. \n\n// ########################## CONSTS ##########################\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// TAU, 2*Pi\nconst float M_TAU = 6.28318530717958647692528676655900577;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// ########################## INPUT PARAMS ##########################\n\n// Bias used to convert the noise to an occlusion map\nconst float bias = 0.5f;\n\n// Number of steps per ray\nconst int stepCount = 64;\n\n// Maximal ray length\nconst float rayLength = 1.25f;\n\n// ########################### MAIN BODY ###########################\n\n// Calculate the value of the occlusion map at a certian coordinate \nfloat geometry(vec2 uv, float bias)\n{     \n    //noise\n    return step(texture(iChannel0, uv).r,bias);\n    \n    //rectangle\n    //return 1. - step(abs(.5 - uv.x), .05) * step(abs(.5 - uv.y), .05);\n}\n\n// Calculate the distance of a ray from the center p in the direction theta\nfloat rayCast(vec2 p, float theta, float bias, float rayLength, int steps, float a)\n{\n    float stepSize = rayLength/float(steps);\n    \n    // Step in direction of ray\n    vec2 increment = stepSize*vec2(cos(theta)/a, sin(theta));\n    \n    vec2 coord = p;\n    \n    for(int i = 0; i < steps; i++)\n    {    \n        if(geometry(coord, bias) < .5) break;\n        coord += increment;\n    \n    }\n    \n    vec2 dist = coord - p; // UV space\n    dist.x *= a; // world space\n    return length(dist)/rayLength;\n}\n\n// Store the distance in iResolution.y directions in the columns of the r channel\n// and store the occlusion map in the green channel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float a = iResolution.x/iResolution.y;\n    vec2 p = iMouse.xy/iResolution.xy;\n\n    // demo\n    if(p==vec2(0.,0.)) p = vec2(.450f, .467f) + vec2(0.326*cos(.1*M_TAU*iTime), 0.357*sin(.1*M_TAU*iTime));\n    \n    float geom = geometry(uv,bias);\n        \n    float ray = rayCast(p, M_TAU*uv.x, bias, rayLength, stepCount, a);\n\n    fragColor = vec4(ray,geom,0,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// This shader calculates the light level for positions within the penumbra of a shadow. \n// This is intended to be used once and then used as a LUT\n\n// To see it work separately,\n// check out https://www.shadertoy.com/view/sd2BzD\n\n// The LUT is in polar coordinates. Distance from the occluder changing with X, the angle from the occluder changes with Y.  \n// The light source is at the world origin, and the occluder extends down from the X acis and to the right from the occluder distance.\n// The light level is calculated by testing for each point in the shadow the line of sight to points\n// in the lower half of the light's radius (all points in the upper half would hit). \n// The points chosen lie on the lower half of a vogel disk.\n\n// ########################## INPUT PARAMS ##########################\n\n// Amount of light points sampled (includes top half of disk)\nconst int lightPoints = 2048;\n\n// Radius of the light\nconst float lightRadius = .12;\n\n// Distance of the occluder from the origin on the X axis\nconst float occluderDistance = .5;\n\n// Maximum distance from at which the shadow is evaluated\n// (the output tex X ranges from the occluder to the occluder plus this distance)\nconst float rayLength =  1.f;\n\n// Angle from the occluder at which the shadow is evaluated\n// (the output tex Y ranges from 0 to this angle)\nconst float penumbraAngle = 0.15;\n\n// ########################### MAIN BODY ###########################\n\n// Calculate the fraction of ray hits for a certain world pos\nfloat getDiskRays(vec2 worldPos)\n{\n    float lightLevel = 0.;\n    int lightCount = 0;\n    \n    for (int i = 0; i < lightPoints; i++)\n    {\n        // Vogel disk sampling\n        float theta = 2.4 * float(i);\n        float r = sqrt((float(i) + 0.5) / float(lightPoints));\n        vec2 u = r * vec2(cos(theta), sin(theta));\n        \n        // Discard samples in the top half circle\n        if(u.y > 0.) continue; \n        \n        // Calculate light position of bottom half\n        vec2 lightPos = u * lightRadius;\n        lightCount++;\n        \n        // Increase the light level if there is LoS\n        // Think of this as evaluating a a linear equation from the light to the point in the shadow \n        // at the X coordinate of the occluder. There is LoS if this line is above the X axis at this point.\n        lightLevel += step(0., lightPos.y+(worldPos.y-lightPos.y)/(worldPos.x-lightPos.x)*(occluderDistance-lightPos.x));      \n        \n    }\n    lightLevel /= float(lightCount);     \n    \n    return lightLevel;\n}\n\n\n// Calculate the fraction of ray hits for a certain world pos\nfloat getLight(vec2 uv)\n{\n    float r = occluderDistance + uv.x*rayLength;\n    float angle =  uv.y*penumbraAngle;\n    // angle =  uv.y*atan(lightRadius/occluderDistance); // uncomment for auto-scaling the angle\n    vec2 worldPos = r*vec2(cos(angle), sin(angle));\n    return getDiskRays(worldPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float shadow = 1.-getLight(uv);\n    \n    // Output to screen\n    fragColor = vec4(vec3(shadow),1.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// This shader creates a shadow map in polar coordinates using the results of the raycast in buffer A.\n// Adjacent rays are also sampled to determine the (angular) distance to the occluder.\n// This is used to sample the penumbra LUT from buffer B to create a penumbra\n\n// ########################## CONSTS ##########################\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// TAU, 2*Pi\nconst float M_TAU = 6.28318530717958647692528676655900577;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// ########################## INPUT PARAMS ##########################\n\n\n// Number of radial samples in each direction taken for the penumbra\nconst int penumbraSteps = 8;\n\n// Angle offset between the samples taken for the penumbra\nconst float penumbraAngle = 0.15f;\n\n// Maximum length of the raycasts\nconst float rayLength =  1.25f;\n\n// ########################### MAIN BODY ###########################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    // Occlusion\n    vec4 color = texture(iChannel0, uv);\n    \n    float shadow = 0.0f;\n    \n    // If behind ray on main occluder is \n    float dist_occluder = uv.y-texture(iChannel0, vec2(uv.x,0.0f)).r;  \n    if(dist_occluder > 0.) shadow = 1.0f;    \n\n    // penumbra\n    float angle_increment = penumbraAngle/float(penumbraSteps+2)/M_TAU; // step distance on raycast LUT\n    float angle_increment_uv = 1./float(penumbraSteps+2); // step distance on penumbra LUT\n    for(int i = 1; i <= penumbraSteps; i++)\n    { \n        // Get distance of adjacent ray \n        float dist_occluder = uv.y-texture(iChannel0, vec2(uv.x+float(i)*angle_increment,0.0f)).r;  \n        // Use distance to sample occlusion from Penumbra LUT\n        float occlusion = texture(iChannel1, vec2(dist_occluder*rayLength,float(i)*angle_increment_uv)).r;         \n        shadow = max(occlusion, shadow);\n        \n        // Second sample in other direction\n        dist_occluder = uv.y-texture(iChannel0, vec2(uv.x-float(i)*angle_increment,0.0f)).r;  \n        occlusion = texture(iChannel1, vec2(dist_occluder*rayLength,float(i)*angle_increment_uv)).r;         \n        shadow = max(occlusion, shadow);\n        \n    }\n    \n    fragColor = vec4(shadow, color.g, 0.0f, 1.0f);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// This shader performs a special blur the raycast texture. \n// Samples with a large difference in distance have less weight in the kernel.\n// This is used to smoothe out differences in ray steps on adjacent rays on top of occluders.\n// To see why this is needed, set the steps to 0.\n// \n\n// ########################## INPUT PARAMS ##########################\n\n// Number of samples to take in each direction\nconst int steps = 8;\n\n// Ray length to normalise distance in ray texture\nconst float rayLength =  1.25f;\n\n// Factor determining the decrease in sample contribution based on the difference in distance between samples\nconst float distWeight = 5.;\n\n// ########################### MAIN BODY ###########################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Get distance from ray texture\n    float dist = texture(iChannel0, uv).r;\n    \n    float color = dist;\n    float weight = 1.;\n    float stepWeight = 1./float(steps);\n    \n    // The distance between the samples is increased based on the range\n    // Technically this should be ATAN based but this is faster\n    // Based on a curve fit with a few values that worked at different distances\n    float blurAngle = stepWeight*.0069/(dist+0.1337);\n    \n    for(int i = 1; i <= steps; i++)\n    {\n        // Falloff with angle from the ray\n        float falloffWeight = 1.-float(i)*stepWeight;\n        \n        // Falloff with distance from the ray\n        float sampleDist = texture(iChannel0, vec2(uv.x-float(i)*blurAngle, 0.)).r;\n        float sampleWeight = falloffWeight*max(0., 1.-distWeight*abs(dist-sampleDist));\n        weight += sampleWeight;\n        color += sampleWeight*sampleDist;\n        \n        // Second sample in other direction        \n        sampleDist = texture(iChannel0, vec2(uv.x+float(i)*blurAngle, 0.)).r;\n        sampleWeight = falloffWeight*max(0., 1.-distWeight*abs(dist-sampleDist));\n        weight += sampleWeight;\n        color += sampleWeight*sampleDist;\n    }\n    \n    color /= weight;\n    \n    fragColor = vec4(vec3(color), 1.);\n}","name":"Buffer D","description":"","type":"buffer"}]}