{"ver":"0.1","info":{"id":"tdGfDy","date":"1608388617","viewed":173,"name":"Satisfaction Machine","username":"shau","description":"inspired by \"oddly satisfying\" animations [url]https://www.youtube.com/c/arbenl1berateme/featured[/url]","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .005\n#define FAR 100.\n#define T iTime\n#define PI 3.141592\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Eiffie\nfloat sdHelix(vec3 p, float r1, float r2, float m) \n{\n    float halfm = m*.5,\n          b = mod(p.y, PI*m) - PI*halfm,\n          a = abs(atan(p.x, p.z) * halfm - b);\n    if (a > PI*halfm) a = PI*m - a;\n\n    //optimisation from Shane\n    p.xy = vec2(length(p.xz) - r1, a);\n    p.x = abs(p.x) - .5;\n    return length(p.xy) - r2;\n}\n\n//IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.yz)-t.x,p.x);\n    return length(q)-t.y;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 near(vec2 a, vec2 b) {\n    float s = step(a.x,b.x);\n    return a*s + b*(1. - s);\n}\n\n/* Model */\n\nvec2 rail(vec3 p, float yoff)\n{\n    float t = max(sdHelix(p,3.5,0.1,1.0), abs(p.y - 0.8) - PI*0.4);\n    t = min(t, max(sdTorus(p - vec3(0.,PI*0.5,3.5), vec2(0.5,0.1)), p.y - PI*0.5));\n    t = min(t, max(sdTorus(p.zyx - vec3(0.0,PI*0.25,-3.5), vec2(0.5,0.1)), p.y - PI*0.25));\n    t = min(t, max(sdTorus(p - vec3(0.,0.,-3.5), vec2(0.5,0.1)), p.y));\n    t = min(t, sdCappedCylinder(p - vec3(-1.,PI*0.25,0.), 0.4, 0.6));\n    t = min(t, sdCappedCylinder(p.yxz - vec3(PI*0.25,-2.,0.), 0.1, 1.0));\n    t = max(min(t, sdCappedCylinder(p.xzy - vec3(-2.,0.,PI*0.25), 0.3, 0.28)), p.x);\n \n    p.z = abs(p.z);\n    p.xy -= vec2(-2., PI*0.25);\n    p.xy *= rot(yoff*0.04);\n    t = min(t, sdCappedCylinder(p.xzy - vec3(0.,0.7,0.), 0.3, 0.35));\n    t = min(t, sdCappedCylinder(p - vec3(0.,6.+yoff,0.7), 0.3, 4.0));\n\n    float t1 = sdCappedCylinder(p - vec3(0.,4.,0.7), 0.15, 4.0);\n    t1 = min(t1, sdCappedCylinder(p.xzy - vec3(0.,0.7,0.), 0.2, 0.45));\n    \n    return near(vec2(t,1.), vec2(t1,2.));\n}\n\nvec2 map(vec3 p) \n{\n    float at = mod(T, 2.*PI);\n    \n    vec3 q = p;\n    q.xz *= rot(at);\n    vec2 n = vec2(length(q - vec3(0.,0.5,-3.5)) - 0.6, 3.);\n    n = near(n, vec2(length(vec2(abs(p.x), p.z) - vec2(1.0, 0.0)) - 0.2, 2.));\n\n    p.y -= at*0.5;\n\n    q = p;\n    float yoff1 = clamp((at - 1.0)*2.0,0.,PI);\n    float yoff2 = clamp((at - (1.0 + PI))*2.0,0.,PI);\n    q.y += yoff1;\n    n = near(n, rail(q, yoff1 - clamp((at - (0.2 + PI))*4.0,0.,PI)));\n    p.y += PI*0.5 + yoff2;\n    p.xz *= rot(PI);\n    n = near(n, rail(p, (PI - clamp((at - 0.2)*4.0,0.,PI)) + yoff2));\n    \n    return n;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\nvec2 march(vec3 ro, vec3 rd) \n{\n    float t = 0.0, id = 0.0;   \n    for (int i=ZERO; i<100; i++)\n    {\n        vec2 ns = map(ro + rd*t);\n        if (ns.x<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec2(t,id);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0),\n         la = vec3(0),\n         lp = vec3(5,5,-2),\n         ro = vec3(0,5.+sin(T*0.3)*2.,-7. + sin(T*0.21)*2.);\n    \n    ro.xz *= rot(1.0 + T*0.5);\n    vec3 rd = camera(U,ro,la,1.4);\n    \n    vec2 s = march(ro,rd);\n    if (s.x>0.0)\n    {\n        vec3 p = ro + rd*s.x;\n        vec3 n = normal(p);\n        vec3 ld = normalize(lp - p);\n        float ao = AO(p, n);\n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 8.0);\n\n        vec3 sc = vec3(0);\n        if (s.y == 1.) sc = texture(iChannel0, reflect(rd,n)).xyz;\n        if (s.y == 2.) sc = vec3(0.08);\n        if (s.y == 3.) sc = vec3(1,0,0);\n        pc += sc * max(0.05,dot(ld,n));\n        pc += vec3(1) * spec;\n        pc *= ao;\n    }\n    C = vec4(pc,1.0);\n}","name":"Image","description":"","type":"image"}]}