{"ver":"0.1","info":{"id":"lclGzl","date":"1703527542","viewed":30,"name":"cyclical animation","username":"GravityMan","description":"Learning  the basics of GLSL, pls roast\nHere is a shader abusing a clock function, and a circle function.\nI want to learn, so please, any amount of criticism is welcome.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 uv, vec2 p, float radius, float blur)\n{\n    float c = length(uv - p);\n    c = smoothstep(radius, radius - blur, c);\n    return c;\n}\n\nfloat clock(float speed, float phase) // phase between 0 and 1, 0 = 1\n{\n    float clock = (sin((iTime*speed) + (phase * 3.14159265)) + 1.)/2.;\n    return clock;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((2.*fragCoord/iResolution.xy)-1.);\n    uv.x = uv.x * (iResolution.x/iResolution.y);\n    \n    float mask = 0.;\n    \n    float iterationcount = 20.;\n\n    for(float i = 0.; i < iterationcount;++i)\n    {\n        float phase = i / (iterationcount/2.);\n        vec2 rotatepos = vec2((2. * clock(1.5, phase) - 1.), ((2. * clock(1.5, phase + .5)) - 1.));\n        float x = ((mod(i, 4.) / .25)*.1) + .9;\n        mask += circle(uv, (rotatepos * ((.8 * clock(1., x)) + .1)), .1, .01);\n    }\n\n\n    //draw background\n    mask += smoothstep(-30., 3., uv.x);\n    \n    \n    float lightspeed = .02;\n    vec2 lightrotatepos = vec2((2. * clock(lightspeed, .0) - 1.), ((2. * clock(lightspeed, .5)) - 1.));\n    float light = 1.5*(circle(uv, vec2(lightrotatepos*1.1), 3.4, (3.)));\n    \n    // Apply color mask\n    float r = .6*clock(.1, 0.);\n    float g = .6*clock(.2, 0.);\n    float b = .6*clock(.3, 0.);\n    vec3 rgb = vec3(r, g, b);\n    vec3 col = rgb * mask * light;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}