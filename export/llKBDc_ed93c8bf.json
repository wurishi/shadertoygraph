{"ver":"0.1","info":{"id":"llKBDc","date":"1544389324","viewed":329,"name":"Sink or Float","username":"Passion","description":"A bit of random rotation and movement","likes":16,"published":1,"flags":64,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"llfGR4","filepath":"https://soundcloud.com/thelongestjohns/bones-in-the-ocean","previewfilepath":"https://soundcloud.com/thelongestjohns/bones-in-the-ocean","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define eps 0.01\n\nmat2 r2d(float a){\n    float s = sin(a);\n\tfloat c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float d1, float d2, float k){\n        float h = exp(-k * d1) + exp(-k * d2);\n        return -log(h) / k;\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvoid partitionSpaceAndColor(inout vec3 c, inout vec3 p){\n    // index the cells\n    vec3 i = floor(p);\n    //random y\n    float ry = fract(sin(i.x*76.78+i.z*786.89)*1488.88);\n    //if random number is over .49 invert y direction\n    float updown = 1.0;\n    updown = (ry>.49) ? 1.0 : -1.0;\n    //addto and move y\n    p.y += (ry*1.5 + iTime*ry*2.5)*updown;\n    p.y += ry;\n    //re index cells\n    i=floor(p);\n    //divide the space\n    p=fract(p)-.5;\n    //random rotation using reindexed vec3    \n    float r  = fract(sin(i.x*76.68+i.y*148.34)*768.78);\n    float r2 = fract(sin(i.z*76.68+i.y*148.34)*768.78);\n    p.xz*=r2d(r- iTime*(r*3.));\n    p.xy*=r2d(r2-iTime*(r*2.5));    \n    //random color\n    float c1  = fract(sin(i.x*76.68+i.y*148.34)*768.78);\n    float c2 = fract(sin(i.z*76.68+i.y*148.34)*768.78);\n    float c3 = fract(sin(i.z*76.68+i.x*148.34)*768.78);\n    \n    c = vec3(c1,c2,c3);\n    \n}\n\nfloat map(vec3 p){\n    \n    vec3 dummyVec = vec3(0.0);\n    partitionSpaceAndColor(dummyVec, p);\n    //p += (sin(p.x*55.)*sin(p.y*55.5)*sin(p.z*56.)*.0075);\n    //return smin(udRoundBox(p,vec3(.15),.015), pl, 6.); //*.75;\n    return udRoundBox(p,vec3(.15),.015);\n}\n\nfloat trace(vec3 r, vec3 o){\n    float t = 0.0;\n    for(int i = 0; i < 64; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.75;\n        if(d<eps || t > 8.0) break;\n    }\n    return t;\n}\n\nvec3 getNormal2(in vec3 p) {\n\tvec2 e = vec2(eps, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\n// https://github.com/darrenmothersele/raymarch/blob/master/shaders/frag.glsl\nvec3 getNormal(in vec3 p) {\n\t// 6-tap normalization. Probably the most accurate, but a bit of a cycle waster.\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 l = normalize(vec3(0.3, 0.4, 0.75));\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * .33));\n    vec3 o = vec3(0.0, 0.9, -9.0);\n    \n    o.zy *= r2d(iTime*.15);\n    //o.y = -map(sp)+.3;\n    r.zy*=r2d((sin(iTime/4.)*.5));\n    r.xz*=r2d(iTime*.73+sin(iTime*.25)*4.);\n    \n    \n    float t = trace(r, o);\n    \n    vec3 sp = o+r * t;\n    float d = map(sp);\n\t//vec3 sky = pow(vec3(0.1,0.1,0.65),vec3(3.*r.y));\n\t// https://www.shadertoy.com/view/MlcGD7\n    vec4 sky= pow(vec4(.1, .7, .8, 1), vec4(4.*max(-r.y,-0.41)+2.))+(dot(r,l)*.315+.215);\n    \n    vec3 n = getNormal(sp);\n    \n    float fog = smoothstep(-0.015, .17, t*0.03);\n    // Time varying pixel color\n    //vec4 col = (sky);    //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 c = vec3(0.0);\n    \n    // so if 'sp' or surface position was to be used later it wouldnt be changed...\n    vec3 tmpSP = sp;\n    partitionSpaceAndColor(c, tmpSP);\n    \n    if(abs(d) < .5){\n        vec3 rf = reflect(r,n);\n        vec3 cmp = texture(iChannel0, rf).rgb;\n        fragColor = mix(vec4(0.25+cmp+vec3(c),1.0)* max(dot(n,l),0.18), vec4(sky), fog);\n    }\n    else\n    \tfragColor = vec4(sky);\n}\n\n\n/*\n        vec3 i = floor(sp);\n        float ry = fract(sin(i.x*76.78+i.z*786.89)*1488.88);\n        sp.y += ry*1.5 + iTime*ry;\n        sp.y += ry;\n        i=floor(sp);\n\n        sp=fract(sp)-.5;\n        \n        \n        \n    \tfloat c1  = fract(sin(i.x*76.68+i.y*148.34)*768.78);\n    \tfloat c2 = fract(sin(i.z*76.68+i.y*148.34)*768.78);\n        float c3 = fract(sin(i.z*76.68+i.x*148.34)*768.78);\n        */\n        //vec3 c = partitionSpaceAndColor(sp);\n\n    //vec3 i = floor(sp);\n    //vec3 rn = fract(i);\n    //rn=floor(rn);\n\n\n\n//float pl = p.y;\n/*    \n    vec3 i = floor(p);\n    float ry = fract(sin(i.x*76.78+i.z*786.89)*1488.88);\n    p.y += ry*1.5 + iTime*ry;\n    p.y += ry;\n    i=floor(p);\n    \n    p=fract(p)-.5;\n    \n    float r  = fract(sin(i.x*76.68+i.y*148.34)*768.78);\n    float r2 = fract(sin(i.z*76.68+i.y*148.34)*768.78);\n    p.xz*=r2d(r- iTime*(r*3.));\n    p.xy*=r2d(r2-iTime*(r*2.5));\n    */","name":"Image","description":"","type":"image"}]}