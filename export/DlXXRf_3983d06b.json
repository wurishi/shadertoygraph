{"ver":"0.1","info":{"id":"DlXXRf","date":"1675113058","viewed":63,"name":"Analytical 2D Grid Soft Shadows","username":"Oberdiah","description":"What I believe to be mathematically correct soft shadows on a grid.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","shadow","square","analytical","soft"],"hasliked":0,"parentid":"tdccz8","parentname":"Testing branchless size changing"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define steps 50\n\nconst int numLights = 3;\n\nvec2 lightPos[numLights] = vec2[numLights](\n    vec2(0., -2.),\n    vec2(2., -4.),\n    vec2(-2., -5.)\n);\n\nvec3 lightColors[numLights] = vec3[numLights](\n    vec3(1., 0.7, 0.3),\n    vec3(0.3, 0.6, 0.8),\n    vec3(0.4, 0.9, 0.5)\n);\n\nvec2 toWorldspace(vec2 a) {\n    a -= vec2(-70.0, 40.0);\n    return (a * 2.0 - iResolution.xy) / (iResolution.y/9.0);\n}\n\n// Interesting: https://www.shadertoy.com/view/wsKXzK\n// Also interesting: https://www.shadertoy.com/view/7scXD4\n\nfloat line( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nbool isOpaque(vec2 q) {\n    for (int i = 0; i < numLights; i++) {\n        if (floor(q) == lightPos[i]) {\n            return true;\n        }\n    }\n\n    vec2 p = floor(q)/10.;\n    vec2 c = vec2(cos(1.),sin(1.0));\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p*1.01;\n    p = vec2((p.y>0.3)?p.x:l*sign(-c.x),\n             (p.x>-0.7)?p.y:l );\n    p = vec2(p.x,abs(p.y-0.5))-vec2(0.250,0.25);\n    return length(max(p,0.01)) + min(0.0,max(p.x,p.y)) < 0.;\n}\n\nvoid updateMaxAngle(inout float maxAngle, vec2 rayStart, vec2 dir, vec2 currBlock, bool backward) {\n    vec2 v = normalize(currBlock - rayStart);\n    vec2 n = normalize(vec2(v.y, -v.x));\n    \n    if ((dot(dir, n) < 0.) == backward) {\n        return;\n    }\n    \n    maxAngle = max(acos(dot(dir, v)), maxAngle);\n}\n\nfloat raycast(inout vec3 col, vec2 worldPos, vec2 lightPos, vec2 rayStart, vec2 rayEnd, bool backward) {\n    vec2 currBlock = floor(rayStart);\n    vec2 dir = normalize(rayEnd - rayStart);\n    \n    vec2 mask = vec2(0.0);\n    \n    vec2 rayStep = sign(dir);\n    vec2 deltaDist = abs(1. / dir);\n    \n    vec2 sdoffs = (sign(dir) * .5 + .5) * deltaDist;\n    vec2 sideDist = (sign(dir) * (currBlock - rayStart)) * deltaDist + sdoffs;\n    float maxAngle = 0.0;\n    \n    for (int i = 0; i < steps; i++) {\n        if(floor(worldPos) == currBlock) {\n            col.r+=.5;\n        }\n        if (currBlock == lightPos) break;\n        \n        if (isOpaque(currBlock)) {\n            updateMaxAngle(maxAngle, rayStart, dir, currBlock + vec2(0., 0.), backward);\n            updateMaxAngle(maxAngle, rayStart, dir, currBlock + vec2(0., 1.), backward);\n            updateMaxAngle(maxAngle, rayStart, dir, currBlock + vec2(1., 0.), backward);\n            updateMaxAngle(maxAngle, rayStart, dir, currBlock + vec2(1., 1.), backward);\n        }\n        \n        mask = vec2(lessThanEqual(sideDist.xy, sideDist.yx));\n        sideDist += mask * deltaDist;\n        currBlock += mask * rayStep;\n    }\n    \n    if (1.0-20.0 * line(worldPos, rayStart, rayStart + dir * 100.) > 0.55) {\n        col.rg += 1.0;\n    }\n    \n    return maxAngle;\n}\n\nfloat doLineEdge(bool display, inout vec3 col, vec2 worldPos, vec2 lightPos, vec2 rayStart, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(ba.y, -ba.x));\n    vec2 v1 = normalize(rayStart - a);\n    vec2 v2 = normalize(rayStart - b);\n\n    if (dot(n, v1) < 0.) {\n        return 0.0;\n    }\n    \n    \n    float angle = acos(dot(v1, v2));\n    float finalAngle = 0.0;\n    \n    if (display) {\n        float aStart = raycast(col, worldPos, lightPos, rayStart, a, false);\n        float aEnd = angle - raycast(col, worldPos, lightPos, rayStart, b, true);\n        finalAngle = max(aEnd - aStart, 0.);\n    } else {\n        vec3 col = vec3(0., 0., 0.);\n        float aStart = raycast(col, worldPos, lightPos, rayStart, a, false);\n        float aEnd = angle - raycast(col, worldPos, lightPos, rayStart, b, true);\n        finalAngle = max(aEnd - aStart, 0.);\n    }\n    \n    float finalBrightness = finalAngle;\n    \n    return finalBrightness;\n}\n\nvec3 renderLight(vec2 lightPos, vec3 lightColor, vec2 worldPos) {\n    vec2 lP1 = lightPos + 0.001;\n    vec2 lP2 = lightPos + 0.999;\n\n    if (floor(worldPos) == lightPos) {\n        return lightColor * 1.4;\n    }\n    \n    float brightness = 0.0;\n    vec3 col = vec3(0.);\n    brightness += doLineEdge(false, col, worldPos, lightPos, worldPos, vec2(lP1.x, lP2.y), lP1);\n    brightness += doLineEdge(false, col, worldPos, lightPos, worldPos, lP1, vec2(lP2.x, lP1.y));\n    brightness += doLineEdge(false, col, worldPos, lightPos, worldPos, lP2, vec2(lP1.x, lP2.y));\n    brightness += doLineEdge(false, col, worldPos, lightPos, worldPos, vec2(lP2.x, lP1.y), lP2);\n    \n    brightness /= 3.1415;\n    \n    return lightColor * brightness;\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 worldPos = toWorldspace(fragCoord.xy);\n    \n    vec2 localPos = mod(worldPos, 1.);\n    // Grid\n    //col += 0.2 * max(max(abs(localPos.x-0.5),abs(localPos.y-0.5))*20.0-9.0, 0.);\n\n    vec2 mouseP = toWorldspace(iMouse.xy);\n    \n    // doLineEdge(true, col, worldPos, mouseP, vec2(lP2.x, lP1.y), lP2);\n\n#pragma optionNV(inline 0)\n    for (int i = 0; i < numLights; i++) {\n        col += renderLight(lightPos[i], lightColors[i], worldPos);\n    }\n    \n    \n    if (isOpaque(worldPos)) {\n        col += vec3(.2, .3, .5);\n    }\n   \n    col += texture(iChannel0, fragCoord / 8.).r / 255.;\n   \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}