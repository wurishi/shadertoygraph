{"ver":"0.1","info":{"id":"DtlSz4","date":"1674588271","viewed":285,"name":"Neon Mandelbulb","username":"Poisson","description":"A simple montecarlo pathtraced mandelbulb, with neon lights calculated with orbit trapping and depth of field.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","raymarching","fractal","raytracer","ray","mandelbulb","light","dof","bokeh","raymarcher","bloom","pathtracing","pathtracer","path","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ACES tonemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bloom function\nvec4 bloom(sampler2D sam, vec2 p) {    \n    vec4 col = vec4(0); // accumulated color\n    const int N = 8; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++)  {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n        if (dot(off, off)<1.) { // inside disk\n            // blurred texture\n            col += textureLod(iChannel0, p+.05*off, 4.);\n        }\n    }\n    // output\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    // base texture\n    vec4 data = texture(iChannel0, p);\n    vec3 col = data.rgb/data.w;\n    \n    // post processing\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    // bloom;\n    vec3 bloom = bloom(iChannel0, p).rgb;\n    col += bloom;\n    \n    col = clamp(col,0.,1.);\n    col = col*col*(3.-2.*col); // contrast\n    col = ACES(col); // tonemapping\n    \n    // vignette\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y),.1);\n                   \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float seed; // randoms seed\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// normalized 3d vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c; // discriminant\n    if(h<0.) return vec2(-1);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// mandelbulb sdf\n// thanks to iq: https://www.shadertoy.com/view/ltfSWn\n// trap is the orbit trapping\nfloat map(vec3 p, out vec4 trap) {    \n    p.y = -p.y;\n    vec3 w = p;\n    float m = dot(w,w);\n\n    trap = vec4(abs(w),m);\n\tfloat dz = 1.;\n    \n\tfor (int i=0; i<8; i++) {\n\t\tdz = 8.*pow(m,3.5)*dz + 1.;\n      \n        float r = length(w);\n        float b = 8.*acos(w.y/r);\n        float a = 8.*atan(w.x, w.z);\n        w = p + pow(r,8.) * vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n        \n        trap = min(trap, vec4(abs(w),m));\n        \n        m = dot(w,w);\n\t\tif(m>256.) break;\n    }\n\n    return .25*log(m)*sqrt(m)/dz;\n}\n\n// raymarching function\n// trap is the orbit trapping of the mandelbulb\nfloat intersect(vec3 ro, vec3 rd, out vec4 trap) {\n    // bounding volume\n    vec2 bound = sphIntersect(ro, rd, vec3(0), 1.2);\n    float tmin = max(bound.x,0.); // min distance\n    float tmax = bound.y; // max distance\n    \n    if (tmax<0.) return -1.;\n    float t = tmin; // distance travelled\n    \n    for (int i=0; i<256; i++) { // ramarching loop\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p, trap); // distance to the scene\n        if (h<.001) break; // we hit the surface\n        t += h;\n        if (t>tmax) return -1.;\n    }\n    // return the distance\n    return t;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    vec4 tmp;\n    float h = map(p, tmp);\n    vec2 e = vec2(h,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy, tmp),\n                              map(p-e.yxy, tmp),\n                              map(p-e.yyx, tmp)));\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {    \n    vec3 col = vec3(0); // accumulated color\n    \n    for (int i=0; i<8; i++) { // 8 GI bounces\n        vec4 trap; // orbit trapping\n        float t = intersect(ro, rd, trap); // distance\n        if (t<0.) break; // we don't hit the surface\n        \n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // normal of the surface\n        \n        // light color depending on the orbit trapping\n        vec3 emit = vec3(1,.3,.2);\n        emit = mix(emit, vec3(.1,.3,1), clamp(trap.y*1.5,0.,1.));\n        if (trap.y>.8) emit = vec3(1,.3,.2);\n        if (pow(trap.w,40.)>.4 || pow(trap.y,2.5)>.5) return emit;\n        \n        ro = p+n*.002; // new ray origin\n        rd = normalize(n+uniformVector()); // new ray direction, cheap diffuse BRDF\n    }\n    // output\n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime+dot(sin(fragCoord),vec2(453.712,983.234)); // init randoms seed\n    \n    vec2 off = hash2()-.5; // AA offset\n    // pixel coordinates centered to the origin\n    vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0,1.7,1); // ray origin\n    vec3 ta = vec3(0,.7,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    vec4 tmp;\n    // depth of field\n    // inspired by this shader: https://www.shadertoy.com/view/tl23Rm\n    float t = intersect(ro, ca[2], tmp); // distance in the direction of the camera\n    vec3 fp = ro + rd*t; // focus plane\n    ro += uniformVector()*.05;\n    rd = normalize(fp-ro);\n    \n    // render\n    vec3 col = render(ro, rd); \n\n    // blend the color with the previous frame color\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(col,1.0) + data;\n}","name":"Buffer A","description":"","type":"buffer"}]}