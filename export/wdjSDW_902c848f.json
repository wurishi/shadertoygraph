{"ver":"0.1","info":{"id":"wdjSDW","date":"1553865724","viewed":447,"name":"Evil Disturbed","username":"snakebyteme2","description":"Derivative work using mash-up of multiple shaders.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fire","hell","smoke","demon","soul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\t//-----------------CONSTANTS MACROS-----------------\n\n\t#define PI 3.14159265359\n\t#define E 2.7182818284\n\t#define GR 1.61803398875\n\n\t//-----------------UTILITY MACROS-----------------\n\n\t#define time ((sin(float(__LINE__))/PI/GR+1.0/GR)*iTime+1000.0)\n\t#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n\t#define clip(x) (smoothstep(0.25, .75, x))\n\t#define TIMES_DETAILED (1.0)\n\t#define angle(uv) (atan(uv.y, uv.x))\n\t#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n\t#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\n\t#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n\t//-----------------LOGO COLOR/POSITION/SIZE MACROS-----------------\n\n\t#define WHITE (vec4(vec3(255.0,255.0,255.0)/255.0, 1.0))\n\t#define BROWN (vec4(vec3(165.0,42.0,42.0)/255.0, 1.0))\n\t#define SKIN (vec4((sin(time+seedling)*.25+.5)*WHITE.rgb+(cos(time-seedling)*.25+.75)*BROWN.rgb, 1.0))\n\t#define CLOTHING (vec4((flux(time+seedling)+(sin(-time/GR/PI-seedling)*.25+.5))*(sin(-time/E/PI)*.125+.875), 1.0))\n\t#define RED (vec4(vec3(255.0,0.0,0.0)/255.0, 1.0))\n\t#define GREEN (vec4(vec3(0.0,255.0,0.0)/255.0, 1.0))\n\t#define BLUE (vec4(vec3(0.0,0.0,255.0)/255.0, 1.0))\n\t#define YELLOW (vec4(vec3(255.0,255.0,0.0)/255.0, 1.0))\n\n\t#define female_size (1.0/GR)\n\t#define female_target (vec2(-sqrt(2.0)/GR/2.0, sqrt(2.0)/GR-female_size/GR))\n\t#define male_size (1.0/GR)\n\t#define male_target (vec2(-female_target.x, female_target.y))\n\n\tfloat saw(float x)\n\t{\n\t\tx /= PI;\n\t\tfloat f = mod(floor(abs(x)), 2.0);\n\t\tfloat m = mod(abs(x), 1.0);\n\t\treturn f*(1.0-m)+(1.0-f)*m;\n\t}\n\tvec2 saw(vec2 x)\n\t{\n\t\treturn vec2(saw(x.x), saw(x.y));\n\t}\n\n\tvec3 saw(vec3 x)\n\t{\n\t\treturn vec3(saw(x.x), saw(x.y), saw(x.z));\n\t}\n\n\t//-----------------SEEDLINGS-----------------------\n\tfloat seedling = 0.0;\n\tvec2 offset = vec2(0.0);\n\tfloat last_height = 0.0;\n\tfloat scale = 1.0;\n\tfloat extraTurns = 0.0;\n\tfloat aspect = 1.0;\n\n\t//-----------------AUDIO ALGORITHM-----------------\n\n\tfloat lowAverage()\n\t{\n\t\tconst int iters = 32;\n\t\tfloat product = 1.0;\n\t\tfloat sum = 0.0;\n\t\t\n\t\tfloat smallest = 0.0;\n\t\t\n\t\tfor(int i = 0; i < iters; i++)\n\t\t{\n\t\t\tfloat sound = texture(iChannel1, vec2(float(i)/float(iters), 0.5)).r;\n\t\t\tsmallest = \n\t\t\t\n\t\t\tproduct *= sound;\n\t\t\tsum += sound;\n\t\t}\n\t\treturn max(sum/float(iters), pow(product, 1.0/float(iters)));\n\t}\n\n\t//-----------------SIMPLEX ALGORITHM-----------------\n\n\tvec3 random3(vec3 c) {\n\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\tvec3 r;\n\t\tr.z = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.x = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.y = fract(512.0*j);\n\t\treturn r-0.5;\n\t}\n\n\tfloat simplex3d(vec3 p) {\n\t\tconst float F3 =  0.3333333;\n\t\tconst float G3 =  0.1666667;\n\t\t\n\t\tvec3 s = floor(p + dot(p, vec3(F3)));\n\t\tvec3 x = p - s + dot(s, vec3(G3));\n\t\t\n\t\tvec3 e = step(vec3(0.0), x - x.yzx);\n\t\tvec3 i1 = e*(1.0 - e.zxy);\n\t\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\n\t\tvec3 x1 = x - i1 + G3;\n\t\tvec3 x2 = x - i2 + 2.0*G3;\n\t\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t\t\n\t\tvec4 w, d;\n\t\t\n\t\tw.x = dot(x, x);\n\t\tw.y = dot(x1, x1);\n\t\tw.z = dot(x2, x2);\n\t\tw.w = dot(x3, x3);\n\t\t\n\t\tw = max(0.6 - w, 0.0);\n\t\t\n\t\td.x = dot(random3(s), x);\n\t\td.y = dot(random3(s + i1), x1);\n\t\td.z = dot(random3(s + i2), x2);\n\t\td.w = dot(random3(s + 1.0), x3);\n\t\t\n\t\tw *= w;\n\t\tw *= w;\n\t\td *= w;\n\t\t\n\t\treturn dot(d, vec4(52.0));\n\t}\n\n\t//-----------------LOGO RENDERING CODE-----------------\n\n\tfloat getEyes(vec2 uv)\n\t{\n\t\tvec2 p = uv;\n\n\t\tp.y += 1.0/PI;\n\n\t\tp.x *= GR;\n\n\t\tvec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n\t\tvec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n\t\tp.y += cos(uv.x*8.0)/PI;\n\n\t\tfloat distA = length(p.xy-a.xy);\n\t\tfloat distB = length(p.xy-b.xy);\n\n\t\tfloat fade_lengthA = .20;\n\t\tfloat fade_lengthB = .20;\n\n\t\tfloat color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n\t\t\t\t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n\t\treturn color;\n\t}\n\n\tfloat getTeeth(vec2 uv)\n\t{\n\t\tvec2 p = uv;\n\t\tp.x *= PI;\n\t\tp.y *= PI*(cos(p.x/PI/PI));\n\t\tp.y += 1.5*cos(p.x)+1.0;\n\t\tp.y *= (sin(time*PI+seedling))+2.0;\n\n\t\tfloat r = p.x*p.x+p.y*p.y;\n\t\t\n\t\tfloat xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n\t\treturn clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n\t}\n\n\tvec4 demon(vec2 uv)\n\t{\n\t\tfloat eyes = getEyes(uv);\n\t\tfloat teeth = getTeeth(uv);\n\t\t\n\t\tvec3 col = clamp(eyes+flux(seedling)*eyes+teeth, 0.0, 1.0);\n\t\t\n\t\treturn vec4(col, clamp(length(col), 0.0, 1.0));\n\t}\n\n\n\t//-----------------ITERATED FUNCTION SYSTEM-----------------\n\n\tvec2 mobius(vec2 uv)\n\t{\n\t\tfloat r = length(uv);\n\t\tuv = normalize(uv)/log(r+1.0);\n\t\t\n\t\tfloat turns = 4.0*extraTurns;\n\t\tfloat theta = atan(uv.y, uv.x);\n\t\t\n\t\tuv = vec2((theta*turns), (turns/(length(uv))-time*PI));\n\t\t\n\t\tseedling += floor(uv.x/PI)+floor(uv.y/PI);\n\t\t\n\t\treturn vec2(saw(uv));\n\t}\n\n\tvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n\t{\n\t\tuv += offset;\n\t\t\n\t\tvec2 a = uv+vec2(0.0, \t\t0.0);\n\t\tvec2 b = uv+vec2(dxdy.x, \t0.0);\n\t\tvec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n\t\tvec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n\t\tvec2 ma = mobius(a);\n\t\tvec2 mb = mobius(b);\n\t\tvec2 mc = mobius(c);\n\t\tvec2 md = mobius(d);\n\t\t\n\t\tfloat da = length(mb-ma);\n\t\tfloat db = length(mc-mb);\n\t\tfloat dc = length(md-mc);\n\t\tfloat dd = length(ma-md);\n\t\t\n\t\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n\t\t\n\t\tmagnification = stretch;\n\t\t\n\t\treturn mobius(uv);\n\t}\n\t\t\n\tvec4 getEvil( in vec2 fragCoord )\n\t{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\tfloat scale = E;\n\t\tuv = uv*scale-scale/2.0;\n\t\t\n\t\tfloat aspect = iResolution.x/iResolution.y;\n\t\t\n\t\tuv.x *= aspect;\n\t\t\n\t\tvec2 uv0 = uv;\n\t\t\n\t\tconst int max_iterations = 4;\n\t\tint target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n\t\t\n\t\tfloat antispeckle = 1.0; \n\t\tfloat magnification = 1.0;\n\t  \n\t\tvec4 color = vec4(0.0);\n\t\tfloat border = 1.0;\n\t\t\n\t\tseedling = 0.0;\n\t\t\n\t\t\t\n\t\toffset = sin(vec2(time+seedling,\n\t\t\t\t\t\t  -time-seedling))*(.5/E);\n\t\t\n\t\tcolor += demon(uv);\n\t\tborder *= (1.0-color.a);//*antispeckle;\n\t\t\n\t\tfor(int i = 0; i < max_iterations; i++)\n\t\t{\n\t\t\tfloat iteration = float(i)/float(max_iterations);\n\t\t\t\n\t\t\tseedling = float(i);\n\t\t\textraTurns = float(i*i+1);\n\t\t\t\n\t\t\tuv = (iterate(uv0, .5/iResolution.xy, magnification)*2.0-1.0);\n\t\t\tuv = uv*(saw(time+seedling)+1.0);\n\t\t\t\n\t\t\tuv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, -1.0), sin(seedling+time)*PI).xy;\n\n\t\t\tcolor += demon(uv)*border*antispeckle;\n\t\t\t\n\t\t\tborder *= smoothstep(1.0-1.0/GR/E/PI, 1.0, 1.0-color.a);//*antispeckle;\n\t\t\t\n\t\t\tfloat weight = smoothstep(0.0, 0.25, magnification);\n\t\t\tantispeckle *= 1.0/magnification;\n\t\t}\n\t\t\n\t\t//fragColor = vec4(everything(uv*2.0-1.0, o).a);\n\t\t//fragColor = everything(uv*2.0-1.0, o);\n\t\t\n\t\treturn color;\n\t}\n\n\t#define STEPS 1./50.\n\t#define VOLUME_BIAS 0.01\n\t#define MIN_DIST 0.005\n\t#define STEP_DAMPING .9\n\t#define TAU PI*2.\n\n\t// raymarch toolbox\n\tfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\n\tmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\tfloat sdSphere (vec3 p, float r) { return length(p)-r; }\n\tfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\tfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\n\tfloat sdBox( vec3 p, vec3 b ) {\n\t  vec3 d = abs(p) - b;\n\t  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t}\n\tfloat amod (inout vec2 p, float count) {\n\t\tfloat an = TAU/count;\n\t\tfloat a = atan(p.y,p.x)+an/2.;\n\t\tfloat c = floor(a/an);\n\t\ta = mod(a,an)-an/2.;\n\t\tp.xy = vec2(cos(a),sin(a))*length(p);\n\t\treturn c;\n\t}\n\n\tfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\tfloat smin (float a, float b, float r) {\n\t\tfloat h = clamp(.5+.5*(b-a)/r, 0., 1.);\n\t\treturn mix(b,a,h)-r*h*(1.-h);\n\t}\n\n\t// geometry for spell\n\tfloat tubes (vec3 pos) {\n\t\t\n\t\t// cylinder made of 8 tube\n\t\tfloat cylinderRadius = .02; // change shape\n\t\tvec3 p = pos;\n\t\tp.xz *= rot(p.y*.5); // twist amount\n\t\tfloat c = amod(p.xz, 8.); // amount of tubes\n\t\tp.x -= 2.; // tube cylinder radius\n\t\tfloat tube = sdCylinder(p.xz, cylinderRadius);\n\t\t\n\t\t// another cylinder made of tubes 16\n\t\tp = pos;\n\t\tp.xz *= rot(-p.y*.5); // twist amount\n\t\tc = amod(p.xz, 16.); // amount of tubes\n\t\tp.x -= 2.; // tube cylinder radius\n\t\ttube = smin(tube, sdCylinder(p.xz, cylinderRadius), .15);\n\t\treturn tube;\n\t}\n\n\t// geometry for spell\n\tfloat disks (vec3 pos) {\n\t\tfloat radius = 1.5;\n\t\tfloat radiusInner = .57;\n\t\tfloat thin = .01;\n\t\tfloat repeatY = 2.;\n\t\tfloat cellY = floor(pos.y/repeatY);\n\t\tfloat a = atan(pos.z,pos.x)-iTime*.3+cellY*.1;\n\t\tvec3 p = pos;\n\t\tp.y += sin(a*6.)*.1;\n\t\tp.y = repeat(p.y, repeatY);\n\t\tfloat disk = max(-sdCylinder(p.xz, radiusInner), sdCylinder(p.xz, radius));\n\t\tdisk = max(abs(p.y)-thin,disk);\n\t\treturn disk;\n\t}\n\n\tvec3 anim1 (vec3 p) {\n\t\tfloat t = iTime*.5;\n\t\tp.xz *= rot(t);\n\t\tp.xy *= rot(t*.7);\n\t\tp.yz *= rot(t*.5);\n\t\treturn p;\n\t}\n\n\tvec3 anim2 (vec3 p) {\n\t\tfloat t = -iTime*.4;\n\t\tp.xz *= rot(t*.9);\n\t\tp.xy *= rot(t*.6);\n\t\tp.yz *= rot(t*.3);\n\t\treturn p;\n\t}\n\n\tfloat map (vec3 pos) {\n\t\tfloat scene = 1000.;\n\t\t\n\t\t// ground and ceiling\n\t\tfloat bump = texture(iChannel0, pos.xz*.1).r;\n\t\tfloat ground = 2. - bump*.1;\n\t\tscene = min(scene, pos.y+ground);\n\t\tscene = min(scene, -(pos.y-ground));\n\t\t\n\t\t// spell geometry 1\n\t\tvec3 p = pos;\n\t\tp.y += sin(atan(p.z,p.x)*10.)*3.; // change numbers to get new distortion\n\t\tp.xz *= rot(p.y*.2-iTime);\n\t\tp = anim1(p);\n\t\tp.x = length(p.xyz)-3.;\n\t\tscene = smin(scene, tubes(p), .5);\n\t\tscene = smin(scene, disks(p), .5);\n\t\t\n\t\t// spell geometry 2\n\t\tp = pos;\n\t\tp.y += sin(atan(p.z,p.x)*3.)*2.; // change numbers to get new distortion\n\t\tp = anim2(p);\n\t\tp.xz *= rot(p.y+iTime);\n\t\tp.x = length(p.xyz)-3.;\n\t\tscene = smin(scene, tubes(p), .3);\n\t\tscene = smin(scene, disks(p), .3);\n\t\t\n\t\treturn scene;\n\t}\n\n\tvoid camera (inout vec3 p) {\n\t\tp.xz *= rot((-PI*(0./iResolution.x-.5)));\n\t}\n\n\tvec4 getSoulMask( in vec2 uv )\n\t{\n\t\tuv = (uv.xy-.5*iResolution.xy)/iResolution.y;\n\t\tvec2 mouse = vec2(0.)/iResolution.xy;\n\t\tvec3 eye = vec3(0.,0.,-7.+mouse.y*3.);\n\t\tvec3 ray = normalize(vec3(uv,.7));\n\t\tcamera(eye);\n\t\tcamera(ray);\n\t\tvec3 pos = eye;\n\t\tfloat shade = 0.;\n\t\tfor (float i = 0.; i <= 1.; i += STEPS) {\n\t\t\tfloat dist = map(pos);\n\t\t\tif (dist < VOLUME_BIAS) {\n\t\t\t\tshade += STEPS;\n\t\t\t}\n\t\t\tif (shade >= 1.) break;\n\t\t\tdist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n\t\t\tdist = max(MIN_DIST, dist);\n\t\t\tpos += dist * ray;\n\t\t}\n\t\tvec4 color = vec4(1);\n\t\tcolor.rgb *= shade;\n\t\treturn color;\n\t}\n\t//-------------------------------------------------------------------\n\n\tvec3 mod289(vec3 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 mod289(vec4 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n\t}\n\n\tvec4 taylorInvSqrt(vec4 r)\n\t{\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\n\tfloat snoise(vec3 v)\n\t  { \n\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\n\t  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  //   x1 = x0 - i1  + 1.0 * C.xxx;\n\t  //   x2 = x0 - i2  + 2.0 * C.xxx;\n\t  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\t  i = mod289(i); \n\t  vec4 p = permute( permute( permute( \n\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3  ns = n_ * D.wyz - D.xzx;\n\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t  }\n\n\tfloat normnoise(float noise) {\n\t\treturn 0.5*(noise+1.0);\n\t}\n\n\tfloat clouds(vec2 uv) {\n\t\tuv += vec2(iTime*0.05, + iTime*0.01);\n\t\t\n\t\tvec2 off1 = vec2(50.0,33.0);\n\t\tvec2 off2 = vec2(0.0, 0.0);\n\t\tvec2 off3 = vec2(-300.0, 50.0);\n\t\tvec2 off4 = vec2(-100.0, 200.0);\n\t\tvec2 off5 = vec2(400.0, -200.0);\n\t\tvec2 off6 = vec2(100.0, -1000.0);\n\t\tfloat scale1 = 3.0;\n\t\tfloat scale2 = 6.0;\n\t\tfloat scale3 = 12.0;\n\t\tfloat scale4 = 24.0;\n\t\tfloat scale5 = 48.0;\n\t\tfloat scale6 = 96.0;\n\t\treturn normnoise(snoise(vec3((uv+off1)*scale1,iTime*0.5))*0.8 + \n\t\t\t\t\t\t snoise(vec3((uv+off2)*scale2,iTime*0.4))*0.4 +\n\t\t\t\t\t\t snoise(vec3((uv+off3)*scale3,iTime*0.1))*0.2 +\n\t\t\t\t\t\t snoise(vec3((uv+off4)*scale4,iTime*0.7))*0.1 +\n\t\t\t\t\t\t snoise(vec3((uv+off5)*scale5,iTime*0.2))*0.05 +\n\t\t\t\t\t\t snoise(vec3((uv+off6)*scale6,iTime*0.3))*0.025);\n\t}\n\n\n\tvec4 getSmoke( in vec2 fragCoord )\n\t{\n\t  \n\t\tvec2 uv =  fragCoord.xy/iResolution.x;\n\t\t   \n\t\tfloat cloud = clouds(uv);\n\t\t\n\t\treturn vec4(cloud,cloud,cloud,1.0);\n\n\t}\n\n\t//--------------------------------------------------------------------------\n\n\tvec4 dnoise(vec3 p);\n\n\tvec4 quat_rotation( float half_angr, vec3 unitVec );\n\n\tvec2 screen_uv;\n\tvec4 quat;\n\n\tfloat Checker2(vec2 uv)\n\t{\n\t\tfloat s = sin(uv.x)*cos(uv.y);\n\t\t//s = s*s*s*s*s;\n\t\treturn s;\n\t}\n\n\tvec4 FlowNoise(vec3 uvw, vec2 uv)\n\t{\n\t\tvec4 n = vec4(0.);\n\n\t\tfloat f = 1.;\n\t\tfloat a = 1.;\n\t\t\t\t\n\t\tfloat lac = 2.13;\n\t\t\n\t#if 0\t\n\t\tfor (int i=0; i<5; i++)\n\t\t{\t\n\t\t\t//offsetting swirl angle relative to position seems to flow along the gradient\n\t\t\tfloat ang = iTime*.4;//+uv.y*0.5;\n\t\t\t\n\t\t\tang *= Checker2(uvw.xy*0.0125);\n\t\t\t\n\t\t\tvec3 ax = normalize(vec3(1,1,1)); \n\t//\t\tvec3 ax = texture(u_tex1,vec2(float(i)*0.1,0.)).xyz*2.-1.;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\n\t\t\tfloat e = 0.1;//*f;\n\t\t\t\n\t\t\t//advect by going back in domain along noise gradient\n\t\t\tvec4 dn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\t\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t}\n\t#else\n\t\tvec3 ax = normalize(vec3(1,1,1)); \n\t\tfloat e = 0.1;//*f;\n\t\tfloat ang;\n\t\tvec4 dn;\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t\n\t#endif\n\t\t\n\t\treturn n;\n\t}\n\t\t\n\tvec3 hsv2rgb(vec3 c)\n\t{\n\t\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\t\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\t\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\t}\n\n\t//thanks iq..\n\t// Smooth HSV to RGB conversion \n\tvec3 hsv2rgb_smooth( in vec3 c )\n\t{\n\t\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\t\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\t\treturn c.z * mix( vec3(1.0), rgb, c.y);\n\t}\n\n\tvec3 hsv2rgb_trigonometric( in vec3 c )\n\t{\n\t\tvec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\t\treturn c.z * mix( vec3(1.0), rgb, c.y);\n\t}\n\n\tvec3 FlameColour(float f)\n\t{\n\t\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n\t}\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\tuv.x *= iResolution.x/iResolution.y;\t\n\t\tuv.y = 1. - uv.y;\n\t\tscreen_uv = uv;\n\t\t\n\t\tfloat t = iTime*0.8;\n\t\tvec3 uvw = vec3(uv*1.15+vec2(0.,t),t*0.5);\n\n\n\t\tvec4 d = FlowNoise(uvw,uv);\n\t\tfloat de = d.w;\n\t\tde = length(d.xyz)*.15+.2-d.w*.2;\n\t\tvec3 n = FlameColour(de);\n\n\t\tvec4 soulMask = vec4(1.0) - getSoulMask(fragCoord);\n\t\tvec4 smoke = getSmoke(fragCoord) * 0.25;\n        vec4 evil = getEvil(fragCoord) * 0.35;\n\t\tfragColor = vec4(soulMask.xyz,1.0);\n\t\tfragColor.xyz = vec3(n) * 1.6 - fragColor.xyz;\n        \n\t\tfragColor.x = max(evil.x,fragColor.x);\n\t\tfragColor.y = max(evil.y,fragColor.y);\n\t\tfragColor.z = max(evil.z,fragColor.z);\n        \n        fragColor.x = max(smoke.x,fragColor.x);\n\t\tfragColor.y = max(smoke.y,fragColor.y);\n\t\tfragColor.z = max(smoke.z,fragColor.z);\n\t\t\n\t}\n\n\tvec4 quat_rotation( float half_angr, vec3 unitVec )\n\t{\n\t\tfloat s, c;\n\t\ts = sin( half_angr );\n\t\tc = cos( half_angr );\n\t\treturn vec4( unitVec*s, c );\n\t}\n\n\tvec3 quat_times_vec(vec4 q, vec3 v)\n\t{\n\t\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\t\tvec3 t = 2. * cross(q.xyz, v);\n\t\treturn v + q.w * t + cross(q.xyz, t);\n\t}\n\n\t/* Created by Nikita Miropolskiy, nikat/2013\n\t * This work is licensed under a \n\t * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\t * http://creativecommons.org/licenses/by-nc-sa/3.0/\n\t *  - You must attribute the work in the source code \n\t *    (link to https://www.shadertoy.com/view/XsX3zB).\n\t *  - You may not use this work for commercial purposes.\n\t *  - You may distribute a derivative work only under the same license.\n\t */\n\n\t/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n\tvec3 random3a(vec3 c) \n\t{\n\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\tvec3 r;\n\t\tr.z = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.x = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.y = fract(512.0*j);\n\t\tr = r-0.5;\n\n\t\t\n\t\t//rotate for extra flow!\n\t\tr=quat_times_vec(quat,r);\n\t\t\n\t\treturn r;\n\t}\n\n\t/* skew constants for 3d simplex functions */\n\tconst float F3 =  0.3333333;\n\tconst float G3 =  0.1666667;\n\n\tvec4 dnoise(vec3 p) \n\t{\n\t\t /* 1. find current tetrahedron T and its four vertices */\n\t\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t\t \n\t\t vec3 s = floor(p + (p.x+p.y+p.z)*F3);\n\t\t vec3 x = p - s + (s.x+s.y+s.z)*G3;\n\t\t \n\t\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t\t vec3 i1 = e*(1.0 - e.zxy);\n\t\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\t\n\t\t vec3 x1 = x - i1 + G3;\n\t\t vec3 x2 = x - i2 + 2.0*G3;\n\t\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t\t\t\t \n\t\t /* calculate surflet weights */\n\t\t vec4 w;\n\t\t w.x = dot(x, x);\n\t\t w.y = dot(x1, x1);\n\t\t w.z = dot(x2, x2);\n\t\t w.w = dot(x3, x3);\n\t\t \n\t\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t\t w = max(0.6 - w, 0.0);\t\t//aka t0,t1,t2,t3\n\t\t vec4 w2 = w*w;\t\t\t\t//aka t20,t21,t22,t23\n\t\t vec4 w4 = w2*w2;\t\t\t//aka t40,t41,t42,t43\n\t\t \n\t\t /* 2. find four surflets and store them in d */\n\t\t vec3 g0 = random3a(s);\n\t\t vec3 g1 = random3a(s + i1);\n\t\t vec3 g2 = random3a(s + i2);\n\t\t vec3 g3 = random3a(s + 1.0);\n\t\t \n\t\t vec4 d;\n\t\t /* calculate surflet components */\n\t\t d.x = dot(g0, x);\t\t//aka graddotp3( gx0, gy0, gz0, x0, y0, z0 )\n\t\t d.y = dot(g1, x1);\n\t\t d.z = dot(g2, x2);\n\t\t d.w = dot(g3, x3);\n\t\t \n\t\t //derivatives as per\n\t\t //http://webstaff.itn.liu.se/~stegu/aqsis/flownoisedemo/srdnoise23.c\n\t\t vec4 w3 = w*w2;\n\t\t vec4 temp = w3*d;\n\t\t vec3 dnoise = temp[0]*x;\n\t\t\t dnoise += temp[1]*x1;\n\t\t\t dnoise += temp[2]*x2;\n\t\t\t dnoise += temp[3]*x3;\n\t\t\t dnoise *= -8.;\n\t\t\t dnoise += w4[0]*g0+w4[1]*g1+w4[2]*g2+w4[3]*g3;\n\t\t\t dnoise *= 52.; //???\n\t\t\t \n\t\t d *= w4;\t//aka n0,n1,n2,n3\n\t\t \n\t\tfloat n = (d.x+d.y+d.z+d.w)*52.;\n\t\t\n\t\treturn vec4(dnoise,n);\n\t}\t","name":"Image","description":"","type":"image"}]}