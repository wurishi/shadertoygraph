{"ver":"0.1","info":{"id":"4tlXzf","date":"1442484009","viewed":166,"name":"cravo-raytrace","username":"cravo","description":"Raytracing rather than raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nfloat orenNayarDiffuse2(vec3 lightDirection, vec3 viewDirection, vec3 normal, float roughness)\n{   \n    // calculate intermediary values\n    float NdotL = dot(normal, lightDirection);\n    float NdotV = dot(normal, viewDirection); \n\n    float angleVN = acos(NdotV);\n    float angleLN = acos(NdotL);\n    \n    float alpha = max(angleVN, angleLN);\n    float beta = min(angleVN, angleLN);\n    float gamma = dot(viewDirection - normal * dot(viewDirection, normal), lightDirection - normal * dot(lightDirection, normal));\n    \n    float roughnessSquared = roughness * roughness;\n    \n    // calculate A and B\n    float A = 1.0 - 0.5 * (roughnessSquared / (roughnessSquared + 0.57));\n\n    float B = 0.45 * (roughnessSquared / (roughnessSquared + 0.09));\n \n    float C = sin(alpha) * tan(beta);\n    \n    // put it all together\n    float L1 = max(0.0, NdotL) * (A + B * max(0.0, gamma) * C);\n    \n    return L1 / PI;\n}\n\nfloat raytraceSphere(vec3 ro, vec3 rd, vec3 p, float r)\n{\n    vec3 op = p - ro;\n    float eps = 1e-4;\n    float b = dot(op,rd);\n    float det = (b*b)- dot(op,op) + (r*r);\n    if ( det < 0.0 ) return 0.0;\n    det = sqrt(det);\n    float t = b - det;\n    if (t > eps)\n    {\n        return t;\n    }\n    else\n    {\n        t = b + det;\n        if ( t > eps )\n        {\n            return t;\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n}\n\nfloat getHit(vec3 ro, vec3 rd, out vec3 oPos, out vec3 oNor, out float obj)\n{\n    vec3 sphere1Pos = vec3(0,0.5,0);\n    float sphere1Rad = 0.5;\n    obj = 0.0;\n    \n    // raytrace first small sphere\n\tfloat t = raytraceSphere(ro, rd, sphere1Pos, sphere1Rad);   \n    if ( t > 0.0 )\n    {\n        oPos = ro + t * rd;\n        oNor = normalize(oPos - sphere1Pos);\n        obj = 1.0;\n    }\n\telse\n    {\n        // didn't hit the small sphere, raytrace a massive one\n        // which is pretending to be a flat plane for the ground\n        vec3 sphere2Pos = vec3(0.0,-50000.0,0);\n    \tfloat sphere2Rad = 50000.0;\n\t\tt = raytraceSphere(ro, rd, sphere2Pos, sphere2Rad);   \n        \n        if ( t > 0.0 )\n        {\n\t        oPos = ro + t * rd;\n    \t    oNor = normalize(oPos - sphere2Pos);\n            obj = 2.0;\n        }\n    }\n\n    return t;\n}\n\nfloat getShadow(vec3 ro, vec3 rd)\n{\n    vec3 unusedPos;\n    vec3 unusedNor;\n    float unusedObj;\n    \n    float sh = getHit(ro, rd, unusedPos, unusedNor, unusedObj);\n    if ( sh > 0.0 )\n    {\n        sh = 0.0;\n    }\n    else\n    {\n        sh = 1.0;\n    }\n    \n    return sh;\n}\n\nvec3 getSkyColour(vec3 rd)\n{   \n    vec3 col = texture(iChannel1, rd).xyz;\n    \n    return sqrt(col);\n}\n\nvec3 getF0(float obj)\n{\n    if ( obj == 2.0 )\n    {\n        // wood\n    \treturn vec3(0.042); // f0 for plastic        \n    }\n    else\n    {\n    \t//return vec3(0.549,0.556,0.554); // f0 for chrome\n    \t//return vec3(1.022,0.782,0.344); // f0 for gold\n    \treturn vec3(0.042); // f0 for plastic\n    }\n}\n\nvec3 getLightDirection()\n{\n   return normalize(vec3(3.0,8.0,6.0));\n}\n\nfloat getG1V(float nDotV, float k)\n{\n    return 1.0 / (nDotV * (1.0-k) + k);\n}\n\nfloat getG(float nDotL, float nDotV, float k)\n{\n    return getG1V(nDotL,k) * getG1V(nDotV, k);\n}\n\nfloat getRoughness(float obj)\n{\n    float rough = 1.0 - 0.46; // glossy plastic\n    if ( obj == 2.0 )\n    {\n        rough = 1.0 - 0.32; // wood\n    }\n    \n    return rough;\n}\n\n// D function is GGX\nfloat chiGGX(float v)\n{\n    return v > 0.0 ? 1.0 : 0.0;\n}\n\nfloat getD(vec3 n, vec3 h, float alpha)\n{\n    float NoH = dot(n,h);\n    float alpha2 = alpha * alpha;\n    float NoH2 = NoH * NoH;\n    float den = NoH2 * alpha2 + (1.0 - NoH2);\n    return (chiGGX(NoH) * alpha2) / ( PI * den * den );\n}\n\nvec3 saturate(vec3 v)\n{\n    return clamp(v,0.0,1.0);\n}\n\nfloat saturate(float v)\n{\n    return clamp(v,0.0,1.0);\n}\n\nvec3 getLitColour(vec3 ro, vec3 rd, out float t, out vec3 pos, out vec3 nor, out float obj)\n{\n    vec3 col = vec3(0,0,0);\n\tt = getHit(ro, rd, pos, nor, obj);\n    \n    if ( t > 0.0 )\n    {\n        vec3 diffuse = vec3(0.75);\n        \n        float roughness = getRoughness(obj);\n        \n        if ( obj == 2.0 )\n        {\n            diffuse = texture(iChannel0, vec2(pos.x * 0.5, pos.z * 0.5)).xyz;\n            roughness = 0.9;\n        }\n               \n\t\tfloat alpha = roughness * roughness;\n        \n        \n        vec3 light = getLightDirection();\n\t\tvec3 view = -rd;\n        vec3 h = normalize(light + view);\n        vec3 f0 = getF0(obj);\n        vec3 fresnel = f0 + (vec3(1.0) - f0) * pow((1.0 - clamp(dot(light,h),0.0,1.0)),5.0);\n        \n        float d = getD(nor, h, alpha);\n        \n        float k = alpha * 0.5;\n        float g = saturate(getG((dot(nor,light)), (dot(nor,view)), k));\n        \n        float sh = getShadow(pos + nor * 0.01, light);\n               \n        float diffuseRoughness = 0.4;\n        float lighting = orenNayarDiffuse2(light, view, nor, diffuseRoughness);\n\n        float div = ( 4.0 * (dot(nor,view) * (dot(h, nor)) + 0.05) );\n        vec3 brdf = saturate((fresnel * g * d) / div);\n              \n        vec3 sky = saturate(getSkyColour(nor));\n        \n        vec3 ambient = vec3(0.05) * sky;\n\n\t\tdiffuse *= vec3(1.0) - brdf;\n        \n        col = (ambient) + sh * ((diffuse * lighting) + (brdf));\n    }   \n    else\n    {\n        return texture(iChannel2, rd).xyz / PI;\n    }\n    \n    return col;\n}\n\n// filmic tone-mapping function\n// see https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float t;\n    vec3 pos;\n    vec3 nor;\n    float obj;\n\tvec3 col = getLitColour(ro, rd, t, pos, nor, obj);    \n \n    if ( t > 0.0 )\n    {\n        vec3 f0 = getF0(obj);\n        vec3 refFre = f0 + ((vec3(1.0)-f0) * pow(1.0 - clamp(dot(-rd,nor),0.0,1.0),5.0));             \n\n        vec3 ref = reflect(rd, nor);\n        vec3 refCol = getLitColour(pos + nor * 0.01, ref, t, pos, nor, obj);\n\n        col += refCol * refFre;\n    }\n  \n    col *= 0.8; // exposure\n    col = ACESFilm(col); // tone-mapping\n    col = pow (col, vec3(1.0/2.2,1.0/2.2,1.0/2.2)); // gamma\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3(2.5 * cos(iTime * 0.5), 0.8 + 0.6 * sin(iTime * 0.5), 2.5 * sin(iTime * 0.5));//vec3( 0.0, 0.4, 2.5 );\n\tvec3 ta = vec3( 0.0, 0.5, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\n    //col = sqrt(col);\n    \n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}