{"ver":"0.1","info":{"id":"3ttSR7","date":"1580653384","viewed":1091,"name":"bookofshaders ikeda on torus","username":"Bleuje","description":"Using this 2D example from bookofshaders : https://thebookofshaders.com/edit.php#10/ikeda-03.frag\nto put it on a torus.","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// Using Ikeda style pattern from bookofshaders : https://thebookofshaders.com/edit.php#10/ikeda-03.frag\n// Using torus raymarching from https://www.shadertoy.com/view/MsX3Wj\n\n// There is some antialiasing\nconst bool TURN_ON_ANTI_ALIASING = true; // put it to false for faster computation\n\nconst float PI = 3.14159265358979323846264;\nconst int MAX_PRIMARY_RAY_STEPS = 80; // decrease this number if it runs slow on your computer\n\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p.yxz, vec2(5.0, 1.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(25.+p*.000004)+random(p.x)*0.75 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    for(float di=-0.25;di<=0.25;di+=.5){\n        for(float dj=-0.25;dj<=0.25;dj+=.5){\n            vec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n            vec2 screenPos = ((fragCoord.xy + vec2(di,dj)) / iResolution.xy) * 2.0 - 1.0;\n            vec3 cameraPos = vec3(0.0, 4.2, -3.8);\n\n            vec3 cameraDir = vec3(0., 0.22, 1.3);\n            vec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n            vec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n            vec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\n            vec3 rayPos = castRay(cameraPos, rayDir);\n\n            float majorAngle = atan(rayPos.z, rayPos.y);\n            float minorAngle = atan(rayPos.x, length(rayPos.yz) - 5.0);\n\n            vec2 st = vec2(majorAngle/PI/2.0,minorAngle/PI);\n\n            vec2 grid = vec2(1000.0,50.);\n            st *= grid;\n\n            vec2 ipos = floor(st);  // integer\n            vec2 fpos = fract(st);  // fraction\n\n            vec2 vel = vec2(iTime*0.09*max(grid.x,grid.y)); // time\n            vel *= vec2(1.,0.0) *(0.4+2.0*pow(random(1.0+ipos.y),2.0)); // direction\n\n            // For colorful stuff\n            vec2 offset = 0.*vec2(0.2,0.25);\n\n            vec3 color = vec3(0.);\n            float replaceMouse = 0.75+0.45*sin(0.6*iTime + 0.015*st.x);\n            color.r = pattern(st+offset,vel,replaceMouse);\n            color.g = pattern(st,vel,replaceMouse);\n            color.b = pattern(st-offset,vel,replaceMouse);\n\n            // Margins\n            color *= step(0.2,fpos.y);\n\n            if(TURN_ON_ANTI_ALIASING){\n            \tfragColor += 0.25*vec4(color,1.0);\n            } else {\n                fragColor = vec4(color,1.0);\n                return;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}