{"ver":"0.1","info":{"id":"XcfSDn","date":"1705095123","viewed":73,"name":"20240112-test-raymarching","username":"pepitos","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS=80;\n\nfloat sdSphere(vec3 p,float s){\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p,vec3 size){\n  vec3 d=abs(p)-size;\n  return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),0.);\n}\n\nfloat sdTorus(vec3 p,float majorRadius,float minorRadius){\n  vec2 q=vec2(length(p.xz)-majorRadius,p.y);\n  return length(q)-minorRadius;\n}\n\nfloat opUnion(float d1,float d2){\n  return min(d1,d2);\n}\n\nfloat opSubtraction(float d1,float d2){\n  return max(-d1,d2);\n}\n\nfloat opIntersection(float d1,float d2){\n  return max(d1,d2);\n}\n\nfloat smin(float a,float b,float k){\n  float h=clamp(.5+.5*(b-a)/k,0.,1.);\n  return mix(b,a,h)-k*h*(1.-h);\n}\n\nmat2 rot2D(float a){\n  return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvec3 rot3D(vec3 p,vec3 axis,float angle){\n  // Rodrigues' rotation formula\n  return mix(dot(axis,p)*axis,p,cos(angle))+cross(axis,p)*sin(angle);\n}\n\n// Distance to the scene\nfloat map(vec3 p){\n  vec3 spherePos=vec3(tan(iTime)*3.,0,0);\n  float sphere=sdSphere(p-spherePos,2.);\n  \n  vec3 q=p;\n  q.xy*=rot2D(iTime*3.);\n  q.yz*=rot2D(-iTime);\n  \n  vec3 boxPos=vec3(-8,0,0);\n  float box=sdBox(q-boxPos,vec3(sin(iTime)*-2.));\n  \n  q.xy*=rot2D(iTime*1.);\n  vec3 torusPos=vec3(2.,0,0);\n  float torus=sdTorus(q-torusPos,2.5,.75);\n  \n  float ground=p.y+.2;\n  float shapes=smin(sphere,box,3.);\n  \n  return smin(smin(ground,shapes,.2),torus,1.4);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 uv=(fragCoord*2.-iResolution.xy)/iResolution.y;\n  vec2 m=(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n  \n  vec3 ro=vec3(0.,0.,-8.);// ray origin\n  vec3 rd=normalize(vec3(uv,1));// ray direction\n  vec3 color=vec3(0.);\n  \n  float t=0.;// total distance traveled\n  \n  ro.yz*=rot2D(-m.y);\n  rd.yz*=rot2D(-m.y*-3.);\n  ro.xz*=rot2D(-m.x);\n  rd.xy*=rot2D(m.x*-3.);\n  \n  int i=0;\n  for(i;i<MAX_STEPS;i++){\n    vec3 p=ro+rd*t;// current position along the ray\n    \n    p.xy*=rot2D(t*.15*m.x);\n    p.y+=sin(t*(m.y+1.)*.5)*.35;// wiggle ray\n    \n    float d=map(p);\n    t+=d;\n    \n    color=vec3(i)/float(MAX_STEPS);// color based on the number of steps taken\n    \n    if(d<.001||t>100.)break;\n  }\n  \n  color=vec3(t*.02,0.,t*.1);\n  \n  fragColor=vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}