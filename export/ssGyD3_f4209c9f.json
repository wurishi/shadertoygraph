{"ver":"0.1","info":{"id":"ssGyD3","date":"1658733939","viewed":153,"name":"Boat on a sea at night","username":"liberat0r","description":"Work in progress","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["waves","sea","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYMARCHER_DEPTH 800\n\nvec2 rmin(vec2 a, vec2 b) {\n    return a[0] < b[0] ? a : b;\n}\n\nvec2 rmax(vec2 a, vec2 b) {\n    return a[0] > b[0] ? a : b;\n}\n\nvec2 smin(vec2 a, vec2 b, float k) {\n    float c = max(0.0, k - abs(a[0] - b[0]));\n    \n    return a[0] < b[0] ? vec2(a[0] - (c*c / (k*4.0)), a[1]) : vec2(b[0] - (c*c / (k*4.0)), b[1]);\n}\n\nfloat sdSphere(vec3 pos, vec3 cen, float r) {\n    return length(pos - cen) - r;\n}\n\nfloat noise(vec3 pos, float time) {\n    return 1.0 - fract((pos.x+pos.y+pos.x+time) * 1337.0) / 100000.0;\n    //return 0.0;\n}\n\nfloat sdGnd(vec3 pos, float time) {\n    //float waves = 0.5 * sin(0.5 * pos.x + time) * sin(-0.1*pos.z + time) * sin(time);\n    //waves += 0.3 * sin(0.6 * pos.x + time) * sin(0.3*pos.z + time) * (1.0+sin(time));\n    //waves += 0.3 * sin(1.6 * pos.x + time) * sin(1.3*pos.z + time) * (1.0+sin(time));\n    \n    //waves += (0.0054 * sin(23.0*pos.z + 6.0*time)*sin(20.2*pos.x + 6.0*time)) * sin(time);\n    //waves += (0.0074 * sin(24.4*pos.z + 12.3*time)*sin(0.5 + 24.6*pos.x + 12.3*time)) * sin(time);\n    \n    //float waves = (0.2 * sin(pos.x + time) * sin(pos.z));\n    //waves += 0.1 * sin(0.5*time) * sin(2.0*(pos.x + time));\n    //waves += 0.2 * sin(1.0*time) * sin(1.0*(pos.x + time));\n    //waves += (0.3 * sin(pos.z + time) * sin(pos.x + pos.z +  time * 3.0));\n    //waves += (0.0094 * sin(4.0*pos.z + time)*sin(8.0*pos.x + time));\n    //waves += (0.004 * sin(16.0*pos.z + time)*sin(16.0*pos.x + time));\n    \n    float waves = 0.0;\n    \n    float a = 0.65 * cos(time / 10.0);\n    float a_f = 0.25;\n    float t_f = 0.9;\n    float x_mul = 1.36;\n    float t_mul = 1.4;\n    float x_a_mul = 0.58;\n\n    float dir_x = 1.0;\n    float dir_z = 1.0;\n    \n    for(int i=0;i<10;++i) {\n        dir_x = sin(float(i)*0.5) ;\n        dir_z = cos(float(i)*0.5)  ;\n        waves += a*sin(a_f*pos.x*dir_x + t_f * time) + a*sin(a_f*pos.z*dir_z + t_f * time);//+ 0.001*sin(noise(pos, time*float(i)));\n        \n        a_f *= x_mul;\n        t_f *= t_mul;\n        a *= x_a_mul;\n    }    \n    \n    //dir_x = sin(2.0);\n    //dir_z = cos(2.0);\n    //t_f=2.0;\n    //waves += 0.001*sin(10.0*pos.x*dir_x + t_f * time) + 0.002*sin(10.0*pos.z*dir_z + t_f * time); //+ a*noise(pos, time*float(i));\n\n    //dir_x = sin(4.0);\n    //dir_z = cos(4.0);\n    //waves += 0.002*sin(10.0*pos.x*dir_x + t_f * time) + 0.001*sin(10.0*pos.z*dir_z + t_f * time); //+ a*noise(pos, time*float(i));\n    \n    return  waves;\n}\n\nvec2 map(vec3 pos, float time, vec3 boatPosF, vec3 boatPosB) {\n    float z = -0.5*time;\n    vec2 res = vec2(20.0, 0.0);\n    \n    vec2 d = vec2(sdSphere(pos, boatPosF, 0.2), 2.0);\n    vec2 d2 = vec2(sdSphere(pos, boatPosB, 0.2), 2.0);\n    \n    vec2 d3 = vec2(sdSphere(pos, boatPosF + vec3(-0.3,0.3,0.0), 0.1), 3.0);\n    vec2 d4 = vec2(sdSphere(pos, boatPosF + vec3(0.3,0.3,0.0), 0.1), 4.0);\n    vec2 d5 = vec2(sdSphere(pos, boatPosB + vec3(0.0,0.3,0.0), 0.1), 5.0);\n    \n    //vec2 d6 = vec2(sdSphere(pos, boatPosF + vec3(5.3,0.9,20.0), 0.7), 3.0);\n    \n    vec2 gnd = vec2(sdGnd(pos, time) + pos.y + 0.1, 1.0);\n    \n    res = rmin(res, d);\n    res = smin(res, d2, 1.5);\n    res = rmin(res, d3);\n    res = rmin(res, d4);\n    res = rmin(res, d5);\n    //res = rmin(res, d6);\n    res = rmin(gnd, res);\n    \n    return res;\n}\n\nvec3 calcNormal(vec3 pos, float time, vec3 boatPosF, vec3 boatPosB) {\n    float eps = 0.01;\n    \n    return normalize(vec3(\n        map(vec3(pos.x - eps, pos.y, pos.z), time, boatPosF, boatPosB)[0] - map(vec3(pos.x + eps, pos.y, pos.z), time, boatPosF, boatPosB)[0],\n        map(vec3(pos.x, pos.y - eps, pos.z), time, boatPosF, boatPosB)[0] - map(vec3(pos.x, pos.y + eps, pos.z), time, boatPosF, boatPosB)[0],\n        map(vec3(pos.x, pos.y, pos.z - eps), time, boatPosF, boatPosB)[0] - map(vec3(pos.x, pos.y, pos.z + eps), time, boatPosF, boatPosB)[0]\n    ));\n\n    //vec3 n = vec3(0.0);\n    //for( int i=min(iFrame,0); i<4; i++ )\n    //{\n    //    vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n    //    n += e*map(pos+0.1*e,time, boatPosF, boatPosB).x;\n    //}\n    //return -normalize(n);\n}\n\nvec2 castRay(vec3 ro, vec3 rd, float time, vec3 boatPosF, vec3 boatPosB, int depth) {\n    vec2 d = vec2(0.1, 0.0);\n    \n    for(int i=0;i<depth;++i) {\n        vec2 h = map(ro + rd * d[0], time, boatPosF, boatPosB);\n        d[0] += h[0];\n        \n        if(h[0] > 20.0) {\n            return d;\n        }\n        \n        if(h[0] < 0.0001) {\n            d[1] = h[1];\n            return d;\n        }\n    }\n    \n    if(rd.y < 0.0) {\n        d[1] = 1.0;\n    }\n    \n    return d;\n\n}\n\nvec3 get_sky(vec3 ray, float time) {\n    vec2 mp = ray.xy - vec2(0.15,0.13);\n    vec2 mp2 = ray.xy - vec2(0.08,0.13);\n    vec3 mc = vec3(0.0);\n    if(length(mp) < 0.07 && length(mp2) > 0.07 && ray.z > 0.0) {\n        mc = vec3(0.6) * smoothstep(0.06,0.05, length(mp)) * smoothstep(0.07,0.08, length(mp2));\n        //mc = vec3(2.5, 2.2, 1.2) * smoothstep(0.06,0.05, length(mp)) * smoothstep(0.07,0.08, length(mp2));\n        \n    }\n    \n    if(length(mp) < 0.20 && ray.z > 0.0) {\n        mc += vec3(0.5) * smoothstep(0.20,0.00, length(mp));\n        //mc += vec3(2.5, 2.2, 1.2)*0.6 * smoothstep(0.20,0.00, length(mp));\n    }        \n    \n    vec3 sky = vec3(0.1, 0.25, 0.4) - 0.7 * ray.y;\n    sky = mix(sky, vec3(0.3,0.35,0.4), exp(-10.0*ray.y));\n    sky = mix(sky, mc, 0.5) * 2.0;\n    return sky;\n}\n\nvec3 getMaterialColor(float m, vec3 pos) {\n    vec3 mate = vec3(0.0);\n    if(m < 1.5) {\n        mate = vec3(0.00,0.04,0.07);\n    } else if(m < 2.5) {\n        mate = vec3(0.9,0.9,0.9);\n    } else if(m < 3.5) {\n        mate = vec3(0.0,1.0,0.0);\n    } else if(m < 4.5) {\n        mate = vec3(1.0,0.0,0.0);\n    } else if(m < 5.5) {\n        mate = vec3(1.0,1.0,0.7);\n    }\n    return mate;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float time = iTime;\n\n    //float an = iTime;\n    float an = 10.0*iMouse.x / iResolution.x + 3.4;\n\n    vec3 ta = vec3(-2.0,1.95,time*0.5-3.0);\n    vec3 ro = ta + vec3(1.5*sin(an),0.4,1.5*cos(an));\n    \n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.8*ww);\n\n\n    vec2 boatPos = vec2(1.0, time*0.5 );\n    vec3 boatPosF = vec3(0.0,-sdGnd(vec3(0.0, boatPos.x, boatPos.y), time-0.2),boatPos.y);\n    vec3 boatPosB = vec3(0.0,-sdGnd(vec3(0.0, boatPos.x, boatPos.y-0.9), time-0.2),boatPos.y-0.9);\n\n\n\n    vec3 col = vec3(0.01,0.55,0.8);\n    vec3 mate = vec3(0.0);\n    vec3 sd = normalize(vec3(0.50,0.2,3.5));\n    \n    vec2 t = castRay(ro, rd, time, boatPosF, boatPosB, RAYMARCHER_DEPTH);    \n    \n    \n    vec3 ls1 = boatPosF + vec3(-0.36,0.39,0.05);\n    vec3 ls2 = boatPosF + vec3(0.36,0.39,0.05);\n    vec3 ls3 = boatPosB + vec3(0.0,0.39,-0.05);\n    \n    \n    vec3 pos = ro + rd * t[0];\n    \n    if(t[1] > 0.5) {        \n        mate = getMaterialColor(t[1], pos);\n    \n        vec3 nor = calcNormal(pos, time, boatPosF, boatPosB);\n    \n        float s_dif = clamp(dot(-sd, nor), 0.0, 1.0);\n        float c_dif = clamp(dot(vec3(0.0,-1.0,0.0), nor), 0.0, 1.0);\n        \n        float m_spe = clamp(dot(normalize(pos+rd),sd)*dot(-normalize( sd-rd ),nor),0.0,1.0);\n        \n        float s_sha = clamp(castRay(pos, sd, time, boatPosF, boatPosB, 50)[0], 0.0, 1.0);\n        \n        float ls1_d = castRay(pos, normalize(ls1 - pos), time, boatPosF, boatPosB, 50)[0];\n        float ls1_dif = (ls1_d >= length(pos - ls1) && length(pos - ls1) > 0.0 ? 1.0 : 0.0) * exp(-1.6*length(pos - ls1))*clamp(dot(pos - ls1, nor),0.0,1.0)*4.0;\n        \n        float ls2_d = castRay(pos, normalize(ls2 - pos), time, boatPosF, boatPosB, 50)[0];\n        float ls2_dif = (ls2_d >= length(pos - ls2) && length(pos - ls2) > 0.0 ? 1.0 : 0.0) * exp(-1.6*length(pos - ls2))*clamp(dot(pos - ls2, nor),0.0,1.0)*4.0;\n        \n        float ls3_d = castRay(pos, normalize(ls3 - pos), time, boatPosF, boatPosB, 50)[0];\n        float ls3_dif = (ls3_d >= length(pos - ls3) && length(pos - ls3) > 0.0 ? 1.0 : 0.0) * exp(-1.6*length(pos - ls3))*clamp(dot(pos - ls3, nor),0.0,1.0)*4.0;       \n        \n        col = vec3(0.0);\n        col += mate*vec3(2.0, 2.0, 2.0)*s_dif*s_sha*1.0;\n        col += vec3(0.1, 0.25, 0.4)*c_dif*0.4;\n        col += vec3(0.6)*m_spe*0.4;\n        \n        col += vec3(0.0, 0.95, 0.1)*ls1_dif;\n        col += vec3(0.95, 0.0, 0.1)*ls2_dif;\n        col += vec3(0.95, 0.9, 0.7)*ls3_dif;\n        \n        vec3 r = reflect(rd, nor);\n        vec2 t2 = castRay(pos, r, time, boatPosF, boatPosB, 100);\n        \n        if(t2[1]> 0.5 ) {\n            vec3 mate2 = getMaterialColor(t2[1], pos);\n            if(t2[1] > 2.5) {\n                col += mix(col, mate2, 0.7);\n            } else {\n                col+= mix(col, mate2, 0.05);\n            }\n        } else if(r.y > 0.0) {\n            col += get_sky(r, time)*0.3;\n        }\n\n        col = mix( col, vec3(0.3,0.35,0.4), 1.0-exp( -0.0000001*t[0]*t[0]*t[0] ) );\n        \n    \n    } else {\n        col = get_sky(rd, time);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}