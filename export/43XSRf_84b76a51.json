{"ver":"0.1","info":{"id":"43XSRf","date":"1709884590","viewed":85,"name":"Discrete wave function","username":"TotallyReal","description":"simulation of a wave function","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["wavefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = texelFetch(iChannel0,ivec2(fragCoord),0).x;\n\tfragColor = vec4(t*t, t, sqrt(t), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float dt = 1.0;\nconst float freq = 1.0;\nconst float edge = 0.0;\n#define PI 3.1415926535898\n\nvec4 getLaplacian(sampler2D g, ivec2 p){\n    vec4 middle    = texelFetch(g,p,0);   \t\n    vec4 up        = texelFetch(g,p+ivec2( 0, 1),0);\n    vec4 down      = texelFetch(g,p+ivec2( 0,-1),0);\n    vec4 right     = texelFetch(g,p+ivec2( 1, 0),0);\n    vec4 left      = texelFetch(g,p+ivec2(-1, 0),0);\n    vec4 upright   = texelFetch(g,p+ivec2( 1, 1),0);\t\n    vec4 upleft    = texelFetch(g,p+ivec2(-1, 1),0);\n    vec4 downright = texelFetch(g,p+ivec2( 1,-1),0);\n    vec4 downleft  = texelFetch(g,p+ivec2(-1,-1),0);\n    \n    float addLeft  = step(edge + 1.1, float(p.x));\n    float addRight = step(float(p.x), iResolution.x-(edge+1.1));\n    float addDown  = step(1.1, float(p.y));\n    float addUp    = step(float(p.y), iResolution.y-1.1);\n    \n    vec4 sum = up*addUp + down*addDown + left*addLeft + right*addRight +\n               upleft*addUp*addLeft + upright*addUp*addRight + \n               downleft*addDown*addLeft + downright*addDown*addRight;\n    float count = addUp + addDown + addLeft + addRight + \n                  (addUp+addDown)*(addLeft + addRight);\n    \n    return sum/count - middle;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){      \n\n    if (distance(fragCoord.xy, iResolution.xy/2.)<10.){\n        fragColor = vec4((1.+cos(iTime*freq*2.*PI))/2., sin(iTime*freq*2.*PI)/2., 0., 0.);\n    } else {\n\n        // use x coord for position and y coordinate for speed    \n        vec4 T = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        float force = getLaplacian(iChannel0, ivec2(fragCoord)).x;\n        float speed = T.y + force*dt;\n        float position = clamp(T.x + speed*dt, 0., 1.);\n\n        fragColor = vec4(position, speed, 0., 0.)*step(10., distance(iMouse.xy, fragCoord));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}