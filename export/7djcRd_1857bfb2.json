{"ver":"0.1","info":{"id":"7djcRd","date":"1643974366","viewed":212,"name":"3D Field View - Shapes Merging","username":"stuwatt193","description":"Creating a 3D shape with a plane showing the SDF\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdfs"],"hasliked":0,"parentid":"NdjcW1","parentname":"3D Field Viewer TPMS"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 setCamera(in vec3 ro, in vec3 ta, in float cr)\n{\n    //ro = ray origin / camera position\n    //ta = target\n    //cr = camera roll\n    \n    vec3 cw = normalize(ro-ta); //unit vector between camera and target (Camera Z Axis)\n    vec3 cp = vec3(sin(cr), cos(cr),0.0); //Create vector defining camera rotation, this will always be in the X,Y plane and enables the v axis of the camera to be defined\n\tvec3 cu = normalize( cross(cw,cp) ); // Camera U axis unit vector\n\tvec3 cv = normalize( cross(cu,cw) ); // Resolve camera V axis unit vector\n    return mat3( cu, cv, -cw );\n}\n\nfloat dist(in vec3 pos)\n{\n    float d;\n    \n    float speed = 2.0;\n    float extreme = 10.0;\n    \n\n    float xSphere = map(sin(iTime/speed),vec2(-1.0,1.0),vec2(0,-extreme));\n    float sphere1 = sdfSphere(pos, vec3(xSphere,0.0,0.0), 7.0);\n    \n    float xBox = map(sin(iTime/speed),vec2(-1.0,1.0),vec2(0,extreme));\n    pos = translate(pos, vec3(xBox,0.0,0.0));\n    \n    float box1 = sdfBox(pos, vec3(6.0,6.0,6.0));\n        \n    d = sdfUnionRounded(box1, sphere1, 2.0);\n    //d = sphere1;\n    //d = box1;\n    return d;\n}\n\nfloat distPlane(in vec3 pos)\n{\n    vec3 box = vec3(40.0,0.001,40.0);\n    float d = sdfBox(pos, box);\n    return d;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 del = vec2(0.0001,0);\n    float dx = dist(pos+del.xyy) - dist(pos-del.xyy);\n    float dy = dist(pos+del.yxy) - dist(pos-del.yxy);\n    float dz = dist(pos+del.yyx) - dist(pos-del.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 dist2Color(in float d)\n{\n    float h = 0.5;\n    float s = 0.5;\n    float l = 0.5;\n           \n    float dt = d;\n    float dr = 1.0;\n    dt = dt/dr - mod(dt,dr);\n            \n    if(dt>=0.0)\n    {\n        h= map(dt,vec2(0.0,10.0),vec2(0.0,0.2));\n    }\n    else\n    {\n        h= map(dt,vec2(0.0,-5.0),vec2(0.5,0.7));\n    }\n                         \n    if(0.97<mod(d,1.0)||mod(d,1.0)<0.03){s=0.0;l=0.3;}\n    if(abs(d)<0.04){l=0.0;}\n    return hsl2rgb(vec3(h,s,l));\n}\n\nvec3 shapeCol(in vec3 pos)\n{\n    vec3 ld = vec3(1.0,-0.5,0.0);  //light direction\n    vec3 col = vec3(0.5,1.0,1.0);\n    float shade = 0.0+ 0.8* vectorAngle(calcNormal(pos),ld)/pi;\n    col *= shade;\n    return col;\n}\n\nvec3 render(in vec3 pos, in vec3 rd, in int qInd)\n{\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    int maxSteps = 200;\n    float tol = 0.001;\n    \n    for( int i=0; i<maxSteps; i++ ) \n    {\n        float d = dist(pos);\n        float dp = distPlane(pos);\n        \n        //pos+= rd*abs(d);\n        //pos+= rd*abs(dp);\n        \n        if(qInd == 3){\n            pos+= rd*d;\n            \n            if(abs(d)<tol)\n            {     \n                col = shapeCol(pos);\n                break;\n            }\n        }else if(qInd == 2){\n            pos+= rd*min(d,dp);\n            if(dp<tol)\n            {\n                col = dist2Color(d);\n                break;\n            }\n\n            if(abs(d)<tol)\n            {     \n                col = shapeCol(pos);\n                break;\n            } \n        }else if(qInd == 1){\n            pos+= rd*d;\n            \n            if(abs(d)<tol)\n            {     \n                col = shapeCol(pos);\n                break;\n            }\n        }else if(qInd == 0){\n            pos+= rd*dp;\n                        \n            if(dp<tol)\n            {\n                col = dist2Color(d);\n                break;\n            }            \n        }  \n    }  \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 col;\n    vec3 colB = vec3(1.0);\n\n    //get normalised pixelCoordinate\n    vec2 pRangeNorm = iResolution.xy/min(iResolution.x, iResolution.y);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y);\n  \n    if(abs(p.x)<0.01){colB = vec3(0.0);}\n    if(abs(p.y)<0.01){colB = vec3(0.0);}\n  \n    // Create quadrants\n    float theta = pi+atan(p.y,p.x);\n    int qInd = int((theta - mod(theta,pi/2.0))/(pi/2.0));\n       \n    p.x = mod(p.x,pRangeNorm.x)-pRangeNorm.x/2.0;\n    p.y = mod(p.y,pRangeNorm.y)-pRangeNorm.y/2.0;\n        \n    // Set up Camera    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ro;    \n    float lSpin = iTime/2.0;\n    \n    if(qInd == 1){\n        ro = ta + 50.0*vec3(cos(lSpin),1.0,sin(lSpin));\n    }else{\n        ro = ta + 50.0*vec3(0.0,1.0,1.0);\n    }    \n    \n    float fl = 2.5; //Focal length\n    float cr = 0.0;\n    mat3 ca = setCamera( ro, ta, cr ); \n    \n    //Get ray direction for pixel\n    vec3 rd = ca*normalize(vec3(p,fl)); \n    \n    \n    \n    //Render\n    col = render(ro,rd,qInd);\n    col *= colB; \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://iquilezles.org/articles/distfunctions\n//https://mercury.sexy/hg_sdf/\nconst float pi = 3.141592;\nconst float tau = 6.283185;\n\n// Maths\nfloat vectorAngle(in vec3 a, in vec3 b)\n{\n    float ang = acos(dot(a,b)/(length(a)*length(b)));\n    return ang;\n}\n\nvec3 rotate( in vec3 pos, in vec3 rA, in float angDeg)\n{\n    float angRad = radians(angDeg);\n    float C = cos(angRad);\n    float S = sin(angRad);\n    float t = 1.0 - C;\n\n    mat3x3 rotMat = mat3(t*rA.x*rA.x+C, t*rA.x*rA.y - S*rA.z, t*rA.x*rA.z + S*rA.y,t*rA.x*rA.y - S*rA.z, t*rA.y*rA.y+C,  t*rA.y*rA.z - S*rA.x, t*rA.x*rA.z + S*rA.y,  t*rA.y*rA.z - S*rA.x, t*rA.z*rA.z+C);\n    \n    vec3 newPos = rotMat*pos;\n    return newPos;\n}\n\nvec3 translate(in vec3 pos, in vec3 t)\n{\n    return pos - t;\n}\n\nfloat vectorLength(in vec3 v)\n{\n    return sqrt(v.x*v.x+v.y*v.y+v.z*v.z);\n}\n\nfloat map(in float d, in vec2 inMap, in vec2 outMap)\n{\n    float inRange = inMap.y-inMap.x;\n    float inPerc = (d-inMap.x)/inRange;\n    \n    float outRange = outMap.y-outMap.x;\n    float outVal = outMap.x + inPerc*outRange;\n    return outVal;\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// SDFs\nfloat sdfUnion(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat sdfUnionRounded(float d1, float d2, float r){\n\tvec2 u = max(vec2(r - d1,r - d2), vec2(0.0));\n\treturn max(r, min (d1, d2)) - length(u);\n}\n\n\nfloat sdfSubtract(in float d1, in float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat sdfIntersect(in float d1, in float d2)\n{\n    return max(d1, d2);\n}\n\nfloat sdfSphere(in vec3 p, in vec3 c, in float r)\n{\n    return  distance(p,c) - r;\n}\n\nfloat sdfBox(in vec3 p,in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdfHexPrism( vec3 p, vec2 h )\n{\n    p = rotate(p, vec3(1.0,0.0,0.0), 90.0);\n\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdfOffset(in float d, in float offset)\n{\n    return d - offset;\n}\n\nfloat sdfThicken(in float d, in float thickness)\n{\n    return abs(d) - thickness/2.0;\n}\n\nfloat sdfGyroid(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = sin(x)*cos(y) + sin(y)*cos(z) + sin(z)*cos(x);\n    return d*size;\n}\n\nfloat sdfDiamond(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = sin(x)*sin(y)*sin(z)+sin(x)*cos(y)*cos(z)+cos(x)*sin(y)*cos(z)+cos(x)*cos(y)*sin(z);\n    return d*size;\n}\n\nfloat sdfSchwartz(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = cos(x)+cos(y)+cos(z);\n    return d*size;\n}\n\nfloat sdfLidinoid(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = sin(2.0*x)*cos(y)*sin(z) + sin(2.0*y)*cos(z)*sin(x) + sin(2.0*z)*cos(x)*sin(y) - cos(2.0*x)*cos(2.0*y) - cos(2.0*y)*cos(2.0*z) - cos(2.0*z)*cos(2.0*x) + 0.3;\n    return d*size;\n}\n\nfloat sdfSplitP(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = 1.1*(sin(2.0*x)*sin(z)*cos(y)+sin(2.0*y)*sin(x)*cos(z)+sin(2.0*z)*sin(y)*cos(x))-0.2*(cos(2.0*x)*cos(2.0*y)+cos(2.0*y)*cos(2.0*z)+cos(2.0*z)*cos(2.0*x))-0.4*(cos(2.0*x) + cos(2.0*y) +cos(2.0*z));\n    return d*size;\n}\n\nfloat sdfNeovius(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = 3.0*(cos(x)+cos(y)+cos(z))+4.0*cos(x)*cos(y)*cos(z);\n    return d*size;\n}\n\nfloat sdfS(in vec3 pos, in float size)\n{\n    float x = pos.x/size;\n    float y = pos.y/size;\n    float z = pos.z/size;\n    float d = cos(2.0*x)*sin(y)*cos(z)+cos(2.0*y)*sin(z)*cos(x)+cos(2.0*z)*sin(x)*cos(y)-0.4;\n    return d*size;\n}","name":"Common","description":"","type":"common"}]}