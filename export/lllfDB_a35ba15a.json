{"ver":"0.1","info":{"id":"lllfDB","date":"1513217495","viewed":161,"name":"Cube Tunnel Tron","username":"balkhan","description":"really ugly code, too lazy to despaghettify it.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n** Created by bal-khan\n*/\n\n// hlsl lazy translation\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat   t;\n\n#define I_MAX       100\n#define E           0.01\n\nfloat4  march(float3 pos, float3 dir);\nfloat3  camera(float2 uv);\nfloat3  calcNormal(in float3 pos, float e, float3 dir);\nfloat3  color_func(float3 pos, float3 dir);\nvoid    rotate(inout float2 v, float angle);\n\nfloat   neo, h, accum, trinity, rabbit;\nfloat   col_id;\n\nfloat4  render(float3 dir, float3 pos)\n{\n    col_id = 0.;\n    neo = 0.;h = 0.;accum = 0.;trinity = 0.;rabbit = 0.;\n    t = iTime;\n\n    float3  col = float3(0., 0., 0.);\n\trotate(dir.zx, .001251+t*.1);\n    float4  inter = (march(pos-float3(0.,0.,t*.5), dir));\n\n    float3  base = float3(.8, .0, 1.);\n    float4  c_out =  float4(col,1.0)*1.;\n    c_out.xyz += neo * float3(.7, .6, .3);\n    if (col_id == 2.)\n    {\n        c_out.xyz += (1.-inter.w*.051)*float3(.3,.4,.7);\n    }\n    if (col_id == 1.)\n    {\n        c_out.xyz += (1.-inter.w*.051)*float3(.38,.75,.5);\n        c_out.xyz += rabbit*.00001*float3(1., .4, .5);\n    }\n    c_out.xyz += (inter.x*.0051)*float3(.5,.3,.25)*h;\n\tc_out.xyz += .0051*trinity*float3(.2, .150, .950);\n    c_out.xyz *= accum;\n\tc_out.w = 1.;\n    return  c_out;\n}\n\nvoid mainImage(out float4 fragColor, in float2 uv)\n{\n    vec2\tu = (uv.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec3\tpos = vec3(.0,.0,.0);\n    vec3\tdir = camera(u*1.);\n    fragColor = render(dir, pos);\n}\n\nvoid rotate(inout float2 v, float angle)\n{\n    v = float2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat udBox( float3 p, float3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat   mylength(float p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p;\n    ret = pow(ret, 1./3.);\n    return (ret);\n}\n\nfloat   mylength(float2 p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n\n\nfloat   mylength(float3 p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y+p.z;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n\nfloat sdCappedCylinder( float3 p, float2 h )\n{\n  float2 d = abs(float2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat2  rot(float2 p, float2 ang)\n{\n    float   c = cos(ang.x);\n    float   s = sin(ang.y);\n    mat2    m = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nfloat   plane_de(float3 p)\n{\n    float   ret = dot(p, float3(1.0, 1.0, -1.) ) + 1. ;\n    return ret;\n}\n\nfloat sdTorus( float3 p, float2 t )\n{\n    float2 q = float2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat   scene(float3 p)\n{\n    float   minf = 1e5;\n    float   mind = 1e5;\n    float   ming = 1e5;\n    float   minr = 1e5;\n    float   mins = 1e5;\n    float   minc = 1e5;\n    float3  id = float3(0.);\n    minr = length(p.xy)-1.;\n    mins = length(p-float3(.0,.0,0.-t*20.));\n    minr = max(minr, -(length(p.xy)-.99) );\n    float   outer = length(p.xy)-.25;\n    float   s = p.z;\n    id.z  = floor(p.z*3.);\n    p.z = fract(p.z*3.)-.5;\n    p.xy -= float2(cos(id.z*0.+mod(s*1000., 10000.)/(.1+mins*mins)+iTime*1.),sin(id.z*0.+mod(s*1000., 10000.)/(.1+mins*mins)+iTime*1.))*.02512;\n    id.xy = floor(p.xy * 10.);\n    p.xy  = fract(p.xy*(7.5+mod(id.z, 2.5) ))-.5;\n\n\tminf = max(abs(p.x), max(abs(p.y), abs(p.z)))-.0125-.17*abs(sin(s*.125+.0*id.z));\n\tminc = min(minc, (length(fract(p.xy*(3.+ 7.*mod(-id.z*10., 70.)/70. ) )-.5)-.2501) );\n\tminc = min(minc, (length(fract(p.yz*(3.+ 7.*mod(+id.x*10., 70.)/70. ) )-.5)-.2501) );\n\tminc = min(minc, (length(fract(p.zx*(3.+ 7.*mod(+id.y*10., 70.)/70. ) )-.5)-.2501) );\n\ttrinity = .51/(.0+minc*minc);\n\tminc = max(minc, - minf);\n\trabbit += .0051/(.0000001+minc*minc);\n\tming = max(minf, -outer);\n\tneo += .02/(2.1+ming*ming);\n\th += 5.1/(mins*mins);\n    mind = min(minr, ming);\n    mind = min(mind, mins);\n    col_id = (mind == minf) ? 2. : col_id;\n    col_id = (mind == minr) ? 1. : col_id;\n    col_id = (mind == mins) ? 0. : col_id;\n    return mind;\n}\n\nfloat4  march(float3 pos, float3 dir)\n{\n    float2  dist = float2(0.0, 0.0);\n    float3  p = float3(0.0, 0.0, 0.0);\n    float4  step = float4(0.0, 0.0, 0.0, 0.0);\n    float3  dirr;\n    float   dynamiceps = E;\n    for (int i = 1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n        rotate(dirr.xy, (.001*floor(t*2.1-dist.y*300.))) ;\n        p = pos + dirr * dist.y;\n        dynamiceps = -dist.x+(dist.y)/(50.);\n        dist.x = scene(p);\n        dist.y += dist.x*.2;\n        accum += .01;\n        // log trick by aiekick \n        if (log((dist.y*dist.y/dist.x)/1e5)>0. || (dist.x) < dynamiceps)\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat3 calcNormal( in float3 pos, float e, float3 dir)\n{\n    e /= 100.;\n    float3 eps = float3(e,0.0,0.0);\n\n    return normalize(float3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nfloat3  camera(float2 uv)\n{\n    float       fov = 1.;\n    float3      forw  = float3(0.0, 0.0, -1.0);\n    float3      right = float3(1.0, 0.0, 0.0);\n    float3      up    = float3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}","name":"Image","description":"","type":"image"}]}