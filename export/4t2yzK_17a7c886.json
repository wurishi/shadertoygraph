{"ver":"0.1","info":{"id":"4t2yzK","date":"1509289969","viewed":89,"name":"Hello Ray Marching (3)","username":"2YY","description":"i don't understand yet this repetation logic.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float COLLISION_THRESHOLD = 1e-6;\nconst float INFINITE = 1e128;\nconst float E = 2.71828182846;\n\n\n\n\nfloat unionDistance(float distance1, float distance2) {return min(distance1, distance2);}\n\nfloat distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 p) {\n\treturn distance(spherePosition, p) - sphereRadius;\n}\n\nfloat distanceToAll(vec3 p) {\n\tvec3 sphere1Pos = vec3(1.5, 1.5, 3.0);\n\tfloat sphere1Radius = 1.0;\n\tvec3 sphere2Pos = vec3(0.0, 0.0, 2.0);\n\tfloat sphere2Radius = 1.0;\n\tvec3 sphere3Pos = vec3(-2.0, -2.0, 3.0);\n\tfloat sphere3Radius = 0.5;\n\n\tfloat d1 = distanceToSphere(sphere1Pos, sphere1Radius, p);\n\tfloat d2 = distanceToSphere(sphere2Pos, sphere2Radius, mod(p, 6.0) - 3.0);\n\tfloat d3 = distanceToSphere(sphere3Pos, sphere3Radius, p);\n\tfloat d = unionDistance(d1, d2);\n\td = unionDistance(d, d3);\n\td = d2;\n\treturn d;\n}\n\nvec3 getNormal(vec3 p) {\n\tconst float d = 0.0001;\n\treturn normalize(\n\t\tvec3 (\n\t\t\tdistanceToAll(p+vec3(d,0.0,0.0))-distanceToAll(p+vec3(-d,0.0,0.0)),\n\t\t\tdistanceToAll(p+vec3(0.0,d,0.0))-distanceToAll(p+vec3(0.0,-d,0.0)),\n\t\t\tdistanceToAll(p+vec3(0.0,0.0,d))-distanceToAll(p+vec3(0.0,0.0,-d))\n\t\t)\n\t);\n}\n\nvec3 shading(vec3 ray) {\n\tvec3 normal = getNormal(ray);\n\tfloat diff = dot(normal, vec3(0.3, 0.6, sin(iTime*4.0)*0.5-0.3)); // 第二引数が、たぶん、ライトの方向\n\treturn vec3(diff);\n}\n\n\n\n\n/**\n * とりあえずワールド座標のことは忘れて、ビュー座標上のみで計算する。\n * ビュー座標 === カメラの場所が原点であり、正のZ方向がカメラの方向。\n *\n * 1. 方向\n * 2. 焦点距離\n * 3. Z回転\n *\n * とりあえず動くように鳴ったけど、新しい課題見つかった。\n *\n * 1. 座標系のスケールが画面のスケールに依存している(画面が大きくなると座標系も拡大して見えてしまう)\n * 2. 焦点距離が調整できない(現状かなりの広角。人間の視覚に近づけられるようにしたい。)\n *   -> 出来れば、現実のカメラのプロパティで調整できるようにしたい(27mm とか 50mm とか 300mm とか)\n *     -> 順に、広角レンズ、標準レンス、望遠レンズ。ただし、35mm 換算の場合。\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0); // ビュー座標なので、カメラの座標は常に座標系の原点になります。\n\tvec3 cameraDirection = vec3(0.0, 0.0, 1.0); // カメラの向きも、ビュー座標なので、正のZ方向で固定。\n\tfloat cameraFocalLength = sin(iTime*0.5)*0.1+0.5; // 焦点距離を調整するパラメータだが、焦点距離では無い(笑\n\n\tfloat rayLength = 0.0;\n\tvec3 rayDirection = normalize(vec3(uv.x, uv.y, cameraDirection.z + cameraDirection.z * cameraFocalLength));\n\n\tvec3 color = vec3(false);\n\n\tfor(int i=0;  i<20; i++) {\n\t\tvec3 ray = cameraPos + rayDirection * rayLength;\n\t\tfloat d = distanceToAll(ray);\n\t\tif(d < COLLISION_THRESHOLD) {\n\t\t\tcolor = shading(ray);\n\t\t\tbreak;\n\t\t}\n\t\trayLength += d;\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}