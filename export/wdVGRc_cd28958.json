{"ver":"0.1","info":{"id":"wdVGRc","date":"1571000887","viewed":631,"name":"Engine Failure","username":"shau","description":"Slow train. Slow shader","likes":35,"published":1,"flags":32,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nfloat noise(\n    vec2 uv, \n    float s1, \n    float s2, \n    float t1, \n    float t2, \n    float c1) \n{\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.0);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n    float nz = noise(uv, 64., 16., float(iFrame), float(iFrame), 0.98);\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    pc *= nz;\n    \n    C = vec4(pc, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define EPS .005\n#define FAR 100.\n#define ZERO (min(iFrame,0))\n\n#define X 1.8\n#define METAL 1.0\n#define BLACK_GLOSS 2.0\n#define BLACK_MATT 3.0\n#define WOOD 4.0\n#define GROUND 5.0\n\n#define SEP vec3(1.0, 0.7, 0.3)\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat fbm(vec3 x) {\n    float r = 0.0,\n          w = 1.0,\n          s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * n3D(s * x);\n    }\n    return r;\n}\n\n//IQ Sphere Functions\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd),\n          c = dot(oc, oc) - sph.w * sph.w,\n          h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h,\n          tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\n//SDF - IQ\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 nearest(vec2 a, vec2 b) {\n    float s = step(a.x, b.x);\n    return a*s + (1.0-s)*b;\n}\n\nvec2 track(vec3 p) {\n    p.x = abs(p.x);\n    //rail\n    float metal = sdBox(p - vec3(X+0.14, -0.1, 0.0), vec3(0.04, 0.12, 1000.0));\n    metal = min(metal, sdBox(p - vec3(X+0.14, -0.26, 0.0), vec3(0.2, 0.04, 1000.0)));\n    //sleeper\n    vec3 q = p;\n    q.z = mod(q.z, 0.8) - 0.4;\n    float wood = sdBox(q - vec3(0.0, -0.4, 0.0), vec3(3.2, 0.1, 0.24));\n    //clamps\n    metal = min(metal, sdTorus(q - vec3(2.2, -0.25, 0.0), vec2(0.14, 0.02)));\n    \n    return nearest(vec2(metal, METAL), vec2(wood, WOOD));\n}\n\nfloat wheel(vec3 p, float scale) {\n    float w = sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 1.0*scale, 0.02); //rim\n    w = smin(w, sdCappedCylinder(p.yxz - vec3(0.0, X + 0.08, 0.0), 0.9*scale, 0.06), 0.04); //rim\n    w = max(w, -sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.8*scale, 0.16)); //rim cutout\n    w = min(w, sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.3*scale, 0.13)); //hub\n    w = max(w, -sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.2*scale, 0.2)); //hub cutout\n    w = min(w, sdCappedCylinder(p.yxz - vec3(0.0, 0.0, 0.0), 0.1*scale, X+0.1)); //axle\n    //spokes\n    float a = (atan(p.z, p.y) / 6.2831853);\n    float ia = (floor(a*18.0) + 0.5)/18.0*6.2831853;\n    p.yz *= rot(ia);\n    return min(w, sdBox(p - vec3(X, 0.36*scale, 0.0), vec3(0.02, 0.5*scale, 0.05*scale)));    \n}\n\nfloat link(vec3 p, vec3 a, vec3 b) {    \n    float t = sdCappedCylinder(p.yxz - a.yxz, 0.1, 0.05);\n    t = min(t, sdCappedCylinder(p.yxz - b.yxz, 0.1, 0.05));\n    return min(t, sdCapsule(p, a, b, 0.05));\n}\n\nvec2 train(vec3 p) {\n    \n    p.x = abs(p.x);\n\n    //wheels\n    vec3 q = p;\n    q.z += 1.1;\n    float metal = wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 1.0, 1.1), 1.0);\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 1.0, 3.3), 1.0));\n    metal = min(metal, wheel(p - vec3(0.0, 0.8, 6.0), 0.8));\n    metal = min(metal, wheel(p - vec3(0.0, 0.6, -8.0), 0.6));\n    //coal truck\n    q = p;\n    q.z -= 15.5;\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.6, 2.5), 0.6));\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.6, 4.5), 0.6));\n    \n    //coal truck bogeys\n    float matt = sdBox(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.7, 3.5), vec3(1.2, 0.2, 1.2));\n\n    //engine\n    float gloss = sdCappedCylinder(p.xzy - vec3(0.0, -1.0, 4.0), 1.6, 7.0);\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(0.0, -4.6, 4.0), 1.7, 0.1));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(0.0, 2.0, 4.0), 1.7, 0.1));\n    gloss = max(gloss, -sdCappedCylinder(p.xzy - vec3(0.0, -7.0, 4.0), 1.54, 3.0));\n    //top cyclinders\n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 5.0, -2.0), 0.8, 0.7), 0.5);\n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 5.0, 3.4), 0.5, 0.8), 0.5);\n    gloss = smin(gloss, sdBox(p - vec3(0.0, 3.8, 5.0), vec3(1.4, 1.4, 1.2)), 0.2);\n    \n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.5, 0.5), vec3(2.0, 0.1, 7.5)));//cylinder platform\n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.5, 8.0), vec3(1.6, 0.1, 2.0)));//driver platform \n    matt = min(matt, sdBox(p - vec3(0.0, 2.0, 1.5), vec3(0.6, 0.4, 8.5)));//beam platform\n    matt = min(matt, sdBox(p - vec3(0.0, 1.7, -1.0), vec3(1.0, 1.0, 5.0)));//core platform\n    matt = min(matt, sdBox(p - vec3(0.0, 0.9, 5.0), vec3(1.4, 0.2, 2.0)));//rear axle platform\n    matt = min(matt, sdBox(p - vec3(0.0, 1.2, 6.4), vec3(0.4, 0.6, 0.4)));//rear support platform\n    //front platform\n    matt = min(matt, sdBox(p - vec3(0.0, 0.6, -7.0), vec3(1.0, 0.2, 1.4)));\n    matt = min(matt, sdBox(p - vec3(0.0, 1.2, -7.8), vec3(0.4, 0.6, 0.6)));\n    gloss = min(gloss, sdBox(p - vec3(0.0, 1.6, -8.4), vec3(2.0, 0.2, 0.2)));\n    //bumpers\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(1.2, -8.7, 1.6), 0.2, 0.1));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(1.2, -8.8, 1.6), 0.34, 0.03));\n    //link support    \n    gloss = min(gloss, sdBox(p - vec3(2.0, 2.2, -3.1), vec3(0.2, 0.4, 0.2)));\n    \n    //ladder\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.3, 9.4), vec3(1.4, 2.6, 9.4), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.3, 9.9), vec3(1.4, 2.6, 9.9), 0.02));\n    //rungs\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.5, 9.4), vec3(1.4, 0.5, 9.9), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 1.2, 9.4), vec3(1.4, 1.2, 9.9), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 1.9, 9.4), vec3(1.4, 1.9, 9.9), 0.02));\n    \n    //cab\n    gloss = min(gloss, sdBox(p - vec3(0.0, 4.0, 7.0), vec3(2.0, 1.4, 1.0)));\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.0, 7.1), vec3(1.94, 1.34, 1.0)));    \n    //roof\n    float r = sdBox(p - vec3(0.0, 6.7, 8.0), vec3(2.0, 1.4, 2.0));\n    r = max(r, sdCappedCylinder(p.xzy - vec3(0.0, 8.0, 0.0), 5.8, 2.0));\n\tgloss = min(gloss, r);\n    //windows\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.5, 6.8), vec3(2.4, 0.4, 0.2)));\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.5, 7.5), vec3(2.4, 0.4, 0.4)));\n    gloss = max(gloss, -sdBox(p - vec3(1.75, 4.5, 7.0), vec3(0.16, 0.4, 1.4)));   \n    \n    //coal truck\n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.7, 15.5), vec3(2.2, 1.5, 5.4)));\n    gloss = min(gloss, sdBox(p - vec3(0.0, 1.4, 41.0), vec3(2.2, 1.0, 20.0)));    \n    \n    //front cylinders\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 2.1), 0.4, 0.7));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 2.1), 0.5, 0.5));\n    gloss = min(gloss, sdBox(p - vec3(2.0, 1.7, -6.3), vec3(0.5, 0.4, 0.5)));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 1.2), 0.5, 0.7));\n    gloss = min(gloss, sdCapsule(p, vec3(2.0, 2.1, -6.3), vec3(1.0, 4.0, -6.3), 0.3)); \n    //rear cylinder\n    gloss = min(gloss, sdCapsule(p, vec3(2.2, 2.3, 1.0), vec3(2.2, 2.3, 2.8), 0.3));\n    //front cylinder\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 2.1, -8.2), vec3(-1.4, 2.1, -8.2), 0.3));\n    gloss = min(gloss, sdCappedCylinder(p.yxz - vec3(2.1, 0.8, -8.2), 0.32, 0.1));\n    \n    //linkages\n    metal = min(metal, link(p, vec3(2.0, 1.2, -6.3), vec3(2.0, 1.2, 0.3)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 0.6, 2.2)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 0.6, -2.2)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, -2.2), vec3(2.0, 0.6, -4.6)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 1.2, 0.3)));\n    metal = min(metal, link(p, vec3(2.0, 2.1, -6.3), vec3(2.0, 2.1, -3.4)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, -4.6), vec3(2.0, 2.1, -3.4)));\n\n    //pipes\n    //top\n    gloss = min(gloss, sdCapsule(p, vec3(1.8, 4.0, -7.0), vec3(1.8, 4.0, 6.0), 0.1));\n    gloss = min(gloss, sdCapsule(p, vec3(1.8, 4.0, -7.0), vec3(-1.8, 4.0, -7.0), 0.1));    \n    q = p;\n    q.z += 2.0;\n    gloss = min(gloss, max(sdTorus(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 4.0, 3.0), vec2(1.7, 0.05)), -p.y+4.0));\n    //bottom\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 2.8, -5.0), vec3(1.9, 2.8, 6.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 2.8, -5.0), vec3(-1.9, 2.8, -5.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -5.0), vec3(1.9, 3.0, 6.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -5.0), vec3(-1.9, 3.0, -5.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -3.0), vec3(1.9, 3.6, -3.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, 0.4), vec3(1.9, 3.6, 0.4), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.6, -3.0), vec3(1.9, 3.6, 0.4), 0.05));\n        \n    return nearest(nearest(vec2(gloss, BLACK_GLOSS), vec2(matt, BLACK_MATT)),\n                           vec2(metal, METAL));\n}\n\nfloat blowout(vec3 p) {\n    \n    p.xy -= vec2(-4.0, 4.0);\n    \n    //blowout\n    vec3 q = p;\n    float amt = max(0.0, abs(q.z)-7.4);\n    float a = (atan(q.y, q.x) / 6.2831853);\n    float ia = (floor(a*16.0) + 0.5)/16.0*6.2831853;\n    q.xy *= rot(ia);\n    \n    float dx = (amt*amt*-0.2) + sin(q.z*ia*0.4+n3D(q))*amt*0.4;\n    float bo = sdCapsule(vec3(q.x+dx, q.y, q.z), \n                         vec3(1.2, 0.0, -10.0), \n                         vec3(1.2, 0.0, -6.0), \n                         0.05);\n\n    q.xy *= rot(0.1);\n    dx = (amt*amt*-0.2) + sin((q.z+2.3)*(ia+3.0)*0.7+n3D(q*1.3))*amt*0.2;\n    bo = min(bo, sdCapsule(vec3(q.x+dx, q.y, q.z), \n                           vec3(0.8, 0.0, -11.0), \n                           vec3(0.8, 0.0, -6.0), \n                           0.05));\n\n    //q.xy *= rot(-0.2);\n    //dx = (amt*amt*-0.2) + sin((q.z+1.7)*(ia+2.1)*0.7+n3D(q*1.6))*amt*0.4;\n    //bo = min(bo, sdCapsule(vec3(q.x+dx, q.y, q.z), \n    //                       vec3(0.8, 0.0, -11.0), \n    //                       vec3(0.8, 0.0, -6.0), \n    //                       0.05));\n\n    q = p;\n    q.y += smoothstep(-8.0, -12.0, q.z) * 4.0;\n    q.x -= amt*amt * sign(q.x) * 0.2;\n    a = (atan(q.y, q.x) / 6.2831853);\n    ia = (floor(a*20.0) + 0.5)/20.0*6.2831853;\n    q.xy *= rot(ia);\n    bo = min(bo, sdCapsule(vec3(q.x+dx*0.4, q.y, q.z), \n                           vec3(0.6, 0.0, -12.0), \n                           vec3(0.6, 0.0, -6.0), \n                           0.05));\n    \n    dx = (amt*amt*-0.2) + sin((q.z+3.7)*(ia+5.1)*0.7+n3D(q*1.7))*amt*0.4;\n    q.xy *= rot(0.1);\n    bo = min(bo, sdCapsule(vec3(q.x+dx*0.4, q.y, q.z), \n                           vec3(0.8, 0.0, -11.0), \n                           vec3(0.8, 0.0, -6.0), \n                           0.05));    \n    \n    return bo;\n}\n\nvec2 map(vec3 p) {\n    vec2 tn = train(p + vec3(4.0,0.0,0.0));\n    p.x = abs(p.x);\n    vec2 tk = track(p - vec3(4.0,0.0,0.0));\n    return nearest(tn, tk);    \n}\n\nvec3 normal(vec3 p) {  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec2 march(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.0, id = 0.0;\n    for (int i=ZERO; i<140; i++) {\n        vec3 p = ro + rd*t;\n        vec2 ns = map(p);\n        if (abs(ns.x)<EPS || t>maxt) {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n    }\n    return vec2(t, id);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = ZERO; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 bump(vec3 p, vec3 n, float ba) {\n    vec2 e = vec2(EPS, 0.0);\n    float nz = n3D(p);\n    vec3 d = vec3(n3D(p + e.xyy) - nz, n3D(p + e.yxy) - nz, n3D(p + e.yyx) - nz) / e.x;\n    n = normalize(n - d * ba / sqrt(0.1));\n    return n;\n}\n\n\n//Patu\nvec3 sky(vec3 rd, vec3 ld){\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(T*0.02, 0.0), T*0.02)) * 1.5,\n\t      sun = max(dot(rd, ld), 0.0);\n    vec3 col = mix(vec3(0.4, 0.1, 0.0), vec3(1.0, 0.7, 0.3), max(0.0, rd.z*0.5 + 0.8));\n    col += vec3(1.0, .7, 0.4) * pow(sun, 8.0);\n\tcol += vec3(1.0, .8, 0.6) * pow(sun, 64.0);\n    return col + col * clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n\nvec3 normalBO(vec3 p) {  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = blowout(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec2 marchBO(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    for (int i=ZERO; i<160; i++) {\n        vec3 p = ro + rd*t;\n        float ns = blowout(p);\n        if (ns<EPS) break;\n        t += ns*0.3;\n        if (t>maxt) {\n            t = 0.0;\n            break;\n        }\n    }\n    return vec2(t, BLACK_GLOSS);\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec2 s, vec3 n) {\n\n    vec3 pc = vec3(0),\n         lp = vec3(3.0, 20.0, 10.0),\n         SLD = normalize(vec3(1.0, 20.0, 2.0));\n    \n    if (s.x<FAR) {\n        \n        vec3 p = ro + rd*s.x;\n        float ao = AO(p, n);\n        \n        //sky\n        float sh = shadow(p+n*EPS, SLD, EPS, 20.0);\n        float specSky = pow(max(dot(reflect(-SLD, n), -rd), 0.0), 32.0);\n        pc = vec3(0.2) * SEP * max(0.2, dot(SLD, n));\n\n        //*\n        //highlight\n        vec3 sc = vec3(0.1);\n        vec3 ld = normalize(lp - p);\n        float specLight = pow(max(dot(reflect(-ld, n), -rd), 0.0), 12.0);\n        if (s.y==METAL) {\n            sc =vec3(1.4); \n            specLight = pow(max(dot(reflect(-ld, n), -rd), 0.0), 32.0)*2.0;\n        } else if (s.y==GROUND) {\n            sc =vec3(0.4);    \n        } else if (s.y==WOOD) {\n            sc =vec3(0.77);    \n        }\n        \n        pc += sc * SEP * max(0.05, dot(ld, n));\n        if (s.y==BLACK_GLOSS || s.y==METAL) {\n            pc += SEP * (specSky + specLight);\n        }\n        //*/\n        \n        pc *= ao;\n        pc *= sh;\n        \n    }\n    \n    pc = mix(pc, sky(rd, SLD)*0.4, s.x*1.2/FAR);\n    \n    return pc;\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    vec3 ro,\n         la,\n         rd = camera(U, R, ro, la, 0.6, T);\n   \n    vec2 surface = vec2(FAR, 0.0);\n    vec3 n = vec3(0);\n    float dof = 1.0;\n    \n    vec3 fo = vec3(0.0, -0.5, 0.0), fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersect(ro, rd, fn, fo);\n    if (ft>0.0 && ft<surface.x) {\n        vec3 p = ro + rd*ft;\n        surface = vec2(ft, GROUND);\n        n = bump(p*9.0, fn, 0.6);\n        dof = length(la-p);\n    }\n    \n    vec2 si = march(ro, rd, surface.x);\n    if (si.x>0.0 && si.x<surface.x) {\n        vec3 p = ro + rd*si.x;\n        surface = si;\n        n = normal(p);\n        if (si.y==WOOD) {\n            n = bump(vec3(p.x*1.0,p.y*20.0,p.z*20.0), n, 0.3);\n        }\n        dof = length(la-p);\n    }\n    \n    vec2 bt = sphIntersect(ro, rd, vec4(-4.0,4.0,-9.0,6.0));\n    if (bt.x>0.0) {\n        vec2 t = marchBO(ro, rd, bt.x, min(surface.x, bt.y));\n        if (t.x>0.0 && t.x<surface.x) {\n            vec3 p = ro + rd*t.x;\n            surface = t;\n            n = normalBO(p);\n            dof = length(la-p);\n        }\n    }\n\n    vec3 pc = shade(ro, rd, surface, n); \n\n    //gamma correction\n    pc = pow(pc, vec3(1.0/1.6));\n    \n    /*\n    //debug\n    if (bt.y > 0.0) {\n        pc += vec3(0.2,0.0,0.0);\n    }\n    //*/\n    \n    C = vec4(pc, dof*1.4/FAR);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define T iTime\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 camera(vec2 U, vec2 r, inout vec3 ro, inout vec3 la, float fl, float t) {\n    \n    vec2 uv = (U - r*.5) / r.y;\n    \n    ro = vec3(6.0, 2.0 + sin(t*0.13)*0.2, -22.0);\n    la = vec3(-4.0, 3.0, -9.0);\n    \n    ro.xz *= rot(sin(t * 0.1) * 0.02);\n    \n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}","name":"Common","description":"","type":"common"}]}