{"ver":"0.1","info":{"id":"Xlc3Rf","date":"1470438705","viewed":12278,"name":"Worley Hyperdisc - Ocean Planet","username":"CaliCoastReplay","description":"3rd mix of the Worley noise shader at https://www.shadertoy.com/view/Xl33Wn , the hyperbolic disc from : https://www.shadertoy.com/view/XllSWf , and starfield from https://www.shadertoy.com/view/4scXWB .  Try it at high-res!","likes":72,"published":1,"flags":0,"usePreview":0,"tags":["ocean","planet","worley","stars","disc","mattdamon","hyperbolic","yeis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Adapted from:  https://www.shadertoy.com/view/Xl33Wn\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    return fract(sin(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n float d = 1e30;\n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n  return 3.0*exp(-4.4*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 11.0 + 0.15 * iTime) * \n                          sqrt(worley(p*50.0+ 0.18+ -0.12*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+0.3*iTime))))));\n}\n\n\n//hyperbolic disc/radial distortion adapted from https://www.shadertoy.com/view/XllSWf\nvec2 HyperbolicDisc(vec2 fragCoord) {    \n    fragCoord -= iResolution.xy * 0.29;\n    fragCoord /= iResolution.x;\n    float r = length(fragCoord);\n    vec2 d = fragCoord / r *1.5 ;\n    fragCoord = d / atanh(r * (2.5 )) / 2.0;\n    fragCoord *= iResolution.x;\n    fragCoord += iResolution.xy *0.212;\n    fragCoord += 1.59+ sin(iTime/10.0);\n    return fragCoord;\n}\n\nfloat flare( vec2 U )                            // rotating hexagon \n{\tvec2 A = sin(vec2(0, 1.57) + iDate.w);\n    U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2,0,1,1.7); \n    return .2/max(U.x,U.y);                      // glowing-spiky approx of step(max,.2)\n  //return .2*pow(max(U.x,U.y), -2.);\n \n}\n\n#define r(x)     fract(1e4*sin((x)*541.17))      // rand, signed rand   in 1, 2, 3D.\n#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )\n#define sr3(x)   ( r(vec4(x,x+.1,x+.2,0)) *2.-1. )\n\nvec4 stars( vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U =  (U+U - R) / R.y;\n\tO -= O+.3;\n    for (float i=0.; i<99.; i++)\n        O += flare (U - sr2(i)*R/R.y )           // rotating flare at random location\n              * r(i+.2)                          // random scale\n              * (1.+sin(iDate.w+r(i+.3)*6.))*.1  // time pulse\n            //* (1.+.1*sr3(i+.4));               // random color - uncorrelated\n              * (1.+.1*sr3(i));                  // random color - correlated\n    return O;\n}\n\nvec4 fake_planet( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 fragCoord2;\n    fragCoord2.x += sin(iTime/3.5)*12.0;\n    fragCoord2.y += cos(iTime/3.5)*12.0;\n    fragCoord2 = HyperbolicDisc(fragCoord);\n    vec2 uv = fragCoord2.xy / iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy / 1919.0) + fworley((uv*iResolution.xy + sin(iTime*2.0)) / 3200.0)\n         + fworley((uv*iResolution.xy - sin(iTime*2.0)) / 4800.0);\n \twolo *= .85*exp(-length2(abs(0.5*uv-0.9)));\n    fragColor = vec4(wolo * vec3(0.1*wolo*wolo, 0.3*wolo, 1.2*pow(wolo, 0.90-wolo)), 1.0);\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    hsv.z *= sqrt(hsv.z) * 1.1+ cos(iTime/13.0)*0.4;\n    hsv.x += hsv.z/200.0 * sin(iTime/2.0)*2.0;\n    hsv.y -= hsv.z/102.0;\n    fragColor.xyz = hsv2rgb(hsv);\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 starColor = stars(fragColor, fragCoord);\n    vec4 planetColor = fake_planet(fragCoord);\n    float distanceToCenter = 0.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float xDist = uv.x - 0.35;\n    float yDist = uv.y - 0.35;\n    distanceToCenter += sqrt(xDist*xDist/.29 + yDist*yDist);\n    if (distanceToCenter > 0.60)\n    \tfragColor =starColor/2.0;\n    else        \n    {\n        float falloff =  1.0-distanceToCenter;\n    \tfragColor = planetColor * falloff *falloff * falloff * 1.90;\n    }\n\n}","name":"Image","description":"","type":"image"}]}