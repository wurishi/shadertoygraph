{"ver":"0.1","info":{"id":"l3tSzn","date":"1718542775","viewed":69,"name":"Vietoris–Rips Complex","username":"chronos","description":"The 2D Vietoris–Ripscomplex of a set of points for a given radius as a function of time. Up to simplices of size 3, aka triangles.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["graph","complex","topology","persistent","computational","vietoris","rips","homology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Vietoris–Rips Complex by chronos\n    --------------------------------------\n    \n    Simple (and inefficient) rendering and demonstration of the\n    Vietoris–Rips complex of a set of points in 2D \n    \n    The Vietoris–Rips complex contains all simplices constructed from points in the set whose \n    diameter is less than a specified value. The diameter of a set of points is the maximum of\n    all pairwise distances between points in the set.\n     \n    As I understand, the Vietoris–Rips complex can contain subsets of\n    size greater than the (ambient-) dimension. E.g containing tetrahedrons even in 2D.\n    This is in contrast to Delaunay Complexes and Alpha Complexes.\n    Here I only include simplices of size up to 3 (aka triangles).\n    \n    Related concepts:\n    \n    Delaunay complex ( and Voronoi diagram)\n        - Contains all simplices whose circumsphere do not contain other vertices.\n    Convex hull\n        - Intuitively the outline/surface of the Delaunay complex.\n    Čech complex\n        - Simplices are included based on the intersection of all balls centered at the vertices.\n          In contrast to Vietoris-Rips, where we only require *pairwise* intersections of the participating vertices.\n          There is also a 2x difference in scale due to one definition using radius and and the other using the diameter.\n          \n    Alpha Complex\n        - A generalization and a subcomplex of the Delaunay complex which only includes simplicies that have a circumcircle smaller than\n          the given radius. α is the reciprocal of the generalized disc radius, 1/α. \n          \n    Alpha Shape\n        - Intuitively the outline/surface of the alpha complex, so it only includes simplices with circumsphere radius *exactly* equal to 1/α,\n          which do not contain other vertices. Exact definition varies a bit it seems.\n    \n    \n    Links:\n    ----------------------------------------------------\n    https://en.wikipedia.org/wiki/Vietoris–Rips_complex\n    https://en.wikipedia.org/wiki/Čech_complex\n    https://en.wikipedia.org/wiki/Alpha_shape\n    https://en.wikipedia.org/wiki/Diameter#Generalizations\n    https://en.wikipedia.org/wiki/Delaunay_triangulation#d-dimensional_Delaunay\n    \n    self link: https://www.shadertoy.com/view/l3tSzn\n\n*/\n\n\nvec2 get_pos(int index)\n{\n    return  .8 * (-1. + 2. * texelFetch(iChannel0, ivec2(index, 0), 0).rg);\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat tri(vec2 a, vec2 b, vec2 c, vec2 p, float ps)\n{\n    c-= a; b-=a; p-=a;\n    float ABC = determinant(mat2(b,c));\n    float C = determinant(mat2(b,p));\n    float B = determinant(mat2(p,c));\n    float A = ABC - B - C;\n    ps *= ABC * 4.;\n    return smoothstep(-ps, ps, A) * smoothstep(-ps, ps, B) * smoothstep(-ps, ps, C);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ps = 2. / iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float dotsize = 0.01;\n    float seg_thickness = 0.005;\n    \n    float t = fract(iTime*0.01);\n    float r = abs(min(t,(1.-t)));\n    \n    if(length(iMouse.xy) > 10.)\n        r = length(mouse)*.35;\n    \n    const int num_points = 20;\n    \n    // Loop over all points\n    for(int i = 0; i < num_points; i++)\n    {\n\n        vec2 pos = get_pos(i);\n        float d = length(uv-pos);\n\n        col += smoothstep(dotsize+ps,dotsize-ps, d); // Draw dot\n\n        col += smoothstep(r+ps,r-ps, d) * 0.00125 * vec3(1, 2, 3); // Draw disc\n        col += smoothstep(3.*ps,ps, abs(d-r)) * 0.0125 * vec3(0.25, 1, 4); // Draw circle\n    }\n    \n    // Loop over all pairs\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n\n            float d = length(pos_i-pos_j);\n            float connected = smoothstep(2. * r+0.01, 2. * r-0.01, d); // 1 if  d < 2. * r\n            float seg_alpha = 0.1 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_i, pos_j, uv));\n            col += seg_alpha * connected;\n        }\n    }\n        \n    // Loop over all triples\n    float tri_alpha = 0.;\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n            \n            for(int k = j; k < num_points; k++)\n            {\n                vec2 pos_k = get_pos(k);\n\n                float d_ij = length(pos_i-pos_j);\n                float d_ik = length(pos_i-pos_k);\n                float d_jk = length(pos_j-pos_k);\n                float connected =\n                    smoothstep(2. * r+0.01, 2. * r-0.01, d_ij) *\n                    smoothstep(2. * r+0.01, 2. * r-0.01, d_ik) *\n                    smoothstep(2. * r+0.01, 2. * r-0.01, d_jk)\n                    ;\n                    \n                tri_alpha = max(tri_alpha, connected * 0.1 *tri(pos_i, pos_j, pos_k, uv, ps));\n            \n            }\n        }\n    }\n    \n    col += tri_alpha * vec3(1, 3, 2);\n\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}