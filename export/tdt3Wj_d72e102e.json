{"ver":"0.1","info":{"id":"tdt3Wj","date":"1569328827","viewed":76,"name":"Denoising pathtraced","username":"drcd1","description":"Denoising using a median filter.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 delta = 1.0f/iResolution.xy;\n    vec4 buffer = texture( iChannel0, uv );\n\t\n    float values[25];\n    float copy[25];\n    for(int i = 0; i<5;i++){\n        for(int j = 0; j<5; j++){\n            \n            \n            vec2 aux = vec2(i-2,j-2);\n            \n            \n        \tvalues[i*5+j] = texture(iChannel0,uv+aux*delta).x;\n        }\n    }\n    //sorting values\n    \n    for(int i = 0; i<25;i++){\n    \tcopy[i] = 10000000.0f;\n        float tmp_val = values[i];\n        for(int j = 0; j<i;j++){\n            if(copy[j]>tmp_val){\n            \tfloat tmp = tmp_val;\n                tmp_val = copy[j];\n                copy[j] = tmp;\n            }\n        }\n        copy[i] = tmp_val;\n    }\n    float sum = 0.0f;\n    for(int i = 0; i<25;i++){\n        sum+=values[i];\n    \t\n    }\n    sum/=25.0f;\n    //median filter\n    vec3 col = vec3(copy[12]);\n    \n    \n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define SAMPLES 8\n#define SPHERE 1\n#define PLANE 2\n#define TRIANGLE 3\n#define INF 1e9\n#define EPS 1e-3\n#define N_SHAPES 6\n#define N_LIGHTS 2\n#define DEPTH 3\n#define M_PI 3.14159265358979323846 \n#define ROUGHNESS 0.5f\n\n\n\n\n\n\nint t = 2;\nvec2 fragPos;\nmat3 cameraRot = mat3(1,0,0,0,1,0,0,0,1);\nvec3 cameraPosBase = vec3(2.0f,2.0f,2.0f);\nvec3 cameraPos = vec3(2.0f,2.0f,2.0f);\nfloat tanFovy = 1.0f;\nstruct shape{\n\tvec3 q[3];\n    int type;\n    int material;\n};\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719,\n    0.07600,\n    0.02840,\n\t\n\t0.35458, \n\t0.90834, \n\t0.13383, \n\t\n\t0.04823,\n\t0.01566,\n\t0.83777\n);  \nconst mat3 ACESOutputMat = mat3(\n     1.60475, \n    -0.10208, \n    -0.00327, \n\n\t-0.53108, \n\t 1.10813, \n\t-0.07276, \n\t\n\t-0.07367,\n\t-0.00605,\n\t 1.07602\n);\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat getRandom(){\n\tt++;\n\treturn random(fragPos.xy + vec2(2*(t),0));\t\n}\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n\nvec3 cosineHemisphereSample(float u1, float u2, vec3 normal){\n\tvec3 tan = ortho(normal);\n\tvec3 cotan = cross(normal, tan);\n\tmat3 m;\n\tm[0] = tan;\n\tm[1] = cotan;\n\tm[2] = normal;\n\t\n\t\n\tfloat r = sqrt(u1);\n\tfloat theta = M_PI*2.0f*u2;\n\t\n\tvec3 ret = vec3(r*cos(theta),r*sin(theta), sqrt(1.0f-u1));\n\treturn m*ret;\n\t\n}\n\nvec3 beckmannSample(float e1, float e2, vec3 normal, float rough){\n            float phi = 2.0f*3.14159f*e1;\n\t\t\tfloat tan2theta;\n\t\t\tfloat logSample = e2>0.0?log(e2):0.0f;\n\t\t\ttan2theta = - rough* rough * logSample;\n\t\t\tfloat cosTheta = 1. /sqrt(1. + tan2theta);\n\t\t\tfloat sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));\n\t\t\tvec3 wh = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n    \t\t\n    \t\tvec3 tan = ortho(normal);\n\t\t\tvec3 cotan = cross(normal, tan);\n\t\t\tmat3 m;\n\t\t\tm[0] = tan;\n\t\t\tm[1] = cotan;\n\t\t\tm[2] = normal;\n\t\n    \n\t\t\treturn m*wh;\n}\n\n\nstruct ray{\n\tvec3 o;\n    vec3 d;\n    float tMax;\n    int depth;\n    \n};\nshape make_sphere(vec3 center, float r){\n\tshape ret;\n    ret.q[0] = center;\n    ret.q[1].x = r;\n    ret.type = SPHERE;\n    ret.material = 0;\n    return ret;\n}\n\n//normal mustbe normalized\nshape make_plane(vec3 point, vec3 normal){\n    shape ret;\n    ret.material = 0;\n    ret.type = PLANE;\n    ret.q[0] = point;\n    ret.q[1] = normal;\n    return ret;\n}\n\nstruct intersection{\n    float t;\n    vec3 normal;\n    int material;\n};\n\nbool solve_quadratic(float a, float b, float c, out float tMin, out float tMax){\n\tfloat d = b*b-4.0f*a*c;\n    if(d<0.0f)\n        return false;\n    tMin = (-b-sqrt(d))/(2.0f*a);\n    tMax = (-b+sqrt(d))/(2.0f*a);\n    return true;\n}\n\nbool intersect_sphere(inout ray r, in shape s, inout intersection i){\n    vec3 delta = s.q[0] - r.o;\n   \tfloat c = dot(delta,delta) - s.q[1].x*s.q[1].x;\n    float b = -2.0f*dot(r.d, delta);\n    float a = dot(r.d, r.d);\n    \n    float tMin, tMax;\n    \n    if(solve_quadratic(a,b,c,tMin,tMax)){\n        if(tMin>EPS && tMin<r.tMax){\n            i.t = tMin;\n            i.normal = normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else if(tMax>EPS && tMax<r.tMax){\n        \ti.t = tMax;\n            i.normal =  normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else {\n        \treturn false;\n        }\n    \n    } else {\n       return false;\n    }    \n\treturn false;\n}\n\nbool intersect_plane(inout ray r, in shape s, inout intersection i){\n    \n    vec3 delta = s.q[0]-r.o;\n    float tMax = (dot(delta,s.q[1]))/dot(s.q[1],r.d);\n\n    if(tMax<EPS||tMax>r.tMax)\n        return false;\n    \n    i.t = tMax;\n    i.normal = s.q[1];\n    r.tMax = i.t;\n    i.material = s.material;\n    return true;\n}\n\n\n\nshape make_tri(vec3 v1, vec3 v2, vec3 v3){\n\tshape ret;\n    ret.q[0] = v1;\n    ret.q[1] = v2;\n    ret.q[2] = v3;\n    return ret;\n    \n}\n\nray getRay(vec2 fragCoord){\n\tvec2 uv = fragCoord;\n    float aspect = iResolution.x/iResolution.y;\n    ray r;\n    r.o.x=0.0f;\n    r.o.y=0.0f;\n    r.o.z=0.0f;\n    \n\tr.d.x = (uv.x)*aspect*tanFovy;\n    r.d.y = uv.y*tanFovy;\n    r.d.z = -1.0f;\n    \n    r.o += cameraPos;\n    r.d = cameraRot*r.d;\n    \n    r.d = normalize(r.d);\n    \n    r.tMax = INF;\n    return r;\n\n}\n\nray makeRay(){\n    ray r;\n    r.o = vec3(0,0,0);\n    r.d = vec3(0,0,0);\n    r.tMax = INF;\n    r.depth = 0;\n    return r;\n}\nstruct light{\n\tvec3 o;\n    vec3 col;\n};\n\nstruct scene{\n   \tshape shapes[N_SHAPES];\n\tlight lights[N_LIGHTS];\n};\n\n\n\nvec3 raycast(ray r, scene s){\n    \n    vec3 colFin = vec3(0,0,0);\n    vec3 colMul = vec3(1,1,1);\n    \n    while(r.depth<=DEPTH){ \n        vec3 col = vec3(0,0,0);\n        /*col = cameraRot[1]*0.5f + vec3(0.5f);\n        colFin+=col*colMul;\n        break;\n    */\n   \t\tbool hit = false;\n   \t\tintersection inter;\n   \t\tfor(int i = 0; i<N_SHAPES; i++){\n   \t\t    bool prev_hit = hit;\n            switch(s.shapes[i].type){\n                case SPHERE:\n                    hit = intersect_sphere(r, s.shapes[i], inter);\n                    break;\n                case PLANE:\n                    hit = intersect_plane(r, s.shapes[i], inter);\n                    break;\n                default:\n                    return vec3(0,0,0);\n\n            }\n   \t\t   \thit = hit || prev_hit;\n   \t\t}\n   \t\t\n   \t\t\n   \t\t\n   \t\tif(hit){\n            if(inter.material==1) {\n                vec3 pos = r.o + r.d*inter.t;\n                float base = (pos.z+iTime*0.6f);\n                if(int(sin(cos(base*3.1415126f*0.1)+13.12794*base)*0.3+base)%2==0){\n                    if(pos.z<5.0f){\n                    col = vec3(5,5,5);\n            \t    colFin+=col*colMul;\n                    break;\n                    }\n                }\n            }\n            \n                ray rr;\n            \trr.o =  r.o + inter.t*r.d;\n                \n            \trr.depth = r.depth+1;\n                rr.tMax = INF;\n            if(inter.material!=5){\n                vec3 norm = beckmannSample(getRandom(),getRandom(),inter.normal,ROUGHNESS);\n                norm = normalize(norm);\n                rr.d = normalize(r.d - 2.0f*dot(norm, r.d)*norm);\n                float r0 = 0.2f;\n                float costheta = 1.0f-abs(dot(norm,r.d));\n                float spec = r0+(1.-r0)*costheta*costheta*costheta*costheta*costheta;\n            \tcolMul = colMul*vec3(1,1,1)*spec;\n    \n            } else {\n                \n            \trr.d=cosineHemisphereSample(getRandom(),getRandom(), inter.normal);\n                \n            \tcolMul = colMul*vec3(0.4,0.4,0.4);\n            }\n            \n               r = rr;\n           \n        } else {\n        \tcol = vec3(0,0,0);//vec3(0.5,0.5,0.8)*(r.d.z+0.5f + 0.5f);\n            colFin+=col*colMul;\n            break;\n        }\n    }\n    return colFin;\n}\n\n\nfloat toSRGB(float d){\n\tif(d <=  0.0404482362771082\t)\n        return d/12.92;\n    else\n        return pow((d+0.055)/1.055, (2.4));\n}\n\nvec3 convertToACES(vec3 x){\n\t\n\tx.x = toSRGB(x.x);\n\tx.y = toSRGB(x.y);\n\tx.z = toSRGB(x.z);\n\n\tx = ACESInputMat*x;\n\tvec3 a = x * (x + 0.0245786f) - 0.000090537f;\n    vec3 b = x * (0.983729f * x + 0.4329510f) + 0.238081f;\n\tx =  a / b;\n\t\n\tx = ACESOutputMat*x;\n\treturn clamp(x,0.0f,1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\t\n    fragCoord = 2.0*(fragCoord/iResolution.xy)-vec2(1);\n    \n    fragPos = fragCoord;\n    scene s;\n    s.shapes[0] = make_plane(vec3(0.0f,0.0f,0.0f),vec3(0,0,1));\n    s.shapes[1] = make_plane(vec3(0.0f,0.0f,0.0f),vec3(0,1,0));\n    s.shapes[2] = make_plane(vec3(0.0f,0.0f,0.0f),vec3(1,0,0));\n    s.shapes[3] = make_plane(vec3(0.0f,3.0f,0.0f),vec3(0,-1,0));\n    s.shapes[4] = make_plane(vec3(3.0f,0.0f,0.0f),vec3(-1,0,0));\n    s.shapes[5] = make_sphere(vec3(0.7f,0.7f,0.7f), 0.7f);\n    \n    vec2 pixSize = vec2(2,2)/(iResolution.xy);\n\t\n    cameraPos.x = cameraPosBase.x + sin(iTime*0.9);\n    cameraPos.y = cameraPosBase.y + cos(iTime*1.3+0.5);\n    cameraPos.z = cameraPosBase.z + cos(iTime*0.4)+1.0f;\n    s.shapes[0].material = 1;\n    s.shapes[1].material = 1;\n    s.shapes[2].material = 1;\n\tvec3 up =vec3(0,0,1);\n \tvec3 at = normalize(vec3(0,0,0)-cameraPos);\n \tvec3 right = normalize(cross(up,-at));\n \tup = normalize(cross(-at,right));\n    cameraRot[0] = right;\n    cameraRot[1] = up;\n    cameraRot[2] = -at;\n \t\n    \n\t\n    float div = 1.0f/float(SAMPLES*SAMPLES);\n\n  \tray r = getRay(fragPos.xy);\n    vec3 acc = vec3(0,0,0);\n    for(int i = 0; i<SAMPLES; i++){\n\t\tfor(int j = 0; j<SAMPLES; j++){\n\t\t\tfloat eps1 = getRandom();\n\t\t\tfloat eps2 = getRandom();\n\t\t\tvec2 delta = vec2((float(i)+eps1)/float(SAMPLES), (float(j)+eps2)/float(SAMPLES));\n\t\t\tray r = getRay(fragCoord.xy+delta*pixSize);\n\t\t\tacc += raycast(r,s);\n\t\t}\n\t}\n   \t\t        \n   \tfragColor = vec4(convertToACES(acc*div), 1.0f);\n    \n\t\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}