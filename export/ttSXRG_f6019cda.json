{"ver":"0.1","info":{"id":"ttSXRG","date":"1566319926","viewed":509,"name":"Peachy Goo","username":"PixelFiddler","description":"Raymarching noise inside a sphere to create a peachy goo ball. Experimental stuff.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Carl-Mikael Lagnecrantz 2019\n// Much of this code was derived from shaders by Inigo Quilez (iq)\n\n// Raymarches noise inside a sphere to create a peachy goo ball\n\nvec3 intersectSphere( in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float radius )\n{\n\tvec3 v = rayPos - spherePos;\n\tfloat b = dot(v, rayDir);\n\tfloat c = dot(v, v) - radius * radius;\n\tfloat discr = b * b - c;\n    \n    // A negative discriminant corresponds to ray missing sphere \n    if (discr < 0.0) return vec3(0.0,0.0,discr);\n    \n    // Ray intersects sphere. Compute and return distances of both intersections, front and back of sphere\n    discr = sqrt(discr);\n\treturn vec3(-b - discr, -b + discr, discr);\n}\n\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nfloat noise(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 w = fract(x);\n\tvec3 u = w * w*(3.0 - 2.0*w);\n\tvec3 du = 6.0*w*(1.0 - w);\n\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\n\tfloat a = hash(n + 0.0);\n\tfloat b = hash(n + 1.0);\n\tfloat c = hash(n + 157.0);\n\tfloat d = hash(n + 158.0);\n\tfloat e = hash(n + 113.0);\n\tfloat f = hash(n + 114.0);\n\tfloat g = hash(n + 270.0);\n\tfloat h = hash(n + 271.0);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k3 = e - a;\n\tfloat k4 = a - b - c + d;\n\tfloat k5 = a - c - e + g;\n\tfloat k6 = a - b - e + f;\n\tfloat k7 = - a + b + c - d + e - f - g + h;\n\n    return k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x*u.y + k5 * u.y*u.z + k6 * u.z*u.x + k7 * u.x*u.y*u.z;\n}\n\nfloat fractalNoise(in vec3 x)\n{\n\tconst float scale = 3.0;\n    \n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfloat f = 1.0;\n\n    float centerAspect = x.x*x.x + x.y*x.y + x.z*x.z;\n    float centerFade = (1.0 - centerAspect) * (1.0 - centerAspect);\n    \n    // Run iterations of noise\n\tfor (int i = 0; i<5; i++)\n\t{\n\t\tvec3 pp = f * x*scale;\n\t\tpp.x += sin(iTime * 0.1 * (float(i) + 1.0));\n\t\tpp.y += cos(iTime * 0.3 * (float(i) + 1.0));\n\t\tpp.z += sin(iTime * 0.6 * (float(i) + 1.0));\n\t\tfloat n = noise(pp);\n\t\ta += b * n;           // accumulate values\t\t\n\t\tb *= 0.52;             // amplitude decrease\n\t\tf *= -1.3 - 2.2 * centerFade; // frequency increase\n\t}\n    \n    // Fade outer rim of sphere to nothing so that no part of the mesh will intersect the sphere hull\n\tcenterAspect = 1.0 - pow(centerAspect, 40.0);\n    \n    a = 1.0 - pow(1.0 - a, 1.3);\n    \n    // Add small surface bumbs\n    float smallBumps = noise(x * 130.0 + iTime * 4.0);\n    a += smallBumps * 0.06 * (1.0 - centerAspect);\n    \n\treturn a * centerAspect;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(fractalNoise(pos + eps.xyy) - fractalNoise(pos - eps.xyy),\n\t\tfractalNoise(pos + eps.yxy) - fractalNoise(pos - eps.yxy),\n\t\tfractalNoise(pos + eps.yyx) - fractalNoise(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\nvec3 background(vec2 uv)\n{\n    vec2 uvScreen = (uv + 1.0) * 0.5; // Convert from -1...1 to 0...1\n    vec3 back = vec3(0.5, 0.6, 0.6);\n    back += (vec3(0.6, 0.8, 0.95) - back) * uvScreen.y;\n    back += vec3(1.0 - pow(1.0 - length(uv), 2.0)) * 0.2;\n    back += (1.0 - clamp(length(uv), 0.0, 1.0)) * 0.3;\n    \n    return back;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec2 tminmax, vec2 uv)\n{\n    // Raymarch\n\tconst int numIter = 96;\n\tfloat depth = tminmax.x;\n\tint hasSetDepth = 0;\n    float accum = 0.0;\n\tfor (int i = 0; i<numIter; i++)\n\t{\n        float loopVal = float(i) / float(numIter);\n        loopVal *= loopVal * loopVal * loopVal; // Move in smaller steps in the beginning to counter banding\n        float t = tminmax.x + (tminmax.y - tminmax.x) * loopVal;\n        \n\t\tvec3 pos = ro + t * rd;\n        \n        // Get noise value\n\t\tfloat noiseVal = fractalNoise(pos);\n        \n        // If the noise value is above 0.55 it counts as a surface hit\n\t\tif (noiseVal > 0.55 && hasSetDepth == 0)\n\t\t{\n\t\t\tdepth = t;\n\t\t\thasSetDepth = 1;\n\t\t}\n        accum += noiseVal * 2.0; // Accumulate raymarching noise values\n\t}\n\tif (hasSetDepth == 0) return background(uv); // There was no hit\n    \n    \n\tvec3 sectPos = ro + rd * depth; // Intersection pos\n    vec3 norm = calcNormal(sectPos); // Normal\n    \n    // Distance from sphere center values\n    float centerAspect = length(sectPos);\n    float centerAspectSquared = centerAspect * centerAspect;\n\n    // Lighting\n    vec3 lightDir = vec3(0.0, -1.0, 0.0); // Top light\n\tvec3 diffuse = clamp((dot(norm, lightDir)),0.0, 1.0) * vec3(0.4, 0.8, 0.9);\n    diffuse *= diffuse * 1.5;\n    vec3 lightDir2 = normalize(vec3(1.0, 0.0, 1.0)); // Back light\n    vec3 diffuse2 = clamp((dot(norm, lightDir2)),0.0, 1.0) * vec3(0.2, 0.8, 0.9);\n    diffuse2 *= centerAspectSquared * centerAspect;\n    diffuse += diffuse2 * 2.5;\n    \n    // Specular\n\tvec3 camToPos = normalize(sectPos - ro);\n\tvec3 h = normalize(lightDir + camToPos);\n\tfloat nDotH = clamp((dot(norm, h)), 0.0, 1.0);\n\tfloat specular = pow(nDotH, 40.0); // Power controls glossiness\n\tdiffuse += specular * 0.5;\n    \n    // Accumulated raymarch values simulates some smoke\n    accum /= float(numIter);\n    vec3 back = background(uv);\n    vec3 smoke = back + (vec3(accum) - back) * accum * (1.0 - pow(centerAspect, 30.0));\n    \n    // Calculate inner glow\n    float innerGlow = 1.0 - clamp((centerAspect / 0.75), 0.0, 1.0);\n    \n    centerAspect *= centerAspectSquared;\n    centerAspectSquared = centerAspect * centerAspect;\n    \n    // Color adjustments\n\tvec3 finalCol = diffuse * vec3(0.36, 0.28, 0.28);\n\tfinalCol += vec3(1.0, 0.4, 0.2) * centerAspect;\n\tfinalCol += vec3(1.0, 0.8, 0.6) * centerAspectSquared * 0.5;\n    \n    // Darken towards middle\n    finalCol *= 0.3 + 0.7 * centerAspect;\n    \n    // Inner glow\n    finalCol += vec3(1.0, 0.35, 0.25) * innerGlow * 1.5;\n    finalCol += vec3(1.0, 0.6, 0.25) * innerGlow * (1.0 - centerAspect) * (1.0 - centerAspect);\n    \n    // Smoke added from raymarch\n    float camDot = 1.0 - pow(clamp(dot(rd, norm), 0.0, 1.0), 3.0); // Fresnel\n    float smokeBlend = 0.7 * camDot * centerAspectSquared;\n    finalCol += (smoke - finalCol) * smokeBlend;\n    \n    // Fade outer rim of sphere to background slightly\n    float rimBlend = pow(length(uv), 6.0);\n    finalCol += (back - finalCol) * rimBlend;\n\n    // Some contrast\n    finalCol = (finalCol - 0.8) * 1.2 + 0.8;\n    \n\treturn clamp(finalCol, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera coordinates (from -1 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    // Setup camera\n    vec3 ro = vec3(0.0, 1.6, 1.6 );\n\tvec3 ta = vec3(0.0);\n\t\n    // Camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0, 1.0, 0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( uv.x*cu + uv.y*cv + 1.7*cw );\n    \n    // Intersect sphere\n    vec3 sect = intersectSphere(ro, rd, vec3(0.0, 0.0, 0.0), 1.0);\n    \n    // Raymarch\n    vec3 col;\n\tif (sect.z < 0.0) col = background(uv);\n    else col = raymarch(ro, rd, sect.xy, uv);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}