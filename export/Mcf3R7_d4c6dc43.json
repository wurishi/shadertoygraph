{"ver":"0.1","info":{"id":"Mcf3R7","date":"1702880327","viewed":26,"name":"polar plot","username":"maxwellcoffee","description":"Breathe along","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["breathe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Maxwell Josephson 2023 and Nikos Papadopoulos, 4rknova / 2019 \n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI  3.14159265359\n\n#define ITERATIONS (1015)     // Number of iterations\n#define AMPLITUDE  (0.80)\t// Polar radius multiplier\n#define PERIOD     (0.40)   // Polar angle multiplier (i.e. repetitions)\n#define PERIOD_MUL (1.00)   // Angular offset modifier\n#define SCALE      (1.50)   // Zoom factor\n#define RING_MIN   (0.98)   // Ring shape lower boundary\n#define RING_MAX   (1.00)   // Ring shape upper boundary\n#define FADE       (3.50)   // Fading factor\n#define BRIGHTNESS (0.25)   // Brightness modifier\n#define CONTRAST   (0.85)   // Contrast modifier\n\nfloat ring(float r) { return step(r, RING_MAX) - step(r, RING_MIN); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the aspect corrected normalized 2D coords\n\tvec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Calculate the polar coordinates and scale\n    float r     = SCALE  * length(p);\n    float theta = PERIOD * (iTime / 1.) * atan(p.y, p.x);\n        \n    // This is the grayscale value (gradient) of the pixel\n    float f = 0.0;\n    \n    // In each iteration calculate the distance from the shape\n    // and accumulate the value to the pixel's gradient\n    for (int i = 1; i < ITERATIONS; ++i) {\n        float k = float(i)/float(ITERATIONS);\n        \n        // For each iteration, offset the angle (i.e. rotate the shape)\n        // Scale the radius for each iternation and offset the value by\n        // a sine wave of the polar angle.\n    \tfloat w = r/k + AMPLITUDE * (sin(iTime)) * sin(theta + PI * PERIOD_MUL / k);\n        \n        // Calculate the distance from the shape and fade the\n        // value based on a constant value, the polar radius and\n        // the iteration number. Accumulate value for current pixel.\n        f += ring(w) * BRIGHTNESS * pow(k,FADE) * r;\n    }\n    \n    fragColor = vec4(vec3(pow(f,CONTRAST)), 1);\n}","name":"Image","description":"","type":"image"}]}