{"ver":"0.1","info":{"id":"3tfBRM","date":"1596318530","viewed":1088,"name":"Infinite Raindrops ","username":"chetgnegy","description":"Rain droplets on an arbitrary-sized body of water.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["water","rain","ripple","lake","pond"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I've been playing around with water droplets lately. You can sort of see the \n// trail of evidence in the two shaders below. The original Lake Drops shader \n// works on a very limited space (which is fine because that's all the camera\n// was pointing at). I wanted to make it work over the entire body of a big \n// lake without appearing periodic in any fake-looking ways.\n//\n// Basically the idea is to modulo the space, which of course looks\n// terrible if you aren't careful. Each ripple (they are still time periodic as\n// in the original) should have it's own modulo grid and the grid size shouldn't\n// be the same for all ripples (also the ripple has to be in the center or you\n// get clipping as it grows. Making the grid size a random function of the\n// loop indices works well. I also stagger the start time within each cell by\n// making the start time offset a random function of which \"cell\" in the grid the \n// ripple was in. With a bit more work, I could probably make the start position\n// vary with each time loop, but it looks convincing enough as it is.\n//\n// You can change how hard it is raining with the cursor.\n//\n// Originally [SH17A] Lake Drops deobfuscated by me.\n// https://www.shadertoy.com/view/wtsfzN\n// which was originally [SH17A] Lake Drops by fizzer.\n// https://www.shadertoy.com/view/MdjBDh\n//\n// WTFPL License.\n\n#define PI 3.1415936535\n\nhighp float rand(vec2 co) {  // https://stackoverflow.com/questions/4200224\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat Square(float x) { return x * x; }\n\nvoid mainImage(out vec4 color,vec2 fragCoord) {\n  // Goes from 0 to 1.\n  float intensity = iMouse.x / iResolution.x;\n  vec2 screen_window = fragCoord / iResolution.x * 2.0 - 1.0; // x goes from [-1 to 1].\n  // This is used to accumulate over all ripples at the fragment location.\n  vec2 displacement = vec2(0.0);\n  // Same ripples over and over again, they repeat with this frequency.\n  float loop_time = 1.6;\n  // Lower numbers make wider ripples.\n  float ripple_width_inverse = 40.0;\n  float limits = PI / ripple_width_inverse;\n  // Increase number of ripples. It can be cheaper to decrease the loop time.\n  int num_ripples = 40;\n  // The overall size of the ripples.\n  float scale = 0.05;\n\n  float strength_control = 5.0 + (float(num_ripples) - 5.0) * intensity;\n\n  vec2 screen_window_ripple = screen_window / scale;\n  for (float i = 0.0; i < float(num_ripples); ++i) {\n    // Distance from the origin of a ripple.\n    vec2 origin = vec2(919.,154.) * i;\n    // Make cells that are at least the max size of the ripples to prevent weird\n    // overlap artifacts. Use a different cell size for each cell.\n    float min_mirror_size = 2.0 * loop_time;\n    float mirror_size = (1.0 + rand(vec2(i * 0.2, i * 0.17))) * min_mirror_size;\n    // Make the ripple map periodic.\n    float mirror_correction = mirror_size / 2.0;\n    vec2 corr = origin - mirror_correction;\n    vec2 mirrored_window = mod(screen_window_ripple - corr, mirror_size) + corr;\n    // Get a number that corresponds to the quantized cell so we can give each\n    // mirrored version a different time offset.\n    vec2 cell_num = floor((screen_window_ripple - corr) / mirror_size);\n\n    vec2 dist = mirrored_window - origin;\n    // Increasing this value staggers the creation time of ripples. For zero, they all create at the\n    // same time.\n    float time_offset = i * 0.12 + 23.0 * rand(cell_num);\n    float t = length(dist) - mod(time_offset + iTime, loop_time);\n    // Only show one period of each sine wave.\n    float t_one_period = clamp(t, -limits, limits);\n    // Waves decay with time. Square denominator so waves decay more with time.\n    // Add a small offset to prevent a divide by zero artifact.\n    vec2 amplitude = dist / (Square(dot(dist, dist)) + 1e-3);\n    // https://www.desmos.com/calculator/nhezxj5adb\n    amplitude *= max(0.0, min(0.2 * (strength_control -  i + 1.0), 1.0));\n    displacement += amplitude * sin(ripple_width_inverse * t_one_period);\n  }\n\n  color = 0.7 * texture(iChannel0, vec3(displacement - 10.0 * screen_window, 5.0)) +\n          0.4 * texture(iChannel1, 3.0 * screen_window);\n  // View only the displacement.\n  // color = vec4(vec3(displacement + 0.5,0.5), 1);\n}","name":"Image","description":"","type":"image"}]}