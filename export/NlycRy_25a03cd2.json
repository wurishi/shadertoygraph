{"ver":"0.1","info":{"id":"NlycRy","date":"1668315469","viewed":92,"name":"separation828767634646","username":"HaleyHalcyon","description":"a","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TURN = 2. * acos(-1.);\n\n#define DITHER 0\n#define XYLOOP 2\n#define STEREO 1\n#define ADDITIVE 1\n\n#define R_OUT 0.25\n#define THICKNESS 0.08\n\nvec2 angleVec(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat square(vec2 uv, float angle) {\n    vec2 a = angleVec(angle);\n    vec2 b = a.yx * vec2(1., -1.);\n    return max(abs(dot(uv, a)), abs(dot(uv, b)));\n}\n\nvec3 hue(float x) {\n    x = mod(x, 6.);\n    return clamp(vec3(\n        abs(x - 3.) - 1.,\n        -abs(x - 2.) + 2.,\n        -abs(x - 4.) + 2.\n    ), 0., 1.);\n}\n\n#if DITHER != 0\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\n\nvec3 posterize(vec3 col, float thres) {\n    const float steps = 1.;\n    return (\n      floor(\n        col * steps\n      ) + step(\n        vec3(thres),\n        fract(col * steps)\n      )\n    ) / steps;\n}\n#endif\n#define LOOPLEN (1. / 6.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    uv *= 0.17;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    float t = fract(iTime * LOOPLEN);\n    \n    const float LAYERS = 12.;\n    const float LAYERS_PER_LOOP = 6.;\n    float firstLayer = floor(t * LAYERS_PER_LOOP);\n    \n    const float ROT_PER_LAYER = TURN / LAYERS_PER_LOOP / -4.;\n    const float SCALE_PER_LAYER = 6.;\n    #if STEREO\n    const vec2 SEP = vec2(0.035, 0.);\n    #endif\n           \n    const float ROT_ALL = 3. * TURN / 4.;\n    float rotAll = ROT_ALL * t;\n    \n    for (float layer = LAYERS; layer > -1.; layer--) {\n        float z = layer + fract(t * LAYERS_PER_LOOP);\n        float layerAlpha = clamp(-0.9 + exp2((LAYERS - z) / LAYERS), 0., 1.);\n        vec2 uvScale = uv * (z * SCALE_PER_LAYER + sqrt(z) * -0.6);\n#if XYLOOP == 1\n        uvScale = fract(uvScale + 0.5) - 0.5;\n#elif XYLOOP == 2\n        uvScale = (1. - abs(1. - mod(uvScale + 0.5, 2.))) - 0.5;\n#endif\n        float sqL = square(\n#if STEREO\n            uvScale - SEP,\n#else\n            uvScale,\n#endif\n            z * ROT_PER_LAYER + rotAll\n        );\n        float sqAaL = fwidth(sqL) * 0.5;\n        float sqMaskL = smoothstep(\n            sqAaL, -sqAaL, sqL - R_OUT\n        ) * smoothstep(\n            -sqAaL, sqAaL, sqL - R_OUT + THICKNESS * layerAlpha\n        );\n#if STEREO\n        float sqR = square(\n            uvScale + SEP,\n            z * ROT_PER_LAYER + rotAll\n        );\n        \n        float sqAaR = fwidth(sqR) * 0.5;\n        float sqMaskR = smoothstep(\n            sqAaR, -sqAaR, sqR - R_OUT\n        ) * smoothstep(\n            -sqAaR, sqAaR, sqR - R_OUT + THICKNESS * layerAlpha\n        );\n#endif\n        \n        vec3 colLayer = hue(layer - firstLayer);\n#if ADDITIVE\n        col = max(col, (\n            sqMaskL * colLayer\n#if STEREO\n            + sqMaskR * (1. - colLayer)\n#endif\n        ));\n#else\n        col = mix(\n            col,\n            colLayer,\n            sqMaskL\n        );\n#endif\n\n        //col = mix(col, sqMaskL * colLayer + sqMaskR * (1. - colLayer), layerAlpha);\n    }\n    \n    col = pow(min(vec3(1.), col * 1.25), vec3(2.));\n    \n#if DITHER == 1\n    float thres = (\n    crosshatch(fragCoord)\n    + crosshatch(fragCoord / 2.) / 4.\n    + 1./32.\n    //+ crosshatch(fragCoord / 4.) / 16.\n    //+ crosshatch(fragCoord / 8.) / 64.\n    );\n    col = posterize(col, thres);\n#elif DITHER == 2\n    col = posterize(col, .5);\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}