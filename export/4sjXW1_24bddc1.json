{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Sphere mapping by nimitz (twitter: @stormoid)\n\n/*\n\tLittle demo of different sphere uv mapping techniques.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 tex(in vec2 p)\n{\n    float frq =50.3;\n    p += 0.405;\n    return vec3(1.)*smoothstep(.9, 1.05, max(sin((p.x)*frq),sin((p.y)*frq)));\n}\n\n//Cube projection, cheap to compute and not too much deformation\nvec3 cubeproj(in vec3 p)\n{\n    vec3 x = tex(p.zy/p.x);\n    vec3 y = tex(p.xz/p.y);\n    vec3 z = tex(p.xy/p.z);\n    \n    //simple coloring/shading\n    x *= vec3(1,0,0)*abs(p.x) + p.x*vec3(0,1,0);\n    y *= vec3(0,1,0)*abs(p.y) + p.y*vec3(0,0,1);\n    z *= vec3(0,0,1)*abs(p.z) + p.z*vec3(1,0,0);\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\n//HEALPix  (debugged and cleaned from: http://www.cse.cuhk.edu.hk/~ttwong/papers/spheremap/spheremap.html)\n//Has several advantages, might not be as versatile as cubemapped.\nvec3 healpix(vec3 p)\n{\n\tfloat a = atan(p.z, p.x) * 0.63662; \n\tfloat h = 3.*abs(p.y);\n\tfloat h2 = .75*p.y;\n\tvec2 uv = vec2(a + h2, a - h2);\n\th2 = sqrt(3. - h);\n\tfloat a2 = h2 * fract(a);\n    uv = mix(uv, vec2(-h2 + a2, a2), step(2., h));    \n  \t\n    vec3 col = tex(uv);\n    col.x = a*0.5;\n    return hsv2rgb(vec3(col.x,.8,col.z));\n}\n\n//Triplanar, not really a sphere mapping, but adding it for completeness sake\nvec3 tpl(in vec3 p)\n{\n\tvec3 x = tex(p.yz);\n\tvec3 y = tex(p.zx);\n\tvec3 z = tex(p.xy);\n    \n    //simple coloring/shading\n    x *= vec3(1,0,0)*abs(p.x) + p.x*vec3(0,1,0);\n    y *= vec3(0,1,0)*abs(p.y) + p.y*vec3(0,0,1);\n    z *= vec3(0,0,1)*abs(p.z) + p.z*vec3(1,0,0);\n    \n    p = normalize(max(vec3(0),abs(p)-.6));\n    return x*p.x + y*p.y + z*p.z;\n}\n\n//Spherical coordinates, very heavy deformation on the poles\nvec3 sphproj(in vec3 p)\n{\n    vec2 sph = vec2(acos(p.y/length(p)), atan(p.z,p.x));\n    \n    vec3 col = tex(sph*.9);\n    col.x = sph.x*0.4;\n    return hsv2rgb(vec3(col.x,.8,col.z));\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(time*.4+um.x*5.);\n    mat2 my = mm2(time*0.3+um.y*5.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float sel = mod(floor(time*0.3),4.);\n    \n    float t = iSphere(ro,rd);\n    vec3 col = vec3(0);\n    if (sel == 0.) col = cubeproj(rd)*1.1;\n    else if (sel == 1.) col = tpl(rd)*1.2;\n    else if (sel == 2.) col = healpix(rd);\n    else col = sphproj(rd);\n    \n        if (t > 0.)\n    {\n    \tvec3 pos = ro+rd*t;\n    \tif (sel == 0.) col = cubeproj(pos)*1.1;\n        else if (sel == 1.) col = tpl(pos)*1.2;\n        else if (sel == 2.) col = healpix(pos);\n        else col = sphproj(pos);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjXW1","date":"1411534703","viewed":3578,"name":"Sphere mappings","username":"nimitz","description":"I couldn't find an implementation of procedural cubemaps here on shadertoy, so I did a little study on the different options. For further study: Is there a cheap way to do Icosahedral projection? (and geodesic grids). Drag to rotate.","likes":107,"published":1,"flags":0,"usePreview":0,"tags":["3d","uv","mapping","technique","healpix","quadcube"],"hasliked":0,"parentid":"","parentname":""}}