{"ver":"0.1","info":{"id":"Ddt3D4","date":"1677335023","viewed":134,"name":"Buddahbrot","username":"boehmseb","description":"Renders the mandelbrot fractal with the buddahbrot algorithm.\nNot as fast as https://www.shadertoy.com/view/Xd3fW4, but in color.\n\nConfiguration options are in Common.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Denoise & output to screen\n    fragColor = smartDeNoise(iChannel0, uv, 5.0, 2.0, .100);\n    //fragColor = texture(iChannel0, uv);\n    fragColor = pow(fragColor, vec4(1.0 / GAMMA));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Checks whether pos is in the box defined by bottomLeft and topRight\nbool isHit(vec2 pos, vec2 bottomLeft, vec2 topRight) {\n    vec2 s = step(bottomLeft, pos) - step(topRight, pos);\n    return (s.x * s.y) == 1.0;   \n}\n\nint mandelbrot(vec2 pos0, vec2 bottomLeft, vec2 topRight, int maxIterations) {\n    vec2 pos = pos0;\n    int iterations = 0;\n    int selfHits = 0;\n    for (; iterations < maxIterations && dot(pos, pos) <= 4.0; iterations++) {\n        pos = mat2(pos, -pos.y, pos.x) * pos + pos0;\n        \n        if (isHit(pos, bottomLeft, topRight)) {\n            selfHits += 1;\n        }\n    }\n    \n    // return number of self hits if escaped or 0 otherwise\n    if (iterations < maxIterations) {\n        return selfHits;\n    }\n    return 0;\n}\n\n/* Trace some buddahbrot samples.\n *\n * Since we can only write a single datapoint each time,\n * each frag traces the same samples and records the number of self-hits.\n * We use a pre-cached mandelbrot set to discard samples that lie within the set.\n */\nivec3 buddahbrot(vec2 selfPos, vec2 delta) {\n    vec2 bottomLeft = selfPos - (delta / 2.0);\n    vec2 topRight = selfPos + (delta / 2.0);\n    ivec3 numHits = ivec3(0);\n    \n    for (int i = 0; i < SAMPLES_PER_FRAME; i++) {\n        vec2 pos0 = rand2();\n        vec3 vals = texture(iChannel1, pos0).rgb;\n        pos0 = pos0 * 2.0 * SAMPLE_RADIUS - vec2(SAMPLE_RADIUS, SAMPLE_RADIUS);\n        \n        if (vals.r == 1.0) {\n            numHits.r += mandelbrot(pos0, bottomLeft, topRight, MAX_ITERATIONS.r);\n        }\n#ifdef USE_COLOR\n        if (vals.g == 1.0) {\n            numHits.g += mandelbrot(pos0, bottomLeft, topRight, MAX_ITERATIONS.g);\n        }\n        if (vals.b == 1.0) {\n            numHits.b += mandelbrot(pos0, bottomLeft, topRight, MAX_ITERATIONS.b);\n        }\n#endif\n    }\n    \n    return numHits;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // we need to have the same random points for each fragment\n    rng_initialize(vec2(0, 0), iFrame);\n\n    // calculate fragment coordinates in \"mandelbrot-space\"\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 size = vec2(VIEWPORT_SIZE * aspect, VIEWPORT_SIZE);\n    vec2 delta = size / iResolution.xy;\n    vec2 coords = uv * size - size/2. - VIEWPORT_CENTER;\n    \n    vec3 numHits = vec3(buddahbrot(coords, delta));\n    vec3 data = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb + numHits;\n#ifndef USE_COLOR\n    data = data.rrr;\n#endif\n    fragColor = vec4(data,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// buddahbrot parameters\n#define SAMPLE_RADIUS 2.\n#define SAMPLES_PER_FRAME 1000\n#define USE_COLOR\n#define MAX_ITERATIONS ivec3(1000, 100, 10)\n#define VIEWPORT_CENTER vec2(0.5, 0.)\n#define VIEWPORT_SIZE 2.\n#define VIEWPORT_ROTATION_RAD \n\n#define GAMMA 1.\n\n\n\n//------------------------------------------------------------------------------\n// RNG: https://www.shadertoy.com/view/wltcRS\n//------------------------------------------------------------------------------\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame) {\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v) {\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nvec2 rand2() {\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\n\n//------------------------------------------------------------------------------\n// Denoiser: https://www.shadertoy.com/view/3dd3Wr\n//------------------------------------------------------------------------------\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//  Copyright (c) 2018-2019 Michele Morrone\n//  All rights reserved.\n//\n//  https://michelemorrone.eu - https://BrutPitt.com\n//\n//  me@michelemorrone.eu - brutpitt@gmail.com\n//  twitter: @BrutPitt - github: BrutPitt\n//  \n//  https://github.com/BrutPitt/glslSmartDeNoise/\n//\n//  This software is distributed under the terms of the BSD 2-Clause license\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\n\n//  smartDeNoise - parameters\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//  sampler2D tex     - sampler image / texture\n//  vec2 uv           - actual fragment coord\n//  float sigma  >  0 - sigma Standard Deviation\n//  float kSigma >= 0 - sigma coefficient \n//      kSigma * sigma  -->  radius of the circular kernel\n//  float threshold   - edge sharpening threshold \n\nvec4 smartDeNoise(sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold) {\n    float radius = round(kSigma*sigma);\n    float radQ = radius * radius;\n    \n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n    \n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n    \n    vec4 centrPx = texture(tex,uv);\n    \n    float zBuff = 0.0;\n    vec4 aBuff = vec4(0.0);\n    vec2 size = vec2(textureSize(tex, 0));\n    \n    for(float x=-radius; x <= radius; x++) {\n        float pt = sqrt(radQ-x*x);  // pt = yRadius: have circular trend\n        for(float y=-pt; y <= pt; y++) {\n            vec2 d = vec2(x,y);\n\n            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI; \n            \n            vec4 walkPx =  texture(tex,uv+d/size);\n\n            vec4 dC = walkPx-centrPx;\n            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n                                 \n            zBuff += deltaFactor;\n            aBuff += deltaFactor*walkPx;\n        }\n    }\n    return aBuff/zBuff;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int mandelbrot(vec2 pos0, int maxIterations) {\n    vec2 pos = pos0;\n    int iterations = 0;\n    for (; iterations < maxIterations \n         && dot(pos, pos) <= 4.0; iterations++) {\n        pos = mat2(pos, -pos.y, pos.x) * pos + pos0;\n    }\n    return iterations;\n}\n\n/* Pre-calculate mandelbrot set.\n * Sampling random coordinates between (0,0) and (1,1) from this buffer\n * yields whether the sample transformed to our sample space lies in the set or not.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        // calculate fragment coordinates in \"mandelbrot-space\"\n        vec2 uv = fragCoord / iResolution.xy;\n        vec2 coords = uv * 2. * SAMPLE_RADIUS - vec2(SAMPLE_RADIUS, SAMPLE_RADIUS);\n        \n        vec3 hits;\n        hits.r = float (clamp(MAX_ITERATIONS.r - mandelbrot(coords, MAX_ITERATIONS.r), 0, 1));\n        hits.g = float (clamp(MAX_ITERATIONS.g - mandelbrot(coords, MAX_ITERATIONS.g), 0, 1));\n        hits.b = float (clamp(MAX_ITERATIONS.b - mandelbrot(coords, MAX_ITERATIONS.b), 0, 1));\n        fragColor = vec4(hits, 1.0);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float FACTOR = 4.; // > 1\n\n#define SIZE(N) pow(FACTOR, N)\n#define LEVEL(S) log((FACTOR - 1.) * (S) + 1.) / log(FACTOR)\n#define BORDER(L) (SIZE(L + 1.) - 1.) / (FACTOR - 1.)\n\n/* Piplined max reduction of buddahbrot samples\n * based on this: https://www.shadertoy.com/view/wsj3z1\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float resolutionMax = max(iResolution.x, iResolution.y);\n    \n    // smallest power of 4 that encapsulates the image\n    float maxLevel = ceil(LEVEL(resolutionMax)) - 1.;\n    float maxLevelWidth = SIZE(maxLevel);\n    float rightBorder = BORDER(maxLevel);\n    \n    // current level and size\n    float currentLevel = floor(LEVEL(fragCoord.x));\n    float currentSize = SIZE(currentLevel);\n    \n    // left and right of the current cell, using geometric sequence sum formula\n    float left = BORDER(currentLevel - 1.);\n    float right = BORDER(currentLevel);\n    \n    if (fragCoord.y < currentSize && fragCoord.x <= rightBorder){\n        // shift x coordinate to left border\n        fragCoord.x -= left;\n        // initialize max value\n        vec3 maxVal  = vec3(0., 0., 0.);\n        // loop over area\n        for(float x = 0.; x < FACTOR; x++){\n            for(float y = 0.; y < FACTOR; y++){\n                vec2 delta = vec2(x, y);\n                vec3 currentVal;\n                if (currentLevel == maxLevel){\n                    // sample from the input\n                    vec2 inputUV = (fragCoord * FACTOR + delta) / iResolution.xy;\n                    currentVal = texture(iChannel0, inputUV).rgb;\n                } else {\n                    // sample from previous level\n                    vec2 sampleUV = (vec2(right, 0) + floor(fragCoord) * FACTOR + delta) / iResolution.xy;\n                    currentVal = texture(iChannel1, sampleUV).rgb;\n                }\n                maxVal = max(maxVal, currentVal);\n            }\n        }\n        \n        fragColor = vec4(maxVal, 1.0);\n    } else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Normalize data with max value to a 0 to 1 range.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 data = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec3 maxVal = texture(iChannel1, vec2(.5)/iResolution.xy).rgb;\n    fragColor = vec4(data / maxVal, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}