{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define OCTAVES  8.0\n\n#define MAX_STEPS  32\n#define THRESHOLD .01\n\nconst float fogDensity = 0.25;\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat interFunc2(float t) {\n   return 6.0*pow(t, 5.0) - 15.0 * pow(t, 4.0) + 10.0 * pow(t, 3.0);\n}\n\n// Rough Value noise implementation\nfloat valueNoiseSimple(vec2 vl) {\n   float minStep = 1.0 ;\n\n   vec2 grid = floor(vl); // Left-bottom corner of the grid\n   vec2 gridPnt1 = grid;\n   vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);\n   vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);\n   vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);\n\n    // Removed perlinNoise, Value noise is much faster and has good enough result\n    float s = rand2(grid); // 0,0\n    float t = rand2(gridPnt3); // 1,0\n    float u = rand2(gridPnt2); // 0,1\n    float v = rand2(gridPnt4); // 1,1\n    \n    float x1 = smoothstep(0., 1., fract(vl.x));\n    float interpX1 = mix(s, t, x1);\n    float interpX2 = mix(u, v, x1);\n    \n    float y = smoothstep(0., 1., fract(vl.y));\n    float interpY = mix(interpX1, interpX2, y);\n    \n    return interpY;\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 1.2;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance; // Actually the size of the grid and noise frequency\n        //frequency *= persistance;\n    }\n    return rez;\n}\n\nfloat scene(vec3 a) {\n   \n   float zVal = fractalNoise(vec2(a.x- 5., a.z ));\n   return a.y + 0.2 + sin(zVal / 2.); // add smoothing noise to the plane\n   \n   //return min(length(a - vec3(0., -0.015, 0.)) - .25, a.y + 0.2);\n}\n\nvec3 snormal(vec3 a) {\n   vec2 e = vec2(.0001, 0.);\n   float w = scene(a);\n    /*\n       return normalize(vec3(\n       scene(a+e.xyy) - scene(a-e.xyy),\n       scene(a+e.yxy) - scene(a-e.yxy),\n       scene(a+e.yyx) - scene(a-e.yyx) ));\n*/\n\n   return normalize(vec3(\n       scene(a+e.xyy) - w,\n       e.x,\n       scene(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D, out float hill) {\n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = scene(O + D*L);\n        L += d;\n        \n        if (d < THRESHOLD*L) // Adaptive threshold \n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\nfloat occluded(vec3 p, float len, vec3 dir) {\n    return max(0., len - scene(p + len * dir));\n}\n\nfloat occlusion(vec3 p, vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .2;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    // Basically we should count number of intersections to use\n    // Monte-Carlo approximation. But, we can use information\n    // about distance to the surface. \n    return (1. - min(rez, 1.));\n}\n\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    vec3 color = texture(iChannel0, p.xz *.5 + .5).rgb;//vec3(.0, .5, .0);//\n    \n    vec3 ambient = color;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    diffuse = clamp(diffuse, 0., 1.) * 0.75;\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n    \n    spec = pow(spec, 0.3 * 60.); // the main power of material:)\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * vec3(1.0, 1.0, .9);\n    \n    return Ispec + diffuse + ambient * occlusion(p, normal);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 sunPos = vec2(.845 * iResolution.x / iResolution.y, .2);\n\n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = scene(O) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -1.0)); //fov\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157); // nice blue color\n    vec3 sunColor = vec3(1.0, 1.0, .975);\n    vec3 sunGalo = vec3(.7, .7, .5);\n\n    // Background color\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n    float sunDst = length(centered_uv - sunPos) ;\n    float sunFluctuation = valueNoiseSimple(centered_uv - sunPos + timeOffset);\n    sunFluctuation = clamp(sunFluctuation * .25, 0.1, .2);\n    \n    float galoVal= exp(-pow(sunDst * 0.35, 1.15));\n    float val  = clamp(1. / (sunDst *110.5), 0., 1.);\n    \n    bgColor = mix(bgColor, sunColor*val + (galoVal + sunFluctuation) * sunGalo, galoVal + .5);\n    \n    if (hill >= 0.2) {\n        float cloudCeil = centered_uv.y * .5 - .085;\n        vec2 cloudCoord = centered_uv / cloudCeil;\n        cloudCoord.y += timeOffset / 4.;\n        cloudCoord.x /= pow(iResolution.x / iResolution.y, 3.5);\n        float cloudNoise = -2. + 2. * fractalNoise(cloudCoord + 3.5);\n        resColor = (bgColor + clamp(cloudNoise, 0., 1.) );\n        resColor = mix(bgColor, resColor, clamp(cloudCeil, 0., 1.));\n    } else {\n        vec3 lightPos = vec3(5., 3. -h, -2. - timeOffset);\n        vec3 normal = snormal(coord);\n        \n        resColor = enlight(coord, normal, O, lightPos);\n    \n        // Calc some fog\n    \tfloat fogFactor = exp(-pow(abs(fogDensity * (coord.z - 1.5 + timeOffset)), 4.0));\n    \tfogFactor = clamp(fogFactor, 0.0, 1.0);\n    \tresColor = mix(bgColor, resColor, fogFactor);\n    }\n\n    fragColor = vec4(resColor, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBXWy","date":"1415452107","viewed":7551,"name":"After rain","username":"FatumR","description":"Mountains (correct clouds scattering should be added)","likes":33,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""}}