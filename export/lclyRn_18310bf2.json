{"ver":"0.1","info":{"id":"lclyRn","date":"1720717739","viewed":31,"name":"flower power (claude generated)","username":"_bm","description":"this shader was written using Claude ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["claude"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec3 applyHueShift(vec3 color, float hueShift) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hueShift);\n    return vec3(color * cosAngle + cross(k, color) * sin(hueShift) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nfloat petal(vec2 uv, float angle, float size, float time) {\n    float oscillation = sin(time * 2.0 + angle * 2.0) * 0.1;\n    vec2 offset = vec2(cos(angle), sin(angle)) * oscillation;\n    uv = uv - offset;\n    \n    uv = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n    float d = length(uv);\n    float r = size * (1.0 - 0.5 * sin(atan(uv.y, uv.x) * 8.0));\n    return smoothstep(r, r - 0.05, d);\n}\n\nvec3 flower(vec2 uv, float size, float time, bool inverse, float hueShift) {\n    vec3 col = vec3(0.0);\n    \n    // Center circle\n    float d = length(uv);\n    col += applyHueShift(vec3(1.0, 0.8, 0.2), hueShift) * smoothstep(0.1 * size, 0.09 * size, d);\n    \n    // Petals\n    float numPetals = 6.0;\n    for (float i = 0.0; i < numPetals; i++) {\n        float angle = i * 2.0 * PI / numPetals;\n        col += applyHueShift(vec3(0.9, 0.4, 0.7), hueShift) * petal(uv, angle, 0.4 * size, time);\n    }\n    \n    return inverse ? 1.0 - col : col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    vec3 finalColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    // Animate the hue shift\n    float globalHueShift = iTime * 0.3;\n    \n    // Create nested flowers\n    int numLayers = 5;\n    for (int i = 0; i < numLayers; i++) {\n        float size = 1.0 - float(i) * 0.2;\n        bool inverse = (i % 2 == 1);\n        float layerHueShift = globalHueShift + float(i) * 0.5; // Vary hue slightly per layer\n        vec3 layerColor = flower(uv / size, size, iTime + float(i), inverse, layerHueShift);\n        \n        // Use additive blending with size-based weighting\n        float weight = 1.0 - float(i) / float(numLayers);\n        finalColor += layerColor * weight;\n        totalWeight += weight;\n    }\n    \n    // Normalize the final color\n    finalColor /= totalWeight;\n    \n    // Add a more colorful animated background\n    vec2 bgUV = uv * 3.0; // Scale UV for background pattern\n    float bgPattern = sin(bgUV.x * 5.0 + iTime) * sin(bgUV.y * 5.0 + iTime) * 0.5 + 0.5;\n    vec3 bgColor = applyHueShift(vec3(0.5, 0.7, 1.0), globalHueShift + bgPattern * 2.0);\n    finalColor = mix(bgColor, finalColor, 0.7); // Blend background with flowers\n    \n    // Ensure the final color is not too dark\n    finalColor = max(finalColor, 0.1);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}