{"ver":"0.1","info":{"id":"MlSfDD","date":"1515802497","viewed":557,"name":"waves table","username":"fu5ha","description":"shader port of some generative art originally written in Processing. Original: https://twitter.com/n_disorder/status/942456733544472577","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CHANGE TO CHANGE THE SPEED OF THE WAVE MOVEMENTS\n#define ANIM_SPEED_MULTIPLIER 10.0\nfloat interpsin(float x, float rand, float c1, float c2, float c3, float c4) {\n    float cons = x * c1 * 3.14159 + rand;\n    float s = sin(-cons);\n    float cos1 = 0.25 * cos(cons * c2) * (abs(s*0.7) + 0.3);\n  \tfloat cos2 = 0.1 * cos(cons * c3 + 1.5) * (abs(s*0.7) + 0.3);\n    float l = 0.2 * log(abs(-cons) + 1.);\n    float ss = pow(smoothstep(-1.25, 0., x) - smoothstep(0., 1.25, x), 3.);\n    return (s + cos1 * (1.-ss) + cos2 + l) * (ss) * abs(c4) * 0.3;\n}\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nmat4 makeRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n    mat4 rot = makeRotation( 0.3, 0.0, 0.0 );\n     \n    vec4 uvp = (vec4(uv, 0., 1.) - vec4(0.0, 0.1, 0., 1.)) * rot;\n    uv = uvp.xy / (uvp.z + 1.) * 1.45;\n    \n    float col = 1.0;\n    \n    for (int i = 0; i < 101; i++) {\n    \n    \tfloat y = 0.3 * pow((1. - abs((float(i) - 50.)/50.)), 1.1) * \n            interpsin(\n                uv.x, \n                -(iTime * ANIM_SPEED_MULTIPLIER + 100.5 * (fract(cnoise(vec2(float(i),float(iTime)/30.))))), \n                5. + abs(cnoise(vec2(float(i),float(i)/50.))) * 18. * (0.5 + 0.5*abs(sin(float(iFrame)/(500. * (0.8 + mod(float(i),4.2)))))), \n                2. + abs(cnoise(vec2(float(i),float(i)/20.))) * 4. * (0.5 + 0.5*abs(sin(float(iFrame)/(5000. * (0.8 + mod(float(i),4.2)))))), \n                4. + abs(cnoise(vec2(float(i),float(i)/50.))) * 1. * (0.5 + 0.5*abs(sin(float(iFrame)/(5000. * (0.8 + mod(float(i),4.2)))))), \n                1.\n            ) + 1.5 - 0.025 * float(i);\n        if (i == 0) {\n\t\t\tcol *= smoothstep(uv.y - 0.01, uv.y, y) - smoothstep(uv.y, uv.y + 0.01, y);\n        } else {\n            col += smoothstep(uv.y - 0.01, uv.y, y);\n            col *= 1. - smoothstep(uv.y, uv.y+0.01, y);\n            col += smoothstep(uv.x - 0.01, uv.x, -1.) - smoothstep(uv.x, uv.x + 0.01, -1.);\n            col += smoothstep(uv.x - 0.01, uv.x, 1.) - smoothstep(uv.x, uv.x + 0.01, 1.);\n            col *= smoothstep(-1.01, -1.0, uv.x) - smoothstep(1.0, 1.01, uv.x);\n            col *= step(-1.005, uv.y) - step(1.505, uv.y);\n            col += (smoothstep(uv.x - 0.01, uv.x, -1. * (uvp.z - 1.) * 1.38) - smoothstep(uv.x, uv.x + 0.01, -1. * (uvp.z - 1.) * 1.38)) * (1. - step(-1.005, uv.y));\n            col += (smoothstep(uv.x - 0.01, uv.x, 1. * (uvp.z - 1.) * 1.38) - smoothstep(uv.x, uv.x + 0.01, 1. * (uvp.z - 1.) * 1.38)) * (1. -step(-1.005, uv.y));\n        }\n    }\n    \n    \n    fragColor = vec4(vec3(col), 1.);\n}","name":"Image","description":"","type":"image"}]}