{"ver":"0.1","info":{"id":"csscWj","date":"1687209724","viewed":56,"name":"Love Learning About Shaders","username":"ericsmith3542","description":"My first attempt at writing a shader without using Unity shader graph. Learning by following this video: https://www.youtube.com/watch?v=f4s1h2YETNY","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Function for applying a color palette to the shader\nvec3 palette(float t){\n    \n    /*\n        Link to a website to help find values and understand what this function actually does\n            http://dev.thi.ng/gradients/\n    */\n    \n  vec3 a = vec3(0.768, 0.083, 0.182);\nvec3 b = vec3(0.810, 0.430, 0.451);\nvec3 c = vec3(1.421, 1.539, 0.851);\nvec3 d = vec3(4.791, 2.141, 5.308);\n\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n/*\n    Signed distance function of a heart shape\n        Link for SD functions: https://iquilezles.org/articles/distfunctions2d/\n*/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float id = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - id*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (id<0.5 || p.x>0.0) ? p : -p;\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat sdfCoolS( in vec2 p )\n{\n    float six = (p.y<0.0) ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - 0.2;\n    float rex = p.x - min(round(p.x/0.4),0.4);\n    float aby = abs(p.y-0.2)-0.6;\n    \n    float d = dot2(vec2(six,-p.y)-clamp(0.5*(six-p.y),0.0,0.2));\n    d = min(d,dot2(vec2(p.x,-aby)-clamp(0.5*(p.x-aby),0.0,0.4)));\n    d = min(d,dot2(vec2(rex,p.y  -clamp(p.y          ,0.0,0.4))));\n    \n    float s = 2.0*p.x + aby + abs(aby+0.4) - 0.4;\n\n    return sqrt(d) * sign(s);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/ iResolution.y;\n    \n    //Capture original uv gradient\n    vec2 uv0 = uv;\n    \n    //Color variable for help during interations\n    vec3 finalColor = vec3(0.0);\n    \n    /* The following lines describe the step by step process that helps us derive the simplified version seen on the line above\n    \n        //Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord/iResolution.xy);\n\n        //Center 0,0 at the center of the screen\n        uv -= 0.5;\n\n        //This ensures that the corners of the screen will be 1,1 instead of .5,.5\n        uv *= 2.0;\n\n        //Fix stretching by multiplying by the aspect ratio\n        uv.x *= iResolution.x / iResolution.y;\n    */\n    \n    for(float i = 0.0; i < 2.0; i++){\n        //Break the space into fractions and refit to the 0-1 range\n        uv = fract(uv * 1.5) - .5;\n\n        //Variable to scale the speed by scaling iTime\n        float speed = 3.;\n\n        //The distance of a point from the center\n        vec2 offset = vec2(0, -.5);\n        vec2 zoom = vec2(5., 5.);\n        float d = sdHeart((uv*zoom) - offset)*.1;\n        \n        //Not entirely sure I understand what this does quiet yet\n        d *= exp(length(uv0));\n\n        //Color of the output\n        //Using length(uv0) instead of d here makes it so the color palette decouples from the local coordinates of each fract\n        //vec3 color = palette(length(uv0) + iTime*.5);\n        \n        vec3 color = palette(d + iTime*.5);\n\n        d = sin(d*8. + iTime*speed)/8.;\n        d = abs(d);\n\n        //step helps create a sharp boundary\n        //d = step(0.1, d);\n\n        //smoothstep helps create a gradient boundary\n        //d= smoothstep(0.0, 0.1, d);\n\n        //Inverting the function to invert the colors giving a nice glow effect\n        //The inversion must be scaled so that d will actually be capable of being < 1\n        d = 0.03 / d;\n        \n        //Using this pow function, we can increase contrast by making lower numbers trend toward 0, and higher numbers trend toward 1\n        d = pow(d, 1.2);\n\n        //Apply our function to the color\n        finalColor += color * d;\n      }\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}