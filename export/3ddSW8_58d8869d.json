{"ver":"0.1","info":{"id":"3ddSW8","date":"1571887585","viewed":181,"name":"reaction diffusion with sepconv","username":"matthen","description":"simulating reaction diffusion equations with separable convolutions","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation","convolution","diffusion","separable","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\t\n    fragColor = texture(iChannel0, uv);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// initial image,\n// and vertical high pass filter\n# define kNUM 33\nconst float[kNUM] coeffs = float[kNUM](0.0192704, 0.0194881, 0.0146247, 0.00515698, -0.0072565, -0.0199888, \n-0.0298842, -0.033849, -0.0294816, -0.015617, 0.00732985, 0.037302, \n0.0708441, 0.103621, 0.131119, 0.14941, 0.155822, 0.14941, 0.131119, \n0.103621, 0.0708441, 0.037302, 0.00732985, -0.015617, -0.0294816, \n-0.033849, -0.0298842, -0.0199888, -0.0072565, 0.00515698, 0.0146247, \n0.0194881, 0.0192704);\nvec2 hash22(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * 0.1102);\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.xx+p3.yz)*p3.zy);   \n}\n\nfloat hash21(vec2 p) {\n    p = mod(p, 6.);\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))));\n}\n\nvec3 hash23(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (iFrame < 60) {\n        \n        col = texture(iChannel0, uv).rgb;\n    } else {\n    \t// apply high pass filter\n        float pixel = 1. / iResolution.y;\n        for (int i = 0; i < kNUM; i++) {\n            float coeff = coeffs[i];\n            vec2 off = vec2(\n                0.,\n                float(i) - float(kNUM) / 2. + .5) * pixel;\n            col += coeff * texture(iChannel1, uv + off).rgb;\n        }\n       col = clamp(col, -.5, 1.5);\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// and horizontal high pass filter\n# define kNUM 33\nconst float[kNUM] coeffs = float[kNUM](0.0192704, 0.0194881, 0.0146247, 0.00515698, -0.0072565, -0.0199888, \n-0.0298842, -0.033849, -0.0294816, -0.015617, 0.00732985, 0.037302, \n0.0708441, 0.103621, 0.131119, 0.14941, 0.155822, 0.14941, 0.131119, \n0.103621, 0.0708441, 0.037302, 0.00732985, -0.015617, -0.0294816, \n-0.033849, -0.0298842, -0.0199888, -0.0072565, 0.00515698, 0.0146247, \n0.0194881, 0.0192704);\nvec2 hash22(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * 0.1102);\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.xx+p3.yz)*p3.zy);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n    \n    // apply high pass filter\n    vec2 uv = fragCoord / iResolution.xy;\n    float pixel = 1. / iResolution.x;\n    for (int i = 0; i < kNUM; i++) {\n        float coeff = coeffs[i];\n        vec2 off = vec2(\n            float(i) - float(kNUM) / 2. + 0.5,\n            0.) * pixel;\n        col += coeff * texture(iChannel0, uv + off).rgb;\n    }\n    col = clamp(col, -.5, 1.5);\n\t\n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// horizontal gaussian filter\n#define kNUM 5\nconst float[kNUM] coeffs = float[kNUM](\n0.0544887, 0.244201, 0.40262, 0.244201, 0.0544887);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    vec2 uv = fragCoord / iResolution.xy;\n    float pixel = 0.75 / iResolution.x;\n    for (int i = 0; i < kNUM; i++) {\n        float coeff = coeffs[i];\n        vec2 off = vec2(float(i) - float(kNUM) / 2. + 0.5, 0.) * pixel;\n        col += coeff * texture(iChannel0, uv + off).rgb;\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// horizontal gaussian filter\n#define kNUM 5\nconst float[kNUM] coeffs = float[kNUM](\n    0.0544887, 0.244201, 0.40262, 0.244201, 0.0544887);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    vec2 uv = fragCoord / iResolution.xy;\n    float pixel = 0.75 / iResolution.y;\n    for (int i = 0; i < kNUM; i++) {\n        float coeff = coeffs[i];\n        vec2 off = vec2(0., float(i) - float(kNUM) / 2. + 0.5) * pixel;\n        col += coeff * texture(iChannel0, uv + off).rgb;\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buffer D","description":"","type":"buffer"}]}