{"ver":"0.1","info":{"id":"lX3SRl","date":"1719401913","viewed":28,"name":"GAO_Wang_48246120","username":"takaou","description":"homework for utokyo course","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(5.0, 2.0, 3.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{            \n    // TODO: ベクトル正規化normalize()や外積cross()を用いて実装する。\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: ピクセル座標をカメラ座標系に変換する。\n    float x = FilmWidth() * (1.0- 2.0*(pixelCoordinate.x + 0.5)/iResolution.x);\n    float y = FilmHeight() * (1.0- 2.0*(pixelCoordinate.y + 0.5)/iResolution.y);\n    float z = FilmDistance();\n    return vec3(x, y, z);\n    // return vec3(0.0, 0.0, 0.0);\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: 以下を実装する。\n    // 1. ピクセル座標をカメラ座標系に変換\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    // 4. カメラレイを計算。\n    Ray dummy;\n    vec3 u, v, w, e;\n    vec3 cameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    createOrthoNormalBasis(CameraFrom(), CameraTo(), CameraUp(), u, v, w, e);\n    dummy.org = e;\n    dummy.dir = -normalize(u * cameraCoordinate.x + v * cameraCoordinate.y + w * cameraCoordinate.z);\n    return dummy;\n}\n\nbool intersectToSphere(\n    vec3 center, float radius, Ray ray,\n    out Hit hit\n)\n{\n    // TODO: レイと球の交差判定を実装する。\n    // 二次方程式の解の計算に帰着する。\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(ray.dir, ray.org - center);\n    float c = dot(ray.org - center, ray.org - center) - radius * radius;\n    float Delta = b * b - 4.0 * a * c;\n    if (Delta < 0.0)\n    {\n        return false;\n    }\n    float t1 = (-b - sqrt(Delta)) / (2.0 * a);\n    float t2 = (-b + sqrt(Delta)) / (2.0 * a);\n    if (t1 > 0.0)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize(ray.org + t1 * ray.dir - center)/radius;\n        return true;\n    }\n    if (t2 > 0.0)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize(ray.org + t2 * ray.dir - center)/radius;\n        return true;\n    }\n    return false;\n}\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    // TODO: intersectToSphere を用いて具体的な球との交差判定を行う。\n    vec3 center = vec3(2.0, 0.0, 0.0);\n    float radius = 1.0;\n    if (intersectToSphere(center, radius, ray, hit))\n    {\n        return true;\n    }\n    return hit.distanceToHitpoint < LargeFloat();\n}\n\nvec3 shade(Ray ray, Hit hit)\n{\n    // TODO: なんらかのシェーディングを行う。\n    return hit.normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n     \n    Hit hit;\n    if (intersect(ray, hit))\n    {\n        fragColor = vec4(shade(ray, hit), 0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}