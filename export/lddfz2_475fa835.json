{"ver":"0.1","info":{"id":"lddfz2","date":"1526053748","viewed":275,"name":"Color illusion","username":"Ultraviolet","description":"The famous color illusion (ref:[url]https://nerdist.com/wp-content/uploads/2015/02/DressIllusion_FEAT-970x545.png[/url]).\nThe bright tile color in the dark area is the same as the dark tile color in the light area.\nUse mouse to move cam.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","illusion","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI\t\t\t\t3.1415926535\n#define SQRT2\t\t\t0.707\n\n#define LIGHT_DIR\t\tnormalize(vec3(1., -2., 1.))\n#define CAM_SPEED\t\t.3\n#define CAM_POS \t\tvec3(4.*cos(-iTime*CAM_SPEED), 4.0, 4.*sin(-iTime*CAM_SPEED))\n\n\n\n#define CYL_POS  vec3(0.56, 0.0, 0.56)\n#define CYL_DIR  normalize(vec3(0., 1., 0.))\n#define CYL_RAD  0.35\n#define CYL_HEI  2.\n\n#define SHADOW_SHARPNESS\t.05\n\n#define AA\t4.\n\n\n// strait from https://iquilezles.org/articles/boxfunctions\n// added a parameter for the far intersection normal computation\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal, out vec3 outNormal2 )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    vec3 d = abs(roo+rdd*tF);\n    outNormal2 = -sign(rdd)*vec3(d.x>d.y&&d.x>d.z?1.:0., d.y>d.x&&d.y>d.z?1.:0., d.z>d.y&&d.z>d.x?1.:0.);\n\n    return vec2( tN, tF );\n}\n\n\nvec2 traceCylindre(vec3 ro, vec3 rd, out vec3 n0, out vec3 n1)\n{\n    vec3 A = rd - CYL_DIR*dot(rd,CYL_DIR);\n    vec3 B = ro - CYL_POS - CYL_DIR*dot(ro-CYL_POS,CYL_DIR);\n    \n    float delta = dot(A,B)*dot(A,B) - dot(A,A)*(dot(B,B)-CYL_RAD*CYL_RAD);\n    \n    if(delta < 0.)\n        return vec2(1., 0.);\n        \n    delta = sqrt(delta);\n    \n    float t0 = (-dot(A,B)-delta)/dot(A,A);\n    float t1 = (-dot(A,B)+delta)/dot(A,A);\n    \n    vec2 t = vec2(t0, t1);\n    \n    vec3 p0 = ro+rd*t0;\n    float h0 = dot(CYL_DIR,p0 - CYL_POS);\n    n0 = normalize(p0 - (CYL_POS+CYL_DIR*h0));\n    if(h0 > 0.)\n    {\n        return vec2(1., 0);\n    }\n    \n    if(h0 < -CYL_HEI)\n    {\n        n0 = vec3(0., -1., 0.);\n        float tt = (-CYL_HEI-ro.y)/rd.y;\n        \n        vec3 p = ro+rd*tt;\n        if(length(p - (CYL_POS - CYL_DIR*CYL_HEI))<CYL_RAD)\n        {\n            return vec2(tt, 100.);\n        }\n        return vec2(1., 0);\n    }\n    \n    vec3 p1 = ro+rd*t1;\n    float h1 = dot(CYL_DIR,p1 - CYL_POS);\n    n1 = normalize(p1 - (CYL_POS+CYL_DIR*h1));\n    \n    return t;\n}\n\n\n// from iq   https://www.shadertoy.com/view/XlcSz2\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    float ret = mod( q.x+q.y, 2.0 );            // xor pattern\n    \n    if(p.x>2. && p.x<3. && p.y>2. && p.y<3.)\n    {\n        vec2 uv = p-vec2(2.);\n        uv = uv.yx/16. + vec2(1., 11.)/16.;\n        if(texture(iChannel0, uv).w<.5)\n        \tret = 1.-ret;\n    }\n    \n    if(p.x>4. && p.x<5. && p.y>1. && p.y<2.)\n    {\n        vec2 uv = p-vec2(4., 1.);\n        uv = uv.yx/16. + vec2(2., 11.)/16.;\n        if(texture(iChannel0, uv).w<.5)\n        \tret = 1.-ret;\n    }\n    \n    return ret;\n}\n\n\n// distance between lines + param along each vector to reach closest point\nvec3 LineLineDist(vec3 P0, vec3 d0, vec3 P1, vec3 d1)\n{\n    vec3 d0c = d0 / dot(d0, d0);\n    vec3 X = d1 - d0 * dot(d1, d0c);\n    vec3 Y = P1 - P0 - d0*dot(P1, d0c);\n\n    float t1 = -dot(Y, X) / dot(X, X);\n    \n    t1 = clamp(t1, -CYL_HEI, 0.);\n\n    vec3 Pd1 = P1 + t1 * d1;\n    \n    float t0 = dot((Pd1 - P0), d0) / dot(d0, d0);\n    vec3 Pd0 = P0 + t0 * d0;\n    \n    return vec3(length(Pd1-Pd0), dot(Pd0-P0,d0)/dot(d0,d0), dot(Pd1-P1, d1)/dot(d1,d1));\n}\n\n// simulates a circular focal\nfloat shadowFunction(float x)\n{\n    //return x;\n    x *= 0.999;\n    x += 0.0005;\n    return .5+(asin(x*2.-1.)+(x*2.-1.)*sqrt(1.-(x*2.-1.)*(x*2.-1.)))/PI;\n}\n\n// ray casting\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = 10000.;\n    vec3 col = vec3(1.);\n    \n    \n    //--------------------------------------\n    // Board\n    vec3 n_1_box, n_2_box;\n    vec2 t_box = boxIntersection(ro, rd, vec3(1., .12, 1.), mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.), n_1_box, n_2_box);\n    \n    if(t_box.x < t_box.y)\n    {\n        t = t_box.x;\n        \n        float f = max(0., dot(n_1_box, LIGHT_DIR));\n        f = f*.6+.4;\n        \n        vec3 pos = ro+rd*t;\n        \n        float checker = checkersTexture((pos.xz-vec2(-1.0001))*.5*4.999);\n        \n        \n        \n        //--------------------------------------\n        // Shadow\n\n        vec3 d_sha = LineLineDist(ro+rd*t, LIGHT_DIR, CYL_POS, CYL_DIR);\n        \n        float f_sha = 1.;\n        if(d_sha.y > 0.)\n        {\n            f_sha = clamp(d_sha.x-CYL_RAD, -d_sha.y*SHADOW_SHARPNESS, d_sha.y*SHADOW_SHARPNESS)/d_sha.y/SHADOW_SHARPNESS * .5 + .5;\n            f_sha = shadowFunction(f_sha);\n            //col *= .5+.5*f_sha;\n        }\n\n        vec3 col_0 = vec3(0.9);\n        vec3 col_1 = vec3(0.6);\n        vec3 col_2 = vec3(0.2);\n        \n\t\tvec3 colShadow = mix(col_1, col_2, checker);\n\t\tvec3 colLight  = mix(col_0, col_1, checker);\n\t\tvec3 baseCol   = mix(colShadow, colLight, f_sha);\n        \n        \n        col = baseCol * f;\n    }\n    \n    \n    //--------------------------------------\n    // Moving tile\n    \n    float t_tile = (-.12-ro.y)/rd.y;\n    vec3 pos = ro+rd*t_tile;\n    //vec2 tile_pos = mix(vec2(0.), vec2(.8, -.4), .5+.5*sin(iTime));\n    vec2 tile_pos = mix(vec2(0., -.4), vec2(.8, -.8), .5+.5*sin(iTime));\n    vec2 diff = pos.xz - tile_pos;\n\n    if(abs(diff.x)<.2 && abs(diff.y)<.2)\n    {\n        vec3 n = vec3(0., -1., 0.);\n        float f = max(0., dot(n, LIGHT_DIR));\n        f = f*.6+.4;\n        col = vec3(0.6)* f;\n    }\n    \n    \n    \n    //--------------------------------------\n    // Cylindre\n    \n    \n    vec3 n_1_cyl, n_2_cyl;\n    vec2 t_cyl = traceCylindre(ro, rd, n_1_cyl, n_2_cyl);\n    \n    if(t_cyl.x < t_cyl.y && t_cyl.x < t)\n    {\n        t = t_cyl.x;\n        \n        float f = max(0., dot(n_1_cyl, LIGHT_DIR));\n        f = f*.6+.4;\n        \n        vec3 baseCol = vec3(28., 83., 48.)*2./255.;\n        \n        col = baseCol * f;\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    \n    vec3 ca = normalize(vec3(-2., 3., 1.));\n    \n    if(iMouse.z > 0.)\n    {\n        float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n        float psi = ((iMouse.y-0.5)/iResolution.y) * PI * .5;\n\n        ca = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    }\n        \n    vec3 ta = vec3(0., .0, .0);\n    mat3 m = setCamera(ca, ta, 0.0);\n\t\n    float zoom = 1.;\n    //vec3 ro = (m[0]*p.x + m[2]*p.y) / zoom;\n    vec3 rd = m[1];\n    \n    \n    // scene rendering\n    vec3 col = vec3(0.);\n    \n    for(float i=0.; i<AA; ++i)\n    for(float j=0.; j<AA; ++j)\n    {\n        vec2 o = vec2(i,j) / AA - 0.5;\n        p += o/iResolution.y;\n    \tvec3 ro = (m[0]*p.x + m[2]*p.y) / zoom;\n    \tcol += render( ro, rd);\n    }\n    \n    col /= AA*AA;\n    \n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}