{"ver":"0.1","info":{"id":"MlfBDB","date":"1513133282","viewed":248,"name":"Screen-space crack fixing","username":"steverock","description":"Wanted to quickly try an idea for mending terrain cracks in screen space. Currently I'm just sampling a neighborhood around pixels that are in cracks. Better crack-filling algos definitely exist, but this seems promising! Could be faster with downsampling","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        \nfloat cracks(vec2 uv) {\n    vec2 olduv = uv;\n    uv.y += 0.01*sin(6.28*1.0*olduv.x);\n    uv.y *= 1.5;\n    uv.x /= 4.0;\n    uv.x += 0.3*sin(6.28*1.0*olduv.y);\n    vec3 c = texture(iChannel1, uv).rgb;\n    //return length(c);\n    return 1.0 - step(0.5, length(c));\n}\n\nvec3 cracked(vec2 uv) {\n    return mix(\n        texture(iChannel0, uv).rgb,\n        vec3(1.0, 0., 1.0),\n        cracks(uv));\n}\n\n#define SR 2\n#define TR 0.01\n\nvec3 mended(vec2 uv) {\n    if(cracks(uv) < 0.5) {\n        // Not actually a cracked pixel\n        return cracked(uv);\n    }\n    \n    float duv = TR/float(SR);\n    vec3 total = vec3(0.);\n    float total_wt = 0.0;\n    float weight = 1.0;\n    for(int i = -SR; i <= SR; i++) {\n        for(int j = -SR; j <= SR; j++) {\n            vec2 uv2 = uv + vec2(float(i)*duv, float(j)*duv);\n            if(cracks(uv2) > 0.5) {\n                continue;\n            }\n            vec3 s = cracked(uv2);\n            total += s;\n            total_wt += weight;\n            \n            //weight *= 0.5;\n    \t}\n    }\n    return total / total_wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx * 3.0;\n    uv.x += iTime / 3.;\n    //uv.y += iTime / 20.;\n    vec3 m = mended(uv);\n\tfragColor = vec4(mix(\n        mended(uv), cracked(uv), step(0., sin(6.28/3.0*iTime))),\n        1.0);\n}","name":"Image","description":"","type":"image"}]}