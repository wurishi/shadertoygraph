{"ver":"0.1","info":{"id":"tdsGWX","date":"1547694718","viewed":413,"name":"planetoid /w satellite","username":"chadams","description":"ray marching test\n\nupdate: atmosphere shadow\nupdate: atmosphere on planetoid\nupdate: smoothed shadows, sandy planetoid lowlands, colorization\nupdate: code cleanup etc\nupdate: rotating & zooming camera, fine tuned ray marching","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","planet","asteroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n// Soft shadow implementation based on: https://iquilezles.org/articles/rmshadows\n// 3D simplex noise from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 (by Ian McEwan)\n// Arbitraty axis rotation from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/ (blarg)\n\n\n/////// -- simplex noise start\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return (42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                   dot(p2,x2), dot(p3,x3) ) )) * 0.5 + 0.5;\n}\n\n\n////// -- simplex noise end / abritrary rotation axis start\n\n\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n\n////// -- abritrary rotation axis end / ray<->sphere intersect start\n\n\nvec2 raySphere(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float test = b*b - 4.0*a*c;\n    if (test < 0.0) {\n        return vec2(-1.0, -1.0);\n    }\n    test = sqrt(test);\n    float X = (-b - test)/(2.0*a);\n    float Y = (-b + test)/(2.0*a);\n    return vec2(\n        min(X, Y),\n        max(X, Y)\n    );\n}\n\n\n////// -- ray<->sphere intersect end / main start\n\n\n\n// Planetoid terrain functions\nfloat planetHeightHD(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*2.5 + pseed * 1234.1) * 0.5 +\n        snoise(n*2.5*2. + pseed * 1234.1) * 0.25 +\n        snoise(n*2.5*4. + pseed * 1234.1) * 0.125 +\n        snoise(n*2.5*8. + pseed * 1234.1) * 0.125*0.5 +\n        snoise(n*2.5*16. + pseed * 1234.1) * 0.125*0.25;\n}\n\nfloat planetHeightHDS(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*1.5 + pseed * 1234.1) * 0.85,\n        snoise(n*2.5 + pseed * 1234.1) * 0.15;\n}\n\nvec3 clrPlanetHD(vec3 p, vec3 pc, vec3 pseed, mat3 rot) {\n    vec3 n = normalize(rot * (p - pc));\n    float ph = planetHeightHD(n, pseed);\n    float t = pow(ph, 1.5);\n    float t2 = pow((1. - ph) * 1.5, 2.0);\n    return mix(\n        mix(\n        \tvec3(0.3, 0.3, 0.3),\n            vec3(1., 1., 1.),\n            t2\n        ),\n    \tvec3(1., 1., .7) * (0.25 + pow(snoise(n*2.5*1. + pseed * 11234.1), 0.2) * 0.75),\n        t\n   \t);\n}\n\nfloat distPlanetHD(vec3 p, vec3 pc, float pr, vec3 pseed, float hd, mat3 rot) {\n    \n    // Start with sphere\n    float d0 = length(p - pc);\n    // Offset by layered simplex noise\n    float ph = planetHeightHD(normalize(rot * (p - pc)), pseed);\n    float phs = planetHeightHDS(normalize(rot * (p - pc)), pseed);\n    float r = pr - pr * hd * mix(ph, phs * 3.5, pow(ph, 1.5));\n    \n    return d0 - r;\n    \n}\n\n// Satellite terrain functions\nfloat planetHeight(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*0.5 + pseed * 1234.1) +\n        snoise(n*0.5*4. + pseed * 1234.1) * 0.25 +\n        snoise(n*0.5*16. + pseed * 1234.1) * 0.125 * 0.5;\n}\n\nfloat distPlanet(vec3 p, vec3 pc, float pr, vec3 pseed, float hd, mat3 rot) {\n    \n    float d0 = length(p - pc);\n    float r = pr + pr * hd * planetHeight(normalize(rot * (p - pc)), pseed);\n    \n    return d0 - r;    \n    \n}\n\n// Scene function\nfloat getDist(vec3 p) {\n    \n    // Planetoid self rotation\n    mat3 p1r = rotAxis(normalize(vec3(.5, -.2, 1.)), iTime * 0.1);\n    // Orbital rotation\n    mat3 p1r2 = rotAxis(normalize(vec3(-1, -.1, 0.05)), -iTime * 0.2);\n    // Satellite self rotation\n    mat3 p2r = rotAxis(normalize(vec3(.1, .5, -1.)), -iTime * 0.5);\n    \n    return min(\n\t    distPlanetHD(p, vec3(0., 0., 0.), 5., vec3(.4315, .3415, .141561), 0.1, p1r),\n        distPlanet(p, p1r2 * vec3(1., 3., 7.) * 1., 0.5, vec3(.1315, .7615, .5341561), 1., p2r)\n    );\n    \n}\n\nvec3 getClr(vec3 p) {\n    vec3 clr = vec3(0.75, 0.75, 0.75);\n    mat3 p1r = rotAxis(normalize(vec3(.5, -.2, 1.)), iTime * 0.1);\n    float dp = distPlanetHD(p, vec3(0., 0., 0.), 5., vec3(.4315, .3415, .141561), 0.1, p1r);\n    if (dp < (1e-3)) {\n        return clrPlanetHD(p, vec3(0., 0., 0.), vec3(.4315, .3415, .141561), p1r);\n    }\n    return clr;\n}\n\n// Raymarching implementation\n#define MAX_ITERATIONS 256\n#define FAR_CLIP 60.\n#define MIN_DIST (1e-3)\n\nfloat rayMarch(vec3 r0, vec3 rd) {\n    float ds = 0.;\n    for (int i=0; i<MAX_ITERATIONS; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < MIN_DIST) {\n            return ds;\n        }\n        if (ds >= FAR_CLIP) {\n            break;\n        }\n    }\n    return FAR_CLIP;\n}\n\n// Lighting functions\n#define LIGHT vec3(0., 15., -1.)\n#define SHADOW_STRENGTH 0.8\n#define AMBIENT_LIGHT 0.01\n#define SURFACE_DIST 0.02\n#define NORMAL_SAMPLE_DIST (1e-3)\n#define SHADOW_ITERATIONS 32\n#define SHADOW_MIN_DIST (1e-4)\n#define SHADOW_SHARPNESS 2.25\n\nfloat shadowRay(vec3 r0, vec3 rd, float maxDist) {\n    float ds = 0.;\n    float ret = 1.;\n    for (int i=0; i<SHADOW_ITERATIONS && ds < maxDist; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < SHADOW_MIN_DIST) {\n            return 0.0;\n        }\n        ret = min(ret, SHADOW_STRENGTH * dist/ds);\n    }\n    return pow(ret, 1.0 / SHADOW_SHARPNESS);\n}\n\nfloat shadowRayLD(vec3 r0, vec3 rd, float maxDist) {\n    float ds = 0.;\n    float ret = 1.;\n    for (int i=0; i<16 && ds < maxDist; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < (0.5 * 1e-1)) {\n            return 0.0;\n        }\n        ret = min(ret, SHADOW_STRENGTH * dist/ds);\n    }\n    return pow(ret, 1.0 / 2.);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 eps = vec2(NORMAL_SAMPLE_DIST, 0.);\n    return normalize(\n        getDist(p) - vec3(\n            getDist(p - eps.xyy),\n            getDist(p - eps.yxy),\n            getDist(p - eps.yyx)\n        )\n    );\n}\n\nfloat getLight(vec3 n, vec3 p) {\n       \n    vec3 ld = normalize(LIGHT - p);\n    \n    // Apply defuse lighting\n    float l = clamp(dot(n, ld), 0., 1.) * (1. - AMBIENT_LIGHT) + AMBIENT_LIGHT;\n      \n    return l;\n}\n\nfloat getShading(vec3 n, vec3 p) {\n\n    vec3 ld = normalize(LIGHT - p);\n    return shadowRay(p + n*SURFACE_DIST, ld, length(LIGHT - p)-SURFACE_DIST);\n\n}\n\nfloat getShadingLD(vec3 n, vec3 p) {\n\n    vec3 ld = normalize(LIGHT - p);\n    return shadowRayLD(p + n, ld, length(LIGHT - p)-1.0);\n\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Translate viewport\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvx1 = ((fragCoord-vec2(2., 0.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvx2 = ((fragCoord+vec2(2., 0.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvy1 = ((fragCoord-vec2(0., 2.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvy2 = ((fragCoord+vec2(0., 2.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n\n    // Animate camera and compute camera ray\n    mat3 crot = rotAxis(vec3(0., 1., 0.), iTime * 0.15);\n    vec3 r0 = vec3(0., 0., -40. + (sin(iTime * 0.25) * 0.5 + 0.5) * 15.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    r0 = crot * r0;\n    rd = normalize(crot * rd);\n    \n    vec3 rdx1 = normalize(crot * normalize(vec3(uvx1, 1.)));\n    vec3 rdx2 = normalize(crot * normalize(vec3(uvx2, 1.)));\n    vec3 rdy1 = normalize(crot * normalize(vec3(uvy1, 1.)));\n    vec3 rdy2 = normalize(crot * normalize(vec3(uvy2, 1.)));\n    \n    // Render fragment\n    float id = rayMarch(r0, rd);\n    vec3 rp = r0 + rd * id;\n    vec3 n = getNormal(rp);\n    float shadow = getShading(n, rp);\n    float light = getLight(n, rp) * shadow;\n    if (id < (FAR_CLIP-(1e-6))) {\n    \tfragColor = vec4(getClr(rp) * light, 1.0);\n    }\n    else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n    \n    // Atmosphere\n    vec2 rsi = raySphere(r0, rd, vec3(0., 0., 0.), 5.75);\n    if (rsi.x > 0.) {\n        rsi.y = min(rsi.y, id);\n        vec3 rp2 = r0 + rd * (rsi.x+rsi.y) * 0.5;\n        float ashadow = 0.35 + 0.65 * getShadingLD(n, rp2);\n        float astr = max(rsi.y - rsi.x, 0.) / 11.5 * max(dot(normalize(LIGHT), normalize(rp2)), 0.0);\n        fragColor.rgb += vec3(1., 1., 0.8) * ashadow * pow(astr, 2.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}