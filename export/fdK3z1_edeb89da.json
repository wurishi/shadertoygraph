{"ver":"0.1","info":{"id":"fdK3z1","date":"1631087188","viewed":469,"name":"Happy Moomin","username":"ytt","description":"A modeling attempt using SDF","likes":41,"published":1,"flags":0,"usePreview":1,"tags":["moomins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Happy Moomin\n//\n// Based on Inigo Quilez wonderful tutorials\n//\n// Reference image:\n// https://www.moominworld.fi/clients/muumimaailma/mellow_internal/imagefolder/en//generated/kortti-muumipeikko635x344c_90.png\n//\n\n#define SCENE_BACKGROUND\n//#define MOUSE_ROTATE1\n#define MOUSE_ROTATE2\n//#define OVERLAY\n#define MAX_STEPS 50\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define MATERIAL_SKIN 1.0\n#define MATERIAL_EAR 2.0\n#define MATERIAL_HAIR 3.0\n#define MATERIAL_GRASS 4.0\n#define MATERIAL_FLOWER1 5.0\n#define MATERIAL_FLOWER2 6.0\n#define MATERIAL_MOUNTAIN 7.0\n#define MATERIAL_TREE 8.0\n\nfloat smin(in float a, float b, float k)\n{\n\tfloat h = max(k - abs(a - b), 0.0);\n\treturn min(a, b) - h * h / (k * 4.0);\n}\n\nvec2 smin(in vec2 a, vec2 b, float k) // material smooth min\n{\n\tfloat x = smin(a.x, b.x, k);\n\treturn vec2(x, a.x < b.x ? a.y : b.y);\n}\n\nfloat smax(in float a, float b, float k)\n{\n\tfloat h = max(k - abs(a - b), 0.0);\n\treturn max(a, b) + h * h / (k * 4.0);\n}\n\nvec2 smax(in vec2 a, vec2 b, float k) // material smooth min\n{\n\tfloat x = smax(a.x, b.x, k);\n\treturn vec2(x, a.x > b.x ? a.y : b.y);\n}\n\nvec2 min2(in vec2 a, vec2 b) // material min\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 max2(in vec2 a, vec2 b) // material min\n{\n\treturn a.x > b.x ? a : b;\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash(vec3 p)\n{\n\tp  = fract(p * .1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat hash(vec2 p)\n{\n\treturn hash(p.xyx);\n}\n\nfloat sdSurface(in vec3 pos)\n{\n\treturn pos.y;\n}\n\nfloat sdSphere(in vec3 pos, float rad)\n{\n\t//pos.x -= max(0.0, min(1.0, pos.x));\n\treturn length(pos) - rad;\n}\n\nfloat sdEllipsoid(in vec3 pos, vec3 rad)\n{\n\t//pos.x -= max(0.0, min(1.0, pos.x));\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdArc(in vec3 pos, float len, float angle, float width, float taper)\n{\n\t// parameters\n\tvec2 sc = vec2(sin(angle), cos(angle));\n\tfloat ra = 0.5 * len / angle;\n\n\t// recenter\n\tpos.x -= ra;\n\n\t// reflect\n\tvec2 q = pos.xy - 2.0 * sc * max(0.0, dot(sc, pos.xy));\n\n\tfloat u = abs(ra) - length(q);\n\tfloat d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n\tfloat s = sign(angle);\n\n\tfloat t = (pos.y > 0.0) ? atan(s * pos.y, -s * pos.x) * ra : (s * pos.x < 0.0) ? pos.y : len - pos.y;\n\twidth = max(0.001, width - t * taper);\n\n\treturn sqrt(d2 + pos.z * pos.z) - width;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n\tfloat rba  = rb-ra;\n\tfloat baba = dot(b-a,b-a);\n\tfloat papa = dot(p-a,p-a);\n\tfloat paba = dot(p-a,b-a)/baba;\n\n\tfloat x = sqrt( papa - paba*paba*baba );\n\n\tfloat cax = max(0.0,x-((paba<0.5)?ra:rb));\n\tfloat cay = abs(paba-0.5)-0.5;\n\n\tfloat k = rba*rba + baba;\n\tfloat f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n\tfloat cbx = x-ra - f*rba;\n\tfloat cby = paba - f;\n\n\tfloat s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n\treturn s*sqrt( min(cax*cax + cay*cay*baba,\n\t\t\t\t\t   cbx*cbx + cby*cby*baba) );\n}\n\nvec2 rotate(in vec2 pos, float angle)\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn pos * m;\n}\n\nvec3 rotate(in vec3 pos, vec3 angle)\n{\n\tpos.xz = rotate(pos.xz, angle.y);\n\tpos.xy = rotate(pos.xy, angle.z);\n\tpos.yz = rotate(pos.yz, angle.x);\n\n\treturn pos;\n}\n\nvec2 sdEar(in vec3 pos)\n{\n\tfloat bounds = dot(pos, pos);\n\tif (bounds > 0.1) return vec2(bounds, 0.0);\n\n\tvec2 d1, d2;\n\tfloat y = -0.15;\n\td1 = vec2(sdEllipsoid(pos - vec3(0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\n\n\td2 = vec2(sdEllipsoid(pos - vec3(-0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.03);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, 0.5), vec3(0.6,0.7,0.6)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.1);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, -0.1), vec3(0.12, 0.33, 0.12)), MATERIAL_EAR);\n\td1 = smax(d1, vec2(-d2.x, d2.y), 0.05);\n\n\treturn d1;\n}\n\nvec2 sdArm(in vec3 pos, vec3 armAngle, float elbowAngle, vec3 wristAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\t// upper arm\n\tpos1 = pos;\n\tpos1 = rotate(pos1, armAngle);\n\tpos1.x -= 0.36;\n\td1 = sdEllipsoid(pos1 - vec3(0.48, 0.0, 0.0), vec3(0.6, 0.38, 0.38));\n\n\tif (d1 > 1.6) return vec2(d1, MATERIAL_SKIN); // optimization\n\n\t// forearm\n\tpos1.x -= 0.72;\n\tpos1.xy = rotate(pos1.xy, elbowAngle);\n\tpos1.xz = rotate(pos1.xz, 0.4);\n\td2 = sdEllipsoid(pos1 - vec3(0.24, 0.0, 0.0), vec3(0.42, 0.26, 0.26));\n\td1 = smin(d1, d2, 0.1);\n\n\t// palm\n\tpos1.x -= 0.3;\n\tpos1 = rotate(pos1, wristAngle);\n\td2 = sdEllipsoid(pos1 - vec3(0.3, 0.0, 0.0), vec3(0.2, 0.22, 0.15));\n\td1 = smin(d1, d2, 0.1);\n\n\tif (d1 > 0.2) return vec2(d1, MATERIAL_SKIN); // optimization\n\n\t// fingers\n\tpos2 = rotate(pos1, vec3(0.0, -0.4, 0.6));\n\td2 = sdEllipsoid(pos2 - vec3(0.41, 0.0, 0.1), vec3(0.1, 0.06, 0.06)); // thumb\n\n\tfloat spreadAngle = 0.2;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tpos2 = rotate(pos1, vec3(-0.3, -0.4, float(i) * spreadAngle - 0.5));\n\t\td3 = sdEllipsoid(pos2 - vec3(0.47, 0.0, 0.15), vec3(0.1, 0.06, 0.06)); // finger\n\t\td2 = min(d2, d3);\n\t}\n\td1 = smin(d1, d2, 0.06);\n\n\t// palm bend\n\td2 = sdEllipsoid(pos1 - vec3(0.4, 0.0, -0.2), vec3(0.05, 0.25, 0.07));\n\td1 = smax(d1, -d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdLeg(in vec3 pos, vec3 legAngle, float kneeAngle, vec3 footAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\tfloat s = 1.15; // scale\n\n\t// hip\n\tpos1 = pos;\n\n\tpos1.xz = rotate(pos1.xz, legAngle.y);\n\tpos1.yz = rotate(pos1.yz, legAngle.x);\n\tpos1.xy = rotate(pos1.xy, legAngle.z);\n\n\td1 = sdEllipsoid(pos1 + vec3(0.0, 0.3 * s, 0.0), vec3(0.4, 0.7, 0.4) * s);\n\n\tif (d1 > 2.0) return vec2(d1, MATERIAL_SKIN); // optimization\n\n\t// thigh\n\tpos1.y += 0.7 * s;\n\tpos1.yz = rotate(pos1.yz, kneeAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.2 * s, 0.0), vec3(0.3, 0.5, 0.3) * s);\n\td1 = smin(d1, d2, 0.1);\n\n\t// foot\n\tpos1 += vec3(0.0, 0.55, -0.15) * s;\n\tpos1 = rotate(pos1, footAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.0, 0.3) * s, vec3(0.22, 0.15, 0.35) * s * 1.2);\n\td1 = smin(d1, d2, 0.1);\n\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.3, 0.3) * s, vec3(0.4, 0.2, 0.5) * s);\n\td1 = smax(d1, -d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdTail(in vec3 pos, vec3 angle)\n{\n\tpos = rotate(pos, angle);\n\tpos.y = -pos.y;\n\tfloat d1 = sdArc(pos, 2.4, 1.4, 0.15, 0.04);\n\n\tpos += vec3(-1.9, 0.1, 0.0);\n\tpos.xy = rotate(pos.xy, -2.6);\n\tfloat d2 = sdArc(pos, 0.3, 0.4, 0.22, 0.5);\n\n\td1 = smin(d1, d2, 0.1);\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdEye(in vec3 pos)\n{\n\t// eye\n\tvec2 d1 = vec2(sdSphere(pos, 0.15), MATERIAL_SKIN);\n\n\tif (d1.x > 0.7) return d1; // optimization\n\n\t// eyelash\n\tvec3 pos1 = pos;\n\tpos1.yz = rotate(pos1.yz, -0.4);\n\tvec2 d2 = vec2(sdArc(pos1 + vec3(0.14, -0.04, 0.0), 0.4, 1.4, 0.01, 0.04), MATERIAL_HAIR);\n\td1 = smin(d1, d2, 0.02);\n\n\t// brow\n\tpos1 = pos + vec3(0.0, -0.58, -0.23);\n\tpos1 = rotate(pos1, vec3(-0.3, 0.7, -1.7));\n\td2 = vec2(sdArc(pos1, 0.25, 0.4, 0.015, 0.08), MATERIAL_HAIR);\n\td1 = smin(d1, d2, 0.01);\n\n\treturn d1;\n}\n\nvec2 sdMoomin(in vec3 pos)\n{\n\tvec2 d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\tfloat bounds = length(pos) - 5.0; // bounding sphere\n\tif (bounds > 1.5) return vec2(bounds, MATERIAL_SKIN); // optimization\n\n\t// head\n\tpos1 = pos - vec3(0.0, 1.6, 0.5);\n\tpos1 = rotate(pos1, vec3(0.65, -0.5, -0.2)); // head rotation\n\tpos1.y -= 0.3;\n\n\t// jaw\n\td1.x = sdEllipsoid(pos1 - vec3(0.0, -0.4, -0.8), vec3(0.7));\n\td2.x = sdEllipsoid(pos1 - vec3(0.0, -1.1, -0.5), vec3(1.2));\n\td1 = smax(d1, d2, 0.1);\n\n\t// skull\n\tpos2 = pos1;\n\tpos2.yz = rotate(pos2.yz, 0.4); // head rotation\n\td2.x = sdEllipsoid(pos2, vec3(0.7, 0.95, 0.7));\n\td1 = smin(d1, d2, 0.2);\n\n\tpos2.yz = rotate(pos2.yz, 0.5);\n\tpos2 += vec3(0.0, 0.4, 0.1);\n\td2.x = sdEllipsoid(pos2, vec3(0.6, 0.6, 0.4));\n\n\td1 = smin(d1, d2, 0.2);\n\td1.y = MATERIAL_SKIN;\n\n\t// eyes\n\tvec3 eyesPos = pos1 - vec3(0.0, 0.05, -0.6);\n\tfloat eyesOffset = 0.28;\n\n\t// right eye\n\td2 = sdEye(eyesPos - vec3(eyesOffset, 0.0, 0.0));\n\t// left eye\n\teyesPos.x = -eyesPos.x;\n\td3 = sdEye(eyesPos - vec3(eyesOffset, 0.0, 0.0));\n\td2 = min2(d2, d3);\n\n\td1 = smin(d1, d2, 0.1);\n\t//return d1;\n\n\t// right ear\n\tpos2 = pos1;\n\tpos2.xy = rotate(pos2.xy, -0.32);\n\td2 = sdEar(pos2 - vec3(0.0, 0.9, 0.0));\n\td1 = smin(d1, d2, 0.05);\n\n\t// left ear\n\tpos2 = pos1;\n\tpos2.xy = rotate(pos2.xy, 0.32);\n\td2 = sdEar(pos2 - vec3(0.0, 0.9, 0.0));\n\td1 = smin(d1, d2, 0.05);\n\n\tfloat t = 0.9; // taper\n\n\t// body\n\tpos1 = pos - vec3(0.0, 1.7, 1.1);\n\tpos1 = rotate(pos1,  vec3(1.0, 0.0, -0.3)); // body rotation\n\n\tvec3 bodyCurve = vec3(-0.25, -0.2, 0.0);\n\tfloat y;\n\n\t// neck\n\ty = 0.6;\n\tpos2 = rotate(pos1, bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// shoulders\n\ty = 1.2;\n\tpos2 = rotate(pos1, bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// ribcage\n\ty = 1.9;\n\tpos2 = rotate(pos1, bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// belly\n\ty = 2.25;\n\tpos2 = rotate(pos1, bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.1);\n\n\t// arms\n\ty = 2.1;\n\tvec3 armsPos = rotate(pos1, bodyCurve * y);\n\tarmsPos.y += y;\n\tvec3 armOffset = vec3(0.4, 0.0, 0.0);\n\n\t// right arm\n\tpos2 = armsPos - armOffset;\n\td2 = sdArm(pos2, vec3(0.0, -0.5, 0.85), -0.2, vec3(0.0, 0.2, -0.3));\n\n\t// left arm\n\tpos2 = vec3(-armsPos.x, armsPos.yz) - armOffset; // mirror\n\td3 = sdArm(pos2, vec3(0.0, -0.7, 0.5), -0.1, vec3(0.0, 0.2, -0.3));\n\td2 = min2(d2, d3);\n\n\td1 = smin(d1, d2, 0.1);\n\n\t// legs\n\ty = 2.6;\n\tvec3 legsPos = rotate(pos1, bodyCurve * y);\n\tlegsPos.y += y;\n\tvec3 legOffset = vec3(0.7, 0.0, -0.5);\n\n\t// right leg\n\tpos2 = legsPos - legOffset;\n\td2 = sdLeg(pos2, vec3(0.8, -2.1, 3.6), -1.6, vec3(0.5, -0.2, 0.0));\n\n\t// left leg\n\tpos2 = vec3(-legsPos.x, legsPos.yz) - legOffset; // mirror\n\td3 = sdLeg(pos2, vec3(0.1, 0.0, -0.5), -0.3, vec3(-1.0, 0.0, 0.0));\n\td2 = min2(d2, d3);\n\n\t// tail\n\ty = 3.0;\n\tvec3 tailPos = rotate(pos1, bodyCurve * y);\n\ttailPos.y += y;\n\td3 = sdTail(tailPos, vec3(0.0, 0.2, -0.4));\n\n\td2 = min2(d2, d3);\n\n\td1 = smin(d1, d2, 0.1);\n\n\treturn d1;\n}\n\nfloat getGrassMaterial(in vec2 uv)\n{\n\tfloat tileId = fract(hash(floor(uv))); // tile id\n\n\tif (tileId > 0.8)\n\t{\n\t\tint n = int(pow(tileId, 8.0) * 5.0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfloat id = fract(hash(floor(uv + vec2(float(i))))); // id\n\n\t\t\tvec2 uv1 = -1.0 + 2.0 * fract(uv);\n\t\t\tuv1 *= 1.0 - 0.4 * id;\n\t\t\tuv1 += 0.5 * vec2(sin(id * 100.0), cos(id * 100.0));\n\n\t\t\tfloat r = length(uv1) * 1.3;\n\t\t\tfloat a = atan(uv1.y, uv1.x) + sin(id * 100.0);\n\n\t\t\tif (r < 0.08)\n\t\t\t{\n\t\t\t\treturn MATERIAL_FLOWER1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tr += sin(a * 5.0) * 0.1;\n\t\t\tif (r < 0.22)\n\t\t\t{\n\t\t\t\treturn MATERIAL_FLOWER2 + 0.4 * id;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn MATERIAL_GRASS;\n}\n\nfloat sdGroundHeight(in vec3 pos)\n{\n\tfloat s = 0.1;\n\treturn -2.0 +\n\t\t0.8 * (sin(pos.x * s) + sin(pos.z * s)) +\n\t\t0.4 * (sin(2.0 * pos.x * s) + sin(2.0 * pos.z * s));\n}\n\nvec2 sdGrass(in vec3 pos)\n{\n\tvec2 d1;\n\n\tfloat height = sdGroundHeight(pos);\n\tfloat m = getGrassMaterial(pos.xz);\n\tfloat bump = 0.02 * step(MATERIAL_GRASS + 0.5, m) - 0.01 * step(MATERIAL_FLOWER1 + 0.5, m);\n\n\td1 = vec2(sdSurface(pos - vec3(0.0, height + bump, 0.0)), m);\n\treturn d1;\n}\n\nvec2 sdMountains(in vec3 pos)\n{\n\tfloat bounds = -(length(pos) - 50.0);\n\tif (bounds > 5.0)\n\t{\n\t\treturn vec2(bounds, 0.0);\n\t}\n\n\tfloat d1, d2;\n\td1 = MAX_DIST;\n\t\n\tfor (int i = 0; i < 15; i++)\n\t{\n        float fi = float(i);\n\t\tfloat id = fract(hash(fi));\n\t\tvec3 pos1 = pos;\n\t\tpos1.xz = rotate(pos1.xz, (fi + id * 0.2) * 20.0 + 4.4);\n\t\tpos1.z += 80.0 + 30.0 * id;\n\t\tpos1.y += sin(id * 0.5 + pos.x * 0.2 + pos.z * 0.3) * 1.5 + 10.0 * id + 5.0;\n\t\tpos1.xy = rotate(pos1.yx, (fi + id * 0.1) * 0.1);\n\n\t\td2 = sdEllipsoid(pos1, (vec3(0.5, 1.0, 0.8) + id * vec3(0.4, 0.2, 0.3)) * 25.0);\n\t\td1 = smin(d1, d2, 5.0);\n\t}\n\n\treturn vec2(d1, MATERIAL_MOUNTAIN);\n}\n\nfloat sdTree(in vec3 pos)\n{\n\tfloat d1, d2;\n\tvec3 pos1;\n\n\tpos1 = pos;\n\td1 = sdCone(pos1, vec3(0.0), vec3(0.0, 4.0, 0.0), 1.8, 0.0);\n\n\tpos1.y += 2.2;\n\td2 = sdCone(pos1, vec3(0.0), vec3(0.0, 5.0, 0.0), 2.0, 0.0);\n\td1 = min(d1, d2);\n\n\tpos1 = pos;\n\tpos1.y += 4.0;\n\td2 = sdCone(pos1, vec3(0.0), vec3(0.0, 4.0, 0.0), 0.5, 0.0);\n\td1 = min(d1, d2);\n\n\treturn d1;\n}\n\nvec2 sdTrees(in vec3 pos)\n{\n\tfloat bounds = -(length(pos) - 40.0);\n\tif (bounds > 5.0)\n\t{\n\t\treturn vec2(bounds, 0.0);\n\t}\n\n\tfloat d1, d2;\n\n\td1 = MAX_DIST;\n\tfor (int i = 0; i < 35; i++)\n\t{\n        float fi = float(i);\n\t\tfloat id = fract(hash(fi));\n\t\tvec3 pos1 = pos;\n\t\tpos1.xz = rotate(pos1.xz, (fi + id * 0.1) * 20.0);\n\t\tpos1.z += 60.0 + 10.0 * id;\n\t\tpos1.y += sin(id + pos.x * 0.4 + pos.z * 0.4) * 0.5;\n\n\t\tpos1.y += sdGroundHeight(pos1) + 1.0;\n\t\tpos1 *= 1.2;\n\t\td2 = sdTree(pos1);\n\t\td1 = min(d1, d2);\n\t}\n\n\treturn vec2(d1, MATERIAL_TREE);\n}\n\nfloat getCloud(in vec2 uv)\n{\n\tuv *= 0.8;\n\treturn sin(uv.x) + sin(uv.y) + 0.5 * sin(uv.x * 2.0) + 0.7 * sin(uv.y * 2.0);\n}\n\nvec3 getSkyTexture(in vec3 rd)\n{\n\tvec3 color = vec3(0.05, 0.4, 0.95);\n\n\tvec2 uv = rd.xz / rd.y; // uv map\n\tfloat cloud = getCloud(uv);\n\tvec3 cloudColor = mix(vec3(0.8, 0.75, 1.0), vec3(0.6, 0.3, 0.6), clamp((cloud - 0.5) * 0.2, 0.0, 1.0));\n\n\tcolor = mix(color, cloudColor, clamp((cloud - 1.0) * 10.0, 0.0, 1.0));\n\n\t// fog\n\tcolor = mix(color, vec3(0.5, 0.85, 0.95), clamp(1.0 - 2.0 * rd.y, 0.0, 1.0));\n\n\treturn color;\n}\n\nvec2 map(in vec3 pos)\n{\n\tvec2 d1, d2;\n\n\td1 = vec2(MAX_DIST, 0.0);\n\td1 = sdMoomin(pos - vec3(0.0, 2.0, 0.0));\n\t//d1 = vec2(sdEllipsoid(pos - vec3(0.0, 4.0, 0.0), vec3(2.0, 3.0, 2.0)), MATERIAL_SKIN);\n\n#ifdef SCENE_BACKGROUND\n\td2 = sdMountains(pos);\n \td1 = min2(d1, d2);\n\n\td2 = sdTrees(pos);\n\td1 = min2(d1, d2);\n#endif\n\n\td2 = sdGrass(pos);\n\td1 = min2(d1, d2);\n\n\treturn d1;\n}\n\nvec3 getNormal(in vec3 pos)\n{\n\tfloat d = map(pos).x;\n\tvec2 e = vec2(0.0001, 0.0); // offset\n\n\tvec3 nor = d - vec3(map(pos - e.xyy).x, map(pos - e.yxy).x, map(pos - e.yyx).x); // normal\n\n\treturn normalize(nor);\n}\n\nvec2 castRay(in vec3 ro, vec3 rd) // ray origin, ray direction\n{\n\tfloat d = 0.0; // distance from ray origin\n\tfloat m = 0.0; // material\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + rd * d; // current position\n\t\tvec2 ds = map(pos); // distance from current position to the scene\n\t\tm = ds.y;\n\n\t\tif (abs(ds.x) < SURF_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\td += ds.x;\n\n\t\tif (d > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn vec2(d, m);\n}\n\nfloat calcOcclusion(in vec3 pos, vec3 nor)\n{\n\tfloat occlusion = 0.0; // occlusion\n\tfloat scale = 1.0; // scale\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h = 0.01 + 0.11 * float(i) / 4.0;\n\t\tvec3 occlusionPos = pos + h * nor; // occlusion position\n\t\tfloat d = map(occlusionPos).x;\n\t\tocclusion += (h - d) * scale;\n\t\tscale *= 0.95;\n\t}\n\n\treturn clamp(1.0 - 2.0 * occlusion, 0.0, 1.0);\n}\n\nfloat castShadow(in vec3 ro, vec3 rd)\n{\n\tfloat result = 1.0;\n\tfloat t = 0.01; // position\n\n\tfloat maxT = MAX_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat d = map(pos).x;\n\t\tresult = min(result, max(0.0, 16.0 * d / t)); // soft shadow\n\t\tt += d;\n\n\t\tif (abs(d) < (t * 0.001) || t > maxT)\n\t\t\tbreak;\n\t}\n\n\tvec3 cloudPos = ro + rd.y * (60.0 - ro.y); // cloud height\n\tfloat cloud = getCloud(cloudPos.xz * 0.1);\n\tresult *= (1.0 - 0.3 * smoothstep(0.3, 1.0, cloud));\n\n\treturn result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 target = vec3(0.0, 2.5, 0.0); // camera target\n\tfloat dist = 4.0; // camera distance\n\n\tfloat fov = 1.5; // field of view\n\n\tvec3 ro = vec3(sin(2.8) * dist, 5.0, cos(2.8) * dist); // camera origin\n\n\t#ifdef MOUSE_ROTATE2\n        vec2 m = iMouse.xy / iResolution.xy;\n\n        // mouse camera angle\n\t\tvec2 an = vec2(6.0 + 12.0 * m.x, -3.0 * (1.0 + clamp(m.y, 0.0, 1.0)));\n\n        if (m.x < 0.001 && m.y < 0.001) // jump to default position\n        {\n            an = vec2(2.8, 0.0);\n        }\n\n\t\tdist = 6.0;\n\t\tfov = 1.2;\n\n\t\t//dist = 8.0;\n\t\t//target.y += 1.0;\n\n\t\tvec3 dir = normalize(vec3(0.1, 0.3, 0.4)); // camera direction\n\t\tdir.yz = rotate(dir.yz, an.y);\n\t\tdir.xz = rotate(dir.xz, an.x);\n\t\tro = target + dir * dist;\n\t\tro.y = max(0.01, ro.y);\n\n\t#else\n\t\t#ifdef MOUSE_ROTATE1\n\t\t\tfloat an = 2.8 + 12.0 * (iMouse.x - 0.5);\n\t\t\tro = vec3(sin(an) * dist, 7.0, cos(an) * dist); // camera origin\n\t\t#endif\n\t#endif\n\n\t// camera direction\n\t//vec3 rd = normalize(vec3(uv.xy, -1.0));\n\tvec3 rdz = normalize(target - ro);\n\tvec3 rdx = normalize(cross(rdz, vec3(0.0, 1.0, 0.0)));\n\tvec3 rdy = cross(rdx, rdz);\n\tvec3 rd = normalize(uv.x * rdx + uv.y * rdy + fov * rdz);\n\n\tvec2 dm = castRay(ro, rd);\n\tvec3 pos = ro + dm.x * rd; // point in scene\n\tvec3 nor = getNormal(pos); // point normal\n\tvec3 posOffset = pos + nor * SURF_DIST; // point with a small offset\n\n\tvec3 color = vec3(0.0);\n\n\tif (dm.x < MAX_DIST)\n\t{\n\t\t// object\n\t\tvec3 material;\n\n\t\tif (dm.y < 0.5)\n\t\t{\n\t\t\tmaterial = vec3(1.0, 1.0, 0.0); // missing\n\t\t}\n\t\telse if (dm.y < MATERIAL_SKIN + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.3, 0.3, 0.35);\n\t\t}\n\t\telse if (dm.y < MATERIAL_EAR + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.5, 0.3, 0.3);\n\t\t}\n\t\telse if (dm.y < MATERIAL_HAIR + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.1);\n\t\t}\n\t\telse if (dm.y < MATERIAL_GRASS + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.25, 0.25, 0.0);\n\t\t}\n\t\telse if (dm.y < MATERIAL_FLOWER1 + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.5, 0.2, 0.0);\n\t\t}\n\t\telse if (dm.y < MATERIAL_FLOWER2 + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.5, 0.5, 0.2);\n\t\t\tmaterial += 0.1 * cos((dm.y - MATERIAL_FLOWER2) * 100.0 * vec3(0.6, 0.5, 0.2)); // variation\n\t\t}\n\t\telse if (dm.y < MATERIAL_MOUNTAIN + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.2, 0.3, 0.5);\n\t\t}\n\t\telse if (dm.y < MATERIAL_TREE + 0.5)\n\t\t{\n\t\t\tmaterial = vec3(0.04, 0.15, 0.1);\n\t\t}\n\n\t\tfloat occlusion = calcOcclusion(pos, nor);\n\t\tfloat fresnel = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // fresnel\n\n\t\t// sun\n\t\t//vec3 sunDirection = normalize(vec3(0.8, 0.4, 0.2));\n\t\tvec3 sunDirection = normalize(vec3(0.5, 0.5, -0.6));\n\t\tfloat sunDiffuse = clamp(dot(nor, sunDirection), 0.0, 1.0);\n\t\tfloat sunShadow = castShadow(posOffset, sunDirection);\n\n\t\tfloat bounceDiff = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0); // bounce diffuse, from the ground\n\n\t\tvec3 sunLight = sunDiffuse * 4.0 * vec3(0.7, 0.4, 0.3); // sun color\n\t\tsunLight *= vec3(sunShadow, pow(sunShadow, 1.5), pow(sunShadow, 3.0)); // sun shadow transition color\n\t\tsunLight += vec3(0.25, 0.25, 0.0) * bounceDiff; // bounce light\n\t\tsunLight += fresnel * 3.0 * vec3(0.6, 0.8, 1.2) * (0.5 + 0.5 * sunDiffuse) * (0.9 + 0.1 * clamp(sunShadow, 0.0, 1.0)); // sun fresnel\n\n\t\t// sky light\n\t\tvec3 skyDirection = normalize(vec3(0.0, 1.0, 0.0));\n\t\tfloat skyDiffuse = clamp(0.5 + 0.5 * dot(nor, skyDirection), 0.0, 1.0); // sky diffuse\n\t\tfloat skyReflection = smoothstep(0.3, 0.5, reflect(rd, nor).y); // sky reflection\n\t\tvec3 skyColor = vec3(0.1, 0.8, 1.0);\n\t\tvec3 skyLight = 0.3 * skyDiffuse * skyColor + 0.02 * skyReflection * skyColor;\n\n\t\t#ifdef SCENE_BACKGROUND\n\t\tfloat fog = pow(smoothstep(5.0, 80.0, dm.x), 2.0);\n\t\t#else\n\t\tfloat fog = pow(smoothstep(5.0, 40.0, dm.x), 2.0);\n\t\t#endif\n\t\tfog *= clamp(1.0 - rd.y * 6.0, 0.0, 1.0);\n\n\t\tcolor = material;\n\t\tcolor *= sunLight;\n\t\tcolor += skyLight;\n\t\tcolor *= occlusion;\n\t\tcolor = mix(color, vec3(0.5, 0.85, 0.95), fog);\n\t}\n\telse\n\t{\n\t\t// sky texture\n\t\tcolor = getSkyTexture(rd);\n\t}\n\n\t// gamma correction\n\tcolor = pow(color, vec3(0.5));\n\n\t#ifdef OVERLAY\n\t// overlay\n\tvec3 fillCol = vec3(0.522, 0.788, 0.824);\n\tvec2 texPos = uv * 0.5;\n\tvec3 texCol = abs(texPos.x) < 0.5 && abs(texPos.y) < 0.5 ?\n\t\ttexture(texture1, (texPos - vec2(0.5))).rgb : fillCol;\n\tcolor = mix(color, texCol, pow(distance(texCol, fillCol), 0.3) * 0.1);\n\t#endif\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}