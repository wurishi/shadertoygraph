{"ver":"0.1","info":{"id":"wsGyDt","date":"1604011327","viewed":157,"name":"sphere integration + ssao","username":"melissaran","description":"mat test","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 chrom=(uv-0.5)*0.03;\n    float r= texture(iChannel0,uv).r;\n    float g= texture(iChannel0,uv+chrom).g;\n    float b= texture(iChannel0,uv+chrom*2.).b;\n\t\n    float ao= texture(iChannel1,uv).r;\n   \tfragColor = vec4(r,g,b,1.0)*(ao);\n    //fragColor=vec4(vec3(ao),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//depthnormal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro= vec3(0.,sin(iTime)+3.5,-2.);\n    vec3 rd= rotate_x(normalize(vec3(uv.x,uv.y,1.2)),sin(iTime)*0.5+0.5);\n\t\n    float d=march(ro,rd);\n        if(d>20.){\n            vec4 col2 = vec4(30.);\n            fragColor=vec4(col2.xyz,1.);\n            //fragColor=vec4(col2.xyz,1.)+fogcol*fog;\n        }else{\n            vec3 n=norm(ro+d*rd);\n    \t\tfragColor = vec4(d,n);\n            //fragColor = mat(ro+d*rd,n,rd)+fogcol*fog;\n        }\n        \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//materials\n\nvec2 bc(vec3 ro, vec3 rd, vec3 sc, float r){\n    float b = dot(rd, ro-sc);\n    float c=pow(length(ro-sc),2.)-r*r;\n    return vec2(b,c);\n}\n\nvec2 sphereIntersect(float b, float c){\n    float t=sqrt(b*b-c);\n    return vec2(-b+t,-b-t);\n}\n\nfloat fogIntFunc(float b, float c, float r, float t){\n    float t2=t*t;\n    float t3=t2*t;\n    return (1./r/r)*(c*t+b*t2+t3/3.);\n}\n\nfloat fogInt(vec3 ro, vec3 rd, vec3 sc, float r, float clip){\n    vec2 bc=bc(ro, rd, sc, r);\n    if(bc.x*bc.x<bc.y) return 0.;\n    vec2 t = sphereIntersect(bc.x,bc.y);\n    if(clip<t.y) return 0.;\n    t.x=min(t.x,clip);\n    return fogIntFunc(bc.x,bc.y,r,t.y)-fogIntFunc(bc.x,bc.y,r,t.x);\n}\n\n\nfloat ndotl(vec3 n, vec3 lp, vec3 p, vec3 l){\n\tfloat d =march(p+n*0.2,l);\n    float ndl = clamp(dot(n,l),0.,1.);\n    if(d<length(p-lp))ndl*=0.1;\n    \n    //float vs=vshadow(l,p,d);\n\n    //return ndl*vs;\n    \n    return ndl;\n}\n\nvec4 mat(vec3 p, vec3 n, vec3 vdir){\n    vec3 lp=vec3(cos(iTime)*2.,3.,-2.);\n    vec3 l=normalize(lp-p);\n    float nl=ndotl(n,lp, p,l);\n    \n\tvec3 r = reflect(vdir,n);\t\n\tfloat reflectance = dot(l,r)*.5+.5;\n    float fre=1.-clamp(0.,1.,dot(n,-vdir));\n    fre=pow(fre,2.);\n    vec4 ref=fre*texture(iChannel2,-r);\n    \n    vec4 col=mix(vec4(0.),vec4(1.), nl);\n    col*=reflectance;\n    col+=ref;\n    p.z=max(0.,p.z)*0.2;\n    \n    float fog=1.-1./(1.+p.z*p.z);\n    \n    col= mix(col, vec4(0.),fog);\n   \tcol.w=1.;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro= vec3(0.,sin(iTime)+2.,-2.);\n    vec3 rd= rotate_x(normalize(vec3(uv.x,uv.y,1.2)),sin(iTime)*0.5+0.5);\n\tvec2 uv2=(fragCoord/iResolution.xy);\n         vec4 depthnorm=texture(iChannel0,uv2);\n    float d=depthnorm.x;\n        float fog= fogInt(ro,rd,vec3(sin(iTime)*2.,0.,0.5),2.,d)*0.4;\n\t\tvec4 fogcol=vec4(1.,0.9,0.8,1.);\n    \n        if(d>20.){\n            vec4 col2 = vec4(0.);\n            fragColor=mix(vec4(col2.xyz,1.),fogcol,fog);\n            //fragColor=vec4(col2.xyz,1.)+fogcol*fog;\n        }else{\n            vec3 n = depthnorm.yzw;\n    \t\tfragColor = mix(mat(ro+d*rd,n,rd),fogcol,fog);\n            //fragColor = mat(ro+d*rd,n,rd)+fogcol*fog;\n        }\n        \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 proj(vec3 a , vec3 b){\n    return (dot(a,b)/dot(b,b))*b;\n}\n\n\nfloat map(vec3 p){\n  \tp.z=p.z-round(p.z);\n    return smin(dot(p,vec3(0.,1.,0.)),length(p+vec3(0.,-2.,0.))-0.4,4.);\n}\n\n\n\nvec3 norm(vec3 p){\n    //approx\n    \n    float d=map(p);\n    vec2 e = vec2(0.01,0.);\n    vec3 n= d- vec3(map(p-e.xyy),\n                    map(p-e.yxy),\n                    map(p-e.yyx));\n    \n                    \n\treturn normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float d=0.;\n    for(int i=0;i<80;i++){\n        vec3 p= ro+d*rd;\n        float dist = map(p);\n        d+=dist;\n        if(abs(dist)<0.01 || d>20.) break;\n    }\n    return d;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uvf=fragCoord/iResolution.xy;\n    \n    \n    float d=texture(iChannel0,uvf).x;\n    \n        vec2 e=vec2(0.,0.01/d);\n\n    \n    float d0=texture(iChannel0,uvf+e.xy).x-d;\n    float d1=texture(iChannel0,uvf-e.xy).x-d;\n\tfloat d2=texture(iChannel0,uvf+e.yx).x-d;\n    float d3=texture(iChannel0,uvf-e.yx).x-d;\n    \n    float dev=(d0*d0+d1*d1+d2*d2+d3*d3)*0.25;\n    \n\n    \n    fragColor=vec4(1./(1.+dev));\n}*/\nvec3 unKernel[16] = vec3[](\n    \tvec3(0.,1.,0.),vec3(0.,-1.,0.),vec3(1.,0.,0.),vec3(-1.,0.,1.),\n    \tvec3(1.,1.,0.),vec3(1.,-1.,0.),vec3(1.,-1.,1.),vec3(-1.,-1.,-1.),\n    \tvec3(0.,1.,1.),vec3(-1.,-1.,0.),vec3(1.,0.,-1.),vec3(-1.,-1.,0.),\n    \tvec3(-1.,1.,0.),vec3(0.,-1.,1.),vec3(1.,-1.,-1.),vec3(-1.,1.,1.)\n    );\n\nvec3 orientate(vec3 v, vec3 n){\n    if(dot(v,n)<0.) return -v;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uvf=fragCoord/iResolution.xy;\n    \n    \n    float z=texture(iChannel0,uvf).x;\n    \n    vec3  nor = texture(iChannel0,uvf).yzw;    // read normal\n    vec3  ref = normalize(texture(iChannel1,uvf*10.).xyz-0.5);    // read normal\n\t\n    // accumulate occlusion\n    float bl = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n       // vec3  of = orientate(reflect( unKernel[i], ref ),nor);\n       vec3 of=reflect( unKernel[i], ref );\n        float sz = texture(iChannel0,uvf+0.03*of.xy).x;//texture2D( unTexZ, uv+0.03*of.xy).x;\n        float zd = clamp(-0.1,0.1,sz-z);\n        //bl += clamp(zd,-1.0,1.0)*(clamp((zd-1.0)/5.0,0.0,1.0));\n        bl+=(zd*zd/(pow(z,2.5)));\n    }\n\n    fragColor=vec4( 1.0 - bl/8.);\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}