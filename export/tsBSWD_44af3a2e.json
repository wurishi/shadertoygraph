{"ver":"0.1","info":{"id":"tsBSWD","date":"1554044046","viewed":8701,"name":"Colored lines","username":"hamtarodeluxe","description":"2d IFS fractal evolving with time and along up axis.","likes":250,"published":1,"flags":32,"usePreview":0,"tags":["lines","color","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//bloom and DOF. Check buffer's #define to tweak the shape\nfloat [] blurWeights = float[](0.002216,\n   0.008764,\n   0.026995,\n   0.064759,\n   0.120985,\n   0.176033,\n   0.199471,\n   0.176033,\n   0.120985,\n   0.064759,\n   0.026995,\n   0.008764,\n   0.002216);\n\nvec4 blur (vec2 uv)\n{\n    vec4 res;\n\tfor (int x = - 6; x < 6; x ++)\n    {\n    \tfor (int y = -6 ; y < 6; y ++)\n        {\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n   \tvec4 buf = texture( iChannel0, ( uv));\n    vec3 blr = blur(uv).rgb;\n    float near =3.; float mid = 9.; float far = 15.;\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\n    vec3 col = mix (blr,buf.rgb,curve);\n    col.rgb += 0.5*blr;\n\n    fragColor = vec4 (col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Marching parameters\n#define MAXSTEPS 50\n#define HITTHRESHOLD 0.009\n#define FAR 25.\n//AA : change to 1 to turn it off\n#define AA 2\n//IFS iterations : try 2 or 3\n#define NIFS 6\n//scale and translate for the IFS in-loop transformation\n#define SCALE 2.3\n#define TRANSLATE 3.5\n\nmat2x2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2x2(c, -s,\n\t\t\t\t  s, c);\n}\n\nvec4 sd2d(vec2 p, float o)\n{\n    float time = 0.2*o+0.6*iTime;\n \tfloat s =0.5;\n    p*= s;\n    float RADIUS =(1.+sin(iTime));\n    int i;\n    vec3 col;  \n    p = p*rot(-0.4*time);// twist\n\n    for ( i = 0; i<NIFS; i++)\n    {        \n        if (p.x<0.) {p.x = -p.x;col.r++;}\n\t\tp = p*rot(0.9*sin(time));\n        if (p.y<0.) {p.y = -p.y;col.g++; }\n        if (p.x-p.y<0.){ p.xy = p.yx;col.b++;}        \n      \tp = p*SCALE-TRANSLATE;\n        p = p*rot(0.3*(iTime));\n    }\n    \n    float d = 0.425*(length(p)-RADIUS) * pow(SCALE, float(-i))/s;\n    col/=float(NIFS);\n    vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\n    \n    return vec4(oc,d);\n}\n\nvec4 map (vec3 p)\n{\n\treturn sd2d(p.xz,p.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float h = 0.;\n    float k =3.5;//shadowSmooth\n    float res = 1.;\n    float t = 0.2; //bias\n    for (int i = 0; t < 15.; i++) // t < shadowMaxDist\n    {\n        h = map(ro + rd * t).w;\n\t\tres = min(res, k*h / t);\n        if (h < HITTHRESHOLD)\n        {\n           break;\n        }\n        t = t + h;\n    }\n    return clamp(res+0.05,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //camera\n    float height = -0.4;\n    float rot=iTime*0.1;\n    float dist= 9.+1.*sin(0.5*iTime);\n    vec3 ro = dist * vec3(cos(rot),height,sin(rot));\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-ro);\n    //tilting camera for a \"weirder\" feel when rotating around Y axis\n    vec3 right = normalize(cross(vec3(0.,1.,1.0), fw));\n    vec3 up = normalize(cross (fw, right));\n    right = normalize(cross(up,fw));\n    \n    //light\n    rot+=sin(iTime)*0.2;\n    vec3 lightPos =  dist * vec3(cos(rot),height,sin(rot));\n    \n    //raymarch\n    vec3 pos, closest;\n    float t;\n    float smallest;\n    int i;\n    vec3 sdfCol; \n    vec3 col;\n    \n    for (int x=0; x<AA;x++)\n    for (int y=0; y<AA;y++)\n    {\n        t = 0.; smallest = 500.;\n        vec2 o = vec2(float(x),float(y)) / float(AA) - 0.5;\n        vec2 uv = (fragCoord+o)/iResolution.xy;\n        uv -= 0.5;\n        uv.x *= iResolution.x/iResolution.y; \n        vec3 rd = normalize( fw *0.5 + right * uv.x + up * uv.y);  \n        \n        for ( i=0; i<MAXSTEPS; i++)\n        {\n            pos = ro + rd *t;   \n            vec4 mr = map(pos);\n            float d = mr.w;\n            if (d < smallest) smallest = d; closest = pos; sdfCol = mr.rgb;\n            if (abs(d)<HITTHRESHOLD || t> FAR) {break;}\n            t +=d;\n        }   \n        pos = closest;\n        vec3 c;\n        if (t<FAR)\n        { \n            c = sdfCol; \n            vec3 toLight = normalize(lightPos-pos);\n            float s = shadow(pos,toLight);\n            c*=s; \n          \tc = mix(c, 1.5*c,1.-s);\n        }\n        else \n        {\n            c = vec3(0.);                \n        }     \n        col += c;\n    }\n    col/=float(AA*AA);\n    \n    fragColor = vec4 (col,t);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}