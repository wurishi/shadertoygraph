{"ver":"0.1","info":{"id":"Mt3SRf","date":"1480803898","viewed":349,"name":"3D Raymarch Tunnel","username":"TrueBoolean","description":"A simple 3D tunnel with a low step count. What's a good way to generate a 3D procedural texture? I'd use a 3D XOR pattern, but XOR does not work in GLSL.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","tunnel","raymarch","square","depth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 c, vec2 uv ){\n\tuv = (uv/iResolution.xy) * 2. - 1.;\n    uv.x*=iResolution.x/iResolution.y;\n    c-=c;\n    vec2 ray;\n    #define ITER 16.\n    for(float z=0.;z<ITER;z+=1.){\n        float scale = (z>3.)?2.: 1.;\n        scale = (z>10.)?1.:scale;\n        ray = uv*z;\n        ray.x+=sin(iTime);\n        ray.y+=sin(iTime/3.);\n        vec2 r = abs(ray);\n         if(max(r.x, r.y) > scale){\n             float fog = 1.-z/ITER;\n             //float s = z * iTime;\n             float s = z;\n\t\t\tfloat col = (mod(  s , 2.) < 1.) ? 1. - fog : fog;\n            c=vec4(vec3(col), 1.);\n            break;\n        }\n    }\n}\n\n/*\n//Better one:\n\nvoid mainImage(out vec4 C, vec2 U){\n\n    vec2 R = iResolution.xy;\n\tU = (U+U-R)/R.y;\n    R -= R;\n    C -= C;\n    for (float z = 1.; z > 0. && length(R+sin(iTime)) < 2.; z -= .1)\n        R += U,\n        C.zy += z-C.xy; //Color added, just for fun\n}\n\n*/","name":"Image","description":"","type":"image"}]}