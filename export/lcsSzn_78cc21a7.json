{"ver":"0.1","info":{"id":"lcsSzn","date":"1704880206","viewed":116,"name":"Polaris","username":"pitchsend","description":"Fractal rendering based on SDF and raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433\n#define Iterations 20\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat DE(vec3 z, float Scale)\n{\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < Iterations) {\n\t\t c = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(Scale, float(-n));\n}\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette1(float t) {\n    return .5+.5*cos(6.28318*(t+vec3(.3,.416,.557)));\n}\n\nvec3 palette2(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n// Scene distance\nfloat map(vec3 p) {\n    vec3 p2 = vec3(p.xy * rotate2d(PI / 2.0), p.z);\n    //float d1 = DE(p, 1.5 - 0.5 * cos(0.2 * iTime));\n    //float d2 = DE(p2, 1.5 + 0.5 * cos(0.2 * iTime));\n    float d1 = DE(p, 1.5 - 0.5 * cos(0.2 * iTime));\n    float d2 = DE(p2, 1.5 - 0.5 * cos(0.2 * iTime));\n    return smin(d1, d2, 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(0, 0, -2);         // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n    \n    rd.xy *= rotate2d(-PI / 4.0);\n\n    float t = 0.; // total distance travelled\n\n    // Raymarching\n    int i = 0;\n    for (; i < 80; i++) {\n        vec3 p = ro + rd * t;     // position along the ray\n\n        float d = map(p);         // current distance to the scene\n\n        t += d;                   // \"march\" the ray\n\n        if (d < .001) break;      // early stop if close enough\n        if (t > 100.) break;      // early stop if too far\n    }\n\n    // Coloring\n    float u = log(0.1*t) + 0.3 * iTime;\n    float q = length(0.25 * uv) + float(i) / 80.0 + 0.2 * iTime;\n    col = vec3(palette1(u) * palette2(q));\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}