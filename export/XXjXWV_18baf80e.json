{"ver":"0.1","info":{"id":"XXjXWV","date":"1711112152","viewed":43,"name":"Isometric Implicit Surface","username":"kowalski_analytics","description":"Rendering an implicit surface using raymarching (either direct or via Newton rootfinding).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","isometric","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265\n\nfloat A[5] = float[5](11./19., -1./6., -2./300., -10./525., -1./542.);\n\nfloat f ( vec3 r ) {\n    vec3 cyl =  Cartesian_To_Cylindrical(r);\n    \n    float s = 0.;\n    for (int n = 0; n<5; n++) {\n        s += A[n] * cos(cyl.y * 6. * float(n));\n    }\n    \n    float f = 0.;\n    \n    if (-2. < cyl.z && cyl.z < 0.7)\n        f = -s/(cyl.z - 1.1) - cyl.x;\n    else \n        f = 100.;\n        \n    if ( cyl.z < 2. ) {\n        s = cyl.x - 0.3 * (pow(cyl.z, 1./6.) - 0.6/(cyl.z - 2.4) ) * (1. + 0.1 * cos(12. * cyl.y) );\n        f = min(f,s);\n    }\n    \n    return f;\n}\n\nvec3 df ( vec3 r ) {\n    return 2.*r;\n}\n\nvec3 Newton_Raymarch( vec3 p0, vec3 ray ) {\n    float l = 0.;\n    vec3 x = vec3(0);\n    \n    for (int i=0; i<1000; i++){\n        x = p0 + l * ray;\n        l -= 0.1* f(x) / dot(ray, df(x));\n    }\n    \n    return x;\n}\n\nvec3 Raymarch( vec3 p0, vec3 ray ) {\n    vec3 x = vec3(0);\n    \n    for(float l = -10.; l < 10.; l+=0.01){\n        x = p0 + l * ray;\n        if (abs(f(x)) < 0.05) break;\n    }\n    \n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2. * fragCoord/iResolution.y  - iResolution.xy/iResolution.y;\n    vec2 tf = 2. * iMouse.xy/iResolution.xy;\n    \n    uv *= 2.;\n    \n    if (iMouse.z == 0.) {\n        tf = vec2(0.1,0.05) * iTime;\n    }\n    \n    // Theta and Phi\n    float t = tf.y * 2. * pi;\n    float p = tf.x * pi;\n    \n    // basis vectors r, theta, phi\n    vec3 ray = vec3(sin(t) * cos(p), sin(t) * sin(p),  cos(t));\n    vec3 p1  = vec3(cos(t) * cos(p), cos(t) * sin(p), -sin(t));\n    vec3 p2  = vec3(        -sin(p),          cos(p),    0.  );\n    \n    // assign raytracing initial conditions\n    vec3 p0 = p1 * uv.x + p2 * uv.y;\n    ray = -ray;\n\n    vec3 x = Raymarch(p0, ray);\n    \n    // now, assign a color according to whether or not it's on the surface\n    vec3 col = vec3(0.);\n    vec3 cyl = Cartesian_To_Cylindrical(x);\n    \n    if ( abs( f(x) ) < 0.1 ) { \n        col = texture(iChannel0, cyl.yz/6.).xyz;\n        if (mod(cyl.z, 0.2) < 0.01) col.x = 1.;\n        if (mod(cyl.y, 0.2) < 0.01) col.y = 1.;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = texture(iChannel0, cyl.yz);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 Cartesian_To_Cylindrical( vec3 r ){\n    float rho = length(r.xy);\n    float phi = atan(r.y, r.x);\n    float z = r.z;\n    \n    return vec3(rho, phi, z);\n}\n\nvec3 Jacobian_cart_to_cyl (vec3 r, vec3 dr ) {\n    return vec3(0);\n}","name":"Common","description":"","type":"common"}]}