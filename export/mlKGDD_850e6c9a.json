{"ver":"0.1","info":{"id":"mlKGDD","date":"1684063910","viewed":22,"name":"Naxaes - Ray marching","username":"Naxaes","description":"Just experimenting with ray marching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on tutorial from: https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n// Set to 0 to turn off and 1 to turn on.\n#define SOFT_SHADOWS       1\n#define DISPLACE_SPHERE    0\n#define DISPLACE_TORUS     0\n#define USE_WAVY_DISPLACE  0\n\n#define FOG_EXPONENT_FACTOR 0.00000003\n\n\n#if USE_WAVY_DISPLACE\n    #define Displace Wavy\n#else\n    #define Displace Golf\n#endif\n\n\nconst int   MAX_STEPS    = 3500;\nconst float MAX_DISTANCE = 350.0;\nconst float MIN_DISTANCE = 0.0001;\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Distance\n{\n    float t;\n    int   id;  // ID of primitive\n};\n\n\nDistance Closest(Distance a, Distance b) \n{\n    if (a.t < b.t) return a; else return b;\n}\n\n\n// Returns the shortest distance\n// from the point to all other \n// boundaries in the scene.\nDistance GetClosestDistance(vec3 point)\n{\n    Sphere    sphere = Sphere(vec3(0, 1, 6), 1.0);\n    AAPlane   plane  = AAPlane(0.0);\n    Torus     torus  = Torus(vec3(0, 0.4, 2.5), 0.75, 0.2);\n    Box       box    = Box(vec3(2.0, 0, 5.0), vec3(0.2, 3.2, 1.0));\n    Ellipsoid ellips = Ellipsoid(vec3(-2.0, 1.0, 5.0), vec3(0.4, 0.8, 0.4));\n    \n    \n    Distance result = Distance(sdf(point, plane), 1);\n    #if DISPLACE_SPHERE\n        result = Closest(result, Distance(sdf(Displace(point), sphere), 2));\n    #else\n        result = Closest(result, Distance(sdf(point, sphere), 2));\n    #endif\n    #if DISPLACE_TORUS\n        result = Closest(result, Distance(sdf(Displace(point), torus),  3));\n    #else\n        result = Closest(result, Distance(sdf(point, torus),  3));\n    #endif\n    result = Closest(result, Distance(sdf(point, box),    4));\n    result = Closest(result, Distance(sdf(point, ellips), 5));\n    \n    return result;\n}\n\n\nDistance RayMarch(Ray ray)\n{\n    float ray_distance = 0.0;\n    for (int _ = 0; _ < MAX_STEPS; ++_)\n    {\n        vec3     point = ray.origin + ray.direction * ray_distance;\n        Distance dist  = GetClosestDistance(point);\n        \n        ray_distance += dist.t;\n        \n        if (dist.t < MIN_DISTANCE)\n            return Distance(ray_distance, dist.id);\n        else if (ray_distance > MAX_DISTANCE)\n            break;\n    }\n    return Distance(ray_distance, 0);\n}\n\n\nvec3 GetNormal(vec3 point)\n{\n    float d = GetClosestDistance(point).t;\n    vec2  e = vec2(0.01, 0.0);\n    vec3  n = d - vec3(\n        GetClosestDistance(point-e.xyy).t,\n        GetClosestDistance(point-e.yxy).t,\n        GetClosestDistance(point-e.yyx).t\n    );\n    return normalize(n);\n}\n\n\nfloat Softshadow(Ray ray)\n{\n    const float T_MAX = 8.0;\n\n    float result = 1.0;\n    float t      = 0.01;\n    float ph     = 1e20;\n   \n    for (int i = 0; i < 32; i++)\n    {\n        float h = GetClosestDistance(ray.origin + ray.direction * t).t;\n                \n        float y = h*h / (2.0 * ph);\n        float d = sqrt(h*h - y*y);\n        result  = min(result, 10.0 * d / max(0.0, t-y));\n        ph = h;\n        \n        t += h;\n        \n        if (result < MIN_DISTANCE || t > T_MAX) \n            break;\n    }\n    return result;\n}\n\n\nvec3 Phong(Ray ray, Distance dist, vec3 camera, Material material)\n{\n    float t = iTime;\n    float s = 5.0;\n    vec3 light = vec3(s * cos(t), 10, 6.0 + s * sin(t));\n    \n    vec3 point = ray.origin + ray.direction * dist.t;\n    \n    // Ambient\n    vec3 ambient = material.ambient;\n    \n    // Diffuse\n    vec3  to_light     = light - point;\n    vec3  dir_to_light = normalize(to_light);\n    vec3  normal       = GetNormal(point);\n    float d_factor     = clamp(dot(normal, dir_to_light), 0.0, 1.0);\n    vec3  diffuse      = d_factor * material.diffuse;\n    \n    // Shadow\n    #if SOFT_SHADOWS\n        diffuse *= Softshadow(Ray(point, dir_to_light));\n    #else\n        Distance shadow = RayMarch(Ray(point + normal * 1.001 * MIN_DISTANCE, dir_to_light));\n        if (shadow.t < length(to_light))\n            diffuse *= 0.1;\n    #endif\n    \n    // Specular\n    vec3  dir_to_camera  = normalize(camera - point);\n    vec3  dir_reflection = reflect(-dir_to_light, normal);\n    float s_factor       = pow(max(dot(dir_to_camera, dir_reflection), 0.0), material.shininess);\n    vec3  specular       = s_factor * diffuse;\n\n    // Fog (darkness gradient at farther distances)\n    float fog = exp(-FOG_EXPONENT_FACTOR * dist.t * dist.t * dist.t);\n\n    return (ambient + diffuse + specular) * fog;\n}\n\n\nmat3 SetCamera(vec3 origin, vec3 target)\n{\n\tvec3 forward = -normalize(target - origin);\n\tvec3 upward  = vec3(0.0, 1.0, 0.0);\n\tvec3 right   = normalize(cross(forward, upward));\n\t     upward  =           cross(right,   forward);\n    return mat3(right, upward, forward);\n}\n\nvoid mainImage(out vec4 out_color, in vec2 coordinate)\n{\n    Material materials[6];\n    materials[0] = Material(vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0),  0.0);\n    materials[1] = emerald;\n    materials[2] = red_rubber;\n    materials[3] = black_plastic;\n    materials[4] = chrome;\n    materials[5] = bronze;\n\n\n    vec2 mouse = 5.0 * iMouse.xy / iResolution.xy;\n\n    // Normalized coordinate where the shortest \n    // dimension is in range [-1, 1].\n    vec2 point = (coordinate - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 target = vec3(0.0, 1.0, 6.0);\n    vec3 origin = target + vec3(15.0 * cos(1.5 - 7.0 * mouse.x), 2.0 - 1.0 * mouse.y, 15.0 * sin(-1.0 + 7.0 * mouse.x));\n    mat3 view   = SetCamera(origin, target);\n   \n    float focal = -2.5;\n    vec3  direction = view * normalize(vec3(point, focal));\n    \n    // Camera: Ray origin and direction\n    Ray ray = Ray(origin, direction);\n    \n    Distance dist  = RayMarch(ray);\n    vec3     color = vec3(0);\n    \n    if (dist.id == 0) {\n        color = vec3(0);\n    } else {\n        color = Phong(ray, dist, origin, materials[dist.id]);\n    }\n       \n    out_color = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ---- PRIMITIVES ----\nstruct Sphere \n{\n    vec3  position;\n    float radius;\n};\n\nstruct AAPlane // Axis-Aligned Plane\n{\n    float height;\n};\n\nstruct Torus\n{\n    vec3  position;\n    float width;\n    float height;\n};\n\nstruct Box \n{\n    vec3 position;\n    vec3 dimension;\n};\n\nstruct Ellipsoid \n{\n    vec3 position;\n    vec3 radius;\n};\n\n\n// An SDF (Singed Distance Field) is a function that \n// calculates the distance from a point to a boundary. The\n// distance is negative if the point is within the bounds.\nfloat sdf(vec3 point, Sphere sphere)\n{\n   return length(point - sphere.position) - sphere.radius;\n}\n\nfloat sdf(vec3 point, AAPlane plane)\n{\n   return point.y - plane.height;\n}\n\nfloat sdf(vec3 point, Torus torus)\n{\n    point -= torus.position;\n    return length(vec2(length(point.xz) - torus.width, point.y)) - torus.height;\n}\n\nfloat sdf(vec3 point, Box box)\n{\n    vec3 d = abs(point - box.position) - box.dimension;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdf(vec3 point, Ellipsoid ellipsoid) // Approximated, not exact.\n{\n    point -= ellipsoid.position; \n    float k0 = length(point /  ellipsoid.radius);\n    float k1 = length(point / (ellipsoid.radius * ellipsoid.radius));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n\n// ---- MATERIALS ---- \n// http://devernay.free.fr/cours/opengl/materials.html\nstruct Material {\n    vec3  ambient;\n    vec3  diffuse;\n    vec3  specular;\n    float shininess;\n};\n\nMaterial emerald = Material(\n    vec3(0.0215,  0.1745,   0.0215), \n    vec3(0.07568, 0.61424,  0.07568), \n    vec3(0.633,   0.727811, 0.633), \n    128.0 * 0.6\n);\nMaterial black_plastic = Material(\n    vec3(0.06), \n    vec3(0.06), \n    vec3(0.5), \n    128.0 * 0.25\n);\nMaterial red_rubber = Material(\n    vec3(0.05, 0.0,  0.0), \n    vec3(0.5,  0.4,  0.4), \n    vec3(0.7,  0.04, 0.04), \n    128.0 * 0.078125\n);\nMaterial chrome = Material(\n    vec3(0.25), \n    vec3(0.4), \n    vec3(0.774597), \n    128.0 * 0.6\n);\nMaterial bronze = Material(\n    vec3(0.2125,   0.1275,   0.054), \n    vec3(0.714,    0.4284,   0.18144), \n    vec3(0.393548, 0.271906, 0.166721), \n    128.0 * 0.2\n);\n\n\n// ---- DISPLACEMENT ----\nvec3 Wavy(vec3 point) \n{\n    float distortion = sin(6.0 * point.x) * cos(6.0 * point.y) * sin(6.0 * point.z) * 0.25;\n    point.x = point.x + distortion;\n    point.y = point.y + distortion;\n    point.z = point.z + distortion;\n    return point;\n}\n\nfloat remap01(float a, float b, float t) \n{\n    return (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d , float t) \n{\n    return remap01(a, b, t)  * (d-c) + c;\n}\n\nvec3 Golf(vec3 point) \n{\n    float dist = sin(17.0 * point.x) * cos(17.0 * point.y) * sin(17.0 * point.z) * 0.05;\n    point.x = remap(-0.5, 0.5, 0.01, 0.25, point.x + dist);\n    point.y = remap(-0.5, 0.5, 0.01, 0.25, point.y + dist);\n    point.z = remap(-0.5, 0.5, 0.01, 0.25, point.z + dist);\n    return point;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}