{"ver":"0.1","info":{"id":"WdXyWH","date":"1637001306","viewed":125,"name":"some_terrain","username":"skaplun","description":"some another terrain","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["noise","sdf","animation","nosense"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 256\n#define EPSILON 0.00001\n#define TINT vec3(.6, 1., 1.2)\n\n#define FLOOR 131.\n\nvec2 world(vec3 p){\n    vec2 texCoords = p.xz - vec2(0., .5);\n    return vec2(p.y - texture(iChannel0, texCoords).x * .1, FLOOR);\n}\n\nvec2 march(vec3 eye, vec3 marchingDirection){\n\tconst float precis = .01;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    vec2 hit = world(eye + marchingDirection * t);\n        if( hit.x < precis ) return vec2(t, hit.y);\n        t += hit.x * .15;\n    }\n    return vec2(-1.);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).x - world(vec3(p.x - EPSILON, p.y, p.z)).x,\n        world(vec3(p.x, p.y + EPSILON, p.z)).x - world(vec3(p.x, p.y - EPSILON, p.z)).x,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).x - world(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a  = iMouse.x/iResolution.x * PI * 2.;\n    vec3 eye = vec3(1. - iTime, .2 + sin(iTime * .5) * .1, 0.);\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3( -iTime, 0., 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    vec2 hit = march(eye, worldDir);\n    if (hit.x > 0.) {\n        vec3 p = (eye + hit.x * worldDir);\n        vec3 norm = estimateNormal(p);\n        \n        color = vec3(1.) * smoothstep(.025, .05, p.y) * clamp(dot(norm, vec3(0., 1., 0.)), 0., 1.);\n    }\n    return vec4(color, 1.);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.); \nstruct Ray{vec3 origin, direction;};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 hash2(vec2 p){\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nfloat n2D(vec2 p) {\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);\n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n\n}\n\n//Can't remember where I took this\nfloat terrain(vec2 p){\n    \n    p /= 8.; // Choosing a suitable starting frequency.\n    \n    // Edging the terrain surfacing into a position I liked more. Not really necessary though.\n    p += .5; \n\n    // Amplitude, amplitude total, and result variables.\n    float a = 1., sum = 0., res = 0.;\n\n    // Only five layers. More layers would be nicer, but cycles need to be taken into\n    // consideration. A simple way to give the impression that more layers are being added\n    // is to increase the frequency by a larger amount from layer to layer.\n    for (int i=0; i<5; i++){\n        \n        res += n2D(p)*a; // Add the noise value for this layer - multiplied by the amplitude.\n        //res += abs(n2D3(p) - .5)*a; // Interesting variation.\n        //res += n2D3(p)*abs(a)*.8; // Another one.\n        \n        // Scaling the position and doing some skewing at the same time. The skewing isn't \n        // mandatory, but it tends to give more varied - and therefore - interesting results.\n        // IQ uses this combination a bit, so I'll assume he came up with the figures. I've \n        // tried other figures, but I tend to like these ones as well.      \n        p = mat2(1, -.75, .75, 1)*p*2.72;\n        //p *= 3.2; // No skewing. Cheaper, but less interesting.\n        \n        sum += a; // I reasoned that the sum will always be positive.\n        \n        // Tempering the amplitude. Note the negative sign - a less common variation - which\n        // was thrown in just to mix things up.\n        a *= -.5/1.7; \n    }\n    \n   \n    return res/sum; // Return the noisy terrain value.\n    \n}\n\nconst int POINTS_CNT = 5;\nvec4 voronoi2(in vec2 coord){\n    vec2 pt = vec2(floor(coord.x) + .5 * step(0., coord.y),\n                   sign(coord.y) * .5);\n    vec2 points[POINTS_CNT] = vec2[](\n        pt, pt + vec2(1., 0.), pt + vec2(-1., 0.),\n        pt + vec2(.5, -1.*sign(coord.y)), pt + vec2(-.5, -1.*sign(coord.y)));\n\t\n    vec2 mr;\n    float minDistance = MAX_FLOAT;\n    int index = -1;\n    for(int i=0; i<POINTS_CNT; i++){\n    \tvec2 to = points[i] - coord;\n        float curDistance = distance(points[i], coord);\n        if(curDistance < minDistance){\n            minDistance = curDistance;\n            mr = to;\n            index = i;\n        }\n    }\n    minDistance = MAX_FLOAT;\n    for(int i=0; i<POINTS_CNT; i++){\n    \tif(i == index)\n            continue;\n        vec2 r = points[i] - coord;\n        if(distance(mr, r)>0.0000000000001)\n            minDistance = min(minDistance, dot((mr + r), normalize(r - mr)));\n    }\n    return vec4( minDistance, mr, float(index) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float width = 1.;\n    float f = smoothstep(.15 * width, .75 * width, voronoi2(uv).x);\n    f += f * terrain(uv * 75. - vec2(iTime, 0.)) * .5;\n\tfragColor.rgb = vec3(f);\n}","name":"Buffer A","description":"","type":"buffer"}]}