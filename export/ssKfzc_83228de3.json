{"ver":"0.1","info":{"id":"ssKfzc","date":"1658650436","viewed":137,"name":"Chebyshev Nodes","username":"Envy24","description":"Blue points - Chebyshev nodes, which used to sample function that you want to approximate opposite to equally spaced nodes.\nhttps://www.shadertoy.com/view/NsyBW1","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","theory","chebyshev","nodes"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  3.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nconst int num_of_nodes = max(51,  2);\nvec2 nodes[num_of_nodes];\n\nvoid sample_unit_circle(\n    inout vec2 nodes[num_of_nodes])\n{\n    float dtheta = PI / float(num_of_nodes - 1);\n    \n    for (int i = 0; i < num_of_nodes; ++i)\n    {\n        float theta = PI - float(i) * dtheta;\n        \n        nodes[i] = vec2(cos(theta), sin(theta)); // This is not chebyshev nodes\n        // nodes[i] = vec2(cos(theta), 0.); // This is chebyshev nodes.\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 1.03\n#define OFFSET vec2(0., 0.5)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n#define func(x)  ( cos(x) )\n#define deriv(x) ( sin(x) )\n\n#define FUNC(x, y) ( x*x+y*y-1. )\n#define GRAD(x, y) ( vec2(2.*x, 2.*y) )\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n    /* Explicit function y=f(x) *\n         color.rb -= draw_func(NDC, func(NDC.x), deriv(NDC.x));\n    /* Implicit function d=f(x,y) */\n         vec2 grad = GRAD(NDC.x, NDC.y);\n         float fxy = FUNC(NDC.x, NDC.y); \n         color.gb -= SM(abs(fxy) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y));\n    /* */                \n        \n    sample_unit_circle(nodes);\n        \n    float radius = UNIT*2.;\n        \n    for (int i = 0; i < num_of_nodes; ++i)\n    {\n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, nodes[i], radius)));       \n        color = mix(color, vec3(1, 0, 1), SM(segmentSDF_L2(NDC, vec2(nodes[i].x, 0.), nodes[i])));       \n        color = mix(color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(nodes[i].x, 0.), radius)));             \n    }   \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}