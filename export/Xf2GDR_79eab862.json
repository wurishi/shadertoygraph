{"ver":"0.1","info":{"id":"Xf2GDR","date":"1704078485","viewed":44,"name":"a little dynamic bump map detail","username":"Kerdek","description":"that helps reduce flickering","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["sdfbump"],"hasliked":0,"parentid":"XffGzH","parentname":"Finally the correct shape yeesh"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Original Shader by yx: https://www.shadertoy.com/view/Wd2Gzt\n\nconst float fillet_radius = 0.05;\nconst vec3 color = vec3(0.5, 0.55, 0.6);\nconst float gloss_ior = 2.7;\nconst float gloss_cosine_power = 100.0;\nconst vec3 ambient_light = 0.005 * vec3(3.19, 5.92, 5.22);\nconst int light_count = 4;\nvec3 lightdir[light_count] = vec3[](\n  normalize(vec3(-1.0, 1.0, 2.0)),\n  normalize(vec3(-1.0, 1.0, -2.0)),\n  normalize(vec3(1.0, 1.0, 0.0)),\n  normalize(vec3(1.0, 1.0, 0.0)));\nconst vec3 light_color[light_count] = vec3[](\n  vec3(0.6, 0.2, 0.2),\n  vec3(0.2, 0.6, 0.2),\n  vec3(0.2, 0.2, 0.6),\n  vec3(5.0));\nconst float bump_freq = 5.0;\nconst float bump_power = 2.0;\nconst float bump_threshold = -0.0;\nconst float bump_scale = -0.005;\nconst float bump_harmonics = 15.0;\nconst float bump_harmonic_denominator = 2.0;\nconst float ss = 1.0 / 1.0;\nconst float zoom = 1.6;\nconst float standback = 2.5;\nconst float dmin = 1e-5;\n\nfloat zero = 0.0;\n\n// handy nil vector\nconst vec4 nil = vec4(0.0);\n\n// basis vectors\nconst vec4 dx = vec4(1.0, nil.xyz);\nconst vec4 dy = dx.wxyz;\nconst vec4 dz = dy.wxyz;\nconst vec4 dw = dz.wxyz;\n\nmat4 translate(\n  vec4 by) {\n  return mat4(dx, dy, dz, by + dw); }\n\nmat3 scale(\n  float by) {\n  return mat3(by * dx.xyz, by * dy.xyz, by * dz.xyz); }\n\nmat3 rotate(\n  vec3 axis,\n  float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  vec3 l = (1.0 - c) * axis;\n  vec3 m = l.xyz * axis.yzx;\n  vec3 n = s * axis;\n  return mat3(\n    l.x * axis.x, m.x - n.z, m.z + n.y,\n    m.x + n.z, l.y * axis.y, m.y - n.x,\n    m.z - n.y, m.y + n.x, l.z * axis.z) + scale(c); }\n\nvec3 projectu(vec3 v, vec3 u) {\n  return u * dot(v, u); }\n\nvec3 rejectu(vec3 v, vec3 u) {\n  return v - projectu(v, u); }\n\n// linear sRGB component to nonlinear sR'G'B' component\nfloat srgb_gamma(\n  float v) {\n  return v <= 0.0031308\n    ? v * 12.92\n    : 1.055 * pow(v, 0.41666666666) - 0.055; }\n\nvec3 srgb_gamma(\n  vec3 v) {\n  return vec3(\n    srgb_gamma(v.r),\n    srgb_gamma(v.g),\n    srgb_gamma(v.b)); }\n\n// apparently this transforms linear srgb to aces srgb\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0); }\n\n// i can't believe it's an LCG\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst int lcgbase0 = 594156893;\nconst ivec3 lcgbase = lcgbase0 * ivec3(37769685, 26757677, 20501397);\n\nfloat hash3d(\n  int seed,\n  ivec3 p) {\n  p *= lcgbase;\n  return pow(2.0, -30.0) * float((lcgbase0 * (seed +\n  (p.x ^ p.y ^ p.z))) >> 1); }\n\n// perlin noise with gradient\nvec4 noise3d(\n  int seed,\n  vec3 p) {\n  vec3 f = floor(p);\n  ivec3 ip = ivec3(f);\n  f = p - f;\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  vec3 v = 1.0 - u;\n  vec3 w = -6.0 * (f - 1.0) * f;\n  float k[8] = float[8](\n    hash3d(seed, ip + ivec3(0, 0, 0)),\n    hash3d(seed, ip + ivec3(1, 0, 0)),\n    hash3d(seed, ip + ivec3(0, 1, 0)),\n    hash3d(seed, ip + ivec3(1, 1, 0)),\n    hash3d(seed, ip + ivec3(0, 0, 1)),\n    hash3d(seed, ip + ivec3(1, 0, 1)),\n    hash3d(seed, ip + ivec3(0, 1, 1)),\n    hash3d(seed, ip + ivec3(1, 1, 1)));\n  return vec4(\n   - w.x * v.y * v.z * k[0]\n   + w.x * v.y * v.z * k[1]\n   - w.x * u.y * v.z * k[2]\n   + w.x * u.y * v.z * k[3]\n   - w.x * v.y * u.z * k[4]\n   + w.x * v.y * u.z * k[5]\n   - w.x * u.y * u.z * k[6]\n   + w.x * u.y * u.z * k[7],\n\n   - v.x * w.y * v.z * k[0]\n   - u.x * w.y * v.z * k[1]\n   + v.x * w.y * v.z * k[2]\n   + u.x * w.y * v.z * k[3]\n   - v.x * w.y * u.z * k[4]\n   - u.x * w.y * u.z * k[5]\n   + v.x * w.y * u.z * k[6]\n   + u.x * w.y * u.z * k[7],\n\n   - v.x * v.y * w.z * k[0]\n   - u.x * v.y * w.z * k[1]\n   - v.x * u.y * w.z * k[2]\n   - u.x * u.y * w.z * k[3]\n   + v.x * v.y * w.z * k[4]\n   + u.x * v.y * w.z * k[5]\n   + v.x * u.y * w.z * k[6]\n   + u.x * u.y * w.z * k[7],\n\n   + v.x * v.y * v.z * k[0]\n   + u.x * v.y * v.z * k[1]\n   + v.x * u.y * v.z * k[2]\n   + u.x * u.y * v.z * k[3]\n   + v.x * v.y * u.z * k[4]\n   + u.x * v.y * u.z * k[5]\n   + v.x * u.y * u.z * k[6]\n   + u.x * u.y * u.z * k[7]); }\n\n// fractal noise with gradient\nvec4 fractal3d(\n  int seed,\n  vec3 p,\n  float division,\n  float attenuation,\n  int harmonics) {\n  vec4 v = nil;\n  float ampl = 1.0;\n  float freq = 1.0;\n  for (int i = 0; i < harmonics; i++) {\n    vec4 s = noise3d(seed, freq * p);\n    s.xyz *= freq;\n    s *= ampl;\n    v += s;\n    freq += division;\n    ampl += attenuation;\n    seed++; }\n  return v; }\n\nvec2 rotate(vec2 a, float b) {\n  float c = cos(b);\n  float s = sin(b);\n  return vec2(\n    a.x * c - a.y * s,\n    a.x * s + a.y * c); }\n\nvec4 constg(float c) {\n  return vec4(nil.www, c); }\n\nmat4 constg(vec3 c) {\n  return mat4(\n    constg(c.x),\n    constg(c.y),\n    constg(c.z),\n    nil); }\n\nmat4 ivg(vec3 c) {\n  return mat4(\n    dx.xyz, c.x,\n    dy.xyz, c.y,\n    dz.xyz, c.z,\n    nil); }\n\nvec4 prodg(vec4 p, vec4 q) {\n  return vec4(\n    p.w * q.x + p.x * q.w,\n    p.w * q.y + p.y * q.w,\n    p.w * q.z + p.z * q.w,\n    p.w * q.w); }\n\nvec4 dotg(mat4 p, mat4 q) {\n  return prodg(p[0], q[0]) +\n    prodg(p[1], q[1]) +\n    prodg(p[2], q[2]); }\n\nvec4 sqrtg(vec4 p) {\n  float fin = sqrt(p.w);\n  return vec4(\n    0.5 / fin * p.xyz,\n    fin); }\n\nmat4 sqrtg(mat4 p) {\n  return mat4(\n    sqrtg(p[0]),\n    sqrtg(p[1]),\n    sqrtg(p[2]),\n    dw); }\n\nvec4 powg(vec4 p, float c) {\n  return vec4(\n    c * pow(p.w, c - 1.0) * p.xyz,\n    pow(p.w, c)); }\n\nmat4 powg(mat4 p, float c) {\n  return mat4(\n    powg(p[0], c),\n    powg(p[1], c),\n    powg(p[2], c),\n    dw); }\n\nvec4 maxg(vec4 p, vec4 q) {\n  return p.w > q.w ? p : q; }\n\nvec4 ming(vec4 p, vec4 q) {\n  return p.w < q.w ? p : q; }\n\nmat4 maxg(mat4 p, mat4 q) {\n  return mat4(\n    maxg(p[0], q[0]),\n    maxg(p[1], q[1]),\n    maxg(p[2], q[2]),\n    dw); }\n\nmat4 ming(mat4 p, mat4 q) {\n  return mat4(\n    ming(p[0], q[0]),\n    ming(p[1], q[1]),\n    ming(p[2], q[2]),\n    dw); }\n\nvec4 lengthg(mat4 p) {\n  return sqrtg(dotg(p, p)); }\n\nvec4 logisticg(\n  vec4 v) {\n  float q = 1.0 / (1.0 + exp(v.w));\n  return vec4(\n    (q - q * q) * v.xyz,\n    1.0 / (1.0 + exp(-v.w))); }\n\nvec4 smoothmaxg(vec4 p, vec4 q, float r, out vec4 h) {\n  h = ming(maxg(constg(0.5) - prodg(constg(0.5 / r), q - p), constg(0.0)), constg(1.0));\n  return prodg(constg(1.0) - h, q) + prodg(h, p) + prodg(prodg(constg(r), h), constg(1.0) - h); }\n\nvec4 scene(mat4 p, out bool optimize) {\n  optimize = false;\n  vec4 s = constg(-10000.0);\n  vec3 tetnorms[] = vec3[](\n    normalize(vec3(-1.0, -1.0, -1.0)),\n    normalize(vec3(-1.0, 1.0, 1.0)),\n    normalize(vec3(1.0, -1.0, 1.0)),\n    normalize(vec3(1.0, 1.0, -1.0)));\n  vec4 q, h;\n\n  q = constg(1.15) - sqrtg(powg(p[0], 2.0) + powg(p[1], 2.0) + powg(p[2], 2.0));\n  s = smoothmaxg(s, q, fillet_radius, h);\n\n  for (int i = 0; i < 4; i++) {\n    q = dotg(p, constg(tetnorms[i]));\n    q -= constg(1.0);\n    s = smoothmaxg(s, q, fillet_radius, h);\n    optimize = optimize || h.w == 0.0; }\n\n  for (int i = 0; i < 4; i++) {\n    tetnorms[i] *= rotate(dy.xyz, 1.0471975512); }\n\n  for (int i = 0; i < 4; i++) {\n    q = dotg(p, constg(tetnorms[i]));\n    q -= constg(1.0);\n    s = smoothmaxg(s, q, fillet_radius, h);\n    optimize = optimize || h.w == 0.0; }\n\n  for (int i = 0; i < 4; i++) {\n    tetnorms[i] *= rotate(dy.xyz, 1.0471975512); }\n\n  for (int i = 0; i < 4; i++) {\n    q = dotg(p, constg(tetnorms[i]));\n    q -= constg(1.0);\n    s = smoothmaxg(s, q, fillet_radius, h);\n    optimize = optimize || h.w == 0.0; }\n\n  return s; }\n\nint trace(vec3 cam, vec3 dir, out vec3 p, out vec3 n) {\n  float t;\n  for(int i = 0; i < 400; i++) {\n    p = cam + dir * t;\n    bool optimize;\n    vec4 s = scene(ivg(p), optimize);\n    n = normalize(s.xyz);\n    float dt = dot(dir, n);\n    // amazing convex surface optimization to ray-marching equation\n    t += optimize && dt < 0.0 ? s.w / -dt : max(s.w, dmin);\n    if (s.w < dmin && dt < 0.0) {\n      return 2; }\n    if (s.w > 1e2) {\n      return 1; } }\n  return 0; }\n\nvoid cameraspin(inout vec3 p) {\n    p.yz = rotate(p.yz, 0.7 * sin(exp(-6.0) * float(iFrame)));\n    p.xz = rotate(p.xz, float(iFrame) * 0.002); }\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec3 cam = vec3(0.0, 0.0, -standback);\n    cameraspin(cam);\n    cameraspin(lightdir[3]);\n    out_color = vec4(0.0);\n    for (vec2 ij = vec2(0.0); ij.x < 1.0; ij.x += ss) {\n      for (ij.y = 0.0; ij.y < 1.0; ij.y += ss) {\n        vec2 uv = (fragCoord.xy + ij) / iResolution.xy - 0.5;\n        uv.x *= iResolution.x / iResolution.y;\n        vec3 dir = normalize(vec3(uv, zoom));\n        cameraspin(dir);\n        vec3 p, n;\n        if (2 == trace(cam, dir, p, n)) {\n          vec4 bump = fractal3d(\n            0, bump_freq * p,\n            1.0, 0.0,\n            int(bump_harmonics + log(zoom / length(p - cam)) / log(bump_harmonic_denominator)));\n          bump.xyz *= bump_freq;\n          bump = bump_scale * logisticg(bump_power * (bump + constg(bump_threshold)));\n          bump.xyz = rejectu(bump.xyz, n);\n          vec3 bumpn = normalize(n - bump.xyz);\n          if (iMouse.z > 0.0) {\n            out_color.rgb += 0.5 + 0.5 * bumpn; }\n          else {\n            vec3 fresnel_n = normalize(n + (0.5 + 0.5 * dot(bumpn, dir)) * bump.xyz);\n            float dt1 = -dot(dir, fresnel_n);\n            float ior22 = pow(gloss_ior, 2.0);\n            float dt12 = pow(dt1, 2.0);\n            float discriminant = -1.0 + ior22 + dt12;\n            vec3 refracted_heading = normalize(\n              dir\n              + (dt1 - sqrt(discriminant)) * fresnel_n);\n            float dt2 = -dot(refracted_heading, fresnel_n);\n            float dt22 = pow(dt2, 2.0);\n            float k1 = dt12 + ior22 * dt22;\n            float k2 = ior22 * dt12 + dt22;\n            float v = 2.0 * gloss_ior * dt1 * dt2;\n            float reflectance = clamp(0.5 * (\n              (k1 - v) / (k1 + v)\n              + (k2 - v) / (k2 + v)), 0.0, 1.0);\n            float sad = exp(0.05 * bump.w * length(bump.xyz));\n            out_color.rgb += ambient_light * color * sad;\n            for (int i = 0; i < light_count; i++) {\n              vec3 plight;\n              vec3 nlight;\n              int obstacle = trace(p, lightdir[i], plight, nlight);\n              if (obstacle != 1) continue;\n              float light_fraction = 0.995;\n              float lights = clamp((dot(reflect(dir, bumpn), lightdir[i])) / light_fraction, 0.0, 1.0);\n              float lightc = clamp((dot(n, lightdir[i])) / light_fraction, 0.0, 1.0);\n              out_color.rgb += color * light_color[i] * (0.2 * (1.0 - reflectance) * sad * lightc + 10.0 * reflectance * pow(lights, gloss_cosine_power) * (1.0 - pow(1.0 - lightc, gloss_cosine_power))); } } } } }\n\n    out_color.rgb *= pow(ss, 2.0);\n\n    if (iMouse.z <= 0.0) {\n        vec2 uv = (fragCoord.xy) / iResolution.xy - 0.5;\n    \tout_color.rgb *= pow(color, vec3(2.0 * dot(uv,uv)));\n        out_color.rgb = max(vec3(0.0), out_color.rgb);\n        out_color.rgb = aces(out_color.rgb);\n        out_color.rgb = min(vec3(1.0), out_color.rgb);\n    \tout_color.rgb = srgb_gamma(out_color.rgb); } }","name":"Image","description":"","type":"image"}]}