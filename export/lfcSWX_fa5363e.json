{"ver":"0.1","info":{"id":"lfcSWX","date":"1714507105","viewed":71,"name":"Landscape flythrough","username":"eriben0628","description":"h","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["h"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float v) {\n    return mat2(cos(v), sin(v), -sin(v), cos(v));\n}\n\nvec3 toneMapper(vec3 color) {\n    return color/(color+1.0);\n}\n\nfloat randomValue(vec2 p) {\n    \n    uint a = uint(2343242.0*fract(sin(dot(p*0.2, vec2(12.9898,7.343))*353.322+234.234)*233.234+0.5));\n    a = a*a*2353453u;\n    float b = fract(float(a)/2342425.3432);\n    return b;\n}\n\nfloat smoooth(float x) {\n    return 6.0*x*x*x*x*x - 15.0*x*x*x*x + 10.0*x*x*x;\n}\n\nfloat perlinNoise(vec2 p) {\n    vec2 p00 = floor(p);\n    float r00 = randomValue(p00);\n    float r10 = randomValue(p00 + vec2(1.0 , 0.0));\n    float r01 = randomValue(p00 + vec2(0.0 , 1.0));\n    float r11 = randomValue(p00 + vec2(1.0 , 1.0));\n    \n    float h0 = mix(r00, r10, smoooth(fract(p.x)));\n    float h1 = mix(r01, r11, smoooth(fract(p.x)));\n    float h = mix(h0, h1, smoooth(fract(p.y)));\n    \n    return h;\n}\n\nfloat heightOfGround(vec2 pos) {\n    float height = 0.0;\n    float freq = 0.1;\n    float amp = 10.0;\n    \n    \n    for(int i = 0; i < 8; i++) {\n        height += perlinNoise(pos*freq)*amp;\n    \n        freq *= 2.0;\n        amp *= 0.33;\n        pos = pos*rot(float(i));\n    }\n    \n    return height;\n}\n\nfloat InsideGround(vec3 pos) {\n    return pos.y - heightOfGround(pos.xz);\n}\n\nvec3 NormalOfGround(vec3 pos) {\n    float h = 0.001;\n    vec3 A = vec3(0.0,heightOfGround(pos.xz),0.0);\n    vec3 B = vec3(h,heightOfGround(pos.xz+vec2(h,0.0)),0.0);\n    vec3 C = vec3(0.0,heightOfGround(pos.xz+vec2(0.0,h)),h);\n    \n    vec3 N = normalize(-cross(B-A, C-A));\n    \n    return N;\n}\n\nvec3 Image(vec3 Origin, vec3 Dir) {\n    vec3 prevSamplePos = Origin;\n    vec3 samplePos = Origin;\n    float transmittance = 1.0;\n    float step = 0.05;\n    float prevValue = 0.0;\n    float currentValue = 0.0; \n    float tValue = 0.0;\n    vec3 LPos = Origin + vec3(15.0,10.0,0.0);\n    \n    \n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < 60; i++) {\n        samplePos += Dir*step;\n        \n        currentValue = InsideGround(samplePos);\n        if(currentValue < 0.0) {\n            tValue = prevValue/(prevValue - currentValue);\n            samplePos = mix(prevSamplePos, samplePos, tValue);\n            vec3 N = NormalOfGround(samplePos);\n            vec3 L = normalize(LPos - samplePos);\n            float LDist = length(LPos- samplePos);\n            \n            vec3 albedo = (N.y > 0.8) ? vec3(0.3,1.0,0.2) : vec3(0.5,0.4,0.2);\n            color = albedo * clamp(dot(N, L),0.0,1.0)/(LDist*LDist)*350.0;\n            break;\n        }\n        prevSamplePos = samplePos;\n        prevValue = currentValue;\n        transmittance *= 0.96;\n        step *= 1.1;\n    }\n    \n    return toneMapper(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 normalizedCoords = uv*2.0-1.0;\n    \n    vec3 Dir = normalize(vec3(normalizedCoords, 1.0));\n    vec3 Origin = vec3(0.0, 13.0, 0.0+iTime*3.0);\n    \n    vec3 color = Image(Origin, Dir);\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}