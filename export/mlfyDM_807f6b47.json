{"ver":"0.1","info":{"id":"mlfyDM","date":"1690811319","viewed":15,"name":"Rotate In Place","username":"gpachos","description":"Rotation in Place","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 palette(float t){\n    vec3 a = vec3(0.500,0.500,0.500);\n    vec3 b = vec3(0.500,0.500,0.500);\n    vec3 c = vec3(0.800,0.800,0.500);\n    vec3 d = vec3(0.000,0.200,0.500);\n    \n    return a+b*cos(6.28318*(c*t+d));\n}\n\nvoid findPointOnCircle(out vec2 point,vec2 circlePos,float radius,float angle, out float pointAngle){\n    \n    if(cos(angle)==0.0){\n        if(sin(angle)>0.0){\n            point=vec2(0,circlePos.y+radius);\n        }\n        else\n        {\n            point=vec2(0,circlePos.y-radius);\n        }\n        \n        return;\n    }\n    \n    float al=tan(angle);\n    //y = al*x\n    \n    float h=circlePos.x;\n    float k=circlePos.y;\n    \n    //(x-h)²+(y-k)²=radius²\n    //x²-2xh+h²+y²-2yk+k²=radius²\n    //x²-2xh+h²+al²x²-2kalx+k²=radius²\n    //(1+al²)x²-(2h+2kal)x+h²+k²-radius²=0;\n    \n    float a=(1.0+al*al);\n    float b= -(2.0*h+2.0*k*al);\n    float c=h*h+k*k-radius*radius;\n    \n    float d=sqrt((b*b)-(4.0*a*c));\n    \n    float x1=(-b+d)/(2.0*a);\n    float x2=(-b-d)/(2.0*a);\n    \n    float y1=x1*al;\n    float y2=x2*al;\n    \n    float dist1=(x1)*(x1)+(y1)*(y1);\n    float dist2=(x2)*(x2)+(y2)*(y2);\n    if(dist1>dist2){\n        point=vec2(x1,y1);\n        pointAngle=(-1.0)*atan(circlePos.x-x1,circlePos.y-y1);\n    }\n    else\n    {\n        point=vec2(x2,y2);\n        pointAngle=(-1.0)*atan(circlePos.x-x2,circlePos.y-y2);\n    }\n    return;\n   //point=vec2(x1,y1);\n   //point=vec2(x2,y2);\n   //return;\n   \n   if(sin(angle)>0.0){\n       if(cos(angle)>0.0){\n           point=vec2(x1,y1);\n       }\n       else\n       {\n           point=vec2(x2,y2);\n           \n       }\n       \n   }\n   else\n   {\n       \n       if(cos(angle)<0.0)\n       {\n           point=vec2(x2,y2);\n           \n       }\n       else\n       {\n           point=vec2(x1,y1);\n           \n       }\n       \n   }\n   \n    \n    \n    \n    \n}\nfloat easeInOutSine(float x) {\nreturn -(cos(3.14159 * x) - 1.0) / 2.0;\n}\n\nvec2 transformedVec(vec2 v,float angle){\n    float sinA=sin(angle);\n    float cosA=cos(angle);\n    \n    mat2 tm;\n    tm[0]=vec2(cosA,sinA);\n    tm[1]=vec2(-sinA,cosA);\n    \n    return v*tm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 -iResolution.xy)/iResolution.y;\n    vec2 uv0 =uv;\n    \n    \n    int numberOfPoints=5;\n    \n    vec2 points[5];\n    float radiuses[5];\n    float distances[5];\n    float initialAngleTo=3.14159/2.0;\n    float angleTo=initialAngleTo;\n    float angleStep=3.14159*2.0/float(numberOfPoints);\n    float radiusMax=0.8;\n    \n    vec3 finalColor=vec3(0,0,0);\n    \n    \n    \n    \n    float circleToFollowRadius=0.5;\n    float circleToFollowAngle=iTime*2.0;\n    float circleToFollowOffset=0.5;\n    float maxRadius=circleToFollowRadius+circleToFollowOffset;\n    vec2 circlePos=vec2(cos(circleToFollowAngle)*circleToFollowOffset,sin(circleToFollowAngle)*circleToFollowOffset);\n    \n    \n    \n    for(int i=0;i<numberOfPoints;i++){\n    \n        /*\n        float loopTime=1.0;\n        float iTimeToUse=iTime+2.0*loopTime*(angleTo/(2.0*3.14159));\n        float loops=floor(iTimeToUse/loopTime);\n        \n        float radiusTime=iTimeToUse-loopTime*loops;\n        float radius;\n        if(int(loops)%2==0){\n            radius=radiusMax*radiusTime/loopTime;\n        }\n        else\n        {\n            radius=radiusMax*(loopTime-radiusTime)/loopTime;\n        }\n        points[i]=vec2(cos(angleTo)*radius,sin(angleTo)*radius);\n        */\n        \n        vec2 pointPos=vec2(0,0);\n        float pointAngle=0.0;\n        findPointOnCircle(pointPos,circlePos,circleToFollowRadius,angleTo,pointAngle);\n        \n        \n        \n        points[i]=pointPos;\n        \n        \n        \n        vec2 dif=transformedVec(uv-points[i],pointAngle-3.14159/2.0);\n        \n        angleTo=angleTo+angleStep;\n        \n        \n        \n        if(false){\n            float d = sdPentagon(dif,0.1) * exp(-length(uv0));\n\n            vec3 col = palette(sdPentagon(dif,0.1) + float(i)*.4 + iTime*.4);\n\n            d = sin(d*8. + iTime)/8.;\n            d = abs(d);\n\n            d = pow(0.01 / d, 1.2);\n\n            finalColor += col * d;\n        }\n        else\n        {\n            float pd=sdPentagon(dif,0.1);\n            vec3 pCol=palette(pd+iTime);\n\n            pd=abs(pd);\n            pd=0.01/pd;\n            pCol=pd*pCol;\n\n            \n            finalColor=finalColor+pCol;\n        }\n        \n        \n        \n        \n        \n    }\n    \n    float loopTime=8.0;\n    float iTimeToUse=iTime+2.0*loopTime*(angleTo/(2.0*3.14159));\n    float loops=floor(iTimeToUse/loopTime);  \n    float radiusTime=iTimeToUse-loopTime*loops;\n    \n    angleTo=initialAngleTo;\n    \n  \n      for(int i=0;i<numberOfPoints;i++){\n        \n        \n        float coef=1.0;\n        \n        if(int(loops)%2==0){\n            coef=0.0;\n            \n            break;\n        }\n        else\n        {\n            if(radiusTime<0.5){\n                coef=easeInOutSine(radiusTime/0.5);\n            }\n            else if(radiusTime>loopTime-0.5){\n                coef=easeInOutSine(loopTime-radiusTime/0.5);\n            }\n            else\n            {\n                coef=1.0f;\n            }\n            \n            \n            \n        }\n        vec2 a=vec2(cos(angleTo)*maxRadius*coef,sin(angleTo)*maxRadius*coef);\n        vec2 b=vec2(cos(angleTo+3.14159)*maxRadius*coef,sin(angleTo+3.14159)*maxRadius*coef);\n        angleTo=angleTo+angleStep;\n        float pd=sdSegment(uv,a,b);\n        \n        //pd=pd*(1.0-coef);\n        \n        vec3 pCol=palette(pd+0.5)*coef;\n        \n        \n        pd=abs(pd);\n        pd=0.02/pd;\n        pCol=pd*pCol*coef;\n        pd=pd;\n      \n        finalColor=finalColor+pCol;\n\n      }\n\n    \n    \n    \n    \n    //vec3 col=palette(d);\n    \n    //d=sin(d*5.0*cos(iTime*1.5)+iTime)/5.0;\n    //d=abs(d);\n    \n    //d=0.02/d;\n    //d=smoothstep(0.0,0.1,d);\n  \n    \n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    //col *= d;\n    \n    fragColor = vec4(finalColor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}