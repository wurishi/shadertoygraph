{"ver":"0.1","info":{"id":"mlSGzV","date":"1678622608","viewed":45,"name":"Makoto-Shinkai Style Landscape","username":"Fuergu","description":"BufferA is another shader on this website, which is not written by myself.\nI fogot to link it and couldn't find the original author :(     SORRY!\nIf you know BufferA shader's ID , please comment bellow!\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////\n#define PI 3.14159265358979\nvec2 hash( in vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n//****https://www.shadertoy.com/view/MtGcWh\nvec3 erosion(in vec2 p, vec2 dir) {    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;\n    vec3 va = vec3(0.0);\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) {\n\t\tfor (int j=-2; j<=1; j++) {\t\t\n        \tvec2 o = vec2(i, j);\n        \tvec2 h = hash(ip - o)*0.5;\n            vec2 pp = fp +o - h;\n            float d = dot(pp, pp);\n            float w = exp(-d*2.0);\n            wt +=w;\n            float mag = dot(pp,dir);\n            va += vec3(cos(mag*f), -sin(mag*f)*(pp+dir))*w;\n        }\n    }\n    return va/wt;\n}\n\nvec3 mountain(vec2 p, float s) {\n    //First generate a base heightmap\n    //it can be based on any type of noise\n    //so long as you also generate normals\n    //Im just doing basic FBM based terrain using\n    //iq's analytic derivative gradient noise\n    vec3 n = vec3(0.0);\n    float nf = 1.0;\n    float na = 0.6;\n    for (int i=0;i<2;i++) {\n       n+= noised(p*s*nf)*na*vec3(1.0, nf, nf);\n       na *= 0.5;\n       nf *= 2.0;\n    }\n    \n    //take the curl of the normal to get the gradient facing down the slope\n    vec2 dir = n.zy*vec2(1.0, -1.0);\n    \n    //Now we compute another fbm type noise\n    // erosion is a type of noise with a strong directionality\n    //we pass in the direction based on the slope of the terrain\n    //erosion also returns the slope. we add that to a running total\n    //so that the direction of successive layers are based on the\n    //past layers\n    vec3 h = vec3(0.0);\n    float a = 0.7*(smoothstep(0.3, 0.5,n.x*0.5+0.5)); //smooth the valleys\n    float f = 1.0;\n    for (int i=0;i<5;i++) {\n        h+= erosion(p*f, dir+h.zy*vec2(1.0, -1.0))*a*vec3(1.0, f, f);\n        a*=0.4;\n        f*=2.0;\n    }\n    //remap height to [0,1] and add erosion\n    //looks best when erosion amount is small\n    //not sure about adding the normals together, but it looks okay\n    return vec3(smoothstep(-1.0, 1.0, n.x)+h.x*0.05, (n.yz+h.yz)*0.5+0.5);\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nfloat map(in vec3 pos)\n{\n    //float sphere=length(pos)-.25;//length(a point in space from a sphere)\n    float ground=pos.y-(-0.21)-mountain(pos.xz*10.,0.1).x;//generate a plane\n    float link1 = sdLink(pos,.5,.4,.02)*1.;\n    float link2 = sdLink(pos,.5,.5,.02)*1.;\n    return min(link2,min(link1,ground));//min(sphere,ground);//make sure always see the closer thing\n}\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h));\n}\nfloat castRay(in vec3 ro,vec3 rd)\n{\n    float t=0.;\n    for(int i0=0;i0<101;i0++)\n    {\n        vec3 pos= ro+t*rd;\n        \n        float h=map(pos);\n        if(h<0.001)  break;//if h is negative, light is outside the sphere\n        t+=h;\n        if(t>20.)    break;//distance is too large,dismiss\n    }\n    if(t>20.) t= -1.0;\n    return t;\n}\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = -2.+exp2(-t*0.00001*vec3(1,1.7,4.)); \n    return col*ext + (1.-ext)*vec3(0.55,0.52,0.60); // 0.55\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        /**********************************************\n          Normalized pixel coordinates (from 0 to 1)\n        **********************************************/\n    vec2 p=(2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float zoom=1.5;\n    float an=-10.*iMouse.x/iResolution.x;\n    //an=10.*0.25*(sin(iTime*0.1)+1.);\n    vec3 ro=vec3(1.*sin(an),0.5,1.*cos(an));\n    \n            /********set up camera system********/\n            vec3 ta=vec3(0.,.5,0.);//camera target direction vector\n            vec3 f = normalize(ta-ro);\n            vec3 r = normalize(cross(f,vec3(0., 1., 0.)));\n            vec3 u = normalize(cross(r,f));\n            \n    vec3 rd=normalize(p.x*r+p.y*u+zoom*f);\n    vec3 col=vec3(0.);\n    vec3 origin_sky_color=vec3(.4,.75,1.);\n    vec3 horizon_color=vec3(.9,.56,.65);\n    origin_sky_color -= 0.5*rd.y;//make the sky upwards darker,create variation\n    col+=origin_sky_color;\n    col=mix(col,horizon_color,exp(-5.896*rd.y));//add horizon\n    \n    float t = castRay(ro,rd);\n    if(t>0.) \n    {\n        vec3 pos= ro+t*rd;\n        vec3 nor=calcNormal(pos);\n        //col=nor;      //dispaly normal\n        //col=nor.zzz;  //dispaly normal\n        \n        vec3 mate=vec3(.17647054,.13725,.1531372);    //mate is material\n        vec3 sun_dir=normalize(vec3(.8,.4,.2));\n        float sun_diff=clamp( dot(nor,sun_dir), 0., 1.);//sun_dir is the direction of the sun\n        float sun_sha = step(castRay(pos+nor*0.0001, sun_dir),0.);//step is kinda conpare the first component and the second one 0..//if larger than 0,return 1;else return 0.\n        vec3 sky_dir=normalize(vec3(0.,1.,0.));\n        float sky_diff=clamp(0.5+0.5*dot(nor,sky_dir), 0., 1.);//enhance skylight\n        float bou_diff = clamp(0.5+0.5*dot(nor,vec3(sky_dir.x,-sky_dir.y,sky_dir.z)), 0., 1.);//bounce light from the ground\n        \n        col=vec3(7.,6.,4.)*sun_diff*sun_sha; \n        col+=vec3(.5,.8,.9)*sky_diff; \n        col+=vec3(.8,.6,.5)*bou_diff; \n        col*=mate;\n        col = fog( col, 1000.);\n        \n\n    }    \n        \n\n    col+=texture(iChannel0,vec2(rd.y*0.8+.1,-rd.z)).xyz*(p.y-.1);\n    col+=texture(iChannel1,vec2(rd.y*1.+.2,rd.z)).xyz*(p.y-.1);\n\n    col= pow(col,vec3(1.3));    //gamma correction\n        // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.39f36dNMc5CmshUCPAH1VsCv4A84pGdSyu\n#define M_TWO_PI (2.0 * M_PI)\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec3 ramp(float t) {\n\treturn t <= .5 ? vec3( 1. - t * 1.4, .2, 1.05 ) / t : vec3( .3 * (1. - t) * 2., .2, 1.05 ) / t;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (sqrt(uv.x * uv.x + uv.y * uv.y) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nfloat fire(vec2 n) {\n    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;\n}\n\nfloat shade(vec2 uv, float t) {\n    uv.x += uv.y < .5 ? 23.0 + t * .035 : -11.0 + t * .03;    \n    uv.y = abs(uv.y - .5);\n    uv.x *= 35.0;\n    \n    float q = fire(uv - t * .013) / 2.0;\n    vec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));\n    \n    return pow((r.y + r.y) * max(.0, uv.y) + .1, 4.0);\n}\n\nvec3 color(float grad) {\n    \n    float m2 = iMouse.z < 0.0001 ? 1.15 : iMouse.y * 3.0 / iResolution.y;\n    grad =sqrt( grad);\n    vec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 2.61, vec3(2.0))));\n    vec3 color2 = color;\n    color = ramp(grad);\n    color /= (m2 + max(vec3(0), color));\n    \n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float m1 = iMouse.z < 0.0001 ? 3.6 : iMouse.x * 5.0 / iResolution.x;\n    \n    float t = iTime;\n    vec2 uv = fragCoord / iResolution.yy;\n    float ff = 1.0 - uv.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.0) / 2.0;\n    vec2 uv2 = uv;\n    uv2.y = 1.0 - uv2.y-0.1;\n   \tuv2 = polarMap(uv2, 1.9, m1);\n    vec3 c2 = color(shade(uv2, t)) * (1.0 - ff);\n    \n    fragColor = vec4(c2 , 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.9, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(t), 2.*sin(t), -3.*cos(t));\n    \n    vec3 lookat = vec3(.5);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 ipoint = c + uv.x*r + uv.y*u;\n    vec3 rd = ipoint-ro;\n    \n   \n    //计算alpha\n    float a=1.3;\n    float d = 0.;\n    float d1 = DrawPoint(ro, rd, vec3(0., 0., 0.));//1\n    float d2 = DrawPoint(ro, rd, vec3(0., 0., a));//2\n    float d3 = DrawPoint(ro, rd, vec3(0., a, 0.));//3\n    float d4 = DrawPoint(ro, rd, vec3(a, 0., 0.));//4\n    float d5 = DrawPoint(ro, rd, vec3(0., a, a));//5\n    float d6 = DrawPoint(ro, rd, vec3(a, 0., a));//6\n    float d7 = DrawPoint(ro, rd, vec3(a, a, 0.));//7\n    float d8 = DrawPoint(ro, rd, vec3(a, a, a));//8\n    d=d1+d2+d3+d4+d5+d6+d7+d8;\n    \n    //计算颜色\n    \n    float dist[8];\n     dist[0]=ro[0]*ro[0]+ro[1]*ro[1]+ro[2]*ro[2];\n     dist[1]=ro[0]*ro[0]+ro[1]*ro[1]+(ro[2]-1.)*(ro[2]-1.);\n     dist[2]=ro[0]*ro[0]+(ro[1]-1.)*(ro[1]-1.)+ro[2]*ro[2];\n     dist[3]=(ro[0]-1.)*(ro[0]-1.)+ro[1]*ro[1]+ro[2]*ro[2];\n     dist[4]=ro[0]*ro[0]+(ro[1]-1.)*(ro[1]-1.)+(ro[2]-1.)*(ro[2]-1.);\n     dist[5]=(ro[0]-1.)*(ro[0]-1.)+ro[1]*ro[1]+(ro[2]-1.)*(ro[2]-1.);\n     dist[6]=(ro[0]-1.)*(ro[0]-1.)+(ro[1]-1.)*(ro[1]-1.)+ro[2]*ro[2];\n     dist[7]=(ro[0]-1.)*(ro[0]-1.)+(ro[1]-1.)*(ro[1]-1.)+(ro[2]-1.)*(ro[2]-1.);\n    \n    float g1=0.,  g2=1.;\n    float max0=max(dist[0],max(dist[1],max(dist[2],max(dist[3],max(dist[4],max(dist[5],max(dist[6],dist[7])))))));\n    float min0=min(dist[0],min(dist[1],min(dist[2],min(dist[3],min(dist[4],min(dist[5],min(dist[6],dist[7])))))));\n    float color[8];\n    \n    for (int i0 = 0; i0<8; i0++) \n    {\t\n    color[i0]=(dist[i0]-min0)/(max0-min0);\n    }\n    float d1c =d1*color[0];\n    float d2c =d2*color[1];\n    float d3c =d3*color[2];\n    float d4c =d4*color[3];\n    float d5c =d5*color[4];\n    float d6c =d6*color[5];\n    float d7c =d7*color[6];\n    float d8c =d8*color[7];\n    float dc=max(d1c,max(d2c,max(d3c,max(d4c,max(d5c,max(d6c,max(d7c,d8c)))))));\n    \n    \n    \n\tfragColor =  vec4(d*0.5*(1.+sin(t)),d*dc*0.5*(1.+sin(t)),0.5*(1.+cos(t))*d,d); \n\n}","name":"Buffer B","description":"","type":"buffer"}]}