{"ver":"0.1","info":{"id":"ftVfDK","date":"1668643716","viewed":72,"name":"GPT-3 A \"specular\" sphere","username":"sferrando","description":"promtp:\nwrite a shadertoy code that renders a white point light and a specular sphere that reflects some of the light.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gpt3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray-sphere intersection\nvec3 rayIntersectSphere(vec3 ro, vec3 rd, vec3 sc, float rc)\n{\n    vec3 rs = ro - sc;\n    float B = dot(rd, rs);\n    float C = dot(rs, rs) - rc*rc;\n    float D = B*B - C;\n    if (D > 0.0)\n    {\n        float t2 = -B - sqrt(D);\n        if (t2 > 0.0)\n        {\n            float t = t2/sqrt(D);\n            return vec3(t, t2, 1.0);\n        }\n    }\n    return vec3(-1.0, -1.0, -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // The ray (viewing direction)\n    vec3 ray = normalize(vec3(uv, -1.5));\n \n    // The origin of the ray (view position)\n    vec3 ro = vec3(0, 0, 0);\n \n    // The sphere center\n    vec3 c = vec3(0, 0, -3);\n \n    // The sphere radius\n    float r = 1.0;\n \n    // Intersection of the ray with the sphere\n    vec3 tc = rayIntersectSphere(ro, ray, c, r);\n \n    // If there's no hit\n    if (tc.z < 0.0)\n    {\n        // The background color\n        fragColor = vec4(0.02, 0.02, 0.02, 1.0);\n    }\n    else\n    {\n        // The point on the sphere that was hit\n        vec3 p = ro + ray*tc.z;\n \n        // The normal at the point on the sphere\n        vec3 n = normalize(p - c);\n \n        // The color of the sphere\n        vec3 diffuseColor = vec3(0.6, 0.6, 0.6);\n \n        // The color of the light\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n \n        // The position of the light\n        vec3 l = vec3(4, 4, 0);\n \n        // The cosine of the angle between the light ray and the sphere normal\n        float diffuseTerm = clamp(dot(n, normalize(l - p)), 0.0, 1.0);\n \n        // The color of the reflection\n        vec3 reflectionColor = vec3(1.0, 1.0, 1.0);\n \n        // The direction of the reflected ray\n        vec3 reflectedRay = reflect(normalize(l - p), n);\n \n        // The color of the specular reflection\n        vec3 specularColor = vec3(1.0, 1.0, 1.0);\n \n        // The power of the specular reflection\n        float specularPower = 2.0;\n \n        // The cosine of the angle between the reflected ray and the view ray\n        float specularTerm = clamp(dot(reflectedRay, ray), 0.0, 1.0);\n \n        // The combined color of diffuse and specular reflection\n        vec3 color = diffuseColor*diffuseTerm + specularColor*pow(specularTerm, specularPower);\n \n        // Final color\n        fragColor = vec4(color, 1.0);\n    }\n}\n \n","name":"Image","description":"","type":"image"}]}