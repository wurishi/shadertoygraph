{"ver":"0.1","info":{"id":"7sSXRy","date":"1620570028","viewed":219,"name":"Spherical Occlusion by Darko","username":"omegasbk","description":"Spherical parallax occlusion - super wip","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["comet","parallaxocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk) 9.5.2021.\n// Twitter @darkosupe\n// Sub here youtube.com/c/DarkoSupe for educational videos\n\n#define PI 3.14159265359\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    float focalDistance;\n};\n\nCamera camera = Camera(\n    vec3(0., 0., -.3), \n    vec3(1., 0., 1.),\n    0.5);\n    \nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n    float reflection;\n};\n\nconst Material material = Material(0.5, 0.2, 10.1, 0.5, 0.1);\n\nstruct Sphere \n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    Material material;\n};\n\nSphere sphere = Sphere(\n    vec3(0.0, 0., 0.),  \t\t\t\t\t// position\n    vec3(0.1, 0.1, 0.3), \t\t\t\t\t// color\n    0.15,\t\t\t\t\t\t\t\t\t// radius\n    material);  // material \n    \nstruct PointLight\n{\n    vec3 position;\n    float intensity;\n};\n\nPointLight light = PointLight(\n    vec3(0., 2.5, 0.), // position\n    50.);              // intensity\n\n\n//////////////////////////////////////////////////////////////\n// \t                        UTILS                           // \n//////////////////////////////////////////////////////////////\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in PointLight pointLight, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - pointLight.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.1, 2.) / pow(length(lightVector), 2.)) * pointLight.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambience * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.0), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\n//////////////////////////////////////////////////////////////\n// \t                   INTERSECTION CODE                    // \n//////////////////////////////////////////////////////////////\nbool intersectSphere(\n    vec3 origin, \n    vec3 direction, \n    Sphere sphere, \n    out float dist, \n    out vec3 surfaceNormal, \n    out vec3 Phit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {        \n        if (t0 > t1) \n        {\n        \tfloat temp = t0;\n            t0 = t1;\n            t1 = temp;\n        } \n \n        if (t0 < 0.)\n        { \n            t0 = t1; // if t0 is negative, let's use t1 instead \n            if (t0 < 0.) return false; // both t0 and t1 are negative \n        }  \n             \n        dist = t0;\n       \n        Phit = origin + dist * direction;\n        surfaceNormal = normalize(Phit - sphere.position);               \n        \n        return true;\n    }  \n     \n    return false;\n}\n\n#define RESOLUTION 0.00001\n\nfloat getDepth(vec2 coord, float scale)\n{\n    return (1. - texture(iChannel1, coord).r) * scale;\n}\n\nvec3 getSpherePoint(float r, float polar, float azimuth)\n{\n    float x = r * sin(polar) * sin(azimuth);\n    float y = r * cos(polar);\n    float z = -r * cos(azimuth) * sin(polar);\n    \n    return vec3(x, y, z);\n}\n\nfloat getDepth(vec3 normal, float scale)\n{\n    float u = atan(normal.x, normal.z) / (2. * PI);\n    float v = normal.y * 0.5; \n    return (1. - texture(iChannel1, vec2(u,v)*vec2(6., 2.5)).r) * scale;\n}\n\nfloat getColor(vec3 normal)\n{\n    float u = atan(normal.x, normal.z) / (2. * PI);\n    float v = normal.y * 0.5; \n    return texture(iChannel2, vec2(u,v)*vec2(6., 2.5)).r;\n}\n\nbool getParallaxSphere(vec3 pHit, inout vec3 normal, vec3 direction, float scale, out vec3 newPoint)\n{  \n    float angle = dot(direction, normal);\n    \n    if (angle == 0.) \n        return false;\n        \n    float layerCount = 220. * (1. - angle);\n    float layerSize = scale / layerCount;\n    \n    vec3 newNormal;\n    \n    for (int i = 0; i < int(layerCount); i++)\n    {\n        vec3 point = pHit + direction * layerSize / -dot(normal, direction) * float(i);\n        \n        newNormal = normalize(point - sphere.position);\n        float sampleDepth = getDepth(newNormal, scale);\n        \n        float altitude = length(point - sphere.position);  \n        altitude -= sphere.radius;\n        \n        sampleDepth += altitude;\n\n        if (sampleDepth <= float(i) * layerSize )\n        {\n            newPoint = point - newNormal * altitude;\n            return true;\n        }\n\n    }\n    \n    return false;\n}\n\n//////////////////////////////////////////////////////////////\n// \t                       MAIN CODE                        // \n//////////////////////////////////////////////////////////////\nvec3 rayTrace(vec3 origin, vec3 direction, float scale, float pos, float bound)\n{\n    float dist;\n    vec3 pHit;\n    \n    vec3 normal;\n    if (intersectSphere(origin, direction, sphere, dist, normal, pHit))\n    {\n        vec3 newPoint;\n        bool isVisible = getParallaxSphere(pHit, normal, direction, scale, newPoint); \n       \n        if (!isVisible)\n            return texture(iChannel0, direction).rgb;\n\n        float azimuth = -atan(newPoint.x, newPoint.z);\n        float polar = acos(newPoint.y / sphere.radius);\n       \n        vec3 centerNormal = normalize(getSpherePoint(sphere.radius, polar, azimuth));\n        vec3 center = centerNormal * getDepth(centerNormal, scale);\n        \n        float azimuth2 = azimuth + 2. * PI * RESOLUTION;\n        vec3 right = normalize(getSpherePoint(sphere.radius, polar, azimuth2));\n        right *= getDepth(right, scale);\n        right = normalize(right - center);\n        \n        polar += 2. * PI * RESOLUTION;\n        vec3 down = normalize(getSpherePoint(sphere.radius, polar, azimuth));\n        down *= getDepth(down, scale);\n        down = normalize(down - center);\n        \n        normal = normalize(cross(-down, -right));\n                \n        vec3 texColor = vec3(getColor(centerNormal));\n        texColor *= vec3(0.4, 0.6, 0.64) * 2.4;\n        vec3 baseColor = getLitColor(direction, newPoint, texColor, light, normal, sphere.material).rgb;       \n        \n        \n        vec3 reflColor = texture(iChannel0, normal).rgb;\n        baseColor = mix(baseColor, reflColor, 0.75);\n        \n        if (pos > bound)\n            return normal;\n        return baseColor;\n    }\n    \n    return texture(iChannel0, direction).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    float rotation = iTime / 3.;\n    camera.position = vec3(cos(rotation), 0., sin(rotation)) * camera.focalDistance;\n    camera.direction = normalize(vec3(0., 0., 0.) - camera.position);\n    vec3 right = normalize(cross(camera.direction, vec3(0., 1., 0.)));\n    vec3 up = cross(right, camera.direction);\n   \tvec3 dir =  normalize(uv.x * right + uv.y * up + camera.direction);           \n                 \n    light.position = camera.position;\n    light.position.x += 1.;\n    light.position.y += 0.4;\n\n    vec3 finalColor = rayTrace(camera.position, dir, (sin(iTime * 2.) + 1.) / 18. + 0.02, uv.x, sin(iTime / 2.)); \n     \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}