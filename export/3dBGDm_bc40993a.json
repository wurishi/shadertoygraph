{"ver":"0.1","info":{"id":"3dBGDm","date":"1548983457","viewed":61,"name":"RM Test","username":"2cherries","description":"Baby's first ray marcher","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n/* \n\tThis gets the minimum distance from a point to every object\n\tin the scene, \n\tused in RayMarch() and Normal()\n */\nfloat GetDistance(vec3 p) {\n    vec4 sphere = vec4(0., 1., 6., 1.);\n   \n    float sphereDist = length(p-sphere.xyz)-sphere.w;\n    float floorDist = p.y;\n    \n    return min(sphereDist, floorDist);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float distanceFromOrigin = 0.; // our return value\n    \n    for(int i= 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + rd*distanceFromOrigin; //new march point\n        float ds = GetDistance(p);\n        distanceFromOrigin += ds;\n        \n        // Break out of march if distance is too high, or is low\n        // enough to be a desired value\n        if(distanceFromOrigin > MAX_DIST || ds<SURF_DIST) break;\n    }\n\n    return distanceFromOrigin;\n}\n\nvec3 Normal(vec3 p) {\n    float d = GetDistance(p);\n    vec2 n = vec2(.01, 0.);\n\n\t// Hint: Scalar (operator) Vector does the operation component-wise\n    vec3 norm = d - vec3(\n        // Swizzle!\n        GetDistance(p - n.xyy),\n        GetDistance(p - n.yxy),\n        GetDistance(p - n.yyx)\n    );\n\n    return normalize(norm);\n}\n\nfloat DiffuseLight(vec3 p) {\n    // Position of light source\n    vec3 lPos = vec3(3.+sin(iTime), 3.+sin(iTime), 3.);\n    \n    // Normal of light\n    vec3 l = normalize(lPos - p);\n    vec3 norm = Normal(p);\n    \n    // Angle between light vector and normal\n    float dif = dot(norm, l); // -1 <> 1\n    \n    // Clamp light value between 0 and 1\n    dif = clamp(dif, 0., 1.);\n    //dif = dif+1./2.; // 0 <> 1\n    \n\t/* \n\t\tShadow Detection: If we raymarch to object instead of light\n\t\tsource, we are behind an object, meaning we are in a shadow \n\t */\n    float shadow = RayMarch(p+norm*SURF_DIST*2., l);\n    if (shadow < length(lPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5*iResolution.xy) /iResolution.y;\n    \n    // Camera Model\n    vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float diffuse = DiffuseLight(p);\n   \n    // Output to screen\n    fragColor = vec4(vec3(diffuse),1.0);\n}","name":"Image","description":"","type":"image"}]}