{"ver":"0.1","info":{"id":"wlGfDc","date":"1615194074","viewed":99,"name":"Blending Color Mode study","username":"emotiog","description":"test for unity color blending mode","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blendingcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgbToHsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsvToRgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 image(int panel, vec2 uv) {\n\n    // user input color\n    vec3 v_color = vec3(0.0, sin(iTime), cos(iTime));\n    vec3 vHsv = rgbToHsv(v_color);\n\n    // particle color\n    vec4 textureColor = texture(iChannel0, uv);\n    \n    // define problem state: the resource image exists red channel only.\n    vec3 spriteColor = vec3(textureColor.r, 0.0, 0.0);\n\n    float spriteGray = dot(spriteColor.rgb, vec3(0.299, 0.587, 0.114));\n    \n    vec3 spriteHSV = rgbToHsv(spriteColor.rgb);\n    vHsv.b = sign(vHsv.b);\n    \n    switch (panel) {\n    \n        // the resource\n        case 0: return spriteColor;\n        \n        // user input\n        case 1: return v_color;\n        \n        // the input modified as Unity style. (intensity always equals)\n        case 2: return hsvToRgb(vHsv);\n    \n    \n    \n        // Gray of the resource, Intensity of the resource,\n        case 3: return vec3(spriteGray); \n        case 4: return vec3(spriteHSV.b);\n        \n        \n        // case 5 empty.\n        \n        // The result of the image combining v_color with the gray one.\n        case 6: return spriteGray * mix(vec3(1.0), v_color, spriteHSV.b);\n\n\n        // The result of the image combining v_color with the intensity one.\n        case 7: return spriteHSV.b * mix(vec3(1.0), v_color, vHsv.b);\n        \n        \n        // The result of the image combining v_color with the intensity one. (Unity interface)\n        // rgbToHsv(vHsv) != v_color (the channel blue is different).\n        case 8: return spriteHSV.b * mix(vec3(1.0), hsvToRgb(vHsv), vHsv.b);\n        \n        \n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    const float ROWS = 3.;\n    const float COLUMNS = 3.;\n    const float GAP = 0.05;\n    // If ROWS=3 and COLUMNS=3 then the layout of the panels is:\n    //\n    // \t+---+---+---+\n    // \t| 6 | 7 | 8 |\n    // \t+---+---+---+\n    // \t| 3 | 4 | 5 |\n    // \t+---+---+---+\n    // \t| 0 | 1 | 2 |\n    // \t+---+---+---+\n    //\n    // If ROWS=3 and COLUMNS=2 then the layout of the panels is:\n    //\n    // \t+---+---+\n    // \t| 4 | 5 |\n    // \t+---+---+\n    // \t| 2 | 3 |\n    // \t+---+---+\n    // \t| 0 | 1 |\n    // \t+---+---+\n    vec3 srgb = vec3(0.1);\n    uv.x -= (1. - COLUMNS / ROWS) * 0.5; // Centre the panels according to the aspect ratio\n    uv = uv * (ROWS + GAP) - GAP; // Add gaps between panels\n    if ((uv.x >= 0.) && (uv.y >= 0.) && (uv.x < COLUMNS))\n    {\n        // We're inside the main panel region\n        ivec2 iuv = ivec2(uv);\n        uv = fract(uv) * (1. + GAP);\n        if (max(abs(uv.x), abs(uv.y)) < 1.)\n        {\n\t        // We're inside one of the panels\n\t        int panel = iuv.x + iuv.y * int(COLUMNS);\n            srgb = image(panel, uv);\n        }\n    }\n\n\n\n    // Output to screen\n    fragColor = vec4(srgb,1.0);\n}","name":"Image","description":"","type":"image"}]}