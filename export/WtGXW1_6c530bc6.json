{"ver":"0.1","info":{"id":"WtGXW1","date":"1665351084","viewed":64,"name":"COLORED_CUBES","username":"hedyla2055","description":"Colored cubes\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURFACE_DIST 0.01\n#define CUBE1 vec3(2., 2. , 6.)\n#define CUBE2 vec3(-2.5, -2. , 5.5)\n#define CUBE3 vec3(-2.5, 2, 5.6)\n#define CUBE_SIZE vec3(0.5, 0.5, 0.3)\n\n// Random number between 0 and 1\nfloat Random(vec2 seed)\n{\n    seed = fract(seed * vec2(123.39, 456.21));\n\tseed += dot(seed, seed + 695.39);\n    return fract(seed.x * seed.y);\n}\n\nfloat GetDistance(vec3 pos)\n{\n    float dist = 10000.0;\n\tfor (float i = -5.; i <= 5.; i += 1.02)\n    {\n        for (float j = -3.; j <= 3.; j += 1.02)\n        {\n            float r1 = Random(vec2(i, j));\n            float r2 = Random(vec2(j, i));\n            vec3 center = vec3(i + .5, j + .5,\n                               3.  +  fract(r1 * abs(cos(iTime))));\n        \tdist = min(abs(length(max(abs(pos - center) - CUBE_SIZE, 0.))), dist);\n        }\n    }\n    \n    return dist;\n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_direction)\n{\n    float distance_from_origin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ray_origin + distance_from_origin * ray_direction;\n        float distance_from_surface = GetDistance(p);\n        distance_from_origin += distance_from_surface;\n        if (distance_from_origin > MAX_DISTANCE ||\n            distance_from_surface < SURFACE_DIST)\n            break;\n    }\n    \n    return distance_from_origin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 diff = vec2(0.01, 0.);\n    float dist = GetDistance(p);\n    \n    vec3 normal = dist - vec3(GetDistance(p - diff.xyy),\n                              GetDistance(p - diff.yxy),\n                              GetDistance(p - diff.yyx) );\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0., 1., 0.);\n    vec3 normal_dir = GetNormal(p);\n    vec3 light_dir = normalize(lightPos - p);\n    \n    return dot(normal_dir, light_dir);\n}\n\nvec3 LayoutCubes(vec2 uv)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n   \tvec2 id = floor(uv);\n\n    vec3 col = vec3(0.);\n    float dist = 0.0;\n\tfor (float i = -5.; i <= 5.; i += 1.2)\n    {\n        for (float j = -3.; j <= 3.; j += 1.2)\n        {\n            float r1 = Random(vec2(i, j));\n            float r2 = Random(vec2(j, i));\n            vec3 center = vec3(i + .5, j + .5,\n                               4.  +  fract(r1 * abs(cos(2. * iTime))));\n        \tdist = RayMarch(ro, rd);\n            vec3 p = ro + dist * rd;\n            float cube = GetLight(p);\n            col = cube * vec3(1.0 * abs(uv.x), 1. * abs(uv.y), 1. * r2);\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\tuv *= 1.0;\n    \n    vec3 ro = vec3(uv.x, uv.y, 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n   \n\tfloat dist = RayMarch(ro, rd);    \n\tvec3 p = ro + dist * rd;\n    float cube = GetLight(p);\n    vec3 col = cube * vec3(1.0 * abs(uv.x * 2.), 1. * abs(uv.y * 2.), .5 );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}