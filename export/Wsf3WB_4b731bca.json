{"ver":"0.1","info":{"id":"Wsf3WB","date":"1547303189","viewed":133,"name":"Transparent sphere and cube","username":"gest","description":"experiment","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cube","sphere","intersect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\nPlane plane_1 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,1,0));\nPlane plane_2 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,0,1));\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\nSphere sphere_1 = Sphere(vec3(-1.0, 1.5, 1.0), 0.4);\nSphere sphere_2 = Sphere(vec3( 1.0, 1.5, 1.0), 0.4);\nSphere sphere_3 = Sphere(vec3( 0.0, 1.5, 1.0), 0.4);\nSphere sphere_4 = Sphere(vec3( 0.0, 1.5, 2.0), 0.4);\n\t\nstruct Box {\n\tvec3 center;\n\tvec3 size;\n};\nBox box_1 = Box(vec3(-1.0, 1.5, -1.0), vec3(0.4) );\nBox box_2 = Box(vec3( 1.0, 1.5, -1.0), vec3(0.4) );\nBox box_3 = Box(vec3( 0.0, 1.5, -1.0), vec3(0.4) );\nBox box_4 = Box(vec3( 0.0, 1.5, -2.0), vec3(0.4) );\n\nstruct Material {\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n\tfloat shininess;\n\t\n\tfloat reflectivity;\n\tfloat refractivity;\n\tfloat indexRefractive;\n\tbool flagSolid;\n};\n\nconst Material material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\n\nconst Material material_box_1 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_2 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_3 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_4 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\n\nconst Material material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.2, 0.2, 0.2), vec3(1.0), 128.0, 0.5, 0.0, 0.0, false );\nconst Material material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.5, 1.0, true );\n\nconst Material material_plane_2b \t= \tMaterial ( vec3(0.1, 0.0, 0.0), vec3(0.9, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\nconst Material material_plane_2w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.9, 0.95, true );\n\t\nstruct Light {\n\tvec3 position;\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n};\nLight light_0 = Light ( vec3(-10.0, 10.0, 10.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0) );\nLight light_1 = Light ( vec3( 10.0, 10.0, 10.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0) );\n\nMaterial getMaterial (Ray ray) {\n\tMaterial material;\n\tif (ray.object.id == 1) {\n\t\tfloat squareSize = 1.0;\n\t\tvec3 p = mod ( ray.position - plane_1.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s*0.5;\n\t\tfloat h = s*0.5;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_1b;\n\t\t} else {\n\t\t\tmaterial = material_plane_1w;\n\t\t}\n\t} else if (ray.object.id == 2) {\n\t\tfloat squareSize = 0.25;\n\t\tvec3 p = mod ( ray.position - plane_2.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s;\n\t\tfloat h = s;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_2b;\n\t\t} else {\n\t\t\tmaterial = material_plane_2w;\n\t\t}\n\t} else if (ray.object.id == 3) {\n\t\tmaterial = material_sphere_1;\n\t} else if (ray.object.id == 4) {\n\t\tmaterial = material_sphere_2;\n\t} else if (ray.object.id == 5) {\n\t\tmaterial = material_sphere_3;\n\t} else if (ray.object.id == 6) {\n\t\tmaterial = material_sphere_4;\n\t} else if (ray.object.id == 7) {\n\t\tmaterial = material_box_1;\n\t} else if (ray.object.id == 8) {\n\t\tmaterial = material_box_2;\n\t} else if (ray.object.id == 9) {\n\t\tmaterial = material_box_3;\n\t} else if (ray.object.id == 10) {\n\t\tmaterial = material_box_4;\n\t}\n\treturn material;\n}\n\t\n//-----------------------------------------------------------------------------------------\t\n//Пересечение луча со сферой\nfloat intersectSphere(Ray ray, Sphere sphere, inout vec3 normal) {\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.center - ray.origin;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 ) return ray.far;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 ) return ray.far;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 ) {\n\t\tt = t1;\n\t} else if ( t1 < 0.0 ) {\n\t\tt = t0;\n\t} else {\n\t\tt = min(t0,t1);\n\t}\n\tif (t<0.0) return ray.far;\n\tvec3 p = ray.origin + t * ray.direction;\n\tfloat flagInside = -sign(dot(ray.direction, p - sphere.center));\n\tnormal = normalize ( p - sphere.center ) * flagInside;\n\treturn t;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane(Ray ray, Plane plane, inout vec3 normal) {\n\tfloat det = dot ( plane.normal, ray.direction );\n\tif (abs(det) < ray.epsilon) return ray.far;\n\n\tfloat t = - ( dot ( plane.normal, ray.origin ) + length(plane.center) ) / dot ( plane.normal, ray.direction );\n\t\n\tif ( t < 0.0 ) return ray.far;\n\t\n\tfloat flagInside = -sign(dot(ray.direction, plane.normal));\n\tnormal = plane.normal;\n\tnormal *= flagInside;\n\t\t\n\treturn t;\t\n}\n//Пересечение луча с кубом\nfloat intersectBox(Ray ray, Box box, inout vec3 normal) {\n\t\n\tvec3 minp = box.center - box.size;\n\tvec3 maxp = box.center + box.size;\n\t\n\tfloat tmin = (minp.x - ray.origin.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.origin.x) / ray.direction.x;\n\tif (tmin > tmax) { \n\t\tfloat s = tmin; \n\t\ttmin = tmax; \n\t\ttmax = s; \n\t}\n\tfloat tymin = (minp.y - ray.origin.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.origin.y) / ray.direction.y;\n\tif (tymin > tymax) { \n\t\tfloat s = tymin; \n\t\ttymin = tymax; \n\t\ttymax = s; \n\t}\n\tif ((tmin > tymax) || (tymin > tmax)) return ray.far;\n\tif (tymin > tmin) tmin = tymin;\n\tif (tymax < tmax) tmax = tymax;\n\tfloat tzmin = (minp.z - ray.origin.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.origin.z) / ray.direction.z;\n\tif (tzmin > tzmax) { \n\t\tfloat s = tzmin; \n\t\ttzmin = tzmax; \n\t\ttzmax = s; \n\t}\n\tif ((tmin > tzmax) || (tzmin > tmax)) return ray.far;\n\tif (tzmin > tmin) tmin = tzmin;\n\tif (tzmax < tmax) tmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < ray.epsilon && tmax < ray.epsilon ) return ray.far;\n\tif ( tmin < ray.epsilon ) {\n\t\tt = tmax;\n\t} else if ( tmax < ray.epsilon ) {\n\t\tt = tmin;\n\t} else {\n\t\tt = min(tmin, tmax);\n\t}\n\t\n\tfloat flagInside = 1.;\n\tif ( tmin < ray.epsilon && tmax > ray.epsilon ) flagInside = -1.;\n\t\n\tvec3 p = ray.origin + t * ray.direction;\n\t\n\tif ( abs(p.x - maxp.x) < ray.epsilon ) {\n\t\tnormal = vec3(1,0,0) * flagInside;\n\t} else if ( abs(p.x - minp.x) < ray.epsilon ) {\n\t\tnormal = vec3(-1,0,0) * flagInside;\n\t} else if ( abs(p.y - maxp.y) < ray.epsilon ) {\n\t\tnormal = vec3(0,1,0) * flagInside;\n\t} else if ( abs(p.y - minp.y ) < ray.epsilon ) {\n\t\tnormal = vec3(0,-1,0) * flagInside;\n\t} else if ( abs(p.z - maxp.z ) < ray.epsilon ) {\n\t\tnormal = vec3(0,0,1) * flagInside;\n\t} else {\n\t\tnormal = vec3(0,0,-1) * flagInside;\n\t}\n\treturn t;\n}\n\n//---------------------------------------------------------------------------------\nvoid rayMarch(inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.hit = false;\n\tray.distance = Infinity;\n\tray.position = ray.origin + ray.distance * ray.direction;\n\tray.normal = vec3(0);\n\tray.object.id = -1;\n\n\tSphere sphere;\n\tPlane plane;\n\tBox box;\n\t\n\tfloat d;\n\tvec3 normal;\n\n\t//Горизонтальная поверхность\n\tplane = plane_1;\n\td = intersectPlane ( ray, plane, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 1;\n\t}\n\t\n\t//Вертикальная поверхность\n\tplane = plane_2;\n\td = intersectPlane ( ray, plane, normal );\n\tif (ray.distance > d) {\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tif (p.y>0. && p.y < 1.0 && abs(p.x) < 2.) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= 2;\n\t\t}\n\t}\n\t\n\t//Красная сфера\n\tsphere = sphere_1;\n\tsphere.center.y += sin(u_time * 0.4);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 3;\n\t}\n\t\n\n\t//Зеленая сфера\n\tsphere = sphere_2;\n\tsphere.center.y += cos(u_time * 0.5);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 4;\n\t}\n\t\n\t\n\t//Синяя сфера\n\tsphere = sphere_3;\n\tsphere.center.y += sin(u_time * 0.5);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 5;\n\t}\n/*\n\t//Белая сфера\n\tsphere = sphere_4;\n\tsphere.center.y += cos(u_time * 0.4);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 6;\n\t}\n*/\t\n\tbox = box_1;\n\tbox.center.y += cos(u_time * 0.4);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 7;\n\t}\n\n\tbox = box_2;\n\tbox.center.y += sin(u_time * 0.5);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 8;\n\t}\n\n\tbox = box_3;\n\tbox.center.y += cos(u_time * 0.5);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 9;\n\t}\n/*\n\tbox = box_4;\n\tbox.center.y += sin(u_time * 0.4);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 10;\n\t}\n*/\t\n}\n\nvec3 lighting(Ray ray, Light lights[2], Material material) {\n\tvec3 col = vec3(0);\n\t\n\tfor (int i=0; i<2; i++) {\n\t\tLight light = lights[i];\n\t\t\n\t\tfloat lightDistance = length(light.position - ray.position);\n\t\t\n\t\t//Тень\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= normalize(light.position - ray.position);\n\t\t\tray1.near \t\t= 0.01;\n\t\t\tray1.far\t\t= lightDistance;\n\t\t}\n\t\trayMarch ( ray1 );\n\t\n\t\t\n\t\tif ( ray1.distance < ray1.far) {\n\t\t\tshadowFactor = clamp(1. - (lightDistance - 3.*ray1.distance) / lightDistance, 0.2, 1.);\n\t\t}\n\t\t\n\t\tfloat distanceAttenuationPower = 0.2;\n\t\tvec3 lightDir \t= normalize(light.position - ray.position);\n\t\tvec3 eyeDir \t= - ray.direction; //normalize ( ray.origin - ray.position );\n\t\tvec3 reflected \t= reflect ( -lightDir, ray.normal );\n\t\n\t\tvec3 color = light.colorAmbient * material.colorAmbient;\n\t\n\t\tcolor += shadowFactor * light.colorDiffuse * material.colorDiffuse * max(dot(ray.normal,lightDir), 0.0);\n\t\tcolor += shadowFactor * light.colorSpecular * material.colorSpecular * pow ( max ( dot(reflected, eyeDir), 0.0) , material.shininess ) * step(1., shadowFactor) ;\t\n\t\tcolor *= min ( 1.0/pow(length(ray.position - ray.origin), distanceAttenuationPower), 1.0);\n\t\n\t\tcol += color/2.;\n\t}\n\t\n\treturn col;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[2]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\t//Цвет фона\n\t\t\tcolor += vec3(0.1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[2]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления сквозь фигуру\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n            \n            if (! material.flagSolid) {\n\n\t\t\t\t\n\t\t\t\tif (ray.hit) {\n\t\t\t\t\t//Достигли границы 2 фигуры\n\t\t\t\t\t//Луч преломления сквозь границу 2 фигуры\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t//Цвет за границей 2 фигуры\n\t\t\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t\t\t\t\n\t\t\t\t\t//Луч отражения от границы 2\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Отражение от границы 2\n\t\t\t\t\trayMarch (ray);\n\t\t\t\t\t\n\t\t\t\t\tif (ray.hit) {\n\t\t\t\t\t\t//Отраженный луч достиг границы 1 фигуры\n\t\t\t\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy -= 0.5;\n    if (u_mouse.xy==vec2(0) ) mouse.xy = vec2(0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n\n        cam.origin  = vec3(0.0, 3.0, 3.0);\n        \t\t\t\t\n\t\tif (mouse.z != 0.0) {\n\t\t\trotate(cam.origin, vec3(1,1,0) * vec3(PI/3. + mouse.y*PI, mouse.x*2.*PI + u_time * 0.2, 0));\n\t\t} else {\n\t\t\trotate(cam.origin, vec3(0,1,0) * u_time * 0.2);            \n\t\t}\t\n\t\t\t\t\t\t\t\t\t\n//        cam.origin  = vec3(0.0, 3.0, 3.0 + mouse.z);\n//        rotate (cam.origin, vec3(1,1,0) * vec3(mouse.y*PI, mouse.x*PI*2. + (mouse.z==0. ? u_time/4. : 0.), 0));\n\n        cam.target  = vec3(0,1,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 1e20;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 1;\n    }\t\n\n    rotate(light_0.position, vec3(0,1,0)*u_time*0.25);\n    rotate(light_1.position, vec3(0,1,1)*u_time*0.25);\n\n    vec3 color = vec3(0);\n\n    Light lights[2];\n    lights[0] = light_0;\n    lights[1] = light_1;\n\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);\n\n    //Гаммакоррекция\n    //\t\t\tcolor = pow(color, vec3(1.0/2.2));\n\n    GL_FragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}