{"ver":"0.1","info":{"id":"DsVBzW","date":"1697988325","viewed":143,"name":"[TDF16ms] Falling Truchet Blocks","username":"Kamoshika","description":"GLSL Graphics Compo @ TDF (Tokyo Demo Fest) 16ms\nhttps://16ms.tokyodemofest.jp\n\nThankfully, it won 2nd place out of 8 entries!","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raycasting","voxel","globalillumination","truchet","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader (twigl link):\n// https://twigl.app?ol=true&ss=-NhMXwZqlzHqchJeAyu9\n\n// The code has been changed due to bug fixes, etc.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int maxDepth = 3;    // レイの経路の深さの最大値（反射回数+1の値）\nconst int numSamples = 20; // パストレーシングのサンプル数\n\nconst float PI = acos(-1.);       // 円周率\nconst float PI2 = acos(-1.) * 2.;\nconst float EPS = 0.0001;         // レイトレースなどに使う微小量\nconst float FOV = 60.;            // 視野角（degree） 範囲：(0., 180.)\nconst float fallInterval = 100.;  // Voxelが落ちてくる間隔\nconst float fallSpeed = 4.;       // Voxelが落ちる速さ\nconst float heightRange = 5.;     // Voxelの高さの範囲\nconst float bumpFactor = 2.;      // Voxelの凹凸の強さ\n\nvec3 camPos;         // カメラの座標\nfloat pathSeed = 0.; // パストレーシングで使う乱数のシード\n\n// 1Dの乱数\nfloat hash11(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// 3Dの乱数\nfloat hash13(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 52.178))) * 43758.5453); // 52.178は信頼できない\n}\n\n// 1Dの乱数(シードを更新)\nfloat random() {\n    return hash11(pathSeed++);\n}\n\n// 2Dの回転行列\nmat2 rotate2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// HSVをRGBに変換\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.);\n    res = clamp(abs(res * 6. - 3.) - 1., 0., 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    return res;\n}\n\n// 座標pにVoxelが存在するか否か\nfloat map(vec3 p, out vec3 ID) {\n    float res = 1.;\n    ID = floor(p);\n    float h = hash12(ID.xz);\n    ID.y -= floor(max(ID.x * ID.x * 0.1, 5.) - h * heightRange);\n    float T = iTime * fallSpeed / fallInterval + hash11(h);\n    if(ID.y > 0.) {\n        float tmp = ID.y / fallInterval + T;\n        if(fract(tmp) * fallInterval > 1.) {\n            res = 0.;\n        }\n        ID.y = floor(tmp);\n    } else {\n        ID.y += floor(T);\n    }\n    \n    p += 0.5 - camPos;\n    if(dot(p, p) < 1.) {\n        res = 0.;\n    }\n    return res;\n}\n\n// ref: \"Voxel Edges\" by iq\n// https://www.shadertoy.com/view/4dfGzs\n// roから物体表面まで飛ばしたレイの長さ\nfloat castRay(vec3 ro, vec3 rd, const int itr, out vec3 ID, out vec3 normal, out vec3 pos, out float seed) {\n    pos = floor(ro);\n    vec3 ri = 1.0 / rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri; // roからセルの境界までのレイの長さ（X,Y,Z方向）\n    \n    float res = -1.0;\n    vec3 mm = vec3(0);\n    vec3 tmp = vec3(0);\n    for(int i = 0; i < itr; i++) {\n        if(map(pos, ID) > 0.5) {\n            res = 1.0;\n            break;\n        }\n        mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy); // X,Y,Zのうち、どの方向の隣接セルに進むか\n        tmp = mm * rs;\n        dis += tmp * ri;\n        pos += tmp;\n    }\n    \n    normal = -tmp;\n    vec3 mini = (pos - ro + 0.5 - 0.5 * rs) * ri;\n    float t = max(mini.x, max(mini.y, mini.z)); // roからVoxel表面まで伸ばしたレイの長さ\n    \n    seed = hash13(ID);\n    \n    return t * res;\n}\n\n// エミッションの色\nfloat emission(float seed) {\n    return step(hash11(seed), 0.08) * 10.;\n}\n\n// 物体の色\nvec3 objColor(float seed){\n    return hsv(hash11(seed), 0.6, 1.);\n}\n\n// Voxelの凹凸\nfloat bumpFunc(vec3 p, vec3 n, float seed) {\n    float nSeed = dot(n, vec3(1, 2, 4));\n    n = abs(n);\n    vec2 uv = n.x > 0.5 ? p.yz : n.y > 0.5 ? p.xz : p.xy;\n    uv = fract(uv) - 0.5;\n    \n    if(hash11(seed + nSeed) < 0.5) {\n        uv.y = -uv.y;\n    }\n    if(uv.y < -uv.x) {\n        uv = -uv.yx;\n    }\n    float d = abs(length(uv - 0.5) - 0.5);\n    const float w = 0.15;\n    float tmp = w * w - d * d;\n    float res = tmp > 0. ? sqrt(tmp) : 0.;\n    \n    return -res;\n}\n\n// ref: \"Maze Lattice\" by Shane\n// https://www.shadertoy.com/view/llGGzh\n// Voxelの凹凸ベクトル\nvec3 bumpMap(vec3 p, vec3 n, float seed) {\n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p, n, seed);\n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n, seed),\n                      bumpFunc(p - e.yxy, n, seed),\n                      bumpFunc(p - e.yyx, n, seed)) - ref) / e.x;\n    grad -= n * dot(n, grad);\n    return normalize(n + grad * bumpFactor);\n}\n\n// vを天頂として極座標phi, thetaだけ回転させたベクトル\n// ※引数vは長さ1のベクトルである必要あり\nvec3 jitter(vec3 v, float phi, float sinTheta, float cosTheta) {\n    vec3 xAxis = normalize(cross(v.yzx, v));\n    vec3 yAxis = cross(v, xAxis);\n    vec3 zAxis = v;\n    return (xAxis * cos(phi) + yAxis * sin(phi)) * sinTheta + zAxis * cosTheta;\n}\n\n// ref: \"パストレーシング - Computer Graphics - memoRANDOM\" by Shocker_0x15\n// (Japanese article)\n// https://rayspace.xyz/CG/contents/path_tracing/\n\n// ref: \"GLSL smallpt\" by Zavie\n// https://www.shadertoy.com/view/4sfGDB\n\n// ref: \"[SESSIONS] Syobon's Lobby\" by Kamoshika (myself)\n// https://www.shadertoy.com/view/ctt3zX\n\n// パストレーシングで得られる色\nvec3 pathTrace(vec3 ro, vec3 rd) {\n    vec3 acc = vec3(0);\n    vec3 mask = vec3(1);\n    \n    vec3 ID;     // VoxelのID\n    vec3 normal; // Voxelの法線ベクトル ((±1, 0, 0) or (0, ±1, 0) or (0, 0, ±1))\n    vec3 pos;    // Voxelの整数座標\n    float seed;  // Voxelの色やエミッション、模様を決定するシード\n    \n    // 最初にカメラからレイを飛ばす\n    float t = castRay(ro, rd, 100, ID, normal, pos, seed);\n    if(t < 0.) { // レイが物体に衝突しなかった\n        return vec3(0.);\n    }\n    ro += t * rd; // レイの原点を物体表面まで進める\n    \n    vec3 f = ro - pos - 0.5;\n    vec3 n = normalize(f * pow(f, vec3(8.)));\n    n = normalize(n + bumpMap(ro, normal, seed));\n    \n    // ※本来はサンプル数の分だけカメラからレイを飛ばすため、numSamplesをかける\n    acc += mask * emission(seed) * float(numSamples);\n    mask *= objColor(seed);\n    \n    // 次に、物体表面からランダムにレイを飛ばす\n    vec3 ro0 = ro + n * EPS;\n    vec3 n0 = n;\n    vec3 mask0 = mask;\n    for(int i = 0; i < numSamples; i++) {\n        ro = ro0;\n        n = n0;\n        mask = mask0;\n        for(int depth = 1; depth < maxDepth; depth++) {\n            float ur = random(); // 一様乱数\n            // 重点的サンプリングを行うため、半球面内cos分布を使用する\n            rd = jitter(n, random() * PI2, sqrt(1. - ur), sqrt(ur)); // 次のレイの方向\n            \n            t = castRay(ro, rd, 15, ID, normal, pos, seed);\n            if(t < 0.) { // レイが物体に衝突しなかった\n                break;\n            }\n            ro += t * rd;\n            \n            f = ro - pos - 0.5;\n            n = normalize(f * pow(f, vec3(8.)));\n            n = normalize(n + bumpMap(ro, normal, seed));\n            \n            acc += mask * emission(seed);\n            mask *= objColor(seed);\n            ro += n * EPS; // 現在の物体表面を避けるために、少し浮かせる\n        }\n    }\n    \n    acc /= float(numSamples);\n    acc = clamp(acc, 0., 1.);\n    \n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y); // 座標の正規化\n    \n    camPos = vec3(0.5, 7.5, -iTime * 2.); // カメラの位置（レイの原点）\n    vec3 dir = normalize(vec3(0.5, -0.3, -1)); // カメラの向き\n    dir.xy *= rotate2D(iTime * 0.2);\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = cross(side, dir);\n    vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(FOV / 360. * PI)); // レイの向き\n    \n    // パストレーシングで使う乱数のシードを初期化する\n    float T = fract(iTime / 10.) * 500.;\n    pathSeed = hash12(fragCoord * PI) * 500.;\n    pathSeed += hash12(fragCoord + pathSeed + T) * 500.;\n    \n    // パストレーシングをする\n    vec3 col = vec3(0);\n    col += pathTrace(camPos, rd);\n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    \n    // パストレーシングで得られた色の分散を低減するために前のフレームの色を合成する\n    float tex = 0.6;\n    //float tex = 0.;\n    col = mix(col, texture(iChannel0, fragCoord / iResolution.xy).rgb, tex);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}