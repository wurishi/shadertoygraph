{"ver":"0.1","info":{"id":"dtGcRh","date":"1700102373","viewed":104,"name":"Shell Texturing Fur Ball","username":"Dev1ati0n","description":"Using the shell texturing technique, described here: https://youtu.be/9dr-tRQzij4 but with slightly more fleshed-out physics.\nHopefully my comments are enough to understand what the program is doing, I added them kind of hastily after the fact.","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["ball","shell","acerola","shelltexturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Increase to improve performance\n#define shelldistance 0.003\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = normalize(vec3(1,fragCoord/iResolution.x-0.5*iResolution.xy/iResolution.x));\n    vec3 ballpos = vec3(6,0,0);\n    vec2 mouse = texture(iChannel1,vec2(0.25,0.75)).xy;\n    ballpos.yz = mouse/iResolution.x-0.5*iResolution.xy/iResolution.x;\n    ballpos.yz *= ballpos.x;\n    float rad;\n    \n    vec3 curve = 0.00004*vec3(0,texture(iChannel1,vec2(0.75,0.25)).xy); // Retrieve fur curvature direction\n    curve /= length(curve) + 1.; // Apply sigmoid function to curvature amount\n    curve *= 4.;\n    \n    \n    for(rad = 0.333; rad >= 0.; rad -= shelldistance){\n        \n        vec3 center = ballpos+curve*rad*rad; // Calculate shell center\n        \n        float det = dot(uv,center)*dot(uv,center)-dot(center,center)+rad*rad+2.*rad+1.; // Sphere intersection\n        \n        vec3 pos = vec3(0);\n        vec3 nrm = vec3(0);\n        vec3 texuv = vec3(0);\n        float diffuse;\n        \n        if(det>0.){ // If ray intersects sphere\n            \n            pos = uv*(dot(uv,center)-sqrt(det)); // Point on sphere\n            nrm = (pos-center)/(rad+1.); // Normal vector\n            diffuse = .1*dot(nrm,vec3(-0.333,0.667,0.667))+.9; // Lambertian diffuse\n            texuv = 30.*nrm/max(max(abs(nrm.x),abs(nrm.y)),abs(nrm.z)); // Texture UV Coordinates\n            float hairlen = 0.2+0.8*texture(iChannel0,texuv/32.+0.0001).r; // Get hair length\n            float r = sqrlen(fract(texuv+0.0001)-0.5); // Get distance from center of strand\n            r = 2.*sqrt(r-0.2499);\n            if(r<(1.-3.*rad/hairlen)){fragColor=diffuse*.5*(rad+2.)*vec4(0.9,0.7,0.5,1.0); return;}\n        }\n    }\n    \n    float det = dot(uv,ballpos)*dot(uv,ballpos)-dot(ballpos,ballpos)+rad*rad+2.*rad+1.;\n    \n    vec3 pos = vec3(0);\n    vec3 nrm = vec3(0);\n    vec3 texuv = vec3(0);\n    float diffuse;\n    \n    if(det>0.){ // If ray intersects sphere\n        pos = uv*(dot(uv,ballpos)-sqrt(det));\n        nrm = (pos-ballpos)/(rad+1.);\n        diffuse = .1*dot(nrm,vec3(-0.333,0.667,0.667))+.9;\n        fragColor=vec4(0.9,0.7,0.5,1.0)*diffuse;\n        return;\n    }\n    \n    fragColor = vec4(0.7,0.8,0.9,1.); // Sky color\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0);\n    float maxSpeed = 3000./iFrameRate;\n    \n    if(uv.y>0.5){\n        if(uv.x<0.5){\n            if(iMouse.xy==vec2(0)){fragColor.xy=iResolution.xy*0.5; return;}\n            vec2 lastmouse = texture(iChannel0,vec2(0.25,0.75)).xy;\n            if(sqrlen2(iMouse.xy-lastmouse)>maxSpeed*maxSpeed){fragColor.xy=lastmouse+maxSpeed*normalize(iMouse.xy-lastmouse); return;} // Limit the ball's speed\n            fragColor.xy=iMouse.xy; return;\n        }\n        if(iFrame==0){fragColor.xy=iResolution.xy*0.5; return;}\n    fragColor.xy = texture(iChannel0,vec2(0.25,0.75)).xy; return;\n    }\n    if(uv.x<0.5){\n        vec2 lastmouse;\n        vec2 lastlastmouse;\n        if(iFrame==0){lastmouse=iResolution.xy*0.5; lastlastmouse=lastmouse;}\n        else{\n            lastmouse = texture(iChannel0,vec2(0.25,0.75)).xy;\n            lastlastmouse = texture(iChannel0,vec2(0.75,0.75)).xy;\n        }\n        vec2 currmouse; // Calculate current ball position\n        if(iMouse.xy==vec2(0)){currmouse=iResolution.xy*0.5;}\n        else if(sqrlen2(iMouse.xy-lastmouse)>maxSpeed*maxSpeed){currmouse=lastmouse+maxSpeed*normalize(iMouse.xy-lastmouse);}\n        else{currmouse=iMouse.xy;}\n        \n        vec2 accel = -currmouse+2.*lastmouse-lastlastmouse; // Calculate acceleration of the ball\n        accel *= iFrameRate*iFrameRate;\n        accel.y += -20000.; // Gravity\n        fragColor.xy = texture(iChannel0,vec2(0.25,0.25)).xy; // Get previous hair velocity\n        fragColor.xy += 12.*(accel-texture(iChannel0,vec2(0.75,0.25)).xy)/iFrameRate; // Apply hair acceleration\n        fragColor.xy *= exp(-6./iFrameRate); // Damping\n        return;\n    }\n    fragColor.xy = texture(iChannel0,vec2(0.75,0.25)).xy+9.*texture(iChannel0,vec2(0.25,0.25)).xy/iFrameRate; // Apply hair velocity\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float sqrlen(vec3 x){ // length of a vector squared\n    return dot(x,x);\n}\n\nfloat sqrlen2(vec2 x){ // length of a vector squared\n    return dot(x,x);\n}","name":"Common","description":"","type":"common"}]}