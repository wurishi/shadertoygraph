{"ver":"0.1","info":{"id":"DlBcWd","date":"1732078647","viewed":87,"name":"Very Fake Atmosphere","username":"fishy","description":"very fake but looks pretty! it's just a bunch of magic numbers\n\nit's really blue...","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fake","sky","scattering","skybox","atmosphere","rayleigh","mie","skylight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AXIS_X vec3(1, 0, 0)\n#define AXIS_Y vec3(0, 1, 0)\n#define AXIS_Z vec3(0, 0, 1)\n\n#define PI  3.1415927\n#define TAU 6.2831853\n\n#define PROJECTION 1\n\nvec3 rot(vec3 p, vec3 k, float t)\n{\n    k = normalize(k);\n    return mix(k*dot(k,p), p, cos(t)) + cross(k, p)*sin(t);\n}\n\nvec3 project(vec2 uv)\n{\n#if PROJECTION == 0\n    vec2 r = uv * PI;\n    vec3 p = vec3(0, 0, 1);\n    return rot(rot(p, AXIS_X, -r.y*0.5), AXIS_Y, r.x);\n#else\n    //uv = normalize(uv) * min(0.99, length(uv));\n    //return vec3(uv.x, sqrt(1.0-dot(uv, uv)), uv.y);\n    return vec3(2.0 * uv / (1.0 + dot(uv, uv)), -(-1.0 + dot(uv, uv)) / (1.0 + dot(uv, uv))).xzy;\n#endif\n}\n\nvec3 skylight(vec3 r, vec3 l)\n{\n    // Utility macros\n    #define impulse(x, k) k*x*exp(1.0 - k*x)\n    #define sustain(x, k, p) pow(1.0 - exp(-k*x), p)\n    #define SUN_SIZE 0.0025\n    \n    // Get the \"time\"\n    float sunBrightness = smoothstep(-0.3, 1.0, l.y);\n    \n    // Get the gradient value\n    float cx = (max(0.0, r.y) + 0.3) * sunBrightness * 2.0;\n    // Distort gradient value by how far away it is from the sun\n    // replicating the Earth's shadow\n    cx += (dot(r, l)*0.5+0.5)*0.2;\n    \n    // Compute sky gradient\n    vec3 baseColor = vec3(impulse(cx, 8.0),\n                          0.5*sustain(cx, 32.0, 10.0) + 0.2*impulse(cx, 6.0),\n                          sustain(cx, 10.0, 5.0)) * pow(sunBrightness, 0.7);\n    \n    // Get the halo around the sun and the gradient from bottom to top\n    vec3 sunHalo = pow(dot(r, l)*0.5+0.5, 32.0) * smoothstep(-0.5, 1.0, r.y) * vec3(1.0, 0.8, 0.7) * baseColor*4.0;\n    sunHalo += exp(-abs(r.y) * sunBrightness * 2.0) * pow(sunBrightness, 1.0) * baseColor*2.0;\n    \n    vec3 sunDisk = smoothstep(1.0 - SUN_SIZE, 1.0, max(0.0, dot(r, l)))*vec3(1.000,0.549,0.102) * 100.0 * smoothstep(-0.02, 1.0, r.y);\n    \n    // Final color = base color + sun halo + sun disk + constant value so nights aren't completely black\n    vec3 finalColor = baseColor;\n    finalColor += sunHalo;\n    finalColor += sunDisk;\n    finalColor += vec3(0.05, 0.05, 0.1)*0.3;\n    \n    return finalColor;\n}\n\nvec3 hillAcesTonemap(vec3 col) {\n    col = max(vec3(0), col) * mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777));\n    \n    vec3 a = col * (col + 0.0245786) - 0.000090537;\n    vec3 b = col * (0.983729 * col + 0.4329510) + 0.238081;\n    col = a/b;\n    \n    return clamp(col * mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)), vec3(0), vec3(1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if PROJECTION == 0\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    vec2 m = iMouse.xy/iResolution.xy*2.0-1.0;\n#else\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy*2.0-iResolution.xy)/iResolution.y;\n#endif\n    float t = -(sin(iTime)*0.6+0.5)*PI;\n    \n    vec3 sky = skylight(project(uv), iMouse.x > 1.0? project(m) : rot(AXIS_Z, AXIS_X, t));\n\n    // Output to screen\n    fragColor = vec4(sqrt(hillAcesTonemap(sky)),1.0);\n    //fragColor.rgb = project(uv).yyy;\n}","name":"Image","description":"","type":"image"}]}