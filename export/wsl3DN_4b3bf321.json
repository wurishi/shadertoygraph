{"ver":"0.1","info":{"id":"wsl3DN","date":"1546447554","viewed":706,"name":"Conway's Ecosystem","username":"khlorghaal","description":"Mouse click to zoom.\n\nThis was my first research citation! in \"Lenia and Expanded Universe\" by Chakazul https://arxiv.org/abs/2005.03742","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["automata","life","conway","discrete"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//simple renderer, see buffer A\nvec4 img(vec2 uv){\n    uv.x*= res.y/res.x;\n    if(iMouse.z>.5){\n    \tuv*= .3;\n        uv+= mouse;\n    }\n    vec4 t= tex(iChannel0, uv);\n    if(t.y>.5)//connie\n        return vec4(0.,0.,1.,1.);\n    if(t.z>.5)//mitosaur\n        return vec4(1.,0.,0.1,1.);\n    \n    vec3 col;\n    float g= t.x/150.;\n    vec3 grass= vec3(0.1,.8,0.1)*g;\n    col= grass;\n    \n    col= lerp(col, vec3(.4,.7,.85), sat(t.w));//blob\n    \n    return vec4(col,1.);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 col, in vec2 fragCoord ) { col = img(fragCoord/iResolution.xy); }\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define BIG 1e8\n#define ETA 1e-5\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc gl_FragCoord.xy\n#define res iResolution.xy\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*vec2(PI, PI/2.))\n#define tex texture\n\n//vectorization macros\n//I dont use these since I don't trust the optimizer to inline the lambda\n//also multiline edit is easy\n#define VECTORIZE_UNARY_FLOAT(f) \\\nvec2 f(vec2 a){ return vec2(f(a.x),f(a.y)); } \\\nvec3 f(vec3 a){ return vec3(f(a.x),f(a.y),f(a.z)); } \\\nvec4 f(vec4 a){ return vec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_FLOAT(f) \\\nvec2 f(vec2 a, vec2 b){ return vec2(f(a.x,b.x),f(a.y,b.y)); } \\\nvec3 f(vec3 a, vec3 b){ return vec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nvec4 f(vec4 a, vec4 b){ return vec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n#define VECTORIZE_UNARY_INT(f) \\\nivec2 f(ivec2 a){ return ivec2(f(a.x),f(a.y)); } \\\nivec3 f(ivec3 a){ return ivec3(f(a.x),f(a.y),f(a.z)); } \\\nivec4 f(ivec4 a){ return ivec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_INT(f) \\\nivec2 f(ivec2 a, ivec2 b){ return ivec2(f(a.x,b.x),f(a.y,b.y)); } \\\nivec3 f(ivec3 a, ivec3 b){ return ivec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nivec4 f(ivec4 a, ivec4 b){ return ivec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n/* example\nfloat accumulate(float x){ return acc+= x; }\nVECTORIZE_UNARY_FLOAT(accumulate);\nAn impure function is a weird but valid example\n*/\n#define VECTORIZE_SCALAR_ARG(f) \\\nvec2 f(vec2 x, vec1 y){ return _f(x,vec2(y));} \\\nvec3 f(vec3 x, vec1 y){ return _f(x,vec3(y));} \\\nvec4 f(vec4 x, vec1 y){ return _f(x,vec4(y));}\n\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\nvec2 clamps(vec2 x, vec1 min, vec1 max){ return clamp(x, vec2(min),vec2(max));}\nvec3 clamps(vec3 x, vec1 min, vec1 max){ return clamp(x, vec3(min),vec3(max));}\nvec4 clamps(vec4 x, vec1 min, vec1 max){ return clamp(x, vec4(min),vec4(max));}\nvec2 mins(vec2 v, vec1 s){ return min(v, vec2(s));}\nvec3 mins(vec3 v, vec1 s){ return min(v, vec3(s));}\nvec4 mins(vec4 v, vec1 s){ return min(v, vec4(s));}\nvec2 maxs(vec2 v, vec1 s){ return max(v, vec2(s));}\nvec3 maxs(vec3 v, vec1 s){ return max(v, vec3(s));}\nvec4 maxs(vec4 v, vec1 s){ return max(v, vec4(s));}\nvec2 mins(vec1 s, vec2 v){ return min(v, vec2(s));}\nvec3 mins(vec1 s, vec3 v){ return min(v, vec3(s));}\nvec4 mins(vec1 s, vec4 v){ return min(v, vec4(s));}\nvec2 maxs(vec1 s, vec2 v){ return max(v, vec2(s));}\nvec3 maxs(vec1 s, vec3 v){ return max(v, vec3(s));}\nvec4 maxs(vec1 s, vec4 v){ return max(v, vec4(s));}\n\nfloat maxv(vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv(vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv(vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv(vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv(vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv(vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\nfloat sum (vec2 v){ return dot(v,vec2(1));}\nfloat sum (vec3 v){ return dot(v,vec3(1));}\nfloat sum (vec4 v){ return dot(v,vec4(1));}\nfloat prod(vec2 v){ return v.x*v.y;}\nfloat prod(vec3 v){ return v.x*v.y*v.z;}\nfloat prod(vec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nfloat pow2i(int x){ return float(1<<x); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>16)^x)*0x45d9f3b;\n\tx= ((x>>16)^x)*0x45d9f3b;\n\t//x=  (x>>16)^x;\n    return x;\n}\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(dot(x,x+R2A))); }\nvec3 rand (vec3 x){ return hashf(x*hashf(dot(x,x+R3A))); }\nvec4 rand (vec4 x){ return hashf(x*hashf(dot(x,x+R4A))); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\n//vec1 rand1(vec3 x){ return hashf(dot(x+R3A,x+R3B));  }\n//vec1 rand1(vec4 x){ return hashf(dot(x+R4A,x+R4B));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\n\n\n\n//f0 is a param because its almost always calculated for something else\n#define grad2(f,f0,x) \\\n\t((vec2( \\\n    \tf( x+vec2(ETA,0) ), \\\n\t\tf( x+vec2(0,ETA) ) \\\n\t)-f0)/ETA)\n#define grad3(f,f0,x) \\\n\t((vec3( \\\n    \tf( x+vec3(ETA,0,0) ), \\\n\t\tf( x+vec3(0,ETA,0) ), \\\n\t\tf( x+vec3(0,0,ETA) ) \\\n\t)-f0)/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\n#define FOV 110.\n#define FOV_S tan(deg2rad*.5*FOV)\n#define NEAR .1\n\nray look_persp(vec2 uv, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uv*FOV_S,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_orbit(vec2 uv, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uv*FOV_S,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Copyright 2018 GNU GPLv3 https://www.gnu.org/licenses/gpl.txt\n\nstruct ecos{\n    int plant;//eaten by connies, regenerates\n\tbool connie;//conway's life modified to eat plants\n    int mitosisaur;//predator, divides after eating enough connies\n    float blob;//omnivore, eats connies when there is lots of plant\n};\n//lots more animals could be added if creative with packing\necos ecos_unpack(vec4 t){\n    return ecos(\n        int(t.x),\n    \tt.y>.5,\n       \tint(t.z),\n        t.w\n    );\n}\nvec4 ecos_pack(ecos e){\n    return vec4(\n        float(e.plant)+.5,\n    \tfloat(e.connie)+.5,\n        float(e.mitosisaur)+.5,\n        e.blob\n    );\n}\n\n#define R 1\n#define arrw (R*2+1)\n#define arrl (arrw*arrw)\n#define idx ((x+R)+(y+R)*arrw)\n#define idx0 (R+R*arrw)\n#define loop \\\nfor(int x=-R;x<=R;x++)\\\n\tfor(int y=-R;y<=R;y++)\n\nvec4 img(vec2 uv){\n    vec2 uvn= nmaps(uv);\n    \n    //initial state\n    if(tex(iChannel0, vec2(0.)).r==0.0){\n        vec4 rnd= rand(vec4(fc/res,0.1,0.2));\n        ecos e= ecos(\n            9000,\n        \trnd.r>.96? true:false,\n            rnd.g>.998? 9000:0,\n            sat(rnd.b-.9)\n        );\n        return ecos_pack(e);\n    }\n    \n    vec2 o00= gl_FragCoord.xy;\n    vec2 o[arrl];\n    loop{\n    \to[idx]= (o00+vec2(x,y))/res;\n    }\n    ecos eco[arrl];\n    loop{\n        vec4 v= tex(iChannel0, o[idx]);\n        eco[idx]= ecos_unpack(v);\n    }\n    \n    //previous values\n    ecos c= eco[idx0];\n    bool connie= c.connie;\n    int m= c.mitosisaur;\n    float b= c.blob;\n    \n    //plants\n    #define pmax 250\n    int p= c.plant;\n    p= min(pmax, p+1);\n        \n    if(connie)\n        p-= 8;//population controller\n    \n        \n    //connies\n    int n= 0;//adjacent\n    loop{\n        n+= eco[idx].connie? 1:0;\n    }\n    n-= connie? 1:0;\n\n    #define c_die  (c.connie= false)\n    #define c_live (c.connie= true)\n    if(connie){\n        if(n<2||n>3 || p<=0)\n            c_die;\n    }\n    else{//empty\n        if(n>=3 && n<5 && p>1){//reproduce            \n            //p-= 4;//babies eat less\n            c_live;\n        }\n    }\n    \n    \n    \n    //mitosisaurs\n    //i dont understand how the advection works.\n    //i randomly poked the code until it did what i wanted.\n    int m_sum= 0;\n    int m_count= 0;\n    loop{\n        int mB= eco[idx].mitosisaur;\n    \tm_sum+= mB;\n        m_count+= mB!=0? 1:0;\n    }\n    #define m_full 40\n    #define m_eat 5\n    if(m!=0){\n        if(connie){//nom\n            m+= m_eat;\n            c_die;\n        }\n        else\n\t\t\tm--;\n        if(m_count>3)//not friendly\n            m-= m_eat/5;\n        \n        b= -10.;\n    }\n    else if(m_count>1){\n    \tif(m_sum>=m_full)\n            m= m_full/m_count;\n    }\n    \n   \n    \n    //blob\n    float b_avg= 0.;\n    loop{\n    \tb_avg+= eco[idx].blob;\n    }\n    b_avg/= 9.;\n    float pf= float(p)/float(pmax);\n    b= lerp(b,b_avg, .15);//diffusion\n    if(p<pmax-pmax/8){//die without enough plant\n        b= 0.;\n    }\n    if(n>0 && b>=1.){\n        c_die;//nom\n        b+= 2.5;\n    }\n    if(p==pmax&&b<=0.01)//seeding\n        b= min(1.,b+1.);\n\n    //mouse interaction\n    if(keyDown(KEY_SPACE) && len(mouse-uvn)<.2)\n        p= 0;\n    \n    \n    //output\n    c.plant= p;\n    c.mitosisaur= max(0,min(m_full,m));\n    c.blob= max(0.,b);\n    return ecos_pack(c);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 col, in vec2 fragCoord ) { col = img(fragCoord/iResolution.xy); }\n#endif\n","name":"Buffer A","description":"","type":"buffer"}]}