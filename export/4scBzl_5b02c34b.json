{"ver":"0.1","info":{"id":"4scBzl","date":"1526312769","viewed":390,"name":"Light Field rendering","username":"KylBlz","description":"Control the view of the light field with your mouse. To view the raw light field, mouse over to the top or right of the window. Experiment with the resolution trade-off by changing SUBFRAMES in the Common tab.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["ray","light","field","trace","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Light Field rendering (kinda)\n// Buffers A-D render a SUBFRAMES by SUBFRAMES grid of views (defined in Common)\n// This pass blends between them\n\nvec4 lf(in vec2 uv) {\n    int frame = int(step(.5, uv.x)) + 2 * int(step(.5, uv.y));\n    if (frame == 0) return tex(iChannel0, uv * 2.);\n    if (frame == 1) return tex(iChannel1, uv * 2. - vec2(1., 0.));\n    if (frame == 2) return tex(iChannel2, uv * 2. - vec2(0., 1.));\n    if (frame == 3) return tex(iChannel3, uv * 2. - vec2(1., 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 asp = vec2(iResolution.x / iResolution.y, 1.),\n    \t uv = fragCoord.xy / iResolution.xy,\n    \t mouse = iMouse.xy / iResolution.xy,\n    \t ms2 = mouse * SUBFRAMES * 2.,\n    \t fms2 = fract(ms2),\n    \t uv00 = (uv + floor(ms2)) * SUBFRAMES_RCP,\n    \t uv01 = (uv + floor(ms2 + vec2(0., 1.))) * SUBFRAMES_RCP,\n    \t uv10 = (uv + floor(ms2 + vec2(1., 0.))) * SUBFRAMES_RCP,\n    \t uv11 = (uv + floor(ms2 + vec2(1., 1.))) * SUBFRAMES_RCP;\n    int frame = int(step(.5, mouse.x)) + 2 * int(step(.5, mouse.y));\n    if (frame == 0) {\n        // this ugly bit exists because we are blending between channels\n        vec4 c00 = (uv00.x > 1.)? (uv00.y > 1.)? tex(iChannel3, fract(uv00)): tex(iChannel1, fract(uv00)): (uv00.y > 1.)? tex(iChannel2, fract(uv00)): tex(iChannel0, uv00);\n        vec4 c01 = (uv01.x > 1.)? (uv01.y > 1.)? tex(iChannel3, fract(uv01)): tex(iChannel1, fract(uv01)): (uv01.y > 1.)? tex(iChannel2, fract(uv01)): tex(iChannel0, uv01);\n        vec4 c10 = (uv10.x > 1.)? (uv10.y > 1.)? tex(iChannel3, fract(uv10)): tex(iChannel1, fract(uv10)): (uv10.y > 1.)? tex(iChannel2, fract(uv10)): tex(iChannel0, uv10);\n        vec4 c11 = (uv11.x > 1.)? (uv11.y > 1.)? tex(iChannel3, fract(uv11)): tex(iChannel1, fract(uv11)): (uv11.y > 1.)? tex(iChannel2, fract(uv11)): tex(iChannel0, uv11);\n        \n        fragColor = mix( mix(c00, c10, fms2.x), mix(c01, c11, fms2.x), fms2.y);\n    } else if (frame == 1) {\n        uv00 -= vec2(1., 0.);\n        uv01 -= vec2(1., 0.);\n        uv10 -= vec2(1., 0.);\n        uv11 -= vec2(1., 0.);\n        // this ugly bit exists because we are blending between channels\n        vec4 c00 = (uv00.x > 1.)? lf(uv): (uv00.y > 1.)? tex(iChannel3, fract(uv00)): tex(iChannel1, uv00);\n        vec4 c01 = (uv01.x > 1.)? lf(uv): (uv01.y > 1.)? tex(iChannel3, fract(uv01)): tex(iChannel1, uv01);\n        vec4 c10 = (uv10.x > 1.)? lf(uv): (uv10.y > 1.)? tex(iChannel3, fract(uv10)): tex(iChannel1, uv10);\n        vec4 c11 = (uv11.x > 1.)? lf(uv): (uv11.y > 1.)? tex(iChannel3, fract(uv11)): tex(iChannel1, uv11);\n        \n        fragColor = mix( mix(c00, c10, fms2.x), mix(c01, c11, fms2.x), fms2.y);\n    } else if (frame == 2) {\n        uv00 -= vec2(0., 1.);\n        uv01 -= vec2(0., 1.);\n        uv10 -= vec2(0., 1.);\n        uv11 -= vec2(0., 1.);\n        // this ugly bit exists because we are blending between channels\n        vec4 c00 = (uv00.x > 1.)? (uv00.y > 1.)? lf(uv): tex(iChannel3, fract(uv00)): (uv00.y > 1.)? lf(uv): tex(iChannel2, uv00);\n        vec4 c01 = (uv01.x > 1.)? (uv01.y > 1.)? lf(uv): tex(iChannel3, fract(uv01)): (uv01.y > 1.)? lf(uv): tex(iChannel2, uv01);\n        vec4 c10 = (uv10.x > 1.)? (uv10.y > 1.)? lf(uv): tex(iChannel3, fract(uv10)): (uv10.y > 1.)? lf(uv): tex(iChannel2, uv10);\n        vec4 c11 = (uv11.x > 1.)? (uv11.y > 1.)? lf(uv): tex(iChannel3, fract(uv11)): (uv11.y > 1.)? lf(uv): tex(iChannel2, uv11);\n        \n        fragColor = mix( mix(c00, c10, fms2.x), mix(c01, c11, fms2.x), fms2.y);\n    } else {\n        uv00 -= vec2(1., 1.);\n        uv01 -= vec2(1., 1.);\n        uv10 -= vec2(1., 1.);\n        uv11 -= vec2(1., 1.);\n        // this ugly bit exists because we are blending between channels\n        vec4 c00 = (uv00.x > 1.)? (uv00.y > 1.)? lf(uv): lf(uv): (uv00.y > 1.)? lf(uv): tex(iChannel3, uv00);\n        vec4 c01 = (uv01.x > 1.)? (uv01.y > 1.)? lf(uv): lf(uv): (uv01.y > 1.)? lf(uv): tex(iChannel3, uv01);\n        vec4 c10 = (uv10.x > 1.)? (uv10.y > 1.)? lf(uv): lf(uv): (uv10.y > 1.)? lf(uv): tex(iChannel3, uv10);\n        vec4 c11 = (uv11.x > 1.)? (uv11.y > 1.)? lf(uv): lf(uv): (uv11.y > 1.)? lf(uv): tex(iChannel3, uv11);\n        \n        fragColor = mix( mix(c00, c10, fms2.x), mix(c01, c11, fms2.x), fms2.y);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * SUBFRAMES;\n    vec3 camLoc = vec3(floor(uv) * SUBFRAMES_RCP - vec2(1., 1.), 0.) * SUBFRAMES * MOVE_DIST / iResolution.x;\n    camLoc.z = -3.;\n    vec3 col = renderImage(fract(uv), camLoc, iTime, iResolution.y / iResolution.x);\n    fragColor = vec4(col, 1.);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * SUBFRAMES;\n    vec3 camLoc = vec3(floor(uv) * SUBFRAMES_RCP - vec2(0., 1.), 0.) * SUBFRAMES * MOVE_DIST / iResolution.x;\n    camLoc.z = -3.;\n    vec3 col = renderImage(fract(uv), camLoc, iTime, iResolution.y / iResolution.x);\n    fragColor = vec4(col, 1.);\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * SUBFRAMES;\n    vec3 camLoc = vec3(floor(uv) * SUBFRAMES_RCP - vec2(1., 0.), 0.) * SUBFRAMES * MOVE_DIST / iResolution.x;\n    camLoc.z = -3.;\n    vec3 col = renderImage(fract(uv), camLoc, iTime, iResolution.y / iResolution.x);\n    fragColor = vec4(col, 1.);\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * SUBFRAMES;\n    vec3 camLoc = vec3(floor(uv) * SUBFRAMES_RCP - vec2(0., 0.), 0.) * SUBFRAMES * MOVE_DIST / iResolution.x;\n    camLoc.z = -3.;\n    vec3 col = renderImage(fract(uv), camLoc, iTime, iResolution.y / iResolution.x);\n    fragColor = vec4(col, 1.);\n}\n","name":"Buf D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// rendering\n\n#define SUBFRAMES\t\t4.\n#define SUBFRAMES_RCP\t.25\n#define MOVE_DIST\t\t30.\n// typical image controls\n#define GAMMA\t\t\t.6\n#define EXPOSURE\t\t1.3\n#define SD_SAMPLES\t\t64\n#define MSAA\t\t\t4\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 50.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 r, t, e; float s, u, f, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, segment, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o, m; };\n//Location, Normal, Distance, Object id\nstruct sdf { float d; int o, m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//center Location, Radius, Material, iDentifier\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n//Center, Size, Orientation, Material, iDentifier\nstruct box { vec3 c, s; mat3 o; int m, d; };\n\nconst mat nullMat = mat(v30, v31, v30, 0., 0., 0., 0., -1);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, -1);\nconst sdf nullSdf = sdf(zfar, -1, -1);\nconst vec2 nullT = vec2(zfar, 0.);\n\n///////////////////////////////////////// Function Library ///////////////////////////////////////////\nfloat hash12( in vec2 p );\nvec3 rotateXY(in vec3 p, in vec2 angle);\nvoid basis(in vec3 n, out vec3 f, out vec3 r);\nvec3 norm4(in sampler2D iChannel, in vec4 comp, in vec3 px, in vec2 uv);\nvec3 slerp(in vec3 start, in vec3 end, in float percent);\nfloat smin(float a, float b, float k);\nfloat smax(float a, float b, float k);\nmat2 rotmat(float a);\n// Segment operators\n#define len(a) (a.t.y - a.t.x)\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\nvec2 lt(in seg s);\nvoid lt(inout seg o, in seg s) { if (minT(s.t) < minT(o.t)) o = s; }\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1, d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\nvoid lt(inout sdf l, in sdf r) { if (r.d < l.d && r.d > 0.) l = r; }\n// Signed distance functions (thanks IQ)\nsdf sd(in vec3 l, in box b);\nsdf sd(in vec3 l, in sph s);\nsdf sd(in vec3 l, in pln p);\n// UV map functions\nvec2 map(in vec3 l, in box b);\nvec2 map(in vec3 l, in sph s);\nvec2 map(in vec3 l, in pln p);\n// Normal functions\nvec3 nrm(in vec3 l, in box b);\nvec3 nrm(in vec3 l, in sph s);\nvec3 nrm(in vec3 l, in pln p);\n// Segment functions\nseg rs(in ray r, in box b);\nseg rs(in ray r, in sph s);\nseg rs(in ray r, in pln p);\n// Hit functions\nvoid lt(inout hit o, in hit h) { if (minT(h.s.t) < minT(o.s.t)) o = h; }\n#define _trc seg s = rs(r, o); vec3 l = r.o + r.d * minT(s.t); hit h = hit(l, nrm(l, o), s, o.d, o.m)\nhit trace(in ray r, in box o) { _trc; return h; }\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n// Displaced functions\n\n// Volume functions\n\n// Surface functions\nfloat Schlick(in float r1, in float r2, in float vn);\nfloat Blinn(in  vec3 N, in vec3 E, in vec3 L, in float roughness);\nfloat Lambertian(in vec3 N, in vec3 L);\n\n///////////////////////////////// Function Lib Implementation ////////////////////////////\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(907.4993, 683.64751));\n    return fract(sin(h)*701.5837);\n}\nvec2 hash21( in float p ) {\n    return 2. * fract(sin(p * vec2(12.9898, 78.233)) * 43758.5453) - 1.;   \n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvec3 norm4(in sampler2D iChannel, in vec4 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp),\n          s21 = texComp(iChannel, uv + px.zy, comp),\n\t\t  s10 = texComp(iChannel, uv + px.yx, comp),\n          s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s01 - s21)),\n\t\t vb = normalize(vec3(px.yx*4., s10 - s12));\n\treturn cross(va, vb).xzy;\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a,float b, float k) {\n    return -smin(-a,-b,k);\n}\nmat2 rotmat(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\n\n//////////////////////////////////////////// Signed distance functions ////////////////////////////////////////////\n\n//thanks IQ\nsdf sd(in vec3 l, in box b) {\n\tvec3 d = abs(l - b.c) - b.s;\n\treturn sdf(min(vec3max(d), 0.) + length(max(d, 0.)), b.d, b.m);\n}\nsdf sd(in vec3 l, in sph s) {\n    vec3 oc = l - s.l;\n    return sdf(dot(oc, oc) - s.r * s.r, s.d, s.m);\n}\nsdf sd(in vec3 l, in pln p) {\n    return sdf(dot(p.o[1], l - p.l), p.d, p.m);\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\n\nvec2 map(in vec3 l, in box b) {\n\tmat3 o = mat3(v30, nrm(l, b) + eps, v30);\n    basis(o[1], o[0], o[2]);\n    vec3 r = l * o;\n    return r.xz;\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\nvec3 nrm(in vec3 l, in box b) {\n\tvec3 a = l - b.c;\n\treturn step(b.s*ieps, abs(a)) * sign(a);\n}\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\nseg rs(in ray r, in box b) {\n    vec3 t0 = b.c - r.o,\n         t1 = (t0 - b.s)/r.d,\n         t2 = (t0 + b.s)/r.d;\n    float tn = vec3max(min(t1, t2)),\n          tx = vec3min(max(t1, t2));\n    if (tx<tn || tx<0.) return nullSeg;\n    return seg(vec2(tn, tx), ivec2(b.d, -b.d));\n}\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n\n////////////////////////////////////////// Surface functions //////////////////////////////////////////\nfloat schlick(in float r1, in float r2, in float vn) {\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\nfloat Blinn(in vec3 hn, in vec3 rd, in vec3 lv, in float roughness) {\n    vec3 H = normalize(rd + lv);\n    float dotNH = clamp(dot(hn, H), 0., 1.);\n    return (roughness + 2.) / (8. * pi) * pow(dotNH, roughness);\n}\nfloat Lambertian(in vec3 hn, in vec3 lv) {\n    return clamp(dot(hn, lv), 0., 1.) * pi_rcp;\n}\n\n////////////////////////////////////////// 3D scene //////////////////////////////////////////\n\n#define LIGHT_COUNT 2\n#define LIGHT_COUNT_RCP .5\n\n// IDs\nconst int\n// Materials\n_air = 0, _glas = 1, _wht_e = 2, _rnbw_e = 3, _mgrnd = 4, _mshine = 5, _msemi = 6,\n// Primitivies\n_lit1 = 1, _lit2 = 2, _sph1 = 3, _sph2 = 4, _sph3 = 5, _box1 = 6, _box2 = 7, _box3 = 8, _pln1 = 9;\n\n//////////////////////////////////////// Raytrace Primitives ////////////////////////////////////////\nsph[] lights = sph[] (\n    sph(v30, 0., 0, 0),\n    sph(vec3(-2.,2.,3.), .1, _wht_e, _lit1),\n    sph(vec3(2.,3.,-3.), .5, _rnbw_e, _lit2)\n);\nsph sph1 = sph(vec3( 2., 0., 0.), .5, _msemi, _sph1),\n\tsph2 = sph(vec3( 0., 0., 0.), .5, _mshine, _sph2),\n\tsph3 = sph(vec3(-2., 0., 0.), .5, _glas, _sph3);\nbox box1 = box(vec3( 2.,-.5, 2.), vec3(.5), mat3(0.), _msemi, _box1),\n    box2 = box(vec3( 0.,-.5, 2.), vec3(.5), mat3(0.), _mshine, _box2),\n    box3 = box(vec3(-2.,-.5, 2.), vec3(.5), mat3(0.), _glas, _box3);\npln pln1 = pln(vec3(0., -1., 0.), mat3(1.), _mgrnd, _pln1);\n\n////////////////////////////////////////// SD Scene ////////////////////////////////////////////\n\n//////////////////////////////////////////// Materials /////////////////////////////////////////////\nconst mat[] matLib = mat[] (\n    mat(v30, v31, v30, .01, .01, 1.0003, 0., _air),\n\tmat(vec3(1.,.1,.1), v31, v30, 32., .01, 2.4, 0., _glas),\n\tmat(v31, v30, vec3(255.), 1., 1., -1., 0., _wht_e),\n    mat(v31, v30, vec3(64.), 1., 1., -1., 0., _rnbw_e),\n    mat(vec3(1.,.1,.1), v30, v30, 0., 0., -1., 0., _mgrnd),\n    mat(vec3(.1,1.,.1), vec3(.1,1.,.1), v30, 4., 1., -1., 0., _mshine),\n    mat(vec3(.1,.1,1.), vec3(.1,.1,1.), v30, 2., .5, -1., 0., _msemi)\n);\n\nmat mgrnd(inout ray r, inout hit h) {\n    mat ret = matLib[_mgrnd];\n    vec2 uv = map(h.l, pln1) * vec2(.5, 1.);\n    vec3 t = vec3(.5);\n    float ao = min(min(sd(h.l, box1).d, sd(h.l, box2).d), sd(h.l, box3).d);\n    ret.r = t * (2. - 1.5 * pow(1. - clamp(ao, 0., 1.), 16.));\n    return ret;\n}\n\nvoid updateMaterials(inout ray r, inout hit res) {\n    if (res.m == _mgrnd) r.m = mgrnd(r, res);\n    else if (res.m < 0) r.m = nullMat;\n    else r.m = matLib[res.m];\n}\n    \n//////////////////////////////////////////// Scene //////////////////////////////////////////////\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    lt(ret, trace(r, pln1));\n    lt(ret, trace(r, sph1));\n    lt(ret, trace(r, sph2));\n    lt(ret, trace(r, sph3));\n    lt(ret, trace(r, box1));\n    lt(ret, trace(r, box2));\n    lt(ret, trace(r, box3));\n    lt(ret, trace(r, lights[_lit1]));\n\tlt(ret, trace(r, lights[_lit2]));\n\treturn ret;\n}\n\nhit traceSceneSimple(in ray r) {\n    seg s = nullSeg;\n    lt(s, rs(r, pln1));\n    lt(s, rs(r, sph1));\n    lt(s, rs(r, sph2));\n    lt(s, rs(r, sph3));\n    lt(s, rs(r, box1));\n    lt(s, rs(r, box2));\n    lt(s, rs(r, box3));\n    lt(s, rs(r, lights[_lit1]));\n\tlt(s, rs(r, lights[_lit2]));\n\treturn hit(r.o + r.d*minT(s.t), v30, s, int(lt(s).y), abs(s.d.x));\n}\n\nhit renderScene(in ray r) {\n    hit h = traceScene(r);\n    return h;\n}\n\nhit renderSceneSimple(in ray r) {\n    hit h = traceSceneSimple(r);\n    return h;\n}\n\n///////////////////////////////////////// Shading functions ////////////////////////////////////////\nvec3 Kyles(in ray r, in hit h) {\n\tvec3 col = v30;\n\tfor (int i = _lit1; i <= _lit2; ++i) {\n\t\tsph l = lights[i];\n\t\tvec3 Li = matLib[l.m].e,\n\t\t\t lv = l.l - h.l;\n\t\tfloat ld2 = dot(lv, lv),\n\t\t\t  ld = sqrt(ld2);\n\t\tvec3 nlv = lv / ld;\n\t\thit res = renderSceneSimple(ray(h.l + h.n*sml, nlv, v30, nullMat));\n\t\tfloat blinn = Blinn(h.n, -r.d, nlv, r.m.s * 10.) * r.m.s * .05,\n              lamb = Lambertian(h.n, nlv);\n        float thickness = len(res.s),\n              hitlit = float(res.o == l.d) + pow(clamp(1. - thickness * thickness, 0. ,1.), 1. / res.s.t.x);\n\t\tcol += (blinn + lamb * lamb * 2.) * r.m.r * hitlit * (l.r * l.r * Li) / (1. + ld2);\n\t}\n\tcol += r.m.e;\n    return col;\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n\n//////////////////////////////////////////// Main Image /////////////////////////////////////////////\nvec3 renderImage(in vec2 uv, in vec3 l, in float iTime, in float aspect) {\n    //get rd\n\tvec3 d = normalize(vec3((uv * 2. - 1.) * vec2(1., aspect), 1.));\n    \n    //update objects\n    lights[_lit1].l = sph3.l - vec3(.6*sin(iTime), 0., .6*cos(iTime));\n    lights[_lit2].l = sph1.l - vec3(cos(iTime), -3., 3.*sin(iTime));\n    \n    //begin tracing\n\thit res;\n\n    //final color\n    vec3 final = v30;\n#ifndef MSAA\n    ray r = ray(l, d, v31, matLib[_air]);\n#else\n    //orthonormal basis for MSAA\n    vec3 uu = v30, vv = v30;\n    float px = .003;\n    basis(d, uu, vv);\n    uu *= px; vv *= px;\n#if MSAA == 3\n    vec3[] offsets = vec3[](d + uu*s60, d - uu*s60 + vv, d - uu*s60 - vv);\n#elif MSAA == 4\n    vec3[] offsets = vec3[](d + uu, d - uu, d + vv, d - vv);\n#endif\n    //take a few samples\n    for (int i = 0; i < MSAA; i++) {\n        //start the ray at the camera in starting material\n        ray r = ray(l, normalize(d + offsets[i]), v31, matLib[_air]);\n#endif\n        //do entire scene (raytrace and raymarch)\n        res = renderScene(r);\n        //march volume\n        vec3 col = v30;\n#ifdef EAS\n        //do the volume lighting\n        col += volmarch(r, seg(vec2(0., minT(res.s.t)), ivec2(0)));\n#endif\n        if (res.m > 0) {\n            //update dynamic materials\n            updateMaterials(r, res);\n            final += r.c * Kyles(r, res);\n        }\n        final += col;\n#ifdef MSAA\n    }\n    final /= float(MSAA);\n#endif\n    vec2 eyeUV = uv * 1.3 - .65;\n    float fragDepth = minT(res.s.t),\n          eye = clamp(pow(dot(eyeUV, eyeUV), 6.) * 2., 0., 1.);\n    return clamp(pow(final * (EXPOSURE - eye * .25), vec3(GAMMA + eye)), v30, v31);\n}\n","name":"Common","description":"","type":"common"}]}