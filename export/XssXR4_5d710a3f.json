{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float packA( float depth ) {\n\n\treturn floor(256.0 * depth) / 256.0;\n}\n\nfloat packB( float depth ) {\n\n\treturn floor(256.0 * fract(256.0 * depth)) / 256.0;\n}\n\nfloat packG( float depth ) {\n\n\treturn floor(256.0 * fract(256.0 * 256.0 * depth)) / 256.0;\n}\n\nfloat packR( float depth ) {\n\n\tfloat tmp = 256.0 * 256.0 * 256.0 * depth;\n\treturn tmp - floor(tmp);\n\t//return floor(256.0 * tmp) / 256.0;\n}\n\nvec4 packFloatOld( float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = fract( depth * bit_shift );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\nvec4 packFloat( float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 255 ) ) / vec4( 255 );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\nfloat unpackFloat( vec4 depth ) {\n\n\tvec4 bitSh = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(depth, bitSh);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scale = 1.0 / pow(2.0, iTime);\n\tfloat offset = 0.5 - 0.5 * scale;\n    vec2 p = offset + scale * fragCoord.xy / iResolution.xy;\n\n\tvec4 packedFloatOld = packFloatOld(p.x);\n\tvec4 packedFloat = packFloat(p.x);\n\t//float packedR = packR(p.x);\n\t//float packedG = packG(p.x);\n\t//float packedB = packB(p.x);\n\t//float packedA = packA(p.x);\n\t//float error = 1000000.0*abs(unpackFloat(vec4(0.0, packedG, packedB, packedA)) - p.x);\n\t//float error = clamp(100000.0*abs(unpackFloat(packedFloat) - p.x),0.0,1.0);\n    vec4 error = abs(packedFloatOld - packedFloat);\n\tfragColor = vec4(vec3(error.x), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssXR4","date":"1397550691","viewed":296,"name":"float to RGBA precision","username":"dams32","description":"float to RGBA8 is used in threejs to store depth in an RGBA texture.\nArtefacts are due to the error introduced during the packing :  floor and fract seem to work incorrectly with big values. See packR for different values of offset.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["floatrgbaprecisiondepth"],"hasliked":0,"parentid":"","parentname":""}}