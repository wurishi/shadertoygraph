{"ver":"0.1","info":{"id":"lst3DB","date":"1452073805","viewed":868,"name":"Gimmick! Shoreline (multi-pass)","username":"Hamneggs","description":"A multipass redux of my and mikejmoffitt's very ill-fated Siggraph 2015 entry. What was wrong with it? All the sprite branching took oodles of resources when compiled as a single shader. Now with meh music!\nOriginal: https://www.shadertoy.com/view/4llSRf","likes":16,"published":1,"flags":112,"usePreview":0,"tags":["nes","famicom","gimmick","mr","20a3","sunsoft","5b","kageyama"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// A recreation of the extra little shoreline scene from stage 2 of \n// Gimmick! (Or in PAL regions, Mr. Gimmick).\n//     \n// Original game by Sunsoft: https://en.wikipedia.org/wiki/Gimmick!\n// \n// Original graphics design: Hiroyuki Kagoya\n// Shader graphics: Gerard Geer (https://github.com/gerard-geer)\n// Original music composition: Masashi Kageyama\n// Shader sound and ShaderTracker sound engine: Michael Moffitt (https://github.com/mikejmoffitt)\n// The original shader on github: https://github.com/gerard-geer/GimmickShader/\n\n#define CLOUD_BUFFER iChannel0\n#define BIRDS_BUFFER iChannel1\n#define SHORE_BUFFER iChannel2\n#define WAVES_BUFFER iChannel3\n\n// The background color.\nconst vec4 D_BLUE  = vec4(.235, .737, .988, 1.00);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Standard coordinates.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Get a buffer's value, and alpha-mask it with what's already here,\n    // for each buffer.\n    vec4 bufferContrib = texture(CLOUD_BUFFER,uv);\n    fragColor = mix(D_BLUE, bufferContrib, bufferContrib.a);\n    bufferContrib = texture(BIRDS_BUFFER,uv);\n    fragColor = mix(fragColor, bufferContrib, bufferContrib.a);\n    bufferContrib = texture(SHORE_BUFFER,uv);\n    fragColor = mix(fragColor, bufferContrib, bufferContrib.a);\n    bufferContrib = texture(WAVES_BUFFER,uv);\n    fragColor = mix(fragColor, bufferContrib, bufferContrib.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdsGWr","filepath":"https://soundcloud.com/user-891621526/gimmick-good-weather","previewfilepath":"https://soundcloud.com/user-891621526/gimmick-good-weather","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A. This buffer's shader just draws the clouds, near and far.\n\n// A 2,4.,8,1.6, or 32 element array implemented as a binary search.\nfloat ARR2(in float x, in float a, in float b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nvec4 ARR2(in float x, in vec4 a, in vec4 b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nfloat ARR4(in float x, in float a, in float b, in float c, in float d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nvec4 ARR4(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nfloat ARR8(in float x, in float a, in float b, in float c, in float d,\n\t\t\t       in float e, in float f, in float g, in float h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nvec4 ARR8(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t    in vec4 e, in vec4 f, in vec4 g, in vec4 h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nfloat ARR16(in float x, in float a, in float b, in float c, in float d,\n\t\t\t        in float e, in float f, in float g, in float h,\n         \t\t\tin float i, in float j, in float k, in float l,\n         \t\t\tin float m, in float n, in float o, in float p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nvec4 ARR16(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t     in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n         \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l,\n         \t\t\t in vec4 m, in vec4 n, in vec4 o, in vec4 p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nfloat ARR32(in float _x, in float a, in float b, in float c, in float d, in float e, in float f, in float g,  in float h,\n          \t\t\t in float i, in float j, in float k, in float l, in float m, in float n, in float o,  in float p,\n          \t\t\t in float q, in float r, in float s, in float t, in float u, in float v, in float w,  in float x,\n          \t\t\t in float y, in float z, in float aa,in float ab,in float ac,in float ad,in float ae, in float af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\nvec4 ARR32(in float _x, in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n          \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l, in vec4 m, in vec4 n, in vec4 o, in vec4 p,\n          \t\t\t in vec4 q, in vec4 r, in vec4 s, in vec4 t, in vec4 u, in vec4 v, in vec4 w, in vec4 x,\n          \t\t\t in vec4 y, in vec4 z, in vec4 aa,in vec4 ab,in vec4 ac,in vec4 ad,in vec4 ae,in vec4 af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\n// Constant color vectors so palette functions don't continually have to initialize new stuff.\nconst vec4 L_BLUE  = vec4(.659, .894, .988, 1.00);\nconst vec4 WHITE   = vec4(.988, .988, .988, 1.00);\nconst vec4 TRANS   = vec4(.000, .000, .000, .000);\n\n// The position of the far clouds.\nconst float FAR_CLOUD_Y = 128.;\n\n// The big cloud takes a lot of orchestration. These are the coordinates\n// of the individual tiles.\n// The cloud tiles represent only the detailed upper portions of it.\n// Anything below them is drawn in as white.\nconst float CLOUD_A_X = 97.;\nconst float CLOUD_A_Y = 160.;\nconst float CLOUD_B_X = 105.;\nconst float CLOUD_B_Y = 152.;\nconst float CLOUD_C_X = 113.;\nconst float CLOUD_C_Y = 153.;\nconst float CLOUD_D_X = 129.;\nconst float CLOUD_D_Y = 144.;\nconst float CLOUD_E_X = 137.;\nconst float CLOUD_E_Y = 136.;\nconst float CLOUD_F_X = 145.;\nconst float CLOUD_F_Y = 128.;\nconst float CLOUD_G_X = 161.;\nconst float CLOUD_G_Y = 128.;\nconst float CLOUD_H_X = 169.;\nconst float CLOUD_H_Y = 128.;\nconst float CLOUD_I_X = 177.;\nconst float CLOUD_I_Y = 136.;\nconst float CLOUD_J_X = 185.;\nconst float CLOUD_J_Y = 144.;\nconst float CLOUD_K_X = 193.;\nconst float CLOUD_K_Y = 153.;\nconst float CLOUD_L_X = 201.;\nconst float CLOUD_L_Y = 153.;\nconst float CLOUD_M_X = 217.;\nconst float CLOUD_M_Y = 154.;\nconst float CLOUD_N_X = 225.;\nconst float CLOUD_N_Y = 152.;\nconst float CLOUD_BOT = 168.;\n\n// The positioning of the smaller cloud.\nconst float S_CLOUD_A_X = 184.;\nconst float S_CLOUD_A_Y = 115.;\nconst float S_CLOUD_B_X = 192.;\nconst float S_CLOUD_B_Y = 112.;\nconst float S_CLOUD_C_X = 216.;\nconst float S_CLOUD_C_Y = 115.;\n\n/*\n*\tThe palette of those distant clouds.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 farCloudsPalette(in float x)\n{\n    return ARR2(x, TRANS,\n                   L_BLUE);\n}\n\n/*\n*\tThe tile function of those clouds in the distance.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat farClouds(in float x, in float y)\n{\n    // The clouds repeat along the X axis across the entire screen.\n    x = mod(float(x),32.);\n    if(y < 4.0)\n    {\n        return ARR4(y, \n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.),\n        ARR32(x,0.,0.,0.,1.,1.,0.,0.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.),\n        ARR32(x,1.,1.,1.,1.,0.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.));\n    }\n    else return ARR32(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.);\n}\n\n/*\n*\tThe distant cloud draw function.\n*   \n*\tDraws the dark, distant clouds to the screen.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of the far clouds at the given position.\n*/\nvec4 drawFarClouds(in float x, in float y)\n{\n    // Above? Nada.\n    if(y < FAR_CLOUD_Y) return TRANS;\n    // Below? Fill'er'in.\n    else if(y > FAR_CLOUD_Y+5.0) return L_BLUE;\n    // Within the narrow band designated for the clouds?\n    else return farCloudsPalette(farClouds(x,y-FAR_CLOUD_Y));\n}\n\n/*\n*\tThe palette of the white clouds.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 nearCloudsPalette(in float x)\n{\n\treturn ARR2(x, TRANS, WHITE);\n}\n\n/*\n*\tCloud tile functions.\n*\t\n*\tWhat follows are the tile functions for the large white cloud.\n*\tOnly the topmost sections with actual features are encoded.\n*\tThe solid white interior is assumed.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat cloudA(in float x, in float y)\n{\n    // Do some bounds checking.\n    // To the left or right? TRANSPARENT FOR YOU!\n\tif(x < CLOUD_A_X || x >= CLOUD_B_X) return 0.;\n    // Above this cloud tile? TRANSPARENT YOU AS WELL!\n\telse if(y < CLOUD_A_Y) return 0.;\n    // Below the tile? OH YOU ARE MORE CLOUD HAVE CLOUD COLOR.\n\telse if(y > CLOUD_A_Y+7.) return 1.;\n\t\n    else\n    {\n        // Transform the coordinates to cloud space.\n        x -= CLOUD_A_X;\n        y -= CLOUD_A_Y;\n\n        // Finally do the 2D binary lookup to get the actual color.\n        return\n        ARR8(y,\n          0.,\n          ARR8(x,0.,0.,0.,0.,0.,0.,1.,1.),\n          ARR8(x,0.,0.,0.,0.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,0.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile B.\nfloat cloudB(in float x, in float y)\n{\n\tif(x < CLOUD_B_X || x >= CLOUD_C_X) return 0.;\n\telse if(y < CLOUD_B_Y) return 0.;\n\telse if(y > CLOUD_B_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_B_X;\n        y -= CLOUD_B_Y;\n\n        return\n        ARR8(y,\n          0.,\n          0.,\n          ARR8(x,0.,0.,0.,0.,0.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,0.,1.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,1.,1.),\n          ARR8(x,1.,1.,1.,0.,0.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,0.,1.,1.,1.,1.),\n          ARR8(x,1.,0.,0.,0.,1.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile C.\nfloat cloudC(in float x, in float y)\n{\n\tif(x < CLOUD_C_X || x >= CLOUD_D_X) return 0.;\n\telse if(y < CLOUD_C_Y) return 0.;\n\telse if(y > CLOUD_C_Y+1.) return 1.;\n\telse\n    {\n        x -= CLOUD_C_X;\n        y -= CLOUD_C_Y;\n\n        return\n        ARR2(y,\n          ARR16(x,0.,0.,1.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.),\n          ARR16(x,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,0.,0.,1.,1.,0.)\n        );\n    }\n}\n// Cloud tile D.\nfloat cloudD(in float x, in float y)\n{\n\tif(x < CLOUD_D_X || x >= CLOUD_E_X) return 0.;\n\telse if(y < CLOUD_D_Y) return 0.;\n\telse if(y > CLOUD_D_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_D_X;\n        y -= CLOUD_D_Y;\n\n        return\n        ARR8(y,\n          0.,\n          ARR8(x,0.,0.,0.,0.,0.,0.,1.,1.),\n          ARR8(x,0.,0.,0.,0.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,0.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,0.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile E.\nfloat cloudE(in float x, in float y)\n{\n\tif(x < CLOUD_E_X || x >= CLOUD_F_X) return 0.;\n\telse if(y < CLOUD_E_Y) return 0.;\n\telse if(y > CLOUD_E_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_E_X;\n        y -= CLOUD_E_Y;\n\n        return\n        ARR8(y,\n          0.,\n          0.,\n          ARR8(x,0.,0.,0.,0.,0.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,0.,1.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,1.,1.),\n          ARR8(x,1.,1.,1.,0.,0.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,0.,1.,1.,1.,1.),\n          ARR8(x,1.,0.,0.,0.,1.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile F.\nfloat cloudF(in float x, in float y)\n{\n\tif(x < CLOUD_F_X || x >= CLOUD_G_X) return 0.;\n\telse if(y < CLOUD_F_Y) return 0.;\n\telse if(y > CLOUD_F_Y+15.) return 1.;\n\telse\n    {\n        x -= CLOUD_F_X;\n        y -= CLOUD_F_Y;\n\n        return\n        ARR16(y,\n          ARR16(x,0.,0.,0.,0.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n          ARR16(x,0.,0.,0.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n          ARR16(x,1.,1.,0.,1.,1.,0.,1.,1.,1.,1.,0.,1.,1.,0.,1.,0.),\n          ARR16(x,0.,0.,0.,0.,0.,0.,0.,1.,0.,1.,0.,0.,0.,0.,0.,0.),\n          0.,\n          ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,0.,0.,0.,0.),\n          ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,0.,0.,0.,0.),\n          0.,\n          ARR16(x,0.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.,1.,1.),\n          ARR16(x,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.),\n          ARR16(x,0.,0.,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.),\n          ARR16(x,1.,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.),\n          ARR16(x,1.,1.,1.,1.,1.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.),\n          ARR16(x,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.),\n          1.,\n          ARR16(x,1.,1.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile G.\nfloat cloudG(in float x, in float y)\n{\n\tif(x < CLOUD_G_X || x >= CLOUD_H_X) return 0.;\n\telse if(y < CLOUD_G_Y) return 0.;\n\telse if(y > CLOUD_G_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_G_X;\n        y -= CLOUD_G_Y;\n\n        return\n        ARR8(y,\n          ARR8(x,0.,0.,0.,0.,0.,0.,1.,1.),\n          ARR8(x,0.,0.,0.,0.,1.,1.,1.,1.),\n          ARR8(x,1.,1.,0.,1.,1.,1.,1.,1.),\n          ARR8(x,1.,0.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.),\n          ARR8(x,0.,1.,1.,1.,1.,1.,1.,1.),\n          1.,\n          1.\n        );\n    }\n}\n// Cloud tile H.\nfloat cloudH(in float x, in float y)\n{\n\tif(x < CLOUD_H_X || x >= CLOUD_I_X) return 0.;\n\telse if(y < CLOUD_H_Y) return 0.;\n\telse if(y > CLOUD_H_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_H_X;\n        y -= CLOUD_H_Y;\n\n        return\n        ARR8(y,\n          ARR8(x,1.,1.,1.,0.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,1.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,1.,1.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,1.,1.,0.),\n          1.,\n          ARR8(x,1.,1.,1.,1.,1.,0.,1.,0.),\n          1.\n        );\n    }\n}\n// Cloud tile I.\nfloat cloudI(in float x, in float y)\n{\n\tif(x < CLOUD_I_X || x >= CLOUD_J_X) return 0.;\n\telse if(y < CLOUD_I_Y) return 0.;\n\telse if(y > CLOUD_I_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_I_X;\n        y -= CLOUD_I_Y;\n\n        return\n        ARR8(y,\n          ARR8(x,1.,1.,0.,0.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,0.,0.,1.,1.,0.),\n          ARR8(x,1.,1.,1.,0.,0.,0.,1.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,0.,1.,0.,0.,0.),\n          1.\n        );\n    }\n}\n// Cloud tile J.\nfloat cloudJ(in float x, in float y)\n{\n\tif(x < CLOUD_J_X || x >= CLOUD_K_X) return 0.;\n\telse if(y < CLOUD_J_Y) return 0.;\n\telse if(y > CLOUD_J_Y+7.) return 1.;\n\telse\n    {\n        x -= CLOUD_J_X;\n        y -= CLOUD_J_Y;\n\n        return\n        ARR8(y,\n          ARR8(x,1.,1.,0.,0.,1.,1.,0.,0.),\n          ARR8(x,1.,1.,1.,0.,1.,1.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,1.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,1.,1.,0.,0.,0.)\n        );\n    }\n}\n// Cloud tile K.\nfloat cloudK(in float x, in float y)\n{\n\tif(x < CLOUD_K_X || x >= CLOUD_L_X) return 0.;\n\telse if(y < CLOUD_K_Y) return 0.;\n\telse if(y > CLOUD_K_Y+1.) return 1.;\n\telse\n    {\n        x -= CLOUD_K_X;\n        y -= CLOUD_K_Y;\n\n        return\n        ARR2(y,\n          ARR8(x,0.,0.,1.,0.,0.,0.,1.,1.),\n          ARR8(x,1.,1.,1.,1.,0.,1.,1.,1.)\n        );\n    }\n}\n// Cloud tile L. This one is repeated twice along X.\nfloat cloudL(in float x, in float y)\n{\n\tif(x < CLOUD_L_X || x >= CLOUD_M_X) return 0.;\n\telse if(y < CLOUD_L_Y) return 0.;\n\telse if(y > CLOUD_L_Y+1.) return 1.;\n\telse\n    {\n        x -= CLOUD_L_X;\n        y -= CLOUD_L_Y;\n\n        x = mod(float(x),8.0);\n\n        return\n        ARR2(y,\n          ARR8(x,1.,1.,0.,0.,0.,0.,0.,0.),\n          ARR8(x,1.,1.,1.,0.,0.,1.,1.,0.)\n        );\n    }\n}\n// CLoud tile M.\nfloat cloudM(in float x, in float y)\n{\n\tif(x < CLOUD_M_X || x >= CLOUD_N_X) return 0.;\n\telse if(y < CLOUD_M_Y) return 0.;\n\telse if(y > CLOUD_M_Y+3.) return 1.;\n\telse\n    {\n        x -= CLOUD_M_X;\n        y -= CLOUD_M_Y;\n\n        return\n        ARR4(y,\n          ARR8(x,0.,0.,0.,1.,1.,0.,0.,0.),\n          ARR8(x,0.,1.,0.,1.,1.,0.,0.,0.),\n          ARR8(x,0.,0.,0.,0.,0.,0.,0.,1.),\n          ARR8(x,1.,1.,1.,1.,0.,0.,1.,1.)\n        );\n    }\n}\n// Cloud tile N. This is repeated to coda.\nfloat cloudN(in float x, in float y)\n{\n\tif(x < CLOUD_N_X) return 0.;\n\telse if(y < CLOUD_N_Y) return 0.;\n\telse if(y > CLOUD_N_Y+1.) return 1.;\n\telse\n    {\n        x -= CLOUD_N_X;\n        y -= CLOUD_N_Y;\n\n        x = mod(float(x),32.);\n\n        return\n        ARR2(y,\n          ARR32(x,0.,0.,1.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.),\n          ARR32(x,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,0.,0.,1.,1.,0.,1.,1.,1.,1.,0.,1.,1.,1.,1.,1.,1.,0.,0.,1.,1.,0.)\n        );\n    }\n}\n\n/*\n*\tThe large cloud draw function.\n*\n*\tComposites all the large cloud tiles together and\n*\tdraws them to the screen.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of the cloud from under the current fragment.\n*/\nvec4 drawNearClouds(in float x, in float y)\n{\n    if(y > CLOUD_BOT) return TRANS;\n    else if(y < FAR_CLOUD_Y) return TRANS;\n    else if(x < CLOUD_A_X) return TRANS;\n    else\n    {\n        // The usual broken-apart additive blending.\n        vec4 result = nearCloudsPalette(cloudA(x,y));\n        result += nearCloudsPalette(cloudB(x,y));\n        result += nearCloudsPalette(cloudC(x,y));\n        result += nearCloudsPalette(cloudD(x,y));\n        result += nearCloudsPalette(cloudE(x,y));\n        result += nearCloudsPalette(cloudF(x,y));\n        result += nearCloudsPalette(cloudG(x,y));\n        result += nearCloudsPalette(cloudH(x,y));\n        result += nearCloudsPalette(cloudI(x,y));\n        result += nearCloudsPalette(cloudJ(x,y));\n        result += nearCloudsPalette(cloudK(x,y));\n        result += nearCloudsPalette(cloudL(x,y));\n        result += nearCloudsPalette(cloudM(x,y));\n        result += nearCloudsPalette(cloudN(x,y));\n\t\treturn result;\n    }\n}\n\n/*\n*\tThe palette of the smaller clouds floating above.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 smallCloudPalette(in float x)\n{\n\treturn ARR4(x, TRANS, WHITE, L_BLUE, TRANS);\n}\n\n/*\n*\tThe tile function of the smaller part of the small clouds.\n*   \n*\tReturns a palette index given a position.\n*\tSince this tile is repeated within the cloud, we have to\n*\tbe able to specify where to draw it.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\tatx: The x position at which to draw the cloud.\n*\taty: The y position at which to draw the cloud.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat smallCloudA(in float x, in float y, in float atx, in float aty)\n{\n\tif(x < atx || x > atx+7.) return 0.;\n\telse if(y < aty || y > aty+3.) return 0.;\n\telse\n    {\n        x -= atx;\n        y -= aty;\n\n        return\n        ARR4(y,\n          ARR8(x,0.,0.,0.,0.,2.,2.,0.,0.),\n          ARR8(x,0.,0.,2.,1.,1.,0.,2.,0.),\n          ARR8(x,1.,0.,0.,1.,2.,0.,0.,0.),\n          ARR8(x,2.,0.,0.,2.,0.,0.,0.,0.)\n        );\n    }\n}\n\n/*\n*\tThe tile representing the large part of the small cloud.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat smallCloudB(in float x, in float y)\n{\n\tif(x < S_CLOUD_B_X || x > S_CLOUD_B_X+15.0) return 0.;\n\telse if(y < S_CLOUD_B_Y || y > S_CLOUD_B_Y+7.) return 0.;\n\telse\n    {\n        x -= S_CLOUD_B_X;\n        y -= S_CLOUD_B_Y;\n\n        return\n        ARR8(y,\n          ARR16(x,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n          ARR16(x,1.,2.,0.,0.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n          ARR16(x,0.,0.,0.,1.,1.,1.,1.,2.,0.,1.,1.,0.,0.,0.,0.,0.),\n          ARR16(x,0.,0.,2.,1.,1.,1.,1.,2.,1.,1.,1.,2.,0.,1.,0.,0.),\n          ARR16(x,0.,0.,2.,1.,1.,1.,2.,2.,2.,0.,2.,1.,0.,0.,0.,1.),\n          ARR16(x,2.,1.,0.,2.,2.,2.,0.,2.,0.,0.,0.,0.,0.,0.,0.,0.),\n          0.,\n          0.\n        );\n    }\n}\n\n/*\n*\tThe small cloud's draw function.\n*\n*\tDraws the smaller cloud to the screen.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of the cloud from under the current fragment.\n*/\nvec4 drawSmallCloud(in float x, in float y)\n{\n    // smallCloudA actually appears twice.\n\tvec4 result = smallCloudPalette(smallCloudA(x,y,S_CLOUD_A_X,S_CLOUD_A_Y));\n\tresult += smallCloudPalette(smallCloudB(x,y));\n\tresult += smallCloudPalette(smallCloudA(x,y,S_CLOUD_C_X,S_CLOUD_C_Y));\n\treturn result;\n}\n\n/*\n*\tThe global draw function.\n*\n*\tCalculates the contribution of this buffer's scene elements to \n*\tthe current fragment.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of this buffer's scene under the current fragment.\n*/\nvec4 drawElements(in float x, in float y)\n{\n    // Reuse some variables.\n    vec4 result = drawFarClouds(x,y);\n    vec4 element = drawNearClouds(x,y);\n    \n    result = mix(result, element, element.a);\n    element = drawSmallCloud(x,y);\n    result = mix(result, element, element.a);\n    return result;\n}\n\n/*\n*\tThe main draw function.\n*\n*\tComputes the color of the current fragment.\n*\n*\tfragColor: The computed fragment color.\n*\tfragCoord: The coordinate of this fragment.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates.\n    fragCoord = (fragCoord.xy / iResolution.xy);\n    \n    // Invert the Y axis.\n    fragCoord.y = 1.0-fragCoord.y;\n    \n    // Account for aspect ratio.\n    fragCoord.x *= iResolution.x/iResolution.y;\n    \n    // Let's get NES sized pixels. This is the Y-resolution of Gimmick's screen sans-HUD.\n    // We also have to account for the fact that the NES didn't have square pixels.\n    fragCoord *= vec2(184.0*0.85736,184.0);\n    \n    // Determine and store the texel of the scene elements this pixel occupies.\n    vec4 imageElements = drawElements(floor(fragCoord.x), floor(fragCoord.y));\n    \n\t// Mix this texel with the background.\n\tfragColor = mix(TRANS, imageElements, imageElements.a);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B. This bad boy draws the birds. All of them. Easily.\n// Oh and the boat.\n\n// A 2,4.,8,1.6, or 32 element array implemented as a binary search.\nfloat ARR2(in float x, in float a, in float b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nvec4 ARR2(in float x, in vec4 a, in vec4 b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nfloat ARR4(in float x, in float a, in float b, in float c, in float d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nvec4 ARR4(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nfloat ARR8(in float x, in float a, in float b, in float c, in float d,\n\t\t\t       in float e, in float f, in float g, in float h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nvec4 ARR8(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t    in vec4 e, in vec4 f, in vec4 g, in vec4 h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\n// Constant color vectors so palette functions don't continually have to initialize new stuff.\nconst vec4 WHITE   = vec4(.988, .988, .988, 1.00);\nconst vec4 BLACK   = vec4(.000, .000, .000, 1.00);\nconst vec4 GRAY    = vec4(.455, .455, .455, 1.00);\nconst vec4 BROWN   = vec4(.486, .031, .000, 1.00);\nconst vec4 TRANS   = vec4(.000, .000, .000, .000);\n\n// Define out stuff so we don't have to pass the values as parameters.\nconst float BIRD_A_Y    = 20.;\nconst float BIRD_B_Y    = 32.;\nconst float BIRD_C_Y    = 45.;\nconst float BIRD_D_Y    = 53.;\nconst float BIRD_E_Y    = 62.;\nconst float BIRD_F_Y    = 69.;\nconst float BIRD_G_Y    = 72.;\nconst float BIRD_FLIP_FREQUENCY = .23438;\n\n/*\n*\tThe birds' palette.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 birdPalette(in float c)\n{\n    return ARR4(c,  WHITE,  // The slightly not white white.\n                \tGRAY,  \t// Gray\n                \tBLACK,  // Black\n                    TRANS); // Transparency.\n}\n\n/*\n*\tA bird's wing-level tile frame.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat birdWingsLevel(in float x, in float y)\n{\n    if(y<4.){\n\t\treturn ARR4(y,\t 3.,\n\t\t\t\t\t\t ARR8(x,3.,0.,0.,0.,1.,0.,0.,3.),\n\t\t\t\t\t\t ARR8(x,2.,3.,3.,0.,0.,3.,3.,2.),\n\t\t\t\t\t\t ARR8(x,3.,3.,3.,1.,0.,3.,3.,3.));\n    }\n    else return 3.;\n}\n\n/*\n*\tThe frame of the bird with its wings up.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat birdWingsUp(in float x, in float y)\n{\n    if(y<4.){\n\t\treturn ARR4(y,\t ARR8(x,3.,2.,0.,3.,3.,3.,2.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,0.,0.,3.,0.,3.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,1.,0.,1.,0.,3.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,3.,0.,0.,3.,3.,3.));\n    }\n    else return\t\t ARR8(x,3.,3.,3.,1.,0.,3.,3.,3.);\n}\n\n/*\n*\tThe frame of the bird with its wings down.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat birdWingsDown(in float x, in float y)\n{\n    if(y<4.){\n\t\treturn ARR4(y,\t ARR8(x,3.,3.,3.,0.,1.,3.,3.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,3.,0.,0.,0.,3.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,0.,1.,0.,1.,3.,3.),\n\t\t\t\t\t\t ARR8(x,3.,3.,0.,3.,3.,3.,0.,3.));\n    }\n    else return\t\t ARR8(x,3.,3.,2.,3.,3.,3.,2.,3.);\n}\n\n/*\n*\tThe bird draw function.\n*   \n*\tDraws a single bird to the screen.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\tatx: The x position at which to draw the bird.\n*\taty: The y position at which to draw the bird.\n*\tflip: Whether or not to flip the bird. (along the x axis.)\n*\n*\tReturns: The color of the bird from under the current texel.\n*/\nvec4 drawBird(in float x, in float y, in float atx, in float aty, bool flip)\n{\n    // Bounds checking.\n    if(x < atx || x > atx + 7.) return TRANS;\n    if(y < aty || y > aty + 4.) return TRANS;\n    \n    // Transform coordinates to bird space.\n    x -= atx;\n    y -= aty;\n    \n    // Flip the bird if necessary.\n    if(flip) x = 7.-x;\n    \n    // This animation is less framecounting and more dividing an amount\n    // of time by four.\n    float t = mod(iTime, .533);\n    if(t < .133)\treturn birdPalette(birdWingsLevel(x,y));\n    else if(t < .266)\treturn birdPalette(birdWingsUp(x,y));\n    else if(t < .400)\treturn birdPalette(birdWingsLevel(x,y));\n    else return birdPalette(birdWingsDown(x,y));\n}\n\n\n\n/*\n*\tThe birds' animation function.\n*   \n*\tReturns a modulated value by adding a triangle wave to the\n*\tstarting value s.\n*\t\t\n*\ts: The starting position.\n*\tt: The current time within the function.\n*\ta: The amplitude of the triangle wave.\n*\td: The boolean first derivative of the triangle function.\n*\n*\tReturns: The modulated position.\n*/\nfloat anim(in float s, in float t, in float a, out bool d)\n{\n    // Triangle wave = |saw wave|\n    \n    // Let's get the derivative first.\n    d = 2.0*(mod((t)*BIRD_FLIP_FREQUENCY, 1.0))-1.0 < 0.0;\n    \n    // Now that we've stored the direction let's go back and \n    // calculate the position.\n    float val = abs( (mod((t)*BIRD_FLIP_FREQUENCY, 1.0)*2.0)-1.0 )*a;\n    \n    // Return the animated position.\n\treturn s + val;\n}\n\n/*\n*\tThe whole flock's draw function.\n*\n*\tDraws all the birds to the screen, animated.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\t\n*\tReturns: The color of the birds from under the current fragment.\n*/\nvec4 drawBirds(in float x, in float y)\n{\n    // Since birds never cross we can use additive blending.\n    // And as we've learned from the sound let's divvy up addition.\n\t\n\t// Getting the positioning and timing accurate to the actual game\n\t// was not fun. Frame-counting and screen-shooting dominated an\n\t// evening of mine. Should have bit the bullet and looked at a\n\t// disassembly.\n\t// Each bird's flight path lasts 128 frames each way. However\n\t// those path start times differ, as well as the length of the path.\n    \n    bool f; // For directional awareness.\n\t\n\t// Bird 1.\n    float a = anim(110., iTime, 32.0, f);\n    vec4 result = drawBird(x,y,a,BIRD_A_Y,f);\n\t\n\t// Bird 2.\n    a = anim(140., iTime+3.267, 24.0, f);\n    result += drawBird(x,y,a,BIRD_B_Y,f);\n\t\n\t// Bird 3.\n    a = anim(77., iTime+1.533, 40.0, f);\n    result += drawBird(x,y,a,BIRD_C_Y,f);\n\t\n\t// Bird 4.\n    a = anim(198., iTime+.1667, 32.0, f);\n    result += drawBird(x,y,a,BIRD_D_Y,f);\n\t\n\t// Bird 5.\n    a = anim(141., iTime+.5667, 32.0, f);\n    result += drawBird(x,y,a,BIRD_E_Y,f);\n\t\n\t// Bird 6.\n    a = anim(85., iTime+1.067, 24.0, f);\n    result += drawBird(x,y,a,BIRD_F_Y,f);\n    \n\t// Bird 7.\n    a = anim(165., iTime+1.167, 24.0, f);\n    result += drawBird(x,y,a,BIRD_G_Y,f);\n    return result;\n    \n}\n\n/*\n*\tThe boat draw function.\n*\n*\tDraws the boat in the corner. Unlike all the other art,\n*\tthis doesn't use the LUT approach.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of the cloud from under the current fragment.\n*/\nvec4 drawBoat(in float x, in float y)\n{\n\t// Oh look the boat looks just like elementary inequality graphs...\n    x = -x; // save time, negate x.\n    // Most common case is the first checked.\n\tif (y > 2.*x + 71. || y > x + 40.) return TRANS;\n\telse if(y > 2.*x + 24.) return BLACK;\n    else return BROWN;\n\t\n}\n\n/*\n*\tThe global draw function.\n*\n*\tCalculates the contribution of this buffer's scene elements to \n*\tthe current fragment.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of this buffer's scene under the current fragment.\n*/\nvec4 drawElements(in float x, in float y)\n{\n    // Reuse some variables.\n    vec4 result = drawBoat(x,y);\n    vec4 element = drawBirds(x,y);\n    result = mix(result, element, element.a);\n    return result;\n}\n\n/**\n*\tThe main draw function.\n*\n*\tComputes the color of the current fragment.\n*\n*\tfragColor: The computed fragment color.\n*\tfragCoord: The coordinate of this fragment.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoord = (fragCoord.xy / iResolution.xy);\n    \n    fragCoord.y = 1.0-fragCoord.y;\n    \n    fragCoord.x *= iResolution.x/iResolution.y;\n    fragCoord *= vec2(184.0*0.85736,184.0);\n    \n    vec4 imageElements = drawElements(floor(fragCoord.x), floor(fragCoord.y));\n    \n\tfragColor = mix(TRANS, imageElements, imageElements.a);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C draws the shoreline, and Yumetarou!\n\n// A 2,4.,8,1.6, or 32 element array implemented as a binary search.\nfloat ARR2(in float x, in float a, in float b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nvec4 ARR2(in float x, in vec4 a, in vec4 b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nfloat ARR4(in float x, in float a, in float b, in float c, in float d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nvec4 ARR4(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nfloat ARR8(in float x, in float a, in float b, in float c, in float d,\n\t\t\t       in float e, in float f, in float g, in float h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nvec4 ARR8(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t    in vec4 e, in vec4 f, in vec4 g, in vec4 h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nfloat ARR16(in float x, in float a, in float b, in float c, in float d,\n\t\t\t        in float e, in float f, in float g, in float h,\n         \t\t\tin float i, in float j, in float k, in float l,\n         \t\t\tin float m, in float n, in float o, in float p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nvec4 ARR16(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t     in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n         \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l,\n         \t\t\t in vec4 m, in vec4 n, in vec4 o, in vec4 p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nfloat ARR32(in float _x, in float a, in float b, in float c, in float d, in float e, in float f, in float g,  in float h,\n          \t\t\t in float i, in float j, in float k, in float l, in float m, in float n, in float o,  in float p,\n          \t\t\t in float q, in float r, in float s, in float t, in float u, in float v, in float w,  in float x,\n          \t\t\t in float y, in float z, in float aa,in float ab,in float ac,in float ad,in float ae, in float af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\nvec4 ARR32(in float _x, in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n          \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l, in vec4 m, in vec4 n, in vec4 o, in vec4 p,\n          \t\t\t in vec4 q, in vec4 r, in vec4 s, in vec4 t, in vec4 u, in vec4 v, in vec4 w, in vec4 x,\n          \t\t\t in vec4 y, in vec4 z, in vec4 aa,in vec4 ab,in vec4 ac,in vec4 ad,in vec4 ae,in vec4 af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\n// Constant color vectors so palette functions don't continually have to initialize new stuff.\nconst vec4 WHITE   = vec4(.988, .988, .988, 1.00);\nconst vec4 BLACK   = vec4(.000, .000, .000, 1.00);\nconst vec4 GRAY    = vec4(.455, .455, .455, 1.00);\nconst vec4 GRASS   = vec4(.502, .816, .063, 1.00);\nconst vec4 D_GREEN = vec4(.000, .235, .078, 1.00);\nconst vec4 L_GREEN = vec4(.298, .863, .282, 1.00);\nconst vec4 D_GOLD  = vec4(.486, .031, .000, 1.00);\nconst vec4 L_GOLD  = vec4(.988, .596, .219, 1.00);\nconst vec4 TRANS   = vec4(.000, .000, .000, .000);\n\n// Define out stuff so we don't have to pass the values as parameters.\nconst float YUMETAROU_X = 52.;\nconst float YUMETAROU_Y = 117.;\nconst float SHORE_Y     = 136.;\nconst float SHORE_END   = 79.;\n\nconst vec2 KEY_LEFT = vec2(37.0/256.0,0.0);\nconst vec2 KEY_RIGHT = vec2(39.0/256.0,0.0);\n\n// Alright\n\n/*\n*\tYumetarou's palette.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 yumetarouPalette(in float c)\n{\n    if(c < 4.)\n    {\n        return ARR4(c,  WHITE,  \t// The slightly not white white.\n                        L_GREEN,\t// Light green.\n                        D_GREEN,\t// Dark green.\n                        L_GOLD); \t// Light gold.\n    }\n    else\n    {\n        c-=4.;\n        return ARR2(c, \tD_GOLD, \t// Dark gold.\n                \t\tTRANS);  \t// Transparency.\n    }\n}\n\n/*\n*\tYumetarou's eyes-open sprite frame.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat yumetarouEyesOpen(in float x, in float y)\n{\n    if(y<16.)\n    {\n        return ARR16(y,  ARR16(x,5.,5.,5.,5.,4.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,4.,3.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,4.,3.,3.,4.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,2.,2.,2.,2.,2.,2.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,2.,2.,1.,1.,1.,1.,2.,2.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.,5.,5.),\n                         ARR16(x,5.,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.,5.,5.),\n                         ARR16(x,5.,5.,2.,1.,1.,1.,0.,0.,0.,1.,1.,0.,0.,2.,5.,5.),\n                         ARR16(x,5.,2.,1.,1.,1.,0.,0.,2.,2.,2.,0.,0.,2.,2.,5.,5.),\n                         ARR16(x,5.,2.,1.,1.,1.,0.,0.,0.,2.,2.,0.,0.,0.,2.,5.,5.),\n                         ARR16(x,2.,1.,1.,1.,1.,0.,0.,2.,2.,2.,0.,0.,2.,2.,2.,5.),\n                         ARR16(x,2.,1.,1.,1.,1.,1.,0.,0.,0.,1.,1.,0.,0.,1.,2.,5.),\n                         ARR16(x,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.),\n                         ARR16(x,2.,1.,1.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.),\n                         ARR16(x,5.,2.,2.,1.,1.,1.,1.,1.,1.,2.,2.,2.,1.,1.,1.,2.),\n                         ARR16(x,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.));\n    } \n    else if(y==16.) return \t ARR16(x,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.);\n    else if(y==17.) return \t ARR16(x,5.,5.,2.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,2.,5.);\n    else\t\t   return \t ARR16(x,1.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.);\n}\n\n/*\n*\tYumetarou's eyes-closed sprite frame.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat yumetarouEyesClosed(in float x, in float y)\n{\n    if(y<16.){\n        return ARR16(y,  ARR16(x,5.,5.,5.,5.,4.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,4.,3.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,4.,3.,3.,4.,5.,5.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,2.,2.,2.,2.,2.,2.,5.,5.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,5.,2.,2.,1.,1.,1.,1.,2.,2.,5.,5.,5.,5.),\n                         ARR16(x,5.,5.,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.,5.,5.),\n                         ARR16(x,5.,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.,5.,5.),\n\t\t\t\t\t\t ARR16(x,5.,5.,2.,1.,1.,1.,0.,0.,0.,1.,1.,0.,0.,2.,5.,5.),\n\t\t\t\t\t\t ARR16(x,5.,2.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.),\n\t\t\t\t\t\t ARR16(x,5.,2.,1.,1.,1.,0.,2.,2.,2.,2.,0.,2.,2.,2.,5.,5.),\n\t\t\t\t\t\t ARR16(x,2.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,5.),\n\t\t\t\t\t\t ARR16(x,2.,1.,1.,1.,1.,1.,0.,0.,0.,1.,1.,0.,0.,1.,2.,5.),\n                         ARR16(x,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.),\n                         ARR16(x,2.,1.,1.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.),\n                         ARR16(x,5.,2.,2.,1.,1.,1.,1.,1.,1.,2.,2.,2.,1.,1.,1.,2.),\n                         ARR16(x,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.));\n    } \n    else if(y==16.) return \t ARR16(x,5.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,5.);\n    else if(y==17.) return \t ARR16(x,5.,5.,2.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,2.,5.);\n    else\t\t   return \t ARR16(x,1.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.);\n}\n\n/*\n*\tYumetarou's draw function.\n*   \n*\tDraws Yumetarou to the screen.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of Yumetarou from under the current texel.\n*/\nvec4 drawYumetarou(in float x, in float y)\n{\n    // Really basic keyboard controls.\n    float keys = texture(iChannel0, KEY_LEFT).r +\n        \t\t texture(iChannel0, KEY_RIGHT).r;\n    if(x < YUMETAROU_X || x > YUMETAROU_X + 15.0) return TRANS;\n    else if(y < YUMETAROU_Y || y > YUMETAROU_Y + 18.0) return TRANS;\n    else\n    {\n        x -= YUMETAROU_X;\n        y -= YUMETAROU_Y;\n        \n        // If the keys are right, flip Yummi.\n        x = mix(x, 15.0-x, step(1.0, keys));\n\n        // Yummy yummy frame counting.\n        float t = mod(iTime, 3.67);\n        if( t > .066 && (t < .533 || t >.600) )\n            return yumetarouPalette(yumetarouEyesOpen(x,y));\n        else\n            return yumetarouPalette(yumetarouEyesClosed(x,y));\n\t}\n}\n\n/*\n*\tThe rocky shoreline's palette.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 shorePalette(in float x)\n{\n    return ARR4(x, WHITE,\n                   GRASS,\n                   GRAY,\n                   BLACK);\n}\n\n/*\n*\tThe repeated interior portion of the shore.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat shoreInterior(in float x, in float y)\n{\n    // This element repeats in the X direction.\n    x = mod(float(x),32.0);\n    return ARR32(y, \n             3.,\n\t\t\t 0.,\n\t\t\t 1.,\n\t\t\t 1.,\n\t\t\t 1.,\n\t\t\t 1.,\n\t\t\t 1.,\n\t\t\t 1.,\n\t\t\t ARR32(x,1.,1.,1.,1.,1.,1.,2.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.),\n\t\t\t ARR32(x,1.,1.,1.,1.,1.,2.,2.,2.,1.,1.,1.,1.,2.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,2.,2.,1.,1.,1.,1.,1.),\n\t\t\t ARR32(x,1.,1.,1.,1.,1.,2.,2.,3.,2.,1.,2.,3.,3.,2.,2.,1.,1.,1.,1.,1.,1.,1.,2.,2.,3.,3.,3.,2.,1.,1.,1.,1.),\n\t\t\t ARR32(x,1.,1.,1.,1.,2.,2.,3.,3.,3.,3.,3.,3.,3.,3.,2.,1.,1.,1.,1.,1.,1.,2.,2.,3.,2.,2.,2.,2.,2.,1.,1.,1.),\n\t\t\t ARR32(x,1.,1.,1.,1.,2.,2.,3.,3.,2.,0.,0.,0.,0.,2.,2.,1.,1.,1.,1.,1.,2.,2.,2.,0.,0.,0.,0.,0.,2.,2.,1.,1.),\n\t\t\t ARR32(x,1.,1.,2.,2.,2.,2.,3.,0.,0.,0.,0.,0.,0.,0.,2.,2.,1.,1.,1.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,1.),\n\t\t\t ARR32(x,2.,2.,2.,2.,2.,3.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.),\n\t\t\t ARR32(x,2.,2.,2.,2.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.),\n\t\t\t ARR32(x,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.),\n\t\t\t ARR32(x,3.,3.,3.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.),\n\t\t\t ARR32(x,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.),\n\t\t\t ARR32(x,0.,0.,0.,0.,2.,2.,2.,0.,0.,0.,0.,2.,2.,2.,3.,3.,3.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,2.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,2.,2.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,2.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,2.,3.,3.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,2.,3.,2.,2.,2.,2.,2.,2.,2.,2.,3.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.,2.,2.,2.,2.,3.,2.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,2.,2.,2.,3.,3.,3.,2.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,0.,0.,0.,0.,2.,3.,3.,2.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,2.,3.,2.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,0.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,0.,2.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,0.),\n\t\t\t ARR32(x,0.,0.,0.,0.,0.,2.,2.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.),\n\t\t\t ARR32(x,2.,0.,0.,0.,2.,2.,2.,2.,3.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.),\n\t\t\t ARR32(x,2.,2.,2.,2.,2.,2.,2.,3.,3.,2.,2.,0.,0.,0.,0.,0.,2.,3.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.),\n\t\t\t ARR32(x,2.,2.,2.,2.,2.,2.,3.,3.,3.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,2.,2.,3.,3.,2.));\n}\n\n/*\n*\tThe non-repeated exterior portion of the shore.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat shoreExterior(in float x, in float y)\n{\n    return ARR32(y,\n            ARR16(x,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,2.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,1.,2.,2.,1.,1.,1.,1.,2.,2.,2.,3.),\n            ARR16(x,1.,1.,1.,1.,1.,2.,2.,2.,2.,2.,2.,2.,2.,2.,3.,2.),\n            ARR16(x,1.,1.,1.,1.,1.,2.,2.,3.,2.,2.,2.,2.,3.,3.,3.,2.),\n            ARR16(x,1.,1.,1.,1.,2.,2.,3.,3.,3.,3.,2.,2.,2.,3.,3.,2.),\n            ARR16(x,1.,1.,1.,1.,2.,2.,3.,3.,0.,0.,0.,0.,0.,2.,3.,2.),\n            ARR16(x,1.,1.,2.,2.,2.,2.,3.,0.,0.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,2.,2.,2.,2.,2.,3.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,2.,2.,2.,2.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,3.,3.,3.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,2.,2.,2.,0.,0.,0.,0.,0.,2.,2.,3.,2.),\n            ARR16(x,0.,0.,0.,0.,0.,2.,2.,2.,0.,0.,0.,2.,2.,3.,3.,2.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,2.,3.,2.,2.,2.,2.,0.,0.,3.,2.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,2.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,3.,2.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,3.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,0.,2.,2.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,0.,2.,2.,2.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,0.,0.,0.,0.,0.,2.,2.,2.,3.,0.,0.,0.,0.,0.,2.,3.),\n            ARR16(x,2.,0.,0.,0.,2.,2.,2.,2.,3.,0.,0.,0.,0.,2.,3.,3.),\n            ARR16(x,2.,2.,2.,2.,2.,2.,2.,3.,3.,0.,0.,0.,2.,2.,2.,3.),\n            ARR16(x,2.,2.,2.,2.,2.,2.,3.,3.,3.,2.,2.,2.,0.,0.,2.,3.));\n}\n\n/*\n*\tThe shoreline's draw function.\n*\n*\tDraws the two interior segments of the shore, then the endcap.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\t\n*\tReturns: The color of the shore from under the current fragment.\n*/\nvec4 drawShore(in float x, in float y)\n{\n    // Bounds checking.\n    if(x > SHORE_END) return TRANS;\n    else if(y < SHORE_Y || y > SHORE_Y + 31.) return TRANS;\n    else\n    {\n        // Transform to be relative to the shore tiles.\n        y -= SHORE_Y;\n\n        // Draw the interior of the shore.\n        if(x < 64.) return shorePalette(shoreInterior(x,y));\n        // Draw the endcap exterior.\n        else\n        {\n            x -= 64.;\n            return shorePalette(shoreExterior(x,y));\n        }\n    }\n}\n\n/*\n*\tThe global draw function.\n*\n*\tCalculates the contribution of this buffer's scene elements to \n*\tthe current fragment.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of this buffer's scene under the current fragment.\n*/\nvec4 drawElements(in float x, in float y)\n{\n    // Reuse some variables.\n    vec4 result = drawYumetarou(x,y);\n    vec4 element = drawShore(x,y);\n    result = mix(result, element, element.a);\n    return result;\n}\n\n/**\n*\tThe main draw function.\n*\n*\tComputes the color of the current fragment.\n*\n*\tfragColor: The computed fragment color.\n*\tfragCoord: The coordinate of this fragment.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoord = (fragCoord.xy / iResolution.xy);\n    \n    fragCoord.y = 1.0-fragCoord.y;\n    \n    fragCoord.x *= iResolution.x/iResolution.y;\n    fragCoord *= vec2(184.0*0.85736,184.0);\n    \n    vec4 imageElements = drawElements(floor(fragCoord.x), floor(fragCoord.y));\n    \n\tfragColor = mix(TRANS, imageElements, imageElements.a);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D is responsible for the waves alone. It's easily the most\n// intensive part of this whole image. Is it harder than the music? No.\n\n// A 2,4.,8,1.6, or 32 element array implemented as a binary search.\nfloat ARR2(in float x, in float a, in float b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nvec4 ARR2(in float x, in vec4 a, in vec4 b)\n{\n    if(x<1.) return a;\n    else return b;\n}\n\nfloat ARR4(in float x, in float a, in float b, in float c, in float d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nvec4 ARR4(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d)\n{\n    if(x<2.) return ARR2(x,a,b);\n    else return ARR2(x-2.,c,d);\n}\n\nfloat ARR8(in float x, in float a, in float b, in float c, in float d,\n\t\t\t       in float e, in float f, in float g, in float h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nvec4 ARR8(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t    in vec4 e, in vec4 f, in vec4 g, in vec4 h)\n{\n    if(x<4.) return ARR4(x, a,b,c,d);\n    else return ARR4(x-4., e,f,g,h);\n}\n\nfloat ARR16(in float x, in float a, in float b, in float c, in float d,\n\t\t\t        in float e, in float f, in float g, in float h,\n         \t\t\tin float i, in float j, in float k, in float l,\n         \t\t\tin float m, in float n, in float o, in float p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nvec4 ARR16(in float x, in vec4 a, in vec4 b, in vec4 c, in vec4 d,\n\t\t\t   \t     in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n         \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l,\n         \t\t\t in vec4 m, in vec4 n, in vec4 o, in vec4 p)\n{\n    if(x<8.) return ARR8(x, a,b,c,d, e,f,g,h);\n    else return ARR8(x-8., i,j,k,l, m,n,o,p);\n}\n\nfloat ARR32(in float _x, in float a, in float b, in float c, in float d, in float e, in float f, in float g,  in float h,\n          \t\t\t in float i, in float j, in float k, in float l, in float m, in float n, in float o,  in float p,\n          \t\t\t in float q, in float r, in float s, in float t, in float u, in float v, in float w,  in float x,\n          \t\t\t in float y, in float z, in float aa,in float ab,in float ac,in float ad,in float ae, in float af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\nvec4 ARR32(in float _x, in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 e, in vec4 f, in vec4 g, in vec4 h,\n          \t\t\t in vec4 i, in vec4 j, in vec4 k, in vec4 l, in vec4 m, in vec4 n, in vec4 o, in vec4 p,\n          \t\t\t in vec4 q, in vec4 r, in vec4 s, in vec4 t, in vec4 u, in vec4 v, in vec4 w, in vec4 x,\n          \t\t\t in vec4 y, in vec4 z, in vec4 aa,in vec4 ab,in vec4 ac,in vec4 ad,in vec4 ae,in vec4 af)\n{\n    if(_x<16.) return ARR16(_x, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n    else return ARR16(_x-16., q,r,s,t, u,v,w,x, y,z,aa,ab, ac,ad,ae,af); \n}\n\n// Constant color vectors so palette functions don't continually have to initialize new stuff.\nconst vec4 D_BLUE  = vec4(.235, .737, .988, 1.00);\nconst vec4 L_BLUE  = vec4(.659, .894, .988, 1.00);\nconst vec4 WHITE   = vec4(.988, .988, .988, 1.00);\nconst vec4 TRANS   = vec4(.000, .000, .000, .000);\n\n// Define out stuff so we don't have to pass the values as parameters.\nconst float SHORE_END   = 79.;\nconst float WAVES_Y     = 168.;\n\n/*\n*\tThe palette of the waves when under the shoreline.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 wavesShadowPalette(in float x)\n{\n    if(x<4.)\n    {\n        return ARR4(x,  D_BLUE,\n\t\t\t   \t\t\tWHITE,\n\t\t\t   \t\t\tL_BLUE,\n\t\t\t   \t\t\tWHITE);\n    }\n    else return ARR2(x-4., D_BLUE, L_BLUE);\n}\n\n/*\n*\tThe palette of the waves in the sun.\n*   \n*\tReturns a color given a palette index.\n*\n*\tc: The color index to look up.\n*\n*\tReturns: The corresponding color.\n*/\nvec4 wavesSunnyPalette(in float x)\n{\n    if(x<4.)\n    {\n        return ARR4(x, L_BLUE,\n\t\t\t\t\t   L_BLUE,\n\t\t\t\t\t   L_BLUE,\n\t\t\t\t\t   WHITE);\n    }\n    else return ARR2(x-4., WHITE, WHITE);\n}\n\n/*\n*\tOne frame of the waves.\n*\tNote: The palette of the sunny and shadowed waves are\n*\tconsolidated into a single map with a larger palette.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat wavesA(in float x, in float y)\n{\n    if(x < 32.) // ARR64 would be a really long line.\n    {\n        return ARR8(y,\n       \tARR32(x,3.,3.,3.,3.,3.,3.,3.,3.,3.,5.,5.,5.,4.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,3.),\n\t\tARR32(x,3.,3.,3.,2.,2.,0.,0.,0.,0.,2.,5.,5.,5.,5.,5.,5.,3.,3.,3.,3.,3.,5.,5.,2.,2.,2.,0.,0.,0.,0.,0.,0.),\n\t\tARR32(x,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,3.,3.,2.,0.,0.,0.,0.,5.,5.,5.,5.,5.,5.,2.,2.,2.,2.),\n\t\tARR32(x,0.,0.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.,5.,5.,5.,5.),\n\t\tARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.),\n\t\tARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n\t\t2.,\n        2.);\n    }\n    else\n    {\n        x -= 32.;\n        return ARR8(y,\n\t\tARR32(x,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,3.,3.,3.),\n        ARR32(x,0.,0.,0.,0.,2.,5.,5.,5.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,3.,3.),\n        ARR32(x,2.,2.,1.,3.,3.,3.,2.,2.,2.,5.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.,3.,3.,3.,3.,3.,3.,3.,3.,2.,3.,3.,3.),\n        ARR32(x,3.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.,5.,3.,3.,3.,3.,3.,3.,2.,2.,2.,3.,3.,3.,3.,2.,0.),\n        ARR32(x,5.,5.,5.,5.,5.,5.,2.,0.,0.,0.,0.,5.,5.,3.,3.,3.,3.,3.,3.,3.,2.,2.,2.,3.,3.,3.,3.,2.,0.,0.,0.,2.),\n        ARR32(x,0.,0.,0.,0.,0.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,2.,2.,2.,2.,2.,2.,2.,2.,2.),\n        2.,\n        2.);\n    }\n}\n\n/*\n*\tAnother frame of the waves.\n*\tNote: The palette of the sunny and shadowed waves are\n*\tconsolidated into a single map with a larger palette.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat wavesB(in float x, in float y)\n{\n    if(x < 32.) // ARR64 would be a really long line.\n    {\n        return ARR8(y,\n\t\tARR32(x,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,5.,5.,2.,0.,0.,0.,0.,0.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,0.,0.,0.,0.,0.,5.,5.,2.,2.,2.,0.),\n        ARR32(x,0.,0.,0.,2.,2.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,2.),\n        ARR32(x,2.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,2.,2.,3.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.),\n        ARR32(x,3.,3.,3.,3.,3.,3.,2.,2.,2.,2.,3.,3.,3.,2.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.),\n        ARR32(x,3.,3.,3.,2.,2.,2.,3.,3.,3.,3.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.),\n\t\t2.,\n        2.);\n\t}\n    else\n    {\n        x -= 32.;\n        return ARR8(y,\n        ARR32(x,0.,0.,2.,2.,2.,3.,3.,3.,3.,3.,3.,3.,5.,5.,5.,5.,5.,5.,5.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,5.,5.,5.,5.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.),\n        ARR32(x,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,3.,3.,2.,3.,2.,0.,0.,0.,0.),\n        ARR32(x,4.,4.,4.,4.,4.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.),\n        ARR32(x,0.,0.,0.,4.,4.,4.,4.,4.,5.,5.,5.,5.,5.,5.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,3.,3.,3.,3.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.,5.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.),\n        ARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,3.,3.,3.,2.),\n        2.);\n    }\n}\n\n/*\n*\tA third frame of sweet wave action.\n*\tNote: The palette of the sunny and shadowed waves are\n*\tconsolidated into a single map with a larger palette.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat wavesC(in float x, in float y)\n{\n    if(x < 32.) // ARR64 would be a really long line.\n    {\n        return ARR8(y,\n        ARR32(x,3.,3.,3.,3.,0.,0.,0.,0.,0.,0.,0.,3.,3.,3.,0.,0.,0.,0.,0.,0.,2.,3.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.),\n        ARR32(x,2.,0.,0.,0.,5.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,3.,3.,3.,2.,2.,2.,3.,2.,2.,0.,0.,3.,3.,3.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,2.,2.,2.,2.,3.,3.,3.,3.,3.,5.,0.,0.,0.,0.,0.,0.,5.,5.,3.,3.,3.,3.),\n        ARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,5.,5.,5.,5.,5.,5.,0.,0.,0.,0.,0.,5.,5.,5.,3.,3.,3.,1.,3.,4.),\n        ARR32(x,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,4.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,3.,3.,1.,1.,3.,3.,4.,0.),\n        ARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,4.,0.,0.,0.,0.),\n        ARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,2.,2.,2.),\n        2.);\n\n    }\n    else\n    {\n        x -= 32.;\n        return ARR8(y,\n\t\tARR32(x,0.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,4.,5.,5.,5.,3.,3.,3.,3.,3.),\n\t\tARR32(x,3.,3.,3.,3.,5.,2.,2.,2.,0.,0.,0.,0.,0.,0.,4.,4.,4.,4.,4.,4.,5.,5.,5.,5.,5.,3.,3.,3.,3.,3.,3.,3.),\n\t\tARR32(x,3.,4.,4.,4.,4.,5.,5.,5.,5.,5.,5.,5.,4.,4.,4.,4.,5.,5.,5.,5.,5.,5.,5.,1.,1.,1.,3.,3.,3.,2.,0.,0.),\n\t\tARR32(x,4.,4.,0.,0.,0.,0.,0.,0.,0.,0.,2.,5.,5.,5.,5.,5.,3.,1.,2.,2.,2.,1.,3.,3.,3.,3.,4.,0.,0.,0.,2.,2.),\n\t\tARR32(x,0.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,2.,1.,3.,3.,5.,5.,0.,0.,0.,2.,2.,2.,2.,2.,2.),\n\t\tARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.),\n\t\t2.,\n\t\t2.);\n    }\n}\n\n/*\n*\tThe forth frame of waves.\n*\tNote: The palette of the sunny and shadowed waves are\n*\tconsolidated into a single map with a larger palette.\n*   \n*\tReturns a palette index given a position.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The corresponding palette index.\n*/\nfloat wavesD(in float x, in float y)\n{\n    if(x < 32.) // ARR64 would be a really long line.\n    {\n        return ARR8(y,\n\t\tARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,3.,3.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.),\n\t\tARR32(x,2.,2.,2.,2.,2.,3.,3.,3.,3.,1.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,5.,3.,3.,3.,3.),\n\t\tARR32(x,3.,3.,3.,3.,3.,1.,0.,0.,0.,0.,0.,5.,5.,2.,2.,2.,2.,0.,0.,0.,0.,2.,5.,5.,5.,3.,3.,3.,3.,3.,3.,3.),\n\t\tARR32(x,5.,5.,5.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.,5.,5.,5.,5.,5.,5.,5.,3.,3.,3.,3.,3.,3.,3.,3.,5.,0.),\n\t\tARR32(x,0.,4.,4.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,5.,3.,3.,3.,3.,3.,3.,3.,3.,5.,0.,0.,0.,0.,0.),\n\t\tARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,3.,3.,3.,3.,3.,3.,3.,3.,0.,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.),\n\t\tARR32(x,0.,0.,0.,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.),\n\t\t2.);\n    }\n    else\n    {\n        x -= 32.;\n        return ARR8(y,\n\t\tARR32(x,5.,5.,3.,3.,3.,3.,3.,3.,3.,3.,3.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,3.,3.,3.,3.,3.,0.,0.,0.,0.,0.),\n\t\tARR32(x,3.,3.,3.,5.,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,4.,5.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.),\n\t\tARR32(x,5.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,4.,4.,4.,4.,4.,4.,4.,5.,5.,5.,5.,5.,5.),\n\t\tARR32(x,0.,0.,0.,0.,0.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,4.,4.,4.,4.,4.,4.,4.,5.),\n\t\tARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.),\n\t\tARR32(x,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,0.,0.,0.,0.,0.),\n\t\t2.,\n\t\t2.);\n    }\n}\n\n/*\n*\tThe wave draw function.\n*   \n*\tDraws the waves using the appropriate palette given the position.\n*\tThis also animates the waves.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of the waves at the given position.\n*/\nvec4 drawWaves(in float x, in float y)\n{\n    // Bounds checking.\n    if(y < WAVES_Y) return TRANS;\n    else if(y > WAVES_Y+7.) return L_BLUE;\n    else\n    {\n        // Modulo the time and cast it to an int so the value returned\n        // can be used as an index for which frame of animation to use.\n        float t = mod(iTime*6.0,4.0);\n\n        // We need to do the usual transform here as well.\n        y -= WAVES_Y;\n        \n\t\t// If we are under the shoreline, we need to use the palette\n        // that reflects the shore.\n        if(x > SHORE_END)\n        {\n            // The prior comparison required x to be pristine, so\n            // we have to perform this modulo in here.\n            x = mod(float(x),64.);\n            return ARR4(t,\n                        wavesSunnyPalette(wavesC(x,y)),\n                        wavesSunnyPalette(wavesA(x,y)),\n                        wavesSunnyPalette(wavesB(x,y)),\n                        wavesSunnyPalette(wavesD(x,y)));\n        }\n        // otherwise we use the palette that reflects the clouds.\n        else\n        {\n            x = mod(float(x),64.);\n            return ARR4(t,\n                        wavesShadowPalette(wavesC(x,y)),\n                        wavesShadowPalette(wavesA(x,y)),\n                        wavesShadowPalette(wavesB(x,y)),\n                        wavesShadowPalette(wavesD(x,y)));\n        }\n    }\n}\n\n/*\n*\tThe global draw function.\n*\n*\tCalculates the contribution of this buffer's scene elements to \n*\tthe current fragment.\n*\n*\tx: The x position of the current fragment.\n*\ty: The y position of the current fragment.\n*\n*\tReturns: The color of this buffer's scene under the current fragment.\n*/\nvec4 drawElements(in float x, in float y)\n{\n    return drawWaves(x, y);\n}\n\n/**\n*\tThe main draw function.\n*\n*\tComputes the color of the current fragment.\n*\n*\tfragColor: The computed fragment color.\n*\tfragCoord: The coordinate of this fragment.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoord = (fragCoord.xy / iResolution.xy);\n    \n    fragCoord.y = 1.0-fragCoord.y;\n    \n    fragCoord.x *= iResolution.x/iResolution.y;\n    fragCoord *= vec2(184.0*0.85736,184.0);\n    \n    vec4 imageElements = drawElements(floor(fragCoord.x), floor(fragCoord.y));\n    \n\tfragColor = mix(TRANS, imageElements, imageElements.a);\n}","name":"Buf D","description":"","type":"buffer"}]}