{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Light properties\n#define N_col vec3(1., .8, .8)\n#define N_n normalize(vec3(-1., -1., 1.))\n\n// Sphere properties\n#define A_o vec3(0.,0.,5.)\n#define A_r\t3.\n#define A_col vec3(.7, 0.1, 0.1)\n\n#define spec_scale .8\n#define diff_scale .4\n#define glob_scale .2\n\nstruct Sphere\n{\n    vec3 o; //Center of sphere\n    float r; //radius\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 o; // Point on the ray\n    vec3 n; // Direction of the ray\n};\n\nstruct Light\n{\n    vec3 n; // Light direction\n    vec3 color; // Light color\n};\n\n\nvec3 ray_sphere_intersect(Ray r, Sphere A)\n{\n    // Where does r first intersect A?\n    \n    vec3 o_ = r.o - A.o;\n    \n    float b = 2.*dot(o_, r.n);\n    \n    float c = dot(o_, o_) - A.r*A.r;\n    \n    float det = b*b - 4.*c;\n    \n    if (det > 0.)\n    {\n    \tfloat s = (-b - sqrt(det))/2.;\n        return r.o + s*r.n;\n    } else {\n        return A.o;\n    }\n}\n\nRay cast_ray(vec2 uv, float fov)\n{\n    float z = 0.5 / tan(fov / 2.);\n    \n    vec3 n = normalize(vec3(uv,z));\n    \n    vec3 o = vec3(0.);\n    \n    return Ray(o, n);\n}\n\nfloat specular_factor(vec3 i, vec3 o, vec3 n)\n{\n    // Reflect i around n\n    vec3 r = i - 2.*dot(i,n)*n;\n    \n    return pow(max(0.,dot(r,o)), 4.);\n}\n\nvec3 bm_ripple(vec3 n)\n{\n    return normalize(n + 0.3*sin(10.*iTime - 40.*n.y)*vec3(0.,1.,0.));\n}\n\nvec3 bm_texture(vec3 n)\n{\n    float theta = atan(length(n.xz)/n.y);\n    \n    float phi = atan(n.z/n.x);\n    \n    \n\treturn n + 0.1*texture(iChannel0, 4.*vec2(phi/6.28, theta/3.14)).xyz;\n}\n\nvec3 shade_sphere(Ray r, Sphere A, vec3 s, Light N)\n{\n    vec3 normal = bm_texture(normalize(s - A.o));\n    \n    float intensity = max(0., dot(normal, -N.n));\n    \n    vec3 diffuse_term = diff_scale*A.color*intensity;\n    \n    vec3 specular_term = spec_scale*N.color*specular_factor(N.n, normalize(r.o - s), normal);\n    \n    vec3 global_term = glob_scale*A.color;\n    \n\treturn global_term + diffuse_term + specular_term;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - 0.5*vec2(iResolution.x/iResolution.y, 1.);\n    \n    // Define sphere\n    Sphere A = Sphere(A_o, A_r, A_col);\n    \n    // Define light\n    vec3 light_dir = normalize(vec3(cos(iTime), -0.5, sin(iTime)));\n    Light N = Light(light_dir, N_col);\n    \n    // Go from pixel position to ray direction\n    Ray r = cast_ray(uv, 90.);\n\n    // Find ray-sphere intersection\n    vec3 s = ray_sphere_intersect(r, A);\n    \n    // BG color\n\tvec3 col = vec3(0.1);\n    \n    if (s != A.o)\n    {\n        col = shade_sphere(r, A, s, N);\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// Clifford algebra definitions\nconst mat4 I = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n\nconst mat4 g1 = mat4(\n    0, 0, 0, 1,\n    0, 0, 1, 0,\n    0, 1, 0, 0,\n    1, 0, 0, 0);\nconst mat4 g2 = mat4(\n    0, 0, 1, 0,\n    0, 0, 0, -1,\n    1, 0, 0, 0,\n    0, -1, 0, 0);\nconst mat4 g3 = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, -1, 0,\n    0, 0, 0, -1);\nconst mat4 g23 = g2*g3;\nconst mat4 g31 = g3*g1;\nconst mat4 g12 = g1*g2;\nconst mat4 g123 = g1*g2*g3;\n\n// Trace of 4x4 matrix\nfloat tr(mat4 A)\n{\n    return A[0][0] + A[1][1] + A[2][2] + A[3][3];\n}\n\n\n// Euclidean vector to Clifford vector\nmat4 cvec(vec3 u)\n{\n    return u.x * g1 + u.y * g2 + u.z * g3;\n}\n\n// Clifford vector to Euclidean vector\nvec3 evec(mat4 A)\n{\n    return 0.25*vec3(tr(A*g1), tr(A*g2), tr(A*g3));\n}\n\n// Normalize a Clifford vector\nmat4 cnormalize(mat4 a)\n{\n    return a / sqrt(tr(a*a)/4.);\n}\n\n// Clifford dot product\nfloat cdot(mat4 a, mat4 b)\n{\n\treturn tr(a*b + b*a) / 8.;\n}\n\n// Clifford cross product\nmat4 ccross(mat4 a, mat4 b)\n{\n    return -0.5*g123*(a*b - b*a);\n}\n\n// Rotation vector: RxR^T\nmat4 rotor(vec3 n, float a)\n{\n    float c = cos(a/2.);\n    float s = sin(a/2.);\n    return c * I - s * (n.x * g23 + n.y * g31 + n.z * g12);\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"tl2Szw","date":"1734786124","viewed":32,"name":"Wrinkleball","username":"Trips","description":"Sphere with a noisy normal map","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bumpmap"],"hasliked":0,"parentid":"","parentname":""}}