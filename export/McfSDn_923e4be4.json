{"ver":"0.1","info":{"id":"McfSDn","date":"1705112255","viewed":62,"name":"My first Ray Marching Project","username":"aolopez","description":"This is a Shader for me to continue to improve my Ray Marching prowess","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a,b) - h*h*h*h*(1.0/6.0);\n}\n\nfloat opSub(float d1, float d2) {\n    return max(-d1, d2);\n}\n\n// Rotate Function\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat repeatedSphere(vec3 p, float s) {\n    vec3 r = p - s * round(p / s);\n    return sdSphere(r, 0.5);\n}\n\nfloat repeatedBox(vec3 p, float s) {\n    vec3 r = p - s * round(p / s);\n    return sdBox(r, vec3(0.25));\n}\n\n// Distance to the scene\nfloat map(vec3 p) {\n    vec3 spherePos = vec3(-sin(iTime) * 5.0, 2.5, 0.0); // Sphere Position\n    float sphere = sdSphere(p - spherePos, 1.0); // Sphere SDF\n    \n    vec3 q = p;\n    \n    float boxScale = 0.75;\n    vec3 boxPos = vec3(-sin(iTime) * 5.0, 1.75, 0.0); // Box Position\n    q -= boxPos; // Translate First so box rotates in position\n    q.xz *= rot2D(iTime); // Rotate around the Y axis\n    float box = sdBox(q / boxScale, vec3(0.75)) * boxScale; // Cube SDF\n\n    q = p;\n    vec3 sPos2 = vec3(sin(iTime) * 5.0, -1.5, 0.0);\n    vec3 bPos2 = vec3(sin(iTime) * 5.0, -0.75, 0.0);\n    float s2 = sdSphere(p - sPos2, 1.0);\n    q -= bPos2;\n    q.xz *= rot2D(iTime);\n    float b2 = sdBox(q / boxScale, vec3(0.75)) * boxScale;\n\n    // float ground = p.y + 2.0; // Ground SDF\n    \n    float r1 = opSub(sphere, box); // min(sphere, box);\n    float r2 = opSub(s2, b2);\n    // float result = smin(r1, r2, 2.0);\n    \n    // Sphere Repetition\n    q = p;\n    q -= vec3(1.0, 0.0, 0.0); // Offset from center\n    q -= vec3(0.0, 0.0, -iTime); // Move Towards Camera\n    q.xy *= rot2D(iTime * 0.5);\n    float repS = repeatedSphere(q, 3.0);\n    \n    float result = repS;\n    // result = min(ground, result);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    // Initialization\n    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);    // Ray Origin\n    float raySpread = 2.0;\n    vec3 rayDirection = normalize(vec3(uv * raySpread, 1.0));  // Ray Direction\n    vec3 col = vec3(0.0);  // Final Pixel Color\n    \n    float t = 0.0; // Total Distance Travelled\n    \n    // Ray Marching\n    for (int i = 0; i < 80; i++) {\n        vec3 p = rayOrigin + rayDirection * t; // Position along the ray\n\n        float d = map(p);  // Current distance to the scene\n\n        t += d;  // \"March\" the ray\n                \n        if (d < .001 || t > 100.0) break; // Early Stop\n    }\n    \n    // Coloring\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    col = vec3(t * 0.1) + color; // Color based on distance\n       \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}