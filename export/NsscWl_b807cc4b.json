{"ver":"0.1","info":{"id":"NsscWl","date":"1642917870","viewed":182,"name":"Pond Sculpture","username":"PGRacer","description":"Using some spatial distortion to create a dynamic sculpture and a simple shallow water effect.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","distortion"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"PGRacer - Raymarching Template\" by PGRacer. https://shadertoy.com/view/slVXDz\n// 2022-01-21 05:46:43\n\n//////////////////\n// IMAGE SHADER //\n//////////////////\n\n// MATERIAL IDS;\nconst int MAT_METAL = 0;\nconst int MAT_WEAVE = 1;\nconst int MAT_TILE = 2;\nconst int MAT_STARS = 3;\nconst int MAT_WOOD = 4;\nconst int MAT_ROCK = 5;\nconst int MAT_STONE = 6;\nconst int MAT_MIRROR = 7;\nconst int MAT_POND = 8;\n\nSDFSample Scene(vec3 p)\n{\n    mat4 rTorus1 = MRotate(-TIME * 0.589692, RIGHT);\n    SDFSample sTorus1 = Torus(mul(rTorus1, p - UP * 0.5 - RIGHT * 0.3), 0.3, 0.05);\n    sTorus1.r = rTorus1;\n    sTorus1.m = MAT_MIRROR;\n    \n    mat4 rTorus2 = MRotate(TIME * 0.589692, RIGHT);\n    SDFSample sTorus2 = Torus(mul(rTorus2, p - UP * 0.8 - LEFT * 0.4), 0.3, 0.05);\n    sTorus2.r = rTorus2;\n    sTorus2.m = MAT_MIRROR;\n    \n    mat4 rTorus3 = MRotate(PI * 0.5, FORWARD);\n    vec3 pTorus3 =  mul(rTorus3, p - UP * 0.25);\n    SDFSample sTorus3 = Torus(pTorus3, 1.0, 0.1);\n    sTorus3.m = MAT_MIRROR;\n    sTorus3.r = rTorus3;\n    \n    vec3 pCylinder = SpacialWave(p, DOWN + RIGHT, 0.1, 5.0, TIME * 1.234864) - UP * 0.5;\n    SDFSample sCylinder = Capsule(pCylinder, 1.0, 0.35);\n    sCylinder.m = MAT_WOOD;\n    sCylinder.d *= 0.75;\n    \n    vec3 pPlatform = SpacialWave(p, DOWN * 0.1, 0.02, 30.0, -TIME * 2.0);\n    SDFSample sPlatform = Cylinder(pPlatform, 0.2, 2.0);\n    sPlatform.m = MAT_POND;\n    \n    SDFSample sScene = sTorus3;\n    sScene = BufferedUnion(sScene, sCylinder, 0.2);\n    \n    SDFSample sToruses = Union(sTorus1, sTorus2);\n    sScene = BufferedUnion(sToruses, sScene, 0.25);\n    sScene = Union(sScene, sPlatform);\n    \n    SDFSample sRing = Hoop(p, 0.35, 2.1, 2.0);\n    sRing.m = MAT_STONE;\n    \n    sScene = Union(sScene, sRing);\n    \n    return sScene;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n    \n\tvec3 n = Scene(p).d - vec3(\n\t\tScene(p - e.xyy).d,\n\t\tScene(p - e.yxy).d,\n\t\tScene(p - e.yyx).d\n\t\t);\n\treturn normalize(n);\n}\n\nfloat GetAO(vec3 p, vec3 n)\n{\n    float stepSize = AMBIENT_OCCLUSION_STEP_SIZE;\n    float t = stepSize;\n\n    float ac = 0.0;\n\n    for(float i = 0.0; i < AMBIENT_OCCLUSION_STEP_COUNT; i++) {\n        float d = Scene(p + n * t).d;\n        ac += t - d;\n        t += stepSize;\n    }\n    return 1.0 - ac / 2.0;\n}\n\nfloat GetShadows(vec3 ro, vec3 rd, float tMax)\n{\n    float res = 1.0;\n    float t = SHADOW_CORRECTION;\n    for( int i=0; i<50; i++ )\n    {\n        float h = Scene(ro + rd * t).d;\n        res = min( res, tMax*h/t );\n        t += clamp(h, 0.005, 0.5);\n        if(res < 0.005 || t > tMax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nSDFSample SampleScene(vec3 origin, vec3 rayDir, out vec3 p, out float distFromOrigin, out bool hit, out bool outline)\n{\n    p = vec3(0.0);\n    float prevDist = MAX_DIST;\n    SDFSample s;\n    \n    distFromOrigin = 0.0;\n    hit = false;\n    outline = false;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = origin + rayDir * distFromOrigin;\n\t\ts = Scene(p);\n\t\tdistFromOrigin += s.d;\n        \n        if (s.d < OUTLINE_WIDTH * pow(distFromOrigin, OUTLINE_DIST_COMP))\n\t\t{\n\t\t\toutline = true;\n\t\t}\n        \n        if (distFromOrigin >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s.d < SURFACE_DISTANCE_TOLERANCE)\n\t\t{\n            hit = true;\n\t\t\toutline = false;\n\t\t\tbreak;\n\t\t}\n        \n        if (outline && prevDist < s.d)\n        {\n            hit = false;\n            break;\n        }\n        \n        prevDist = s.d;\n    }\n    \n    return s;\n}\n\nvec3 GetLight(vec3 p, LightSource ls, MaterialSample mat, float ao, vec3 normal)\n{\n    vec3 lightDir = normalize(p - ls.p);\n\n    float lightDist = distance(p, ls.p);\n    float shadowValue = GetShadows(p, -lightDir, lightDist);\n\n    float attenuation = 1.0 / (pow(lightDist, 2.0));\n    float light = ls.s * attenuation;\n\n    float scalar = dot(-lightDir, normal);\n    scalar = clamp(scalar, 0.0, 1.0);\n     \n    light *= scalar;\n    light *= shadowValue;\n    light += ao * ls.s * attenuation;   \n        \n    return light * ls.c;\n}\n\nvec2 GetRegionalCoord(vec2 uv, vec3 region)\n{\n    return (fract(uv) + region.xy) / region.z;\n}\n\nvec3 GetTriPlanarTexture(vec3 p, vec3 normal, sampler2D sampler, vec3 region)\n{\n    vec3 texXY = texture(sampler, GetRegionalCoord(p.xy * 0.5 + 0.5, region)).rgb;\n    vec3 texXZ = texture(sampler, GetRegionalCoord(p.xz * 0.5 + 0.5, region)).rgb;\n    vec3 texYZ = texture(sampler, GetRegionalCoord(p.zy * 0.5 + 0.5, region)).rgb; \n        \n    normal = abs(normal);\n    //normal = pow(normal, vec3(2.0));\n    //normal /= SumComponents(normal);\n    \n    vec3 tex = texXY * normal.z + texXZ * normal.y + texYZ * normal.x;\n    \n    return tex;\n}\n\nMaterialSample SampleSurface(SDFSample s, vec3 rayDir, vec3 normal)\n{\n    MaterialSample ms;\n    vec3 p = s.p * 4.0 * s.f;\n    ms.m = 0.0;\n    ms.s = 0.0;\n    normal = mul(s.r, normal);\n    \n    vec3 localNormal = mul(s.r, normal);\n    vec3 iridescent = vec3(NSin(localNormal.r), NSin(localNormal.g), NSin(localNormal.b));\n\n    switch(s.m)\n    {\n        case MAT_METAL:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 1.0, 4.0));\n            ms.s = 0.8;\n            ms.m = 0.4;\n            ms.c = mix(ms.c, ms.c * iridescent, 0.75);\n            break;\n        case MAT_WEAVE:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 0.0, 4.0));\n            break;\n        case MAT_TILE:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 0.0, 4.0));\n            break;\n        case MAT_STARS:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 1.0, 4.0));\n            break;\n        case MAT_WOOD:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 0.0, 2.0));\n            ms.s = 0.95;\n            ms.m = 0.1;\n            break;\n        case MAT_ROCK:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 1.0, 2.0));\n            break;\n        case MAT_STONE:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 1.0, 2.0));\n            break;\n        case MAT_MIRROR:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 1.0, 4.0));\n            ms.m = 0.7;\n            ms.s = 0.99;\n            ms.c *= iridescent;\n            break;\n        case MAT_POND:\n            ms.c = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 0.0, 4.0));\n            ms.s = 0.99;\n            ms.m = 0.5;\n            break;\n    }\n\n    return ms;\n}\n\nvec3 ColorCorrection(vec3 color)\n{\n    if (COLOR_BIT_DEPTH < 8.0)\n    {\n        float colorsPerChannel = pow(2.0, COLOR_BIT_DEPTH);\n        color = floor(color * colorsPerChannel) / colorsPerChannel;\n    }\n    \n    color = (color - vec3(0.5)) * CONTRAST + vec3(0.5);\n    color = pow(color / 255.0, vec3(1.0 / GAMMA)) * 255.0;\n    color = mix(vec3(AvgComponentLength(color)), color, SATURATION);\n    color = mix(color, vec3(1.0) - color, NEGATIVE);\n    color *= TINT;\n\n    return color;\n}\n\nvec3 Render(vec3 camPos, vec3 camDir)\n{\n    float distFromOrigin = 0.0;\n    bool hit;\n\tbool outline;\n    \n    vec3 rayOrigin = camPos;\n    vec3 rayDir = camDir;\n        \n    // Light Sources\n    LightSource ls1 = LightSource(vec3(8.0, 8.0, 8.0), WHITE, 100.0);\n    LightSource ls2 = LightSource(vec3(-8.0, 8.0, 8.0), WHITE, 100.0);\n    \n    SDFSample s;\n    vec3 p = vec3(0.0);\n    vec3 finalColor;\n    vec3 bgColor;\n    float reflectiveStrength = 1.0;\n    float mainDistRatio = -1.0;\n    int hitCount = 0;\n    MaterialSample ms;\n    \n    // Do raymarching\n    do {\n        distFromOrigin = 0.0;\n        hit = false;\n        outline = false;\n        \n        bgColor = GradientSky(rayDir);\n        s = SampleScene(rayOrigin, rayDir, p, distFromOrigin, hit, outline);\n        \n        vec3 color = BLACK;\n        \n        float distRatio = distFromOrigin / MAX_DIST;\n        mainDistRatio = mainDistRatio < 0.0 ? distRatio : mainDistRatio;\n        vec3 normal = GetNormal(p);\n\n        float scalar = clamp(dot(-rayDir, normal), 0.0, 1.0);\n        \n        // Apply color to pixel\n        if (hit)\n        {    \n            ms = SampleSurface(s, rayDir, normal);\n            vec3 surfaceColor = ms.c * (1.0 - ms.m);\n            float ao = GetAO(p, normal);\n            \n            vec3 light1 = GetLight(p, ls1, ms, ao, normal);\n            vec3 light2 = GetLight(p, ls2, ms, ao, normal);\n            \n            vec3 litColor = color = light1 * surfaceColor;\n            litColor += light2 * surfaceColor;\n            \n            color = mix(BLACK, litColor, scalar);\n        }\n        else if (outline)\n        {\n            color = BLACK;\n        }\n        else\n        {\n            color = bgColor;\n        }\n        \n        finalColor += color * reflectiveStrength;\n        reflectiveStrength *= max(ms.m * reflectiveStrength, mix(0.0, 1.0, pow(1.0 - scalar, 4.0)));\n#if DIFFUSE_REFLECTION      \n#if REFLECTION_ANGLE_VARIANCE\n        vec3 pSeed = p * iTime;\n#else\n        vec3 pSeed = p;\n#endif\n        rayDir = normalize(reflect(rayDir, mix(NNormal(normal, N33(pSeed)), normal, ms.s)));\n#else\n        rayDir = reflect(rayDir, normal);\n#endif\n        rayOrigin = p + normal * SURFACE_DISTANCE_TOLERANCE * 1.05;\n        hitCount++;\n    }\n    while (hit && !outline && hitCount < MAX_RAY_HITS);\n    \n    // Saturate and apply distance fade\n    finalColor = clamp(finalColor, vec3(0.0), vec3(1.0));\n    finalColor = mix(finalColor, bgColor, pow(mainDistRatio, FADE_ATTENUATION));\n    \n    return finalColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter resolution for old-school look\n    fragCoord *= RESOLUTION_RATIO;\n    fragCoord = floor(fragCoord) / RESOLUTION_RATIO;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv -= vec2(0.5);\n\n    // Vignette\n    float uvLength = length(uv);\n    uvLength = uvLength * 1.33333 - .25;\n    float vignette = smoothstep(0.99, 0.001, uvLength);\n    \n    // Aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec3 camPos = mul(MRotate(TIME * 0.25, UP), vec3(0.0, 1.5, -3.0));\n    vec3 camDir = mul(MRotate(TIME * 0.25, UP) * MRotate(-0.35, RIGHT), normalize(vec3(uv.x, uv.y, 1.0)));\n    \n    // Render the scene\n    vec3 color = Render(camPos, camDir);\n    \n    // Apply color correction\n    color = ColorCorrection(color);\n    \n#if SCAN_LINES_ENABLED\n    if (mod(fragCoord.y * RESOLUTION_RATIO, 2.0) < 1.0) color = BLACK;\n#endif\n          \n    // Fade scene in at start\n    color *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    color *= vignette;\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 2000\n#define MAX_DIST 100.0\n#define SURFACE_DISTANCE_TOLERANCE 0.0001\n#define NORMAL_CHECK_OFFSET 0.001\n#define MAX_RAY_HITS 3\n\n// TIMING\n#define TIME iTime * 1.0\n\n// OUTLINE\n#define OUTLINE_WIDTH 0.000\n#define OUTLINE_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define FADE_ATTENUATION 10.0\n#define AMBIENT_OCCLUSION_STEP_SIZE 0.006\n#define AMBIENT_OCCLUSION_STEP_COUNT 20.0\n#define AMBIENT_OCCLUSION_ATTENUATION 1.0\n#define SHADOW_CORRECTION 0.001\n#define DIFFUSE_REFLECTION 1\n#define REFLECTION_ANGLE_VARIANCE 1\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define TAU 6.283185\n#define PI  TAU / 2.0\n#define ROOT2 1.414213\n#define ROOT3 1.732051\n#define EULER 2.718282\n#define MIDENTITY mat4(1.0)\n\n// AXIAL VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// COLORS\n#define BLACK vec3(0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define BROWN vec3(0.5, 0.2, 0.0)\n#define DARK_GREY vec3(0.25, 0.25, 0.25)\n#define FUCHSIA vec3(1.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define LIGHT_GREY vec3(0.75, 0.75, 0.75)\n#define MEDIUM_GREY vec3(0.5, 0.5, 0.5)\n#define ORANGE vec3(1.0, 0.5, 0.0)\n#define PINK vec3(1.0, 0.5, 0.5)\n#define RED vec3(1.0, 0.0, 0.0)\n#define TURQUOISE vec3(0.0, 1.0, 1.0)\n#define WHITE vec3(1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n// COLOR CORRECTION\n#define COLOR_BIT_DEPTH 8.0\n#define GAMMA 1.0\n#define CONTRAST 1.0\n#define SATURATION 1.0\n#define NEGATIVE 0.0\n#define TINT WHITE\n\n// RENDERING OPTIONS\n#define INTERPUPILARY_DISTANCE 0.064\n#define SCAN_LINES_ENABLED 0\n#define RESOLUTION_RATIO 1.0 // 0.0 will result in divide-by-zero, magnitude 1.0+ will have no effect.  negative values will shift pixels (-1,-1).\n\n// INPUT KEYS\n#define KEY_SHIFT   16\n#define KEY_CONTROL 17\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_A       65\n#define KEY_B       66\n#define KEY_C       67\n#define KEY_D       68\n#define KEY_E       69\n#define KEY_F       70\n#define KEY_G       71\n#define KEY_H       72\n#define KEY_I       73\n#define KEY_J       74\n#define KEY_K       75\n#define KEY_L       76\n#define KEY_M       77\n#define KEY_N       78\n#define KEY_O       79\n#define KEY_P       80\n#define KEY_Q       81\n#define KEY_R       82\n#define KEY_S       83\n#define KEY_T       84\n#define KEY_U       85\n#define KEY_V       86\n#define KEY_W       87\n#define KEY_X       88\n#define KEY_Y       89\n#define KEY_Z       90\n#define KEY_0       48\n#define KEY_1       49\n#define KEY_2       50\n#define KEY_3       51\n#define KEY_4       52\n#define KEY_5       53\n#define KEY_6       54\n#define KEY_7       55\n#define KEY_8       56\n#define KEY_9       57\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// TRANSFORMATIONS\nmat2x2 MRotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat4 MRotate(float angle, vec3 axis) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c,          0.0,\n                0.0,                               0.0,                               0.0,                               1.0);\n}\n\nmat4 MScale(vec3 s)\n{\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 MScale(float s)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0 / s);\n}\n\nmat4 MTranslate(vec3 v)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\n}\n\nmat4 MTransInv(mat4 m)\n{\n    return transpose(inverse(m));\n}\n\nvec3 mul(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 1.0)).xyz;\n}\n\nvec3 nmul(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 0.0)).xyz;\n}\n\n// USEFUL MATH STUFF\nfloat SumComponents(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\nfloat SumComponentLength(vec3 v)\n{\n    return SumComponents(abs(v));\n}\n\nfloat AvgComponents(vec3 v)\n{\n    return (v.x + v.y + v.z) / 3.0;\n}\n\nfloat AvgComponentLength(vec3 v)\n{\n    return AvgComponents(abs(v));\n}\n\nfloat ComponentVariance(vec3 v)\n{\n    float mean = AvgComponentLength(v);\n    vec3 sqDiff = vec3(mean) - v * v;\n    float sum = SumComponents(sqDiff);\n    return sum / 3.0;\n}\n\nfloat NSin(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\nfloat NCos(float t)\n{\n    return cos(t) * 0.5 + 0.5;\n}\n\nfloat TriangleWave(float t)\n{\n    return 2.0 * abs(2.0 * (t / TAU - floor(t / TAU + 0.5))) - 1.0;\n}\n\nfloat NTriangleWave(float t)\n{\n    return 2.0 * abs(t / TAU - floor(t / TAU + 0.5));\n}\n\nfloat SFract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 SFract(vec2 v)\n{\n    return vec2(SFract(v.x), SFract(v.y));\n}\n\nvec3 SFract(vec3 v)\n{\n    return vec3(SFract(v.xy), SFract(v.z));\n}\n\nfloat SMod(float v, float x)\n{\n    return x == 0.0 ? v : SFract(v / x) * x;\n}\n\nvec2 SMod(vec2 v, vec2 x)\n{\n    return vec2(SMod(v.x, x.x), SMod(v.y, x.y));\n}\n\nvec3 SMod(vec3 v, vec3 x)\n{\n    return vec3(SMod(v.xy, x.xy), SMod(v.z, x.z));\n}\n\nvec3 FlipX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 FlipY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 FlipZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 AbsX(vec3 p)\n{\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 AbsY(vec3 p)\n{\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 AbsZ(vec3 p)\n{\n    return vec3(p.x, p.y, abs(p.z));\n}\n\nvec3 AbsXY(vec3 p)\n{\n    return vec3(abs(p.x), abs(p.y), p.z);\n}\n\nvec3 AbsXZ(vec3 p)\n{\n    return vec3(abs(p.x), p.y, abs(p.z));\n}\n\nvec3 AbsYZ(vec3 p)\n{\n    return vec3(p.x, abs(p.y), abs(p.z));\n}\n\nvec3 NegateX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 NegateY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 NegateZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 NegateXY(vec3 p)\n{\n    return vec3(-p.x, -p.y, p.z);\n}\n\nvec3 NegateYZ(vec3 p)\n{\n    return vec3(p.x, -p.y, -p.z);\n}\n\nvec3 NegateXZ(vec3 p)\n{\n    return vec3(-p.x, p.y, -p.z);\n}\n\n// STRUCTS\nstruct MaterialSample\n{\n    vec3 c;\n    float m;\n    float s;\n};\n\nstruct SDFSample\n{\n    float d;\n    vec3 p;\n    int m;\n    float f;\n    mat4 r;\n};\n\nstruct LightSource\n{\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\n// COMBINATIONS\nSDFSample Union(SDFSample d1, SDFSample d2)\n{\n    if (d1.d < d2.d) return d1; return d2;\n}\n\nSDFSample SmoothUnion(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) - smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample Difference(SDFSample s1, SDFSample s2, float c)\n{\n    float clearance = s2.d - c;\n    return SDFSample(s1.d > -clearance ? s1.d : -clearance, s1.p,  s1.m, s1.f, s1.r);\n}\n\nSDFSample SmoothDifference(SDFSample s1, SDFSample s2, float smoothing) {\n    float h = max(smoothing - abs(-s2.d - s1.d), 0.0);\n    return SDFSample(max(s1.d, -s2.d) + h * h  *0.25 / smoothing, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample BufferedUnion(SDFSample s1, SDFSample s2, float r)\n{\n    return Union(s1, SmoothDifference(s2, s1, r));\n}\n\nSDFSample Intersection(SDFSample s1, SDFSample s2)\n{\n    return SDFSample(s1.d > s2.d ? s1.d : s2.d, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample SmoothIntersection(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) + smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample Negation(SDFSample s1, SDFSample s2)\n{\n    return Difference(Union(s1, s2), Intersection(s1, s2), 0.004); // Seems to need a slight error correction\n}\n\nSDFSample SmoothNegation(SDFSample s1, SDFSample s2, float smoothing)\n{\n    SDFSample i = Intersection(s1, s2);\n    return Union(SmoothDifference(s1, i, smoothing), SmoothDifference(s2, i, smoothing)); // Doing the Differences separately and before the union preserves rotations\n}\n\n// DISTORTIONS\nvec3 Twist(vec3 p, float twist)\n{\n    float c = cos(twist * p.y);\n    float s = sin(twist * p.y);\n    mat2  m = mat2(c, -s ,s, c);\n    vec2 pT = m*p.xz;\n    vec3  q = vec3(pT.x, p.y, pT.y);\n    return q;\n}\n\nvec3 Bend(vec3 p, float bend)\n{\n    float c = cos(bend * p.x);\n    float s = sin(bend * p.x);\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec4 Elongate(vec3 p, vec3 h)\n{   \n    // Usage: dist = min(dist, w.w+DistFunc(w.xyz, ... ) );\n    // Where w is the output of this function\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat Layer(float d, float h)\n{\n    return abs(d) - h;\n}\n\nvec3 SpacialWave(vec3 p, vec3 c, float a, float f, float t)\n{\n    return (length(p - c) * (1.0 - a) + a * sin(length(p - c) * f + t)) * normalize(p - c) + c;\n}\n\n// Slicing\nfloat SliceXZ(vec3 p, float d)\n{\n    return max(abs(p.y), d);\n}\n\nfloat SliceXY(vec3 p, float d)\n{\n    return max(abs(p.z), d);\n}\n\nfloat SliceYZ(vec3 p, float d)\n{\n    return max(abs(p.x), d);\n}\n\n// Repetitions\nvec3 RepeatRange(in vec3 p, in vec3 c, in vec3 l)\n{\n    p -= c * 0.5 * (1.0 - mod(l, 2.0));\n    return p - c * (clamp(round(p / c), ceil(-l * 0.5), ceil(l * 0.5) - vec3(1.0)));\n}\n\nvec3 RepeatInfinite(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat Extrusion(vec3 p, float d, float h)\n{\n    vec2 w = vec2(d, abs(p.y) - h * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 2D PRIMITIVES\nvec2 Circle(vec3 p, float r)\n{\n    return vec2(length(vec2(p.x, p.z)) - r, 0.0);\n}\n\nfloat Star5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// 3D PRIMITIVES - Mostly adapted from https://iquilezles.org/articles/distfunctions\nSDFSample SquareColumn(vec3 p, vec2 d)\n{\n    vec3 pO = abs(p);\n    return SDFSample(max(pO.x - d.x / 2.0, pO.z - d.y / 2.0), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Sphere(vec3 p, float r)\n{\n\treturn SDFSample(length(p) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample ISphere(vec3 p, float r)\n{\n    return SDFSample(r - length(p), p, 1, 1.0, MIDENTITY);\n}\n\nSDFSample Box(vec3 p, vec3 dimensions)\n{\n    vec3 pO = abs(p);\n\treturn SDFSample(length(max(abs(pO) - (0.5 * dimensions), 0.0)), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Disk(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Capsule(vec3 p, float h, float r)\n{\n\tvec3 a = vec3(0.0, h * 0.5, 0.0);\n\tvec3 b = vec3(0.0, -h * 0.5, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n    \n\treturn SDFSample(length(p - c) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Cylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);\n    return SDFSample(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), vec3(p.x, p.y, p.z), 0, 1.0, MIDENTITY);\n}\n\nSDFSample Tube(vec3 p, float h, float r, float t)\n{\n    float dHoop = abs(Circle(p, r).x) - t;\n    return SDFSample(Extrusion(p, dHoop, h), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Torus(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Hoop(vec3 p, float h, float rO, float rI)\n{\n    SDFSample c1 = Cylinder(p, h, rO);\n    SDFSample c2 = Capsule(p, h, rI);\n\treturn Difference(c1, c2, 0.0);\n}\n\nSDFSample Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    vec3 pO = p * repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return SDFSample(abs(dot(sin(pO * bias.x), cos(pO.zxy * bias.y))) / avgRepetition - width, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample BoxFrame(vec3 p, vec3 b, float e)\n{\n    vec3 pO = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    float minimum = min(min(\n        length(max(vec3(pO.x,q.y,q.z),0.0))+min(max(pO.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,pO.y,q.z),0.0))+min(max(q.x,max(pO.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,pO.z),0.0))+min(max(q.x,max(q.y,pO.z)),0.0));\n      \n    return SDFSample(minimum, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Plane(vec3 p)\n{\n    vec3 pO = AbsY(p);\n    return SDFSample(pO.y, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample InfiniteCone(vec3 p, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(p.xz), -p.y);\n    float d = length(q - c * max(dot(q, c), 0.0));\n    return SDFSample(d * ((q.x * c.y - q.y * c.x < 0.0) ? -1.0 : 1.0), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample CappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return SDFSample(s * sqrt(min(dot(ca, ca), dot(cb, cb)) ), p, 0, 1.0, MIDENTITY);\n}\n\n// NOISE\n\nfloat N11(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n\nfloat N21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat N31(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\nvec3 N33(vec3 p)\n{\n    vec4 a = fract(p.xyzx * vec4(1278.67, 3134.61, 298.647, 134.489));\n    a += dot(a, a + 318.978);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.z * a.w)) * 0.5;\n}\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 NNormal(vec3 d, vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n// BACKGROUNDS\nvec3 ColoredSpace(vec3 rayDir, vec2 res, float time)\n{\n    vec3 r3 = N33(floor(rayDir * res.y * 0.5) / res.y * 2.0);\n    float r1 = pow(N31(r3), 5.0);\n    float stars = smoothstep(0.95, 0.995, r1);\n    \n    vec3 v = vec3(NSin(time * 0.2496 + rayDir.r), NSin(time * 0.354 + rayDir.g), NSin(time * 0.4289 + rayDir.b));\n    v *= 0.2;\n    \n    v += mix(vec3(stars), r3 * stars, 0.66);\n    \n    return v;\n}\n\nvec3 GradientSky(vec3 rayDir)\n{\n\n#define SKY_BLUE vec3(0.3, 0.7, 1.0)\n#define HORIZON_ORANGE vec3(1.0, 0.5, 0.2)\n#define DARK_BLUE vec3(0.05, 0.0, 0.15)\n    float scalar = dot(normalize(vec3(rayDir.x, 0.0, rayDir.z)), normalize(rayDir));\n    scalar = 1.0 - scalar;\n    if (rayDir.y < 0.0) scalar = -scalar;\n    scalar = (scalar + 1.0) / 2.0;\n    \n    vec3 col = DARK_BLUE;\n    col = mix(col, HORIZON_ORANGE, smoothstep(0.499, 0.5, scalar));\n    col = mix(col, SKY_BLUE, smoothstep(0.49, 0.51, scalar));\n    \n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Pack textures into atlas\n// 2 3\n// 0 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    \n    if (uv.x > 1.0)\n    {\n        if (uv.y >= 1.0)\n        {\n            fragColor = texture(iChannel3, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, uv);\n        }\n    }\n    else\n    {\n        if (uv.y >= 1.0)\n        {\n            \n            fragColor = texture(iChannel2, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        } \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Pack textures into atlas\n// 2 3\n// 0 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    \n    if (uv.x > 1.0)\n    {\n        if (uv.y >= 1.0)\n        {\n            fragColor = texture(iChannel3, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, uv);\n        }\n    }\n    else\n    {\n        if (uv.y >= 1.0)\n        {\n            \n            fragColor = texture(iChannel2, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        } \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}