{"ver":"0.1","info":{"id":"MfX3D8","date":"1702997419","viewed":27,"name":"ki-3","username":"tono","description":"First, my grandmother passed away. My grandfather took care of the flower she loved. He also passed away, but the yellow flower remains here.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["flower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define YELLOW 1.\n#define GAKU 2.\n#define KUKI 3.\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.)*2.;\n\nvec2 min2(vec2 a,vec2 b){\n\treturn mix(a,b,step(b.x,a.x));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n\n    return p * rot(-a);\n}\nfloat smoothmin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n//https://iquilezles.org/articles/distfunctions/\n//https://www.shadertoy.com/view/Ds2czG\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nvec2 hana(vec3 p){\n\tfloat o = 10.;\n    float h = 0.2;\n    float w = 0.08;\n   // p.x = abs(p.x)-0.1;\n     \n    //p.z = abs(p.z)-0.05;\n    p.yz *= rot(pi/2.);\n    //p.yz *= rot(0.1);\n    // vec3 rp = p;\n    // rp.xy = pmod(rp.xy,13.);\n    // rp.yz *= rot(1.4);\n    // o = sdVerticalVesicaSegment(rp,h,w);\n    \n    for(int i = 0; i< 2;i++){\n        float fi = float(i);\n    \tvec3 rp = p;\n        \n        rp.xy *= rot(fi * 140.);\n        rp.xy = pmod(rp.xy,5.);\n        rp.yz *= rot(.3 - fi/3.);\n        o = min(o,sdVerticalVesicaSegment(rp * vec3(1.,1.,1.),h -fi/100.,w));\n    }\n\t\n    return vec2(o,YELLOW);\n}\n\nvec2 gaku(vec3 p){\n\tfloat o = 10.;\n    o = length(p * vec3(1.,1.,1.)) - 0.05;\n    \n    if(o < 0.1){\n    \to -= noise(p.xz * 100.)/150.;\n    }\n    return vec2(o,GAKU);\n}\n\nvec2 hanaHead(vec3 p){\n\tvec2 o = hana(p);\n    o = min2(o,gaku(p));\n    return o;\n}\n\nvec2 kuki(vec3 p){\n\tfloat o = 10.;\n    p.y -=0.01;\n    o = length(p) - 0.01;\n    p.y -= clamp(p.y , 0.,30.2);\n    o = smoothmin(length(p) - 0.01,o,27.2);\n    \n    return vec2(o,KUKI);\n}\n\nvec2 map(vec3 p){\n\tvec2 o = vec2(0.);\n    \n    float id = floor(p.z);\n    p.x += sin(iTime/2. + id);\n    p.y += cos(iTime/2. + id);\n    p.xy *= rot(-p.z/3.);\n    p.xy = pmod(p.xy , 16.);\n    p.y -= 1.4;\n    p.z = mod(p.z , 1.)-.5;\n    //p.z -= 0.4;\n    p.xz *= rot(iTime);\n    o = hanaHead(p);\n    o = min2(o,kuki(p));\n    o.x *= 0.7;\n    return o;\n}\n\nfloat nearest = 0.;\nvec2 march(vec3 cp,vec3 rd){\n    float depth = 0.;\n    for(int i = 0; i < 180; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        \n        nearest = (d.x < nearest)?d.x:nearest;\n        if(abs(d.x) < 0.00001){\n        \treturn vec2(depth , d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec3 getMat(float id,vec3 p){\n    vec3 mat = vec3(1.,0.,1.);\n    if(YELLOW == id){\n    \tmat = vec3(1.,0.8,0.);\n    }else if(GAKU == id){\n    \tmat = vec3(.7,0.15,0.3);\n    }else if(KUKI == id){\n        mat = vec3(0.,.2,0.3);\n    }\n    return mat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp = vec3(0.,-1.,-3.);\n    cp.xz *= rot(iTime/6.);\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target -cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n\n    float fov = 6.5;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    \n    vec3 col = vec3(1.,0.,.3) * (noise(p*noise(p * 1000.))*0.2 + 0.75);\n    vec3 bcol = col;\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,.1);\n        vec3 n = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = n;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        \n        vec3 mat = getMat(d.y,pos);\n        float diff= max(dot(sun,n) ,0.);\n        float sp = max(0.,dot(rd,reflect(-n,sun)));\n        sp = pow(sp,1.6);\n        float rim = pow(clamp(1. - dot(n, rd), 0., 1.), 3.);\n        \n        rim = step(1.,rim);\n        col = mat;\n       // col = (1.-rim) * mat + floor(sp*5.)/15.;\n        col = max(col,mat/6.);\n        float t = 1. - exp(-0.002 * d.x * d.x * d.x * d.x);\n        col = mix(col,bcol,t);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}