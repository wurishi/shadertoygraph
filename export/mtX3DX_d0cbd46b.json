{"ver":"0.1","info":{"id":"mtX3DX","date":"1672527283","viewed":231,"name":"GPU Gems 3: Light Scattering","username":"PrzemyslawZaworski","description":"Happy New Year 2023","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["light","effect","volumetric","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 64\n\n// https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\nvec4 Scattering (vec2 texCoord, sampler2D frameSampler, vec2 ScreenLightPos, float Density, float Weight, float Decay, float Exposure) \n{\n     // Calculate vector from pixel to light source in screen space.    \n     vec2 deltaTexCoord = (texCoord - ScreenLightPos.xy);\n     // Divide by number of samples and scale by control factor.   \n     deltaTexCoord *= 1.0 / float(NUM_SAMPLES) * Density;   \n     // Store initial sample.    \n     vec3 color = texture(frameSampler, texCoord).rgb;   \n     // Set up illumination decay factor.    \n     float illuminationDecay = 1.0;   \n     // Evaluate summation from Equation 3 NUM_SAMPLES iterations.    \n     for (int i = 0; i < NUM_SAMPLES; i++)   \n     {     \n        // Step sample location along ray.     \n        texCoord -= deltaTexCoord;     \n        // Retrieve sample at new location.    \n        vec3 sampler = texture(frameSampler, texCoord).rgb;     \n        // Apply sample attenuation scale/decay factors.     \n        sampler *= illuminationDecay * Weight;     \n        // Accumulate combined color.     \n        color += sampler;     \n        // Update exponential decay factor.     \n        illuminationDecay *= Decay;   \n    }   \n    // Output final color with a further scale control factor.    \n    return vec4( color * Exposure, 1);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texCoord = fragCoord.xy / iResolution.xy;\n    vec2 ScreenLightPos = vec2(0.5,0.5);\n    float Density = 1.0;\n    float Weight = 1.0;\n    float Decay = 1.0;\n    float Exposure = 1.0;\n    vec4 mountain = vec4(0.0);\n    if (texture(iChannel0, texCoord).r < 0.0001)\n    {\n        vec2 uv2 = 2.0*fragCoord/iResolution.xy;\n        uv2 = vec2(uv2.x + iTime,uv2.y);\n        mountain = texture(iChannel1, uv2) * texture(iChannel0, texCoord).a;\n    }\n    fragColor = Scattering (texCoord, iChannel0, ScreenLightPos, Density, Weight, Decay, Exposure) + mountain;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://thebookofshaders.com/13/\n\nfloat random (in vec2 st) \n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) \n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 st) \n{\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < 6; i++) \n    {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0*fragCoord/iResolution.xy;\n    float c = fbm(vec2(uv2.x + iTime,0.0));\n    float cc = fbm(vec2(uv2.x + iTime,uv2.y));\n    float d = ceil(uv.y-c) * 0.5;\n    vec3 color = texture(iChannel0, (uv * 0.1) + vec2(0.2)).rgb / 20.0 * d;\n    fragColor = vec4(color, uv.y-c + 0.6);\n}","name":"Buffer A","description":"","type":"buffer"}]}