{"ver":"0.1","info":{"id":"3t2SDh","date":"1565767786","viewed":168,"name":"Hello Green Chicken","username":"GreenChicken","description":"Raymarching training with my Green Chicken !\n\nI followed the awesome page https://github.com/ajweeks/RaymarchingWorkshop by ajweeks.\nsdf functions and boolean stuffs src iq : https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","chicken"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// SOME SDF FUNCTIONS\n//\n\nfloat spiralSDF(vec2 uv, float t)\n{\n    float r = dot(uv,uv);\n    float a = atan(uv.y, uv.x);\n    return abs(sin(fract(log(r)*t+a*0.159)));\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//\n// RAYMARCH SCENE\n//\n\nfloat sceneSDF(vec3 pos)\n{\n    float a, b, c;\n    float result = 0.0;\n    vec3 aPos = pos;\n    vec3 bPos = pos;\n    vec3 cPos;\n    \n    a = sdSphere(aPos, 1.0);\n    aPos.y -= 1.5;\n    a = opSmoothUnion(a, sdSphere(aPos, 1.0), .5);\n    \n    bPos.y -= 1.5;\n    bPos.x += .25;\n    bPos.z += .75;\n    b = sdSphere(bPos, .5);\n    bPos.x -= .5;\n    b = max(b, sdSphere(bPos, .5));\n    bPos = pos + vec3(0.5, -1.75, 0.75);\n    b = min(b, sdSphere(bPos, .25));\n    bPos = pos + vec3(-0.5, -1.75, 0.75);\n    b = min(b, sdSphere(bPos, .25));\n    \n    cPos = pos + vec3(0.0, -2.7, 0.0);\n    c = sdSphere(cPos, .5);\n    cPos = pos + vec3(0.0, -2.3, 0.7);\n    c = opSmoothUnion(c, sdSphere(cPos, .4),.25);\n    cPos = pos + vec3(0.0, -2.3, -0.7);\n    c = opSmoothUnion(c, sdSphere(cPos, .4),.25);\n    \n    result = min(min(a, b), c);\n    \n    \n    return result;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n    \n    for(int i=0; i<64 ; i++)\n    {\n        float res = sceneSDF(rayOrigin + rayDir * t);\n        if(res < (0.0001*t))\n        {\n            return t;\n        }\n        t += res;\n    }\n    \n    return -1.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = castRay(rayOrigin, rayDir);\n    vec3 col;\n    if(t == -1.0)\n    {\n        col = vec3(1., .1, .2) * -rayDir.y + .2;\n    }\n    else\n    {\n        float ao = pow(1.0-t*.1, 8.0) * 256.0;\n        col = vec3(.1, 1., .2) * ao;\n    }\n    \n    return col;\n}\n\nvec3 CameraViewDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 viewDir;\n    vec3 forward = normalize(camTarget - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    float fPersp = 2.0;\n    \n    viewDir = normalize(uv.x * right + uv.y * up + fPersp * forward);\n    return viewDir;\n}\n\nvec2 NormalizeScreen(vec2 st)\n{\n    vec2 uv = (2.0 * st/iResolution.xy - 1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(.0);\n    vec3 camPos = vec3(sin(iTime), .25 + sin(iTime)*.25, cos(iTime)) * 6.0;\n    vec3 camTarget = vec3(0.0, 1., .0);\n    \n    vec2 uv = NormalizeScreen(fragCoord);\n    vec3 viewDir = CameraViewDir(uv, camPos, camTarget);\n    \n    col.xy = uv;\n    \n    col = render(camPos, viewDir);\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}