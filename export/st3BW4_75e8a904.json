{"ver":"0.1","info":{"id":"st3BW4","date":"1665179353","viewed":1226,"name":"Analytic Indirect Light","username":"Mathis","description":"Analytic integral over sunlight with hard shadows. Gives proper indirect light with occlusion.\nUnfortunately there are some precision issues with the triangle clipping, resulting in noise/instability.\n\nChange the sun direction with N/M.","likes":19,"published":1,"flags":48,"usePreview":1,"tags":["3d","global","illumination","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAnalytic integration of direct sunlight in 3D\n    Overview\n        Triangulates the visible lighting when projected on geometry\n            The difference between 2 overlapping triangles generate many triangles -> not good!\n            Instead areas where two triangles overlap is compensated with negative/positive emissive triangles\n                It is the same approach used in the shader \"Analytic 3D Direct Illumination\"\n        Every pixel then determines what parts of the triangulation is visible and computes indirect light\n    The complexity per pixel is really bad (n is the number of triangles)\n        Worst case: O(n^4)\n        Best case: O(n^2)\n            It depends on the geometry and sun direction\n    Limits\n        Intersecting geometry is not implemented\n    Some notes about noise and instability\n        Parts of the indirect occlusion creates noticeable noise or fluctuating light, caused by precision issues\n            A NEAR-distance is used to reduce some of those cases\n    Improvements\n        Add skylight and emissive triangles\n        Support intersections\n        Use the linear cosine transform to implement the GGX distribution\n    Feedback\n        Is welcome :)\n\n\n\nControls:\n    Change the sun direction with N/M\n    Uncomment the path tracer \n*/\n\n\nvec3 Integrate(vec3 P, vec3 N, int TriangleIndex, vec3 SunDir) {\n    //Integrates the sunlight\n    vec3 Integral = vec3(0.);\n    TriangleI VTris[(NTris-1)*2]; //Clipped geometry\n    Triangle3 SunTris[2]; //Clipped suntriangles\n    Triangle3 OTris[100]; //Stores 2D positive/negative triangles;\n    Triangle3 Sample; TriangleI TriSI;\n    //Clip all valid occluders\n    int NVTris=0; int NSunTris;\n    for (int i=0; i<NTris; i++) {\n        //For all triangles\n        if (i==TriangleIndex) continue;\n        Triangle TriS = Triangles[i];\n        //Validity check\n        vec3 P0 = TriS.p0;\n        vec3 P1 = TriS.p1;\n        vec3 P2 = TriS.p2;\n        vec3 DotV = vec3(dot(N,TriS.p0-P),dot(N,TriS.p1-P),dot(N,TriS.p2-P));\n        bvec3 DotVb = bvec3(DotV.x>=NEAR,DotV.y>=NEAR,DotV.z>=NEAR);\n        float NFront = dot(vec3(1.),vec3(DotVb));\n        if (NFront<0.5) {\n            //Triangle is behind P\n            continue;\n        } else if (NFront<1.5) {\n            //1 point in front of P\n            if (!DotVb.x) {\n                if (DotVb.y) {\n                    P1 = TriS.p0;\n                    P0 = TriS.p1;\n                } else {\n                    P2 = TriS.p0;\n                    P0 = TriS.p2;\n                }\n            }\n            vec3 IP0 = P0+(P1-P0)*(-dot(P0-P,N)/dot(P1-P0,N));\n            vec3 IP1 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n            VTris[NVTris] = TriangleI(P0,IP0,IP1,i);\n            NVTris += 1;\n        } else if (NFront<2.5) {\n            //2 points in front of P\n            if (DotVb.x) {\n                if (!DotVb.y) {\n                    P1 = TriS.p2;\n                    P2 = TriS.p1;\n                }\n            } else {\n                P0 = TriS.p2;\n                P1 = TriS.p1;\n                P2 = TriS.p0;\n            }\n            vec3 IP0 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n            vec3 IP1 = P1+(P2-P1)*(-dot(P1-P,N)/dot(P2-P1,N));\n            VTris[NVTris] = TriangleI(P0,IP0,P1,i);\n            VTris[NVTris+1] = TriangleI(P1,IP0,IP1,i);\n            NVTris += 2;\n        } else {\n            //Triangle is completely in front of P\n            VTris[NVTris] = TriangleI(TriS.p0,TriS.p1,TriS.p2,i);\n            NVTris += 1;\n        }\n    }\n    for (int SubjectIndex=0; SubjectIndex<NTris; SubjectIndex++) {\n        //For every triangle\n        if (TriangleIndex==SubjectIndex) continue;\n        float SubjectIndexf = float(SubjectIndex);\n        Triangle CTri = Triangles[SubjectIndex];\n        //Behind P check\n        vec3 DotV = vec3(dot(N,CTri.p0-P),dot(N,CTri.p1-P),dot(N,CTri.p2-P));\n        if (max(DotV.x,max(DotV.y,DotV.z))<NEAR) continue;\n        //Attributes\n        vec3 CNor = normalize(cross(CTri.p1.xyz-CTri.p0.xyz,CTri.p2.xyz-CTri.p0.xyz));\n        CNor *= sign(dot(SunDir,CNor));\n        if (dot(P-CTri.p0,CNor)<=0.) continue;\n        float CTanLen = length(CTri.p1-CTri.p0);\n        vec3 CTan = (CTri.p1-CTri.p0)/CTanLen;\n        vec3 CBit = normalize(cross(CTan,CNor));\n        vec3 LightCoeff = CTri.C*dot(SunDir,CNor);\n        for (float sui=0.; sui<NMaxSunTrisf; sui++) {\n            //For all sun-triangles\n            NSunTris = 0;\n            float texOff = sui*3.;\n            vec4 sp0 = texture(iChannel1,vec2(texOff+0.5,SubjectIndexf+0.5)*IRES);\n            if (sp0.w<-1.5) break;\n            vec4 sp1 = texture(iChannel1,vec2(texOff+1.5,SubjectIndexf+0.5)*IRES);\n            vec4 sp2 = texture(iChannel1,vec2(texOff+2.5,SubjectIndexf+0.5)*IRES);\n            //Validity check\n            vec3 P0 = sp0.xyz;\n            vec3 P1 = sp1.xyz;\n            vec3 P2 = sp2.xyz;\n            vec3 DotV = vec3(dot(N,P0-P),dot(N,P1-P),dot(N,P2-P));\n            bvec3 DotVb = bvec3(DotV.x>=NEAR,DotV.y>=NEAR,DotV.z>=NEAR);\n            float NFront = dot(vec3(1.),vec3(DotVb));\n            if (NFront<0.5) {\n                //Triangle is behind P\n                //continue;\n            } else if (NFront<1.5) {\n                //1 point in front of P\n                if (!DotVb.x) {\n                    if (DotVb.y) {\n                        P1 = sp0.xyz;\n                        P0 = sp1.xyz;\n                    } else {\n                        P2 = sp0.xyz;\n                        P0 = sp2.xyz;\n                    }\n                }\n                vec3 IP0 = P0+(P1-P0)*(-dot(P0-P,N)/dot(P1-P0,N));\n                vec3 IP1 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n                SunTris[NSunTris] = Triangle3(P0,IP0,IP1,sp1.w);\n                NSunTris += 1;\n            } else if (NFront<2.5) {\n                //2 points in front of P\n                if (DotVb.x) {\n                    if (!DotVb.y) {\n                        P1 = sp2.xyz;\n                        P2 = sp1.xyz;\n                    }\n                } else {\n                    P0 = sp2.xyz;\n                    P1 = sp1.xyz;\n                    P2 = sp0.xyz;\n                }\n                vec3 IP0 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n                vec3 IP1 = P1+(P2-P1)*(-dot(P1-P,N)/dot(P2-P1,N));\n                SunTris[NSunTris] = Triangle3(P0,IP0,P1,sp1.w);\n                SunTris[NSunTris+1] = Triangle3(P1,IP0,IP1,sp1.w);\n                NSunTris += 2;\n            } else {\n                //Triangle is completely in front of P\n                SunTris[NSunTris] = Triangle3(sp0.xyz,sp1.xyz,sp2.xyz,sp1.w);\n                NSunTris += 1;\n            }\n            //Occlusion\n            float ssds,ssdC; vec3 VDot,TNormS,pp0,pp1,pp2,IFDir,ssns,ssnC; vec3 TPOut[6],TPIn[6];\n            for (int sti=0; sti<NSunTris; sti++) {\n                //Inject clipped suntriangles\n                Triangle3 WT = SunTris[sti];\n                Integral += abs(SolidAngle(P,N,Triangle(WT.p0,WT.p1,WT.p2,vec3(0.))))*WT.Sign*LightCoeff;\n                //*\n                int NOTris = 1; float ssds,ssdC; vec3 VDot,TNormS,pp0,pp1,pp2,IFDir,ssns,ssnC; vec3 TPOut[6],TPIn[6];   \n                OTris[0] = Triangle3(WT.p0,WT.p1,WT.p2,1.);\n                for (int o=0; o<NVTris; o++) {\n                    //For all other visible triangles\n                    TriangleI VT = VTris[o];\n                    if (SubjectIndex==VT.Index || VT.Index<0) continue;\n                    int tmpNOTris = NOTris;\n                    for (int oti=0; oti<tmpNOTris; oti++) {\n                        //For every occluder triangle\n                        Triangle3 OT = OTris[oti];\n                        //Triangle intersection: https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\n                        int NPoints = 3;  int OutPoints = 3; pp0 = VT.p0; pp1 = VT.p1; pp2 = VT.p2;\n                        vec3 LTan,tmpp0,cpp,cppPrev,cppIntersect;\n                        TPOut = vec3[6](OT.p0,OT.p1,OT.p2,vec3(0.),vec3(0.),vec3(0.));\n                        for (int SH=0; SH<3; SH++) { //For every clip-line in the clipping triangle\n                            LTan = normalize(cross(pp0-P,pp0-pp1));\n                            LTan = LTan*sign(dot(LTan,pp2-pp0));\n                            TPIn = TPOut;\n                            NPoints = OutPoints;\n                            OutPoints = 0;\n                            cppPrev = TPIn[NPoints-1];\n                            for (int ci=0; ci<NPoints; ci++) { //For every point in the subject polygon\n                                cpp = TPIn[ci];\n                                cppIntersect = cpp-(cpp-cppPrev)*dot(cpp-pp0,LTan)/dot(cpp-cppPrev,LTan);\n                                if (dot(cpp-pp0,LTan)>=NEAR) {\n                                    if (dot(cppPrev-pp0,LTan)<0.) {\n                                        //Enough precision\n                                        TPOut[OutPoints] = cppIntersect;\n                                        OutPoints += 1;\n                                    } else if (dot(cppPrev-pp0,LTan)<=NEAR) {\n                                        TPOut[OutPoints] = cppPrev;\n                                        OutPoints += 1;\n                                    }\n                                    TPOut[OutPoints] = cpp;\n                                    OutPoints += 1;\n                                } else if (dot(cppPrev-pp0,LTan)>=NEAR) {\n                                    if (dot(cpp-pp0,LTan)<=0.) {\n                                        //Enough precision\n                                        TPOut[OutPoints] = cppIntersect;\n                                        OutPoints += 1;\n                                    } else if (dot(cpp-pp0,LTan)<=NEAR) {\n                                        TPOut[OutPoints] = cpp;\n                                        OutPoints += 1;\n                                    }\n                                }\n                                cppPrev = cpp;\n                            }\n                            tmpp0 = pp0;\n                            pp0 = pp1;\n                            pp1 = pp2;\n                            pp2 = tmpp0;\n                        }\n                        //Add occluded geometry as negative triangles\n                        if (OutPoints>=3) {\n                            //In front test\n                            IFDir=normalize((TPOut[0]+TPOut[1]+TPOut[2])/3.-P);\n                            bool BTCT=TriangleA(P,IFDir,CTri.p0,CTri.p1,CTri.p2,ssdC,ssnC);\n                            bool BTst=TriangleA(P,IFDir,VT.p0,VT.p1,VT.p2,ssds,ssns);\n                            if (ssdC>=ssds) {\n                                //A clipped polygon -> 1 or more negativa triangles\n                                pp0 = TPOut[0];\n                                pp1 = TPOut[1];\n                                for (int it=2; it<OutPoints; it++) {\n                                    Triangle3 tmpWT = Triangle3(pp0,pp1,TPOut[it],-OT.Sign);\n                                    Integral += -abs(SolidAngle(P,N,Triangle(tmpWT.p0,tmpWT.p1,tmpWT.p2,\n                                                vec3(0.))))*LightCoeff*(OT.Sign*WT.Sign);\n                                    OTris[NOTris] = tmpWT;\n                                    NOTris += 1;\n                                    pp1 = TPOut[it];\n                                }\n                            }\n                        }\n                    }\n                }//*/\n            }\n        }\n    }\n    //Return\n    return max(vec3(0.),Integral)*SunLight/(2.*PI);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Update triangles\n    float tAngle = iTime*0.7;\n    vec2 tsc = vec2(sin(tAngle),cos(tAngle))*0.3;\n    Triangles[3] = Triangle(vec3(0.,0.6,0.5),vec3(-tsc.x,0.000,0.5-tsc.y),vec3(tsc.x,0.000,0.5+tsc.y),vec3(0.99));\n    //Pos\n    vec3 Color = vec3(0.);\n    vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n    vec3 Dir = normalize(vec3((fragCoord*IRES*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n    //Render scene\n    HIT Pixel=TraceRay(Pos,Dir,-1);\n    if (Pixel.D<9990.) {\n        vec3 Integral = vec3(0.);\n        //Analytic integral\n        Integral += Integrate(Pixel.P,Pixel.N,Pixel.Index,SunDir);\n        \n        //Path tracing reference\n        /*\n        if (texelFetch(iChannel2,ivec2(76,2),0).x>0.) {\n            vec3 Diffuse = vec3(0.);\n            float NSamples = 32.;\n            for (float i=0.; i<NSamples-0.5; i++) {\n                vec3 rdir = RandSample(texture(iChannel3,(fragCoord+i*(vec2(314.734,517.394)))/1024.).zw)*TBN(Pixel.N);\n                HIT RefHit = TraceRay(Pixel.P+Pixel.N*0.001,rdir,Pixel.Index);\n                if (RefHit.D<99990.) {\n                    float LDot = dot(SunDir,RefHit.N);\n                    if (LDot>0.) {\n                        HIT SunHit = TraceRay(RefHit.P,SunDir,RefHit.Index);\n                        if (SunHit.D>9990.) Diffuse += LDot*RefHit.C*SunLight;\n                    }\n                }\n            }\n            Integral = Diffuse/NSamples;\n        }\n        //*/\n        \n        //Direct light\n        HIT SunHit = TraceRay(Pixel.P,SunDir,Pixel.Index); HIT RefHit;\n        if (SunHit.D>9990.) Integral += max(0.,dot(SunDir,Pixel.N))*SunLight;\n        //Color\n        Color=Pixel.C*Integral;\n    } else {\n        //Sky\n        Color=SkyLight*pow(Dir.y*0.5+0.5,0.5)*0.;\n    }\n    //Output\n    fragColor=vec4(pow(1.-exp(-1.25*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float NEAR=0.00005; //A small value to fix errors in numerical precision\nconst float FOV=0.7; //In radians\nconst vec3 SkyLight = vec3(0.2,0.45,1.);\nconst vec3 SunLight = vec3(2.,1.7,1.2);\n\n//Other vars\nconst int NTris=6;\nconst int NMaxSunTris = 140;\nconst float NMaxSunTrisf = float(NMaxSunTris);\nconst float CFOV=tan(FOV);\nconst float PI=3.141592653;\n#define RES iResolution.xy\n#define IRES (1./iResolution.xy)\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; int Index; };\nstruct Triangle { vec3 p0; vec3 p1; vec3 p2; vec3 C; };\nstruct Triangle2 { vec2 p0; vec2 p1; vec2 p2; float Sign; };\nstruct Triangle3 { vec3 p0; vec3 p1; vec3 p2; float Sign; };\nstruct TriangleI { vec3 p0; vec3 p1; vec3 p2; int Index; };\n\nTriangle Triangles[NTris]=Triangle[NTris](\n        Triangle(vec3(-2.,0.,0),vec3(0.,0.,6.),vec3(4.,0.,0.),vec3(1.)), //Floor\n        Triangle(vec3(-2.,0.0001,0.),vec3(0.,2.5,0.),vec3(0.,0.0001,3.),vec3(1.,0.1,0.1)), //Red wall\n        Triangle(vec3(2.,0.0001,0.),vec3(0.001,2.5,0.),vec3(0.001,0.0001,3.),vec3(0.05,1.,0.05)), //Green wall\n        //Interior triangles\n        Triangle(vec3(0.,0.6,0.5),vec3(-0.3,0.000,0.5),vec3(0.3,0.000,0.5),vec3(0.4,0.4,1.)),\n            Triangle(vec3(-0.3,0.000,0.6),vec3(-0.1,0.000,1.),vec3(-0.2,0.9,0.75),vec3(0.4,0.4,1.)),\n            Triangle(vec3(0.3,0.000,0.6),vec3(0.1,0.000,1.),vec3(0.2,0.85,0.75),vec3(0.4,0.4,1.))\n        );\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O=normalize(cross(N,vec3(0.001,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nbool TriangleA(vec3 p, vec3 d, vec3 p0, vec3 p1, vec3 p2, out float hit, out vec3 triN) {\n    //From https://github.com/Jojendersie/gpugi/blob/5d18526c864bbf09baca02bfab6bcec97b7e1210/gpugi/shader/intersectiontests.glsl#L63\n    vec3 e0 = p1 - p0;\n    vec3 e1 = p0 - p2;\n    triN = cross( e1, e0 );\n    vec3 e2 = ( 1.0 / dot( triN, d ) ) * ( p0 - p );\n    vec3 i  = cross( d, e2 );\n    vec3 barycentricCoord=vec3(0.);\n    barycentricCoord.y = dot( i, e1 );\n    barycentricCoord.z = dot( i, e0 );\n    barycentricCoord.x = 1.0 - (barycentricCoord.z + barycentricCoord.y);\n    hit = dot( triN, e2 );\n    return  (hit>NEAR) && all(greaterThanEqual(barycentricCoord, vec3(0.0)));\n}\n\nHIT TraceRay(vec3 Pos, vec3 Dir, int IgnoreIndex) {\n    //Ray tracing against geometry\n    float sd; float D=10000.; Triangle Sample; vec3 sn; HIT OUT=HIT(D,vec3(0.),vec3(0.),vec3(0.),-1);\n    for (int i=0; i<NTris; i++) {\n        if (i==IgnoreIndex) continue;\n        Sample=Triangles[i];\n        if (TriangleA(Pos,Dir,Sample.p0,Sample.p1,Sample.p2,sd,sn)) {\n            if (sd<D) {\n                D=sd;\n                OUT=HIT(D,Pos+Dir*D,sn,Sample.C,i);\n            }\n        }\n    }\n    OUT.N=normalize(OUT.N)*sign(dot(-Dir,OUT.N));\n    return OUT;\n}\n\nfloat SolidAngle(vec3 P, vec3 N, Triangle Tri) {\n    //Returns the solid angle for a visible triangle\n    vec3 v0=normalize(Tri.p0-P);\n    vec3 v1=normalize(Tri.p1-P);\n    vec3 v2=normalize(Tri.p2-P);\n    float ret=abs(dot(N,normalize(cross(v0,v1)))*acos(dot(v0,v1))+\n                dot(N,normalize(cross(v1,v2)))*acos(dot(v1,v2))+\n                dot(N,normalize(cross(v2,v0)))*acos(dot(v2,v0)));\n    return ((isnan(ret))?0.:ret);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(-1.,-1.3,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(0.1,0.7,0.8,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.36,-0.65,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w=1.;\n                    \tColor.xy=iMouse.zw;\n                    }\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed=iTimeDelta;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=5.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n                vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Color.y+=0.02;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Color.y-=0.02;\n                Color.z=Color.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Color=vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) { //Last frame dir\n                Color=texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) { //Last frame position\n                Color=texture(iChannel0,vec2(3.5,0.5)*IRES);\n            }\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Direct light triangulation\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Update triangles\n    float tAngle = iTime*0.7;\n    vec2 tsc = vec2(sin(tAngle),cos(tAngle))*0.3;\n    Triangles[3] = Triangle(vec3(0.,0.6,0.5),vec3(-tsc.x,0.000,0.5-tsc.y),vec3(tsc.x,0.000,0.5+tsc.y),vec3(0.99));\n    //Rest\n    vec4 Output = vec4(-2.);\n    int TriangleIndex = int(floor(fragCoord.y));\n    if (TriangleIndex<NTris) {\n        vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n        //Triangle initialisation\n        Triangle CTri = Triangles[TriangleIndex];\n        vec3 CNor = normalize(cross(CTri.p2-CTri.p0,CTri.p1-CTri.p0));\n        if (dot(CNor,SunDir)!=0.) {\n            //Triangle faces SunDir and can generate sun-triangles\n            CNor = CNor*sign(dot(CNor,SunDir));\n            int OutputIndex = int(floor(fragCoord.x/3.));\n            Triangle ValidTris[20]; int NValidTris = 0;\n            Triangle Sample; vec3 P0,P1,P2;\n            for (int i=0; i<int(NTris); i++) {\n                //For all geometry that might occlude the current triangle\n                if (i==TriangleIndex) continue;\n                Sample = Triangles[i];\n                //Validity check\n                \n                //*\n                //Skips clipping -> is wrong but works anyway???!?? (Idk what I'm doing)\n                if (i==0) continue;\n                ValidTris[NValidTris] = Sample;\n                NValidTris += 1;\n                //*/\n                \n                \n                /*\n                //Clipping\n                vec3 DotV = vec3(dot(CNor,Sample.p0-CTri.p0),dot(CNor,Sample.p1-CTri.p0),dot(CNor,Sample.p2-CTri.p0));\n                if (max(DotV.x,max(DotV.y,DotV.z))<=0.) {\n                    //Triangle is behind CTri\n                    continue;\n                } else if (min(DotV.x,min(DotV.y,DotV.z))>=0.) {\n                    //Triangle is completely in front of CTri\n                    ValidTris[NValidTris] = Sample;\n                    NValidTris += 1;\n                } else {\n                    //Horizon-clipping\n                    P0 = Sample.p0;\n                    P1 = Sample.p1;\n                    P2 = Sample.p2;\n                    float NFront = dot(vec3(1.),vec3(DotV.x>0.,DotV.y>0.,DotV.z>0.));\n                    if (NFront==1.) {\n                        //1 point in front of CTri\n                        if (DotV.x<0.) {\n                            if (DotV.y>0.) {\n                                P1=Sample.p0;\n                                P0=Sample.p1;\n                            } else {\n                                P2=Sample.p0;\n                                P0=Sample.p2;\n                            }\n                        }\n                        vec3 IP0 = P0+(P1-P0)*(-dot(P0-CTri.p0,CNor)/dot(P1-P0,CNor));\n                        vec3 IP1 = P0+(P2-P0)*(-dot(P0-CTri.p0,CNor)/dot(P2-P0,CNor));\n                        Sample = Triangle(P0,IP0,IP1,vec3(0.));\n                        ValidTris[NValidTris] = Sample;\n                        NValidTris += 1;\n                    } else if (NFront==2.) {\n                        //2 points in front of CTri\n                        if (DotV.x>0.) {\n                            if (DotV.y<0.) {\n                                P1 = Sample.p2;\n                                P2 = Sample.p1;\n                            }\n                        } else {\n                            P0 = Sample.p2;\n                            P1 = Sample.p1;\n                            P2 = Sample.p0;\n                        }\n                        vec3 IP0 = P0+(P2-P0)*(-dot(P0-CTri.p0,CNor)/dot(P2-P0,CNor));\n                        vec3 IP1 = P1+(P2-P1)*(-dot(P1-CTri.p0,CNor)/dot(P2-P1,CNor));\n                        Sample = Triangle(P0,IP0,P1,vec3(0.));\n                        ValidTris[NValidTris] = Sample;\n                        Sample = Triangle(P1,IP0,IP1,vec3(0.));\n                        ValidTris[NValidTris+1] = Sample;\n                        NValidTris += 2;\n                    }\n                }//*/\n            }\n            //Creation of 2D coordinate system\n            Triangle2 SunTris[NMaxSunTris]; Triangle2 STri; int NSunTris = 1;\n            float CTanLen = length(CTri.p1-CTri.p0);\n            vec3 CTan = (CTri.p1-CTri.p0)/CTanLen;\n            vec3 CBit = normalize(cross(CTan,CNor));\n            SunTris[0] = Triangle2(vec2(0.),vec2(CTanLen,0.),vec2(dot(CTri.p2-CTri.p0,CTan),dot(CTri.p2-CTri.p0,CBit)),1.);\n            //Triangulation from occlusion\n            vec2 pv0,pv1,pv2,tp0,tp1,tp2; vec3 pp0,pp1,pp2;\n            for (int i=0; i<NValidTris; i++) {\n                //For each clipped triangle\n                Sample = ValidTris[i];\n                pp0 = Sample.p0-SunDir*dot(Sample.p0-CTri.p0,CNor)/dot(SunDir,CNor);\n                pp1 = Sample.p1-SunDir*dot(Sample.p1-CTri.p0,CNor)/dot(SunDir,CNor);\n                pp2 = Sample.p2-SunDir*dot(Sample.p2-CTri.p0,CNor)/dot(SunDir,CNor);\n                pv0 = vec2(dot(pp0-CTri.p0,CTan),dot(pp0-CTri.p0,CBit));\n                pv1 = vec2(dot(pp1-CTri.p0,CTan),dot(pp1-CTri.p0,CBit));\n                pv2 = vec2(dot(pp2-CTri.p0,CTan),dot(pp2-CTri.p0,CBit));\n                int NSTtmp = NSunTris;\n                for (int sti=0; sti<NSTtmp; sti++) {\n                    //For each sun-triangle\n                    STri = SunTris[sti];\n                    if (STri.Sign<-1.5) continue; //Invalid\n                    //https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\n                        //The projected valid triangle clips the sun triangle\n                    int NPoints = 3;  int OutPoints = 3; tp0 = pv0; tp1 = pv1; tp2 = pv2;\n                    vec2 TPIn[6]; vec2 tpNor,tmpp0,cpp,cppPrev,cppIntersect; bool Modify = false;\n                    vec2 TPOut[6] = vec2[6](STri.p0,STri.p1,STri.p2,vec2(0.),vec2(0.),vec2(0.));\n                    for (int SH=0; SH<3; SH++) { //For every clip-line in the clipping triangle\n                        tpNor = tp0-tp1; tpNor = vec2(tpNor.y,-tpNor.x);\n                        tpNor *= sign(dot(tp2-tp0,tpNor));\n                        TPIn = TPOut;\n                        NPoints = OutPoints;\n                        TPOut = vec2[6](vec2(0.),vec2(0.),vec2(0.),vec2(0.),vec2(0.),vec2(0.));\n                        OutPoints = 0;\n                        cppPrev = TPIn[NPoints-1];\n                        for (int ci=0; ci<NPoints; ci++) { //For every point in the subject polygon\n                            cpp = TPIn[ci];\n                            cppIntersect = cpp-(cpp-cppPrev)*dot(cpp-tp0,tpNor)/dot(cpp-cppPrev,tpNor);\n                            if (dot(cpp-cppPrev,tpNor)==0.) {\n                                if (dot(cpp-tp0,tpNor)>=0.) {\n                                    TPOut[OutPoints] = cpp;\n                                    OutPoints += 1;\n                                }\n                            } else if (dot(cpp-tp0,tpNor)>=0.) {\n                                if (dot(cppPrev-tp0,tpNor)<0.) {\n                                    TPOut[OutPoints] = cppIntersect;\n                                    OutPoints += 1;\n                                    Modify = true;\n                                }\n                                TPOut[OutPoints] = cpp;\n                                OutPoints += 1;\n                            } else if (dot(cppPrev-tp0,tpNor)>=0.) {\n                                TPOut[OutPoints] = cppIntersect;\n                                OutPoints += 1;\n                                Modify = true;\n                            }\n                            cppPrev = cpp;\n                        }\n                        tmpp0 = tp0;\n                        tp0 = tp1;\n                        tp1 = tp2;\n                        tp2 = tmpp0;\n                    }\n                    //Occluded geometry has the opposite sign of the subject\n                    if (OutPoints>=3) {\n                        //We have an intersection\n                        if (!Modify) {\n                            //The sun-triangle is not modified -> fully occluded and deleted\n                            SunTris[sti].Sign = -2.;\n                        } else {\n                            //1 or more triangles\n                            tp0 = TPOut[0];\n                            tp1 = TPOut[1];\n                            for (int it=2; it<OutPoints; it++) {\n                                SunTris[NSunTris] = Triangle2(tp0,tp1,TPOut[it],-STri.Sign);\n                                NSunTris += 1;\n                                tp1 = TPOut[it];\n                            }\n                        }\n                    }\n                }\n            }\n            //Output\n            if (OutputIndex<NSunTris) {\n                //Måste iterera över SunTris eftersom vissa trianglar är invalid\n                int csOutIndex = 0;\n                for (int sti=0; sti<NSunTris; sti++) {\n                    //For each sun-triangle\n                    STri = SunTris[sti];\n                    if (STri.Sign<-1.5) continue; //Invalid\n                    if (OutputIndex == csOutIndex) {\n                        if (mod(fragCoord.x,3.)<1.)\n                            Output = vec4(CTri.p0+STri.p0.x*CTan+STri.p0.y*CBit,1.);\n                        else if (mod(fragCoord.x,3.)<2.)\n                            Output = vec4(CTri.p0+STri.p1.x*CTan+STri.p1.y*CBit,STri.Sign);\n                        else\n                            Output = vec4(CTri.p0+STri.p2.x*CTan+STri.p2.y*CBit,1.);\n                        break;\n                    }\n                    csOutIndex += 1;\n                }\n            }\n        }\n    }\n    fragColor = Output;\n}\n\n//DEBUG - Image\n/* //Render sun-triangles\nfloat dbgt = 10000.;\nfloat dbgN = 0.;\nif (texelFetch(iChannel2,ivec2(76,2),0).x>0.) { //L button\n    vec4 st0,st1,st2; vec3 stn; float std;\n    for (float si=0.; si<iResolution.x; si++) {\n        st0 = texture(iChannel1,vec2(si*3.+0.5,0.5)*IRES);\n        if (st0.w<-1.5) break;\n        dbgN += 1.;\n        st1 = texture(iChannel1,vec2(si*3.+1.5,0.5)*IRES);\n        st2 = texture(iChannel1,vec2(si*3.+2.5,0.5)*IRES);\n        float dh = si*0.001; st0.y += dh; st1.y += dh; st2.y += dh;\n        if (TriangleA(Pos,Dir,st0.xyz,st1.xyz,st2.xyz,std,stn)) {\n            if (std<dbgt) {\n                dbgt = std;\n                Color = vec3(max(0.,st1.w));\n            }\n        }\n    }\n    //if (dbgN>-49.5) Color.y = 1.;\n}\n//*/\n//if (texture(iChannel1,(floor(fragCoord*0.5)+0.5)*IRES).w>-1.5)\n//    Color=texture(iChannel1,(floor(fragCoord*0.5)+0.5)*IRES).xyz; //Buffer B","name":"Buffer B","description":"","type":"buffer"}]}