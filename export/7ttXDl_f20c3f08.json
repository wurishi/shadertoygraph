{"ver":"0.1","info":{"id":"7ttXDl","date":"1640031426","viewed":379,"name":"Sunset sky gradient v2","username":"vegardno","description":"I tried to model a sunset based on values from a photograph. Now animated. skybox() is intended as a drop-in replacement for textureCube().\n\nThanks to Phillip Trudeau for suggesting the sin(1/x) formula for the gradients!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sunset","gradient","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml\nmat3 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat3(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c\n    );\n}\n\nvec3 skybox(vec3 dir, float time_of_day)\n{\n    float t = (time_of_day + 4.) * radians(360. / 24.);\n\n    vec3 sun_pos = normalize(vec3(0., -sin(t), cos(t)));\n\n    vec3 col = vec3(0.);\n    \n    vec3 p_sunset_dark[4] = vec3[4](\n        vec3(0.3720705374951474, 0.3037080684557225, 0.26548632969565816),\n        vec3(0.446163834012046, 0.39405890487346595, 0.425676737673072),\n        vec3(0.16514907579431481, 0.40461292460006665, 0.8799446225003938),\n        vec3(-7.057075230154481e-17, -0.08647963850488945, -0.269042973306185)\n    );\n\n    vec3 p_sunset_bright[4] = vec3[4](\n        vec3( 0.38976745480184677, 0.31560358280318124,  0.27932656874),\n        vec3( 1.2874522895367628,  1.0100154283349794,   0.862325457544),\n        vec3( 0.12605043174959588, 0.23134451619328716,  0.526179948359),\n        vec3(-0.0929868539256387, -0.07334463258550537, -0.192877259333)\n    );\n\n    vec3 p_day[4] = vec3[4](\n        vec3(0.051010496458305694, 0.09758747153634058, 0.14233364823001612),\n        vec3(0.7216045769411271, 0.8130766810405122, 0.9907063181559062),\n        vec3(0.23738746590578705, 0.6037047603190588, 1.279274525377467),\n        vec3(-4.834172446370963e-16, 0.1354589259524697, -1.4694301190050114e-15)\n    );\n\n    /* Sky */\n    {\n        float brightness_a = acos(dot(dir, sun_pos));\n        float brightness_d = 1.5 * smoothstep(radians(80.), radians(0.), brightness_a) - .5;\n    \n        vec3 p_sunset[4] = vec3[4](\n            mix(p_sunset_dark[0], p_sunset_bright[0], brightness_d),\n            mix(p_sunset_dark[1], p_sunset_bright[1], brightness_d),\n            mix(p_sunset_dark[2], p_sunset_bright[2], brightness_d),\n            mix(p_sunset_dark[3], p_sunset_bright[3], brightness_d)\n        );\n\n        float sun_a = acos(dot(sun_pos, vec3(0., 1., 0.)));\n        float sun_d = smoothstep(radians(100.), radians(60.), sun_a);\n\n        vec3 a = mix(p_sunset[0], p_day[0], sun_d);\n        vec3 b = mix(p_sunset[1], p_day[1], sun_d);\n        vec3 c = mix(p_sunset[2], p_day[2], sun_d);\n        vec3 d = mix(p_sunset[3], p_day[3], sun_d);\n\n        float sky_a = acos(dot(dir, vec3(0., 1., 0.)));\n        float sky_d = smoothstep(radians(90.), radians(60.), sky_a);\n\n        // sin(1/x) suggested by Phillip Trudeau\n        col += (b - d) * sin(1. / (vec3(sky_d) / c + 2. / radians(180.) - a)) + d;\n    }\n\n    /* Sun */\n    float sun_a = acos(dot(sun_pos, dir));\n    vec3 sun_col = .01 * vec3(1., .95, .95) / sun_a;\n    col = max(col + .5 * sun_col, sun_col);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time_of_day = mod(iTime, 24.);\n\n    vec3 dir = rayDirection(80., iResolution.xy, fragCoord);\n    \n    // look up\n    dir = rotate(radians(25.), vec3(1., 0., 0.)) * dir;\n\n    // rotate sideways\n    dir = rotate((time_of_day - 8.) * radians(360.) / 24., vec3(0., 1., 0.)) * dir;\n\n    // this ought to be normalized already but isn't, for some reason I don't understand\n    // (maybe some kind of float inaccuracy in rotate()?)\n    dir = normalize(dir);\n\n    vec3 col = skybox(dir, time_of_day);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}