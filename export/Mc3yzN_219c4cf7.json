{"ver":"0.1","info":{"id":"Mc3yzN","date":"1730313124","viewed":30,"name":"Graphic Computation - Project 2","username":"Dduarte","description":"Project 2 - Trying to make diferent randoms lavalamps styles ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nfloat circle(vec2 uv, vec2 center, float r, float k)\n{\n    return smoothstep(r + k, r, length(uv - center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Configurando o tamanho dos blocos\n    float blockSize = 5.0;\n    vec2 blockUV = floor(uv * blockSize) / blockSize;  // Coordenadas de blocos\n\n    // Gerando um deslocamento pseudo-aleatório único para cada bloco\n    float blockNoiseX = hash(blockUV + vec2(1.0, 0.0));\n    float blockNoiseY = hash(blockUV + vec2(0.0, 1.0));\n\n    uv = fract(uv * blockSize) - 0.5;\n\n    float r = 0.02;\n    float k = 0.2;\n    float num = 3.0;\n    float circ = 0.0;\n    vec3 color = vec3(0.0);\n\n    for (float i = 0.0; i < num; i++)\n    {\n        // Trajetória aleatória usando combinações de sin e cos para variações não circulares\n        vec2 randomTrajectory = vec2(\n            sin(iTime * (1.5 + blockNoiseX * i)) * 0.1 * (blockNoiseY + 1.0),\n            cos(iTime * (2.3 + blockNoiseY * i)) * 0.1 * (blockNoiseX + 1.0)\n        );\n\n        // Posição central do círculo com trajetória aleatória\n        vec2 center = randomTrajectory;\n\n        // Adicionando o círculo com a trajetória modificada\n        float circleValue = circle(uv, center, 0.05, 0.1);\n\n        // Variação de cor para cada círculo\n        float hue = hash(vec2(i, iTime/50000000.0)); // Usa um valor único baseado em 'i' e 'iTime'\n        vec3 circleColor = vec3(\n            sin(6.28318 * hue),\n            0.5 + 0.5 * cos(6.28318 * hue + 1.0),\n            sin(6.28318 * hue + 2.0)\n        );\n\n        color += circleColor * circleValue; // Multiplicando o valor do círculo pela cor\n        circ += circleValue;\n    }\n\n    fragColor = vec4(color * smoothstep(0.2, 0.25, circ), 1.0);\n}","name":"Image","description":"","type":"image"}]}