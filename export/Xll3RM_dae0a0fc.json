{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//#define MORE_MOUSE_MOVEMENT\n//#define RANDOM_BALL_OFFSETS\n\n// Gets the normal vector along which to trace a ray for the current pixel.\nvec3 lens(vec2 fragCoord) {\n    return normalize(vec3(fragCoord.xy / iResolution.xy - 0.5, 0.3));\n}\n\n// Terrain.\nfloat terrainWave(vec3 at, float xzScale, float yScale) {\n    return (sin(at.x * xzScale) + cos(at.z * xzScale)) * yScale;\n}\n\nfloat terrain(vec3 at) {\n    return \n        terrainWave(at, 0.01, 32.0)\n        + terrainWave(at, 0.1, 2.0)\n        -abs(sin((at.x/40.0) + sin(at.z / 100.0) * 1.0)) * 50.0;\n}\n\nfloat terrainDetailed(vec3 at) {\n    return terrain(at);\n}\n\n// Shapes.\nstruct shapeResult {\n    float distance;\n    int materialId;\n};\n    \nshapeResult sphere(vec3 origin, float radius, int materialId, vec3 at) {\n    return shapeResult(distance(origin, at) - radius, materialId);\n}\n\nshapeResult plane(float origin, int materialId, float at) {\n    return shapeResult(at - origin, materialId);\n}\n\n// Shape CSG.\nshapeResult add(shapeResult left, shapeResult right) {\n    return shapeResult(left.distance < right.distance ? left.distance : right.distance, left.distance < right.distance ? left.materialId : right.materialId);\n}\n\n// Scene analysis.\n#define MATERIAL_SKY 0\n#define MATERIAL_SAND 1\n#define MATERIAL_MIRROR 2\n\nshapeResult scene(vec3 at) {\n    return add(\n        sphere(vec3(30.0, 30.0, 30.0)\n\t\t\t\t#ifdef RANDOM_BALL_OFFSETS\n\t\t\t\t\t+ sin(floor(at.x / 60.0) * 2.0 + floor(at.y / 60.0) * 3.1 + floor(at.z / 60.0) * 4.6) * 16.0\n\t\t\t\t#endif\n\t\t\t, 5.0, MATERIAL_MIRROR, mod(at, 60.0)), \n        plane(terrainDetailed(at), MATERIAL_SAND, at.y)\n    );\n}\n\n#define NORMAL_OFFSET vec2(0.01, 0.0)\nvec3 sceneNormal(vec3 at) {\n    return normalize(vec3(\n        scene(at + NORMAL_OFFSET.xyy).distance - scene(at - NORMAL_OFFSET.xyy).distance,\n        scene(at + NORMAL_OFFSET.yxy).distance - scene(at - NORMAL_OFFSET.yxy).distance,\n        scene(at + NORMAL_OFFSET.yyx).distance - scene(at - NORMAL_OFFSET.yyx).distance\n    ));\n}\n\nstruct raymarchResult {\n    vec3 location;\n    int materialId;\n};\n\nraymarchResult raymarch(vec3 at, vec3 normal) {\n    for(int iteration = 0; iteration < 128; iteration++) {\n        shapeResult sam = scene(at);\n        if(sam.distance < 0.1)\n            return raymarchResult(at, sam.materialId);\n        at += normal * sam.distance * 0.5;\n    }\n    return raymarchResult(vec3(0.0), MATERIAL_SKY);\n}\n\nraymarchResult raymarchFast(vec3 at, vec3 normal) {\n    for(int iteration = 0; iteration < 24; iteration++) {\n        shapeResult sam = scene(at);\n        if(sam.distance < 0.1)\n            return raymarchResult(at, sam.materialId);\n        at += normal * sam.distance;\n    }\n    return raymarchResult(vec3(0.0), MATERIAL_SKY);\n}\n\n// Materials.\n\n\n// Computes the sky color at a given normal.\nvec3 sky(vec3 normal) {\n    if(normal.y < -0.1) return vec3(0.0);\n    // Sun normal.\n    float sunBlend = dot(normal, normalize(vec3(1.0, 2.0, 2.0))) * 0.5 + 0.5;\n    return mix(\n        mix(\n            // Horizon color.\n            vec3(0.4, 0.5, 0.7),\n            mix(\n                // Sky color.\n                vec3(0.0, 0.0, 1.0), \n                vec3(0.0, 0.0, 0.1),\n            \tsunBlend\n            ),\n            normal.y\n        ), \n        // Sun color.\n        vec3(2.0, 2.0, 1.0),\n        pow(\n \t\t\tsunBlend,\n            // Sun size.\n            32.0\n        )\n    );\n}\n\nfloat occlusion(vec3 at, vec3 normal, float radius) {\n    return max(scene(at + normal * radius).distance / radius, 0.0);\n}\n\nvec3 diffuse(vec3 at, vec3 color) {\n    vec3 normal = sceneNormal(at);\n    vec3 light = sky(normal) * occlusion(at, normal, 8.0);\n    return light * color;\n}\n\nvec3 sand(vec3 at) {\n    return diffuse(at, vec3(0.9, 0.4, 0.01));\n}\n\nvec3 secondary(vec3 at, vec3 normal) {\n    raymarchResult sam = raymarchFast(at, normal);\n    if(sam.materialId == MATERIAL_SAND) {\n        return sand(sam.location);\n    } else if(sam.materialId == MATERIAL_MIRROR) {\n        vec3 refl = sceneNormal(sam.location);\n        return sky(reflect(normal, refl)) * occlusion(sam.location, refl, 8.0);\n    }    \n    return sky(normal);\n}\n\nvec3 mirror(vec3 at, vec3 inboundNormal) {\n    vec3 normal = reflect(inboundNormal, sceneNormal(at));\n    return secondary(at + normal * 0.1, normal);\n}\n\nvec3 primary(vec3 at, vec3 normal) {\n    raymarchResult sam = raymarch(at, normal);\n    if(sam.materialId == MATERIAL_SAND) {\n        return sand(sam.location);\n    } else if(sam.materialId == MATERIAL_MIRROR) {\n        return mirror(sam.location, normal);\n    }    \n    return sky(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLocation = vec3(0.0, 50.0, -2.0) + vec3((iMouse.xy / iResolution.xy) * \n\t\t#ifdef MORE_MOUSE_MOVEMENT\n\t\t\t72.0, \n\t\t#else\n\t\t\t8.0,\n\t\t#endif\n\t\t-50.0 + iTime * 5.0);\n    vec3 cameraNormal = lens(fragCoord);\n\tfragColor = vec4(pow(primary(cameraLocation, cameraNormal), vec3(1.0 / 2.2)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xll3RM","date":"1420059581","viewed":435,"name":"Marching the Desert","username":"jameswilddev","description":"A scene of infinite rolling sand dunes.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingdesertsandskysceneinfinite"],"hasliked":0,"parentid":"","parentname":""}}