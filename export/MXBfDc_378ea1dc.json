{"ver":"0.1","info":{"id":"MXBfDc","date":"1730012706","viewed":25,"name":"Sand Dunes Noise","username":"zleong","description":"sand dune shader used for game","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = 1.0 - 6.0 * pow(distX, 5.f) + 15.0 * pow(distX, 4.f) - 10.0 * pow(distX, 3.f);\n    float tY = 1.0 - 6.0 * pow(distY, 5.f) + 15.0 * pow(distY, 4.f) - 10.0 * pow(distY, 3.f);\n    // Get the random vector for the grid point\n    vec2 gradient = 2.f * random2(gridPoint) - vec2(1.f);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\nfloat perlinNoise(vec2 uv) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pn = 1.f-abs(perlinNoise(fragCoord/100.0+iTime));\n\n    vec3 col = vec3(pn);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}