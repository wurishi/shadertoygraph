{"ver":"0.1","info":{"id":"3sVXDh","date":"1573930001","viewed":1039,"name":"Voxel Sprite Mario","username":"fizzer","description":"Mario fan-art, made of isometric voxel sprites looking a bit like lego bricks.\nClick and drag to rotate. See shader source code for details.\nSuper Mario is © Nintendo","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["voxel","isometric","nintendo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mario fan-art, made of isometric voxel sprites looking a bit like lego bricks. Click and drag to rotate.\n// Super Mario is © Nintendo\n//\n// An individual brick is rendered in Buffer A using the current camera orientation, then\n// that rendered buffer is used in the final image as a sprite texture. The sprites are rendered\n// from front-to-back in a 3D grid, the sorting is done by inverting voxel coordinates according to\n// the signs of the camera direction vector coordinates.\n//\n// The voxel data is stored in a column-major format, so that voxels are pre-sorted by column and each column can move independently\n// of any other. This allows the building animation to work without breaking the sort order.\n//\n// The sprite texture stores diffuse light in the R channel, specular light in the G channel,\n// an M logo image in the B channel (only used on one brick in the hat), and a coverage alpha mask in the A channel.\n//\n// The sprites are carefully composited so that no over-brightening or darkening occurs when they overlap.\n//\n// The voxel data itself was converted by my own Blender script from this source model:\n//\thttps://3dwarehouse.sketchup.com/model/u708722ae-48d2-442b-9f34-52e56deddde6/3D-8-Bit-Mario?hl=en&login=true\n// The model conversion itself was just as difficult as writing this whole shader...\n//\n\n// 16x10x16 voxels, 2 bits per voxel (3 colours and solid/empty)\nconst uint voxelData[160] = uint[160](0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x2800U, 0x2b00U, 0xfc0U, 0xf00U,\n0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x50U, 0x2050U, 0x2850U, 0xa800U, 0xa800U, 0xa800U, 0xab00U, 0x2fc0U, 0xf00U,\n0x0U, 0x0U, 0x0U, 0x0U, 0x80000U, 0x80000U, 0x43c0054U, 0x4ec0554U, 0x6ac2514U, 0x2ac8254U, 0xf08854U, 0xa820U, 0xa828U, 0xa828U, 0x2000U, 0x0U,\n0x0U, 0x0U, 0x0U, 0x80000U, 0x280000U, 0x43f0054U, 0x13f30754U, 0x13031014U, 0x10034005U, 0x40c4005U, 0x2885555U, 0x280054U, 0x28U, 0x28U, 0xaU, 0x0U,\n0x0U, 0x0U, 0x380000U, 0x43b0000U, 0x43f0550U, 0x1ab32554U, 0x1000a014U, 0x10008014U, 0x10000005U, 0x10038005U, 0x6082505U, 0xa80155U, 0x28U, 0x28U, 0xaU, 0x0U,\n0xa80U, 0x300080U, 0x4380040U, 0x4fb0350U, 0x7f32410U, 0x1bf08014U, 0x10000014U, 0x10000014U, 0x10000014U, 0x10038014U, 0x6082554U, 0xa80054U, 0x0U, 0x0U, 0x0U, 0x0U,\n0x2aa0U, 0xf00002a0U, 0xf0380150U, 0x42b1510U, 0x4285410U, 0x1abc0014U, 0x10300014U, 0x10000014U, 0x10000014U, 0x100f8550U, 0x6882550U, 0xa80000U, 0x0U, 0x0U, 0x0U, 0x0U,\n0xfe800a80U, 0xfea80080U, 0xfeaa0040U, 0xaa9550U, 0x2a9550U, 0x4380154U, 0x1bfc0554U, 0x1bff5554U, 0x1aefa550U, 0x6bc2540U, 0x2a80000U, 0x280000U, 0x0U, 0x0U, 0x0U, 0x0U,\n0xfea00000U, 0xfea80000U, 0xfeaa0000U, 0xaa8040U, 0xaa550U, 0xaa950U, 0x42da554U, 0x4ec5554U, 0x6ac0550U, 0x2ac0000U, 0xf00000U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U,\n0x0U, 0x2a00000U, 0x2a80000U, 0x2a0000U, 0xa8000U, 0x2a000U, 0x8000U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U, 0x0U\n);\n\nconst vec3 pallette[4] = vec3[4]( vec3(0), vec3(.7,.005,.005), vec3(.2,.08,0.005), vec3(1.,.5,.3) * 1.2 );\n\nconst float alpha_threshold = .01;\n\nmat3 camera_to_world;\nmat3 world_to_camera;\nvec3 camera_position;\nvec2 frag_uv;\n\nvec4 sprite2D(vec2 p)\n{\n    if(abs(p.x) >= .5 / cam_zoom || abs(p.y) > 1. / cam_zoom)\n        return vec4(0);\n    return textureLod(iChannel0, p.xy * .5 + .5, 0.);\n}\n\nfloat signNoZero(float x)\n{\n    return (x < 0.) ? -1. : +1.;\n}\n\nvec3 signNoZero(vec3 x)\n{\n    return vec3(signNoZero(x.x), signNoZero(x.y), signNoZero(x.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mouse = vec3(iMouse.xy / iResolution.xy * 2. - 1., iMouse.z);\n    \n    float time = iTime + texelFetch(iChannel2, ivec2(fragCoord.xy) & 1023, 0).r / 60.;\n    \n    camera_to_world = cameraOrientation(time, mouse);\n    world_to_camera = transpose(camera_to_world);\n    camera_position = cameraPosition(time, mouse);\n    \n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    frag_uv = uv;\n\n    uv.x *= iResolution.x / iResolution.y;    \n\n    vec3 rd = vec3(0, 0, -1.);\n    vec3 ro = vec3(uv * cam_zoom, 0.);\n    \n    mat3 camrot = cameraOrientation(time, mouse);\n    \n    ro = camrot * ro;\n    rd = camrot * rd;\n    \n    ro += cameraPosition(time, mouse);\n\n    // Do bounding box test.\n    \n    vec2 bi = box(ro, rd, -brickDims * 8.1, +brickDims * 8.1 + vec3(0, 2, 0));\n    \n    vec4 col = vec4(mix(vec3(.8), vec3(.85,.59,.01), .97), 0.);\n    \n    if(bi.x < bi.y)\n    {\n        vec3 sns = -signNoZero(camera_to_world[2]);\n\n\t\tvec2 u = world_to_camera[0].xy * vec2(iResolution.y / iResolution.x, 1.) / cam_zoom * brickDims.x;\n\t\tvec2 v = world_to_camera[1].xy * vec2(iResolution.y / iResolution.x, 1.) / cam_zoom * brickDims.y;\n\t\tvec2 w = world_to_camera[2].xy * vec2(iResolution.y / iResolution.x, 1.) / cam_zoom * brickDims.z;\n\n        float alpha = 1.;\n        vec3 mario_col = vec3(0);\n        \n        // Composite the brick sprites in front-to-back order.\n        \n        for(int z = 9; z >= 0; --z)\n        {\n            int z2 = (sns.z < 0.) ? z : (9 - z);\n            for(int x = 15; x >= 0; --x)\n            {                \n                int x2 = (sns.x < 0.) ? x : (15 - x);\n                           \n                // Fetch a whole column of voxels. There are 16 voxels per column, 2 bits per voxel.\n                uint voxel_pack = voxelData[z2 * 16 + x2];\n\n                if(voxel_pack != 0U)\n                    for(int y = 15; y >= 0; --y)\n                    {\n                \t\tint y2 = (sns.y < 0.) ? y : (15 - y);\n                    \n                        vec3 q = vec3(float(x) - 15. / 2., float(y) - 15. / 2., float(z) - 9. / 2.) * sns;\n                        uint vx = (voxel_pack >> (y2 * 2)) & 3U;\n                        if(vx != 0U)\n                        {\n                            // Falling bricks animation\n                            q.y += -20. * (1. - smoothstep(0., 1., time * 1. - q.x * .059 - q.z * 1.75 - 8.7 + q.y * 1.3));\n\n                            if(q.y > -10.)\n                            {\n                                vec2 p = u * q.x + v * q.y + w * q.z + frag_uv;                        \n                                vec4 s = sprite2D(p);\n                                \n                                // Make the bricks a little bit translucent, and also make them fade when falling.\n                                s.a *= .87 * (1. - smoothstep(-9., -10., q.y));\n\n                                vec3 pc = pallette[vx & 3U];\n                                \n                                // Special hard-coded hat brick with the \"M\" logo on it.\n                                if(x2 == 5 && y2 == 14 && z2 == 5)\n                                \tpc = mix(pc, vec3(1), s.b);\n                                \n                                vec3 sc = pc * s.r;\n\n                                sc += s.g * vec3(1) * mix(pc, vec3(1.), .9);\n                                \n                                // Perform compositing operation.\n                                mario_col += sc * alpha * s.a;\n                                alpha *= 1. - s.a;\n                            }\n                        }\n                        \n                        if(alpha < alpha_threshold)\n                     \t\tbreak;\n                    }\n                if(alpha < alpha_threshold)\n                    break;\n            }\n            if(alpha < alpha_threshold)\n                break;\n        }\n\n        mario_col *= 1.05;\n        \n        // Composite with background.\n        col.rgb = mario_col + col.rgb * alpha;\n    }\n\n    // Tonemap.\n    col.rgb /= (col.rgb + 2.) / 2.9;\n    \n    // Clamp + Gamma.\n    fragColor = vec4(pow(clamp(col.rgb, 0., 1.), vec3(1. / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Brick dimensions.\nconst vec3 brickDims = vec3(1, .9, 1);\nconst float studHeight = .07;\nconst float bevel = .014;\nconst float studRadius = .15;\nconst float cam_zoom = 9.;\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nfloat sdRoundBox(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat sdRoundRect(vec2 p, vec2 s)\n{\n    return length(max(abs(p) - s, 0.));\n}\n\nmat3 cameraOrientation(float time, vec3 mouse)\n{\n    if(mouse.z > .5)\n    \treturn rotY(2.8 + mouse.x * 2.) * rotX(0. + mouse.y * 2.);\n    else\n\t    return rotY(-time / 4. + 5.5 + 3.14) * rotX(-.2);\n}\n\nvec3 cameraPosition(float time, vec3 mouse)\n{\n    vec3 pos = vec3(0, 0, 2.);\n    return cameraOrientation(time, mouse) * pos;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Single brick distance field.\nfloat brickDist(vec3 p)\n{\n    float d = sdRoundBox(p + vec3(0, studHeight, 0), (brickDims - vec3(0, studHeight * 2., 0)) / 2. - bevel) - bevel;\n    p.xz = abs(p.xz);\n    \n    vec2 studcoord = vec2(length(p.xz - .25), p.y - (brickDims.y / 2. - studHeight * 2.));\n    \n    d = min(d, sdRoundRect(studcoord, vec2(studRadius, studHeight * 2. - bevel)) - bevel);\n    \n    float gutter = max(studcoord.x - studRadius - bevel * 2., abs(studcoord.y) - bevel);\n    \n    gutter = max(gutter, -(length(vec2(abs(studcoord.x) - studRadius - bevel * 2., studcoord.y - bevel)) - bevel));\n    \n    d = min(d, gutter);\n    \n    studcoord = vec2(length(p.xz - .25), p.y + (brickDims.y / 2.));\n        \n    d = max(d, -(sdRoundRect(studcoord, vec2(studRadius * 1.1, studHeight * 5. - bevel)) - bevel));\n    \n    return d;\n}\n\nvec3 brickNormal(vec3 p)\n{\n    vec3 e = vec3(1e-2, 0, 0);\n    float d = brickDist(p);\n    return normalize(vec3(brickDist(p + e.xyy) - d, brickDist(p + e.yxy) - d, brickDist(p + e.yyx) - d));\n}\n\nfloat sdSegment(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ab = b - a;\n    return distance(p, mix(a, b, clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.)));\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    if(abs(uv.x) > .1 || abs(uv.y) > .1)\n        return vec4(0);\n    \n    vec3 rd = vec3(0, 0, -1.);\n    vec3 ro = vec3(uv * cam_zoom, 0.);\n    \n    vec3 mouse = vec3(iMouse.xy / iResolution.xy * 2. - 1., iMouse.z);\n    \n    mat3 camera_to_world = cameraOrientation(iTime, mouse);\n    mat3 world_to_camera = transpose(camera_to_world);\n\n    ro = camera_to_world * ro;\n    rd = camera_to_world * rd;\n    \n    ro += cameraPosition(iTime, mouse);\n\n    vec2 bi = box(ro, rd, -brickDims / 2., +brickDims / 2.);\n    \n    vec4 col = vec4(0);\n    \n    if(bi.x < bi.y)\n    {\n        float t = bi.x;\n        \n        // SDF raymarching loop.\n        \n        for(int i = 0; i < 50; ++i)\n        {\n            float d = brickDist(ro + rd * t);\n            if(abs(d) < 1e-3)\n                break;\n            t += d;\n            if(t >= bi.y)\n                break;\n        }\n        \n        vec3 rp = ro + rd * t;\n        \n        vec3 n = brickNormal(rp);\n        \n        if(t < bi.y)\n        {\n            // Apply lighting.\n            \n            float fr = mix(.09, .9, pow(clamp(1. - dot(-rd, n), 0., 1.), 3.));\n            \n            vec3 ld = normalize(vec3(-1, 0.2, -5));\n            \n            col.r = (.2 + .8 * max(0., .5 + .5 * dot(n, ld))) * (1. - fr);\n            col.g = pow(max(0., clamp(dot(reflect(rd, n), ld), 0., 1.)), 8.)* fr + pow(fr, 4.) / 3.;\n            col.a = 1.;\n            \n            col.b = step(length(rp.zy - vec2(0., -studHeight)), .3);\n            \n            vec2 uv = vec2(abs(rp.z), rp.y + studHeight);\n            \n            // \"M\" Logo for the hat.\n            \n            vec2 lp0 = vec2(0, -.08);\n            vec2 lp1 = vec2(.12, .11);\n            vec2 lp2 = vec2(.15, -.11);\n            \n            float Mdist = min(sdSegment(lp0, lp1, uv), sdSegment(lp1, lp2, uv));\n                              \n\t\t\tcol.b *= step(.055, Mdist);\n\n            // Self-shadowing.\n            \n            float b = .2;\n\t\t    float d = sdRoundBox(rp + vec3(0, studHeight, 0), (brickDims - vec3(0, studHeight * 2., 0)) / 2. - b) - b;\n\n            if(abs(rp.x) < .45 && abs(rp.z) < .45 && rp.y < 0.)\n            \tcol.r *= clamp(-rp.y * 2. + .4, 0., 1.);\n            \n            col.r += smoothstep(-.05, 0.3, d) / 3.;\n        }\n        else\n        {\n            col = vec4(0.);\n        }        \n    }\n    else\n    {\n    }\n\n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    \n    // Anti-aliasing sample loop.\n\tfor(int y = 0; y < 5; ++y)\n    {\n        for(int x = 0; x < 5; ++x)\n        {\n            col += render(fragCoord + (vec2(x, y) - 2.) / 5. * 1.3);\n        }\n    }\n    \n    fragColor = col / 25.;\n    \n    // Un-multiply the alpha, because primary ray occlusion term is already applied implicitly.\n    if(fragColor.a > 0.001)\n    \tfragColor.rgb /= fragColor.a;\n}","name":"Buffer A","description":"","type":"buffer"}]}