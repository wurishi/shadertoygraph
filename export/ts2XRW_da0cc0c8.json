{"ver":"0.1","info":{"id":"ts2XRW","date":"1553127566","viewed":339,"name":"Jump flood particles","username":"rory618","description":"Using just jump flood with a list of two nearset points to draw tons of particles that have an arbitrary SDF","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["particles","sort","greyscale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Deterministic particle sorting algorithm\n//using 7 stage 3x3 strided sorting stages split over 2 frames, in total just 36 or 27 calls to texelFetch per frame\n//Non recurrent, each frame is computed independent of the last, particles can jump around quickly with no adverse effects\n//Running at half speed, takes two frames to draw the image. I'm starting to like this approach, d 30 fps on shadertoy\n//feels a lot more than twice as powerful.\n\n//Still no gaurentee that a pixel doesnt come up empty when there is a particle there, but chances of that happening\n//are reduced compared to previous approaches\n\n//See https://www.shadertoy.com/view/XsjyRm for another use of strided sort\n\n//No spatial decorrelation, sorting directly in image space to make for easy drawing of big particles.\n\n\n//Rendering in buf A\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    #define T(a,b) texelFetch(iChannel0, ivec2(I)+ivec2(a,b),0).wwww\n    //Soften with a little blur over space\n    O=T(0,0)/2.+(T(1,0)+T(0,1)+T(-1,0)+T(0,-1))/12.+(T(1,1)+T(1,-1)+T(-1,-1)+T(-1,1))/24.;\n    O=O*.15;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Simple newtonian particles\n//Use O.w for render pass\n\n//Uncomment to see the decorrelated image that is getting rendered\n//#define show_decorrelated\n\n//Drawing a particle\n//Need another pass or bigger output pass to draw bigger particles\n//For now just light up the pixel it lands in\n\n\nvoid splat(inout float O, vec2 I, vec2 ip, vec2 p){\n    \n    //O = min(O,vec4(length(p-I))/3.);\n    float d2 = score(ip,p,R);//max(0.,dot2(ip-p)-12.);\n    O += .5*max(1.-d2,0.);\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/R.xy;\n    vec2 r = rand2(IHash3(iFrame,I.x,I.y));\n    O = texture(iChannel0,uv);\n    float Owp = O.w;\n    O.w=0.;\n    vec2 p = O.xy;\n    vec2 v = umpackVec2(O.z);\n    if(iFrame<3 || texelFetch(iChannel3,ivec2(32,1),0).x>.5){\n        p = I;\n        v=vec2(0);\n    }\n    v /= 1.003;\n    \n    //Add some brownian motion to seperate the particles when they all get stuck together\n    p += randn(r)/1e4;\n    p += v/2.;\n    \n    //also add an interesting force\n    vec2 k = vec2(cos(10.*float(iFrame)/60.),sin(10.*float(iFrame)/60.))*R.y/7.+R.xy/2.;\n    vec2 d = (k-p);\n    v += sin(-float(iFrame)/60.*6.5+.6*pow(dot2(d),.6)/9.)*3.*d/(pow(length(d),1.7));\n    v *= 1.-exp(-.1*length(d));\n    \n    if(iMouse.z > 1.){\n        vec2 d = (iMouse.xy-p);\n        v += 4.*d/(pow(length(d),1.7));\n        v *= 1.-exp(-.1*length(d));\n    }\n    //bounce off the walls\n    if(p.x<0.)  {v.x =  abs(v.x); p.x=-p.x;}\n    if(p.y<0.)  {v.y =  abs(v.y); p.y=-p.y;}\n    if(p.x>R.x) {v.x = -abs(v.x); p.x=R.x*2.-p.x;}\n    if(p.y>R.y) {v.y = -abs(v.y); p.y=R.y*2.-p.y;}\n    \n    O.xy = p;\n    O.z = packVec2(v);\n    \n    vec2 ip = forward_mapping(I,iR.x,iR.y,iFrame/2-1);\n    \n    //Drawing pass and last search stage are the same.\n    for(int i = 0; i < 9; i++){\n        vec4 t = texelFetch(iChannel1,ivec2(ip-1.)+ivec2(i/3,i%3),0);\n        \n        splat(O.w,I,ip,t.xy);\n        splat(O.w,I,ip,t.zw);\n    }\n    O.w=pow(O.w,.7);\n    int stage = iFrame%2;\n    if(stage==1) O.w=Owp;\n    else O.w = mix(O.w,Owp,0.3);\n    //Smooth over time\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define iR ivec3(R)\n#define uR uvec3(R)\n#define IHash3(x,y,z) IHash(int(x)^IHash(int(y)^IHash(int(z))))\n#define dot2(o) dot((o),(o))\n#define tx(ch,p,R) texelFetch(ch, Zmod(p,iR.xy),0)\n\n//Roboust/universal integer modulus function\n#define Zmod(x,y) (((x)+(y)+(y)+(y))-(((x)+(y)+(y)+(y))/(y))*(y))\n//#define Zmod(x,y) ((x+y*10)%y)\n\nfloat packVec2(vec2 x){\n    return uintBitsToFloat(packSnorm2x16(x/10.));\n}\nvec2 umpackVec2(float x){\n    return unpackSnorm2x16(floatBitsToUint(x))*10.;\n}\n\nbool inbounds(vec2 x, vec2 y){\n    return (x.x>0.&&x.y>0.&&x.x<y.x&&x.y<y.y);\n}\n\n//RNG\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n//Identity mapping\nvec2 forward_mapping(vec2 Z,int p, int q, int Fover2){\n    //int seed = 0;        // Optionaly keep seed constant for that static randomness look\n\tint seed = Fover2;\n    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry\n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    \n    return vec2(x,y)+fract(Z);\n    \n}\nvec2 reverse_mapping(vec2 Z,int p, int q, int Fover2){\n    //int seed = 0;        // Optionaly keep seed constant for that static randomness look\n\tint seed = Fover2;\n    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry\n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    \n    return vec2(x,y)+fract(Z);\n    \n}\n\nfloat score(vec2 p, vec2 I, vec3 R){\n    if(!inbounds(p,R.xy)) return 1e6; \n    \n    //SDF of a particle\n    //Could be anything\n    \n    return max(0.,abs(length(I-p)-25.)-0.5);\n}\n\nvoid updateRank(vec4 t, inout vec4 O, inout float s, vec2 I, vec3 R){\n    float sp = score(t.xy,I,R);\n    if(sp<s){\n        s=sp;\n        O=t;\n    }\n}\n\n//Update ranking, save a list of two particle xy indices. O.xy is better particle, O.zw is a different not as good one\nvoid updateRank2x(vec2 t, inout vec4 O, inout float s0, inout float s1, vec2 I, vec3 R){\n    float sp = score(t,I,R);\n    if(sp<s0){\n        //Shift down the line\n        s1=s0;\n        O.zw=O.xy;\n        s0=sp;\n        O.xy=t;\n    } else if(sp<s1){\n        //Bump off the bottom one\n        s1=sp;\n        O.zw=t;\n        \n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Strided sort summarry:\n//Each pass looks at 9 xy locations stored in the previous pass and selects the closest one\n//The locations sampled are arranged in a 3x3 with the center located at I, and the spacing\n//a power of 3\n//Total 7 passes over two frames sized large to small\n//A->B->C->D->B->C->D->Image\n//Spacing 3^6 ..., 3^1, 3^0\n//I think this gives an optimal data path from each pixel to each other pixel under the constraint of 7 passes\n\n//In each buffer, the pixel to get drawn at index is saved in xy and the exact particle location is saved in zw.\n//For more complex particles zw should instead be a pointer to the particle\n//zw is unused for sorting, sort only based on xy\n\n\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //Split frames into two stages\n    int stage = iFrame%2;\n    \n    int size = stage==0?729:27; //729=3^6\n    float s0;\n    float s1;\n    //init with top left corner and center\n    if(stage==0){\n        vec2 t0 = tx(iChannel0, ivec2(I)-size,R).xy;\n        vec2 t1 = tx(iChannel0, ivec2(I),R).xy;\n                                                                         \n        s0 = score(t0,I,R);\n        s1 = score(t1,I,R);\n        \n        O.xy=t0==vec2(0)?vec2(0):forward_mapping(t0, iR.x, iR.y,iFrame/2);\n        O.zw=t1==vec2(0)?vec2(0):forward_mapping(t1, iR.x, iR.y,iFrame/2);\n        \n        //Select the better one, make sure scores are in order with s0<s1\n        if(s0>s1){\n            vec2 _ = O.xy;\n            O.xy = O.zw;\n            O.zw = _;\n            _.x = s0;\n            s0 = s1;\n            s1 = _.x;\n        }\n    } else {\n        O = tx(iChannel1, ivec2(I)-size,R );\n        s0 = score(O.xy,I,R);\n        s1 = score(O.zw,I,R);\n    }\n    for(int i = 1; i < 9; i++){\n        if(stage==0){\n        \tvec2 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R).xy;\n            t = forward_mapping(t, iR.x, iR.y,iFrame/2);\n            updateRank2x(t,O,s0,s1,I,R);\n            \n        } else {\n        \tvec4 t;\n            t = tx(iChannel1,ivec2(I)-size+size*ivec2(i/3,i%3),R); \n            updateRank2x(t.xy,O,s0,s1,I,R);\n            updateRank2x(t.zw,O,s0,s1,I,R);\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//3x3 strided sort/Jump flood\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    int stage = iFrame%2;\n    \n    int size = stage==0?243:9;\n    //init with top left corner\n    O = tx(iChannel0, ivec2(I)-size, R);\n    float s0 = score(O.xy,I,R);\n    float s1 = score(O.zw,I,R);\n    for(int i = 1; i < 9; i++){\n        vec4 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R);\n        updateRank2x(t.xy,O,s0,s1,I,R);\n        updateRank2x(t.zw,O,s0,s1,I,R);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//3x3 strided sort/Jump flood\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    int stage = iFrame%2;\n    \n    int size = stage==0?81:3;\n    //init with top left corner\n    O = tx(iChannel0, ivec2(I)-size, R);\n    float s0 = score(O.xy,I,R);\n    float s1 = score(O.zw,I,R);\n    for(int i = 1; i < 9; i++){\n        vec4 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R);\n        updateRank2x(t.xy,O,s0,s1,I,R);\n        updateRank2x(t.zw,O,s0,s1,I,R);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}