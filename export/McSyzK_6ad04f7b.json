{"ver":"0.1","info":{"id":"McSyzK","date":"1722590835","viewed":20,"name":"Voronoi-1","username":"Pumpkinlamp9562","description":"Voronoi practice\nReference to https://thebookofshaders.com/12/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dis = 1.0;\n\nvec2 voronoiCellRandomVec2(vec2 uv)\n{\n\treturn fract(sin(vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 uv_i = floor(uv); //tiles\n\tvec2 uv_f = fract(uv);\n\n\tfloat m_dist = 1.0;\n\tvec2 cellPoint = vec2(0.0, 0.0);\n\t// one tile need to calculate 9 times\n\tfor (int y = -1; y <= 1; y++){\n\t\tfor (int x = -1; x <= 1; x++){\n\n\t\t\tvec2 neighbor = vec2(x, y);\n\t\t\tvec2 ranPoint = voronoiCellRandomVec2(uv_i+neighbor); // calculate the random point\n\t\t\tvec2 ranPos = neighbor + ranPoint - uv_f; // offset the random point back to their tile and add gradient\n\n\t\t\tfloat dist = min(length(ranPos),1.0);\n\n\t\t\tif(dist+0.01 <= m_dist){\n\t\t\t\tm_dist = dist;\n\t\t\t\tcellPoint = ranPoint;\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat cells = dot(cellPoint, vec2(0.3,0.6));\n\tfragColor = vec4(min(m_dist,1.0));\n    fragColor = vec4(cells);\n\n}","name":"Image","description":"","type":"image"}]}