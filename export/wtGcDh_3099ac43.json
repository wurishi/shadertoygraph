{"ver":"0.1","info":{"id":"wtGcDh","date":"1699908740","viewed":86,"name":"Cyclical Void","username":"UnstableLobster","description":"Of folding dry ice.\n\nA little bit of chaos can be healthy too :)","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["fluid","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-12-16 10:30:33 \n\n//Takes a bit of poking it and waiting for it to start folding.\n//Space bar shows the \"underlying\" particles.\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    vec2 V = P.V*3.0;\n\n    float of = length(V)*1.0 + iTime*0.1;\n    vec3 cv = vec3(dot(V, Dir(of + 0.0))*0.5+0.5, dot(V, Dir(of + TAU / 3.0 * 2.0))*0.5+0.5, dot(V, Dir(of + TAU / 3.0 * 1.0))*0.5+0.5 );\n    cv = saturate(cv);\n    cv = mix(vec3(1.0), cv, length(V)-0.1);\n   \n    col.xyz = cv;\n    col.xyz *= pow(P.M*0.6, 0.75);\n    col.xyz = pow(col.xyz, vec3(0.9))*1.5;   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define texelLoop(a, p) texelFetch(a, ivec2(mod(p,R)), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define pixelLoop(a, p) texture(a, mod(p,R)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n#define TAU PI*2.0\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*2.0))\n\n#define dt 1.0\n#define particle_diameter 6.0\n\n//------\n//Params\n//------\n\n#define VEL_MULT  ((P0.M*2.0) + length(P0.V))\n\n//0-1\n#define DIFFUSION_CENTER 0.85\n#define DC_MULT (1.0 - pow(length(P0.V), 0.25)*0.95)\n//#define DC_MULT (1.0 - pow(length(P0.V), 0.25)+abs(P0.R.y*2.0))\n//#define DC_MULT (1.0 - pow(length(P0.V), 0.25)+abs(P0.R.x))\n\n//#define MASS_REST 0.6\n//#define MR_SPEED 0.05\n//#define MR_INCREASE abs(MASS_REST - P.M)*0.05\n\n#define CENTERING_SPEED 0.1\n\n\n\n#define UV (pos/R)\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n//crossProductIsh\nvec2 rot90(vec2 a) { return vec2(a.x, -a.y); }\n\nfloat det(vec2 a, vec2 b)      { return a.x*b.y - a.y*b.x; } //cross\nfloat cosAngle(vec2 a, vec2 b) { return a.x*b.x + a.y*b.y; } //dot\nfloat sinAngle(vec2 a, vec2 b) { return -a.x*b.y + a.y*b.x; }\nfloat watAngle(vec2 a, vec2 b) { return -a.x*b.y - a.y*b.x; }\nfloat fullAngle(vec2 a, vec2 b) { return atan(sinAngle(a, b), cosAngle(a, b)); }\n//float fullAngle(vec2 a, vec2 b) { return atan(det(a, b), cosAngle(a, b)); }\n//float fullAngle(vec2 a, vec2 b) { return atan(det(a, b), cosAngle(a, b)); }\n\nvec2 safeNormalize(vec2 x) { return ((length(x) == 0.0) ? vec2(0.0) : normalize(x)); }\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    \n    //return unpackSnorm2x16(X);\n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    //uint X = packSnorm2x16(x);\n    uint X = packHalf2x16(x);\n   \n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 R;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.R = decode(data.z);\n    P.M = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    return vec4(encode(P.X), encode(P.V), encode(P.R), (P.M));\n}\n\n\n//-------------\n// RNG https://www.shadertoy.com/view/wltcRS\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 distribution(vec2 x, vec2 p, vec2 K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K.x*K.y));\n}\n\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    int I = int(particle_diameter); \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        \n        if (tpos.x < 0.0 || tpos.y < 0.0\n        || tpos.x > iResolution.x || tpos.y > iResolution.y) continue;\n       \n        particle P0 = getParticle(data, tpos);        \n            \n        P0.X += P0.V*dt * VEL_MULT;\n        P0.R.x += P0.R.y * dt;\n\n        vec2 P0R = (P0.X-pos)*Rot(P0.R.x) + pos;\n\n        vec3 D = distribution(P0R, pos, vec2(particle_diameter, (particle_diameter/6.0) + P0.M*3.5/6.0*particle_diameter ));\n        float m = P0.M*D.z; //the deposited mass into this cell\n        \n        float s = 1.0 - texel(ch3, ivec2(32,2)).x;\n\n        //add weighted by mass\n        P.X += mix(P0.X, D.xy, DIFFUSION_CENTER * DC_MULT * s)*m;\n        P.V += P0.V*m;\n        P.R += P0.R*m;\n\n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if (P.M != 0.0)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n        P.R /= P.M;\n    }\n\n\n    //----- \n    float prevM = P.M;\n        P.M = max(P.M, 0.0025);\n    P.V = P.V * prevM/P.M;\n    \n    vec2 CP = clamp(P.X - pos, -.5, .5) + pos;\n    P.X = mix(P.X, CP, saturate(distance(P.X, pos) - 0.0) * CENTERING_SPEED);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    rng_initialize(pos, iFrame);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;\n       \n    Reintegration(ch0, P, pos);\n   \n    if (iFrame < 1)\n    {\n       \n        P.X = pos;\n        P.V = (rand2()-0.5)*0.25;\n        P.M = 0.25;\n        P.R = vec2(PI*2.0, 50.5)*(rand()-0.5);\n    }\n    \n    U = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    \n    if (iMouse.z > 0.)\n    {\n        vec2 dx = pos - iMouse.xy;\n        if (length(dx) < 30.)\n            P.V += 0.005*Rot(PI*0.0*iTime)*dx;\n    }       \n\n    if (length(P.V) != 0.0)\n    {\n        float v = length(P.V);\n        float r = length(R.y);\n        float s = sign(P.R.y);\n        \n        if (s == 0.0) s = rand();    \n        \n        v = pow(0.1, -v + 1.0);\n        v = saturate(v-0.25);\n        \n        float rr = v/(1.0+r)*s;\n        \n        //P.R.y += rr * 1.0;\n    }\n    \n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n        rng_initialize(pos, iFrame);\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n\n    \n    if(P.M != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    \n    U = saveParticle(P, pos);\n}","name":"Buffer B","description":"","type":"buffer"}]}