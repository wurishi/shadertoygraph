{"ver":"0.1","info":{"id":"mlfcRM","date":"1690511401","viewed":1337,"name":"Breaking Repetition","username":"Xor","description":"My favorite technique for breaking repetition, when using SDFs. Works in 3D too!","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["sdf","repetition","technique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Breaking Repetition\" by @XorDev\n    \n    Here's a simple technique for pseudo-randomly distributing objects.\n    This method preserves proper spacing for distance fields and works in 3D!\n    \n    The concept is simple:\n    -Render a few tiled layers of objects\n    -Rotate and scale the coordinates for each layer\n    -Divide the distance by the octave scale\n    \n    Rotation only helps a ton, but when combined with scaling it's patternless*\n*/\n\n//Optional octave index for coloring\nfloat IND = 1.0;\n//Distance field function\nfloat dist(vec2 p, float num, float scl)\n{\n    //Arbitrary rotation matrix\n    mat2 m = mat2(.8,-.6,.6,.8);\n    //Scaling factor\n    float s = 1.0;\n    //Store minimum distance\n    float d = 1e9;\n    \n    //Loop through passes\n    for(float i = 0.0; i<num; i++)\n    {\n        //Repeating circles rotating octaves and scaling\n        float _d = length(mod((p*=m)*s+i*.3,2.)-1.)/s;\n        //Store closest distance (and optionally, index for coloring)\n        if (d>_d)\n        {\n            d = _d;\n            IND = i;\n        }\n        //Scale by factor amount\n        s *= scl;\n    }\n    //Return distance field\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered and scale pixel coordinates\n    vec2 coord = (fragCoord - iResolution.xy*0.5)/3e1;\n    //Time loop\n    float T = abs(mod(iTime+6.,12.)-6.);\n    //Number of octaves\n    float N = clamp(T,1.,4.);\n    //Octave scaling\n    float S = clamp(1.4-T*.1,.9,1.);\n    //Distance gradients and coloring\n    fragColor = (1.-dist(coord,N,S)) * (.5-.5*cos(IND+vec4(0,2,4,0)));\n}","name":"Image","description":"","type":"image"}]}