{"ver":"0.1","info":{"id":"fsVSD3","date":"1636064247","viewed":70,"name":"Test Rand Distribution","username":"fulminatus","description":"Visually show how random","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["random","distribution","histogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GPU printf\n// Inspired by https://www.shadertoy.com/view/Mt2GWD\n// Thanks to morimea, FabriceNeyret2 for suggestions.\n//\n// Usage: see drawText() for quick-start and API section for all available functions\n\n// Options\n#define GPF_MACROS\t\t\t\t1\t\t// use macros to ease writing text/numbers\n#define GPF_PRINT_FLOAT_USE_INT\t1\n#define GPF_SCALE\t\t\t\t2.0\t\t// scale the font\n#define GPF_MAX_INT_DIGITS\t\t10\n#define GPF_MAX_DECIMAL_DIGITS\t6\n\n///////////////////////////////////////////////////////////////\n// Data\n///////////////////////////////////////////////////////////////\n\n// Automatically generated from the 8x12 font sheet here:\n// http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 gpf_digits[10] = vec4[]\n(\n    vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000), // 0\n    vec4(0x001030,0xF03030,0x303030,0xFC0000), // 1\n    vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000), // 2\n    vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000), // 3\n    vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000), // 4\n    vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000), // 5\n    vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000), // 6\n    vec4(0x00FEC6,0xC6060C,0x183030,0x300000), // 7\n    vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000), // 8\n    vec4(0x0078CC,0xCCCC7C,0x181830,0x700000)  // 9\n);\n\n// ascii table starting from 32\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); // (space)\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); // !\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); // \"\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); // #\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); // $\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); // %\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); // &\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); // '\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); // (\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); // )\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); // *\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); // +\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); // ,\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); // -\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); // .\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); // /\nvec4 ch_0   = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); // 0\nvec4 ch_1   = vec4(0x001030,0xF03030,0x303030,0xFC0000); // 1\nvec4 ch_2   = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); // 2\nvec4 ch_3   = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); // 3\nvec4 ch_4   = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); // 4\nvec4 ch_5   = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); // 5\nvec4 ch_6   = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); // 6\nvec4 ch_7   = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); // 7\nvec4 ch_8   = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); // 8\nvec4 ch_9   = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); // 9\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); // :\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); // ;\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); // <\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); // =\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); // >\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); // ?\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); // @\nvec4 ch_A   = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); // A\nvec4 ch_B   = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); // B\nvec4 ch_C   = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); // C\nvec4 ch_D   = vec4(0x00F86C,0x666666,0x66666C,0xF80000); // D\nvec4 ch_E   = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); // E\nvec4 ch_F   = vec4(0x00FE66,0x62647C,0x646060,0xF00000); // F\nvec4 ch_G   = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); // G\nvec4 ch_H   = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); // H\nvec4 ch_I   = vec4(0x007830,0x303030,0x303030,0x780000); // I\nvec4 ch_J   = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); // J\nvec4 ch_K   = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); // K\nvec4 ch_L   = vec4(0x00F060,0x606060,0x626666,0xFE0000); // L\nvec4 ch_M   = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); // M\nvec4 ch_N   = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); // N\nvec4 ch_O   = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); // O\nvec4 ch_P   = vec4(0x00FC66,0x66667C,0x606060,0xF00000); // P\nvec4 ch_Q   = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); // Q\nvec4 ch_R   = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); // R\nvec4 ch_S   = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); // S\nvec4 ch_T   = vec4(0x00FCB4,0x303030,0x303030,0x780000); // T\nvec4 ch_U   = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); // U\nvec4 ch_V   = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); // V\nvec4 ch_W   = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); // W\nvec4 ch_X   = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); // X\nvec4 ch_Y   = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); // Y\nvec4 ch_Z   = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); // Z\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); // [\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); // right slash\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); // ]\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); // ^\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); // _\nvec4 ch_a   = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); // a\nvec4 ch_b   = vec4(0x00E060,0x607C66,0x666666,0xDC0000); // b\nvec4 ch_c   = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); // c\nvec4 ch_d   = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); // d\nvec4 ch_e   = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); // e\nvec4 ch_f   = vec4(0x00386C,0x6060F8,0x606060,0xF00000); // f\nvec4 ch_g   = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); // g\nvec4 ch_h   = vec4(0x00E060,0x606C76,0x666666,0xE60000); // h\nvec4 ch_i   = vec4(0x001818,0x007818,0x181818,0x7E0000); // i\nvec4 ch_j   = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); // j\nvec4 ch_k   = vec4(0x00E060,0x60666C,0x786C66,0xE60000); // k\nvec4 ch_l   = vec4(0x007818,0x181818,0x181818,0x7E0000); // l\nvec4 ch_m   = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); // m\nvec4 ch_n   = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); // n\nvec4 ch_o   = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); // o\nvec4 ch_p   = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); // p\nvec4 ch_q   = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); // q\nvec4 ch_r   = vec4(0x000000,0x00EC6E,0x766060,0xF00000); // r\nvec4 ch_s   = vec4(0x000000,0x0078CC,0x6018CC,0x780000); // s\nvec4 ch_t   = vec4(0x000020,0x60FC60,0x60606C,0x380000); // t\nvec4 ch_u   = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); // u\nvec4 ch_v   = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); // v\nvec4 ch_w   = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); // w\nvec4 ch_x   = vec4(0x000000,0x00C66C,0x38386C,0xC60000); // x\nvec4 ch_y   = vec4(0x000000,0x006666,0x66663C,0x0C18F0); // y\nvec4 ch_z   = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); // z\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); // {\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); // |\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); // }\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); // ~\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000); // DEL\n\n\n///////////////////////////////////////////////////////////////\n// API\n///////////////////////////////////////////////////////////////\n\n// globals\nvec2 gpf_gRes      = vec2(0); // by default init to top-left\nvec2 gpf_gPrintPos = vec2(0);\nvec2 gpf_gUV       = vec2(0);\n\nvec2  gpf_char_size()                   { return vec2(8, 12); }\nfloat gpf_char_size_x()                 { return gpf_char_size().x; }\nfloat gpf_char_size_y()                 { return gpf_char_size().y; }\nvec2  gpf_char_spacing()                { return vec2(8, 12); }\nfloat gpf_char_spacing_x()              { return gpf_char_spacing().x; }\nfloat gpf_char_spacing_y()              { return gpf_char_spacing().y; }\nvoid  gpf_reset_pos()                   { gpf_gPrintPos = vec2(0.0, gpf_gRes.y - gpf_char_spacing_y()); }\nvoid  gpf_set_pos(float x, float y)     { gpf_gPrintPos = vec2(x, y); }\nvoid  gpf_newline()                     { gpf_gPrintPos.x = 0.0; gpf_gPrintPos.y -= gpf_char_spacing_y(); }\nvoid  gpf_init(vec2 res, vec2 scrcoord) { gpf_gRes = res / GPF_SCALE; gpf_reset_pos(); gpf_gUV = floor(scrcoord.xy / GPF_SCALE); }\nfloat gpf_char(vec4 ch);\nfloat gpf_print_number(float number);\nfloat gpf_print_integer(float number, int zeros);\n\n\n///////////////////////////////////////////////////////////////\n// Implementation\n///////////////////////////////////////////////////////////////\n\n// Extracts bit b from the given number.\n// Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat _gpf_extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// Returns the pixel at uv in the given bit-packed _gpf_sprite.\nfloat _gpf_sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the _gpf_sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += _gpf_extract_bit(spr.x, bit - 72.0);\n    pixels += _gpf_extract_bit(spr.y, bit - 48.0);\n    pixels += _gpf_extract_bit(spr.z, bit - 24.0);\n    pixels += _gpf_extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n// Returns the digit _gpf_sprite for the given number.\nvec4 _gpf_get_digit(int index)\n{\n    return 0 <= index && index < 10 ? gpf_digits[index] : gpf_digits[0];\n}\n\n// value >= 0\nint _gpf_count_digits(int value, int maxDigits)\n{\n    int count = 1;\n    \n    for (int i=0; i<maxDigits; i++)\n    {        \n        value /= 10;\n        if (value == 0)\n            break;\n        count++;\n    }\n    \n    return count;\n}\n\n// value >= 0\n// NOTE: modifies value\nivec2 _gpf_count_decimal_digits(inout int value, int maxDigits)\n{\n    int zeros = 0;\n    for (int i=0; i<maxDigits; i++)\n    {\n        if (value == 0)\n            break;\n        if (value % 10 > 0)\n            break;\n        value /= 10;\n        zeros++;\n    }\n    return ivec2(_gpf_count_digits(value, maxDigits), zeros);\n}\n\n// draw from last digit to first\nfloat _gpf_int_positive(int value, int digitCount)\n{\n    float result = 0.0;\n    \n    gpf_gPrintPos.x += gpf_char_spacing_x() * float(digitCount - 1);\n\n    for (int i=0; i<digitCount; i++)\n    {\n        result += gpf_char(_gpf_get_digit(value % 10));\n        value /= 10;\n        gpf_gPrintPos.x -= 2.0 * gpf_char_spacing_x();\n    }\n    gpf_gPrintPos.x += gpf_char_spacing_x() * float(digitCount + 1);\n\n    return result;\n}\n\n// Prints a character and moves the print position forward by 1 character width.\nfloat gpf_char(vec4 ch)\n{\n\tvec2 uv = gpf_gUV;\n\t\n    float px = _gpf_sprite(ch, gpf_char_size(), uv - gpf_gPrintPos);\n    gpf_gPrintPos.x += gpf_char_spacing_x();\n    return px;\n}\n\n\nfloat gpf_int(int value)\n{\n    float result = 0.0;\n    \n    if (value == -2147483648)\n    {\n        result += gpf_char(ch_dsh);\n        result += gpf_char(ch_2);\n        result += gpf_char(ch_1);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_7);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_8);\n        result += gpf_char(ch_3);\n        result += gpf_char(ch_6);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_8);        \n    }\n    else\n    {\n        if (value < 0)\n        {\n            result += gpf_char(ch_dsh); // add -\n            value = -value;\n        }\n\n        int digitCount = _gpf_count_digits(value, GPF_MAX_INT_DIGITS);\n        result += _gpf_int_positive(value, digitCount);\n    }\n        \n    return result;\n}\n\nint _gpf_int_pow(int a, int b)\n{\n    int ret = 1;\n    for (int i=0; i<b; i++)\n        ret *= a;\n    return ret;\n}\n\nfloat _gpf_float_frac(float value, int maxDecimalDigits)\n{\n    float result = 0.0;       \n    \n    int decimalValue = int(fract(abs(value)) * float(_gpf_int_pow(10, maxDecimalDigits)));\n    if (decimalValue == 0)\n    {\n        result += gpf_char(ch_0);\n    }\n    else\n    {\n        ivec2 decimalDigits = _gpf_count_decimal_digits(decimalValue, maxDecimalDigits);\n        int lzeros = maxDecimalDigits - decimalDigits.x - decimalDigits.y;\n        for (int i=0; i<lzeros; i++)\n            result += gpf_char(ch_0);\n        result += _gpf_int_positive(decimalValue, decimalDigits.x);\n    }    \n    \n    return result;\n}\n\nfloat gpf_float(float value, int maxDecimalDigits)\n{\n    float result = 0.0;\n    \n    if (isnan(value))\n    {\n        result += gpf_char(ch_N);\n        result += gpf_char(ch_a);\n        result += gpf_char(ch_N);\n    }    \n    else if (isinf(value))\n    {\n        result += gpf_char(ch_I);\n        result += gpf_char(ch_n);\n        result += gpf_char(ch_f);\n    }\n    else\n    {\n    #if GPF_PRINT_FLOAT_USE_INT\n        // TODO: Since we are working with bits, we can actually detect nan/inf manually\n        uint bits = floatBitsToUint(value);\n        bool isNegative = (bits >> 31) != 0u;\n        uint mantissa = bits & ((1u << 23) - 1u);\n        uint exponent = (bits >> 23) & ((1u << 8) - 1u);\n                \n        if (isNegative)\n        {\n            result += gpf_char(ch_dsh);\n        }\n        \n        if (mantissa == 0u && exponent == 0u)\n        {\n            result += gpf_char(ch_0);\n            result += gpf_char(ch_per);\n            \n            for (int i=0; i<maxDecimalDigits; i++)\n                result += gpf_char(ch_0);\n        }\n        else\n        {\n            uint m2 = (1u << 23) | mantissa;\n            int e2 = 23 - (int(exponent) - 127);\n\n            // separate m2 into integer part/fractional part\n            uint i = m2 >> e2;\n            uint f = m2 - (i << e2);\n\n            result += gpf_int(int(i));\n            result += gpf_char(ch_per);\n\n            uint fmask = (1u << e2) - 1u;\n\t\t\tfor (int i = 0; i < maxDecimalDigits; i++)\n\t\t\t{\n\t\t\t\tf *= 10u;\n                result += gpf_char(_gpf_get_digit(int(f >> e2)));\n\t\t\t\tf &= fmask;\n\n\t\t\t\tif (f == 0u)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n    #else\n        result += gpf_int(int(value));\n        result += gpf_char(ch_per); // .\n        result += _gpf_float_frac(value, maxDecimalDigits);    \n    #endif\n    }\n    \n    return result;\n}\n\n///////////////////////////////////////////////////////////////\n// Macros\n///////////////////////////////////////////////////////////////\n#if GPF_MACROS\n\t#define _a    col += gpf_char(ch_a);\n\t#define _b    col += gpf_char(ch_b);\n\t#define _c    col += gpf_char(ch_c);\n\t#define _d    col += gpf_char(ch_d);\n\t#define _e    col += gpf_char(ch_e);\n\t#define _f    col += gpf_char(ch_f);\n\t#define _g    col += gpf_char(ch_g);\n\t#define _h    col += gpf_char(ch_h);\n\t#define _i    col += gpf_char(ch_i);\n\t#define _j    col += gpf_char(ch_j);\n\t#define _k    col += gpf_char(ch_k);\n\t#define _l    col += gpf_char(ch_l);\n\t#define _m    col += gpf_char(ch_m);\n\t#define _n    col += gpf_char(ch_n);\n\t#define _o    col += gpf_char(ch_o);\n\t#define _p    col += gpf_char(ch_p);\n\t#define _q    col += gpf_char(ch_q);\n\t#define _r    col += gpf_char(ch_r);\n\t#define _s    col += gpf_char(ch_s);\n\t#define _t    col += gpf_char(ch_t);\n\t#define _u    col += gpf_char(ch_u);\n\t#define _v    col += gpf_char(ch_v);\n\t#define _w    col += gpf_char(ch_w);\n\t#define _x    col += gpf_char(ch_x);\n\t#define _y    col += gpf_char(ch_y);\n\t#define _z    col += gpf_char(ch_z);\n\t#define _A    col += gpf_char(ch_A);\n\t#define _B    col += gpf_char(ch_B);\n\t#define _C    col += gpf_char(ch_C);\n\t#define _D    col += gpf_char(ch_D);\n\t#define _E    col += gpf_char(ch_E);\n\t#define _F    col += gpf_char(ch_F);\n\t#define _G    col += gpf_char(ch_G);\n\t#define _H    col += gpf_char(ch_H);\n\t#define _I    col += gpf_char(ch_I);\n\t#define _J    col += gpf_char(ch_J);\n\t#define _K    col += gpf_char(ch_K);\n\t#define _L    col += gpf_char(ch_L);\n\t#define _M    col += gpf_char(ch_M);\n\t#define _N    col += gpf_char(ch_N);\n\t#define _O    col += gpf_char(ch_O);\n\t#define _P    col += gpf_char(ch_P);\n\t#define _Q    col += gpf_char(ch_Q);\n\t#define _R    col += gpf_char(ch_R);\n\t#define _S    col += gpf_char(ch_S);\n\t#define _T    col += gpf_char(ch_T);\n\t#define _U    col += gpf_char(ch_U);\n\t#define _V    col += gpf_char(ch_V);\n\t#define _W    col += gpf_char(ch_W);\n\t#define _X    col += gpf_char(ch_X);\n\t#define _Y    col += gpf_char(ch_Y);\n\t#define _Z    col += gpf_char(ch_Z);\n\t#define _0    col += gpf_char(ch_0);\n\t#define _1    col += gpf_char(ch_1);\n\t#define _2    col += gpf_char(ch_2);\n\t#define _3    col += gpf_char(ch_3);\n\t#define _4    col += gpf_char(ch_4);\n\t#define _5    col += gpf_char(ch_5);\n\t#define _6    col += gpf_char(ch_6);\n\t#define _7    col += gpf_char(ch_7);\n\t#define _8    col += gpf_char(ch_8);\n\t#define _9    col += gpf_char(ch_9);\n\t#define _    col += gpf_char(ch_spc);\n\t\n\t#define _newline_    gpf_newline();\t\n\t#define println_i(x)   col += gpf_int(x); _newline_\n\t#define println_f(x)   col += gpf_float(x, GPF_MAX_DECIMAL_DIGITS); _newline_\n\t#define print_i(x)     col += gpf_int(x)\n\t#define print_f(x)     col += gpf_float(x, GPF_MAX_DECIMAL_DIGITS)\n#endif // #if GPF_MACROS\n\n#define NUM_RENDERERS 6\n#define NO_REVIEWER -1\n\nint seed;\n\nuint pcg_hash(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n//float rand() { return fract(sin(seed++)*43758.5453123); }\n\nfloat rand() { return float(pcg_hash(uint(seed++))) * (1.0/float(0xffffffffu)); }\n\nint GetRandomReviewer()\n{\n    return int(rand() * float(NUM_RENDERERS));\n}\n\nint PickReviewer(int PreviousReviewer1, int PreviousReviewer2)\n{\n    int reviewer;\n    const int numTries = 4;\n    for(int i = 0; i < numTries; i++)\n    {\n        reviewer = GetRandomReviewer();\n        if(reviewer != PreviousReviewer1 && reviewer != PreviousReviewer2) break;\n    }\n    \n    // If rand keeps hitting matches, brute force it and go through \n    // every reviewer starting from PreviousReviewer1 + 1\n    if(reviewer == PreviousReviewer1 || reviewer == PreviousReviewer2)\n    {\n        for(int i = 0; i < NUM_RENDERERS; i++)\n        {\n           reviewer = (PreviousReviewer1 + i) % NUM_RENDERERS;\n           if(reviewer != PreviousReviewer1 && reviewer != PreviousReviewer2) break; \n        }\n    }\n    \n    \n    return reviewer;\n}\n\nvoid drawName(int index, out float col)\n{\n    switch(index)\n    {\n        case 0:\n            _C _h _r _i _s\n            break;\n        case 1:\n            _M _i _k _e\n            break;\n        case 2:\n            _S _i _m _o _n\n            break;\n        case 3:\n            _J _i _l _l _i _a _n\n            break;\n        case 4:\n            _D _a _v _e\n            break;\n        case 5:\n            _I _a _n\n            break;\n    }\n    _newline_\n}\n\nvoid drawHistogram(vec2 fragCoord, out vec3 rgb, inout float col)\n{\n    const float barHeight = 100.0f;\n    const float barDrawRegion = barHeight * float(NumModes);\n    \n    gpf_set_pos(0.0, ( iResolution.y/2.0 + barHeight - gpf_char_spacing_y()/2.0)/GPF_SCALE);\n    _ _C _h _r _i _s _ _O _r _i _g\n\n    gpf_set_pos(0.0, ( iResolution.y/2.0 + gpf_char_spacing_y())/GPF_SCALE);\n    _ _C _h _r _i _s _newline_\n    _ _b _i _t _r _e _v \n\n    gpf_set_pos(0.0, ( iResolution.y/2.0 - barHeight + gpf_char_spacing_y()*1.5)/GPF_SCALE);\n    _ _C _h _r _i _s _newline_\n    _ _x _1 _0 _0 _0 _0 _newline_\n    _ _b _i _t _r _e _v \n\n\n    if (fragCoord.y > (iResolution.y/2.0 - barDrawRegion/2.0) && fragCoord.y < (iResolution.y/2.0 + barDrawRegion/2.0))\n    {\n        int ModeNum = NumModes - 1 - (int((fragCoord.y - (iResolution.y/2.0 - barDrawRegion/2.0)) / barHeight));\n        \n        const uint NumBars = 6u;\n        float ColumnWidth = (iResolution.x / float(NumBars + 1u));\n        float vals[NumBars];\n\n        vals[0] = texelFetch(iChannel1, ivec2(2, ModeNum), 0).x;\n        float minVal = vals[0];\n        float maxVal = vals[0];\n\n        for (int i = 1; i < int(NumBars); ++i)\n        {\n            vals[i] = texelFetch(iChannel1, ivec2(i+2, ModeNum), 0).x;\n            if (minVal > vals[i])\n            {\n                minVal = vals[i];\n            }\n            else if (maxVal < vals[i])\n            {\n                maxVal = vals[i];\n            }\n        }\n        \n        int Index = int(fragCoord.x / ColumnWidth);\n        \n        float range = (maxVal - minVal)*1.0;\n        \n        if (Index >= 1)\n        {\n            if (range > 0.0)\n            {\n                //col = (vals[Index] - minVal) / range;\n                col = vals[Index]*6.0;\n            }\n            else\n            {\n                col = 1.0;\n            }\n        }\n        else\n        {\n            range = clamp(range, 0.0, 1.0);\n            rgb = vec3(\n                (range) * 2.0,\n                1.0-(range) * 2.0,\n                0.0\n            );\n        }\n        \n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Store the time on the first frame so things aren't random every frame\n    bool bFirstFrame = (iFrame == 0);\n    seed = bFirstFrame ? int(iDate.w * 10.0f) : int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n   \n    if(int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        fragColor = vec4(seed);\n        return;\n    }\n\n    gpf_init(iResolution.xy, fragCoord.xy);\n    \n    int Reviewer1 = PickReviewer(NO_REVIEWER, NO_REVIEWER);\n    float col = 0.0f; \n    \n    _1 _\n    drawName(Reviewer1, col);\n    \n    int Reviewer2 = PickReviewer(Reviewer1, NO_REVIEWER);\n    _2 _\n    drawName(Reviewer2, col);\n    \n    _3 _\n    int Reviewer3 = PickReviewer(Reviewer1, Reviewer2);\n    drawName(Reviewer3, col);\n    \n    vec3 rgb = vec3(0);\n    drawHistogram(fragCoord, rgb, col);\n    \n\tfragColor = vec4(vec3(col) + rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"uint pcg_hash(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n\nfloat rand(inout uint seed) { return float(pcg_hash(uint(seed++))) * (1.0/float(0xffffffffu)); }\n\nuint ReverseBits(uint start)\n{\n    uint s0 = start;\n    uint s1 = ((s0 & 0x0000ffffu) << 16) | (( (s0 & 0xffff0000u) >> 16) & 0x0000ffffu);\n         s0 = ((s1 & 0x00ff00ffu) << 8)  | (( (s1 & 0xff00ff00u) >> 8)  & 0x00ffffffu);\n         s1 = ((s0 & 0x0f0f0f0fu) << 4)  | (( (s0 & 0xf0f0f0f0u) >> 4)  & 0x0fffffffu);\n         s0 = ((s1 & 0x33333333u) << 2)  | (( (s1 & 0xccccccccu) >> 2)  & 0x3fffffffu);\n         s1 = ((s0 & 0x55555555u) << 1)  | (( (s0 & 0xaaaaaaaau) >> 1)  & 0x7fffffffu);\n    return s1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ModeNum = int(fragCoord.y);\n    \n    if (ModeNum > NumModes)\n    {\n        discard;\n    }\n    \n    if (int(fragCoord.x) > 8)\n    {\n        discard;\n    }\n    \n    // Phase1: Update Seed\n    if(int(fragCoord.x) == 0)\n    {\n        // Init Phase\n        if (ModeNum == 0) // Chris's algorithm\n        {\n            float artificialTimeDelaySec = 20.0f;\n            fragColor = vec4(((iDate.w + artificialTimeDelaySec) * 10.0f));\n            return;\n        }\n        else if (ModeNum == 1)\n        {\n            uint wallisSeed = uint(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n            uint s0 = ReverseBits(uint(wallisSeed));\n\n            fragColor = vec4((s0), 0, 0, 0);\n            return;\n        }\n        else if (ModeNum == 2)\n        {\n            float wallisSeedf = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n            uint s0 = ReverseBits(uint(wallisSeedf * 1000.0f));\n\n            fragColor = vec4((s0), 0, 0, 0);\n            return;\n        }\n    }\n    \n    // Phase2: Update Random\n    if(int(fragCoord.x) == 1)\n    {\n        uint modeSeed = uint(texelFetch(iChannel0, ivec2(0, ModeNum), 0).x);\n        \n        // store the pseudo random number for this frame\n        fragColor = vec4(rand(modeSeed));\n        return;\n    }\n\n    // Phase3: Update history\n    \n    // read random val for the frame\n    float currRand = (texelFetch(iChannel0, ivec2(1, ModeNum), 0).x) * 6.0;\n\n    // Update bucket averages based on value\n    vec4 LastColor = texelFetch(iChannel0, ivec2(int(fragCoord.x), ModeNum), 0);\n    \n    if (int(fragCoord.x) == int(currRand)+2)\n    {\n        // Increase average in this bucket\n        fragColor = (LastColor * float(iFrame+1) + 1.0) / float(iFrame+2);\n    }\n    else\n    {\n        // Decrease average in this bucket\n        fragColor = (LastColor * float(iFrame+1)) / float(iFrame+2);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int NumModes = 3;\n","name":"Common","description":"","type":"common"}]}