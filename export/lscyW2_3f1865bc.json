{"ver":"0.1","info":{"id":"lscyW2","date":"1520195140","viewed":258,"name":"Basic 2D Shapes 11","username":"WQS33","description":"Basic 2D shapes: Circle, rectangle etc. Anti-aliasing possible","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define SYMMETRY_ON\n\n// draw binary circle scale to resolution --optimized!\nvoid Circle(in vec2 uv, in vec2 center, in float radius, out float intensity){\n    intensity = float(distance(uv,center) < radius);\n\n}\n\n//rescaled binary circle  --optimized!\nvoid CircleRect(in vec2 uv, in vec2 center, in float radius, out float intensity){\n    uv = (uv - vec2(0.5)) * vec2(1, iResolution.y / iResolution.x) + vec2(0.5);\n    Circle(uv, center, radius, intensity);\n}\n\n//draw binary circle anti-aliasing further optimization WIP\nvoid CircleAA(in vec2 uv, in vec2 center, in float radius, int divPixel, out float intensity){\n    vec2 subPix = vec2(1.0) / iResolution.xy;\n    float subDis = distance(subPix, vec2(0, 0));\n    float dis = distance(uv,center);\n    if(abs(dis - radius) <= max(subPix.x, subPix.y)){\n        float subintensity = 0.0;\n        for(int i = 0; i < divPixel * divPixel; i++){\n            vec2 offset = vec2(i % divPixel, i / divPixel);\n            offset /= vec2(divPixel);\n            float newDis = distance( uv + offset * subPix - vec2(0.5) * subPix, center);\n            if(newDis > radius){\n                intensity += 0.0;\n            }\n            else{\n                intensity += 1.0;\n            }\n            //uv = uv + offset * subPix - vec2(0.5) * subPix;\n            \n            //Circle(uv, center, radius, subintensity);\n            //intensity += subintensity;\n        }\n        intensity /= float(divPixel * divPixel);\n    }\n    else{\n        Circle(uv, center, radius, intensity);\n    }\n}\n\n//rescaled binary circle  further optimization WIP\nvoid CircleRectAA(in vec2 uv, in vec2 center, in float radius, int divPixel, out float intensity){\n    uv = (uv - vec2(0.5)) * vec2(1, iResolution.y / iResolution.x) + vec2(0.5);\n    vec2 subPix = vec2(1.0) / iResolution.xy;\n    float subDis = distance(subPix, vec2(0, 0));\n    float dis = distance(uv,center);\n    if(abs(dis - radius) <= max(subPix.x, subPix.y)){\n        float subintensity = 0.0;\n        for(int i = 0; i < divPixel * divPixel; i++){\n            vec2 offset = vec2(i % divPixel, i / divPixel);\n            offset /= vec2(divPixel);\n            float newDis = distance( uv + offset * subPix - vec2(0.5) * subPix, center);\n            if(newDis > radius){\n                intensity += 0.0;\n            }\n            else{\n                intensity += 1.0;\n            }\n            //uv = uv + offset * subPix - vec2(0.5) * subPix;\n            \n            //Circle(uv, center, radius, subintensity);\n            //intensity += subintensity;\n        }\n        intensity /= float(divPixel * divPixel);\n    }\n    else{\n        Circle(uv, center, radius, intensity);\n    }\n}\n\n//draw binary rectangle optimzed!\nvoid Rect(in vec2 uv, in vec2 center, in vec2 wh, out float intensity){\n    vec2 disRec = abs(uv - center) - wh * 0.5;\n    float dis = max(disRec.x, disRec.y);\n    intensity = float(dis < 0.0);\n}\n\n//draw gradient based on \nvoid dirGradient(in vec2 uv, in vec2 dir, out float intensity){\n    dir = normalize(dir);\n    float theta = atan(dir.y/ dir.x);\n    \n    mat2 rotMat= mat2( cos(theta), -1.0 * sin(theta),\n                      sin(theta), cos(theta));\n    \n    uv = rotMat * uv;\n    intensity = uv.x;\n}\n\nvec2 MirrorReflect(vec2 uv, int SplitNum){\n    // Convert to the polar coordinate.\n        vec2 sc = uv - 0.5;\n        float phi = atan(sc.y, sc.x);\n        float r = sqrt(dot(sc, sc));\n\n        // Angular repeating.\n        //phi += _Offset;\n    \tphi +=  0.5;\n        phi = phi - float(SplitNum) * floor(phi / float(SplitNum));\n        //#if SYMMETRY_ON\n        //phi = min(phi, float(SplitNum) - phi);\n        //#endif\n    \tfloat _Roll = 0.0;\n    \tfloat _Offset = 0.0;\n        phi += _Roll - _Offset;\n\n        // Convert back to the texture coordinate.\n         uv = vec2(cos(phi), sin(phi)) * r + 0.5;\n\n        // Reflection at the border of the screen.\n        uv = max(min(uv, 2.0 - uv), -uv);\n    \n    return uv;\n}\n\n//draw binary N-side polygon -- WIP\nvoid NGon(in vec2 uv, in vec2 center, in float radius, in int edgeNum, out float intensity){\n    vec2 dir = uv - center;\n    float angle = atan(-1.0 * dir.x / dir.y); //current angle of the direction to vec2(0.0, -1.0)\n    \n    //\n    float singleAngle = 2.0 * PI / float(edgeNum); //radian of a single angle of NGon\n    //the section pixel falls to \n    int Sec = int(floor(mod(angle + PI * 0.5, singleAngle)));\n    float rotAngle = singleAngle * float(Sec) - PI * 0.5;\n    vec2 Ngondir = vec2(cos(rotAngle), sin(rotAngle));\n    dirGradient(uv, Ngondir, intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //parameters for shape\n    float radius = 0.2;\n    \n    float intensity, intensity1, intensity2 = 0.0;\n    vec2 center = vec2(0.5);\n    vec2 wh = vec2(0.1, 0.3);\n    \n    vec2 center1  = vec2(0.75);\n    \n    //uv = MirrorReflect(uv, 5);\n    \n    //use shape functions\n    CircleRectAA(uv, center1, radius *0.5,4, intensity1);\n    //Circle(uv, center1, radius, intensity1);\n    Rect(uv, center, wh, intensity);\n    //NGon(uv, center, radius, 4, intensity);\n   // dirGradient(uv, vec2(0.2, 0.3), intensity);\n    //calculate color\n    vec3 col = vec3(intensity + intensity1);\n    //vec3 col = vec3(intensity);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}