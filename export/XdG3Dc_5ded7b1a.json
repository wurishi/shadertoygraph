{"ver":"0.1","info":{"id":"XdG3Dc","date":"1456733583","viewed":706,"name":"Paintbrush on sphere","username":"kqyrt","description":"Draw on a sphere and toggle between 2d and 3d.","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["paintbrush"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 idView = vec2(1.0, 2.0);\n\nconst float gridSize = 1.0 / 6.0;\n\nconst float r = 0.65;\nconst vec3 eyePos = vec3(0.0, 0.0, 1.8);\n\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec4 load(vec2 id) {\n    return texture(iChannel0, (id + 0.5) / iChannelResolution[0].xy);\n}\n\nvec3 RotateX(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\n\nvec3 RotateY(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\n\nvec3 RotateZ(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nfloat dist_field(vec3 pos) {\n    float ret = length(pos) - r;\n    return ret;\n}\n\nvec2 xyz2xy(vec3 pos) {\n    vec2 ret =  vec2(atan(pos.z, pos.x) / 2.0, atan(pos.y, length(pos.xz))) / PI + 0.5;\n    ret.x = mix(gridSize * iResolution.y / iResolution.x, 1.0, ret.x);\n    return ret;\n}\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n\tfloat shininess = 16.0;\n\tvec3 final = vec3(0.0);\n\tvec3 ev = normalize(v - eye);\n\tvec3 ref_ev = reflect(ev, n);\n    vec3 tex = texture(iChannel1, xyz2xy(v)).xyz;\n\t{\n\t\tvec3 light_color = vec3(1.0, 0.7, 0.7);\n\t\tvec3 vl = normalize(vec3(1.0));\n\t\tfloat diffuse  = max(0.0, dot(vl, n));\n\t\tfloat specular = max(0.0, dot(vl, ref_ev));\n\t\tspecular = pow(specular, shininess) / 4.0;\n\t\tfinal += light_color * (diffuse + specular);\n\t}\n\t{\n        vec3 light_color = vec3(0.4, 0.6, 0.9);\n\t\tvec3 vl = normalize(vec3(-1.0));\n\t\tfloat diffuse  = max(0.0, dot(vl, n));\n\t\tfloat specular = max(0.0, dot(vl, ref_ev));\n\t\tspecular = pow(specular, shininess) / 4.0;\n\t\tfinal += light_color * (diffuse + specular); \n\t}\n\treturn clamp((final + 0.3)* tex, 0.0, 1.0);\n}\n\nvec3 gradient(vec3 pos) {\n\tconst vec3 dx = vec3(grad_step, 0.0, 0.0);\n\tconst vec3 dy = vec3(0.0, grad_step, 0.0);\n\tconst vec3 dz = vec3(0.0, 0.0, grad_step);\n\treturn normalize(\n\t\tvec3(dist_field(pos + dx) - dist_field(pos - dx),\n             dist_field(pos + dy) - dist_field(pos - dy),\n             dist_field(pos + dz) - dist_field(pos - dz)));\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n\tfloat depth = start;\n\tfor (int i = 0; i < max_iterations; i++) {\n\t\tfloat dist = dist_field(origin + dir * depth);\n\t\tif (dist < stop_threshold) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif (depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize(vec3(xy, -z));\n}\n\nvec4 getGrid(vec2 uv) {\n    if (uv.x < gridSize) {\n        return vec4(0.0, floor(uv.y / gridSize), mod(uv.xy, gridSize) / gridSize);\n    }\n    return vec4(-1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 resizeUV = fragCoord / iResolution.y;\n    vec4 grid = getGrid(resizeUV);\n    vec4 view = load(idView);\n    if (grid.x > -0.5) {\n        fragColor = vec4(texture(iChannel1,uv));\n        return;\n    }\n    if (view.x > 0.5) {\n        fragColor = vec4(texture(iChannel1,uv));\n        return;\n    }\n\tvec3 eye = eyePos;\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n    dir = RotateX(dir,  iTime / 3.0);\n    dir = RotateY(dir,  iTime / 3.0);\n    eye = RotateX(eye,  iTime / 3.0);\n    eye = RotateY(eye,  iTime / 3.0);\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far);\n\tif (depth >= clip_far) {\n\t\tfragColor = vec4(vec3(mix(0.5, 0.8, uv.y)), 1.0);\n        return;\n\t}\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient(pos);\n\tfragColor = vec4(shading(pos, n, eye), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 idBrushSize = vec2(0.0,0.0);\nconst vec2 idBrushColor = vec2(0.0,1.0);\nconst vec2 idResolution = vec2(0.0,2.0);\nconst vec2 idGrid = vec2(1.0,0.0);\nconst vec2 idMouse = vec2(1.0,1.0);\nconst vec2 idView = vec2(1.0, 2.0);\n\nconst float gridSize = 1.0 / 6.0;\nconst float initBrushSize = 0.006;\nconst float brushScale = 2.0;\n\nvec4 load(vec2 id) {\n    return texture(iChannel0, (id + 0.5) / iResolution.xy);\n}\n\nvoid save(vec2 id, vec4 val, inout vec4 fragColor, vec2 fragCoord) {\n    vec2 diff = abs(id + 0.5 - fragCoord);\n    if (max(diff.x, diff.y) < 0.5) {\n        fragColor = val;\n    }\n}\n\nvec4 getGrid(vec2 uv) {\n    if (uv.x < gridSize) {\n        return vec4(0.0, floor(uv.y / gridSize), mod(uv.xy, gridSize) / gridSize);\n    }\n    return vec4(-1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    if (fragCoord.x > 2.0 || fragCoord.y > 3.0) return;\n    // Initialization.\n    if (iFrame == 0) {\n        save(idBrushSize, vec4(initBrushSize), fragColor, fragCoord);\n        save(idBrushColor, vec4(0.0), fragColor, fragCoord);\n        return;\n    }\n    vec4 resolution = load(idResolution);\n    resolution.zw = resolution.xy;\n    resolution.xy = iResolution.xy;\n    save(idResolution, resolution, fragColor, fragCoord);\n    // Mouse clicked, update.\n    if (iMouse.z > 0.5) {\n        vec2 mousePos = iMouse.xy / iResolution.y;\n        vec4 mouse = load(idMouse);\n        mouse.zw = mouse.xy;\n        mouse.xy = mousePos;\n        // Keep track of mouse pos from previous frame to draw line in between.\n        save(idMouse, mouse, fragColor, fragCoord);\n        vec4 grid = getGrid(mousePos);\n        if (grid.x > -0.5 && mouse.w < -0.5) {\n            if (grid.y > 1.0 / gridSize - 1.5) {\n                save(idBrushColor, vec4(grid.zw, 1.0, 1.0), fragColor, fragCoord);\n            } else if (grid.y > 1.0 / gridSize - 2.5) {\n                vec4 view = load(idView);\n                save(idView, vec4(view.x < 0.5 ? 1.0 : 0.0), fragColor, fragCoord);\n            } else {\n                save(idGrid, vec4(grid.y), fragColor, fragCoord);\n                save(idBrushSize, vec4(pow(brushScale, grid.y) * initBrushSize), fragColor, fragCoord);\n            }\n        }\n    } else {\n        save(idMouse, vec4(-1.0), fragColor, fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 idBrushSize = vec2(0.0,0.0);\nconst vec2 idBrushColor = vec2(0.0,1.0);\nconst vec2 idResolution = vec2(0.0,2.0);\nconst vec2 idGrid = vec2(1.0,0.0);\nconst vec2 idMouse = vec2(1.0,1.0);\nconst vec2 idView = vec2(1.0, 2.0);\n\nconst float gridSize = 1.0 / 6.0;\nconst float initBrushSize = 0.006;\nconst float brushScale = 2.0;\nconst float brushSmooth = 0.7;\n\nconst float r = 0.65;\nconst vec3 eyePos = vec3(0.0, 0.0, 1.8);\n\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float clip_far = 1000.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec4 load(vec2 id) {\n    return texture(iChannel0, (id + 0.5) / iChannelResolution[0].xy);\n}\n\nvec3 getColor(vec2 uv) {\n    vec3 rgb = vec3(uv.x);\n    if (uv.y > 1.0 / 3.0) {\n        rgb = clamp(abs(mod(uv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n        rgb = ((uv.y - 1.0 / 3.0) * 3.0 / 2.0) * mix(vec3(1.0), rgb, 1.0);\n    }\n    return rgb;\n}\n\nfloat dist(vec2 p, vec2 posA, vec2 posB) {\n    vec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(p - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\treturn distance(p, proj);\n}\n\nvec4 draw(vec2 pos, float brushSize, vec3 brushColor, vec2 A) {\n    float d = distance(pos, A);\n\tfloat f = smoothstep(brushSize * brushSmooth, brushSize, d);\n    return vec4(brushColor, 1.0 - f);\n}\n\nvec4 draw(vec2 pos, float brushSize, vec3 brushColor, vec2 A, vec2 B) {\n    float d = dist(pos, A, B);\n\tfloat f = smoothstep(brushSize * brushSmooth, brushSize, d);\n    if (d > brushSize) {\n        return vec4(brushColor, 0.0);\n    }\n    return vec4(brushColor, 1.0 - f);\n}\n\nvec4 draw(vec3 pos, float brushSize, vec3 brushColor, vec3 A) {\n    float d = distance(pos, A);\n\tfloat f = smoothstep(brushSize * brushSmooth, brushSize, d);\n    return vec4(brushColor, 1.0 - f);\n}\n\nvec4 getGrid(vec2 uv) {\n    if (uv.x < gridSize) {\n        return vec4(0.0, floor(uv.y / gridSize), mod(uv.xy, gridSize) / gridSize);\n    }\n    return vec4(-1.0);\n}\n\n\nvoid drawGrid(vec4 grid, inout vec4 fragColor) {\n    float selectedGrid = load(idGrid).x;\n    vec2 gridCenter = vec2(0.0, gridSize * grid.y) + vec2(gridSize / 2.0);\n    vec2 uv = (grid.xy + grid.zw) * gridSize;\n    fragColor = vec4(0.92, 0.92, 0.92, 1.0);\n    if (grid.y > 1.0 / gridSize - 1.5) {\n        fragColor = vec4(getColor(grid.zw), 1.0);\n    } else if (grid.y > 1.0 / gridSize - 2.5) {\n        vec4 view = load(idView);\n        if (view.x > 0.5) {\n            float dist = abs(distance(uv, gridCenter) / gridSize - 0.3);\n            vec3 col = clamp(vec3(pow(dist, 0.3) * 1.3), 0.0, 1.0);\n            fragColor = vec4(mix(fragColor.xyz, vec3(col), 1.0 - col), 1.0);\n        } else {\n            float dist = length(max(abs(uv - gridCenter) / gridSize - vec2(0.27, 0.21), 0.0));\n            vec3 col = vec3(pow(1.0 - dist, 50.0));\n            fragColor = vec4(mix(fragColor.xyz, vec3(col), col), 1.0);\n        }\n    } else {\n        if (abs(selectedGrid - grid.y) < 0.5) {\n            fragColor = vec4(0.8, 0.8, 0.9, 1.0);\n        }\n        vec3 brushColor = getColor(load(idBrushColor).xy);\n        vec4 col = draw(uv, pow(brushScale, grid.y) * initBrushSize, brushColor, gridCenter);\n        fragColor = vec4(mix(fragColor.xyz, col.xyz, col.w), 1.0);\n    }\n}\n\nvec3 xy2xyz(vec2 pos) {\n    pos.x = 1.0 - (1.0 - pos.x) / (1.0 - gridSize * iResolution.y / iResolution.x);\n    pos -= 0.5;\n    return vec3(cos(pos.x * 2.0 * PI) * cos(pos.y * PI) * r,\n                sin(pos.y * PI) * r,\n                sin(pos.x * 2.0 * PI) * cos(pos.y * PI) * r);\n}\n\nvec3 RotateX(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\n\nvec3 RotateY(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\n\nvec3 RotateZ(vec3 v, float rad) {\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nfloat dist_field(vec3 pos) {\n    float ret = length(pos) - r;\n    return ret;\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n\tfloat depth = start;\n\tfor (int i = 0; i < max_iterations; i++) {\n\t\tfloat dist = dist_field(origin + dir * depth);\n\t\tif (dist < stop_threshold) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif (depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 resizeUV = fragCoord / iResolution.y;\n    vec4 resolution = load(idResolution);\n    if (iFrame == 0 || (resolution.z > 0.0 && resolution.z != iResolution.x)) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    vec4 grid = getGrid(resizeUV);\n    if (grid.x > -0.5) {\n\t\tdrawGrid(grid, fragColor);\n        return;\n    }\n    fragColor = texture(iChannel1, uv);   \n    float brushSize = load(idBrushSize).x;\n    vec3 brushColor = getColor(load(idBrushColor).xy);\n    vec2 curPos = iMouse.xy / iResolution.y;\n    if (iMouse.z > 0.0) {\n        vec4 view = load(idView);\n        if (view.x > 0.5) {\n            vec2 prePos = load(idMouse).zw;\n            vec4 preCol = vec4(0.0);\n            if (prePos.x < 0.0) {\n                prePos = curPos;\n            } else {\n                preCol = draw(resizeUV, brushSize, brushColor, prePos);\n            }\n            vec4 col = draw(resizeUV, brushSize, brushColor, prePos, curPos);\n            // Restore color from previous step to prevent drawing intersaction twice.\n            // But I think this part may still not right.\n            fragColor.xyz = clamp((fragColor.xyz - preCol.xyz * preCol.w) / (1.0 - preCol.w), 0.0, 1.0);\n            fragColor = vec4(mix(fragColor.xyz, col.xyz, col.w), 1.0);\n            return;\n        }\n        vec3 eye = eyePos;\n        vec3 dir = ray_dir(45.0, iResolution.xy, iMouse.xy);\n        dir = RotateX(dir,  iTime / 3.0);\n        dir = RotateY(dir,  iTime / 3.0);\n        eye = RotateX(eye,  iTime / 3.0);\n        eye = RotateY(eye,  iTime / 3.0);\n        float depth = ray_marching(eye, dir, 0.0, clip_far);\n        // clicked on the sphere\n        if (depth < clip_far) {\n            vec3 pos = eye + dir * depth;\n            vec3 curPos = xy2xyz(uv);\n            // Haven't figured out how to draw a line between previous pos and current pos.\n            vec4 col = draw(curPos, brushSize, brushColor, pos);\n            fragColor = vec4(mix(fragColor.xyz, col.xyz, col.w), 1.0);\n            return;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}