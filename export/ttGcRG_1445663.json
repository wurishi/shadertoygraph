{"ver":"0.1","info":{"id":"ttGcRG","date":"1611214365","viewed":266,"name":"verbose hammer","username":"Carandiru","description":"ended up doing a little more than trying to reproduce a bug...","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["pixel","oddwayofdoingthings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/ttGcRG\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    uv.x *= iResolution.x/iResolution.y;\n     \n    float cellSize = max(iResolution.x,iResolution.y) * 0.08f;\n    \n    vec2 suv = uv;\n    ivec2 q;\n    float i = triangle_wave(iTime);\n    \n    uv -= mod(uv, 1.0 / cellSize);\n    uv.x *= 0.5f;\n    \n    q = ivec2(floor((uv * 0.5f + 0.5f) * iResolution.xy + 0.5f));\n    float s = texelFetch(iChannel1, q, 0).x * i;\n    \n    q = ivec2(floor((uv * 0.5f + 0.5f) * iResolution.xy + 0.5f));\n    float d = texelFetch(iChannel2, q, 0).x;\n    \n    vec2 la = vec2(s + d);\n    \n    uv = rotate(suv, iTime * 0.1f);\n    \n    uv = uv * 0.5f + 0.5f;\n    vec4 c0c1 = textureGrad(iChannel0, magnify(uv, iResolution.xy), dFdx(uv), dFdy(uv)).xzyz;\n\n    la = mix( vec2(la.x * (1.0f - c0c1.w) + c0c1.z * (la.y), la.y + c0c1.w),\n              la + c0c1.xy,\n              smoothstep(0.0f, 1.0f, i));\n              \n    la = mix(la * GOLDEN_RATIO_ZERO, la, aaStep( SCANLINE_INTERLEAVE * 0.5f, \n        mod(fragCoord.y, SCANLINE_INTERLEAVE - (1.0f/iResolution.y) * 0.5f) ) );\n        \n    fragColor = vec4(la.x * la.y);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define SCANLINE_INTERLEAVE 5.0f\n\n#define fma(a,b,c) (a*b+c)\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t//return(XMVectorSet(SFM::__fms(p.x, angle.c, p.y * angle.s),\n\t//\t\t\t\t     SFM::__fma(p.x, angle.s, p.y * angle.c), p.z, p.w));\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\nfloat triangle_wave(in float time) \n{\n\treturn(abs(fract(time) * 2.0f - 1.0f));\n}\n\nvec2 magnify(in vec2 uv, in vec2 dimensions)\n{\n    uv *= dimensions; \n    return (clamp(fract(uv) / clamp(fwidth(uv), 0.0f, 1.0f), 0.0f, 1.0f) + floor(uv) - 0.5f) / dimensions;\n}\n\nfloat aaStep(in float compValue, in float gradient){\n  float halfChange = fwidth(gradient) * 0.5f;\n\n  //base the range of the inverse lerp on the change over one pixel\n  float lowerEdge = compValue - halfChange;\n  float upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    float o = 0.0f;\n    \n    if ( uv.x > -0.5f && uv.x < 0.5f \n      && uv.y > -0.5f && uv.y < 0.5f) {\n                \n        o = 1.0f;\n        o *= step(0.65f, textureLod(iChannel0, uv * 0.5f + 0.5f, 0.0f).r);\n    \n    }\n    \n   \n    fragColor = vec4(o, (1.0f - o), o, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    float o = 0.0f;\n    \n    if ( uv.y > -0.90f && uv.y < 0.90f) {\n                \n        o = 1.0f;\n        uv.x += iTime;\n        o *= step(0.99f, textureLod(iChannel0, uv * 0.5f + 0.5f, 0.0f).r);\n    \n    }\n    \n   \n    fragColor = vec4(o);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    float o = 0.0f;\n    \n    if ( uv.y > -0.90f && uv.y < 0.90f) {\n                \n        o = 1.0f;\n        \n        uv.x += iTime * GOLDEN_RATIO_ZERO * 0.25f;\n        float t0 =  textureLod(iChannel0, uv * 0.5f + 0.5f, 0.0f).r;\n        uv.x += iTime * GOLDEN_RATIO_ZERO * 0.5f;\n        float t1 =  textureLod(iChannel0, uv * 0.5f + 0.5f, 0.0f).r;\n        \n        o *= step(0.99f, t0) * t0 + step(0.9999f, t1) * t1;\n    \n    }\n    \n   \n    fragColor = vec4(o);\n}","name":"Buffer C","description":"","type":"buffer"}]}