{"ver":"0.1","info":{"id":"slccRB","date":"1660028145","viewed":76,"name":"Packing int to half","username":"M_cgode","description":"Packing a 16-bit short into a half float (with the half <-> float conversion in-between) losslessly.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["packing","half"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Use factor to have \n    const float kFactor = 1.f / 8.f;\n\n    uint value = uint(fragCoord.x * kFactor)\n        + uint(fragCoord.y * kFactor) \n        * uint(iResolution.x * kFactor);\n    \n    float packed = packIntToHalf(value);\n    \n    bool isSame = value == unpackHalfToInt(packed);\n    \n    fragColor = isSame ? vec4(0, 1, 0, 1) : vec4(1, 0, 0, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/// 1024 is one of the first values that guarantee losslessness\n#define OFFSET 1024u\n\n/// CPU-usable packing function.\n/// \n/// We first assume that the integer is a bitwise representation of a IEE 16-bits float.\n/// Next, we manually convert that f16 bits float to a 32-bits float representation (lossless)\n/// according to the IEEE spec.\n/// We then just need to bitcast back to float. \n/// The float conversion between half and float should also be lossless in this context.\n///\n/// It should be noted though that an offset must be applied to the integer, as the lowest half\n/// values can indeed experience conversion data loss.\n/// The supported range of integer is [0, 32767 - OFFSET]\nfloat packIntToHalf(in uint _f16)\n{\n    uint f16 = _f16 + OFFSET;\n    \n    uint signBits = (f16 & 0x8000u) << 16;\n    uint expBits = ((f16 & 0x7fffu) == 0u) ? 0u : (((f16 & 0x7c00u) >> 10) + 127u - 15u) << 23;\n    uint mantBits = (f16 & 0x03ffu) << 13;\n    uint f32 = signBits | expBits | mantBits;\n    \n    float f = uintBitsToFloat(f32);\n    \n    // Convert to half then back to float to emulate potentially lossy half <-> float conversion.\n    f = unpackHalf2x16(packHalf2x16(vec2(f, 0))).x;\n    \n    return f;\n}\n\n// GPU side easy unpacking function\n// Could also be done manually by reverting the function above.\nuint unpackHalfToInt(in float _packedValue)\n{\n    uint value = packHalf2x16(vec2(_packedValue, 0));\n    return value - OFFSET;\n}","name":"Common","description":"","type":"common"}]}