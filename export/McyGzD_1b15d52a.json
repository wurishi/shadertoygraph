{"ver":"0.1","info":{"id":"McyGzD","date":"1712770516","viewed":60,"name":"CutieTurdie","username":"EvoraDilemma","description":"A cute turd <3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["turd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDonut(vec3 p, float R, float r)\n{\n    return sqrt(p.y*p.y +(length(vec2 (p.x,p.z))- R)*(length(vec2 (p.x,p.z))- R))-r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nmat2 rot2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c);\n}\n\nvec2 sdf(vec3 p)\n{    \n    p.xy *= rot2d(0.02*sin(4.0*iTime)*p.y);\n    float id = 0.0;\n    float d = sdDonut(p-vec3(0.0,-0.2,0.0),2.3,1.0);\n    d = min(d, sdDonut(p-vec3(0.0,1.0,0.0),1.7,0.8));\n        d = min(d, sdDonut(p-vec3(0.0,2.1,0.0),1.2,0.5));\n\n    float dMouth = sdCappedTorus((p-vec3(0.0,0.5,-3.5))*vec3(1.0,-1.0,1.0),vec2(0.8,-0.2),0.4,0.08);\n    if (dMouth < d)\n    {\n        d = dMouth;\n        id = 1.0;\n    }\n    \n             p.xy *= rot2d(-0.02*p.y);\n        d=min(d,sdCone(p-vec3(0.3,3.8,-0.6),vec2(0.5,0.8),1.4));\n    \n        float dEyeWhite = sdEllipsoid( p- vec3(0.45,1.35,-2.85),vec3(0.1,0.1,0.1));\n    dEyeWhite = min(dEyeWhite, sdEllipsoid( p- vec3(-0.65,1.35,-2.85),vec3(0.1,0.1,0.1)));\n    if (dEyeWhite < d)\n    {\n        d = dEyeWhite;\n        id = 2.0;\n    }\n        \n    p.x = abs(p.x);\n    \n    float dEyeBlack = sdEllipsoid( p- vec3(0.6,1.25,-2.5),vec3(0.3,0.38,0.3));\n    if (dEyeBlack < d)\n    {\n        d = dEyeBlack;\n        id = 1.0;\n    }\n    \n    return vec2(d, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 -1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0,0.9,-6.5);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.4));\n\n    float max_iter = 80.0;\n    float eps = 0.005;\n\n    float t = 0.0;\n    float i = 0.0;\n    while (true)\n    {\n        vec3 p = ro + t * rd;\n        float dist = sdf(p).x;\n        if (dist > eps && t <500.0 && i < max_iter)\n        {\n            t = t + dist;\n            i = i + 1.0;\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    vec3 newp = ro + t * rd;\n    vec2 newDistAndId = sdf(newp).xy;\n    \n    if (newDistAndId.x <=eps)\n    {\n        col = vec3(0.6,0.3,0.05);\n        if (newDistAndId.y == 1.0)\n        {\n            col = vec3(0);\n        }\n        if (newDistAndId.y == 2.0)\n        {\n            col = vec3(1);\n        }\n        col = col * (1.0 - i/max_iter);\n    }\n\n    // Output to screen\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}