{"ver":"0.1","info":{"id":"NtGcWK","date":"1662370127","viewed":121,"name":"Drawing blob","username":"grom12345","description":"Draw with mouse!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","sdf","deformation","blob","paint","drawing","cellularautomata"],"hasliked":0,"parentid":"7lVcDy","parentname":"Drawing automata"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv*=.5;\n \n    vec4 col;\n    col = texture(iChannel1, uv);\n    \n    //col = pow(abs(col), vec4(2.2));\n    fragColor = col;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera camera = getCamera(fragCoord, iResolution, iTime);\n   \n    vec4 dCol = RayMarch(camera.ro, camera.rd);\n    vec3 col = vec3(.0);\n    vec2 uvt = dCol.yz;//-iTime*.1;\n    vec2 id = floor(uvt*10.-.5);\n    float checkers = mod(id.y+id.x, 2.);\n    float d = dCol.w;\n\n    if(d<MAX_DIST) {\n       col = dCol.rgb;\n       \n       if (dCol.x==1.){\n           col = clamp(texture(iChannel1, uvt*texPart).rgb, 0., 1.);\n       }else{\n           vec2 id = floor(uvt*2.-.5);\n           float checkers = mod(id.y+id.x, 2.);\n           col = vec3(.3)*checkers;\n       }\n        vec3 p = camera.ro + camera.rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = vec3(10, 10, 10);\n        \n        if (dCol.x==1.){\n        \n            n.xy*= Rot(sin(uvt.x*500.)*.1);\n            n.xz*= Rot(sin(uvt.y*500.)*.1);\n            float dif = dot(n, normalize(r));\n            dif = mix(dif*0.5+.5, max(dif, 0.), .8);\n            col *= pow(dif, .2);\n            col += pow(dif, 100.);\n        \n            float step = .005;\n            float steps = 10.;\n            float occ = 1.;\n            for(float i=1.; i<=steps; i++) {\n               vec3 p1 = p+n*step*i;\n               float d1 = GetDist(p1).w;\n               occ *= 1.-max(0., d1-step);\n            }\n            col *= vec3(pow(1.85-occ, 5.));\n        }else{\n            n.yz*= Rot(sin(uvt.x*100.)*.1);\n            n.xy*= Rot(cos(uvt.y*100.)*.1);\n            float dif = dot(n, normalize(r));\n            dif = mix(dif*0.5+.5, max(dif, 0.), .8);\n            col *= pow(dif, .2);\n            col += pow(dif, 100.);\n        \n            float step = .1;\n            float steps = 15.;\n            float occ = 1.;\n            vec3 occCol = vec3(1.);\n            for(float i=1.; i<=steps; i++) {\n               vec3 p1 = p+n*step*i;\n               vec4 dCol = GetDist(p1);\n               vec2 uvt = dCol.yz;\n               float d1 = dCol.w;\n               \n               if(d1-step>0.){\n                   occ *= 1.-(d1-step);\n               }else{\n                   \n                   occCol = (occCol+texture(iChannel1, uvt*texPart).rgb)/2.;\n               }\n            }\n            col *= pow(1.8-occ, 2.);\n            col = mix(col, occCol, occ*.3);\n        }\n    }\n    \n    col = pow(col, vec3(.5));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 fetch(ivec2 c){\n    ivec2 size = ivec2(iResolution.xy*texPart);\n    ivec2 coord = ivec2((c+size)%size);\n    return texelFetch(iChannel1, coord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color1 = vec4(0);\n    float count = 0.;\n    int u = 1+int(iTime*.1)%8;\n    int sx = 1+int(iTime*.1)%5;\n    int sy = 1+int(iTime*.1)%5;\n    vec4 c0 = fetch(ivec2(fragCoord));\n    for (int x = -u*(sx/2); x <= u*(sx/2) ; x+=u){\n        for (int y = -u*(sy/2); y <= u*(sy/2) ; y+=u){\n            if(x==0&&y==0) break;\n            vec4 c = fetch(ivec2(fragCoord)+ivec2(x, y));\n\n            if(c0.a<c.a){\n                color1 += c;\n                count += 1.;\n            }\n        }\n    }\n\nif(count>0.){\n    color1 /=count;\n    color1.r += (hash1(fragCoord*10.+iTime).x-.5)*.2;\n    color1.g += (hash1(fragCoord*10.+iTime).y-.5)*.2;\n    color1.b += (hash1(fragCoord*38.+iTime).x-.5)*.2;\n    //color1.rgb = mix(c0, color1+hash(fragCoord*.1).x*.1, .5).rgb;\n}else{\n    color1 = c0;\n}\n\nvec2 m = hash(vec2(iTime))*iResolution.xy;\nif(iMouse.z > 0.0) {\n   m = iMouse.xy;\n}\n    \n    Camera camera = getCamera(m, iResolution, iTime);\n    vec4 dCol = RayMarch(camera.ro, camera.rd);\n    if(dCol.x==1.){\n        vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n        vec2 mUV = dCol.yz*texPart-.5;\n\n        float dst = length(uv - mUV);  \n        if(dst <= spotSize) {\n            vec3 col = vec3(sin(iTime*5.)*2.+1.,\n                            sin(iTime*5.+pi*.5)*2.+1.,\n                            sin(iTime*5.+pi)*2.+1.);\n            color1 = vec4(col, iTime);\n        }\n    }\n//}\n    \n//if(iFrame<100) color1 = texture(iChannel0, uv);\n    fragColor = color1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.1415926535\n\n#define texPart 1.\n#define spotSize 0.01\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec2 hash1( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n#define MAX_STEPS 200\n#define MAX_DIST 20.\n#define SURF_DIST .0001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Camera{\n    vec3 ro;\n    vec3 rd;\n};\n\nCamera getCamera(vec2 fragCoord, vec3 iResolution, float iTime){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*0.1+1.6;\n    float n = (sin(time*2.))*.5;\n    mat2 nn = Rot(time);\n    mat2 nn1 = Rot(PI*.22+n);\n    vec3 ro = vec3(0., .5, -4.+cos(time));\n    ro.yz *= nn1;\n    ro.xz *= nn;\n    \n    \n    vec3 rd = vec3(uv, 1.);\n    rd.yz *= nn1;\n    rd.xz *= nn;\n    \n    rd = normalize(rd);\n    return Camera(ro, rd);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn abs(length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.))-0.01;\n}\n\nfloat sdPlane(vec3 p, float z){\n    return p.z-z;\n}\n\nvec2 koch(vec2 uv, int k) {\n    uv.x = abs(uv.x);\n   \n    float d;\n    \n    vec2 n = N((5./6.)*3.1415);\n    \n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n    \n    float scale = 1.;\n    \n    n = N((2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<k; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n    }\n    uv /= scale;\n    return uv;\n}\n\nvec2 koch3D(vec3 p, int n){\n     vec2 uv = p.xy;\n     return koch(uv, n);\n}\n\nvec4 GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    vec3 tp=p;\n    \n    tp = p+sin(tp.x*5.5)*sin(tp.y*7.)*sin(tp.z*4.)*.3;\n    tp.xy*=Rot(.4);\n    \n    float time = 0.;\n    float floorPlane = (p.y+.435-0.02*(1.-time));\n    vec2 q = vec2(length(tp.xz)-1.,-tp.y+1.2);\n    float t = atan(tp.x, tp.z)/(PI*2.)+.5;\n    time = t*(time);\n    float uvY = atan(q.x, q.y)/PI;\n    q.xy *= Rot(time*PI*0.125);\n    //p.xy += vec2(sin(iTime*0.32895+p.z), cos(iTime*0.123765+p.z))*0.5;\n    int n1;\n    int n2;\n    float k;\n    float scale1;\n    float scale2;\n    \n    float parts = 7.;\n    int part = int(time*parts);\n    n1 = part;\n    n2 = part+1;\n    scale1 = pow(4./3., float(part));\n    scale2 = scale1*4./3.;\n    k = (time-float(part)/parts)*parts;\n    \n    \n    \n    vec2 koch1 = koch(q*scale1, n1)/scale1;\n    vec2 koch2 = koch(q*scale2, n2)/scale2;\n    \n    vec2 dd = mix(koch1, koch2, k);\n    vec2 uv = vec2(t, uvY);\n    \n    float d = length(q-vec2(.5, 0))-.5;\n    d *= .5;\n    \n    if (floorPlane<d){\n        p+=sin(p.x*2.5)*sin(p.y*3.)*sin(p.z*2.)*1.;\n        return vec4(0, p.xz, floorPlane);\n    }else{\n        return vec4(1, uv, d);\n    }\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec4 dS;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS.w;\n        if(dO>MAX_DIST || abs(dS.w)<SURF_DIST) break;\n    }\n    \n    return vec4(dS.rgb, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).w - \n        vec3(GetDist(p-e.xyy).w, GetDist(p-e.yxy).w,GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\n","name":"Common","description":"","type":"common"}]}