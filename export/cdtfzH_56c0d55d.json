{"ver":"0.1","info":{"id":"cdtfzH","date":"1698339100","viewed":38,"name":"3d cloud renderer","username":"mikeyaboy","description":"Mik0 is my other account that i use in school. Everything in this project is original.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley"],"hasliked":0,"parentid":"DsdBRH","parentname":"3d worley noise"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float lerp(float a, float b, float x)\n{\n    return (a*(1.0-x)) + (b*x);\n}\n\nvec2 lerp(vec2 a, vec2 b, float x)\n{\n\n    return (a*(1.0-x)) + (b*x);\n}\n\nvec3 lerp(vec3 a, vec3 b, float x)\n{\n    return (a*(1.0-x)) + (b*x);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat worley(vec3 p)\n{\n    float finalDist = 64.0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                float dist = distance(p, floor(p)+offset+hash33(floor(p)+offset));\n                finalDist = min(finalDist, dist);\n            }\n        }\n    }\n    return (1.0 - finalDist)*0.35;\n    //return texture(iChannel0, p).x*0.35;\n}\n\nfloat cloudNoise(vec3 p)\n{\n    p+=iTime*0.5;\n    float total;\n    float divide;\n    for(int i = 1; i <= 1; i++)\n    {\n        total += worley(vec3((p+float(i)*1.5)*float(i)))/float(i);\n        divide += 1.0/float(i);\n    }\n    //total *= pow(worley(vec3(p*0.5)), 1.5);\n    return clamp(pow(total/divide, 1.0), 0.0, 1.0);\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nconst float convert = acos(0.0)/90.0;\n\nvec3 getVec(vec2 a)\n\n{\n    return vec3(sin((a.x)*convert)*cos((a.y)*convert), cos((a.x)*convert)*cos((a.y)*convert), sin((a.y)*convert));\n}\n\nRay cam(vec3 o, vec2 a, float zoom, vec2 uv)\n{\n    vec3 forward = vec3(sin((a.x)*convert)*cos((a.y)*convert), cos((a.x)*convert)*cos((a.y)*convert), sin((a.y)*convert));\n    vec3 up = vec3(sin((a.x)*convert)*cos((a.y+90.0)*convert), cos((a.x)*convert)*cos((a.y+90.0)*convert), sin((a.y+90.0)*convert));\n    vec3 right = vec3(sin((a.x+90.0)*convert), cos((a.x+90.0)*convert), 0.0);\n    vec3 p = (forward*zoom)+(up*uv.y)+(right*uv.x);\n    return Ray(o, normalize(p));\n}\n\nvec3 getSky(vec2 a, Ray ray)\n{\n    vec3 sunVec = getVec(vec2(a.x, a.y));\n    vec3 sky1 = vec3(0.5, 0.75, 1.0)*pow(dot(vec3(0, 0, 1), sunVec), 0.05);\n    vec3 sky2 = vec3(1.0, 0.75, 0.5)*pow(dot(ray.dir, sunVec), 3.0);\n    vec3 sky = lerp(sky2, sky1, pow(clamp(0.5*ray.dir.z+0.5, 0.0, 1.0), 1.5));\n    if(dot(ray.dir, sunVec)>0.995)\n    {\n    sky = vec3(1.0,1.0,1.0);\n    }\n    return clamp(sky, 0.0, 1.0);\n}\n\nfloat castRay(Ray ray, float size, int steps)\n{\n    float density = 0.0;\n    float total = 0.0;\n    vec3 p = ray.origin;\n    \n    for(int i = 0; i<steps; i++)\n    {\n        if(length(p.z)>1.0){density = 0.0;}\n        else{density = cloudNoise(p*0.2);}\n        total+=density;\n        p+=ray.dir*size;\n    }\n    \n    return total*size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=0.5;\n    \n    Ray ray = cam(vec3(-getVec(vec2(m.x*360.0, m.y*180.0))*8.0), vec2(m.x*360.0, m.y*180.0), 0.5, uv);\n    \n    vec3 sun = getVec(vec2(45.0, 90.0));\n    \n    vec3 sky = getSky(vec2(45.0, 90.0), ray);\n    \n    float size = 0.5;\n    int steps = int(16.0/size);\n    \n    float density = 0.0;\n    float total = 0.0;\n    float shadow = 0.0;\n    vec3 p = ray.origin;\n    \n    for(int i = 0; i<steps; i++)\n    {\n        if(length(p.z)>1.0){density = 0.0;}\n        else{density = cloudNoise(p*0.2);}\n        total+=density*size;\n        shadow+=(castRay(Ray(p, sun), size*2.0, steps/2)*size)*(1.0/pow(2.71828, total));\n        p+=ray.dir*size;\n    }\n    \n    vec3 col = lerp(vec3(1,1,1)*((1.0/pow(2.71828, shadow))), sky, 1.0/pow(2.71828, total));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}