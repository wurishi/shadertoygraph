{"ver":"0.1","info":{"id":"XffXR7","date":"1705052886","viewed":89,"name":"Van Damm grid unfinished","username":"bugmenot","description":"Description of this beautiful shader","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"MclSzN","parentname":"Van Damma Popierdolilo"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cellSize = 8.;\n\nbool isWhite(in vec4 col)\n{\n    return (col[0]+col[1]+col[2] < 1.0);\n}\n\nbool isWhite(in vec3 col)\n{\n    return (col[0]+col[1]+col[2] < 1.0);\n}\n\nbool isActuallyWhite(in vec4 col)\n{\n    return (col[3] == 1.0);\n}\n\n\nvoid checkCell(inout float nearestDist, inout vec2 nearest, in vec2 cellLocation, in vec2 fragCoord)\n{\n    for (float y = cellLocation.y; y < cellLocation.y+cellSize; y++) {\n        for (float x = cellLocation.x; x < cellLocation.x+cellSize; x++) {\n            vec2 location = vec2(x, y);\n            vec3 pixel = texture(iChannel0, location/iResolution.xy).rgb;\n            float dist = distance(location, fragCoord);\n            if (isWhite(pixel) && dist < nearestDist) {\n                nearestDist = dist;\n                nearest = location;\n            }\n        }\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, q).rgb;\n    \n    vec2 cell = floor(fragCoord / cellSize);\n    vec2 currentCellLoc = cell * cellSize +0.5;\n    \n    \n    vec2 nearestCellLoc = vec2(0, 0);\n    float nearestCellDist = 9999.;\n    for (float y = 0.5; y < iResolution.y+0.5; y+=cellSize) {\n        for (float x = 0.5; x < iResolution.x+0.5; x+=cellSize) {\n            vec2 location = vec2(x, y);\n            vec4 pixel = texture(iChannel0, location/iResolution.xy).rgba;\n            float dist = distance(location, currentCellLoc);\n            if (isActuallyWhite(pixel) && dist < nearestCellDist) {\n                nearestCellDist = dist;\n                //nearestCellLoc = floor(location / cellSize)*cellSize;\n                nearestCellLoc = location +0.5;\n            }\n        }\n    }\n    \n    \n    vec2 nearest = vec2(0, 0);\n    float nearestDist = 9999.;\n    \n    vec2 cellDiff = currentCellLoc - nearestCellLoc;\n    float searchRadius = min(abs(cellDiff.x), abs(cellDiff.y))+8.;\n    for (float y = currentCellLoc.y-searchRadius+0.5; y <= currentCellLoc.y+searchRadius+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x-searchRadius+0.5, y), fragCoord);\n    }\n    \n    for (float y = currentCellLoc.y-searchRadius-cellSize+0.5; y <= currentCellLoc.y+searchRadius+cellSize+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x-searchRadius-cellSize+0.5, y), fragCoord);\n    }\n    for (float y = currentCellLoc.y-searchRadius-cellSize+0.5; y <= currentCellLoc.y+searchRadius+cellSize+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x-searchRadius+cellSize+0.5, y), fragCoord);\n    }\n    //*/\n    \n    for (float y = currentCellLoc.y-searchRadius+0.5; y <= currentCellLoc.y+searchRadius+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x+searchRadius+0.5, y), fragCoord);\n    }\n    for (float y = currentCellLoc.y-searchRadius-cellSize+0.5; y <= currentCellLoc.y+searchRadius+cellSize+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x+searchRadius-cellSize+0.5, y), fragCoord);\n    }\n    for (float y = currentCellLoc.y-searchRadius-cellSize+0.5; y <= currentCellLoc.y+searchRadius+cellSize+0.5; y+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(currentCellLoc.x+searchRadius+cellSize+0.5, y), fragCoord);\n    }\n    \n    for (float x = currentCellLoc.x-searchRadius+0.5; x <= currentCellLoc.x+searchRadius+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y-searchRadius+0.5), fragCoord);\n    }\n    for (float x = currentCellLoc.x-searchRadius-cellSize+0.5; x <= currentCellLoc.y+searchRadius+cellSize+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y-searchRadius-cellSize+0.5), fragCoord);\n    }\n    for (float x = currentCellLoc.x-searchRadius-cellSize+0.5; x <= currentCellLoc.y+searchRadius+cellSize+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y-searchRadius+cellSize+0.5), fragCoord);\n    }\n    \n    for (float x = currentCellLoc.x-searchRadius+0.5; x <= currentCellLoc.x+searchRadius+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y+searchRadius+0.5), fragCoord);\n    }\n    for (float x = currentCellLoc.x-searchRadius-cellSize+0.5; x <= currentCellLoc.y+searchRadius+cellSize+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y+searchRadius-cellSize+0.5), fragCoord);\n    }\n    for (float x = currentCellLoc.x-searchRadius-cellSize+0.5; x <= currentCellLoc.y+searchRadius+cellSize+0.5; x+=cellSize) {\n        checkCell(nearestDist, nearest, vec2(x, currentCellLoc.y+searchRadius+cellSize+0.5), fragCoord);\n    }\n    \n    /*\n        for (float x = 0.5; x < iResolution.x; x+=cellSize) {\n           vec2 cellLoc = vec2(x, y);\n           checkCell(nearestDist, nearest, cellLoc, fragCoord);\n        }\n        */\n    \n    /*\n    for (float y = nearestCellLoc.y; y < nearestCellLoc.y+cellSize; y++) {\n        for (float x = nearestCellLoc.x; x < nearestCellLoc.x+cellSize; x++) {\n            vec2 location = vec2(x, y);\n            vec3 pixel = texture(iChannel0, location/iResolution.xy).rgb;\n            float dist = distance(location, fragCoord);\n            if (isWhite(pixel) && dist < nearestDist) {\n                nearestDist = dist;\n                nearest = location;\n            }\n        }\n    }\n    */\n\n    \n    \n    vec2 diff = normalize(fragCoord-nearest);\n    vec4 res = vec4(0., (1.+diff.x)/2., (1.+diff.y*-1.)/2., 0.);\n    \n    //uncomment if you wanna see the black and white \"source\" image\n    /*\n    if (isWhite(col)) {\n        res = vec3(1., 1., 1);\n    } else {\n        res = vec3(0., 0., 0);\n    }\n    //*/\n        \n    vec2 q1 = fragCoord / iResolution.xy;\n    vec4 col1 = texture(iChannel0, q).rgba;\n    fragColor = mix(col1, vec4(col1[3], col1[3], col1[3], 0.), 0.5);\n    \n    fragColor = mix(res, vec4(col1[3], col1[3], col1[3], 0.), .0);\n    \n\n    \n    \n\t//fragColor = vec4(nearestCellDist/iResolution.x*5.,nearestCellDist/iResolution.x,nearestCellDist/iResolution.x*5., 1.0); \n    \n    /*\n    res = vec4(0.,0.,0.,0.);\n    for (float y = currentCellLoc.y-searchRadius+0.5; y < currentCellLoc.y+searchRadius+0.5; y+=cellSize) {\n        if (fragCoord.y > y && fragCoord.y < y+searchRadius) {\n            res = vec4(1.,1.,1.,0.);\n        }\n    }\n    for (float y = currentCellLoc.y-searchRadius+0.5; y < currentCellLoc.y+searchRadius+0.5; y+=cellSize) {\n        if (fragCoord.y > y && fragCoord.y < y+searchRadius) {\n            res = vec4(1.,1.,1.,0.);\n        }\n    }\n    for (float x = currentCellLoc.x-searchRadius+0.5; x < currentCellLoc.x+searchRadius+0.5; x+=cellSize) {\n        if (fragCoord.x > x && fragCoord.x < x+searchRadius) {\n            res = vec4(1.,1.,1.,0.);\n        }\n    }\n    for (float x = currentCellLoc.x-searchRadius+0.5; x < currentCellLoc.x+searchRadius+0.5; x+=cellSize) {\n        if (fragCoord.x > x && fragCoord.x < x+searchRadius) {\n            res = vec4(1.,1.,1.,0.);\n        }\n    }\n    fragColor = res;\n    */\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float cellSize = 8.;\n\nbool isWhite(in vec4 col)\n{\n    return (col[0]+col[1]+col[2] < 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cell = floor(fragCoord / cellSize);\n    vec2 cellLocation = cell * cellSize+0.5;\n    \n    bool containsWhite = false;\n    for (float y = cellLocation.y+0.5; y < cellLocation.y+cellSize+0.5; y++) {\n        for (float x = cellLocation.x+0.5; x < cellLocation.x+cellSize+0.5; x++) {\n            vec2 q = vec2(x, y) / iResolution.xy;\n            vec4 col = texture(iChannel0, q).rgba;\n            if (isWhite(col)) {\n                containsWhite = true;\n            }\n        }\n    }\n    \n    vec2 q = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, q).rgba;\n    fragColor = col;\n    \n    \n    if (containsWhite) {\n        fragColor[3] = 1.0;\n    } else {\n\n        fragColor[3] = 0.0;\n    }\n    \n    \n    \n    /*\n    vec4 col;\n    if (isWhite(texture(iChannel0, fragCoord/iResolution.xy).rgba)) {\n        col = vec4(1.0,1.0,1.0,1.0);\n    } else {\n        col = vec4(0.0,0.0,0.0,1.0);\n    }\n    fragColor = mix(fragColor, col, 0.5);\n    */\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}