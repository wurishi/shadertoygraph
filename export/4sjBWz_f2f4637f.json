{"ver":"0.1","info":{"id":"4sjBWz","date":"1508701869","viewed":531,"name":"Space Battle","username":"yangb","description":"Space battle using simple geometric shapes as ships.\n\nThanks to:\naiekick for particle effect (https://www.shadertoy.com/view/Xs2BWR)\ncalx for HUD (https://www.shadertoy.com/view/4dtSRl)\nxaot88 for starfield (https://www.shadertoy.com/view/Md2SR3)","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 f, vec2 g )\n{\n\tvec4 background = texelFetch(iChannel3, ivec2(g),0);\n\tf = texelFetch(iChannel0, ivec2(g),0); // thanks to dave hoskins\n    f += texelFetch(iChannel1, ivec2(g),0);\n    f += texelFetch(iChannel2, ivec2(g),0);\n    \n    if (length(f) < 0.2)\n    {\n        f = background;\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 f, vec2 g )\n{\n    f.xyz = iResolution;\n    vec2 v = (g+g-f.xy)/f.y*3.,k;\n    f *= texture(iChannel0, g/f.xy) / length(f);\n   \tg = vec2(iFrame);\n    f += 1e-2 / dot(\n        k = v - sin(g + vec2(1.6,0)) * fract(iTime*.1+4.52*sin(g*6.5))*3.,\n        k);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define QUARTER_PI 0.78539816339\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nconst vec4 \tBLUE\t\t\t= vec4(0.306, 0.502, 0.537, 1.000);\nconst vec4 \tRED\t\t\t\t= vec4(0.941, 0.306, 0.208, 1.000);\nconst vec4 \tGREY_BLUE\t\t= vec4(0.494, 0.620, 0.663, 1.000);\nconst vec4 \tYELLOW\t\t\t= vec4(0.969, 1.000, 0.804, 1.000);\nconst vec4 \tGREEN\t\t\t= vec4(0.804, 1.000, 0.965, 1.000);\nconst vec4 \tGREY\t\t\t= vec4(0.449, 0.481, 0.489, 1.000);\nconst vec4 \tD_GREY\t\t\t= vec4(0.050, 0.050, 0.050, 1.000);\nconst vec4 \tM_GREY\t\t\t= vec4(0.200, 0.200, 0.200, 1.000);\nconst vec4 \tWHITE \t\t\t= vec4(1.000, 1.000, 1.000, 1.000);\nconst vec4 \tT_WHITE \t\t= vec4(1.000, 1.000, 1.000, 0.500);\nconst vec4 \tBLACK\t\t\t= vec4(0.000, 0.000, 0.000, 0.000);\nconst vec2 \tORIGIN \t\t\t= vec2(0.0);\nconst float LINE_WEIGHT \t= 0.0035;\nconst float METER_WEIGHT \t= 0.0100;\n\t  float SMOOTH\t\t\t= 0.0;\n\t  float R_SMOOTH\t\t= 0.2000;\n\nfloat map(float value, float istart, float istop, float ostart, float ostop) \n{\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nfloat n_angleBetween(vec2 v1, vec2 v2)\n{\n    float angle = atan(v1.y-v2.y, v1.x-v2.x);\n    return ((angle < 0.0) ? (angle += TWO_PI) : angle) / TWO_PI;\n}\n\nvec2 rotate(vec2 v, float rotation)\n{\n\treturn vec2(cos(rotation)*v.x + sin(rotation)*v.y, -sin(rotation)*v.x + cos(rotation)*v.y);\n}\n\nfloat radialLine(vec2 r, float radius, float cutoff, float weight, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 180.0;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring * line;;\n}\n\nfloat radialMeter(vec2 r, float radius, float cutoff, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;  \n\tfloat or = \tir + METER_WEIGHT;   \n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 200.0;\n    float grads = fract(s);    \n\tfloat steps = (1.0-smoothstep((0.4-R_SMOOTH), (0.41+R_SMOOTH), grads)) * smoothstep((0.2-R_SMOOTH),(0.21+R_SMOOTH), grads) ;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n\n    steps *= ring * line;\n        \n\treturn steps;\n}\n\nfloat dottedSect(vec2 r, float radius, float cutoff, float dotSize, bool flip, float num)\n{ \n    float a = num;\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n    float theta =  round(n_angleBetween(uv, vec2(0.0)) * (TWO_PI * a)) / a;\n    float x = radius * cos(theta);\n    float y = radius * sin(theta);\n    vec2  v = vec2(x, y);   \n \tfloat d = distance(uv, v);\n    float e = smoothstep(d-SMOOTH, d+SMOOTH, dotSize);\n    float line =  step(theta, cutoff);\n\n    return e*line;\n}\n\nfloat returnBracket(vec2 r, float radius, float cutoff, float weight, float vCut, bool flip)\n{\n    vec2 uv =  rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float line =   step(theta, cutoff/TWO_PI);\n    float halfs =  (cutoff/TWO_PI) / 2.0;\n    float sec = step(halfs-(vCut/TWO_PI), theta) * (1.0-step(halfs+((vCut/TWO_PI)), theta));\n\tfloat ring = smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n  \n\treturn ring * (line - sec);\t\n}\n\nfloat solBracket(vec2 r, float radius, float weight, float cutoff, float cut, float retrn)\n{\n    vec2 uv =  r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n  \tfloat ring =  smoothstep(ir-SMOOTH, ir+SMOOTH, d) * (1.0 - smoothstep(or-SMOOTH, or+SMOOTH, d));\n    float circ = step(radius+weight, d);\n\tfloat block = \tsmoothstep(uv.y-SMOOTH, uv.y+SMOOTH, cutoff) * (1.0 - smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -cutoff));\n    float topLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH,  cutoff-weight);\n    float botLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -(cutoff-(weight)));\n    \n\tfloat xblock = step(-retrn, uv.x) * (1.0-step(retrn, uv.x));\n    float yblock = step(-cut, uv.y) * (1.0-step(cut, uv.y));\n    \n    ring *= block;\n    topLine *= (1.0 - botLine);\n    block *= (1.0 - topLine);\n    ring += block;\n    ring *= 1.0-circ;\n    float blocks = (xblock+yblock);\n    \n\treturn ring * (1.0-(blocks));\t\n}\n\nfloat single(vec2 r, float radius, float weight)\n{\n    vec2  uv = r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring;\n}\n\nfloat splitLine(vec2 r, float w, float yOffset, float split, float weight) \n{\n    vec2 uv = r + vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float g = step(uv.x, split) * (1.0-step(split, -uv.x));\n    \n    return f * l * (1.0-g);\n}\n\nfloat meter(vec2 r, float w, float yOffset, float inc, float weight, float num) \n{\n    vec2 uv = r - vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float incr = fract(uv.x*num);\n    float gnn = (1.0-smoothstep((0.4-SMOOTH), (0.41+SMOOTH), incr)) * smoothstep((0.2-SMOOTH),(0.21+SMOOTH), incr);\n    f *= (gnn * l);   \n    \n    return f ;\n}\n\nfloat grid(vec2 r, float num, float weight)\n{\n    vec2 uv = r * num;\n    float gridx = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.x));\n    float gridy = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.y));\n    \n    return (1.0 - (gridx * gridy));\n}\n\nfloat dots(vec2 r, float num, float pointSize)\n{\n    vec2 uv = r * num;\n    vec2  v = vec2(round(uv.x),round(uv.y));   \n \tfloat d = distance(uv, v);\n    return smoothstep(d-SMOOTH, d+SMOOTH, pointSize);   \n}\n\nfloat bg(vec2 r, float w, float h)\n{\n    float f = 1.0 - step(w, distance(r, ORIGIN));\n    \n    float g = step(-h, r.y) * (1.0-step(h, r.y));\n    \n    f *= g;\n    \n\treturn 1.0-f;\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 hashPosition(float x)\n{\n    return vec2(hash(x) * 64.0, hash(x * 1.1) * 64.0);\n}\n\nfloat sineOut(float t) \n{\n  return sin(t * HALF_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SMOOTH \t\t= map(iResolution.x, 800.0, 2560.0, 0.0025, 0.0010);\n\tvec2 uv =  2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float rotation = - PI / 4.0;\n    rotation = 0.0;\n    uv = vec2(cos(rotation)*uv.x + sin(rotation)*uv.y, -sin(rotation)*uv.x + cos(rotation)*uv.y);\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\t\n\tconst float sequenceDuration = 1.25;\n\tfloat currentSequence = floor(iTime / sequenceDuration);\n\tfloat currentSequenceTime = mod(iTime, sequenceDuration);\n\tvec2  startingPosition = hashPosition(currentSequence) * 0.005;\n\tvec2  goalPosition = hashPosition(currentSequence + 1.0) * 0.005;\n\tvec2  currentPosition;\n\tconst float speed = 0.5;\n\tfloat potentialDistance = speed * currentSequenceTime;\n\tfloat goalDistance = length(goalPosition - startingPosition);\n    \n\tif (potentialDistance < goalDistance) {\n\t\tcurrentPosition = mix(startingPosition, goalPosition, sineOut(potentialDistance / goalDistance));\n\t} else {\n\t\tcurrentPosition = goalPosition;\n\t}\n\t\n    vec2 targetPosition = uv-currentPosition;\n    \n    vec4 tex = texture(iChannel0, q) * 0.1; \n    \n    vec4 final  = mix(tex, \tBLACK, \tbg(uv, 1.4805, 0.500) * 0.50);      \n    \t final *= mix(tex, \tBLACK, \tbg(uv, 1.2805, 0.702) * 0.25); \n    \n    final = mix(final, \tWHITE\t, dots(uv, 20.0, 0.04) * 0.25);    \n    final = mix(final, \tWHITE\t, grid (uv, 10.0, 0.03) * 0.10);   \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, true)); \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, true));\n    final = mix(final,  BLUE    , splitLine  (targetPosition, 0.3000, 0.3300, 0.0160, 0.005));\n    final = mix(final,  WHITE   , splitLine  (targetPosition, 0.6231, 0.0000, 0.5324, LINE_WEIGHT));\n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, false, 12.40)); \n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, true, 12.40));  \n    final = mix(final,  GREY    , solBracket (targetPosition, 0.3490, LINE_WEIGHT, 0.3, 0.265, 0.000));\n   \tfinal = mix(final,  WHITE   , solBracket (targetPosition, 0.3777, LINE_WEIGHT, 0.05, 0.018, 0.3675));\n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, false));   \n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, true)); \n    final = mix(final,  GREY    , single     (targetPosition, 0.4527, LINE_WEIGHT));\n   \tfinal = mix(final, \tGREY_BLUE, splitLine  (targetPosition, 0.6231, 0.0, 0.5324, LINE_WEIGHT));    \n    final = mix(final, \tBLUE\t, solBracket (targetPosition, 0.5750, LINE_WEIGHT, 1.0, 0.2314, 0.0000));\n \tfinal = mix(final, \tWHITE\t, solBracket (uv, 1.4805, LINE_WEIGHT, 0.7000, 0.0592, 1.2900));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.6685, 0.1592, 0.0000));\n    final = mix(final, \tGREY\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.7000, 0.6950, 0.0000));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5174, 0.0000, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5374, 0.5300, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.6390, 0.6300, 0.8551));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, false, 112.40));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, true, 112.40));\n    final = mix(final, \tGREY\t, meter\t\t (uv, 0.8500, 0.6390, 0.9324, 0.010, 50.0));\n    \n\n    fragColor = final;\n} ","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int MAX_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat leftShip(vec3 p)\n{\n    vec3 b = vec3(.08);\n    vec3 r = vec3(.2, .075, .075);\n    \n    float body = sdEllipsoid(p + vec3(-0.1, 0., 0.), r);\n    float tail = udBox(p + vec3(0.1, 0., 0.), b);\n    \n    float ship = opU( body, tail );\n    \n    return ship;\n}\n\nfloat rightShip(vec3 p)\n{\n    vec3 b = vec3(.5, .05, .05);\n    float s = .08;\n    \n    float main = udBox(p, b);\n    float center = sdSphere(p + vec3(-0.1, 0., 0.), s);\n    \n    float ship = opU(main, center);\n    \n    return ship;\n}\n\nfloat sdScene( vec3 p )\n{\n    //vec3 b = vec3(.2, 0.075, 0.075);\n    //vec3 r = vec3(.2, .075, .075);\n    \n    //float ship = rightShip(p, b, r, h);\n    \n    //return ship;\n    \n    \n    float ship1 = rightShip(p + vec3(.005*sin(iTime)-2.2, .01*sin(iTime), -0.3));\n    float ship2 = rightShip(p + vec3(.007*sin(iTime)-1.8, .011*sin(iTime)+1., 0.3));\n    float ship3 = rightShip(p + vec3(.004*sin(iTime)-1.8, .013*sin(iTime)-0.55, 0.2));\n    float ship4 = rightShip(p + vec3(.009*sin(iTime)-2.1, .008*sin(iTime)+0.5, 0.0));\n    \n    float ship12 = opU(ship1, ship2);\n    float ship34 = opU(ship3, ship4);\n    \n    float ship1234 = opU(ship12, ship34);\n    \n    \n    \n    float ship5 = leftShip(p + vec3(.005*cos(iTime)+2., .01*cos(iTime)+.8, -0.3));\n    float ship6 = leftShip(p + vec3(.007*cos(iTime)+2.1, .011*cos(iTime)-.4, -0.3));\n    float ship7 = leftShip(p + vec3(.004*cos(iTime)+1.9, .013*cos(iTime)+.4, -0.3));\n    float ship8 = leftShip(p + vec3(.009*cos(iTime)+2.2, .008*cos(iTime)+.1, -0.3));\n\n    float ship56 = opU(ship5, ship6);\n    float ship78 = opU(ship7, ship8);\n    \n    float ship5678 = opU(ship56, ship78);\n    \n    float ship1to8 = opU(ship1234, ship5678);\n    \n    return ship1to8;\n    \n}\n\nfloat rMarcher(vec3 ro, vec3 rd, float start, float end)\n{\n    float depth = start; //starting depth from camera?\n    \n    for(int i = 0; i < MAX_STEPS; i++) //going until limit (dont want to go on forever)\n    {\n        float dist = sdScene(ro + depth * rd); //finding smallest distance to object\n        \n        if (dist < EPSILON) //check whether it hit or not\n        {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) //check if it goes past MAX_DIST (if so, just return MAX_DIST)\n        {\n            return end;\n        }\n    }\n    return end; //just return MAX_DIST because it didn't hit anything ^_^\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) { //expain\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 ro, vec3 c, vec3 up) { //need to explain\n    // Based on gluLookAt man page\n    vec3 f = normalize(c - ro);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 estimateNormal(vec3 p) { //needs explanation\n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)) - sdScene(vec3(p.x - EPSILON, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)) - sdScene(vec3(p.x, p.y - EPSILON, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, //ripped from\n                          vec3 lightPos, vec3 lightIntensity) {\t\t\t\t //phong reflection model\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) { \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0., 0., -3.);                    //change light position!\n    vec3 light1Intensity = vec3(.01*sin(iTime), .01*sin(iTime), .01*sin(iTime));\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(.1*cos(iTime) + .5, .1*cos(iTime) + .5, .1*cos(iTime) + .5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 10.);\n\tvec3 rd = rayDirection(45., iResolution.xy, fragCoord); //explain\n    \n    mat4 viewToWorld = viewMatrix(ro, vec3(0., 0., 0.), vec3(0., 1., 0.)); //explain\n    \n    vec3 worldDir = (viewToWorld * vec4(rd, 0.0)).xyz; //explain\n\n    float dist = rMarcher(ro, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) \n    {\n        fragColor = vec4(0., 0., 0., 0.); //pixel color is black\n        return;\n    }\n    else\n    {\n        vec3 p = ro + dist * worldDir;\n        \n        vec3 K_a = vec3(.2, .2, .2);\n        vec3 K_d = vec3(.7, .2, .2);\n        vec3 K_s = vec3(1., 1., 1.);\n        float shininess = 10.0;\n        \n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, ro);\n        \n        fragColor = vec4(color, 1.);\n        //fragColor = vec4 (1., 0., 0., 1.);\n    }\n}\n\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Sky Background Color\n\tvec3 vColor = vec3( 0.1, 0.2, 0.4 ) * fragCoord.y / iResolution.y;\n\n    // Note: Choose fThreshhold in the range [0.99, 0.9999].\n    // Higher values (i.e., closer to one) yield a sparser starfield.\n    float StarFieldThreshhold = 0.97;\n\n    // Stars with a slow crawl.\n    float xRate = 0.2;\n    float yRate = -0.06;\n    vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( iFrame ) * .25, yRate * float( iFrame ) *.25 );\n\tfloat StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    vColor += vec3( StarVal );\n\t\n\tfragColor = vec4(vColor, 1.0);\n}\n\n","name":"Buf D","description":"","type":"buffer"}]}