{"ver":"0.1","info":{"id":"wdGyDm","date":"1603035202","viewed":104,"name":"RayMarchingggggg","username":"EcureuilViolent","description":"Ray March","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_DISTANCE 100.\n#define MAX_STEPS 100\n#define SURF_DIST .01\n#define RITER 5\n\nstruct Ray {\n    vec3 o,d;\n};\n\nstruct Material {\n    vec4 c;\n    float r;\n};\n\nstruct Light {\n    vec3 p;\n    vec4 c;\n};\n\nstruct Object {\n    vec3 p;\n    float d;\n    Material m;\n};\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat boxSDF(vec3 p, vec3 c) {\n    vec3 q=abs(p)-c;\n    return length(max(q,0.0))+ min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylSDF(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torusSDF(vec3 p, float a, float b) {\n    vec2 pp = normalize(p.xz)*(a);\n    return(length(vec3(pp.x,0.,pp.y)-p)-b);\n}\n\nmat2 Rotate(float t) {\n    float s=sin(t), c=cos(t);\n    return mat2(c,-s,s,c);\n}\n\nObject Add(Object a, Object b) {\n    if (a.d < b.d) {return a;}\n    return b;\n}\n\nObject Sub(Object a, Object b) {\n       if (a.d > -b.d) {return a;}\n    return Object(b.p, -b.d, b.m);\n}\n\nObject Inter(Object a, Object b) {\n       if (a.d > b.d) {return a;}\n    return Object(b.p, b.d, b.m);\n}\n\nfloat SmoothMin(float a, float b, float k){\n    float h = clamp(.5 + .5 *(b-a)/k, 0., 1.);\n    return  mix(b, a, h) - k * h * (1.- h);\n}\n\nObject sAdd(Object a, Object b, float k) {\n    if (a.d < SmoothMin(b.d,a.d,k)+.1) {return Object(a.p, SmoothMin(a.d,b.d,k),a.m);}\n    return Object(b.p, SmoothMin(a.d,b.d,k),b.m);;\n}\n\nObject sSub(Object b, Object a, float k) {\n    if (a.d < SmoothMin(-b.d,a.d,k)+.3) {return Object(a.p, -SmoothMin(a.d,-b.d,k),a.m);}\n    return Object(b.p, -SmoothMin(a.d,-b.d,k),b.m);\n}\n\nfloat sInter(float d0, float d1, float k) {\n    return -SmoothMin(-d0,-d1,k);\n}\n\n\nObject SafeDist(vec3 p) {\n\n    \n    Material M1 = Material(vec4(.9,.7,.0,1.),.8);\n    Material M2 = Material(vec4(.9,.99,1.,1.),.0);\n    \n    Object oa[2];\n    \n    float size = 1.3;\n    p = (p - vec3(0.,0.,4.))/size+vec3(0.,0.,4.);\n    \n    for (float i = 0.; i <= 1.; i++) {\n        \n        vec3 off = vec3(0.,.6*cos(iTime*2.)*i+.5*size,0.);\n        \n        vec3 ps0 = vec3(0.,0.,4.)+off;\n        vec3 s0 = p - ps0;\n        float ds0 = sphereSDF(s0,2.5);\n        Material ms0 = M1;\n        Object os0 = Object(ps0,ds0,ms0);\n\n        vec3 ps2 = vec3(0.,0.,4.)+off;\n        vec3 s2 = p - ps0;\n        float ds2 = sphereSDF(s2,2.3);\n        Material ms2 = M1;\n        Object os2 = Object(ps2,ds2,ms2);\n\n\n        vec3 pt0 = vec3(0.,0.,4.)+off;\n        vec3 t0 = p-pt0;\n        Material mt0 = M1;\n        float dt0 = torusSDF(t0,3.,1.);\n        Object ot0 = Object(pt0,dt0,mt0);\n\n        vec3 pb0 = vec3(0.,0.,4.)+off;\n        vec3 b0 = p-pb0;\n        b0.xz*=Rotate(PI/4.*i);\n        Material mb0 = M1;\n        float db0 = boxSDF(b0,vec3(2.));\n        Object ob0 = Object(pb0,db0,mb0);\n        \n        vec3 pb3 = vec3(0.,2.3*pow(-1.,i),4.)+off;\n        vec3 b3 = p-pb3;\n        b3.xz*=Rotate(PI/4.*i);\n        Material mb3 = M2;\n        float db3 = boxSDF(b3,vec3(4.,2.,4.));\n        Object ob3 = Object(pb3,db3,mb3);\n        \n        Object o = Sub(ob0,ot0);\n        o = Inter(o,os0);\n        o = Sub(o,os2);\n        \n        oa[int(i)] = Sub(o,ob3);\n        \n    }\n    \n    p = (p - vec3(0.,0.,4.))*size+vec3(0.,0.,4.);\n    \n    vec3 pb0 = vec3(10.,0.,13.);\n    vec3 b0 = p - pb0;\n    b0.xz*=Rotate(PI/4.);\n    float db0 = boxSDF(b0,vec3(15.,15.,.4));\n    Material mb0 = M1;\n    Object ob0 = Object(pb0,db0,mb0);\n    \n\n    vec3 pb1 = vec3(0.,5.5,4.);\n    vec3 b1 = p-pb1;\n    Material mb1 = M2;\n    float db1 = boxSDF(b1,vec3(15.,8.,15.));\n    Object ob1 = Object(pb1,-db1,mb1);\n\n\n    \n\n    Object o = sAdd(oa[0],oa[1],.01);\n\n    o = Add(o,ob1);\n    o = Add(o,ob0);    \n    \n    return o;\n}\n\nvec3 GetNormal(vec3 p) { \n    vec2 e = vec2(.01,0.);\n    float d = SafeDist(p).d;\n    vec3 n = d-vec3(\n\t\tSafeDist(p-e.xyy).d,\n\t\tSafeDist(p-e.yxy).d,\n\t\tSafeDist(p-e.yyx).d);\n    return normalize(n);\n}\n\n\nRay GetRay(vec3 camOgn, vec3 lookAt, float zoom, vec2 uv) {\n    Ray a;\n    a.o = camOgn;\n    vec3 up = vec3(0., 1., 0.);\n    vec3 fwd = normalize(lookAt - camOgn);\n    vec3 right = cross(fwd, up);\n\n    vec3 i = camOgn + zoom * fwd + up * uv.y + right * uv.x;\n    a.d = normalize(i-a.o);\n    return a;\n}\n\nObject RayMarch(Ray ray) {\n    \n    float d = 0.;\n    Object o;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        o = SafeDist(ray.o+d*ray.d);\n        d+=o.d*.75;\n        if (abs(o.d) < SURF_DIST) \n            { return Object(o.p, d, o.m);; }\n        else if (d>MAX_DISTANCE)\n            { return Object(o.p, d, Material(vec4(vec3(0.),0.), 0.)); }\n    }\n}\n\nvec3 GetLight(vec3 p) {\n    \n    Light lArray[2] = Light[](Light(vec3(0.*cos(iTime)+0., 10., 4.),vec4(1.,1.,1., 3.)),Light(vec3(0., 1., 4.),vec4(.9,.3,.0,3.)));\n    \n    vec3 n = GetNormal(p);\n    \n    vec3 lInt = vec3(0.);\n\t\n    for (int i = 0; i<lArray.length();i++) {\n        vec3 l = lArray[i].p;\n\n        \n        vec3 dir = l-p;\n        float r = length(dir);\n        dir /= r;\n        float coef = clamp(pow(dot(dir, n),1.), 0.0, 1.);\n\n        vec3 pp = p+2.*SURF_DIST*n;\n\n        float dl = RayMarch(Ray(pp, normalize(l-pp))).d;\n\n        if (dl<length(pp-l)) \n            { coef*=.1;}\n        lInt += coef*lArray[i].c.xyz/r*lArray[i].c.w;\n    }\n    return vec3(clamp(lInt,0.,1.));\n}\n\nvec3 GetColor(Ray r) {\n    \n    //Couleur de l'objet\n    Object o = RayMarch(r);\n    vec3 q = r.o;\n    vec3 p = r.o + r.d * o.d;\n    vec3 c = o.m.c.xyz * GetLight(p);\n    \n    //Calcul de sa reflection\n    \n    int i = 0;\n    \n    while (o.m.r > 0. && i < RITER) {\n   \t\t\n        float ref = o.m.r;\n        p = r.o + r.d * o.d;\n\n        vec3 dir = normalize(p-q);\n        vec3 n = GetNormal(p);\n        \n        vec3 pp = p + 2.*SURF_DIST*n;\n        \n        vec3 s = normalize(dir-2.*dot(dir,n)*n);\n        \n        r = Ray(pp,s);\n        o = RayMarch(r);\n        \n        c = ref*o.m.c.xyz*GetLight(r.o+r.d*o.d)+(1.-ref)*c;\n        q = pp;\n    \n        i++;\n    }\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n   \n    vec3 camOgn = vec3(-sin(iTime/3.), 0., -cos(iTime/3.))*13.+vec3(0.* sin(iTime/3.), 4., 4.);\n    vec3 lookAt = vec3(0., 0., 4.);\n\n    float zoom = 1.;\n\n    vec3 color = GetColor(GetRay(camOgn,lookAt,zoom,uv));\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}