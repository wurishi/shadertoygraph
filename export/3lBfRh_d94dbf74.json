{"ver":"0.1","info":{"id":"3lBfRh","date":"1629243135","viewed":332,"name":"Cubic Space.","username":"julianlumia","description":"remixing some older shaders, don't mind the code mess i made here while doing so;)","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["twistyspacetunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.005).x;\n    fragColor.y = T(uv -f*0.006).y;\n    fragColor.z = T(uv-f*0.03).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 70.\n#define SURF_DIST .001\n\n//---------\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\n\nvec2 path(float z){\n float x = sin(z) - 4.0 * cos(z * 0.3) - .5 * sin(z * 0.12345);\n float y = cos(z) - 4. * sin(z * 0.3) - .5 * cos(z * 2.12345);\n return vec2(x,y);\n}\n\n\nvec2 modA (vec2 p, float count) {\n float an = TAU/count;\n float a = atan(p.y,p.x)+an*.5;\n a = mod(a, an)-an*.5;\n return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n\n\n//----\n\n\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\n\n\nfloat g5;\n\nmat2 E;\nfloat T;\n\nvec2 GetDist(vec3 p) {\n      float r = 3.14159*sin(p.z*0.5);//+cos(T*0.025*1.);\n    E = mat2(cos(r), sin(r), -sin(r), cos(r));\n//        p.xy*= E;  \n                     float the =(p.z*0.0*1.);\n\n  p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n vec2 d;\n vec3 p2 = p;\n\n\n float gap = 1.;\n p2 = mod(p + gap,2.0 * gap) - gap;\n\n//    p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n     vec3 p4 = p;\n     float gap2 =2.;\n\n p4.z = mod(p.z + gap2,2.0 * gap) - gap;\n    \n vec2 box = vec2(sdBox(p2-vec3(1.0,0.0,.0), vec3(0.0,.0,0.)),3);\n vec2 box2 = vec2(sdBox(p2-vec3(0.,0.,.0), vec3(1.,.02,.8)),3);\n vec2 box3 = vec2(sdBox(p2-vec3(0,0.,0), vec3(.3,1.,1.)),3);\n// float prev = 1.;\n// vec3 p1 = vec3( p- vec3(1.,1.0,sin(iTime-3.))); \n// float the = iTime *1.3;\n// p1.x = abs(p1.x)-.9;\n// p1.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n// the = iTime *0.1;\n// p1.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n //\n    \n    //\n    //p2 = vec3( p- vec3(1.0,1.,1.5)); \n the = iTime *.1;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.05;\n\n    \n    \n    p2.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n    \n    \n //    p2.x *= abs(p2.x)-.6;\n    \n     //   E = mat2(cos(r), sin(r), -sin(r), cos(r));\n//        p.xy*= E;  \n   //                   the =(p2.z*0.3*1.);\n\n // p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n     float n = sin(dot(floor(p), vec3(27, 113, 57)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .05;\n        vec3 rnd2 = fract(vec3(2097152, 262144, 32768)*n)*0.1 - 0.1;\n\n    // Repeat factor. If irregularity isn't your thing, you can get \n    // rid of \"rnd\" to line things up again.\n//    p = fract(p + rnd) - .5;\n    // vec2 dbox =vec2( sdOctahedron( p1,.2),3);\n\n  gap = 1.;\n    p2 =p;\n p2 = mod(p + gap,2.0 * gap) - gap;\n      gap = 1.1;\n\n //    p2.x = mod(p.x + gap,2.0 * gap) - gap;\n    \n        gap = 1.1;\n\n     //p2.y = mod(p.y + gap,2.0 * gap) - gap;\n\n    float size = .10+ rnd.y;\n     p2 = abs(p2+ rnd2)-0.5;\n     p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n//     p2 = abs(p2)-0.13;\n\n     the = iTime *1.5;\n\n     p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n     p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n vec2 dbox2 = vec2(sdBox( p2,vec3(size))*1.,3);\n vec2 dbox20 = vec2(sdOctahedron( p2,(size)),3);\n dbox2.x = mix (dbox2.x,dbox20.x,0.);\n\n    \n    \n    \n    \n    p2 = vec3( p- vec3(1.,1.,1.)); \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    the = iTime *-0.4;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.4;\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = abs(p2)-1.2;\n vec2 dbox4 = vec2(sdSphere( p2-vec3(0.,-0.,iTime),(.01)),1);\n vec3 p3 = vec3( p- vec3(1.,1.,1.-0.)); \n the = iTime *-.5;\n p3.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n //vec2 dbox5 = vec2(sdBox( p3-vec3(0,0,iTime-10.),vec3(.1)),1);\n //g1 +=1./(.1+pow(abs(dbox2.x),2.));\n //g2 +=1./(0.1+pow(abs(dbox.x),5.));\n// g3 +=1./(0.1+pow(abs(dbox4.x),2.));\n //g4 +=1./(1.+pow(abs(dbox5.x),2.));\n// dbox5.x=   min(dbox5.x,dbox4.x);\n// dbox = condmin(dbox,dbox2);\n// dbox = condmin(dbox,dbox5);\n box = condmin(box3,box);\n box = condmin(box2,box);\n// dbox = condmin(dbox,box);\n    p4.y = abs(p4.y);\n     vec2 box7 = vec2(sdBox(p4-vec3(1,1.,1.), vec3(1.2,.2,0.2)),1);\n\n    //-----------------\n     vec2 o = path(p.z) / 4.0;\n p = vec3(p)-vec3(1,1.,1.);//-vec3(o.x,o.y,0.);  \n\n// p.xy *= rz2(p.z*sin(1.+250.));    \n// q.xy *= rz2(q.z*sin(-t*0.002+250.));\n float cyl2wave = 1.+4.*(sin(p.z+t*4.)*0.);\n float cylfade = 1.+smoothstep(.0,5.,abs(p.z*1.));\n float cyl2r = 0.1*cyl2wave*cylfade;\n float cylT = 1.;\n float cylC = 1.;\n \n    vec2 cyl2p = modA(p.xy, (abs(sin(5.)+4.)))-vec2(cyl2wave, 0)*cylfade;\n    \n vec2 cyl2 = vec2(cyl(cyl2p, cyl2r),1);\n    \n    \n    \n    \n   float cyl2wave2 = 0.0+0.*(sin(p.z+t*0.)*0.1);\n float cylfade2 =0.1+smoothstep(0.,5.,abs(p.z*1.+iTime*1.));\n float cyl2r2 = .01*cyl2wave2*cylfade2;\n float cylT2 = 1.;\n float cylC2 = 1.;\n \n    vec2 cyl2p2 = modA(p.xy, (abs(sin(0.)+4.)))-vec2(cyl2wave2, 0)*cylfade2;\n    \n vec2 cyl22 = vec2(cyl(cyl2p2, cyl2r2),1);  \n    \n    \n    \n    \n    \n    \n// cyl2p = modA(p.xy*rz2(-p.z*cylT), cylC)-vec2(cyl2wave, 0)*cylfade; \n vec3 cubP = p;\n float cubC = .5;\n cubP.z = mod(cubP.z, cubC)-cubC*.01;\n cubP.xy *= rz2((t*0.75)*5.);\n    \n    vec2 cub =vec2(cube(cubP,vec3(.2*cyl2wave*cylfade)),1.);\n    \n//cyl2.x+= smin(cyl2.x, box.x,.5);\nbox.x =(max(box.x,-box7.x));\n    \nvec2 ebox = condmin(cyl2,box);\n// ebox = condmin(ebox,box7);\n\n    ebox = condmin(ebox,dbox2);\n\n\n   //     ebox = condmin(ebox,cyl22);\n\n //box.x=   min(box.x,cyl22);\n// box.x = mix (box.x,cyl22,1.);\n //dbox = condmin(dbox,dbox2); \n    //-----------------\n  //  g1 +=1./(1.+pow(abs(dbox2.x),2.));\n    g1 +=1./(.05+pow(abs(cub.x),3.));\n\n    g2 +=1./(.01+pow(abs(cyl2.x),2.));\n //   g5 +=abs(sin(iTime)*4.)/(.001+pow(abs(cyl22.x),2.));\n\n    // dbox = condmin(dbox,box);\n//dbox.x = cyl2a;\n //---------\n    \n    d = ebox;\n return d ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i <50; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || abs(t)>100.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n  //motion blurr algorithm // by noby:   https://www.shadertoy.com/view/wljSz1\n const float numb1 = 3.;\n    const float tm = numb1;\n const int samples = 1;\n float T = iTime*tm/numb1;\n float ot = T;\n for(int y = 0; y < samples; ++y)\n for(int x = 0; x < samples; ++x)\n {\n  vec2 p = -1.0 + 3.0 * (uv + (-0.5+(vec2(x, y)/float(samples)))/iResolution.xy);\n  p.x *= iResolution.x/iResolution.y;  \n  float r = texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r;\n  T = ot+(tm*r)/36.0;\n };\n     //=   \n    \n    \n vec2 m = iMouse.xy/iResolution.xy;\n //   vec3 eye = 1.0*vec3(1.,0.5,T+abs((sin(T*.1)))-1.2);\n\n vec3 eye = 1.0*vec3(1.2,1.,T*.5);\n             float the =(eye.z*.1);\n\n       float r = 3.14159*sin(eye.z*0.005);//+cos(T*0.025*1.);\n    E = mat2(cos(r), sin(r), -sin(r), cos(r));\n//        p.xy*= E;  \n              the =(eye.z*-0.2+iTime *.5);\n\n//   eye.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));   \n    \n    \n    \n  //     eye.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n     the = (T*.2);\n\n vec3 hoek = vec3(1,1.,1);  \n    the = (T*.2)-2.5;\n\nmat3 camera = setCamera( eye, hoek,4.7);\n     float fov = .9;\n vec3 dir = camera * normalize(vec3(uv, fov));\n\n vec3 focalPoint = eye + (dir );\n\n    vec3 shiftedRayOrigin = eye;\n\n    vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\n      \nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n    \n    \n    \n    \n  vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n  vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n  float t =d.x *1.;   \n   if(t>.1){\n    vec3 baseColor = vec3(0.,0.,0.);\n    shiftedRayOrigin += shiftedRay * t;\n    vec3 sn = GetNormal(shiftedRayOrigin);\n    shiftedRay = reflect(shiftedRay, sn);\n    if(d.y==3.) traceRef(shiftedRayOrigin +  shiftedRay*1., shiftedRay);\n\n  }\n }\n vec3 col;\n    \n col += marchCount * vec3(1., 1.,1.) * 0.000005;\ncol +=g1*vec3(0.0008)*abs(vec3(0.2,0.25,0.3));    \ncol +=g2*vec3(0.0003)*vec3(1.);    \ncol +=g3*vec3(0.1)*vec3(5.);    \ncol +=g5*vec3(0.00005)*vec3(abs(sin(iTime-5.)*5.),1.,0.)*abs(cos(iTime*0.5)*1.);    \n \n    \n//  col +=g4*vec3(0.1)*vec3(abs(sin(iTime)),0,0);    \n vec3 sky = vec3(1., 1., 1.);\n col = mix(sky, col, 1./(d.x*d.x/1./1.*.02+1.0)); \n\n //d*= 1.;\n col=pow(col, vec3(0.6545));\n\n fragColor = vec4(col,t);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Dof code from: 42yeah, https://shadertoy.com/view/wsXBRf\n\n// Random hash function\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(\n        dot(uv, vec2(215.1616, 82.1225)),\n        dot(uv, vec2(12.345, 856.125))\n    )) * 41234.45) * 2.0 - 1.0;\n}\n\n// Calculate CoC: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch23.html\nfloat getCoC(float depth, float focalPlane) {\n    float focalLength = .01;\n    float aperture = min(1.0, focalPlane * focalPlane);\n    return abs(aperture * (focalLength * (focalPlane - depth)) /\n        (depth * (focalPlane - focalLength)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample original texture data at uv\n    vec4 texData = texture(iChannel0, uv);\n    \n    // Get its depth\n    float depth = texData.w;\n    \n    // Focal plane at 3.9 (the camera is looking at the center from ~4.0)\n   // float focalPlane =sin(iTime)+0.7;\n    \n       float focalPlane =2.;\n\n    \n    // Calculate CoC, see above\n    float coc = getCoC(depth, focalPlane);\n    \n    // Sample count\n    const int taps = 32;\n    \n    // Golden ratio: https://www.youtube.com/watch?v=sj8Sg8qnjOg\n    float golden = 3.141592 * (3.0 - sqrt(5.0));\n    \n    // Color & total weight\n    vec3 color = vec3(0.0);\n    float tot = 0.01;\n    \n    for (int i = 0; i < taps; i++) {\n        // Radius slowly increases as i increases, all the way up to coc\n        float radius = coc * sqrt(float(i)) / sqrt(float(taps));\n        \n        // Golden ratio sample offset\n        float theta = float(i) * golden;\n        vec2 tapUV = uv + vec2(sin(theta), cos(theta)) * radius;\n        \n        // Sample the bit over there\n        vec4 tapped = texture(iChannel0, tapUV);\n        float tappedDepth = tapped.w;\n\n        if (tappedDepth > 0.0) {\n            // Use CoC over there as weight\n            float tappedCoC = getCoC(tappedDepth, focalPlane);\n            float weight = max(0.001, tappedCoC);\n            \n            // Contribute to final color\n            color += tapped.rgb * weight;\n            // And final weight sum\n            tot += weight;\n        }\n    }\n    // And normalize the final color by final weight sum\n    color /= tot;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//radial blur code from jeyko: https://www.shadertoy.com/view/WlKXRR :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    float steps = 20.0;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){  \n        scale *= -1.2;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;  \n    fragColor = radial*1.;   \n    fragColor *= 1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), .2);  \n    fragColor = max(fragColor, 0.);\n  //  fragColor.xyz = pow(fragColor.xyz, vec3(3.,sin(iTime)*0.+1.,1.));\n    fragColor *= 1. - dot(uvn,uvn)*1.9;\n}","name":"Buffer C","description":"","type":"buffer"}]}