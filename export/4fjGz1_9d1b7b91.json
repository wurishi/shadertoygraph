{"ver":"0.1","info":{"id":"4fjGz1","date":"1703831415","viewed":44,"name":"elements in space","username":"nayk","description":"cosmos, stars, elements","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["stars","cosmos","elements"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/mstyWr*/\n\n#define iterations 12\n#define formuparam 0.43\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.200\n#define distfading 0.730\n#define saturation 0.850\n\n\n\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,t) saturate(((t)-(a)) / ((b)-(a)))\n#define repeat(i,n) for(int i=0;i<n;i++)\n\nconst int EPHEMERAL_SAMPLES = 20;\n\nconst float EPHEMERAL_AMP = 0.5;\nconst float EPHEMERAL_DRIP = 1.0;\nconst float EPHEMERAL_BLUR = 0.05;\nconst vec3 EPHEMERAL_FREQ = vec3( 0.3, 0.3, 0.2 );\n\nconst float PI = acos( -1.0 );\n\nuvec3 hash3( uvec3 s ) {\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    return s;\n}\n\nvec3 hash3f( vec3 s ) {\n    uvec3 r = floatBitsToUint( s );\n    return vec3( hash3( r ) ) / float( -1u );\n}\n\nuvec3 seed;\nuvec3 random3() {\n    seed = hash3( seed );\n    return seed;\n}\n\nvec3 random3f() {\n    return vec3( random3() ) / float( -1u );\n}\n\nmat2 rotate2D( float t ) {\n    float c = cos( t );\n    float s = sin( t );\n    return mat2( c, s, -s, c );\n}\n\nmat3 getOrthogonalBasis( vec3 z ) {\n  z = normalize( z );\n  vec3 up = abs( z.y ) < 0.99 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 0.0, 0.0, 1.0 );\n  vec3 x = normalize( cross( up, z ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvec3 cyclicNoise( vec3 p, float pump ) {\n  vec4 sum = vec4( 0.0 );\n  mat3 basis = getOrthogonalBasis( vec3( -1.0, 2.0, -3.0 ) );\n  \n  repeat( i, 5 ) {\n    p *= basis;\n    p += sin( p.yzx );\n    sum += vec4(\n      cross( cos( p ), sin( p.zxy ) ),\n      1.0\n    );\n    sum *= pump;\n    p *= 2.0;\n  }\n  \n  return sum.xyz / sum.w;\n}\n\nfloat sdbox( vec2 p, vec2 s ) {\n\tvec2 d = abs( p ) - s;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdcapsule( vec2 p, vec2 tail ) {\n    float h = clamp( dot( p, tail ) / dot( tail, tail ), 0.0, 1.0 );\n    return length( p - ( tail * h ) );\n}\n\nfloat shape0( vec2 p ) {\np.x+=-cos(iTime);\np.y+=sin(iTime);\n    float s = abs( sdbox( p, vec2( 0.05, 0.0 ) ) - 0.2 ) - 0.05;\n    s = min( s, length( p ) - 0.13 );\n\n    return s;\n}\n\nfloat shape1( vec2 p ) {\np.x+=-cos(iTime);\np.y+=-sin(iTime);\n    float s = abs( sdbox( p, vec2( 0.10, 0.0 ) ) - 0.2 ) - 0.05;\n    s = min( s, length( p ) - 0.13 );\n\n    return s;\n}\nfloat shape2( vec2 p ) {\np.x+=cos(iTime);\np.y+=sin(iTime);\n    float s = abs( sdbox( p, vec2( 0.15, 0.3 ) ) - 0.2 ) - 0.05;\n    s = min( s, length( p ) - 0.13 );\n\n    return s;\n}\n\nfloat shape( vec2 p ) {\n    float s = 1E9;\n    s = min( s, shape0( p - vec2( -0.0, 0.0 ) ) );\n   \ns = min( s, shape1( p - vec2( -0.5, 0.0 ) ) );\n s = min( s, shape2( p - vec2( 0.5, 0.0 ) ) );\n\n    return s;\n}\n\nfloat grid( vec2 p ) {\n    vec2 d = abs( p - floor( p + 0.5 ) );\n    return min( d.x, d.y );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,cos(iTime*0.22));\n\tfloat time=iTime*speed+.25;\n\n\nseed = uvec3( fragCoord, iFrame );\n\n    vec2 p = uv ;\n    p*=10.1;\n    float d = 1.0 / iResolution.y;\n    \n    vec3 aa = vec3( 0.0 );\n    \n    float dice = random3f().x;\n    \n    repeat( i, EPHEMERAL_SAMPLES ) {\n        vec2 pt = p;\n        float ephemeral = ( float( i ) + dice ) / float( EPHEMERAL_SAMPLES );\n        float sqEphemeral = ephemeral * ephemeral;\n\n        pt.y -= ( 1.0 - exp( -EPHEMERAL_DRIP * sqEphemeral ) ) * abs( pt.y ) * sign( pt.y );\n        pt += EPHEMERAL_AMP * sqEphemeral * cyclicNoise( EPHEMERAL_FREQ * vec3( p, iTime - sqEphemeral ), 1.5 ).xy;\n        vec3 color = 3.0 / float( EPHEMERAL_SAMPLES ) * smoothstep( 1.5, 0.0, abs( 5.0 * ephemeral - vec3( 1.0, 1.5, 1.0 ) ) );\n        \n        aa += color * linearstep( d + EPHEMERAL_BLUR * sqEphemeral, -d, shape( pt ) );\n    }\n\tvec3 from=vec3(1.,.5,0.5)*aa;\n\tfrom+=vec3(time*2.,time,-2.);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n        fragColor+= vec4( aa, 1.0 );\n}","name":"Image","description":"","type":"image"}]}