{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Ref: http://adrianboeing.blogspot.in/2011/01/xor-demoeffect-in-webgl.html\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The first step is to calculate the position of the pixel on the screen \n    // (or canvas in case of WebGL) normalised from -1 to 1\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // 0,0 is origin we calculate distance from origin and set is as color \n\tfloat radius = sqrt(p.x*p.x + p.y*p.y);\n    \n    /*\n\t* If we want to generate concentric circles we could set a boolean value on or off\n\t* depending on a modulo operation. If we take the modulo of a value and then test \n\t* whether it is above half-way then we can generate an on-off pulse. For example, \n\t* if we get a value ranging from 0 to 1, module 0.1, we can generate a on/off pulse \n\t* by testing if it is greater than 0.05.\n\t*/\n    float modulo = mod(radius,0.1);\n\tbool toggle = false;\n\tif (modulo > 0.05) \n        toggle = true;\n    \n    if (toggle)\n\t\tfragColor = vec4(1.0* ( 0.5 * (1.0 +sin(iTime))),0.0,0.0,1.0);\n\telse\n        // phasing green color ahead by pi/2\n\t\tfragColor = vec4(0.0,1.0* ( 0.5 * (1.0 +sin(iTime + 1.57))), 0.0,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdBSDD","date":"1412071664","viewed":149,"name":"ConcentricCircles","username":"abhi_bansal","description":"Simple Co-centric Circles animating in time","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","circles","cocentric"],"hasliked":0,"parentid":"","parentname":""}}