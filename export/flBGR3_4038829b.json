{"ver":"0.1","info":{"id":"flBGR3","date":"1624459298","viewed":99,"name":"Monochrome dithered phong","username":"sepehrnoor","description":"Simple phong shader with dithered color","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"7lf3DS","parentname":"very simple raytracing demo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* MONOCHROME PHONG LIGHTING\n   DITHERING ALGORITHM BY ALEX CHARLTON \n   http://alex-charlton.com/posts/Dithering_on_the_GPU/\n*/\n\nstruct {\n    vec2 screen;\n} globals;\n\nconst int indexMatrix4x4[16] = int[](0,  8,  2,  10,\n                                     12, 4,  14, 6,\n                                     3,  11, 1,  9,\n                                     15, 7,  13, 5);\n\nfloat indexValue() {\n    int x = int(globals.screen.x) % 4;\n    int y = int(globals.screen.y) % 4;\n    return float(indexMatrix4x4[(x + y * 4)]) / 16.0;\n}\n\nfloat dither(float color) {\n    float closestColor = (color < 0.5) ? 0. : 1.;\n    float secondClosestColor = 1. - closestColor;\n    float d = indexValue();\n    float distance = abs(closestColor - color);\n    return (distance < d) ? closestColor : secondClosestColor;\n}\n\nfloat dist_sphere(vec3 center, float radius, vec3 eye, vec3 dir){\n    vec3 oc = eye - center;\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc,oc) - radius*radius;\n    float d = b*b - 4.*a*c;\n    if(d < 0.0){\n        return -1.0;\n    }\n    else{\n        float num = -b - sqrt(d);\n        if (num > 0.0) {\n        return num / (2.0 * a);\n    }\n\n    num = -b + sqrt(d);\n    if (num > 0.0) {\n        return num / (2.0 * a);\n    }\n    else {\n        return -1.;\n    }\n\n    }\n}\n\nvec3 sphere_normal(vec3 eye, vec3 dir, float dist, vec3 center){\n    return normalize((eye + dist * dir) - center);\n}\n\n\nfloat dist_plane(vec3 center, vec3 normal, vec3 eye, vec3 dir)\n{\n    \n    float d = dot(normal, dir);\n    if (abs(d) > 0.001f)\n    {\n        float t = dot(normal, (center - eye)) / d;\n        if (t >= 0.001f) return t;\n    }\n    return -1.;\n}\n\nbool trace(vec3 eye, vec3 dir, vec3[3] sphere_center, float[3] sphere_radius, vec3 plane_center, vec3 plane_normal){\n    \n    for (int i = 0; i < 3; i++){\n        float new_depth = dist_sphere(sphere_center[i], sphere_radius[i], eye, dir);\n        if (new_depth != -1.) {\n            return true;\n        }\n    }\n    if (dist_plane(plane_center, plane_normal, eye, dir) > 0.) return true;\n    return false;\n}\n\nvec3 raytrace(  vec3 eye, vec3 dir,\n                vec3[3] sphere_center, float[3] sphere_radius, \n                vec3 plane_center, vec3 plane_normal, \n                vec3 light_pos, int iteration){\n\n    float bias = 0.01;\n    if (iteration < 1) return vec3(0.);\n    vec3 col = vec3(0.);\n    float depth = 99999.;\n    vec3 normal = vec3(0.);    \n    bool hit = false;\n    int color_index = -1;\n\n    // sphere intersection\n    for (int i = 0; i < 3; i++){\n        float new_depth = dist_sphere(sphere_center[i], sphere_radius[i], eye, dir);\n        if (new_depth != -1. && new_depth < depth) {\n            hit = true;\n            depth = new_depth;\n            normal = sphere_normal(eye, dir, new_depth, sphere_center[i]);\n            color_index = i;\n        }\n    }\n    \n    // plane intersection\n    float new_depth = dist_plane(plane_center, plane_normal, eye, dir);\n        if (new_depth != -1. && new_depth < depth) {\n            hit = true;\n            depth = new_depth;\n            normal = plane_normal;\n            color_index = -1;\n    }\n    \n    if (hit){    \n        vec3 hit_point = eye + depth * dir;\n        vec3 shadow_point = hit_point + normal * bias;\n        vec3 light = vec3(0.);\n        vec3 light_dir = light_pos - hit_point;\n\n        // check shadow\n        bool in_shadow = trace(shadow_point, light_dir, sphere_center, sphere_radius, plane_center, plane_normal);\n        \n        if (color_index == -1) col = vec3(1.);\n        else {\n            float phong = clamp(dot(normalize(light_pos - hit_point), normal), 0., 1.);\n            phong = dither(phong);\n            col = vec3(phong);\n        }\n        col = col * float(!in_shadow);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    globals.screen = fragCoord;\n    \n    float angle = radians(-30.);\n    \n    mat3 rotate = mat3(\n        vec3(1, 0,          0),\n        vec3(0, cos(angle),-sin(angle)),\n        vec3(0, sin(angle), cos(angle))\n    );\n\n    vec3 eye = vec3(0.,5.,-10.);\n    vec3 pixel = eye + rotate * vec3((fragCoord - iResolution.xy / 2. ) / iResolution.y, 1.);\n    vec3 dir = normalize(pixel - eye);\n    vec3 light_pos = vec3(cos(iTime / 5.) * 10., 10. + sin(iTime / 5.) * sin(iTime / 5.) * 5., 0.);    \n    vec3 plane_center = vec3(0.,-5.,0.);\n    vec3 plane_normal = normalize(vec3(0.,1.,0.));\n    \n    vec3[] sphere_center = vec3[](\n        vec3(sin(iTime * 1.2 + 0.3) * 3., 0., cos(iTime * 1.2 + 0.3) * 3.), \n        vec3(sin(iTime * 0.87) * 2., 2., cos(iTime * 0.87) * 2.), \n        vec3(sin(-iTime), 3., cos(-iTime)));\n    float[] sphere_radius = float[](.5, 1., .2);\n    \n    vec3 col = vec3(0.);\n    col = raytrace(eye, dir, sphere_center, sphere_radius, plane_center, plane_normal, light_pos, 1);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}