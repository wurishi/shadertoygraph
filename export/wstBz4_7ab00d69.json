{"ver":"0.1","info":{"id":"wstBz4","date":"1607852576","viewed":485,"name":"Playable Chess","username":"Jinkweiq","description":"This shader must not be paused to work (it takes 3 frames for each move). Fully playable game of chess - including castling (and without en passant). In the lower left hand corner, you can see the storage (see buffer A).","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["ui","chess","storage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// made by jinkweiq\n//\n// just display stuff, check buffer a for logic\n//\n\n//shows the data stored in buffer a\n#define SHOW_DATA\n\nfloat char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n    vec4 a = textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n\treturn a.x*(a.y+.5);\n}\n// converts peice to char equivalent\nint getPiece(int p) {\n    switch (p) {\n        case 0:\n            return -32;\n        case 1:\n        case 7:\n            return 16;\n        case 2:\n        case 8:\n            return 11;\n        case 3:\n        case 9:\n            return 17;\n        case 4:\n        case 10:\n            return 2;\n        case 5:\n        case 11:\n            return 14;\n        case 6:\n        case 12:\n            return 18;\n    };\n    return -32;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 luv = uv;\n    uv=posToBoard(uv);\n    vec3 col = vec3(.2)+.02*length(uv-vec2(5.,5.));\n    \n    #ifdef SHOW_DATA\n    if (fragCoord.x < 66.&&fragCoord.y < 66.) {\n   \t\tcol = data(fragCoord.x, fragCoord.y).rgb;\n    }\n    #endif\n    \n    luv.y -=.93;\n    luv*=15.;\n    if (FLAG_MOVE) {\n        col += vec3(char(luv,66));\n        col += vec3(char(luv-vec2(.6,0.),76));\n        col += vec3(char(luv-vec2(1.2,0.),65));\n        col += vec3(char(luv-vec2(1.8,0.),67));\n        col += vec3(char(luv-vec2(2.4,0.),75));\n    } else {\n        col += vec3(char(luv,87));\n        col += vec3(char(luv-vec2(.6,0.),72));\n        col += vec3(char(luv-vec2(1.2,0.),73));\n        col += vec3(char(luv-vec2(1.8,0.),84));\n        col += vec3(char(luv-vec2(2.4,0.),69)); \n    }\n    luv.y+=.8;\n    col += vec3(char(luv,84));\n   \tcol += vec3(char(luv-vec2(.6,0.),79));\n    col += vec3(char(luv-vec2(1.8,0.),77));\n    col += vec3(char(luv-vec2(2.4,0.),79));\n    col += vec3(char(luv-vec2(3.,0.),86));\n    col += vec3(char(luv-vec2(3.6,0.),69));\n\n\n   \t//border\n    vec2 coord = floor(uv);\n    if (coord.x>=0.&&coord.x<=9.&&coord.y>=0.&&coord.y<=9.) {\n        float off = .014;\n        vec2 nuv = uv*(.1+off)-(off/.2);\n        if(nuv==fract(nuv)) {\n        \tcol=mix(texture(iChannel1, fragCoord/iResolution.xy*.5,2.).xyz,vec3(0.427,0.482,0.494),.8);\n            col+=float(nuv.x+nuv.y>1.)*.1;\n            col+=float(nuv.x-nuv.y>.0)*.05;\n        }\n    }\n    //board\n    if (coord.x>0.&&coord.x<9.&&coord.y>0.&&coord.y<9.) {\n    \tuv = 2.3*(fract(uv)-.5);\n        vec2 selected = FLAG_SELECTED/.1;\n        int p = int(ceil(data(0,(coord.y-1.)*8.+coord.x-1.).x/.01));\n        if(coord==selected) {\n            col=vec3(0.933,0.902,0.525);\n        } else if (KING_CHECK&&((FLAG_MOVE&&p==8)||(!(FLAG_MOVE)&&p==2))) {\n            col=vec3(0.706,0.514,0.533);\n        } else {\n            vec3 bcol = (mod(coord.x+coord.y,2.)>0.)?vec3(0.812,0.898,0.906):vec3(0.318,0.365,0.541);\n            col = mix(texture(iChannel1, fragCoord/iResolution.xy*.5,2.).xyz,bcol,.8);\n        }\n        selected-=1.;\n        coord-=1.;\n        float possibleMove = data(coord.y*8.+coord.x+2.,selected.y*8.+selected.x).x;\n        if (possibleMove>.5) {\n            col-=.2*smoothstep(.5,.45,length(uv));\n        }\n        int piece=getPiece(p);\n        col = mix(col, vec3(0.), smoothstep(.0,.5,char(uv*.5+.5,64+piece)));\n        col = mix(col, (p>6?vec3(0.141,0.141,0.141):vec3(0.871,0.906,0.906)), char(uv*.5+.5,64+piece));\n        fragColor = vec4(col,1.0);\n        return;\n\n    }\n    vec2 nuv=uv-vec2(1.,.1);\n    nuv*=2.;\n    if (nuv.x>0.&&nuv.x<16.&&nuv.y>0.&&nuv.y<1.) {\n        int p = int(ceil(data(int(floor(nuv.x)),65).x/.01));\n        int piece=getPiece(p);\n        col = mix(col,vec3(0.),char(fract(nuv),64+piece));\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    nuv=uv-vec2(1.,9.5);\n    nuv*=2.;\n    if (nuv.x>0.&&nuv.x<16.&&nuv.y>0.&&nuv.y<1.) {\n        int p = int(ceil(data(int(floor(nuv.x)),65).y/.01));\n        int piece=getPiece(p);\n        col = mix(col,vec3(1.),char(fract(nuv),64+piece));\n        fragColor = vec4(col,1.0);\n        return;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// made by jinkewiq \n//\n// call me italian, because this code is some top-notch spaghetti.\n// \n// the r channel is the current state, the g channel is the simulated state\n// x=0 is 1x64 colum of the current game state \n// x=1 is just data like whose move, selected piece, etc\n// x=2...66 is a 64x64 grid of all the possible moves (can peice at y move to sqare at x)\n// y=65 is a 1x16 row of captured peices (r for white and g for black, b for buffer)\n//\n// before each move, I simulate to make sure king is not in check, then undo if move is not legal.\n// maybe I will make a better version later with proper structs and fewer if statements and everything \n// I know there are much better ways to do the storage, but I jsut store a 1 or a 0 in each pixel because \n// I don't want to think too hard. Maybe a proper chess engine that stores the moves and pareses for en passant\n// and castling and check. Maybe you can paste a chess game PGN and it will show you the state.... idk i dont\n// have time.\n//\nbool squareIsInCheck(int square) {\n    // you cannot castle through check\n    float dir=FLAG_MOVE?-1.:1.;    \n    simulated=true;\n    for (int y=0;y<64;y++) {\n        if (dir*data(0,y).x>dir*.065) {\n            if(data(square+2,y).x>.5) {\n                simulated=false;\n                return true;\n            }\n        }\n    }\n    simulated=false;\n    \n    return false;\n}\nbool kingIsInCheck() {\n    int p=FLAG_MOVE?8:2;\n    int king_square;\n    simulated=true;\n    for (int y=0;y<64;y++) {\n        if(int(ceil(data(0,y).x/.01))==p) {\n            king_square = y;\n            break;\n        }\n    }\n    simulated=false;\n    return squareIsInCheck(king_square);\n}\nfloat getPawnMove(vec2 s, vec2 t, bool isWhite) {\n\tfloat dir = isWhite?1.:-1.;\n    //forward\n    if(t.y == s.y+dir&&t.x==s.x) {\n    \tif(data(0,b2s(t)).x<=0.) {\n        \treturn 1.;\n    \t}\n    }\n    //forward two on first move\n    else if(t.y == s.y+dir*2.&&s.y==(isWhite?1.:6.)&&t.x==s.x) {\n        if(data(0,b2s(t)).x<=0.) {\n           \tif(data(0,b2s(t-vec2(0.,dir))).x==0.) {\n        \t\treturn 1.;\n            }\n    \t}\n    }\n    //capture\n    float p = data(0,b2s(t)).x;\n    if (p > 0.) {\n        if (isWhite) {\n            if(t.y == s.y+dir&&t.x==s.x+1.) {\n            if(p>.06) {\n                return 1.;\n            }\n            }\n            else if(t.y == s.y+dir&&t.x==s.x-1.) {\n                if(p>.06) {\n                   return 1.;\n                }\n            }\n        } else {\n            if(t.y == s.y+dir&&t.x==s.x+1.) {\n            if(p<.06) {\n                return 1.;\n            }\n            }\n            else if(t.y == s.y+dir&&t.x==s.x-1.) {\n                if(p<.06) {\n                   return 1.;\n                }\n            }\n        }\n   \t}\n    return 0.;\n}\nfloat getBishopMove(vec2 s, vec2 t, bool isWhite, bool q) {\n\t// iterative, checkes if bishop can move sqare 1 move closer to bishop,\n    // or if that square is a bishop. also schecks if that sqare has a peice on\n    // it because bishop cannot jump through peices. q flag is for queen move\n\tvec2 d = abs(s-t);\n    int b = q?(isWhite?9:3):(isWhite?4:10);\n    float dir = isWhite?1.:-1.;\n    dir*=q?-1.:.1;\n    if (d.x==d.y) {\n    \tvec2 nt=t+sign(s-t);\n    \tfloat p = data(0,b2s(nt)).x;\n    \tif(int((p+.005)/.01) == b) {\n        \tp = dir*data(0,b2s(t)).x;\n            if(p>dir*.06||p==0.) {\n        \t\treturn 1.;\n    \t\t}\n\n        }\n       \tif(data(b2s(nt)+2.,b2s(s)).x > .5) {\n        \tp = dir*data(0,b2s(t)).x;\n            if(p>dir*.06||p==0.) {\n                p = dir*data(0,b2s(nt)).x;\n                if(p<dir*.06||p==0.) {\n                    return 1.;\n                }\n    \t\t}\n        }\n    }\n    return 0.;\n}\nfloat getRookMove(vec2 s, vec2 t, bool isWhite, bool q) {\n\t//same as bishop, but on rows/cols\n\tvec2 d = abs(s-t);\n    int b = q?(isWhite?9:3):(isWhite?12:6);\n    float dir = isWhite?-1.:1.;\n    if (t.x==s.x||t.y==s.y) {\n    \tvec2 nt=t+sign(s-t);\n    \tfloat p = data(0,b2s(nt)).x;\n    \tif(int((p+0.005)/.01) == b) {\n        \tp = dir*data(0,b2s(t)).x;\n            if(p>=dir*.06||p==0.) {\n        \t\treturn 1.;\n    \t\t}\n\n        }\n\t\tif(data(b2s(nt)+2.,b2s(s)).x > .5) {\n        \tp = dir*data(0,b2s(t)).x;\n            if(p>dir*.06||p==0.) {\n                p = dir*data(0,b2s(nt)).x;\n                if(p<dir*.06||p==0.) {\n                    return 1.;\n                }\n    \t\t}\n        }\n    }\n    return 0.;\n}\nfloat getKnightMove(vec2 s, vec2 t, bool isWhite) {\n\t// just check all possible moves\n    vec2 d = abs(s-t);\n    float dir = isWhite?-1.:1.;\n    if (max(d.x,d.y)==2.&&min(d.x,d.y)==1.) {\n    \tfloat p = dir*data(0,b2s(t)).x;\n    \tif (p>dir*.06||p==0.) {\n    \t\treturn 1.;\n        }\n    } \n    return 0.;\n}\nfloat getQueenMove(vec2 s, vec2 t, bool isWhite) {\n\t//cheap trick\n    return max(getRookMove(s, t, isWhite, true), getBishopMove(s, t, isWhite, true));\n}\nfloat getKingMove(vec2 s, vec2 t, bool isWhite) {\n\t// just check all possible moves\n\tvec2 d = abs(s-t);\n    float dir = isWhite?-1.:1.;\n    if (d.x <=1.&&d.y<=1.) {\n    \tfloat p = dir*data(0,b2s(t)).x;\n    \tif (p>dir*.06||p==0.) {\n    \t\treturn 1.;\n        }\n    }\n    //castle\n    if (d.x==2.&&d.y==0.) {\n        if (kingIsInCheck()) {\n            return 0.;\n        }\n        vec4 has_moved = isWhite?BLACK_KING_CASTLE:WHITE_KING_CASTLE;\n        int square;\n        if(t.x<s.x) {\n            if (has_moved.x > .5) {\n                return 0.;\n            }\n            for (int i=1;i<4;i++) {\n                square = int(b2s(s-vec2(i,0.)));\n                if(data(0,square).x > .0||squareIsInCheck(square)) {\n                    return 0.;\n                }\n            }\n        } else {\n            if (has_moved.y > .5) {\n                return 0.;\n            }\n            for (int i=1;i<3;i++) {\n                square = int(b2s(s+vec2(i,0.)));\n                if(data(0,square).x > .0||squareIsInCheck(square)) {\n                    return 0.;\n                }\n            }\n        }\n        return 1.;\n    }\n    return 0.;\n}\nfloat getPossibleMove(vec2 coord) {\n    float res = 0.;\n    int peice = int(ceil(data(0,coord.y).x/.01));\n    if (peice == 0) {\n        return 0.;\n    }\n    vec2 square = s2b(coord.y);\n    vec2 target = s2b(coord.x);\n    // got to be a better way to do this\n    // wish i could stick functions in a dict or list and\n    // if peice in PAWN_PEICES like in python\n    if (square!=target) {\n        switch(peice) {\n            case 1:\n                return getPawnMove(square, target, true);\n            case 7:\n                return getPawnMove(square, target, false);\n            case 4:\n                return getBishopMove(square, target, true, false);\n            case 10:\n                return getBishopMove(square, target, false, false);\n            case 6:\n                return getRookMove(square, target, false, false);\n            case 12:\n                return getRookMove(square, target, true, false);\n            case 5:\n                return getKnightMove(square, target, false);\n            case 11:\n                return getKnightMove(square, target, true);\n           \tcase 3:\n                return getQueenMove(square, target, false);\n            case 9:\n                return getQueenMove(square, target, true);\n            case 2:\n                return getKingMove(square, target, false);\n            case 8:\n                return getKingMove(square, target, true);\n        }\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\tvec2 mp=iMouse.xy/iResolution.xy;\n    mp.x*=iResolution.x/iResolution.y;\n    vec2 coord=floor(posToBoard(mp));\n    vec2 lastCoord=FLAG_SELECTED/.1;\n    \n    vec4 ld = data(fragCoord.x, fragCoord.y);\n    // initialization\n    if (iFrame<5) {\n        int[8*8] board = int[](\n        6, 5, 4, 3, 2, 4, 5, 6,\n        1, 1, 1, 1, 1, 1, 1, 1,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        7, 7, 7, 7, 7, 7, 7, 7,\n        12,11,10,9, 8,10,11,12\n        );\n        \n        fragColor=vec4(0.);\n        if(fragCoord.x<1.&&fragCoord.y<=64.){\n            fragColor.x=float(board[int(fragCoord.y)])*.01;\n            return;\n        }\n    }\n    // do moves, undo if illegal\n    if(fragCoord.x<1.&&fragCoord.y<=64.){\n        int piece = int(ceil(ld.x/.01));\n        int movedp = int(ceil(data(0,b2s(lastCoord-1.)).x/.01));\n        // promote pawns -- would be more efficent if if statement params are swapped, but too lazy\n        if(piece==1&&s2b(fragCoord.y).y==7.) {\n            ld.x=3.*.01;\n        } else if(piece==7&&s2b(fragCoord.y).y==0.) {\n            ld.x=9.*.01;\n        }\n        // new position has been calculated, undo if move was illigal.\n        if (FLAG_RECALC>.75&&!kingIsInCheck()) {\n            fragColor=ld.yyzz;\n            return;\n        }\n        if (coord != lastCoord && lastCoord.x > .0) {\n            lastCoord-=1.;\n            coord-=1.;\n            if (data(b2s(coord)+2.,b2s(lastCoord)).x > .5) {\n                fragColor=ld.xxzz;\n                if (int(b2s(lastCoord)) == int(fragCoord.y)) {\n                    fragColor.y=0.;\n                    return;\n                } else if (int(b2s(coord)) == int(fragCoord.y)) {\n                    fragColor.y=data(0,b2s(lastCoord)).x;\n                    return; \n                }\n                // castling -- hardcoded\n                if ((movedp==2||movedp==8)) {\n                    float rook = (FLAG_MOVE)?12.:6.;\n                    if((lastCoord.x-coord.x)<-1.5) {\n                        if (int(b2s(coord-vec2(1.,0.))) == int(fragCoord.y)) {\n                            fragColor.y=rook*.01;\n                            return;\n                        } else if (int(b2s(coord+vec2(1.,0.))) == int(fragCoord.y)) {\n                            fragColor.y=0.;\n                            return;\n                        }\n                    } else if ((lastCoord.x-coord.x)>1.5) {\n                         if (int(b2s(coord+vec2(1.,0.))) == int(fragCoord.y)) {\n                            fragColor.y=rook*.01;\n                            return;\n                        } else if (int(b2s(coord-vec2(2.,0.))) == int(fragCoord.y)) {\n                            fragColor.y=0.;\n                            return;\n                        }\n                    }\n                    \n                }\n                return;\n            }\n        }\n    }\n    // currently selected\n    if (fragCoord.x>1.&&fragCoord.x<2.&&fragCoord.y<1.) {\n       if (coord != lastCoord && lastCoord.x > .0) {\n            if (data(b2s(coord-1.)+2.,b2s(lastCoord-1.)).x > .5) {\n            \tfragColor = vec4(0.);\n                return;\n            }\n       \t}\n            \n        if (coord.x>=0.&&coord.x<=9.&&coord.y>=0.&&coord.y<=9.) {\n        \tfloat dir=FLAG_MOVE?1.:-1.;\n        \tif (dir*data(0,b2s(coord-1.)).x>dir*.065) {\n            \tfragColor=vec4(coord*.1,0,0);\n            \treturn;\n            }\n        }\n    }\n    // should calc if king is in check flag\n    if (fragCoord.x>1.&&fragCoord.x<2.&&fragCoord.y<2.) {\n        if ((FLAG_LAST_MOVE.x>0.||FLAG_LAST_MOVE.y>0.)&&FLAG_RECALC<=0.) {\n        \tfragColor=vec4(ld.xy,.5,0);\n            return;\n        }\n        if (FLAG_RECALC < .75&&FLAG_RECALC>.25) {\n        \tfragColor=vec4(ld.xy,1.,0);\n        \treturn;\n        }\n        if (FLAG_RECALC > .75) {\n        \tfragColor=vec4(0.);\n        \treturn;\n        }\n        if (coord != lastCoord && lastCoord.x > .0) {\n             lastCoord-=1.;\n             coord-=1.;\n             if (data(b2s(coord)+2.,b2s(lastCoord)).x > .5) {\n             \tfragColor=vec4(lastCoord*.1,0,0);\n             \treturn;\n             }\n        }\n        fragColor=ld/10.;\n        return;\n    }\n    // toggle whose move\n    else if (fragCoord.x>1.&&fragCoord.x<2.&&fragCoord.y<3.) {\n        fragColor=ld;\n        bool checked=kingIsInCheck();\n        fragColor.y=checked?1.:0.;\n        if (FLAG_RECALC > .75) {\n        \tlastCoord-=1.; \n            coord-=1.;\n            if (!checked) {\n                if (FLAG_MOVE) {\n                    fragColor.x=0.;\n                    return;\n                }\n                fragColor.x=1.;\n                return;\n            }\n        }\n        return;\n    }\n    // white king castling\n    if (fragCoord.x>1.&&fragCoord.x<2.&&fragCoord.y<4.) {\n       fragColor=ld;\n       if (FLAG_RECALC>.75&&!kingIsInCheck()) {\n            fragColor.z=0.;\n            if (ld.z>.75) {\n               fragColor.xy=vec2(1.);\n            } else if (ld.z>.0){\n                if ((lastCoord.x-coord.x)<0.) {\n                    fragColor.x=1.;\n                } else {\n                    fragColor.y=1.;\n                }\n            }\n            return;\n       }\n       \n       int movedp = int(ceil(data(0,b2s(lastCoord-1.)).x/.01));\n       if (coord != lastCoord && lastCoord.x > .0) {\n            lastCoord-=1.;\n            coord-=1.;\n            if (data(b2s(coord)+2.,b2s(lastCoord)).x > .5) {\n                if (movedp==2) {\n                    fragColor.z=1.;\n                    return;\n                } else if (movedp==6) {\n                    fragColor.z=.5;\n                }\n            }\n        }\n        return;\n    }\n    // black king castling\n    if (fragCoord.x>1.&&fragCoord.x<2.&&fragCoord.y<5.) {\n       fragColor=ld;\n       if (FLAG_RECALC>.75&&!kingIsInCheck()) {\n            fragColor.z=0.;\n            if (ld.z>.75) {\n               fragColor.xy=vec2(1.);\n            } else if (ld.z>.0){\n                if ((lastCoord.x-coord.x)<-1.5) {\n                    fragColor.x=1.;\n                } else {\n                    fragColor.y=1.;\n                }\n            }\n            return;\n       }\n       \n       int movedp = int(ceil(data(0,b2s(lastCoord-1.)).x/.01));\n       if (coord != lastCoord && lastCoord.x > .0) {\n            lastCoord-=1.;\n            coord-=1.;\n            if (data(b2s(coord)+2.,b2s(lastCoord)).x > .5) {\n                if (movedp==8) {\n                    fragColor.z=1.;\n                    return;\n                } else if (movedp==12) {\n                    fragColor.z=.5;\n                }\n            }\n        }\n        return;\n    }\n    // calc posssible moves\n    if (fragCoord.x>=2.&&fragCoord.x<66.&&fragCoord.y<65.) {\n        fragColor.x=getPossibleMove(fragCoord-vec2(2.,0.));\n        simulated=true;\n        fragColor.y=getPossibleMove(fragCoord-vec2(2.,0.));\n        simulated=false;\n        return;\n    }\n    //captured peices\n    else if (fragCoord.x>=0.&&fragCoord.x<64.&&fragCoord.y<66.&&fragCoord.y>=65.) {\n        // stored in buffer in z channel and then swapped if simulated move goes through\n        fragColor=ld;\n        if (FLAG_RECALC>.75&&!kingIsInCheck()) {\n            fragColor.z=0.;\n            if (ld.z>0.) {\n                if(FLAG_MOVE) {\n                    fragColor.y=ld.z;\n                } else {\n                    fragColor.x=ld.z;\n                }\n            }\n            \n            return;\n        }\n        simulated=FLAG_MOVE;\n        if ((data(fragCoord.x-1.,fragCoord.y).x>0.&&fragCoord.x>=1.)||(fragCoord.x<1.&&data(fragCoord.x,fragCoord.y).x<=0.)) {\n            if (data(fragCoord.x,fragCoord.y).x <= 0.) {\n                if (coord != lastCoord && lastCoord.x > .0) {\n                    lastCoord-=1.;\n                    coord-=1.;\n                    if (data(b2s(coord)+2.,b2s(lastCoord)).x > .5) {\n                        fragColor.z=data(0,b2s(coord)).x;\n                        return;\n                    }\n                }\n            }\n        }\n        simulated=false;\n    }\n    fragColor = ld;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FLAG_MOVE texelFetch(iChannel0, ivec2(1,2), 0).x > .5\n#define KING_CHECK texelFetch(iChannel0, ivec2(1,2), 0).y > .5\n#define FLAG_SELECTED texelFetch(iChannel0, ivec2(1,0), 0).xy\n#define FLAG_LAST_MOVE texelFetch(iChannel0, ivec2(1,1), 0).xy\n#define FLAG_RECALC texelFetch(iChannel0, ivec2(1,1), 0).z\n\n#define WHITE_KING_CASTLE texelFetch(iChannel0, ivec2(1,3), 0)\n#define BLACK_KING_CASTLE texelFetch(iChannel0, ivec2(1,4), 0)\n\n#define data(x, y) (simulated?texelFetch(iChannel0, ivec2(x,y), 0).yxzw:texelFetch(iChannel0, ivec2(x,y), 0))\n// simulated is used for calculating simulated moves (flip r/g channels)\nbool simulated = false;\n// conversion for mose to board\nvec2 posToBoard(vec2 p) {\n    p.x-=.38; //close enough to center\n    p*=10.;\n    return p;\n}\n// board coords to storage coords\nfloat b2s(vec2 p) {\n    return p.y*8.+p.x;\n}\n// storage coords to board coords\nvec2 s2b(float p) {\n    return vec2(mod(p,8.),floor(p/8.));\n}","name":"Common","description":"","type":"common"}]}