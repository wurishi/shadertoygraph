{"ver":"0.1","info":{"id":"ctGcRw","date":"1700011421","viewed":65,"name":"Simple Veroni","username":"codeforger","description":"A simple veroni shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["veroni"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a cheap random nuber generator\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Makes a point, since this is pure, it will make the same point every time (for each index)\nivec2 makePoint(int i) {\n  return ivec2(rand(vec2(i*4+1,i*4+2)) * 10000.0 - 5000.0, rand(vec2(i*4+3,i*4+4)) * 10000.0 - 5000.0);\n}\n\n// Distance between two points\nfloat dist(ivec2 a, ivec2 b) {\n    ivec2 c = b - a;\n    c *= c;\n    return float(sqrt(float(c.x + c.y)));\n}\n\n// wrap a point back onto the screen\nivec2 center(ivec2 a, ivec2 iRes) {\n    ivec2 c = a % iRes;\n    if (c.x < 0) { c.x += iRes.x; }\n    if (c.y < 0) { c.y += iRes.y; }\n    return c;\n}\n\n// Take a point, move it along its given vector for the number of frames given, then wrap it back onto the screen\nivec2 ptop(ivec2 p, ivec2 iRes) { return center(p * (iFrame + 1000) / 5000, iRes); }\n\n// given a point, call ptop, then get its distance from the uv\nfloat dist2(ivec2 point, ivec2 iRes, ivec2 uv) {\n    return dist(ptop(point, iRes), uv);\n}\n\n// given 2 points, call dist2 on them and get the difference between the results\nfloat diff(ivec2 a, ivec2 b, ivec2 iRes, ivec2 uv) {\n  return abs(dist2(a, iRes, uv) - dist2(b, iRes, uv));\n}\n// Same as above, but can take vec2 instead of ivec2\nfloat diff(vec2 a, vec2 b, ivec2 iRes, ivec2 uv) {\n  return diff(ivec2(a), ivec2(b), iRes, uv);\n}\n\nconst int pointCount = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get co-ords as ints, making the % math easier\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 uv = ivec2(fragCoord);\n\n    // our output color\n    vec3 col = vec3(0,0,0);\n    \n    // find the closet two points, and the distance to them\n    vec3 closest = vec3(0.0,0.0,1000000.0);\n    vec3 second = vec3(0.0,0.0,1000000.0);\n    for(int i=0;i<pointCount;++i)\n    {\n        ivec2 point = makePoint(i);\n        float d = dist2(point, iRes, uv);\n        \n        // otherwise, record the distance if the current point is closer that the existing ones\n        if(d < closest.z) { second = closest; closest = vec3(point, d); }\n        else if (d < second.z) { second = vec3(point, d); }\n        \n    }\n        \n    // if the current pixes is on top of a point, draw it green\n    if (closest.z < 5.0) {\n       col.y = 1.0;\n    }\n    \n    // get the difference in distances to these points\n    float diff = diff(closest.xy, second.xy, iRes, uv);\n    \n    // hack in anti aliasing by drawing a mid tone red arround the single pixel line\n    if (diff/3.  < (dist(ptop(ivec2(closest.xy), iRes), ptop(ivec2(second.xy), iRes)))/(closest.z + second.z)){ col.x = .5; }\n    \n    // If the difference is low enough, this pixel must be a border between two cells, draw it red\n    if (diff <  (dist(ptop(ivec2(closest.xy), iRes), ptop(ivec2(second.xy), iRes)))/(closest.z + second.z)){ col.x = 1.0; }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}