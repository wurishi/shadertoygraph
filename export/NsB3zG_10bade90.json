{"ver":"0.1","info":{"id":"NsB3zG","date":"1617546739","viewed":712,"name":"ALMOST DONE - Revision 2021","username":"bitnenfer","description":"ALMOST DONE BY LIA\n4K EXECUTABLE GRAPHICS\nI made this just a couple of hours before the deadline, so it's a bit rough. Made in shadertoy and packed with yx's blossom. Thanks!! \nCode & Visuals by Bitnenfer \nLove you Nicko!!","likes":21,"published":1,"flags":32,"usePreview":1,"tags":["4k","pathtracer","exegfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * --------------------\n *     ALMOST DONE\n *  by Bitnenfer / LIA\n * --------------------\n *\n *  Made for Revision 2021 Online - 4K Executable Graphics Compo.\n *\n *  I made this just a couple of hours \n *  before the deadline, so it's a bit rough. \n *  Made in shadertoy and packed with yx's blossom. \n *  Thanks!! Code & Visuals by Bitnenfer \n *  Love you Nicko!!\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BOUNCE_COUNT 5\n#define saturate(x) clamp((x), 0., 1.)\n\n#define MAX_DIST 500.0\n#define MAX_RAY_STEPS 300\n#define PI 3.14159265359\n#define MOVE_WITH_MOUSE 0\n\nstruct RayHit\n{\n    float dist;\n    int id;\n    vec3 color;\n};\n\nstruct Material\n{\n    vec3 color;\n    float shininess;\n    float shininessScale;\n    float refractiveness;\n    float indexOfRefraction;\n    float refractionScale;\n    bool emissive;\n};\n\nfloat line( vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// Logo by Kali\nfloat logo(vec2 uv) {\n    uv.x-=.12;\n    uv.y*=1.2;\n    float c = line(uv, vec2(-.65,.3), vec2(-.65,-.3));\n    c = min(c,line(uv, vec2(-.65,-.3), vec2(-.35,-.3)));\n    c = min(c,line(uv, vec2(-.15,.3), vec2(-.15,-.3)));\n    c = min(c,line(uv, vec2(.25,.3), vec2(.05,-.3)));\n    c = smin(c,line(uv, vec2(.3,.3), vec2(.50,-.3)),.05);\n    c = min(c,line(uv, vec2(.5,-.3), vec2(.2,-.3)));\n    return c;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat hash(float n) { return fract(sin(n) * 753.5); }\n\nvec4 noised(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 w = fract(x);\n\tvec3 u = w * w * (3. - 2. * w);\n\tvec3 du = 6. * w * (1. - w);\n\n\tfloat n = p.x + p.y * 157. + 113. * p.z;\n\n\tfloat a = hash(n);\n\tfloat b = hash(n + 1.);\n\tfloat c = hash(n + 157.);\n\tfloat d = hash(n + 158.);\n\tfloat e = hash(n + 113.);\n\tfloat f = hash(n + 114.);\n\tfloat g = hash(n + 270.);\n\tfloat h = hash(n + 271.);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k3 = e - a;\n\tfloat k4 = a - b - c + d;\n\tfloat k5 = a - c - e + g;\n\tfloat k6 = a - b - e + f;\n\tfloat k7 = -a + b + c - d + e - f - g + h;\n\n\treturn vec4(k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z,\n\t\tdu * (vec3(k1, k2, k3) + u.yzx * vec3(k4, k5, k6) + u.zxy * vec3(k6, k4, k5) + k7 * u.yzx * u.zxy));\n}\n\nvec4 fbmd(in vec3 x)\n{\n    //return vec4(0);\n\tfloat a = 0.,\n\t\tb = 0.5,\n\t\tf = 1.;\n\tvec3  d = vec3(0, 0, 0);\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tvec4 n = noised(f * x);\n\t\ta += b * n.x;           // accumulate values      \n\t\td += b * n.yzw * f; // accumulate derivatives\n\t\tb *= 0.5;             // amplitude decrease\n\t\tf *= 1.8;             // frequency increase\n\t}\n\n\treturn vec4(a, d);\n}\n\nvec4 fbmd1(in vec3 x)\n{\n\tfloat a = 0.,\n\t\tb = 0.5,\n\t\tf = 1.;\n\tvec3  d = vec3(0, 0, 0);\n\t{\n\t\tvec4 n = noised(f * x);\n\t\ta += b * n.x;           // accumulate values      \n\t\td += b * n.yzw * f; // accumulate derivatives\n\t\tb *= 0.5;             // amplitude decrease\n\t\tf *= 1.8;             // frequency increase\n\t}\n\n\treturn vec4(a, d);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvoid opUnion(RayHit a, RayHit b, out RayHit result)\n{\n    if (a.dist < b.dist) result = a;\n    else result = b;\n}\n\nvec3 joinColor(float a, float b, vec3 ca, vec3 cb)\n{\n    if (a < b) return ca;\n    else return cb;\n}\n\nmat2 rot(float r) { return mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 getCargoCol(vec3 c)\n{\n    vec3 col = 0.5 + 0.5*cos( c.y*6.2831 + vec3(0.8,0.25,0.1) );\t\n\tcol *= clamp(1.0 - 0.9*c.x*c.x,0.0,1.0);\n    return col;\n}\n\nRayHit suezPet(vec3 p)\n{\n    RayHit sceneHit = RayHit(MAX_DIST, -1, vec3(0));\n    \n    vec3 p1 = p;\n    vec3 p2 = p - vec3(0, 0.25, -6);\n\n    p1.y *= 4.;\n    float petSdf = length(p1 - vec3(1, -4, -6)) - 3.0;\n    p2.xz *= rot(-0.6);\n\n    float eyeSdf = length(abs(p2) - vec3(1.1, 0, 0)) - 0.04;    \n    float mouthSdf = length(p2 - vec3(0, 0, -1)) - 0.04;\n\n    \n    RayHit petHit = RayHit(petSdf, 8, vec3(0.0));\n    RayHit eyeHit = RayHit(eyeSdf, 6, vec3(10.0, 1,1 ));\n    RayHit mouthHit = RayHit(mouthSdf, 6, vec3(5, 0,0 ));\n\n    opUnion(sceneHit, petHit, sceneHit);\n    opUnion(sceneHit, eyeHit, sceneHit);\n    opUnion(sceneHit, mouthHit, sceneHit);\n    //sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n    float tent1 = sdCapsule(p - vec3(0, -1, 0), vec3(0, 0, 0), vec3(-6. + sin(p.z), sin(p.z) *0.4, -12), 1.);\n    float tent2 = sdCapsule(p - vec3(0, -1, 0), vec3(2, 0, 0), vec3(2.+ sin(p.z) , sin(p.z) *0.9, -15.), 1.);\n    float tent3 = sdCapsule(p - vec3(0, -1, 0), vec3(0, 0, 0), vec3(-3. + sin(p.z * 2.)*2., 0, 15), 1.);\n    RayHit tentHit = RayHit(min(min(tent1, tent2), tent3), 8, vec3(0));\n    opUnion(sceneHit, tentHit, sceneHit);\n\n    return sceneHit;\n}\n\nRayHit cargo(vec3 p)\n{\n    RayHit sceneHit = RayHit(MAX_DIST, -1, vec3(0));\n    \n    p.xz *= rot(-0.1);\n    p.xz *= rot(-0.685398);\n    \n    vec3 cp1 = p - vec3(0, 4, 0);\n    float idx = pModInterval1(cp1.z, 0.25, -8., 8.);\n    float idy = pModInterval1(cp1.y, 0.23, -8., 5.);\n    float idz = pModInterval1(cp1.x, 0.65, -6., 6.);\n    float cont1Sdf = sdBox(cp1, vec3(0.3, 0.1, 0.1));\n    \n    vec3 cp2 = p - vec3(5.4, 4, 0);\n    float idx2 = pModInterval1(cp2.z, 0.25, -8., 8.);\n    float idy2 = pModInterval1(cp2.y, 0.23, -8., 5.);\n    float idz2 = pModInterval1(cp2.x, 0.65, 0., 5.);   \n    float cont2Sdf = sdBox(cp2, vec3(0.3, 0.1, 0.1));\n    \n    vec3 cp3 = p - vec3(-6.0, 4, 0);\n    float idx3 = pModInterval1(cp3.z, 0.25, -8., 8.);\n    float idy3 = pModInterval1(cp3.y, 0.23, -8., 5.);\n    float idz3 = pModInterval1(cp3.x, 0.65, -6., 1.);   \n    float cont3Sdf = sdBox(cp3, vec3(0.3, 0.1, 0.1));\n    \n    vec3 col = joinColor(\n        cont1Sdf, cont2Sdf, \n        getCargoCol(hash33(vec3((idz), (idy), (idx)))), \n        getCargoCol(hash33(vec3((idz2), (idy2), (idx2))))\n    );\n    float m2 = min(cont1Sdf, cont2Sdf);\n    col = joinColor(cont3Sdf, m2, getCargoCol(hash33(vec3((idz3), (idy3), (idx3)))), col);\n    \n    \n    RayHit contHit = RayHit(min(cont3Sdf, m2), 7, col.xyz);\n    \n    opUnion(sceneHit, contHit, sceneHit);\n\n    return sceneHit;\n}\n\nRayHit ship(vec3 p)\n{\n    vec4 noise = fbmd(p*12.);\n    RayHit sceneHit = RayHit(MAX_DIST, -1, vec3(0));\n    p.xz *= 0.9;\n    p.xz *= rot(-0.1);\n    \n    vec3 bp = p;\n    vec3 fp = p;\n    bp.xz *= rot(-0.685398);\n    fp.x += 8.0;\n    fp.z += 6.5;\n    fp.y -= 1.5;\n    fp.y *= 0.5;\n    fp.xy *= rot(0.785398*2.);\n    fp.yz *= rot(-0.685398);\n\n    float baseSdf = sdBox(bp, vec3(8, 2, 2));\n    float frontSdf = sdRoundCone(fp, 1.0, 2.0, 2.0) - 0.05;\n    float topSdf = sdBox(bp + vec3(-4.2, -3, 0), vec3(0.32, 2.2, 1.9));\n\n    topSdf = min(topSdf, sdBox(bp + vec3(4.15, -3, 0), vec3(0.26, 2, 0.5)));\n    topSdf = min(topSdf, sdBox(bp + vec3(4.15, -5, 0), vec3(0.26, 0.2, 1.9)));\n    topSdf = max(topSdf, -(sdBox(bp + vec3(-4, -5, 0), vec3(1, 1, 0.8))));\n    frontSdf = max(frontSdf, -sdBox(bp - vec3(0, 5, 0), vec3(15, 3, 3)));\n    baseSdf = min(baseSdf, frontSdf) - 0.02;\n    vec3 color = vec3(0.05, 0.1, 0.05) * 2.0;\n    if (bp.y > 2.0)\n    {\n        color = vec3(0.5,0.5,.6);\n    }\n    color = joinColor(topSdf, baseSdf, vec3(0.8, 0.7, 0.5), color);\n    baseSdf = min(baseSdf, topSdf);\n    \n    vec2 lp = bp.xy - vec2(0, 1.3);\n    pModInterval1(lp.x, 2., -2., 2.);\n    if (logo(lp) < 0.05)\n    {\n        color += vec3(0.7);\n    }\n\n    \n    RayHit shipBase = RayHit(baseSdf - 0.02, 5, color);\n    opUnion(sceneHit, shipBase, sceneHit);\n    \n    return sceneHit;\n}\n\nRayHit terrain(vec3 p)\n{\n    vec4 noise = fbmd(p * 15.);\n    vec4 noise2 = fbmd(p * 1.);\n    float left = sdBox(p + vec3(-15, 0, 0), vec3(8. * (1.-(p.y * 0.15)) - noise2.x * 0.5, 1, 25)) * 0.4;\n    float right = sdBox(p + vec3(15, 0, 0), vec3(8. * (1.-(p.y * 0.15)) - noise2.x * 0.5, 1, 25)) * 0.4;\n    RayHit terrainHit = RayHit(min(left - noise.x * 0.05, right - noise.x * 0.05), 3, vec3(0.7, 0.5, 0.4));\n    \n    return terrainHit;\n}\n\n\nRayHit water(vec3 p)\n{\n    p.y += 0.1;\n    vec4 noise = fbmd(p*12.);\n    //float wa = max(sdBox(p, vec3(10, 1, 25)), -sdBox(p + vec3(0, 0.5, 0), vec3(15, 1, 45))) - noise.x * 0.05;\n    float wa = sdBox(p + vec3(0, 4.2, 0), vec3(10, 5, 85)) - noise.x * 0.02;\n    RayHit waterHit = RayHit(abs(wa) - 0.02, 4, vec3(0.9, 0.95, 1));\n    return waterHit;\n}\n\nRayHit map(vec3 p)\n{\n    RayHit sceneHit = RayHit(MAX_DIST, -1, vec3(0));\n    \n    float light = length(p - vec3(-35, 65, 75)) - 26.;\n    RayHit lightHit = RayHit(light, 6, vec3(1, 1, 1) * 5.);\n    RayHit shipHit = ship(p);\n    RayHit waterHit = water(p);\n    RayHit terrainHit = terrain(p);\n    RayHit petHit = suezPet(p);\n    waterHit.dist -= (sin(terrainHit.dist*40.) * 0.005) * clamp(1.-(terrainHit.dist * 1.5), 0., 1.0);\n    waterHit.dist -= (sin(shipHit.dist*60.) * 0.005) * clamp(1.-(shipHit.dist * 1.3), 0., 1.0);\n    opUnion(shipHit, sceneHit, sceneHit);\n    opUnion(terrainHit, sceneHit, sceneHit);\n    opUnion(waterHit, sceneHit, sceneHit);\n    opUnion(lightHit, sceneHit, sceneHit);\n    opUnion(cargo(p), sceneHit, sceneHit);\n    opUnion(petHit, sceneHit, sceneHit);\n\n    return sceneHit;\n}\n\n/*\nstruct Material\n{\n    vec3 color;\n    float shininess;\n    float shininessScale;\n    float refractiveness;\n    float indexOfRefraction;\n    float refractionScale;\n    bool emissive;\n};\n*/\nMaterial getMaterial(vec3 p, RayHit hit)\n{\n    int id = hit.id;\n    if (id == 3) // Terrain\n    {\n        return Material(hit.color, 0.5, 0.0, 0.0, 0.0, 0.0, false);\n    }\n    else if (id == 4) // Water\n    {\n        return Material(hit.color, 1.0, 1000.0, 0.9, 1.2, 1.5, false);\n    }\n    else if (id == 5) // Ship\n    {\n        vec4 noise = fbmd(p*12.);\n\n        return Material(hit.color, 0.5 * noise.x, 100.0*noise.x,0.0, 0.0, 0.0, false);\n    }\n    else if (id == 6) // Light\n    {\n        return Material(hit.color, 0.0, 0.0, 0.0, 0.0, 0.0, true);\n    }\n    else if (id == 7) // Cargo\n    {\n        vec4 noise = fbmd(p*12.);\n\n        return Material(mix(hit.color, hit.color * 0.5, noise.x), noise.x, 110.0*noise.x, 0.0, 0.0, 0.0, false);\n    }\n    else if (id == 8) // Pet\n    {\n        return Material(hit.color, 0.0, 0.0, 0.0, 0.0, 0.0, false);\n    }\n    return Material(vec3(0, 0, 0), 0., 0., 0., 0., 0., false);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\n\n\nbool trace(vec3 ro, vec3 rd, out RayHit hit)\n{\n    hit = RayHit(MAX_DIST, -1, vec3(0));\n    float t = 0.;\n    float maxDist = 0.001;\n    for (int i = 0; i < MAX_RAY_STEPS; ++i)\n    {\n        vec3 p = ro + rd * t;\n        RayHit sceneInfo = map(p);\n        if (sceneInfo.dist < maxDist)\n        {\n            sceneInfo.dist = t;\n            hit = sceneInfo;\n            return true;\n        }\n        t += sceneInfo.dist;\n        maxDist += sceneInfo.dist * 0.0001;\n        if (t > MAX_DIST)\n            return false;\n    }\n    return false;\n}\n\nbool simpleTrace(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for (int i = 0; i < MAX_RAY_STEPS; ++i)\n    {\n        vec3 p = ro + rd * t;\n        RayHit sceneInfo = map(p);\n        if (sceneInfo.dist < 0.001)\n        {\n            return true;\n        }\n        t += sceneInfo.dist;\n        if (t > MAX_DIST)\n            return false;\n    }\n    return false;\n}\n\nvec3 seed = vec3(0, 0, 0);\nfloat random()\n{\n    return fract(sin(fract(sin(dot(seed.xy, vec2(12.98, 78.23)) * (seed.z += 1.)) * 437.54))*73.54);\n}\n\nvec3 getSampleBiased(vec3 dir, float power) {\n    dir = normalize(dir);\n    vec3 o1 = normalize(abs(dir.x) > abs(dir.z) ? vec3(-dir.y, dir.x, 0) : vec3(0, -dir.z, dir.y));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r = vec2(random(), random());\n    r.x = r.x * 2. * PI;\n    r.y = pow(r.y, 1. / (power + 1.));\n    float oneminus = sqrt(1. - r.y * r.y);\n    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvoid getRay(vec2 uv, vec2 res, inout vec3 ro, inout vec3 rd)\n{\n    float mx = -1.25;\n    float my = -1.2;\n\n#if MOVE_WITH_MOUSE\n    mx = (iMouse.x / res.x  * 2. - 1.) * PI;\n    my = (iMouse.y / res.y  * 2. - 1.) * PI;\n#endif\n\n    mat2 rx = mat2(cos(mx), sin(mx), -sin(mx), cos(mx));\n    mat2 ry = mat2(cos(my), sin(my), -sin(my), cos(my));\n\n    ro = vec3(-1.5, 1.2, -50);\n    rd = normalize(vec3(uv, 7));\n\n    ro.yz *= ry;\n    rd.yz *= ry;\n\n    ro.xz *= rx;\n    rd.xz *= rx;\n}\n\nvec3 getSky(vec3 p)\n{\n    vec3 color = mix(vec3(0.5, 0.75, 1.0), vec3(0.5, 0.75, 1.0) * 0.5, p.y * 0.01);\n    if (p.y < 0.0)\n    {\n        color = vec3(0.05, 0.1, 0.08)*0.25;\n    }\n    else\n    {\n        vec4 noise = fbmd(p * 0.05 + p.y * 0.08);\n        color = mix(color, color + vec3(1, 0.5, 0.4) * 2., noise.x * (p.y * 0.007));\n    }\n    \n    return color; \n}\n\nvec4 pathtrace(vec2 uv)\n{\n    vec3 ro, rd;\n    vec3 accum = vec3(0, 0, 0);\n    vec3 luminance = vec3(1, 1, 1);\n\n    getRay(uv, iResolution.xy, ro, rd);\n\n    for (int i = 0; i < BOUNCE_COUNT; ++i)\n    {\n        RayHit hit;\n        if (trace(ro, rd, hit))\n        {\n            vec3 p = ro + rd * hit.dist;\n            Material mat = getMaterial(p, hit);\n            luminance *= mat.color;\n\n            if (mat.emissive)\n            {\n                accum += luminance;\n                break;\n            }\n            vec3 n = getNormal(p);\n\n\n            float rand = random();\n            if (mat.refractiveness > rand)\n            {\n                rd = getSampleBiased(normalize(refract(rd, n, 1./max(mat.indexOfRefraction, 1.))), mat.refractionScale);\n            }\n            else if (mat.shininess > rand)\n            {\n                rd = getSampleBiased(normalize(reflect(rd, n)), mat.shininessScale);\n            }\n            else\n            {\n                rd = getSampleBiased(n, 1.);\n            }\n            ro = p + rd * 0.1;\n        }\n        else\n        {\n            accum += luminance * getSky(ro + rd * MAX_DIST * 0.1);\n            break;\n        }\n    }\n    \n    return vec4(accum, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n#if !MOVE_WITH_MOUSE\n    if (iFrame < 1000)\n#endif\n    {\n        seed = vec3(uv, mod(iTime, 10.));\n        vec2 jitter = (vec2(random() - 0.5, random() - 0.5) / iResolution.xy);\n        vec2 ndc = (uv + jitter * 2.) * 2. - 1.;\n        ndc.x *= iResolution.x / iResolution.y;\n        vec4 prev = texture(iChannel0, uv);\n        vec4 curr = pathtrace(ndc);\n        #if MOVE_WITH_MOUSE\n        float blendFactor = (prev.a == 0. || iTime < .1 || iMouse.z > 0.) ? 1. : 1. / (1. + (1. / prev.a));\n        #else\n        float blendFactor = (prev.a == 0. || iTime < .1) ? 1. : 1. / (1. + (1. / prev.a));\n        #endif\n        fragColor = vec4(mix(prev.rgb, curr.rgb, blendFactor), blendFactor);\n    }\n#if !MOVE_WITH_MOUSE\n    else\n    {\n        fragColor = texture(iChannel0, uv);\n    }\n#endif\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n\n    fragColor = clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}