{"ver":"0.1","info":{"id":"lcjXRc","date":"1706651243","viewed":378,"name":"Neon Raindrops","username":"chronos","description":"After I did the [url=https://www.shadertoy.com/view/MflXDj]TRIOPTIMUM[/url] shader, I wanted to explore the grid pulse effect a bit more.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["pulse","grid","tron","colorful","disco","neon","drops","electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Neon Raindrops by chronos\n    --------------------------\n    \n    Created by adding layers of domain repeated cells of inverted pyramids falling down.\n\n*/\n#define DEBUG 0\n\nconst float PI = 3.14159265;\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nvec3 drops(vec2 uv)\n{\n    vec3 color = vec3(0);\n    float hash_cnt = 0.;\n    // GRID\n    float grid_size = 20.;\n    vec2 g = cos(grid_size * (1.+uv) * PI);\n    float grid = smoothstep(0.98, 0.99, max(g.x, g.y));\n    grid += (.0001/(1.5+max(g.x, g.y)) + grid*(40./255.)*hash(vec3(uv, 0.)));\n\n    // MASKS\n    vec2 mask_uv = abs(uv);\n    float square_mask = smoothstep(1.01, 1.0, max(mask_uv.x, mask_uv.y));\n    float disc_mask   = smoothstep(1., .66, length(uv));\n\n    // UNIT CIRCLE\n    float circle = smoothstep(0.01, 0.005, abs(length(uv)-1.));\n\n    for(int i = 0; i < 7; i++)\n    {\n        int anim_instance = i;\n        // ANIMATION\n        float time_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n        float speed_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n\n        float speed = 0.25 * mix(0.8, 1.2, speed_offset);\n\n        float t = speed * iTime + time_offset;\n        float drop_cycle = fract(t);\n        float drop_instance = floor(t);\n\n        // COLOR\n        vec3 L = normalize(vec3(1));\n        vec3 U = normalize(vec3(2,-1,-1)/3.);\n        vec3 V = cross(L, U);\n        float hue = 2. * PI * hash(vec3(drop_instance, anim_instance, hash_cnt++));\n        vec3 pulse_color = clamp(.5 * L + U * cos(hue) + V * sin(hue), 0., 1.);\n\n        // PULSE\n        vec2 pos = vec2(\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++)),\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++))\n        );\n        vec2 p = abs(uv-pos);\n        float pulse_tail_len = 0.5;\n        float f = p.x + p.y - (pulse_tail_len + 2. * sqrt(2.)) * drop_cycle;\n        float pulse = max(1.-abs(f)/pulse_tail_len, 0.) * exp(-abs(f))/(0.001 + 100.*abs(f));\n \n        pulse_color = mix(pulse_color, vec3(1), 0.1*smoothstep(0.9, .95, pulse));\n        \n        pulse = mix(pulse, pulse*smoothstep(0.01, 0.00, f), .8);\n \n        color += pulse * pulse_color * grid;\n    }\n    \n    color += 0.01 * (.075/(1.5+max(g.x, g.y)) + (40./255.)*hash(vec3(uv, 0.)));\n    \n    //color += 0.1*grid;\n    color *= mix(0.0, 1., disc_mask);\n    color *= square_mask;\n    \n    #if DEBUG\n    color += circle;\n    #endif\n    \n    return color;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // BASIC SETUP\n    vec2 uv = (2. * fragCoord-iResolution.xy)/ iResolution.y;\n    vec2 m = (2. * iMouse.xy-iResolution.xy)/ iResolution.y;\n    vec3 color = vec3(0);\n    if(length(iMouse.xy) < 10.) m = cos(vec2(iTime, iTime - PI/2.)) * 0.05 - vec2(0, 0.2);\n    \n    \n    #if DEBUG\n    color = drops(uv);\n    color = sqrt(tanh(color * color));\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1);\n    return;\n    #endif\n    \n    \n    // CAMERA SETUP\n    float focal = 1.;\n    vec3 ro = vec3(0, 1., 1.5);\n    vec3 rd = vec3(uv, -focal);\n    \n    float angle = m.y * PI;\n    float c = cos(angle), s = sin(angle);\n    mat2 R = mat2(c,s,-s, c);\n    rd.yz = R * rd.yz;\n    \n    angle = m.x * PI;\n    c = cos(angle), s = sin(angle);\n    R = mat2(c,s,-s, c);\n    rd.xz = R * rd.xz;\n    \n    // solve (ro + rd * t).y = 0. to intersect floor\n    float t = -ro.y/ rd.y;\n    if(t > 0.)\n    {\n        vec3 ray_hit_pos = ro + t * rd;\n        color = drops(.25 * ray_hit_pos.xz);\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    color = sqrt(tanh(color * color));\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}