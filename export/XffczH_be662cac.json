{"ver":"0.1","info":{"id":"XffczH","date":"1720750279","viewed":23,"name":"Wobble polypoints","username":"MajorCallisto","description":"Take a number of points with position (xy) and speed, offset (zw) and animate them.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","wobble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define CATMULL_ROM 0\n#define BEZIER 1\n\nconst int NUM_POINTS = 6;\n\nvec4 points[NUM_POINTS] = vec4[NUM_POINTS](\n    vec4(-0.2, -0.2, 1., 0.03125),\n    vec4(-0.2, 0.2, 1.5, -0.011),\n    vec4(0.0, 0.4, 0.99, 0.022),\n    vec4(0.2, 0.2, 10., -0.044),\n    vec4(0.2, -0.2, 1.11, 0.0055),\n    vec4(0.0, -0.4, 2., -0.033)\n);\n\nvec2 get_pt(int i) {\n    vec4 current = points[(i + NUM_POINTS) % NUM_POINTS];\n    \n    current.x += sin(iTime /current.z)*current.w;\n    current.y += cos(iTime /current.z)*current.w;\n    return current.xy;\n}\n\n// Characteristic matrices\nconst float bezier[16] = float[16](\n    1.,  0.,  0.,  0.,\n    -2., 2.,  0.,  0.,\n    1., -2.,  1.,  0.,\n    0.,  0.,  0.,  0.\n);\nconst float hermite[16] = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3., -2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    vec2 p = a + ab * clamp(dot(uv - a, ab) / dot(ab, ab), 0., 1.);\n    return length(uv - p);\n}\n\nvec2 curve_sample(const float m[16], float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    return (P0 * m[0] + P1 * m[1] + P2 * m[2] + P3 * m[3]) +\n           t * (P0 * m[4] + P1 * m[5] + P2 * m[6] + P3 * m[7]) +\n           t * t * (P0 * m[8] + P1 * m[9] + P2 * m[10] + P3 * m[11]) +\n           t * t * t * (P0 * m[12] + P1 * m[13] + P2 * m[14] + P3 * m[15]);\n}\n\nvoid draw_curve(\n    inout vec3 col, vec2 uv, vec3 curve_col, const float m[16], vec2 P0, vec2 P1, vec2 P2, vec2 P3\n) {\n    const float its = 44.;\n    float sd_curve = 1000.;\n    vec2 prev_p;\n    for (float t = 0.; t <= 1. + 0.01 / its; t += 1. / its) {\n        vec2 p = curve_sample(m, t, P0, P1, P2, P3);\n\n        if (t < 0.01 / its)\n            prev_p = p;\n\n        sd_curve = min(sd_curve, sdLine(uv, prev_p, p) - 0.002);\n        prev_p = p;\n    }\n    col = mix(col, curve_col, smoothstep(fwidth(uv.y), 0., sd_curve));\n}\n\nfloat get_bez_x(float t, vec2 a, vec2 b, vec2 c) {\n    return a.x + t * (2. * b.x - 2. * a.x) + t * t * (-2. * b.x + c.x + a.x);\n}\n\nbool does_py_intersect_bezier(vec2 p, vec2 _a, vec2 _b, vec2 _c) {\n    float a = -2. * _b.y + _c.y + _a.y;\n    float b = 2. * _b.y - 2. * _a.y;\n    float c = _a.y - p.y;\n\n    float s = b * b - 4. * a * c;\n    if (s < 0.)\n        return false;\n\n    float ra = (-b - sqrt(s)) / (2. * a);\n    float rb = (-b + sqrt(s)) / (2. * a);\n    bool ba = ra > 0. && ra < 1.;\n    bool bb = rb > 0. && rb < 1.;\n    if (ba)\n        ba = ba && get_bez_x(ra, _a, _b, _c) < p.x;\n    if (bb)\n        bb = bb && get_bez_x(rb, _a, _b, _c) < p.x;\n    return ba ^^ bb;\n}\n\nvoid drawPoly(inout vec3 col, vec2 uv, vec3 curve_col) {\n    // Generate catmull rom tangents\n    vec2 tangents[NUM_POINTS];\n    const float visc = 0.5;\n    for (int i = 0; i < NUM_POINTS; i++) {\n        tangents[i] = (get_pt(i + 1) - get_pt(i - 1)) * visc;\n    }\n\n    const vec3 bezier_col = vec3(0, 0, 0);\n    const vec3 catmull_rom_col = vec3(0.1, 0.5, 0.);\n\n    int flag = 0;\n    for (int spline = 0; spline < 2; spline++) {\n        for (int pid = 0; pid < NUM_POINTS; pid++) {\n            // Get catmull rom points\n            vec2 P0 = get_pt(pid);\n            vec2 P1 = tangents[pid];\n            vec2 P2 = get_pt(pid + 1);\n            vec2 P3 = tangents[(pid + 1) % NUM_POINTS];\n            if (spline == CATMULL_ROM) {\n                // Draw\n                draw_curve(col, uv, catmull_rom_col, hermite, P0, P1, P2, P3);\n            } else if (spline == BEZIER) {\n                vec2 mid_point = curve_sample(hermite, 0.5, P0, P1, P2, P3);\n\n                P3 = vec2(0);\n\n                // Calculate beziers\n                const float k = 0.25;\n\n                vec2 bez_a_P0 = get_pt(pid);\n                vec2 bez_a_P1 = P0 + k * tangents[pid];\n                vec2 bez_a_P2 = mid_point;\n\n                vec2 bez_b_P0 = mid_point;\n                vec2 bez_b_P2 = get_pt(pid + 1);\n                vec2 bez_b_P1 = P2 - k * tangents[(pid + 1) % NUM_POINTS];\n\n                if (does_py_intersect_bezier(uv, bez_a_P0, bez_a_P1, bez_a_P2)) {\n                    flag = 1 - flag;\n                }\n                if (does_py_intersect_bezier(uv, bez_b_P0, bez_b_P1, bez_b_P2)) {\n                    flag = 1 - flag;\n                }\n\n                // Draw\n                draw_curve(col, uv, bezier_col, bezier, bez_a_P0, bez_a_P1, bez_a_P2, P3);\n                draw_curve(col, uv, bezier_col, bezier, bez_b_P0, bez_b_P1, bez_b_P2, P3);\n\n            }\n        }\n    }\n\n    if (flag > 0)\n        col = bezier_col;\n\n\n    col = pow(col, vec3(0.454545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uvPoly = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 shapePoly = vec3(1.);\n\n    // Call the drawPoly function with the specified points\n    drawPoly(shapePoly, uvPoly, vec3(1, 0.2, 0));\n    \n    vec4 layerPoly = vec4(shapePoly, 1.0);\n    fragColor = layerPoly;\n}","name":"Image","description":"","type":"image"}]}