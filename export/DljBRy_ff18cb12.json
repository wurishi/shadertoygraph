{"ver":"0.1","info":{"id":"DljBRy","date":"1694222101","viewed":11,"name":"Project - 1A","username":"neguete10","description":"Assignment 1A","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["computergraphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\nfloat sdBoxFrame(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    //Normal Vector Generalization\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * sdBoxFrame(pos + e.xyy * eps, vec3(0.5, 0.3, 0.5), 0.025) +\n                     e.yyx * sdBoxFrame(pos + e.yyx * eps, vec3(0.5, 0.3, 0.5), 0.025) +\n                     e.yxy * sdBoxFrame(pos + e.yxy * eps, vec3(0.5, 0.3, 0.5), 0.025) +\n                     e.xxx * sdBoxFrame(pos + e.xxx * eps, vec3(0.5, 0.3, 0.5), 0.025));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera movement\n    float an = 0.5 * (iTime - 10.0);\n    vec3 ro = 1.2 * vec3(1.0 * cos(an), 0.0, 1.0 * sin(an));\n    vec3 ta = vec3(0.0, -0.0, 0.0);\n    // Camera matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    // Render\n    vec3 tot = vec3(0.0);\n\n    for (int m = 0; m < AA; m++)\n        for (int n = 0; n < AA; n++)\n        {\n            // Pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n\n            // Create view ray\n            vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n            // Raymarch\n            const float tmax = 5.0;\n            float t = 0.0;\n            for (int i = 0; i < 256; i++)\n            {\n                vec3 pos = ro + t * rd;\n                float h = sdBoxFrame(pos, vec3(0.5, 0.3, 0.5), 0.025);\n                if (h < 0.0001 || t > tmax)\n                    break;\n                t += h;\n            }\n\n            // Phong Shading\n            vec3 col = vec3(0.0);\n            if (t < tmax)\n            {\n                vec3 pos = ro + t * rd;\n                vec3 nor = calcNormal(pos);\n                vec3 lightDirection = normalize(vec3(-1.0, 1.0, -1.0));\n                vec3 viewDirection = normalize(ro - pos);\n                float ambientStrength = 0.3;\n                float specularStrength = 0.4; \n                float shininess = 40.0;\n\n                vec3 materialColor = vec3(0.4, 0.4, 0.5);\n                vec3 lightColor = vec3(0.9, 0.8, 0.7);\n\n                // Lambertian reflection\n                float diffuse = max(dot(nor, lightDirection), 0.0);\n\n                // Specular reflection\n                vec3 reflectDir = reflect(-lightDirection, nor);\n                float specular = pow(max(dot(viewDirection, reflectDir), 0.0), shininess);\n\n                // Calculate the individual RGB components\n                vec3 ambientColor = ambientStrength * vec3(0.2, 0.2, 0.3);\n                vec3 diffuseColor = diffuse * materialColor * lightColor;\n                vec3 specularColor = specularStrength * vec3(0.5, 0.5, 0.6);\n                col = ambientColor + diffuseColor + specularColor;\n            }\n\n            // Blue skies and sunshine background\n            if (t >= tmax)\n            {\n                // Background color gradient\n                float gradient = 0.5 * (rd.y + 1.0);\n                vec3 backgroundColor = mix(vec3(0.5, 0.7, 1.0), vec3(0.7, 0.8, 0.2), gradient);\n                               \n                col = vec3(min(cos(iTime * backgroundColor),vec3(0.7, 0.8, 0.2)));\n                \n                //col = smoothstep(iTime*backgroundColor, vec3(0.7, 0.8, 1.0), t);\n                //col = vec3(t, smoothstep(rd.x, 0.3, iTime), t)*backgroundColor;\n                //col = backgroundColor;\n            }\n\n            // Gamma correction\n            col = sqrt(col);\n            tot += col;\n        }\n\n    tot /= float(AA * AA);\n    \n    fragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}