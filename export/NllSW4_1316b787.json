{"ver":"0.1","info":{"id":"NllSW4","date":"1626412092","viewed":123,"name":"Cellular Automata Perfect Maze","username":"MazeMason","description":"A cellular automata that generates mazes that are perfect on each iteration. Click on maze to reset. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["maze","cellularautomata","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool grid = false;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 coord = ivec2((fragCoord  + iResolution.xy / 2.0 + zoom / 2.0) / zoom - iResolution.xy * (1.0 - zoom)/zoom); \n    vec4 col = texelFetch(iChannel0, coord / 2 , 0);\n    int comp = coord.x % 2 + 2 * (coord.y % 2); \n \n     // Output to screen\n     \n    float color = steps?col[comp]:max(outside * float(col[comp] != 0.0), float(col[comp] == 1.0));\n    fragColor = vec4(color - float(grid && any(equal(mod((fragCoord-.50)/ 2.0,zoom), vec2(0.0)))));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 color;\n    \n    vec4 mem = texelFetch(iChannel0, ivec2(0.0), 0);\n\n    if(all(equal(fragCoord, vec2(0.5)))) {\n        color = vec4(vec2(iResolution.xy),\n                        (mem.z + 1.0) * (1.0 - float(iMouse.z > 0. && iMouse.w > 0.||\n                                        all(notEqual(mem.xy, iResolution.xy)))),\n                        0.0);\n        \n    } else {\n\n        int frame = int(mem.z);\n\n        if(frame == 0 && !all(equal(fragCoord, vec2(0.5)))) {\n\n            // one cell initial maze on reset\n            ivec2 coord = ivec2(fragCoord - 0.5 - iResolution.xy / 2.0);\n            if(coord.y == 0) {\n                if(coord.x == 0) {\n                    color = vec4(block,block, block, open);\n                } else if(coord.x == 1) {\n                    color = vec4(block, outside, block, outside);\n                } else {\n                    color = vec4(outside);\n                }\n\n            } else if(coord.y == 1) {\n                if(coord.x == 0) {\n                    color = vec4(block, block, outside, outside);\n                } else if(coord.x == 1) {\n                    color = vec4(block, outside, outside, outside);\n                } else {\n                    color = vec4(outside);\n                }\n            } else {\n                    color = vec4(outside);\n            }\n\n        } else if(frame % delay == 0) {\n            // open doors to outside based on random seeds for buffer B\n            vec4 here = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            vec4 down = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.0, 1.0)), 0);\n            vec4 left = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.0, 0.0)), 0);\n            vec4 up = texelFetch(iChannel0, ivec2(fragCoord + vec2(0.0, 1.0)), 0);\n            vec4 right = texelFetch(iChannel0, ivec2(fragCoord + vec2(1.0, 0)), 0);\n\n            if(here.x == block) {\n                if(here.w == open &&\n                    ( down.w != open && down.w != block ||\n                      left.w != open && left.w != block )) {\n                        here = vec4(block, float(here.y == open || down.w == outside + north),\n                                           float(here.z == open || left.w == outside + east), open);             \n\n                } else if(here.w != open && here.w != outside) {\n                         here = vec4(block, float(down.w == outside + north || here.w == outside + south), \n                                            float(left.w == outside + east || here.w == outside + west), open);             \n                }\n            }\n\n            color = here;\n\n        } else {\n            color = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0);\n        }\n    }    \n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Please change these to change the maze\nconst int delay = 5;\nconst float zoom = 2.;\nconst bool sparse = false;\nconst float square = 0.5;\n\n\nconst bool steps = false;\n\n\n// cell states, not to modified\nconst float block = 0.0;   // black\nconst float open  = 1.0;   // white\nconst float outside = 0.5; //grey\n\n// the randomized states to open the external blocks\nconst float north = 0.1;\nconst float west = 0.2;\nconst float south = 0.3;\nconst float east = 0.4;\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 here = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.0, 1.0)), 0);\n    vec4 sw = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.0, 1.0)), 0);\n    vec4 se = texelFetch(iChannel0, ivec2(fragCoord - vec2(-1.0, 1.0)), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.0, 0.0)), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord + vec2(0.0, 1.0)), 0);\n    vec4 nw = texelFetch(iChannel0, ivec2(fragCoord + vec2(-1.0, 1.0)), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord + vec2(1.0, 0)), 0);\n    \n    vec4 new = vec4(here.x, here.y, here.z, here.w);\n    \n    vec4 mem = texelFetch(iChannel0, ivec2(0.0), 0);\n\n    int frame = int(mem.z) - 1;\n\n    if(frame % delay == int(steps) * delay /4 ) {\n    \n        // close blocks around new open doors from buffer a to complete the maze\n        if(here.x == outside) {\n            new.x = here.x * (1.0 - float(sw.w == open || s.w == open || w.w == open || e.z == open || n.y == open || se.z == open|| nw.y == open));\n        }\n        \n        if(here.y == outside) {\n            new.y = here.y * (1.0 - float(s.w == open || s.z == open || e.z == open || se.z == open || e.z == open || n.y == open));\n        }\n        \n        if(here.z == outside) {\n            new.z = here.z * (1.0 - float(w.w == open || w.y == open || n.y == open || nw.y == open || e.z == open ));\n        }\n        \n        if(here.w != open && here.w != block ) {\n            \n            new.w = min(outside * (1.0 - float(here.z == open || here.y == open )) + float(n.y == open || e.z == open), 1.0);\n        }\n\n    }\n    \n    fragColor = new;\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://www.shadertoy.com/embed/ttc3zr\n// 1 output, 4 inputs\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\n\n\n\nfloat hash12(vec2 src) {\n    return abs(fract(hash14(vec4(iFrame,\n                                int(iDate.y * 32.0 + iDate.z),\n                                int(iDate.w),\n                                src.x + src.y * iResolution.x))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 here = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.0, 1.0)), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.0, 0.0)), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord + vec2(0.0, 1.0)), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord + vec2(1.0, 0)), 0);\n    \n    vec4 mem = texelFetch(iChannel0, ivec2(0.0), 0);\n\n    int frame = int(mem.z) -1;\n\n\n    if(frame % delay == int(steps) * delay /2) {\n    \n        // random seeds around external walls to open new doors on buffer a \n        if(here.w != open && here.w != block && \n                fragCoord.x > iResolution.x * (.5 - .25 / zoom) + .6 &&\n                fragCoord.y > iResolution.y * (.5 - .25 / zoom) + .6 &&\n                fragCoord.x < iResolution.x * (.5 + .25 / zoom) - .6 &&\n                fragCoord.y < iResolution.y * (.5 + .25 / zoom) - .6 ) {\n            \n            \n            float[4] dir = float[](0.0,0.0,0.0,0.0);\n            int i = 0;\n            \n            if(e.z == block && e.w == open){\n                dir[i++] = east;\n            }\n            \n             \n            if(n.y == block && n.w == open){\n                dir[i++] = north;\n            }\n            \n            if(here.z == block && w.w == open){\n                dir[i++] = west;\n            }\n\n            if(here.y == block && s.w == open){\n                dir[i++] = south;\n            }\n            \n            float r = hash12(fragCoord);\n            float rr = floor(r * 10.) / 10.;\n\n            float rand = float(square > rr) * float(i>0 && !sparse || i == 1) * dir[int(floor(float(i) * r))];\n \n            here.w = outside + rand;\n        }\n\n    }\n    \n    fragColor = here;\n}","name":"Buffer B","description":"","type":"buffer"}]}