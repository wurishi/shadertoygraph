{"ver":"0.1","info":{"id":"lXKSRy","date":"1720141819","viewed":59,"name":"july 3 2024","username":"ufffd","description":"was a terrible day","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","materials"],"hasliked":0,"parentid":"dstGD4","parentname":"ufffd raymarch template feb 2023"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // setup\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y += sin(uv.y*10. + iTime)*0.01 - .01;\n    \n    uv -= 0.5;\n    \n    uv.x -= smoothstep(0.9,1.,bnoise(uv.y*10. + iTime*300.))*.05;\n    float slow_warp = smoothstep(0.7,.9,sin(uv.y*4. + iTime*.8));\n    uv.x -= slow_warp*.02*(0.5+0.5*bnoise(uv.y*20.+iTime*300.));\n    \n    uv += 0.5;\n    \n    vec2 cell_pxl = pxl_size/iResolution.xy;\n    \n    vec2 cell = fragCoord / pxl_size;\n    \n    float cell_hash1 = hash12(cell + iTime);\n    if (cell_hash1  > 0.9)\n        uv.x -= cell_pxl.x + slow_warp*.03;\n    if (cell_hash1  > 0.95)\n        uv.x -= cell_pxl.x;\n    \n    vec3 col = texture(iChannel0,uv/pxl_size).rgb;\n    \n    col.r *= 0.4 + 0.6*smoothstep(1.,.6,bnoise(uv.y*2. + iTime*3.));\n    col.g *= 0.7 + 0.3*smoothstep(.9,.1,bnoise(uv.y*5. + 0.1 + iTime*20.));\n    // col.rg -= 0.01*smoothstep(.9,.1,bnoise(uv.y*5. + 0.1 + iTime*100.));\n    col.b *= 0.5 + 0.5*smoothstep(.95,.4,bnoise(uv.y*4. + 0.2 + iTime*4.));\n    \n    col *= 1. - 0.5*slow_warp*sin(uv.x*5. + iTime*3.);\n    col += slow_warp * 0.001;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int pxl_size_i = 5;\nconst float pxl_size = float(pxl_size_i);\n\n\n#define SS(a,b,c) smoothstep(a-b,a+b,c)\n\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn v * Rot(a);\n}\n\n// sdfs\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOrb(vec3 p, float b) {\n  return length(p) - b;\n}\nfloat sdGyroid(vec3 p, float b) {\n    float g = dot(sin(p),cos(p.yzx));\n    return g - b;\n}\n\n// voronoi 3d\n// https://github.com/MaxBittker/glsl-voronoi-noise?tab=MIT-1-ov-file#readme\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n\n  return vec3(sqrt(res), abs(id));\n}\n\n\n\n// hash - rand - noise\n//--------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/3sd3Rs\n// Basic noise - iq MIT\nfloat bnoise( in float x ) {\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    float k = hash11(i);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n\n// iq box intersect\nfloat boxIntersect( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return tF;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEP_MAX 120.\n#define RAY_MAX 3.\n#define SPECULAR_POWER 100.\n#define SPECULAR_INTENSITY .5\n\n// define textures\nstruct Tex {\n    vec3  c; // color\n    float m; // mirror\n    // add more material data:\n    float r; // rough\n    // metal - maybe replace mirror\n    // specular\n    // anisotropic - does this one really matter\n    // opacity - complicated\n    // emission/glow - maybe less complicated\n    // ior\n};\n// tex setup. takes object and global position as inputs\nTex T1(in vec3 p, in vec3 gp) {\n    // green, nonreflective\n    Tex T;\n    T.c = vec3(0.,1.,0.);\n    T.m = 0.;\n    return T;\n}\nTex T2(in vec3 p, in vec3 gp) {\n    // black and white stripes\n    // the black part is reflective\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x+p.y+p.z+tt));\n    stripes = SS(0.,0.01,stripes);\n    T.c = vec3(stripes);\n    T.m = 1.-stripes;\n    return T;\n}\nTex T3(in vec3 p, in vec3 gp) {\n    // show norms\n    Tex T;\n    T.c = normalize(p);\n    T.m = 0.;\n    return T;\n}\nTex T4(in vec3 p, in vec3 gp) {\n    // black mirror\n    Tex T;\n    T.c = vec3(.001);\n    T.m = .8;\n    return T;\n}\nTex T5(in vec3 p, in vec3 gp) {\n    // white mattte\n    Tex T;\n    T.c = vec3(1.);\n    T.m = .0;\n    return T;\n}\n// structs for abstracting march process\nstruct MapData {\n    vec4  c; // color\n    float d; // distance\n    float m; // mirror\n    bool  h; // hit\n};\nstruct MarchData {\n    vec4  c; // color\n    vec3  p; // intersection point\n    float d; // distance\n    float s; // steps\n    bool  h; // hit\n    // bounces\n    // attenuation\n    // steps in this bounce\n};\nvoid drawTex(in vec3 p, in vec3 gp, inout MapData m, int tx) {\n    Tex T;\n    if (tx==1) T = T1(p,gp);\n    if (tx==2) T = T2(p,gp);\n    if (tx==3) T = T3(p,gp);\n    if (tx==4) T = T4(p,gp);\n    if (tx==5) T = T5(p,gp);\n    float color_mix = 1.; // this should be set based on material & incidence angle\n    m.c = vec4(T.c,color_mix);\n    m.m = T.m;\n}\n// 3d scene\nvoid addObject(in float sdf, in int tx, in vec3 p, in vec3 gp, inout MapData m) {\n    m.h = m.h || sdf < 0.001; // register hit\n    if (sdf < m.d) { // this is the closest object so far\n        m.d == sdf;\n        drawTex(p,gp,m,tx);\n    }\n    m.d = min(m.d,sdf);\n}\nMapData map(in vec3 p) {\n    // returns distance to nearest surface from a given point in 3d space\n    MapData m;\n    m.d = 9999.; // start high, use min(d,x) to add geometry to scene\n    m.m = 0.; // no reflective surfaces yet\n    m.h = false; // no surfaces at all yet really\n    m.c = vec4(0.); // sure is dark in here...\n    \n    \n    vec3 pmod = mod((p+0.5*2.), 2.) - 0.5*2.;\n    vec3 id = floor(p+0.5*2./2.) - 0.5*2.;\n    \n    float cell_rand = hash13(id);\n    \n    pmod *= 1.5;\n    pmod += .1*cell_rand;\n    \n    // add sphere\n    // float sph1 = sdOrb(pmod+vec3(sin(iTime),sin(iTime/4.),cos(iTime))*0.3, 0.2);\n    // addObject(sph1, 2, pmod, pmod, m);\n    \n    float vorosph1 = voronoi3d(p).x - 0.07;\n    addObject(vorosph1, 2, p, p, m);\n    \n    \n    float vorosph2 = voronoi3d(p*.5).x - 0.12;\n    addObject(vorosph2, 2, p, p, m);\n    \n    /*\n    // wrapper spheres for boolean ops\n    float sph2 = sdOrb(pmod+vec3(sin(iTime),sin(iTime/4.),cos(iTime))*0.3, 0.25-0.02);\n    float sph3 = sdOrb(pmod+vec3(sin(iTime),sin(iTime/4.),cos(iTime))*0.3, 0.25+0.02);\n    float sph4 = sdOrb(pmod+vec3(sin(iTime),sin(iTime/4.),cos(iTime))*0.3, 0.3);\n        \n    // add box\n    vec3 boxp = pmod;\n    boxp.xy = rotate(boxp.xy, iTime);\n    boxp.yz = rotate(boxp.yz, iTime*0.17);\n    float box1 = sdBox(boxp, vec3(0.2)) - 0.01;\n    box1 = max(box1,-sph4);\n    addObject(box1, 2, boxp, pmod, m); \n    // wrapper boxes for boolean ops\n    float box2 = sdBox(boxp, vec3(0.25-0.02)) - 0.01;\n    float box3 = sdBox(boxp, vec3(0.25+0.02)) - 0.01;\n    \n    \n    // add gyroid\n    float gy1 = sdGyroid(pmod*20., -.5);\n    // gy1 = max(gy1, sph3);\n    // gy1 = max(gy1, -sph2);\n    float gy1bound = max(-sph2, sph3);\n    gy1bound = min(gy1bound, max(-box2, box3));\n    gy1 = max(gy1, gy1bound);\n    // gy1 = gy1bound;\n    int gyroid_mat = 1;\n    if (cell_rand > 0.5) gyroid_mat = 5;\n    addObject(gy1, gyroid_mat, pmod, pmod, m);\n    */\n        \n    return m;\n}\nvec3 getNorm(vec3 p, float spread) { \n    float d = map(p).d; // Distance\n    vec2 e = vec2(.02*spread,0); // Epsilon\n    vec3 n = d - vec3(\n        map(p-e.xyy).d,  \n        map(p-e.yxy).d,\n        map(p-e.yyx).d);   \n    return normalize(n);\n}\nvec3 getNorm(vec3 p) {\n    return getNorm(p, 0.01); // default spread\n}\n// raymarch\nMarchData raymarch(in vec3 ro, in vec3 rd) {\n    MarchData d;\n    d.h = false;\n    d.d = 0.;\n    d.c = vec4(0.);\n    float atten = 1.;\n    for (d.s=0.;d.s<STEP_MAX;d.s++) {\n        vec3 p = ro + rd*d.d;\n        MapData m = map(p);\n        // avoid pmod artifacts by stopping at cell boundaries\n        float cell_size = 2.;\n        // float b = boxIntersect(mod(p, SIZE) - SIZE/2.0, rd, vec3(SIZE/2.0));\n        float b = boxIntersect(\n            mod((p+0.5*2.), 2.) - 0.5*2., \n            rd, \n            vec3(cell_size/2.0)\n            );\n        m.d = min(m.d, b + 0.001);\n        if (m.h) { // hit\n            d.h = true; // record hit\n            d.p = p; // hit location\n            d.c.rgb += m.c.rgb*m.c.a*atten; // lol. adds hit color to return color\n            if (m.m<0.01) break; // if not a mirror, we're done\n            // else, we hit a mirror. reflect and keep steppin\n            atten *= m.m;\n            vec3 n = getNorm(p);\n            rd = reflect(rd, n);\n            d.d = 0.;\n            // d.c = vec4(n,1.); break; // debug\n            ro = p + rd*.001; // step away from surface\n        } else\n            d.d += m.d * 0.5;\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // setup\n    fragCoord *= pxl_size;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    if (any(greaterThan(uv,vec2(1.)))) return;\n    // uvc *= 4./pxl_size;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(iTime*0.05-.3,-.3,-1);\n    vec3 rd = normalize(vec3(uvc,4.));\n    \n    rd.xz *= Rot(iTime*.03);\n    rd.yz *= Rot(iTime*.02);\n    // raymarch\n    for (float M=0.;M<RAY_MAX;M++) { // multiple rays per pixel\n        MarchData d = raymarch(ro+hash31(M)/100000000.,rd);\n        vec3 raycol = d.c.rgb;\n        // col = vec3(1./d.d, d.s/STEP_MAX, float(d.h)); // debug march data\n        // col = vec3(d.d);\n        // lighting - should all of this happen within raymarch for each intersection? probably\n        vec3 n = d.h?getNorm(d.p):vec3(0,0,1);\n        n += hash33(d.p*100.)*.1; // scatter - ought to be based on material roughness\n        vec3 bounceAngle = reflect(rd,n); \n\n        float amb = d.h?0.001:0.; // add ambient light for all hit pixels\n\n        vec3 light1pos = vec3(sin(iTime*0.2),cos(iTime*0.2), sin(iTime));\n        vec3 light1dir = normalize(light1pos-d.p);\n        vec3 light2pos = vec3(sin(iTime*0.3),cos(iTime), cos(iTime*0.3));\n        vec3 light2dir = normalize(light2pos-d.p);\n        \n        float diff1 = max(0.0, dot(n, light1dir)) * 1.;\n        float spec1 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light1result = diff1 + spec1;\n        \n        float diff2 = max(0.0, dot(n, light2dir)) * 1.;\n        float spec2 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light2result = diff2 + spec2;\n\n        raycol *= vec3(amb + light1result + light2result); // apply lighting\n        col += raycol;\n    }\n    col /= RAY_MAX;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}