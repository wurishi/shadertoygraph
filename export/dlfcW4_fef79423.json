{"ver":"0.1","info":{"id":"dlfcW4","date":"1690915020","viewed":85,"name":"Universe Shader","username":"thekiross","description":"learning shader toy","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float DistLine(vec2 p,vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),.0,1.);\n    return length(pa-ba*t);\n}\nfloat N21 (vec2 p){\n    p = fract(p*vec2(233.34,851.73));\n    p += dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\nvec2 N22 (vec2 p){\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\nvec2 GetPos(vec2 id, vec2 offset){\n     vec2 n = N22(id+offset) *iTime;\n     return offset+sin(n) *.4;\n}\nfloat Line (vec2 p, vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float m = smoothstep(0.03,0.01,d);\n    float d2 = length(a-b);\n    m *= smoothstep (1.2,0.8,d2)*.5+smoothstep(0.05,0.03,abs(d2-0.75));\n    return m;\n}\nfloat Layer (vec2 uv){\n    \n    float m=0.;\n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n    vec2 p [9];\n    int i =0;\n    for (float y= -1.;y<=1.;y++){\n        for (float x = -1.;x<=1.;x++){\n            p[i++] = GetPos(id,vec2(x,y));\n        }\n    }\n    float t = iTime * 10.;\n    for(int i=0;i<9;i++){\n        m += Line(gv,p[4],p[i]);\n        //distance from point to pixel\n        vec2 j = (p[i]-gv) *20.;\n        //length squared length(j)\n        float sparkle = 1./dot(j,j);\n        m+= sparkle * (sin(t+fract(p[i].x)*10.)*.5+.5);\n    }\n    m+= Line(gv,p[1],p[3]);\n    m+= Line(gv,p[1],p[5]);\n    m+=Line(gv,p[7],p[3]);\n    m+=Line(gv,p[7],p[5]);\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n    //float d = DistLine(uv,vec2 (0),vec2(1));\n    float m = 0.;\n    float gradient = uv.y*.5;\n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c,-s,s,c);\n    \n    uv*=rot;\n    mouse*=rot;\n    for(float l =0.; l<=1.;l+= 1./3.){\n        float depth = fract(l+t);\n        float size = mix(10.,.5,depth);\n        float fade = smoothstep(0.,.5,depth)*smoothstep(1.,.8,depth);\n        m+=Layer(uv*size+l*20. - mouse)*fade;\n    }\n    \n    // Time varying pixel color\n    float fft = texelFetch(iChannel0, ivec2(.7,1),0 ).x;\n    vec3 base = 1.5*fft*(sin(t*5.*vec3(108./255., 92./255., 231./255.))*.5+.5);\n    vec3 col = m*base;\n    col+= -gradient*base;\n    col*= 1.2*fft;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}