{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n\n// Distance to other shapes ---------------------------------------------\n\tfloat dShape;\n\tint idMorph = int(mod(floor(.5+(iTime)/(2.*3.141592658)),3.));\n\t\n\tif (idMorph == 1) {\n\t\tp.xz *= mat2Rot;\n   \t \tvec3 d = abs(p-vec3(.0,.5,0)) - vec3(.8,.7,.8);\n   \t\tdShape = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t} else if (idMorph == 2) { \n\t\tp -= vec3(0,.55,0);\n\t\tvec3 d1 = abs(p) - vec3(.67,.67,.67*1.618),\n\t\t     d3 = abs(p) - vec3(.67*1.618,.67,.67);\n   \t\tdShape = min(max(d1.x,max(d1.y,d1.z)),0.) + length(max(d1,0.));\n   \t\tdShape = min(dShape,min(max(d3.x,max(d3.y,d3.z)),0.) + length(max(d3,0.)));\n\t} else {\n\t\tdShape = length(p-vec3(0,.45,0))-1.1;\n\t}\n\t\n\t// !!! The morphing is here !!!\n    return mix(dTeapot, dShape, abs(tMorph));\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n    vec2 d = vec2(-1,1) * pitch;\n\tvec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx; // tetrahedral offsets\n\tfloat f0 = M(p0), f1 = M(p1), f2 = M(p2), f3 = M(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Morphing step\n\ttMorph = cos(iTime*.5);\n\ttMorph*=tMorph*tMorph*tMorph*tMorph;\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = hsv2rgb_smooth(.9+iTime*.02, 1.,1.); \n\t\t// Shading\n\t    c = mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslSDN","date":"1401636158","viewed":8727,"name":"Morphing","username":"iapafoto","description":"[Mouse available]\n3D morphing between 2 distance fields is just a \"mix\" between the distances of the 2 scenes  :) (possible to extend it to colors of course).","likes":99,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","bezier","hsv","teapot","morphing"],"hasliked":0,"parentid":"","parentname":""}}