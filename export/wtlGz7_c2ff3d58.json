{"ver":"0.1","info":{"id":"wtlGz7","date":"1556179668","viewed":112,"name":"581 Final Proj Part1","username":"zheng516","description":"This shadertoy is a final project for the school course. It took references from multiple works.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["581"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\n//camera position\nvec3  camPos = vec3(0.0, 0.0, 10.0);\n\n\n//template distance funciton\nfloat sphereSDF(in vec3 samplePoint, in float radius){\nreturn length (samplePoint) - radius;\n}\n\nfloat planeSDF( in vec3 samplePoint, in vec4 n)\n{// n must be normalized\n\treturn dot(samplePoint, n.xyz) + n.w;\n}\n\n//rectangle\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat cupSDF(vec3 p) {\t\n    float dst = 0.0;\n\tfloat d1 = sdRoundedCylinder(-p, 0.12, 0.1, 0.1);\n   \tfloat d2 = sdCappedCylinder(vec3(0.,0.2,0.)-p, vec2(.1,.35));\n    dst = opSmoothSubtraction(d2, d1, 0.2);    \n    return dst;   \n}\n\n//Bezier curve utility func=====================\n\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n//Tea pot distance func=============================================\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nfloat potSDF(vec3 p) {\n\n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.0);\n\n    return dTeapot;\n}\n\n\t\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//used in the sceneSDF, but sceneSDF only returns .x, set global here to hold .y\n// which is the ID of dist\nvec2 result = vec2 (0.0);\n\n//**assign id to each dist as the second component in mapNid\nfloat sceneSDF(vec3 samplePoint) {\n    result = vec2(sdBox(samplePoint- vec3 (0.0, -1.8, -2.0), (vec3(3.0, 1.0, 3.0))), 0.0);\n    \n    //result = opU(result, vec2(sphereSDF(samplePoint-vec3 (-1.5, \t\t\t3.0, \t\t\t   -1.5), 1.0), 1.0));\n    //result = opU(result, vec2(sphereSDF(samplePoint-vec3 ( 1.5, \t\t\t3.0, \t\t\t\t-1.5), 1.0), 2.0));   \n    //result = opU(result, vec2(sphereSDF(samplePoint-vec3 ( 0.0, \t\t3.0+cos(iTime), \t\t\t-1.5), 0.5), 3.0));\n    \n    result = opU(result, vec2(potSDF(samplePoint- vec3(-0.5, -0.89, -1.0)), 4.0));\n    result = opU(result, vec2(cupSDF(samplePoint- vec3(0.8, -0.7, -2.0)), 5.0));\n    \n    //return min(min(sphereSDF1(samplePoint), sphereSDF2(samplePoint)),\n      //        sphereSDF3(samplePoint));\n\n    return result.x;\n\n}\n\n/**\n * Return the shortest distance from the camera point to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * camPos: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat distTosurf(vec3 camPos, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(camPos + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}          \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/*============Utility functions===================*/\n/*vec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}*/\n\nvec3 estimateNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sceneSDF( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sceneSDF( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sceneSDF( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sceneSDF( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneSDF(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif  \n}\n\n\nfloat softShadow( in vec3 pos, in vec3 lightDir, float mint, float maxt, float k )\n{\n    float res = 1.0;\n\tfloat t = mint;\n\n\tfloat h = sceneSDF(pos + lightDir*t);\n\n    float ph = 1e20;\n    for( float t=mint; t < maxt;  )\n    {\n        h = sceneSDF(pos + lightDir*t);\n        if( h< 1e-4) return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n    }\n    return clamp(res, 0.0f, 1.0f);\n}\n\nfloat ambientOcc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = sceneSDF( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\n//** PBR Equations===========================================================\n\nconst float PI = 3.14159265359;\n\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\n//some variables before lighting\nint numOfLit = 1;\n//set parameters for material\nvec3 albedo;\nfloat roughness = 0.1; //** can be changed later\nfloat metallic = 0.3;  //** can be changed later\n\n//preset albedo color\nvec3 alumi = vec3(0.96, 0.96, 0.97);\nvec3 gold = vec3(1.00, 0.86, 0.57);\nvec3 copper = vec3(0.95, 0.64, 0.54);\nvec3 plastic = vec3(0.24, 0.24, 0.24);\nvec3 test = vec3(0.8, 0.8, 0.7);\n\n//******PBR lighting\nvec3 renderPBR(in vec3 ro, in vec3 rd){\n//** in shader toy changing variables cannot be global, so put litPos locally    \nvec3 lightPos[4] = vec3[4](\n        vec3(6.0 \t\t, 2.0\t\t\t\t\t , -10.0),\n        vec3(2.0 * sin(0.37 * iTime), 2.0 * cos(0.37 * iTime), -2.0),\n        vec3(3.0 * sin(0.66 * iTime), 2.0 * cos(0.66 * iTime), - 1.0),\n    \tvec3(5.0 * cos(0.17 * iTime), 3.0 * sin(0.47 * iTime), -2.0+ cos(0.17*iTime))\n    );\nvec3 lightColor[4] =  vec3[4](\n    vec3(0.4,0.2,0.1),\n    vec3(0.3),\n    vec3(0.1),\n    vec3(0.3));\n   \n\n//mapNid.y is the ID of the dist, so set parameters of each dist here\nif(result.y == 1.0)\n    {\n        roughness = 0.5;\n        metallic= 0.6;\n        albedo = gold;\n        //F0 =  mix(F0, albedo, metallic);\n    }\n    else if(result.y == 2.0)\n    {\n        roughness =0.7;\n        metallic = 0.9;\n        albedo = copper;\n       \t//F0 = mix(F0, albedo, metallic);\n    }\n    else if (result.y == 3.0)\n    {\n        roughness =0.5;\n        metallic = 0.5;\n        albedo = vec3 (0.95, 0.93, 0.88);\n       \t//F0 = mix(F0, albedo, metallic);\n    }\n    else if (result.y == 0.0){\n       \troughness =0.2;\n        metallic = 0.8;\n        albedo = test;\n       \t//F0 = mix(F0, albedo, metallic); \n    }\n     else if (result.y == 4.0){\n       \troughness =0.2;\n        metallic = 0.8;\n        albedo = alumi;\n       \t//F0 = mix(F0, albedo, metallic); \n    }\n    else if (result.y == 5.0){\n       \troughness =0.2;\n        metallic = 0.8;\n        albedo = copper;\n       \t//F0 = mix(F0, albedo, metallic); \n    }\n\n    //*****sample point\n    float t = distTosurf(ro, rd, MIN_DIST, MAX_DIST);\n    vec3 p = ro + t*rd;\n    \n    //computing the variable needed in the loop\n\tvec3 N =  estimateNormal(p);\n\tvec3 V =  normalize(camPos - p);\n\tvec3 F0 = vec3(0.04);\n\t\t F0 = mix(F0, albedo, metallic); \n\tvec3 Spec = vec3(0.0);\n    vec3 diff = vec3(0.0);\n\tfloat sShadow = 0.0;\n    \t\n    for(int i=0;i<numOfLit;i++)\n    {\n        vec3 L = normalize(lightPos[i]-p);\n        vec3 H = normalize(V+L);\n        \n        float attenDist = length(lightPos[i]-p);\n        float attenuation = 1.0/(attenDist*attenDist);\n        \n        vec3 radiance = lightColor[i]*attenuation;\n        \n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F = fresnelSchlick(max(dot(H,V),0.0),F0);\n        \n        vec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);\n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - roughness;\n        \n        float NdotL = max(dot(N, L), 0.0);\n        //if(NdotL<0.1)\n        //    NdotL = 1.0;\n        \n        Spec += (kD * albedo / PI  + specular) * radiance * NdotL;\n    \tdiff += lightColor[i]*albedo*NdotL;\n        \n        //sShadow += softShadow(p, L, 0.001, 10.0);\n    \tsShadow += softShadow(p, L, 0.01, 5.0, 32.0);\n    }\n    \n    float occ = ambientOcc(p, N);\n\n    vec3 ambient =  0.5*albedo * roughness*occ;\n    vec3 color =  ambient+(0.5*diff + Spec)*sShadow;\n     \n    \n    return color;\n}\n\n\nvec3 clearCol(in vec3 rd, in vec2 fragCoord){\n/*\n // background sky  \n   vec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 clearcol = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tclearcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n    // sun glare    \n\tclearcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n*/\n   vec2 uv = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n    \n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n//    vec3 clearcol = vec3(texture( iChannel2, q ));\n\tvec3 clearcol = textureLod(iChannel3, q, 0.0).xyz;\n        \n    return clearcol;\n\n}\n\n//=================================================================\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Teapot body profil (8 quadratic curves) \n    A[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t//vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //vec3 camPos = vec3(0.0, 0.0, 5.0);\n  /* float dist = distTosurf(camPos, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }*/\n    \n    \n    //vec3 color = renderPBR(camPos, dir);\n    \n    \n    //fragColor = vec4(color, 1.0);\n    \n     vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    vec3 ro = vec3( 1.0+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.0+3.5*sin(6.0*mo.x) );\n    vec3 ta = vec3( 0.0, 1.0, -0.0 );\n    \n     mat3 ca = setCamera( ro, ta, 0.0 );\n\tfloat dist = 0.0;\n    \n     vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        //vec3 dir = rayDirection(45.0, iResolution.xy, (fragCoord+o));\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        //vec3 dir = rayDirection(45.0, iResolution.xy, (fragCoord));\n#endif\n\n        // ray direction\n        vec3 rd =  ca*normalize( vec3(p.xy,2.0) );\n        //vec3 rd = dir;\n\n    \t//clear color\n         dist = distTosurf(ro, rd, MIN_DIST, MAX_DIST);\n    \n        vec3 col = vec3(0.0);\n        \n        const float eps = 0.001;\n        if(dist >= MAX_DIST) col = clearCol(rd, fragCoord);\n          else col = renderPBR(ro, rd);\n     \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n   \n    fragColor = vec4( tot, 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\nvoid mainImage( out vec4 O, vec2 u ){\n\n    vec2 r = iResolution.xy,\n         U, p = 0.5*( u - 0.5*r ) / r.y;\n    float z = iTime, l = length(p);\n\n    for( int i=0; i<3; i++ ) {\n        z +=.07;\n        U = u/r + p/l * ( sin(z)+0.9) * abs(sin(l*9.-z*2.));\n        O[i] = .01 / length( (U)-.5 );\n\t}\n\tO /= l;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//fork https://www.shadertoy.com/view/WdBXWV\n#define f(a) exp( -10.* pow( length( U -.52*cos(a+vec2(0,33)) ) , 2. ) )\n#define time iTime\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    \n    O =   ( .5-.5*cos(-time+min(6.*length(U),6.3)) ) \n        * (    .7* vec4(1,.25,0,0)\n            + ( f(.65- time*.1 )+f(1.6 + time*.5)+f(2.8 + time) ) * vec4(.8,.8,.5,0) );\n  O *= O;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Misty Lake. Created by Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MsB3WR\n//\n\n#define BUMPFACTOR 0.1\n#define EPSILON 0.1\n#define BUMPDISTANCE 60.\n\n#define time (iTime+285.)\n\n// Noise functions by inigo quilez \n\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy) + f.xy;\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nmat2 rot(const in float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n// intersection functions\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. && d < dist ) {\n\t\tdist = d;\n\t\treturn true;\n    } else {\n\t\treturn false;\n\t}\n}\n\n// light direction\n\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\n\nvec3 bgColor( const in vec3 rd ) {\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\treturn col;\n}\n\n// coulds functions by inigo quilez\n\n#define CLOUDSCALE (500./(64.*0.03))\n\nfloat cloudMap( const in vec3 p, const in float ani ) {\n\tvec3 r = p/CLOUDSCALE;\n\n\tfloat den = -1.8+cos(r.y*5.-4.3);\n\t\t\n\tfloat f;\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\n    f += 0.03125*noise( q );\n\t\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\n}\n\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\n    // dithering\t\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\n\t\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tfor( int i=0; i<64; i++ ) {\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat a = cloudMap( pos, ani );\n\n        // lighting\t\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\n\t\t// fog\t\t\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        // advance ray with LOD\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\n\t}\n\n    // blend with background\t\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\n\t\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\n// terrain functions\nfloat terrainMap( const in vec3 p ) {\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\n}\n\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\n\tfloat t = startdist;\n\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tbool hit = false;\n\tvec3 col = bgc;\n\t\n\tfor( int i=0; i<80; i++ ) {\n\t\tif( hit ) break;\n\t\t\n\t\tt += 8. + t/300.;\n\t\tvec3 pos = ro + t*rd;\n\t\t\n\t\tif( pos.y < terrainMap(pos) ) {\n\t\t\thit = true;\n\t\t}\t\t\n\t}\n\tif( hit ) {\n\t\t// binary search for hit\t\t\n\t\tfloat dt = 4.+t/400.;\n\t\tt -= dt;\n\t\t\n\t\tvec3 pos = ro + t*rd;\t\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\n\t\tfor( int j=0; j<2; j++ ) {\n\t\t\tpos = ro + t*rd;\n\t\t\tdt *= 0.5;\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\n\t\t}\n\t\tpos = ro + t*rd;\n\t\t\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\n\t\t\n\t\tvec3 normal = vec3( 0., 0., 0. );\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\n\t\tnormal.y = 1.;\n\t\tnormal = normalize( normal );\t\t\n\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \n\t\t\t\t   vec3(1.,.9,0.6);\n\t\t\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\n\t\t\t\t\t\n\t\tif( veg > 0.75 ) {\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\n\t\t} else \n\t\tif( veg > 0.66 ) {\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\n\t\t}\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\n\t\t\n\t\tvec3 brdf = col;\n\t\t\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\n\t\t\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\n\t\t\n\t\tdist = t;\n\t\tt -= pos.y*3.5;\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t}\n\treturn col;\n}\n\nfloat waterMap( vec2 pos ) {\n\tvec2 posm = pos * m2;\n\t\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    \n    \n\t// camera parameters\n\t//vec3 ro = vec3(0.0, 0.5, 0.0);\n\t//vec3 ta = vec3(0.0, 0.45,1.0);\n\t/*if (iMouse.z>=1.) {\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\n\t}\n\t\t\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );*/\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3( 1.0+3.5*cos(6.0*-mo.x), 1.0 + 2.0*mo.y, 0.0+3.5*sin(6.0*-mo.x) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n\t// build ray\n    //vec3 ww = normalize( ta - ro);\n    //**\n    vec3 ww = normalize( ca*ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\n\tbool reflected = false;\n\tvec3 normal, col = bgColor( rd );\n\tvec3 roo = ro, rdo = rd, bgc = col;\n\t\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\n\t\tro += refldist*rd;\t\n\t\tvec2 coord = ro.xz;\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\n\t\t\t\t\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\n\t\tnormal = normalize( normal );\t\t\n\t\t\n\t\tfloat ndotr = dot(normal,rd);\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\n\n\t\trd = reflect( rd, normal);\n\n\t\treflected = true;\n\t\tbgc = col = bgColor( rd );\n\t}\n\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\n\t\n\tif( reflected ) {\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\n\t\tcol *= fresnel*0.9;\t\t\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\n\t\tintersectPlane( ro, refr, -2., refldist );\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \n\t\t\t   * (1.-fresnel)*0.125;\n\t}\n\t\n\tcol = pow( col, vec3(0.7) );\n\t\n\t// contrast, saturation and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer D","description":"","type":"buffer"}]}