{"ver":"0.1","info":{"id":"fdB3RG","date":"1617543237","viewed":88,"name":"CG homework","username":"marcelldavid96","description":"Homework assignment for the CG course, ELTE 2021 spring semester.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Value sdf(vec3 p)\n{\n    // time, some shifting temp variables\n    float t = iTime * witch_circ_f, h = 0.0, r = 0.0;\n    \n    // sdf of the dancing witches\n    Value witches = def;\n    for (int i = 0; i < witch_num; i++)\n    {\n        float a = 2.0 * PI / float(witch_num) * float(i) + t;\n    \n        // starting on an XZ circle\n        vec3 start_pos = vec3(witch_circ_r * cos(a),\n                              0.0,\n                              witch_circ_r * sin(a));\n        \n        //////////\n        // head\n        Value left_eye, right_eye, eyes, head, hat;\n        r = 0.3;\n        \n        left_eye = sdf_sphere(p - vec3(-0.4, 0.3, -0.8) - start_pos, r, 2);\n        right_eye = sdf_sphere(p - vec3(0.4, 0.3, -0.8) - start_pos, r, 2);\n        eyes = union_objects(left_eye, right_eye);\n        \n        head = sdf_sphere(p - vec3(0.0, 0.3, 0.0) - start_pos, 1.0, 1);\n        head = difference_objects(head, eyes);\n        \n        hat = sdf_cone(p - vec3(0.0, 2.0, 0.0) - start_pos, vec2(1.0, 0.75), 1.2, 0);\n        head = union_objects(head, hat);\n\n        //////////\n        // hands\n        Value left_arm, left_hand, right_arm, right_hand, hands;\n        r = 0.5;\n        h = 0.6;\n        \n        left_arm = sdf_cylinder(rotate_z(PI / 2.0) * (p - vec3(-1.2, -1.4, 0.0) - start_pos), r, h, 0);\n        left_hand = sdf_sphere(p - vec3(-1.6, -1.4, -0.4) - start_pos, r, 1);\n        left_arm = difference_objects(left_arm, left_hand);\n        \n        right_arm = sdf_cylinder(rotate_z(PI / 2.0) * (p - vec3(1.2, -1.4, 0.0) - start_pos), r, h, 0);\n        right_hand = sdf_sphere(p - vec3(1.6, -1.4, -0.4) - start_pos, r, 1);\n        right_arm = difference_objects(right_arm, right_hand);\n                \n        hands = union_objects(left_arm, right_arm);\n\n        //////////\n        // legs\n        Value left_leg, left_toe, right_leg, right_toe, legs;\n        r = 0.5;\n        h = 1.0;\n        \n        left_leg = sdf_cylinder(rotate_z(-PI / 4.0) * (p - vec3(-0.7, -3.5, 0.0) - start_pos), r, h, 0);\n        left_toe = sdf_sphere(p - vec3(-1.3, -4.0, -0.4) - start_pos, r, 1);\n        left_leg = difference_objects(left_leg, left_toe);\n        \n        right_leg = sdf_cylinder(rotate_z(PI / 4.0) * (p - vec3(0.7, -3.5, 0.0) - start_pos), r, h, 0);\n        right_toe = sdf_sphere(p - vec3(1.3, -4.0, -0.4) - start_pos, r, 1);\n        right_leg = difference_objects(right_leg, right_toe);\n        \n        legs = union_objects(left_leg, right_leg);\n\n        //////////\n        // body\n        Value body = sdf_cylinder(p - vec3(0.0, -2.0, 0.0) - start_pos, 0.75, 1.5, 0);\n        body = union_objects(body, union_objects(hands, legs));\n\n        Value witch = union_objects(head, body);\n        witches = union_objects(witches, witch);\n    }\n    \n    // sdf of background\n    Value ground, sky = def, environment = def;\n    ground = sdf_plane(p, vec3(0.0, 1.0, 0.0), 5.5, 3);\n    environment = union_objects(ground, sky);\n    \n    // sdf of the entire scene\n    Value scene = union_objects(witches, environment);\n    \n    return scene;\n}\n\nValue trace_ray(Ray r)\n{\n    Value v;\n\tfloat t = 0.0, d = 0.0;\n   \n    for (int i = 0; i < max_iter; i++)\n    {\n       v = sdf(r.p0 + t * r.v);\n        d = v.v;\n    \tt += d;\n        if (d < e || t > max_t)\n        {\n            break;\n        }\n    }\n    return Value(t, v.i);\n}\n\nvec3 normal(const vec3 p)\n{\n    vec3 forward = vec3(\n        sdf(p + vec3(e, 0., 0.)).v,\n        sdf(p + vec3(0., e, 0.)).v,\n        sdf(p + vec3(0., 0., e)).v);\n        \n    vec3 backward = vec3(\n        sdf(p - vec3(e, 0., 0.)).v,\n        sdf(p - vec3(0., e, 0.)).v,\n        sdf(p - vec3(0. ,0. ,e)).v);\n    \n    vec3 g = (forward - backward) / (2. * e);\n    g = normalize(g);\n    return g;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 to_eye, Light source, int i)\n{\n    vec3 source_p = rotate_z(iTime * source_f) * source.start;\n    vec3 to_source = normalize(source_p - p);\n    vec3 reflected = reflect(-to_source, n);\n    \n    // diffuse\n    float d_coef = clamp(dot(to_source, n), 0.0, 1.0);\n    vec3 diffuse = source.diffuse * max(d_coef, 0.0);\n    \n    // specular\n    float s_coef = clamp(dot(reflected, to_eye), 0.0, 1.0);\n    vec3 specular = source.specular * pow(max(s_coef, 0.0), m[i].roughness) * max(d_coef, 0.0);\n\n    // ambient\n    // if it is ground, add some noise\n    vec3 ambient = m[i].ambient;\n    if (i == 3)\n    {\n        int seed = int(p.x) + int(p.z) * int(iResolution.x);\n        ambient = ambient * rand(seed);\n    }\n    \n    // shading\n    // move out the starting point from the object region into the direction of the light-normal\n    // so the ray can \"break out\" to the light source\n    Ray light_ray;\n    light_ray.p0 = p + 0.05 * (n + to_source); \n    light_ray.v = normalize(source_p - light_ray.p0);\n    \n    Value v = trace_ray(light_ray);\n    \n    // if the ray could not reach the light source, then it is in shadow\n    float light = 1.0;\n    if (v.v < distance(source_p, light_ray.p0))\n    {\n        light = 0.0;\n    }\n    vec3 final = ambient + (diffuse + specular) * light;\n    return final;\n}\n\nvec4 draw(Ray r, Value v)\n{\n    vec3 p = r.p0 + v.v * r.v;\n    vec3 n = normal(p);\n    vec3 to_eye = -r.v;\n\n    vec3 sun_col = shade(p, n, to_eye, sun, v.i);\n    vec3 moon_col = shade(p, n, to_eye, moon, v.i);\n    \n    vec3 final_col = sun_col * moon_col;\n    \n    return vec4(final_col, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// CAMERA & EVENT HANDLING\n\nbool is_key_held(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.0;\n}\n\nRay set_camera(vec2 frag_coord, out vec3 eye, out vec2 at)\n{\n    if (iMouse.xy == vec2(0.0))\n    {\n        at = vec2(0.0);\n    }\n\n    // ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw + eye_start; // camera position\n    at = texelFetch(iChannel0, ivec2(1,0), 0).zw; // looking at\n    vec2 uv\t= abs(at);\n    \n    // if the mouse is held or was held on the last frame\n    // iMouse.zw stores the xy-coords of the last click point\n    // iMouse.xy stores the xy-coords of the current position of the mouse (regardless of click)\n   \tif (iMouse.z > 0.0 || at.x >= 0.)\n    {\n        // += means inverted camera\n        uv -= (abs(iMouse.zw) - abs(iMouse.xy)) * m_speed;\n        // save the coordinates of mouse\n        if(iMouse.z >= 0.0)\n        {\n            at = abs(at.xy);\n        }\n        else\n        {\n            at = -mod(uv, 2.0 * PI);\n        }\n    }\n    \n    // calculate camera coordinate system from the spherical angles and up (0, 1, 0) direction\n    vec3 w = vec3(cos(uv.x) * cos(-uv.y),\n                  \t\t\t  sin(-uv.y),\n                  sin(uv.x) * cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n\tvec3 v = cross(w, u);\n    \n    // handle keyboard\n    if (is_key_held(k_left) || is_key_held(k_a))\n    {\n        eye -= u * k_speed;\n    }\n    if (is_key_held(k_right) || is_key_held(k_d))\n    {\n        eye += u * k_speed;\n    }\n    if (is_key_held(k_up) || is_key_held(k_w))\n    {\n        eye += w * k_speed;\n    }\n    if (is_key_held(k_down) || is_key_held(k_s))\n    {\n        eye -= w * k_speed;\n    }\n    if (is_key_held(k_sp))\n    {\n        eye = eye_start;\n    }\n    \n    // set the pixel we want to calculate\n    // transform to [0.0; 1.0], then to [-1.0, 1.0], and fit it to the aspect ratio finally\n    vec2 p = frag_coord;\n    p = p / iResolution.xy;\n    p = p * 2.0 - 1.0;\n    p = p * normalize(iResolution.xy);\n    \n    // ray generation starting from eye, looking at pixel coords multiplied by the coord system\n    return Ray(eye, normalize(p.x * u + p.y * v + w));\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage(out vec4 frag_col, vec2 frag_coord)\n{\n    // generate ray from pixel\n    vec3 eye; // where is the camera\n    vec2 at; // looking at point (defined by spherical angles)\n    Ray r = set_camera(frag_coord, eye, at);\n    \n    // trace ray and draw\n    frag_col = vec4(0.0);\n    Value v = trace_ray(r);\n    if (v.v > max_t)\n    {\n        frag_col = vec4(0.0);\n    }\n    else\n    {\n        frag_col = draw(r, v);\n    }\n    \n    // save camera eye & at position in the first two pixels\n    if (frag_coord.x == 0.5 && frag_coord.y == 0.5)\n    {\n        frag_col.yzw = eye - eye_start;\n    }    \n    if (frag_coord.x == 1.5 && frag_coord.y == 0.5)\n    {\n        frag_col.zw = at;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nUSEFUL LINKS\n\nWIKI\nbrdf - https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function\ncsg - https://en.wikipedia.org/wiki/Constructive_solid_geometry\nsdf - https://en.wikipedia.org/wiki/Signed_distance_function\n\nIQ\n*/\n\n\n// https://en.wikipedia.org/wiki/List_of_colors_by_shade\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// MATERIALS\n\nprecision lowp float;\n\n// STRUCTS\n\nstruct Material\n{\n    vec3 ambient;\n    float roughness;\n};\n\nMaterial m[4] = Material[4] (\n   Material(vec3(0.2, 0.0, 0.0), 5.0), // robes - https://www.colorhexa.com/290000\n   Material(vec3(0.8, 0.5, 0.4), 5.0), // skin - https://www.colorhexa.com/ffb79f\n   Material(vec3(0.4, 1.0, 0.2), 10.0), // eyes - https://www.colorhexa.com/6bff39\n   Material(vec3(0.3, 0.3, 0.3), 20.0) // ground -  https://www.colorhexa.com/9a9a9a   \n);\n\nstruct Light\n{\n    vec3 start;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Value\n{\n    float v;\n    int i;\n};\n\nstruct Ray\n{\n\tvec3 p0;\n\tvec3 v;\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// constant values\n\n// maths\nconst float PI = 3.1415926535;\n// const float E = 2.7182818284;\n// const float G = 0.5772156649;\n\n// raymarching\nconst Value def = Value(1000.0, 0);\nconst int max_iter = 50;\nconst float max_t = 100.0;\nconst float e = 0.001;\n\n// witches\nconst int witch_num = 6;\nconst float witch_circ_r = 6.0;\nconst float witch_circ_f = 0.16;\n\n// camera params\nconst vec3 eye_start = vec3(-10.0, 10.0, 10.0);\n\nconst int k_left  = 37;\nconst int k_right = 39;\nconst int k_up = 38;\nconst int k_down = 40;\n\nconst int k_a  = 65;\nconst int k_d = 68;\nconst int k_w = 87;\nconst int k_s = 83;\n\nconst int k_sp = 8;\n\nconst float k_speed = 0.3;\nconst float m_speed = 0.003;\n\n// lighting\nconst float sun_moon_h = 10.0;\nconst float source_f = 0.5;\n\nconst Light sun = Light(\n    vec3(0.0, sun_moon_h, 0.0),\n    vec3(1.0, 0.5, 0.0),\n    vec3(0.8, 0.8, 0.8)\n    );\nconst Light moon = Light(\n    vec3(0.0, -sun_moon_h, 0.0),\n    vec3(0.25, 0.25, 0.5),\n    vec3(0.3, 0.3, 1.0));\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// MATH STUFF\n\nmat3 rotate_x(float a)\n{\n    return mat3(1.0, 0.0   , 0.0    ,\n                0.0, cos(a), -sin(a),\n                0.0, sin(a), cos(a));\n}\nmat3 rotate_y(float a)\n{\n    return mat3(cos(a) , 0.0, sin(a) ,\n                0.0    , 1.0, 0.0    ,\n                -sin(a), 0.0, cos(a));\n}\nmat3 rotate_z(float a)\n{\n    return mat3(cos(a), -sin(a), 0.0,\n                sin(a), cos(a) , 0.0,\n                0.0   , 0.0    , 1.0);\n}\n\nValue sdf_sphere(vec3 p, float r, int i)\n{\n    return Value(length(p) - r,  i);\n}\n\nValue sdf_cone(vec3 p, vec2 c, float h, int i)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return Value(sqrt(d)*sign(s), i);\n}\n\n//Value sdf_cone(vec3 p, vec2 c, float h, int i)\n//{\n//  float q = length(p.xz);\n//  return Value(max(dot(c.xy, vec2(q, p.y)), -h - p.y), i);\n//}\n\nValue sdf_cylinder(vec3 p, float h, float r, int i)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return Value(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), i);\n}\n\nValue sdf_plane(vec3 p, vec3 n, float h, int i)\n{\n  n = normalize(n);\n  return Value(dot(p, n) + h, i);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// SET OPERATIONS\n\nValue union_objects(Value a, Value b)\n{\n    if (a.v < b.v)\n    {\n        return Value(a.v, a.i);\n    }\n    else\n    {\n        return Value(b.v, b.i);\n    }\n}\n\nValue intersect_objects(Value a, Value b)\n{\n    if (a.v > b.v)\n    {\n        return Value(a.v, a.i);\n    }\n    else\n    {\n        return Value(b.v, b.i);\n    }\n}\n\nValue difference_objects(Value a, Value b)\n{\n    if (a.v > -b.v)\n    {\n        return Value(a.v, a.i);\n    }\n    else\n    {\n        return Value(-b.v, b.i);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// RANDOM\n// https://www.shadertoy.com/view/tsf3Dn\nfloat rand(int seed) {\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    return abs(fract(float(seed) / 3141.592653));\n}\n\n","name":"Common","description":"","type":"common"}]}