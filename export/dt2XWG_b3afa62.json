{"ver":"0.1","info":{"id":"dt2XWG","date":"1676544974","viewed":55,"name":"katze","username":"blurryroots","description":"katze","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","masking","katze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any commercial\n// or non-commercial product, website or project. You cannot sell this Work,\n// mint an NFTs of it, or train machine learning models with it. I share this\n// Work for educational purposes, and you can link to it, through an URL,\n// proper attribution and unmodified screenshot, as part of your educational\n// material. If these conditions are too restrictive please contact me and\n// we'll definitely work it out. You are free however, to incorporate this work\n// within the Shadertoy ecosystem, e.g. by forking.\n\n#define R iResolution\n\nvoid mainImage (out vec4 C, in vec2 F) {\n\t// Mask of cat skin.\n\tvec3 mask_colors[4] = vec3[4] (\n\t\trgb3 (153, 153, 153),\n\t\trgb3 (255, 255, 255),\n\t\trgb3 (254, 153, 153),\n\t\trgb3 (000, 000, 000)\n\t);\n\tivec2 texture_size = ivec2 (256, 32);\n\n\t// .\n\tfloat frame_pixel_width = 40.;\n\tfloat frame_count = 6.;\n\tfloat frame_r = frame_pixel_width / float (texture_size.y);\n\tfloat aspect = R.x / R.y;\n\tfloat t = iTime;\n\tfloat frame_index = floor (mod (t * 9., frame_count));\n\tvec2 uv = F / R.xy;\n    vec2 uvn = (F - 0.5 * R.xy) / max (R.x, R.y);\n\n    // .\n    vec3 c = texture (iChannel2, uv).rgb;\n\n\t// .\n\tvec2 frame_uv = uv;\n\tframe_uv.x /= frame_count;\n\tframe_uv.x += (frame_index * frame_pixel_width) / float (texture_size.x);\n    \n\tvec2 cat_uv = pixel_uv (frame_uv, texture_size);\n\tvec4 cat_c = texture (iChannel0, cat_uv);\n\tfloat pixel_mask = 1.;    \n\tfor (int ci = 0; ci < mask_colors.length (); ++ci) {\n        pixel_mask *= mask_color (cat_c.rgb, mask_colors[ci], 0.01);\n\t}\n\tc = mix (c, cat_c.rgb, cat_c.a);\n\n\t// .\n\t#if 1\n\tfloat belly_tv_mask = mix (0., pixel_mask * cat_c.a, psin (iTime/2.));\n\tvec3 belly_tv_color = texture (iChannel1, uv).rgb;\n\tc = mix (c, belly_tv_color, belly_tv_mask);\n\t#endif\n\n\t// .\n\tC = vec4 (c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any commercial\n// or non-commercial product, website or project. You cannot sell this Work,\n// mint an NFTs of it, or train machine learning models with it. I share this\n// Work for educational purposes, and you can link to it, through an URL,\n// proper attribution and unmodified screenshot, as part of your educational\n// material. If these conditions are too restrictive please contact me and\n// we'll definitely work it out. You are free however, to incorporate this work\n// within the Shadertoy ecosystem, e.g. by forking.\n\nconst float pi = 355. / 113.;\n\nfloat psin (float t) {\n\treturn (1. + sin (pi * t - pi/2.)) / 2.;\n}\nfloat pcos (float t) {\n\treturn (1. + cos (pi * t)) / 2.;\n}\n\nvec3 rgb3 (int r, int g, int b) {\n\treturn vec3 (r, g, b) / 255.;\n}\n\n// Based on uv_iq and https://jorenjoestar.github.io/post/pixel_art_filtering\nvec2 pixel_uv (vec2 uv, ivec2 texture_size) {\n    vec2 pixel = uv * vec2 (texture_size);\n\n    vec2 seam = floor (pixel + 0.5);\n    vec2 dudv = fwidth (pixel);\n    pixel = seam + clamp ((pixel - seam) / dudv, -0.5, 0.5);\n    \n    return pixel / vec2 (texture_size);\n}\n\nfloat mask_color (vec3 color, vec3 mask_color, float threshold) {\n\treturn distance (mask_color, color) < threshold\n\t\t? 0.\n\t\t: 1.\n\t\t;\n}","name":"Common","description":"","type":"common"}]}