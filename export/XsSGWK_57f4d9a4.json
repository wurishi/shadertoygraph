{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nbool texture = false; // make this true to apply a checker board texture\n\nvec3 checkerBoard(vec2 uv, float nTile) {\n\tvec3 color1 = vec3(1.0, 1.0, 1.0);\n\tvec3 color2 = vec3(0.0, 0.0, 0.0);\n\tfloat side = 1.0/nTile;\n\tfloat c1 = mod(uv.x, 2.0 * side);\n\tc1 = step(side, c1);\n\tfloat c2 = mod(uv.y, 2.0 * side);\n\tc2 = step(side, c2);\t\n\tvec3 color = mix(color1, color2, mod(c1+c2,2.0));\n\treturn color;\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n\t// a sphere centered at the origin has equation x^2+y^2+z^2 = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 +2<ro,rd>t - r^2 = 0\n\t// a quadratic equation. so\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = 2.0*dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - 4.0*c;\n\tif (h<0.0) {\n\t\treturn -1.0;\n\t}\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\nvec3 nSphere(in vec3 pos, in vec4 sph) { // normal of the sphere at given position\n\treturn (pos - sph.xyz)/sph.w; // why divide to radius, instead of normalize?\n}\n\nfloat iEllipsoid(in vec3 ro, in vec3 rd, in vec3 center, in vec3 radii) {\n\t// ellipsoid needs a center point (3D) and 3 radii to be defined.\n\t// equation of ellipsoid at coordinate center: (x/rx)^2 + (y/ry)^2 + (z/rz)^2 == 1\n\t// where (rx, ry, rz) are the radii in different axes\n\tvec3 oc = ro - center;\n\tvec3 oc2 = oc*oc;\n\tvec3 ocrd = oc*rd;\n\tvec3 rd2 = rd*rd;\n\tvec3 invRad = 1.0/radii;\n\tvec3 invRad2 = invRad*invRad;\n\t\n\t// quadratic equation coefficients\n\tfloat a = dot(rd2, invRad2);\n\tfloat b = 2.0*dot(ocrd, invRad2);\n\tfloat c = dot(oc2, invRad2) - 1.0;\n\t\n\tfloat delta = b*b - 4.0*a*c;\n\tif (delta<0.0) {\n\t\treturn -1.0;\n\t}\t\n\tfloat t = (-b -sqrt(delta))/(2.0*a);\n\treturn t;\n}\nvec3 nEllipsoid(in vec3 pos, in vec3 center, in vec3 radii) { // normal vector of the ellipsoid at given position\n\t// gradient on ellipsoid equation: (2(x-cx)/rx^2, 2(y-cy)/ry^2, 2(z-cz)/rz^2)\n\t// evaluate this vector at pos\n\tvec3 radii2 = radii*radii;\n\tvec3 normal = (pos-center)/radii2;\n\treturn normalize( normal );\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd) {\n\t// equation of plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\nvec3 nPlane( in vec3 pos ) {\n\treturn vec3(0.0, 1.0, 0.0);\n}\n\n//vec4 sph1 = vec4(0.0, 1.0, 0.0, 1.0);\nfloat osc;\nvec3 eCenter;\nvec3 eRadii;\nvec3 eP = vec3(0.0, 1.0, 0.0); // pole vector\nvec3 eE = vec3(1.0, 0.0, 0.0); // euqator vector (used in texturing)\nvec3 light = normalize( vec3(0.57703) );\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT ){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\t//float tsph = iSphere(ro, rd, sph1); // intersect with a sphere\n\tfloat tell = iEllipsoid(ro, rd, eCenter, eRadii); // intersect with an ellipsoid\n\tfloat tpla = iPlane(ro, rd); // intersect with a plane\n\t/*if (tsph > 0.0 ){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}*/\n\tif (tell > 0.0 ){\n\t\tid = 1.0;\n\t\tresT = tell;\n\t}\t\n\tif( tpla > 0.0 && tpla < resT ) {\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\t\n\t//float t = min(tsph, tpla);\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    osc = sin(iTime*3.0)*sin(iTime*3.0);\n    eCenter = vec3(0.0, 0.5+osc, 0.0); // center of ellipsoid\n    eRadii = vec3(1.0+(1.0-osc)*0.5, 0.5+osc, 1.0+(1.0-osc)*0.5); // x, y, z radii of ellipsoid\n\n\t// uv are the pixel coordinates, from 0 to 1\n\t//vec2 uv = fragCoord.xy / iResolution.xy*vec2(1.78, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// move ellipsoid\n\teCenter.x = 0.5*cos(iTime);\n\teCenter.z = 0.5*sin(iTime);\n\t\n\t// we generate a ray with origin ro and direction rd\n\tvec3 ro = vec3(0.0, 0.5, 3.0);\n\t//vec3 rd = normalize(vec3(-1.0+2.0*uv, -1.0));\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv)*vec2(1.78, 1.0), -1.0)); // -1.0 can be the zoom value\n\t\n\t// intersect the ray with the objects in the 3D scene\n\tfloat t;\n\tfloat id = intersect(ro, rd, t);\n\t\n\t//vec3 col = vec3(0.68); // grey background\n\tvec3 col = vec3(0.4, 0.5, 0.6);\n\tif( id>0.5 && id<1.5) { // if we hit the ellipsoid\n\t\tvec3 pos = ro + t*rd;\n\t\t//vec3 nor = nSphere( pos, sph1 );\n\t\tvec3 nor = nEllipsoid( pos, eCenter, eRadii );\n\t\t//col = vec3( 0.3, 0.6, 0.7 ); // fixed color\n\t\t\n\t\tfloat amb = 0.05;\t\n\t\tfloat diffuse = clamp( dot(nor, light), 0.0, 1.0);\n\t\tfloat ao = 0.5 + 0.5*nor.y; // why normal? I guess, to make surfaces that look down darker.\n\t\t\t\t\t\t\t\t\t// 0.5 + 0.5* is to make lower parts darker and upper parts lighter\n\t\tcol = vec3( 0.9, 0.8, 0.6 )*diffuse*ao + vec3(0.1, 0.2, 0.4)*ao + vec3(amb);\n\t\t//col = vec3( 0.9, 0.8, 0.6 )*diffuse;\n\t\t//col = vec3( ao );\n\n\t\t// texturing\n\t\tif( texture == true ) {\n\t\t\tfloat theta = acos( dot(nor, eP) ); // theta of spherical coordinates\n\t\t\tfloat v = 1.0 - theta/PI; // [0,PI] -> [1.0, 0.0]\n\t\t\tfloat phi = acos(dot(nor, eE)/sin(theta));\n\t\t\tfloat u = phi/TWO_PI;\t\n\t\t\tcol = checkerBoard( vec2(u, v), 8.0)*(0.1+0.9*diffuse*ao) + vec3(amb);\n\t\t}\n\t}\n\telse if( id>1.5) {\n\t\t// we hit the plane\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = nPlane( pos );\n\t\tfloat dif = clamp( dot(nor, light), 0.0, 1.0);\n\t\t//float amb = 0.2;\n\t\tfloat amb = smoothstep(0.0, 1.0*eRadii.x, length(pos.xz - eCenter.xz) );\n\t\t//col = vec3(1.0, 0.8, 0.6)*dif + amb*vec3(0.5, 0.6, 0.7);\n\t\tcol = vec3(0.5, 0.6, 0.65)*amb*0.5;\n\t\t\n\t}\n\tcol = pow(col, vec3(0.5));\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSGWK","date":"1393230166","viewed":367,"name":"Study 8: Ellipsoid Raytracer","username":"vug","description":"My first raytracer ever. T_T I studied iq's wonderful \"writing a raytracer in 24 minutes\" live coding video at https://iquilezles.org/blog/?p=1521 and implemented an ellipsoid raytracer by looking at his sphere intersection/normal code.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""}}