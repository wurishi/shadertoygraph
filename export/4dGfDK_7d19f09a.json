{"ver":"0.1","info":{"id":"4dGfDK","date":"1530405330","viewed":552,"name":"Meta Matter","username":"leon","description":"One selected sketch from days of improvisation ","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// leon/ponk 01/07/2018\n// a lot of lines are from the community\n\nconst float steps = 100.;\nconst float far = 20.;\nconst float count = 8.;\n\nvec3 cameraPos = vec3(4);\nvec3 cameraTarget = vec3(0);\nconst float fov = 3.;\n\nvec3 lightPos = vec3(1, 1, 1);\nvec3 ambient = vec3(.5);\nvec3 light = vec3(.5);\nvec3 specular = vec3(0);\nfloat specularSharpness = 10.;\nvec3 glow = vec3(0);\nfloat glowSharpness = .5;\n\n#define PI 3.14159\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define sdist(p,r) (length(p)-r)\n#define saturate(p) clamp(p,0.,1.)\nmat2 rot (float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\nfloat smin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nvec3 look (vec3 eye, vec3 target, vec2 uv) {\n\tvec3 forward = normalize(target-eye);\n\tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n\tvec3 up = normalize(cross(right, forward));\n\treturn normalize(forward * fov + right * uv.x + up * uv.y);\n}\n\nfloat sdf (vec3 p) {\n\tfloat scene = 10.;\n    float shape = 10.;\n\tfloat breath = sin(iTime - length(p)*4. + atan(p.y, p.z));\n\tfloat thin = .05;\n\tfloat range = .4 + .1 * breath;\n\tfloat height = .5 - .5 * breath;\n\tfloat smoo = .2 + .1 * breath;\n\tfor (float i = count; i > 0.; --i) {\n\t\tfloat r = i / count;\n\t\tr *= r;\n\t\tp.xz = abs(p.xz) - range * r;\n\t\tp.xz *= rot(+.5);\n\t\tp.yz *= rot(-.5);\n\t\tp.yx *= rot(+r*breath*.1+2.);\n\t\tshape = sdist(p.yz, thin*r);\n\t\tshape = max(abs(p.x)-height*r, shape);\n\t\tscene = smin(scene, shape, smoo * r);\n\t}\n\treturn scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(vec3(sdf(p+e.xyy)-sdf(p-e.xyy),\n                          sdf(p+e.yxy)-sdf(p-e.yxy),\n                          sdf(p+e.yyx)-sdf(p-e.yyx)));\n}\n\nvec3 raymarching (vec3 eye, vec3 ray)\n{\n    vec4 hit = vec4(0);\n\tfloat total = .001;\n\tfor (float i = steps; i >= 0.; --i) {\n\t\tfloat dist = sdf(eye + ray * total);\n\t\tif (dist < .001 * total || total > far) {\n\t\t\thit.xyz = eye + ray * total;\n\t\t\thit.w = i/steps;\n\t\t\tbreak;\n\t\t}\n\t\tdist *= .5;\n\t\ttotal += dist;\n\t}\n\n\tvec3 pos = hit.xyz;\n\tvec3 normal = getNormal(pos);\n\tvec3 view = normalize(cameraPos-pos);\n\tvec3 lightDir = normalize(lightPos);\n\tfloat lightIntensity = clamp(dot(lightDir, normal),0.,1.);\n\tfloat specularIntensity = saturate(pow(max(0., dot(reflect(-lightDir, normal), view)), specularSharpness));\n\tfloat glowIntensity = pow(abs(1.-abs(dot(normal, view))), glowSharpness);\n\n\tvec3 color = ambient + light * lightIntensity + specular * specularIntensity + glow * glowIntensity;\n\tcolor *= hit.w;\n\tcolor *= step(length(cameraPos-pos), far);\n\n\treturn saturate(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    cameraPos.yz *= rot((mouse.y*2.-1.)*step(.1, iMouse.z));\n    cameraPos.xz *= rot((mouse.x*2.-1.)*step(.1, iMouse.z));\n\tvec3 ray = look(cameraPos, cameraTarget, uv);\n    fragColor = vec4(raymarching(cameraPos, ray), 1);\n}","name":"Image","description":"","type":"image"}]}