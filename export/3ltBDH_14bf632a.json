{"ver":"0.1","info":{"id":"3ltBDH","date":"1612780238","viewed":329,"name":"Random1 [HurleybirdJr]","username":"HurleybirdJr","description":"Yep.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [[[SETTINGS]]] //\nfloat brightness = 20.; // Brightness is inverted\nfloat lfl = .75; // [L]ine [f]lash [l]ength requirement\n\n// Smoothstep function rename\n#define S(a, b, t) smoothstep(a, b, t)\n\n// Line Function\nfloat DistLine (vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba * t);\n}\n\n//p = Point\n\n// 2 :> 1\nfloat N21(vec2 p) {\n    p = fract(p*vec2(214.65, 918.36)); // Multiply by larger number\n    p += dot(p, p+23.45); // Dot and add random number\n    return fract(p.x*p.y); // Return coords of point\n}\n\n// 2 :> 2\nvec2 N22(vec2 p) {\n    float n = N21(p); // take X value\n    return vec2(n, N21(p+n)); // Add X to rand X\n}\n\n// Noise for points\nvec2 GetPos(vec2 id, vec2 offset) {\n    vec2 n = N22(id+offset)*iTime; // Make [n]oise from id as seed\n    \n    float rotateAmount = 0.4; // Controls point rotation radius\n\n    return offset+sin(n)*rotateAmount;\n}\n\n// Create line\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b); // Calculate line between points\n    float m = S(.03, .01, d); // Create line variable using smoothstep\n    float d2 = length(a-b); // Line Length\n    // Distance rules [Min distance], [Max distance], [Line length]\n    m *= S(1.2, .8, d2)*.5+S(.05, .03, abs(d2-lfl)); //Second S flashes on certain length\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n\n    // guv = [G]rid [UV]\n    vec2 guv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    //float d = length(guv-p); // Find [d]istance to point\n    //m = S(.1, .05, d);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for(float y = -1.; y <= 1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x, y)); // Create random [p]oint with offset\n        }\n    }\n    \n    float tr = iTime*5.; // Changes [t]winkle [r]ate\n    \n    for(int i=0; i<9; i++) { \n        m += Line(guv, p[4], p[i]);\n        \n        vec2 j = (p[i]-guv)*brightness;\n        float sparkle = 1./dot(j, j);\n        \n        m += sparkle*(sin(tr+fract(p[i].x)*10.)*.5+.5);\n    }\n    \n    // Fix gaps on diagonal lines\n    m += Line(guv, p[1], p[3]);\n    m += Line(guv, p[1], p[5]);\n    m += Line(guv, p[7], p[3]);\n    m += Line(guv, p[7], p[5]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalised pixels to 0 <> 1 and Aspect Ratio\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5; // Get mouse coords and align to center\n\n    //float d = DistLine(uv, vec2(0), vec2(1)); [REDACTED]\n    \n    float gs = 5.; // [G]rid [s]ize value\n    \n    float gradient = uv.y;\n    \n    float m = 0.;\n\n    float lc = 4.; // 3D [l]ayer [c]ount\n    float lw = .5; // 3D [l]ayer [w]idth\n    float ld = 10.; // 3D [l]ayer [d]ensity\n    float ls = .1; // 3D [l]ayer [s]peed\n    float lr = 20.; // 3D [l]ayer [r]andomness\n    \n    float t = iTime*ls; // Time Variable\n\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c); // Create rotate matrix\n    \n    uv *= rot; // Alter uv with rotate\n    mouse *= rot; // Alter mouse coords\n\n    for(float i=0.; i<1.; i += 1./lc) {\n        float z = fract(i+t);\n        float size = mix(ld, lw, z);\n        // S(lStartFade, lEndFade, depth)\n        float fade = S(0., .5, z)*S(1., .8, z); // Fade in * Fade out\n        m += Layer(uv*size+i*lr-mouse)*fade;\n    }\n    \n    float cs = 10.; // Controls [c]olour [s]peed\n\n    vec3 base = sin(t*cs*vec3(.345, .456, .567))* .4 + .6; // Create base colour\n    vec3 col = m*base;\n\n    // Music React [iChannel0] //\n    //float fft = texelFetch(iChannel0, ivec2(.7,0), 0).x;\n    //gradient *= fft*2.;\n    \n    col -= gradient*base;\n\n    //col.rg = guv;\n    \n    // [[[DEBUG]]] //\n    // [ID Check] //\n    //float idScale = 0.2;\n    //col.rg = id*idScale;\n    \n    // [Grid Check] //\n    //float gridOS = 0.5; // Initialise gridOS\n    //gridOS -= 0.01; // [Grid] [O]utline [S]ize\n    \n    //if(guv.x>gridOS||guv.y>gridOS) col = vec3(1,0,0); // Create Grid\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}