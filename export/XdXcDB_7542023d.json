{"ver":"0.1","info":{"id":"XdXcDB","date":"1489591443","viewed":115,"name":"star SIRIUS","username":"zproxy","description":"via https://www.shadertoy.com/view/lsfyzf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define EPS 0.001\n#define FAR 50.0 \n#define PI 3.1415\n#define IGT iTime\n\nfloat rand1(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat audio_freq(in sampler2D channel, in float f) {return texture(channel, vec2(f, 0.25)).x;}\nvec3 sound = vec3(0.0);\n\nstruct DistInfo {\n    float d;\n    vec3 lc;\n};\n    \nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n//http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a,angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\n//modified version of IQs box distance function \n//bc: box center; w: box width\nfloat sdSpikeBox(vec3 rp, vec3 bc, float w) {\n    vec3 b = vec3(w) + length(rp - bc) * 0.5;\n    vec3 d = abs(rp - bc) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));;\n}\n\nfloat dfScene(vec3 rp) {\n    \n    // up to down\n    rp.yz *= rot(IGT * 0.0125);\n    //pModPolar(rp.yz, 5.0);\n    \n    // left to right\n    rp.xy *= rot(IGT * 0.0125);\n    //pModPolar(rp.yx, 16.);\n    return sdSpikeBox(rp,  \n                      \n                      vec3(\n                          0.0, \n                          0.2 , \n                          0.0), \n                      \n                      0.0000);\n}\n\n// Used for Fade effect\nfloat mapTo(float x, float minX, float maxX, float minY, float maxY) {\n    float a = (maxY - minY) / (maxX - minX);\n    float b = minY - a * minX;\n    return a * x + b;\n}\n\n//Shane - hue rotation. I think I'vereturn sdSpikeBox(rp,  vec3(0.0, 1.5 + smoothstep(0., 1., sound.w), 0.0), w); used this in pretty much all of my shaders so far :)\nvec3 rotHue(vec3 p, float a){\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat raytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n\treturn dot(o - ro, n) / dot(rd, n);\n}\n\n\n\n\n\nDistInfo marchScene(vec3 ro, vec3 rd) {\n    \n    DistInfo di = DistInfo(0., vec3(0.));\n    vec3 rp = vec3(0.0); //ray position\n    \n    for (int i = 0; i < 65; i++) {\n        rp = ro + rd * di.d;\n        float ns = dfScene(rp);\n        di.d += ns;\n        if (ns < EPS || di.d > FAR) break;\n        vec3 col = abs(rp);\n        di.lc += 0.0001 / (ns * ns) * col; //distance field light contribution\n    }\n    return di;\n}\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.); //pixel colour\n\n    for (int i = 0; i < 10; i++) {\n        if (i < 3) {\n            sound.x += audio_freq(iChannel0, float(i));    \n        } else if (i < 7) {\n            sound.y += audio_freq(iChannel0, float(i));    \n        } else {\n            sound.z += audio_freq(iChannel0, float(i));    \n        }\n    }\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    \n    \n    \n    \n    \n    \n    float mousex = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    \n    float mousey = (2.0*iMouse.y-iResolution.y) / iResolution.y;\n   \n    \n    \n    \n       \n    if (abs(mousey) < 1.0)\n    \trd *=  rotationMatrix(vec3(1., 0., 0.), radians(16. * mousey));\n    \n    // allow limited interacton\n    rd *=  rotationMatrix(vec3(0., 1., 0.), radians(0. + 2. * 16. * -mousex));\n\n    \n    // looks good for 2D viewport\n    rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n    //rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n \n    //rd *=  rotationMatrix(vec3(0., 1., 0.), radians(-270. * -mousex));\n    \n    \n    \n    \n    //vec3 ro = vec3(0.0, 1.0, -0.5);\n    \n    // now its small .\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n\n    // start top right, and have it all slowly rotate\n    vec3 ro = vec3(-0.0, -0.0, -2.0);\n    // neg x looses color?\n\n    \n    //rotate camera\n    //ro.xy *= rot(sin(IGT) * 0.25);\n    //rd.xy *= rot(sin(IGT) * 0.25); \n    //ro.xz *= rot(IGT);\n    //rd.xz *= rot(IGT);    \n    //ro.yz *= rot(sin(IGT) * 0.125);\n    //rd.yz *= rot(sin(IGT) * 0.125); \n\t//\n    //raytace floor \n    vec3 fn = vec3(0, 1, 0); //floor normal\n\t//float fd = raytraceFloor(ro, rd, fn, vec3(0, -10.0, 0)); //floor distance\n\n    DistInfo di = marchScene(ro, rd);\n    \n    \n       \n    pc += startrails( rd);\n    \n    // 20fps / \n   \n    //if (false)\n    //if (fd > 0.0 && fd < FAR) {\n    //    //disco floor\n    //    vec3 rp = ro + rd * fd; //ray surface intersection\n    //    rp.x += IGT * 0.; //moving checkerboard\n    //    vec2 m  = mod(rp.xz, 4.0) - 2.0;\n    //    vec3 sc = \n    //        m.x * m.y > 0. ? rotHue(vec3(1., 0., 0.), mod(IGT / 16., 6.283)) : vec3(0., 0., 0.);      \n    //    sc *= clamp(pow(sound.z, 2.) * 2., 0.3, 3.0);\n    //    pc += sc / length((m * m) - 1.); \n    //    //fade\n    //\tfloat z = mapTo(fd, 0.0, FAR, 1.0, 0.0);\n    //    //pc = mix(vec3(0.), pc, z * z);\n    //}\n   //\n    //sparkly thing\n    \n    //pc += di.lc;\n    //pc += rotHue(di.lc, mod(IGT / 0.01, 6.283));\n    pc += rotHue(di.lc, mod(IGT / 0.001, 6.283));\n    \n   // //pixel effect from Virgil\n   // float klang1 = sound.z;\n   // vec2 uv2 = -0.3 + 2.0 * fragCoord.xy / iResolution.xy;\n   // pc -= 0.020 * (1.0 -klang1) * rand1(uv2.xy * IGT);\t\t\t\t\t\n   // vec2 g =  .9 + .2 * (1.-klang1) * sin(10.* IGT + uv2 * iResolution.xy);\n   // pc *= g.x * g.y; \n   // \n    fragColor = vec4(pc, 1.0);\n}","name":"Image","description":"","type":"image"}]}