{"ver":"0.1","info":{"id":"3syGWc","date":"1571760774","viewed":502,"name":"Flight Over Dunes","username":"Delvar","description":"Just a pretty flight over some sand dunes, Flight Over Dunes","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","terrain","raymarch","sun","clouds","fog","mountains","flare","lensflare","dust","sand","flightoverdunes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Flight Over Dunes'\n//  https://www.shadertoy.com/view/3syGWc\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tCredits: \n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tParts of the lensFlare were copied or inspired from\n//\t\tmu6k : 'musk's lens flare' : https://www.shadertoy.com/view/4sX3Rs\n//\t\tnimitz : 'Cloud Ten' : https://www.shadertoy.com/view/XtS3DD\n//\n//\tClouds were copied and modified from\n//\t\tDave_Hoskins : 'Frozen wasteland' : https://www.shadertoy.com/view/Xls3D2\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 150\n#define RAY_MAX_DISTANCE 200.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.01\n#define RAY_MAX_STEPS_SHADOW RAY_MAX_STEPS\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.04\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET (OBJECT_MIN_SURFACE_DISTANCE_SHADOW*1.1)\n\n#define PI\t3.1415926535897932384626433832795\n\n//Flags for debugging\n#define DEBUG_RAY_DITHER\n#define DEBUG_GRAIN_VIGNETTE\n#define DEBUG_DYNAMIC_EXPOSURE\n//#define DEBUG_OCCLUSION\n#define DEBUG_SAND_RIPPLES\n#define DEBUG_SAND_SHADING\n#define DEBUG_SAND_3POINT_NORMAL\n#define DEBUG_CAMERA_FLY\n#define DEBUG_SPECULAR\n#define DEBUG_SUN_RAYS_RENDER\n#define DEBUG_FOG_RENDER\n#define DEBUG_DUST_RENDER\n#define DEBUG_SAND_RENDER\n#define DEBUG_CLOUD_RENDER\n#define DEBUG_MOUNTAIN_RENDER\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel1\n//#define NOISE_TEXTURE_2D iChannel0\n\n// -- The Materials\n#define MAT_SKY 0\n#define MAT_GROUND 1\n#define MAT_SPHERE_1 2\n#define MAT_SPHERE_2 3\n\n// -- The Lights\n#define LIGHT_SUN 0\n#define LIGHT_SKY 1\n//#define LIGHT_GROUND 2\n\n// -- colours\n#define SAND_COLOUR vec3(0.98,0.82,0.68)\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n\tvec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance, dust;\n    int materialId;\n    int iteration;\n};\n\nstruct sphere {\n    vec3 origin;\n    float radius;\n};\n\nstruct light {\n    vec3 origin, colour;\n    float brightness;\n    float maxDistance;\n};\n\n// ========== ==========\n\n// ========== Globals ==========\n\nvec3 sunDir = normalize(vec3(5.0, 4.0, 5.0));\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HE 702.566665305\n#define HF 149.311292882\n#define HG 446.230257362\n#define HH 833.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st)*HE); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(sin(st.xy),vec2(HE,HF)))*HG);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(sin(st),vec3(HE,HF,HG)))*HH);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HH);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HG))*HH);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HH);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n//Quintic interpolation curve\nvec2 quinticInterpolation(vec2 x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat quinticInterpolation(float x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    float bl = hash21(pointI + vec2(0.0,0.0) );\n    float br = hash21(pointI + vec2(1.0,0.0) );\n    float fl = hash21(pointI + vec2(0.0,1.0) );\n    float fr = hash21(pointI + vec2(1.0,1.0) );\n    //vec2 u = smoothstep(0.0,1.0,pointF);\n    vec2 u = quinticInterpolation(pointF);\n    float b = mix(bl,br,u.x);\n    float f = mix(fl,fr,u.x);\n\n    return mix(b,f,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(pointI);\n    float f = hash11(pointI + 1.0 );\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(mod(pointI, wrap));\n    float f = hash11(mod(pointI + 1.0 ,wrap));\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n\nvec3 ClosestRayPoint(ray ray, vec3 point) {\n    return ray.origin + max(0.0,dot(point - ray.origin, ray.direction)) * ray.direction;\n}\n\nfloat DistanceRayPoint(ray ray, vec3 point) {\n    return (distance(point,ClosestRayPoint(ray, point) )) ;   \n}\n\nfloat DistancePointSphere(sphere sphere, vec3 point) {\n    float sphereDistance = distance(point, sphere.origin) - sphere.radius;\n    return sphereDistance; \n}\n\n// ========== ==========\n\n// ========== Clouds ==========\n\nfloat getCloudNoise(vec2 origin, float time) {\n    origin.x-= time*0.1;\n    origin.y-= time*0.5;\n\n    float r = valueNoise2du(origin*0.3);\n    r+= valueNoise2du(origin*1.3)*0.66;\n    r+= valueNoise2du(origin*2.3)*0.33;\n    r*= valueNoise2du(origin*0.2);\n    r*=0.5;\n    return clamp(r,0.0,1.0);\n}\n\nfloat getClouds(vec3 direction, float time) {\n    //Dont draw clouds very low on the horizon or ground.\n    if (direction.y<=0.04) {\n        return 0.0;\n    }\n\n    vec2 s = direction.xz;\n    s *= (1000.0)/direction.y;\n    s *= 0.001;\n    //slowly fade out the clouds at distance, to get rid of aliasing issues.\n    return getCloudNoise(s,time)*(clamp(0.0,0.1,(direction.y-0.04))*10.0);\n}\n\n// ========== ==========\n\n// ========== Terrain ==========\n\nfloat getTerrainHeight(vec2 point) {\n    const int octaves = 3;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float amplitude = 1.5;\n    float frequency = 0.2;\n\n    float height = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        height += amplitude * (sin(frequency*point.x*0.5)*cos(frequency*point.y+point.x)*0.5+0.5);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    //Add surface ripples in the dips, moved to shading to reduce overhead, adds errors at small scale but its not notisable\n    //height += ((sin(30.0*point.x)*sin(1.5*point.y+10.0*point.x)*0.5+0.5)*0.05)*(smoothstep(0.3,2.0,1.7-height));\n    return height;\n}\n\nvec3 getTerrainNormal(vec2 point, float hc) {\n\n    #if defined(DEBUG_SAND_3POINT_NORMAL)\n    float hl = getTerrainHeight(point + vec2(-0.01,0.0));\n    float hf = getTerrainHeight(point + vec2(0.0,-0.01));\n    return normalize(vec3(\n        hl - hc,\n        0.01,\n        hf - hc\n    ));\n    #else\n    float hl = getTerrainHeight(point + vec2(-0.01,0.0));\n    float hr = getTerrainHeight(point + vec2(0.01,0.00));\n    float hf = getTerrainHeight(point + vec2(0.0,-0.01));\n    float hb = getTerrainHeight(point + vec2(0.0,0.01));\n    return normalize(vec3(\n        hl - hr,\n        0.02,\n        hf - hb\n    ));\n    #endif    \n\n}\n\nvoid getTerrainHit(vec3 currentPoint, inout rayMarchHit hit, float minSurfaceDistance) {\n    float heightCenter = getTerrainHeight(currentPoint.xz);\n\n    float newDistance = (currentPoint.y - heightCenter);\n\n    if (newDistance < hit.distance) {\n        hit.distance = newDistance;        \n        //if (newDistance <= minSurfaceDistance) {\n        hit.origin = currentPoint;\n        hit.surfaceNormal = getTerrainNormal(currentPoint.xz, heightCenter);\n        hit.materialId = MAT_GROUND;\n        //}\n    }\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 currentPoint, float minSurfaceDistance, float time) {\n    rayMarchHit hit;\n    hit.distance = RAY_MAX_DISTANCE;\n    #if defined(DEBUG_SAND_RENDER)\n    getTerrainHit(currentPoint, hit, minSurfaceDistance);\n    #endif\n    return hit;\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    float currentDistance = 0.0;\n    rayMarchHit hit;\n    float accumulatedDust = 0.0;\n    float lastDistance = 0.0;\n    float maxDustDistance = maxDistance/2.0;\n    float dustMaxHeight = 4.0;\n\n    for(int i=0; i<maxSteps; i++) {\n\n        vec3 currentPoint = ray.origin + ray.direction*currentDistance;\n        hit = GetRayMarchHit(currentPoint, minSurfaceDistance, time);\n\n        #if defined (DEBUG_DUST_RENDER)\n        float tHeight = getTerrainHeight(currentPoint.xz);\n        float dHeight = tHeight+dustMaxHeight;\n\n        if (currentDistance <= maxDustDistance && currentPoint.y < dustMaxHeight) {\n            float remapedY =  map(currentPoint.y, tHeight, dHeight, 0.0, 2.0*PI);\n            //we add the remapped y value ot the time for the lookup so the sand closer to the ground runs slower, not sure its that notisable.\n            float dust = lastDistance * (getCloudNoise(currentPoint.xz*3.0, time*(20.0-(remapedY*0.002))));\n            //we remap the ray height into the 0.0 to 2PI range, then pass it though sin to get a nice smooth falloff\n            dust *= sin(remapedY)*0.5+0.5;\t\t\t\n            dust *= 1.0-currentDistance/maxDustDistance;\n            accumulatedDust+= dust;\n        }\n        #endif\n\n        //had to add this to remove some of the dust artifacts., we jsut check if the ray is going into the dust and limit the distance\n        if (hit.distance > 1.0)\n        {\n            #if defined (DEBUG_DUST_RENDER)\n            if (currentPoint.y + (ray.direction.y * hit.distance) <= dHeight)\n            {\n                #endif\n                hit.distance = min(hit.distance,max((hit.distance*(currentDistance/maxDustDistance)),1.0));\n                #if defined (DEBUG_DUST_RENDER)\n            }\n            #endif\n        }\n        hit.iteration = i;\n        \n        #if defined (DEBUG_RAY_DITHER)\n\t        if(hit.distance > 0.0) {\n    \t        hit.distance *= mix(0.9,1.0, hash31(fract(currentPoint+time)));\n        \t}\n        #endif\n        \n        lastDistance = hit.distance;\n        currentDistance += hit.distance;\n\n        if(currentDistance >= maxDistance || (currentPoint.y > 5.0 && ray.direction.y > 0.0) || (currentPoint.y < 0.0 && ray.direction.y < 0.0)) {\n            hit.surfaceNormal = ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        } \n        //terminate if we are very close or bounce back out if we end up within an object. \n        else if(hit.distance >= 0.0 && hit.distance <= minSurfaceDistance) {\n            break;\n        }\n    }\n    hit.distance = currentDistance;\n\t//This should match the calculation in the getLight function to ensure they line up.\n    hit.dust = clamp(0.2 * accumulatedDust * ((cos(time*0.5) + cos(time*0.3))*0.25+0.5),0.0,1.0);\n    return hit;\n}\n\n// ========== ==========\n\n// ========== Lighting ==========\n\nfloat getShadow(vec3 origin, vec3 destination, float soft, float time) {\n    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;\n    float maxDistance = distance(destination, origin);\n    vec3 direction = normalize(destination-origin);\n    rayMarchHit rayMarchHit;\n    float light = 1.0;\n\n    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {\n        vec3 currentPoint = origin + direction*currentDistance;\n        rayMarchHit = GetRayMarchHit(currentPoint, 99999.0, time);\n        //Soft Shadows!\n        light = min(light,soft * rayMarchHit.distance/currentDistance);\n        currentDistance += rayMarchHit.distance;\n        if(currentDistance > maxDistance) {\n            break;\n        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {\n            light = 0.0;\n            break;\n        }\n    }\n\n    return light;\n}\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 0.7;\n    rayMarchHit hit;\n\n    for( int i=0; i<6; i++ )\n    {\n        float distance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW + 0.025*float(i);\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, OBJECT_MIN_SURFACE_DISTANCE_SHADOW, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nvoid getLight(vec3 point, vec3 normal, vec3 rayDirection, out vec3 diffuseLight, out vec3 specularLight, float time) {\n\n    //FIXME: could bake the light brightness into the colour\n    //FIXME: get material shinynes for power\n\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    vec3 direction;\n    vec3 colour;\n    float brightness;\n    float shadow;\n    vec3 specDirection;\n    float dotProduct;\n    float maxDustDistance = RAY_MAX_DISTANCE/6.0;\n\n    #if defined (DEBUG_DUST_RENDER)\n    float dust = (getCloudNoise(point.xz*3.0, time*20.0))*0.25;\n    //This should match the calculation in the RayMarch function to ensure they line up.\n    dust = 1.0-clamp(1.2*dust * ((cos(time*0.5) + cos(time*0.3))*0.25+0.5),0.0,1.0);\n    #endif\n\n    #if defined(LIGHT_SUN)\n    colour=vec3(0.8,0.6,0.4);\n    direction = sunDir;\n    brightness = clamp(dot(direction,normal),0.0,1.0);\n    shadow = getShadow(point +  normal*OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET, point+direction*RAY_MAX_DISTANCE*0.5, 10.0, time);\n    #if defined (DEBUG_CLOUD_RENDER)\n    float cloudCover = (1.0-getCloudNoise(point.xz*0.2, time));\n    brightness *= cloudCover;\n    #endif\n    #if defined (DEBUG_DUST_RENDER)\n    brightness *= dust;\n    #endif\n    brightness *= shadow;\n\n    #if defined(DEBUG_SPECULAR)\n    \n    float spec = hash21(floor(point.xz*100.0)/100.0);\n    \n    if(spec > 0.98) {\n        spec = (spec-0.98) * 50.0;\n        specDirection = reflect(direction, normal);\n        dotProduct = dot(specDirection, rayDirection);\n        specularLight += colour * 5.0 * spec * pow(max(dotProduct,0.0), 5.0) * shadow;\n    }\n        #endif\n        diffuseLight += colour * 5.0 * brightness;\n    #endif\n\n    #if defined(LIGHT_SKY)\n    colour=vec3(0.4, 0.85, 1.0);\n    direction = normalize(vec3(0.0, 1.0, 0.0));\n    brightness = clamp(dot(direction,normal),0.0,1.0);\n    #if defined (DEBUG_DUST_RENDER)\n    \tbrightness *= dust;\n    #endif\n    \n        #if defined(DEBUG_SPECULAR)\n        spec = hash21(floor(point.xz*150.0)/150.0);\n\n        if(spec > 0.99) {\n            spec = (spec-0.99) * 100.0;\n            specDirection = normalize(reflect(direction, normal));\n            dotProduct = dot(specDirection, rayDirection);\n            specularLight += colour * 2.0 * pow(max(dotProduct,0.0), 5.0);\n        }\n        #endif\n    \n    diffuseLight += colour * 2.0 * brightness;\n    #endif\n\n    //#if defined(LIGHT_GROUND)\n    //colour=SAND_COLOUR;\n    //direction = normalize(vec3(0.0, -1.0, 0.0));\n    //brightness = clamp(dot(direction,normal),0.0,1.0);\n    //#if defined(DEBUG_SPECULAR)\n    //specDirection = normalize(reflect(direction, normal));\n    //dotProduct = dot(specDirection, rayDirection);\n    //specularLight += pow(max(dotProduct,0.0), 2.0) * colour;\n    //#endif\n    //diffuseLight += colour * 1.0 * brightness;\n    //#endif\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    //Force a loop in time .. large values of time cuase judder\n    //FIXME: need to figure out a way to make the loop smooth, remove the glitch jump.\n    //time=mod(time,300.0);\n\n    vec3 r;\n    //r.y = 6.0;\n    //r.x=sin(time/10.0)*40.0;\n    //r.z=cos(time/10.0)*40.0;\n    r.y = (sin(time/2.0)*0.5+0.5) + (sin(time/6.0)+1.0) + (sin(time/15.0)+1.0) + 3.0;\n    r.x = ( sin(time/10.0) * 40.0 ) + sin(time/6.0) * 5.0 + sin(time/2.0) * 3.0;\n   r.z = ( cos(time/10.0) * 40.0 ) + sin(time/5.0) * 9.0 + sin(time/3.0) * 2.0;\n    return r;\n\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n\t\tvec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n        \n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0)*5.0;\n        roll = clamp(roll,-0.5,0.5);\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(0.0,5.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Screen Space Effects ==========\n\nvec3 getLensFlare(vec2 uv, vec2 sunUv)\n{\n    // Render the 'godray'?\n    vec2 delta = uv-sunUv;\n    float distance = clamp(dot(delta,delta),0.0,1.0);\n    float angle = atan(delta.x,delta.y);\n    float ray =sin(valueNoise1du(sin(angle*3.0+sunUv.x*2.0)*7.0-cos(angle*5.0+sunUv.y*2.0)))*0.2;\n    ray*=1.0-distance;\n    ray+=pow(1.0-distance,10.0);\n\n    //Render the 'circles'\n\n    //further away from the center the bigger they gets\n    vec2 uvSpread =  uv * length(uv) ;\n    //Offset the RGB to fake Chromatic Aberration\n    vec3 circles = vec3(0.0);\n    if (sunUv.x > -1.5 && sunUv.y > -1.0 && sunUv.x < 1.5 && sunUv.y < 1.0) {\n        for (float i=0.0;i<5.0;i++) {\n            vec2 circlePosition = sunUv * (0.5 - 0.4*i);\n            float size = 40.0/(i+1.0);\n            float blur = 2.0*(5.0-i);\n            circles += vec3(\tmax(\t0.0,\t1.0-pow(length(\t\t\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.05*\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.1*\t\tcirclePosition-delta)*size,blur)));    \n        }\n    }\n    // Odd edge glows ...\n    circles += vec3(\n        max(0.0, 5.0/(1.0+25.0*pow(length(uvSpread-0.7*-sunUv),1.5))),\n        max(0.0, 5.0/(1.0+30.0*pow(length(uvSpread-0.8*-sunUv),1.4))),\n        max(0.0, 5.0/(1.0+35.0*pow(length(uvSpread-0.9*-sunUv),1.3)))\n    );\n\n    circles += vec3(\n        max(0.0, 1.0-(1.0*pow(length(uvSpread-0.7*-sunUv)*5.5,2.5))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.8*-sunUv)*5.5,2.4))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.9*-sunUv)*5.5,2.3)))\n    );\n\n    return circles*0.1*length(uv-sunUv) + ray;\n}\n\n// ========== ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    \n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n\n    //float yaw3 = atan(ray.direction.x,ray.direction.z)/PI;\n    //debugOverlay = vec3(abs(fract( (yaw3-yaw1)*0.5+0.5)*2.0-1.0));\n\n    vec3 colour;\n\n    // ---- Render Sky Box\n\n    //Get the distance from the sun so we can tint the sky, This is also used for the fog colour later.\n    float distanceFromSun = 1.0-(dot(sunDir,ray.direction)*0.5+0.5);\n\n    vec3 skyColour;    \n\n    if(ray.direction.y < 0.0) {\n        // Floor (not the sand!)\n        skyColour = mix(SAND_COLOUR*0.75,SAND_COLOUR*0.5,distanceFromSun);\n    } else {\n        // Sky\n        skyColour = mix(vec3(0.4, 0.85, 1.0),vec3(0.1, 0.2, 0.25),distanceFromSun) - max(ray.direction.y,0.0)*0.3;\n    }\n\n    skyColour *= 5.0; //Make it very bright!\n\n    // ---- Render Mountains\n    #if defined(DEBUG_MOUNTAIN_RENDER)\n    if (ray.direction.y > 0.0 && ray.direction.y < 0.1875) {\n        float rayYaw = atan(ray.direction.x,ray.direction.z)/PI*0.5+0.5;\n        float mountainDepth = 0.0;\n        float maxMountainHeight = 1.0;\n        vec3 mountainColour;\n        for (float i=0.0;i<6.0;i++) {\n            float \tmountainHeight =\tvalueNoise1duw( i*1234.543 + rayYaw*(30.0),\t\t30.0) * 2.0;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*7832.856 + rayYaw*(60.0),\t\t60.0) * 1.0;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*5892.473 + rayYaw*(120.0),\t120.0) * 0.5;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*2857.673 + rayYaw*(180.0),\t180.0) * 0.25;\n            mountainHeight*= 0.07-i*0.01;\n\n            if(ray.direction.y < mountainHeight) {\n                mountainDepth=(i+1.0)/7.0;\n                //FIXME: should move this out somwhere or remap the mountain height to 0.0 to 1.0\n                //add a fade from the top to the bottom of this mountain\n                float maxHeight = (2.0+1.0+0.5+0.25)*(0.07-i*0.01);\n                float ratio = mountainHeight/maxHeight;\n                mountainDepth*= 1.0-pow(1.0-ratio,3.6);\n                mountainColour = mix(vec3(1.0),SAND_COLOUR*2.0,(i+1.0)/5.0);\n            }\n        }\n\n        float pointHeight = map(ray.direction.y,0.0,0.1875,0.0,1.0);\n        skyColour = mix(skyColour, mountainColour, mountainDepth);\n    }\n    #endif\n    //Haze\n    skyColour = mix(skyColour,mix(SAND_COLOUR*1.5,SAND_COLOUR,distanceFromSun)*3.0,pow(1.0-abs(ray.direction.y),20.0));\n\n    // ---- Render Clouds and Sun\n    if(hit.materialId == MAT_SKY) {\n        vec3 samplePoint = ray.direction;\n        float clouds = 0.0;\n        #if defined(DEBUG_CLOUD_RENDER)\n        clouds = getClouds(ray.direction, time);\n        #endif\n        vec3 suncolour = vec3(0.8,0.6,0.6);\n        float sunBright = 1.0-distanceFromSun;\n\n        sunBright = pow(smoothstep(0.99,1.0,sunBright),20.0) * 10.0; //blow it right out\n\n        skyColour += suncolour * sunBright;\n\n        skyColour = mix(skyColour, vec3(3.0), clouds );        \n\n        colour = skyColour;\n\n        // ---- Render Ground/Sand\n    } else if(hit.materialId == MAT_GROUND) {\n\n        //base sand colour\n        vec3 sandColour = SAND_COLOUR;//vec3(0.98,0.82,0.68);\n\n        #if defined(DEBUG_SAND_RIPPLES)\n        //Add riples by distorting the normal\n        float offset = ((sin(35.0*hit.origin.x)*sin(2.0*hit.origin.y+5.0*hit.origin.x)*2.0-1.0)*0.4)*(smoothstep(0.3,2.0,1.7-hit.origin.y));\n        hit.surfaceNormal.xy = normalize(hit.surfaceNormal.xy - offset);\n        #endif\n\n        #if defined(DEBUG_SAND_SHADING)\n        //give the sand some interesting variations\n        sandColour = mix(sandColour,vec3(1.0),smoothstep(0.0,1.0,dot(vec3(-1.0,0.0,0.0),hit.surfaceNormal)));\n        sandColour = mix(sandColour, vec3(0.8,0.6,0.6),smoothstep(0.0,2.0,(sin((hit.origin.x+hit.origin.z)*0.2)*cos((hit.origin.z+hit.origin.y)*0.2)*cos(hit.origin.y*0.1)*0.5+0.5)));\n        sandColour = mix(sandColour,vec3(0.6,0.4,0.3),smoothstep(0.0,1.0,1.5-hit.origin.y));\n        #endif\n        colour = sandColour;\n\n        // ---- Render Other Objects\n    } else if(hit.materialId == MAT_SPHERE_1) {\n        colour = vec3(1.0,0.1,0.1);\n    } else if(hit.materialId == MAT_SPHERE_2) {\n        colour = vec3(hit.surfaceNormal)*0.5+0.5;\n    } else {\n        colour = vec3(1.0,0.0,1.0);//vec3(1.0-hit.distance/RAY_MAX_DISTANCE);    \n    }\n\n    // ---- Render Lighting, Occlusion and Fog for everything but the skybox\n    if(hit.materialId != MAT_SKY) {\n        // Apply diffuse and specular Light\n        vec3 diffuseLight, specularLight;\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, diffuseLight, specularLight, time);\n\n        colour = colour * diffuseLight + specularLight;\n\n        #if defined(DEBUG_OCCLUSION)\n        //Simple fake Occlusion\n        float occlusion = getOcclusion(hit.origin, hit.surfaceNormal, time);\n        colour *= occlusion;\n        #endif\n\n        #if defined(DEBUG_DUST_RENDER)\n        colour = mix(colour,SAND_COLOUR*2.0,hit.dust);\n        #endif\n\n        #if defined(DEBUG_FOG_RENDER)\n        //Fog - fade to sky colour in the distance\n        colour = mix(colour,skyColour,pow((hit.distance/RAY_MAX_DISTANCE),3.0));\n        #endif\n    }\n\n    // ---- Lense Flare\n    #if defined(DEBUG_SUN_RAYS_RENDER)\n    float sunDot = dot(camera.forward, sunDir);\n    if (sunDot > 0.0) {\n        //Project the sun to the screen to get its UV position\n        mat3 invMat = rotateY(-camera.yaw) * rotateX(-camera.pitch) * rotateZ(-camera.roll);\n        vec3 sunProjection = (sunDir*invMat);\n        vec2 sunUv = sunProjection.xy/sunProjection.z*camera.zoom;\n        colour += getLensFlare(uv, sunUv)*5.0;//*pow(clamp(dot(camera.forward, sunDir),0.0,1.0),1.5);\n    }\n    #endif\n\n    // ---- Colour correction and Vignette\n    float exposure = 0.35;\n\n    #if defined(DEBUG_DYNAMIC_EXPOSURE)\n    exposure *= smoothstep(-0.7,1.0,( 1.0-pow(clamp(dot(camera.forward, sunDir),0.0,1.0),4.0)));\n    #endif\n\n    // Gamma\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    #if defined(DEBUG_GRAIN_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.5)+0.4,0.0,1.0);\n    // Grain\n    //vignette *= (1.0-hash31( (vec3(ray.direction)+(5.0+mod(vec3(time),vec3(10.0,137.0,75.3))  )) * 50.00 ) * 0.1);\n    //Burn it in\n    colour=vec3(1.0)-((vec3(1.0)-colour)/vignette);\n    #endif\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n    // colour grading\n    //colour = colour*vec3(1.0,0.8,1.0);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n    //ragColour = vec4(mix(colour,debugOverlay,0.5),1.0);\n}","name":"Image","description":"","type":"image"}]}