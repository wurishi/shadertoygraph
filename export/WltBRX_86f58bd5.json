{"ver":"0.1","info":{"id":"WltBRX","date":"1613251907","viewed":151,"name":"noise cloud density raymarch","username":"itsjonebone","description":"drew inspiration from Schneider's chapter in GPU pro 7","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ray_it 100\n// no sense in reassigning values which never change every time main is run\nfloat opacity = 75.;\nvec3 cloudCol = vec3(0.9, 0.3, 0.8);\n\n// in other uses, the RGBA texture used should have different octaves as different colors\n// which would allow the FBM to be the combination of the different channels\n\n// this noise lookup inspired by iq's 3D noise lookup in his clouds shader\nfloat noise(vec3 p) {\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    //quintic interpolation\n    pos = pos * pos * pos * (pos *(pos * 6.0 - 15.0) + 10.0);\n    p = id + pos + 0.5;\n    return textureLod(iChannel0, p / 32. , 0.0).x * 2. - 1.;\n}\n\nfloat fbm(vec3 p) {\n    return abs(\n           noise(p * 1.) * .6 ) +\n           noise(p * 2.) * .3 +\n           noise(p * 4.) * .25 +\n           noise(p * 8.) * .125 +\n           noise(p * 16.) * .075;\n}\n// makes a sphere\n// x - length(p) is inverse distance function \n// points with length less than x get positive values, outside of x radius values become negative\n// high enough values from the FBM can outweigh the negative distance values\nfloat scene(vec3 p) {\n    float l = .3 - length(p) * .05;\n    //if (l <= 0.) return 0.;\n    return .3 - length(p) * .05 + fbm(p * .0321);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates so that 0,0 is the center\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    \n    /// raycasting \n    // for more information refer to: https://learnopengl.com/Getting-started/Camera\n    // rays start at origin\n    float dist = 20. + 10. * iMouse.y / iResolution.y;\n    vec3 origin = dist * normalize(cos(iTime * vec3(.0, .0, 1.)));\n    vec3 target = vec3(0., 1., 0.);\n    \n    // unit vector in the direction from origin to target\n    vec3 ot = normalize(target - origin);\n    // unit vector in the left direction\n    vec3 left = normalize(cross(vec3(0., 1., 0.), ot));\n    // unit vector in the up direction\n    vec3 up = normalize(cross(ot, left));\n    // unit vector from origin to pixel\n    vec3 dir = normalize(uv.x * left + uv.y * up + 1.5 * ot);\n    \n    // ray loop things\n    float zMax = 2. * dist + 10.;\n    float zStep = zMax / float(ray_it);\n    vec3 rayPoint = origin;\n    vec3 color = vec3(0.);\n    float density = 0.;\n    //Transmittence\n    float T = 1.;\n    \n    // ray loop\n    for(int i = 0; i < ray_it; i ++) {\n        density = scene(rayPoint);\n        \n        if (density > 0.) {\n            density = density / float(ray_it);\n            T *= 1. - density * 100.; \n            // allows transmittence to be \"used up\" as it goes through the cloud\n            if (T <= .01) break;\n            color += cloudCol * opacity * density * T;\n            \n        }\n        rayPoint += dir * zStep;\n    }\n    \n    //add background if you want to!\n    vec3 bg = vec3(0.05, 0.1, 0.55) * .35 * (length(uv));\n    color += bg;\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}