{"ver":"0.1","info":{"id":"NtS3Dm","date":"1623981757","viewed":74,"name":"Class 6 Homework BRDF (gerrit)","username":"celeph","description":"SIGGRAPH Frontiers Introduction to Ray Tracing by Rajesh Sharma \ncontinued last scene with a few more spheres orbiting the perlin planet, move light, mouse coords to tweak metallic property (x-coord) and roughness (y-coord) ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/******************************************************************************\n * constants\n */\n#define MAXX 10000000.0\n\nconst float PI = 3.14159265358979323846;\nconst float ONE_OVER_PI = 1.0 / PI;\n\n// array sizes\nconst int NUM_SPHERES = 10;\n\n// samples per pixel\nconst int NUM_SAMPLES = 1;\n\n\n/******************************************************************************\n * counters\n */\n// seed for random numbers \nfloat seed = 0.0;\n\n/******************************************************************************\n * objects and collections\n */\nstruct Material {\n  vec3 baseColor;      \n  float metallic;      \n  float subsurface;    \n  float specular;      \n  float roughness;     \n  float specularTint;  \n  float anisotropic;   \n  float sheen;         \n  float sheenTint;     \n  float clearcoat;     \n  float clearcoatGloss;\n} materials[NUM_SPHERES];\n\n// a Light is defined by a location, color, radius\nstruct Light {\n  vec3 location;\n  vec3 color;\n  float radius;\n} lights[1];\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n  float radius;\n  vec3 center;\n  vec3 color;\n} spheres[NUM_SPHERES];\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n/******************************************************************************\n * misc functions\n */\n// background gradient color\nvec3 bgColor(vec3 rayDir) {\n  float u =  0.5*(1.0 + rayDir[1]);\n  return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n  return fract(sin(seed++)*43758.5453123);\n}\n\n// square number\nfloat sqr(float x) { return x*x; }\n\n/******************************************************************************\n * transformations\n */\n// translate\nmat4 transformTranslate(in vec3 t) {\n  mat4 ret = mat4(1.0);\n  ret[3] = vec4(t, 1.0);\n  return ret;\n}\n\n// scale\nmat4 transformScale(in vec3 s) {\n  return mat4(s.x, 0.0, 0.0, 0.0,\n              0.0, s.y, 0.0, 0.0,\n              0.0, 0.0, s.z, 0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\n// rotate\nmat4 transformRotate(in float angle, in vec3 axis) {\n  float radians = PI * angle / 180.0;\n  vec3 a = normalize(axis);\n\n  mat3 id = mat3(1.0);\n  mat3 aat = mat3(a.x*a.x, a.x*a.y, a.x*a.z,\n                  a.x*a.y, a.y*a.y, a.y*a.z,\n                  a.x*a.z, a.z*a.z, a.z*a.z);\n\n  mat3 astar = mat3( 0.0, -a.z,  a.y,\n                     a.z,  0.0, -a.x,\n                    -a.y,  a.x,  0.0);\n\n  return mat4(cos(radians) * id + (1.0 - cos(radians)) * aat + sin(radians) * astar);\n}\n\n// rotate about an arbitrary axis in 3 dimensions (verbose)\n// see also http://paulbourke.net/geometry/rotate/\nvec3 rotate(in float angle, in vec3 point, in vec3 axis, in vec3 U) {\n  // 1. translate space so that the rotation axis passes through the origin\n  mat4 T = transformTranslate(axis * -1.0);\n  mat4 Ti = inverse(T);\n\n  // 2. rotate space about the x axis so that the rotation axis lies in the xz plane\n  float t = float(angle) * PI / 180.0;\n  float a = U.x;\n  float b = U.y;\n  float c = U.z;\n  float d = sqrt(b*b + c*c);\n\n  mat4 Rx = mat4(1.0, 0.0, 0.0, 0.0, \n                 0.0, c/d, -b/d, 0.0,\n                 0.0, b/d, c/d, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n  mat4 Rxi = inverse(Rx);\n\n  // 3. rotate space about the y axis so that the rotation axis lies along the z axis\n  mat4 Ry = mat4(d, 0.0, -a, 0.0,\n                 0.0, 1.0, 0.0, 0.0,\n                 a, 0.0, d, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n  mat4 Ryi = inverse(Ry);\n\n  // 4. perform the desired rotation by theta about the z axis\n  mat4 Rz = mat4(cos(t), -sin(t), 0.0, 0.0,\n                 sin(t), cos(t), 0.0, 0.0,\n                 0.0, 0.0, 1.0, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n\n  // 5. apply the inverse of step (3)\n  // 6. apply the inverse of step (2)\n  // 7. apply the inverse of step (1)\n\n  vec4 pos = vec4(point, 1.0);\n  vec4 newPos = Ti * Rxi * Ryi * Rz * Ry * Rx * T * pos;\n  return vec3(newPos);\n}\n\n\n/******************************************************************************\n * brdf code\n */\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0-u, 0.0, 1.0);\n  float m2 = m*m;\n  return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0/PI;\n  float a2 = a*a;\n  float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n  return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a*a;\n  float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n  return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG) {\n  float a = alphaG*alphaG;\n  float b = NdotV*NdotV;\n  return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {\n  return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y, Material m) {\n  //float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n  //float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n  //float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n  //float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n  ///float dot_ht\t= h_ts.x;\n  ///float dot_hb\t= h_ts.y;\n  \n  float NdotL = clamp(L.z, 0.0, 1.0); // dot(N,L);\n  float NdotV = clamp(V.z, 0.0, 1.0); // dot(N,V);\n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0, 0.0, 0.0);\n\n  vec3 H = normalize(L+V);\n  float NdotH = clamp(H.z, 0.0, 1.0); // dot(N,H);\n  float LdotH = clamp(dot(L, H), 0.0, 1.0); // dot(L,H);\n  \n  float HdotX = H.x;\n  float HdotY = H.y; \n  \n  vec3 Cdlin = mon2lin(m.baseColor);\n  Cdlin = m.baseColor;\n  float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(m.specular*.08*mix(vec3(1), Ctint, m.specularTint), Cdlin, m.metallic);\n  vec3 Csheen = mix(vec3(1), Ctint, m.sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH*LdotH * m.roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n  \n  float fd_90_minus_1 = 2.0 * LdotH * LdotH * m.roughness - 0.5;\n  \n  Fd  = (1.0 + fd_90_minus_1 * pow(1.0 - NdotL, 5.0))\n      * (1.0 + fd_90_minus_1 * pow(1.0 - NdotV, 5.0));\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to \"flatten\" retroreflection based on roughness\n  float Fss90 = LdotH*LdotH*m.roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n  // specular\n  float aspect = sqrt(1.0-m.anisotropic*.9);\n  float ax = max(.001, sqr(m.roughness)/aspect);\n  float ay = max(.001, sqr(m.roughness)*aspect);\n  float Ds = GTR2_aniso(NdotH, HdotX, HdotY, ax, ay);\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1), FH);\n  float Gs;\n  Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n  Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n  Gs = 1.0; \n  // sheen\n  vec3 Fsheen = FH * m.sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(.1,.001,m.clearcoatGloss));\n  float Fr = mix(.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n  //return 1.0/PI * Fd*Cdlin * (1.0-m.metallic);\n  \n  return ((1.0/PI) * mix(Fd, ss, m.subsurface)*Cdlin + Fsheen)\n      * (1.0-m.metallic)\n      + Gs*Fs*Ds + .25*m.clearcoat*Gr*Fr*Dr;\n}\n\n// BRDF code from last lecture\n// vec3 calc_fresnel_schlick(vec3 f0, float dot_vn) {\n//   return f0 + (1.0 - f0) * pow(1.0 - dot_vn, 5.0);\n// }\n\n// vec3 calc_diffuse_term(float dot_nl, float dot_nv, float dot_lh, vec3 base_color, float rough_s) {\n//   float fd_90_minus_1 = 2.0 * dot_lh * dot_lh * rough_s - 0.5;\n  \n//   return base_color * ONE_OVER_PI \n//     * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nl, 5.0))\n//     * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nv, 5.0));\n// }\n\n// // anisotropic GGX / Trowbridge-Reitz\n// float calc_distribution_ggx(float dot_nh, float dot_ht, float dot_hb, vec2 linear_roughness) {\n//   float rought_x  = linear_roughness.x * linear_roughness.x;\n//   float rought_y  = linear_roughness.y * linear_roughness.y;\n//   float rough_x_s = rought_x * rought_x;\n//   float rough_y_s = rought_y * rought_y;\n    \n//   float d = (dot_nh * dot_nh\n//     + dot_ht * dot_ht * (1.0 / rough_x_s)\n//     + dot_hb * dot_hb * (1.0 / rough_y_s));\n  \n//   return ONE_OVER_PI * (1.0 / (rought_x * rought_y * d * d));\n// }\n\n// float calc_smith_lambda(float a2, float cos_angle) {\n//   if (cos_angle < 0.01) return 0.0;\n    \n//   float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n//   float tan_angle = sin_angle * (1.0 * cos_angle);\n\n//   return sqrt(1.0 + a2 * tan_angle * tan_angle) * 0.5 - 0.5;\n// }\n\n// float calc_masking_shadow_factor(float dot_nl, float dot_nv, float rought_s) {\n//   // smith correlated\n//   float a2     = rought_s * 0.5;\n//   float lambda_l   = calc_smith_lambda(a2, dot_nl);\n//   float lambda_v   = calc_smith_lambda(a2, dot_nv);\n//   return 1.0f / (1.0 + lambda_l + lambda_v);\n// }\n\n// vec3 calc_specular_term(vec3 fresnel, float dot_nl, float dot_nv, float dot_nh, float dot_lh, \n//                         float dot_ht, float dot_hb, vec2 linear_roughness, float rough_s) {\n//   float v_1_over_denom = 1.0 / (4.0 * dot_nl * dot_nv);\n\n//   return fresnel\n//     * calc_distribution_ggx(dot_nh, dot_ht, dot_hb, linear_roughness)\n//     * calc_masking_shadow_factor(dot_nl, dot_nv, rough_s)\n//     * v_1_over_denom;\n// }\n\n// vec3 mon2lin(vec3 x) {\n//   return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n// }\n\n\n/******************************************************************************\n * intersections\n */\nstruct Intersection {\n  int obj;\n  float t;\n};\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n  vec3 rayToSphere = ray.origin - sphere.center;\n  float b = dot(rayToSphere, ray.direction);\n  float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n  float disc = b*b - c;\n  float t;\n\n  if (disc > 0.0) {\n    t = -b - sqrt(disc);\n    if (t > 0.00001) return t;\n\n    t = -b + sqrt(disc);\n    if (t > 0.00001) return t;\n  }\n  return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n  float minT = MAXX;\n  int iSphere = -1;\n    \n  for (int i=0; i < NUM_SPHERES; i++) {\n    Sphere sphere = spheres[i];\n      \n    float t = raySphereIntersect(ray, sphere);\n        \n    if (t < minT && t >= 0.001) {\n      // keep track of the closest sphere and intersection\n      iSphere = i;\n      minT = t;\n    }\n  }\n  \n  return Intersection(iSphere, minT);\n}\n\n/******************************************************************************\n * lights, shadows, colors\n */\n// convert directionToLight and directionToView to tangent space\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS) {\n  // use a matrix to convert\n  vec3 t = normalize(dFdx(hitPoint));\n  vec3 b = normalize(dFdy(hitPoint));\n  vec3 n = normalize(cross(t, b));\n  mat3 xformMatrix = transpose(mat3(t, b, n));\n  \n  toLightTS = xformMatrix * toLight;\n  toViewTS = xformMatrix * toView;\n  nTS = n;\n}\n\n// returns 1.0 if light visible, 0.0 otherwise\nfloat checkLightVisibility(in Light light, vec3 hitPoint, vec3 hitNormal) {\n  float visible = 0.0;\n  vec3 lightDir = normalize(light.location - hitPoint);\n  Ray ray;\n  ray.origin = hitPoint + lightDir * 0.01;\n  ray.direction = lightDir;\n  Intersection intersection = intersectAllObjects(ray);\n  int iSphere = intersection.obj;\n  if (iSphere == -1) { \n      // no object was hit, light is visible\n      visible = 1.0;\n  }\n  return visible;\n}\n\n\n// Classic Perlin 3D Noise \n// by Stefan Gustavson\n// see https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\n  return 2.2 * n_xyz;\n}\n\nvec3 addMyPerlinTexture1(in vec2 fragCoord, int f) {\n  vec2 uv = fragCoord/iResolution.xy;\n\n  // Displace the UV\n  vec2 displacedUv = uv + cnoise(vec3(uv * 5.0, iTime * .1));\n\n  // Perlin noise\n  float strength = cnoise(vec3(displacedUv * 5.0, iTime * .2));\n  \n  float outerGlow = distance(uv, vec2(0.5)) * 5.0 - 1.2;\n  //gl_FragColor = vec4(outerGlow, outerGlow, outerGlow, 1.0);\n  \n  strength += outerGlow;\n\n  // Apply cool step\n  strength += step(-0.2, strength) * .8;\n\n  strength = clamp(strength, 0.0, 1.0);\n\n  vec3 colorStart = vec3(0.2,0.2,.2);\n  vec3 colorEnd = vec3(1.,1.,1.);\n\n  vec3 colorMixed = 1./mix(colorStart, colorEnd, strength);\n  return colorMixed;\n}\n\n/******************************************************************************\n * the scene and main entry point\n */\n// create 4 spheres at different locations in different colors\nvoid makeScene(int f) {\n  float width = iResolution.x;\n  float height = iResolution.y; \n  float aspectRatio = width/height;\n\n  spheres[0] = Sphere(0.2, vec3(0.0, 0.0, -1.0), vec3(1, 1, 0));\n\n  // See also Blender: Principled BSDF\n  materials[0].baseColor = vec3(.8, 0.0, 0.011);\n  materials[0].metallic = 0.5;\n  materials[0].specular = 0.5;\n  materials[0].specularTint = 0.796;\n  materials[0].roughness = 0.5;\n  materials[0].anisotropic = 0.181;\n  materials[0].sheen = 0.218;\n  materials[0].sheenTint = 0.5;\n  materials[0].clearcoat = .720;\n  materials[0].subsurface = 1.;\n  materials[0].clearcoatGloss = .161;\n\n  float xs = -0.4;\n\n  for(int i=1; i<8; i++) {\n    float x = xs + float(i-1) * .1;\n    spheres[i] = Sphere(min(.1*random(), 0.05), vec3(x, 0.0, -1.4), vec3(0.,0.,1.));\n    materials[i].baseColor = vec3(random(), random(), random());\n    materials[i].metallic += (iMouse.x / width * aspectRatio * 2.0 - 1.0) * .1;\n    materials[i].roughness += (iMouse.y / height * 2.0 - 1.0) * .1; // TODO\n\n    materials[i].specular = .5;\n    materials[i].specularTint = .2;\n    materials[i].anisotropic = .1;\n    materials[i].sheen = .1;\n    materials[i].sheenTint = .1;\n    materials[i].clearcoat = .12;\n    materials[i].subsurface = 1.;\n    materials[i].clearcoatGloss = 0.525;\n\n    float rx = 0.0;\n    float ry = 1.0 * random();\n    float rz = 0.0;\n    spheres[i].center = rotate(float(f)*.5*random(), spheres[i].center, spheres[0].center, normalize(vec3(rx,ry,rz)));\n    spheres[i].center = rotate(45.0*random(), spheres[i].center, spheres[0].center, normalize(vec3(0.0, 0.0, 1.0)));\n  }\n\n  lights[0] = Light(vec3(-.8, 1.0, -.5), vec3(1, 1, 1), .2);\n  lights[0].location = rotate(float(f)*.2, lights[0].location, spheres[0].center, normalize(vec3(0.0, 1.0, 0.0)));\n}\n\n// The main entry point: This is called for every pixel on the screen \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // fragCoord ranges from \n  //   in x: 0.5 to iResolution.x-0.5\n  //   in y: 0.5 to iResolution.y-0.5\n  // pixel (0,0) is at the bottom left corner\n  \n  makeScene(iFrame);\n  \n  vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n  \n  float screenDepth = -2.0;\n  \n  float width = iResolution.x;\n  float height = iResolution.y; \n  float aspectRatio = width/height;\n   \n  vec3 samp = vec3(0, 0, 0);\n  seed = 0.0;\n\n  // position light by mouse coord \n  // lights[0].location.x = (iMouse.x / width * aspectRatio * 2.0 - 1.0);\n  // lights[0].location.y = (iMouse.y / height * 2.0 - 1.0);\n\n  for (int i=0; i<1*NUM_SAMPLES; i++) {\n    float x = fragCoord.x + random() - 0.5;\n    float y = fragCoord.y + random() - 0.5;\n    \n    // map (0.5, w-0.5) to (-1, 1)\n    // and (0.5, h-0.5) to (-1, 1)\n    x = (x/width)*2.0 - 1.0;\n    y = (y/height)*2.0 - 1.0;\n    \n    // account for the non-square window\n    y = y/aspectRatio;\n              \n    // normalized ray direction\n    vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n    Ray ray = Ray(rayOrigin, rayDirection);\n              \n    // traverse the scene (all spheres) and find the \n    // closest intersected object and intersection point\n    Intersection intersection = intersectAllObjects(ray);\n       \n    int iSphere = intersection.obj;\n    float minT = intersection.t;\n       \n    Sphere sphere;\n       \n    if (iSphere > -1) { // if there is an intersection\n      // to get around iSphere not being constant\n      // TODO: Not entirely sure why this is needed, need to look into this.\n      for (int i=0; i<NUM_SPHERES; i++) {\n        if (i==iSphere) {\n          sphere = spheres[i];\n          break;\n        }\n      }\n           \n      // hit coordinates\n      vec3 hit = ray.origin + minT*ray.direction;\n      // normal at the point of ray-sphere intersection\n      vec3 hitPointNormal = normalize(hit-sphere.center);         \n      // vector from intersection to light\n      vec3 hitPointToLight = normalize(lights[0].location-hit);\n      vec3 hitPointToView = ray.origin-hit;\n           \n      vec3 toViewTS;\n      vec3 toLightTS;\n      vec3 nTS;\n\n      convertToTangentSpace(hitPointToLight, hitPointToView, hit, toLightTS, toViewTS, nTS); \n\n      vec3 h_ts     = normalize(toLightTS + toViewTS);\n      float dot_nl  = clamp(toLightTS.z, 0.0, 1.0);\n      float dot_nv  = clamp(toViewTS.z, 0.0, 1.0);\n      float dot_nh  = clamp(h_ts.z, 0.0, 1.0);\n      float dot_lh  = clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n      float dot_ht  = h_ts.x;\n      float dot_hb  = h_ts.y;\n\n      Material m = materials[iSphere];\n\n      // lighting\n      // vec3 f0 = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n      // vec3 fresnel  = calc_fresnel_schlick(f0, dot_nv);\n      // float rough_s = dot_ht * dot_ht * m.roughness * m.roughness\n      //     + dot_hb * dot_hb * m.roughness * m.roughness; \n   \n      // vec3 diffuse_factor = (1.0 - fresnel) * (1.0 - m.metallic);\n            \n      // vec3 diffuse_term = diffuse_factor * calc_diffuse_term(dot_nl, dot_nv, dot_lh, m.baseColor, rough_s);\n      // vec3 specular_term = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n      // vec3 col = diffuse_term * dot_nl;\n\n      vec3 wi;\n      float lightPdf;\n      float lightVisible = checkLightVisibility(lights[0], hit, hitPointNormal);\n\n      vec3 brdf = BRDF(toLightTS, toViewTS, nTS, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), m);\n          \n      vec3 col = brdf * dot_nl * lightVisible;\n\n      if (iSphere == 0) {\n        col *= addMyPerlinTexture1(fragCoord, iFrame);\n      }\n\n      vec3 toneMappedColor = col * (1.0 / (col + 1.0));\n      float gamma = 1.0 / 2.2;\n\n      vec3 finalColor = vec3(pow(toneMappedColor.x, gamma),\n                             pow(toneMappedColor.y, gamma),\n                             pow(toneMappedColor.z, gamma));\n\n      samp = samp + finalColor; \n    } \n    else {\n      samp = samp + bgColor(ray.direction);\n    }\n  }\n\n  // average all the samples per pixel\n  fragColor = vec4(samp/float(NUM_SAMPLES), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}