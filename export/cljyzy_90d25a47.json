{"ver":"0.1","info":{"id":"cljyzy","date":"1692121205","viewed":74,"name":"Domain repetition overstep fix","username":"gunthern","description":"Fix for bounded domain repetition overstepping in raymarching. Corrected geometry is shown on the left, uncorrected on the right.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","domainrepetition","domain","repetition","overstep","overstepping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURFACE_DIST 0.005\n#define gridSize 10.0\n\n// Raymarched sphere and box from iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float r) {\n    \n    return length(p)-r;\n    \n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getDist(vec3 p, vec3 rd, vec2 uv) {\n    \n    // Bound domain repetition to size of grid\n    p = clamp(p, vec3(0.0), vec3(gridSize));\n    \n    // 3D repetition from iquilezles.org/articles/distfunctions/\n    vec3 q = fract(p)-0.5;\n    \n    // Correct overstepping by marching to the cell boundary instead, if the ray exits the cell\n    vec2 rC = ((2.0 * step(0.0, rd.xz) - 1.0) * vec2(0.5) - q.xz) / rd.xz; // ray to cell boundary\n    float dC = min(rC.x, rC.y) + 0.01; // distance to cell just past boundary\n    /* Conditional below prevents cell boundaries from being drawn around\n    outside of the 3d grid in a bounded domain repetition like this one*/\n    if (p.x >= float(gridSize) || p.x <= 0.0\n     || p.y >= float(gridSize) || p.y <= 0.0\n     || p.z >= float(gridSize) || p.z <= 0.0 ) \n    { dC += MAX_DIST; }\n    \n    // Draw spheres and boxes\n    float d = sdSphere(q, 0.1);\n    if (mod(floor(p.x),2.0) == 0.0 || mod(floor(p.z),2.0) == 0.0) d = sdBox(q, vec3(0.2));\n    \n    if (uv.x > 0.0) return d;\n    return min(d, dC);\n  \n}\n\n// Raymarch\nfloat rayMarch(vec3 ro, vec3 rd, vec2 uv){\n\n    float dO = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n    \n        vec3 p = ro + rd*dO;\n        \n        float dist = getDist(p, rd, uv);\n        float dS = dist;\n        \n        dO += dS;\n        if (dO>MAX_DIST || dS<SURFACE_DIST) break;\n    }\n    \n    return dO;\n    \n}\n\n// Get normal\nvec3 getNormal(vec3 p, vec3 rd, vec2 uv) {\n\n    float d = getDist(p, rd, uv);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, rd, uv),\n        getDist(p-e.yxy, rd, uv),\n        getDist(p-e.yyx, rd, uv));\n        \n    return normalize(n);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    // Ray origin\n    vec3 ro = vec3(gridSize * 0.5 - 0.5, gridSize * 0.5, 0.0);\n    // Ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Raymarch and get diffuse color\n    float d = rayMarch(ro, rd, uv);\n    \n    vec3 p = (ro + rd * d);\n    \n    // Normal \"lighting\"\n    vec3 normal = getNormal(p, rd, uv);\n    float normalLight = clamp((normal.r)*0.33 + (1.0-normal.b)*0.33 + normal.g*0.33, 0.25, 1.0); \n    if (d > 15.0) normalLight = 0.0;\n    \n    fragColor = vec4(vec3(normalLight), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}