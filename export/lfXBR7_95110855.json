{"ver":"0.1","info":{"id":"lfXBR7","date":"1723504183","viewed":18,"name":"Hyperbolic_Icosahedron_3","username":"afoksha","description":"Renders tesselation of the hyperbolic space by icosahedron with dihedral angle 2π/3.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","hyperbolicspace","lorentzspace","hyperboloidmodel"],"hasliked":0,"parentid":"lcXBR7","parentname":"Hyperbolic_Hexahedron_6"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==========================================================================================================================\n\nfloat hyp_dot(vec4 u, vec4 v)\n    { return dot(u.xyz, v.xyz) - u.w * v.w; }\n    \nvec4 normalize_t(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(-hyp_dot(v, v));\n    return inv_l * v;\n}\n\nfloat arccosh(float q)\n{\n    q = max(q, 1.0f);\n    float s = q + sqrt(q * q - 1.0f);\n    return log(s);\n}\n\nfloat arccosh_sqrt(float q)\n{\n    q = max(q, 1.0f);\n    float s = sqrt(q) + sqrt(q - 1.0f);\n    return log(s);\n}\n\n/* space-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = +1. Tangent directions to H^3 are space-like 4-vectors */\nvec4 normalize_s(vec4 v)\n{\n    float norm = dot(v.xyz, v.xyz) - v.w * v.w;\n    float inv_l = 1.0f / sqrt(norm);\n    return inv_l * v;\n}\n\nconst float beta  = 1.5882513925501116f;        /* sqrt(9 + 5 * sqrt(5)) / (2 * sqrt(2)) */\nconst float alpha = 2.5698447358254320f;        /* sqrt(13 + 6 * sqrt(5)) / 2 */\nconst float gamma = 2.9270509831248423f;        /* (5 + 3 * sqrt(5)) / 4 */\nconst float ksi   = 0.8090169943749474f;        /* (sqrt(5) + 1) / 4 */\nconst float omega = 1.3090169943749474f;        /* (3 + sqrt(5)) / 4 */\nconst float mu    = 0.9815933432753205f;        /* sqrt(1 + 3 * sqrt(5)) / (2 * sqrt(2)) */\nconst float nu    = 1.5882513925501116f;        /* sqrt(9 + 5 * sqrt(5)) / (2 * sqrt(2)) */\nconst float delta = 2.1180339887498948f;        /* sqrt(9 + 4 * sqrt(5)) / 2 */\n\nconst float rho   = 1.5115226281523415f;        /* sqrt((7 + 3 * sqrt(5)) / 6) */\nconst float chi   = 1.1334463619495020f;        /* sqrt((1 + 3 * sqrt(5)) / 6) */\nconst float phi   = 0.9169773690296049f;        /* (chi / 2) * (sqrt(5) + 1) / 2 */\nconst float tau   = 0.5667231809747510f;        /* (chi / 2) */\nconst float eta   = 0.3502541880548539f;        /* (chi / 2) * (sqrt(5) - 1) / 2 */\nconst float kappa = 0.8090169943749474f;        /* (1 + sqrt(5)) / 4 */\nconst float theta = 0.3090169943749474f;        /* (sqrt(5) - 1) / 4 */\n\nconst float K0    = 1.8512295868219161f;        /* (3 + sqrt(5)) / (2 * sqrt(2)) */\nconst float K1    = 0.7071067811865475f;        /* 1 / sqrt(2) */\nconst float K2    = 1.1441228056353686f;        /* (sqrt(5) + 1) / (2 * sqrt(2)) */\nconst float K3    = 1.3881826187951073f;        /* sqrt(1 + 3 * sqrt(5)) / 2 */\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of hyperbolic reflections\n// group closest to the origin, or, the same, finds point equivalent to p in the main fundamental icosahedron\n//==========================================================================================================================\n/*  Reflection directions ::\n\n    {   ±ksi,   ±ksi,   ±ksi, mu }\n    { ±omega,   ±0.5,    0.0, mu }\n    {    0.0, ±omega,   ±0.5, mu }\n    {   ±0.5,    0.0, ±omega, mu }\n*/\nvec4 bounce(vec4 P)\n{\n    int k = 0;\n\n    /* sqrt(2) * vec4(omega, 0.5f, ksi, mu) */\n    const vec4 K = vec4(K0, K1, K2, K3);\n\n    /* to avoid possible infinite loops for points lying on the faces of the main icosahedron */\n    while (k < 12)\n    {\n        vec3 a = abs(P.xyz);\n        vec4 q = vec4(K.x * a + K.y * a.yzx, K.z * (a.x + a.y + a.z));\n\n        vec2 m = max(q.xy, q.zw);\n        float M = max(m.x, m.y);\n\n        /* dp is maximal hyperbolic dot product of P with reflection vectors (scaled by sqrt(2)) */\n        float dp = M - K.w * P.w;\n\n        if (dp <= 0.0f) break;\n\n        vec3 s = sign(P.xyz);\n\n        if (q.w >= M)        /* q.w = ksi * (|p.x| + |p.y| + |p.z|) is maximal */\n            P.xyz -= K.z * dp * s;\n        else if (q.x >= M)   /* q.x = omega * |p.x| + 0.5f * |p.y| is maximal */\n            P.xy -= dp * K.xy * s.xy;\n        else if (q.y >= M)   /* q.y = omega * |p.y| + 0.5f * |p.z| is maximal */\n            P.yz -= dp * K.xy * s.yz;\n        else /* q.z >= M */  /* q.z = omega * |p.z| + 0.5f * |p.x| is maximal */\n            P.zx -= dp * K.xy * s.zx;\n\n        P.w -= dp * K.w;\n        ++k;\n    }\n\n    return P;\n}\n\n/*  Vertices of the main icosahedron ::\n\n    { ±mu, ±nu, 0.0, delta }\n    { 0.0, ±mu, ±nu, delta }\n    { ±nu, 0.0, ±mu, delta }\n*/\nfloat vertex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n    vec3 q = mu * a + nu * a.yzx;\n    float Q = delta * p.w - max(max(q.x, q.y), q.z);\n    float v_sdf = arccosh(Q) - 0.32f;\n    return v_sdf;\n}\n\n/*  Centers of the neighbouring fundamental domains ::\n\n    {  ±beta,  ±beta,  ±beta, gamma }\n    { ±alpha,    ±mu,    0.0, gamma }\n    {    0.0, ±alpha,    ±mu, gamma }\n    {    ±mu,    0.0, ±alpha, gamma }\n*/\nfloat face_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n    vec4 s = vec4(alpha * a + mu * a.yzx, beta * (a.x + a.y + a.z));\n    s.xy = max(s.xy, s.zw);\n    float dp = gamma * p.w - max(s.x, s.y);\n    float d0 = arccosh(p.w);\n    float d1 = arccosh(dp);\n    float b_sdf = 0.917f - d0;\n    float f_sdf = 0.5f * (d1 - d0 - 0.018f);\n    return max(b_sdf, f_sdf);\n}\n\n/*  Centers of edges and rays tangent to edges at center ::\n\n    {  chi,  0.0,  0.0, rho },      {    0.0,    0.0,    1.0 }\n    { -chi,  0.0,  0.0, rho },      {    0.0,    0.0,    1.0 }\n    {  0.0,  chi,  0.0, rho },      {    1.0,    0.0,    0.0 }\n    {  0.0, -chi,  0.0, rho },      {    1.0,    0.0,    0.0 }\n    {  0.0,  0.0,  chi, rho },      {    0.0,    1.0,    0.0 }\n    {  0.0,  0.0, -chi, rho },      {    0.0,    1.0,    0.0 }\n\n    {  phi,  tau,  eta, rho },      {  theta, -kappa,    0.5 }\n    {  phi,  tau, -eta, rho },      { -theta,  kappa,    0.5 }\n    {  phi, -tau,  eta, rho },      {  theta,  kappa,    0.5 }\n    {  phi, -tau, -eta, rho },      { -theta, -kappa,    0.5 }\n    { -phi,  tau,  eta, rho },      { -theta, -kappa,    0.5 }\n    { -phi,  tau, -eta, rho },      {  theta,  kappa,    0.5 }\n    { -phi, -tau,  eta, rho },      { -theta,  kappa,    0.5 }\n    { -phi, -tau, -eta, rho },      {  theta, -kappa,    0.5 }\n\n    {  eta,  phi,  tau, rho },      {    0.5,  theta, -kappa }\n    { -eta,  phi,  tau, rho },      {    0.5, -theta,  kappa }\n    {  eta,  phi, -tau, rho },      {    0.5,  theta,  kappa }\n    { -eta,  phi, -tau, rho },      {    0.5, -theta, -kappa }\n    {  eta, -phi,  tau, rho },      {    0.5, -theta, -kappa }\n    { -eta, -phi,  tau, rho },      {    0.5,  theta,  kappa }\n    {  eta, -phi, -tau, rho },      {    0.5, -theta,  kappa }\n    { -eta, -phi, -tau, rho },      {    0.5,  theta, -kappa }\n\n    {  tau,  eta,  phi, rho },      { -kappa,    0.5,  theta }\n    {  tau, -eta,  phi, rho },      {  kappa,    0.5, -theta }\n    { -tau,  eta,  phi, rho },      {  kappa,    0.5,  theta }\n    { -tau, -eta,  phi, rho },      { -kappa,    0.5, -theta }\n    {  tau,  eta, -phi, rho },      { -kappa,    0.5, -theta }\n    {  tau, -eta, -phi, rho },      {  kappa,    0.5,  theta }\n    { -tau,  eta, -phi, rho },      {  kappa,    0.5, -theta }\n    { -tau, -eta, -phi, rho },      { -kappa,    0.5,  theta }\n*/\n\nfloat edge_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    vec3 q = rho * p.w - chi * a;\n    vec3 A = q * q - a.zxy * a.zxy;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = p.x * S1.xyxy + p.y * S1.wzzw + 0.5f * p.z;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = p.y * S1.xyxy + p.z * S1.wzzw + 0.5f * p.x;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = p.z * S1.xyxy + p.x * S1.wzzw + 0.5f * p.y;\n    vec4 D = d0 * d0 - d1 * d1;\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n\n    float Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.077f;\n    return e_sdf;\n}\n\nfloat edge_vertex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    /* vertex sdf */\n    vec3 q = mu * a + nu * a.yzx;\n    float Q = delta * p.w - max(max(q.x, q.y), q.z);\n    float v_sdf = arccosh(Q) - 0.32f;\n\n    /* edge sdf */\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    q = rho * p.w - chi * a;\n    vec3 A = q * q - a.zxy * a.zxy;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = p.x * S1.xyxy + p.y * S1.wzzw + 0.5f * p.z;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = p.y * S1.xyxy + p.z * S1.wzzw + 0.5f * p.x;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = p.z * S1.xyxy + p.x * S1.wzzw + 0.5f * p.y;\n    vec4 D = d0 * d0 - d1 * d1;\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n\n    Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.077f;\n\n    return min(v_sdf, e_sdf);\n}\n\nfloat edge_face_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    /* edge sdf */\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    vec3 q = rho * p.w - chi * a;\n    vec3 A = q * q - a.zxy * a.zxy;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = p.x * S1.xyxy + p.y * S1.wzzw + 0.5f * p.z;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = p.y * S1.xyxy + p.z * S1.wzzw + 0.5f * p.x;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = p.z * S1.xyxy + p.x * S1.wzzw + 0.5f * p.y;\n    vec4 D = d0 * d0 - d1 * d1;\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n\n    float Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.077f;\n\n    /* face sdf */\n    vec4 s = vec4(alpha * a + mu * a.yzx, beta * (a.x + a.y + a.z));\n    s.xy = max(s.xy, s.zw);\n    float dp = gamma * p.w - max(s.x, s.y);\n    float dist0 = arccosh(p.w);\n    float dist1 = arccosh(dp);\n    float b_sdf = 0.917f - dist0;\n    float f_sdf = 0.5f * (dist1 - dist0 - 0.018f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(e_sdf, f_sdf);\n}\n\nfloat face_vertex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    /* vertex sdf */\n    vec3 q = mu * a + nu * a.yzx;\n    float Q = delta * p.w - max(max(q.x, q.y), q.z);\n    float v_sdf = arccosh(Q) - 0.32f;\n\n    /* face sdf */\n    vec4 s = vec4(alpha * a + mu * a.yzx, beta * (a.x + a.y + a.z));\n    s.xy = max(s.xy, s.zw);\n    float dp = gamma * p.w - max(s.x, s.y);\n    float d0 = arccosh(p.w);\n    float d1 = arccosh(dp);\n    float b_sdf = 0.917f - d0;\n    float f_sdf = 0.5f * (d1 - d0 - 0.018f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(v_sdf, f_sdf);\n}\n\nfloat face_edge_vertex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    /* vertex sdf */\n    vec3 q = mu * a + nu * a.yzx;\n    float Q = delta * p.w - max(max(q.x, q.y), q.z);\n    float v_sdf = arccosh(Q) - 0.32f;\n\n    /* edge sdf */\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    q = rho * p.w - chi * a;\n    vec3 A = q * q - a.zxy * a.zxy;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = p.x * S1.xyxy + p.y * S1.wzzw + 0.5f * p.z;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = p.y * S1.xyxy + p.z * S1.wzzw + 0.5f * p.x;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = p.z * S1.xyxy + p.x * S1.wzzw + 0.5f * p.y;\n    vec4 D = d0 * d0 - d1 * d1;\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n    Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.077f;\n\n    /* face sdf */\n    vec4 s = vec4(alpha * a + mu * a.yzx, beta * (a.x + a.y + a.z));\n    s.xy = max(s.xy, s.zw);\n    float dp = gamma * p.w - max(s.x, s.y);\n    float dist0 = arccosh(p.w);\n    float dist1 = arccosh(dp);\n    float b_sdf = 0.917f - dist0;\n    float f_sdf = 0.5f * (dist1 - dist0 - 0.018f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(v_sdf, min(e_sdf, f_sdf));\n}\n\nfloat sdf(vec4 p)\n{\n    //return vertex_sdf(p);\n    //return face_sdf(p);\n    //return edge_sdf(p);\n\n    //return edge_vertex_sdf(p);\n    //return face_vertex_sdf(p);\n    //return edge_face_sdf(p);\n\n    return face_edge_vertex_sdf(p);\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.0005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    const int MAX_ITERATIONS = 64;\n\n    int i = 0;\n    while ((i < MAX_ITERATIONS) && (d > eps) && (t < 32.0))\n    {\n        t += d;\n        float s = sinh(t);\n        float c = cosh(t);\n        p = c * origin + s * ray;\n        d = sdf(p);\n        ++i;\n    }\n\n    if (d < 0.05f)\n        dist = t;\n\n    return p;\n}\n\n//==============================================================================================================================================================\n//      SDF gradient :: standard 6-point evaluation\n//      Standard orthonormal basis at origin parallel translated along the geodesic into a generic point P = { x, y, z, w }\n//  looks like:\n//\n//       X = { 1.0f + (x * x) / (w + 1),        (x * y) / (w + 1),        (x * z) / (w + 1), x },\n//       Y = {        (y * x) / (w + 1), 1.0f + (y * y) / (w + 1),        (y * z) / (w + 1), y },\n//       Z = {        (z * x) / (w + 1),        (z * y) / (w + 1), 1.0f + (z * z) / (w + 1), z },\n//\n//      They are normalized, orthogonal among themselves and orthogonal to P.\n//==============================================================================================================================================================\nvec4 hyperbolic_gradient6(vec4 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float inv_w = 1.0f / (1.0f + p.w);\n\n    vec4 X = vec4(1.0f + inv_w * x * x,        inv_w * x * y,        inv_w * x * z, x);\n    vec4 Y = vec4(       inv_w * y * x, 1.0f + inv_w * y * y,        inv_w * y * z, y);\n    vec4 Z = vec4(       inv_w * z * x,        inv_w * z * y, 1.0f + inv_w * z * z, z);\n\n    const float eps = 0.00625f;\n\n    float di = sdf(normalize_t(p + eps * X)) - sdf(normalize_t(p - eps * X));\n    float dj = sdf(normalize_t(p + eps * Y)) - sdf(normalize_t(p - eps * Y));\n    float dk = sdf(normalize_t(p + eps * Z)) - sdf(normalize_t(p - eps * Z));\n\n    vec4 g = di * X + dj * Y + dk * Z;\n    return normalize_s(g);\n}\n\n/* distance to origin :: arccosh(2) = 1.316958 */\nconst vec4 light_ws[8] = vec4[]\n(\n    vec4(+1, +1, +1, 2),\n    vec4(+1, +1, -1, 2),\n    vec4(+1, -1, +1, 2),\n    vec4(+1, -1, -1, 2),\n    vec4(-1, +1, +1, 2),\n    vec4(-1, +1, -1, 2),\n    vec4(-1, -1, +1, 2),\n    vec4(-1, -1, -1, 2)\n);\n\n//==============================================================================================================================================================\n//   Computes direction in 4-space hyperbolic-orthogonal to P, A, and B\n//   Note: if P is time-like (e.g. represents a point), and A, B are \n// space-like (e.g. represent directions) then cross-product is also space-like, \n// so is space-like normalizable\n//==============================================================================================================================================================\nvec4 hyp_cross(vec4 P, vec4 A, vec4 B)\n{\n    /* six 2x2 minors constructed from the rows A and B */\n    vec4 det2x2_1 = A * B.yzwx - B * A.yzwx;       /* xy, yz, zw, wx */\n    vec2 det2x2_2 = A.xy * B.zw - B.xy * A.zw;     /* xz, yw */\n\n    return vec4( \n        +P.y * det2x2_1.z - P.z * det2x2_2.y + P.w * det2x2_1.y,\n        -P.z * det2x2_1.w - P.w * det2x2_2.x - P.x * det2x2_1.z,\n        +P.w * det2x2_1.x + P.x * det2x2_2.y + P.y * det2x2_1.w,\n        +P.x * det2x2_1.y - P.y * det2x2_2.x + P.z * det2x2_1.x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.77f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.97f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n    \n    float R = 1.32f + 0.32f * c1 + 0.371f * s0;\n    float W = sqrt(1.0f + R * R);\n    vec3 camera_xyz = R * normalize(vec3(-c1 * s0, s1 *  c0 * s2, s0 * c2));\n    vec4 camera_ws = vec4(camera_xyz, W);\n\n    /* compute some random directions in 3 space, lift them to hyperboloid and \n       apply Gram-Schmidt orthogonalization process on the fly */\n\n    float r = 0.75f;                                 /* look at close to origin */\n    vec3 z = camera_xyz + r * vec3(s1 * c0, -s0 * c2, s3 *  c1 * s2); \n    vec4 Z = vec4(z, dot(camera_xyz, z) / W);        /* lift it up to hyperboloid tangent space, Z is orthogonal to camera_ws */\n    Z = normalize_s(Z);                              /* normalize */\n    \n    vec3 x = vec3(s2 * c0, -s1 * c1, c2);            /* generate some random direction */\n    vec4 X = vec4(x, dot(camera_xyz, x) / W);        /* lift it up to hyperboloid tangent space, X is orthogonal to camera_ws */\n    X = X - hyp_dot(X, Z) * Z;                       /* make it hyperbolic-orthogonal to Z, it should remain orthogonal to camera_ws */\n    X = normalize_s(X);                              /* normalize */\n\n    vec4 Y = hyp_cross(camera_ws, Z, X);             /* compute the last basis vector as a cross product */\n    Y = normalize_s(Y);                              /* normalize, should not be needed */\n\n    vec4 view_ray = uv.x * X + uv.y * Y - Z;\n    view_ray = normalize_s(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f && dist < 7.2f)\n    {\n        float W = position.w;\n        vec4 n = hyperbolic_gradient6(position);\n        \n        const vec3 hue = vec3(1.41f, 1.73f, 2.72f);\n        float c = 1.0 / (1.0f + 0.175f * sqrt(position.w));\n        vec3 rgb = pow(vec3(c), 4.0f * hue);\n\n        vec3 view = camera_ws.xyz - position.xyz;\n        vec4 v = vec4(view, dot(view, position.xyz) / W);\n        v = normalize_s(v);                                     /* unit view vector at tangent space at position */\n\n        color = 0.225f * rgb;                                   /* ambient */\n\n        for (int i = 0; i < 8; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light.xyz, position.xyz);\n            float hyp_dp = W * light.w - dp;                    /* ch(distance), can be used directly for attenuation */\n\n            /* lift of the light direction to the hyperboloid */\n            vec4 l = vec4(light.xyz - position.xyz, -W + ((dp + 1.0f) / W));\n            l = normalize_s(l);                                 /* unit light vector at tangent space at position */\n\n            float a = 0.75f / (1.0f + 0.025f * hyp_dp);\n\n            float cos_theta = max(hyp_dot(l, n), 0.0f);\n            vec4 h = normalize_s(l + v);\n\n            float cos_alpha = max(hyp_dot(h, n), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}