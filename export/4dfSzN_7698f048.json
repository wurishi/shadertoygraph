{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const int\t\tRAY_MARCHING_STEPS\t\t\t\t= 768;\nconst float\t\tRAY_MARCHING_EPSILON\t\t\t= 0.0001;\n\nconst float \tAMBIENT_OCCLUSION_FALLOFF\t\t= 0.5;\nconst int \t\tAMBIENT_OCCLUSION_STEPS \t\t= 5;\n\nconst int \t\tSOFT_SHADOW_STEPS \t\t\t\t= 50;\n\nstruct marchresult\n{\n\tbool miss;\n\tvec3 color;\n\tvec3 normal;\n\tvec3 direction;\n\tvec3 hit;\n};\n\nvec3 getRay(vec3 eye, vec3 lookAt, vec2 uv)\n{\n\tvec3 direction = normalize(lookAt - eye);\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), direction));\n\tvec3 up = cross(direction, right);\n\t\n\treturn normalize(direction + right * uv.x + up * uv.y);\n}\n\nvec3 getRay(vec3 eye, float yaw, float pitch, vec2 uv)\n{\n\tvec3 lookAt = vec3(sin(yaw), sin(pitch), -cos(pitch) * cos(yaw));\n\t\n\treturn getRay(eye, lookAt, uv);\n}\n\nfloat distanceFromSphere(vec3 point, vec4 sphere)\n{\n\treturn distance(point, sphere.xyz) - sphere.w;\n}\n\nfloat distanceFromPlane(vec3 point, vec4 plane)\n{\n\treturn dot(point, plane.xyz) + plane.w;\n}\n\nfloat distanceFromWorld(vec3 point)\n{\n\tfloat s = distanceFromPlane(point, vec4(0.0, 1.0, 0.0, 1.0)); \n\t\n\ts = min(s, distanceFromSphere(point, vec4(-2.0, 0.0, -2.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(-2.0, 0.0, 0.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(-2.0, 0.0, 2.0, 1.0)));\n\t\n\ts = min(s, distanceFromSphere(point, vec4(0.0, 0.0, -2.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(0.0, 0.0, 0.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(0.0, 0.0, 2.0, 1.0)));\n\t\n\ts = min(s, distanceFromSphere(point, vec4(2.0, 0.0, -2.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(2.0, 0.0, 0.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(2.0, 0.0, 2.0, 1.0)));\n\t\n\ts = min(s, distanceFromSphere(point, vec4(-1.0, sqrt(2.0), -1.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(-1.0, sqrt(2.0), 1.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(1.0, sqrt(2.0), -1.0, 1.0)));\n\ts = min(s, distanceFromSphere(point, vec4(1.0, sqrt(2.0), 1.0, 1.0)));\n\t\n\ts = min(s, distanceFromSphere(point, vec4(0.0, 2.0 * sqrt(2.0), 0.0, 1.0)));\n\t\n\treturn s;\n}\n\nvec3 getWorldNormal(vec3 point) {\n\t\n\tconst float eps = RAY_MARCHING_EPSILON;\n\t\n\tfloat nx = distanceFromWorld(point + vec3(eps, 0.0, 0.0)) - distanceFromWorld(point + vec3(-eps, 0.0, 0.0));\n\tfloat ny = distanceFromWorld(point + vec3(0.0, eps, 0.0)) - distanceFromWorld(point + vec3(0.0, -eps, 0.0));\n\tfloat nz = distanceFromWorld(point + vec3(0.0, 0.0, eps)) - distanceFromWorld(point + vec3(0.0, 0.0, -eps));\n\t\n\treturn normalize(vec3(nx, ny, nz));\n}\n\nvec2 getScreenUV(vec2 fragCoord)\n{\n\tvec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n\t\n\treturn (fragCoord.xy / iResolution.xy + vec2(-0.5, -0.5)) * aspect;\n}\n\nvec4 marchRay(vec3 eye, vec3 dir)\n{\n\tvec4 currentMarch = vec4(0.0);\n\t\n\tfor(int i = 0; i < RAY_MARCHING_STEPS; i++)\n\t{\n\t\tcurrentMarch.xyz = eye + dir * currentMarch.w;\n\t\t\n\t\tfloat pointDistance = distanceFromWorld(currentMarch.xyz);\n\t\t\n\t\tif(pointDistance <= RAY_MARCHING_EPSILON) {\n\t\t\t\n\t\t\treturn currentMarch;\n\t\t}\n\t\t\n\t\tcurrentMarch.w += pointDistance;\n\t\t\n\t\tif(currentMarch.w > 10000.0)\n\t\t\tbreak;\n\t}\n\t\n\tcurrentMarch.w = 10000.0;\n\t\n\treturn currentMarch;\n}\n\nfloat getSoftShadowFactor(vec3 point, vec3 light)\n{\n\tvec3 rd = normalize(light - point);\n\tvec3 ro = point;\n\tfloat maxt = distance(light, point);\n\tfloat t = 0.01;\n    float res = 1.0;\n\tconst float k = 3.0;\n    for( int i = 0; i <  SOFT_SHADOW_STEPS; i++)\n    {\n        float h = distanceFromWorld(ro + rd*t);\n        if( h<0.001)\n            return 0.0;\n\t\t\n\t\tres = min( res, k*h/t );\t\t\n        t += h;\n\t\t\n\t\tif(t > maxt)\n\t\t\treturn res;\n    }\n    return res;\n}\n\nfloat getSubsurfaceScatteringFactor(vec3 point, vec3 rayDirection)\n{\n\tfloat total = 0.0;\n\tfloat weight = 3.0;\n\t\n\tfor ( int i = 0; i < 15; ++i )\n\t{\n\t\tfloat delta = pow ( float(i) +1.0, 2.5 ) *0.01 *1.0;\n\t\ttotal += -weight *min ( 0.0, distanceFromWorld ( point + rayDirection * delta ) );\n\t\tweight *= 0.5;\n\t}\n\treturn clamp ( 1.0 - total, 0.0, 1.0 );\n}\n\nfloat getAmbientOcclusionFactor(vec3 point, vec3 normal)\n{\n\tfloat distance = 0.0;\n\t\n\tfloat occlusion = 0.0;\n\tfloat falloff = 1.0;\n\t\n\tfor(int i = 1; i <= AMBIENT_OCCLUSION_STEPS; i++)\n\t{\n\t\tdistance += AMBIENT_OCCLUSION_FALLOFF / float(AMBIENT_OCCLUSION_STEPS);\n\t\t\n\t\tfloat worldDistance = distanceFromWorld(point + normal * distance);\n\t\tfloat distanceDif = (abs(distance - worldDistance)) / AMBIENT_OCCLUSION_FALLOFF;\n\t\tocclusion += (1.0 / falloff) * distanceDif;\n\t\tfalloff *= 2.0;\n\t\t\n\t}\n\t\n\treturn 1.0 - occlusion;\n}\n\nvec3 shade(vec3 hit, vec3 rayDirection, vec3 normal, float depth)\n{\n\tvec3 sunPos = vec3(30.0, 100.0, 120.0);\n\tvec3 sunDir = normalize(sunPos - hit);\n\tfloat ao = 0.5 + (0.5 * getAmbientOcclusionFactor(hit, normal));\n\tfloat softShadow = getSoftShadowFactor(hit, sunPos);\n\tfloat sssc = getSubsurfaceScatteringFactor(hit, rayDirection);\n\tvec3 materialColor = vec3(0.2, 0.25, 0.3);\n\t\n\t// compute materials\n    vec3 material = materialColor;\n\n    // lighting terms\n    float sun = clamp( dot( normal, sunDir ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*normal.y, 0.0, 1.0 );\n    float ind = clamp( dot( normal, sunDir*vec3(-1.0,0.0,-1.0) ), 0.0, 1.0 );\n\n\tvec3 sunColor = vec3(1.64,1.27,0.99);\n\t\n    // compute lighting\n    vec3 lin  = sun*sunColor*pow(vec3(softShadow),vec3(1.0,1.2,1.5));\n         lin += sky*vec3(0.16,0.20,0.28)*ao;\n         lin += ind*vec3(0.40,0.28,0.20)*ao;\n\n\tlin+=sunColor * sssc;\n\t\n    // multiply lighting and materials\n    vec3 color = material * lin;\n\t//color = vec3(sssc);\n\n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n\n    // display\n    return vec3(color);\t\n}\n\nmarchresult marchAndShadeRay(vec3 origin, vec3 direction)\n{\n\tvec4 marchResult = marchRay(origin, direction);\n\t\n\tvec3 hit = marchResult.xyz;\n\tmarchresult result;\n\t\n\tif(marchResult.w >= 10000.0) {\n\t\t\n\t\tresult = marchresult(true, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t}\n\telse\n\t{\t\t\n\t\tvec3 normal = getWorldNormal(hit);\t\n\t\t\n\t\tvec3 col = shade(hit, direction, normal, marchResult.w);\n\t\n\t\tresult = marchresult(false, col, normal, direction, hit);\n\t}\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = getScreenUV(fragCoord);\n\tvec2 mouse = (iMouse.xy / iResolution.xy + vec2(-0.5, -0.5));\n\tvec3 eye = vec3(sin(iTime) * 20.0, 5.0, cos(iTime) * 20.0);\n\tvec3 rayDirection = getRay(eye, vec3(0.0), uv);\n\t\n\tmarchresult result = marchAndShadeRay(eye, rayDirection);\n\t\n\tfragColor = vec4(result.color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfSzN","date":"1397472629","viewed":421,"name":"ray marching - test #2","username":"remonvv","description":"First attempt on writing a raymarcher from scratch (rather than glorious copy/pasting from people way better at it than me).","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","softshadows","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""}}