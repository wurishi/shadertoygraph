{"ver":"0.1","info":{"id":"NsXSDj","date":"1619205361","viewed":109,"name":"Journey Scene","username":"vatsin","description":"Scene from Journey","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AO_DIST 0.085\n#define AO_K 2.0\n#define DISTORTION 0.2\n#define GLOW 6.0\n#define AMBIENT 0.0\n#define SCALE 3.0\n#define PERLIN_GRID 8.0\n\nconst float k = 5.0;\n\nconst float PI = 3.14159265359;\nconst float RAD = 3.14159265359 / 180.0;\n\nconst vec3 cameraPos = vec3(0.0, 0.0, -20.0);\n\nconst vec3 lightPos = vec3(0.0, 28.0, 32.0);\nconst vec3 fakeLightPos = vec3(0.0, 15.0, 32.0);\n                                    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.y, -sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\nvec2 noise2D2D( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(230.2, 409.1)),\n                 dot(p, vec2(909.1, 891.5))))\n                 * 58290.101);\n}\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec2 t2 = abs(p - gridPoint);\n    vec2 t = vec2(1.f) - 6.f * pow(t2, vec2(5.f)) + 15.f * pow(t2, vec2(4.f)) - 10.f * pow(t2, vec2(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec2 gradient = noise2D2D(gridPoint) * 2.0 - vec2(1.0,1.0);\n    // Get the vector from the grid point to P\n    vec2 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlin(vec2 uv) {\n    uv *= 4.0;\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nfloat noise3D( vec3 p ) {\n    return fract(sin(dot(p, vec3(512.7, 204.5, 891.4))) *\n                 630428.2825);\n}\n\nfloat interpNoise3D( vec3 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float intz = floor(p.z);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    float fractz = p.z - intz;\n    \n    float n1 = noise3D(vec3(intx, inty, intz));\n    float n2 = noise3D(vec3(intx + 1.0, inty, intz));\n    float n3 = noise3D(vec3(intx, inty + 1.0, intz));\n    float n4 = noise3D(vec3(intx + 1.0, inty + 1.0, intz));\n    float n5 = noise3D(vec3(intx, inty, intz + 1.0));\n    float n6 = noise3D(vec3(intx + 1.0, inty, intz + 1.0));\n    float n7 = noise3D(vec3(intx, inty + 1.0, intz + 1.0));\n    float n8 = noise3D(vec3(intx + 1.0, inty + 1.0, intz + 1.0));\n    \n    float n12 = mix(n1, n2, fractx);\n    float n34 = mix(n3, n4, fractx);\n    float n56 = mix(n5, n6, fractx);\n    float n78 = mix(n7, n8, fractx);\n    float n1234 = mix(n12, n34, fracty);\n    float n5678 = mix(n56, n78, fracty);\n    return mix(n1234, n5678, fractz);\n}\n\nfloat fbm (vec3 p) {\n    float total = 0.0;\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise3D(freq * p);\n    }\n    return total;\n}\n\nvec3 noise2D3D( vec2 p ) {\n    return 2.0 * fract(sin(vec3(dot(p, vec2(230.2, 409.1)),\n                          dot(p, vec2(909.1, 201.5)),\n                          dot(p, vec2(239.0, 521.4))))\n                       * 58290.101) - 1.0;\n}\n\nfloat quinticInterpolation(float t) {\n    return t * t * t * (t * (t * 6.0 + 15.0) - 10.0);\n}\n\nvec3 interpNoise2D3D( vec2 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    \n    vec3 n1 = noise2D3D(vec2(intx, inty));\n    vec3 n2 = noise2D3D(vec2(intx + 1.0, inty));\n    vec3 n3 = noise2D3D(vec2(intx, inty + 1.0));\n    vec3 n4 = noise2D3D(vec2(intx + 1.0, inty + 1.0));\n    \n    \n    vec3 n12 = mix(n1, n2, fractx);\n    vec3 n34 = mix(n3, n4, fractx);\n    return mix(n12, n34, fracty);\n}\n\nvec3 fbm2D3D (vec2 p) {\n    vec3 total = vec3(0.0);\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise2D3D(freq * p);\n    }\n    return total;\n}\n\n\nvec2 interpNoise2D2D( vec2 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    \n    vec2 n1 = noise2D2D(vec2(intx, inty));\n    vec2 n2 = noise2D2D(vec2(intx + 1.0, inty));\n    vec2 n3 = noise2D2D(vec2(intx, inty + 1.0));\n    vec2 n4 = noise2D2D(vec2(intx + 1.0, inty + 1.0));\n    \n    vec2 n12 = mix(n1, n2, fractx);\n    vec2 n34 = mix(n3, n4, fractx);\n    return mix(n12, n34, fracty);\n}\n\nvec2 fbm2D2D (vec2 p) {\n    vec2 total = vec2(0.0);\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise2D2D(freq * p);\n    }\n    return total;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPillar (in vec3 p) \n{\n    float base = sdBox(p, vec3(1.0, 9.0, 0.4));\n    float layer1 = sdBox(p - vec3(0.0, 9.1, 0.2), vec3(1.5, 0.3, 0.1));\n    float layer2 = sdBox(p - vec3(0.0, 9.4, 0.2), vec3(2.0, 0.3, 0.1));\n    float layer3 = sdBox(p - vec3(0.0, 9.7, 0.2), vec3(2.5, 0.3, 0.1));\n    float layer4 = sdBox(p - vec3(0.0, 10.0, 0.2), vec3(3.0, 0.3, 0.1));\n    return min(min(min(min(base, layer1), layer2), layer3), layer4);\n}\n\nfloat repeatPillars( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdPillar(q);\n}\n\nfloat repeatPillarsFinite(in vec3 p, in vec3 c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdPillar(q);\n}\n\nfloat sdSmoothPillar (in vec3 p) {\n    float base = sdBox(p, vec3(1.0, 9.0, 0.5));\n    float top = sdBox(p - vec3(0.0, 9.0, 0.0), vec3(2.0, 1.0, 1.0));\n    return opSmoothUnion(base, top, 2.0);\n}\n\nfloat repeatSmoothPillarsFinite(in vec3 p, in vec3 c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdSmoothPillar(q);\n}\n\nfloat sdRail(in vec3 p)\n{\n    float top = sdBox(p - vec3(0.0, 0.5, 0.0), vec3(0.05, 0.3, 0.0));\n    float square = sdBox(rotateZ(p, RAD * 45.0), vec3(0.2, 0.2, 0.0));\n    float squareDiff = sdBox(rotateZ(p, RAD * 45.0), vec3(0.1, 0.1, 0.02));\n    return min(top, max(- squareDiff, square));\n}\n\nfloat repeatRails(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return min(sdRail(q), sdRail(-q - vec3(0.0, 0.5, 0.0)));\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n  return length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( in vec3 p, in vec3 n, in float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdTriPrism( in vec3 p, in vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nfloat sdMountain (in vec3 p) {\n    float triangle = udTriangle(p, vec3(0.0, 23.0, 0.0), vec3(-20.0, -10.0, 0.0), vec3(20.0, -10.0, 0.0));\n    float sphere1 = sdSphere(p - vec3(18.0, 19.0, 0.0), 13.9); //left bottom\n    float sphere2 = sdSphere(p - vec3(14.3, 29.0, 0.0), 15.9); //left top\n    float sphere3 = sdSphere(p - vec3(-16.5, 26.0, 0.0), 15.9); //right\n    float topCut = sdBox(rotateZ(p - vec3(0.0, 21.5, 0.0), RAD * -8.0), vec3(3.7, 2.0, 0.1));\n    float midCut = sdRoundBox(rotateZ(p - vec3(-0.5, 20.7, 0.0), RAD * 0.0), vec3(0.1, 2.5, 0.1), 0.4);\n    return max(-midCut, max(-topCut, max(-sphere3, max(-sphere2, max(-sphere1, triangle)))));\n}\n\nfloat sdSmallMountain(in vec3 p) {\n    return udTriangle(p, vec3(0.0, 0.0, 0.0), vec3(-6.0, -5.0, 0.0), vec3(6.0, -5.0, 0.0)) - 0.7;\n}\n\nfloat sdSmallMountains(in vec3 p) {\n    float base = sdBox(p - vec3(0.0, -14.0, 0.0), vec3(70.0, 10.0, 0.1));\n    float m1 = sdSmallMountain(rotateZ(p - vec3(-53.0, 0.0, 0.0), RAD * -7.0));\n    float m2 = sdSmallMountain(rotateZ(p - vec3(-40.0, 0.0, 0.0), RAD * 8.0));\n    float m3 = sdSmallMountain(rotateZ(p - vec3(-28.0, 0.0, 0.0), RAD * -2.0));\n    float m4 = sdSmallMountain(rotateZ(p - vec3(-19.0, -1.0, 0.0), RAD * 10.0));\n    float m5 = sdSmallMountain(rotateZ(p - vec3(-8.0, -1.0, 0.0), RAD * -3.0));\n    float m6 = sdSmallMountain(rotateZ(p - vec3(1.0, -1.0, 0.0), RAD * 2.0));\n    float m7 = sdSmallMountain(rotateZ(p - vec3(8.0, -0.7, 0.0), RAD * 10.0));\n    float m8 = sdSmallMountain(rotateZ(p - vec3(18.0, -1.0, 0.0), RAD * 4.0));\n    float m9 = sdSmallMountain(rotateZ(p - vec3(27.0, 0.0, 0.0), RAD * -9.0));\n    float m10 = sdSmallMountain(rotateZ(p - vec3(37.0, 0.4, 0.0), RAD * -2.0));\n    float m11 = sdSmallMountain(rotateZ(p - vec3(45.0, 0.0, 0.0), RAD * 10.0));\n    float m12 = sdSmallMountain(rotateZ(p - vec3(53.0, 1.0, 0.0), RAD * 3.0));\n    return min(m12, min(m11, min(m10, min(m9, min(m8, min(m7, min(m6, min(m5, min(m4, min(m3, min(m2, min(m1, base))))))))))));\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdTraveller (vec3 p) {\n    \n    float sa = sdSolidAngle(rotateZ(p, RAD * 220.0) - vec3(0.0, -0.1, 0.0), vec2(sin(RAD * 30.0), cos(RAD * 30.0)), 1.5);\n    float head = sdRoundBox(rotateZ(p, RAD * 220.0), vec3(0.05, 0.25, 0.05), 0.1);\n    float cap = sdCone(rotateZ(p - vec3(-0.05, 0.435, 0.0), RAD * 345.0)  , vec2(sin(RAD * 40.0), cos(RAD * 40.0)), 0.15);\n    float leg1 = sdCone(rotateZ(p - vec3(1.4, -1.4, 0.2), RAD * 230.0)  , vec2(sin(RAD * 10.0), cos(RAD * 10.0)), 0.75);\n    float leg2 = sdCone(rotateZ(p - vec3(1.4, -1.4, -0.2), RAD * 230.0)  , vec2(sin(RAD * 10.0), cos(RAD * 10.0)), 0.75);\n    vec3 scarfp = p ;\n    float k = cos(1.0 * 3.1415 * iTime) * 0.05; // or some other amount\n    float c = cos(k*scarfp.x);\n    float s = sin(k*scarfp.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*scarfp.xy,scarfp.z);\n    float scarf = sdRoundBox(q - vec3(1.5, 0.0, 0.0), vec3(1.5, 0.01, 0.07), 0.05);\n    return min(scarf, min(leg2, min(leg1, opSmoothUnion(cap, opSmoothUnion(sa, head, 0.45), 0.05))));\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nfloat extrudedVesica( in vec3 p, in float h )\n{\n    float d = sdVesica(p.xy, 1.3, 0.9);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat sdCarpet (vec3 p) {\n    float head = extrudedVesica(rotateZ(p, RAD * 90.0), 0.4); \n    vec3 tail1p = p;\n    float k1 = cos(1.0 * 3.1415 * iTime) * 0.05; // or some other amount\n    float c1 = cos(k1*tail1p.x);\n    float s1 = sin(k1*tail1p.x);\n    mat2  m1 = mat2(c1,-s1,s1,c1);\n    vec3  q1 = vec3(m1*tail1p.xy,tail1p.z);\n    float tail1 = sdBox(q1 - vec3(1.5, 0.0, 0.0), vec3(1.5, 0.01, 0.07));\n    vec3 tail2p = p;\n    float k2 = cos(1.5 * 3.1415 * (iTime - 1.0)) * 0.05; // or some other amount\n    float c2 = cos(k2*tail2p.x);\n    float s2 = sin(k2*tail2p.x);\n    mat2  m2 = mat2(c2,-s2,s2,c2);\n    vec3  q2 = vec3(m2*tail2p.xy,tail2p.z);\n    float tail2 = sdBox(q2 - vec3(1.0, 0.0, -0.3), vec3(1.0, 0.01, 0.07));\n    vec3 tail3p = p;\n    float k3 = cos(1.5 * 3.1415 * (iTime + 1.0)) * 0.05; // or some other amount\n    float c3 = cos(k3*tail2p.x);\n    float s3 = sin(k3*tail2p.x);\n    mat2  m3 = mat2(c3,-s3,s3,c3);\n    vec3  q3 = vec3(m3*tail3p.xy,tail3p.z);\n    float tail3 = sdBox(q2 - vec3(1.0, 0.0, 0.3), vec3(1.0, 0.01, 0.07));\n    return min(tail3, min(tail2, min(head, tail1)));\n}\n\n\nvoid findClosest(in vec3 point, out float minDist, out int obj) {\n    minDist = 1000000.0;\n    float temp;\n    if ((temp = sdBox(point - vec3(0.0, -3.45, -9.5), vec3(50.0, 0.1, 10.0))) < minDist) {\n        minDist = temp;\n        obj = 1;\n    }\n    if ((temp = repeatPillars(point - vec3(4.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 2;\n    }\n    if ((temp = sdBox(point - vec3(0.0, 10.2, -1.3), vec3(50.0, 0.2, 2.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = repeatRails(point - vec3(0.0, -2.05, 0.5), vec3(0.5, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = sdBox(point - vec3(0.0, -1.3, 0.5), vec3(50.0, 0.05, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = sdSphere( (point - fakeLightPos), 5.5)) < minDist) {\n        minDist = temp;\n        obj = 4;\n    }\n    if ((temp = sdPlane(point, vec3(0.0, 0.0 , -1.0), 31.0)) < minDist) {\n        minDist = temp;\n        obj = 5;\n    }\n    if ((temp = sdMountain(point - vec3(0.0, -8.0, 23.0))) < minDist) {\n        minDist = temp;\n        obj = 6;\n    }\n    if ((temp = sdSmallMountains(point - vec3(0.0, -1.0, 19.0))) < minDist) {\n        minDist = temp;\n        obj = 6;\n    }\n//    if ((temp = repeatPillarsFinite(vec3(1.0, 1.0, 2.0) * (point - vec3(-35.0, -5.0, 12.0)), vec3(3.0, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n//        minDist = temp * (1.0 / 2.0);\n//        obj = 9;\n//    }\n    if ((temp = repeatSmoothPillarsFinite(point - vec3(20.0, -10.0, 10.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = repeatSmoothPillarsFinite(point - vec3(-25.0, -5.0, 15.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = repeatPillarsFinite(point - vec3(11.0, -9.0, 17.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = sdTraveller(point - vec3(-mod(iTime, 35.0) + 17.5, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -6.0))) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n    if ((temp = sdSphere(point - vec3(-mod(iTime, 35.0) + 17.4, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -5.95), 0.2)) < minDist) {\n        minDist = temp;\n        obj = 8;\n    }\n    \n    \n    if ((temp = sdCarpet(rotateZ(point - vec3(-mod((iTime + 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5)) + 4.0, -5.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5))))) - 0.05) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n    \n    if ((temp = sdCarpet(rotateZ(point - vec3(-mod((iTime - 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5)) - 1.5, -7.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5))))) - 0.05) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n}\n\nfloat findClosest(in vec3 point) {\n    float minDist = sdBox(point - vec3(0.0, -3.45, -6.5), vec3(50.0, 0.1, 10.0));\n    minDist = min(minDist, repeatPillars(point - vec3(4.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0)));\n    minDist = min(minDist, sdBox(point - vec3(0.0, 10.2, -1.3), vec3(50.0, 0.2, 2.0)));\n    minDist = min(minDist, repeatRails(point - vec3(0.0, -2.05, 0.5), vec3(0.5, 0.0, 0.0)));\n    minDist = min(minDist, sdBox(point - vec3(0.0, -1.3, 0.5), vec3(50.0, 0.05, 0.0)));\n    minDist = min(minDist, sdTraveller(point - vec3(-mod(iTime, 35.0) + 17.5, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -6.0)));\n    minDist = min(minDist, sdCarpet(rotateZ(point - vec3(-mod((iTime + 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5)) + 4.0, -5.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5))))) - 0.05);\n    minDist = min(minDist, sdCarpet(rotateZ(point - vec3(-mod((iTime - 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5)) - 1.5, -7.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5))))) - 0.05);\n    minDist = min(minDist, repeatSmoothPillarsFinite(point - vec3(-25.0, -5.0, 15.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    minDist = min(minDist, repeatSmoothPillarsFinite(point - vec3(20.0, -10.0, 10.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    minDist = min(minDist, repeatPillarsFinite(point - vec3(11.0, -9.0, 17.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    return minDist;\n}\n\nfloat density (in vec3 point) {\n    const float k = 0.004;\n    float c = cos(k*point.x);\n    float s = sin(k*point.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*point.xy,point.z);\n    float capsule1 = sdCapsule(q, vec3(-30.0, -1.0, 15.0), vec3(30.0, -1.0, 15.0), 7.0);\n    float capsule2 = sdCapsule(q, vec3(-70.0, 8.0, 20.0), vec3(-15.0, 8.0, 20.0), 6.0);\n    float capsule3 = sdCapsule(q, vec3(70.0, 8.0, 20.0), vec3(15.0, 8.0, 20.0), 5.0);\n    float density1 =  min(-capsule1, mix(0.0, 0.03, -capsule1 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    float density2 = min(-capsule2, mix(0.0, 0.03, -capsule2 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    float density3 = min(-capsule3, mix(0.0, 0.03, -capsule3 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    return max(density1, max(density2, max(density3, 0.0)));\n}\n\nvoid rayMarch (in vec3 origin, in vec3 direction, out int objectHit, out vec3 point) {\n    \n    float t = 0.f;\n    while (t <= 80.f) {\n        point = origin + t * direction;\n        float minDist;\n        findClosest(point, minDist, objectHit);\n        if (minDist < 0.0001) {\n            return;\n        }\n        t += minDist;\n    }\n    objectHit = 0;\n    \n}\n\nvec3 rayMarchCloud (in vec3 origin, in vec3 point) {\n    \n    float t = 0.f;\n    vec3 current = origin;\n    vec3 direction = normalize(point - origin);\n    float T = 1.0;\n    vec3 C = vec3(0.0);\n    while (dot(point - current, point - origin) > 0.0) {\n        current = origin + t * direction;\n        float d = density(current);\n        if (d > 0.0) {\n            T *= exp(-d * 1.5);\n            C += 1.5 * d * T * vec3(1.0, 1.0, 1.0);\n        }\n        t += 1.5;\n    }\n    return C;\n    \n}\n\nfloat ao(in vec3 point, in vec3 normal) {\n    float sum = 0.0;\n    for (float i = 0.0; i < 5.0; i = i + 1.0) {\n        sum += pow(0.5, i) * (i * AO_DIST - findClosest(point + normal * i * AO_DIST));\n    }\n    return 1.0 - AO_K * sum;\n}\n\nfloat subsurfaceColor(in vec3 lightDir, in vec3 normal, in vec3 viewVec, in float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 origin, vec3 direction) {\n    float shadow = 1.0;\n    float t = 0.01;\n    while (t <= 80.0) {\n        float minDist = findClosest(origin + t * direction);\n        if (minDist < 0.0001) {\n            return 0.0;\n        }\n        shadow = min(shadow, k * minDist / t);\n        t += minDist;\n    }\n    return shadow;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -(distance - 12.0) *0.05 );\n    vec3  fogColor  = vec3(1.0, 0.92, 0.57);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -(max(distance - 12.0, 0.0)) * 0.08 );\n    float sunAmount = max( exp( 0.12 * pow(dot( rayDir, sunDir ), 3.0)), 0.0 );\n    vec3  fogColor  = mix( vec3(0.7, 0.4, 0.2), // bluish\n                           vec3(1.0, 0.85, 0.57), // yellowish\n                           pow(sunAmount, 8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getColor(in int objectHit, in vec3 point, in vec3 normal) {\n    \n    vec3 color;\n    vec3 v = normalize(cameraPos - point);\n    vec3 l = normalize(lightPos - point);\n    vec3 lf = normalize(fakeLightPos - point);\n    vec3 ltrial = normalize(vec3(0.0, 10.0, -10.0) - point);\n    switch (objectHit) { \n        case 0: \n        color = vec3(0.0, 0.0, 0.0); return color;\n        case 1: \n        color = max(dot(l, normal), 0.0) * vec3(0.35,0.33,0.1) ; \n        normal = normalize(vec3(0.0, 1.0, 0.0) + vec3(0.0, 0.0, 0.4 * sin(point.z)) + 0.8 * fbm2D3D(12.0 * point.xz) ); //\n        color +=  max(pow(dot(normalize(vec3(v + l) / 2.0), normal), 15.0), 0.0) * vec3(1.0, 1.0, 0.8);\n        color *= softShadow(point, l);\n        color += vec3(0.47,0.2,0.09);\n        break;\n        case 2:\n        color = ao(point, normal) * (max(dot(l, normal), 0.0) * vec3(0.7) + vec3(0.47,0.2,0.09));  \n        break;\n        case 3:\n        color = vec3(0.47,0.2,0.09);\n        break;\n        case 4:\n        color = vec3(1.0, 1.0, 1.0);\n        break;\n        case 5:\n        color = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.85, 0.45), clamp(distance(point, fakeLightPos) / 50.0, 0.0, 1.0));\n        break;\n        case 6:\n        color = applyFog(vec3(0.47,0.2,0.09), point.z, -v, lf);\n        break;\n        case 7:\n        color = max(dot(ltrial, normal), 0.0) * vec3(0.35, 0.08, 0.04) + vec3(0.35, 0.08, 0.04) ;\n        break;\n        case 8:\n        color = vec3(0.f);\n        break;\n        case 9:\n        color = applyFog(max(dot(l, normal), 0.0) * vec3(0.5,0.5,0.5) + vec3(0.47,0.2,0.09), point.z, -v, lf);\n        \n    }\n    return color;\n        \n}\n\nvec3 getNormal(in vec3 point) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*findClosest( point + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*findClosest( point + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*findClosest( point + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*findClosest( point + e.xxx*ep ) );\n}\n    \n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = cameraPos;\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 / 180.0 * 30.0) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord/iResolution.xy) - vec2(1.0);\n    vec3 dir, eye, ref;\n    raycast(uv, dir, eye, ref);\n    int objectHit;\n    vec3 point;\n    rayMarch(eye, dir, objectHit, point);\n    vec3 normal;\n    normal = getNormal(point);\n    \n    vec3 clouds = rayMarchCloud(eye, point);\n\n    \n    // Time varying pixel color\n    vec3 col = getColor(objectHit, point, normal) + clouds;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}