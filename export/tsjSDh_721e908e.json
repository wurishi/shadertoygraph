{"ver":"0.1","info":{"id":"tsjSDh","date":"1553679444","viewed":261,"name":"XZ Plane folding spheres","username":"edo_m18","description":"XZ Plane folding spheres.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sphere","folding","xzplane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS (1e-3)\n#define OFFSET (1e-2)\n\nconst float maxdist = 100.0;\nconst vec3 light = normalize(vec3(0.5, 0.5, 0.5));\nconst vec3 amblight = vec3(0.15);\nconst float softShadow = 32.0;\n\nfloat clamp01(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat dist_sphere(in vec3 p, in vec3 offset, float size)\n{\n    return length(p + offset) - size;\n}\n\nfloat dist_plane(in vec3 p)\n{\n    const vec4 n = vec4(normalize(vec3(0, 1.0, 0)), 1.0);\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat dist_func(in vec3 p)\n{\n    vec3 q = p;\n    q.x = mod(q.x, 4.0) - 2.0;\n    q.z = mod(q.z, 8.0) - 4.0;\n    float d1 = dist_plane(p);\n    float d2 = dist_sphere(q, vec3(0), 1.0);\n    float d3 = dist_sphere(p, vec3(0, -4.0, 0), 2.0);\n    return min(d1, min(d2, d3));\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const vec2 d = vec2(0.001, 0.0);\n    \n    return normalize(vec3(dist_func(p + d.xyy) - dist_func(p - d.xyy),\n                          dist_func(p + d.yxy) - dist_func(p - d.yxy),\n                          dist_func(p + d.yyx) - dist_func(p - d.yyx)));\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    const vec3 up = vec3(0, 1.0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat genShadow(vec3 ro, vec3 rd)\n{\n    float d = 0.0;\n    \n    float c = 0.001;\n    \n    float r = 1.0;\n    \n    float shadowCoef = 0.5;\n    \n    for (int i = 0; i < 50; i++)\n    {\n        d = dist_func(ro + rd * c);\n        \n        if (d < EPS)\n        {\n            return shadowCoef;\n        }\n        \n        r = min(r, d * softShadow / c);\n        \n        c += d;\n    }\n    \n    return 1.0 - shadowCoef + (r * shadowCoef);\n}\n\n// +-----------------+--------------------+\n// | ro = Ray Origin | rd = Ray Direction |\n// +-----------------+--------------------+\nvec4 genAmbientOcculusion(vec3 ro, vec3 rd)\n{\n    vec4 totalAO = vec4(0.0);\n    float scale = 1.0;\n    \n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = 0.01 + (0.02 * float(aoi * aoi));\n        vec3 aopos = ro + rd * hr;\n        \n        float dd = dist_func(aopos);\n        float ao = clamp01(-(dd - hr));\n        totalAO += ao * scale * vec4(1.0, 1.0, 1.0, 1.0);\n        scale *= 0.75;\n    }\n    \n    const float aoCoef = 2.0;\n    totalAO.w = 1.0 - clamp01(aoCoef * totalAO.w);\n    \n    return totalAO;\n}\n\nvec3 getRayColor(in vec3 origin, in vec3 ray, in vec2 uv, out vec3 p, out vec3 normal, out bool hit)\n{    \n    float depth = 0.0;\n    float d = 0.0;\n    \n    const int count = 500;\n    \n    for (int i = 0; i < count; i++)\n    {\n        p = origin + ray * depth;\n        \n        d = dist_func(p);\n        \n        if (d < EPS)\n        {\n            break;\n        }\n        \n        depth += d;\n    }\n    \n    vec3 col = vec3(1.0);\n    \n    if (d < EPS)\n    {\n        normal = getNormal(p);\n        \n        vec3 r = reflect(ray, normal);\n        vec4 tex = texture(iChannel0, r);\n        float diff = dot(normal, light);\n        \n        float shadow = genShadow(p + normal * EPS, light);\n        vec4 ao = genAmbientOcculusion(p + normal * EPS, normal);\n        \n        vec3 hl = normalize(-ray + light);\n        float spec = pow(clamp01(dot(hl, normal)), 40.0);\n        \n        col *= (diff * tex.xyz * shadow) + amblight + spec;\n        col -= ao.rgb * ao.w;\n        \n        hit = true;\n    }\n    else\n    {\n        vec4 tex = texture(iChannel0, ray);\n        //vec3 sky = mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), uv.y + 0.75);\n        col = tex.xyz;\n        hit = false;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float sp = iTime * 0.5;\n    float camDist = 10.0;\n    \n    float d = 1.0;\n    float coef = 2.0;\n    float k = 2.0 * (exp(coef * sin(sp)) / exp(coef));\n    \n    float x = sin(sp) * camDist + d;\n    float y = k * camDist + d;\n    float z = cos(sp) * camDist + d;\n    \n    vec3 ro = vec3(x, y, z);\n    vec3 ta = vec3(0, 4.0, 0);\n    \n    mat3 c = camera(ro, ta);\n    \n    vec3 ray = c * normalize(vec3(uv, 1.75));\n    \n    vec3 p = ro;\n    \n    vec3 q, normal;\n    bool hit;\n    float alpha = 1.0;\n    \n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++)\n    {\n        col += getRayColor(p, ray, uv, q, normal, hit) * alpha;\n        \n        if (!hit)\n        {\n            break;\n        }\n        \n        alpha *= 0.3;\n        \n        ray = normalize(reflect(ray, normal));\n        \n        p = q + normal * OFFSET;\n    }\n    \n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}