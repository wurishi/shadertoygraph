{"ver":"0.1","info":{"id":"mdcXD2","date":"1681148478","viewed":28,"name":"polytesterr","username":"DLord","description":"Triangle perspective raycast, unfair distance coloring","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangleraycastperspectivepolygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi=3.1415926535897932384626433832795;\nconst vec4 sky=vec4(0.5,0.5,0.5,1.);\nstruct Ray{\nvec3 s;\nvec3 d;\n};\nstruct Triangle{\nvec4 p;//plane\nvec4 f;//first\nvec4 s;//second\nvec4 t;//third\nvec4 c;//color\n};\nfloat fm(in float x,in float m){return floor(x/m)*m;}\nvec2 fm(in vec2 x,in float m){return floor(x/m)*m;}\nvec3 fm(in vec3 x,in float m){return floor(x/m)*m;}\nvec4 fm(in vec4 x,in float m){return floor(x/m)*m;}\nvec2 rotNorming(in vec2 r){\nreturn vec2(abs(mod(r.x+pi,2.*pi)-pi),mod(r.y,2.*pi));\n}\nfloat oRotNorming(in float o){\nreturn abs(mod(o+pi,2.*pi)-pi);\n}\nfloat fRotNorming(in float f){\nreturn mod(f,2.*pi);\n}\nRay getRay(in vec3 start, in vec2 rot, float fov, in vec2 screen){\n//rot=(pi/2,0)\n    vec3 oncam=vec3(fov,screen.yx);\n    oncam=oncam.xzy;\n    float r=sqrt(dot(oncam,oncam));\n    float o=acos(oncam.z/r);\n    float f=sign(oncam.y)*acos(oncam.x/sqrt(dot(oncam.xy,oncam.xy)));\n    o+=rot.x-(pi/2.);\n    f+=rot.y;\n    o=oRotNorming(o);\n    f=fRotNorming(f);\n    vec3 rv=vec3(sin(o)*cos(f),sin(o)*sin(f),cos(o)); \n    //rv*=r;dont use if you want make lenght one\n    return Ray(start,rv.xzy);\n}\n\nvec2 gameRotToSphereRot(vec2 rot){return vec2(pi/2.-rot.x,rot.y);}\nvec2 SphereRotTogameRot(vec2 rot){return vec2(pi/2.-rot.x,rot.y);}\nvec4 pointsToPlane(in vec3 p1, in vec3 p2, in vec3 p3){\n    vec3 d1=p1-p3;\n    vec3 d2=p2-p3;\n    vec3 c=cross(d1,d2);\n    float d=-dot(p3,c);\n    return vec4(c,d);\n}\nTriangle pointsToTriangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec4 color){\n    vec3 d1=p1-p3;\n    vec3 d2=p2-p3;\n    vec3 pc=cross(d1,d2);\n    vec3 fc=cross(pc,(p3-p2));\n    vec3 sc=cross(pc,(p1-p3));\n    vec3 tc=cross(pc,(p2-p1));\n    return Triangle(vec4(pc,-dot(p3,pc)),vec4(fc,-dot(p3,fc)),vec4(sc,-dot(p1,sc)),vec4(tc,-dot(p2,tc)),color);\n}\nvec4 caster(in Ray ray,in Triangle tr){\nfloat k=dot(ray.d,tr.p.xyz);\nif(k==0.){return sky;}\nfloat t= -(dot(tr.p.xyz,ray.s)+tr.p.w)/k;\nif(t<=0.){return sky;}\nvec3 i=ray.s+(t*ray.d);\n\nif(dot(tr.f.xyz,i)+tr.f.w<0.){return sky;}\nif(dot(tr.s.xyz,i)+tr.s.w<0.){return sky;}\nif(dot(tr.t.xyz,i)+tr.t.w<0.){return sky;}\nreturn tr.c/sqrt(t+1.);\n}\nfloat angleFovToDistanceFov(in float x){\nreturn 1./tan(x/2.);\n}\nfloat angleDegFovToDistanceFov(in float x){\nreturn angleFovToDistanceFov(x*pi/180.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov=angleDegFovToDistanceFov(90.);\n    vec3 p1=vec3(2.,0.,0.);\n    vec3 p2=vec3(3.,0.,3.);\n    vec3 p3=vec3(4.,1.,0.);\n    vec4 color=vec4(0.,1.,0.,1.);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=2.;\n    uv-=1.;\n    vec2 timerot=0.19*vec2(pi*sin(iTime*0.86472),pi*sin(iTime*0.2313));\n    //vec2 timerot=vec2(iTime,0.);\n    vec2 rot=vec2(0.,0.);rot+=timerot;\n    rot=(iMouse.xy / iResolution.xy).yx*2.-1.;\n    //if(distance(mod(rot+pi,2.*pi)-pi,uv.yx*pi)<0.03){    fragColor=vec4(1.,0.,0.,1.);return;}\n    rot=gameRotToSphereRot(rot);\n    Ray r=getRay(vec3(0.),rot,fov,uv);\n    Triangle tr=pointsToTriangle(p1,p2,p3,color);\n    vec4 col = 0.5 + 0.5*cos(iTime+uv.xyxy+vec4(1,0,2,4));\n    col=caster(r,tr);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}