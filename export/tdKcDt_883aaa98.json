{"ver":"0.1","info":{"id":"tdKcDt","date":"1604081525","viewed":412,"name":"DistoLines","username":"Kaeylos","description":"#9 distortion\nmade during the Ink-MAC-tober 2020","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distortion","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n#define AA_SAMPLES 2 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 200\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n#define FBM_MAX_ITER 10\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t)/(2.*s*s)); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nfloat distanceField(vec3 p) {\n    float final = perlinNoise(p*0.06125) -0.5;\n    float other = perlinNoise(p*0.06125 + 1234.567) - 0.5;\n    final = 1./(abs(final*final*other));\n    return final*0.0001;\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\n// return dist, marchingCount, maxDist\nvec3 rayMarching(vec3 O, vec3 D, int steps, inout float density) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \tfloat maxD = 1.e-10;\n    for(int i = 0; i < steps; i++) {\n    \tif( i > MAX_STEPS) break;\n    \tvec3 newPos = O + D * t;\n        float d = distanceField(newPos);\n        \n        // custom incrementation here for this sketch\n        t += 3.; // precision handling\n        density += d*0.01;\n        ++marchingCount;\n        maxD = max(maxD, d);\n        \n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n    }\n    return vec3(t, marchingCount, maxD);\n}\n\nfloat densityMarching(vec3 O, vec3 D) {\n\tfloat density = 0.;\n    // ray marching\n\tint steps = 12;\n    float t = 0.0;\n    for(int i = 0; i < steps; i++) {\n    \tif( i > MAX_STEPS) break;\n    \tvec3 newPos = O + D * t;\n        float d = distanceField(newPos + 12.);\n        \n        // custom incrementation here for this sketch\n        t += 3.; // precision handling\n        density += d*0.01;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n    }\n    return density;\n}\n\nvec3 render(vec3 O, vec3 D) {\n\tvec3 cyan = vec3(25., 80., 122.)/255.;\n    vec3 blue = vec3(21., 71., 199.)/255.;\n    vec3 orange = vec3(255., 184., 113.)/255.;\n    \n    float density =  densityMarching(O, D);\n    \n\tvec3 col = blue*0.1;\n\tcol += pow(density, 0.45)*orange*0.5;\n\tcol += gauss(density*2., 0.1) * cyan * 0.2;\n\treturn saturate(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 2.; // zoom\n    float delay = 12.; // loop delay in s\n\tfloat a = 2.*PI*iTime/delay; // angle\n\tfloat r = 3.; // radius\n\tfloat y = sin(a + 12.)*0.5;\n\tvec3 O = vec3(r*cos(a), y, r*sin(a)); // origin\n\t\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.0; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.0; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // color grading\n    finalColor *= vec3(1.0 ,0.9, 0.98) *1.2;\n    \n\tfragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}