{"ver":"0.1","info":{"id":"mtsBzr","date":"1692556054","viewed":116,"name":"neon cirles ","username":"nayk","description":"connecting two shaders","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["neoncirlescolorfulrotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/dtsBzn https://www.shadertoy.com/view/DlSyzc   */\n\n\n\n#define TWO_PI              6.28318530718\n#define r(A)                mat2(cos(A), -sin(A), sin(A), cos(A))\n\n\nvec3 palette(vec2 uv, float i) {\n    float t = length(uv) + i * 0.5 - iTime * 0.5;\n\n    vec3 a = vec3(0.468, 0.358, 0.5);\n    vec3 b = vec3(0.448, 0.218, 0.388);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.002, 0.168, 0.498);\n\n    return a + b * cos(TWO_PI * (c * t + d));\n}\n\nvec3 palette(float d) {\n    vec3 neonGreen = vec3(1.2, 1.0, 0.4)*sin(iTime); // Neon Green\n    vec3 darkerGreen = vec3(0.1, 0.3, 0.1)*sin(iTime); // Darker Green\n    return mix(neonGreen, darkerGreen, d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.2;\n    for (int i = 0; i < 15; ++i) {\n        float t = angle+cos(iTime);\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 0.89);\n        p.xz = abs(p.xz);\n        \n       \n          p.xyz-= 0.5;\n    }\n    \n    float durian = length(p.xy) - 0.2; // Create a circular durian shape\n    \n    return durian;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\nfloat circle(vec2 uv, vec2 center, float r)\n{\n    float brightness = 0.008;\n    float l = length(uv + center);\n\n    return brightness / abs(sin(l - r));\n}\n\nfloat shape(vec2 uv, float size)\n{\n    float mask = 0.2;\n    float time = iTime * 0.13;\n\n    const float sides = 10.0;\n\n    for (float i = 0.0; i < sides; i++) {\n        uv *= r(TWO_PI / sides);\n        vec3 ro = vec3(0.0, 0.0, -50.0);\n    ro.xz = rotate(ro.xz, iTime);\n      ro.yz = rotate(ro.zx, iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 1.0 + uv.x * cs + uv.y * cu*cos(iTime);\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n        vec2 uvOrig = uv;\n\n        mask += circle(uv, vec2(uv.x, uv.y + size * 1.0), size * 1.0);\n        uv = -(uvOrig * r(-2.65 * time))+col.xy;\n        \n    }\n\n    return mask;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = shape(uv, 0.9) * palette(uv, 0.0);\n\n\n    vec3 ro = vec3(0.0, 0.0, -50.0);\n    ro.xz = rotate(ro.xz, iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    fragColor = vec4(color, 1.0);\n    fragColor+= col;\n}\n","name":"Image","description":"","type":"image"}]}