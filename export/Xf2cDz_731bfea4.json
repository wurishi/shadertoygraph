{"ver":"0.1","info":{"id":"Xf2cDz","date":"1722178119","viewed":93,"name":"Deadpool + Wolverine","username":"dechichi","description":"Got inspired by the new move and decided to make this using raymarching.\n   Ended up being a fun challenge, and I had to use several sd functions and operations.\n   Getting Wolverine \"eye frame\" was particularly challenging.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","deadpool","wolverine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \"Deadpool + Wolverine - https://www.shadertoy.com/view/Xf2cDz\n\n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n   Got inspired by the new move and decided to make this using raymarching.\n   Ended up being a fun challenge, and I had to use several sd functions and operations.\n   Getting Wolverine \"eye frame\" was particularly challenging.\n\n   Thanks to Inigo Quilez for the distance functions and the amazing educational content.\n   https://iquilezles.org/articles/distfunctions/\n\n   Inspiration:\n   - https://www.shadertoy.com/view/4dcfz7\n   - https://www.pinterest.com/pin/deadpool-x-wolverine-logo-png-in-2024--1006413847967142752/\n*/\n\nvec3 background(vec2 uv, vec3 col1, vec3 col2) {\n    uv = rotate2d(uv, PI * 0.25);\n\n    vec2 uvx = mod(uv * 150.0, vec2(4.0, 8.0)) - vec2(2.0, 2.0);\n    vec2 uvy = mod(uv * 150.0 + vec2(2.0, 4.0), vec2(4.0, 8.0)) - vec2(2.0, 2.0);\n    float cx = rectangle(uvx, vec2(1.0, 1.5));\n    float cy = rectangle(uvy, vec2(1.5, 1.0));\n\n    float factor = cx + cy;\n\n    vec3 col = mix(col1, col2, factor);\n    float vignetteRadius = 0.4;\n    float vignette = min(1.0 - length(uv) + vignetteRadius, 1.0);\n    return col * vignette;\n}\n\nvec3 calculateLighting(vec3 color, vec3 normal, vec3 viewDir)\n{\n    vec3 lightDir = normalize(vec3(0.4, -0.7, -1.0));\n\n    //diffuse\n    float diffuseFactor = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = vec3(diffuseFactor) * color;\n\n    //specular\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specularStrength = 1.;\n    float shininess = 82.0;\n    float specFactor = pow(max(dot(normal, halfDir), 0.0), shininess);\n    vec3 specular = specularStrength * specFactor * vec3(1.0); // White specular highlight\n\n    //ambient\n    vec3 ambientLight = vec3(0.2, 0.1, 0.1);\n    float ambFactor = 0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0));\n    vec3 ambient = ambientLight * ambFactor;\n\n    return diffuse + specular + ambient;\n}\n\nRaymarchResult logoBase(vec3 p, vec3 innerCol, vec3 outerCol) {\n    RaymarchResult r;\n    float outerCylinder = sdCylinderZ(p, 0.15, 1.2);\n    float outerCylinderHole = sdCylinderZ(p, 0.4, 1.0);\n    outerCylinder = opSubtraction(outerCylinder, outerCylinderHole);\n\n    float outerBox = sdBox(p, vec3(0.15, 1.20 - 0.01, 0.15));\n    outerCylinder = opUnion(outerBox, outerCylinder);\n\n    float innerCylinder = sdCylinderZ(p, 0.10, 1.0);\n\n    if (outerCylinder < innerCylinder) {\n        r.distance = outerCylinder;\n        r.color = outerCol;\n    } else {\n        r.distance = innerCylinder;\n        r.color = innerCol;\n    }\n    return r;\n}\n\nRaymarchResult eyeWolverine(vec3 p, float mult) {\n    RaymarchResult r;\n    p.xy -= vec2(0.58 * mult, 0.1);\n    p.xy = rotate2d(p.xy, PI * 0.75 * mult);\n    r.distance = sdTriPrismZ(vec3(p.x / 1.7, p.y * 1.2, p.z), vec2(0.21, 0.17));\n    r.color = vec3(1.0);\n    return r;\n}\n\nRaymarchResult eyeFrame(vec3 p, float sign) {\n    vec2 baseOffset = vec2(0.9 * sign, 0.45);\n    vec3 p1 = p;\n    p1.xy -= baseOffset;\n    p1.xy = rotate2d(p1.xy, -PI * 1.75 * sign);\n    float tri1 = sdRhombus(p1, 0.99, 0.35, 0.12, 0.06);\n\n    vec3 p2 = p;\n    p2.xy -= baseOffset + vec2(0.09 * sign, 0.1);\n    p2.xy = rotate2d(p2.xy, -PI * 1.78 * sign);\n    float tri2 = sdRhombus(p2, 1.0, 0.4, 0.12, 0.06);\n\n    tri1 = opSmoothUnion(tri1, tri2, 0.15);\n    RaymarchResult r;\n    r.distance = tri1;\n    r.color = vec3(0.1);\n    return r;\n}\n\nRaymarchResult raymarchWolverine(vec3 p) {\n    p = rotateY(p, iTime);\n    RaymarchResult r = logoBase(p, vec3(.7, .7, 0.0), vec3(0.9, 0.9, 0.1));\n\n    RaymarchResult eyeRight = eyeWolverine(p, 1.);\n    RaymarchResult eyeLeft = eyeWolverine(p, -1.);\n\n    if (eyeRight.distance < r.distance) {\n        r = eyeRight;\n    }\n    if (eyeLeft.distance < r.distance) {\n        r = eyeLeft;\n    }\n\n    RaymarchResult eyeFrameRight = eyeFrame(p, 1.);\n    RaymarchResult eyeFrameLeft = eyeFrame(p, -1.);\n\n    if (eyeFrameRight.distance < r.distance) {\n        r = eyeFrameRight;\n    }\n    if (eyeFrameLeft.distance < r.distance) {\n        r = eyeFrameLeft;\n    }\n\n    float minusBox = sdBox(p + vec3(10.0, 0.0, 0.0), vec3(10., 10., 3.));\n    r.distance = opSubtraction(r.distance, minusBox);\n\n    return r;\n}\n\nRaymarchResult eyeDeadpool(vec3 p, float mult) {\n    RaymarchResult r;\n\n    p.xy += vec2(-0.55 * mult, -0.1);\n    p.x /= 1.2;\n    p.y /= 1.1;\n\n    float eye = sdCylinderZ(p, 0.15, 0.2);\n\n    p.xy += vec2(0.22 * mult, -0.2);\n    eye = opSubtraction(eye, sdCylinderZ(p, 0.72, 0.3));\n\n    r.distance = eye;\n    r.color = vec3(1.0);\n    return r;\n}\n\nRaymarchResult raymarchDeadpool(vec3 p) {\n    RaymarchResult r;\n    p = rotateY(p, iTime);\n    float outerCylinder = sdCylinderZ(p, 0.15, 1.2);\n    float outerCylinderHole = sdCylinderZ(p, 0.4, 1.0);\n    outerCylinder = opSubtraction(outerCylinder, outerCylinderHole);\n\n    float outerBox = sdBox(p, vec3(0.15, 1.20 - 0.01, 0.15));\n    outerCylinder = opUnion(outerBox, outerCylinder);\n\n    float innerCylinder = sdCylinderZ(p, 0.10, 1.0);\n\n    if (outerCylinder < innerCylinder) {\n        r.distance = outerCylinder;\n        r.color = vec3(0.7, 0.1, 0.1);\n    } else {\n        r.color = vec3(0.12);\n        r.distance = innerCylinder;\n    }\n\n    RaymarchResult eyeRight = eyeDeadpool(p, 1.);\n    RaymarchResult eyeLeft = eyeDeadpool(p, -1.);\n\n    if (eyeRight.distance < r.distance) {\n        r = eyeRight;\n    }\n    if (eyeLeft.distance < r.distance) {\n        r = eyeLeft;\n    }\n\n    float minusBox = sdBox(p - vec3(10.0, 0.0, 0.0), vec3(10., 10., 3.));\n    r.distance = opSubtraction(r.distance, minusBox);\n\n    return r;\n}\n\nvec3 normalsDeadpool(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = EPSILON;\n    return normalize(e.xyy * raymarchDeadpool(pos + e.xyy * eps).distance +\n            e.yyx * raymarchDeadpool(pos + e.yyx * eps).distance +\n            e.yxy * raymarchDeadpool(pos + e.yxy * eps).distance +\n            e.xxx * raymarchDeadpool(pos + e.xxx * eps).distance);\n}\n\nvec3 normalsWolverine(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = EPSILON;\n    return normalize(e.xyy * raymarchWolverine(pos + e.xyy * eps).distance +\n            e.yyx * raymarchWolverine(pos + e.yyx * eps).distance +\n            e.yxy * raymarchWolverine(pos + e.yxy * eps).distance +\n            e.xxx * raymarchWolverine(pos + e.xxx * eps).distance);\n}\n\nRaymarchResult logoDeadpool(in vec3 ro, in vec3 rd)\n{\n    RaymarchResult r;\n    float t = 0.;\n    for (int i = 0; i < MAX_RM_IT; i++) {\n        vec3 p = ro + rd * t;\n        r = raymarchDeadpool(p);\n        t += r.distance;\n        if (r.distance < MIN_RM_DISTANCE) break;\n        if (t > MAX_RM_DISTANCE) break;\n    }\n\n    if (t < MAX_RM_DISTANCE) {\n        vec3 pos = ro + rd * t;\n        vec3 normal = normalsDeadpool(pos);\n        vec3 viewDir = normalize(ro - pos);\n        r.color = calculateLighting(r.color, normal, viewDir);\n    }\n\n    r.distance = t;\n    return r;\n}\n\nRaymarchResult logoWolverine(in vec3 ro, in vec3 rd)\n{\n    RaymarchResult r;\n    float t = 0.;\n    for (int i = 0; i < MAX_RM_IT; i++) {\n        vec3 p = ro + rd * t;\n        r = raymarchWolverine(p);\n        t += r.distance;\n        if (r.distance < MIN_RM_DISTANCE) break;\n        if (t > MAX_RM_DISTANCE) break;\n    }\n\n    if (t < MAX_RM_DISTANCE) {\n        vec3 pos = ro + rd * t;\n        vec3 normal = normalsWolverine(pos);\n        vec3 viewDir = normalize(ro - pos);\n        r.color = calculateLighting(r.color, normal, viewDir);\n    }\n\n    r.distance = t;\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -3.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    vec3 color = vec3(0.);\n    float t = MAX_RM_DISTANCE;\n\n    RaymarchResult lDeadpool = logoDeadpool(ro, rd);\n    RaymarchResult lWolverine = logoWolverine(ro, rd);\n    if (lDeadpool.distance < lWolverine.distance) {\n        color = lDeadpool.color;\n        t = lDeadpool.distance;\n    } else {\n        color = lWolverine.color;\n        t = lWolverine.distance;\n    }\n\n    vec3 bgDeadpool = background(uv,\n            vec3(0.370, 0.004, 0.011), //col1\n            vec3(0.520, 0.100, 0.018)); //col2\n    vec3 bgWolverine = background(uv,\n            vec3(0.370, 0.30, 0.011), //col1\n            vec3(0.520, 0.420, 0.018)); //col2\n\n    float bgT = uv.x * 0.5 + 0.5; //[0,1]\n    bgT = smoothstep(0., 1., bgT);\n    vec3 bg = mix(bgDeadpool, bgWolverine, bgT);\n\n    color = mix(color, bg, step(MAX_RM_DISTANCE, t));\n\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#ifndef H_CONSTS\n#define H_CONSTS\nconst float PI = 3.14159265359;\nconst float PI2 = 2.0 * PI;\nconst float EPSILON = 0.001;\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n#endif\n\n#ifndef H_MATH\n#define H_MATH\n\nvec2 rotate2d(vec2 v, float a) {\n    mat2 rotation = mat2(vec2(cos(a), sin(a)), vec2(-sin(a), cos(a)));\n    return rotation * v;\n}\n\nvec3 rotateY(vec3 point, float angle) {\n    float r = angle;\n    float x = point.x * sin(r) - point.z * cos(r);\n    float z = point.x * cos(r) + point.z * sin(r);\n    return vec3(x, point.y, z);\n}\n\nfloat rectangle(vec2 uv, vec2 size) {\n    float left = size.x * 0.5;\n    float up = size.y * 0.5;\n    float cx = 1.0 - smoothstep(left, left + 1.5, abs(uv.x));\n    float cy = 1.0 - smoothstep(up, up + 1.5, abs(uv.y));\n    return (cx * cy);\n}\n\nfloat box(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n#endif\n\n#ifndef H_RAYMARCHING\n#define H_RAYMARCHING\n\n#define MAX_RM_DISTANCE 200.0\n#define MIN_RM_DISTANCE EPSILON\n#define MAX_RM_IT 100\n\nstruct RaymarchResult {\n    float distance;\n    vec3 color;\n};\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n// d1 - d2\nfloat opSubtraction(float d1, float d2)\n{\n    return max(-d2, d1);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdTriPrismZ(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la, lb);\n    float f = clamp((ndot(b, b - 2.0 * p.yx)) / dot(b, b), -1.0, 1.0);\n    vec2 q = vec2(\n            length(p.yx - 0.5 * b * vec2(1.0 - f, 1.0 + f))\n                * sign(p.y * b.y + p.x * b.x - b.x * b.y)\n                - ra, p.z - h);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\nfloat sdCylinderZ(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n#endif\n\n","name":"Common","description":"","type":"common"}]}