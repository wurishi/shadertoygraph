{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// 1000 spheres in a 10x10x10 cube pattern, ray tracing with grid marching\n//\n// Version 1.2 (2013-03-12)\n// Simon Stelling-de San Antonio\n//\n// Remake of my raytracing image from March 1995,\n// see http://home.wtal.de/ss/html/pix/1000kug.jpg\n// and http://home.wtal.de/ss/html/pix/1000zoom.jpg\n//\n// Many thanks to Inigo Quilez (iq) for articles, example source codes and Shadertoy.\n//\n// V1.0  2013-03-12  Initial public version with ray marching\n// V1.1  2013-03-13  Bugfix in ray reflection\n// V1.2  2013-03-13  Replaced ray marching by \"grid marching\" and exact ray/sphere intersection\n\nbool isInCube(vec3 pos)\n{\n  return max(max(abs(pos.x),abs(pos.y)),abs(pos.z)) < 5.0;\n}\n\nfloat tToPlane(vec3 o, vec3 d)\n{\n    float t = 9999999.9;\n    if (abs(d.x) > 0.0001)\n    {\n      float tt = -(5.0 * sign(d.x) + o.x)/d.x;\n      if (tt >= 0.0)\n      {\n        vec2 s = o.yz + tt * d.yz;\n        if ((abs(s.x) <= 5.0) && (abs(s.y) <= 5.0)) {\n          t = tt;\n        }\n      }\n    }\n    return t;\n}\n\nfloat tToCube(vec3 ro, vec3 rd)\n{\n  float t = 0.0;\n  if (!isInCube(ro)) {\n    t = min(tToPlane(ro.xyz, rd.xyz),\n        min(tToPlane(ro.yxz, rd.yxz),\n            tToPlane(ro.zxy, rd.zxy)\n        ));\n    if (t == 9999999.9) t = 0.0;\n  }\n  return t;\n}\n\nvec4 intersectSphere(vec3 pos, vec3 v, vec3 m) // Ray position and direction, Sphere center\n{\n  vec3 a = pos - m;\n  float ph = dot(a,v);\n  float d = ph*ph - dot(a,a) + 0.0625;\n  vec4 res = vec4(-1.0);\n  if (d >= 0.0) {\n    res = vec4(pos - (ph + sqrt(d))*v, 0.0);\n  }\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  p.x *= (iResolution.x / iResolution.y);\n\n  // camera\n  float camtime = 0.27*iTime;\n  vec3 ro = (3.9+1.5*cos(0.61*camtime))*vec3(2.5*sin(0.25*camtime),1.02+1.01*cos(0.13*camtime),2.51*cos(0.25*camtime));\n  vec3 ww = normalize(vec3(0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 last_test_box = vec3(8.0);\n  float sh = 1.0;\n\n  ro += tToCube(ro,rd)*rd;\n\n  for (int j = 0; j < 20; j++) {\n    vec3 test_box = floor(ro);\n    if ((test_box != last_test_box) && isInCube(ro)) {\n      last_test_box = test_box;\n      vec3 m = test_box + 0.5;\n      vec4 hit = intersectSphere(ro,rd,m);\n      if (hit.w == 0.0) {\n        vec3 n = normalize( hit.xyz - m );\n        rd -= 2.0 * dot(n,rd) * n;\n        ro = hit.xyz + 0.25 * rd;\n        sh *= 0.89;\n      }\n    }\n    ro = ro + 0.91 * rd;\n  }\n\n  float li = 0.0;\n  float ang = abs(rd.y);\n  vec3 col1;\n  vec3 col2;\n  vec2 ip = ro.xz + ((33.3 - ro.y) / rd.y) * rd.xz;\n  if (rd.y < 0.0) {\n    // earth color\n    vec2 fc = fract(0.03*ip);\n    float mix1 = texture(iChannel0,fc).x;\n    col1 = mix( vec3(0.99, 0.78, 0.39), vec3(0.71, 0.58, 0.19), mix1);\n    col2 = mix( vec3(0.75, 0.55, 0.16), vec3(0.65, 0.25, 0.16), mix1);\n  } else {\n    // sky color\n    vec2 fc = fract(0.001*ip + 0.5);\n    float mix1 = 1.0 - texture(iChannel1,fc).x;\n    mix1 = clamp( (mix1 * 1.7 - 0.5), 0.0, 1.0);\n    ang = clamp(ang * 1.5,0.0,1.0);\n    col1 = mix( vec3(0.39, 0.78, 1.0), vec3(0.19, 0.58, 0.7), mix1);\n    col2 = mix( vec3(0.90, 0.90, 0.9), vec3(0.03, 0.24, 0.5), mix1);\n    // light\n    vec3 light = normalize(vec3(1.0,0.9,0.3));\n    li = pow( max(dot(rd,light),0.0), 88.1);\n  }\n  vec3 col = mix(col1,col2,ang);\n  col = mix(col, vec3(1.0), li); // apply light\n  col = mix(vec3(0.3), col, sh); // apply shadow\n  fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lds3z8","date":"1363089181","viewed":1354,"name":"1000 Spheres remake from 1995","username":"ssdsa","description":"1000 spheres in a 10x10x10 cube pattern. A remake of raytracing images I did on my Amiga in March 1995 in my Raytracer coded in 68030 assembly, see http://home.wtal.de/ss/html/pix/1000kug.jpg and http://home.wtal.de/ss/html/pix/1000zoom.jpg","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","remake","spheres","1995","amiga","marching"],"hasliked":0,"parentid":"","parentname":""}}