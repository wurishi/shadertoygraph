{"ver":"0.1","info":{"id":"dd3czS","date":"1695174396","viewed":172,"name":"Quartz-like growth","username":"stb","description":"Not that realistic.\n\nMouse to move light, 'r' to reset field.","likes":17,"published":3,"flags":48,"usePreview":1,"tags":["2d","shading","25d","silica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Quartz-like growth\n    \n    September 2023 stb\n    \n    Update:\n        * the shading is more accurate but different, thanks to true 2.5d evaluation\n        * fixed striations unintentionally appearing on terminations\n        * crystals are now purplish ':]\n\n    Update 2:\n        * fixed crystals not having the right height a given offest\n        * lighten smaller crystals\n        \n    Old news: The refraction isn't right... I don't know how to properly use the refract function, so\n    I used the normal directly instead -_-\n*/\n\nfloat map (vec2 uv, vec2 p) {\n    vec2 pos = texture(iChannel0, uv).rg;\n    float rot = texture(iChannel0, uv).b;\n    float off = texture(iChannel0, uv).a;\n    \n    //return .02 * (1.-min(1., 1.-sqrt(1.-(p.x*p.x*2.+p.y*p.y*2.))));\n    return .25 * (1.-shape(p-pos, rot, off, res.y)) * off;\n}\n\nfloat de(vec2 uv, vec3 p) {\n    return p.z - map(uv, p.xy) / res.y / .01;\n}\n\nvec3 getNorm(vec2 uv, vec3 p) {\n    vec3 o = .5 * vec3(-1., 0., 1.) / res.y;\n    return\n        normalize(\n            vec3(\n                de(uv, p-o.xyy) - de(uv, p-o.zyy),\n                de(uv, p-o.yxy) - de(uv, p-o.yzy),\n                //de(p-o.yyz) - de(p-o.yyx)\n                2.*o.x\n            )\n        );\n}\n\nvoid mainImage(out vec4 fo, in vec2 fc) {\n    vec2 uv = fc.xy / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    \n    vec3 rpos = vec3(p, -10.);\n    vec3 rdir = vec3(0., 0., 1.);\n    vec3 rhit = vec3(rpos.xy, -map(uv, rpos.xy));\n    \n    // mouse position\n    vec2 m = 1. * (iMouse.xy-res/2.) / res.y;\n    \n    // output rgb value\n    vec3 rgb;\n    \n    // light position\n    vec3 lpos = vec3(m, -.5) - rhit;\n    if(iMouse.w>=0.)\n        lpos = .65 * vec3(sin(.7*iTime), cos(.7*iTime), -1.5) - rhit;\n    \n    // light color\n    vec3 lcol = .5 * vec3(3., 2.7, 2.3);\n    \n    // light distance\n    float ldist = pow(length(lpos), 1.);\n    \n    // normal\n    vec3 norm = getNorm(uv, rhit);\n    \n    // diffuse\n    float brilliance = .5;\n    vec3 diff = .5 * vec3(.9, .86, .83) * pow(max(0., 1.-dot(-normalize(lpos), norm)), brilliance) / ldist;\n    \n    // cut down diffuse if surface is not a crystal\n    //diff *= map(uv, p)>.001 ? 1.: .75;\n    \n    // reflection vector\n    vec3 refl = normalize(reflect(-normalize(lpos), norm));\n    \n    // specular hightlight\n    float spec = 1.5 * pow(clamp(.52*(1.-dot(refl, rdir)), 0., 1.), 32.) / ldist;\n    \n    // refraction vector\n    vec2 refr = (p + vec2(.03, .0113)*iTime + 14.*normalize(refract(vec3(0,0,1), norm, 1./1.5)).xy) ;\n    \n    // refracted background\n    rgb = vec3(5.) * mix(vec3(.5), smoothstep(vec3(0.), vec3(1.), texture(iChannel1, refr.xy/5.+.5).rgb)*1., .5);\n    \n    // crystal color\n    vec3 xcol = vec3(map(uv, rhit.xy)<.001 ? vec3(0.75) : vec3(.9, .8, 1.));\n    \n    // shade by offset value\n    //rgb *= mix((1.-map(uv, rhit.xy))*xcol, vec3(0.), map(uv, p)+.5*texture(iChannel0, uv).a);\n    vec3 mask = map(uv, p)>.001 ? diff*2. : vec3(1.);\n    rgb *= .5 * (diff+.5) * mix((1.-4.*map(uv, rhit.xy))*xcol, vec3(0.), map(uv, p)+.125+.15*texture(iChannel0, uv).a);\n    \n    // apply diffuse\n    //rgb += lcol * diff;\n    \n    // apply specular\n    float aoi = 1.05 - pow(dot(vec3(0,0,-1), norm), 1.);\n    rgb += lcol * spec * aoi;// * float(map(uv, p)>.001);\n    \n    //rgb = vec3( texture(iChannel0, uv).a );\n    \n    // output\n    fo = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hash without sine: https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// a time-based, pseudo-random float\nfloat trand(vec2 p){ return hash12(mod(p+iDate.w/10., 100.));}\n\n// texture definition\n#define tx(o) texture( iChannel0, uv+o/res )\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 uv = fc / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // position vector\n    vec2 pos;\n    \n    // rotation, size\n    float rot, off;\n    \n    // first frame or when 'r' is pressed\n    if(iFrame==0 || texture(iChannel1, vec2(82.5/256., .2)).r>0.) {\n        // save pixel position\n        if(trand(p)<SeedDensity && trand(-p)<.1)\n            pos = p;\n            \n        // otherwise, set pixel to a high distance\n        else\n            pos = vec2(16.);\n        \n        // default rotation\n        rot = 6.28 * trand(p+8.341);\n        \n        // default offset\n        off = mix(.5, trand(p+1.492), .75);\n    }\n    \n    // all other frames\n    else{\n    \n        // sample directions\n        // s[7] s[4] s[8]\n        // s[1] s[0] s[2]\n        // s[5] s[3] s[6]\n\n        vec4 s[9];\n\n        s[0] = tx(o.yy);\n\n        s[1] = tx(o.xy);\n        s[2] = tx(o.zy);\n        s[3] = tx(o.yx);\n        s[4] = tx(o.yz);\n\n        s[5] = tx(o.xx);\n        s[6] = tx(o.xz);\n        s[7] = tx(o.zx);\n        s[8] = tx(o.zz);\n    \n        // this cell's position\n        pos = s[0].rg;\n        rot = s[0].b;\n        off = s[0].a;\n        \n        // save position\n        vec2 opos = pos;\n        \n        // loop through neighbors\n        float lpos;\n        for(int i=1; i<9; i++) {\n        \n            // attempt to round things out by randomly bailing out on corner samples\n            if(i>4 && trand(p+2.34) < .9)\n                break;\n            \n            // sample neighboring position\n            vec2 ipos = s[i].rg;\n            float irot = s[i].b;\n            float ioff = s[i].a;\n\n            // compare distance-to-pos with distance-to-ipos\n            // ...and rewrite pos when the latter is less than the former\n            if(shape(p-ipos, irot, ioff, res.y) < shape(p-pos, rot, off, res.y)) {\n                pos = ipos;\n                rot = irot;\n                off = ioff;\n            }\n        }\n        \n        // if original position's length is more than 9.\n        if(length(opos) > 8.) {\n        \n            // randomize position\n            pos += PosV * (.5-hash22(mod(uv+iDate.w/10., 100.))) / res.y;\n            \n            // randomize rotation\n            if(trand(7.213-p)<.0001)\n                rot += RotV * (.5-trand(mod(p+iDate.w/10.-2.73, 100.)));\n                \n            // randomize offset\n            off = clamp(off-OffV*trand(mod(p-iDate.w/10., 100.)), 0., 1.);\n        }\n        \n    }\n    \n    // output\n\tfo = vec4(pos, rot, off);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SeedDensity .0007 // number of initial seeds\n#define PosV .5 // random position multiplier\n#define RotV .1 // random rotation multiplier\n#define OffV 0.000 // random offset multiplier\n\n#define res iResolution.xy\n#define scale (res.y/400.)\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\n// hash without sine: https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// this can be anything resembling an sdf\nfloat shape (in vec2 p, float rot, float off, float resy) {\n    p *= resy;\n    p /= 50.;\n    p /= off;\n    p = rotate(p, rot);\n    float f;\n    \n    float o2 = .5+fract(off*13.72);\n    float o3 = .2*(.5-fract(off*13.72));\n    f = max(abs(p.x)-o2, abs(p.y));\n    f = max(.5, f);\n    \n    float px = 8. * p.x + 72. * off;\n    float striations = clamp(mix(hash11(floor(px)), hash11(floor(px+1.)), fract(px) ), 0., 1.);\n    px *= 3.;\n    striations += .3 * clamp(mix(hash11(floor(px)), hash11(floor(px+1.)), fract(px) ), 0., 1.);\n    f += .25 * striations * o3;\n    \n    f = max(f, abs(p.x)-o2+p.y-2.*o3);\n    f = max(f, abs(p.x)-o2-p.y+2.*o3);\n    \n    \n    f = max(f, p.x/2.-.5*o2+.5+o3);\n    f = max(f, -p.x/2.-.5*o2+.5-o3);\n    \n    f = min(1., f);\n    \n    f -= .001*off;\n    \n    return f;\n}","name":"Common","description":"","type":"common"}]}