{"ver":"0.1","info":{"id":"MtKSW3","date":"1486247564","viewed":383,"name":"Twisty Thing","username":"TekF","description":"A little sculpture in my bidirectional monte carlo tracer.\nClick to refresh after resolution change.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hazel Quantock 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nconst float phi = 1.61803398875;\n\nvec2 Rand( in float seed )\n{\n    vec2 r = fract( vec2( 37.*sin(phi*seed), 31.*sin(seed/phi) ) + seed/1024.);\n    return fract( r + .5);\n}\n\nvec2 Rand( in int seed, in int roll )\n{\n    return Rand( float(seed)*(1.+phi/(1.+float(roll))) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    int pass = 0;//iFrame; // don't need animated noise when rendering a still image\n    int pixelSeed = int( Rand( pass, 0 ) * 256. ) + pass*61 + int(fragCoord.x) + 1023*int(fragCoord.y);\n    \n    vec2 dither = Rand( pixelSeed, 0 );\n    \n\tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n    fragColour /= fragColour.a;\n    \n    // HDR\n    const float a = 1.5;\n    const float p = 1.7; // curve where colours hit white (lower = softer)\n    const float r = 1.2; // overflow\n    fragColour = r*pow(1.-1./(1.+pow(a*fragColour/r,vec4(p))),vec4(1./p));\n    \n\tfragColour = pow(fragColour,vec4(1./2.2)) + dither.xxxx/255.;\n    fragColour.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ben Quantock 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\nconst int DEPTH = 3; // trace depth - longest path is 2*DEPTH+1\n\nconst float tau = 6.28318530717958647692;\nconst float phi = 1.61803398875;\n\nvec2 Rand( in float seed )\n{\n\t// line artefacts get worse as seed gets higher => rand isn't the problem\n//    seed /= 100.;\n    // concentrates more at the edges\n//    vec2 r = vec2( fract(37*sin(phi*seed)), fract(31*sin(seed/phi)) );\n\n\t// offsetting by a procession = almost perfect!\n    vec2 r = fract( vec2( 37.*sin(phi*seed), 31.*sin(seed/phi) ) + seed/1024.);\n    \n    return fract( r + .5);  // offset to make edge biases more visible\n}\n\n\n// generate a unique seed \nvec2 Rand( in int seed, in int roll )\n{\n    return Rand( float(seed)*(1.+phi/(1.+float(roll))) );\n}\n\n\nvec3 SphereRand( in int seed, in int roll )\n{\n    vec2 a = Rand(seed,roll);\n    \n    a.x = a.x*2.-1.;\n    a.x = sign(a.x)*(1.-sqrt(1.-abs(a.x))); // this is not the perfect distribution\n    a.x *= tau/4.;\n    a.y *= tau;\n    \n    return vec3(cos(a.x)*sin(a.y),-sin(a.x),cos(a.x)*cos(a.y));\n}\n\nvec3 HemisphereRand( in int seed, in int roll, in vec3 dir )\n{\n    vec3 r = SphereRand(seed,roll);\n    \n    return r*(step(.0,dot(r,dir))*2.-1.);\n}\n\n\n//const vec3 lightPos = vec3(-20,10,50); const vec3 lightSourceCol = vec3(2,1,.5);\n//const vec3 lightPos = vec3(-20,40,40); const vec3 lightSourceCol = vec3(1.5,1.3,1.1); //vec3(1.5,1.2,.9);\nconst vec3 lightPos = vec3(20,50,-10); const vec3 lightSourceCol = vec3(1.4,1.3,1.2); //vec3(1.5,1.2,.9);\n//const vec3 lightPos = vec3(20,40,-40); const vec3 lightSourceCol = vec3(1.5,1.3,1.1); //vec3(1.5,1.2,.9);\n//const vec3 lightPos = vec3(20,20,-50); const vec3 lightSourceCol = vec3(1.5,1.2,1); //vec3(1.5,1.2,.9);\n\nconst vec3 skyTone = vec3(.25,.5,1.);\n//const vec3 skyTone = vec3(.04,.05,.1);\n\n// I can't do emissive at present, so centre sky dome on light source and adjust its colour to compensate for light colour\nconst float skyRadius = 1000.;\n\n\nfloat Box( in vec3 pos, in vec3 p0, in vec3 p1 )\n{\n    vec3 centre = (p0+p1)*.5;\n    vec3 dims = abs(p0-p1);\n    vec3 box = abs(pos-centre) - dims/2.;\n    return max(max(box.x,box.y),box.z);\n}\n\nfloat ShapesColour1( vec3 pos )\n{\n    return 1e38;//Box( pos, vec3(10,0,-10), vec3(-5,1,-30) );\n}\n\nfloat SDF( in vec3 pos )\n{\n    // sky dome\n    float f = -(length(pos-lightPos)-skyRadius);\n    \n    // floor\n    f = min( f, max( pos.y, length(pos.xz)-80. ) );\n    \n    vec3 p1 = pos;\n    \n    float arcs = 1.;\n    if ( arcs > 1. )\n    {\n        float a2 = atan(p1.x,p1.z)/tau;\n        a2 = (abs( fract( a2*arcs-.25 ) - .5 ) - .25) / arcs;\n        a2 *= tau;\n        p1.xz = vec2( sin(a2), cos(a2) )*length(p1.xz);\n    }\n    \n    float r1 = 200. / tau; // circumference/tau\n//    p1.z -= r1;\n    float a1 = atan(p1.z,p1.y);\n    p1.z = r1-length(p1.yz);\n    p1.y = a1*r1;\n    \n    \n    // tower of spheres\n    float r = 1.;\n    float d = 2.*r;\n    vec3 p2 = p1;\n    p2.xz = abs(p2.xz)-r;\n    vec3 cp = vec3( 0, floor(p2.y/d+.5)*d, 0 );\n    f = min( f, length( p2 - cp ) - r );\n    \n    // helix wrapped round it\n    float a = p1.y/2.;\n    float r2 = 2.4;// + 1.+cos(a1*2.);\n    float t = .1;\n    float n = 2.;\n    float s = abs(length(p1.xz)-r2-t/2.)-t/2.;\n    float o = atan(p1.x,p1.z);\n    //float w = dot( pos.xz, vec2(cos(a),sin(a)) );\n    float w = cos((o+a)*n)/n;\n    f = min( f, max( s, w ) );\n    \n    \n    // bright coloured thing to show off radiosity\n    f = min( f, ShapesColour1( pos ) );\n    \n\treturn f;\n}\n\nvec3 BRDF( in vec3 toCam, in vec3 toLight, in vec3 normal, in vec3 pos )\n{\n    // map materials to scene\n    \n    float power = 50.;\n    vec2 reflectance = vec2(0);\n    vec3 albedo = vec3(.9);\n\n    if ( length(pos-lightPos)-skyRadius >= -.001  )\n    {\n        vec3 sp = (pos-lightPos)/skyRadius;\n        \n        if ( sp.y > .0 )\n        {\n        \talbedo = mix(vec3(0),vec3(1),exp2(-abs(sp.y)/skyTone));\n        }\n        else\n        {\n        \talbedo = mix(vec3(1),vec3(.2),exp2((.1/min(-.01,sp.y))*skyTone));\n        }\n        \n        albedo /= lightSourceCol; \n        reflectance = vec2(0);\n    }\n    else if ( pos.y < .001 )\n    {\n        albedo = vec3(.6);\n    }\n    else if ( ShapesColour1(pos) < .001 )\n    {\n        albedo = vec3(.95,0,0);\n    }\n/*    else if ( length(vec2(length(pos.zy)-200./tau,pos.x)) < 2.45 )\n    {\n        albedo = max(vec3(0),sin(atan(pos.z,pos.y)*2.+vec3(0,1,2)*tau/3.)*.7+.3);\n    }*/\n\n    \n    // shading\n  \tfloat ndoti = dot(normal,toCam);\n    \n    // specular\n    vec3 h = normalize(toCam+toLight);\n    float hdotn = abs(dot( normal, h ));\n\n    float spec = .0;\n    if ( hdotn > .0 )// && ndoti > .0 )\n    {\n        spec = pow( abs(hdotn), power );\n\n        // experiment to fix the dark edge (unsuccessful, but it doesn't hurt anything)\n//        spec *= max(dot(h,toCam),.0)/hdotn; // weigh up facets facing camera vs edge-on facets\n        \n        // normalisation (found by fitting a curve to brute force sampled data)\n//        spec /= 1.35/(.75+power);\n        spec /= 2./(2.+power);\n    }\n    \n    float fresnel = mix( reflectance.x, reflectance.y, pow( 1.-ndoti, 5. ) );\n\n\treturn mix( albedo * max(.0,dot(toLight,normal)), vec3(spec), fresnel );\n}\n\n\n\nvec3 Normal( in vec3 pos )\n{\n    vec2 d = vec2(-1,1)*.0001;\n    vec3 ignore; float ignore2;\n    return normalize(\n        SDF(pos+d.xxx)*d.xxx +\n        SDF(pos+d.yyx)*d.yyx +\n        SDF(pos+d.yxy)*d.yxy +\n        SDF(pos+d.xyy)*d.xyy\n    );\n}\n\n\nvec3 Trace( in vec3 pos, in vec3 dir )\n{\n    const float e = .001;\n    const float e2 = e*2.;\n    \n    // try to push ray start out of an object\n    float t = .0;\n    \n    float h = SDF( pos );\n    if ( h < e2 )\n    {\n        vec3 n = Normal(pos);\n\t\tt += (e2-h)/max(.01,dot(dir,n));\n// think ^ this is screwing up shallow-angle reflections\n    }\n    \n    for ( int i=0; i < 500; i++ )\n    {\n        h = SDF( pos+dir*t );\n        t += h;\n        if ( h < .001 ) break;\n    }\n    \n    return pos+dir*t;\n}\n\n\nfloat TestTrace( in vec3 from, in vec3 to )\n{\n    // try to push ray start out of an object\n    float t = max( .1-SDF( from ), .0 );\n    \n    float d = .001;\n    \n    float tEnd = length(to-from) - d;\n    \n    vec3 dir = normalize(to-from);\n        \n    for ( int i=0; i < 100; i++ )\n    {\n        float h = SDF( from+dir*t );\n        t += h;\n        if ( h < d || t > tEnd ) break;\n    }\n    \n    return step( tEnd, t );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    int pass = iFrame;\n//    int pixelSeed = pass + 121*int(fragCoord.x) + 1023*int(fragCoord.y);\n    int pixelSeed = int( Rand( pass, 0 ) * 256. ) + pass*61 + int(fragCoord.x) + 1023*int(fragCoord.y);\n    \n    vec2 jitter = Rand( pixelSeed, 0 );\n    \n    vec3 ray;\n    ray.xy = (fragCoord.xy+(jitter-.5)*1.-iResolution.xy*.5)/iResolution.y;\n//    if ( max(abs(ray.x),abs(ray.y)) > .5 ) discard;\n    \n    vec3 pos = vec3(-10,1.8,-30);\n    vec3 target = vec3(0,20,0); ray.z = .8;\n//    vec3 target = vec3(-2,14,-10); ray.z = .8;\n//    vec3 target = vec3(0,17,-5); ray.z = .8;\n\n    // depth of field\n    pos += SphereRand(pixelSeed,20)*.1;\n    \n    ray = normalize(ray);\n\n    vec3 forward = normalize(target-pos);\n    vec3 right = normalize(cross(vec3(0,1,0),forward));\n    vec3 up = cross(forward,right);\n    ray = ray.x*right + ray.y*up + ray.z*forward;\n\t\n    \n    // point light, fire ray in random direction\n    vec3 lightRay = SphereRand(pixelSeed,1);\n    \n\n    const int N = DEPTH;\n    vec3 viewIntersections[N], lightIntersections[N];\n    vec3 viewNormal[N], lightNormal[N];\n    vec3 viewCol[N], lightCol[N];\n    \n    viewIntersections[0] = Trace( pos, ray );\n    lightIntersections[0] = Trace( lightPos, lightRay );\n    viewNormal[0] = Normal(viewIntersections[0]);\n    lightNormal[0] = Normal(lightIntersections[0]);\n\n    vec3 lastViewDir = ray;\n    vec3 lastLightDir = lightRay;\n    vec3 viewDir = HemisphereRand(pixelSeed,0,viewNormal[0]);\n    vec3 lightDir = HemisphereRand(pixelSeed,1,lightNormal[0]);\n\n    viewCol[0] = BRDF( -lastViewDir, viewDir, viewNormal[0], viewIntersections[0] );\n    lightCol[0] = lightSourceCol * BRDF( lightDir, -lastLightDir, lightNormal[0], lightIntersections[0] );\n\n    for ( int i=1; i < N; i++ )\n    {\n    \tviewIntersections[i] = Trace( viewIntersections[i-1], viewDir );\n    \tlightIntersections[i] = Trace( lightIntersections[i-1], lightDir );\n    \tviewNormal[i] = Normal(viewIntersections[i]);\n    \tlightNormal[i] = Normal(lightIntersections[i]);\n\n        lastViewDir = viewDir;\n        lastLightDir = lightDir;\n        viewDir = HemisphereRand(pixelSeed,2*i+0,viewNormal[i]);\n        lightDir = HemisphereRand(pixelSeed,2*i+1,lightNormal[i]);\n\n        viewCol[i] = viewCol[i-1] * BRDF( -lastViewDir, viewDir, viewNormal[i], viewIntersections[i] );\n        lightCol[i] = lightCol[i-1] * BRDF( lightDir, -lastLightDir, lightNormal[i], lightIntersections[i] );\n    }\n\n    // connect every light intersection (including source) with every view intersection (excluding source)\n    vec3 col = vec3(0);\n    vec3 lastViewPos = pos;\n    vec3 lastViewCol = vec3(1,1,1);\n    for ( int i=0; i < N; i++ )\n    {\n        vec3 toView = normalize(lastViewPos - viewIntersections[i]);\n        float weight = 1./min(float(1+i),float(2*N-i)); // divide by the number of rays which have this many bounces\n        float shadow = TestTrace( viewIntersections[i], lightPos );\n        col += weight * lastViewCol * lightSourceCol * BRDF( toView, normalize(lightPos-viewIntersections[i]), viewNormal[i], viewIntersections[i] ) * shadow;\n\n        vec3 lastLightPos = lightPos;\n        vec3 lastLightCol = lightSourceCol;\n        for ( int j=0; j < N; j++ )\n        {\n            weight = 1./min(float(2+i+j),float(2*N-1-i-j)); // divide by the number of rays which have this many bounces\n            shadow = TestTrace( viewIntersections[i], lightIntersections[i] );\n\n            vec3 toLight = normalize(lightIntersections[i]-viewIntersections[i]);\n            vec3 lightColHere = lastLightCol * BRDF( -toLight, normalize(lastLightPos-lightIntersections[i]), lightNormal[i], lightIntersections[i] );\n    \n            col += weight * lastViewCol * lightColHere * BRDF( toView, toLight, viewNormal[i], viewIntersections[i] ) * shadow;\n            \n            lastLightPos = lightIntersections[i];\n            lastLightCol = lightCol[j];\n        }\n        \n        lastViewPos = viewIntersections[i];\n        lastViewCol = viewCol[i];\n    }\n\n//col = vec3(exp2(-length(pos - viewIntersections[0])));\n    \n\tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n\n    if ( pass == 0 || ( iMouse.x != .0 && iMouse.x == iMouse.z ) ) fragColour = vec4(0);\n\n    fragColour.rgb += col;\n    fragColour.a += 1.;\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}