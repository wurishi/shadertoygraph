{"ver":"0.1","info":{"id":"WsVyDm","date":"1603036371","viewed":112,"name":"Utils_Shapes","username":"bigt","description":"图形","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circle","rect","shape","util"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 像素为单位:\n\n// pos:当前坐标,center:中心点坐标,radius:圆的半径,threshold:边缘平滑像素阈值(向圆心过度)\n// return:圆内为0,圆外为1\nfloat shapeCircle(vec2 pos, vec2 center, float radius, float threshold)\n{\n    float s = clamp(threshold, 0.0, radius);// 控制阈值范围\n    return smoothstep(radius-s, radius, length(pos-center));\n}\n\n// rectangular\n// pos:当前坐标,center:中心点坐标,size:矩形的宽高,threshold:边缘平滑像素阈值(向中心过度)\n// return:矩形内为0,矩形外为1\nfloat shapeRect(vec2 pos, vec2 center, vec2 size, float threshold)\n{\n    vec4 t = vec4(center - size/2.0, center + size/2.0);// 左下，右上坐标\n    vec2 s = clamp(vec2(threshold), vec2(0.0), size/2.0);// 控制阈值范围\n    // pos.x > left为1, pos.y > bottom为1\n    vec2 v = vec2(smoothstep(t.x, t.x+s.x, pos.x), smoothstep(t.y, t.y+s.y, pos.y));\n    // pos.x < right为1, pos.y < top为1\n    v *= vec2(1.0 - smoothstep(t.z-s.x, t.z, pos.x), 1.0 - smoothstep(t.w-s.y, t.w, pos.y));\n    // 此时v.x*v.y的结果为:矩形内为1，矩形外为0\n    // 反向一下\n    return 1.0-v.x*v.y;\n}\n\n// pos:当前坐标,center:中心点坐标,radius:内切圆半径,sides:n边形,threshold:边缘平滑像素阈值(向中心过度)\n// return:多边形内为0,多边形外为1\n// 感谢狐狸 :)\nconst float PI = 3.1415926535;\nfloat shapePoly(vec2 pos, vec2 center, float radius, float sides, float threshold)\n{\n    sides = max(3.0, sides);\n    float s = clamp(threshold, 0.0, radius);// 控制阈值范围\n    pos -= center;// 以center为中心建立坐标系\n    float angle = atan(pos.x, pos.y);// 计算与y轴夹角\n    // ps:这里可以看成angle+2pi,那么angle绕y轴正半轴顺时针的变化为0~2pi\n    // angle+2pi和angle一样,绕了一圈,所以没有必要+2pi\n    \n    float slice = PI * 2.0 / sides;// 正n边形每一份的角度\n    // 计算当前角度处于哪个索引中 0,1,2,3,4,5区域\n    float index = floor(angle / slice);\n    // 计算每一份区域中的中心角度:索引直接加0.5\n    float c2 = (index + 0.5) * slice;\n    // 得到与中线的夹角\n    float delta = angle - c2;\n    // 判断该cos(夹角)的值是否小于内切圆半径\n    return smoothstep(radius-s, radius, length(pos) * cos(delta));// < radius;\n}\n\nmat2 rotateZ(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float result = 1.0;\n    \n    // 圆形\n    vec2 centerCircle = iResolution.xy / 2.0;\n    vec2 posCircle = fragCoord;\n    vec2 translateCircle = vec2(90.0 + sin(iTime*5.0)*40.0,70.0);\n    posCircle -= translateCircle;\n    float radiusCircle = 40.0 + sin(iTime + 1.0) * 10.0;\n    float circle = shapeCircle(posCircle, centerCircle, radiusCircle, 5.0);\n    result *= circle;\n    \n    // 矩形\n    vec2 centerRect = iResolution.xy / 2.0;\n    vec2 translateRect = vec2(90.0 + sin(iTime*2.5)*30.0, -50.0 + cos(iTime*2.5)*30.0);\n    vec2 scaleRect = vec2(0.5,0.5);\n    vec2 posRect = fragCoord;\n    posRect -= translateRect;// 位移:相当于反向移动坐标轴\n    // 矩形以中心为原点,绕z旋转\n    // 旋转前将center变为原点,旋转后在移动回来\n    posRect -= centerRect; posRect *= rotateZ(sin(iTime) * PI * 2.0); posRect += centerRect;\n    float rect = shapeRect(posRect, centerRect, vec2(200.0, 100.0)*scaleRect, 5.0);\n    result *= rect;\n    \n    // 正n边形\n    vec2 centerPoly = iResolution.xy / 2.0 + vec2(-100.0, 30.0);\n    vec2 posPoly = fragCoord;\n    posPoly -= centerPoly; posPoly *= rotateZ(sin(iTime) * PI * 2.0); posPoly += centerPoly;\n    float poly = shapePoly(posPoly, centerPoly, 50.0, 7.0, 5.0);\n    result *= poly;\n    \n    fragColor = vec4(vec3(result), 1.0);\n}","name":"Image","description":"","type":"image"}]}