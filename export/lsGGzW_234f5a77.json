{"ver":"0.1","info":{"id":"lsGGzW","date":"1453564323","viewed":3322,"name":"Video on Tablet","username":"TambakoJaguar","description":"The webcam picture is integrated in the scene. You can use your mouse to move the camera.\nI also could learn a lot with this \"project\". :)\nIt's nice to work with IDs for objects.\nComments and critics welcome as usual.","likes":56,"published":1,"flags":34,"usePreview":1,"tags":["reflections","webcam","fresnel","picture","bumpmap","softshadow","tablet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Video on Tablet\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Much code adapted from https://www.shadertoy.com/view/Xds3zN, thanks iq to let us use it! :)\n\n#define pi 3.141593\n\n// Switches, you can play with them!\n#define shadow\n#define reflections\n//#define ambocc\n#define specular\n#define bumpmaps\n#define smooth_floor_bump\n#define complex_tab_light_color\n#define spheres\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nLamp lamps[3];\n\n// Every object of the scene has its ID\n#define SKY_OBJ      0\n#define FLOOR_OBJ    1\n#define TABLET_OBJ   2\n#define IMAGE_OBJ    3\n#define SPHERES_OBJ  4\n\n// Campera options\nvec3 campos;\nvec3 camtarget = vec3(0., 1.8, 0.);\nvec3 camdir;\nfloat fov = 4.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0., 0., 0.3);\nconst float ambientint = 0.05;\n\n// Shading options\nconst float specint = 0.2;\nconst float specshin = 150.;\nconst float aoint = 0.5;\nconst float shi = 0.85;\nconst float shf = 0.4;\n\n// Tracing options\nconst float normdelta = 0.002;\nconst float maxdist = 200.;\nconst int nbref = 2;\n\n// Floor options\nconst float woodSize = 0.1;\nfloat flpos = 0.;\n\n// Tablet/image constants\nconst vec3 tabPos = vec3(0., 2.3, 0.);\nconst float tabWidth = 3.;\nconst float tabHeight = 2.;\nconst float tabletRounding = 0.3;\nconst float picWidth = 0.93;\nconst float picHeight = 0.96;\nconst float tcNbSampless = 5.;\nconst float tcNbSamplesc = 16.;\nconst vec2 tcWindowSize = vec2(0.2,0.4);\nconst float tcJitter = 0.035;\nconst float image_br = 0.55;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.65;\nconst int aasamples = 1;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// 2D hash function\nvec2 hash2( vec2 n ){\n\treturn fract(vec2(sin(n.x)*3538.5453, sin(n.y)*2753.8256));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Union operation from iq\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// Gets the coordinates of the image (0..1) from the world coordinates of the tablet point\n// ToDo: use tabPos, tabWidth, tabHeight, picWidth and picHeight\nvec2 pos2screen(vec3 pos)\n{\n   return pos.xy*vec2(-0.18, 0.148*iResolution.x/iResolution.y) + vec2(0.5, -0.1);\n}\n\n// Gets the light color at a given surface point. Not really realistic but also not too slow\n// I could optimize it to get it nicer. Has some jitter to hide the sampling bands a bit\n#ifdef complex_tab_light_color\nvec3 getScreenColor(vec3 pos)\n{\n   //return vec3(0.8);\n   //vec2 pos2screen = (pos-tabPos).xy/vec2(tabWidth*picWidth, tabHeight*picHeight) - vec2(0.5);\n   vec2 screenpos = pos2screen(pos) + vec2(0., 0.09*pos.z);\n    \n   vec2 tcWindowSize2 = tcWindowSize*vec2(1. + abs(pos.z)/4.2, 1. + abs(pos.y)/6.);\n    \n   vec3 scol = vec3(0.);\n   for (float y=0.; y<tcNbSamplesc; y++)  \n   {\n       for (float x=0.; x<tcNbSamplesc; x++)\n       {\n           vec2 coord = screenpos + vec2(\n                 tcWindowSize2.x*x/(tcNbSamplesc-1.) - tcWindowSize2.x/2., \n                 tcWindowSize2.y*y/(tcNbSamplesc-1.) - tcWindowSize2.y/2.)\n                 + tcJitter*hash2(vec2(pos.x, pos.z));\n           scol+= texture(iChannel2, coord).rgb;\n       }\n   }\n   return mix(clamp(1.5*scol/(tcNbSamplesc*tcNbSamplesc), 0., 0.65), vec3(0.7), 0.35);\n}\n#else\n// This option just calculates the average color of the image\nvec3 getScreenColor(vec3 pos)\n{    \n   vec3 scol = vec3(0.);\n   for (float y=0.; y<tcNbSampless; y++)  \n   {\n       for (float x=0.; x<tcNbSampless; x++)\n       {\n           vec2 coord = vec2(\n                 x/(tcNbSampless-1.), \n                 y/(tcNbSampless-1.));\n           scol+= texture(iChannel2, coord).rgb;\n       }\n   }\n   return mix(scol/(tcNbSampless*tcNbSampless), vec3(0.7), 0.2);\n}\n#endif\n\n// Also a cheap and fast trick to simulate an arealight, the pos of the lamp is dynamic, it depends on the position of the sampling point\nvec3 getScreenLampPosition(vec3 lamppos, vec3 pos)\n{\n    //return lamppos;\n    \n    pos-= tabPos;\n    vec3 lamppos2 = vec3(min(max(pos.x, -tabWidth*picWidth), tabWidth*picWidth),\n                         min(max(pos.y, -tabHeight*0.4), tabHeight*picHeight) + 0.3*pos.z,\n                         lamppos.z - tabPos.z);\n    lamppos2+= tabPos;\n    return lamppos2;\n}\n\n// Whether or not the point is in the picture (only along X and Y axes)\nbool inPic(vec3 pos)\n{\n   pos-= tabPos;\n   return abs(pos.x)<tabWidth*picWidth && abs(pos.y)<tabHeight*picHeight;\n}\n\n// Distance mapping of the floor\nfloat map_floor(vec3 pos, bool btext)\n{\n    float h=0.;\n    #ifdef smooth_floor_bump\n    #ifdef bumpmaps\n   \th = texture(iChannel3, fract(woodSize*pos.xz)).x;\n    #endif\n    return pos.y - flpos - (btext?0.01*h:0.);\n    #else\n    #ifdef bumpmaps\n    h = texture(iChannel0, woodSize*pos.xz).x;\n    return pos.y - flpos - (btext?0.007*h:0.);\n    #endif\n    #endif\n    #ifndef bumpmaps\n    return pos.y - flpos;\n    #endif\n}\n\n// Distance mapping of the tablet, based on the roundcube of iq. Has some bumpmapping on it\nfloat map_tablet(vec3 pos, vec3 orig, vec3 size, float flatn, float r, bool btext)\n{\n    pos.z*= flatn;\n    return length(max(abs(pos-orig)-size,0.0)) - r + (!btext || inPic(pos)?0.:0.008*texture(iChannel1, pos.xy*0.6).x);\n}\n\n// Distance mapping of four mirror rotating spheres. Just to have some more reflection! ;)\nfloat map_spheres(vec3 pos, vec3 center, float d, float r)\n{\n    pos-= center;\n    pos.xz = rotateVec(pos.xz, iTime*0.5);\n    pos.x = abs(pos.x);\n    pos.x-= d;\n    pos.z = abs(pos.z);\n    pos.z-= d;\n    return length(pos) - r;   \n}\n\n// Combines all the distance fields\nvec2 map(vec3 pos, bool btext)\n{\n    vec2 res = opU(vec2(map_floor (pos, btext)                                                            , FLOOR_OBJ),\n                   vec2(map_tablet(pos, tabPos, vec3(tabWidth, tabHeight, 0.1), 5., tabletRounding, btext), TABLET_OBJ));\n    #ifdef spheres\n    res = opU(res, vec2(map_spheres(pos, vec3(.0, 0.45, 2.9), 1.7, 0.45)                                        , SPHERES_OBJ));\n    #endif\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.15;\n    float objnr = 0.;\n  \tfor (int i = 0; i < 200; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n        vec2 res = map(pos, false);\n    \tfloat dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*0.22;\n        objnr = res.y;\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,\n                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,\n                          map(pos + q.xxy, true).x - map(pos - q.xxy, true).x));\n}\n\n// Gets the color of the floor for given position\nvec3 floor_color(vec3 pos)\n{\n    return mix(1.2*texture(iChannel0, woodSize*pos.xz).xyz, vec3(0.65), 0.2);\n}\n \n// Gets the color of the spheres for given position\nvec3 spheres_color(vec3 pos)\n{\n    //return pos.x*pos.y<0.?vec3(1.3):vec3(1.5, 1.1, 0.5);\n    return vec3(1.3);\n}\n\n// Gets the color of the tablet for given position\nvec3 tablet_color(vec3 pos)\n{\n    return vec3(0.15);\n}\n\n// Gets the color of the image on the tablet for given position\nvec3 image_color(vec3 pos)\n{\n    return texture(iChannel2, pos2screen(pos)).rgb;\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n    return vec3(0.1, 0.35, 0.7)*(1. - ray.y*0.5);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n   return objnr==FLOOR_OBJ?floor_color(pos):(\n          objnr==TABLET_OBJ?tablet_color(pos):(\n          objnr==IMAGE_OBJ?image_color(pos):(\n          objnr==SPHERES_OBJ?spheres_color(pos):sky_color(pos))));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n    \tfloat h = map(ro + rd*t, false).x;\n        res = min( res, 10.0*h/t + 0.02*float(i));\n        t += 0.8*clamp( h, 0.01, 0.35 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map(p + rd.x, false).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = objnr==IMAGE_OBJ?ocol*image_br:ocol*lamp.color*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0 && lampnr!=2)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    if (objnr!=IMAGE_OBJ)\n       col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   campos = vec3(-20. + 40.*iMouse.x/iResolution.x,\n                 18.5 - 15.*iMouse.y/iResolution.y,\n                 16.);\n   camdir = camtarget-campos;   \n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    lamps[0] = Lamp(vec3(-15., 10, 20.), vec3(1., 1., 1.), 0.7, 0.01);\n    lamps[1] = Lamp(vec3(15., 10, 20.), vec3(1., 1., 1.), 0.7, 0.01);\n    lamps[2] = Lamp(getScreenLampPosition(vec3(0., 5.5, 0.1), pos), getScreenColor(pos), 1.8, 0.001);\n    \n    if (tx<maxdist)\n    {\n        if (objnr==TABLET_OBJ && inPic(pos)) objnr=IMAGE_OBJ;\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 7., 1.1));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, maxdist);\n  vec3 col = traceinf.col;\n  #ifdef reflections\n  float r = 1.;\n  for (int i=0; i<nbref; i++)\n  {\n  \t  if (traceinf.objnr==FLOOR_OBJ || traceinf.objnr==IMAGE_OBJ || traceinf.objnr==SPHERES_OBJ)\n      {\n          vec3 refray = reflect(ray, traceinf.norm);\n          RenderData traceinf_ref = trace0(traceinf.pos, refray, 30.);\n          if (traceinf.objnr==SPHERES_OBJ)\n          {\n              r*= 0.92;\n              col = mix(col, col*traceinf_ref.col, r);\n          }\n          else\n          {\n              r*= 1.1*clamp(fresnel(ray, traceinf.norm, 2.5), 0.0, 0.3);\n              col = mix(col, traceinf_ref.col, r);\n          }\n          ray = refray;\n          traceinf = traceinf_ref;\n      }\n  }\n  #endif\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //fragColor = mix(vec4(0.8*getScreenColor(vec3(uv, 0.)), 0.), texture(iChannel2, uv), 0.05); \n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const mat3 im_convm = mat3( 1.0,  2.0,  1.0,\n                            2.0,  3.0,  2.0,\n                            1.0,  2.0,  1.0);\n\nvec4 iconv(mat3 mat, vec2 pos)\n{\n   vec4 pixval = vec4(0.);\n   float csum =0.;\n   \n   for (int y=0; y<3; y++)\n   {\n       for (int x=0; x<3; x++)\n       {\n           vec2 ipos = pos + vec2(float(x-1)/iResolution.x, float(y-1)/iResolution.y);\n           pixval+= texture(iChannel0, ipos)*mat[x][y];\n           csum+= mat[x][y];\n       }\n   }\n   return pixval/csum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = iconv(im_convm, uv);\n}","name":"Buf A","description":"","type":"buffer"}]}