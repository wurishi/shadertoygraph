{"ver":"0.1","info":{"id":"lXlSDj","date":"1710024632","viewed":68,"name":"1/d vs view coverage glow","username":"chronos","description":"1/d style glow on the left\nvs\nview-coverage on the right\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","glow","comparison"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\n    Nothing much to see here, just some math :)\n\n    1/d style glow on the left\n    vs\n    \"view coverage\" on the right. Corresponds to projected solid angle of a sphere, but in 2D.\n\n    None of these are \"correct\" per se. Depends on physical interpretation.\n*/\n\nfloat PI = 3.14159265;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0);\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(0, cos(iTime)*.5+.5);\n\n    float radius = abs(mouse.y);\n    float r = radius;\n\n    //vec2 inv_uv = uv * r*r / dot(uv, uv); // circle inversion of uv coordinate by radius r.\n\n    //float x = length(inv_uv);\n    // simplifies to:\n    float x = r*r / length(uv);\n\n    // float c = x/r; // computes the cosine (c) of the view tangent intersection.\n    // simplifies to:\n    float c = r / length(uv);\n\n    // acos(c) computes the angle corresponding to cosine, but this is the complementary angle in the right triangle to the angle we want,\n    // so to get that angle we complete the triangle: PI - PI/2 - acos(c) = PI/2 - acos(c), which is half the view-coverage angle.\n    // factor 2 is because this only computes half the angle, from the circle center to the view-tangent, instead of tangent to tangent.\n    \n    // f = angle coverage normalized from [0, PI] to [0, 1]\n    // float f = abs(PI/2. - acos(c)) * (2./PI);\n    // simplifies to \n    float f = abs(asin(min(c, 1.))) * (2./PI);\n\n    if(uv.x > mouse.x)\n        color += f;\n    else\n        color += radius/length(uv);\n\n    color = tanh(color);\n    color = clamp(color, 0., 1.);\n\n    #if 0\n    if(isnan(f))\n        color = vec3(1,0,1);\n    #endif\n\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}