{"ver":"0.1","info":{"id":"clsfRn","date":"1692534685","viewed":22,"name":"ray marching ss","username":"jayce_lai","description":"ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MaxError = 1e-3;\nvec3 sphere_origin = vec3(0., 1., 6.);\nfloat sphere_radius = 1.;\nvec3 plane_origin = vec3(0., 0., 0.);\nvec3 plane_normal = vec3(0., 1., 0.);\n    \n//////////////////Marching/////////////////////////\n    \nfloat getDistanceWithSphere(vec3 ro)\n{\n    float d = length(ro-sphere_origin) - sphere_radius;\n    return d;\n}\n\nvec3 getNormalWithSphere(vec3 re)\n{\n    return normalize(re - sphere_origin);\n}\n\nfloat getDistanceWithPlane(vec3 ro)\n{\n    return abs(dot(ro - plane_origin, plane_normal));\n}\n\nvec3 getNormalWithPlane(vec3 re)\n{\n    return plane_normal;\n}\n\nfloat getDistance(vec3 ro)\n{\n    float s0 = getDistanceWithSphere(ro);\n    float s1 = getDistanceWithPlane(ro);\n    return min(s0, s1);\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd)\n{\n    int MaxSteps = 100;\n    \n    while(MaxSteps-- > 0)\n    {\n        float d = getDistance(ro);\n        if (d < MaxError)\n        {\n            return ro;\n        }\n        else\n        {\n            ro += rd * d;\n        }\n    }\n    \n    return ro;\n}\n\n//////////////////Shading/////////////////////////\n\nvoid getShadingAttribute(vec3 re, out vec3 pos, out vec3 norm, out vec3 albedo)\n{\n    float s0 = getDistanceWithSphere(re);\n    float s1 = getDistanceWithPlane(re);\n    if(s0 < s1)\n    {\n        pos = re;\n        norm = getNormalWithSphere(re);\n        albedo = vec3(1.0, 0., 0.);\n    } \n    else\n    {\n        pos = re;\n        norm = getNormalWithPlane(re);\n        albedo = vec3(1.0, 1.0, 1.0);\n    } \n}\n\nvec3 diffuse(vec3 radiance, float lambert, vec3 albedo)\n{\n    return radiance * lambert * albedo;\n}\n\nfloat shadow(vec3 l_pos, vec3 l_dir, vec3 shade_pos)\n{\n    vec3 ro = l_pos;\n    vec3 rd = -l_dir;\n    vec3 re = rayMarching(ro, rd);\n    float depthBias = 0.01;\n    bool occlude =  distance(l_pos, re) + MaxError + depthBias < distance(l_pos, shade_pos);\n    return occlude ? .25 : 1.;\n}\n\nvec3 shading(vec3 cam_pos, vec3 shade_pos, vec3 shade_norm, vec3 shade_albedo)\n{\n    vec3 l_pos = vec3(2,10,2);\n    l_pos.xz += vec2(cos(iTime), sin(iTime)) * 5.;\n    vec3 l_color = vec3(1., 1., 1.);\n    float l_intensity = 1.;\n    \n    vec3 l_dir = normalize(l_pos-shade_pos);\n    float lambert = clamp(dot(l_dir, normalize(shade_norm)), 0., 1.);\n    \n    vec3 l_radiance = l_intensity * l_color;\n    vec3 diffuse = diffuse(l_radiance, lambert, shade_albedo);\n    \n    //return diffuse;\n    return diffuse * shadow(l_pos, l_dir, shade_pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n    //fragColor=vec4(uv, 0., 1.);\n\n    vec3 cam_origin =vec3(0.,1.,0.);\n    vec3 cam_dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    vec3 ro = cam_origin;\n    vec3 rd = cam_dir;\n    \n    vec3 re = rayMarching(ro, rd);\n    \n    float d = distance(re, ro) / 6.0;\n    //fragColor=vec4(d, d, d, 1.0);\n    \n    vec3 shade_pos;\n    vec3 shade_norm;\n    vec3 shade_albedo; \n    getShadingAttribute(re, shade_pos, shade_norm, shade_albedo);\n    //fragColor=vec4(shade_albedo, 1.0);\n    \n    vec3 color = shading(cam_origin, shade_pos, shade_norm, shade_albedo);\n    fragColor=vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}