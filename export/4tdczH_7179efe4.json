{"ver":"0.1","info":{"id":"4tdczH","date":"1531593975","viewed":171,"name":"newton cubic","username":"marsipan","description":"Mousex: - translates horizontally,\nMousey - zooms. \nSpacebar - toggle between iteration map and root basin map.\n","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["fractal","newton","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Newton method convergence fractal\n// Polynomial: xÂ³-1 = 0\n//                         -- Paulo Martel 2018\n\n#define PI 3.141593\nfloat bb[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);\n\nfloat coeff = 1.0 ;\n\nfloat log10(float a)\n{\n    return log(a)/log(10.0) ;\n}\n\nvec2 cDiv(vec2 a, vec2 b){\n    return vec2(a.x*b.x+a.y*b.y,a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y);\n}\n\nvec2 cMult(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);\n}\n\nvec2 cPow(vec2 c, int p) {\n    vec2 tmp = vec2(1.0,0.0) ;\n\tfor (int i = 0; i < p; ++i) {\n\t\ttmp = cMult(c, tmp);\n\t}\n    return tmp;\n}\n\nvec2 newtonIter(vec2 c)\n{\n\tvec2 xn1, xn ;\n    xn = c ;\n    //xn1 = xn - cDiv((cMult(cMult(xn,xn),xn)-vec2(1.0,0)),(3.0*cMult(xn,xn))); \n    xn1 = xn - cDiv(cPow(xn,3)-vec2(1.0,0),(3.0*cPow(xn,2))); \n    float i = 0.0 ;\n//    for(; i < 100.0 && length(xn1-xn) > 1.0e-10 ; i++)\n    for(; i < 30.0 && length(xn1-xn) > 1.0e-6 ; i++)\n    {\n       xn = xn1 ; \n       //xn1 = xn - cDiv((cMult(cMult(xn,xn),xn)-vec2(1.0,0)),(3.0*cMult(xn,xn))) ;\n       xn1 = xn - cDiv(cPow(xn,3)-vec2(1.0,0),(3.0*cPow(xn,2))) ;\n    }\n    return vec2(i,xn1.y);\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x / iResolution.y ;\n    uv = uv - vec2(0.5*ar,0.5) ;\n    uv = 4.0*uv ;\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec2 mm = vec2(iMouse.xy/iResolution.xy);\n    //vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y ;\n    //mm.x *= ar ;\n    //mm = vec2(0.0,-0.0) ;\n    float f = 0.4 ;\n    float fact = (1.0+f)/2.0+((1.0-f)/2.0)*cos(iTime*2.0*PI/30.0) ;\n    fact = pow(fact,8.0);\n    if(true) \n    {\n    \tfact = (2.0*iResolution.y-2.0*iMouse.y)/iResolution.y ;\n        fact = pow(fact,1.4) ;\n        uv *= fact ;\n    }\n    else\n    {\n    \tuv.y += 4.0*(iResolution.y-iMouse.y)/iResolution.y-3.0 ;\n    }\n    uv.x += (4.0*(iResolution.x-iMouse.x)/iResolution.x-4.0)/1.0 ;\n    //float cc =  smoothstep(0.29,0.3,pow(length(mm-uv),0.5)) ;\n    // Output to screen\n    //float maxc = 40.0*(1.0+0.5*cos(5.0*iTime)) ;\n    //coeff *= iMouse.x / iResolution.x ;\n    float maxc = 40.0 ;\n    float cc = newtonIter(uv).x/maxc ;\n    float iRoot = newtonIter(uv).y ;\n    //cc = 1.0+log(1.1*cc+0.09) ;\n    cc = 1. - cc ;\n    if(texelFetch( iChannel0, ivec2(32,0), 0 ).x != 0.0) {\n        //fragColor = vec4(iRoot<-0.5,iRoot>0.5,abs(iRoot)<0.5,1.0);\n        //fragColor = 1.5*mix(vec4(iRoot<-0.5,iRoot>0.5,abs(iRoot)<0.5,1.0),\n        //                vec4(1.-cc,1.-cc,1.-cc,1.0),0.5);\n        fragColor = vec4(float(iRoot<-0.5)*cc,float(iRoot>0.5)*cc,float(abs(iRoot)<0.5)*cc,1.0) ;\n    }\n    else {\n        fragColor = vec4(cc,cc,0.0,1.0);\n    }\n}\n\n\n//   if(texelFetch( iChannel0, ivec2(37,0), 0 ).x > -2.0)\n//    {\n//    \tfact = (iResolution.y-iMouse.y)/iResolution.y ;\n//        fact = pow(fact,1.4) ;\n//        uv *= fact ;\n//    }\n//    if(texelFetch( iChannel0, ivec2(37,0), 0 ).x == 0.0)\n//    {\n//    \tuv.y += 4.0*(iResolution.y-iMouse.y)/iResolution.y-4.0 ;\n//    }\n","name":"Image","description":"","type":"image"}]}