{"ver":"0.1","info":{"id":"XXVGRd","date":"1718092628","viewed":41,"name":"strange thing #101","username":"Kenzodabarra","description":"a draft of my next work to be mounted on some market to be decided","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nfloat parallaxDistance1=0.1;\nfloat parallaxDistance2=0.1;\nfloat parallaxDistance3=0.1;\nfloat col1=0.5;\nfloat col2=0.1;\nfloat col3=0.8;\nfloat col11=0.9;\nfloat col22=0.7;\nfloat col33=0.2;\nfloat asseZ=26.0;\nuniform sampler2D fogTexture;\n\n#define MAX_STEPS 100\n#define EPSILON 0.001\n\n// Hash function for Perlin noise\nfloat hash(float n) {\n    return fract(sin(n) * 1e4);\n}\n\n// Function to generate Perlin noise\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = dot(i, vec3(1.0, 57.0, 113.0));\n    return mix(\n        mix(\n            mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n        mix(\n            mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\n\n// Function to generate metal texture with reflection turbulence\nvec3 metalTexture(vec3 p) {\n    float scale = 200.0;\n    vec3 reflection = vec3(p.xy, abs(p.z));\n    vec3 color = vec3(0.0);\n    float turbulence = 0.0;\n    float weight = 0.8;\n    for (int i = 0; i < 14; i++) {\n        turbulence += weight * noise(reflection * scale);\n        reflection *= 200.0;\n        weight *= 0.5;\n    }\n    color = vec3(turbulence);\n    return color;\n}\n\n// Wood texture\nvec3 woodTexture(vec3 pos) {\n    float noiseValue = noise(pos * 10.0);\n    float rings = mod(pos.x * 10.0 + noiseValue, 1.0);\n    vec3 woodColor = mix(vec3(col1, col2, col3), vec3(col11, col22, col33), rings);\n    return woodColor;\n}\n\nfloat distortedBuilding(vec3 p, vec3 buildingPos, float height) {\n    float baseRadius = 0.1 + 0.05 * sin(iTime * 3.0);  \n    float topRadius = 1.0 + 0.2 * sin(iTime * 1.5);   \n    buildingPos.x += sin(iTime * 0.3) * 3.0 + sin(iTime * 0.6) * 1.5;\n    buildingPos.z += cos(iTime * 0.4) * 3.0 + cos(iTime * 0.7) * 1.5;\n    float radius = mix(baseRadius, topRadius, p.y / height);\n    vec2 baseSize = vec2(radius, radius);\n    vec2 d = abs(p.xz - buildingPos.xz) - baseSize / 2.0;\n    float distToBuilding = length(max(d, 0.0)) - 0.05;\n    float twist = sin(p.y * 10.0 + iTime * 5.0) * 0.2;\n    vec3 twistedPos = vec3(p.x * cos(twist) - p.z * sin(twist), p.y, p.x * sin(twist) + p.z * cos(twist));\n    float distortion = sin(twistedPos.x * 5.0 + iTime) * 0.1 + cos(twistedPos.z * 5.0 + iTime) * 0.1;\n    return distToBuilding + distortion;\n}\n\nfloat distortedBuildingTORNADO(vec3 p, vec3 buildingPos, float height) {\n    float baseRadius = 0.1;  \n    float topRadius = 1.0;   \n    float radius = mix(baseRadius, topRadius, p.y / height);\n    vec2 baseSize = vec2(radius, radius);\n    float baseHeight = 0.1;\n    buildingPos.x += sin(buildingPos.z + iTime) * 0.5;\n    buildingPos.z += sin(buildingPos.x + iTime) * 0.5;\n    buildingPos.y += noise(buildingPos * 5.0 + iTime) * 0.5;\n    vec2 d = abs(p.xz - buildingPos.xz) - baseSize / 2.0;\n    float distToBuilding = length(max(d, 0.0)) - 0.05;\n    float distToTop = max(p.y - (buildingPos.y + baseHeight), p.y - (buildingPos.y + height));\n    float distortion = sin(p.x * 5.0 + iTime) * 0.1 + sin(p.z * 5.0 + iTime) * 0.1;\n    return min(distToBuilding + distortion, distToTop + distortion);\n}\n\n// Function to create a distorted abstract building\nfloat distortedBuilding2(vec3 p, vec3 buildingPos, float height) {\n    vec2 baseSize = vec2(1.0, 1.0);\n    float baseHeight = 0.1;\n    buildingPos.x += sin(iTime * 0.3) * 3.0 + sin(iTime * 0.6) * 1.5;\n    buildingPos.z += cos(iTime * 0.4) * 3.0 + cos(iTime * 0.7) * 1.5;\n    buildingPos.y += noise(buildingPos * 5.0 + iTime) * 0.5;\n    vec2 d = abs(p.xz - buildingPos.xz) - baseSize / 2.0;\n    float distToBuilding = length(max(d, 0.0)) - 0.05;\n    float distToTop = max(p.y - (buildingPos.y + baseHeight), p.y - (buildingPos.y + height));\n    float distortion = sin(p.x * 5.0 + iTime) * 0.1 + sin(p.z * 5.0 + iTime) * 0.1;\n    return min(distToBuilding + distortion, distToTop + distortion);\n}\n\nfloat scene1(vec3 p) {\n    vec3 buildingPos = vec3(0.0, 0.0, 0.0); \n    float height = 5.0;                     \n    return distortedBuilding(p, buildingPos, height);\n}\n\n// Function to create a scene with multiple distorted abstract buildings\nfloat scene(vec3 p) {\n    vec3 buildingPos1 = vec3(-2.0, 0.0, 6.0);\n    vec3 buildingPos2 = vec3(0.0, 0.0, 2.0);\n    vec3 buildingPos3 = vec3(2.0, 0.0, -2.0);\n    float height1 = 3.0;\n    float height2 = 4.0;\n    float height3 = 5.0;\n    float dist1 = distortedBuilding2(p, buildingPos1, height1);\n    float dist2 = distortedBuilding2(p, buildingPos2, height2);\n    float dist3 = distortedBuilding(p, buildingPos3, height3);\n    return min(dist1, min(dist2, dist3));\n}\n\n// Function to calculate shadow\nfloat calculateShadow(vec3 origin, vec3 direction, float maxDist) {\n    float shadowIntensity = 1.0;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = origin + dist * direction;\n        float sceneDist = scene(p);\n        if (sceneDist < EPSILON || dist > maxDist) break;\n        shadowIntensity = min(shadowIntensity, 50.0 * sceneDist / dist);\n        dist += sceneDist;\n    }\n    return shadowIntensity;\n}\n\n// Function to calculate normal vector for shading\nvec3 calculateNormal(vec3 p) {\n    vec2 offset = vec2(EPSILON, 0);\n    return normalize(vec3(\n        scene(p + offset.xyy) - scene(p - offset.xyy),\n        scene(p + offset.yxy) - scene(p - offset.yxy),\n        scene(p + offset.yyx) - scene(p - offset.yyx)\n    ));\n}\n\n// Function to cast a ray and find the intersection point with the scene\nvec3 castRay(vec3 origin, vec3 direction) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = origin + totalDistance * direction;\n        float dist = scene(p);\n        if (dist < EPSILON) return p;\n        totalDistance += dist;\n        if (totalDistance > 100.0) break;\n    }\n    return origin + totalDistance * direction;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 backgroundColor = vec3(0.0, 0.0, 0.1); \n\n    vec3 cameraPos = vec3(0.0, 6.0, asseZ);\n    vec3 cameraTarget = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), cameraDir));\n    vec3 up = cross(cameraDir, right);\n\n    vec3 rayDir = normalize(cameraDir + uv.x * right + uv.y * up);\n    vec3 rayOrigin = cameraPos;\n\n    vec3 p = castRay(rayOrigin, rayDir);\n\n    float distanceFromCamera = length(p - cameraPos);\n    float fogDensity = smoothstep(0.0, 10.0, distanceFromCamera) * 0.1;\n    fogDensity += sin(iTime) * 0.5;\n\n    float fogIntensity = texture(fogTexture, uv).r;\n    fogDensity *= fogIntensity;\n\n    vec3 fogColor = vec3(0.0);\n    vec3 fog = fogColor * fogDensity;\n\n    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n    vec3 lightDir = normalize(lightPos - p);\n    float diffuse = max(dot(calculateNormal(p), lightDir), 0.0);\n    float shadow = calculateShadow(p, lightDir, 10.0);\n\n    vec3 color = mix(backgroundColor, fog, fogDensity);\n    color += woodTexture(p);\n    color += metalTexture(p) * diffuse * shadow;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}