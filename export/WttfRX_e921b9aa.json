{"ver":"0.1","info":{"id":"WttfRX","date":"1613169013","viewed":139,"name":"Colors as Positions","username":"oneshade","description":"I've wondered what the pixels in an image look like if their colors were used as positions and I finally was able to find out by using buffers! You can look around with the mouse.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["3d","distancefields","colors","mapping","image","buffering","positions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\n// Returns filtered sample from Buffer A as a vec4(red, green, blue, distance)\n#define fetch(p) texelFetch(iChannel0, ivec2(_322(p, SIZE, RESOLUTION, iChannelResolution[0].xy)), 0)\nvec4 sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        vec3 sp = mod(p + halfSize, SIZE) - halfSize;\n        if (filt == 0) {\n            return fetch(sp);\n        }\n\n        else {\n            vec3 UNIT = SIZE / RESOLUTION;\n            vec3 cell = floor(sp / UNIT) * UNIT;\n            vec3 local = fract(sp / UNIT);\n\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            vec4 ldb = fetch(cell);\n            vec4 rdb = fetch(cell + vec3(UNIT.x, 0.0, 0.0));\n            vec4 lub = fetch(cell + vec3(0.0, UNIT.y, 0.0));\n            vec4 rub = fetch(cell + vec3(UNIT.xy, 0.0));\n            vec4 ldf = fetch(cell + vec3(0.0, 0.0, UNIT.z));\n            vec4 rdf = fetch(cell + vec3(UNIT.x, 0.0, UNIT.z));\n            vec4 luf = fetch(cell + vec3(0.0, UNIT.yz));\n            vec4 ruf = fetch(cell + UNIT);\n\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.25;\n    float bbox = max(q.x, max(q.y, q.z));\n    return vec4(0.0, 0.0, 0.0, bbox);\n}\n\nvec4 mapScene(in vec3 p) {\n    return sampleDistanceField(p, 1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.05, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).w - mapScene(p - e.xyy).w,\n                          mapScene(p + e.yxy).w - mapScene(p - e.yxy).w,\n                          mapScene(p + e.yyx).w - mapScene(p - e.yyx).w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0) mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray and light direction\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Intersect bbox to prevent raymarching artifacts\n    float t = iBox(ro, rd, SIZE * 0.49); // The box has to be a bit smaller to prevent artifacts\n    if (t > 0.0) {\n        vec3 p = ro + rd * t;\n        if (mapScene(p).w > 0.0) {\n            for (int i=0; i < 100; i++) {\n                vec3 p = ro + rd * t;\n                vec4 d = mapScene(p);\n                if (d.w < 0.001) {\n                    vec3 n = getNormal(p);\n                    fragColor.rgb += d.rgb * max(0.2, dot(n, l));\n                    break;\n                }\n\n                if (t > 100.0) {\n                    break;\n                }\n\n                t += d.w;\n            }\n        }\n\n        else {\n            vec3 color = mapScene(p).rgb;\n            vec3 n = getNormal(p);\n            fragColor.rgb += color * max(0.2, dot(n, l));\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PIXELS_PER_FRAME 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1000000.0);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        vec3 p = _223(fragCoord, SIZE, RESOLUTION, iResolution.xy);\n\n        for (int offset=0; offset < PIXELS_PER_FRAME; offset++) {\n            float frame = float(iFrame * PIXELS_PER_FRAME + offset);\n            float x = mod(frame, iChannelResolution[0].x);\n            float y = (frame - x) / iChannelResolution[0].x;\n            vec3 c = texture(iChannel1, vec2(x, y) / iChannelResolution[0].xy).xyz;\n            vec3 o = c * SIZE - 0.5 * SIZE;\n\n            float newShape = length(p - o) - 0.1;\n            if (newShape < fragColor.w) {\n                fragColor.rgb = c;\n                fragColor.w = newShape;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// RESOLUTION is the number of distance samples, SIZE is the space it maps to\n#define RESOLUTION vec3(45.0)\n#define SIZE vec3(3.0)\n\nvec3 _223(in vec2 p2D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p2D = floor(p2D);\n    float p1D = p2D.y * res2D.x + p2D.x;\n    float x = mod(p1D, res3D.x);\n    float y = mod(p1D - x, res3D.x * res3D.y) / res3D.x;\n    float z = (p1D - x - y * res3D.x) / res3D.x / res3D.y;\n    return vec3(x, y, z) / res3D * size3D - 0.5 * size3D;\n}\n\nvec2 _322(in vec3 p3D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p3D = floor(p3D / size3D * res3D + 0.5 * res3D);\n    float p1D = p3D.z * res3D.x * res3D.y + p3D.y * res3D.x + p3D.x;\n    float x = mod(p1D, res2D.x);\n    float y = (p1D - x) / res2D.x;\n    return vec2(x, y);\n}\n\n// Box intersector from https://www.shadertoy.com/view/ld23DV\nfloat iBox(in vec3 ro, in vec3 rd, in vec3 b) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * b;\n    vec3 t1 = -(k + n);\n    vec3 t2 = +(k - n);\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    return tN;\n}","name":"Common","description":"","type":"common"}]}