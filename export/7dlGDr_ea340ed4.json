{"ver":"0.1","info":{"id":"7dlGDr","date":"1617470286","viewed":200,"name":"Vector Machine","username":"BenO","description":"Exploring 2D line rendering and ended up having fun with the oldschool vibe of it.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["wireframe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --------------\n// Screen Effects\n// --------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // bounce\n    float bt = min(fract(iTime*0.2)*5.,1.);\n    float bc = pow(sin(pow(fract(bt),.3)*3.14), 5.)*sin(bt*20.);\n    vec2 uvb = vec2(uv.x,uv.y+bc*2.);\n    \n    // line scanline offset\n    float lofs = sign(fract(uv.y*100.)-.5);\n    vec2 uvo = vec2(uvb.x + lofs*0.001, uvb.y);\n\n    // base picture\n    vec3 col = vec3(0.,0.,0.);\n    vec4 line = 1.-texture(iChannel0, uvb);\n    vec3 cl = mix(vec3(0.,.1,0.), vec3(0.,1.,0.), line.x);\n    cl *= 1.-line.w;\n    col += cl;\n    \n    // -------------------------------------\n    // Blur\n    // https://www.shadertoy.com/view/Xltfzj\n    // -------------------------------------\n    float Pi = 6.28318530718;    \n    float Directions = 16.0;\n    float Quality = 7.0;\n    float Size = 10.;\n    vec2 Radius = Size/iResolution.xy;    \n    vec4 Color = texture(iChannel0, uv);    \n    \n    for( float d=0.0; d<Pi; d+=Pi/Directions){\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += 1.-texture( iChannel0, uvo+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    Color /= Quality * Directions - 15.0;\n    \n    // --------------\n    // Stack Effects\n    // --------------\n    \n    // blur layer\n    vec3 cl2 = mix(vec3(0.,.1,0.), vec3(0.,1.,0.), Color.x)*Color.x*5.;\n    cl2 *= pow(1.-Color.w, .6);    \n    col += cl2*4.;\n    \n    // flicker\n    float its = ((((sin(iTime*2.)*.5)+.5)*.6)+.4);\n    float its2 = ((((sin(iTime*40.)*.5)+.5)*.3)+.7);\n    col *= its * its2;\n    \n    // curvature\n    float crv = 1.-pow(length((uv-0.5)*1.5),4.*its2);\n    vec3 crvc = crv*vec3(0.,1.,0.);\n    crvc *= (lofs*.1)+.9;    \n    crvc *= 1.-bc;\n    col = clamp(col,0.,1.) + crvc*0.25 + ((1.-its)*(1.-its2))*0.1;\n        \n    // highlight\n    float hl = pow(1.-length((uv-0.8)*vec2(.4,.7)), 5.);    \n    col += hl*0.4;\n    \n    // Output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 cmP = vec3(0,0,-2.);\nvec3 tgt = vec3(0,0,-.5);\n\nvec3 Rot(vec3 a, vec3 p, vec3 ct){\n    mat3 rx = mat3(vec3(1, 0, 0),vec3(0, cos(a.x), -sin(a.x)),vec3(0, sin(a.x), cos(a.x)));\n    mat3 ry = mat3(vec3(cos(a.y), 0, sin(a.y)),vec3(0, 1, 0),vec3(-sin(a.y), 0, cos(a.y)));\n    mat3 rz = mat3(vec3(cos(a.z), -sin(a.z), 0),vec3(sin(a.z), cos(a.z), 0),vec3(0, 0, 1));\n    return rx*ry*rz*(p-ct)+ct;\n}\n\n// -------------------------------------\n// Render 2D lines\n// https://www.shadertoy.com/view/3st3zN\n// -------------------------------------\nfloat Line(vec2 pos, vec2 p1, vec2 p2, float w){    \n    float m = (p1.y - p2.y)/(p1.x - p2.x);\n    float c = p1.y - m*p1.x;\n    vec2 line = vec2((pos.y-c)/m, pos.x*m+c);\n    float dist = 0.;\n    if ((pos.y > line.y-w && pos.y < line.y+w) || (pos.x > line.x-w && pos.x < line.x+w))\n        dist = 1.;\n    return dist;    \n}\n\nfloat ScrDst(vec2 p, out float alpha){\n    // -----------------------------------\n    // Convoluted way of making primitives\n    // -----------------------------------\n    float num = 27.;\n    vec3 pts[27];\n    vec3 st = normalize(vec3(.7,0.,-0.7));    \n    int c =0;\n    float ld = 0.;    \n    \n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                \n                // segmented cube\n                vec3 npl = (vec3(float(i)-1.,(float(j)-1.),(float(k)-1.)))*.75;\n                \n                // spherize\n                vec3 nps = normalize(npl)*1.2;\n                \n                // snap to simple cube\n                vec3 npc = (floor(npl)*1.3+.5)*1.2;\n                \n                // pyramid\n                float pa = (atan(nps.x, nps.z) + 3.14159) / 6.28318;\n                float flr = ((floor(pa*3.)/3.) * 6.28318) - 3.14159;\n                vec3 npp = vec3(cos(flr),nps.y,sin(flr));\n                npp = nps.z>0.?vec3(0.,1.,0.):vec3(npp.x,-1.,npp.z);\n                \n                // mix shapes\n                float cm = clamp(((abs(fract(iTime*.1)-.5)*2.)-.4)*3.,0.,1.);\n                float cm2 = clamp(((abs(fract((iTime+3.)*.2)-.5)*2.)-.4)*3.,0.,1.);\n                vec3 npo = mix(nps,npc,cm);\n                npo = mix(npo, npp, cm2);\n                ld = mix(1., 1.7, cm);\n                ld = mix(ld, 3.5, cm2); \n                pts[c]= npo;\n                \n                c+=1;\n            }\n        }\n    }\n    \n    // ---------------------------------------------------\n    // Rotate and flatten points to some pseudo projection\n    // ---------------------------------------------------\n    vec2[pts.length()] tpts;\n    float dist;    \n    alpha = 0.;\n    for(int i=0;i<pts.length();i++)    {\n        vec3 tp = Rot(vec3(.5, iTime*.35, iTime*.3), pts[i], vec3(0.,0.,0.));\n        pts[i]= tp;\n        vec3 scp = normalize(tp-cmP);\n        scp *= pow(length(scp.xy),.3)*.7;\n        scp.y *= iResolution.x/iResolution.y;\n        tpts[i]= scp.xy*.5+.5;\n    }\n    \n    // ------------\n    // render lines\n    // ------------\n    for(int i=0;i<pts.length();i++){\n        for(int j=0;j<pts.length();j++){\n            if(i!=j){\n                if(distance(pts[i], pts[j])<ld && distance(pts[i], pts[j])>.5\n                    && dot(normalize(tpts[i]-p),normalize(tpts[j]-p)) < -.9){\n                    float lc = Line(p, tpts[i], tpts[j], .003);\n                    alpha = max(alpha, lc);\n                    // ----------------------------------------\n                    // Use 3D depth to create 2D gradient\n                    // ----------------------------------------\n                    float d1 = (distance(cmP, pts[i])-2.);\n                    float d2 = (distance(cmP, pts[j])-2.);\n                    float sd1 = distance(p,tpts[i]);\n                    float sd2 = distance(tpts[i],tpts[j]);\n                    float itv = clamp(sd1 / sd2, 0.,1.);\n                    float dpth = clamp(mix(d1,d2,itv),0.,1.);\n                    // add color\n                    dist = max(dist, lc*(1.-dpth));\n                    break;\n                }\n            }\n        }\n    }    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    float a = 0.;\n    float c = 1.-ScrDst(uv, a);\n\n    // Output\n    fragColor = vec4(c,c,c,a);\n}","name":"Buffer A","description":"","type":"buffer"}]}