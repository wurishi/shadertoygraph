{"ver":"0.1","info":{"id":"wtfyWj","date":"1593051545","viewed":208,"name":"Ellipse Distance Comparison","username":"harry7557558","description":"Comparing two ellipse distance methods found on the internet.\n\nmouseable","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","ellipse","compare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparing two ellipse distance methods found on the internet\n// The solution that solves a quartic equation is in Common\n// The iteration method works ~1.2 times faster than the analytical one\n// Step length may need to be reduced when using the iteration method in raymarching\n\n\n\n// This iteration method is introduced in\n// https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n\n// Line 23: the asin() is removed to increase performance\n\nfloat sdEllipse_iter(vec2 p, vec2 ab){\n    p = abs(p);\n    float t = 0.785398;\n    vec2 xy;\n    for (int i=0;i<3;i++){\n        vec2 cs = vec2(cos(t),sin(t));\n        xy = ab*cs;\n        vec2 e = (ab.x*ab.x-ab.y*ab.y)*vec2(1,-1)*cs*cs*cs/ab;\n        vec2 r = xy-e, q = p-e;\n        //float rm = length(r), qm = length(q);\n        //float dc = rm*asin((r.x*q.y-r.y*q.x)/(rm*qm));\n        float dc = (r.x*q.y-r.y*q.x)/length(q);\n        float dt = dc/sqrt(dot(ab,ab)-dot(xy,xy));\n        t += dt;\n        t = min(1.570796,max(0.,t));\n    }\n    vec2 q = p/ab;\n    return sign(dot(q,q)-1.)*length(p-xy);\n}\n\n\n\n\n#define res iResolution.xy\n#define AA 16\n\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 ab = vec2(1.+.8*cos(iTime),1.);\n    float SC = 7./res.x;\n    float T = iMouse.z>0.?SC*(iMouse.x-.5*res.x):1e8;\n    vec2 p0 = SC*(Pos-.5*res);\n    \n    // use AA to waste time to compare performance\n    float d = 0.;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 p = p0+SC*vec2(i,j)/float(AA);\n        if (p.x<T) d += sdEllipse_iter(p,ab);\n        else d += sdEllipse(p,ab);\n    }\n    d /= float(AA*AA);\n    \n    // color\n    vec3 col = vec3(.8)-sign(d)*vec3(.1,.4,.2);\n    col *= (.2*cos(60.*d)+.8)*(1.-exp(-5.*abs(d)));\n    col = mix(col,vec3(1,1,0),clamp(2.-60.*abs(d),0.,1.));\n    col = mix(col,vec3(1),clamp(2.-60.*abs(p0.x-T),0.,1.));\n    Col = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ellipse distance function copy-pasted from iq\n// https://iquilezles.org/articles/ellipsedist\n\n\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = abs( z ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n","name":"Common","description":"","type":"common"}]}