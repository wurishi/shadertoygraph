{"ver":"0.1","info":{"id":"ll3cWs","date":"1534623160","viewed":87,"name":"Simple fractal","username":"drcd1","description":"First shader. Testing the render of a mandelbulb fractal in shadertoy. Rotate the fractal with the left mouse button.\nThe power in the sequence formula (z_{n+1} = z_{n}^p + c ) varies between 2 and 8.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER_SM 50\n#define MAX_ITER_FRACTAL 10\n#define M_PI 3.14159265358979323846 \nstruct ray {\n\tvec3 o;\n    vec3 d;\n};\nstruct sphere{\n\tvec3 o;\n    float size;\n};\nstruct intersection{\n    vec3 n;\n};\n\nfloat de(vec3 x){\t \n    float power = 8.0f;\n    vec3 z = x;\n    float dr = 1.0f;\n    float r = 0.0f;\n    for (int i = 0; i <5 ; i++) {\n        r = length(z);\n        if (r>2.0f) break;\n\n        float phi = asin(z.z/r);\n        float theta = atan(z.y,z.x);\n        dr =  pow( abs(r), power-1.0f)*power*dr + 1.0f;\n\n        float zr = pow( abs(r),power);\n\n        phi = phi*power;\n        theta = theta*power;\n\n        z = vec3(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta))*zr;\n        z = z+x;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n\nfloat de(vec3 x, float power){\t \n    vec3 z = x;\n    float dr = 1.0f;\n    float r = 0.0f;\n    for (int i = 0; i < MAX_ITER_FRACTAL ; i++) {\n        r = length(z);\n        if (r>2.0f) break;\n        float phi = asin(z.z/r);\n        float theta = atan(z.y,z.x);\n        dr =  dr*pow( abs(r), power-1.0f)*power + 1.0f;\n        float zr = pow( abs(r),power);\n        phi = phi*power;\n        theta = theta*power;\n        z = vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), -sin(phi))*zr;\n        z = z+x;\n    }\n    return 0.5*log(r)*r/dr;\n}\nvec3 grad(vec3 x){\n    vec3 dx = vec3(1e-3f,0,0);\n    vec3 dy = vec3(0,1e-3f,0);\n    vec3 dz = vec3(0,0,1e-3f);\n\treturn vec3((de(x+dx)-de(x))*1e3f,(de(x+dy)-de(x))*1e3f,(de(x+dz)-de(x))*1e3f);\n}\nstruct sm_ret{\n\tfloat t;\n    int it;\n};\nsm_ret spheremarch(ray r, float minT, float maxT, float power){\n    int i;\n    sm_ret ret;\n\tfloat t = minT;\n    while(i<MAX_ITER_SM && t<maxT){\n        vec3 x = r.o + r.d*t;\n        float dist = de(x, power);\n        t+=dist;\n        if(dist<1e-4){\n        \tbreak;\n        }\n       \ti++;\n    \t\n    }\n\tif(i==MAX_ITER_SM || t>=maxT)\n        t = maxT+1.0f;\n\n    ret.t = t;\n    ret.it = i;\n\treturn ret;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\n\tfloat theta = (iMouse.x/iResolution.x-0.5f)*2.0f*M_PI;\n\tfloat phi = iMouse.y/iResolution.y*M_PI;\n    mat3 rot;\n    \n    float a = cos(-theta);\n    float b = sin(-theta);\n    float c = cos(phi);\n    float d = sin(phi);\n    \n    rot[0][0]=a;\n    rot[1][0]=-b*c;\n    rot[2][0]= b*d;\n    rot[0][1]= b;\n    rot[1][1]= a*c;\n    rot[2][1]= -a*d;\n    rot[0][2]= 0.0f;\n    rot[1][2]= d;\n    rot[2][2]= c;\n    \n  \tray r;\n    r.o.x=0.0f;\n    r.o.y=0.0f;\n    r.o.z=2.0f;\n    \n\tr.d.x = (uv.x-0.5f)*aspect;\n    r.d.y = uv.y-0.5f;\n    r.d.z = -1.0f;\n    \n    r.o = rot*r.o;\n    r.d = rot*r.d;\n    \n    r.d = normalize(r.d);\n    float power = (cos(iTime*0.2f)+1.0f)*0.5f*6.0f+2.0f;\n\tvec3 col;\n    sm_ret ret= spheremarch(r,0.01f, 8.0f, power);\n    if(ret.t<8.0f){\n       \t// vec3 normal = grad(r.o + ret.t*r.d);\n       \t//col.x=col.y=col.z=max(dot(normal,normalize(vec3(1.0f,1.0f,1.0f))),0.0f);\n\t\tcol.x = col.y = col.z = 1.0f-float(ret.it)/float(MAX_ITER_SM);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}