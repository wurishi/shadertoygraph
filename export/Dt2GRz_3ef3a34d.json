{"ver":"0.1","info":{"id":"Dt2GRz","date":"1672765442","viewed":127,"name":"Recursive Irregular Blocks SDF","username":"jt","description":"Recursive application of [url=https://www.shadertoy.com/view/ftcfWf]Asymmetric Blocks SDF[/url] (unrolled two iterations):\n1. (integral) application for regularity of pattern\n2. (float) application for actual SDF\nOptimized to solve compile-time issue.","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["recursive","blocks","architecture","construction","building","layout","limited","asymmetric"],"hasliked":0,"parentid":"ctB3zR","parentname":"Recursive Asymmetric Blocks SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/Dt2GRz Recursive Irregular Blocks SDF by jt\n// somewhat optimized variant of https://www.shadertoy.com/view/ctB3zR Recursive Asymmetric Blocks SDF\n// based on https://www.shadertoy.com/view/cd2XR3 Limited Asymmetric Blocks SDF\n// based on https://www.shadertoy.com/view/ftcfWf Asymmetric Blocks SDF\n\n// Recursive application of asymmetric / irregular blocks (unrolled two iterations):\n// 1. (integral) application determines regularity of pattern\n// 2. (float) application determines actual signed distance field\n\n// tags: blocks, architecture, construction, building, layout, limited, asymmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Algorithm idea from https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane\n// (re-implemented from scratch by jt).\n\n// Some notes about the optimization applied here.\n// I suspect the long compile-time of the original shader\n// could possibly have been caused by common subexpression elimination\n// so in this optimized version I've tried to reduce the number of similar calls\n// (mainly to the hash function and to insidebox).\n// For example, instead of computing the distance in each branch\n// now the function returns a struct containing min and max coordinates,\n// so the caller can calculate the distance based on that in a single call.\n// I also pulled the hash calls in front of the branches and combined them\n// (the hash function runs now in parallel,\n//  i.e. instead of type uint -> uint it now has type uvec2 -> uvec2).\n// I guessed it might be better to throw away half of the computed hash values\n// (as long as they are computed by on hash call \"in parallel\")\n// as long as the number of calls to the hash function is halved, too.\n\n// It appears the optimized shader now compiles approximately 25 times faster\n// based on a very small sample size ;-)\n\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuvec2 triple32(uvec2 x) // calculate two hashes in parallel\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuvec2 lowbias32(uvec2 x) // calculate two hashes in parallel\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n#define HASH(u) triple32(u)\n//#define HASH(u) lowbias32(u)\n\nuvec2 uhash(ivec2 v)\n{\n    return HASH((uvec2(v.x)*2u+uvec2(0,1) + HASH(uvec2(v.y)*2u+uvec2(0,1))) /*+ uint(iFrame / 120)*/);\n}\n\nint insidebox(ivec2 p, ivec2 p0, ivec2 p1) // inside of min-max box\n{\n    ivec2 d = abs(2*p-(p1+p0))-(p1-p0);\n    return max(d.x,d.y)/2;\n}\n\n// NOTE: power-of-two sizes used to avoid modulo and division\n#define RESEXP 3u\n#define RES (1 << RESEXP)\n#define RESMASK (uint(RES - 1))\n\nstruct block\n{\n    ivec2 id;\n    ivec2 v0;\n    ivec2 v1;\n};\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// xy contains id, z contains distance\nblock blocks_layout(ivec2 p) // https://www.shadertoy.com/view/ctB3zR Recursive Asymmetric Blocks SDF by jt\n{\n    ivec2 tile = p >> RESEXP; // global coordinates of tile\n    //ivec2 clear = p & int(~RESMASK); // remove local coordinates\n    ivec2 clear = tile << RESEXP; // remove local coordinates\n\n    ivec2 center = clear + ivec2(RESMASK & uhash((tile))); // x/y-coordinate of vertical/horizontal line through this tile\n    ivec2 sw = clear + ivec2(RESMASK & uhash((tile+ivec2(-1,-1))))+ivec2(-RES,-RES); // x/y-coordinate of vertical/horizontal line through south-west tile\n    ivec2 nw = clear + ivec2(RESMASK & uhash((tile+ivec2(-1,+1))))+ivec2(-RES,+RES); // x/y-coordinate of vertical/horizontal line through north-west tile\n    ivec2 se = clear + ivec2(RESMASK & uhash((tile+ivec2(+1,-1))))+ivec2(+RES,-RES); // x/y-coordinate of vertical/horizontal line through south-east tile\n    ivec2 ne = clear + ivec2(RESMASK & uhash((tile+ivec2(+1,+1))))+ivec2(+RES,+RES); // x/y-coordinate of vertical/horizontal line through north-east tile\n    ivec2 w = clear + ivec2(RESMASK & uhash((tile+ivec2(-1, 0))))+ivec2(-RES,0); // y/x-coordinate of horizontal/vertical line through west tile\n    ivec2 e = clear + ivec2(RESMASK & uhash((tile+ivec2(+1, 0))))+ivec2(+RES,0); // y/x-coordinate of horizontal/vertical line through east tile\n    ivec2 s = clear + ivec2(RESMASK & uhash((tile+ivec2( 0,-1))))+ivec2(0,-RES); // y/x-coordinate of horizontal/vertical line through south tile\n    ivec2 n = clear + ivec2(RESMASK & uhash((tile+ivec2( 0,+1))))+ivec2(0,+RES); // y/x-coordinate of horizontal/vertical line through north tile\n\n    //bool flip = (tile.x % 2) == (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) == (tile.y & 1);\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n    if(flip) // vertical line goes through\n    {\n        if(p.x < center.x)\n        {\n            if(p.y < w.y)\n            {\n                return\n                    block // south-west\n                    (\n                        ivec2(tile.x, tile.y),\n                        ivec2(sw.x, s.y), ivec2(center.x, w.y)\n                    );\n            }\n            else\n            {\n                return\n                    block // north-west\n                    (\n                        ivec2(tile.x, tile.y + 1),\n                        ivec2(nw.x, w.y), ivec2(center.x, n.y)\n                    );\n            }\n        }\n        else\n        {\n            if(p.y < e.y)\n            {\n                return\n                    block // south-east\n                    (\n                        ivec2(tile.x + 1, tile.y),\n                        ivec2(center.x, s.y), ivec2(se.x, e.y)\n                    );\n            }\n            else\n            {\n                return\n                    block // north-east\n                    (\n                        ivec2(tile.x + 1, tile.y + 1),\n                        ivec2(center.x, e.y), ivec2(ne.x, n.y)\n                    );\n            }\n        }\n    }\n    else // horizontal line goes through\n    {\n        if(p.y < center.y)\n        {\n            if(p.x < s.x)\n            {\n                return\n                    block // south-west\n                    (\n                        ivec2(tile.x, tile.y),\n                        ivec2(w.x, sw.y), ivec2(s.x, center.y)\n                    );\n            }\n            else\n            {\n                return\n                    block // south-east\n                    (\n                        ivec2(tile.x + 1, tile.y),\n                        ivec2(s.x, se.y), ivec2(e.x, center.y)\n                    );\n            }\n        }\n        else\n        {\n            if(p.x < n.x)\n            {\n                return\n                    block // north-west\n                    (\n                        ivec2(tile.x, tile.y + 1),\n                        ivec2(w.x, center.y), ivec2(n.x, nw.y)\n                    );\n            }\n            else\n            {\n                return\n                    block // north-east\n                    (\n                        ivec2(tile.x + 1, tile.y + 1),\n                        ivec2(n.x, center.y), ivec2(e.x, ne.y)\n                    );\n            }\n        }\n    }\n}\n\nbool regularity(ivec2 v)\n{\n    block result = blocks_layout(v);\n    //return (result.id.x & 1) != (result.id.y & 1);\n    return insidebox(v, result.v0, result.v1) >= -1;\n}\n\nbool boundary(ivec2 v)\n{\n    //if(any(equal((uvec2(v) & RESMASK)>>1, uvec2(0)))) return false; // tried \"doors\" (failed)\n    block result = blocks_layout(v);\n    //return (result.id.x & 1) != (result.id.y & 1);\n    int d = insidebox(v, result.v0, result.v1+1);\n    return d >= -1; // blocks\n    //return d >= -1 || d < -2; // yards\n    //return d == 0 || (d & 1) != 0; // nested\n}\n\nvec2 hash(ivec2 v)\n{\n    if(regularity(v)) return vec2(0.5); // transition to regular tiling\n    return mix(vec2(0.2), vec2(0.8), float(HASH(uvec2(iTime)+(uvec2(v.x)*2u+uvec2(0,1) + HASH(uvec2(v.y)*2u+uvec2(0,1))))) / float(0xffffffffU));\n}\n\nfloat box2(vec2 p, vec2 p0, vec2 p1, float r) // rounded min-max box based on https://iquilezles.org/articles/distfunctions2d/ by iq\n{\n    vec2 d = abs(p - (p1+p0)/2.0)-((p1-p0)/2.0-r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// xy contains id, z contains distance\nvec3 blocks(vec2 p, float r) // https://www.shadertoy.com/view/ctB3zR Recursive Asymmetric Blocks SDF by jt\n{\n    vec2 local = fract(p); // local coordinates inside tile\n    ivec2 tile = ivec2(floor(p)); // global coordinates of tile\n\n    vec2 center = hash(tile); // x/y-coordinate of vertical/horizontal line through this tile\n    vec2 sw = hash(tile+ivec2(-1,-1))+vec2(-1,-1); // x/y-coordinate of vertical/horizontal line through south-west tile\n    vec2 nw = hash(tile+ivec2(-1,+1))+vec2(-1,+1); // x/y-coordinate of vertical/horizontal line through north-west tile\n    vec2 se = hash(tile+ivec2(+1,-1))+vec2(+1,-1); // x/y-coordinate of vertical/horizontal line through south-east tile\n    vec2 ne = hash(tile+ivec2(+1,+1))+vec2(+1,+1); // x/y-coordinate of vertical/horizontal line through north-east tile\n    vec2 w = hash(tile+ivec2(-1, 0))+vec2(-1,0); // y/x-coordinate of horizontal/vertical line through west tile\n    vec2 e = hash(tile+ivec2(+1, 0))+vec2(+1,0); // y/x-coordinate of horizontal/vertical line through east tile\n    vec2 s = hash(tile+ivec2( 0,-1))+vec2(0,-1); // y/x-coordinate of horizontal/vertical line through south tile\n    vec2 n = hash(tile+ivec2( 0,+1))+vec2(0,+1); // y/x-coordinate of horizontal/vertical line through north tile\n\n    //bool flip = (tile.x % 2) == (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) == (tile.y & 1);\n    //flip = !flip; // \"dual\" (i.e. swapped T-crossings)\n    if(flip) // vertical line goes through\n    {\n        return\n            local.x < center.x\n            ?\n            (\n                local.y < w.y\n                ?\n                vec3 // south-west\n                (\n                    vec2(tile.x, tile.y),\n                    box2(local, vec2(sw.x, s.y), vec2(center.x, w.y), r)\n                )\n                :\n                vec3 // north-west\n                (\n                    vec2(tile.x, tile.y + 1),\n                    box2(local, vec2(nw.x, w.y), vec2(center.x, n.y), r)\n                )\n            )\n            :\n            (\n                local.y < e.y\n                ?\n                vec3 // south-east\n                (\n                    vec2(tile.x + 1, tile.y),\n                    box2(local, vec2(center.x, s.y), vec2(se.x, e.y), r)\n                )\n                :\n                vec3 // north-east\n                (\n                    vec2(tile.x + 1, tile.y + 1),\n                    box2(local, vec2(center.x, e.y), vec2(ne.x, n.y), r)\n                )\n            );\n    }\n    else // horizontal line goes through\n    {\n        return\n            local.y < center.y\n            ?\n            (\n                local.x < s.x\n                ?\n                vec3 // south-west\n                (\n                    vec2(tile.x, tile.y),\n                    box2(local, vec2(w.x, sw.y), vec2(s.x, center.y), r)\n                )\n                :\n                vec3 // south-east\n                (\n                    vec2(tile.x + 1, tile.y),\n                    box2(local, vec2(s.x, se.y), vec2(e.x, center.y), r)\n                )\n            )\n            :\n            (\n                local.x < n.x\n                ?\n                vec3 // north-west\n                (\n                    vec2(tile.x, tile.y + 1),\n                    box2(local, vec2(w.x, center.y), vec2(n.x, nw.y), r)\n                )\n                :\n                vec3 // north-east\n                (\n                    vec2(tile.x + 1, tile.y + 1),\n                    box2(local, vec2(n.x, center.y), vec2(e.x, ne.y), r)\n                )\n            );\n    }\n}\n\nvec3 idmap(vec2 p)\n{\n    float r = 0.0; // roundness (TODO: fix border)\n\n    return blocks(p + 0.5, r);\n}\n\nvec3 apply_boundary(vec3 v)\n{\n    v.z *= boundary(ivec2(v.xy)) ? +1.0 : -1.0;\n    return v.xyz;\n}\n\n#define pi 3.1415926\n\nvec3 idmap_scaled(vec2 p)\n{\n    float s = mix(6.0, 12.0, 0.5 - 0.5 * cos(2.0*pi*iTime/20.0));\n    return apply_boundary(idmap(p*s)/vec3(1.0, 1.0, s));\n}\n\nvec3 colorcode(ivec2 id)\n{\n    return vec3((id.x & 1) != (id.y & 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 p)\n{\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    p = (2.0 * p - R) / R.y;\n    vec2 m = iMouse.xy;\n    m = (2.0 * m - R) / R.y;\n\n    float d = idmap_scaled(p).z;\n\n    // sdf visualization by iq\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    col *= 1.0 - exp(-24.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(240.0*d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        col *= mix(vec3(0.5), vec3(1.0), colorcode(ivec2(idmap_scaled(p).xy))); // visualize ids\n        // sdf visualization by iq\n        d = idmap_scaled(m).z;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}