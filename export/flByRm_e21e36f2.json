{"ver":"0.1","info":{"id":"flByRm","date":"1649672580","viewed":168,"name":"test99","username":"svatostop","description":"test","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float AOr = 2.0;\nfloat samples = 64.0;\n\nfloat PI = 3.14159265359;\n\nfloat size = 2.0;\n\nvec3 dir;\nvec3 F0;\nvec3 fragPos;\nvec3 normal;\nvec3 camPos = vec3(0.0, 0.0, 1.0);\nvec3 lightPos;\nvec3 lightCol = vec3(0.8, 0.8, 0.5);\nvec3 normalVec ;\nvec3 posVec;\nvec3 lightVec;\nvec3 h ;\n\nvec3 albedo = vec3(1.0);\nfloat roughness = 0.4;\nfloat metallic = 0.2;\n\nfloat bump = 30.0;\n\nfloat alpha;\n\n// --------------------------------------\n// Soft Shadow\n// --------------------------------------\n\nfloat softShadows()\n{\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 currPos = fragPos + lightDir * 0.005;\n    float baseH = texture(iChannel3, size* (fragPos.xy)).r;\n    \n    float stapSize = 0.05;\n    int step = 0;\n    int maxStep = 30;\n    float height;\n    while(distance(currPos, lightPos) > 0.01 && step < maxStep)\n    {\n        step += 1;\n        currPos += lightDir * 0.01;\n\n        height = texture(iChannel3, size* (currPos.xy)).r;\n        if(height - currPos.z > baseH) \n        {\n            float shadow = float(step) / float(maxStep);\n        \n            return clamp(shadow, 0.3, 1.0);\n        }\n    }\n    return 1.0;    \n    \n}\n\n// --------------------------------------\n// PBR\n// --------------------------------------\n\nfloat g1(vec3 n, float x)\n{\n    float numerator = x;\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float denominator = x * (1.0 - k) + k;\n    denominator = max(denominator, 0.000001);\n    \n    return numerator / denominator;\n}\nfloat g(float alpha, vec3 n, vec3 v, vec3 l)\n{\n    float nDotV = max(dot(n, v), 0.0);\n    float nDotL = max(dot(n, l), 0.0);\n    return g1(n, nDotV) * g1(n, nDotL);\n}\n\nfloat d(float alpha, vec3 normalVec, vec3 h)\n{\n    float r  = roughness*roughness;\n    float r2 = r*r;\n    float numerator = r2;\n    float nDotH = max(dot(normalVec, h), 0.0);\n    float nDotH2 = nDotH*nDotH;\n  \n    float denom = (nDotH * (r2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    \n    return numerator / denom;\n}\n\nvec3 f(vec3 F0, vec3 v, vec3 h)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - alpha, 5.0);\n}\n\nvec3 PBR(vec2 fragCoord)\n{\n    vec3 lightVec2 = lightPos - fragPos;\n    lightVec2 = normalize(lightVec2);\n    float distance = length(lightVec2);\n    float attenuation = 1.0 / (distance * distance);\n\n    vec3 radiance= lightCol * attenuation * alpha; \n    \n    vec3 ks = f(F0, posVec, h); \n    vec3 kd = (vec3(1.0) - ks) * (1.0 - metallic);\n    \n    vec3 lambert = albedo / PI;\n    \n    vec3 cTNumerator = d(alpha, normalVec, h) * g(alpha, normalVec, posVec, lightVec) * f(F0,posVec, h);\n    float cTDenominator = 4.0 * max(dot(posVec, normalVec), 0.0) * max(dot(lightVec, normalVec), 0.0) + 0.001;\n    \n    vec3 cT = cTNumerator / cTDenominator;\n    \n    vec3 BRDF = kd * lambert + cT;\n\n    vec3 outLight = BRDF * radiance * max(dot(normalVec, lightVec2) , 0.0);\n    \n    vec3 irradiance = texture(iChannel2, dir).rgb;\n    vec3 diffuse    = irradiance * albedo;\n    //vec3 ambient = 0.3 * lightCol * albedo;\n    vec3 ambient = (kd *lightCol * diffuse);\n    float shadows = softShadows();\n    \n    vec3 color = (shadows * ambient) + outLight;\n\n    return color;\n    \n}\n\n\nvec3 normalFromHeight(vec2 coords)\n{\n    float xT = 1.0 / iResolution.x;\n    float yT = 1.0 / iResolution.y;\n    \n    float top = bump * texture(iChannel3, size * coords + vec2(0.0, yT)).r;\n    float bottom = bump * texture(iChannel3, size * coords + vec2(0.0, -yT)).r;\n    float left = bump * texture(iChannel3,size *  coords + vec2(-xT, 0.0)).r;\n    float right = bump * texture(iChannel3, size * coords + vec2(xT, 0.0)).r;\n\n    vec3 n = normalize(vec3(bottom - top, left - right, 2.0));\n    return n;\n}\n\n// --------------------------------------\n// AO\n// --------------------------------------\n\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\nfloat depth(vec2 coord)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0);\n    return texture(iChannel0, size* uv).x;\n}\n\nvec3 randPoint()\n{\n    vec3 p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    while(length(p)>1.0)\n    {\n        p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    }\n    return p;\n}\nfloat getAmbientOcclision2(vec2 coord)\n{\n    float curDepth = depth(coord);\n    float screenRadius = 0.5 * (AOr / curDepth) / 0.53135;\n    float finL = 0.0;\n    float count = 0.0;\n    for(float i = 0.0; i < samples; i++)\n    {\n        vec3 p = randPoint() * frand();\n        vec2 sp = vec2(coord.x + p.x * screenRadius, coord.y + p.y * screenRadius);\n        float depth = depth(sp);\n        float at = pow(length(p)-1.0, 2.0);\n        finL += step(curDepth + p.z * AOr, depth) * at;\n        count += at;\n    }\n    return finL / count;\n       \n}\n\n// --------------------------------------\n// main\n// --------------------------------------\n\nvoid cubeMapProc(vec2 fragCoord)\n{\n    vec2 r = -iMouse.yx / iResolution.yx * PI * 2.0;\n\n    vec4 cs = cos(vec4(r.y, r.x, r.y - PI * 0.5, r.x - PI * 0.5));\n    vec3 forward = vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = forward * 7.5;\n    vec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    F0 = mix(vec3(0.04), albedo, metallic);\n    lightPos = vec3((iMouse.xy/iResolution.xy -0.5), 0.5);\n    fragPos = vec3((fragCoord/iResolution.xy -0.5), 0.0);\n       \n    normalVec = normalFromHeight(fragCoord.xy/iResolution.xy);\n    \n    posVec = normalize(camPos - fragPos);\n    lightVec = normalize(lightPos - fragPos);\n    h = normalize(posVec + lightVec);\n    alpha = dot(h, posVec);\n\n    float d = depth(fragCoord/iResolution.y);\n    vec3 ao = vec3(0.4) + step(d, 1e5-1.0) * vec3(0.8) * getAmbientOcclision2(fragCoord/iResolution.y);\n    \n    cubeMapProc(fragCoord);\n   \n    if (fragCoord.x < iResolution.x / 1.2)\n    fragColor = vec4(PBR(fragCoord) * ao , 1.0);\n    else \n    fragColor = vec4(texture(iChannel2, dir).rgb, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}