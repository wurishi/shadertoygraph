{"ver":"0.1","info":{"id":"wlSGRd","date":"1560701265","viewed":1778,"name":"Procedural terrain with grid","username":"PrzemyslawZaworski","description":" ","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["grid","terrain","derivatives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// references:\n// http://madebyevan.com/shaders/grid/\n// Hash without sine: https://www.shadertoy.com/view/4djSRW\n\nconst mat3 rotationMatrix = mat3(1.0,0.0,0.0,0.0,0.7,-0.7,0.0,0.7,0.7);\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 10.21);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (vec2 P)\n{\n    float size = 256.0;\n    float s = (1.0 / size);\n    vec2 pixel = P * size + 0.5;   \n    vec2 f = fract(pixel);\n    pixel = (floor(pixel) / size) - vec2(s/2.0, s/2.0);\n    float C11 = hash(pixel + vec2( 0.0, 0.0));\n    float C21 = hash(pixel + vec2( s, 0.0));\n    float C12 = hash(pixel + vec2( 0.0, s));\n    float C22 = hash(pixel + vec2( s, s));\n    float x1 = mix(C11, C21, f.x);\n    float x2 = mix(C12, C22, f.x);\n    return mix(x1, x2, f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float a = 0.5, b = 0.0, t = 0.0;\n    for (int i=0; i<5; i++)\n    {\n        b *= a; t *= a;\n        b += noise(p);\n        t += 1.0; p /= 2.0;\n    }\n    return b /= t;\n}\n\nfloat map( vec3 p )\n{ \n    float h = p.y - 20.0 * fbm(p.xz*0.003);\n    return max( min( h, 0.55), p.y-20.0 );\n}\n\nbool raymarch( inout vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i=0; i<128; i++)\n    {\n        float d = map(ro+rd*t);\n        t+=d;\n        if (d<t*0.001)\n        {\n        \tro+=t*rd;\n        \treturn true;\n    \t}\n    }\n    return false;\n}\n\nvec3 shading( vec3 ro, vec3 rd )\n{\n    vec3 c = vec3(rd.y*2.0) * 0.1;\n    vec3 sk = ro;\n    if (raymarch(ro,rd))\n    {\n        vec2 p = ro.xz;\n        vec2 g = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n        float s = min(g.x, g.y);\n        float f = min(length(ro-sk)/64.,1.);\n        return mix(1.5-vec3(s,s,s), c, f);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.5,25.+sin(iTime)*5.0,iTime * 5.0);\n    vec3 rd = normalize(vec3(uv,2.0)) * rotationMatrix;  \n    fragColor = vec4(shading(ro,rd), 1.0);\n}","name":"Image","description":"","type":"image"}]}