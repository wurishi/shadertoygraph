{"ver":"0.1","info":{"id":"ssy3DK","date":"1632188320","viewed":189,"name":"simple cube raytracer","username":"YielDuck","description":"Similar to fb39ca4's https://www.shadertoy.com/view/4dX3zl\nbut more reusable... maybe","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera\n{\n    float phi, theta;\n    float d;\n    \n    vec3 at;\n    \n    float aspectRatio;\n    float fov;\n};\nmat3 rotate(Camera camera)\n{\n    vec3 z = vec3\n    (\n        cos(camera.theta) * sin(camera.phi),\n        sin(camera.theta),\n        cos(camera.theta) * cos(camera.phi)\n    );\n\n    vec3 x = normalize(cross(vec3(0., 1., 0.), z));\n\n    const float pi = 3.1415926535;\n    x = mod(floor(camera.theta / pi + 0.5), 2.) == 0. ? x : -x;\n\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\nRay castRay(Camera camera, vec2 uv)\n{\n    mat3 m = rotate(camera);\n    float f = tan(0.5 * camera.fov);\n    return Ray\n    (\n        camera.at + camera.d * m[2],\n        normalize\n        (\n            m[0] * (uv.x * f * camera.aspectRatio)\n          + m[1] * (uv.y * f)\n          - m[2]\n        )\n    );\n}\n\nconst float extent = 32.;\n\nstruct Hit\n{\n    vec3 pos;\n    vec3 norm;\n    bool happened;\n};\n\nbool cube(vec3 v)\n{\n    vec3 r = v - vec3(extent) * 0.5;\n    r.y += extent * 0.25;\n    return 16. * r.y * r.y < r.x * r.x + r.z * r.z;\n}\n\nHit closestHit(Ray ray)\n{\n    vec3 invdir = 1. / ray.direction;\n\n    vec3 dx = sign(invdir);\n    vec3 dt = abs(invdir);\n\n    vec3 x = floor(ray.origin);\n    vec3 t = (x + vec3(lessThan(vec3(0.), dx)) - ray.origin) * invdir;\n\n    for(int i = 0; i < 2 * int(extent); ++i)\n    {\n        vec3 mask = vec3(lessThanEqual(t.xyz, min(t.yzx, t.zxy)));\n        x += mask * dx;\n        \n        if(lessThan(x, vec3(extent)) != lessThanEqual(vec3(0.), x))\n            break;\n\n        if(cube(x))\n            return Hit\n            (\n                ray.origin + ray.direction * dot(t, mask),\n                vec3(-dx * mask),\n                true\n            );\n\n        t += mask * dt;\n    }\n    return Hit\n    (\n        vec3(0.),\n        vec3(0.),\n        false\n    );\n}\n\nvec3 trace(Ray ray)\n{\n    const vec3     albedo = vec3(0.50, 0.80, 0.20);\n    const vec3   skyColor = vec3(0.53, 0.81, 0.92);\n    const vec3 lightColor = vec3(1.00, 0.98, 0.88);\n    const vec3 lightDir   = normalize(vec3(2., 4., 1.));\n\n    Hit hit = closestHit(ray);\n    if(!hit.happened)\n        return dot(ray.direction, lightDir) < 0.999f\n            ? skyColor\n            : lightColor * 2.f;\n    Ray shadowRay = Ray(hit.pos, lightDir);\n    vec3 color = !closestHit(shadowRay).happened\n        ? lightColor * max(0., dot(hit.norm, lightDir))\n        : vec3(0.);\n    return (skyColor * 0.3 + color) * albedo;\n}\n\nvec3 tonemap(vec3 color, float exposure)\n{\n    return vec3(1.) - exp(color * (-exposure));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Camera camera = Camera\n    (\n        -0.02 * iMouse.x,\n        -0.02 * iMouse.y,\n        1.,\n        vec3(extent) * 0.5,\n        float(iResolution.x) / float(iResolution.y),\n        1.\n    );\n    vec2 center = 2. * fragCoord / iResolution.xy - 1.;\n    float dx = 0.5 / iResolution.x;\n    float dy = 0.5 / iResolution.y;\n\n    Ray ray[4];\n    ray[0] = castRay(camera, center + vec2(-dx, -dy));\n    ray[1] = castRay(camera, center + vec2(-dx,  dy));\n    ray[2] = castRay(camera, center + vec2( dx, -dy));\n    ray[3] = castRay(camera, center + vec2( dx,  dy));\n\n    vec3 color = vec3(0.);\n    for(int i = 0; i < 4; ++i)\n        color += trace(ray[i]);\n        \n    fragColor = vec4(tonemap(color * 0.25, 1.), 1.);\n}","name":"Image","description":"","type":"image"}]}