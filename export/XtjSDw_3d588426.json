{"ver":"0.1","info":{"id":"XtjSDw","date":"1444250306","viewed":512,"name":"pseudo 3D in 2D","username":"MacSlow","description":"Trying out some basic 3D-to-2D-projection and 2D-drawing-primitives","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","lines","projection","discs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Trying out basic 3D-to-2D projection in a fragment-shader\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red = vec4 (1.0, 0.0, 0.0, 1.0);\nconst vec4 green = vec4 (0.0, 1.0, 0.0, 1.0);\nconst vec4 blue = vec4 (0.0, 0.0, 1.0, 1.0);\nconst vec4 white = vec4 (1.0);\nconst vec4 orange = vec4 (1.0, 0.4, 0.125, 1.0);\nconst vec4 black = vec4 (0.2, 0.3, 0.2, 1.0);\nconst vec4 cyan = vec4 (0.0, 1.0, 1.0, 1.0);\nconst vec4 magenta = vec4 (1.0, 0.0, 1.0, 1.0);\nconst vec4 yellow = vec4 (1.0, 1.0, 0.0, 1.0);\n\nmat2 scale (in vec2 size)\n{\n    mat2 mat = mat2 (vec2 (size.x,    0.0),\n                     vec2 (   0.0, size.y));\n\n    return mat;\n}\n\nmat4 trans (in vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (t.x, t.y, t.z, 1.0));\n    return mat;\n}\n\nmat4 rotX (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0,   c,   s, 0.0),\n                     vec4 (0.0,  -s,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\n// based on line() from Daniel Burke (aka burito) and Inigo Quilez (aka iq)\n// see \"Time Coordinates\" on ShaderToy.com\nvec4 line (in vec2 p, in vec2 a, in vec2 b, in vec4 c, in float thickness)\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp (dot (pa, ba) / dot (ba, ba), 0.0, 1.0);\n    float d = length (pa - ba * h);\n    \n    return c * clamp (((1.0 - d) - (1.0 - thickness)) * 100.0, 0.0, 1.0);\n}\n\n// in case there's no GLSL 1.3+\nfloat mySmoothStep (in float edge0, in float edge1, in float x)\n{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvec4 disc (in vec2 p, in vec2 m, in float r, in vec4 c, in float thickness)\n{   \n    float d = length (p - m);\n    if (d < r) {\n        return c * (1.0 - smoothstep (r - thickness, r, d));\n    } else {\n        return vec4 (0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 gradientColor (in float v)\n{\n\tvec3 color = vec3 (0.0);\n    const vec3 white = vec3 (1.0);\n    const vec3 low = vec3 (0.35, 0.3, 0.4);\n    const vec3 high = vec3 (0.5, 0.6, 0.55);\n\n    if (v < 0.333) {\n        color = v * low / 0.333;\n    } else if (v < 0.666) {\n        color = (v - 0.333) * (high - low) / 0.333 + low;\n    } else {\n        color = (v - 0.666) * (white - high) / 0.333 + high;\n    }\n\n    return color;\n}\n\nstruct boxType {vec4 p[8];};\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    boxType box;\n    box.p[0] = vec4 ( 0.1,  0.1,  0.1, 1.0);\n    box.p[1] = vec4 ( 0.1, -0.1,  0.1, 1.0);\n    box.p[2] = vec4 (-0.1, -0.1,  0.1, 1.0);\n    box.p[3] = vec4 (-0.1,  0.1,  0.1, 1.0);\n    box.p[4] = vec4 ( 0.1,  0.1, -0.1, 1.0);\n    box.p[5] = vec4 ( 0.1, -0.1, -0.1, 1.0);\n    box.p[6] = vec4 (-0.1, -0.1, -0.1, 1.0);\n    box.p[7] = vec4 (-0.1,  0.1, -0.1, 1.0);\n\n    float t = 0.4 * PI * iTime;\n    vec2 uvraw = fragCoord.st / iResolution.xy;\n    vec2 uv = uvraw - vec2 (0.5, 0.5);\n    uv *= vec2 (iResolution.x / iResolution.y, 1.0);\n\n    float u = uvraw.s * 2.0 * PI;\n    float v = uvraw.t * 2.0 * PI;\n    float uf = (cos (1.1 * u + 7.0 * t) + cos (2.3 * v * cos (1.0 * t)) + cos (0.3 * u * cos (3.0 * t))) / 3.0;\n    float vf = (cos (2.3 * v + 8.0 * t) + cos (1.3 * u * cos (3.0 * t)) + cos (1.7 * v * cos (2.0 * t))) / 3.0;\n    float fetcher = (uf * vf + 1.0) / 2.0;\n    vec4 bgCol = vec4 (gradientColor (fetcher), 1.0);\n\n    float thickness = 0.0025;\n\n    vec4 disc0Col = disc (uv, vec2 (0.1 + 0.6 * cos (t), 0.2 * sin (t)), 0.1, cyan, thickness);\n    vec4 disc1Col = disc (uv, vec2 (0.4 * cos (2.0 / 3.0 * t), -0.2 * sin (t)), 0.12, magenta, thickness);\n    vec4 disc2Col = disc (uv, vec2 (0.2 + 0.3 * cos (4.0 / 5.0 * t), -0.3 * sin (7.0 / 8.0 * t)), 0.15, yellow, thickness);\n\n    mat4 rot3d = rotX (-4.0 * t) * rotY (3.0 * t) * rotZ (2.0 * t);\n    mat4 model = trans (vec3 (0.0, 0.0, -0.4)) * rot3d;\n    box.p[0] = model * box.p[0];\n    box.p[1] = model * box.p[1];\n    box.p[2] = model * box.p[2];\n    box.p[3] = model * box.p[3];\n    box.p[4] = model * box.p[4];\n    box.p[5] = model * box.p[5];\n    box.p[6] = model * box.p[6];\n    box.p[7] = model * box.p[7];\n\n    vec4 boxCol = line (uv, box.p[0].xy / box.p[0].z, box.p[1].xy / box.p[1].z, white, thickness);\n    boxCol += line (uv, box.p[1].xy / box.p[1].z, box.p[2].xy / box.p[2].z, white, thickness);\n    boxCol += line (uv, box.p[2].xy / box.p[2].z, box.p[3].xy / box.p[3].z, white, thickness);\n    boxCol += line (uv, box.p[3].xy / box.p[3].z, box.p[0].xy / box.p[0].z, white, thickness);\n    boxCol += line (uv, box.p[4].xy / box.p[4].z, box.p[5].xy / box.p[5].z, white, thickness);\n    boxCol += line (uv, box.p[5].xy / box.p[5].z, box.p[6].xy / box.p[6].z, white, thickness);\n    boxCol += line (uv, box.p[6].xy / box.p[6].z, box.p[7].xy / box.p[7].z, white, thickness);\n    boxCol += line (uv, box.p[7].xy / box.p[7].z, box.p[4].xy / box.p[4].z, white, thickness);\n    boxCol += line (uv, box.p[0].xy / box.p[0].z, box.p[4].xy / box.p[4].z, white, thickness);\n    boxCol += line (uv, box.p[1].xy / box.p[1].z, box.p[5].xy / box.p[5].z, white, thickness);\n    boxCol += line (uv, box.p[2].xy / box.p[2].z, box.p[6].xy / box.p[6].z, white, thickness);\n    boxCol += line (uv, box.p[3].xy / box.p[3].z, box.p[7].xy / box.p[7].z, white, thickness);\n\n    // since starting from a white base-color we've to subract everything so we get black,\n    // red, green and blue\n    fragColor = white - boxCol - disc0Col - disc1Col - disc2Col;\n}","name":"Image","description":"","type":"image"}]}