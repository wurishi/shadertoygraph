{"ver":"0.1","info":{"id":"tljfR3","date":"1600161105","viewed":266,"name":"Universe, Sound, Noise","username":"MapleSyrupCS6","description":"Universe, Sound, Noise","likes":9,"published":1,"flags":40,"usePreview":0,"tags":["maplestudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    col = texture(iChannel0, uv).rgb;\n    \n    vec3 c1 = vec3(0.2, 0.9, 0.4)-0.2;\n    \n    float val = 0.5;\n    float gNoise = rnd(vec2(0.0, uv.y + iTime));\n    float gStep = step(gNoise, val);\n    float strength = gNoise / val;\n    strength = strength * 0.6 -1.;\n    \n    vec2 coord = texture(iChannel0, uv).gb + vec2(gStep*strength*val, 0.);\n    \n    \n    float l = step(sin(uv.y*1500.+iTime), 0.5);\n    l = (l + 1.0)*0.5;\n    float d = length(uv-0.5)*0.8;\n    float r = rnd(uv+iTime*0.01);\n    r =  1.0 - r*0.5;\n        \n    \n   col = sin(iTime*3.0) > 0.0 ? texture(iChannel0, coord).rgb : col;\n    col *= vec3(l)+0.2;\n\t//col *= c1;\n    //col -= vec3(d);\n    //col *= r;\n    //col= texture(iChannel0, coord).rgb;\n    \n    float n = distance(vec2(.0, rand(uv*iTime))*9., vec2(uv.x, uv.y));\n    n = step(2., n);\n    col *= mix(vec3(0.7), vec3(1. ),n);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat image(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), -0.0)*10., uv);\n    d = step(2., d);\n    \n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    \n    float d = distance(vec2(0.5, 0.5), uv);\n    col *= mix(vec3(0.8), vec3(0.), d);\n    \n     vec3 c = vec3(0.3, 0.2, 0.9)-0.75;\n     float im = image(uv);\n     vec3 c2 = vec3(0.9, 0.9, 0.2)+0.5;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAT_CIR 0.\n#define MAT_FLOOR 1.\n#define MAT_TORUS 2.\n#define MAT_TORUS2 3.\n#define MAT_TORUS3 4.\n#define MAT_TORUS4 5.\n#define MAT_TORUS5 6.\n#define MAT_CIR2 7.\n#define MAT_CIR3 8.\n#define MAT_CIR4 9.\n#define MAT_CIR5 10.\n\n\n// めちゃくちゃ小さい数字\n#define FLT_EPS  5.960464478e-8\n\nconst float pi = 3.141592;\nconst float pi2 = pi * 2.0;\n\nfloat rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat image(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), -0.0)*10., uv);\n    d = step(2., d);\n    \n    \n    return d;\n}\n\nvec2 min2(vec2 a, vec2 b){\n    \n    return a.x < b.x ? a : b;\n}\n\nfloat dfCircle(vec3 p, float s){\n    \n    return length(p) - s;\n}\n\n\nfloat dfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 dfm(vec3 p){\n    \n    vec3 q = rotate(p, radians(iTime * 10.0), vec3(1.0, 0.5, 0.0));\n    float cir = dfCircle(p, 2.0);\n    float cir2 = dfCircle(p+ vec3(sin(iTime*2.*0.2), 0.0, cos(iTime*2.*0.2))*2.*3., 1.0);\n    float cir3 = dfCircle(p+ vec3(sin(iTime*2.*0.09), 0.0, cos(iTime*2.*0.09))*2.*5., 1.5);\n    float cir4 = dfCircle(p+ vec3(cos(iTime*2.*0.01), 0.0, sin(iTime*2.*0.01))*2.*7.5, 1.4);\n    float cir5 = dfCircle(p+ vec3(sin(iTime*2.*0.08), 0.0, cos(iTime*2.*0.08))*2.*10.5, 2.);\n    float flo = p.y + 20.0;\n    float tor = dfTorus(p, vec2(6.0, 0.1));\n    float tor2 = dfTorus(p, vec2(10., 0.1));\n    float tor3 = dfTorus(p, vec2(15., 0.1));\n    float tor4 = dfTorus(p, vec2(21., 0.1));\n    float tor5 = dfTorus(p, vec2(32., 0.1));\n    \n    \n    vec2 dm = min2(vec2(cir, MAT_CIR), vec2(flo, MAT_FLOOR));\n    dm = min2(vec2(cir, MAT_CIR), vec2(tor, MAT_TORUS));\n    dm = min2(dm, vec2(tor2, MAT_TORUS2));\n    dm = min2(dm, vec2(tor3, MAT_TORUS3));\n    dm = min2(dm, vec2(tor4, MAT_TORUS4));\n    dm = min2(dm, vec2(tor5, MAT_TORUS5));\n    dm = min2(dm, vec2(cir2, MAT_CIR2));\n    dm = min2(dm, vec2(cir3, MAT_CIR3));\n    dm = min2(dm, vec2(cir4, MAT_CIR4));\n    dm = min2(dm, vec2(cir5, MAT_CIR5));\n    \n    return dm;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    return normalize(\n        e.xyy * dfm(p+e.xyy).x+\n        e.yxy * dfm(p+e.yxy).x+\n        e.yyx * dfm(p+e.yyx).x+\n        e.xxx * dfm(p+e.xxx).x\n        );\n}\n\n// 滑らか(0)から粗い(1)で表現するroughnessというパラメータを計算で使用する指数にマッピングする関数\nfloat roughnessToExponent(float roughness)\n{\n    return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS);\n}\n\n// サーフェイス位置・法線・視線方向・ライト位置・マテリアル情報でライティングする関数\nvec3 light(vec3 p, vec3 n, vec3 v, vec3 lp, vec3 baseColor, float roughness, float reflectance, float metallic, vec3 radiance) {\n    // 反射率をメタリックパラメータで分岐する\n    vec3 ref = mix(vec3(reflectance), baseColor, metallic);\n\n    // ライトベクトルと距離を計算する\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n    \n    // ハーフベクトルを計算\n    vec3 h = normalize(l + v);\n    \n    // 正規化diffuseを評価\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / pi;\n    \n    // 正規化blin-phongを評価\n    float m = roughnessToExponent(roughness);\n\tvec3 specular = ref * pow( max( 0.0, dot( n, h ) ), m ) * ( m + 2.0 ) / ( 8.0 * pi );\n\t\n\t// diffuse項とspecular項を合算してポイントライトを評価\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len*len);\n}\n\nvec3 cameraPos;\n\n// 空間にライトを配置して全て評価する関数\nvec3 evalLights(vec3 p, vec3 n, vec3 ray, vec3 baseColor, float roughness, float reflectance, float metallic) {\n    // ボールから発せられるポイントライトを配置\n    vec3 lp = vec3(0.0, cos(iTime) * 0.1, 0.0);\n    vec3 result = light(p, n, -ray, lp, baseColor, roughness, reflectance, metallic, vec3(0.6, 0.05, 0.01) * (sin(iTime) * 0.5 + 0.5) * 8.0);\n    \n    // カメラ位置にポイントライトを配置\n    result += light(p, n, -ray, cameraPos, baseColor, roughness, reflectance, metallic, vec3(3.0));\n    return result;\n}\n\nvoid getSurfaceParams(vec3 p, vec2 mat, out vec3 outColor, out vec3 outEmission, out float outRoughness, out float outReflectance, out float outMetallic){\n    \n    outColor = vec3(0.0);\n    outEmission = vec3(0.0); \n        // 粗さパラメータを追加\n    outRoughness = 1.0;\n    // 反射率パラメータを追加\n    outReflectance = 0.04;\n    // メタリックパラメータを追加\n    outMetallic = 0.0;\n    \n    if(mat.y == MAT_CIR)\n    {\n        outColor = vec3(0.9, 0.4, 0.1);\n        outEmission = vec3(0.7, 0.6, 0.2)  * (sin(iTime*2.+0.7) * 0.5 + 0.5*3.) + 0.4;\n        outReflectance = 0.04;\n    }\n    else if(mat.y == MAT_FLOOR)\n    {\n        outColor = vec3(0.2, 0.6, 0.9);\n        outColor = vec3(1.0);\n    }\n    else if(mat.y == MAT_TORUS){\n      \toutColor = vec3(0.2, 0.6, 0.9) + 0.6;  \n        outEmission = vec3(0.2, 0.6, 0.9)  * (sin(iTime*2.+0.6)*0.5 + 0.5 * 2.) + 0.6;\n    }\n    else if(mat.y == MAT_TORUS2){        \n        outColor = vec3(0.2, 0.6, 0.9)+ 0.3; \n        outEmission = vec3(0.2, 0.6, 0.9) * (sin(iTime*2.+0.5)*0.5 +0.5 * 2.)+ 0.3;\n    }\n    else if(mat.y == MAT_TORUS3){\n        outColor = vec3(0.2, 0.6, 0.9) + 0.1; \n        outEmission = vec3(0.2, 0.6, 0.9) * (sin(iTime*2.+0.4)*0.5 +0.5 * 2.)+ 0.1;\n    }\n    else if(mat.y == MAT_TORUS4){\n        outColor =vec3(0.2, 0.6, 0.9); \n        outEmission = vec3(0.2, 0.6, 0.9) * (sin(iTime*2.+0.3)*0.5 +0.5 * 2.);\n    }\n    else if(mat.y == MAT_TORUS5){\n        outColor = vec3(0.2, 0.6, 0.9) - 0.2; \n        outEmission = vec3(0.2, 0.6, 0.9) * (sin(iTime*2.+0.2)*0.5 +0.5 * 2.) - 0.2;\n    }\n    else if(mat.y == MAT_CIR2){\n        //outColor = vec3(0.6, 0.5, 0.9);\n        outEmission = vec3(0.6, 0.5, 0.9);\n        outRoughness = 1.;\n        outMetallic = 10.;\n       //outReflectance = 1.0;\n    }\n    else if(mat.y == MAT_CIR3){\n        outColor = vec3(0.2, 0.3, 0.9);\n       //outEmission = vec3(0.2, 0.3, 0.9)* (sin(iTime*2.+0.2)*0.5 +0.5 * 2.) - 0.2;\n        outEmission = vec3(1.0)* (sin(iTime*2.+0.2)*0.5 +0.5 * 2.) - 0.2;;\n            \n    }\n    else if(mat.y == MAT_CIR4){\n        outColor = vec3(0.9, 0.3, 0.5);\n        outEmission = vec3(0.9, 0.3, 0.5);\n        outEmission = vec3(1.0);\n    }\n    else if(mat.y == MAT_CIR5){\n        outColor = vec3(0.2, 0.9, 0.4);\n        outEmission =vec3(0.2, 0.9, 0.4);\n        outEmission = vec3(1.0);\n    }\n}\n\n// 反射時にもう一度レイマーチングをするので、使いまわせるように関数化する\nvoid trace(vec3 p, vec3 ray, vec2 uv,out vec3 outPos, out vec2 outMat, vec3 outCol) {\n    float t = 0.01;\n    vec3 pos;\n    vec2 mat;\n    \n    for(int i=0; i<99; i++) {\n        pos = p + ray * t;\n        mat = dfm(pos);\n        if (mat.x < 0.0001) {\n            outCol = 1.0 - vec3(float(i) / 99.0);\n            vec3 c = vec3(0.3, 0.2, 0.9)-0.75;\n     \t\tfloat d = image(uv);\n     \t\tvec3 c2 = vec3(0.9, 0.9, 0.2)+0.5;\n     \t\toutCol += mix(c2, c, d); \n            break;\n        }\n        t += mat.x;\n    }\n    outPos = pos;\n    outMat = mat;\n}\n\n\nvec3 shade(vec3 pos, vec2 mat, vec3 ray, vec2 uv) {\n    // 一次光源のライティングを行う\n    vec3 color, emission;\n    float roughness, reflectance, metallic;\n    getSurfaceParams(pos, mat, color, emission, roughness, reflectance, metallic);\n    vec3 n = normal(pos);\n    vec3 result = evalLights(pos, n, ray, color, roughness, reflectance, metallic) + emission;\n    \n    // 二次反射の合成率に使用するため、反射率を取得する\n    vec3 ref = mix(vec3(reflectance), color, metallic);\n    vec3 secondPos;\n    vec2 secondMat;\n    // 視線と法線の反射ベクトルを計算する\n    ray = reflect(ray, n);\n    \n    // 二次反射のトレースとライティングを行う\n    trace(pos, ray,uv, secondPos, secondMat, color);\n    getSurfaceParams(secondPos, secondMat, color, emission, roughness, reflectance, metallic);\n    n = normal(secondPos);\n    result += (evalLights(secondPos, n, ray, color, roughness, reflectance, metallic) + emission) * ref;\n    \n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    cameraPos = vec3(20.0, 26.0, 60.0+bd(iTime)*2.);\n    vec3 targetPos = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(targetPos - cameraPos);\n    vec3 right   = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up      = normalize(cross(forward, right));\n    vec3 ray     = normalize(forward * 2.5 + right * uv.x + up * uv.y);\n    \n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(0.0);\n    float depth = 0.0;\n    \n    /* for(int i = 0; i < 99; i++){\n        \n        rayPos = cameraPos + (ray * depth);\n        vec2 dist = dfm(rayPos);\n        \n        if(dist.x < 0.0001) {\n            vec3 color, emission, n;\n            float roughness, reflectance, mettalic;\n            getSurfaceParams(rayPos, dist, color, emission, roughness, reflectance, mettalic);\n            col = 1.0 - vec3(float(i) / 99.0);\n            col *= color;\n            \n            // 法線を推定\n            n = normal(rayPos);\n            // ポイントライトを評価\n            col = evalLights(rayPos, n, ray, color, roughness, reflectance, mettalic);\n            // 発光色を加える\n            col += emission;\n            \n            break;\n        }else{\n            vec3 c = vec3(0.3, 0.2, 0.9)-0.75;\n            float d = image(uv);\n            vec3 c2 = vec3(0.9, 0.9, 0.2)+0.5;\n            col = mix(c2, c, d);  \n        }\n        \n        depth += dist.x;\n     }*/\n    \n    vec3 surfacePos;\n    vec2 surfaceMat;\n    trace(cameraPos, ray,uv, surfacePos, surfaceMat, col);\n    col = shade(surfacePos, surfaceMat, ray, uv);\n    \n    vec3 fog = vec3(0.3, 0.2, 0.9)-0.75;\n    col = mix(fog, col, exp(-depth/100.));\n    col = pow(col, vec3(1.0 / 2.2));\n    \n     vec3 c = vec3(0.3, 0.2, 0.9)-0.75;\n     float d = image(uv);\n     vec3 c2 = vec3(0.9, 0.9, 0.2)+0.5;\n     col += mix(c2, c, d); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nvec2 sound(float time)\n{ \n    //return vec2(sin(6.2831*1500.*time)*fract(-2.*time));\n    return vec2(clamp(sin(6.4831*160.*time)*fract(mod(-time*8.,8.)/3.), 0.0, 0.3));\n    //return vec2(clamp(sin(6.4831*160.*time)*fract(-time*8./3.), 0.0, 0.25));\n}\n\n\nvec2 sound2(float time)\n{\n    return vec2(clamp(sin(6.2831*100.*time)*fract(mod(-2.*time, 5.)/9.), 0.0, 0.5));\n}\n\nvec2 sound3(float time)\n{ \n    //return vec2(sin(6.2831*1500.*time)*fract(-2.*time));\n    return vec2(sin(6.4831*400.*time)*fract(mod(-time*8.,8.)/3.));\n    \n}\n\nvec2 noise(float time)\n{\n    return vec2(clamp(fract(sin(time*8.3)*1e8)-.4, 0.0, 0.2)); \n}\n\n\n\nvec2 sound4( float time )\n{\n    return vec2(sound(time));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    return bd(time)+noise2(time)+sound(time)+sound2(time);//+sound3(time)+sound4(time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"vec2 bd(float time)\n{\n  return vec2(pow(fract(-time*2.),9.));\n}\n\n\nvec2 noise2(float time)\n{\n    return vec2(clamp(fract(sin(time*8.3)*1e6)-.4, 0.0, 0.09)); \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"precision highp float;\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n\n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5+bd(iTime)/10.;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\nfloat distanceFunc(vec3 p)\n{\n    vec3 q1 = rotate(p, radians(iTime * 5.0)*10., vec3(0.0, 0.5, 0.0));\n    p = q1;\n    float pyra = sdPyramid(p, 1.);\n    float box = sdBox(p, vec3(0.5,  0.5, 0.5));\n    return pyra;\n}\n\nvec2 ifs(vec3 p) {\n    float d1 = 999., d2 = 999.;\n    float range = 0.8, radius = 0.5 * (1. + 20.);\n    int iter = 256;\n\n    const float maxIter = 8.;\n    for (int i = int(maxIter); i > 0; i--) {\n        if (i <= iter) {\n            break;\n        }\n\n        float ratio = float(i) / maxIter;\n        float bx = distanceFunc(p);\n        d1 = mix(d1, min(d1, bx), float(i > iter + 1));\n        d2 = min(d2, bx);\n\n        ratio *= ratio;\n\n        p.xz = abs(p.xz) - range * ratio * 0.7;\n        p.xz *= 59.;\n        p.yz *= 29.;\n        p.yx *= 12.;\n\n        p.yz = abs(p.yz) - range * ratio * 0.7;\n        p.xz *= 40.;\n        p.yz *= 159.;\n        p.yx *= 45.;\n    }\n\n    return vec2(d1, d2);\n}\n\nfloat map(vec3 p)\n{\n    vec2 d = ifs(p);\n    return mix(d.y, d.x, 0.5);\n}\n\n\nvec3 normal(vec3 pos, float eps)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773* eps;\n\n    return normalize(e.xyy * distanceFunc(pos + e.xyy)+\n                     e.yyx * distanceFunc(pos + e.yyx)+\n                     e.yxy * distanceFunc(pos + e.yxy)+\n                     e.xxx * distanceFunc(pos + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvd = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cp = vec3(0, 0.4, -2.2);\n    float screenZ = 2.5;\n    vec3 rd = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1, 1, -10));\n\n    float size = 1.0;\n    float depth = 0.0;\n    float dist = 0.0;\n    vec3 rp  = vec3(0.0);\n    vec3 col = vec3(0.);\n\n    for(int i = 0; i < 256; i++){\n        rp = cp + (rd * depth);\n        dist = distanceFunc(rp);\n\n        if(dist < 0.0001)\n        {\n            vec3 nor = normal(rp, 0.0008);\n            float edge = smoothstep(0., 0.01, length(nor - normal(rp, 0.015)));\n            float diff  = dot(nor, lightDir);\n            col = 1.0 - vec3(float(i) / 99.);\n            vec3 c1 = texture(iChannel0, uvd).rgb;\n            col *= edge == 1. ? vec3(0.4, 0., 0.9) + 0.9 * diff : c1;\n            \n            \n            break;\n        } \n        else\n        {\n\t\t\t//float d = distance(vec2(0.0, rand(uv+(sin(iTime*0.001))))*9., vec2(rand(uv+(sin(iTime*0.001))), uv.y));\n            float d = distance(vec2(.0, rand(uv))*9., vec2(uv.x, uv.y));\n    \t\td = step(2., d);\n            //col = mix(vec3(0.4, 0.4, 0.9), mix( vec3(0.4, 0.9, 0.9), vec3(0.9, 0.3, 0.5), uv.y+0.9), d);\n            col = mix(vec3(0.4, 0.4, 0.9), mix( vec3(0.9, 0.9, 0.6), vec3(0.9, 0.34, 0.5), uv.y+0.9), d);\n            //col = mix(vec3(0.4, 0.4, 0.9), vec3(0.9, 0.34, 0.5), d);\n        }\n\n        depth += dist;\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}