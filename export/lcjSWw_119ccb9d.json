{"ver":"0.1","info":{"id":"lcjSWw","date":"1707738242","viewed":140,"name":"First Shader! - josaq","username":"josaq","description":"first shader!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Screen\nfloat ScreenWidth() { return iResolution.x / 100.0; }\nfloat ScreenHeight() { return iResolution.y / 100.0; }\nfloat ScreenDistance() { return 7.0; }\n\n// Camera\nvec3 CameraFrom() { return vec3(5.0*cos(iTime/5.0), 2.0*sin(iTime/4.0) + 4.0, 5.0*sin(iTime/4.0)); }\nvec3 CameraTo() { return vec3(0.0, 0.0, 0.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\n// SDF for Sphere\n// - p: position of point\n// - r: sphere radius\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// SDF for poll\n// - p: position of point\n// - q: poll axis\n// - r: poll radius\nfloat sdPoll(vec3 p, vec3 q, float r) {\n    return length(cross(p, normalize(q))) - r;\n}\n\n// SDF for Box\n// - p: position of point\n// - b: size of edges\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// SDF for Round Box\n// - p: position of point\n// - b: size of edges\n// - r: radius\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;   \n}\n\n// SDF for Box Frame\n// - p: position of point\n// - b: size of edges\n// - e: effect value\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Return vec2 with smaller signed distance\nvec2 opMin(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Return vec2 with smoothed min signed distance\nvec2 opSmoothMin(vec2 d1, vec2 d2, float k) {\n    float h = max(k - abs(d1.x - d2.x), 0.0)/k;\n    float d = min(d1.x, d2.x) - h*h*k*(1.0/4.0);\n    \n    float m;\n    if (abs(d1.x - d) < abs(d2.x - d)) m = d1.y;\n    else m = d2.y;\n    \n    return vec2(d, m);\n}\n\n// Return vec2 with larger signed distance\nvec2 opMax(vec2 d1, vec2 d2) {\n    return (d1.x > d2.x) ? d1 : d2;\n}\n\n// Return (the smallest sd, material constant)\nvec2 map(vec3 p) {\n    vec2 res = vec2(10000.0, -1.0);\n    \n    // Repetition\n    vec3 q = p;\n    float s = 3.0;\n    q = q - round(q/s)*s;\n    \n    float m = 6.0;\n    // Poll\n    res = opSmoothMin(res, vec2(sdPoll(q - vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.1), m), 0.1);\n    res = opSmoothMin(res, vec2(sdPoll(q - vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.1), m), 0.1);\n    res = opSmoothMin(res, vec2(sdPoll(q - vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.1), m), 0.1);\n    \n    m = 4.0;\n    // Box\n    res = opMin(res, vec2(sdRoundBox(q - vec3(0.0, 0.0, 0.0), vec3(0.4, 0.4, 0.4), 0.1), m));\n    // Sphere\n    res = opSmoothMin(res, vec2(sdSphere(q - vec3(0.0, 0.0, 0.0), 0.6), m), 0.2);\n    \n    return res;\n}\n\n// Calculate normal\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.001;\n    const vec2 h = vec2(eps, 0.0);\n    \n    float dx = map(p + h.xyy).x - map(p - h.xyy).x;\n    float dy = map(p + h.yxy).x - map(p - h.yxy).x;\n    float dz = map(p + h.yyx).x - map(p - h.yyx).x;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// Return (distance from camera orig, material constant)\nvec2 raymarching(vec3 orig, vec3 dir) {\n    vec2 res = vec2(-1.0, -1.0);\n\n    const int maxStep = 200;\n    const float eps = 0.01;\n    \n    float t = 0.0;\n    for (int i = 0; i < maxStep; i++) {\n        // Compute current signed distance\n        vec2 h = map(orig + t*dir);\n        if (h.x < eps) {\n            res = vec2(t, h.y);\n            break;\n        }\n        \n        // Step next position\n        t += h.x;\n    }\n    return res;\n}\n\n// Perform rendering\n// 1. cast a ray from orig to dir\n// 2. compute material\n// 3. compute lighting\nvec3 render(vec3 orig, vec3 dir) {\n    // background\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // raymarching\n    vec2 res = raymarching(orig, dir);\n    float t = res.x; // distance from camera orig\n    float m = res.y; // material constant\n    \n    if (m > -0.5) {    \n        vec3 pos = orig + t*dir;\n        vec3 nor = calcNormal(pos);\n        \n        // material\n        vec3 matCol = 0.6 + 0.2*sin(m*2.0 + vec3(0.0, 1.0, 2.0));\n        float matShine = 32.0;\n        \n        // light\n        vec3 lightPos = vec3(3.0, 4.0, 5.0);\n        vec3 lightAmb = vec3(0.3, 0.3, 0.3);\n        vec3 lightDif = vec3(0.5, 0.5, 0.5);\n        vec3 lightSpe = vec3(1.0, 1.0, 1.0);\n        \n        // compute lighting\n        // ambient\n        vec3 ambient = lightAmb * matCol;\n        \n        // diffuse\n        vec3 lightDir = normalize(lightPos - pos);\n        float diff = max(dot(nor, lightDir), 0.0);\n        vec3 diffuse = lightDif * diff * matCol;\n        \n        // specular\n        vec3 viewDir = normalize(CameraFrom() - pos);\n        vec3 reflectDir = reflect(-lightDir, nor);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), matShine);\n        vec3 specular = lightSpe * spec * matCol;\n        \n        col = ambient + diffuse + specular;\n    }\n    \n    // gamma correction\n    float gamma = 1.3;\n    col = pow(col, vec3(1.0/gamma));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Compute bases in the camera coordinate: u, v, w\n    vec3 w = normalize(CameraTo() - CameraFrom());\n    vec3 u = normalize(cross(w, CameraUp()));\n    vec3 v = normalize(cross(u, w));\n    vec3 e = CameraFrom();\n    \n    // Convert pixel-coordinates to camera-coordinates\n    float x = ScreenWidth() * (fragCoord.x /iResolution.x - 0.5);\n    float y = ScreenHeight() * (fragCoord.y / iResolution.y - 0.5);\n    float z = ScreenDistance();\n    vec3 cameraCoord = vec3(x, y, z);\n    \n    // Anti Aliasing\n    vec2[4] offsets = vec2[](\n        vec2(0.0, 0.0),\n        vec2(0.5, 0.0),\n        vec2(0.0, 0.5),\n        vec2(0.5, 0.5)\n    );\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec2 offset = offsets[i];\n    \n        // Compute world-coordinates\n        vec3 worldCoord = e;\n        worldCoord += (cameraCoord.x + ScreenWidth()/iResolution.x*offset.x)*u;\n        worldCoord += (cameraCoord.y + ScreenHeight()/iResolution.y*offset.y)*v;\n        worldCoord += cameraCoord.z*w;\n\n        // Set ray information\n        vec3 orig = e;\n        vec3 dir = normalize(worldCoord - orig);\n        \n        col += render(orig, dir);\n    }\n    col /= 4.0;\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}