{"ver":"0.1","info":{"id":"MttGRS","date":"1470049346","viewed":186,"name":"Hanger","username":"Sobaya","description":"A wooden hanger.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","distancefunction","wood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nfloat distHook(vec3 p) {\n  p = rotate(p, vec3(0,1,0), iTime * 300.);\n  p = scale(p, vec3(0.8, 1,1));\n  p = translate(p, vec3(0,1,0));\n  float sub = length(translate(p, vec3(-0.7,-0.7,0))) - 0.8;\n  vec2 q = vec2(length(p.xy) - 1., p.z);\n  return max(length(q) - 0.1, -sub);\n}\n\nfloat distPoll(vec3 p) {\n  p = translate(p, vec3(0,-1,0));\n  p = scale(p, vec3(1,5,1));\n  vec2 d = abs(vec2(length(p.xz), p.y)) - 0.15;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat distMetalBall(vec3 p) {\n  p = rotate(p, vec3(0,1,0), iTime * 300.);\n  p = translate(p, vec3(-0.80,0.9,0));\n  return length(p) - 0.2;\n}\n\nfloat distMetalUnder(vec3 p) {\n  p.x = abs(p.x);\n  p = translate(p, vec3(4,-5,0));\n  p = scale(p, vec3(1,10,1));\n  vec2 d = abs(vec2(length(p.xz), p.y)) - 0.05;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat distMetal(vec3 p) {\n  float result = smin(distHook(p), distPoll(p), 17.);\n  result = smin(result, distMetalBall(p), 17.);\n  result = min(result, distMetalUnder(p));\n  return result;\n}\n\nfloat distWood1(vec3 p) {\n  p = scale(p, vec3(0.1+abs(p.y) * 0.5,1,1));\n  p = translate(p, vec3(0,-1.5,0));\n  return length(max(abs(p) - vec3(1.0,0.6,0.2), 0.));\n}\n\nfloat distWood2(vec3 p) {\n  p.x = abs(p.x);\n  p = translate(p, vec3(0,-1.5,0));\n  p = rotate(p, vec3(0,0,1) , -35.);\n  p = scale(p, vec3(1, p.x * p.x * 0.07 +2., p.x * p.x * p.x * 0.03 +1.));\n  vec3 s = vec3(0);\n  vec3 e = vec3(5, 0, 0);\n  vec3 ps = p - s;\n  vec3 es = e - s;\n  float h = clamp(dot(ps, es) / dot(es, es), 0., 1.);\n  float d = length(ps - es * h) - 0.2;\n  float sub = p.y;\n  return max(d, -sub);\n}\n\nfloat distWood(vec3 p) {\n  return smin(distWood1(p), distWood2(p), 17.);\n}\n\n\nfloat distUnder(vec3 p) {\n  p = translate(p, vec3(0,-5.5,0));\n  p = scale(p, vec3(20,1,1));\n  vec2 d = abs(vec2(length(p.yz), p.x)) - 0.2;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat dist(vec3 p) {\n  p = translate(p, vec3(0,3,0));\n  float result = min(distMetal(p), distWood(p));\n  result = min(result, distUnder(p));\n  return result;\n  //return result-0.2-0.04*(sin(iTime/3.+p.x*p.x*0.3)+sin(20.*iTime/3.+p.y*p.y*0.2)+sin((iTime/3.+p.z*p.z*0.3)));\n}\n\nint getNearestIndex(vec3 p) {\n  p = translate(p, vec3(0,3,0));\n  float dist = distMetal(p);\n  int idx = 0;\n  float d = distWood(p);\n  if (d < dist) {\n    dist = d;\n    idx = 1;\n  }\n  d = distUnder(p);\n  if (d < dist) {\n    dist = d;\n    idx = 2;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float angle = -.5 * iTime;\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 n = normalize(vec3(0,1,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n  \tvec3 eye = vec3(0,0,-5);\n \teye = rot * eye;\n \tvec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n \tray = rot * ray;\n\tray = normalize(ray);\n \tvec3 current = rayMarch(eye, ray);\n\n \tvec3 lightPos = vec3(1,1,-1) * 10.;\n\n\t if (abs(dist(current)) < eps) {\n \t \tvec3 n = getNormal(current);\n    \tvec3 eyeVec = normalize(eye - current);\n    \tvec3 lightVec = normalize(lightPos - current);\n    \tvec3 refVec = reflect(-lightVec, n);\n    \tfloat diffuse = max(0.,dot(eyeVec, n));\n    \tfloat spec = max(0.,dot(eyeVec, refVec));\n     \tint idx = getNearestIndex(current);\n     \tif (idx == 0) {\n        \tvec4 reflectColor = texture(iChannel0, cubeMap(current, refVec));\n        \tfragColor = reflectColor * 0.2 + vec4(0.5,0.5,0.5,1) * 0.8;\n        \tfragColor *= diffuse;\n        \tfragColor += pow(spec, 5.);\n     \t} else if (idx == 1) {\n        \tvec3 dir = vec3(0.01,0.2,0.5);\n        \tfloat t = noise(current * noise(current * 100.) * 3000. * dir);\n        \tvec4 lightColor = vec4(213,136,76,255) / 255.;\n        \tvec4 darkColor = vec4(vec3(lightColor.rgb / 4.), 1);\n        \tfragColor = mix(lightColor, darkColor, t) * diffuse;\n        \tfragColor += lightColor * pow(spec, 30.) * (1.-t);\n      \t} else if (idx == 2) {\n        \tfragColor = vec4(0,0,0,1) * diffuse;\n      \t}\n\t} else {\n    \tfragColor = vec4(0.25);\n    \tfragColor.a = 1.;\n \t}\n}\n","name":"Image","description":"","type":"image"}]}