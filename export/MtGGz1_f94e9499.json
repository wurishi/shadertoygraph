{"ver":"0.1","info":{"id":"MtGGz1","date":"1473107125","viewed":818,"name":"IcePrimitives_simplerVersion","username":"Bers","description":"Simpler implementation of https://www.shadertoy.com/view/MscXzn.\nNo sliders.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","primitives","ice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author : Sebastien Berube\n// Created : Dec 2014\n// Modified : Sept 2016\n//\n// Shorter version of https://www.shadertoy.com/view/MscXzn, without sliders\n// Based on primitives shader from Inigo Quilez : https://www.shadertoy.com/view/Xds3zN\n//\n// Notes:\n// \n// - Most logic can be found in renderIce() and mainImage()\n// - distance function map() works as usual, as all boolean operations and signed distance functions do.\n// - castRay() function was modified for volume raymarching (sign added, simple as that).\n// - triplanar noise projection used for surface normal noise.\n// - smooth subtraction was implemented to smooth out boolean shape.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants \nconst float GEO_MAX_DIST  = 1000.0;\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_ICE_OUTER = 2;\nconst int MATERIALID_ICE_INNER = 3;\nconst int MATERIALID_SKY       = 4;\nconst float PI             = 3.14159;\nconst float ROUGHNESS      = 1.25;\nconst float ISOVALUE       = 0.03;\nconst float REFRACTION_IDX = 1.31;\n\nvec3 NORMALMAP_main(vec3 p, vec3 n);\nfloat softshadow(vec3 ro, vec3 rd, float coneWidth);\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdTriPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat length2( vec2 p ){\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( vec2 p ){\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus88( vec3 p, vec2 t ){\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\nfloat opSmoothSubtract( float d1, float d2 ){\n    return length(vec2(max(d1,0.),min(d2,0.0)));\n}\nfloat opU( float d1, float d2 ){\n\treturn (d1<d2) ? d1 : d2;\n}\nvec3 opTwist( vec3 p ){\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nstruct DF_out{\n    float d;  //Distance to geometry\n    int matID;//Geometry material ID\n};\nDF_out map( in vec3 pos ){\n    float dist = opU( sdPlane(     pos-vec3( -1.4) ),\n\t                sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ) );\n    dist = opU( dist, udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ) );\n\tdist = opU( dist, sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ) );\n\tdist = opU( dist, sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ) );\n\tdist = opU( dist, sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.10,0.20) ) );\n\tdist = opU( dist, sdTorus88(   pos-vec3(-1.0,0.25, 1.0), vec2(0.20,0.05) ) );\n    dist = opU( dist, opSmoothSubtract(\n\t                      udRoundBox(  pos-vec3(-1.0,0.2, 0.0), vec3(0.15),0.05),\n\t                      sdSphere(    pos-vec3(-1.0,0.2, 0.0), 0.25)) );\n    dist = opU( dist, sdBox(       pos-vec3( 0.0,0.20,-1.0), vec3(0.25)) );\n\tdist = opU( dist, 0.5*sdTorus( opTwist(pos-vec3( 1.0,0.25, 0.0)),vec2(0.15,0.02)) );\n    DF_out outData;\n    outData.d = dist-ISOVALUE;\n    outData.matID = MATERIALID_ICE_OUTER;\n    return outData;\n}\nvec3 gradient( in vec3 p ){\n\tconst float d = 0.001;\n\treturn vec3(map(p+vec3(d,0,0)).d-map(p-vec3(d,0,0)).d,\n                map(p+vec3(0,d,0)).d-map(p-vec3(0,d,0)).d,\n                map(p+vec3(0,0,d)).d-map(p-vec3(0,0,d)).d);\n}\nvec2 castRay( const vec3 o, const vec3 d, const float tmin, const float eps, const bool bInternal){\n    float tmax = 10.0, t = tmin, dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ ){\n        vec3 p = o+d*t;\n\t    dist = (bInternal?-1.:1.)*map(p).d;//[modified for internal marching]\n        if( abs(dist)<eps || t>tmax )\n            break;\n        t += dist;\n    }\n    dist = (dist<tmax)?dist:GEO_MAX_DIST;\n    return vec2( t, dist );\n}\n#define saturate(x) clamp(x,0.0,1.0)\nfloat softshadow( vec3 o, vec3 L, float coneWidth ){\n    float t = 0.0, minAperture = 1.0, dist = GEO_MAX_DIST;\n    for( int i=0; i<6; i++ ){\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = map( p ).d;\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        t += 0.03+dist; //0.03 : min step size.\n    }\n    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\nstruct TraceData{\n    float rayLen;\n    vec3  rayDir;\n    vec3  normal;\n    int   matID;\n    vec3  matUVW;\n    float alpha;\n};\nTraceData TRACE_getFront(const in TraceData tDataA, const in TraceData tDataB){\n    if(tDataA.rayLen<tDataB.rayLen)\n    \treturn tDataA;\n    else\n        return tDataB;\n}\nTraceData TRACE_cheap(vec3 o, vec3 d){\n    TraceData floorData;\n\tfloorData.rayLen  = dot(vec3(-0.1)-o,vec3(0,1,0))/dot(d,vec3(0,1,0));\n    if(floorData.rayLen<0.0) floorData.rayLen = GEO_MAX_DIST;\n\tfloorData.rayDir  = d;\n\tfloorData.normal  = vec3(0,1,0);\n\tfloorData.matUVW  = o+d*floorData.rayLen;\n\tfloorData.matID   = MATERIALID_FLOOR;\n    floorData.alpha   = 1.0;\n    \n    TraceData skyData;\n    skyData.rayLen  = 50.0;\n    skyData.rayDir  = d;\n\tskyData.normal  = -d;\n\tskyData.matUVW  = d;\n\tskyData.matID   = MATERIALID_SKY;\n    skyData.alpha   = 1.0;\n    return TRACE_getFront(floorData,skyData);\n}\nTraceData TRACE_reflexion(vec3 o, vec3 d){\n    return TRACE_cheap(o,d);\n}\nTraceData TRACE_geometry(vec3 o, vec3 d){\n    TraceData cheapTrace = TRACE_cheap(o,d);\n    \n    TraceData iceTrace;\n    vec2 rayLen_geoDist = castRay(o,d,0.1,0.0001,false);\n    vec3 iceHitPosition = o+rayLen_geoDist.x*d;\n    iceTrace.rayDir     = d;\n    iceTrace.rayLen     = rayLen_geoDist.x;\n    iceTrace.normal     = normalize(gradient(iceHitPosition));\n    iceTrace.matUVW     = iceHitPosition;\n    iceTrace.matID      = MATERIALID_ICE_OUTER;\n    iceTrace.alpha      = 0.0;\n    \n    return TRACE_getFront(cheapTrace,iceTrace);\n}\nTraceData TRACE_translucentDensity(vec3 o, vec3 d){\n    TraceData innerIceTrace;\n    \n    vec2 rayLen_geoDist   = castRay(o,d,0.01,0.001,true).xy;\n    vec3 iceExitPosition  = o+rayLen_geoDist.x*d;\n    innerIceTrace.rayDir  = d;\n    innerIceTrace.rayLen  = rayLen_geoDist.x;\n    innerIceTrace.normal  = normalize(gradient(iceExitPosition));\n    innerIceTrace.matUVW  = iceExitPosition;\n    innerIceTrace.matID   = MATERIALID_ICE_INNER;\n    innerIceTrace.alpha   = rayLen_geoDist.x;\n    return innerIceTrace;\n}\nvec3 NORMALMAP_smoothSampling(vec2 uv){\n    vec2 x = fract(uv*64.+0.5);\n    return texture(iChannel0,uv-(x)/64.+(6.*x*x-15.0*x+10.)*x*x*x/64.,-100.0).xyz;\n}\nfloat NORMALMAP_triplanarSampling(vec3 p, vec3 n){\n\tfloat fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n\treturn  (abs(n.x)*NORMALMAP_smoothSampling(p.yz).x\n            +abs(n.y)*NORMALMAP_smoothSampling(p.xz).x\n            +abs(n.z)*NORMALMAP_smoothSampling(p.xy).x)/fTotal;\n}\nfloat NORMALMAP_triplanarNoise(vec3 p, vec3 n){\n    const mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = NORMALMAP_triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy; p.xz = m2*p.xz; p *= 2.1;\n    float f2 = NORMALMAP_triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx; p.yz = m2*p.yz; p *= 2.3;\n    float f3 = NORMALMAP_triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\nvec3 NORMALMAP_main(vec3 p, vec3 n){\n    float d = 0.005;\n    float po = NORMALMAP_triplanarNoise(p,n);\n    return normalize(vec3((NORMALMAP_triplanarNoise(p+vec3(d,0,0),n)-po)/d,\n                          (NORMALMAP_triplanarNoise(p+vec3(0,d,0),n)-po)/d,\n                          (NORMALMAP_triplanarNoise(p+vec3(0,0,d),n)-po)/d));\n}\nstruct Cam{vec3 R;vec3 U;vec3 D;vec3 o;};\nstruct IceTracingData{\n    TraceData reflectTraceData;\n\tTraceData translucentTraceData;\n    TraceData exitTraceData;\n};\nIceTracingData renderIce(TraceData iceSurface, vec3 ptIce, vec3 dir){\n    IceTracingData iceData;\n    vec3 normalDelta = NORMALMAP_main(ptIce*ROUGHNESS,iceSurface.normal)*ROUGHNESS/10.;\n    vec3 iceSurfaceNormal = normalize(iceSurface.normal+normalDelta); \n    vec3 refract_dir = refract(dir,iceSurfaceNormal,1.0/REFRACTION_IDX); //Ice refraction index = 1.31\n    vec3 reflect_dir = reflect(dir,iceSurfaceNormal);\n\n    //Trace reflection\n    iceData.reflectTraceData = TRACE_reflexion(ptIce,reflect_dir);\n    \n    //Balance between refraction and reflection (not entirely physically accurate, Fresnel could be used here).\n    float fReflectAlpha = 0.5*(1.0-abs(dot(normalize(dir),iceSurfaceNormal)));\n    iceData.reflectTraceData.alpha = fReflectAlpha;\n    vec3 ptReflect = ptIce+iceData.reflectTraceData.rayLen*reflect_dir;\n\n    //Trace refraction\n    iceData.translucentTraceData = TRACE_translucentDensity(ptIce,refract_dir);\n    \n    vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*refract_dir;\n    vec3 exitRefract_dir = refract(refract_dir,-iceData.translucentTraceData.normal,REFRACTION_IDX);\n\n    //This value fades around total internal refraction angle threshold.\n    if(length(exitRefract_dir)<=0.95)\n    {\n        //Total internal reflection (either refraction or reflexion, to keep things cheap).\n        exitRefract_dir = reflect(refract_dir,-iceData.translucentTraceData.normal);\n    }\n    \n    //Trace environment upon exit.\n    iceData.exitTraceData = TRACE_cheap(ptRefract,exitRefract_dir);\n    iceData.exitTraceData.matID = MATERIALID_FLOOR;\n    \n    return iceData;\n}\nvec4 MAT_apply(vec3 pos, TraceData traceData){\n    if(traceData.matID==MATERIALID_NONE)\n        return vec4(0,0,0,1);\n    if(traceData.matID==MATERIALID_ICE_INNER)\n        return vec4(1.0);\n    if(traceData.matID==MATERIALID_SKY)\n    \treturn vec4(0.6,0.7,0.85,1.0);\n    vec3 cDiff = pow(texture(iChannel1,traceData.matUVW.xz).rgb,vec3(1.2));\n    float dfss = softshadow(pos, normalize(vec3(-0.6,0.7,-0.5)), 0.07);\n\treturn vec4(cDiff*(0.45+1.2*(dfss)),1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    float rotX = 2.0*PI*(iMouse.x/iResolution.x+iTime*0.05);\n    Cam cam;\n    cam.o = vec3(cos(rotX),0.475,sin(rotX))*2.3;\n    cam.D = normalize(vec3(0,-0.25,0)-cam.o);\n    cam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = cross(cam.R,cam.D);\n    vec2 cuv = uv*2.0*iResolution.x/iResolution.y;//camera uv\n    vec3 dir = normalize(cuv.x*cam.R+cuv.y*cam.U+cam.D*2.5);\n    \n    vec3 ptReflect = vec3(0);\n    TraceData geometryTraceData = TRACE_geometry(cam.o, dir);\n    vec3 ptGeometry = cam.o+geometryTraceData.rayLen*dir;\n    \n    IceTracingData iceData;\n    iceData.translucentTraceData.rayLen = 0.0;\n    if(geometryTraceData.matID == MATERIALID_ICE_OUTER && geometryTraceData.rayLen < GEO_MAX_DIST){\n        vec3 ptIce = ptGeometry;\n        iceData = renderIce(geometryTraceData, ptIce, dir);\n        geometryTraceData = iceData.exitTraceData;\n        vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*iceData.translucentTraceData.rayDir;\n        ptReflect = ptIce+iceData.reflectTraceData.rayLen*iceData.reflectTraceData.rayDir;\n        ptGeometry = ptRefract+geometryTraceData.rayLen*dir;\n    }\n    vec4 cTerrain  = MAT_apply(ptGeometry,geometryTraceData);\n    vec4 cIceInner = MAT_apply(ptGeometry,iceData.translucentTraceData);\n    vec4 cReflect  = MAT_apply(ptReflect,iceData.reflectTraceData);\n    if(iceData.translucentTraceData.rayLen > 0.0 ){\n        float fTrav = iceData.translucentTraceData.rayLen;\n        vec3 cRefract = cTerrain.rgb;\n        cRefract.rgb = mix(cRefract,cIceInner.rgb,0.3*fTrav+0.2*sqrt(fTrav*3.0));\n        cRefract.rgb += fTrav*0.3;\n        vec3 cIce = mix(cRefract,cReflect.rgb,iceData.reflectTraceData.alpha);\n        fragColor.rgb = cIce;\n\t}\n    else\n       fragColor.rgb = cTerrain.rgb;\n    \n    //Vignetting + Gamma\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    fragColor.rgb = pow(fragColor.rgb*cos2*cos2,vec3(0.4545)); //2.2 Gamma compensation\n}","name":"Image","description":"","type":"image"}]}