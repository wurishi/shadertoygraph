{"ver":"0.1","info":{"id":"XldSDn","date":"1480302274","viewed":753,"name":"Dancing Tentacle","username":"mplanck","description":"Building off https://www.shadertoy.com/view/MtdSzn. Using FABRIK. Optimized with buffer and added joint constraints.","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["fabrik","distmarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click and drag mouse to drive IK target\n// TODO: show the pick plane \n\n// Tested on 13-inch Mac Powerbook Chrome\n// Tested on Nvidia GTX 1080 Windows 10 Chrome\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// MATERIAL DEFINES\n\n#define CHAMBER_MATL 1.\n#define BOND_MATL 2.\n#define WATER_MATL 3.\n#define SPHERE_MATL 4.\n\n#define NUM_PTS 9\n#define NUM_SEGS 8\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\n\nvec3  g_key_ldir     = normalize(vec3(0., 0.5, 1.));\nvec3  g_rim_ldir  = normalize(vec3(-.6, .4, -0.5));\n\nstruct Arm\n{    \n    vec3 pts[NUM_PTS]; \n    float pt_sizes[NUM_PTS];\n} g_arm;\n\n// **************************************************************************\n// UTILITIES\n\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\nvec2 mergeobjs(vec2 a, vec2 b) \n{\n    if (a.x < b.x) { return a; } \n    else { return b; }\n    \n    // XXX: Some architectures have bad optimization paths\n    // that will cause inappropriate branching if you DON'T\n    // use an if statement here.\n    \n    //return mix(b, a, step(a.x, b.x)); \n}\n\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat spheredf( vec3 pos, float r ) \n{\n    return length( pos ) - r;\n}\n\nfloat segmentdf( vec3 p, vec3 a, vec3 b, float r)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / max(SMALL_FLOAT, dot(ba, ba));\n    t = clamp(t, 0., 1.);\n    return length(ba * t + a - p) - r;\n}\n\nfloat planedf( vec3 pos, float y)\n{\n    return abs(pos.y - y);\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 armobj(vec3 p, float mr)\n{    \n\n    vec2 ballsobj = vec2(BIG_FLOAT, SPHERE_MATL);\n   \tvec3 ap = p;\n    \n    // unrolling the for loop sped things up from 21 fps to 35 fps on my\n    // 13 inch MacBook Pro, so be mindful if NUM_PTS changes.\n\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[0], 1.1*g_arm.pt_sizes[0]), SPHERE_MATL+0.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[1], 1.1*g_arm.pt_sizes[1]), SPHERE_MATL+1.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[2], 1.1*g_arm.pt_sizes[2]), SPHERE_MATL+2.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[3], 1.1*g_arm.pt_sizes[3]), SPHERE_MATL+3.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[4], 1.1*g_arm.pt_sizes[4]), SPHERE_MATL+4.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[5], 1.1*g_arm.pt_sizes[5]), SPHERE_MATL+5.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[6], 1.1*g_arm.pt_sizes[6]), SPHERE_MATL+6.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[7], 1.1*g_arm.pt_sizes[7]), SPHERE_MATL+7.));\n    ballsobj = mergeobjs(ballsobj, vec2(spheredf(ap - g_arm.pts[8], 1.1*g_arm.pt_sizes[8]), SPHERE_MATL+8.));\n                         \n\n    vec2 bondsobj = vec2(BIG_FLOAT, BOND_MATL);\n\n    /*\n    float br = .3 * mr;\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[0], g_arm.pts[1], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[1], g_arm.pts[2], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[2], g_arm.pts[3], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[3], g_arm.pts[4], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[4], g_arm.pts[5], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[5], g_arm.pts[6], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[6], g_arm.pts[7], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[7], g_arm.pts[8], br));\n\t*/\n    \n    return mergeobjs(ballsobj, bondsobj);\n}\n\nvec2 chamberobj(vec3 p)\n{\n    return vec2(12. - length(p), CHAMBER_MATL);\n}\n\nvec2 waterobj(vec3 p)\n{\n    //vec3 ap = p - .1 * (.5 * (sin(2. * length(p)) + .5));\n    return vec2(planedf(p, -2.), WATER_MATL);\n}\n\n\nvec2 scenedf( vec3 p )\n{\n    vec2 obj = armobj( p, .22 );\n    \n    obj = mergeobjs(chamberobj(p), obj);\n    \n\tobj = mergeobjs(waterobj(p), obj);\n    return obj;\n}\n\n#define DISTMARCH_STEPS 40\n#define DISTMARCH_MAXDIST 20.\n\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || t > maxd ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec2( t, material );\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\n#define SOFTSHADOW_STEPS 30\n#define SOFTSHADOW_STEPSIZE .1\n\nfloat calcSoftShadow( vec3 ro, \n  vec3 rd, \n  float mint, \n  float maxt, \n  float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 6\n#define AO_STEPSIZE .1\n#define AO_STEPSCALE .45\n\nfloat calcAO( vec3 p, vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi< AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid setupGlobals()\n{\n    \n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(6.5, -2., 0.);\n    \n    float rotx    = -1. * PI * .45 + .0 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = 0.;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., -.2, 0.);    \n    \n    float lroty    = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n    \n    //g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\n    \n    g_arm.pts[0] = vec3(0., -2., 0.);\n    g_arm.pt_sizes[0] = 1.;\n    g_arm.pts[1] = vec3(0., -1.5, 0.);\n    g_arm.pt_sizes[1] = .9;\n    g_arm.pts[2] = vec3(0., -1., 0.);\n    g_arm.pt_sizes[2] = .8;\n    g_arm.pts[3] = vec3(0., -.5, 0.);\n    g_arm.pt_sizes[3] = .7;\n    g_arm.pts[4] = vec3(0., 0., 0.);\n    g_arm.pt_sizes[4] = .6;\n    g_arm.pts[5] = vec3(0., .5, 0.);\n    g_arm.pt_sizes[5] = .5;\n    g_arm.pts[6] = vec3(0., 1., 0.);\n    g_arm.pt_sizes[6] = .4;\n    g_arm.pts[7] = vec3(0., 1.5, 0.);\n    g_arm.pt_sizes[7] = .3;\n    g_arm.pts[8] = vec3(0., 2., 0.);\n    g_arm.pt_sizes[8] = .2;\n    \n    /*\n    g_arm.pts[0] = vec3(0., -2., 0.);\n    g_arm.pt_sizes[0] = .1;\n    g_arm.pts[1] = vec3(0., -1.5, 0.);\n    g_arm.pt_sizes[1] = .1;\n    g_arm.pts[2] = vec3(0., -1., 0.);\n    g_arm.pt_sizes[2] = .1;\n    g_arm.pts[3] = vec3(0., -.5, 0.);\n    g_arm.pt_sizes[3] = .1;\n    g_arm.pts[4] = vec3(0., 0., 0.);\n    g_arm.pt_sizes[4] = .1;\n    g_arm.pts[5] = vec3(0., .5, 0.);\n    g_arm.pt_sizes[5] = .1;\n    g_arm.pts[6] = vec3(0., 1., 0.);\n    g_arm.pt_sizes[6] = .1;\n    g_arm.pts[7] = vec3(0., 1.5, 0.);\n    g_arm.pt_sizes[7] = .1;\n    g_arm.pts[8] = vec3(0., 2., 0.);\n    g_arm.pt_sizes[8] = .1;\n\t*/\n    \n}\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera( in vec2 fragCoord )\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    vec3 point;\n    vec3 normal;\n    vec3 basecolor;\n    float roughness;\n    float metallic;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), 0., 0.)\n\nvec3 calcNormal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + epsilon.xyy).x - scenedf(p - epsilon.xyy).x,\n        scenedf(p + epsilon.yxy).x - scenedf(p - epsilon.yxy).x,\n        scenedf(p + epsilon.yyx).x - scenedf(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvec3 calc_tentacle_normal(vec3 n, vec3 dir)\n{\n    vec3 d = normalize(dir);\n    vec3 r = cross(cross(d, n), d);\n    return normalize(mix(r, n, 0.2));\n}\n\nvoid setup_material(float surfid,\n  inout SurfaceData surf)\n{\n    vec3 surfcol = vec3(1.);\n    if (surfid - .5 < CHAMBER_MATL)\n    {\n        surf.basecolor = vec3(0.);\n        surf.roughness = 1.;\n    }\n    else if (surfid - .5 < BOND_MATL)\n    {\n        surf.basecolor = vec3(.02,.02,.05);\n        surf.roughness = .2;\n        surf.metallic = .0;\n    }\n    else if (surfid - .5 < WATER_MATL)\n    {\n        surf.basecolor = vec3(.02,.05,.06);\n        surf.roughness = .05;\n        surf.metallic = 0.;\n        float s = sin(4. * (length(surf.point) - g_time));\n        float f = smoothstep(.1, .2, s);\n        surf.basecolor *= 1. - .2 * f;\n        surf.normal = normalize(surf.normal + normalize(surf.point) * .14 * s);\n    }\n    else\n    {\n        int seg_idx = int(surfid - SPHERE_MATL);\n        // ugly, but doing this since seg_idx is not a constant\n        if (seg_idx == 0) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[1] - g_arm.pts[0]);\n        if (seg_idx == 1) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[2] - g_arm.pts[1]);\n        if (seg_idx == 2) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[3] - g_arm.pts[2]);\n        if (seg_idx == 3) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[4] - g_arm.pts[3]);\n        if (seg_idx == 4) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[5] - g_arm.pts[4]);\n        if (seg_idx == 5) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[6] - g_arm.pts[5]);\n        if (seg_idx == 6) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[7] - g_arm.pts[6]);\n        if (seg_idx == 7) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[8] - g_arm.pts[7]);\n        if (seg_idx == 8) surf.normal = calc_tentacle_normal(surf.normal, g_arm.pts[8] - g_arm.pts[7]);\n        //surf.basecolor = .6*vec3(.16, .26, .15); \n        surf.basecolor = .6*vec3(.28, .16, .25); \n        //surf.basecolor *= 1. + 1. * smoothstep(2., 0., mod(surfid - SPHERE_MATL - 10. * g_time, 8.));\n        surf.roughness = .8;\n        surf.metallic = .7;\n    }\n\n}\n\nvec3 integrateDirLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n\n    // The half vector of a microfacet model \n    vec3 hdir = normalize(ldir + vdir);\n    \n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh = max(-SMALL_FLOAT, dot(surf.normal, hdir)); \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd = max(-SMALL_FLOAT, dot(ldir, hdir));      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl = max(-SMALL_FLOAT, dot(surf.normal, ldir));\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv = max(-SMALL_FLOAT, dot(surf.normal, vdir));\n\n    float ndl = clamp( costl, 0., 1.);\n\n    vec3 cout = vec3(0.);\n\n    if (ndl > 0.)\n    {\n        float frk = .5 + 2.* costd*costd * surf.roughness;\n        vec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-costl)) * (1. + (frk - 1.) * pow5(1.-costv));\n        //vec3 diff = surf.basecolor * ONE_OVER_PI; // lambert\n\n        // D(h) factor\n        // using the GGX approximation where the gamma factor is 2.\n\n        // Clamping roughness so that a directional light has a specular\n        // response.  A roughness of perfectly 0 will create light \n        // singularities.\n        float r = max(0.05, surf.roughness);\n        float alpha = r * r;\n        float denom = costh*costh * (alpha*alpha - 1.) + 1.;\n        float D = (alpha*alpha)/(PI * denom*denom); \n\n        // using the GTR approximation where the gamma factor is generalized\n        // float alpha = surf.roughness * surf.roughness;\n        // float gamma = 2.;\n        // float sinth = length(cross(surf.normal, hdir));\n        // float D = 1./pow(alpha*alpha*costh*costh + sinth*sinth, gamma);\n\n        // G(h,l,v) factor\n        float k = ((r + 1.) * (r + 1.))/8.;    \n        float Gl = costv/(costv * (1. - k) + k);\n        float Gv = costl/(costl * (1. - k) + k);\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\n        vec3 spec = D * F * G / (4. * costl * costv);\n        \n        float shd = calcSoftShadow( surf.point, ldir, 0.1, 20., 6.);\n        \n        cout  += diff * ndl * shd * lcolor;\n        cout  += spec * ndl * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 sampleEnvLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n\n    // The half vector of a microfacet model \n    vec3 hdir = normalize(ldir + vdir);\n    \n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh = dot(surf.normal, hdir); \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd = dot(ldir, hdir);      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl = dot( surf.normal, ldir );\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv = dot( surf.normal, vdir );\n\n    float ndl = clamp( costl, 0., 1.);\n    vec3 cout = vec3(0.);\n    if (ndl > 0.) \n    {\n\n        float r = surf.roughness;\n        // G(h,l,v) factor\n        float k = r*r/2.;    \n        float Gl = costv/(costv * (1. - k) + k);\n        float Gv = costl/(costl * (1. - k) + k);\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\n        // Combines the BRDF as well as the pdf of this particular\n        // sample direction.\n        vec3 spec = lcolor * G * F * costd / (costh * costv);\n        \n        float shd = calcSoftShadow( surf.point, ldir, 0.1, 5., 4.);\n\n        cout = spec * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 integrateEnvLight(SurfaceData surf)\n{\n    vec3 vdir = normalize( surf.point - g_camOrigin );    \n    vec3 envdir = reflect(vdir, surf.normal);\n    vec4 specolor = vec4(.5) * texture(iChannel0, envdir) * (1. - surf.roughness);\n    \n    specolor.rgb = mix( specolor.rgb, vec3(dot(specolor.rgb,vec3(0.333))), .6 );\n    vec3 envspec = sampleEnvLight(envdir, specolor.rgb, surf);\n    return envspec;\n}\n\nvec3 shadeSurface(SurfaceData surf)\n{    \n\n    vec3 amb = surf.basecolor * .04;\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = calcAO(surf.point, surf.normal);\n\n    vec3 cout = vec3(0.);\n    if (dot(surf.basecolor, vec3(1.)) > SMALL_FLOAT)\n    {\n        cout  += integrateDirLight(g_key_ldir,  vec3(.3), surf);\n        cout  += integrateDirLight(g_rim_ldir, .4 * vec3(1., .95, 1.), surf);\n        cout  += integrateEnvLight(surf) * (1. - 3.5 * ao);\n        cout  += amb * (1. - 5.5 * ao);\n    }\n    return cout;\n\n}\n\n// **************************************************************************\n// MAIN\n\nvec4 loadState(vec2 stateCoord)\n{\n    return texture(iChannel2, (stateCoord+.5) / iChannelResolution[2].xy, -100.);    \n}\n\n\nvoid loadFromBufferA(void)\n{\n    for (int i = 0; i < NUM_PTS; i++)\n    {\n\t    g_arm.pts[i] = loadState(vec2(0., float(i))).xyz;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    setupGlobals();\n\n\n    CameraData cam = setupCamera( fragCoord );\n\n    // ----------------------------------------------------------------------\n    // FABRIK SOLVE\n\n    loadFromBufferA();\n    \n    // ----------------------------------------------------------------------\n    // SCENE MARCHING\n\n    vec2 scenemarch = distmarch( cam.origin, \n       cam.dir, \n       DISTMARCH_MAXDIST );\n    \n    // ----------------------------------------------------------------------\n    // SHADING\n\n    vec3 scenecol = vec3(0.);\n    if (scenemarch.y > SMALL_FLOAT)\n    {\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\n        vec3 mn = calcNormal( mp );\n\n        SurfaceData currSurf = INITSURF(mp, mn);\n\n        setup_material(scenemarch.y, currSurf);\n        scenecol = shadeSurface( currSurf );\n    }\n\n    // ----------------------------------------------------------------------\n    // POST PROCESSING\n    \n    // fall off exponentially into the distance (as if there is a spot light\n    // on the point of interest).\n    scenecol *= exp( -0.012 *(scenemarch.x*scenemarch.x - 300.));\n    \n    // brighten\n\tscenecol *= .7;\n    \n    // distance fog\n    scenecol = mix(scenecol, .02 * vec3(.4, .9, .9), smoothstep(10., 30., scenemarch.x));\n\n    // Contrast adjust - cute trick learned from iq\n    scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -1.3 );\n\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    // color tint\n    scenecol = .5 * scenecol + .5 * scenecol * vec3(1., 1., .9);\n    \n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n\n    //fragColor = texture(iChannel2, .1 * fragCoord / iChannelResolution[2].xy, -100.);    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Click and drag mouse to drive IK target\n// TODO: show the pick plane \n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// DEFINES\n\n#define NUM_PTS 9\n#define NUM_SEGS 8\n\n#define MAX_ITERATIONS 6\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\nfloat g_time         = 0.;\n\n\nstruct Arm\n{    \n    vec3 pts[NUM_PTS]; \n    float seg_angle_limits[NUM_SEGS];\n    float seg_length_limits[NUM_SEGS];\n} g_arm;\n\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ray_origin,\n                     vec3 ray_direction,\n                     vec3 plane_normal,\n                     vec3 plane_origin)\n{\n    float ray_direction_dot_normal = dot(ray_direction, plane_normal);\n\n    float denominator = ray_direction_dot_normal;    \n    float intersected = 0.;\n\n    float t = BIG_FLOAT;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is parallel to the given plane.\n    if (abs(denominator) > SMALL_FLOAT) {\n        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    \n        if (t > SMALL_FLOAT) {\n            intersected = 1.;\n        }\n    }\n    return vec2(intersected, t);\n\n}\n    \nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera( in vec2 fragCoord )\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid setupGlobals()\n{    \n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(6.5, -2., 0.);\n    \n    float rotx    = -1. * PI * .45 + .0 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = 0.;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., -.2, 0.);        \n    \n    g_arm.pts[0] = vec3(0., -2., 0.);\n    g_arm.seg_angle_limits[0] = .7;\n    g_arm.seg_length_limits[0] = .5;\n    \n    g_arm.pts[1] = vec3(0., -1.5, 0.);\n    g_arm.seg_angle_limits[1] = .7;\n    g_arm.seg_length_limits[1] = .5;\n    \n    g_arm.pts[2] = vec3(0., -1., 0.);\n    g_arm.seg_angle_limits[2] = .8;\n    g_arm.seg_length_limits[2] = .5;\n    \n    g_arm.pts[3] = vec3(0., -.5, 0.);\n    g_arm.seg_angle_limits[3] = .8;\n    g_arm.seg_length_limits[3] = .5;\n    \n    g_arm.pts[4] = vec3(0., 0., 0.);\n    g_arm.seg_angle_limits[4] = .7;\n    g_arm.seg_length_limits[4] = .5;\n    \n    g_arm.pts[5] = vec3(0., .5, 0.);\n    g_arm.seg_angle_limits[5] = .7;\n    g_arm.seg_length_limits[5] = .5;\n    \n    g_arm.pts[6] = vec3(0., 1., 0.);\n    g_arm.seg_angle_limits[6] = .7;\n    g_arm.seg_length_limits[6] = .4;\n    \n    g_arm.pts[7] = vec3(0., 1.5, 0.);\n    g_arm.seg_angle_limits[7] = .7;\n    g_arm.seg_length_limits[7] = .3;\n    \n    g_arm.pts[8] = vec3(0., 2., 0.);\n    \n}\n\nconst float c_solve_tolerance = .01;\n\nvoid solveFABRIK(vec3 target_pt)\n{\n    // assume g_arm.p9 has been placed before the solve has happened\n    float max_reach = 0.;\n    for (int idx = 0; idx < NUM_SEGS; idx++)\n    {\n        max_reach += g_arm.seg_length_limits[idx];\n    }\n        \n\tvec3 target_vec = target_pt - g_arm.pts[0];\n    float target_length = length(target_vec);\n    \n    vec3 resolve_target_pt = target_pt;\n    \n    // in the case where the target is out of reach - will need to \n    // be changed when we add constraints\n    if (target_length > max_reach)\n    {\n        g_arm.pts[NUM_PTS-1] = g_arm.pts[0] + target_vec * (max_reach/target_length);\n        \n        // optimization that causes pop\n        /*\n        float delta = 1./float(NUM_SEGS);\n        float f = delta;\n        target_vec = g_arm.pts[NUM_PTS-1] - g_arm.pts[0];\n        for (int idx = 1; idx < NUM_PTS-1; idx++)\n        {\n            g_arm.pts[idx] = g_arm.pts[0] + f * target_vec;\n            f += delta;\n        }\n\t\t*/\n\t\t\n        resolve_target_pt = g_arm.pts[NUM_PTS-1];\n    }\n    \n    \n    // solve for an IK target within reach\n    {\n        vec3 base_pt = g_arm.pts[0];\n        float dist_to_target = BIG_FLOAT;\n        \n        for(int iters = 0; iters < MAX_ITERATIONS; iters++)\n        {\n            if (c_solve_tolerance > dist_to_target) break;\n                \n            g_arm.pts[NUM_PTS-1] = target_pt;\n            // FRONT REACHING ITERATION\n            for (int idx = NUM_PTS-2; idx >= 0; idx--)\n            {\n                vec3 seg = g_arm.pts[idx+1] - g_arm.pts[idx];\n                float seg_length = length(seg);\n                vec3 reach = seg * (1. - (g_arm.seg_length_limits[idx]/seg_length));\n                \n\t\t\t\tvec3 new_pt = g_arm.pts[idx] + reach;\n                                               \n                if (idx <= NUM_PTS-3)\n                {\n\t                vec3 from = g_arm.pts[idx+1] - g_arm.pts[idx+2];\n                \tvec3 to = new_pt - g_arm.pts[idx+1];                                                                                                    \n                    \n                    vec3 nfrom = normalize(from);\n                    vec3 nto = normalize(to);\n                    \n                    float theta = max(SMALL_FLOAT, acos(dot(nfrom, nto)));\n                    // constraint of the joints\n                    float alpha = min(1., g_arm.seg_angle_limits[idx+1]/theta);\n                    \n                    float sinTheta = sin(theta);\n                    // slerp\n                    vec3 new_reach = g_arm.seg_length_limits[idx] * ((sin((1.-alpha) * theta)/sinTheta) * nfrom + (sin(alpha * theta)/sinTheta) * nto);                        \n\t\t\t\t\tnew_pt = g_arm.pts[idx+1] + new_reach;\n                }\n                \n                g_arm.pts[idx] = new_pt;\n                \n            }\n            \n            g_arm.pts[0] = base_pt;\n            \n            // BACK REACHING ITERATION            \n            for (int idx = 0; idx < NUM_PTS-1; idx++)\n            {\n                vec3 seg = g_arm.pts[idx] - g_arm.pts[idx+1];\n                float seg_length = length(seg);\n                vec3 new_pt = g_arm.pts[idx+1] + seg * (1. - (g_arm.seg_length_limits[idx]/seg_length));\n\n                vec3 from = vec3(0., 1., 0.);\n                if (idx >= 1)\n                {\n\t                from = g_arm.pts[idx] - g_arm.pts[idx-1];\n                }\n                \n                vec3 to = new_pt - g_arm.pts[idx];                                                                                            \n\n                vec3 nfrom = normalize(from);\n                vec3 nto = normalize(to);\n\n                float theta = max(SMALL_FLOAT, acos(dot(nfrom, nto)));\n                \n                // constraint of the joints\n                float alpha = min(1., g_arm.seg_angle_limits[idx]/theta);\n\n                float sinTheta = sin(theta);\n                // slerp\n                vec3 new_reach = g_arm.seg_length_limits[idx] * ((sin((1.-alpha) * theta)/sinTheta) * nfrom + (sin(alpha * theta)/sinTheta) * nto);                        \n                new_pt = g_arm.pts[idx] + new_reach;\n\n                \n                g_arm.pts[idx+1] = new_pt;\n            }\n\t\t\t\n                \n            dist_to_target = length(resolve_target_pt - g_arm.pts[NUM_PTS-1]);\n        }\n    }    \n}\n\n// **************************************************************************\n// MAIN\n\n\nfloat inPixelRange(vec2 value, vec2 bottom, vec2 top)\n{\n    return step(value.x, top.x) * step(bottom.x, value.x) * step(value.y, top.y) * step(bottom.y, value.y);    \n}\n\nfloat inPixel(vec2 value, vec2 pixel)\n{\n    return inPixelRange(value, pixel, pixel + vec2(1.));\n}\n\nbool saveState(vec2 fragCoord, \n               vec2 stateCoord, \n               in vec4 stateValue, \n               inout vec4 fragColor)\n{\n    \n    if (inPixel(fragCoord, stateCoord) > .0)\n    {\n        fragColor = stateValue;\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    if (inPixelRange(fragCoord + vec2(.5), vec2(0., 0.), vec2(1., NUM_PTS)) < .5)\n\t{\n        discard;\n    }            \n    \n    setupGlobals();\n\n    // ----------------------------------------------------------------------\n    // FABRIK SOLVE\n    \n    vec3 target = vec3(0.);\n    \n    vec2 mouseTarget = iMouse.xy;\n    if (mouseTarget.x + mouseTarget.y < 10.)        \n    {\n        target = vec3(1., -.3, 0.);\n        \n        float beat_rate = 7.42;\n        target += 1.5 * vec3(0.,\n                       \t\t1. * sin(beat_rate * g_time),\n\t                        .3 * cos(beat_rate * g_time) + 1.8 * cos(.05 * beat_rate * g_time + PI_OVER_TWO));\n            \n    }\n    else\n    {\n        CameraData pickCam = setupCamera( mouseTarget );\n        vec3 cdir = normalize(g_camOrigin - g_camPointAt);\n        vec2 p = intersect_plane(pickCam.origin, pickCam.dir, cdir, g_camOrigin - 5.6 * cdir);\n        if (p.x > .5)\n        {\n            target = pickCam.origin + pickCam.dir * p.y;\n        }\n    }\n    \n    solveFABRIK(target);\n    \n    fragColor = vec4(0.0);\n    \n    for (int i = 0; i < NUM_PTS; i++)\n    {\n    \tsaveState(fragCoord, vec2(0., float(i)) + .5, vec4(g_arm.pts[i], 1.), fragColor); \n    }\n\n}\n","name":"Buf A","description":"","type":"buffer"}]}