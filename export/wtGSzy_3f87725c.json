{"ver":"0.1","info":{"id":"wtGSzy","date":"1583749797","viewed":112,"name":"Raymarch Test  (Nicks108)","username":"Nicks108","description":"Ray march test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nfloat start = 0.0;\nvec3 eye = vec3(0,0,5);\nint MAX_MARCHING_STEPS = 255;\nfloat EPSILON = 0.000001;\nfloat end = 100.0;\n\n\nconst uint Shpere = 1u;\nconst uint Box = 2u;\nconst uint Plane = 4u;\n\n\n\nvec3 lightPos = vec3(0,0,2);\n//vec3 lightPos = vec3(-10,0,5);\n#define M_PI 3.1415926535897932384626433832795\nconst int SDF_OBJECT_COUNT = 4;\n\nstruct SDFObject\n{\n    uint Shape;\n    vec3 Position;\n\tfloat Radius;\n    int  texChannelID;\n    float Ambiant;\n    float Spec;\n    float Diff;\n    vec3 BoxSize;\n    bool isMirror; //quick hack to get refletions working\n    \n};\nSDFObject SDFObjects[SDF_OBJECT_COUNT] = SDFObject[SDF_OBJECT_COUNT](    \n    \tSDFObject(Shpere, vec3(2,0,-3),1.0,0,0.2,0.2,0.8, vec3(0,0,0),true)\n        ,SDFObject(Shpere, vec3(-2,0,-3),1.0,0,0.1,1.0,1.0, vec3(0,0,0),false)\n    \t,SDFObject(Box, vec3(0,0,-6),0.0,1,0.2,0.2,0.8, vec3(1.0,0.5,0.5),false)\n    \t,SDFObject(Plane, vec3(0,0,0),1.0,1,0.2,0.2,0.8, vec3(0.0,1.0,0.0),false)\n        );\n    \nfloat shereSDF(vec3 p, SDFObject o)\n{\n    return length(p-o.Position)-o.Radius;\n}\nfloat boxSDF(vec3 pointToTest, vec3 boxBoundery, float radius, vec3 boxPos)\n{\n    vec3 q = abs(pointToTest - boxPos) - boxBoundery;\n    return length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)) ,0.0) -radius;\n}\nfloat planeSDF(vec3 p, vec4 n, vec3 Pos)\n{\n    return dot(p-Pos, n.xyz) + n.w;\n}\n\n\n\n\n\nbool IsShadow(vec3 LightPos, vec3 HitPos)\n{\n    bool isShadow = false;\n\n    \n    vec3 viewRayDirection = normalize(lightPos- HitPos) ;       \n    \n    float depth = start+0.1;\n    \n    vec3 hitpoint;\n    \n    for(int i=0; i<MAX_MARCHING_STEPS; i++)\n    {\n        hitpoint = (HitPos+  depth * viewRayDirection);\n        //hitpoint += viewRayDirection*EPSILON;       \n        \n        float dist = end;\n        \n        for(int j =0; j<SDF_OBJECT_COUNT; j++)\n        {\n            float distToObjectBeingConsidered;\n             if(SDFObjects[j].Shape == Shpere)\n            \tdistToObjectBeingConsidered = shereSDF(hitpoint, SDFObjects[j]);\n            if(SDFObjects[j].Shape == Box)\n                distToObjectBeingConsidered = boxSDF(hitpoint, SDFObjects[j].BoxSize , SDFObjects[j].Radius, SDFObjects[j].Position);\n            if(SDFObjects[j].Shape == Plane)\n                distToObjectBeingConsidered= planeSDF(hitpoint, vec4(SDFObjects[j].BoxSize, SDFObjects[j].Radius), SDFObjects[j].Position);\n                \n        \tif( distToObjectBeingConsidered < dist)\n            {\n               dist = distToObjectBeingConsidered;\n            }\n        }\n        \n        if(dist < EPSILON)\n        {\n            isShadow = true;\n        }\n        \n        \n        depth += dist;\n        \n        if(depth >= end)\n       \t{\n           isShadow = false;\n        } \n        \n    }\n        \n    return isShadow;\n}\n\n\nvec3 MirrorReflection(vec3 inCommingRay, vec3 surfNormal, vec3 HitPos, int objectIndexToIgnore)\n{\n    vec3 returnCol;\n    \n    vec3 reflectedRay = reflect(inCommingRay, surfNormal);\n    \n    \n    \n    vec3 RayDirection = normalize(reflectedRay) ;       \n    \n    float depth = start;\n    \n    SDFObject SDFObjectToDraw;\n    vec3 hitpoint;\n    int i;\n    for(i=0; i<MAX_MARCHING_STEPS; i++)\n    {\n        hitpoint = (HitPos+  depth * RayDirection);\n        \n        \n        float dist = end;\n        \n        for(int j =0; j<SDF_OBJECT_COUNT; j++)\n        {\n            float distToObjectBeingConsidered;\n             if(SDFObjects[j].Shape == Shpere)\n            \tdistToObjectBeingConsidered = shereSDF(hitpoint, SDFObjects[j]);\n            if(SDFObjects[j].Shape == Box)\n                distToObjectBeingConsidered = boxSDF(hitpoint, SDFObjects[j].BoxSize , SDFObjects[j].Radius, SDFObjects[j].Position);\n            if(SDFObjects[j].Shape == Plane)\n                distToObjectBeingConsidered= planeSDF(hitpoint, vec4(SDFObjects[j].BoxSize, SDFObjects[j].Radius), SDFObjects[j].Position);\n                \n            \n           if( distToObjectBeingConsidered < dist && j!= objectIndexToIgnore )// D > 0.0)\n            {\n               dist = distToObjectBeingConsidered;\n               SDFObjectToDraw = SDFObjects[j];\n            }\n        }\n        \n        if(dist < EPSILON)\n        {\n            \n            break;\n        }\n        \n        \n        depth += dist;\n        \n        if(depth >= end)\n       \t{\n            //should look up bg texture here but cant be assed right now\n           return returnCol = vec3(1.0,0.0,0.0);\n           \n        } \n        \n    }\n    \n    vec3 normal =normalize(hitpoint-SDFObjectToDraw.Position);\n            float u = 0.5+ (atan(normal.z, normal.x)/(2.0*M_PI));\n            float v = 0.5+ (asin(normal.y)/(M_PI));\n            \n            vec2 uv =vec2(u,v);            \n            vec4 col = vec4(0,0.5,0.5,0);\n\n            \n\t    \n            if(SDFObjectToDraw.texChannelID == 0)\n                col = texture(iChannel0, uv);\n            if(SDFObjectToDraw.texChannelID == 1)\n               \tcol = texture(iChannel1, uv);\n            \n            \n            vec3 NormalizedDirToLight = normalize(lightPos-SDFObjectToDraw.Position);\n            float theta = dot(normal,NormalizedDirToLight);\n            \n            \n            vec3 reflectionOfLight = reflect(NormalizedDirToLight, normal);\n            vec3 viewDir = normalize(SDFObjectToDraw.Position);\n            float Spec = dot(reflectionOfLight,  viewDir);\n            \n            \n\t\t\tif(IsShadow(lightPos, hitpoint))\n            {\n           \t\treturnCol= (col.xyz*SDFObjectToDraw.Ambiant);\n            }\n            else\n            {\n            \treturnCol= (col.xyz*SDFObjectToDraw.Ambiant) \n                +(col.xyz * max(theta *SDFObjectToDraw.Diff, SDFObjectToDraw.Ambiant));\n            }\n    \n    return returnCol;\n}\n\n\nvec3 rayMarch(vec2 fragCoord)\n{\n    vec3 viewRayDirection = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    float depth = start;\n    \n    vec3 hitpoint;\n    \n    vec3 ReturnColour = vec3(0,0,0);\n    \n    SDFObject SDFObjectToDraw;\n    int objectInDexToIgnore=-1;\n    \n    for(int i=0; i<MAX_MARCHING_STEPS; i++)\n    {\n        hitpoint = (eye+  depth * viewRayDirection);\n        \n        float dist = end;\n        \n        \n        \n        //find closest objecct to current point\n        for(int j =0; j<SDF_OBJECT_COUNT; j++)\n        {\n            float distToObjectBeingConsidered;\n            \n            if(SDFObjects[j].Shape == Shpere)\n            \tdistToObjectBeingConsidered = shereSDF(hitpoint, SDFObjects[j]);\n            if(SDFObjects[j].Shape == Box)\n                distToObjectBeingConsidered = boxSDF(hitpoint, SDFObjects[j].BoxSize , SDFObjects[j].Radius, SDFObjects[j].Position);\n            if(SDFObjects[j].Shape == Plane)\n                distToObjectBeingConsidered= planeSDF(hitpoint, vec4(SDFObjects[j].BoxSize, SDFObjects[j].Radius), SDFObjects[j].Position);\n                \n        \tif( distToObjectBeingConsidered < dist)\n            {\n               \tdist = distToObjectBeingConsidered;\n               \tSDFObjectToDraw = SDFObjects[j];\n                objectInDexToIgnore = j;\n            }\n        }\n        \n        \n        //if we are close enough to an objectoto hit it.\n        if(dist < EPSILON)\n        {\n             break;\n        }\n        \n        \n        depth += dist;\n        \n        if(depth >= end)\n       \t{\n            float u = fragCoord.x/ iResolution.x;\n            float v =  fragCoord.y/ iResolution.y;\n            vec4 col = texture(iChannel2, vec2(u,v));\n           \treturn ReturnColour =col.xyz;\n        } \n        \n    }\n    \n    \n    vec3 normal =normalize(hitpoint-SDFObjectToDraw.Position);\n            if(SDFObjectToDraw.isMirror)\n            {\n                ReturnColour = MirrorReflection( viewRayDirection, normal, hitpoint, objectInDexToIgnore);\n            }\n            else\n            {\n            \t\n            \tfloat u = 0.5+ (atan(normal.z, normal.x)/(2.0*M_PI));\n            \tfloat v = 0.5+ (asin(normal.y)/(M_PI));\n            \n            \tvec2 uv =vec2(u,v);            \n            \tvec4 col;\n            \n            \tif(SDFObjectToDraw.texChannelID == 0)\n                \tcol = texture(iChannel0, uv);\n            \tif(SDFObjectToDraw.texChannelID == 1)\n                \tcol = texture(iChannel1, uv);\n            \n            \n            \tvec3 NormalizedDirToLight = normalize(lightPos-SDFObjectToDraw.Position);\n            \tfloat theta = dot(normal,NormalizedDirToLight);\n            \n            \n            \tvec3 reflectionOfLight = reflect(NormalizedDirToLight, normal);\n            \tvec3 viewDir = normalize(SDFObjectToDraw.Position);\n            \tfloat Spec = dot(reflectionOfLight,  viewDir);\n            \n            \n            \tif( IsShadow(lightPos, hitpoint))\n            \t{\n           \t\t\tReturnColour= (col.xyz*SDFObjectToDraw.Ambiant);\n            \t}\n            \telse\n            \t{\n           \t\t\tReturnColour= (col.xyz*SDFObjectToDraw.Ambiant) \n                \t+(col.xyz * max(theta *SDFObjectToDraw.Diff, SDFObjectToDraw.Ambiant));\n                \t//+(col.xyz* Spec * SDFObjectToDraw.Spec);\n            \t}\n            }\n    \n    \n    \n    return ReturnColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    \n    lightPos += cos(iTime)/2.0*vec3(0,2,0);\n    \n    //lightPos= vec3(cos(iTime)*2.0,0,0);\n    \n    vec3 SDFCol= rayMarch(fragCoord);\n    vec3 col = vec3(0);\n    \n    //if(SDFVal <=1.0)\n      //  col = vec3(1,0,0);\n        \n    //col = vec3(SDFVal,0,0);\n    \n    col = vec3(0.5,0,0);\n    col =  SDFCol;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}