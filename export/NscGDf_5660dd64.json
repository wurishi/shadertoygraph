{"ver":"0.1","info":{"id":"NscGDf","date":"1630710737","viewed":1531,"name":"4 Common Blur Shaders","username":"Xor","description":"Here's a little example of 4 common blur algorithms\nOn the top, Linear and Angular.\nOn the bottom, Radial and Box.","likes":29,"published":1,"flags":32,"usePreview":1,"tags":["example","blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Here's a quick demo for 4 common blur shaders:\n    ____________________\n    |         |         |\n    | Linear  | Angular |\n    |_________|_________|\n    |         |         |\n    | Radial  |  Box    |\n    |_________|_________|\n    \n    Feel free to skim through the examples and comments.\n    Hopefully you'll find something interesting here!\n*/\n\n//Try more samples if your machine can handle it\n#if HW_PERFORMANCE==0\n#define SAMPLES 50.0\n#else\n#define SAMPLES 200.0\n#endif\n\n/*\n    Linear or motion blur:\n    \n    This is the simplest blur that blurs along a straight line.\n    Just sample the texture periodically along the line and average the total.\n    Ideally you want one sample per pixel across the line.\n    Extra samples is slower with little benefit and too few may cause gaps between samples.\n    Finding a balance between performance and quality is key.\n\n    The linear blur can also be used in multiple blur passes for box blurs (example below).\n    For example, you can blur horizontally, then blur that result with a vertical blur.\n    A one-pass box blur requires x*x samples whereas a two-pass box blur only needs 2*x!\n*/\nvec4 blur_linear(sampler2D tex, vec2 texel, vec2 uv, vec2 line)\n{\n    vec4 total = vec4(0);\n    \n    float dist = 1.0/SAMPLES;\n    for(float i = -0.5; i<=0.5; i+=dist)\n    {\n        vec2 coord = uv+i*line*texel;\n        total += texture(tex,coord);\n    }\n    \n    return total * dist;\n}\n\n/*\n    Radial or zoom blur:\n\n    This works by sampling the texture at different scales and averaging the results.\n    You can scale the coordinates relative to any point (in this case 0.5).\n    \n    Here we are zooming in, but you theoretically can zoom out as well.\n    Zooming out requires sampling outside the visible block so you'll need to handle this.\n    If the texture repeats, that is easy, but otherwise you can fade to black.\n*/\nvec4 blur_radial(sampler2D tex, vec2 texel, vec2 uv, float radius)\n{\n    vec4 total = vec4(0);\n    \n    float dist = 1.0/SAMPLES;\n    float rad = radius * length(texel);\n    for(float i = 0.0; i<=1.0; i+=dist)\n    {\n        vec2 coord = (uv-0.5) / (1.0+rad*i)+0.5;\n        total += texture(tex,coord);\n    }\n    \n    return total * dist;\n}\n\n/*\n    \"Angular\" or spin blur:\n\n    Instead of scaling the coordinates, what if you rotated?\n    This is how you get an angular blur.\n    Every texel is rotated around a point (e.g. vec2(0.5)) and then averaged.\n    \n    No need to do fancy trigonometry inside the for loop!\n    You can just calculate the rotation matrix once and repeat it as necessary.\n    Ideally you should compute the trigonometry outside the shader and pass it in a uniform.\n*/\nvec4 blur_angular(sampler2D tex, vec2 texel, vec2 uv, float angle)\n{\n    vec4 total = vec4(0);\n    vec2 coord = uv-0.5;\n    \n    float dist = 1.0/SAMPLES;\n    vec2 dir = vec2(cos(angle*dist),sin(angle*dist));\n    mat2 rot = mat2(dir.xy,-dir.y,dir.x);\n    for(float i = 0.0; i<=1.0; i+=dist)\n    {\n        total += texture(tex,coord+0.5);\n        coord *= rot;\n    }\n    \n    return total * dist;\n}\n\n/*\n    A classic box blur:\n    \n    This is like the linear blur except across both axes.\n    Only use this if you have to do so in one-pass!\n    As I said above, the two-pass linear blur is much faster.\n\n    I only use this in rare cases just for testing, but it lags on most devices.\n*/\nvec4 blur_box(sampler2D tex, vec2 texel, vec2 uv, vec2 rect)\n{\n    vec4 total = vec4(0);\n    \n    float dist = inversesqrt(SAMPLES);\n    for(float i = -0.5; i<=0.5; i+=dist)\n    for(float j = -0.5; j<=0.5; j+=dist)\n    {\n        vec2 coord = uv+vec2(i,j)*rect*texel;\n        total += texture(tex,coord);\n    }\n    \n    return total * dist * dist;\n}\n\n/*\n    Note: All of these examples have equal sample weight.\n    You can quite easily adapt these functions to use a weighted blur like so:\n\n    total_weight = 0.0;\n    for()\n    {\n        total += sample * weight;\n        total_weight += weight;\n    }\n\n    return total/total_weight;\n\n    This is how proper Gaussain blurs are done with a weight formula like this:\n\n    weight = exp(-i*i * falloff);\n\n*/\n\n\n//Render the 4 examples:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 texel = 1./iResolution.xy;\n    vec2 coord = fragCoord*texel*2.;\n    vec2 uv = fract(coord);\n    \n    vec4 col = vec4(0);\n    \n    //Divide the map into quadrants:\n    if (coord.x<1.)\n    {\n        if (coord.y<1.) //Radial:\n        {\n            float radius = 160.0+120.0*sin(iTime*0.4);\n            col = blur_radial(iChannel0,texel,uv,radius);\n        }\n        else            //Linear:\n        {\n            vec2 line = vec2(100,50.0*sin(iTime*0.2));\n            col = blur_linear(iChannel0,texel,uv,line);\n        }\n    }\n    else\n    {\n        if (coord.y<1.) //Box:\n        {\n            vec2 rect = vec2(70,30) + vec2(-20,20)*cos(iTime*0.8);\n            col = blur_box(iChannel0,texel,uv,rect);\n        }\n        else            //Angular:\n        {\n            float angle =0.2+0.1*cos(iTime*0.4);\n            col = blur_angular(iChannel0,texel,uv,angle);\n        }\n    }\n    \n    //Add in divider lines:\n    vec2 divider = min(abs(fragCoord-0.5/texel)*0.5-0.2,1.0);\n    col *= min(divider.x, divider.y);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Just a bunch of colorful balls for blur testing.\n*/\n\n//Animated position and radius:\nvec3 pos(vec2 i)\n{\n    float t = iTime*.5;\n    float f = fract(t);\n    t -= f;\n    \n    vec2 o = vec2(7,3);\n    vec3 p0 = texture(iChannel0,(i+(t+0.)*o)/256.).gba;\n    vec3 p1 = texture(iChannel0,(i+(t+1.)*o)/256.).gba;\n    vec3 p2 = texture(iChannel0,(i+(t+2.)*o)/256.).gba;\n    vec3 p3 = texture(iChannel0,(i+(t+3.)*o)/256.).gba;\n    \n    vec3 p = p3+p1 - p2-p0;\n    vec3 s = p*(f*f*f) + ((p0 - p1) - p)*(f*f) + (p2 - p0)*f + p1;\n    s.z = s.z*.5+.1;\n    return s;\n}\n//Random colors:\nvec3 color(vec2 i)\n{\n    vec3 col = texture(iChannel0,i/256.).rgb;\n    float m = min(col.r,min(col.g,col.b));\n    float M = max(col.r,max(col.g,col.b));\n    col = smoothstep(m*.5,M,col);\n    return col*col;\n}\n//Voronoi balls:\nvec4 balls(vec2 p, float s)\n{\n    p /= s;\n    vec2 f = floor(p);\n    vec2 c = f;\n    \n    vec2 i = f;\n    float d = 2.;\n    \n    for(int x = -1; x<=1; x++)\n    for(int y = -1; y<=1; y++)\n    {\n        vec2 c = f+vec2(x,y);\n        vec3 cir = pos(c);\n        vec2 o = cir.xy+c-p;\n        float t = length(o)-cir.z;\n        if (t<d)\n        {\n            d = t;\n            i = c;\n        }\n    }\n    \n    return vec4(color(i),clamp(-.5*d*s,0.,1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float zoom = .2-.1/(1.+iTime);\n    \n    vec2 texel = 1./iResolution.xy;\n    vec2 uv = fragCoord*texel;\n    \n    vec2 gradient = vec2(uv.x*2.+uv.y*3.+.5*iTime);\n    vec4 back = vec4(color(gradient)*.2,1);\n    vec4 ball = balls(fragCoord-.5/texel,zoom/texel.y);\n    fragColor = back+(ball-back)*ball.a;\n}","name":"Buffer A","description":"","type":"buffer"}]}