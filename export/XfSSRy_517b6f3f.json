{"ver":"0.1","info":{"id":"XfSSRy","date":"1706460169","viewed":247,"name":"TerrainShadows","username":"StormCreeper","description":"Simple 2D terrain generation with shadow casting\nA little experiment on shadow casting for 2D terrain, based on [url=https://www.youtube.com/watch?v=bMTeCqNkId8]this[/url] video I saw . The water is just a bonus hahaha","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","noise","terrain","shadows","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 computeUv(vec2 frag) {\n    vec2 uv = frag/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv /= 1.5;\n    \n    uv = uv * 0.5 + 0.5;\n    \n    return uv;\n}\n\nvec3 computeWaterNormal(vec2 frag) {\n    float epsilon = 1.; // Small epsilon value for finite differences\n    \n    // Sample height values at neighboring points\n    float h  = texture(iChannel1, computeUv(frag + vec2(0.0    , 0.0))).a;\n    float hR = texture(iChannel1, computeUv(frag + vec2(epsilon, 0.0))).a;\n    float hU = texture(iChannel1, computeUv(frag + vec2(0.0, epsilon))).a;\n    \n    // Compute partial derivatives in x and y directions\n    float scale = 100.;\n    vec3 dx = normalize(vec3(epsilon, 0.0, (hR - h) * scale));\n    vec3 dy = normalize(vec3(0.0, epsilon, (hU - h) * scale));\n    \n    // Compute the normal using the cross product of the partial derivatives\n    vec3 normal = normalize(cross(dx, dy));\n    \n    return normal.xyz;\n    //return vec3(0, 0, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = computeUv(fragCoord);\n    \n    vec4 data = texture(iChannel0, uv);\n    vec3 color = data.rgb;\n    float height = data.a;\n    \n    // Lighting\n    \n    vec3 lightPos = vec3(iMouse.xy, 2.);\n    \n    vec3 pos = vec3(fragCoord.xy, height);\n    \n    vec3 dir = normalize(lightPos - pos);\n    \n    int numSteps = 50;\n    float stepSize = length(lightPos - pos) / float(numSteps);\n    \n    bool shadow = false;\n    for(int i = 0; i<numSteps; i++) {\n        pos += dir * stepSize;\n        vec4 dataS = texture(iChannel0, computeUv(pos.xy));\n        //color = color * 0.95 + dataS.rgb * 0.05;\n        if(dataS.a > pos.z) {\n            shadow = true;\n            break;\n        }\n    }\n    float waterHeight = 0.;\n    float specular = 0.;\n    if(height <= 0.1) {\n        waterHeight = height * 10.;\n        \n        vec3 normal = computeWaterNormal(fragCoord);\n        \n        float diffuse = max(dot(normal, dir), 0.0) * 0.3 + 0.7;\n        color *= diffuse;\n        \n        vec3 viewDir = normalize(vec3(0., 0., 1.0));\n        vec3 reflectDir = reflect(-dir, normal);\n\n        specular = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    }\n    \n    color += 0.5 * waterHeight*waterHeight * pow(sin(waterHeight * 20. - iTime*2.) * 0.5 + 0.5, 3.0);\n    if(shadow) color *= 0.5;\n    else color += specular;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.1415926535;\n\nconst float offset = 0.;\n\nfloat gauss(float x) {\n    return 1./(0.4*sqrt(2.*PI))*exp(-x*x/0.18);\n}\n\nfloat noise(vec2 uv) {\n    return texture(iChannel1, uv).r * 2. - 1. + texture(iChannel1, uv + iTime * 0.00).g;\n}\n\nfloat sampleHeight(vec2 uv) {\n    int octaves = 8;\n    float freq = 0.1;\n    float amp = 0.5;\n    float height = 0.;\n    for(int i=0; i<octaves; i++) {\n        height +=  noise(uv * freq) * amp;\n        freq *= 2.0;\n        amp /= 2.0;\n    }\n    height = height * gauss(length(uv)) + offset;\n    height = max(height, 0.);\n    return (1. - exp(-height)) / 0.7;\n}\n\nvec3 colorRamp(float height) {\n    if(height < 0.1) return vec3(0.2, 0.4, 0.7);\n    if(height < 0.2) return vec3(0.7, 0.6, 0.4);\n    if(height < 0.3) return vec3(0.2, 0.6, 0.1);\n    if(height < 0.5) return vec3(0.2, 0.5, 0.1);\n    if(height < 0.9) return vec3(0.2, 0.4, 0.1);\n    return vec3(0.9, 0.9, 0.9);\n}\n\nconst float res = 100.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    //uv = vec2(ivec2(uv * res)) / res; \n    float height = sampleHeight(uv);\n    if(height < 0.0) height = 0.0;\n    float waterHeight = 0.;\n    \n    vec3 col = colorRamp(height);\n    col = (col + 0.5) * col;\n    fragColor = vec4(col,height);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Water height\nconst float PI = 3.1415926535;\n\nfloat gauss(float x) {\n    return 1./(0.4*sqrt(2.*PI))*exp(-x*x/0.18);\n}\n\nfloat noise(vec2 uv) {\n    return (texture(iChannel0, uv).r + texture(iChannel0, uv + iTime * 0.02).g) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    \n    int octaves = 8;\n    float freq = 0.1;\n    float amp = 0.5;\n    float height = 0.;\n    for(int i=0; i<octaves; i++) {\n        height +=  noise(uv * freq) * amp;\n        freq *= 2.0;\n        amp /= 2.0;\n    }\n    \n    //height *= (1.-gauss(length(uv*0.5)));\n\n    fragColor = vec4(0.0,0.0,1.0,height);\n}","name":"Buffer B","description":"","type":"buffer"}]}