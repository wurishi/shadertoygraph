{"ver":"0.1","info":{"id":"Ml2BRD","date":"1514920434","viewed":540,"name":"Spot White Balance using LMS","username":"Tynach","description":"This shader lets you click on a particular pixel and use its color to calculate the gray/white point.\n\nIt calculates the CIE 1931 xy chromaticities for the color, then converts the picture to LMS before performing white balance.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color","rgb","xyz","colorspaces","white","point","colorspace","whitepoint","lms","spaces","balance","whitebalance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n\nstruct transfer {\n\tfloat power;\n\tfloat off;\n\tfloat slope;\n\tfloat cutoffToLinear;\n\tfloat cutoffToGamma;\n\tbool tvRange;\n};\n\nstruct rgb_space {\n\tmat3 primaries;\n\tvec3 white;\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define \\\nprimaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define \\\nwhite(x, y)\\\n\tvec3((x)/y, 1, (1.0 - (x) - (y))/(y))\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define \\\ndiag(v)\\\n\tmat3(\\\n\t\tv.x, 0.0, 0.0,\\\n\t\t0.0, v.y, 0.0,\\\n\t\t0.0, 0.0, v.z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define \\\nrgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*(space.white/space.white.y)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define \\\nxyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define \\\nconversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\nconst mat3 primaries709 = primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\nconst vec3 whiteE = vec3(1.0/3.0);\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0, false);\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, false);\n\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n// Radius for the color sampling; keep low for your GPU's sake!\nconst int r = 0;\n\n// Change this to decide what colorspace the original image uses\nconst rgb_space space = Srgb;\n\nconst mat3 toLms = xyzToRgb(LmsRgb);\n\n\nvec4 toLinear(vec4 color, transfer trc)\n{\n\tif (trc.tvRange) {\n\t\tcolor = color*85.0/73.0 - 16.0/219.0;\n\t}\n\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\nvec4 toGamma(vec4 color, transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\tif (trc.tvRange) {\n\t\tcolor = color*73.0/85.0 + 16.0/255.0;\n\t}\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts from one RGB colorspace to another, output as linear light\nvec4 convert(vec4 color, rgb_space space, vec3 whiteNew)\n{\n\t//const mat3 lmsMat = HUNT;\n\n\t// Normalize the LMS matrix to the white point\n\t//mat3 toLms = inverse(diag((lmsMat*space.white)))*lmsMat;\n\n\t// Or not\n\t//const mat3 toLms = lmsMat;\n\n\tcolor.xyz = rgbToXyz(space)*color.rgb;\n\n\tcolor.rgb = toLms*color.xyz;\n\tcolor.rgb = diag(((toLms*space.white)/(toLms*whiteNew)))*color.rgb;\n\tcolor.xyz = inverse(toLms)*color.rgb;\n\t//color.xyz *= luma/color.y;\n\tfloat luma = color.y;\n\n\tcolor.rgb = xyzToRgb(space)*color.rgb;\n\tcolor = gamutScale(color, luma);\n\n\treturn color;\n}\n\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n\tvec2 mouseCoord = vec2(0.0);\n\tvec3 whiteNew = vec3(0.0);\n\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texCoord = fragCoord;\n\tfloat scale = texRes.x/iResolution.x;\n\n\ttexCoord *= scale;\n\n\tfor (int i = -r; i <= r; ++i) {\n\t\tfor (int j = -r; j <= r; ++j) {\n\t\t\tmouseCoord = (iMouse.xy*scale + vec2(i, j));\n\t\t\twhiteNew += toLinear(texture(iChannel0, mouseCoord/texRes), space.trc).rgb;\n\t\t}\n\t}\n\n\twhiteNew /= float((r*2+1)*(r*2+1));\n\n\twhiteNew = rgbToXyz(space)*whiteNew;\n\twhiteNew /= dot(whiteNew, vec3(1.0));\n\twhiteNew /= whiteNew.y;\n\n\t// Uncomment this portion (remove the '/*' and '*/') for half of the\n\t// image to remain untouched\n\t/*bool left = bool(int(texCoord.x*2.0));\n\n\tif (!left) {\n\t\tfrom = Srgb;\n\t\tto = from;\n\t}*/\n\n\tcolor = texture(iChannel0, texCoord/texRes);\n\tcolor = toLinear(color, space.trc);\n\tcolor = convert(color, space, whiteNew);\n\tcolor = toGamma(color, space.trc);\n}","name":"Image","description":"","type":"image"}]}