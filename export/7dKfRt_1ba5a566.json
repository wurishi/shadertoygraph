{"ver":"0.1","info":{"id":"7dKfRt","date":"1658731915","viewed":112,"name":"C++ 3d","username":"Behzod","description":"cpp lang 3d","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cpp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\n// Rotate around a circular path\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdHexPrism( vec3 p, vec3 off, vec3 col, vec2 h, mat3 transform)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p -= off;\n  p *= transform;\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  float sd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return Surface(sd, col);\n}\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  \n  mat3 rotpid2 = rotateX(PI/2.);\n  \n  co = minWithColor(co, sdBox(p, vec3(1, 1, 3)/3., vec3(-4, 0.5, 0)/3., vec3(1, 1, 0), rotpid2)); // left cube\n  co = minWithColor(co, sdBox(p, vec3(3, 1, 1)/3., vec3(-4, 0.5, 0)/3., vec3(1, 1, 0), rotpid2)); // left cube\n  \n  co = minWithColor(co, sdBox(p, vec3(1, 1, 3)/3., vec3(4, 0.5, 0)/3., vec3(1, 1, 0), rotpid2)); // left cube\n  co = minWithColor(co, sdBox(p, vec3(3, 1, 1)/3., vec3(4, 0.5, 0)/3., vec3(1, 1, 0), rotpid2)); // left cube\n  \n  /* center of */\n  //co = minWithColor(co, sdHexPrism(p - vec3(0, 2, 0), vec3(vec2(0), 0)/1.47, vec3(1, 0, 1), vec2(1, 1)/3., identity() )); // left cube\n  \n  for(float s=-PI/12.; s < 2.*PI - PI/2.; s+=PI/6.){\n  vec3 top = vec3( 0,  1, 0);\n  top = top * rotateZ(s);\n      co = minWithColor(co, sdHexPrism(p - vec3(0, 2, 0), top/1.47, vec3(1, 0, 0), vec2(1, 1)/3., rotateZ(s) )); // left cube\n  }\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0.5, -4); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 5, 0); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI/2., 0., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(1, -.9, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}