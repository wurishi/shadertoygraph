{"ver":"0.1","info":{"id":"Mcs3Wr","date":"1703407597","viewed":47,"name":"3 poisson solvers","username":"celifan","description":"Click to toogle 1d visualization.\n3 methods for solving  ∇u=-4  on [0,1] with boundary conditions u[-1]=0 & u[1]=0\n- jacobi. (top ) slow convergence\n- walk on sphere. (middle)\n- harmonic green function convolution. (bottom)\n\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["poisson","laplace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float _pixSize ;\n// default colors \nconst vec3 _co = vec3( .9,0.3,0.0); // orange \nconst vec3 _cb = vec3(0.0,0.36,1.0); // blue\n\n\nfloat offsetByIdx(float idx)\n{\n    return (iResolution.y*(idx*1.0/3.0 + 1.0/6.0)); \n}\nbool isRange(vec2 fragCoord, float idx)\n{\n   return fragCoord.y > iResolution.y*(idx*1.0/3.0) &&\n          fragCoord.y < iResolution.y*((idx+1.0)*1.0/3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float _1d  = texelFetch(iChannel0,ivec2(0,0),0).x;\n    \n    if (_1d !=0.0)\n    {\n        vec2 c = vec2(iResolution.x/2.0,0.0);\n        // sample range with idx = 2\n        // Jacobi method\n        // blue\n        vec2 pCoord = vec2( fragCoord.x, offsetByIdx(2.0));\n        float H = texelFetch(iChannel0,ivec2(pCoord),0).y;\n        float ar = iResolution.x/iResolution.y;\n        vec2 vx = (fragCoord/iResolution.y)*vec2(2.0,2.0)-vec2(ar,0.0);\n        float fh =smoothstep(0.0, 0.01, abs(vx.y-H));\n\n        // sample range with idx = 1 \n        // WOS method\n        pCoord = vec2( fragCoord.x, offsetByIdx(1.0));\n        vec4 v = texelFetch(iChannel0,ivec2(pCoord),0);\n        H = (v.y/(v.w));\n        float fhwos =smoothstep(0.0, 0.01, abs(vx.y-H));\n\n        // sample range with idx = 0 \n        // green function convolution\n        pCoord = vec2( fragCoord.x, offsetByIdx(0.0));\n        v = texelFetch(iChannel0,ivec2(pCoord),0);\n        float fhgreen =smoothstep(0.0, 0.01, abs(vx.y-v.y));\n\n        // exact solution \n        // black\n        float fx =( 2.0-2.0*vx.x*vx.x); //[0,2]\n        float dxx = abs(fx - vx.y);\n        float fxx = smoothstep(0.0,.01, dxx);\n\n        //\n        vec3 bk = vec3(.9);\n        vec3 O = mix(bk, vec3(0.0,0.0,0.0), 1.0-fhwos);\n        O = mix(O, vec3(1.0,0.0,0.0), 1.0-fhgreen);\n        O = mix(O, vec3(0.0,0.0,1.0), 1.0-fh);\n        //O =O* fxx;\n        fragColor =  vec4(O,1.0);\n    }\n   else\n   {\n        vec4 O = texelFetch(iChannel0,ivec2(fragCoord),0);\n        float l0 = iResolution.y/3.0;\n        O = vec4( mix( _co*2.0,O.xyz, smoothstep(0.0,1.0,abs(l0-fragCoord.y))),O.w);\n        l0 *= 2.0;\n        O = vec4( mix( _co*2.0,O.xyz, smoothstep(0.0,1.0,abs(l0-fragCoord.y))),O.w);\n        fragColor = isRange(fragCoord,1.0) ? vec4(O.xyz/(2.0*O.w),1.0) : O/2.0;\n    \n    }\n     \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//\n// solve laplacian(u(x,y))=-4  with zero boundary condition on [0,1]\n// then compare to analytic solution y = 2-2x^2 on [-1,1] \n\n\n// 1 -> raw green function\n// 2 -> simplified geen function log(1/x) = -log(x)\n// 3 -> use analytic integration of the distribution factorizing the constant \"source term\".\n#define METHOD 3 \n\n\n#define ToCol(x,y,z) (vec3((x+1.0)/2.0, (y+1.0)/2.0,(z+1.0)/2.0))\n#define ToN(v3) (vec3((v3.x*2.0)-1.0, (v3.y*2.0)-1.0,(v3.z*2.0)-1.0))\n\n\nivec2 offset(ivec2 p, ivec2 o, ivec2 bounds)\n{\n    return  ivec2(  o.x, \n                  p.y+o.y < bounds.y ? 0 : o.y);\n} \n\n// from https://www.shadertoy.com/view/wdffWj\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\n\nint randi(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\nfloat rand(void) {\n    return float(randi())/32767.0;\n}\n// --------------------------------------\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomOnCircle(  ) {\n    float theta = 6.28318530 * rand();\n    return vec2(cos(theta), sin(theta));\n}\n\n// https://dl.acm.org/doi/pdf/10.1145/3386569.3392374\n// harmonic Green’s function of the Laplace operator on 𝐵, in 2D\n// straight implementation is producing a non converging result.\nfloat G(float R) {\n    float r = R*(sqrt(rand()+0.0001));\n    return log(R/r)/6.2831853071795;\n}\n// rewrite green function with ln(1/x)=-ln(x)  \nfloat G1()\n{\n    return -log(sqrt(rand()+0.001))/6.28318530;\n}\n\n// WoS\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n    float u=0.0; //solution estimate\n    if (p.x<-1.0 || p.x >1.0) return vec3(0.0);\n\tfor( int i=0; i<32; i++ )\n    {\n        h.x = min(abs(p.x+1.0), abs(p.x-1.0)); // Distance to boundary. \n                                       // The function we are after is zero on boundary.  \n        \n       #if (METHOD == 1)\n           u-= 3.1415926535*h.x*h.x*G(h.x)*-4.0;\n       #elif (METHOD ==2)\n           u-= 3.1415926535*h.x*h.x*G1()*-4.0;\n       #else\n           u+= h.x*h.x; // use the green function probalbility distribution R^2/4\n        #endif\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomOnCircle();\n    }\n    return vec3(u);\n}\n// 1d green function with dirichlet bounary condition 0 on [0,2]\nfloat G1D(float x, float y)\n{\n\n    return  x>=y ?y*(1.0-x/2.0)*2.0\n                 : (1.0-y/2.0)*x*2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set random seed \n    ivec2 q = ivec2(fragCoord);\n    seed = hash(q.x + hash(q.y + hash(iFrame)));\n    //\n    vec2 uv = fragCoord/iResolution.y;\n    float pixSize = 1.0/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    float c = iResolution.y/2.0;\n    if (fragCoord.x<1.0 && fragCoord.y<1.0)\n    {\n        // save mouse state.\n        vec4 mouseState =texelFetch(iChannel0,ivec2(0,0),0);\n        mouseState.x = iMouse.w>0.0 ? mouseState.x ==0.0 ? 1.0 : 0.0 :mouseState.x;\n        mouseState.yz = iMouse.xy;\n        fragColor = mouseState;\n    }\n    else\n    {\n          float ar = iResolution.x/iResolution.y;\n          vec2 v = (fragCoord/iResolution.y)*vec2(2.0,2.0)-vec2(ar,0.0);\n          \n          int method =  int((fragCoord.y/iResolution.y)*3.0);\n          ivec2 bounds;\n          switch(method)\n          {\n              case 0:\n                // 1D green function convolution.\n                if ( v.x>=-1.001  && v.x <= 0.999)\n                {\n                    float u=0.0;\n                    float stepi= ar*2.0/iResolution.y;\n                    for (float i=-1.0; i<1.0; i+=stepi)\n                    {\n                      u+=4.0*G1D(v.x+1.0,i+1.0); \n                    }\n                    u/=2.0/stepi;\n                    fragColor = vec4(vec3(u),1.0);\n                }\n                else \n                fragColor = vec4(vec3(0.0),1.0);\n                break;\n              case 1:\n                 \n                \n                fragColor =texelFetch(iChannel0,ivec2(fragCoord),0);\n                fragColor += vec4(march(v),1.0);\n                \n                break;\n              case 2 :\n             \n                if ( v.x>=-1.001  && v.x <= 0.999)\n                {\n                    for(int i=0;i<512+ min(0,iFrame);++i)\n                    {\n                        bounds =   ivec2(int((iResolution.y+1.0)*2.0/3.0),int(iResolution.y));\n                        // Laplace diffusion.\n                        // jacobi method // slow convergence\n                        float h = 2.0*ar/iResolution.x;\n                        col=texelFetch(iChannel0,ivec2(fragCoord)+ offset(ivec2(fragCoord),ivec2(-1,0),bounds),0).xyz;\n                        col+=texelFetch(iChannel0,ivec2(fragCoord)+offset(ivec2(fragCoord),ivec2(1,0),bounds),0).xyz;\n                        col+=texelFetch(iChannel0,ivec2(fragCoord)+ offset(ivec2(fragCoord),ivec2(0,1),bounds),0).xyz;\n                        col+=texelFetch(iChannel0,ivec2(fragCoord)+ offset(ivec2(fragCoord),ivec2(0,-1),bounds),0).xyz;\n                        col -=h*h*-4.0;\n                        col*=.25;\n                    }\n                 }\n                 else\n                 {\n                     col = vec3(0.0);\n                 }\n                 fragColor = vec4(col,255);\n                 break;\n           }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}