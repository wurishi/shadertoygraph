{"ver":"0.1","info":{"id":"7tBfWy","date":"1652691421","viewed":134,"name":"audio portals deux","username":"Wampow","description":"Visualize Soundcloud audio. Put your own song into Buffer A iChannel1 and enjoy. Change direction by mouse click","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["sound","audio","vortex"],"hasliked":0,"parentid":"ftBBzc","parentname":"audio portals"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mDrift = 2.*iMouse.xy / iResolution.xy - 1.;\n    uv.x = uv.x*1.5+1.25+sin(iTime *0.01); //morph 1\n    uv.y = uv.y*2.+1.5+cos(iTime *0.01);; //morph 1\n    vec3 polar = toPolar(uv); //polar projection (from interwebs)\n    uv = polar.yx; //project onto circle (flipped)\n    uv *= 1.+0.35* sin(iTime * 0.61 * mDrift + uv.xy*4.61)-0.725; // wobble\n    uv.x = uv.x * .75 + 1.15; //morph 2 \n    uv.y = uv.y * .75 + 0.56; //morph 2 \n    \n    // bad try to polar project myself\n    //float r = 1.0*(0.35*sin(iTime)-1.8);\n    //float teta = 2.0 * 3.141 * (uv.x-0.5);\n    //vec2 Tpolar = vec2(r * cos(teta), r *sin(teta)); //wrong\n    //uv = Tpolar;\n    \n    // unused point projection\n    //vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t//point = 1.0 * point.xy / iResolution.y;\n    //point += vec2(+.9,0.50);\n    //point.x *= 0.275;\n    \n    uv *= vec2(.5,1.10); // extramorph\n    // Output to screen\n    // display spectrograph of Buffer A (loaded onto iChannel0)\n    fragColor = texture(iChannel0, uv); //+ vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlSXz1","filepath":"https://soundcloud.com/quantaloop/alternative-views","previewfilepath":"https://soundcloud.com/quantaloop/alternative-views","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //init\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //do point stuff\n    vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tpoint = 2.0 * point.xy / iResolution.y;\n    point.x = -point.x;\n    //regret point stuff\n    //morphs\n    //uv = .625-uv;\n    uv *= 4.725;\n    uv += -2.45;\n    \n    // get sound \n    vec4 snd2 = texture(iChannel1, uv.xy);\n    vec4 sndL = snd2.xxxw;\n    vec4 sndR = snd2.yyyw;\n    //    vec4 sndL = texture(iChannel1, uv.xx);\n    //vec4 sndR = texture(iChannel1, uv.yy);\n    //colors by frequency\n    //float sr = pow((0.5*uv.x+.85),2.)*.001 + (0.8*uv.x+.25)*0.0 + 0.00/(-1.1*uv.x+0.01) + 0.5/(0.2*pow(uv.x,2.)+0.3) -0.0;\n    //float sg = pow((0.8*uv.x+.25),2.)*0.0 + (0.8*uv.x+.25)*4.0 + 0.00/(-1.1*uv.x+0.01) + 0.2/(0.02*pow(uv.x,2.)+0.1) -0.0;\n    //float sb = pow((0.08*uv.x+.25),2.)*2.0 + (0.8*uv.x+.25)*0.0 + 0.00/(-1.1*uv.x+0.01) + 0./(0.2*pow(uv.x,2.)+0.3) -0.0;\n    //vec4 col = vec4(1.825/((0.2*pow(uv.x,2.)+0.3))+0.4,7.75*(0.3*uv.x+.35)-0.3,pow((0.8*uv.x+.25),2.)*6.85-1.02,1.0) -0.75 + 0.02/(-uv.x+0.01);\n    //vec4 col = vec4(sr,sg,sb,1.0);\n    //col = clamp(col,0.0,2.0); // better safe than sorry\n    \n    //colors by frequency\n    vec4 col = vec4(0.825/((pow(uv.x,2.)+0.15))-0.1,6.75*(uv.x*0.5-.15)-0.3,pow((uv.x+.05),2.)*6.85-2.02,1.0) -0.95;\n    col = clamp(col,0.0,2.0); // better safe than sorry\n    //color shift\n    col -= vec4(cross(col.xyz, vec3(0.8*cos(iTime*0.07+1.3),1.7*sin(iTime*0.09+1.0),-1.5*cos(iTime*0.13-1.3))*sin(iTime*0.027)*.75-.710), 1.0);\n    col = clamp(col,0.0,2.0); // better safe than sorry\n    // sound mix and dampening\n    col.xy *= (sndL.xy+sndR.xy) * (1. - (uv.xy*0.45/(1.8*uv.yx+0.85))); \n    \n    //col += vec4(-point.x,0.0,1.75,1.0) * point.x * col.x;\n    col = clamp(col,0.0,1.0); // better safe than sorry\n    fragColor += col + texture(iChannel0, uv) * (0.75 - 1./35.5); // fading from previous frame\n    fragColor = clamp(fragColor,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//https://gamedev.stackexchange.com/questions/135108/converting-back-and-forth-between-spherical-and-cartesian-coordinates-in-glsl\n//credits to andras\nconst float PI = 3.1415926535897932384626433832795028841971693993751058209749;\n\nvec2 toUV(in vec3 n)\n{\n    vec2 uv;\n\n    uv.x = atan(-n.x, n.y);\n    uv.x = (uv.x + PI / 2.0) / (PI * 2.0) + PI * (28.670 / 360.0);\n\n    uv.y = acos(n.z) / PI;\n\n    return uv;\n}\n\n// Uv range: [0, 1]\nvec3 toPolar(in vec2 uv)\n{\n    float theta = 2.0 * PI * uv.x + - PI / 2.0;\n    float phi = PI * uv.y;\n\n    vec3 n;\n    n.x = cos(theta) * sin(phi);\n    n.y = sin(theta) * sin(phi);\n    n.z = cos(phi);\n\n    //n = normalize(n);\n    return n;\n}","name":"Common","description":"","type":"common"}]}