{"ver":"0.1","info":{"id":"Dd23Wt","date":"1668340406","viewed":62,"name":"raymarch-generate","username":"Kolya142","description":"generate 3d","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","generate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise1(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec2 x) {\n\treturn noise1(x);\n}\nvec4 generate(vec2 uv) {\n    vec3 col;\n    vec2 p = uv;\n    float n = noise(p*1.5);\n    float n1;\n    if (n < .1) {\n            col = vec3(.2, .2, .8);\n            n1 = .1;\n        }\n        else {\n            if (n < .3) {\n                col = vec3(.8, .7, .2);\n                n1 = .3;\n            }\n            else {\n                if (n < .86) {\n                    col = vec3(.2, .8, .2);\n                    n1 = .86;\n                }\n                else {\n                    col = vec3(.8, .7, .86);\n                    n1 = n;\n                }\n            }\n        }\n    return vec4(col, n*2.);\n}\nvec3 light_pos() {\n    return vec3(vec2(1.6, 7.), .0);\n}\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a), \n                p.x * sin(a) + p.y * cos(a));\n}\n\nvec2 map_the_world(in vec3 p) {\n    float index = 0.;\n    vec4 gen = generate(p.xz);\n    float d = abs((p.y+3.8)-gen.w);\n    return vec2(d, index);\n}\nvec3 Norm(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy).x - map_the_world(p - small_step.xyy).x;\n    float gradient_y = map_the_world(p + small_step.yxy).x - map_the_world(p - small_step.yxy).x;\n    float gradient_z = map_the_world(p + small_step.yyx).x - map_the_world(p - small_step.yyx).x;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\nfloat shadow(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    for (int i = 0; i < 20;i++) {\n        pos = ro + dist * rd;\n        vec2 map = map_the_world(pos);\n        d = map.x;\n        if (d < .0001 && dist > .015) {\n            if (map.y == 4.) return -10.;\n            return .5;\n        }\n        dist += d;\n    }\n    return 0.;    \n}\nvec3 render(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    for (int i = 0; i < 30;i++) {\n        pos = ro + dist * rd;\n        vec2 map = map_the_world(pos);\n        d = map.x;\n        float id = map.y;\n        vec3 norm = Norm(pos);\n        float light = dot(norm, normalize(light_pos()));\n        light -= shadow(pos, normalize(ro));\n        vec4 gen = generate(pos.xz);\n        if (gen.w-2. > pos.y) {\n            vec3 color = gen.xyz;\n            light = max(light, .2);\n            return color * (light+.899999);\n        }\n        dist += d;\n    }\n    return vec3(.2, .2, .8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vuv = fragCoord/iResolution.xy;\n    vuv.x *= iResolution.x / iResolution.y;\n    vuv.x -= .5;\n    vec2 uv = vuv * 2. - 1.;\n    vec3 ro = vec3(0., 0., -6.);\n    ro.x += iDate.w;\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.xz = rot(rd.xz, -95.7);\n\n    // Time varying pixel color\n    vec3 col = render(ro, rd);\n    if (vuv.y > .7) {\n        if (vuv.x < .05) {\n            vec2 p = uv*1.5;\n            p.x += iDate.w;\n            col = generate(p).rgb;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}