{"ver":"0.1","info":{"id":"cslSzf","date":"1669321727","viewed":96,"name":"Donut music visualization","username":"BPavol","description":"Donut music visualization","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["visualization","music","donut","era","kontrafakt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"llSSWm","filepath":"https://soundcloud.com/timo-timo-timo-460793848/kontrafakt-era-2004-official-video?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/timo-timo-timo-460793848/kontrafakt-era-2004-official-video?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Surface {\n    float sd; // signed distance\n    vec4 color;\n};\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec4 color)\n{\n    float sd = length(p - offset) - r; // p is the test point and r is the radius of the sphere\n    return Surface(sd, color);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdBox(vec3 p, vec3 boundary, vec3 offset, vec4 color, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - boundary;\n  float sd = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  \n  return Surface(sd, color);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdTorus(vec3 p, vec2 t, vec3 offset, vec4 color, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float sd = length(q)-t.y;\n  return Surface(sd, color);\n}\n\nSurface sdFloor(vec3 p, vec4 color) {\n  float sd = p.y + 1.;\n  return Surface(sd, color);\n}\n\nSurface minSdSurface(Surface s1, Surface s2) \n{\n    if (s1.sd < s2.sd) return s1;\n    return s2;\n}\n\nSurface sdScene(vec3 p)\n{\n    vec4 music = texture(iChannel0, vec2(0.2, 0.0));\n\n    //Surface sphere = sdSphere(p, 1.0, vec3(1.5, 0, (music.r*10.0)-5.0), vec4(1.0, 0, 0, 1.0));\n    //Surface sphere2 = sdSphere(p, 1.0, vec3(-1.5, 0, music.r*2.0), vec4(1.0, 1.0, 0, 1.0));\n    \n    const int objectsCount = 5*5;\n    Surface objects[objectsCount];\n    \n    vec2 cosSin = cos(iTime + vec2(0, 33));\n    vec4 rainbow = vec4(\n        abs(cosSin.y),\n        abs(cosSin.x),\n        abs(cosSin.x + cosSin.y),\n        1.0\n    );\n    vec4 invertedRainbow = vec4(rainbow.b, rainbow.r, rainbow.g, 1.0);\n    vec4 floorColor = vec4(vec3(1.0), 1.0);   \n    vec4 lighter = vec4(vec3(2.0), 1.0);\n    bool isEven = mod(floor(p.x) + floor(p.z), 2.0) < 0.1;\n    if (sin(iTime*5.0) <= 0.0) {\n        if (isEven) {       \n            floorColor = invertedRainbow * lighter;\n        } else {\n            floorColor = lighter;\n        }\n    } else {\n        if (isEven) {       \n            floorColor = lighter;\n        } else {\n            floorColor = invertedRainbow * lighter;\n        }\n    }\n    Surface floorSurface = sdFloor(p, floorColor); \n            \n    vec3 boundary = vec3(1.5*music.r);\n    mat3 transform = rotateY(iTime*2.0) * rotateX(iTime*2.0) * rotateZ(iTime*2.0);\n    mat3 transform2 = rotateX(iTime*2.0) * rotateY(iTime*2.0) * rotateZ(iTime*2.0);\n    int k = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            vec3 origin = vec3(-6.0, 0.5, -2.0);\n            origin.x += float(i)*3.5;\n            origin.y += float(j);\n            origin.z -= float(j)*3.5;\n            //objects[k] = sdBox(p, boundary, origin, rainbow, transform); \n            objects[k] =  sdTorus(\n                p, \n                vec2(boundary.x*1.2, .4),\n                origin, \n                rainbow, \n                k%2 == 0 ? transform : transform2\n            );\n            k++;\n        }\n    }\n      \n    /*color.r = abs(cos(iTime));\n    color.g = abs(sin(iTime));\n    objects[9] = sdTorus(p, vec2(1.0, .4), vec3(3.0, 0.5, (music.r*10.0)-7.0), color, rotateY(iTime) * rotateX(iTime) * rotateZ(iTime)); \n    */\n    \n    Surface closestObject = objects[0];\n    for (int i = 1; i < objectsCount; i++) {\n        closestObject = minSdSurface(closestObject, objects[i]);\n    }\n    \n    closestObject = minSdSurface(closestObject, floorSurface);\n    \n    return closestObject;\n}\n\nvec3 calcNormal(vec3 p) {\n    float e = 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(vec3(\n        sdScene(vec3(p.x + e, p.y, p.z)).sd - sdScene(vec3(p.x - e, p.y, p.z)).sd,\n        sdScene(vec3(p.x, p.y + e, p.z)).sd - sdScene(vec3(p.x, p.y - e, p.z)).sd,\n        sdScene(vec3(p.x, p.y, p.z  + e)).sd - sdScene(vec3(p.x, p.y, p.z - e)).sd\n    ));\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface closestObject;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + (depth * rd);\n        closestObject = sdScene(p);\n        depth += closestObject.sd;\n        if (closestObject.sd < PRECISION || depth > end) break;\n    }\n    \n    closestObject.sd = depth;\n\n    return closestObject;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    \n    vec3 ro = vec3(mouse.x * 5.0, (mouse.y * 5.0)+2.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    Surface closestObject = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n    vec4 col = vec4(0);\n\n    if (closestObject.sd > MAX_DIST) {\n        col = vec4(vec3(uv.x+1.0), 1.0); // ray didn't hit anything\n        if (uv.x > 0.0) {\n            col = vec4(vec3(1.0-uv.x), 1.0);\n        }\n        \n        vec2 cosSin = cos(iTime + vec2(0, 33));\n        col.r *= abs(cosSin.y);\n        col.g *= abs(cosSin.x);\n        col.b *= abs(cosSin.x + cosSin.y);\n    } else {\n        // ray hit something\n        vec3 p = ro + rd * closestObject.sd; // point on sphere we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(sin(iTime)*5.0, 0, cos(iTime));\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        // Calculate diffuse reflection by taking the dot product of \n        // the normal and the light direction.\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.0);\n\n        col = dif * closestObject.color;\n    }\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}