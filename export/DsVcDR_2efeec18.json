{"ver":"0.1","info":{"id":"DsVcDR","date":"1695987947","viewed":80,"name":"Bitonic Filter","username":"MartyMcFly","description":"Implementation of \"The Bitonic Filter: Linear Filtering in an Edge-preserving Morphological Framework\"\n\nCompute min/max within kernel, calculate error to original, blur error, weighted avg. of min/max based on blurred error","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","median","bitonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Min | Bitonic Filter | Max\n\n//Combine pass\n//Buffer A computes min/max of source image greyscaled\n//Buffer B computes the gaussian blurred MSE of min/max to source image\n//Here, we perform a weighted blend of min/max filter, based on the blurred error\n\n//Adjust kernel size in Common tab\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy;\n\n    vec2 minmax = texture(iChannel1, uv).zw;\n    vec2 error_filtered = abs(texture(iChannel2, uv).zw)+1e-4; \n    \n    float bitonic_filter = dot(minmax, error_filtered.yx) / dot(error_filtered.xy, vec2(1));\n    \n    //visualization, unrelated to filter functionality    \n    float mv = iMouse.x / iResolution.x;\n    \n    if(dot(iMouse.xy, vec2(1.0)) < 1e-6) mv = 0.5; //fix preview\n    \n    float div_L = mix(0.0, mv, 0.666);\n    float div_R = mix(mv, 1.0, 0.333);  \n    div_L = smoothstep(0.0, 1.0, div_L);\n    div_R = smoothstep(0.0, 1.0, div_R);\n    div_L = smoothstep(0.0, 1.0, div_L);\n    div_R = smoothstep(0.0, 1.0, div_R);\n    \n    float orig = dot(vec3(0.333), texture(iChannel0, uv).rgb);\n    \n    float ret = bitonic_filter;\n    ret = uv.x < div_L ? orig : ret;\n    ret = uv.x > div_R ? orig : ret;\n    o = vec4(ret);\n    \n    float separator = abs(uv.x - div_L) * iResolution.x;    \n    o.rgb = mix(o.rgb, vec3(1.0, 0.0, 0.0), max(0.0, 2.0 - separator));\n    separator = abs(uv.x - div_R) * iResolution.x;\n    o.rgb = mix(o.rgb, vec3(1.0, 0.0, 0.0), max(0.0, 2.0 - separator));\n    \n    \n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//to greyscale, perform min and max pipelined\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy;\n    vec2 duv = 1.0 / iResolution.xy;\n    \n    vec2 minmax_orig = vec2(1000, 0);\n    vec2 minmax_pipe = vec2(1000, 0);\n    \n    for(int j = -KERNEL_SIZE; j <= KERNEL_SIZE; j++)\n    {\n        float orig = dot(vec3(0.333), texture(iChannel0, uv + duv * vec2(j, 0)).rgb);\n        minmax_orig = vec2(min(minmax_orig.x, orig), max(minmax_orig.y, orig));\n        \n        vec2 pipe = texture(iChannel1, uv + duv * vec2(0, j)).xy;\n        minmax_pipe = vec2(min(minmax_pipe.x, pipe.x), max(minmax_pipe.y, pipe.y));\n    }\n         \n    o = vec4(minmax_orig, minmax_pipe);  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KERNEL_SIZE 5","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//gaussian blur of delta, piped\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy;\n    vec2 duv = 1.0 / iResolution.xy;\n    \n    float isigma2 = 0.5/float(KERNEL_SIZE * KERNEL_SIZE);\n    \n    vec4 errorsum = vec4(0);//xy initial, zw pipelined   \n    float gsum = 0.0;\n    \n    for(int j = -KERNEL_SIZE; j <= KERNEL_SIZE; j++)\n    {\n        float g = exp(-float(j*j)*isigma2);  \n        gsum += g;\n        \n        //original image at xy\n        float orig = dot(vec3(0.333), texture(iChannel2, uv + duv * vec2(j, 0)).rgb);        \n        \n        //min/max filter, calculate error and accumulate\n        vec2 minmax = texture(iChannel0, uv + duv * vec2(j, 0)).zw;        \n        \n        vec2 delta = minmax - orig;        \n        delta *= delta; //different from paper - use squared error, seems to yield higher accuracy\n        \n        errorsum.xy += delta * g;\n        \n        //piped delta, vertical filter here as we already did the avg in horizontal\n        vec2 delta_piped = texture(iChannel1, uv + duv * vec2(0, j)).xy; \n        errorsum.zw += delta_piped * g;       \n        \n    }\n         \n    o = vec4(errorsum / gsum);  \n}","name":"Buffer B","description":"","type":"buffer"}]}