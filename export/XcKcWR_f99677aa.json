{"ver":"0.1","info":{"id":"XcKcWR","date":"1731707776","viewed":155,"name":"3D Ray Traced Truchet","username":"me_123","description":"A tunnel through truchet.\nno raymarching involved.","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["3d","raytracing","tunnel","truchet","analytic","supertunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nconst float inf = 10000.;\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{ //by IQ\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return 1000.;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return 1000.;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return 1000.;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\nfloat iCylinder(in vec3 o, in vec3 d, in float thickness) {\n    /*x*x + y*y - r*r = 0\n    x = o.x+d.x*t\n    y = o.y+d.y*t\n    \n    (o.x*o.x+o.y*o.y - r*r) + (2*(o.x*d.x+o.y*d.y))*t + (d.x*d.x+d.y*d.y)*t*t\n    */\n    float c = (o.x*o.x+o.y*o.y - thickness*thickness);\n    float b = 2.*(o.x*d.x+o.y*d.y);\n    float a = (d.x*d.x+d.y*d.y);\n    float disc = b*b-4.*a*c;\n    if (disc < 0.0) return 1000.;\n    disc = -b - sign(dot(o.xy, o.xy)-thickness*thickness)*sqrt(disc);\n    if (disc < 0.0) return 1000.;\n    return 0.5*disc / a;\n}\nfloat thickness = 0.25;\nvec4 cell(in vec3 ro, in vec3 rd, float bound) {\n    float d0 = iTorus(ro-vec3(1, 1, 0), rd, vec2(1.0, thickness));\n    d0 = min(d0, iTorus(ro+vec3(1, 1, 0), rd, vec2(1.0, thickness)));\n    d0 = min(d0, iCylinder(ro, rd, thickness));\n    if (d0 > bound) return vec4(-1);\n    return vec4(d0, 0, 0, 0);\n}\nvec4 cell1(in vec3 ro, in vec3 rd, float bound) {\n    float d0 = iTorus(ro-vec3(1, 1, 0), rd, vec2(1.0, thickness));\n    d0 = min(d0, iTorus(ro.zxy+vec3(1, 1, 0), rd.zxy, vec2(1.0, thickness)));\n    d0 = min(d0, iTorus(ro.zyx+vec3(-1, 1, 0), rd.zyx, vec2(1.0, thickness)));\n    if (d0 > bound) return vec4(-1);\n    return vec4(d0, 0, 0, 0);\n}\nvec2 boxx( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2(tN, tF);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float bound = iCylinder(ro.zxy, rd.zxy, 3.);//boxx(ro, rd, vec3(5.5));\n    ro += rd*bound;\n    vec3 pos = floor(ro);\n    vec3 srd = sign(rd);\n    vec3 rdi = 0.5/rd;\n    vec3 normal;\n    float dist = 0.0;\n    float oldDist;\n    vec3 z = vec3(fract(ro));\n    for (int i = 0; i < 10; i++) {\n        vec3 z = (ro+rd*dist - pos-0.5)*2.0;\n        oldDist = dist;\n        vec3 plain = ((1.+srd-2.*(ro-pos))*rdi);\n        dist = min(plain.x, min(plain.y, plain.z));\n        normal = vec3(equal(vec3(dist), plain))*srd;\n        float bound = (dist-oldDist)*2.0;\n        float rnd = hash13(pos);\n        float innerDist = -1.0;\n        if (rnd < 0.1) innerDist = cell(z, rd, bound).x;\n        else if (rnd < 0.2) innerDist = cell(z.yxz, rd.yxz, bound).x;\n        else if (rnd < 0.3) innerDist = cell(z.xzy, rd.xzy, bound).x;\n        else if (rnd < 0.4) innerDist = cell(z.zxy, rd.zxy, bound).x;\n        else if (rnd < 0.5) innerDist = cell(z.zyx, rd.zyx, bound).x;\n        else if (rnd < 0.6) innerDist = cell1(z.yxz, rd.yxz, bound).x;\n        else if (rnd < 0.7) innerDist = cell1(z.xzy, rd.xzy, bound).x;\n        else if (rnd < 0.8) innerDist = cell1(z.zxy, rd.zxy, bound).x;\n        else if (rnd < 0.9) innerDist = cell1(z.zyx, rd.zyx, bound).x;\n        else innerDist = cell1(z, rd, bound).x;\n        if (innerDist > 0.0) {\n            float dist = (oldDist+0.5*innerDist);\n            vec3 pos = ro+rd*dist;\n            return vec3(exp(-(length(pos.xz)-3.0)))*(sin(vec3(10, 11, 12)*(noise(pos*0.5)*0.5+noise(pos)))*0.5+0.5);\n        }\n        pos += normal;\n    }\n    return vec3(0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    float theta = iTime*0.1;\n    uv *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    vec3 ro = vec3(sin(iTime), iTime*min(iTime, 2.), cos(iTime));\n    vec3 rd = normalize(vec3(uv.x, 1.0, uv.y));//getRay(-normalize(ro), uv);\n    vec3 color = getColor(ro, rd);\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nfloat noise(in vec3 p) {\n    vec3 fp = floor(p);\n    vec3 pp = 0.5-0.5*cos(3.14159*fract(p));\n    return mix(mix(mix(hash13(fp+vec3(0,0,0)), hash13(fp+vec3(1,0,0)), pp.x),\n               mix(hash13(fp+vec3(0,1,0)), hash13(fp+vec3(1,1,0)), pp.x), pp.y),\n               mix(mix(hash13(fp+vec3(0,0,1)), hash13(fp+vec3(1,0,1)), pp.x),\n               mix(hash13(fp+vec3(0,1,1)), hash13(fp+vec3(1,1,1)), pp.x), pp.y), pp.z);\n}","name":"Common","description":"","type":"common"}]}