{"ver":"0.1","info":{"id":"MlK3Dc","date":"1477346765","viewed":1366,"name":"Cartoon FX (Fast Bilateral Blur)","username":"ttoinou","description":"Upgrading https://www.shadertoy.com/view/MlVGW3 in linear color space, optimized with two passes, sampling with two Fermat spirals (click on the right to see them).\nBug in the edges detection (last step) ?","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["cartoon","spiral","gaussian","bilateral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BORDERRADIUS (3)\n#define GAMMA       (2.2)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define PI           (3.14159265359)\n#define pow3(x,y)      (pow( max(x,0.) , vec3(y) ))\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,viewport(fragCoord.xy));\n    \n    // cartoon borders\n    vec4 col = vec4(0.);\n    vec2 pos;\n    float coeff;\n    float x;\n    float sum = 0.;\n    \n    for( int i = -BORDERRADIUS ; i < BORDERRADIUS ; i++ ){\n    \tfor( int j = -BORDERRADIUS ; j < BORDERRADIUS ; j++ ){\n            \n            pos = vec2(i,j)/float(BORDERRADIUS);\n\t\t\tx = dot(pos,pos)*2.;\n            coeff = (1. - x)*exp(-x/2.);\n            \n            col += coeff*texture(iChannel0,viewport(fragCoord.xy+vec2(i,j)));\n       \t\t//sum += coeff;\n        }\n        \n    }\n    \n    // https://en.wikipedia.org/wiki/Mexican_hat_wavelet\n    sum = sqrt(3.0*float(BORDERRADIUS)*sqrt(PI))/2.0;\n    \n    coeff = sqrt(dot(col.rgb*LUMWEIGHT,col.rgb))/(sum);\n    \n    //float black = smoothstep( 0. , 220./iResolution.y , coeff );\n    float black = smoothstep( 0. , 0.8 , coeff );\n    \n    fragColor.rgb -= vec3( black )*1.;\n    fragColor.rgb = pow3(fragColor.rgb,1./GAMMA);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PASS2       (false)\n\n#define DX          (iMouse.x/iResolution.x)\n#define DY          (iMouse.y/iResolution.y)\n#define DZ          (iMouse.z > 0.5)\n\n#define BRUTEFORCE  (false)\n#define SHOWSPIRAL  (DZ && DX > .5 && PASS2 )\n#define SHOWUNCERTAINTY (false)\n#define PI          (3.14159265359)\n#define BLENDCOEFF  (DZ ? (DY*6. - 3.) : -1.3) // (8.*DX-4.) // negative => cartoon effect\n#define RADIUS   \t(40) // if you tweak this u have to tweak two next values :(  \n#define BLENDCMIN   (-2.)\n#define BLENCCMAX   (-1.)\n#define NUMPOINTS   (133)\n#define GAMMA       (2.2)\n#define SPACESMOOTH (2./1.41)\n#define INTENSITYSMOOTH (0.06) // the bigger the glower\n#define SPIRALANGLE ((3. - sqrt(5.))*PI)\n#define EPSILON \t(1e-15)\n#define LUMWEIGHT   (vec3(0.2126,0.7152,0.0722))\n\n#define DIAMETER \t(2*RADIUS+1)\n#define UNMIX(t,a,b) ( clamp( (t-a)/(b-a) , 0. , 1.) )\n#define pow3(x,y)      (pow( max(x,0.) , vec3(y) ))\n\nvec3 spiral(int i,bool pass2){\n    vec2 R = vec2(\n        sqrt(float(i)/float(NUMPOINTS-1)) * (pass2 ? 0.94 : 1. ),\n        //SPIRALANGLE*( float(i) + (pass2 ? 0.5 : 0. ) )\n        SPIRALANGLE*( float(i) + (pass2 ? 0.25 : 0. ))*(pass2 ? 1. : -1.1 )\n    );\n    return vec3(R.x*cos(R.y) + (pass2 ? 0.02 : 0. ),R.x*sin(R.y),R.x);\n}\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvec3 sampleImage(vec2 coord){\n    if( PASS2 ){\n        return texture(iChannel0,viewport(coord)).rgb;\n    } else {\n    \treturn pow3(texture(iChannel0,viewport(coord)).rgb,GAMMA);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = viewport(fragCoord.xy);\n    vec2 uv_ = uv*vec2(1.,iResolution.y/iResolution.x);\n    vec3 pixelColor = sampleImage(fragCoord);\n    fragColor = vec4(0.);\n    float sum = 0.;\n    float coeff;\n    vec3 diff;\n    vec3 pos;\n    vec3 color = vec3(0.);\n    float nbPoints = float( BRUTEFORCE ? (DIAMETER*DIAMETER) : NUMPOINTS  );\n    float IntensitySmooth2 = INTENSITYSMOOTH*INTENSITYSMOOTH;\n    float SpaceSmooth2 = float(RADIUS*RADIUS)*SPACESMOOTH*SPACESMOOTH;\n    \n    if( BRUTEFORCE ){\n        for( int i = -RADIUS ; i <= RADIUS ; i++ ){\n\n\n            for( int j = -RADIUS ; j <= RADIUS ; j++ ){\n\n                color = sampleImage(fragCoord.xy+vec2(i,j));\n\n                diff = color - pixelColor;\n                coeff = exp( -(\n                      dot(diff*diff,LUMWEIGHT)/IntensitySmooth2\n                    + float(i*i+j*j)/SpaceSmooth2 ) );\n\n                if( i == -RADIUS && j == -RADIUS ){\n                    fragColor.rgb = color*coeff;\n                } else {\n                    fragColor.rgb += color*coeff;\n                }\n\n                sum += coeff;\n\n            }\n\n        }\n    } else {\n        \n        for( int i = 0; i < NUMPOINTS ; i++ ){\n            pos = spiral(i,PASS2)*float(RADIUS);\n\n            color = sampleImage(fragCoord.xy+pos.xy);\n\n            diff = color - pixelColor;\n            coeff = exp( -(\n                dot(diff*diff,LUMWEIGHT)/IntensitySmooth2\n                + (pos.z*pos.z)/SpaceSmooth2 ) );\n\n            if( i == 0 ){\n                fragColor.rgb = color*coeff;\n            } else {\n                fragColor.rgb += color*coeff;\n            }\n\n            sum += coeff;\n        }\n        \n    }\n\tfragColor = fragColor/sum;\n    \n    diff = pixelColor - fragColor.rgb;\n    // uncertainty : http://people.csail.mit.edu/fredo/PUBLI/Siggraph2002/DurandBilateral.pdf\n    // if sum is too low we don't want to increases local contrast\n    coeff = 1.;\n    coeff = UNMIX( log(sum/nbPoints) , BLENDCMIN , BLENCCMAX );\n    \n    fragColor.rgb = pixelColor + coeff*BLENDCOEFF*diff;\n    \n    // to see uncertainty\n    if(SHOWUNCERTAINTY){ \n    \tfragColor = vec4(coeff);\n    }\n    \n    if( SHOWSPIRAL  ){\n    \tfor( int i = 0; i < NUMPOINTS ; i++ ){\n            pos = spiral(i,false)/4. + 0.3;\n            fragColor.r += 1. - smoothstep(0.,0.01,length(uv_-pos.xy));\n            pos = spiral(i,true)/4. + 0.3;\n            fragColor.g += 1. - smoothstep(0.,0.01,length(uv_-pos.xy));\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PASS2       (true)\n\n#define DX          (iMouse.x/iResolution.x)\n#define DY          (iMouse.y/iResolution.y)\n#define DZ          (iMouse.z > 0.5)\n\n#define BRUTEFORCE  (false)\n#define SHOWSPIRAL  (DZ && DX > .5 && PASS2 )\n#define SHOWUNCERTAINTY (false)\n#define PI          (3.14159265359)\n#define BLENDCOEFF  (DZ ? (DY*6. - 3.) : -1.3) // (8.*DX-4.) // negative => cartoon effect\n#define RADIUS   \t(40) // if you tweak this u have to tweak two next values :(  \n#define BLENDCMIN   (-2.)\n#define BLENCCMAX   (-1.)\n#define NUMPOINTS   (133)\n#define GAMMA       (2.2)\n#define SPACESMOOTH (2./1.41)\n#define INTENSITYSMOOTH (0.06) // the bigger the glower\n#define SPIRALANGLE ((3. - sqrt(5.))*PI)\n#define EPSILON \t(1e-15)\n#define LUMWEIGHT   (vec3(0.2126,0.7152,0.0722))\n\n#define DIAMETER \t(2*RADIUS+1)\n#define UNMIX(t,a,b) ( clamp( (t-a)/(b-a) , 0. , 1.) )\n#define pow3(x,y)      (pow( max(x,0.) , vec3(y) ))\n\nvec3 spiral(int i,bool pass2){\n    vec2 R = vec2(\n        sqrt(float(i)/float(NUMPOINTS-1)) * (pass2 ? 0.94 : 1. ),\n        //SPIRALANGLE*( float(i) + (pass2 ? 0.5 : 0. ) )\n        SPIRALANGLE*( float(i) + (pass2 ? 0.25 : 0. ))*(pass2 ? 1. : -1.1 )\n    );\n    return vec3(R.x*cos(R.y) + (pass2 ? 0.02 : 0. ),R.x*sin(R.y),R.x);\n}\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvec3 sampleImage(vec2 coord){\n    if( PASS2 ){\n        return texture(iChannel0,viewport(coord)).rgb;\n    } else {\n    \treturn pow3(texture(iChannel0,viewport(coord)).rgb,GAMMA);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = viewport(fragCoord.xy);\n    vec2 uv_ = uv*vec2(1.,iResolution.y/iResolution.x);\n    vec3 pixelColor = sampleImage(fragCoord);\n    fragColor = vec4(0.);\n    float sum = 0.;\n    float coeff;\n    vec3 diff;\n    vec3 pos;\n    vec3 color = vec3(0.);\n    float nbPoints = float( BRUTEFORCE ? (DIAMETER*DIAMETER) : NUMPOINTS  );\n    float IntensitySmooth2 = INTENSITYSMOOTH*INTENSITYSMOOTH;\n    float SpaceSmooth2 = float(RADIUS*RADIUS)*SPACESMOOTH*SPACESMOOTH;\n    \n    if( BRUTEFORCE ){\n        for( int i = -RADIUS ; i <= RADIUS ; i++ ){\n\n\n            for( int j = -RADIUS ; j <= RADIUS ; j++ ){\n\n                color = sampleImage(fragCoord.xy+vec2(i,j));\n\n                diff = color - pixelColor;\n                coeff = exp( -(\n                      dot(diff*diff,LUMWEIGHT)/IntensitySmooth2\n                    + float(i*i+j*j)/SpaceSmooth2 ) );\n\n                if( i == -RADIUS && j == -RADIUS ){\n                    fragColor.rgb = color*coeff;\n                } else {\n                    fragColor.rgb += color*coeff;\n                }\n\n                sum += coeff;\n\n            }\n\n        }\n    } else {\n        \n        for( int i = 0; i < NUMPOINTS ; i++ ){\n            pos = spiral(i,PASS2)*float(RADIUS);\n\n            color = sampleImage(fragCoord.xy+pos.xy);\n\n            diff = color - pixelColor;\n            coeff = exp( -(\n                dot(diff*diff,LUMWEIGHT)/IntensitySmooth2\n                + (pos.z*pos.z)/SpaceSmooth2 ) );\n\n            if( i == 0 ){\n                fragColor.rgb = color*coeff;\n            } else {\n                fragColor.rgb += color*coeff;\n            }\n\n            sum += coeff;\n        }\n        \n    }\n\tfragColor = fragColor/sum;\n    \n    diff = pixelColor - fragColor.rgb;\n    // uncertainty : http://people.csail.mit.edu/fredo/PUBLI/Siggraph2002/DurandBilateral.pdf\n    // if sum is too low we don't want to increases local contrast\n    coeff = 1.;\n    coeff = UNMIX( log(sum/nbPoints) , BLENDCMIN , BLENCCMAX );\n    \n    fragColor.rgb = pixelColor + coeff*BLENDCOEFF*diff;\n    \n    // to see uncertainty\n    if(SHOWUNCERTAINTY){ \n    \tfragColor = vec4(coeff);\n    }\n    \n    if( SHOWSPIRAL  ){\n    \tfor( int i = 0; i < NUMPOINTS ; i++ ){\n            pos = spiral(i,false)/4. + 0.3;\n            fragColor.r += 1. - smoothstep(0.,0.01,length(uv_-pos.xy));\n            pos = spiral(i,true)/4. + 0.3;\n            fragColor.g += 1. - smoothstep(0.,0.01,length(uv_-pos.xy));\n        }\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}