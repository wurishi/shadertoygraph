{"ver":"0.1","info":{"id":"XctXzj","date":"1714164509","viewed":441,"name":"Branchless Tests","username":"Xor","description":"Attempting to improve fb39ca4's DDA implementation. Please try the stress test with and without step and let me know your results!","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel"],"hasliked":0,"parentid":"4dX3zl","parentname":"Branchless Voxel Raycasting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Attempting to improve fb39ca4's DDA implementation\n    Please try the stress test with and without step and let me know your results!\n*/\n\n//Uncommenting will loop through empty 10,000 voxel cells!\n//#define TEST_STRESS\n\n//Try with step instead of LessThanEqual and bvec3\n#define TEST_STEP\n//On my machine, STEP is 58.5 FPS, Less is 56.5 FPS\n\n//Add a unique, small bias to each axis to minimize z-fighting issues\n#define TEST_BIAS\n\n//Up to 10,000 steps for stress test\n#define MAX_RAY_STEPS 10000\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = 1.0;\n    \n    #ifndef TEST_STRESS\n        d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    #endif\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0*sin(iTime), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n    \n    //Visible on frame 0\n    //In the original example and here, the mask can return true for multiple components\n    //This occurs when the side distances to 2 or 3 sides is exactly equal (like z-fighting).\n    //It can be relatively expensive to check for these cases inside the loop,\n    //so I found that adding a small bias to each axis mitigates the intersections.\n    #ifdef TEST_BIAS\n        sideDist += vec3(0,1,2) / 1e4;\n    #endif\n\t\n    vec3  vmask;\n    bvec3 bmask;\n    \n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        \n        //Use step and vec3 \n        #ifdef TEST_STEP\n            vmask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\n            sideDist += vmask * deltaDist;\n            mapPos += ivec3(vmask) * rayStep;\n            \n        //Use lessThanEqual and bvec3\n        #else\n        \n            bmask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\n            sideDist += vec3(bmask) * deltaDist;\n            mapPos += ivec3(vec3(bmask)) * rayStep;\n        #endif\n        \n        //Stop when we hit something\n\t\tif (getVoxel(mapPos)) break;\n\t}\n\t\n    //Output the mask results\n\tfragColor.rgb = vmask + vec3(bmask);\n}","name":"Image","description":"","type":"image"}]}