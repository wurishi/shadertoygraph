{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float lum(vec3 col)\n{\n    return dot(col, vec3(.3, .5, .2));\n}\n\nvec3 fetch(vec2 coord)\n{\n    return texture(iChannel0, coord / iResolution.xy).rgb;\n}\n\n// FXAA-like antialiasing\nvec3 fxaa_ish(vec2 coord)\n{\n    // calculate the gradient\n    vec2 grad = vec2(\n        lum(fetch(coord + vec2(1, 0))) - lum(fetch(coord + vec2(-1, 0))),\n        lum(fetch(coord + vec2(0, 1))) - lum(fetch(coord + vec2(0, -1)))\n    );\n    \n    // skip if the gradient is too small\n    if (dot(grad, grad) < .0003)\n    {\n        return fetch(coord);\n    }\n    \n    // tangent (rotate the gradient 90 deg)\n    vec2 tang = vec2(-grad.y, grad.x);\n\n    // keep following the tangent on both sides and average out the\n    // colors along the path\n    vec3 col = vec3(0);\n    for (int i = -6; i <= 6; i++)\n    {\n        col += fetch(coord + float(i) * tang);\n    }\n    col /= 13.;\n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n    \n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvec3 render(vec2 coord)\n{\n    // before / after divider\n    if (iMouse.z > .5)\n    {\n        if (abs(coord.x - iMouse.x) < 1.1)\n        {\n            return vec3(.8, .05, .02);\n        }\n        if (coord.x < iMouse.x)\n        {\n            return fetch(coord);\n        }\n    }\n    \n    return fxaa_ish(coord);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(view_transform(render(frag_coord)), 1);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// this buffer renders some basic 2D shapes with no AA\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3(.015, .02, .04);\n    if (abs(dot(uv, normalize(vec2(-.06, 1))) - .6) < .01)\n    {\n        col = vec3(.3, .5, .7);\n    }\n    if (abs(sin(uv.x * 6.2831853) - 32. * (uv.y - .1)) < .5)\n    {\n        col = vec3(.8, .6, .2);\n    }\n    \n    if (abs(dot(uv, uv) - .2) < .03)\n    {\n        col = vec3(.3, .6, .1);\n    }\n    if (max(abs(uv.x), abs(uv.y + .15)) < .15)\n    {\n        col = vec3(.8);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec3 col = render(frag_coord);\n    frag_col = vec4(col, 1);\n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"M33cD7","date":"1735165058","viewed":145,"name":"FXAA-ish","username":"beans_please","description":"idk if this is FXAA or SMAA or whatever but screen space methods are still better than TAA\nhold mouse for before/after comparison","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["antialiasing","edge","aa","fxaa","smaa","mlaa"],"hasliked":0,"parentid":"XcBBWW","parentname":"Follow Edge Antialiasing? (Bad)"}}