{"ver":"0.1","info":{"id":"4stBzN","date":"1524287477","viewed":464,"name":"Triplanar mapping","username":"dust","description":"Learning about seamless procedural texturing.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarched","projection","uvs","texturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Whether or not the texturizer should use [abs(...)]\n// to tile the texture in [iChannel0]\n#define AUTO_TILE true\n\n// Texture distortion on/off\n//#define DISTORT\n\n// Preferred demo surface\n// SphDF: sphere\n// BoxDF: box\n// TorDF: torus\n#define SURF TorDF\n\nvec2 refl(vec2 uv,\n          bool refl)\n{\n    if (refl) { return abs(uv); }\n    else { return uv; }\n}\n\nvec3 TriMap(vec3 unitCoord,\n            vec3 normal)\n{\n    #ifdef DISTORT\n        vec3 t = texture(iChannel1, abs(unitCoord.xy)).rgb;\n\t\tvec2 uvX = mix(unitCoord.yz, unitCoord.zy, t.x);\n        vec2 uvY = mix(unitCoord.xz, unitCoord.zx, t.y);\n        vec2 uvZ = mix(unitCoord.xy, unitCoord.yx, t.z);\n    \tmat3x3 triKrn = mat3x3(texture(iChannel0, refl(uvX, AUTO_TILE)).rgb,\n                           \t   texture(iChannel0, refl(uvY, AUTO_TILE)).rgb,\n                           \t   texture(iChannel0, refl(uvY, AUTO_TILE)).rgb);\n    #else\n        mat3x3 triKrn = mat3x3(texture(iChannel0, refl(unitCoord.yz, AUTO_TILE)).rgb,\n                           \t   texture(iChannel0, refl(unitCoord.xz, AUTO_TILE)).rgb,\n                           \t   texture(iChannel0, refl(unitCoord.xy, AUTO_TILE)).rgb);\n    #endif    \n    return (triKrn * abs(normal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Simple marching loop\n    vec3 eyePos = vec3(0, 0.0, -3.0);\n    vec3 rayDir = RayDir(fragCoord,\n                         iResolution.xy);\n    float currRayDist = 0.0;\n    vec3 rgb = vec3(0.25, 0.25, 0.25);    \n    vec3 axis = normalize(mix(mix(vec3(0, 1, 0), \n                                  vec3(1, 0, 0),\n                              \t  sin(iTime / 8.0)), \n                          vec3(0, 0, 1), \n                          sin(iTime / 4.0)));\n    vec4 qtn = vec4(axis * sin(iTime / 2.0), cos(iTime / 2.0));\n    for (int i = 0; i < 256; i += 1)\n    {\n        vec3 ray = eyePos + (rayDir * currRayDist);\n        ray = QtnRotate(ray, qtn);\n        float dist = SURF(ray);\n        if (dist < 0.001)\n        {\n            // Local surface positions are equivalent to normals for\n            // spherical surfaces\n            vec3 normRay = normalize(ray);\n            rgb = TriMap(ray,\n                         normRay);\n            break;\n        }\n        else\n        {\n            currRayDist += dist;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float SphDF(vec3 coord)\n{\n    // Fixed-position unit sphere at the origin\n    return length(coord) - 1.0;\n}\n\n// SDF from iq,\n// https://iquilezles.org/articles/distfunctions\nfloat BoxDF(vec3 coord)\n{\n    // Fixed-position 3/4-unit box at the origin\n    vec3 d = abs(coord) - vec3(0.75, 0.75, 0.75);\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)); \n}\n\n// SDF from iq,\n// https://iquilezles.org/articles/distfunctions\nfloat TorDF(vec3 coord)\n{\n      //vec2 q = vec2(length(p.xz)-t.x,p.y);\n  //return length(q)-t.y;\n    vec2 t = vec2(1.0, 0.4);\n\tvec2 q = vec2(length(coord.xz) - t.x, coord.y);\n\treturn length(q) - t.y;\n}\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nvec3 RayDir(vec2 pixPos,\n            vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}","name":"Common","description":"","type":"common"}]}