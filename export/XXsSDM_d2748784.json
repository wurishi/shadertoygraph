{"ver":"0.1","info":{"id":"XXsSDM","date":"1709596433","viewed":117,"name":"GridSineRainbow","username":"navcon","description":"Calm color changing sinewaves in front of a moving grid background.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["calm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\n\nstruct params {\n    float amplitude;\n    float stretch;\n    float phase;\n    float speed;\n    float power;\n    vec3 color;\n};\n\n\nconst int sins_count = 6;\n\nfloat hline, vline, hdot, vdot;\nfloat amplitude;\n\nparams sin_params[sins_count];\nfloat sins[sins_count];\n\nbool between(float low, float value, float high) {\n    return low < value && value < high;\n}\n\nvec3 blend(vec3 one, vec3 two, float factor) {\n    return factor * two + (1.0 - factor) * one; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0,0,0.8);\n    \n    hline = mod(fragCoord.y, 70.0);\n    vline = mod(fragCoord.x + 15.0*iTime, 70.0);\n    \n    hdot = mod(fragCoord.y, 30.0);\n    vdot = mod(fragCoord.x + 6.0 * iTime, 30.0);\n    \n    col *= (hdot < 4.0 && vdot <4.0) ? vec3(.6) : vec3(0.4);\n    \n    col += between(2.0, hline, 3.0) || between(2.0, vline, 3.0) ? vec3(.1) : vec3(0);\n    \n    col += hline < 5.0 && vline < 5.0 ? vec3(.1) : vec3(0);\n    \n    \n    \n    \n    //vec2 light = vec2(0.5 + 0.5 * (sin(iTime)+sin(iTime*0.1+0.4)), 0.5 + 0.5 * (cos(iTime)+cos(iTime*0.05))) * iResolution.xy;\n    \n    // Visualize light source\n    // col += distance(light, fragCoord) < 25.0 ? vec3(1,1,1) : vec3(0,0,0);\n    \n    \n    \n    col *= 0.25;\n    \n    col += vec3(0,0.2,0.4);\n    \n    //col *= clamp(1.0 - 0.1*pow(0.0005*distance(light, fragCoord), 3.0), 0.4, 1.0);\n    \n    \n    amplitude = 0.2 + 0.1 * sin(0.4*iTime + 1.1 * uv.x);\n       \n    \n    // Colorful Curves\n    \n    //                     amplitude, stretch, phase, speed, power, color\n    /*sin_params[0] = params(amplitude, 1.0, 0.0      , 0.2, 16.0 + 4.0*uv.x, vec3(1.0,0.1,0.1));\n    sin_params[1] = params(amplitude, 1.0, 1.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.5,0.5,0.1));\n    sin_params[2] = params(amplitude, 1.0, 2.0 / 3.0, 0.2, 16.0 + 4.0*uv.x, vec3(0.1,1.0,0.1));\n    sin_params[3] = params(amplitude, 1.0, 3.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.1,0.5,0.5));\n    sin_params[4] = params(amplitude, 1.0, 4.0 / 3.0, 0.2, 16.0 + 4.0*uv.x, vec3(0.1,0.1,1.0));\n    sin_params[5] = params(amplitude, 1.0, 5.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.5,0.1,0.5));\n    */\n    \n    \n    // monochrome Curves\n    \n    vec3 blue = vec3(0,0.8,1);\n    \n    sin_params[0] = params(amplitude, 1.0, 0.0      , 0.24, 16.0 + 24.0*uv.x, 0.15*blue);\n    sin_params[1] = params(amplitude, 1.1, 1.0 / 3.0, 0.20, 24.0 + 24.0*uv.x, 0.20*blue);\n    sin_params[2] = params(amplitude, 1.0, 2.0 / 3.0, 0.21, 16.0 + 24.0*uv.x, 0.30*blue);\n    sin_params[3] = params(amplitude, 1.2, 3.0 / 3.0, 0.16, 24.0 + 24.0*uv.x, 0.40*blue);\n    sin_params[4] = params(amplitude, 1.0, 4.0 / 3.0, 0.14, 16.0 + 24.0*uv.x, 0.50*blue);\n    sin_params[5] = params(amplitude, 1.3, 5.0 / 3.0, 0.18, 18.0 + 24.0*uv.x, 0.80*blue);\n    \n    \n    \n    for(int i = 0; i < sins_count; i++) {\n    \n        sin_params[i].power = 12.0 + 24.0 * pow(uv.x, 4.0);\n        \n        sins[i] = 0.5\n                    + sin_params[i].amplitude\n                    * sin(sin_params[i].stretch * uv.x\n                    + sin_params[i].phase * PI\n                    + sin_params[i].speed * iTime);\n        sins[i] += 0.1 * sin(0.2*iTime + 1.8 * uv.x);\n        \n        col += clamp( pow( 1.0 - abs(uv.y - sins[i] ), sin_params[i].power ), 0.0, 1.0) * sin_params[i].color;\n    }\n    \n    // Output to screen\n    \n    /*float min_dist_to_border = min(min(fragCoord.x, fragCoord.y), min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y));\n    if (min_dist_to_border < 70.0 && min_dist_to_border > 68.0) {\n        col = 0.4* vec3(0.8,0.8,1.0) + 0.6 * col;\n    }\n    \n    if(min_dist_to_border > 80.0) {\n        col = 0.20 * vec3(0.8,0.8,1.0) + 0.80 * col;\n    }*/\n    \n    //col = blend(col, col.zxy, 1.0);\n    \n    float blendTime = 0.05 * iTime;\n    \n    col = clamp(sin(blendTime), 0.0, 1.0) * col\n        + clamp(sin(blendTime + 2.0 * PI / 3.0), 0.0, 1.0) * col.zyx\n        + clamp(sin(blendTime + 4.0 * PI / 3.0), 0.0, 1.0) * col.xzy;\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}