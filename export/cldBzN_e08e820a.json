{"ver":"0.1","info":{"id":"cldBzN","date":"1701035619","viewed":63,"name":"metaballs v0.2","username":"wj","description":"I am using a somewhat pimped up version of this code on my page: \nhttp://www.wothke.ch/webAdPlug/ \n\nunfortunately shadertoy's limitations slow it down considerably here..","likes":5,"published":1,"flags":96,"usePreview":0,"tags":["metaballs","bumpmapping"],"hasliked":0,"parentid":"clycRG","parentname":"metaballs v0.1"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dcGzf","filepath":"https://soundcloud.com/lmanic/devolution","previewfilepath":"https://soundcloud.com/lmanic/devolution","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// metaballs v0.2\n// by wj\n//\n// unfortunately the shadertoy version is unnecessarily slow due to the lack of \n// user definable uniforms.. (see plain WEBGL version on my page: \n// http://www.wothke.ch/webAdPlug/ for comparison)\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// texture bumpmapping from: https://www.shadertoy.com/view/XdKSD3\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{   \n    n = max((abs(n) - .2) * 7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz) * n.x + texture(tex, p.zx) * n.y + texture(tex, p.xy) * n.z).xyz;\n    \n    return p * p;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 bumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n * dot(n, g);\n                      \n    return normalize( n + g * bf ); // Bumped normal. \"bf\" - bump factor. \n}\n\nfloat getShadow(in vec2 uv) \n{\n\tvec2 base = uv + vec2(_lightPosX / 4000., _lightPosY / 4000.);\n\t\n    return 1.0 -  texture(iChannel3, base).x * 1.7;\n}\n\n\tfloat getGlow(in vec2 uv) \n\t{\n\t\tvec2 base = uv - vec2(_lightPosX / 2000.,  _lightPosY / 2000.);\n\t\t\n\t\treturn texture(iChannel3, base).x * 0.15;\n\t}\n\nvec4 colorBackground(in vec2 uv, vec3 eye, in vec3 ray, in vec3 light) \n{\n    vec3 color = texture(iChannel0, uv).xyz;\n\tvec3 normal = bumpMap(iChannel0, vec3(uv.x, uv.y, 10.)*1.2, vec3(0.,0.,1.), 0.002);    \n\t\n\t// replicate rayMarch result for background plane\n\tfloat marchingDist = 47.1 - BLOB_Z;\n\tvec3 surface = eye + ray *  marchingDist + MARCHING_STEP * float(MAX_MARCHING_STEPS);    \n\n\t// apply lighing\n    vec3 reflectedLight  = reflect(normalize(surface - light ), normal) ;\n\n\tcolor = mix(color, vec3(0,0,0), 1.0 - getShadow(uv) );    \n\n\t\tcolor += vec3(1., .88, .48) *  getGlow(uv); \n\n    vec3 hilight = vec3(0.2, 0.2, 0.2) * pow(max(dot(reflectedLight, -ray),0.0), SHININESS); \n    vec3 ambiant = vec3(0.2,0.2,0.1) * 0.3;        \n\n    return vec4(color * 0.8 + hilight + ambiant, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 eye, ray, light;       \n    init(fragCoord, iResolution, iTime,  eye, ray, light);\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel2, uv);\n\t\n    if (fragColor.a == 0.) \n\t{\n        fragColor = colorBackground(uv, eye, ray, light);\n    }       \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\nconst float NEAR_Z = 1.;\nconst float SHININESS = 100.;\n\nconst float NUM_BLOBS = 100.;\nconst float BLOB_Z = -.9;\nconst float BLOB_SIZE = .09;\n\nconst int MAX_MARCHING_STEPS = 50;               // also limits size of playground\nconst float MARCHING_STEP = .17;\n\nfloat _lightPosX = 0.;\nfloat _lightPosY = 0.;\n\n#define PI 3.1415926535897932\n#define PI2 6.283185307179586\n\nconst float PI2_NUM_BLOBS = PI2 / NUM_BLOBS;\n\nvoid init(in vec2 fragCoord, in vec3 resolution, float t, out vec3 eye, out vec3 ray, out vec3 light)\n{\n\tfloat \tratio\t\t\t= resolution.x/resolution.y;\n\tvec3 \tviewportCoord\t= vec3(fragCoord.xy/resolution.y - vec2(ratio *.5, .5), NEAR_Z);\n\n\teye\t\t\t\t\t\t= vec3(0., 0., BLOB_Z);\n\tray\t\t\t\t\t\t= normalize(viewportCoord - eye);\n\n\t_lightPosX\t\t\t\t= -15. * cos(t);\n\t_lightPosY\t\t\t\t= 12. * cos(t *.4);\n    \n\tlight\t\t\t\t\t= vec3(_lightPosX, _lightPosY, 5.);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// use Buffer A to cache ball coordinates .. as a workaround \n// for shadertoy's lack of user definable uniforms..\n\n// the damn texture lookups still seem to be much more expensive\n// than the plain uniform based WEBGL based impl on my webpage..\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1.)\n    {\n        float i = round(fragCoord.x/iResolution.x*NUM_BLOBS);\n        float t = i * PI2_NUM_BLOBS;\n        float a = iTime/1.5;\n        \n        float x = sin(t) * 7. + cos(t*a)*3.;\n        float y = cos(t) * 7. + sin(t*a)*3.;\n        \n        fragColor.xyz = vec3(x, y, 48.);\n    }\n    else\n    {\n        // don't care about the rest of the texture\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float calcMetaball(in vec3 surface, out vec3 normal) \n{\n\tnormal = vec3(0,0,0);\n\tfloat r = 0.0;\n\n\tfor(float i = 0.0; i < NUM_BLOBS; i += 1.0) \n\t{\n\t\tvec3 pos =  texture(iChannel0, vec2(i/NUM_BLOBS, .0)).xyz;\n\t\tfloat d = length(surface - pos);\n\n\t\tfloat r0 = BLOB_SIZE / (d*d);\n\t\tnormal += normalize(surface - pos) * r0;\n\t\tr += r0;\n\t}\n\n\tnormal = normalize(normal);\n\treturn r;\n}\n\nfloat rayMarch(in vec3 origin, in vec3 ray, out vec3 surface, out vec3 normal) \n{\n    float\tdist = 47.1 - BLOB_Z; \n\n \tsurface = origin;   \n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) \n\t{      \n    \tfloat r = calcMetaball(surface, normal);\n        \n        if(r > 0.5) \n\t\t{\n            return r;\n        }\n        else \n\t\t{\n            dist += MARCHING_STEP;\n        \tsurface = origin + ray * dist;    \n        }\n    }\n    \n    normal = vec3(0.,0.,1.);  // imaginary background plane\n\treturn 0.;   \n}\n\nvec4 blobColor( in vec3 ray, in vec3 surface, in vec3 normal, in vec3 light ) \n{\n    vec3 color = texture(iChannel1, normal).xyz;\n       \n    vec3 dLight = normalize(surface - light );\n    float diffuse = dot(normal, -dLight) * 2.8;\n    \n    vec3 reflected = reflect(dLight, normal) ;\n\t\n    float h = pow(max(dot(reflected, -ray), .0), SHININESS);\n    vec3 hilight = vec3(h, h, h);\n    \n    vec3 ambiant = vec3(1,0.3,0.1) * 0.4;        \n\n    return vec4(color * diffuse + hilight + ambiant, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 eye, ray, light;       \n    init(fragCoord, iResolution, iTime,  eye, ray, light);\n    \n    vec3 surface, normal; \t\n    if(rayMarch(eye, ray, surface, normal) > 0.5) \n    {\n        fragColor = blobColor(ray, surface, normal, light);\n    }\n    else \n    {    \n        fragColor = vec4(0.,0.,0.,0.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// blur the blobs image (background is still black) as a base for\n// fake shadows\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 12.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    fragColor =  Color;\n}","name":"Buffer C","description":"","type":"buffer"}]}