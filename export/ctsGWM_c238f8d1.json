{"ver":"0.1","info":{"id":"ctsGWM","date":"1671846201","viewed":221,"name":"Happy holiday","username":"okdalto","description":"Happy holiday!\nThe tree sdf is borrowed from Hazel Quantock's amazing work: https://www.shadertoy.com/view/wdfGzr","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["pathtracer","holiday"],"hasliked":0,"parentid":"7scGDX","parentname":"path tracer implementation new"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(ACESFilm(color), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash1(float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EP 0.001\n#define LIGHTSTEP 2\n\n\n// hashes from https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 exp2(-32.)\n//(1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n// Baubles\n// by Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nfloat TreeBoundsSDF( vec3 pos )\n{\n    // just a cone\n    pos.y -= 4.;\n    return dot( vec2(pos.y,length(pos.xz)), normalize(vec2(.3,1)) );\n}\n\n\n/*\nWarp space into a series of repeated cells (\"branches\") around the y axis\nThis causes some distortion, causing marching errors near the axis when branches are\nparticularly sparse. But this can be worked round by tweaking the SDF.\n\nCells are mirrored so whatever's placed in them will tile with itself!\n\nyByOutStep - tilts branches along the axis, but breaks vertical tiling.\n*/\nvec3 HelixGrid( out ivec2 grid, vec3 pos, int numSpokes, float yStepPerRotation, float yByOutStep )\n{\n    // convert to polar coordinates\n    vec3 p = vec3(atan(pos.x,pos.z),pos.y,length(pos.xz));\n\n    p.y -= yByOutStep*p.z;\n    float l = sqrt(1.+yByOutStep*yByOutStep);\n    \n    // draw a grid of needles\n    vec2 scale = vec2(6.283185/float(numSpokes),yStepPerRotation);\n    p.xy /= scale;\n    \n    // rotate and skew the grid to get a spiral with nice irrational period\n    float sn = 1./float(numSpokes); // so we step by an integer number of rows\n\n    p.xy += p.yx*vec2(-1,1)*sn;\n    \n    // make horizontal triangle-waved, so edges of cells match up no matter what's put inside them!\n    grid = ivec2(floor(p.xy));\n    vec2 pair = fract((p.xy + 1.)*.5)*2.-1.;\n    p.xy = (abs(pair)-.5);\n    vec2 flip = step(0.,pair)*2.-1.; // sign() but without a 0.\n    p.xy *= scale;\n\n    // unshear...\n    p.y += flip.y*yByOutStep*p.z;\n    \n    // reconstruct a non-bent space\n    p.xz = p.z*vec2(sin(p.x),cos(p.x));\n\n    // ...and apply rotation to match the shear (now we've sorted out the grid stuff)\n    p.yz = ( p.yz + flip.yy*p.zy*vec2(-1,1)*yByOutStep )/l; // dammit - I think it breaks the wrap\n    \n// might be worth returning a bound on y to mask the discontinuous area\n// I think it will just be yByAngleStep/sqrt(1.+yByOutStep*yByOutStep) which caller can do if desired\n// Or, could make z NOT start at 0 - so caller has to bound using parent-level's length (totally viable and I'm doing it a lot)\n// so mirroring WOULD line up!\n    \n    return p;\n}\n\n\n\nstruct TreeSpace\n{\n    vec3 branch;\n    vec3 twig;\n    vec3 needle;\n    ivec2 branchGrid;\n    ivec2 twigGrid;\n    ivec2 needleGrid;\n};\n\n\nTreeSpace GetTreeSpace( in vec3 pos )\n{\n    TreeSpace o;\n    o.branch = HelixGrid( o.branchGrid, pos, 12, .5, .5 ); //.5\n    o.twig = HelixGrid( o.twigGrid, o.branch.xzy, 5, .5, 1. );\n    o.needle = HelixGrid( o.needleGrid, o.twig.xzy, 9, .04, 1. );\n    \n    return o;\n}\n\n\nfloat TreeSDF( vec3 pos )\n{\n    float bounds = TreeBoundsSDF(pos);\n    \n\tTreeSpace ts = GetTreeSpace(pos);\n\n\tfloat branchRand = hash1(coord2(uvec2(ts.branchGrid+0x10000)));\n    float branchEndLength = .3*(branchRand-.5);\n    \n    return\n        min(\n            max(\n                min(\n                    min(\n                        // twig\n                        length(ts.twig.xy)-.015,\n                        // needle\n                        length( vec3( ts.needle.xy, max(0.,ts.needle.z-.05) ) ) - .01\n                    ),\n                    // branch\n                    max(\n                    \t(length(ts.branch.xy\n                               + .004*sin(vec2(0,6.283/4.)+ts.branch.z*6.283/.1) // spiral wobble\n                              )-.01)*.9,\n                    \tbounds - branchEndLength - .2 // trim branches shorter than twigs\n                    )\n            \t),\n            \t// branch length (with rounded tip to clip twigs nicely)\n                length( vec3(ts.branch.xy,max(0.,bounds\n                                              -branchEndLength  // this seems to cause more floating twigs (or more obvious ones)\n                                             )) )-.3\n            ),\n            max(\n                // trunk\n                length(pos.xz)-.03,\n                bounds  // this will give a sharp point - better to just chop it - but might not show it\n            )\n        )*.7; // the helical distortion bends the SDF, so gradient can get higher than 1:1\n}\n\n\nvoid rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h + texture(iChannel1, p.xz * 0.05).x * 0.9;\n}\n\nint mat = -1;\n\nfloat sdLights(vec3 p){\n    p.y -= 2.5;\n    vec3 polar = vec3(atan(p.x,p.z),p.y,length(p.xz));\n    rotY(p, 0.5);\n    float d = mod(polar.x, 3.14) - 0.5;\n    float t = length(vec3(polar.z-2.5, p.y, fract(2.*polar.x)-.5)) - .3;\n    return t;\n    \n}\n\nfloat sdf(vec3 p){\n    float dist = TreeSDF(p * 0.6);\n    if(dist < EP){\n        mat = 0;\n    }\n    float plane = sdPlane(p, vec3(0.0, 1.0, 0.0), 2.5);\n    if(dist > plane){\n        dist = plane;\n        mat = 1;\n    }\n    float box1 = sdBox(p + vec3(0.0, 0.0, -15.0), vec3(20.0, 30.5, 0.5));\n    if(dist > box1){\n        dist = box1;\n        mat = 2;\n    }\n    float c = 25.0;\n    p.x = mod(p.x+0.5*c,c)-0.5*c;\n    float box2 = sdBox(p + vec3(0.0, 5.0, 30.0), vec3(8.0, 20.5, 0.5));\n    if(dist > box2){\n        dist = box2;\n        mat = 2;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 ep = vec2(EP, 0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n        ));\n}\n\nvec3 emissions[LIGHTSTEP];\nvec3 sum[LIGHTSTEP];\n\nvoid march(inout vec3 origin, inout vec3 rayDir, float seed, inout int stepNum){\n    float trvlDist = 0.0;\n    vec3 rayPos = origin;\n    \n    for(int i = 0; i < 80; i++){\n        float dist = sdf(rayPos);\n        if(dist < EP){\n            vec3 norm = getNormal(rayPos);\n            float fresnel = dot(norm, rayDir);\n            //rayDir = cosWeightedRandomHemisphereDirection(norm, seed);\n            rayDir = mix(cosWeightedRandomHemisphereDirection(norm, seed), reflect(rayDir, norm), 1.0 - fresnel);\n            //rayDir = cosWeightedRandomHemisphereDirection(norm, seed);\n            origin = rayPos + rayDir * EP * 2.5;\n            if(mat == 0){\n                emissions[stepNum] = max(rayPos.y + 2.0, 0.0) * vec3(0.4, 0.5, 0.4);\n                vec3 surfaceColor = vec3(0.8, 0.9, 0.8);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }else if(mat == 1){\n                emissions[stepNum] = vec3(0.0);\n                vec3 surfaceColor = vec3(0.8, 0.9, 1.0);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }else if(mat == 2){\n                emissions[stepNum] = vec3(5.0, 4.5, 4.0);\n                //emissions[stepNum] = vec3(2.0);\n                vec3 surfaceColor = vec3(1.0, 1.0, 1.0);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }\n            break;\n            \n        }\n        trvlDist += dist;\n        rayPos = origin + rayDir * trvlDist;\n    }\n    stepNum ++;\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy- 0.5) * 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float fov = 0.8;\n    float dof = 0.35;\n    \n    vec3 cameraPos = vec3(0.0, -0.1, 10.0);\n    //vec3 cameraPos = vec3(cos(iTime) * 10.0, -0.1, sin(iTime) * 10.0);\n\n    vec3 targetPos = vec3(0.0, 1.3, 0.5);\n    float focusdistance = length(targetPos-cameraPos) * fov;\n    \n    vec3 up = vec3(0,1,0);\n    vec3 front = normalize(targetPos-cameraPos);\n    vec3 right = normalize(cross(up, front));\n    up = normalize(cross(front, right));\n\n    float seed = uv.x + fract(uv.y * 18753.43121412313) + fract(12.12345314312)*iTime;\n    vec3 finalCol = vec3(0.0);\n    for(int j = 0; j < 1; j++){\n        vec3 col = vec3(0.0);\n        for(int i = 0; i < LIGHTSTEP; i++){\n            emissions[i] = vec3(0.0);\n            sum[i] = vec3(0.0);\n        }\n        vec3 rayPos = cameraPos;\n\n        vec3 rand = (hash3(seed * float(j+1) + iTime) * 2.0 - 1.0);\n\n        vec3 voff = sqrt(rand.x)*(right*sin(rand.y*6.283)+up*cos(rand.z*6.283))*dof;\n        vec3 cameraPosNew = cameraPos - voff;\n        vec3 rayDir = normalize((up * uv.y) + (front) * fov + (right * uv.x) + voff*fov/focusdistance );\n\n        int stepNum = 0;\n        for(int i = 0; i < LIGHTSTEP; i++){\n            march(cameraPosNew, rayDir, seed + iTime * 1.0, stepNum);\n        }\n        for(int i = LIGHTSTEP-1; i >= 0; i--){\n            col = emissions[i] + sum[i] * col;\n        }\n        finalCol = mix(finalCol, col, 1.0f / float(j+1));\n    }\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    finalCol = mix(lastFrameColor, finalCol, 1.0f / float(iFrame+1));\n    \n    if(iTime < 2.0){\n        fragColor = vec4(vec3(0.0),1.0);\n    }else{\n        fragColor = vec4(finalCol,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}