{"ver":"0.1","info":{"id":"wlV3zW","date":"1578478693","viewed":61,"name":"TransferWise logo 3d","username":"kow","description":"Raymarching the TransferWise logo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","logo","transferwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N = 12;\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdLogo(vec2 p) {\n    vec2 center = vec2(-.45, .5);\n    float scale = 1.;\n    vec2 v0 = center - vec2(-0.127,0) * scale;\n    vec2 v1 = center - vec2(-0.295,0.262) * scale;\n    vec2 v2 = center - vec2(-0,0.524) * scale;\n    vec2 v3 = center - vec2(-0.51,0.524) * scale;\n    vec2 v4 = center - vec2(-0.558,0.419) * scale;\n    vec2 v5 = center - vec2(-0.277,0.419) * scale;\n    vec2 v6 = center - vec2(-0.447,0.261) * scale;\n    vec2 v7 = center - vec2(-0.348,0.105) * scale;\n    vec2 v8 = center - vec2(-0.812,0.105) * scale;\n    vec2 v9 = center - vec2(-0.404,1) * scale;\n    vec2 v10 = center - vec2(-0.544,1) * scale;\n    vec2 v11 = center - vec2(-1,0) * scale;\n\n    // add more points\n    vec2[] poly = vec2[](v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);\n\n\treturn sdPoly(poly, p);\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 q = pos - vec3(.0, -.5, .0);\n    float logo = opExtrussion(q, sdLogo( q.xy ), 0.15 );\n    //float plane = sdPlane(pos, normalize(vec4(0, 1, 0, -1.5)));\n    return min(logo, 10.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec3 ro = vec3(0.0, -.25, -1.0);\n        vec3 rd = normalize(vec3(p.x, p.y, 1.));\n\n        float t = 0.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<10.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(sin(iTime)*5., 3.0, -1. - cos(iTime) * .5));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 32.0 );\n            col = vec3(0.025,0.05,0.08) + dif*sha*vec3(.0, 0.09, 0.9);\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}