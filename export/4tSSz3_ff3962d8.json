{"ver":"0.1","info":{"id":"4tSSz3","date":"1445287469","viewed":133,"name":"Ray Marched Fractals","username":"sanchitgarg","description":"fractals","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 100.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n\n//Comment SHADOW_SCALE to remove shadow\n//#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n//#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n#define LAMBERT_COLOR\n//-------------------------------------------------------\n\n\n\n//------------------Ray Casting Modes--------------------\n//#define NAIVE_RAY_CAST\n#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//--------Distance functions for various objects---------\nfloat sdPlane (vec3 p, float y)\n{\n\treturn p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//for fractals\nfloat sdCross( in vec3 p)\n{\n    float v = 1.5;\n\tfloat da = sdBox(p.xyz,vec3(1000.0, v, v));\n  \tfloat db = sdBox(p.yzx,vec3(v, 1000.0, v));\n\tfloat dc = sdBox(p.zxy,vec3(v, v, 1000.0));\n  \treturn min(da,min(db,dc));\n}\n\n//--------------------CSG Operations---------------------\nfloat opDifference( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat opIntersect( float d1, float d2 )\n{\n    return max(d2,d1);\n}\n\nfloat opBlend(float a, float b, float blendRadius) {\n    float c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return ((c) * a + (1.0-c) * b) - blendRadius * c * (1.0 - c);\n}\n\n//Function to create the actual scene\nfloat disEstimator(vec3 pt)\n{\n    float dis = sdBox(pt, vec3(1.0));\n   \tfloat s = 0.5;\n    \n    for( int m=0; m<3; m++ )\n   \t{\n        vec3 a = mod( pt*s, 2.0 )-1.0;\n      \ts *= 5.0;\n\t\tvec3 r = 5.0 - 5.0*abs(a);\n        float c = sdCross(r)/s;\n      \tdis = max(dis,-c);\n   \t}\n\n    return dis;\n}\n\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy) - disEstimator(pos-eps.xyy),\n\t    disEstimator(pos+eps.yxy) - disEstimator(pos-eps.yxy),\n\t    disEstimator(pos+eps.yyx) - disEstimator(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(5.0,5.0,0.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.01;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol + 0.01;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps)\n{\n    #ifdef DEPTH_COLOR\n\t\treturn vec3(abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n\treturn vec3(0.0);\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        float dis = disEstimator(pt);\n        \n     \tif(dis < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps));\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\nvec3 sphericalRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n   \t\n//    float dt = disEstimator(pt);\n\tfloat t = 0.0;\n    \n    for(int i = 1; i<MAX_STEPS; i++)\n\t{\n        pt = ro + t * rd;\n        \n        float dt = disEstimator(pt);\n        \n     \tif(dt < EPSILON)\n        {   \n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(float(i), MAX_STEPS));\n        }\n        \n\t\tt += dt;\n        \n        if(t > MAX_DIS)\n  \t    {\n         \treturn vec3(0.0);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}