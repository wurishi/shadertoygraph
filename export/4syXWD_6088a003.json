{"ver":"0.1","info":{"id":"4syXWD","date":"1464298110","viewed":330,"name":"Constant Width Edge Demo","username":"Xerophyte","description":"A pretty crappy demo of how you can do some sort of constant width borders between texture regions procedurally in a shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bad","terrible","horrible","useless","nogood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parameters and crap\n\n// Scale of the texture\nconst float texture_scale = 5.0;\n\n// Number of distinct bands that we divide the texture range into.\nconst float bands = 10.0;\n\n// Width of edges between bands, in pixels.\nconst float edge_width = 2.0;\n\n// Octaves of summed noise to use for the texture.\nconst int octaves = 5;\n\n// Colors\nconst vec3 color_0 = vec3(0.8, 0.3, 0.1);\nconst vec3 color_1 = vec3(0.1, 0.3, 0.6);\n\n// Morgan McGuire's shader hash and noise implementation\nfloat hash(in float n) { return fract(sin(n) * 1e4); }\nfloat hash(in vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(in float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Summed octave noise\nfloat summed_noise(in vec2 uv) {\n    float sum_noise = 0.0;\n    float weight = 1.0;\n    float frequency = 1.0;\n    \n    vec4 time = vec4(\n        cos(0.0021 * iTime + 2.3461),\n        sin(0.0411 * iTime + 0.1241),\n        cos(0.7865 * iTime + 1.2350),\n    \tsin(1.2421 * iTime + 0.7853)\n    );\n    \n    for (int octave = 0 ; octave < octaves ; ++octave ) {\n        float o = float(octave);\n        o = 1431.0 * o * o + 74.121 * o + 12.24;\n        \n        vec4 translation_weights_u = 0.048 * vec4(\n        \t-50.94 * mod(o, 1.6623),\n        \t7.752  * mod(o, 3.1367),\n        \t-3.775 * mod(o, 5.2141),\n        \t0.913  * mod(o, 7.9832)\n\t\t);\n        vec4 translation_weights_v = 0.030 * vec4(\n        \t22.43  * mod(o, 0.7472),\n        \t-9.220 * mod(o, 2.9782),\n        \t-4.870 * mod(o, 7.2122),\n        \t0.840  * mod(o, 5.5672)\n\t\t);\n        vec2 shift = vec2(dot(translation_weights_u, time),\n                          dot(translation_weights_v, time));\n        \n        sum_noise += weight * (noise(frequency * (uv - 0.5 + shift)));\n        weight = 0.5 * weight;\n        \n        vec4 frequency_weights = 0.05 * vec4(\n        \t14.20 * mod(o, 2.085),\n        \t4.210 * mod(o, 6.325),\n        \t1.290 * mod(o, 5.211),\n        \t0.821 * mod(o, 2.760)\n\t\t);\n        \n        frequency = 2.0 * frequency + dot(frequency_weights, time);\n    }\n    return 0.5 * (sum_noise + 1.0 - weight) / (1.0 - weight);\n}\n\nvec2 texture_mapping(in vec2 pixel) {\n    return texture_scale * (pixel - 0.5 * iResolution.xy) / iResolution.xy;\n}\n\n// Summed octave noise segmented into N bands.\nfloat segment(in vec2 pixel, in float bands) {\n    return floor(summed_noise(texture_mapping(pixel)) * bands); \n}\n\n// Cruddy edge detection of the above noise segments.\nfloat edge_weight(in vec2 pixel, in float edge_width, in float bands, out float pixel_segment) {\n    \n    // 4 samples around the point in a cross pattern. You could take more, do this stochastically, etc.\n    edge_width = 0.5 * edge_width;\n    float segment_px = segment(pixel + vec2(edge_width, 0.0), bands);\n    float segment_py = segment(pixel + vec2(0.0, edge_width), bands);\n    float segment_nx = segment(pixel - vec2(edge_width, 0.0), bands);\n    float segment_ny = segment(pixel - vec2(0.0, edge_width), bands);\n        \n    // Return weight 0 if all surrounding segment samples are equal to the segment at the pixel, 1 otherwise.\n    // Note that this is crap: we really want to lerp at the edge a little bit to avoid aliasing. This\n    // requires better proper processing, or an analytic SDF.\n    pixel_segment = segment(pixel, bands);\n    vec4 segments = vec4(pixel_segment);\n    if (segments == vec4(segment_px, segment_py, segment_nx, segment_ny)) {\n        return 0.0;\n    }\n    else {\n        return 1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float segment;\n    float edge = edge_weight(fragCoord.xy, edge_width, bands, segment);\n    \n    // Alternate segment colors\n    vec3 col;\n    if (mod(segment, 2.0) == 0.0) {\n        col = color_0;\n    }\n    else  {\n        col = color_1;\n    }\n    \n    // Black on the edges.\n    col = mix(col, vec3(0.0), edge);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}