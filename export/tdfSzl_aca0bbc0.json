{"ver":"0.1","info":{"id":"tdfSzl","date":"1551866763","viewed":203,"name":"Lorem ipsum 2","username":"postrediori","description":"Second take on 'Lorem ipsum' typesetting. Infinite scroll of the paragraph with not so pretty hyphenation.\n\nCharacter rendering from 'font morph' by @FabriceNeyret2: https://www.shadertoy.com/view/ltcXzs\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["texture","font","loremipsum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iFont iChannel0\n\n#define Hyphen 45\n\nconst int iPhraseLen = 445;\nconst int ivPhraseCodes[445] = int[445](\n    76, 111, 114, 101, 109, 32, 105, 112, 115, 117, 109, 32,\n    100, 111, 108, 111, 114, 32, 115, 105, 116, 32, 97, 109,\n    101, 116, 44, 32, 99, 111, 110, 115, 101, 99, 116, 101,\n    116, 117, 114, 32, 97, 100, 105, 112, 105, 115, 99, 105,\n    110, 103, 32, 101, 108, 105, 116, 44, 32, 115, 101, 100,\n    32, 100, 111, 32, 101, 105, 117, 115, 109, 111, 100, 32,\n    116, 101, 109, 112, 111, 114, 32, 105, 110, 99, 105, 100,\n    105, 100, 117, 110, 116, 32, 117, 116, 32, 108, 97, 98,\n    111, 114, 101, 32, 101, 116, 32, 100, 111, 108, 111, 114,\n    101, 32, 109, 97, 103, 110, 97, 32, 97, 108, 105, 113, 117,\n    97, 46, 32, 85, 116, 32, 101, 110, 105, 109, 32, 97, 100,\n    32, 109, 105, 110, 105, 109, 32, 118, 101, 110, 105, 97,\n    109, 44, 32, 113, 117, 105, 115, 32, 110, 111, 115, 116,\n    114, 117, 100, 32, 101, 120, 101, 114, 99, 105, 116, 97,\n    116, 105, 111, 110, 32, 117, 108, 108, 97, 109, 99, 111,\n    32, 108, 97, 98, 111, 114, 105, 115, 32, 110, 105, 115,\n    105, 32, 117, 116, 32, 97, 108, 105, 113, 117, 105, 112,\n    32, 101, 120, 32, 101, 97, 32, 99, 111, 109, 109, 111,\n    100, 111, 32, 99, 111, 110, 115, 101, 113, 117, 97, 116,\n    46, 32, 68, 117, 105, 115, 32, 97, 117, 116, 101, 32, 105,\n    114, 117, 114, 101, 32, 100, 111, 108, 111, 114, 32, 105,\n    110, 32, 114, 101, 112, 114, 101, 104, 101, 110, 100, 101,\n    114, 105, 116, 32, 105, 110, 32, 118, 111, 108, 117, 112,\n    116, 97, 116, 101, 32, 118, 101, 108, 105, 116, 32, 101,\n    115, 115, 101, 32, 99, 105, 108, 108, 117, 109, 32, 100,\n    111, 108, 111, 114, 101, 32, 101, 117, 32, 102, 117, 103,\n    105, 97, 116, 32, 110, 117, 108, 108, 97, 32, 112, 97, 114,\n    105, 97, 116, 117, 114, 46, 32, 69, 120, 99, 101, 112, 116,\n    101, 117, 114, 32, 115, 105, 110, 116, 32, 111, 99, 99, 97,\n    101, 99, 97, 116, 32, 99, 117, 112, 105, 100, 97, 116, 97,\n    116, 32, 110, 111, 110, 32, 112, 114, 111, 105, 100, 101,\n    110, 116, 44, 32, 115, 117, 110, 116, 32, 105, 110, 32, 99,\n    117, 108, 112, 97, 32, 113, 117, 105, 32, 111, 102, 102,\n    105, 99, 105, 97, 32, 100, 101, 115, 101, 114, 117, 110,\n    116, 32, 109, 111, 108, 108, 105, 116, 32, 97, 110, 105,\n    109, 32, 105, 100, 32, 101, 115, 116, 32, 108, 97, 98, 111,\n    114, 117, 109, 46);\n\nconst int iColumns = 18;\nconst int iRows = iPhraseLen / iColumns + 1;\n\n// Get character with ASCII code 'ord'\nvec4 Character(vec2 uv, int ord)\n{\n    if (uv.x<0. || uv.x>1.\n        || uv.y<0. || uv.y>1.)\n    {\n        return vec4(0.,0.,0.,1e5);\n    }\n    \n    //return texture(iFont, fract(vec2(ord%16, 15-ord/16) / 16.) + uv / 16.);\n\t\n    //return textureLod(iFont, fract(vec2(ord%16, 15-ord/16) / 16.) + uv/16.\n    //                  , log2(length(fwidth(uv/16.*iResolution.xy))) );\n    \n    return textureGrad(iFont, fract(vec2(ord%16, 15-ord/16) / 16.) + uv/16.\n                       , dFdx(uv/16.),dFdy(uv/16.));\n}\n\n// Print a paragraph of text from 'ivPhraseCodes' array\nvec4 Paragraph(vec2 uv)\n{\n    vec4 cc = vec4(0.);\n    \n    int idx = 0; // Character index\n  \tfor (int j=0; j<iRows; j++)\n  \t{\n      \tfor (int i=0; i<iColumns; i++, idx++)\n      \t{\n          \tcc += Character(uv, ivPhraseCodes[idx]).r;\n          \tuv.x-=.5; // Move caret to the left\n      \t}\n        \n        // Add hyphenation\n      \tif (ivPhraseCodes[idx - 1] != 32)\n      \t{\n          \tcc += Character(uv, Hyphen).r;\n      \t}\n\n        // New line\n      \tuv.y += 1.;\n      \tuv.x += float(iColumns) * .5;\n  \t}\n    \n    return cc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    vec4 cc = smoothstep(.5, .49, vec4(1.));\n  \n    // Screen contains 8 rows and 8*2 columns\n  \tuv *= 8.;\n    \n    // Calculate vertical scroll\n    //\n    // Add 8 to iTime and then substract 8 so that the text will appear\n    // from the bottom of the screen after showing all lines.\n    //\n    // Eight rows between paragraphs mean the screen\n    // will be empty between the two paragraphs.\n    //\n    const int iParagraphMargin = 8;\n    float scroll = mod(iTime + 8., float(iRows + iParagraphMargin)) - 8.;\n    \n    uv.y -= 7. + scroll; // Scroll the top row\n  \tuv.x -= 2.; // Left aligh\n  \t\n  \tcc += Paragraph(uv);\n    \n    // This is to get rid of flickering\n    // between text lines\n    cc = smoothstep(0., 0.5, cc - 0.5);\n       \n    fragColor = vec4(vec3(cc), 1.);\n}","name":"Image","description":"","type":"image"}]}