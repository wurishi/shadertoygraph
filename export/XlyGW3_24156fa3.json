{"ver":"0.1","info":{"id":"XlyGW3","date":"1476981249","viewed":370,"name":"Edge Detected Self-Similarity","username":"metabog","description":"Self-similarity matrix reveals information about the structure of the song. Let it run for a while to see structure appear. It's the same as my other one, but this one is edge enhanced. ","likes":6,"published":1,"flags":96,"usePreview":0,"tags":["music","audio","matrix","analysis","information","self","informationretrieval","similarity","structure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//*****THIS CODE LITERALLY RIPPED FROM https://www.shadertoy.com/view/ldsSWr *******\n\n// Basic edge detection via convolution\n// Ken Slade - ken.slade@gmail.com\n// at https://www.shadertoy.com/view/ldsSWr\n\n// Based on original Sobel shader by:\n// Jeroen Baert - jeroen.baert@cs.kuleuven.be (www.forceflow.be)\n// at https://www.shadertoy.com/view/Xdf3Rf\n\n//options are edge, colorEdge, or trueColorEdge\n#define EDGE_FUNC trueColorEdge\n\n//options are KAYYALI_NESW, KAYYALI_SENW, PREWITT, ROBERTSCROSS, SCHARR, or SOBEL\n#define KAYYALI_NESW\n\n// Use these parameters to fiddle with settings\n#ifdef SCHARR\n#define STEP 0.15\n#else\n#define STEP 1.0\n#endif\n\n\n#ifdef KAYYALI_NESW\nconst mat3 kayyali_NESW = mat3(-6.0, 0.0, 6.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   6.0, 0.0, -6.0);\n#endif\n#ifdef KAYYALI_SENW\nconst mat3 kayyali_SENW = mat3(6.0, 0.0, -6.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   -6.0, 0.0, 6.0);\n#endif\n#ifdef PREWITT\n// Prewitt masks (see http://en.wikipedia.org/wiki/Prewitt_operator)\nconst mat3 prewittKernelX = mat3(-1.0, 0.0, 1.0,\n\t\t\t\t\t\t\t\t -1.0, 0.0, 1.0,\n\t\t\t\t\t\t\t\t -1.0, 0.0, 1.0);\n\nconst mat3 prewittKernelY = mat3(1.0, 1.0, 1.0,\n\t\t\t\t\t\t\t\t 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t -1.0, -1.0, -1.0);\n#endif\n#ifdef ROBERTSCROSS\n// Roberts Cross masks (see http://en.wikipedia.org/wiki/Roberts_cross)\nconst mat3 robertsCrossKernelX = mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, -1.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, 0.0, 0.0);\nconst mat3 robertsCrossKernelY = mat3(0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t\t\t  -1.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, 0.0, 0.0);\n#endif\n#ifdef SCHARR\n// Scharr masks (see http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators)\nconst mat3 scharrKernelX = mat3(3.0, 10.0, 3.0,\n\t\t\t\t\t\t\t\t0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t-3.0, -10.0, -3.0);\n\nconst mat3 scharrKernelY = mat3(3.0, 0.0, -3.0,\n\t\t\t\t\t\t\t\t10.0, 0.0, -10.0,\n\t\t\t\t\t\t\t\t3.0, 0.0, -3.0);\n#endif\n#ifdef SOBEL\n// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\nconst mat3 sobelKernelX = mat3(1.0, 0.0, -1.0,\n\t\t\t\t\t\t\t   2.0, 0.0, -2.0,\n\t\t\t\t\t\t\t   1.0, 0.0, -1.0);\n\nconst mat3 sobelKernelY = mat3(-1.0, -2.0, -1.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   1.0, 2.0, 1.0);\n#endif\n\n//performs a convolution on an image with the given kernel\nfloat convolve(mat3 kernel, mat3 image) {\n\tfloat result = 0.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tresult += kernel[i][j]*image[i][j];\n\t\t}\n\t}\n\treturn result;\n}\n\n//helper function for colorEdge()\nfloat convolveComponent(mat3 kernelX, mat3 kernelY, mat3 image) {\n\tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\treturn clamp(length(result), 0.0, 255.0);\n}\n\n//returns color edges using the separated color components for the measure of intensity\n//for each color component instead of using the same intensity for all three.  This results\n//in false color edges when transitioning from one color to another, but true colors when\n//the transition is from black to color (or color to black).\nvec4 colorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {\n\t//get samples around pixel\n\tvec4 colors[9];\n\tcolors[0] = texture(iChannel0,center + vec2(-stepx,stepy));\n\tcolors[1] = texture(iChannel0,center + vec2(0,stepy));\n\tcolors[2] = texture(iChannel0,center + vec2(stepx,stepy));\n\tcolors[3] = texture(iChannel0,center + vec2(-stepx,0));\n\tcolors[4] = texture(iChannel0,center);\n\tcolors[5] = texture(iChannel0,center + vec2(stepx,0));\n\tcolors[6] = texture(iChannel0,center + vec2(-stepx,-stepy));\n\tcolors[7] = texture(iChannel0,center + vec2(0,-stepy));\n\tcolors[8] = texture(iChannel0,center + vec2(stepx,-stepy));\n\t\n\tmat3 imageR, imageG, imageB, imageA;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\timageR[i][j] = colors[i*3+j].r;\n\t\t\timageG[i][j] = colors[i*3+j].g;\n\t\t\timageB[i][j] = colors[i*3+j].b;\n\t\t\timageA[i][j] = colors[i*3+j].a;\n\t\t}\n\t}\n\t\n\tvec4 color;\n\tcolor.r = convolveComponent(kernelX, kernelY, imageR);\n\tcolor.g = convolveComponent(kernelX, kernelY, imageG);\n\tcolor.b = convolveComponent(kernelX, kernelY, imageB);\n\tcolor.a = convolveComponent(kernelX, kernelY, imageA);\n\t\n\treturn color;\n}\n\n//finds edges where fragment intensity changes from a higher value to a lower one (or\n//vice versa).\nvec4 edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){\n\t// get samples around pixel\n\tmat3 image = mat3(length(texture(iChannel0,center + vec2(-stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,-stepy)).rgb));\n \tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\t\n    float color = clamp(length(result), 0.0, 255.0);\n    return vec4(color);\n}\n\n//Colors edges using the actual color for the fragment at this location\nvec4 trueColorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {\n\tvec4 edgeVal = edge(stepx, stepy, center, kernelX, kernelY);\n\treturn edgeVal * texture(iChannel0,center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n#ifdef KAYYALI_NESW\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tkayyali_NESW, kayyali_NESW);\n#endif\n#ifdef KAYYALI_SENW\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tkayyali_SENW, kayyali_SENW);\n#endif\n#ifdef PREWITT\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tprewittKernelX, prewittKernelY);\n#endif\n#ifdef ROBERTSCROSS\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\trobertsCrossKernelX, robertsCrossKernelY);\n#endif\n#ifdef SOBEL\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tsobelKernelX, sobelKernelY);\n#endif\n#ifdef SCHARR\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tscharrKernelX, scharrKernelY);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdBGWR","filepath":"https://soundcloud.com/madcoil/madcoil-trool","previewfilepath":"https://soundcloud.com/madcoil/madcoil-trool","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 read(vec2 fragCoord, vec2 pos)\n{\n    return texture(iChannel0,(fragCoord+pos)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iTime<0.2)\n    {\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n    \n \t\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tfloat progress = iTime/354.0; //this is song length in seconds!\n        float xprog = progress*iResolution.x;\n    \n    \tfloat val = 0.0; \n    \tvec4 current = read(fragCoord.xy,vec2(0.0,0.0));\n    \n   \t    vec4 s = texture(iChannel1, vec2(uv.y,0.0));\n\t\tif(fragCoord.x<xprog+0.5 && fragCoord.x>xprog-0.5)\n        \tval = s.x;\n        \n    \tfragColor = current + vec4(1.0)*val*0.3;\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* \nWhat is this?\n\nA self-similarity matrix is a way of uncovering useful information about musical sections in a song. \nFor example, you can clearly see the relationship between verse, chorus, etc. This is done by comparing\neveryt FFT frame with every other FFT frame. I used cosine distance as a metric. \n\nOnce you have a SSM you can extract the boundaries by calculating novelty functions on the matrix,\ndecomposition, etc. One easy way is to run a sort of edge detector left-to-right, which will spike \nat boundaries.\n\nAs you'd expect, the diagonal of the matrix is the most similar, so it's all maximum valued. You\ncan also see 'off-diagonals', which show paths in the song that are similar. \n\nSimilarity matrix between two different songs is also the first step in doing Dynamic Time Warping\nfor automatic time alignment (aligning two versions of the same song).\n\nAfter the shader runs for a while you should be able to clearly see the distinct sections of the \ncool song. :)\n\nIt could be much faster if I didn't calculate all the distances again every frame but saved them instead,\nhowever I am too lazy.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float progress = iTime/354.0; //this is song length in seconds!\n\tprogress = clamp(progress,0.1,1.0);\n    \n    vec2 coord = (fragCoord.xy*progress)/iResolution.xy;    \n    float sum1 = 0.0;\n    float sum2 = 0.0;\n    float sum3 = 0.0;\n\n    //cosine distance\n    \n    for(float i=0.0; i<1.0; i+=0.05) //lower increment for higher res... but slower\n    {\n        float v1 = texture(iChannel0, vec2(coord.x,i)).x;\n        float v2 = texture(iChannel0, vec2(coord.y,i)).x;\n        sum1+=v1*v2;\n        sum2+=v1*v1;\n        sum3+=v2*v2;\n    }\n\t\n    sum2 = sqrt(sum2);\n    sum3 = sqrt(sum3);\n    \n    float cdist = sum1/(sum2*sum3 + 0.001);\n\tcdist = pow(cdist,256.0); //accentuate\n\tvec4 col = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    fragColor = clamp(col*cdist +\n                vec4(0.1),vec4(0.0),vec4(1.0))*2.0;\n}","name":"Buf B","description":"","type":"buffer"}]}