{"ver":"0.1","info":{"id":"csGcDd","date":"1696797268","viewed":348,"name":"3D Gaussian Splatting","username":"chronos","description":"I hear splatted gaussians are popular these days :)\nThe gaussian appears to be 3D but is actually drawn as a 2D gaussian on screen.\nThe calculations are directly based on the ones in the paper, so there is a lot of room to optimize!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","box","gaussian","viewer","splats","splatting"],"hasliked":0,"parentid":"DdyyWV","parentname":"Volumetric 3D Gaussian"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBased on \"EWA Volume Splatting\" paper   (EWA = Elliptical Weighted Average)\nby Matthias Zwicker, Hanspeter Pfister, Jeroen van Baar and Markus Gross\nhttps://cgl.ethz.ch/Downloads/Publications/Papers/2001/p_Zwi01b.pdf\n\nNote, there seems to be a newer version here (2002):\nhttps://www.cs.umd.edu/~zwicker/publications/EWASplatting-TVCG02.pdf\n\nI opted to implement this straightforwardly and directly from the paper,\nas a consequence there's a lot of wasteful computation being performed.\nParticularly because most operations uses matrix multiplication where not necessary.\nEven so they could be rearranged in a more efficient manner.\n\nFor example:\nFor rotations, inverse(R) = traspose(R), and det(R) = det(inv(R)) = 1\nScaling can be performed by vector multiplication, since they are diagonal matrices here.\nmatrices that are repeated, like in: u = v^T *M^T * M * v can instead be computed as \nw = M * v; u = dot(w, w)\netc...\n\n// Notation from paper:\n\nt_k = center of the gaussian in world space\nu = phi(t) = Wt + d = viewing transformation ( for matrix W and translation vector d)\nu_k = phi(t_k) = center of gaussian in camera space\n\nm(u) = perspective transform ( z division )\nx_k = m(u_k) = center of gaussian in ray space ( screenspace + depth, after projection)\nx_hat = screenspace coordinates\nx_hat_k = gaussian center in screenspace\n\nThis method is used for rendering 3D Gaussians in the paper\n\"3D Gaussian Splatting for Real-Time Radiance Field Rendering\"\nhttps://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_high.pdf\n\n*/\n\n// Jacobian for linear approximation of perspective transform (z-divide)\nmat3 JacobianOfM_u(vec3 u)\n{\n    vec3 last_row = u / length(u);\n    \n    mat3 J = mat3\n    (\n        1./u.z, 0.,                     last_row.x,\n        0., 1./u.z,                     last_row.y,\n        -u.x/(u.z*u.z), -u.y/(u.z*u.z), last_row.z\n    );\n    \n    return J;\n}\n\n// Based on formula from wikipedia :)\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    float c = cos(angle), s = sin(angle);\n    return\n        mat3(c) + \n        s * mat3(0, axis.z, -axis.y, -axis.z, 0, axis.x, axis.y, -axis.x, 0) + \n        (1.-c) * outerProduct(axis, axis);\n}\n\nfloat gaussian(mat3 V, vec3 x) // 3D gaussian\n{\n    return exp(-.5 * dot(x, inverse(V)*x)) / (2. * PI *sqrt(determinant(V)));\n}\n\nfloat gaussian(mat2 V, vec2 x) // 2D gaussian\n{\n    return exp(-.5 * dot(x, inverse(V)*x)) / (2. * PI *sqrt(determinant(V)));\n}\n\n// Computes eq 21:\n//\n//     G_V_hat_k(x_hat - x_hat_k) / (det(inv(J)) * det(inv(W))\n//\n// But starting from gaussian center in cameraspace\n//\nfloat gaussianSplat(vec3 u_k, vec3 scale, mat3 R, vec2 x_hat)\n{\n    // Camera rotation\n    mat3 W = transpose(R);\n    float invDetW = determinant(inverse(W)); // For rotation matrices, the inverse is the transpose and the determinant is 1\n\n    // In the paper, u.z is positive in the forward direction in camera space\n    u_k.z *= -1.;\n    \n    // Compute ray space center of gaussian (eq 15 and 17)\n    vec3 x_k = vec3(u_k.x/u_k.z, u_k.y/u_k.z, length(u_k));\n    \n    // Compute linear approximation to perspective transform  (eq 18)\n    mat3 J = JacobianOfM_u(u_k);\n    float invDetJ = determinant(inverse(J));\n    \n    vec2 x_hat_k = x_k.xy;\n\n    vec2 x = x_hat - x_hat_k;\n    \n    // Compute 3D variace matrix\n    mat3 S = mat3(scale.x,0,0, 0,scale.y,0, 0,0,scale.z);\n    mat3 V_dprime_k = S*transpose(S);\n    mat3 V_prime_k = W * V_dprime_k * transpose(W);\n    mat3 V_k = J * V_prime_k * transpose(J);\n    \n    mat2 V_hat_k = mat2(V_k[0].xy, V_k[1].xy);        // 3D to 2D integration for gaussians\n    \n    return gaussian(V_hat_k, x) / (invDetJ * invDetW);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.; // Just a convenient way to scale time\n\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Idle mouse animation\n    if(length(iMouse.xy) < 10.)\n    {\n        mouse = vec2(cos(time), sin(time));\n    }\n    \n    float pix_size = 2. / iResolution.y; // Unused atm\n    \n    float focal = 1.; // TODO: Change perspective transform and u_k to allow focal != 1.\n\n    vec3 Camera_Position = vec3(0, 0, 3. + 1. * sin(time / 2.));\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    mat3 Tilt = RotationMatrix(vec3(1,0,0), -mouse.y);\n    \n    float angle = -mouse.x * PI;\n\n    vec3 color = vec3(0);\n\n    vec3 box_center = vec3(0.25*cos(iTime), 0, 0); // t_k\n    float radius = 1.;\n\n    vec3 axis = normalize(vec3(0,1,0));\n    mat3 Camera_Rotation = RotationMatrix(axis, angle) * Tilt;\n\n    vec3 ro = Camera_Rotation * Camera_Position; // ray origin world space\n    \n    // Ray tracing box & splatting gaussian\n    {\n        vec2 T = RayBox(ro, Camera_Rotation * rd, box_center, vec3(radius));\n\n        // Parameters for ray entering and ray exiting box for volumetric calculations.\n        float t_enter = min(T.x, T.y);\n        float t_exit = max(T.x, T.y);\n        float t = T.x;\n        if(T.t >= 0. && (T.y < T.x)) t = T.y;\n\n        // Draw box\n        if(t > 0.)\n        {\n            vec3 p = Camera_Rotation*rd * t + ro;\n            vec3 pos_color = (normalize(p - box_center) + 1.) / 2.;\n            float opacity = 0.9;\n            color += exp(-2.5*(T.y - T.x)) * opacity * pos_color;\n        }\n        \n        vec3 gaussian_center = box_center; //vec3(0,0,0); // t_k\n        vec3 gaussian_scale = vec3(0.4, 0.1, 0.2);\n        \n        // Convert world space center (t_k) to cameraspace center (u_k)\n        mat3 W = transpose(Camera_Rotation);\n        vec3 d = - Camera_Position;\n        vec3 u_k = W * gaussian_center + d;\n        \n        // Splat the gaussian!\n        if(u_k.z < 0.) \n            color += gaussianSplat(u_k, gaussian_scale, Camera_Rotation, uv);\n            \n            \n        // Draw center of gaussian as green dot    \n        T = RaySphere(ro, Camera_Rotation * rd, gaussian_center, 0.05);\n        if(T.x > 0.)\n        {\n            color = vec3(0,1,0);\n        }\n        \n        // Draw center of box as blue dot\n        T = RaySphere(ro, Camera_Rotation * rd, box_center, 0.025);\n        if(T.x > 0.)\n        {\n            color = vec3(1,0,0);\n        }\n    }\n    \n    color = tanh(color);\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    \n    // Project p onto axis:\n    vec3 proj = dot(axis, p) * axis;\n    \n    // Reject p from axis:\n    vec3 rjct = p - proj;\n    \n    // Construct helper axes ( such that cross(a, b) = axis ):\n    // Constructing the axes un-normalized allows up to skip multiplication by length(rjct) later\n    vec3 a = /*normalize*/(rjct);\n    vec3 b = cross(axis, a);\n    \n    vec3 result = // length(rjct) *\n        (cos(angle) * a + sin(angle) * b) + proj;\n    \n    return result;\n}\n\n\nvec3 quadratic_formula(float a, float b, float c)\n{\n    // 0 = b * x + c\n    // x = (0 - c) / b\n\n    if( a == 0.) return vec3(-c / b, 0, 0);\n\n    float discriminant = b * b - 4. * a * c;\n\n    float disc = sqrt(abs(discriminant));\n\n    vec3 result = \n        vec3(\n            (-b + disc) / (2. * a),\n            (-b - disc) / (2. * a),\n            float(discriminant > 0.)\n        );\n\n    return result;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    // o = ro - center\n    // p = o + rd * t\n    // dot(p, p) = r * r\n    // dot(o + rd * t, o + rd * t) = r * r\n    // dot(o,o) - r * r + 2. * t * dot(o, rd) + t * t * dot(rd, rd) = 0\n    \n    vec3 o = ro - center;\n    \n    float a = dot(rd, rd);\n    float b = 2. * dot(o, rd);\n    float c = dot(o, o) - radius * radius;\n    \n    float discriminant = b * b - 4. * a * c;\n    \n    if(discriminant < 0.)\n        return vec2(-1);\n    \n    float t1 = .5 * (sqrt(abs(discriminant)) - b) / a;\n    float t2 = .5 * (-sqrt(abs(discriminant)) - b) / a;\n    \n    float t_min = min(t1, t2);\n    float t_max = max(t1, t2);\n    \n    return vec2(t_min, t_max);\n}\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 center, vec3 normal)\n{\n    // dot(ro - center, normal) + t * dot(rd, normal) = 0.\n    return -dot(ro - center, normal) / dot(rd, normal);\n}\n\nvec2 RayBox(vec3 ro, vec3 rd, vec3 center, vec3 halfextents)\n{\n    vec3 t1, t2;\n    \n    // X planes\n    vec3 N = vec3(1, 0, 0);\n    t1.x = RayPlane(ro, rd, center + N * halfextents.x,  N);\n    t2.x = RayPlane(ro, rd, center - N * halfextents.x, -N);\n    \n    // Y planes\n    N = vec3(0, 1, 0);\n    t1.y = RayPlane(ro, rd, center + N * halfextents.y,  N);\n    t2.y = RayPlane(ro, rd, center - N * halfextents.y, -N);\n    \n    // Z planes\n    N = vec3(0, 0, 1);\n    t1.z = RayPlane(ro, rd, center + N * halfextents.z,  N);\n    t2.z = RayPlane(ro, rd, center - N * halfextents.z, -N);\n\n    float t_min = -1.;\n    float t_max = -1.;\n    vec3 p = vec3(0);\n    float pmax = 9e9;\n    \n    vec3 o = (ro - center);\n    \n    const float eps = 1e-3;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        p = abs(t1[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t1[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t1[i]; }\n        if(((t1[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t1[i]; }\n   \n        p = abs(t2[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t2[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t2[i]; }\n        if(((t2[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t2[i]; }\n    }\n\n    return vec2(t_min, t_max);\n}\n\nfloat BoxDist(vec3 p, vec3 center, vec3 halfextents)\n{\n    vec3 o = abs(p - center) - halfextents;\n    \n    float d = min(max(o.x, max(o.y, o.z)), 0.);\n    \n    return length(length(max(o, 0.))) + d;\n}\n\nfloat SphereDist(vec3 p, vec3 center, float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat gaussian3D(vec3 mean, vec3 scale, vec3 axis, float angle, vec3 p)\n{\n    vec3 v = scale * rot(p - mean, axis, angle);\n    return exp(-dot(v, v));\n}","name":"Common","description":"","type":"common"}]}