{"ver":"0.1","info":{"id":"3tyczw","date":"1612341576","viewed":56,"name":"Fish?","username":"Apeforce","description":"line light","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"ts3fWB","parentname":"Line Light Balls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camera_direction(vec2 uv) {\n    vec3 camera_right = vec3(1.0, 0.0, 0.0);\n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = vec3(0.0, 0.0, 1.0);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec2 c = vec2(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0);\n    vec3 d = normalize(camera_right * c.x * aspect + camera_up * c.y + camera_forward);\n    return d;\n}\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\nfloat raytrace_physical_scene(vec3 p, vec3 d, out vec3 best_normal, out vec3 best_color) {\n    float best_t = -1.0;\n    // First raytrace floor\n    float t_floor = -p.y / d.y;\n    if (t_floor>0.0) {\n        best_t = t_floor;\n        best_normal = vec3(0.0, 1.0, 0.0);\n        best_color = vec3(0.7, 0.7, 0.7);\n    }\n\n    // Raytrace ceiling\n    float t_ceil = (15.0 - p.y) / d.y;\n    if (t_ceil>0.0 && (best_t < 0.0 || t_ceil< best_t)) {\n        best_t = t_ceil;\n        best_normal = vec3(0.0, -1.0, 0.0);\n        best_color = vec3(0.0, 1.0, 0.0);\n    }\n\n    for (int i=0; i<100; i++) {\n        vec4 sphere_state = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 at = sphIntersect(p, d, sphere_state.xyz, sphere_state.w);\n        float t = at.x;\n        if (t>0.0 && (best_t< 0.0 || t<best_t)) {\n            best_t = t;\n            best_color = vec3(1.0, 0.0, 0.0);\n            best_normal = normalize(p + d * t - sphere_state.xyz);\n        }\n    }\n    return best_t;\n}\n\nfloat apply_line_light(vec3 p, vec3 surface_normal, vec3 line_a, vec3 line_b, vec3 line_normal, out vec3 closest_point) {\n\n    vec3 ab = line_b - line_a;\n\n    float t = dot(p-line_a, ab)/dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = line_a + ab * t;\n    closest_point = c;\n    \n    vec3 pc = p-c;\n    float pc_len = length(pc);\n    vec3 l = pc / pc_len;\n    \n\n    // Check if we are behind plane with point=closest point and normal line_normal\n    if (dot(pc, line_normal) < 0.0) {\n        // Seems to be covered by case below!\n        // return 0.0;\n    }\n        \n    // Cull against \"frustum\" of light\n    if (dot(l, line_normal) < cos(45.0 * 2.0 * 3.1415 / 360.0)) {\n        return 0.0;\n    }\n   \n    \n    // We probably want to involve dot(l, line_normal) in shading below\n    \n    // Not sure how we want to do shading... maybe it is\n    float col = 1.0; //max(190.0 * -dot(surface_normal,l) * dot(l, line_normal)/(pc_len*pc_len), 0.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 cp = vec3(0.0, 2.0, -15.0);\n    \n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 mouse_cd = camera_direction(mouse_uv);\n   \n    vec3 cd = camera_direction(uv);\n    \n    // User params, calculated here since I need them to be fun!\n    float angle = iTime * 0.1 * 0.8;\n    const float size = 8.0;\n    vec3 line_a = vec3(cos(angle)*size, 4.0*cos(-iTime * 2.0 * 3.14 * 0.5), sin(angle)*size);\n    vec3 line_b = vec3(-sin(angle)*size, 5.0*sin(-iTime * 2.0 * 3.14 * 0.5), cos(angle)*size);\n    \n    vec3 ideal_normal = vec3(0, -1, 0); //normalize(vec3(0.0, cos(iTime) * 9.0 + 4.5, 0.0) - (line_a + line_b) * 0.5);\n    \n    // Something that is close to ideal_normal and orthogonal to line\n    vec3 line = line_b - line_a;\n    vec3 line_normal = normalize(cross(cross(line, ideal_normal), line));\n    \n    // Do it!    \n    vec3 best_color = vec3(0.0, 0.0, 1.0);\n    vec3 dummy;\n    vec3 best_normal = vec3(0.0);\n    \n    float best_t = raytrace_physical_scene(cp, cd, best_normal, best_color);\n    \n    float ambient = 0.1;\n    \n    best_color = best_color * mix(apply_line_light(cp + cd * best_t, best_normal, line_a, line_b, line_normal, dummy), 1.0, ambient);\n\n    // For debugging we see what point the mouse is hitting in the scene. Then we can use that point (debug_point) for stuff.\n    vec3 debug_point = vec3(0.0), debug_normal = vec3(0.0);\n    float best_debug_t = raytrace_physical_scene(cp, mouse_cd, debug_normal, dummy);\n    if (best_debug_t >= 0.0 && best_debug_t < 10000.0) {\n        debug_point = cp + mouse_cd * best_debug_t;\n\n        // See if current pixel is close, add a white thingy\n        float d = distance(debug_point, cp + cd * best_t);\n        if (d < 0.05*best_debug_t) \n        best_color = vec3(1.0, 0.0, 1.0);\n    }\n        \n    // Line light debug\n    \n    vec4 cyl_hit = cylIntersect(cp, cd, line_a, line_b, 0.11);\n    if (cyl_hit.x > 0.0 && (best_t < 0.0 || cyl_hit.x < best_t)) {\n        best_t = cyl_hit.t;\n        best_color = vec3(2.0, 2.0, 2.0);\n    }\n    \n    // Line light normal debug, place normal at closest point\n    {\n        vec3 closest = vec3(0.0, 7.0, 0.0);\n        apply_line_light(debug_point, debug_normal, line_a, line_b, line_normal, closest);\n        vec3 lm = closest;\n        cyl_hit = cylIntersect(cp, cd, lm, lm + line_normal * 2.0, 0.11);\n        if (cyl_hit.x > 0.0 && (best_t < 0.0 || cyl_hit.x < best_t)) {\n            best_t = cyl_hit.t;\n            best_color = vec3(2.0, 0.0, 2.0);\n        }\n    }\n    \n    fragColor = vec4(best_color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 startState(int x, int y) {\n    if (y==0) {\n        // Sphere positions\n        float a = (float(x)+0.5)/100.0;\n        float PI = 3.1415;\n        return vec4(cos(a*2.0*PI)*10.0, 5.0 + sin(float(x))*4.0, sin(a*2.0*PI)*10.0, 0.5 + sin(a*32.0)*0.1);\n    } else if (y==1) {\n        // Sphere velocities\n        return vec4(0.0);\n    } else {\n        return vec4(1.0, 0.0, 1.0, 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x), y = int(fragCoord.y);\n    if (iFrame == 0) {\n        fragColor = startState(x,y);\n        return;\n    }\n    \n    float dt = iTimeDelta;\n    \n    if (y==0 || y==1) {\n        // This does the simulation of the spheres\n        vec4 pos_radius = texelFetch(iChannel0, ivec2(x, 0), 0);\n        vec3 pos = pos_radius.xyz;\n\t\tfloat radius = pos_radius.w;\n        vec3 vel = texelFetch(iChannel0, ivec2(x, 1), 0).xyz;\n        \n        pos += vel.xyz * dt;\n        vel += vec3(0.0, -9.82*dt, 0.0);\n        \n        if (pos.y < radius) {\n            vel = -vel*0.6;\n            pos.y = radius;\n        }\n        \n        if (y==0) fragColor = vec4(pos, radius);\n        if (y==1) fragColor = vec4(vel, 1.0);\n    } else {\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}