{"ver":"0.1","info":{"id":"3ss3z2","date":"1546897547","viewed":61,"name":"Sekundnik","username":"tomaszborsukowski","description":"Shader tworzy sekundnik, zielona kulka jest środkiem tarczy sekundnika. Niebieska kulka jest wskazówką sekundnika porusza się w linii prostej od środka tarczy (zielona kulka) do krańca tarczy (półksiężyc). Na podstawie Tutorialu GSLS 2D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sekundnik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader sekundnik\n//Ustalanie globalnych wartości\nfloat PI = 3.141592; //liczba PI\nfloat dist = 100.0; //dystans do dyspozycji dla piłeczki\nfloat r2 = 130.0; //promień koła odejmującego kolor od księżyca\nfloat width = 10.0; //uśredniona grubość księżyca\nfloat gap;\nfloat ballwidth = 5.0; //promień piłeczki\nvec2 ballpos = vec2(0.0, 0.0);\nfloat ballmaxdist;\nfloat balldiff;\nfloat r;\nvec2 bouncermiddle;\nvec2 clearmiddle;\nvec2 zero;\n\n//funkcja przemieszczająca środek koła z którego wycinany jest księżyc i obracająca dookoła tego środka drugie koło\nvoid setmiddle(float time){\n    bouncermiddle = zero+vec2(sin(2.0*PI*time)*dist, cos(2.0*PI*time)*dist);\n    clearmiddle = bouncermiddle+vec2(sin(2.0*PI*(time*60.0+time))*(gap-ballwidth),cos(2.0*PI*(time*60.0+time))*(gap-ballwidth));\n}\n\n//funkcja ustalająca ruch piłeczki\nvoid setball(float time){\n    float halfsec = floor(time*120.0);\n    float sec = floor(time*60.0);\n    float partsec = mod(time*60.0, 1.0);\n    float halfasec = mod(time*60.0, 0.5);\n    ballpos.x = (zero.x + sin(2.0*PI*sec/60.0)*(ballwidth+balldiff-balldiff*abs(partsec-0.5)*2.0));\n    ballpos.y = (zero.y + cos(2.0*PI*sec/60.0)*(ballwidth+balldiff-balldiff*abs(partsec-0.5)*2.0));\n}\n\n//funkcja określająca, czy dany piksel jest częścią odbijającego księżyca\nbool isBouncer (vec2 pos, float minmod) {\n    setmiddle(minmod);\n    if (length(pos - bouncermiddle) < r && length(pos - clearmiddle) > r2) { return true; } else { return false; }    \n}\n\n//funkcja określająca, czy dany piksel jest częścią piłeczki\nbool Ball(vec2 pos, float time){\n    setball(time);\n    if (length(pos - ballpos) < ballwidth) return true; else  return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    zero = vec2(iResolution.x/2.0, iResolution.y/2.0); //określenie środka ekranu (punkt zero)\n    gap = (r2-dist)+width; //wyznacznie odległośi między środkami okręgów\n    r = dist+width; //wyznaczenie średnicy okręgu wysującego księżyc\n    ballmaxdist = dist - ballwidth; //maksymalna odległość piłeczki od punktu zero\n    balldiff = ballmaxdist*2.0 - ballwidth;\n    //utworzenie kolorów\n    vec3 bgCol = vec3(1.0, 0.0, 0.0);\n    vec3 pixel = bgCol;\n    vec3 col1 = vec3(0.5, 1.0, 0.75);\n    vec3 col2 = vec3(0.0, 0.2, 0.9);\n    vec3 col3 = vec3(0.19, 0.44, 0.27);\n    if (length(zero - fragCoord) < ballwidth) pixel = col3; //miejscowienie zielonej kulki na środku\n    float t = iTime; //pobranie czasu \n    t = mod(t, 60.0)/60.0; //przypisanie zmniennej t cząstki upłyniętej minuty\n    if (isBouncer(fragCoord, t)) {pixel = col1;} //miejscowienie odbijającego księżyca\n    if (Ball(fragCoord, t)) {pixel = col2;} //miejscowienie piłki\n    fragColor = vec4(pixel,1.0); //rysowanie\n}","name":"Image","description":"","type":"image"}]}