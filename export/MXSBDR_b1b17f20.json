{"ver":"0.1","info":{"id":"MXSBDR","date":"1729323191","viewed":103,"name":"pentacle","username":"amenone","description":"pentacle","likes":8,"published":1,"flags":4,"usePreview":0,"tags":["vj","anbient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    // 回転行列の関数\n    mat3 rotationX(float angle) {\n        float c = cos(angle);\n        float s = sin(angle);\n        return mat3(\n            1.0, 0.0, 0.0,\n            0.0, c, -s,\n            0.0, s, c\n        );\n    }\n\n    mat3 rotationY(float angle) {\n        float c = cos(angle);\n        float s = sin(angle);\n        return mat3(\n            c,  0.0, s,\n            0.0, 1.0, 0.0,\n           -s,  0.0, c\n        );\n    }\n\n    // 球の距離関数\n    float sphereSDF(vec3 p, float radius) {\n        return length(p) - radius;\n    }\n\n    float boxSDF(vec3 p, vec3 size) {\n        vec3 d = abs(p) - size;\n        float outsideDistance = length(max(d, 0.0));\n        float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n        return outsideDistance + insideDistance;\n    }\n\n    float RolledboxSDF(vec3 p, vec3 size , mat3 rot) {\n        // 点 p を逆回転\n        vec3 q = rot * p;\n        // ボックスのSDF計算\n        vec3 d = abs(q) - size;\n        float outsideDistance = length(max(d, 0.0));\n        float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n        return outsideDistance + insideDistance;\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // 画面の解像度を取得\n    vec2 resolution = iResolution.xy;\n\n    // ピクセルの位置を0.0〜1.0に正規化\n    vec2 uv = fragCoord / resolution;\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(10.0, -7.0, -8.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 100;\n    bool hit = false;\n    vec3 bloomCol = vec3(0.0,0.0,0.0);\n    float maxDistance = 20.0;\n    float epsilon = 0.001;\n    \n    // 回転角度を時間に基づいて計算（X軸とY軸周りに回転）\n    float angleX = iTime * 0.5;\n    float angleY = iTime * 0.0;\n    mat3 rot = rotationY(angleY) * rotationX(angleX);\n    \n    float angleX2 = -iTime * 0.1;\n    float angleY2 =  0.5;\n    mat3 rot2 = rotationY(angleY2) * rotationX(angleX2);\n    \n        vec4 audioValue = texture(iChannel0, vec2(uv.x, uv.y));\n    vec3 boxSize = vec3(1.0,1.0,1.0);\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 currentPos = cp + t * rd;\n        float boxDdistance = RolledboxSDF(currentPos,boxSize,rot2);\n        float rolledBoxDistance = RolledboxSDF(currentPos,boxSize,rot);\n        float distance = min(boxDdistance,rolledBoxDistance);\n        if (distance < epsilon) {\n            hit = true;\n            break;\n        }\n        bloomCol += vec3(0.02,0.02,0.02) ;\n        bloomCol += vec3 (audioValue.x * 0.01 ,audioValue.x * 0.01,audioValue.x * 0.01) ;\n        t += distance;\n        if (t > maxDistance) break;\n    }\n    \n    // ヒットしたかどうかで色を決定\n    if (hit) {\n        float time = iTime;\n        float sineTime = sin(time + uv.x * 3.14);\n        vec3 color = vec3(uv.x , uv.y, 1.2);\n        col = color + bloomCol;\n    } else {\n        vec3 color = vec3( abs(p.x) , abs(p.y), 0.5);\n        col = color + bloomCol *2.0;\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}