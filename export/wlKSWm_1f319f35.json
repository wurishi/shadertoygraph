{"ver":"0.1","info":{"id":"wlKSWm","date":"1583778317","viewed":60,"name":"exercice_ArtLineV4","username":"Elliot18","description":"exercice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["exercice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //--INPUT OBJET--------------------------------------------------------------------------\n    \n    vec3 camera = vec3(iMouse.xy, -1000.0);\n    vec4 position_cube = vec4(160.,20.,20.,0.);//=> definit position cube dans l'espace\n\t\n    vec4 vertex_0 = vec4(100., 100, 100.,2.0)+position_cube; // => w est le radius de la sphere\n    vec4 vertex_1 = vec4(200., 100, 100.,2.0)+position_cube; \n    vec4 vertex_2 = vec4(200., 200., 100.,2.0)+position_cube; \n    vec4 vertex_3 = vec4(100., 200., 100.,2.0)+position_cube; \n    vec4 vertex_4 = vec4(100., 200., 200.,2.0)+position_cube; \n    vec4 vertex_5 = vec4(200., 200., 200.,2.0)+position_cube; \n    vec4 vertex_6 = vec4(200., 100., 200.,2.0)+position_cube; \n    vec4 vertex_7 = vec4(100., 100., 200.,2.0)+position_cube; \n    \n  \tvec4 col = vec4(0, 0, 0, 0); // => couleur par defaut fond\n    \n    vec4[] vertexList = vec4[](vertex_0, vertex_1, vertex_2, vertex_3, vertex_4, vertex_5, vertex_6, vertex_7);\n    \n    for (int i; i < vertexList.length(); i++)\n    {\n        col += rayTrace( camera, vertexList[i], fragCoord );\n    }\n                     \n    fragColor = vec4(col.x,col.y,col.z, 1.0);\n}\n    ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 rayTrace ( vec3 camera, vec4 vertex, in vec2 fragCoord ) {\n    \n    vec3 pixel = vec3(fragCoord,0.0);\n    vec3 ray = pixel - camera; \n    vec3 rayNorm = normalize(ray); \n    \n    float h = length(vertex.xyz - camera); // h = hypothenuse\n    float a = dot(vertex.xyz - camera.xyz, rayNorm); // a = adjacent\n    float sqrt_o = h*h - a*a; // o = opposÃ© \n    \n    // Check if there is an intersection\n    \n    float sqrt_d = vertex.w*vertex.w - sqrt_o;\n    if (sqrt_d > 0. ) {\n       \n       // float d = sqrt(sqrt_d); \n       // vec3 intersection = camera + ( a-d )*rayNorm;\n       // return vec4(intersection, 1.0);\n        return vec4(1.);\n    \t}\n    else\n    \t{\n            return vec4(0.);\n        }\n\n}","name":"Common","description":"","type":"common"}]}