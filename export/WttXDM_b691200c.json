{"ver":"0.1","info":{"id":"WttXDM","date":"1581779129","viewed":193,"name":"Warp Zone 01","username":"taso69","description":"Inspired by the warp scene of ASTRAL CHAIN\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\nfloat speed =  15.0;//15.0;\nvec3 tpos;\n\nmat2 rotate(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash11(float p){\n     return fract(sin(p*12.9898)* 43758.5453123);\n}\nvec3 hash13(float p){\n    return fract(cos(p)*vec3(342.87234,174297.125,8723.924));\n\n}\nfloat hash21( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 hash22(vec2 p){\n    float n = hash21(p);\n    return vec2(n,hash21(n+p));\n}\n\nvec2 pMod(vec2 pos,float s){\n    float a = PI/s - atan(pos.x,pos.y);\n    float n = 2.0*PI/s;\n    a = floor(a/n) * n;\n    pos *= rotate(a);\n    return pos;\n}\n\nfloat isectPlane(vec3 n, float d, vec3 org, vec3 dir){\n    float t = -(dot(org, n) + d) / dot(dir, n);\n    return t;\n}\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat sdBox(vec3 pos, vec3 r){\n    vec3 d = abs(pos) - r;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\nvec2 matMin(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\nvec2 map(vec3 pos){\n    vec2 map = vec2(10000.0,-1.0); \n   \n    vec3 p = pos;\n    p.x += (p.y > 0.0) ? iTime*4.0 : -iTime*4.0;\n    vec2 id = floor(p.xz/4.0);\n    vec2 rand = hash22(id) * 0.5 + 0.2;\n    p.xz = mod(p.xz,4.0) - 2.0;\n    p.y = abs(p.y) - 10.0;\n    //p -= vec3(0.0,hash21(id)*0.2,0.0);\n    float d = sdBox(p,vec3(rand.x,9.0 + hash21(id)*0.3,rand.y));\n    map = matMin(map,vec2(d,1.0)); \n\n    p = pos;\n    p.x += floor(p.z/3.0);\n    p.x += (p.y > 0.0) ? iTime*4.0 : -iTime*4.0;\n    id = floor(p.xz / 3.0);\n    rand = hash22(id) * 0.3 + 0.2;\n    p.xz = mod(p.xz,3.0) - 1.5;\n    p.y = abs(p.y) - 10.;\n    //p -= vec3(0.0,hash21(id)*0.2,0.0);\n    d = sdBox(p,vec3(rand.x,9.0 + hash21(id)*0.3,rand.y));\n    map = matMin(map,vec2(d,1.0));\n\n    p = pos;\n    p.z = mod(p.z,20.0) - 10.0;\n    vec3 bPos = (hash13(floor(pos.z/20.0))*vec3(20.0,2.0,5.0)) - vec3(10.0,1.0,2.5);\n    bPos.x = (abs(bPos.x) < 1.0) ? bPos.x + sign(bPos.x)*1.5 : bPos.x;\n    p = p - bPos;\n    p.xy *=rotate(iTime*hash21(vec2(floor(pos.z/20.0))));\n    p.xz *= rotate(iTime*0.5);\n    tpos = p;\n    float box = sdBox(p,vec3(1.0));\n    map = matMin(map,vec2(box,2.0));\n    return map;\n}\n\nvec3 calcNorm(vec3 pos){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 lighting(vec3 pos,vec3 ro,vec2 m){\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0,0.0,5.0-iTime*speed);\n    vec3 N = calcNorm(pos);\n    vec3 L = normalize(light-pos);\n    vec3 E = normalize(pos - ro);\n    vec3 V = normalize(ro - pos);\n    vec3 R  = normalize(reflect(-L,N));\n\n    float diff = clamp(dot(N,L),0.1,1.0);\n    float spec = max(0.0,pow(dot(R,V),32.0)); \n    if(m.y == 1.0){\n        col = vec3(0.01) + vec3(0.15,0.05,0.05)*diff;\n    }else if(m.y == 2.0){  \n        col = vec3(0.01) + vec3(0.1,0.1,0.1)*diff + 0.2*vec3(0.7,0.7,0.95)*spec;\n    }\n    \n    return col;\n}\n\nvec3 render(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float dist = 10000.0;\n    float EDGE = 0.03;\n\n    vec3 pos;\n    vec2 m; \n    float e = 0.0;\n    float lD = 1e10;\n    for(int i = 0; i < 128; i++){\n        pos = ro + t*rd;\n        m = map(pos);\n        t += m.x*0.75;\n\n        //edge detection\n        //https://www.shadertoy.com/view/MsB3W1\n        if(lD < EDGE && m.x > lD + 0.01){\n            e = 1.0;\n            break;\n        }\n        if(abs(m.x) < 0.001){\n            break;\n        }\n        if(m.x < lD) lD = m.x;\n\n    }\n    pos = ro + t*rd;\n    vec3 c;\n    if(abs(m.x) < 0.001){\n        if(m.y != -1.0)\n            col = lighting(pos,ro,m);\n    }\n    \n    col += mix(0.0,1.0,e);\n    col *= 1.0 - clamp(((abs(pos.y)-2.5)),0.0,1.0);\n    col += vec3(0.4,0.1,0.1)*clamp(((abs(pos.y)-3.0))*0.2,0.0,1.0);\n    col += vec3(1.0,0.5,0.5)*length(m.x);\n\n    //https://www.shadertoy.com/view/4sSSWz\n    for(int i=0;i<2;i++){\n        for(int j = 0;j<1;j++){\n        t = isectPlane(vec3(0.0,(i>0)?-1.0:1.0,0.0),300.0+float(j)*20.0,ro,rd);\n        if(t > 0.0)continue;\n        pos = ro + t*rd;\n        float rep = 10.0;\n        vec3 pp = floor(pos/rep)*rep;\n        float n = pp.x * float(i+1)*100.0 + float(j);\n        float q = hash11(n);\n        float q2 = hash11(n*q);\n        q = sin(pp.z*0.0004+q*10.0-iTime*0.5);\n        q = clamp(q*100.0-100.0+1.0,0.0,1.0)*0.8;\n        //q *= saturate(4.0 - 8.0 * abs(-2.5 + pp.y - pos.y) / 100.0);\n        q *= 1.0 - clamp(pow(t / 5000.0, 5.0),0.0,1.0);\n        if(m.y != 2.0){\n            col += q*vec3(0.8,0.1,0.1);\n            col += (q2 > 0.5*sin(iTime)+0.5) ? q : 0.0;\n        }\n        }\n    }\n    \n    return vec3(col);\n\n}\n\nmat3 cam(vec3 ro, vec3 ta){\n    vec3 cUp = vec3(0.0,1.0,0.0);\n    vec3 cDir = normalize(ta-ro);\n    vec3 cSide = normalize(cross(cDir,cUp));\n    cUp = normalize(cross(cSide,cDir));\n\n    return mat3(cSide,cUp,cDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy*2.0 - iResolution.xy;\n    p /= min(iResolution.x,iResolution.y);\n\n    vec3 ro = vec3(0.0,0.0,3.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    ro.z +=  -iTime*speed;\n    ta.z += -iTime*speed;\n    vec3  rd = normalize(vec3(p,2.0)) * cam(ro,ta);\n\n    vec3 col = render(ro,rd);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}