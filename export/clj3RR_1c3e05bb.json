{"ver":"0.1","info":{"id":"clj3RR","date":"1672766092","viewed":190,"name":"Genuary Day 3 - Glitch Art","username":"foodi","description":"Genuary 2023 - Day 3 - Prompt: \"Glitch Art\"\n\n4D Modulation/\"Rotation\" of ray direction was inspired by 'iapafoto': https://www.shadertoy.com/view/4sjGWw\nSDFs and general raymarching techniques inspired (as always) by: 'iq'","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["glitch","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927f\n\nconst vec4 lightDir = normalize(vec4(0.31,-1,0,0.5f));\nfloat time() {\n    return iTime-32.f;\n}\n\n// hash functions by 'nojima' (https://www.shadertoy.com/view/ttc3zr)\n// --------------------------------------------------------------------\nuvec4 murmurHash41(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 1 input\nvec4 hash41(float src) {\n    uvec4 h = murmurHash41(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n// --------------------------------------------------------------------\n\n\nvec4 RandRect(float seed)\n{\n    const vec2 maxSize = vec2(1.f, 0.2f);\n    vec4 rand = hash41(seed);\n    rand = rand * 1.5f - 0.25f; // scale larger than screen so blocks don't appear to crowd to much in the center\n    vec4 result = vec4(min(rand.x,rand.z), min(rand.y,rand.w), max(rand.x,rand.z), max(rand.y,rand.w));\n    // scale delta to more uniformly sample the 'maxSize' (if we just clamp we get an abnormally large count of 'maxSize' rects)\n    vec2 delta = result.zw-result.xy;\n    delta *= maxSize;\n    result.zw = result.xy + min(maxSize, delta); // min not really needed if hash function is [0,1] bound\n    return result;\n}\n\nbool RectContains(vec2 p, vec4 rect) \n{\n    return p.x >= rect.x && p.y >= rect.y && p.x <= rect.z && p.y <= rect.w;\n}\n\nvec2 GlitchOffset(vec2 uv, int channel, float glitchAmount)\n{\n    int steps = int(floor(glitchAmount * 32.f));\n\n    vec2 rects = vec2(0.f);\n    for(int i = 0; i < steps; i++) {\n        float seed = float(i) + floor(time() * 5.f) * 1.1385f;\n        vec4 rect = RandRect(seed);\n        rect.xz += float(channel)*0.035f;\n        if(RectContains(uv,rect)) {\n            rects = hash41(seed*1.317f).rg;\n            // [-1,1]\n            rects = rects*2.f-vec2(1.f);\n        }\n    }\n    return rects * 0.0625f;\n}\n\n// from iq\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBoxFrame4D( vec4 p, vec4 b, float e )\n{\n    p = abs(p)-b;\n    vec4 q = abs(p+e)-e;\n    return min(min(min(\n        length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z,q.w))),0.0),\n        length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z,q.w))),0.0)),\n        length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z,q.w))),0.0)),\n        length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(p.x,max(q.y,max(q.z,q.w))),0.0));\n}\n\nfloat sdSphere4D(vec4 p, float r)\n{\n    return length(p) - r;\n}\n\n// from iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTorus4D( vec4 p, vec3 t )\n{\n  vec3 q = vec3(length(p.xz)-t.x,p.y,p.w);\n  return sdTorus(q, t.yz);\n}\n\n// from iq\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n//#define MODULATE_SPACE\n\nfloat map(vec4 ro) { \n    const float stride = 0.5f;\n    \n    float t = time() - length(ro) * 4.f; // time based domain distortion\n    \n//#define CAPTURE_MODE\n#ifdef CAPTURE_MODE\n    const float startTime = -38.f;\n    const float endTime = -15.f;\n    if(t < startTime || t > endTime) return 100000.f;\n    ro /= clamp((t-startTime) / 5.f, 0.0001f, 1.f);\n    ro /= clamp((endTime-t) / 0.5f, 0.0001f, 1.f);\n#endif\n    \n    float a1 = t * 0.32f;\n    float a2 = t * 0.87f;\n    mat2x2 rotA = mat2x2(cos(a1),-sin(a1),sin(a1),cos(a1));\n    mat2x2 rotB = mat2x2(cos(a2),-sin(a2),sin(a2),cos(a2));\n    ro.yz *= rotA;\n    ro.xw *= rotB;\n\n    float d = 10000000.f;\n    const int numObjs = 7;\n    //const float a = 2.f*PI/float(numObjs);\n    //float a = 2.f*PI/float(numObjs) + sin(time() * 0.5f) * 0.25f +time()*0.2f;\n    float a = 2.f*PI/float(numObjs) * 3.f + time()*0.2f;\n    mat2x2 rot = mat2x2(cos(a),-sin(a),sin(a),cos(a));\n    for(int i = 0; i < numObjs; i++) {\n        //d = min(d, sdTorus4D(ro, vec3(0.25,0.125,0.05)));\n        d = opSmoothUnion(d, sdTorus4D(ro, vec3(0.25,0.125,0.025)), 0.05f);\n        ro.zy *= rot;\n    \n        ro = ro * 1.05f + vec4(0.0625);\n        //ro = ro + vec4(0, 0.125, 0.125f, 0);\n        //ro = ro * 1.1f + vec4(0.125,0.25, 0, 0.0625f);\n    }\n    \n    \n    return d * 0.25f;\n\n    float b1 = sdBoxFrame4D(ro, vec4(0.5f), 0.025f);\n    float b2 = sdBoxFrame4D(ro, vec4(0.35f), 0.0125f);\n    float b3 = sdBoxFrame4D(ro + vec4(0.125,-0.125,0.125,-0.125), vec4(0.222f), 0.0125f);\n    \n    return min(b1, min(b2,b3));\n}\n\nvec4 Normal(vec4 p) \n{\n    vec2 e = vec2(0.001f, 0.f);\n    float v = map(p);\n    float dx = map(p+e.xyyy)-v;\n    float dy = map(p+e.yxyy)-v;\n    float dz = map(p+e.yyxy)-v;\n    float dw = map(p+e.yyyx)-v;\n    return normalize(vec4(dx,dy,dz,dw));\n}\n\nfloat shadowMap(vec4 p)\n{\n    float s = 1.f;\n    float dist = 0.01f;\n    p -= lightDir*dist;\n    const float k = 4.f;\n    for(int i = 0; i < 50; i++) {\n        float d = map(p);\n        if(d < 0.f) {        \n            s = 0.f; \n            break;\n        }\n        s = min(s, d/dist);       \n        //s = min( s, k*d/dist );\n        \n        p -= lightDir*d;\n        dist += d;\n    }\n    \n    s *= 2.f; //1.f - pow(1.f-s, 4.f);\n    \n    return s;\n}\n\nvec3 SurfaceColor(vec4 p, vec4 rd)\n{\n    vec4 n = Normal(p);\n    float lightDot = dot(-n,lightDir);\n    float light = max(0.f, lightDot);  \n    float invLight = max(0.f, -lightDot);\n    \n    float shadow = shadowMap(p);\n    light *= shadow;\n    \n    const vec3 lightCol = vec3(1,0.89,0.73);\n    const vec3 invLightCol = vec3(0.53,0.7,0.85);\n    \n    vec3 col = vec3(0.f);\n    \n    col += vec3(light) * lightCol * 3.f;\n    col += vec3(invLight) * invLightCol * 0.75f;\n       \n    // reflection\n    vec3 rrd=reflect(rd.rgb,n.rgb);\n    vec3 reflection = texture(iChannel1, rrd.xyz).rgb;\n    col += reflection * 0.25f; // * mix(invLightCol,lightCol, lightDot*0.5f+0.5f);\n    \n    col += pow(max(0.f, dot(rrd,-normalize(lightDir.rgb))), 64.f) * (sign(invLight)*invLightCol + sign(light)*lightCol);\n    \n    col = pow(col, vec3(2.2f));\n        \n    return col;\n}\n\n// modulated version of iq's 3D intersection code - does this work as intended in 4D..?\nvec2 sphIntersect4D( in vec4 ro, in vec4 rd, float ra )\n{\n    vec4 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 Render(vec2 uv, float offset4D) {\n    float ph = time()*0.25f;\n    vec4 co = vec4(sin(ph), 0, cos(ph), offset4D * 0.537f) * 2.f;\n    vec4 cf = normalize(-co);\n    vec4 cr = vec4(cos(ph), 0, -sin(ph), 0);\n    vec4 cu = vec4(normalize(cross(cr.xyz,cf.xyz)), 0);\n    \n    vec4 ro = co;\n    vec4 rd = normalize(cf+uv.x*cr+uv.y*cu);\n \n    float boundingRadius = 2.f;\n    vec2 boundDists = sphIntersect4D(ro, rd, boundingRadius);\n    int steps = 200;\n \n    float dist = boundDists.x;\n    ro += dist*rd;\n    bool hit = false;\n    for(int i=0; i<steps; i++) {\n        float d = map(ro);\n        \n        if(abs(d)<0.001f) {\n            hit = true;\n            break;\n        }\n        if(dist >= boundDists.y) { break; }\n        \n        dist+=d;\n        ro+=d*rd;\n    }\n    \n    vec3 bgCol = vec3((1.f-length(uv) * 1.f + hash44(vec4(uv,0,0)).r * 0.1f) * 0.13f);\n    \n    if(hit) {\n        vec3 sc = SurfaceColor(ro,rd);\n        sc = mix(bgCol, sc, clamp(exp(-(dist-1.f)*0.75f), 0.f,1.f));\n        return sc;\n    }\n    \n    return bgCol;\n\n    return texture(iChannel0, uv).rgb;\n    return vec3(float(length(uv) < 0.5f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 glitchAmount = texture(iChannel0, vec2(time() * 2.5f,0)).rgb;\n    glitchAmount = max(vec3(0.f), glitchAmount-0.35f); // remove some frames from any glitch\n    const float globalGlitchOffset = 0.03f;\n    \n    \n    vec2 offsets[3];\n    offsets[0] = GlitchOffset(uv,0, glitchAmount.r-0.125f);\n    offsets[1] = GlitchOffset(uv,1, glitchAmount.g-0.125f);\n    offsets[2] = GlitchOffset(uv,2, glitchAmount.b-0.125f);\n\n    vec3 col = vec3(0.f);\n    \n#define GLITCH\n\n#ifdef GLITCH\n    for(int channel = 0; channel<3; channel++) {\n        vec2 normalUV = (uv * 2.f - vec2(1.f))*vec2(1,iResolution.y/iResolution.x);\n        //vec3 render = Render(normalUV + offsets[channel]);\n        float globalOffset = float(channel-1) * glitchAmount[channel] * globalGlitchOffset;\n        vec3 render = Render(normalUV + vec2(globalOffset, 0.f) + offsets[channel] *0.5f, offsets[channel].g);\n        //vec3 render = Render(normalUV + vec2(globalOffset, 0.f) + offsets[channel], 0.f);\n        col[channel] += render[channel];\n    }\n#else\n    vec2 normalUV = (uv * 2.f - vec2(1.f))*vec2(1,iResolution.y/iResolution.x);\n    col = Render(normalUV);\n#endif\n\n    // Time varying pixel color\n    //vec3 col = vec3(0.f); // 0.5 + 0.5*cos(time()+uv.xyx+vec3(0,2,4));\n    //\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}