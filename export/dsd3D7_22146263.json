{"ver":"0.1","info":{"id":"dsd3D7","date":"1677416995","viewed":119,"name":"Poisoned Neon Klein's Bottle","username":"kznsq","description":"Based on:\nhttps://www.shadertoy.com/view/3tfcRS\nhttps://www.shadertoy.com/view/4ltSW8","likes":11,"published":1,"flags":48,"usePreview":1,"tags":["glass","klein","neon","bottle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = textureLod(iChannel0, uv, 0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on https://www.shadertoy.com/view/3tfcRS\n\n#define LAST_FRAME iChannel0\n#define SKYBOX(v) texture(iChannel1, v).rgb*0.5\n#define NOISE(v) texture(iChannel3, v).rgb\n#define KEY_SAMPLER iChannel2\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\n// https://www.shadertoy.com/view/lsXGzf (iq: \"Input - Keyboard\")\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\n// ===============================\n// Quaternion helpers\n// (Unit quaternions: w+xi+yj+zk)\n// ===============================\n\n#define QID vec4(0.0, 0.0, 0.0, 1.0)\n\nvec4 slerp(vec4 a, vec4 b, float t) {\n    float d = dot(a, b);\n    vec4 a2 = a;\n\n    if (d < 0.0) {\n        d = -d;\n        a2 = -a;\n    }\n    if (d > 0.999) {\n        return normalize(mix(a2, b, t));\n    }\n\n    float theta = acos(d);\n    return (sin((1.-t)*theta)*a2 + sin(t*theta)*b) / sin(theta);\n}\n\nvec4 qMul(vec4 a, vec4 b) {\n    return vec4(\n        a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n        a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,\n        a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,\n        a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z\n    );\n}\n\nvec4 qConj(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qRot(vec3 nvAxis, float angle) {\n    return vec4(nvAxis*sin(angle*0.5), cos(angle*0.5));\n}\n\nmat3 qToMat(vec4 q) {\n    float wx = q.w*q.x, wy = q.w*q.y, wz = q.w*q.z;\n    float xx = q.x*q.x, xy = q.x*q.y, xz = q.x*q.z;\n    float yy = q.y*q.y, yz = q.y*q.z, zz = q.z*q.z;\n    return mat3(\n        1. - 2.*(yy + zz),\n             2.*(xy + wz),\n             2.*(xz - wy),\n\n             2.*(xy - wz),\n        1. - 2.*(xx + zz),\n             2.*(yz + wx),\n\n             2.*(xz + wy),\n             2.*(yz - wx),\n        1. - 2.*(xx + yy)\n    );\n}\n\n// ===============================\n// Reading/writing state\n// ===============================\n\nstruct state {\n    vec3 p; // Pendulum pivot\n    vec3 q; // Accelerate p toward this point\n    vec3 v; // Pendulum \"bob\" (relative to pivot)\n    vec3 L; // Angular momentum\n    vec4 pr; // Object rotation (unit quaternion)\n};\n\nstate readState() {\n    state s = state(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0, -cos(0.25*PI), sin(0.25*PI)),\n        vec3(0.0, 0.5, 0.0),\n        QID\n    );\n    if (iFrame > 0) {\n        s.p = texelFetch(LAST_FRAME, ivec2(0, 0), 0).xyz;\n        s.q = texelFetch(LAST_FRAME, ivec2(1, 0), 0).xyz;\n        s.v = texelFetch(LAST_FRAME, ivec2(2, 0), 0).xyz;\n        s.L = texelFetch(LAST_FRAME, ivec2(3, 0), 0).xyz;\n        s.pr = texelFetch(LAST_FRAME, ivec2(4, 0), 0);\n    }\n    return s;\n}\n\nvoid writeState(in state s, in vec2 fragCoord, inout vec4 fragColor) {\n    if (abs(fragCoord.y - 0.0-0.5) < 0.5) {\n        if (abs(fragCoord.x - 0.0-0.5) < 0.5) {\n            fragColor = vec4(s.p, 1.0);\n        } else if (abs(fragCoord.x - 1.0-0.5) < 0.5) {\n            fragColor = vec4(s.q, 1.0);\n        } else if (abs(fragCoord.x - 2.0-0.5) < 0.5) {\n            fragColor = vec4(s.v, 1.0);\n        } else if (abs(fragCoord.x - 3.0-0.5) < 0.5) {\n            fragColor = vec4(s.L, 1.0);\n        } else if (abs(fragCoord.x - 4.0-0.5) < 0.5) {\n            fragColor = s.pr;\n        }\n    }\n}\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCamera(in state s, in vec2 uv, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 mouseAng = vec2(HALFPI*0.75, PI*0.45) + 0.2*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    camPos = vec3(0.0, 2.0, 0.0) + 5.0 * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = mix(vec3(0.0), s.p, 0.05);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n// ===============================\n// Physics, reading/writing state\n// ===============================\n\nvoid updateState(inout state s) {\n\n    // p (object displacement) gets \"lerped\" towards q\n    if (iMouse.z > 0.5) {\n        vec2 uvMouse = iMouse.xy / iResolution.xy;\n        vec3 camPos;\n        vec3 nvCamDir;\n        getCamera(s, uvMouse, camPos, nvCamDir);\n\n        float t = -camPos.y/nvCamDir.y;\n        if (t > 0.0 && t < 50.0) {\n            vec3 center = vec3(0.0);\n            s.q = camPos + t*nvCamDir;\n            float qToCenter = distance(center, s.q);\n            if (qToCenter > 5.0) {\n                s.q = mix(center, s.q, 5.0/qToCenter);\n            }\n        }\n    }\n\n    // pr (object rotation unit quaternion) gets \"slerped\" towards qr\n    float tmod = mod(iTime+6.0, 9.0);\n    vec4 qr = (\n        tmod < 3.0 ? qRot(vec3( SQRT2INV, 0.0, SQRT2INV), 0.75*PI) :\n        tmod < 6.0 ? qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), 0.5*PI) :\n        QID\n    );\n\n    // apply lerp p -> q and slerp pr -> qr\n    s.p += 0.25*(s.q - s.p);\n    s.pr = normalize(slerp(s.pr, qr, 0.075));\n\n    // object acceleration\n    vec3 a = -0.25*(s.q - s.p) + vec3(0.0, -1.0, 0.0);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    a = prMatInv*a;\n\n    // hand-wavy torque and angular momentum\n    vec3 T = cross(s.v, a);\n    s.L = 0.96*s.L + 0.2*T;\n\n    // hand-wavy angular velocity applied from torque\n    vec3 w = s.L;\n    float ang = 0.25*length(w);\n    if (ang > 0.0001) {\n        mat3 m = qToMat(qRot(normalize(w), ang));\n        s.v = normalize(m*s.v);\n    }\n}\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 5.0\n#define GLASS_THICKNESS 0.1\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// from the https://www.shadertoy.com/view/4ltSW8\n\n#define P 0.1 // Precision\n#define D 115.   // Max distance\n#define M 0.    // # of extra samples\n\nfloat _d, _dsky;\nbool _ignoreBottle = false;\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat scene(vec3 p)\n{\n    _dsky = abs(length(p)-D+8.)-P;\n    \n    if (_ignoreBottle) { return _d = _dsky; }\n    \n    // thickness\n    float t = 0.03;\n    float d = 1e10;\n    \n    p.y += .1;\n    p.xy *= rot(PI/1.);\n\n    vec3  q = p + vec3(1.-cos((1.-p.y)/3.*PI),0,0);\n    float y = pow(sin((1.-p.y)/3.*PI/2.),2.);\n     \n    float tube_hollow = max(max(abs(length(q.xz)-0.5+0.25*y)-t,q.y-1.0),-q.y-2.0);\n    float tube_solid  = max(max(length(q.xz)-0.5+0.25*y,q.y-1.0),-q.y-2.0);\n    \n    // opening (half XZ torus)\n    q = p - vec3(0,1,0);\n    d = min(d,max(abs(length(vec2(length(q.xz)-1.0,q.y))-0.5)-t,-q.y));\n    \n    // body (stretched XZ torus)\n    q = p;\n    d = min(d,max(max(max(abs(length(q.xz)-1.5+1.25*y),q.y-1.0),-q.y-2.0)-t,-tube_solid));\n    \n    // tube (stretched XZ cylinder)\n    d = min(d,tube_hollow);\n    \n    // handle (half XY torus)\n    q = p + vec3(1,2,0);\n    d = min(d,max(abs(length(vec2(length(q.xy)-1.0,q.z))-0.25)-t,q.y));\n    \n    // sky\n    d = min(d,_dsky);\n    \n    return _d = d;\n}\n\nfloat sdfContainer(vec3 p, state s) \n{\n    return scene(p);\n    \n    vec3 v = NOISE(p*.05);//simplex3d_fractal(p*1.0);\n    p += 0.25*v;\n\n    return sdBoxFrame(p, vec3(1.0, 2.0, 3.0), .12);\n    \n    return sdLink(p, 1., 2.5, .2);\n    \n    vec3 d = abs(p - s.p);\n    vec3 d2 = d*d;\n    float sdBase = pow(dot(d2,d2), 0.25) - 2.0;\n\n    float sdInner = length(d.xz) - 0.1;\n    return sdInner;\n    \n    //return opSmoothSubtraction(sdInner, sdBase, 0.15);\n}\n\nfloat sdfWater(vec3 p, state s) {\n    float dglass = sdfContainer(p, s);\n    float depth = 0.0; // Can add e.g. ripples to the surface here\n    float dsurf = sdfPlane(s.p + depth*s.v, -s.v, p);\n    return opSubtraction(opSmoothSubtraction(dsurf, dglass, 0.15), dglass);\n}\n\nfloat sdfGlass(vec3 p, state s) {\n    float etchDepth = 0.0; // Can sample from e.g. cubemap here for some texture\n    return sdfInterval(0.0, GLASS_THICKNESS - etchDepth, sdfContainer(p, s));\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p, s) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0), s ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0), s ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0), s ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0), s ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS), s ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS), s )  \\\n    ))\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 80\n\n#define LIGHT_COLOR vec3(.7, 0.9, 1.0)\n\n#define GLASS_COLOR vec3(.0, 0.2, .2)\n#define GLASS_OPACITY .6\n#define WATER_COLOR vec3(0.0, 10., 5.)\n#define WATER_OPACITY 3.1\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n#define IR_WATER 1.7\n\n#define SPEC_COEFF 1.0\n#define SPEC_EXPONENT 10.0\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n#define SUBSTANCE_WATER 2\n\nvec4 computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvoid march(in state s, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    bool skipOpacity = texelFetch(KEY_SAMPLER, ivec2(KEY_A,0), 0).x > 0.5;\n    bool skipRefraction = texelFetch(KEY_SAMPLER, ivec2(KEY_S,0), 0).x > 0.5;\n    bool debugSteps = texelFetch(KEY_SAMPLER, ivec2(KEY_D,0), 0).x > 0.5;\n    bool debugNormal = texelFetch(KEY_SAMPLER, ivec2(KEY_F,0), 0).x > 0.5;\n\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    vec3 pCam = prMatInv*(pRay - s.p) + s.p;\n    vec3 pLight = prMatInv*(pLightO - s.p) + s.p;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = prMatInv*nvRayIn;\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur - s.p;\n        if (\n            (length(centerToCur) > BOUNDING_SPHERE_RADIUS) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) { break; }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n\n        float sdGlass = sdfGlass(pCur, s);\n        float sdWater = sdfWater(pCur, s);\n        vec3 dpStep = abs(min(sdGlass, sdWater))*nvRayCur;\n\n        vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur, s);\n        vec3 nvWater = SDF_NORMAL(sdfWater, pCur, s);\n\n        if (curSubstance == SUBSTANCE_AIR) {\n\n            if (sdGlass < SDF_EPS && dot(nvGlass,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_GLASS;\n\n                vec4 sColor = computeSpecular(\n                    11.8, 210.0, nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                // Schlick approximation\n                float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                dpStep = sdGlass*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n                }\n\n            } else if (sdWater < SDF_EPS && dot(nvWater,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_WATER;\n\n                vec4 sColor = computeSpecular(\n                    SPEC_COEFF, SPEC_EXPONENT, nvWater, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                // Schlick approximation\n                float cosHitAngle = clamp(dot(nvWater, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_WATER-IR_AIR)/(IR_WATER+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 5.0));\n\n                vec3 nvRefl = reflect(nvRayCur, nvWater);\n                color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                dpStep = sdWater*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvWater;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvWater, IR_AIR/IR_WATER);\n                }\n\n            }\n\n        } else if (curSubstance == SUBSTANCE_GLASS) {\n\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            if (!skipOpacity) {\n                color = blendOnto(color, \n                    clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n            }\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n                }\n\n            }\n\n        } else if (curSubstance == SUBSTANCE_WATER) {\n\n            float sdWaterInv = -sdWater;\n            vec3 nvWaterInv = -nvWater;\n\n            dpStep = abs(sdWaterInv)*nvRayCur;\n\n            if (!skipOpacity) {\n                color = blendOnto(color, clamp(WATER_OPACITY*sdWaterInv,0.0,1.0)*vec4(WATER_COLOR, 1.0));\n            }\n\n            if (sdWaterInv < SDF_EPS && dot(nvWaterInv,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdWaterInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvWaterInv;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvWaterInv, IR_WATER/IR_AIR);\n                }\n\n            }\n\n        }\n\n        pCur += dpStep;\n\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = qToMat(s.pr)*nvRayCur;\n\n    if (debugSteps) {\n        color = vec4( vec3(float(i)/float(STEPS)), 1.0 );\n    } else if (debugNormal) {\n        color = vec4( 0.5 + 0.5*nvRayOut, 1.0 );\n    }\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord, state s) {\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(s, camPos, nvCamDir, color, nvRayOut);\n\n    return blendOnto(color, SKYBOX(nvRayOut));\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    state s = readState();\n\n    fragColor = mainColor(fragCoord, s);\n\n    updateState(s);\n    writeState(s, fragCoord, fragColor);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}