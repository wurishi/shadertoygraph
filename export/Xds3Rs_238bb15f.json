{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock - 23/08/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Adjust the amount of blur (this will accept ridiculous values)\nconst float shutterDuration = 1.0/30.0;\n\n\n// Adjust the quality of blur (some GPUs will struggle)\nconst int blurSteps = 5;\n\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = p.xy + f.xy;\n\treturn texture( iChannel0, (uv+0.5)/256.0, -100.0 );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n}\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec4 Car( vec3 rayStart, vec3 rayDir, vec3 paint, vec3 carPos )\n{\n\tconst float wheelRadius = .3;\n\tfloat wheelRot = carPos.z/wheelRadius;\n\t\n\tvec3 rs = rayStart-carPos;\n\t\n\tfloat d = dot(rs,rayDir);\n\tvec3 perp = rs - rayDir*d;\n\t\n\t// test bounding sphere\n\tif ( d > 0.0 || length(perp) > 4.0 )\n\t\treturn vec4(0);\n\n\t// more detailed shape\n\tfloat t = -sqrt(4.0*4.0-dot(perp,perp))-dot(rs,rayDir);\n\tfloat tb = sqrt(4.0*4.0-dot(perp,perp))-dot(rs,rayDir);\n\t\n\tvec3 norm = normalize(t*rayDir+rs);\n\t\n\tfloat t2;\n\tif ( rayDir.x > 0.0 )\n\t{\n\t\tt2 = (-1.3-rs.x)/rayDir.x;\n\t\tif ( t2 > t )\n\t\t{\n\t\t\tt = t2;\n\t\t\tnorm = vec3(-1,0,0);\n\t\t}\n\n\t\tt2 = (1.3-rs.x)/rayDir.x;\n\t\tif ( t2 < tb )\n\t\t\ttb = t2;\n\t}\n\telse\n\t{\n\t\tt2 = (1.3-rs.x)/rayDir.x;\n\t\tif ( t2 > t )\n\t\t{\n\t\t\tt = t2;\n\t\t\tnorm = vec3(1,0,0);\n\t\t}\n\n\t\tt2 = (-1.3-rs.x)/rayDir.x;\n\t\tif ( t2 < tb )\n\t\t\ttb = t2;\n\t}\n\t\n\tvec3 plane = normalize(vec3(0,1,.1));\n\tfloat m = dot(rayDir,plane);\n\tt2 = (0.5-dot(rs,plane))/m;\n\tif ( m > 0.0 )\n\t{\n\t\tif ( t2 < t )\n\t\t\ttb = t2;\n\t}\n\telse if ( t2 > t )\n\t{\n\t\tt = t2;\n\t\tnorm = plane;\n\t}\n\t\n\tif ( t > tb || t < .0 )\n\t\treturn vec4(0);\n\t\n\tvec3 p = t*rayDir+rs;\n\n\t// clip the bottom to the road\n\tif ( p.y < -1.0 )\n\t\treturn vec4(0);\n\t\n\treturn vec4(paint*max(0.0,dot(norm,normalize(vec3(-3,2,-1)))),1);\n}\n\n\nvec4 Road( vec3 rayStart, vec3 rayDir, vec3 roadPos, vec3 roadDir )\n{\n\t// ray trace in 2D against cross-section of road\n\troadDir = normalize(roadDir);\n\trayStart -= roadPos;\n\t\n\tvec3 rs, rd;\n\trs.z = dot(roadDir,rayStart);\n\trd.z = dot(roadDir,rayDir);\n\t\n\trayStart -= roadDir*rs.z;\n\trayDir -= roadDir*rd.z;\n\t\n\tvec3 perp = cross( roadDir, vec3(0,1,0) );\n\n\trs.xy = vec2( sign(dot(perp.xz,rayStart.xz))*length(rayStart.xz), rayStart.y );\n\trd.xy = vec2( sign(dot(perp.xz,rayDir.xz))*length(rayDir.xz), rayDir.y );\n\n\t// find intersection\n\tfloat t = -rs.y/rd.y;\n\t\n\tif ( t < 0.0 )\n\t\treturn vec4(0);\n\t\n\tvec3 p = t*rd+rs;\n\n\tif ( abs(p.x) > 11.0 )\n\t\treturn vec4(0);\n\t\n\t// white lines\n\tif ( (abs(p.x) < .1 || abs(p.x-5.0) < .1 || abs(p.x+5.0) < .1) && fract(p.z/3.0) < .66 )\n\t\treturn vec4(1,1,1,1);\n\n\t// yellow lines\n\tif ( abs(abs(p.x)-10.0) < .1 )\n\t\treturn vec4(1,.9,0,1);\n\n\t// diagonals\n\tif ( abs(p.x-7.5) < 2.0 && fract((p.x+p.z)/4.0) < .1 )\n\t\treturn vec4(1);\n\t\n\treturn vec4( mix( vec3(.1), vec3(.2), Noise(p).x ), 1 );\n}\n\n\nvec4 Sky( vec3 rayDir )\n{\n\treturn vec4(.1,.1,.2,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 sum = vec4(0);\n\t\n\tfor ( int blur=0; blur < blurSteps; blur++ )\n\t{\n\t\tfloat time = iTime + ((Noise( ivec2(fragCoord.xy) ).x+float(blur))/float(blurSteps))*shutterDuration;\n\t\t\n\t\t// loop the animation\n\t\ttime = fract(time/12.0)*12.0;\n\t\t\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\t\n\t\tvec3 car1Pos = vec3(-4.0,0,-40.0+time*80.0);\n\t\tvec3 car2Pos = vec3(cos(time/1.0)*3.0,0,-20.0+time*80.0-12.0*sin(time/3.0));\n\t\n\t\tvec3 camPos, camDir;\n\t\tfloat camZoom;\n\t\tif ( time < 2.5 )\n\t\t{\n\t\t\tfloat camAnim = smoothstep(0.0,2.0,time);\n\t\t\tcamPos = vec3(-10,1,0)+vec3(-1,1,0)*camAnim;//20.0+time*50.0);\n\t\t\tcamDir = vec3(1,-.4,.5+.5*camAnim);\n\t\t\t//vec3 camLook = vec3(0,0,-30.0+time*76.0);\n\t\t\t//camDir = camLook-camPos;\n\t\t\tcamZoom = 1.0;\n\t\t}\n\t\telse if ( time < 6.5 )\n\t\t{\n\t\t\tcamPos = car1Pos+vec3(2,0,1);\n\t\t\t//camDir = vec3(0,0,1);\n\t\t\tvec3 camLook = car2Pos+vec3(0,0,4);\n\t\t\tcamDir = camLook-camPos;\n\t\t\tcamZoom = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcamPos = vec3(0,12,20.0+time*79.0);\n\t\t\tcamPos += mix(vec3(-10,0,-16),vec3(8.0,-5,0),smoothstep(6.5,12.0,time));\n\t\t\t//camDir = vec3(0,0,1);\n\t\t\tvec3 camLook = car2Pos+vec3(0,0,mix(-2.0,-10.0,smoothstep(6.5,12.0,time)));\n\t\t\tcamDir = camLook-camPos;\n\t\t\tcamZoom = mix(3.0,1.0,smoothstep(7.5,11.0,time));\n\t\t}\n\n// debug, watch the lead cars\n//camDir = -vec3(0,20,-40); camPos = vec3(0.0,0,-40.0+time*82.0) - camDir;\n\t\t\n\t\n\t\tvec3 rayDir = GetRay( camDir, camZoom, uv );\n\t\t\n\t\tvec4 result = vec4(0);\n\t\n\t\t// test things in strict depth order, so we can early-out\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(.7,.3,1), vec3(-2.0,0,-160.0+time*76.0) );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(1,0,0), vec3(2.0,0,-100.0+time*78.0) );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(1,1,1), car1Pos );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(1,.9,.1), car2Pos );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(.2,0,.7), vec3(4.0,0,-40.0+time*80.0-20.0*cos(time/2.1)) );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(0,-1,0), vec3(0,0,1) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(0,-5,30), vec3(1,0,0) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Sky( rayDir );\n\t\t\n\t\tsum += result;\n\t}\n\n\tfragColor = sum/float(blurSteps);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xds3Rs","date":"1377341637","viewed":822,"name":"The Race","username":"TekF","description":"Very simple scene to mess around with motion blur and cinematic camera angles. In the final shot you can see that I'm not comparing depths on my objects.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","motionblur"],"hasliked":0,"parentid":"","parentname":""}}