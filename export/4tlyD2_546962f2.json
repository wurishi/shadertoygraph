{"ver":"0.1","info":{"id":"4tlyD2","date":"1552178281","viewed":365,"name":"extrude (height + pointillize)","username":"ghost","description":"heightmap + pointillize","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trying out \"extrude\" by raymarching heightfield based on grayscale\n// based on: simesgreen's video heightfield\n// https://www.shadertoy.com/view/Xss3zr\n// and iq's terrain raymarching:\n// https://iquilezles.org/articles/terrainmarching\n\n#define tex iChannel0\n\nbool animateHeight = true;\nbool animateDepth = false;\nbool rotateMouse = true;\n\nvec3 rotate(inout vec3 p, float a) \n{\t\n    float s = sin(a);\n    float c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\tp.yz = m*p.yz;\n    return p;\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*.5+.5;\n\tuv.y = 1. - uv.y;\n\treturn uv;\n}\n\nfloat grayScale(vec4 c) { return c.x*.29 + c.y*.58 + c.z*.13; }\n\n\nfloat heightField(vec3 p)\n{\n    vec2 uv = worldToTex(p);\n    vec2 s = 1./iResolution.xy;\n    float c = grayScale(texture(tex, uv));\n    if (animateHeight) {\n    \tc = mix(c,1.-c,sin(iTime*2.)*.8);\n    \tc*=.3;    \n    }\n    //c+=abs(sin(iTime*.5))*.5;\n    return c;\n}\n\n//https://iquilezles.org/articles/terrainmarching\nbool traceHeightField(vec3 ro, vec3 rd, out vec3 hitPos)\n{\n    const float max_steps = 60.;\n    \n    float s = .01;\n    float lh = 0.;\n    vec3  ly = vec3(0.);\n    for(float t = 0.; t < max_steps; t += s)\n    {\n        vec3 p = ro + rd*t;\n\t\tfloat h = heightField(p);\n\t\tif (p.y < h) {\n            t = t - s + s*(lh-ly.y)/(p.y-ly.y-h+lh);\n            //t = (t-.5*s);\n            hitPos = ro + rd  * t;\n            return true;\n\t\t}\n        lh = h;\n        ly = p;\n\t}\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\n\n    // compute ray origin and direction\n    vec3 rd = normalize(vec3(uv, -2.));\n    vec3 ro = vec3(0.,0.,2.);\n    \n    // rotate view\n    ro = rotate(ro, 1.25 * 2.-1.);\n    rd = rotate(rd, 1.25 * 2.-1.); \n\n\t// rotate view w/mouse\n    if (rotateMouse) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2.-1.;\n        if (iMouse.x > 0.0) {\n            float ax = (1. - mouse.y);\n            ro = rotate(ro, ax);\n            rd = rotate(rd, ax); \n        }\n    }\n\n\tvec3 c = vec3(0.);   \n    vec3 hitPos;\n    if (traceHeightField(ro, rd, hitPos)) {\n        vec2 uv = worldToTex(hitPos);\n        if (animateHeight) \n            c = texture(iChannel0, uv).xyz;\n        float depth = (animateHeight) ?\n            1.0 - clamp(sin(mod(iTime,5.)*.2),0.,1.) : 0.0;\n        if (hitPos.y > depth)\n            c = texture(iChannel0, uv).xyz;\n    }\n\tfragColor = vec4(c, 1.0);\n    //fragColor = vec4(grayScale(fragColor));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TILE\n//#define ROUNDED\n\n// pixellate\nconst float borderSize = 1.;\nconst float tileSize = 10.;\nconst float count = 5.;\n\n// pointillize\nconst float size = .2;\nconst float dist = .4;\nconst float alpha = .4;\t\n\n\n// https://gamedev.stackexchange.com/questions/111017/pixelation-shader-explanation\nvec4 pixellate(vec2 uv)\n{\n    vec2 tile = tileSize / iResolution.xy;\n    vec2 coord = floor(uv/tile)*tile;    \n    return texture(iChannel0, coord);   \n}\n\n// based off: https://www.shadertoy.com/view/MtfXRN\nvec4 pixellate2(vec2 uv)\n{\n    vec4 c = vec4(0.);    \n    vec2 tile = tileSize / iResolution.xy;\n    vec2 p = floor(uv/tile);\n    \n    for (float y = 0.; y < count; ++y) {\n        for (float x = 0.; x < count; ++x) {\n            vec2 coord = (p + vec2(x/count, y/count)) * tile;\n            c += texture(iChannel0, coord);\n        }\n    }\n\n    return c / vec4(count * count);\n}\n\n\n// based off: https://www.shadertoy.com/view/ls23DG\nvec4 pointillize(vec2 uv)\n{\n    vec3 tex = texture(iChannel0, uv).xyz;\n    \n    vec3 c = vec3(1.);\n    vec2 point = vec2(size)*.1;\n    point.x *= iResolution.y/iResolution.x;\n\n    vec2 m = mod(uv,point);\n    vec2 p = m/point - .3;\n    \n    float a = (length(p)-.3)*length(point)*iResolution.x;\n    \n    a = 1.-a;\n    a = min(alpha,max(0.,a));\n    c = vec3(a);\n    c = mix(c,tex,a);\n    return vec4(c,1.);\n}\n\nvec4 getBorders(vec4 fragColor, vec2 fragCoord) \n{\n    vec2 p = floor(fragCoord - tileSize);\n    p = mod(p + borderSize, tileSize);\n  \n    #ifdef TILE\n    float border = step(min(p.x,p.y), borderSize);\n    #else\n    float border = step(p.x, borderSize) * step(p.y, borderSize);\n    #endif\n    \n    return pow(fragColor, vec4(border));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;    \n\n    //fragColor = pixellate(uv);\n    fragColor = pixellate2(uv);\n\n    #if defined(TILE) || defined(ROUNDED)\n    fragColor *= getBorders(fragColor, fragCoord);\n    #endif\n    \n    //fragColor = pointillize(uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}