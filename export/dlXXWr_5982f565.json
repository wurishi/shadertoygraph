{"ver":"0.1","info":{"id":"dlXXWr","date":"1681245160","viewed":35,"name":"Raymarcher #2","username":"taka","description":"test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","ssao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEP 10.\n#define PI 3.14159265\nfloat rand(vec2 st)\n{\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sdPlane(vec3 p,vec4 n){\nreturn dot(p,n.xyz)+n.w;\n}\nfloat sdSphere(vec3 p, float r){\nreturn length(p)-r;\n}\nfloat sdCone(vec3 p, vec2 c,float h){\nfloat q = length(p.xz);\nreturn max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat intersectsdf(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionsdf(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differencesdf(float distA, float distB) {\n    return max(distA, -distB);\n}\nfloat sdf(vec3 p){\nfloat t = 0.0999;\nfloat sph,cone,plane;\nsph= min(t,sdSphere(p-vec3(0,0,10),3.));\ncone= min(t,sdCone(abs(p)-vec3(0,1.5,5),vec2(.2,0.1),3.));\nplane= min(t,sdPlane(p-vec3(0,1,1),vec4(0, 0.3, 0,1)));\nfloat res= unionsdf(sph,cone);\n//res+=unionsdf(sph,res);\nres+= unionsdf(res,plane);\nreturn res;\n//return t=sdPlane(p-vec3(0,1,1),vec4(0, 1, 0, 10));\n}\n//SSAO STUFF\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(sdf( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 GetCameraDir(vec2 st, vec3 pos, vec3 target ){\n\nvec3 camForward = normalize(target-pos);\nvec3 camRight = normalize(cross(vec3(0,1,0),camForward));\nvec3 camUp = normalize(cross(camForward,camRight));\nfloat pers= 1.5;\nvec3 viewDir = normalize(camRight*st.x +camUp*st.y + camForward *pers);\nreturn viewDir;\n}\n\nfloat castRay(vec3 ro,vec3 rd){\nfloat t =0.;\nfor(int i=0;i<100;i++){\n float result =sdf(ro+rd*t);\n if(result <0.001*t ){\n    return t;\n } \n else if ( result > MAXSTEP){\n     return -1.;\n }\n   t+=result;    \n}\nreturn -1.;   \n}\n//NORMAL CALC\nvec3 calcNormal(vec3 p){\nfloat center = sdf(p);\nvec2 e = vec2(0.001,0);\n\n    vec3 n = normalize(vec3(sdf(p+e.xyy),sdf(p+e.yxy),sdf(p+e.yyx))-center);\nreturn n;\n}\n//RENDER\nvec3 render(vec3 rorigin,vec3 rdir){\nfloat t = castRay(rorigin,rdir);\nvec3 col;\nif(t==-1.)\n{\n    col = vec3(0.3,0.36,0.6)-rdir.y*0.2;\n}\nelse {\nvec3 pos = rorigin+rdir*t;\nvec3 N = calcNormal(vec3(pos));\n    float surfaceFreq =0.5;\n    vec3 surfaceCol;\n    surfaceCol = vec3(0.9,0.5,0.1);       \n  //  surfaceCol = texture(iChannel0,pos*surfaceFreq).xyz;\n  //surfaceCol = texture(iChannel0, textureFreq * surfacePos).xyz;\n    vec3 L = normalize(vec3(sin(iTime*0.5),cos(iTime*0.5),-0.5));\n    \n    float NdotL = max(dot(N,L),0.);\n   vec3 LDir = vec3(1.9,3.9,1.9)*NdotL;\n    vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n\n    vec3 diffuse = surfaceCol *(LAmbient+LDir);\n   col = diffuse;\n   \n   float shadow =0.;\n   vec3 shadowOrigin = pos+ N * 0.01;\n   vec3 shadowDir = L;\n   float result = castRay(shadowOrigin,shadowDir);\n   if(result >=-1.) shadow = 1.;\n     col = vec3(AO(pos,N,1.0,1.5));\n   //col = mix(col,col*5.9,shadow);    \n   \n   //uncomment to view normals\n  // col = N * vec3(0.5) + vec3(0.5);\n   \n}\n//vec3 col = vec3(1.-t*0.075);\nreturn col;\n}\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float dist ) // camera to point distance\n{\nfloat b = 1.2;\n    float fogAmount = 1.0 - exp( -dist*b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = 2.*(fragCoord/iResolution.xy-0.5);\n    st.x*= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0,0,-1);\n    vec3 camTarget= vec3(0,0,0);\n      vec3 rayDir = GetCameraDir(st,camPos,camTarget);\n   \n    vec3 col =render(camPos,rayDir);\n    col =pow(col,vec3(0.4545));\n   col*= applyFog(vec3(0.15,0.,1.),2.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}