{"ver":"0.1","info":{"id":"MlBSDy","date":"1446147432","viewed":189,"name":"Asteround - Raymarching","username":"Lallis","description":"Just trying out some space stuff :)\nThanks to iq as always.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime*0.25\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nfloat smooth3D(vec3 p)\n{\n    vec3 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n\tfloat p0 = noise3D(p);\n\tfloat x = noise3D(p+vec3(1.0,0.0,0.0));\n\tfloat y = noise3D(p+vec3(0.0,1.0,0.0));\n\tfloat z = noise3D(p+vec3(0.0,0.0,1.0));\n\tfloat xy = noise3D(p+vec3(1.0,1.0,0.0));\n\tfloat xz = noise3D(p+vec3(1.0,0.0,1.0));\n\tfloat yz = noise3D(p+vec3(0.0,1.0,1.0));\n\tfloat xyz = noise3D(p+1.0);\n\t\n    return mix(\tmix(\tmix(p0, x, \t f.x), \n                    \tmix(y, \txy,  f.x), \tf.y), \n               \tmix(\tmix(z, \txz,\t f.x), \n                    \tmix(yz, xyz, f.x), \tf.y), \tf.z);\n}\n\nfloat fbm(vec3 p)\n{\n \tfloat f = 0.5000*smooth3D(p*1.00);\n    \t  f+= 0.2500*smooth3D(p*2.01);\n    \t  f+= 0.1250*smooth3D(p*4.02);\n    \t  f+= 0.0625*smooth3D(p*8.03);\n    \t  f/= 0.9375;\n    return f;\n}\n\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat sphere( vec3 rp, vec3 c, float r )\n{\n    return distance(rp, c) - r;\n}\n\nfloat map(vec3 rp)\n{\n    float d = sphere( rp, vec3(0.0), (fbm(rp*0.2)*0.5+0.5)*5.0+(fbm(rp*0.01+21.0)*0.5+0.5)*100.0 );\n    return d;\n}\n\nfloat mapCam(vec3 rp)\n{\n    return sphere( rp, vec3(0.0), (fbm(rp*0.01+21.0)*0.5+0.5)*100.0 );\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy) - map(rp-eps.xyy),\n           map(rp+eps.yxy) - map(rp-eps.yxy),   //shamelessly stolen from iq :(\n           map(rp+eps.yyx) - map(rp-eps.yyx) ) );\n\n}\n\nfloat softShadow(vec3 rp, vec3 ld)\n{\n \tvec3 ro = rp;\n    float ldmax = 20.0;\n    float td = 0.1;\n    float res = 1.0;\n    float d;\n    for(int i = 0; i < 64; i++)\n    {\n     \trp = ro + ld * td;\n        d = map( rp );\n        if( d < 0.01 || td >= ldmax )\n        {\n         \tbreak;   \n        }\n        res = min(res,8.0*d);\n        td += d;\n    }\n    if( d < 0.01 )\n    {\n     \tres = 0.0;   \n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if( iMouse.xy == vec2(0.0) )\n    {\n       m = vec2(0.5);     \n    }\n    vec3 col = vec3(0.0);\n    \n    vec3 cam = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize( vec3( p, 0.0 ) - cam );\n    vec3 ro = vec3(0.0, 100.0, 0.0);\n    vec3 rp;\n\n    vec3 ang = vec3( 3.14*(0.5-(sin(time*0.2+1.54)*0.5+0.5)*0.25), 3.14*0.0, 3.14*0.0 );\n     rd *= rot(ang);\n    ang = vec3(m.y*6.28-3.14, m.x*6.28-3.14, 0.0);\n    \n    ro *= rot(ang);\n    rd *= rot(ang);\n    \n    ang =  vec3( time*0.25+3.14*1.25, 0.0, 0.0 );\n    ro *= rot( vec3( ang ) );\n    rd *= rot( vec3( ang ) );\n    \n    vec3 rod = normalize(ro);\n    \n    ro -= rod*(mapCam(ro)-(25.0+(sin(time*0.2-1.54)*0.5+0.5)*225.0));\n    \n    vec3 s = normalize(vec3(0.5,0.25,1.0));\n    \n    vec3 stars = vec3(smooth3D(rd*300.0)*0.5+0.5);\n    col = mix(col, vec3(0.8,0.9,1.0), smoothstep(0.95, 1.0, stars)*clamp(dot(-s,rd)+0.75,0.0,1.0));\n    col = clamp(col, 0.0, 1.0);\n    \n    rd -= s;\n\tfloat rdatan = abs(atan(rd.y, rd.x)) ;\n    rd += s;\n    \n    float srd = max(0.0,dot(s,rd))*(fbm(vec3(rdatan*2.0,time*0.5,0.0))*0.5+0.5); \n    col = mix(col,vec3(1.0,0.8,0.4),0.10*srd);\n    \n    float ss = smoothstep( 0.0, 1.0, dot(rd, s) );  \n    float sss = smoothstep( 0.8, 1.0, dot(rd, s) );\n    col += 0.4*pow(ss,5.0)*vec3(1.0,0.7,0.6)*1.0;    // from iq's shader https://www.shadertoy.com/view/llj3Rz\n    col += 0.4*pow(sss,64.0)*vec3(1.0,0.9,0.7)*2.0;   //\n    \n    \n    float td = 0.0;\n    const float maxd = 500.0;\n    float d = 0.0;\n    float dp = 0.01;\n\n    \n    for( int i = 0; i < 512; i++ )\n    {\n        rp = ro + rd * td;\n     \td = map( rp );\n        if( d < dp || td >= maxd )\n        {\n         \tbreak;   \n        }\n        td += d*(0.25+td/(maxd*2.0));\n    }\n\n    if( d < dp )\n    {\n        vec3 n = normal(rp);\n        col = clamp(col, 0.0, 1.0);\n     \tcol = vec3(0.2, 0.25, 0.3)*(fbm(rp*4.0 +100.0)*0.5+0.5);\n        \n        float sha = softShadow( rp, s );\n        float sun = clamp( dot( n, s ), 0.0, 1.0 );\n        \n        vec3 lighting = vec3(0.0);\n        lighting += sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lighting += vec3(0.05);\n        col = clamp(col, 0.0, 1.0);\n        col *= lighting;\n    }\n    \n    col = pow(col , vec3(0.45));\n    float t = 0.5;\n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018);\n    \n     float jitter = (noise3D(rd)*2.0-1.0)*2.0/256.0;\n    col += jitter;\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}