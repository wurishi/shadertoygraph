{"ver":"0.1","info":{"id":"ss2cWW","date":"1643562810","viewed":100,"name":"UniqueFractal","username":"mAmaro","description":"I used this articles implementation. https://blog.bede.io/how-to-render-a-fractal-fast/ ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractalmandelbrot","sets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Miguel Amaro\n// Title: Fractals\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n#define MAX_ITR (800.0)\n#define MAX_X 400.0\n#define MAX_Y 400.0\n#define X_LOWER -10.0\n#define X_UPPER 1.0\n#define Y_LOWER -90.0\n#define Y_UPPER 1.0\n\nstruct cplx\n{\n    float r;\n    float i;\n};\n\ncplx cplxInit(float r, float i)\n{\n    cplx c;\n    c.r = r;\n    c.i = i;\n    return c;\n}\n\n//Complex Operations\n#define  cplx_abs(a)     length(vec2(a.r, a.i))\n#define  cplx_add(a, b)  cplxInit(a.r + b.r, a.i + b.i)\n#define  cplx_prod(a, b) cplxInit(a.r*b.r-a.i*b.i, a.r*b.i+a.i*b.r)\n#define  cplx_conj(a)    cplxInit(a.r,-a.i)\n#define  cplx_div(a, b)  cplxInit(((a.r*b.r+a.i*b.i)/(b.r*b.r+b.i*b.i)),((a.i*b.r-a.r*b.i)/(b.r*b.r+b.i*b.i)))\n\nfloat Iterations(float cr, float ci)\n{\n    cplx z = cplxInit(0.0, 0.0);\n\tcplx c = cplxInit(cr , ci );\n    float Result  = 0.0;\n    for(float ItrCount = 0.0; ItrCount < MAX_ITR; ItrCount += 1.0)\n    {\n        z      = cplx_add(cplx_prod(z, z), c);\n        Result = ItrCount;\n        if(cplx_abs(z) > 4.0) break;\n    }\n    return Result;\n}\n\nfloat LinearMap(float val,\n                float lower1, float upper1,\n                float lower2, float upper2)\n{\n    return ((val - lower1) / (upper1 - lower1)) * \n           (upper2 - lower2) + lower2;\n}\nvec3 GetColor(vec2 pos, float time)\n{\n    \n    float x = LinearMap(pos.x, 0.0, MAX_X, X_LOWER, X_UPPER);\n    float y = LinearMap(pos.y, 0.0, MAX_Y, Y_LOWER, Y_UPPER);\n    //TODE(): Iterations() is supposed take x and y but i got it \n    //        working without it. lol So get it working properly.\n    float Itr = Iterations(pos.x, pos.y);\n    vec3 Color;\n    Color.b = 2.0 / LinearMap(Itr, 0.0, MAX_ITR, 0.0, 256.0);\n    Color.g = (1.0 - abs(sin(time * 0.24))) * Color.b;\n    Color.r = max(Color.b * 0.4, 0.2);\n    \n    return Color;\n}\n\nmat2 rotate(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle),\n               sin(angle), cos(angle));\n}\n\nfloat LinearZoom(float time)\n{\n    float slowtime = time * 0.03;\n    return 1.0 - pow(abs(sin(PI * slowtime / 2.0)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n    vec3  u_resolution = iResolution;\n    vec4  u_mouse = iMouse;\n\n    vec2 st = fragCoord.xy/u_resolution.xy;\n    \n    float zoomrange = 4.0;\n\tfloat zoom      = max(zoomrange * LinearZoom(u_time), 0.6);\n    \n    //Aspect Ratio\n    float aspectratio = u_resolution.x/u_resolution.y;\n    st.x *= aspectratio;\n\n    vec2 center = vec2(0.5, 0.5);\n    //NOTE(): The idea is to scale the movement vector according to\n    //        the zoom. Sensitivity is jank.\n    float sensitivity  = 0.8 * zoom /zoomrange;\n    float usermovslack = (zoomrange - zoom) * 20.0;\n    vec2  usermovdir   = (center - (u_mouse.xy/ u_resolution.xy));\n    vec2  userinput    =  sensitivity * usermovdir * usermovslack;\n    \n    st -= center + userinput;\n\tst = rotate(u_time * 0.1) * st;\n    \n    fragColor = vec4(GetColor(st * zoom, u_time), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}