{"ver":"0.1","info":{"id":"lt2Bz3","date":"1516755053","viewed":968,"name":"Kirby Raymarch","username":"leon","description":"⊂(◉‿◉)つ Kirby !","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","kirby"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ⊂(◉‿◉)つ Kirby !\n// Leon 2018/01/24\n// Using code from IQ, Mercury, LJ, Duke, Koltes\n\n#define STEPS 30.\n#define VOLUME .01\n#define FAR 10.\n#define PI 3.14159\n#define TAU 2.*PI\n\nconst vec3 pink = vec3(0.917,0.482,0.663);\nconst vec3 red = vec3(0.825,0.142,0.111);\nconst vec3 beige = vec3(0.905, 0.670, 0.235);\nconst vec3 blue = vec3(0.058, 0.074, 0.560);\nconst vec3 blueSky = vec3(0.741, 0.941, 1);\nconst vec3 green1 = vec3(0.298,0.830,0.153);\nconst vec3 green2 = vec3(0.038,0.260,0.047);\nconst vec3 gold = vec3(1, 0.858, 0.058);\n\n// sdf toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, float c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\nfloat smoo (float a, float b, float r) { return clamp(.5+.5*(b-a)/r, 0., 1.); }\nfloat smin (float a, float b, float r) { float h = smoo(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nfloat smax (float a, float b, float r) { float h = smoo(a,b,r); return mix(a,b,h)+r*h*(1.-h); }\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nvec3 lookAt (vec3 eye, vec3 target, vec2 uv) {\n  vec3 forward = normalize(target-eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(forward + uv.x * right + uv.y * up);\n}\n\nstruct Shape {\n    float dist;\n    vec3 color;\n    float spec;\n    float glow;\n};\nShape newShape () { Shape shape; shape.dist = 1000.; shape.color = vec3(1.); shape.spec = 0.; shape.glow = 0.; return shape; }\nShape add (Shape a, Shape b) { Shape c = newShape(); c.dist = min(a.dist, b.dist); float op = step(b.dist, a.dist); c.color = mix(a.color, b.color, op); c.spec = mix(a.spec, b.spec, op); c.glow = mix(a.glow, b.glow, op); return c; }\nShape map (vec3 p);\n\nvec3 getNormal (vec3 p) { vec2 e = vec2(.01,0); return normalize(vec3(map(p+e.xyy).dist-map(p-e.xyy).dist,map(p+e.yxy).dist-map(p-e.yxy).dist,map(p+e.yyx).dist-map(p-e.yyx).dist)); }\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t = VOLUME*10.;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        float dist = map(pos + dir * t).dist;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nShape sdKirby (vec3 pos) {\n    Shape kirby = newShape();\n    vec3 p;\n\n    // foot\n    p = pos;\n    p.x = abs(p.x)-.4;\n    p.y += 1.;\n    p.z += .35;\n    p.z *= .65;\n    float foot = sdSphere(p, .4);\n    foot = smax(foot, -p.y, .2);\n\n    // breath animation\n    float wave = .5+.5*sin(iTime*5.);\n    pos.y += 1.;\n    pos.y *= 1.+.1*wave;\n    pos.y -= 1.;\n    pos.xz *= 1.-.1*wave;\n\n    // body\n    p = pos;\n    float body = sdSphere(p, 1.);\n\n    // hand\n    p = pos;\n    p.x = abs(p.x)-1.;\n    p.xy *= rot(PI/3.);\n    p.x *= .75;\n    p.y *= 1.5;\n    float hand = sdSphere(p, .4);\n\n    // body compo\n    kirby.dist = min(min(body, foot), hand);\n    kirby.color = mix(pink, red, step(foot, body));\n    // kirby.spec = 1.;\n    kirby.glow = 1.;\n\n    // eyes\n    p = pos;\n    p.y -= .3;\n    p.y *= 1./smoothstep(.0,.1,abs(sin(iTime)));\n    p.x = abs(p.x) - .2;\n    p.x *= 2.;\n    p.y *= .75;\n    kirby.color = mix(kirby.color, vec3(0), step(length(p.xy), .2));\n    p.y -= .1;\n    p.y *= 1.6;\n    kirby.color = mix(kirby.color, vec3(1), step(length(p.xy), .1));\n    p.y += .2;\n    p.x *= .75;\n    p.y *= .4;\n    kirby.color = mix(kirby.color, blue, clamp(-p.y*10.,0.,1.)*step(length(p.xy), .1));\n\n    // open mouth\n    p = pos;\n    p.x *= .5;\n    p.y += .2-abs(p.x*.2);\n    float d = length(p.xy);\n    float mouth = step(d, .1);\n    kirby.color = mix(kirby.color, red, mouth);\n    kirby.color = mix(kirby.color, red*.1, mouth*(1.-clamp(-p.y*10.+.5,0.,1.)));\n\n    // cheeks\n    p = pos;\n    p.x = abs(p.x) - .5;\n    p *= 6.;\n    p.x *= .75;\n    kirby.color = mix(kirby.color, red, .75*(1.-smoothstep(0.5,1.,length(p.xy))));\n\n    return kirby;\n}\n\nShape sdGround (vec3 pos) {\n    Shape ground = newShape();\n    vec3 p;\n    p = pos;\n    p.y += 1.;\n    float cell = .5;\n    float height = .2;\n    float padding = .45;\n    p.xz = repeat(p.xz, cell);\n    p.y += 1. + height;\n    ground.dist = smin(p.y, sdBox(p, vec3(cell*padding, height, cell*padding)), .2);\n    p.y -= 1.;\n    ground.dist = smin(ground.dist, max(sdBox(pos,vec3(1,3,1)),sdBox(p, vec3(cell*padding, height, cell*padding))), .2);\n    ground.color = beige;\n    return ground;\n}\n\nShape sdPlant (vec3 pos) {\n    Shape plant = newShape();\n    plant.spec = .5;\n    plant.glow = 1.;\n    float radius = 2.;\n    pos.y += 1.;\n    pos.xyz = pos.zxy;\n    vec3 p = pos;\n    p.xy = toroidal(p.xy, radius);\n    p.y *= 2.;\n    p.xz *= rot(p.y * 2.+sin(p.y+iTime));\n    float id = amod(p.xz,2.);\n    p.x -= .2;\n    p.xz *= rot(-p.y+iTime+sin(p.y-iTime*2.)*5.);\n    id += amod(p.xz, 4.);\n    p.x -= .1;\n    plant.dist = sdCylinder(p.xz, .04);\n    plant.color = mix(green1, green2, mod(id,2.));\n    return plant;\n}\n\n\nShape sdStar (vec3 pos) {\n    Shape star = newShape();\n    star.spec = 1.;\n    star.glow = 1.;\n    float radius = 5.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    amod(p.xy, 5.);\n    star.dist = sdIso(p, size);\n    star.color = gold;\n    return star;\n}\n\nShape map (vec3 pos) {\n    Shape scene = newShape();\n    vec3 p = pos;\n    scene = add(scene, sdKirby(p));\n    scene = add(scene, sdGround(p));\n    scene = add(scene, sdPlant(p));\n    scene = add(scene, sdStar(p));\n    return scene;\n}\n\n\nvec3 camera (vec3 p) {\n    float click = clamp(iMouse.z, 0., 1.);\n    p.yz *= rot(click*(-.25*PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot(click*(-.5*PI*(iMouse.x/iResolution.x-.5)));\n    p.xz *= rot((1.-click)*(.5*PI*(.4*sin(iTime*.1))));\n    return p;\n}\n\nvec3 raymarch (vec2 uv) {\n    vec3 eye = camera(vec3(0,1,-5.5));\n    vec3 ray = lookAt(eye, vec3(0), uv);\n    float shade = 0., dist = 0.;\n    vec3 pos = eye;\n    Shape shape;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        shape = map(pos);\n        if (shape.dist < VOLUME || dist > FAR) { shade = 1.-i; break; }\n        shape.dist *= .9 + .1 * rng(uv+fract(iTime));\n        dist += shape.dist;\n        pos = eye + ray * dist;\n    }\n\t   vec3 color = shape.color;\n    vec3 normal = getNormal(pos);\n    vec3 view = normalize(eye-pos);\n    vec3 lightPos = vec3(1.,0,-2.);\n    lightPos.xy *= rot(iTime*.5);\n    lightPos.y += 2.;\n    vec3 lightDir = normalize(lightPos-pos);\n    float light = clamp(dot(lightDir, normal),0.,1.);\n    float ambient = .8;\n    color = mix(shape.color * ambient, shape.color, light);\n    color = mix(color, vec3(1), shape.spec*clamp(pow(light,16.),0.,1.));\n    color *= .3+.7*getShadow(pos, lightPos, 64.)*clamp(dot(lightDir,normal),0.,1.);\n    color = mix(color, shape.color, (1.-abs(dot(normal, view))) * shape.glow);\n    color *= shade;\n    float far = 1.-smoothstep(FAR/2.,FAR,dist);\n    float y = uv.y + sin(uv.x*3.-iTime+sin(uv.x*6.+iTime))*.05;\n    color = mix(beige*abs(y), color, far);\n    color = pow(color, vec3(1./2.));\n    color = mix(color, mix(blueSky, blue, y), (1.-far)*step(0.,y));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfragColor = vec4(raymarch(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}