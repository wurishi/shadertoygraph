{"ver":"0.1","info":{"id":"dtGcz3","date":"1702817606","viewed":28,"name":"Bahaus","username":"Saimon","description":"Animated reproduction of this image: https://desenio.fr/p/affiches/peintres-celebres/bauhaus/bauhaus-1923-affiche/","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["color","circle","bahaus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \"Bahaus\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is the first one of the serie, it follows Bauhaus esthetic, \n * and is based on: https://i.pinimg.com/564x/02/e1/3c/02e13c96109051f12d6d0c62198402e9.jpg\n * (November 2023)\n */\n\n#define PI 3.14 \n\n// Source of code: https://thebookofshaders.com/07/\nvec3 circle(in vec2 center, in float radius, in vec2 st, in vec3 color){\n  vec2 dist = st - center;\n  return 1. - vec3(1. - smoothstep(radius-(radius*0.01),\n                   radius+(radius*0.01),\n                   dot(dist,dist)*4.0)) + color;\n}  \n\n// Clamp the color to make sure it's between [0;1]\nvec3 clampColor(in vec3 color){\n    return vec3(clamp(color.x,0.,1.), clamp(color.y,0.,1.), clamp(color.z,0.,1.));\n}\n\n\nvec3 circleBorder(in vec2 center, in float radius, in vec2 st, in vec3 color, in float borderSize){\n     return circle(center, radius, st, color)+vec3(1.)-(circle(center, radius - borderSize, st, vec3(0.)));\n}\n\n// Source of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat easeInOutExpo(float t) {\n  if (t == 0.0 || t == 1.0) {\n      return t;\n  }\n  if ((t *= 2.0) < 1.0) {\n      return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n  } else {\n      return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n  }\n}\n\n// Source of code: https://www.febucci.com/2018/08/easing-functions/\nfloat Flip(float _x) {\n  return 1. - _x;\n}\n\n// Source of code: https://www.febucci.com/2018/08/easing-functions/\nfloat tweenEaseInOutExpo(float _t) {\n  if (_t <= .5)\n      return easeInOutExpo(_t / .5);\n\n  return easeInOutExpo(Flip(_t)/.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    st.x *= aspect_ratio;\n    float t = fract(iTime/3.);\n    \n    vec3 YELLOW = vec3(0.941,0.588,(0.004));\n    vec3 ORANGE = vec3(0.914,0.349,0.141);\n    vec3 RED = vec3(0.902,0.118,(0.167));\n \n    vec2 center = vec2(0.5*aspect_ratio,0.5);\n \n    // Here the division of the tween aren't completly random. \n    // Indeed, I want my yellow circle to have a radius of 0.6 considering a border of 0.3.\n\t// To simulate this I divide tween out value between [0,1] by the number that could give me what I want:\n    // (1. / 1.66 = 0.6) and (1./3.3 = 0.3)\n    vec3 c1 = circleBorder(center, tweenEaseInOutExpo(t)/1.66, st, YELLOW,tweenEaseInOutExpo(t)/3.3);\n    // Same explanation here, I want a raduis of 0.3 considering a border of 0.2\n    // (1. / 3.3 = 0.3) and (1./5. = 0.2)\n    vec3 c2 = circleBorder(center, tweenEaseInOutExpo(t)/3.3, st, ORANGE,tweenEaseInOutExpo(t)/5.);\n    // Same here, you get the idea\n    vec3 c3 = circle(center, tweenEaseInOutExpo(t)/9.5, st, RED);\n\n    vec3 color = clampColor(c1)*clampColor(c2)*c3;\n\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}