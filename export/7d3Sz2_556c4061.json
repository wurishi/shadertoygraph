{"ver":"0.1","info":{"id":"7d3Sz2","date":"1633595095","viewed":140,"name":"Pong The Game","username":"Famousghost","description":"My First shader with Keyboard.\nSimple pong game in fragment shader:\n\nW/S left Paddle\nUp Arrow/ Down Arrow -> right Paddle","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["sdfpongmovementbuffers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//thanks to PrzemyslawZaworski algorithm for text gen from \"Shader Text for beginners\"\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) U.x-=.5; fragColor+= char(U,48+c).xxxx\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat sdCircle(vec2 uv, vec2 offset, float r)\n{\n    return length(uv - offset) - r;\n}\n\nfloat sdBox( in vec2 uv, in vec2 size, vec2 offset )\n{\n  uv -= offset;\n  vec2 d = abs(uv)-size;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat drawPaddles(vec2 uv, vec2 posPaddle1, vec2 posPaddle2)\n{\n    float paddle1 = sdBox(uv, vec2(0.015f, 0.06f), posPaddle1);\n    float paddle2 = sdBox(uv, vec2(0.015f, 0.06f), posPaddle2);\n    return min(paddle1, paddle2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    \n    \n    vec4 circle = texture(iChannel2, uv).rgba;\n    vec2 paddlePos1 = texture(iChannel0, uv).rg;\n\n    vec2 paddlePos2 = texture(iChannel1, uv).rg;\n\n    vec3 col = vec3(0.0f);\n    \n    float radius = 0.015f;\n    \n    float scene = sdCircle(uv, circle.rg, radius);\n    \n    scene = min(scene, drawPaddles(uv, paddlePos1, paddlePos2));\n\n    if(scene < 0.0f)\n    {\n        col = vec3(1.0f);\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n    vec2 paddleUv1 = fragCoord/iResolution.y;\n    vec2 position1 = vec2(0.3f, 0.9f);\n    float FontSize = 8.;\n    vec2 U = ( paddleUv1 - position1)*64.0/FontSize;\n    C(int(circle.b));\n    \n    vec2 paddleUv2 = fragCoord/iResolution.y;\n    vec2 position2 = vec2(1.3f, 0.9f);\n    U = ( paddleUv2 - position2)*64.0/FontSize;\n    C(int(circle.a));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_UP    = 87;\nconst int KEY_DOWN  = 83;\n\nconst float velocity = 1.0f;\n\nfloat handleInput()\n{\n    float up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n    float down = -texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n    \n    return (up + down) * velocity * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    vec2 paddle = texture(iChannel0, uv).rg;\n    paddle.x = -0.85f;\n    paddle.g += handleInput();\n    paddle.g = clamp(paddle.g, -0.45f, 0.45f);\n    fragColor = vec4(paddle.rg, 0.0f, 0.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\nconst float velocity = 1.0f;\n\nfloat handleInput()\n{\n    float up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n    float down = -texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n    \n    return (up + down) * velocity * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    vec2 paddle = texture(iChannel0, uv).rg;\n    paddle.x = 0.85f;\n    paddle.g += handleInput();\n    paddle.g = clamp(paddle.g, -0.45f, 0.45f);\n    fragColor = vec4(paddle.rg, 0.0f, 0.0f);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float velocity = 1.0f;\n\nvoid circleSceneColiision(inout vec2 circlePos, float radius, out float points1, out float points2)\n{ \n    if(((circlePos.x + (2.0f * radius))) >= 0.9f)\n    {\n        if(iFrame % 2 == 0)\n        {\n            points1 += 1.0f;\n            circlePos = vec2(0.0f, 0.0f);\n        }\n    }\n    \n    if(((circlePos.x - (2.0f * radius))) <= -0.9f)\n    {\n        if(iFrame % 2 == 0)\n        {\n            points2 += 1.0f;\n            circlePos = vec2(0.0f, 0.0f);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    vec2 circlePos = texture(iChannel0, uv).rg;\n    vec2 circleVel = texture(iChannel1, uv).rg * velocity;\n    float points1 = texture(iChannel0, uv).b;\n    float points2 = texture(iChannel0, uv).a;\n    float radius = 0.015f;\n    circlePos += circleVel * iTimeDelta;\n    circleSceneColiision(circlePos, radius, points1, points2);\n    circlePos = clamp(circlePos, vec2(-1.0f, -1.0f), vec2(1.0f, 1.0f));\n    \n    \n    if(points1 > 9.0f || points2 > 9.0f)\n    {\n        points1 = 0.0f;\n        points2 = 0.0f;\n    }\n    fragColor = vec4(circlePos, points1, points2);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float SPEED = 2.0f;\n\n\nfloat findClosestPointOnAxis(float spherePos, float mins, float maxs)\n{\n    float closestPoint = 0.0f;\n\n    if(spherePos >= maxs)\n    {\n        closestPoint = maxs;\n    }\n    if(spherePos <= mins)\n    {\n        closestPoint = mins;\n    }\n    if(spherePos <= maxs && spherePos >= mins)\n    {\n        closestPoint = spherePos;\n    }\n    \n    return closestPoint;\n}\n\nvoid circleBoxCollision(vec2 circlePos, float radius, vec2 box, vec2 size, out vec2 circleVel)\n{\n    float maxX = max(box.x - size.x, box.x + size.x);\n    float maxY = max(box.y - size.y, box.y + size.y);\n    \n    float minX = min(box.x - size.x, box.x + size.x);\n    float minY = min(box.y - size.y, box.y + size.y);\n    \n    vec2 closestPoint = vec2(findClosestPointOnAxis(circlePos.x, minX, maxX), findClosestPointOnAxis(circlePos.y, minY, maxY));\n    \n    if(distance(circlePos, closestPoint) < radius)\n    {\n        circleVel = (circlePos - box) * 50.0f;\n    }\n}\n\nvoid circleSceneColiision(inout vec2 circlePos, out vec2 circleVel, float radius)\n{\n    if(((circlePos.y + (2.0f * radius))) >= 0.5f)\n    {\n        circleVel.y *= -1.0f;\n    }\n    if(((circlePos.y - (2.0f * radius))) <= -0.5f)\n    {\n        circleVel.y *= -1.0f;\n    }\n}\n\nvec2 boxSize = vec2(0.015f, 0.06f);\nvec2 circleVel = vec2(1.0f, 1.0f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    vec2 circle = texture(iChannel1, uv).rg;\n    circleVel = texture(iChannel0, uv).rg;\n    if(circle == vec2(0.0f) && circleVel != vec2(0.0f))\n    {\n        circleVel = vec2(0.5f, 0.5f);\n    }\n    \n    vec2 paddle1Pos = texture(iChannel2, uv).rg;\n    vec2 paddle2Pos = texture(iChannel3, uv).rg;\n    \n    if(circleVel == vec2(0.0f))\n    {\n        circleVel = vec2(1.0f, 1.0f);\n    }\n    float radius = 0.015f;\n    circleSceneColiision(circle.rg, circleVel, radius);\n    circleBoxCollision(circle.rg, radius, paddle1Pos, boxSize, circleVel);\n    circleBoxCollision(circle.rg, radius, paddle2Pos, boxSize, circleVel);\n    fragColor = vec4(normalize(circleVel) * SPEED,0.0f,0.0f);\n}","name":"Buffer D","description":"","type":"buffer"}]}