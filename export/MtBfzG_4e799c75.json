{"ver":"0.1","info":{"id":"MtBfzG","date":"1516256426","viewed":281,"name":"Purple sphere","username":"impiaaa","description":"Recreation, from memory, of:\nhttps://twitter.com/Titouan_Millet/status/849381926930714629\nMade to replace my purple dot avatar picture","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","colorful","sphere","circle","animated","trigonometry","motiongraphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Recreation, from memory, of:\n// https://twitter.com/Titouan_Millet/status/849381926930714629\n\nconst float pi = 3.141592654;\nconst float radius = 0.8; // how big the circle is\nvec3 top = vec3(1.0, 0.65, 1.0); // color on top\nvec3 bottom = vec3(0.65, 0.5, 1.0); // color on bottom\nconst vec3 backside = vec3(0.5, 0.0, 0.15); // backface color\nconst vec3 background = vec3(1.0, 1.0, 1.0); // background color\nconst float angle = -0.125*pi; // tilt angle (radians)\nconst float fillspeed = 0.25;\nconst float rockspeed = 0.9;\n\nfloat noise(vec2 v) {\n    // stretched texture noise\n\treturn texture(iChannel0, v/vec2(128.0, 32.0)).x;\n}\n\nfloat cutoff(vec3 v) {\n    // calculate normal of a plane rocking back and forth\n    float rockx = cos(rockspeed*iTime*pi)*0.125;\n    float rockz = sin(rockspeed*iTime*pi)*0.25+sin(angle); // offset to face the camera\n    vec4 plane = vec4(rockx, sqrt(1.0-(rockx*rockx)-(rockz*rockz)), rockz, 0.0);\n    \n    // distance from v to plane\n    float dist = (dot(plane.xyz, v) + plane.w) / length(vec3(plane));\n    \n    // magic numbers\n    return dist*0.4+0.5+(noise(v.xy)*0.2-0.1);\n    // the rocking plane cutoff is kinda hidden because of the noise... ah well\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n    // https://en.wikipedia.org/wiki/HSL_and_HSV\n    float c = v*s;\n    float x = c*(1.0-abs(mod(h, 2.0)-1.0));\n    vec3 rgb;\n    if (h < 1.0)\n        rgb = vec3(c, x, 0);\n    else if (h < 2.0)\n        rgb = vec3(x, c, 0);\n    else if (h < 3.0)\n        rgb = vec3(0, c, x);\n    else if (h < 4.0)\n        rgb = vec3(0, x, c);\n    else if (h < 5.0)\n        rgb = vec3(x, 0, c);\n    else\n        rgb = vec3(c, 0, x);\n    float m = v-c;\n    return rgb+m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // uncomment for ~rainbow~\n    //top = hsv2rgb(mod(iTime+0.7, 6.0), 0.35, 1.0);\n    //bottom = hsv2rgb(mod(iTime, 6.0), 0.5, 1.0);\n    //backside = vec3(0.0, 0.0, 0.0);\n    \n    // convert pixel coordinates to -1..1 x/y coordinates\n\tvec2 screenspace = (((fragCoord.xy - 0.5*(iResolution.xy - vec2(min(iResolution.x, iResolution.y)))) / min(iResolution.x, iResolution.y))*2.0)-1.0;\n    \n    float dist = length(screenspace);\n    if (dist < radius) {\n        // convert x/y view coordinates to \"model\" space\n        vec3 modelspace = vec3(screenspace / radius, 0.0);\n        // calculate the depth of the surface of the sphere\n        modelspace.z = sqrt(1.0-(modelspace.x*modelspace.x)-(modelspace.y*modelspace.y));\n        \n        // convert cartesian x/y/z to spherical coordinates (rotated)\n        //float r = length(modelspace); // it's a sphere, so r is constant\n        float inclination = acos(modelspace.x);\n        float azimuth = atan(modelspace.z, modelspace.y);\n        \n        // rotate downwards a bit\n        azimuth += angle;\n        \n        // convert back to cartesian, \"projected\" space\n        vec3 proj = vec3(cos(inclination),\n                         sin(inclination)*cos(azimuth),\n                         sin(inclination)*sin(azimuth));\n        \n        // timeline\n        float thresh = sin(fillspeed*iTime*pi)*0.5+0.5;\n        \n        // calculate at what point the sphere is cut off, and compare for each pixel\n        if (cutoff(proj) < thresh) {\n\t\t\tfragColor = vec4(mix(bottom,top,proj.y*0.5+0.5), 1.0);\n        }\n        else {\n            // backside\n            // flip z of our original cartesian space for an outer facing sphere\n            modelspace.z *= -1.0;\n            \n            // back to spherical\n            azimuth = atan(modelspace.z, modelspace.y);\n            azimuth += angle;\n            \n            // back to cartesian\n            proj.y = sin(inclination)*cos(azimuth);\n            proj.z = sin(inclination)*sin(azimuth);\n            \n            if (cutoff(proj) < thresh) {\n            \tfragColor = vec4(backside, 1.0);\n            }\n            else {\n                fragColor = vec4(background, 1.0);\n            }\n        }\n    }\n    else {\n        fragColor = vec4(background, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}