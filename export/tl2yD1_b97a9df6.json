{"ver":"0.1","info":{"id":"tl2yD1","date":"1686187565","viewed":48,"name":"SDF Morphing test","username":"MartinRGB","description":"sdf morhping test\nreference:\nhttps://www.shadertoy.com/view/3dVyWz","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdfmorhping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ######## distance functions #######\n//https://iquilezles.org/articles/distfunctions\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\n// Distance to scene\nfloat M(vec3 p) {\n\n \n    float bShape,dShape;\n    float pShape;\n    vec3 q = abs(vec3(p.x,p.y-0.5,p.z)) - 0.5;\n  \tbShape = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) ;\n    dShape = length(p-vec3(0,.45,0))-1.1;\n\t\n    vec3 a = vec3(0.,0.5,-0.5);\n    vec3 b = vec3(0.,0.5,0.5);\n    vec3 pa = p - a, ba = b - a;\n  \tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tpShape =  length( pa - ba*h ) - 0.5;\n\t// !!! The morphing is here !!!\n    return mix(dShape, pShape, (sin(iTime) + 1.)/2.);\n}\n\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n    vec2 d = vec2(-1,1) * pitch;\n\tvec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx; // tetrahedral offsets\n\tfloat f0 = M(p0), f1 = M(p1), f2 = M(p2), f3 = M(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=0., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>10.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = vec3(0.,0.,0.);\n\t\t\n    // Calculate color on point\n\tif (h < .0001) {\n\t\tx = o + t * d ;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = vec3((sin(iTime)+1.)/2.,(cos(iTime)+1.)/2.,1.); \n\t\t// Shading\n\t    c = mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}","name":"Image","description":"","type":"image"}]}