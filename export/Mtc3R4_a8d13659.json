{"ver":"0.1","info":{"id":"Mtc3R4","date":"1469326697","viewed":161,"name":"Shift Lens Demo","username":"soma_arc","description":"Shift lens demo.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","shiftlens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    /*\n    Created by soma_arc - 2016\n    This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n    */\n\n\n    // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n    vec2 rand2n(vec2 co, float sampleIndex) {\n        vec2 seed = co * (sampleIndex + 1.0);\n        seed+=vec2(-1,1);\n        // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n        return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                    fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n    }\n\n    vec3 rotate(vec3 p, float angle, vec3 axis){\n      vec3 a = normalize(axis);\n      float s = sin(angle);\n      float c = cos(angle);\n      float r = 1.0 - c;\n      mat3 m = mat3(\n          a.x * a.x * r + c,\n          a.y * a.x * r + a.z * s,\n          a.z * a.x * r - a.y * s,\n          a.x * a.y * r - a.z * s,\n          a.y * a.y * r + c,\n          a.z * a.y * r + a.x * s,\n          a.x * a.z * r + a.y * s,\n          a.y * a.z * r - a.x * s,\n          a.z * a.z * r + c\n      );\n      return m * p;\n    }\n\n    const float PI = 3.14159265359;\n    const float PI_2 = PI/2.;\n    const float EPSILON = 0.001;\n    const int MTL_SPHERE = 1;\n    const int MTL_PLANE = 2;\n    int g_mtl = -1;\n\n    vec4 intersectSphere(vec3 sphereCenter, float radius, \n                          vec3 rayOrigin, vec3 rayDir, vec4 isect){\n        vec3 v = rayOrigin - sphereCenter;\n        float b = dot(rayDir, v);\n        float c = dot(v, v) - radius * radius;\n        float d = b * b - c;\n        if(d >= 0.){\n            float s = sqrt(d);\n            float t = -b - s;\n            if(t <= EPSILON) t = -b + s;\n            if(EPSILON < t && t < isect.x){\n                vec3 p = (rayOrigin + t * rayDir);\n                g_mtl = MTL_SPHERE;\n                return vec4(t, normalize(p - sphereCenter));\n            }\n        }\n        return isect;\n    }\n\n    vec4 intersectPlane(vec3 p, vec3 n, \n                        vec3 rayOrigin, vec3 rayDir, vec4 isect){\n        float d = -dot(p, n);\n        float v = dot(n, rayDir);\n        float t = -(dot(n, rayOrigin) + d) / v;\n        if(EPSILON < t && t < isect.x){\n            g_mtl = MTL_PLANE;\n            return vec4(t, n);\n        }\n        return isect;\n    }\n\n    vec4 intersectXYRect (vec2 p1, vec2 p2, float z,\n                          vec3 rayOrigin, vec3 rayDir, vec4 isect){\n        float t = (z - rayOrigin.z) / rayDir.z;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = rayOrigin + t * rayDir;\n            if(p1.x < p.x && p.x < p2.x &&\n               p1.y < p.y && p.y < p2.y ){\n\n                return vec4(t, vec3(0, 0, 1));\n            }\n        }\n        return isect;\n    }\n\n    vec4 intersectYZRect (vec3 p1, vec3 p2, float x, bool flip,\n                          vec3 rayOrigin, vec3 rayDir, vec4 isect){\n        float t = (x - rayOrigin.x) / rayDir.x;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = rayOrigin + t * rayDir;\n            if(p1.y < p.y && p.y < p2.y &&\n               p1.z < p.z && p.z < p2.z ){\n                if(flip){\n                \treturn vec4(t, vec3(-1, 0, 0));\n                }else{\n                \treturn vec4(t, vec3(1, 0, 0));\n                }\n            }\n        }\n        return isect;\n    }\n\n    const vec3 BLACK = vec3(0);\n    vec3 spherePos = vec3(0, .5, 0);\n    vec3 spherePos2 = vec3(3.5, .5, 0);\n    vec3 spherePos3 = vec3(-3.5, .5, 0);\n\n    float sphereR = .5;\n    vec3 planeP = vec3(0, 0, 0);\n    vec3 planeN = normalize(vec3(0, 1, 0));\n\n    float lightVisibility(vec3 org, vec3 target){\n        vec3 v = target - org;\n        vec4 result = vec4(length(v));\n        for(int i = 0 ; i < 5 ; i++){\n            result = intersectSphere(spherePos + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n            if(result.x < length(v)) return 0.;\n            result = intersectSphere(spherePos2 + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n            if(result.x < length(v)) return 0.;\n            result = intersectSphere(spherePos3 + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n            if(result.x < length(v)) return 0.;\n        }\n        result = intersectYZRect(vec3(-5.),vec3(5.), 4., true,org, target, result);\n        result = intersectPlane(planeP, planeN, org, normalize(v), result);\n        if(result.x < length(v)) return 0.;\n        return 1.;\n    }\n\n    const float PI_4 = 12.566368;\n    const vec3 LIGHTING_FACT = vec3(0.1);\n    vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                         const vec3 lightPos, const vec3 lightPower){\n        vec3 v = lightPos - p;\n        float d = dot(n, normalize(v));\n        float r = length(v);\n        return (d > 0. \n               // && lightVisibility(p, lightPos) == 1.\n               ) ?\n            (lightPower * (d / (PI_4 * r * r))) * diffuseColor\n            : vec3(0.);\n    }\n\n\n\n    const vec3 lightPos = vec3(0, 10, 13);\n    const vec3 lightPower = vec3(300.);\n\n\tconst float planeHeight = 15.;\n    vec3 calcColor(vec3 eye, vec3 ray){\n        vec3 l = BLACK;\n        float coeff = 1.;\n        vec4 result = vec4(99999.);\n        for(int i = 0 ; i < 3 ; i++){\n            //result = intersectSphere(spherePos + vec3(0, i * 1 , 0), sphereR, eye, ray, result);\n            for(int j = 0 ; j < 3 ; j++){\n            \tresult = intersectSphere(spherePos2+ vec3(0, i * 1, 7 *(j - 1)), sphereR, eye, ray, result);\n            \tresult = intersectSphere(spherePos3+ vec3(0, i * 1, 7 *(j - 1)), sphereR, eye, ray, result);\n            }\n        }\n        result = intersectXYRect(vec2(-20., -planeHeight),vec2(20., planeHeight), -20., eye, ray, result);\n        result = intersectYZRect(vec3(-20., -planeHeight, -20),vec3(20., planeHeight, 10), 4., true, eye, ray, result);\n        result = intersectYZRect(vec3(-20., -planeHeight, -20),vec3(20., planeHeight, 10), -4., false, eye, ray, result);\n        result = intersectXYRect(vec2(-8., -planeHeight),vec2(-4., planeHeight), 10., eye, ray, result);\n        result = intersectXYRect(vec2(4., -planeHeight),vec2(8., planeHeight), 10., eye, ray, result);\n\n        result = intersectYZRect(vec3(-20., -planeHeight, -20),vec3(20., planeHeight, 10), 8., false, eye, ray, result);\n        result = intersectYZRect(vec3(-20., -planeHeight, -20),vec3(20., planeHeight, 10), -8., true, eye, ray, result);\n        result = intersectPlane(planeP, planeN, eye, ray, result);\n\n        vec3 matColor = vec3(1.);\n\n        if(result.x > 0.){\n            vec3 intersection = eye + ray * result.x;\n            if(g_mtl == MTL_PLANE){\n                float uu = 1.0 - floor(mod(intersection.x * 1./2., 2.0));\n                float vv = 1.0 - floor(mod(intersection.z * 1./2., 2.0));\n                if((uu == 1.0 && vv < 1.0) || (uu < 1.0 && vv == 1.0)){\n                        matColor = vec3(1, 0, 0);\n                }\n            }\n            vec3 normal = result.yzw;\n            l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n        }\n        return l;\n    }\n\n    vec3 hsv2rgb(vec3 c){\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n\n    const float DISPLAY_GAMMA_COEFF = 1. / 2.2;\n    vec3 gammaCorrect(vec3 rgb) {\n        return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                    (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                    (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n    }\n\n    vec3 eye = vec3(1, 0.5, 1);\n    const vec3 up = vec3(0, 1, 0);\n    float fov = radians(45.);\n\n    vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n                  const float width, const float height, const vec2 coord){\n        float imagePlane = (height * .5) / tan(fov * .5);\n        vec3 v = normalize(target - eye);\n        vec3 focalXAxis = normalize(cross(v, up));\n        vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n        vec3 center = v * imagePlane;\n        vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n        return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n    }\n\n    vec3 calcRayWithLens (vec3 camPos, const vec3 target, const vec3 up, const float fov,\n                          const float width, const float height, const vec2 coord,\n                          const float lensR, const float sampleNum){\n        float imagePlane = (height * .5) / tan(fov * .5);\n        vec3 v = normalize(target - camPos);\n        float focalDist = distance(camPos, target);\n        vec3 focalXAxis = normalize(cross(v, up));\n        vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n        vec3 center = v * imagePlane;\n        vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n        vec3 ray = normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n\n        vec2 jitter = lensR * 2. * (rand2n(vec2(1,2), sampleNum)- vec2(.5));\n        vec3 focus = camPos + ray * focalDist / dot(ray, v);\n        eye = camPos + jitter.x * focalXAxis + jitter.y * focalYAxis;\n\n        ray = normalize(focus - eye);\n\n        return ray;\n    }\n\n    vec3 calcRayWithLensShift (vec3 camPos, const vec3 target, const vec3 up, const float fov,\n                          const float width, const float height, const vec2 coord,\n                          const vec2 shift, const float sampleNum){\n        float imagePlane = (height * .5) / tan(fov * .5);\n        vec3 v = normalize(target - camPos);\n        float focalDist = distance(camPos, target);\n        vec3 focalXAxis = normalize(cross(v, up));\n        vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n        vec3 center = v * imagePlane;\n        vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n        origin += -focalXAxis * shift.x - focalYAxis * shift.y;\n        vec3 ray = normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n        vec3 focus = camPos + ray * focalDist / dot(ray, v);\n\n        ray = normalize(focus - eye);\n\n        return ray;\n    }\n\n\n    vec3 target = vec3(0., 5., 0);\n    const float SAMPLE_NUM = 30.;\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        vec4 sum = vec4(0);\n        const float lensR = 1.;\n        for(float i = 0. ; i < SAMPLE_NUM ; i++){\n\n            eye = vec3(0. , 1., 35.);\n\t\t\ttarget = vec3(0., 1. , 0);\n            vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    /*\n            vec3 ray = calcRay(eye, target, up, fov,\n                               iResolution.x, iResolution.y,\n                               gl_FragCoord.xy + coordOffset);\n    */\n\n            vec3 ray = calcRayWithLensShift(eye, target, up, fov,\n                                           iResolution.x, iResolution.y,\n                                           gl_FragCoord.xy + coordOffset,\n                                           vec2(0., 100. * abs(sin(iTime))), i);\n\n\n            sum += vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n        }\n        fragColor = vec4(sum/SAMPLE_NUM);\n\n    }","name":"Image","description":"","type":"image"}]}