{"ver":"0.1","info":{"id":"cdcXW4","date":"1679761998","viewed":112,"name":"Attempt1 at the einstein hat","username":"vega","description":"https://cs.uwaterloo.ca/~csk/hat/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tilinig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hexPt(float x,float y){\n    return vec2(x+y*.5,y*sqrt(3.)*.5);\n}\n\nvec3 hatColor(int tileType){\n    if(tileType==0)return vec3(0.,.537,.831);\n    if(tileType==1)return vec3(.580,.803,.921);\n    if(tileType==2)return vec3(.984,.984,.984);\n    if(tileType==3)return vec3(.980,.980,.980);\n    if(tileType==4)return vec3(.749,.749,.749);\n    return vec3(0.);\n}\n\n// Function to find the closest point on a line segment\nvec2 closestPoint(vec2 p,vec2 a,vec2 b){\n    vec2 ab=b-a;\n    float t=dot(p-a,ab)/dot(ab,ab);\n    t=clamp(t,0.,1.);\n    return a+t*ab;\n}\n\n// Function to find the distance from a point to a line segment\nfloat distPointToLineSegment(vec2 p,vec2 a,vec2 b){\n    vec2 closest=closestPoint(p,a,b);\n    return distance(p,closest);\n}\n\n// Function to find the distance from the point to the outline of the tile\nfloat distToOutline(vec2 p){\n    // Tile outline points in Cartesian coordinates\n    vec2 pts[13]=vec2[](\n        vec2(0,0),vec2(-1,-1),vec2(0,-2),vec2(2,-2),\n        vec2(2,-1),vec2(4,-2),vec2(5,-1),vec2(4,0),\n        vec2(3,0),vec2(2,2),vec2(0,3),vec2(0,2),\n        vec2(-1,2)\n    );\n    \n    float minDist=distance(p,pts[0]);\n    for(int i=1;i<13;++i){\n        minDist=min(minDist,distPointToLineSegment(p,pts[i],pts[(i+12)%13]));\n    }\n    return minDist;\n}\n\nvec4 getTileType(vec2 uv,vec4 H_col,vec4 T_col,vec4 P_col,vec4 F_col){\n    // Constants\n    const float PI=3.1415926535897932384626433832795;\n    const float hr3=.8660254037844386;// half square root of 3\n    const vec2 origin=vec2(0.,0.);\n    \n    // Calculate the distance to the tile outline\n    float dist=distToOutline(uv);\n    \n    // Set a threshold for the distance to decide which tile type the point belongs to\n    float threshold=.1;\n    \n    if(dist<threshold){\n        return H_col;\n    }else if(dist<2.*threshold){\n        return T_col;\n    }else if(dist<3.*threshold){\n        return P_col;\n    }else{\n        return F_col;\n    }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    // Tile colors\n    vec4 H_col=vec4(1.,0.,0.,1.);// Red\n    vec4 T_col=vec4(0.,1.,0.,1.);// Green\n    vec4 P_col=vec4(0.,0.,1.,1.);// Blue\n    vec4 F_col=vec4(1.,1.,1.,1.);// White\n    \n    // Transform the UV coordinates\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=(uv-.5)*20.;\n    \n    // Get the tile type and set the fragment color\n    fragColor=getTileType(uv,H_col,T_col,P_col,F_col);\n}","name":"Image","description":"","type":"image"}]}