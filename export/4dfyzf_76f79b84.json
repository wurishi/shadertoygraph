{"ver":"0.1","info":{"id":"4dfyzf","date":"1489052483","viewed":1341,"name":"2d Procedural Pattern","username":"gPlatl","description":"A collection of 2d procedural pattern types.\nPress mouse button and select pattern in x direction & zoom in y direction.\nShould all work with Antialiasing - hints are welcome...","likes":62,"published":1,"flags":64,"usePreview":0,"tags":["procedural","2d","basic","texture","pattern","collection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsSXDm","filepath":"https://soundcloud.com/user-828301013/linkin-park-she-couldnt-instrumental","previewfilepath":"https://soundcloud.com/user-828301013/linkin-park-she-couldnt-instrumental","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Shader: 2dProceduralPattern.glsl  by gPlatl\n//\n// A collection of 2d procedural pattern types.\n// Press mouse button and select pattern in x direction & zoom in y direction.\n//\n//   v1.0  2017-02-22  initial release\n//   v1.1  2017-02-24  changed mod(x,1.) => fract(x)\n//   v1.2  2017-03-15  pattern menu added\n//   v1.3  2017-04-11  sine pattern added\n//   v1.4  2017-04-30  brick wall pattern added\n//   v1.5  2017-05-07  GearPattern added\n//   v1.6  2017-05-30  HexagonalTruchetPattern added\n//   v1.7  2017-06-10  QCirclePattern added\n//   v1.8  2017-08-05  StarPattern added\n//   v1.9  2017-09-02  Basketwork Pattern added\n//   v1.10 2018-07-14  Diamond Pattern added\n//   v1.11 2018-09-15  RosettePattern added\n//   v1.12 2018-10-11  Wallpaper70sPattern added\n//   v1.13 2018-10-11  MinimalWeavePattern added\n//   v1.14 2019-05-16  GridPattern added\n//\n// tags:   procedural, pattern, 2d, basic, texture, collection\n// note:   procedural pattern routines will return values from 0.0 .. 1.0\n//\n// references:\n//   Procedural Patterns          http://slideplayer.com/slide/6400090/\n//   Antialiasing Proc. Textures  http://www.yaldex.com/open-gl/ch17lev1sec4.html\n//---------------------------------------------------------\n\n#define patternCount 23.0\n\n#define PI 3.141592\n\nbool ANIMATE = true;   // false if mousePressed\n\n#define RandomSign sign(cos(1234.*cos(h.x+9.*h.y)));  // random -1 or 1\n\n//---------------------------------------------------------\n// return test pattern\n//---------------------------------------------------------\nfloat TestPattern(in vec2 uv)\n{\n  uv *= 8.0;\n  return clamp(88.*sin(uv.x)* sin(uv.y), 0.0, 1.0);\n}\n//---------------------------------------------------------\n// return chess board pattern with AA\n//---------------------------------------------------------\nfloat ChessPattern(in vec2 uv)\n{\n//return clamp(88.*sin(uv.x)* sin(uv.y), 0.0, 1.0);\n  return 1. / sin(uv.x) / sin(uv.y);\n}\n//---------------------------------------------------------\n// return checker board pattern with AA\n//---------------------------------------------------------\nfloat KaroPattern(in vec2 uv)\n{\n  return 0.5*clamp(10.*sin(PI*uv.x), 0.0, 1.0)\n       + 0.5*clamp(10.*sin(PI*uv.y), 0.0, 1.0);\n}\n//---------------------------------------------------------\n// return grid pattern 1 with AA\n//---------------------------------------------------------\nfloat Grid1Pattern(in vec2 uv)\n{\n  float col = max(sin(uv.x*10.1), sin(uv.y*10.1));\n  return smoothstep(0.5,1.,col);\n}\n//---------------------------------------------------------\n// return grid pattern 2 with AA\n//---------------------------------------------------------\nfloat Grid2Pattern(in vec2 uv)\n{\n  return 0.5*clamp(10.*sin(PI*uv.x), 0.0, 1.0)\n       / 0.5*clamp(10.*sin(PI*uv.y), 0.0, 1.0);\n}\n//---------------------------------------------------------\n// return rounded square holes grid with AA\n//---------------------------------------------------------\nfloat SquareHolePattern(in vec2 uv)\n{\n  float thickness = 0.8;\n  float t = cos(uv.x*2.0) * cos(uv.y*2.0) / thickness;\n  return smoothstep(0.1, 0.0, t*t);\n}\n//---------------------------------------------------------\n// return lighted square pattern\n//---------------------------------------------------------\nfloat SquarePattern(in vec2 uv)   // no AA\n{\n  return fract(uv.x)*fract(uv.y);\n}\n//---------------------------------------------------------\nfloat CheckerPattern(in vec2 uv)   // no AA\n{\n  uv = 0.5 - fract(uv);\n  return 0.5 + 0.5*sign(uv.x*uv.y);\n}\n//---------------------------------------------------------\nfloat TrianglePattern(in vec2 uv)   // no AA\n{\n  uv.y = uv.y * 0.866 + uv.x * 0.5;\n  if(fract(uv.y) > fract(uv.x)) return 1.0;\n  return 0.0;\n}\n//---------------------------------------------------------\nfloat Rhomb1Pattern(in vec2 uv)   // no AA\n{\n  uv.y = uv.y * 0.866 + uv.x * 0.5;\n  float t = fract(uv.y) - fract(uv.x);\n  return smoothstep(.50, 0.0, t*t);\n}\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\nfloat HexagonalGrid (in vec2 position\n                    ,in float gridSize\n                    ,in float gridThickness)\n{\n  vec2 pos = position / gridSize;\n  pos.x *= 0.57735 * 2.0;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*1.5 + pos.y, pos.y*2.0) - 1.0);\n  return smoothstep(0.0, gridThickness, d);\n}\n//---------------------------------------------------------\n// return hexagonal grid pattern with 3 colors\n//---------------------------------------------------------\nfloat Hexagonal3Pattern(in vec2 p)   // no AA\n{\n  p.y = p.y * 0.866 + p.x*0.5;\n  p = mod(p, vec2(3.0));\n\n  if(p.y < p.x+1.0 && p.y > 0.0 && p.x > 0.0\n  && p.y > p.x-1.0 && p.x < 2.0 && p.y < 2.0)\n    return 0.0;\n  else if(p.y > 1.0 && (p.y < p.x || p.x < 1.0))\n    return 0.5;\n  return 1.0;\n}\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\nfloat HexagonalGrid2 (in vec2 position\n\t                 ,in float gridSize\n\t                 ,in float gridThickness)\n{\n  vec2 pos = position / gridSize;\n  pos.x *= 1.1;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*2.5 + pos.y, pos.y*3.0) - 1.0);\n  return smoothstep(0.30, gridThickness, d);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/Xdt3D8 by FabriceNeyret2\n//---------------------------------------------------------\nfloat HexagonalTruchetPattern(vec2 p)\n{\n  vec2 h = p + vec2(0.58, 0.15)*p.y;\n  vec2 f = fract(h);\n  h -= f;\n  float v = fract((h.x + h.y) / 3.0);\n  (v < 0.6) ? (v < 0.3) ?  h : h++ : h += step(f.yx,f);\n  p += vec2(0.5, 0.13)*h.y - h;        // -1/2, sqrt(3)/2\n  v = RandomSign;\n  return 0.06 / abs(0.5 - min (min\n    (length(p - v*vec2(-1., 0.00)  ),  // closest neighbor (even or odd set, dep. s)\n     length(p - v*vec2(0.5, 0.87)) ),  // 1/2, sqrt(3)/2\n     length(p - v*vec2(0.5,-0.87))));\n}\n\n//---------------------------------------------------------\n// return sinus wave pattern\n//---------------------------------------------------------\nfloat SinePattern(in vec2 p)\n{\n  return sin(p.x * 20.0 + cos(p.y * 12.0 ));\n}\n//---------------------------------------------------------\n// return sinus wave pattern\n//---------------------------------------------------------\nfloat Sine2Pattern(in vec2 p)\n{\n  return 0.5+sin(p.x * 20.0 + cos(p.y * 10.0 ))\n            *sin(p.y * 20.0 + cos(p.x * 10.0 ));\n}\n//---------------------------------------------------------\n// return antialiased brick wall pattern\n//---------------------------------------------------------\nfloat BrickPattern(in vec2 p)\n{\n  p *= vec2 (1.0, 2.8);  // scale\n  vec2 f = floor (p);\n  if (2. * floor (f.y * 0.5) != f.y)\n    p.x += 0.5;  // brick shift\n  p = smoothstep (0.03, 0.08, abs (fract (p + 0.5) - 0.5));\n  return 1. - 0.9 * p.x * p.y;\n}\n//---------------------------------------------------------\n// return brick wall pattern\n//---------------------------------------------------------\nfloat BrickPattern2(in vec2 p)    // no AA\n{\n  const float vSize = 0.10;\n  const float hSize = 0.05;\n  p.y *= 2.5;    // scale y\n  if(mod(p.y, 2.0) < 1.0) p.x += 0.5;\n  p = p - floor(p);\n  if((p.x+hSize) > 1.0 || (p.y < vSize)) return 1.0;\n  return 0.0;\n}\n//---------------------------------------------------------\n// return pattern of rotating gears\n//---------------------------------------------------------\nfloat GearPattern(in vec2 uv     // coordinates\n                 ,in float wn    // vertical wheel count\n                 ,in int tn      // tooth count\n                 ,in float time) // rotation time\n{\n  float g = (step(1.0, uv.x * wn) - 0.5) * time;\n  uv = fract(uv * wn) - 0.5;\n  float r = clamp(0.48, 0.4, 0.45 + 0.12*sin(atan(uv.x,uv.y) * float(tn) + g));\n  return smoothstep(r, r + 0.01, 1.1*length(uv));\n}\n//---------------------------------------------------------\n// return rounded square circle pattern\n//---------------------------------------------------------\nfloat lengthN(in vec2 v, in float n)\n{\n  return pow(pow(abs(v.x), n)+pow(abs(v.y), n), 0.89/n);\n}\n//---------------------------------------------------------\nfloat QCirclePattern(in vec2 p)\n{\n  vec2 p2 = mod(p*8.0, 4.0)-2.0;\n  return sin(lengthN(p2, 4.0)*16.0);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/4sKXzy by aiekick\n//---------------------------------------------------------\nfloat StarPattern(in vec2 p)\n{\n  p = abs(fract(p*1.5)-0.5);\n  return max(max(p.x, p.y), min(p.x, p.y)*2.);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/llfyDn by FabriceNeyret2\n//---------------------------------------------------------\n#define S1(x,y) abs(fract(x))<0.8 ? 0.65 +0.35* sin(3.1415*(y-ceil(x))) : 0.0\n#define S2(x,y) abs(fract(x))<0.8 ? 0.65 +0.35* sin(1.5707*(y-ceil(x))) : 0.0\n\nfloat Basketwork1Pattern(in vec2 uv)\n{\n  vec2 p = uv * 4.0;\n  return max (S1(p.x, p.y), S1(p.y+1.0, p.x));\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/ltXcDn by FabriceNeyret2\n//---------------------------------------------------------\nfloat Basketwork2Pattern(in vec2 uv)\n{\n  vec2 p = uv * 4.0;\n  return max (S2( p.x, p.y), S2(p.y, p.x+1.) );\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/lsVczV by FabriceNeyret2\n//---------------------------------------------------------\nfloat DiamondPattern(in vec2 uv)\n{\n  vec2 dp = abs (fract(uv*2.) - 0.5);\n  return 0.3 - cos (19. * max(dp.x, dp.y));\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/4lGyz3 by FabriceNeyret2\n//---------------------------------------------------------\n#define D(U) .004/abs(length(mod(U,d+d)-d)-d.x)\nfloat RosettePattern(in vec2 p)\n{\n  vec2 d = vec2(0.58,1);\n  vec4 O = vec4(0);\n  for (; O.a++ < 4.; O += D(p) +D(p += d*.5)) p.x += d.x;\n  return O.x;\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/ls33DN by Shane\n//---------------------------------------------------------\nfloat Wallpaper70sPattern(vec2 p, float time)\n{\n  p.x *= sign(cos(length(ceil(p))*time));\n  return cos(min(length(p = fract(p)), length(--p))*44.);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/XttBWn by xentrac\n//---------------------------------------------------------\nfloat MinimalWeavePattern(vec2 coord)\n{\n  vec3 bg = vec3(0),  warp = vec3(.5),  weft = vec3(1);\n  ivec2 uv = ivec2(floor(coord*8.));\n  int mask = (int(iTime / 2.) & 7) << 2;\n  vec3 col = (((uv.x ^ uv.y) & mask) == 0\n   ? 1 == ((uv.x ^ uv.x >> 1) & 1) ? warp : bg\n   : 1 == ((uv.y ^ uv.y >> 1) & 1) ? weft : bg);\n  return col.r;\n}\n//---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float aspect = iResolution.y / iResolution.x;\n  vec2 mpos = iMouse.xy / iResolution.y;\n  vec2 uv = fragCoord.xy / iResolution.y - vec2(0.5);\n\n  float time = iTime;\n\n  ANIMATE = iMouse.z < 1.0;\n\n  // get pattern\n  int pType = int( mpos.x * patternCount * aspect);\n  if (uv.y < -0.4)           // pattern menu ?\n  {\n    pType = int(fragCoord.xy / iResolution.y * patternCount * aspect);\n    uv *= 28.0;\n  }\n  else\n  {\n    uv *= (0.2 + mpos.y) * 10.0;\n    if (ANIMATE)\n    {\n      // rotate and scale position\n      float ra = time*0.12;\n      float cost = cos(ra);   // rotate\n      float sint = sin(ra);\n      uv = vec2(cost*uv.x + sint*uv.y, sint*uv.x - cost*uv.y);\n      uv *= (1.2+0.3*sin(0.5*time));   // scale\n    }\n  }\n\n  float p; // = HexagonalGrid(uv, 0.5, 0.1);\n  if      (pType == 0) p = HexagonalGrid (uv, 0.8, 0.2);\n  else if (pType == 1) p = HexagonalGrid2(uv, 0.8, 0.2);\n  else if (pType == 2) p = Hexagonal3Pattern(uv*2.0);\n  else if (pType == 3) p = HexagonalTruchetPattern (uv*3.);\n  else if (pType == 4) p = CheckerPattern(uv);\n  else if (pType == 5) p = ChessPattern(uv*8.0);\n  else if (pType == 6) p = TrianglePattern(uv);\n  else if (pType == 7) p = Rhomb1Pattern(uv);\n  else if (pType == 8) p = KaroPattern(uv);\n  else if (pType == 9) p = Grid1Pattern(uv);\n//else if (pType == 9) p = Grid2Pattern(uv);\n  else if (pType ==10) p = SquareHolePattern(uv);\n  else if (pType ==11) p = SquarePattern(uv);\n  else if (pType ==12) p = SinePattern(uv);\n  else if (pType ==13) p = BrickPattern(uv);\n//else if (pType ==13) p = BrickPattern2(uv);\n  else if (pType ==14) p = GearPattern(uv, 1.5, 12, iTime * 6.5);\n  else if (pType ==15) p = QCirclePattern(uv);\n  else if (pType ==16) p = StarPattern(uv);\n  else if (pType ==17) p = Basketwork1Pattern(uv);\n  else if (pType ==18) p = Basketwork2Pattern(uv);\n  else if (pType ==19) p = DiamondPattern(uv);\n  else if (pType ==20) p = RosettePattern(uv);\n  else if (pType ==21) p = Wallpaper70sPattern(uv, iTime*0.1);\n  else if (pType ==22) p = MinimalWeavePattern(uv);\n  else                 p = TestPattern(uv);\n\n  vec4 color1 = vec4 (0.2+0.2*sin(time)\n                     ,0.2+0.2*sin(time*0.789)\n                     ,0.2+0.2*sin(time*0.665), 1.0);\n\n  vec4 color2 = vec4 (0.9);\n\n  fragColor = mix(color1, color2, p);\n  fragColor = vec4(p);   // B+W\n}","name":"Image","description":"","type":"image"}]}