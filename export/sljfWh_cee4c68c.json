{"ver":"0.1","info":{"id":"sljfWh","date":"1652161660","viewed":246,"name":"precursor display","username":"saidwho12","description":"Came across a video recently about 7-segment displays which really made me want to try and make virtual clocks for each of these shapes. The video in question is [url=https://youtu.be/RTB5XhjbgZA]Segmented Displays[/url] and shows a variety of designs.","likes":12,"published":1,"flags":8,"usePreview":0,"tags":["2d","time","sdf","clock","random","glow","alien","digit","display","lissajous","segment","seven","segmented","flies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEBUG_MODE 0\n#define MAX_DISTANCE 1000.\n#define ALTERNATE_STYLE 1\n#define CONTOUR_THICKNESS 0.0355\n#define INSET .0215\n#define FIREFLY_COUNT 8\n#define SPARK_COUNT 50\n//#define SEGMENT_COLOR vec3(1.0,.976,.191)\n#define SEGMENT_COLOR vec3(0.592,1.,.216)\n#define FIREFLY_COLOR vec3(0.535,1.,.216)\n#define EPSILON .00003\n#define TURN_OFF 0\n#define RENDER_SPARKS 1\n#define ANIMATE_DIGIT 1\n\nstruct DisplayConsts {\n    // cutout spacing constant\n    float H;\n    float R1; // outer radius\n    float R2; // inner radius\n    float D; // delta between two circles\n    float A; // angle in degrees for right-side cutout\n    float O; // scale of radius for horizontal offset of cut line\n};\n\nDisplayConsts dc = DisplayConsts(.087,1.,.51,.721,50.,.95);\n\nfloat circleSdf(vec2 p, vec2 d, float r) {\n    return length(p-d)-r;\n}\n\nstruct Segment {\n    float t;\n    float z_factor;\n    int index;\n    float t_segments[7];\n};\n\nmat2 Rotate2D(in float angle)\n{\n    float cosT = cos(angle);\n    float sinT = sin(angle);\n    return mat2(cosT,-sinT,sinT,cosT);\n}\n\nvec3 ThreeSegmentDist(in vec2 p)\n{\n    float c1 = circleSdf(p.xy,vec2(0,dc.D),dc.R1);\n    float c2 = circleSdf(p.xy,vec2(0,-dc.D),dc.R1);\n    \n    float bubble = max(c1, // disk\n        -min(\n            circleSdf(p.xy,vec2(0,dc.D),dc.R2), // hole\n            c2 // other disk\n        )) + dc.H/2.;\n        \n    float middle = max(c1,c2) + dc.H/2.;\n    \n    const float S = 1.50;\n    \n    #if ALTERNATE_STYLE\n    float mask1 = min(p.x, max(p.x - (dc.R2*dc.O + dc.H/2.), -(p.y-dc.D*S)));\n    float segment1 = max(bubble,-mask1);\n    \n    float mask2 = min(-p.x, max(-p.x - (dc.R2*dc.O + dc.H/2.), -(p.y-dc.D*S)));\n    float segment2 = max(bubble,-mask2);\n    #else\n    vec2 z = p.xy - vec2(0,dc.D);\n    vec2 z1 = z * Rotate2D(radians(dc.A));\n    vec2 z2 = z * Rotate2D(-radians(dc.A));\n    \n    \n    float mask1 = min(p.x, max(p.x - (dc.R2*dc.O + dc.H/2.), -(p.y-dc.D*S)));\n    float segment1 = max(bubble,-mask1);\n    #if 0\n    float mask1 = min(p.x, max(p.x - (dc.R2*dc.O + dc.H/2.), -(p.y-dc.D)));\n    float segment1 = max(bubble,-mask1);\n    #endif\n    float mask2 = min(-z2.x,-z.x);\n    float segment2 = max(bubble,-mask2);\n    \n    #endif\n    \n    float segment3 = max(bubble, (\n            -(min(-mask1,-mask2)-dc.H)));\n    \n    return vec3(segment1,segment2,segment3);\n}\n\nSegment SegmentDist(in vec3 q)\n{\n    Segment seg;\n    q *= 2.;\n    \n    // mirrored bottom part\n    vec3 top = ThreeSegmentDist(q.xy);\n    vec3 bottom = ThreeSegmentDist(vec2(q.x,-q.y));\n    \n    \n    float c1 = circleSdf(q.xy,vec2(0,dc.D),dc.R1);\n    float c2 = circleSdf(q.xy,vec2(0,-dc.D),dc.R1);\n    \n    float bubble = max(c1, // disk\n        -min(\n            circleSdf(q.xy,vec2(0,dc.D),dc.R2), // hole\n            c2 // other disk\n        )) + dc.H/2.;\n        \n    float middle = max(c1,c2) + dc.H/2.;\n    \n    float t = MAX_DISTANCE;\n    int id = 0;\n    \n    for (int i = 0; i < 7; ++i) {\n        seg.t_segments[i] = MAX_DISTANCE;\n    }\n    \n    if (top[0] < t) {\n        t = top[0];\n        id = 1;\n    }\n    \n    \n    if (top[1] < t) {\n        t = top[1];\n        id = 2;\n    }\n    \n    \n    if (top[2] < t) {\n        t = top[2];\n        id = 3;\n    }\n    \n    if (bottom[0] < t) {\n        t = bottom[0];\n        id = 4;\n    }\n    \n    \n    if (bottom[1] < t) {\n        t = bottom[1];\n        id = 5;\n    }\n    \n    \n    if (bottom[2] < t) {\n        t = bottom[2];\n        id = 6;\n    }\n    \n    if (middle < t) {\n        t = middle;\n        id = 7;\n    }\n    \n    seg.t_segments[0] = top[0];\n    seg.t_segments[1] = top[1];\n    seg.t_segments[2] = top[2];\n    seg.t_segments[3] = bottom[0];\n    seg.t_segments[4] = bottom[1];\n    seg.t_segments[5] = bottom[2];\n    seg.t_segments[6] = middle;\n\n    seg.t = t;\n    seg.z_factor = q.z;\n    seg.index = id;\n    return seg;\n}\n\nvec2 Cross2(vec2 v){\n    return vec2(v.y,-v.x);\n}\n\nvec2 SegmentEdgeDist(in vec2 p) {\n    Segment seg = SegmentDist(vec3(p.xy,0));\n    return vec2(abs(seg.t+INSET)-CONTOUR_THICKNESS, seg.z_factor);\n}\n\nvec2 SegmentEdgeSDFDirection(in vec2 p){\n    float xt0 = SegmentEdgeDist(vec2(p.x-EPSILON,p.y)).x;\n    float xt1 = SegmentEdgeDist(vec2(p.x+EPSILON,p.y)).x;\n    float yt0 = SegmentEdgeDist(vec2(p.x,p.y-EPSILON)).x;\n    float yt1 = SegmentEdgeDist(vec2(p.x,p.y+EPSILON)).x;\n    return normalize(vec2(xt1-xt0, yt1-yt0));\n}\n\nvec3 debugColors[8] = vec3[8](\n    vec3(1,1,1),\n    vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n    vec3(1,1,0), vec3(1,0,1), vec3(0,1,1), vec3(0,.5,1) );\n\n\nstruct LitState { int s[7]; };\n\n\nLitState digitTable[17];\nvoid InitLitState()\n{\n    digitTable[0].s = int[7](1,1,1,1,1,1,0); // 0 zero  \n    digitTable[1].s = int[7](1,0,0,1,0,0,0); // 1 one\n    digitTable[2].s = int[7](1,0,1,0,1,1,1); // 2 two\n    digitTable[3].s = int[7](1,0,1,1,0,1,1); // 3 three\n    digitTable[4].s = int[7](1,1,0,1,0,0,1); // 4 four\n    digitTable[5].s = int[7](0,1,1,1,0,1,1); // 5 five\n    digitTable[6].s = int[7](0,1,1,1,1,1,1); // 6 six\n    digitTable[7].s = int[7](1,0,1,1,0,0,0); // 7 seven\n    digitTable[8].s = int[7](1,1,1,1,1,1,1); // 8 eight\n    digitTable[9].s = int[7](1,1,1,1,0,1,1); // 9 nine\n    digitTable[10].s = int[7](1,1,1,1,1,0,1); // 10 A\n    digitTable[11].s = int[7](0,1,0,1,1,1,1); // 11 B\n    digitTable[12].s = int[7](0,0,0,0,1,1,1); // 12 C\n    digitTable[13].s = int[7](1,0,0,1,1,1,1); // 12 D\n    digitTable[14].s = int[7](0,1,1,0,1,1,1); // 12 E\n    digitTable[15].s = int[7](0,1,1,0,1,0,1); // 12 F\n    digitTable[16].s = int[7](0,1,0,1,1,0,1); // 12 F\n}\n\n\nfloat SegmentOn(in float digit, in int current_id)\n{\n    // return segment On/Off state\n    \n    int x = int(floor(digit));\n    \n    LitState state = digitTable[x];\n    return state.s[current_id-1] == 1 ? 1. : 0.;\n}\n\nvec4 Noise(in vec2 p){ return texture(iChannel0,p);}\n\nvec4 FBM(in vec2 p, int octaves) {\n    vec4 v = vec4(0);\n    float c = .5;\n    \n    for (int i = 0; i < octaves; ++i) {\n        v += Noise(p) * c;\n        c *= .5;\n        p *= 2.;\n    }\n    return v;\n}\n\nfloat ComputeGlow(in Segment seg, in float digit, vec2 p) {\n    float glow = 0.;\n    int x = int(floor(digit));\n    \n    LitState state = digitTable[x];\n    \n    for (int i = 0; i < 7; ++i) {\n    \n    if ((state.s[i] == 1) && (seg.t_segments[i] < MAX_DISTANCE)) { //(true) {//((state.s[i] == 1) && (seg.t_segments[i] < MAX_DISTANCE)) {\n            float t = abs(seg.t_segments[i]+INSET)-CONTOUR_THICKNESS;\n            float noise = FBM(p,6).x*.6+.4;\n            float k = exp(-28.5*max(0.,t))*.363 * noise;\n            glow += k;\n        }\n    }\n    \n    return glow;\n}\n\nstruct Firefly {\n    vec2 o; // center of spawn\n    float t; // initial time\n    float speed;\n    // Fly path parameters (Lissajous constants)\n    float delta,a,b,A,B;\n    // Light-up formula parameters\n    float k,h,n;\n};\n\nfloat FitToRange(float x, float minVal, float maxVal) {\n    return minVal + (maxVal - minVal) * x;\n}\n\nfloat RandomRange(float seed, float minVal, float maxVal) {\n    return FitToRange(hash11(seed),minVal,maxVal);\n}\n\n\nFirefly GetFirefly(in float seed) {\n    Firefly fly;\n    fly.o = vec2(0);\n    fly.t = RandomRange(seed,0.,10.);\n    fly.delta = RandomRange(seed+1.,0.,50.);\n    \n    float s = sign(RandomRange(seed+2.,-1.,1.));\n    float scale = RandomRange(seed+3.,.085,0.43);\n    fly.speed = s * scale;\n    fly.a = RandomRange(seed+4.,.85,1.5);\n    fly.b = RandomRange(seed+5.,.85,1.5);\n    fly.A = RandomRange(seed+6., .97, 2.1);\n    fly.B = RandomRange(seed+7., .93, 1.11);\n    return fly;\n}\n\nvec2 LissajousCurve(in float delta, in float a, in float b, in float A, in float B, in float t) {\n    return vec2(A * sin(a*t*TAU + delta), B *cos( TAU*b*t));\n}\n\nvec2 GetFireflyPos(in Firefly fly, in float dt) {\n    return fly.o + LissajousCurve(fly.delta,fly.a,fly.b,fly.A,fly.B,fly.t+dt*fly.speed);\n}\n\nstruct Spark {\n    vec2 o; // original position\n    float angle;\n    float r;\n    float v_angular;\n    float span;\n    float k; // attenuation\n    float power;\n};\n\nSpark GetSpark(in float seed, in vec2 p, in vec2 v0, in vec2 v1) {\n    Spark spark;\n\n    spark.o = RandomRange(seed,0.,1.) > .5 ? vec2(0.,dc.D) : vec2(0.,-dc.D);\n    \n    float k = RandomRange(seed+2.,-1.,1.);\n    float r_offset = k *5.15* CONTOUR_THICKNESS;\n    float R = RandomRange(seed+1.,0.,1.) > .5 ? dc.R1-(dc.H/2.+INSET+r_offset) : dc.R2+(dc.H/2.+INSET+r_offset);\n    spark.r = R;// radius\n    spark.angle = RandomRange(seed+2.,0.,TAU);\n    spark.v_angular = RandomRange(seed+3.,TAU*.425,TAU*.6) ;\n    \n    spark.span = RandomRange(seed+4.,.51,.75);\n    return spark;\n}\n\nvec2 RenderSpark(in Spark spark, inout vec3 col, in vec3 p, in float dt) {\n    float at = dt/spark.span;\n    \n    float theta = spark.angle ; // angle of spark in relation to origin\n    \n    float new_theta = theta + spark.v_angular * at;\n    \n    vec2 pos = spark.o + vec2(sin(new_theta),cos(new_theta)) * spark.r;\n    \n    float d = distance(p.xy, pos)-.0052;\n    \n    vec2 delta = p.xy - spark.o; // delta of pixel pos to origin of circle\n    float phi = (atan(delta.y,delta.x)+PI) - spark.v_angular * at;\n    \n    float ring = abs(length(p.xy - spark.o) - spark.r - .00525*sin((phi*TAU*8.+dt)))-.00912;\n    float alpha_ring = smoothstep(1.5,-1.5,ring/p.z);\n    \n    vec3 sparkColor = SEGMENT_COLOR;\n    \n    float dist = clamp(abs(mod(phi,TAU)-theta)-PI*.0335,0.,1.);\n    col = mix(col, sparkColor, alpha_ring*exp(-3.6* dist)*smoothstep(.5,0.,at));// exp(-0.065*at)*exp(-200.*max(d/p.z,0.))*.87);\n            \n    return pos;\n}\n\nvoid RenderSparks(inout vec3 col, in vec2 b, in vec3 p, in float dt, in float base_seed) {\n    p *= 2.;\n    for (int i = 0; i < SPARK_COUNT; ++i) {\n        float N = 20.;\n        Spark spark = GetSpark(base_seed*float(SPARK_COUNT)*N+float(i)*N,p.xy,-b*.4,+b*.4);\n        RenderSpark(spark,col,p,dt);\n    }\n}\n\n// normalized scale sin ( from 0 to 1)\nfloat NormalizedSine(in float t, in float s) {\n    return (sin(TAU * t * s) + 1.) / 2.;\n}\n\nvoid RenderFireflies(inout vec3 col, in vec3 p, in float dt) {\n    // Render fireflies\n    for (int i = 0; i < FIREFLY_COUNT; ++i) {\n        Firefly fly = GetFirefly(float(i)*10.);\n        float d = distance(p.xy, GetFireflyPos(fly,iTime))-.0122;\n        \n        // compute intensity\n        float t = fly.t + dt;\n        float intensity = NormalizedSine(t,1.) * NormalizedSine(t,1./5.);\n        \n        vec3 fireflyColor = FIREFLY_COLOR;\n        col = mix(col, fireflyColor, exp(-100.*d)*intensity);\n        col = mix(col, fireflyColor, exp(-5.*d)*.3*intensity);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitLitState();\n    \n    // Screen coordinates (from -1 to 1 on y, -aspect to aspect on x)\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Initial color\n    vec3 col = vec3(0.);\n    \n    // Digit display extent\n    vec3 q = vec3(p,1./iResolution.y);\n    q *= 1.85; // overall zoom\n    \n    vec2 b = vec2(1.15,2);\n   \n    vec3 pre_rep_q = q;\n    \n    q.x += 1.5*b.x;\n    int digitIndex = int(floor((q.x-b.x*.5)/b.x));\n    q.x = mod(q.x+b.x*.5,b.x)-b.x*.5;\n    \n    float time = iTime*1.;\n    \n    if (digitIndex <= 1 && digitIndex >= 0) {    \n        float base = 16.;\n        float group = 256.;\n        float sec = mod(time,group);//mod(iTime,60.);\n        float exponent = pow(base,float(1-digitIndex));\n        float digitVal = mod(sec / exponent, base);\n        \n        float s = int(floor(digitVal)) % 2 == 0 ? +1. : -1.;\n        float t_delta = fract(digitVal) * exponent;\n        float pulse = exp(-5.*max(t_delta*2.,0.)) * sin(t_delta*2.*PI);\n        \n#if ANIMATE_DIGIT\n        q.xy *= Rotate2D(s * radians(35.*pulse));\n#endif\n        //q.y -= pulse * .21;\n        Segment sg = SegmentDist(q);\n\n        float alpha = smoothstep(1.5,-1.5,(abs(sg.t+INSET)-CONTOUR_THICKNESS)/sg.z_factor);\n        \n#if DEBUG_MODE\n        vec3 segmentTint = debugColors[sg.index];\n#else\n        //vec3 segmentTint = vec3(.35,1.,.11);\n        vec3 segmentTint = SEGMENT_COLOR;\n#endif\n        float glow = ComputeGlow(sg, digitVal, p);\n        float isOn = SegmentOn(digitVal, sg.index);\n        \n#if TURN_OFF\n        isOn = 0.;\n#endif\n        col = mix(col, mix(vec3(.051),segmentTint,isOn), alpha);\n        //col = mix(col, segmentTint, alpha*isOn);\n        col = mix(col, segmentTint, glow);\n         \n#if RENDER_SPARKS\n        // Render sparks\n        RenderSparks(col,b,q,t_delta,floor(sec));\n#endif\n    }\n      \n    RenderFireflies(col,pre_rep_q,time);\n    \n    // Output\n    fragColor = vec4(clamp(col,0.,1.),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sineWave(float x, float freq){\n    x *= freq;\n    return sin(x * TAU);\n}\n\nfloat absSineWave(float x, float freq){ x*=freq; return abs(sin(x*TAU))*2.-1.;}\n\nfloat sawtooth(float x){\n    return fract(x+.5)*2.-1.;\n}\n\nfloat triangleWave(float x, float freq) {\n\tx*=freq;\n\treturn -(abs(mod(x,1.)-.5)-.25)*4.;\n}\n\nfloat squareWave(float x) {\n    return step(1.,mod(x+.5,2.))*2.-1.;\n}\n\nfloat tick(float time){\n    float x = floor(time);\n    float t1 = fract(time);\n    float t2 = fract(time-.18);\n    \n    float pitch_shift = (cos(2.*PI * x/10.)*.2*hash11(x)+.8);\n    float atten1 = exp(-14.0*t1);\n    float atten2 = exp(-10.0*t2);\n    float freq1 = 350. + pitch_shift*50.;\n    float freq2 = 310. + pitch_shift*50.;\n    return (.7*sineWave(t1,freq1)*atten1  + .3*sineWave(t2,freq2)*atten2) * (.79 + .21*hash11(floor(time*189451734.)),0.,1.);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    return vec2(tick(time)  ) * .6;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define TAU 2.*PI\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n","name":"Common","description":"","type":"common"}]}