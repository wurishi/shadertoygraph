{"ver":"0.1","info":{"id":"tdyBRz","date":"1606839173","viewed":809,"name":"Reprojection UV Screen-Quad UV","username":"morimea","description":"Point of this logic-make 2D-screen-space logic in 3D engine, or share Screen-space geometry to other shapes in their UV-space.\nBufD has two versions:\n[b]1. Homography [/b]\n[b]2. Image-Wrap[/b]\nCommon to enable.\n\n[b]Hotkey Space[/b] - enable cube update.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["interpolation","reprojection","imagewarp","homography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Danil (2020+) https://github.com/danilw\n// self https://www.shadertoy.com/view/tdyBRz\n\n\n\n// The MIT License\n\n\n\n\n// Control:\n// rotate camera(mouse) and move(arrows)\n// keyboard Space to switch static/dynamic frame\n\n\n// what is it:\n// BufA - camera control\n// BufB - intersected 3D scene (colorRGB dynamic scene, colorA static frame)\n// BufC - Inverse bilinear interpolation\n// BufD - Homography Screen/CameraUV in QuadUV as QuadUV (UV as colorRG)\n\n\n// quad texture is Blue, real cube is Red\n// orange border and Nyancat texture from BufC\n// top right is BufB in BufD UV its quad UV\n// top green is frame that used to build texture(saved frame of cube)\n// quad texture always use BufD as UV\n\n\n// BufD include two versionos of Reprojection, Vanishing point version and Image-Wrap \n// Image-Wrap is much slower (performance), can be enabled in Common\n\n// parallelogram case - camera start in parallelogram case\n\n// orange border and Nyancat texture from BufC (parallelogram case fixed)\n\n// quad texture use BufD as UV and BufB(in color.alpha static frame) as texture to display base on UV\n// (parallelogram case fixed)\n\n\n\nvec4 draw_buf(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel1,uv);\n    fragColor = mix(fragColor,texture(iChannel2,uv),texture(iChannel2,uv).a);\n    vec4 col=draw_buf(fragCoord);\n    fragColor = mix(fragColor,col,col.a);\n    fragColor.a=1.;\n}\n\nvec4 draw_buf(vec2 fragCoord){\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y -res*0.5;\n    vec2 ouv=fragCoord/iResolution.xy;\n    float size=0.2;\n    vec4 retc=vec4(0.);\n    \n    // BufB in quadUV(bufD)\n    if((abs(uv.x-res.x*0.5+size)<size)&&(abs(uv.y-res.y*0.5+size)<size)){\n        uv=uv-.5*res+size*2.;\n        vec2 tuv=texture(iChannel3,uv*.5/size).rg;\n        retc.rgb=vec3(texture(iChannel1,tuv).a*vec3(0.5,0.8,1.)*2.);\n        retc.a=1.;\n        //return retc;\n    }\n    \n    if((abs(ouv.x-1.+size*2.*(1./res.x)+size*0.5)<size*0.5)&&(abs(ouv.y-1.+size*0.5)<size*0.5)){\n        ouv=ouv-1.+vec2(size*2.*(1./res.x)+size*0.5,size*0.5);\n        retc.rgb=vec3(texture(iChannel1,ouv*1./size+0.5).a*vec3(0.45,1.,.45)*2.);\n        retc.a=1.;\n        return retc;\n    }\n    \n    return retc;\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// only camera control\n// License - CC0 or use as you wish\n\n#define keyboard_texture iChannel3\n#define self_texture iChannel0\n\nconst vec3 start_pos = vec3(0.0+pos_x, .5+pos_y, -0.5+pos_z-4.); //vec3(12.0, 9.0, -11.0);\nconst vec2 start_mouse = vec2(0., 0.); //vec2(-.88,-0.55);\n\n\nconst float speed = 1.75;\n\n\nvoid store(ivec2 P, ivec2 ipx, vec4 V, inout vec4 fc){ if(ipx==P) fc = V;}\n\nvec4 load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0);}\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 VMOUSE_last = ivec2(2, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    fragColor=vec4(0.);\n    \n    if(ivec2(fragCoord)==ivec2(iResolution.xy-1.)){\n        vec4 lastcol=texelFetch(iChannel0,ivec2(fragCoord),0);\n        if(abs(lastcol.r)<0.5)lastcol.r=-1.;\n        if((key(Key_Space,keyboard_texture)>0.5)&&(lastcol.g<0.5))lastcol.r*=-1.;\n        lastcol.g=key(Key_Space,keyboard_texture);\n        \n        lastcol.a=max(lastcol.a-1.,-2.);\n        if(lastcol.r>0.)lastcol.a=0.;\n        if(iTime<5.)lastcol.a=0.;\n        fragColor=lastcol;\n    }\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(ipx, self_texture);\n    \n    vec3 position_l = load(POSITION, self_texture).xyz;\n    vec2 vm_l = load(VMOUSE, self_texture).xy;\n    bool is_init = load(INIT, self_texture).x>1.;\n    \n    if (iFrame == 0 || !is_init) {\n        vm_l=start_mouse;\n        position_l=start_pos;\n        store(POSITION, ipx, vec4(start_pos, 0.), fragColor);\n        store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n        store(TARGET, ipx, vec4(start_pos, 0.), fragColor);\n        store(VMOUSE, ipx, vec4(start_mouse,0.,-1.), fragColor);\n        store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n        store(PMOUSE, ipx, vec4(start_mouse,0.,0.), fragColor);\n        store(INIT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(INPUT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n        return;\n    }\n\n    vec3 target      = load(TARGET, self_texture).xyz;   \n    vec3 position    = load(POSITION, self_texture).xyz;\n    vec2 pm          = load(PMOUSE, self_texture).xy;\n    vec3 vm          = load(VMOUSE, self_texture).xyz;\n    vec2 res_l       = load(RES_LAST, self_texture).xy;\n    float tvm          = load(VMOUSE, self_texture).w;\n    \n    float tval=smoothstep(0.,5.,iTime)*(1.-smoothstep(5.,10.,iTime));\n    if ((tvm<0.)&&(iMouse.z<=0.0)) {\n        vec2 rt=vec2(0.,-4.)*mat2(vec2(cos(tval), -sin(tval)), vec2(sin(tval), cos(tval)));\n        target=vec3(rt.x,target.y,rt.y)+vec3(pos_x,0.,pos_z-0.5);\n    }\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy, keyboard_texture) * iTimeDelta * speed;\n    \n    //Collision_floor(ptarget, target);\n    \n    vec3 lp = position;\n    //position += (target - position) * iTimeDelta * 5.0;\n    position = target;\n    \n    bool input_registered = false;\n    input_registered = ivec2(res_l)!=ivec2(iResolution.xy);\n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    store(TARGET, ipx, vec4(target, 0.0), fragColor);\n    store(POSITION, ipx, vec4(position, 0.0), fragColor);\n    \n    if ((tvm<0.)&&(iMouse.z<=0.0)) {\n        store(PMOUSE, ipx, vec4(vm.xy, 0.0, 0.0), fragColor);\n        float tp=iTime>5.?-1.:1.;\n        store(VMOUSE, ipx, vec4(pm + vec2(-cos((-0.5+tval*tp)*3.1415926)*05.01*1.77*1./iResolution.x,0.), 1.0, -1.0), fragColor);\n    }\n    else if (iMouse.z>0.0) {\n        input_registered=true;\n    \tstore(VMOUSE, ipx, vec4(pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y, 1.0, 0.0), fragColor);\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, ipx, vec4(vm.xy, 0.0, 0.0), fragColor);\n    }\n    store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n    store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n    \n    store(INPUT, ipx, vec4(input_registered?2.:0.,0.,0.,0.), fragColor);\n    \n    store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Danil (2020+) https://github.com/danilw\n\n// The MIT License\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n\n#define AA 0\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(2, 0);\n\nvec3 l1Pos = vec3(2,1,0);\n\n#define bgcol vec4(0.4)\nconst vec3 white=vec3(0xef,0xea,0xe0)/float(0xff);\nconst vec3 dark=vec3(0x16,0x14,0x32)/float(0xff);\nconst vec3 blue=vec3(0x0a,0x0f,0x73)/float(0xff);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n    \nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( vec3 t )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t t.x, t.y, t.z, 1.0 );\n}\n\nRay SetCamera(vec2 uv)\n{\n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy;\n    m.y = -m.y;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (M_PI / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n    return Ray(ro,rd);\n}\n\nbool BoxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out float tN, out vec3 norm) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    norm=vec3(0.,1.,0.);\n    \n\tif( tN > tF || tF < 0.0) return false;\n    if(tN<MIN_DIST && tN>MAX_DIST )return false;\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t\n\tnorm = (txi * vec4(nor,0.0)).xyz;\n\n\treturn true;\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\nbool ParallelogramIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, out float tx, out vec3 norm)\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross( a, b );\n    vec3 q = cross( rd, p );\n    float i = 1.0/dot( rd, n );\n    float u = dot( q, a )*i;\n    float v = dot( q, b )*i;\n    float t = dot( n, p )*i;\n    tx=-1.;\n    norm=vec3(0.,1.,0.);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;\n    vec3 normx = vec3( t, u, v );\n    if( normx.x>MIN_DIST && normx.x<MAX_DIST )\n    {\n    tx = normx.x;\n    vec3 nor = normalize( cross(v2-v1,v1-v3) );\n    norm = faceforward( nor, rd, nor );\n    return true;\n    }\n    return false;\n}\n\nvec4 calcColor_plane(vec3 ro, vec3 rd, float d)\n{\n    vec3 p = (ro+rd*d);\n    vec2 real_uv=(p.xy+vec2(-pos_x,-pos_y))/(vs*2.)+vec2(0.5,0.5); // real quad UV\n    vec2 ssUV=texture(iChannel3,real_uv).rg; // screen space UV reprojection from BufD\n    float tc=texture(iChannel1,ssUV).a; // read saved frame in screen space UV\n    return vec4(tc*vec3(0.5,0.8,1.)*2.,0.);\n}\n\nvec4 texBox(vec3 ro, vec3 rd, float d, vec3 nor, mat4 txx)\n{\n    vec3 pos = (ro+rd*d);\n    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n    vec3 tc=abs(onor.x)*texture( iChannel2, 0.5*opos.yz ).xyz + \n                   abs(onor.y)*texture( iChannel2, 0.5*opos.zx ).xyz + \n                   abs(onor.z)*texture( iChannel2, 0.5*opos.xy ).xyz;\n    return vec4(tc,1.);\n}\n\n\nvec4 calcColor_floor(vec3 ro, vec3 rd, float d) {\n   \tvec2 p = (ro+rd*d).xz;\n    vec2 e = min(vec2(1.0), fwidth(p)); \n    vec2 l = smoothstep(vec2(1.0), 1.0 - e, fract(p)) + smoothstep(vec2(0.0), e, fract(p)) - (1.0 - e);\n    return vec4(mix(vec3(0.4), vec3(0.8) * (l.x + l.y) * 0.5, exp(-d*0.01)),0.);\n}\n\n\n#define OBJ_CUBE 1\n#define OBJ_FLOOR 2\n#define OBJ_WALL 3\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n};\n\nvoid ParallelogramIntersectMin(vec3 ro, vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, inout bool result, \n                               inout HitInfo hit, int OBJ) {\n    float tnew;\n    vec3 normnew;\n    vec3 v3 = v1 + v2 - v0;\n    if (ParallelogramIntersect(ro, rd, v0, v1, v2, v3, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            float la=hit.color.a;\n            hit.color= calcColor_plane(ro,rd,hit.t);\n            hit.color.a=la;\n            hit.obj_type = OBJ;\n        }\n        result = true;\n    }\n}\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(0.0,01.,0.0,0.);\n    if (PlaneIntersect(pp, ro, rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.color = calcColor_floor(ro,rd,hit.t);\n            hit.color.a=hit.color.r*0.25;\n            hit.obj_type = OBJ_FLOOR;\n        }else hit.color.rgb = bgcol.rgb;\n        result = true;\n    }\n}\n\nvoid BoxIntersectMin(vec3 ro, vec3 rd, vec3 box, vec3 bpos, float angle, inout bool result, inout HitInfo hit, bool transp) {\n    float tnew;\n    vec3 normnew;\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)),  angle);\n\tmat4 tra = translate(bpos);\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n    if(determinant(txi)==0.)txx=txi;\n    if (BoxIntersect(ro, rd, txx, txi, box, tnew, normnew)) {\n        bool val=false;\n        if(transp)val=tnew < MAX_DIST;\n        else val=tnew < hit.t;\n        if (val) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            if(transp){\n                vec3 lc=hit.color.rgb;\n                hit.color.a = texBox(ro,rd,hit.t,normnew,txx).r;\n                hit.color.rgb=lc;\n            }else{\n                float la=hit.color.a;\n                hit.color.rgb = texBox(ro,rd,hit.t,normnew,txx).r*vec3(1.,0.28,0.15);\n                hit.color.a=la;\n            }\n            hit.obj_type = OBJ_CUBE;\n        }\n        result = true;\n    }\n}\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    vec2 res = vec2(1.);\n    hit.t = MAX_DIST;\n    hit.color=vec4(bgcol.rgb,0.);\n    bool result = false;\n    \n    vec4 verts_local [4]=verts;\n    verts_local[0].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[1].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[2].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[3].xyz+=vec3(pos_x,pos_y,pos_z);\n\n    GroundIntersectMin(ro, rd, result, hit);\n    \n    vec3 box=vec3(pos_x,pos_y,pos_z);\n    float angle=0.5;\n    \n    ParallelogramIntersectMin(ro, rd, verts_local[1].xyz, verts_local[2].xyz, verts_local[0].xyz, result, hit,OBJ_WALL);\n    float refresh=texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).a;\n    if(refresh>=-1.5)BoxIntersectMin(ro, rd,vec3(.75),box,angle,result, hit, false);\n    BoxIntersectMin(ro, rd,vec3(.75),box,angle,result, hit, true);\n    \n    return result;\n}\n\nconst float eps = 1e-3;\n\nvec4 render(Ray r)\n{\n    vec3 col = vec3(0.0);\n    vec3 objectcolor = vec3(1.0);\n    float objcol2=0.;\n    vec3 mask = vec3(1.0);\n    HitInfo hit;\n    hit.color=vec4(0.);\n    {\n        if(minDist(r.pos, r.dir, hit)){\n            objectcolor = hit.color.rgb;\n            vec3 p = r.pos + r.dir * hit.t + hit.norm*eps;\n            vec3 sunDir = normalize(l1Pos-p);\n            col = objectcolor;\n            objcol2=hit.color.a;\n        }else col = bgcol.rgb;\n    }\n    return vec4(col,objcol2);\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 lastcol=texelFetch(iChannel1,ivec2(fragCoord),0);\n    \n    float refresh=texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).a;\n    \n    vec4 ret_col = vec4(0.0);\n    #if AA>1\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n    #else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    #endif\n    uv.y *= iResolution.y/iResolution.x;\n    vec4 col = render(SetCamera(uv));\n    ret_col += col;\n    #if AA>1\n    }\n    ret_col /= float(AA*AA);\n    #endif\n    \n    if(refresh>=-1.5){\n        lastcol.a=ret_col.a;\n    }\n    \n    fragColor=vec4(ret_col.rgb,lastcol.a);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// Inverse bilinear interpolation\n// using https://www.shadertoy.com/view/lsBSDm\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// transform 3D verticles to 2D points\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(2, 0);\n\nmat4 get_camera() {\n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy;\n    m.y = -m.y;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    mat3 rotM=rotY*rotX;\n    \n    mat4 camToWorld = mat4(1.);\n    camToWorld[0].xyz = -rotM[0];\n    camToWorld[1].xyz = -rotM[1];\n    camToWorld[2].xyz = rotM[2];\n\n    camToWorld[3].xyz = ro;\n    camToWorld[0].w=0.;\n    camToWorld[1].w=0.;\n    camToWorld[2].w=0.;\n    \n    return camToWorld;\n}\n\nmat4 perspectiveMatrix(float fovYInRad, float aspectRatio)\n{\n    float yScale = 1.0/tan(fovYInRad / 2.0);\n    float xScale = yScale / aspectRatio;\n    float zf = 100.0;\n    float zn = 1.;\n\n    float z1 = zf/(zf-zn);\n    float z2 = -zn*zf/(zf-zn);\n\n    mat4 result = mat4(vec4(xScale, 0.0, 0.0, 0.0),\n                       vec4(0.0, yScale, 0.0, 0.0),\n                       vec4(0.0, 0.0, z1, z2),\n                       vec4(0.0, 0.0, -1.0, 0.0));\n\n    return result;\n}\n\nvoid get_points(out vec2 a, out vec2 b, out vec2 c, out vec2 d){\n    \n    float aspect = iResolution.x / iResolution.y;\n    //aspect=1.;  //when UV(or p) in mainImage include aspect, this not needed\n    \n    mat4 perspective=perspectiveMatrix(fov* (M_PI / 180.0),aspect);\n    mat4 camera=get_camera();\n    mat4 worldMat = inverse(camera);\n    mat4 mvp = perspective * worldMat;\n    \n    vec4 verts_local [4]=verts;\n    verts_local[0].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[1].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[2].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[3].xyz+=vec3(pos_x,pos_y,pos_z);\n    \n    vec4 WorldVert=vec4(0.);\n    WorldVert = mvp * verts_local[0];\n    a=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[1];\n    b=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[2];\n    c=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[3];\n    d=WorldVert.xy / WorldVert.w;\n}\n\n\n// Inverse bilinear interpolation\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return vec2(-1.0);\n    w = sqrt( w );\n\n    // will fail for k0=0, which is only on the ba edge \n    float v = 2.0*k0/(-k1 - w); \n    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);\n\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n    return vec2( u, v );\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.*(fragCoord.xy/iResolution.xy-0.5);\n    \n    float refresh=texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).a;\n    \n    // background\n    vec4 col = vec4( 0.);\n\n    // move points\n    vec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 d;\n    get_points(a,b,c,d);\n    \n    // when lines paralel just move one point\n    if((a.x==b.x)&&(c.x==d.x))a.x+=0.001;\n\n    // d = c+a-b; // enable this to test parallelograms\n    \n    // area of the quad\n    vec2 uv = invBilinear( p, a, b, c, d );\n    if( uv.x>-0.5 )\n    {\n        col = texture( iChannel1, uv.yx*vec2(1./6.,1.) );\n        float td=0.;\n        if(refresh<.0)td=smoothstep(0.,1.,mod(iTime+10.,20.))*(1.-smoothstep(7.,8.,mod(iTime+10.,20.)));\n        col.a*=0.2+0.8*td;\n    }\n    \n    // quad borders\n    float h = 2.0/iResolution.y;\n    float td=1.;\n    td=min(td,smoothstep(h,2.0*h,sdSegment(p,a,b)));\n    td=min(td,smoothstep(h,2.0*h,sdSegment(p,b,c)));\n    td=min(td,smoothstep(h,2.0*h,sdSegment(p,c,d)));\n    td=min(td,smoothstep(h,2.0*h,sdSegment(p,d,a)));\n    if(td<1.)\n    col = vec4(vec3(1.0,0.7,0.2),1.-td);\n\n\tfragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by Danil (2020+) https://github.com/danilw\n// self https://www.shadertoy.com/view/tdyBRz\n\n// Homography logic version\n// and Image-Wrap version\n\n// The MIT License\n\n// ScreenUV in QuadUV as QuadUV\n\n\n\n\n// transform 3D verticles to 2D points, same as in BufC\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(2, 0);\n\nmat4 get_camera() {\n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy;\n    m.y = -m.y;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    mat3 rotM=rotY*rotX;\n    \n    mat4 camToWorld = mat4(1.);\n    camToWorld[0].xyz = -rotM[0];\n    camToWorld[1].xyz = -rotM[1];\n    camToWorld[2].xyz = rotM[2];\n\n    camToWorld[3].xyz = ro;\n    camToWorld[0].w=0.;\n    camToWorld[1].w=0.;\n    camToWorld[2].w=0.;\n    \n    return camToWorld;\n}\n\nmat4 perspectiveMatrix(float fovYInRad, float aspectRatio)\n{\n    float yScale = 1.0/tan(fovYInRad / 2.0);\n    float xScale = yScale / aspectRatio;\n    float zf = 100.0;\n    float zn = 1.;\n\n    float z1 = zf/(zf-zn);\n    float z2 = -zn*zf/(zf-zn);\n\n    mat4 result = mat4(vec4(xScale, 0.0, 0.0, 0.0),\n                       vec4(0.0, yScale, 0.0, 0.0),\n                       vec4(0.0, 0.0, z1, z2),\n                       vec4(0.0, 0.0, -1.0, 0.0));\n\n    return result;\n}\n\nvoid get_points(out vec2 a, out vec2 b, out vec2 c, out vec2 d){\n    \n    float aspect = iResolution.x / iResolution.y;\n    //aspect=1.;  //when UV(or p) in mainImage include aspect, this not needed\n    \n    mat4 perspective=perspectiveMatrix(fov* (M_PI / 180.0),aspect);\n    mat4 camera=get_camera();\n    mat4 worldMat = inverse(camera);\n    mat4 mvp = perspective * worldMat;\n    \n    vec4 verts_local [4]=verts;\n    verts_local[0].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[1].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[2].xyz+=vec3(pos_x,pos_y,pos_z);\n    verts_local[3].xyz+=vec3(pos_x,pos_y,pos_z);\n    \n    vec4 WorldVert=vec4(0.);\n    WorldVert = mvp * verts_local[0];\n    a=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[1];\n    b=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[2];\n    c=WorldVert.xy / WorldVert.w;\n    WorldVert = mvp * verts_local[3];\n    d=WorldVert.xy / WorldVert.w;\n}\n\n\n// Reprojection\n\n#ifdef use_vpoint\n\n// version 1 \n// using Homography/Vanishing point\n\n// using http://alienryderflex.com/intersect/\nvec2 lineIntersection(vec2 a1, vec2 a2, vec2 b1, vec2 b2){\n  vec2 ret=vec2(100000.);\n  vec2 ob1=b1;\n  vec2 ob2=b2;\n  if ((a1==a2) || (b1==b2)) return ret;\n  a2+=-a1;\n  b1+=-a1;\n  b2+=-a1;\n  float distAB=length(a2);\n  vec2 rot=a2/distAB;\n  \n  float newX=b1.x*rot.x+b1.y*rot.y;\n  b1.y  =b1.y*rot.x-b1.x*rot.y; b1.x=newX;\n  newX=b2.x*rot.x+b2.y*rot.y;\n  b2.y  =b2.y*rot.x-b2.x*rot.y; b2.x=newX;\n  \n  //when lines paralel return far point in line2 direction\n  if (b1.y==b2.y) return 100000.*(ob2-ob1);\n\n  float ABpos=b2.x+(b1.x-b2.x)*b2.y/(b2.y-b1.y);\n  ret=a1+ABpos*rot;\n  return ret; \n}\n\n// https://iquilezles.org/articles/intersectors\nfloat plaIntersect( in vec3 ro, in vec3 rd, vec4 p)\n{\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 resolveCorner(vec3 p1, vec2 p1_r, vec2 p2_a, vec2 pl_a, vec2 pl_b)\n{\n    vec2 intersec = lineIntersection(p1_r,p2_a,pl_a,pl_b);\n    vec3 vp = normalize(vec3(-intersec,1.));\n    vec3 p1_to_p2 = vp;\n    vec3 r2 = normalize(vec3(-p2_a,1.));\n    \n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2);\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2);\n    float t = plaIntersect(p1,p1_to_p2,vec4(n_plane_p2,0.));\n    vec3 p2_ws = p1+t*p1_to_p2;\n    return p2_ws;\n}\n\nvoid resolvePerspective(vec2 sa, vec2 sb, vec2 sc, vec2 sd, \n                        out vec3 wa, out vec3 wb, out vec3 wc, out vec3 wd)\n{\n    wa = normalize(vec3(-sa,1.));\n    wb = resolveCorner(wa, sa, sb, sc, sd);\n    wc = resolveCorner(wb, sb, sc, sa, sd);\n    wd = resolveCorner(wa, sa, sd, sb, sc);\n}\n\nvec2 inversePerspective_uv(vec2 uv)\n{\n    vec3 wa, wb, wc, wd;\n    vec2 a, b, c, d;\n    get_points(a,d,c,b);\n    resolvePerspective(a*.5, b*.5, c*.5, d*.5, wa, wb, wc, wd);\n    vec3 x_ws = wb-wa;\n    vec3 y_ws = wd-wa;\n    vec3 p_ws = wa+uv.x*x_ws + uv.y*y_ws;\n    vec2 puv = -vec2(p_ws.x/p_ws.z,p_ws.y/p_ws.z);\n    \n    //formula from https://www.shadertoy.com/view/Wlccz2 (not perfectly corret)\n    //puv= a*.5+(b*.5-a*.5)*uv.x+((d*.5-a*.5)*(1.-uv.x)+(c*.5-b*.5)*(uv.x))*uv.y;\n    return puv+vec2(0.5,0.5);\n}\n#else\n\n\n// version 2 \n// image warp\n// this code come from old Java version of image wraping\n\nvoid LUDecomposition (out int piv[8],inout float LU[8*8]) {\n    for (int i = 0; i < 8; i++) {\n        piv[i] = i;\n    }\n    float LUcolj[8]=float[](0.,0.,0.,0.,0.,0.,0.,0.);\n\n    for (int j = 0; j < 8; j++) {\n        for (int i = 0; i < 8; i++) {\n            int idx=j+i*8;\n            LUcolj[i] = LU[idx];\n        }\n        for (int i = 0; i < 8; i++) {\n            int kmax = min(i,j);\n            float s = 0.0;\n            for (int k = 0; k < kmax; k++) {\n                s += LU[k+i*8]*LUcolj[k];\n            }\n\n            LU[j+i*8] = LUcolj[i] -= s;\n        }\n        int p = j;\n        for (int i = j+1; i < 8; i++) {\n            if (abs(LUcolj[i]) > abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n        if (p != j) {\n            for (int k = 0; k < 8; k++) {\n                int idx=k+p*8;\n                int idxl=k+j*8;\n                float t = LU[idx]; LU[idx] = LU[idxl]; LU[idxl] = t;\n            }\n            int k = piv[p]; piv[p] = piv[j]; piv[j] = k;\n        }\n        int idx=j+j*8;\n        if (bool(int(j < 8) & int(LU[idx] != 0.0))) {\n            for (int i = j+1; i < 8; i++) {\n                int idxl=j+i*8;\n                int idxg=j+j*8;\n                LU[idxl] /= LU[idxg];\n            }\n        }\n    }\n}\n\nbool isNonsingular (in float LU[8*8]) {\n    for (int j = 0; j < 8; j++) {\n        int idx=j+j*8;\n        if (LU[idx] == 0.)\n            return false;\n    }\n    return true;\n}\n\nbool solve (in int piv[8],in float LB[8],in float LU[8*8], out float X[8]) {\n    if (!isNonsingular(LU)) {\n      return false;\n    }\n    for (int i = 0; i < 8; i++) {\n            X[i] = LB[piv[i]];\n    }\n    for (int k = 0; k < 8; k++) {\n        for (int i = k+1; i < 8; i++) {\n            \tint idx=k+i*8;\n                X[i] -= X[k]*LU[idx];\n        }\n    }\n    for (int k = 8-1; k >= 0; k--) {\n            int idx=k+k*8;\n            X[k] /= LU[idx];\n        for (int i = 0; i < k; i++) {\n            \tint idx=k+i*8;\n                X[i] -= X[k]*LU[idx];\n        }\n    }\n    return true;\n}\n\nvec2 imageWarp_uv(vec2 uv)\n{\n    vec2 A, B, C, D;\n    get_points(A,D,C,B);\n    A*=0.5;B*=0.5;C*=0.5;D*=0.5;\n    A+=0.5;B+=0.5;C+=0.5;D+=0.5;\n    vec2 a, b, c, d;\n    a=vec2(0.);\n    b=vec2(1.,0.);\n    c=vec2(1.,1.);\n    d=vec2(0.,1.);\n    \n    float LU[8*8]=float[](\n        a.x,a.y,1.,0.,0.,0.,-a.x*A.x,-a.y*A.x,\n        b.x,b.y,1.,0.,0.,0.,-b.x*B.x,-b.y*B.x,\n        c.x,c.y,1.,0.,0.,0.,-c.x*C.x,-c.y*C.x,\n        d.x,d.y,1.,0.,0.,0.,-d.x*D.x,-d.y*D.x,\n        0.,0.,0.,a.x,a.y,1.,-a.x*A.y,-a.y*A.y,\n        0.,0.,0.,b.x,b.y,1.,-b.x*B.y,-b.y*B.y,\n        0.,0.,0.,c.x,c.y,1.,-c.x*C.y,-c.y*C.y,\n        0.,0.,0.,d.x,d.y,1.,-d.x*D.y,-d.y*D.y);\n    \n    float LB[8]=float[](A.x,B.x,C.x,D.x,A.y,B.y,C.y,D.y);\n    int piv[8];\n    LUDecomposition(piv,LU);\n    \n    \n    float LC[8];\n    vec2 tuv=vec2(0.);\n    if(solve(piv,LB,LU,LC))\n    {\n        tuv.x=(LC[0]*uv.x+LC[1]*uv.y+LC[2])/(LC[6]*uv.x+LC[7]*uv.y+1.0001);\n        tuv.y=(LC[3]*uv.x+LC[4]*uv.y+LC[5])/(LC[6]*uv.x+LC[7]*uv.y+1.0001);\n    }\n\n    return tuv;\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float refresh=texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).a;\n    if(refresh<-1.5){\n        fragColor=texelFetch(iChannel3,ivec2(fragCoord),0);\n        return;\n    }\n    \n    vec2 uv=(fragCoord/iResolution.xy);\n    \n    #ifdef use_vpoint\n    //version 1\n    vec2 tuv=inversePerspective_uv(uv);\n    #else\n    //version 2\n    vec2 tuv=imageWarp_uv(uv);\n    #endif\n    \n    \n    \n    fragColor = vec4( tuv,0.,0. );\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// this define used in BufD method to build reprojection\n\n// two versions, by default used Homography/Vanishing point version\n\n// second version is image-warp, delete this define to use image-warp\n#define use_vpoint\n\n\nconst float fov=70.0; // camera\n\n\nconst float vs = 2.5; // size of quad\n\nconst float pos_x=0.; // x shift\nconst float pos_y=3.; // y shift\nconst float pos_z=6.; // z shift \n\nconst vec4 verts [4]=vec4[](\n    vec4( -vs, -vs, 0., 1.0 ),\n    vec4( -vs,  vs, 0., 1.0 ),\n    vec4(  vs,  vs, 0., 1.0 ),\n    vec4(  vs, -vs, 0., 1.0 )\n   );\n\n\nconst float M_PI = 3.14159;","name":"Common","description":"","type":"common"}]}