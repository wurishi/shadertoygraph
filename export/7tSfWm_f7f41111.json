{"ver":"0.1","info":{"id":"7tSfWm","date":"1652751073","viewed":218,"name":"Complex Numbers","username":"Horriblebarry12","description":"A shader trying to play around with rendering and visualizing complex numbers and complex functions. May turn into a c++ program in the future. Very much a work in progress.","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["math","numbers","complexnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 speed = vec2(1.0);\nconst float AxisThickness = 0.012;\nconst float MinorGridlines = 0.01;\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 print(vec2 uv, vec2 scale, vec2 position, int character)\n{\n    return char(((1.0/scale) * uv) - position, character).xxxx;\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\nvec4 printFloat(vec2 uv ,vec2 scale, vec2 position, float number)\n{\n    return pFloat(((1.0/scale) * uv) - position, number).xxxx;\n}\n\nvec2 MovementOffset() \n{\n    return texelFetch(iChannel1, ivec2(0,0), 0).xy + (1.0*(texelFetch(iChannel3, ivec2(0), 0).xy));\n}\n\nvec2 LastMousePos()\n{\n    return texelFetch(iChannel2, ivec2(0), 0).xy;\n}\n\nfloat Zoom()\n{\n    float zoom = (texelFetch(iChannel1, ivec2(0), 0).z) + 1.0;\n    \n    \n   \n    return max(zoom,0.0000001);\n}\n\n\n\nvec2 ToLocal(vec2 point)\n{\n    return vec2((iResolution.x/2.0) + (point.x + (MovementOffset().x*speed.x)),\n    -(iResolution.y/2.0) + (point.y + (MovementOffset().y*speed.y)) )*0.01*Zoom();\n}\n\nvec2 ToVec2(ComplexNum num)\n{\n    return vec2(num.Real, num.Imaginary);\n}\n\nvec2 direction(vec2 from, vec2 to)\n{\n    return normalize(to-from);\n}\n\nint QuadrantNumber(vec2 coord)\n{\n    if (coord.x >= 0.0)\n    {\n        if (coord.y >= 0.0)\n        {\n            return 1;\n        }\n        else if (coord.y < 0.0)\n        {\n            return 4;\n        }\n    }\n    else if (coord.x < 0.0)\n    {\n        if (coord.y >= 0.0)\n        {\n            return 2;\n        }\n        else if (coord.y < 0.0)\n        {\n            return 3;\n        }\n    }\n}\n\n// x is the radius, y is the angle\nvec2 ToPolar(vec2 coord)\n{\n    float offset;\n    \n    int quadNum = QuadrantNumber(coord);\n    \n    if (quadNum == 1)\n    {\n        offset = 0.0;\n    }\n    else if (quadNum == 2 || quadNum == 3)\n    {\n        offset = 180.0;\n    }\n    \n    else\n    {\n        offset = 360.0;\n    }\n\n    return vec2(sqrt((coord.x*coord.x) + (coord.y*coord.y)), degrees(atan(coord.y/coord.x)) + offset);\n}\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\n\n// Hue-Saturation-Value [0..1] to RGB [0..1]\nvec3 HSVtoRGB(vec3 hsv)\n{\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nComplexNum ToComplexNum(vec2 inPoint)\n{\n    return ComplexNum(inPoint.x, inPoint.y);\n}\n\nbool inRange(float value, float range)\n{\n    return (value >= -range) && (value <= range);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //speed = normalize(iResolution.xy);\n    speed*= 500.0;\n    \n    ComplexNum inPoint = ToComplexNum(ToLocal(vec2(fragCoord.x,fragCoord.y )));\n\n    ComplexNum fPoint = f(inPoint, iTime);\n    \n    vec2 uv = fragCoord/iResolution.y;\n\n    vec2 dir = direction(ToVec2(inPoint), ToVec2(fPoint));\n    \n    vec3 col = HUEtoRGB((ToPolar(dir).y)/360.0);\n    \n    if (length(dir) == 0.0)\n    {\n        col = vec3(0.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0) * min(distance(vec2(0), ToVec2(fPoint)) * (2.0), 1.0);\n    \n    \n    \n    // Line\n    vec2 a = ToLocal(LastMousePos());\n    vec2 b = ToVec2(f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ) );\n    \n    \n    if (distance(ToVec2(fPoint), vec2(0)) < 0.001)\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    if (DistanceToSegment(a, b, ToLocal(fragCoord)) < 0.01 * Zoom())\n    {\n        vec2 c = (a+b)/2.0;\n    \n        if(distance(ToLocal(fragCoord), c) <= distance(a, c))\n        {\n                fragColor = vec4(0.0);\n        }\n        \n        \n    }\n    \n\n    if (inRange(inPoint.Real, (AxisThickness* Zoom())))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    else if (inRange(inPoint.Imaginary, (AxisThickness* Zoom())))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    if (inRange(mod(inPoint.Imaginary, 1.0), MinorGridlines*Zoom()))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    if (inRange(mod(inPoint.Real, 1.0), MinorGridlines*Zoom()))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    \n    if (distance(ToLocal(fragCoord.xy), ToLocal(LastMousePos())) < 0.05 * Zoom())\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    if (distance(ToLocal(fragCoord.xy), ToVec2(f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ) ) ) <  0.05 * Zoom())\n    {\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    \n        texelFetch(iChannel3, ivec2(1), 0);\n    vec2 scale = vec2(20.0 *(1.0/iResolution.y));\n    fragColor += vec4( print(uv, scale, vec2(0), 122).x); // z\n    fragColor += vec4( print(uv, scale, vec2(0.5,0), 61).x); // =\n    fragColor += vec4( print(uv, scale, vec2(1,0), 40).x); // (\n    fragColor += vec4( printFloat(uv, scale, vec2(2,0.0), ToLocal(LastMousePos()).x).x); // real\n    fragColor += vec4( print(uv, scale, vec2(6.5,0), 43).x); // +\n    fragColor += vec4( printFloat(uv, scale, vec2(7.5,0.0), ToLocal(LastMousePos()).y).x);\n    fragColor += vec4( print(uv, scale, vec2(12,0), 105).x); // i\n    fragColor += vec4( print(uv, scale, vec2(12.5,0), 41).x); // )\n    \n    fragColor += vec4( print(uv, scale, vec2(0, 1), 102).x); // f\n    fragColor += vec4( print(uv, scale, vec2(0.5, 1), 40).x); // (\n    fragColor += vec4( print(uv, scale, vec2(1,1), 122).x); // z\n    fragColor += vec4( print(uv, scale, vec2(1.5,1), 41).x); // )\n    fragColor += vec4( print(uv, scale, vec2(2.0,1), 61).x); // =\n    fragColor += vec4( print(uv, scale, vec2(2.5,1), 40).x); // (\n    fragColor += vec4( printFloat(uv, scale, vec2(3.5,1.0), f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ).Real).x); // real\n    fragColor += vec4( print(uv, scale, vec2(8,1), 43).x); // +\n    fragColor += vec4( printFloat(uv, scale, vec2(9,1.0), f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ).Imaginary).x);\n    fragColor += vec4( print(uv, scale, vec2(13.5,1), 105).x); // i\n    fragColor += vec4( print(uv, scale, vec2(14,1), 41).x); // )\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    float zoom = (-texelFetch(iChannel1, ivec2(KEY_IN, 0), 0).x) + (texelFetch(iChannel1, ivec2(KEY_OUT, 0), 0).x);\n    \n    offset += vec3(left + up + right + down, zoom) * velocity;\n    \n    return offset;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n    \n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_IN = 73;\nconst int KEY_OUT = 79;\n\nconst int KEY_SPACE = 32;\nconst int KEY_CTRL = 17;\n\nfloat pi = 3.14159;\nfloat e = 2.71828;\n\n\n#define MAX_POLYNOMIAL_SIZE 5\n\nstruct ComplexNum\n{\nfloat Real;\n\nfloat Imaginary;\n};\n\nComplexNum origin = ComplexNum(0.0, 0.0);\n\nconst float EPSILON = 0.00000001;\n\nfloat Power(float base, float power) {\n    // We want to ignore negative exponents for now. We invert our result at the if necessary.\n    bool negative = power < 0.0;\n    if (negative) {\n        power *= -1.0;\n    }\n\n    // Seperate the whole and fractional parts.\n    float fraction = power - float(int(power));\n    int integer = int(power - fraction);\n\n    // The whole part is easily calculated.\n    float intPow = 1.0;\n    \n    for (int i; i > integer; i++)\n    {\n        intPow *= base;\n    }\n\n    // The fractional part uses an approximation method.\n    float low = 0.0;\n    float high = 1.0;\n\n    float sqr = sqrt(base);\n    float acc = sqr;\n    float mid = high / 2.0;\n\n    while (abs(mid - fraction) > EPSILON) {\n        sqr = sqrt(sqr);\n\n        if (mid <= fraction) {\n            low = mid;\n            acc *= sqr;\n        } else {\n            high = mid;\n            acc *= (1.0 / sqr);\n        }\n\n        mid = (low + high) / 2.0;\n    }\n\n    // Exponential rules allow us to simply multiply our results.\n    float result = intPow * acc;\n\n    // If we started with a negative exponent we invert the result.\n    if (negative) {\n        return 1.0 / result;\n    }\n\n    return result;\n}\n\nfloat DistanceToSegment(vec2 a, vec2 b, vec2 p)\n{\n    vec2 a1, a2;\n    \n    a1 = a - b;\n    a2 = a - p;\n\n    float alpha = acos(((a1.x * a2.x) + (a1.y * a2.y))/(length(a1) * length(a2)));\n    \n    return distance(a, p)*sin(alpha);\n}\n\nComplexNum multiply_by_i(ComplexNum a, float b)\n{\n    return ComplexNum(-a.Imaginary * -(b), -a.Real * b);\n}\n\nComplexNum scale(ComplexNum a, float b)\n{\n    return ComplexNum(a.Real * b, a.Imaginary * b);\n}\n\nComplexNum multiply(ComplexNum a, ComplexNum b)\n{\n    if (a.Real == 0.0)\n    {\n        multiply_by_i(b, a.Imaginary);\n    }\n    if (b.Real == 0.0)\n    {\n        multiply_by_i(a, b.Imaginary);\n    }\n    if (a.Imaginary == 0.0)\n    {\n        scale(b, a.Real);\n    }\n    if (b.Imaginary == 0.0)\n    {\n        scale(a, b.Real);\n    }\n\n    ComplexNum _out = ComplexNum(1.0,1.0);\n\n    _out.Real = a.Real * b.Real - a.Imaginary * b.Imaginary;\n    _out.Imaginary = b.Real * a.Imaginary + b.Real * a.Imaginary;\n\n\n    return _out;\n}\n\nComplexNum add(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _out = ComplexNum(0.0, 0.0);\n    _out.Real = a.Real + b.Real;\n    _out.Imaginary = a.Imaginary + b.Imaginary;\n\n    return _out;\n}\n\nComplexNum subtract(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _out = ComplexNum(0.0, 0.0);\n    _out.Real = a.Real - b.Real;\n    _out.Imaginary = a.Imaginary - b.Imaginary;\n\n    return _out;\n}\n\nComplexNum divide(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _reciprocal = ComplexNum(1.0/b.Real, 1.0/b.Imaginary);\n\n    return multiply(a, _reciprocal);\n}\n\nComplexNum rotate(ComplexNum a, ComplexNum center, float angle)\n{\n    ComplexNum _out;\n    \n    float _cos = cos(angle);\n    float _sin = sin(angle);\n    float temp;\n    temp = ((a.Real-center.Real)*_cos - (a.Imaginary-center.Imaginary)*_sin) + center.Real;  \n    _out.Imaginary = ((a.Real-center.Real)*_sin + (a.Imaginary-center.Imaginary)*_cos) + center.Imaginary;\n    _out.Real = temp;\n    \n    return _out;\n}\n\nComplexNum Power(ComplexNum z, ComplexNum power)\n{\n    float r = sqrt((z.Real * z.Real) + (z.Imaginary * z.Imaginary));\n    float theta = atan(z.Imaginary/z.Real);\n    \n    return ComplexNum((r*sin(power.Real * theta)) * (1.0/( r * Power(e, power.Imaginary * theta))), (r * cos(power.Real * theta)) * (1.0/( r * Power(e, power.Imaginary * theta))));\n}\n\n\n\nComplexNum f(ComplexNum z, float time)\n{\n    //ComplexNum c = add( power(z,4), subtract(scale(power(z,3), 4.0) ,add( power(scale(z,2.0), 2), ComplexNum(2.0, -1.0)  )));\n       \n    return Power(z, ComplexNum(1.0,0.0));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 HandleMouse(vec4 offset)\n{\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n     \n    if (iMouse.w > 0.0)\n    {\n        offset.zw = mouse.xy;\n    }\n \n    offset.xy += offset.zw - mouse.xy;\n    offset.zw = mouse.xy;\n    \n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // x and y are offset values, z and w are mouse positions last frame ( when fragCoord =/= vec2(1.0) )\n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0);\n    \n    if (texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x > 0.0)\n    {\n        data = HandleMouse(data);\n    }\n    fragColor = data;\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    \n    if (!(texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x > 0.0))\n    {\n        data = iMouse;\n    }\n    \n    data.z = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x;\n    \n    \n    fragColor = data;\n}","name":"Buffer D","description":"","type":"buffer"}]}