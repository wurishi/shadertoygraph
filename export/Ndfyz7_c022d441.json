{"ver":"0.1","info":{"id":"Ndfyz7","date":"1641841274","viewed":154,"name":"Raymarching ùï°ùï£ùï†ùïòùïñùï£","username":"Proger","description":"simple raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535;\nfloat Scale = 0.5;\nfloat Offset = 1.;\nfloat shadowI = 0.08;\n\nvec3 colorO = vec3(1);\nbool isRend = true;\n\nfloat rnd(float value){return mod((value * 73129. + 95121.) , 1000.)/1000.;}\n\nvec2 hash22(vec2 p)\n{\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283 + iTime);\n}\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    float ym = mix(xm1,xm2,w.y); \n    return ym;\n   \n}\n\nfloat noise_one_octave(vec2 p){\n    float r = 0.0;\n\tr += 0.125*abs(perlin_noise(p*30.));\n    return r;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n   return log2(exp2(k * a) + exp2(k * b)) / k;\n}\n\nmat2 mrot(float a){\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getDist(vec3 p){\n  float sdS = length(p - vec3(0,1,0)) - ((1.-noise_one_octave(p.xy*0.05)*3.) );\n  //float sdB = sdBox(mod(p,4.) - vec3(2,2,2), vec3(0.5));\n  float sdP = p.y - noise_one_octave(p.xz*0.1);\n  float minim = min(sdS, sdP);\n\n  if(minim == sdS) colorO = vec3(0.4, 0.4, 1);\n\n  if(minim == sdP){\n    if(mod(float((int(p.x+100.5)+int(p.z+100.5))),2.)==0.)colorO = vec3(0.2, 0.2, 0.2);\n    else colorO = vec3(1, 1, 1);\n  }\n  if(isRend==false)colorO = vec3(1);\n  return minim;\n}\nvec3 getNormal(vec3 p){\n  isRend = false;\n  vec2 e = vec2(0.005,0);\n  float d = getDist(p);\n  vec3 n = vec3(\n    d - getDist(p-e.xyy),\n    d - getDist(p-e.yxy),\n    d - getDist(p-e.yyx)\n  );\n  return normalize(n);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd){\n  float dO = 0.0;\n  for(int i = 0; i < 300; i++){\n    vec3 p = ro + rd*dO;\n    float ds = getDist(p);\n    dO += ds;\n    if(dO > 80.) break;\n    if(ds < 0.005) return vec3(p);\n  }\n  return vec3(0);\n}\n\nfloat getLight(vec3 p, vec3 lp){\n  vec3 l = normalize(lp-p);\n  return dot(l, getNormal(p));\n}\n\nfloat shadow(vec3 light, vec3 p){\n  isRend = false;\n  float r = 1.;\n  vec3 rm = RayMarch(light, normalize(p-light));\n  if(length(p-rm) > 0.05)r=shadowI;\n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float m = min(iResolution.y,iResolution.x);\n  vec2 uv = ((fragCoord.xy-.5*iResolution.xy) / m);\n  vec3 color = vec3(1,5,-6);\n  vec3 light = vec3(3.,3,-3.);\n  vec3 ro = vec3(0, 1, -3);\n  vec3 rd = normalize(vec3(uv.xy, 1.));\n  rd.xz *= mrot(iMouse.x/iResolution.x*PI*3.-PI*1.5);\n  vec3 d = RayMarch(ro,rd);\n  color = colorO*vec3(max(getLight(d, light) * 1.3 * shadow(light,d),shadowI));\n  color = pow(color,vec3(0.4545));\n  if(d != vec3(0))fragColor = vec4(color, 1.0);\n  else fragColor = vec4(0.7,0.7,0.9,1);\n}","name":"Image","description":"","type":"image"}]}