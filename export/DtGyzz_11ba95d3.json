{"ver":"0.1","info":{"id":"DtGyzz","date":"1732031099","viewed":70,"name":"CM  Flowing ","username":"bythesword","description":"cloud map,Water effect","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","water","cloudmap"],"hasliked":0,"parentid":"lls3zf","parentname":"Flowing water"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//some code copy from \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 noise2b( in vec2 p )// Simplex Noise from IQ\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tp /=2.;\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 nx = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n    vec3 ny = h*h*h*h*vec3( dot(a,hash2(i+4.5)), dot(b,hash2(i+o+4.5)), dot(c,hash2(i+1.0+4.5)));\n\n    return vec2(dot( nx, vec3(70.0) ),dot( ny, vec3(70.0) ));\n\t\n}\n\n\nmat2 m2;\n\nvec2 fbm2(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.;\n    \n    for (int i = 0; i < 6; i++)\n    {\n        r += m2*noise2b(x+r)*a; \n        x +=.3*r+.4;\n    }     \n    return r;\n}\n\n\nvec2 water(vec2 x)\n{\n    x=fbm2(x);\n    x=abs(x)/dot(x,x)-1.;\n    return abs(x)/dot(x,x)-1.;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = 2.*fragCoord.xy / iResolution.yy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv*=19.5;\n    float t = 1.5*iTime;\n    float st = sin(t), ct = cos(t);\n    m2 = mat2(ct,st,-st,ct);\n    vec2 p = water(uv+1.*iTime)+1.;\n    float c = length(p)/7.;\n    c=clamp(pow(c,3.),0.,1.);\n    vec3 col=texture(iChannel0,uv/20.+p/45.).rgb;    \n    col=mix(col,vec3(.7,.7,.9),c);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n      \n    float step=12.0;\n    float perStep=step/4.0;\n    float stair=0.25;\n\n    vec3 CM=vec3(1.0,0.50,.0);\n    vec4 C1=vec4(1.,0.5,1.0,0.5);\n    vec3 C2=vec3(5.,1.,.5);\n\n\n\n\n    float w1 = (1.0 - uv.x);\n    float w2 = (uv.x - uv.y);\n    float w3 = uv.y;\n    \n    float v = w1*CM[0] + w2*CM[1] + w3*CM[2];\n    \n    float dv = 1.0 / step;\n\n    float vv = v;\n    int i=0;\n    int j= int (perStep);\n    if( vv <= 0.25 && vv>=0.0) {\n        for(i=0;i<j;i++){\n            if( vv >= float(i) *stair/perStep &&vv <= (float(i)+1.0)*stair/perStep)\n            {\n                fragColor = vec4(0.0, 1.0- float(i)/perStep*stair+0.0, 1.0, 1.0);\n                break;\n            }\n        }\n    }   \n    else if ( vv > 0.25 && vv <= 0.5) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.25+float(i) *stair/perStep &&vv <=0.25+ (float(i)+1.0)*stair/perStep)\n            {\n                fragColor = vec4(0.0, 0.75- float(i)/perStep*stair , 1.0, 1.0);\n                break;\n            }\n        }\n    }\n    else if ( vv > 0.5 && vv <= 0.75) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.5+float(i) *stair/perStep &&vv <=0.5+ (float(i)+1.0)*stair/perStep)\n            {\n                fragColor = vec4(0.0, 0.5- float(i)/perStep*stair , 1.0, 1.0);\n                break;\n            }\n        }\n    }\n    else if ( vv > 0.75 && vv <= 1.0) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.75+float(i) *stair/perStep &&vv <=0.75+ (float(i)+1.0)*stair/perStep)\n            {\n                fragColor = vec4(0.0, 0.25- float(i)/perStep*stair , 1.0, 1.0);\n                break;\n            } \n        }\n    }  \n    else{  \n        fragColor = vec4( 1.0 ,1.0, 1., 1.0); \n    }  \n//fragColor = vec4( .0 ,.0, 1., 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}