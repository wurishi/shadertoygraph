{"ver":"0.1","info":{"id":"fl2SzR","date":"1626971868","viewed":351,"name":"Temporal anti-aliasing","username":"Shcherbakov","description":"Temporal anti-aliasing sample.\nBicubic filtering from: https://www.shadertoy.com/view/MllSzX","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["taa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float INF = 1e10;\nconst vec3 TO_LIGHT_DIR = normalize(vec3(1, 1, 0));\n\nconst float PI = 3.14;\n\nconst float CAMERA_SPEED = 1.0;\nconst float PHASE = 1.0;\n\nconst int HALTON_COUNT = 8;\n\nconst float JITTER_SCALE = 1.0;\n\nvec2 HALTON_SEQUENCE[HALTON_COUNT] = vec2[HALTON_COUNT](\n    vec2(1.0 / 2.0, 1.0 / 3.0),\n    vec2(1.0 / 4.0, 2.0 / 3.0),\n    vec2(3.0 / 4.0, 1.0 / 9.0),\n    vec2(1.0 / 8.0, 4.0 / 9.0),\n    vec2(5.0 / 8.0, 7.0 / 9.0),\n    vec2(3.0 / 8.0, 2.0 / 9.0),\n    vec2(7.0 / 8.0, 5.0 / 9.0),\n    vec2(1.0 / 16.0, 8.0 / 9.0)\n);\n\nfloat towerSdf(vec3 pos) {\n    float cilindrDist = length(pos.xz);\n    float d = cilindrDist - 0.5;\n    d -= max(clamp(pos.y, -0.6, -0.2) + 0.6, 0.0) * 0.5;\n    d = max(d, pos.y + 0.3);\n    float sineScale = 0.04;\n    float sine = (\n        pow(sin(pos.y * 40.0) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y) * 19.05 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(cilindrDist * 40.0 + 0.5) * 0.5 + 0.5, 0.125 * 0.25)\n    );\n    d -= sine * sineScale;\n    {\n        float cil2 = length(pos.xz);\n        float dist = cil2 - 0.75;\n        dist = max(dist, -pos.y - 0.12);\n        dist = max(dist, pos.y - 0.7);\n        dist = max(dist, -cil2 + 0.7);\n        float doorCil1 = length(pos.xy * vec2(1.5, 0.5) + vec2(0, 0.3)) - 0.5;\n        dist = max(dist, -doorCil1);\n        float doorCil2 = length(pos.zy * vec2(1.5, 0.5) + vec2(0, 0.3)) - 0.5;\n        dist = max(dist, -doorCil2);\n        dist -= (pow(sin(pos.y * 40.0) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y + 1.0) * 19.5 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25))\n        * sineScale;\n        d = min(d, dist);\n    }\n    return d;\n}\n\nfloat roofSdf(vec3 pos) {\n    float q = length(pos.xz);\n    pos.y -= 2.3;\n    float d = max(dot(vec2(sqrt(3.0) / 2.0, 0.5),vec2(q,pos.y)),-1.7-pos.y);\n    d += fract(pos.y * 7.0) * 0.02;\n    d -= pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y + 1.0) * 22.0 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25) * 0.03;\n    return d;\n}\n\nvec2 intersect(vec3 pos, vec3 dir) {\n    float t = 0.0;\n    for (int i = 0; i < 150; ++i) {\n        vec3 samplePos = pos + t * dir;\n        float sdf = towerSdf(samplePos);\n        float sdf2 = roofSdf(samplePos);\n        if (sdf < 0.0) {\n            return vec2(t, 1.0);\n        }\n        if (sdf2 < 0.0) {\n            return vec2(t, 2.0);\n        }\n        t += max(min(sdf, sdf2), 0.01);\n    }\n    return vec2(INF, 0.0);\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(towerSdf(p+h.xyy) - towerSdf(p-h.xyy),\n                           towerSdf(p+h.yxy) - towerSdf(p-h.yxy),\n                           towerSdf(p+h.yyx) - towerSdf(p-h.yyx) ) );\n}\n\nvec3 calcNormalRoof( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(roofSdf(p+h.xyy) - roofSdf(p-h.xyy),\n                           roofSdf(p+h.yxy) - roofSdf(p-h.yxy),\n                           roofSdf(p+h.yyx) - roofSdf(p-h.yyx) ) );\n}\n\nbool sampleScene(vec3 pos, vec3 dir, inout vec3 color, samplerCube sky, sampler2D tex, sampler2D tex2) {\n    vec2 dist_mat = intersect(pos, dir);\n    if (dist_mat.x == INF) {\n        return false;\n    }\n    vec3 worldPos = pos + dist_mat.x * dir;\n    vec2 shadowCast = intersect(worldPos + TO_LIGHT_DIR * 1e-1, TO_LIGHT_DIR);\n    float shadowVal = shadowCast.x == INF ? 1.0 : 0.0;\n    vec3 col = vec3(0.7, 0.7, 0.7);\n    vec3 normal;\n    if (dist_mat.y == 1.0) {\n        normal = calcNormal(worldPos);\n        vec3 samplePos = worldPos * 1.0;\n        vec3 x = texture(tex, samplePos.yz).xyz;\n        vec3 y = texture(tex, samplePos.zx).xyz;\n        vec3 z = texture(tex, samplePos.xy).xyz;\n    \n        // blend factors\n        vec3 w = pow(abs(normal), vec3(1));\n        // blend and return\n        col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx;\n    } else {\n        col = vec3(0.7, 0.2, 0.2);\n        normal = calcNormalRoof(worldPos);\n        vec3 samplePos = worldPos * 5.0;\n        vec3 x = texture(tex2, samplePos.yz).xyz;\n        vec3 y = texture(tex2, samplePos.zx).xyz;\n        vec3 z = texture(tex2, samplePos.xy).xyz;\n    \n        // blend factors\n        vec3 w = pow(abs(normal), vec3(1));\n        // blend and return\n        col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx * col;\n    }\n    color = (max(0.0, dot(normal, TO_LIGHT_DIR)) * shadowVal + texture(sky, normal).rgb * 0.3) * col;\n    return true;\n}\n\nvec3 sampleScene(vec3 pos, vec3 dir) {\n    vec2 dist_mat = intersect(pos, dir);\n    return pos + dist_mat.x * dir;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0, 1, 5);\n    const float CAMERA_DIST = 5.0;\n    float speed = iTime * CAMERA_SPEED + PHASE;\n\n    CAMERA_POS = vec3(sin(speed) * CAMERA_DIST, 1, cos(speed) * CAMERA_DIST);\n    vec3 target = vec3(0, 0, 0);\n    vec3 finalColor = vec3(0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (HALTON_SEQUENCE[iFrame % HALTON_COUNT] - 0.5) * JITTER_SCALE) / iResolution.x;\n    vec3 forward = normalize(target - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + right * uv.x + up * uv.y);\n\n    vec3 color;\n    vec3 worldPos;\n    if (sampleScene(CAMERA_POS, viewVec, color, iChannel0, iChannel1, iChannel2)) {\n        finalColor += color;\n    } else {\n        finalColor += texture(iChannel0, viewVec).rgb;\n    }\n    \n    fragColor.rgb = finalColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 rgb_to_ycbcr(vec3 rgb) {\n    vec3 res;\n    res.x = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;\n    res.y = -0.168736 * rgb.r - 0.331264 * rgb.g + 0.5 * rgb.b;\n    res.z = 0.5 * rgb.r - 0.418688 * rgb.g - 0.081312 * rgb.b;\n    return res * vec3(219, 224, 224) + vec3(16, 128, 128);\n}\n\nvec3 ycbcr_to_rgb(vec3 ycbcr) {\n    vec3 res;\n    res.x = 298.082 / 256.0 * ycbcr.x + 408.583 * ycbcr.z / 256.0 - 222.921;\n    res.y = 298.082 / 256.0 * ycbcr.x - 100.291 / 256.0 * ycbcr.y - 208.120 / 256.0 * ycbcr.z+ 135.576;\n    res.z = 298.082 / 256.0 * ycbcr.x + 516.412 / 256.0 * ycbcr.y - 276.836;\n    return res / 256.0;\n}\n\n#define c_onePixel  (1.0 / iResolution.xy)\n#define c_twoPixels  (2.0 / iResolution.xy)\n\nfloat c_x0 = -1.0;\nfloat c_x1 =  0.0;\nfloat c_x2 =  1.0;\nfloat c_x3 =  2.0;\n\nvec3 CubicLagrange (vec3 A, vec3 B, vec3 C, vec3 D, float t)\n{\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n//=======================================================================================\nvec3 BicubicLagrangeTextureSample (vec2 P)\n{\n    vec2 pixel = P * iResolution.xy + 0.5;\n    \n    vec2 frac = fract(pixel);\n    pixel = floor(pixel) / iResolution.xy - vec2(c_onePixel/2.0);\n    \n    vec3 C00 = texture(iChannel1, pixel + vec2(-c_onePixel.x ,-c_onePixel.y)).rgb;\n    vec3 C10 = texture(iChannel1, pixel + vec2( 0.0        ,-c_onePixel.y)).rgb;\n    vec3 C20 = texture(iChannel1, pixel + vec2( c_onePixel.x ,-c_onePixel.y)).rgb;\n    vec3 C30 = texture(iChannel1, pixel + vec2( c_twoPixels.x,-c_onePixel.y)).rgb;\n    \n    vec3 C01 = texture(iChannel1, pixel + vec2(-c_onePixel.x , 0.0)).rgb;\n    vec3 C11 = texture(iChannel1, pixel + vec2( 0.0        , 0.0)).rgb;\n    vec3 C21 = texture(iChannel1, pixel + vec2( c_onePixel.x , 0.0)).rgb;\n    vec3 C31 = texture(iChannel1, pixel + vec2( c_twoPixels.x, 0.0)).rgb;    \n    \n    vec3 C02 = texture(iChannel1, pixel + vec2(-c_onePixel.x , c_onePixel.y)).rgb;\n    vec3 C12 = texture(iChannel1, pixel + vec2( 0.0        , c_onePixel.y)).rgb;\n    vec3 C22 = texture(iChannel1, pixel + vec2( c_onePixel.x , c_onePixel.y)).rgb;\n    vec3 C32 = texture(iChannel1, pixel + vec2( c_twoPixels.x, c_onePixel.y)).rgb;    \n    \n    vec3 C03 = texture(iChannel1, pixel + vec2(-c_onePixel.x , c_twoPixels.y)).rgb;\n    vec3 C13 = texture(iChannel1, pixel + vec2( 0.0        , c_twoPixels.y)).rgb;\n    vec3 C23 = texture(iChannel1, pixel + vec2( c_onePixel.x , c_twoPixels.y)).rgb;\n    vec3 C33 = texture(iChannel1, pixel + vec2( c_twoPixels.x, c_twoPixels.y)).rgb;    \n    \n    vec3 CP0X = CubicLagrange(C00, C10, C20, C30, frac.x);\n    vec3 CP1X = CubicLagrange(C01, C11, C21, C31, frac.x);\n    vec3 CP2X = CubicLagrange(C02, C12, C22, C32, frac.x);\n    vec3 CP3X = CubicLagrange(C03, C13, C23, C33, frac.x);\n    \n    return CubicLagrange(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float weight = 0.95;\n    \n    vec3 CAMERA_POS = vec3(0, 1, 5);\n    const float CAMERA_DIST = 5.0;\n    float speed = iTime * CAMERA_SPEED + PHASE;\n\n    CAMERA_POS = vec3(sin(speed) * CAMERA_DIST, 1, cos(speed) * CAMERA_DIST);\n    vec3 target = vec3(0, 0, 0);\n    vec3 finalColor = vec3(0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (HALTON_SEQUENCE[iFrame % HALTON_COUNT] - 0.5) * JITTER_SCALE) / iResolution.x;\n    vec3 forward = normalize(target - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + right * uv.x + up * uv.y);\n    \n    vec3 worldPos = sampleScene(CAMERA_POS, viewVec);\n    float prevTime = speed - CAMERA_SPEED * iTimeDelta;\n    vec3 prevCameraPos = vec3(sin(prevTime) * CAMERA_DIST, 1, cos(prevTime) * CAMERA_DIST);\n    vec3 prevViewVec = normalize(worldPos - prevCameraPos);\n    vec3 prevForward = normalize(target - prevCameraPos);\n    vec3 prevUp = vec3(0, 1, 0);\n    vec3 prevRight = normalize(cross(prevForward, prevUp));\n    prevUp = cross(prevRight, prevForward);\n    vec3 scaledPrevView = prevViewVec / dot(prevViewVec, prevForward);\n    vec2 prevUV = vec2(dot(scaledPrevView, prevRight), dot(scaledPrevView, prevUp));\n    vec2 prefFragCoord = prevUV * iResolution.x + iResolution.xy * 0.5;\n    \n    vec3 colorMin = vec3(INF);\n    vec3 colorMax = vec3(-INF);\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            vec3 color = rgb_to_ycbcr(texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy).rgb);\n            colorMin = min(colorMin, color);\n            colorMax = max(colorMax, color);\n        }\n    }\n    \n    vec2 motionVector = (fragCoord - prefFragCoord) / iResolution.xy;\n    weight *= max(1.0 - length(motionVector) / 10.0, 0.0) ;\n    if (prefFragCoord.x < 0.0 || prefFragCoord.y < 0.0 || prefFragCoord.x > iResolution.x || prefFragCoord.y > iResolution.y) {\n        weight = 0.0;\n    }\n    \n    vec3 prevFrame = rgb_to_ycbcr(BicubicLagrangeTextureSample(prefFragCoord / iResolution.xy).rgb);\n    prevFrame = clamp(prevFrame, colorMin, colorMax);\n    vec3 currentFrame = rgb_to_ycbcr(texture(iChannel0, fragCoord / iResolution.xy).rgb);\n    fragColor.rgb = ycbcr_to_rgb(mix(currentFrame, prevFrame, weight));\n}","name":"Buffer B","description":"","type":"buffer"}]}