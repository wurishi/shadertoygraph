{"ver":"0.1","info":{"id":"M3SyWK","date":"1727718019","viewed":44,"name":"raycasting 6 spheres","username":"user49594","description":"raycasting","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float TAU = 6.2831853;\n\nfloat sphIntersect(vec3 ro, vec3 rd, float ra){\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra * ra;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nfloat plaIntersect(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nfloat triIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross(b, a);\n    vec3 q = cross(p, rd);\n    float idet = 1.0 / dot(rd, n);\n    float u = dot(q, b) * idet;\n    float v = dot(q, a) * idet;\n    float t = dot(n, p) * idet;\n    if (u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return t;\n}\n\nfloat sphOcclusion(vec3 pos, vec3 nor, vec4 sph) {\n    vec3  di = sph.xyz - pos;\n    float l = length(di);\n    float nl = dot(nor, di / l);\n    float h  = l / sph.w;\n    float h2 = h * h;\n    float k2 = 1.0 - h2 * nl * nl;\n    float res = max(0.0, nl) / h2;\n    if (k2 > 0.001){\n\t\tres = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n      res = res / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n      res /= PI;\n    }\n    return res;\n}\n\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 ) {\n    vec3 a = normalize(v0 - pos);\n    vec3 b = normalize(v1 - pos);\n    vec3 c = normalize(v2 - pos);\n    float s = sign(dot(v0 - pos, cross(v1 - v0, v2 - v1)));\n    return s * (dot(nor, normalize(cross(a,b))) * acos(dot(a,b)) +\n              dot(nor, normalize(cross(b,c))) * acos(dot(b,c)) +\n              dot(nor, normalize(cross(c,a))) * acos(dot(c,a))) / TAU;\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    float d = sqrt( max(0.0, sph.w * sph.w - h)) - sph.w;\n    float t = -b - sqrt(max(h, 0.0));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5 * k * d / t);\n}\n\n\n\nstruct info{\n\tvec3 p;\n\tvec3 n;\n\tbool hit;\n\tfloat len;\n\tfloat id;\n};\n\ninfo castRay (in vec3 ro, in vec3 rd) {\n\tfloat minIt = 99999.0;\n\tvec3 n;\n\tfloat it;\n\tfloat id;\n\tit = sphIntersect(ro - vec3(0.0, 0.0, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(0.0, 0.0, 0.0) + rd * it;\n\t\tid = 1.0;\n\t}\n\tit = sphIntersect(ro - vec3(2.0, 0.0, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(2.0, 0.0, 0.0) + rd * it;\n\t\tid = 3.0;\n\t}\n\tit = sphIntersect(ro - vec3(-2.0, 0.0, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(-2.0, 0.0, 0.0) + rd * it;\n\t\tid = 4.0;\n\t}\n\tit = sphIntersect(ro - vec3(1.0, 1.71, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(1.0, 1.71, 0.0) + rd * it;\n\t\tid = 5.0;\n\t}\n\tit = sphIntersect(ro - vec3(-1.0, 1.71, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(-1.0, 1.71, 0.0) + rd * it;\n\t\tid = 6.0;\n\t}\n\tit = sphIntersect(ro - vec3(0.0, 3.42, 0.0), rd, 1.0);\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = ro - vec3(0.0, 3.42, 0.0) + rd * it;\n\t\tid = 7.0;\n\t}\n\tit = triIntersect(ro, rd, vec3(0.0, -1.0, -9999.0), vec3(-9999.0, -1.0, 0.0), vec3(9999.0, -1.0, 9999.0));\n\tif(it > 0.0 && it < minIt){\n\t\tminIt = it;\n\t\tn = vec3(0.0, 1.0, 0.0);\n\t\tid = 2.0;\n\t}\n\tif (minIt == 99999.0) return info(vec3(0.0), vec3(0.0), false, 0.0, 0.0);\n\tvec3 p = ro + (rd * (minIt + 0.001));\n\treturn info(p, n, true, minIt, id);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 n, float len, float id){\n\tvec3 col;\n\tvec3 color;\n\tvec3 light = normalize(vec3(cos(iTime * 2.0) * 200.0, 150.0, sin(iTime * 2.0) * 200.0) - p);\n\tfloat occ = 1.0;\n\tif (id == 3.0) {\n\t\tcolor = vec3(1.0, 0.10, 0.10);\n\t\tocc = 1.0 - triOcclusion(p, n, vec3(0.0, -1.0, -9999.0), vec3(-9999.0, -1.0, 0.0), vec3(9999.0, -1.0, 9999.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(1.0, 1.71, 0.0, 1.0));\n\t} else if (id == 2.0){\n\t\tint a = int((p.x + 300.0) / 1.0) + int((p.y + 300.0) / 1.0) + int((p.z + 300.0) / 1.0);\n\t\tcolor = vec3(mod(float(a), 2.0) * 0.4 + 0.2);\n\t\tocc = 1.0 - sphOcclusion(p, n, vec4(0.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(2.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-2.0, 0.0, 0.0, 1.0));\n\t} else if (id == 1.0){\n\t\tcolor = vec3(0.1, 1.0, 0.1);\n\t\tocc = 1.0 - triOcclusion(p, n, vec3(0.0, -1.0, -9999.0), vec3(-9999.0, -1.0, 0.0), vec3(9999.0, -1.0, 9999.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(2.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-2.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(1.0, 1.71, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-1.0, 1.71, 0.0, 1.0));\n\t} else if (id == 4.0){\n\t\tcolor = vec3(0.1, 0.1, 1.0);\n\t\tocc = 1.0 - triOcclusion(p, n, vec3(0.0, -1.0, -9999.0), vec3(-9999.0, -1.0, 0.0), vec3(9999.0, -1.0, 9999.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-1.0, 1.71, 0.0, 1.0));\n\t}else if (id == 5.0){\n\t\tcolor = vec3(1.0, 1.0, 0.1);\n\t\tocc = 1.0 - sphOcclusion(p, n, vec4(2.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-1.0, 1.71, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 3.42, 0.0, 1.0));\n\t}else if (id == 6.0){\n\t\tcolor = vec3(0.1, 1.0, 1.0);\n\t\tocc = 1.0 - sphOcclusion(p, n, vec4(-2.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 0.0, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(1.0, 1.71, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(0.0, 3.42, 0.0, 1.0));\n\t}else if (id == 7.0){\n\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\tocc = 1.0 - sphOcclusion(p, n, vec4(1.0, 1.71, 0.0, 1.0));\n\t\tocc *= 1.0 - sphOcclusion(p, n, vec4(-1.0, 1.71, 0.0, 1.0));\n\t}\n\tvec3 specular = vec3(0.5) * pow(clamp(dot(reflect(-light, n), -rd), 0.0, 1.0), 64.0);\n\tvec3 fresnel = 0.25 * color * pow(1.0 + dot(rd, n), 3.0);\n\tvec3 back = 0.05 * color * clamp(dot(n, -light), 0.0, 1.0);\n\tfloat shadow = (sphSoftShadow(p, light, vec4(0.0, 0.0, 0.0, 1.0),10.0) *\n\tsphSoftShadow(p, light, vec4(2.0, 0.0, 0.0, 1.0), 10.0) *\n\tsphSoftShadow(p, light, vec4(-2.0, 0.0, 0.0, 1.0), 10.0)*\n\tsphSoftShadow(p, light, vec4(1.0, 1.71, 0.0, 1.0), 10.0)*\n\tsphSoftShadow(p, light, vec4(-1.0, 1.71, 0.0, 1.0), 10.0)*\n\tsphSoftShadow(p, light, vec4(0.0, 3.42, 0.0, 1.0), 10.0));\n\tvec3 diffuse = color * clamp(dot(light, n), 0.0, 1.0);\n\treturn (fresnel + color * 0.05) * occ + (specular * occ + diffuse) * shadow;\n}\n\nvec2 getUv(vec2 offset, in vec2 fragCoord){\n\treturn (2.0 * fragCoord.xy + offset - iResolution.xy) / iResolution.y;\n}\n\nvec3 getSky(vec3 rd){\n\treturn vec3(0.25, 0.35, 1.0) + vec3(pow(max(dot(normalize(vec3(cos(iTime * 2.0) * 200.0, 150, sin(iTime * 2.0) * 200.0)), rd), 0.0), 128.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinfo inf;\n\tvec3 col;\n\tvec3 ro = vec3(0.0, 1.25, 7.0);\n\n\t\n\tvec3 rd;\n\tvec2 uv = getUv(vec2(0.0), fragCoord);\n    rd = normalize(vec3(uv, -1.0));\n    inf = castRay(ro, rd);\n    if (inf.hit){\n    \tcol += mix(getLight(inf.p, rd, inf.n, inf.len, inf.id), getSky(rd), 1.0 - exp(-0.0008 * inf.len * inf.len));\n    } else {\n       \tcol += getSky(rd)- max(0.95 * -rd.y, 0.0);\n    }\n    col.x = pow(col.x, 0.4545);\n    col.y = pow(col.y, 0.4545);\n    col.z = pow(col.z, 0.4545);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}