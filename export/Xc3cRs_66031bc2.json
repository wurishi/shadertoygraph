{"ver":"0.1","info":{"id":"Xc3cRs","date":"1731000533","viewed":83,"name":"Dancing Angel (?)","username":"Hardronix","description":"Made it out of pure boredom ^^''","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["procedural","2d","cute","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Hardronix out of pure boredom in 2024.\n\nvec4 drawEyes(vec2 uv, float headTime, vec4 color) {\n    vec4 col = vec4(0);\n    \n    float horizontalEyeOffset = 0.038;\n    float verticalEyeOffset = (-cos(iTime) * 0.1) + 0.12;\n    float bobbingEyeOffset = -headTime * 0.01;\n    \n    if(withinRect(uv, vec2(horizontalEyeOffset + bobbingEyeOffset, verticalEyeOffset), vec2(0.005, 0.03))) {\n        col += color;\n    }\n    \n    if(withinRect(uv, vec2(-horizontalEyeOffset + bobbingEyeOffset, verticalEyeOffset), vec2(0.005, 0.03))) {\n        col += color;\n    }\n    \n    return col;\n}\n\nvec4 drawMouth(vec2 uv, float headTime, vec4 color) {\n    vec4 col = vec4(0);\n    \n    float horizontalMouthOffset = 0.0092f;\n    float verticalMouthOffset =  (cos(iTime) * 0.1) - 0.1;\n    float horizontalMouthBobbingOffset = headTime * 0.01f;\n    \n    if(inLowCircleOutline(uv + vec2(horizontalMouthOffset + horizontalMouthBobbingOffset, verticalMouthOffset), 0.01, 0.002)) {\n            col += color;\n    }\n    \n    if(inLowCircleOutline(uv + vec2(-horizontalMouthOffset + horizontalMouthBobbingOffset, verticalMouthOffset), 0.01, 0.002)) {\n            col += color;\n    }\n    \n    return col;\n}\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 bgColor = vec3(0.078,0.078,0.09);\n    \n    vec3 col = bgColor;\n    \n    float danceSpeed = DANCE_SPEED;\n\n    vec2 angelUv = uv;\n    \n    float angelOffset = cos(iTime) * 0.1;\n    angelUv.y += angelOffset;\n\n    col -= uv.y * 0.2;\n    \n    float angelTime;\n    vec2 angelData;\n    \n    float osc1 = oscillate(iTime, 0.2, 0.4, 0.5, 0.5);\n    float headTime = osc1 > 0.4 ? sin(iTime * danceSpeed) : 0.0;\n    float bodyTime = sin(iTime) * 0.005;\n    float brightOsc = sin(iTime + 0.420);\n    \n    for(int i = 0; i < 20; i++) {\n        angelTime = float(i) / 5.0 * 3.14159;\n        \n        angelData.x = 16.0 * pow(sin(angelTime), 3.0);\n        angelData.y = 13.0 * cos(angelTime) - 5.0 * cos(2.0 * angelTime) - 2.0 * cos(3.0 * angelTime + bodyTime) - cos(4.0 * angelTime + headTime);\n\n        angelData *= 0.03 * osc1; \n        \n        if(brightOsc < 0.0f) {\n            angelData *= pow(angelTime, 0.03);\n        }\n        \n        col *= vec3(0.9) * draw(angelUv - angelData);\n    }\n    \n    col = pow(col, vec3(brightOsc));\n    \n    if(brightOsc < 0.4) {\n        if(lumi(col) > 5.0) {\n            col *= 0.1;        \n            col /= 2.0;\n        }\n    }\n    \n    if(brightOsc < 0.0) {\n        col = vec3(lumi(col));\n    }\n    \n    vec4 colTwo = vec4(col, 1.0);\n    \n    colTwo += -drawEyes(uv, headTime, vec4(bgColor * vec3(3.0), 1.0));\n    colTwo += -drawMouth(uv, headTime, vec4(bgColor * vec3(3.0), 1.0));\n    \n    fragColor = colTwo;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DANCE_SPEED 6.0f;\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nfloat oscillate(float timeIn, float freq, float minAmp, float maxAmp, float shift) {\n    return clamp(sin(timeIn * freq + timeIn), minAmp, maxAmp) + shift;\n}\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nfloat sdfCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdfHollowCircle(vec2 p, float outerRadius, float innerRadius) {\n    float dOuter = length(p) - outerRadius;\n    float dInner = length(p) - innerRadius;\n    return max(dOuter, -dInner); \n}\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nbool inCircleOutline(vec2 uv, float radius, float borderWidth) {\n    float d = length(uv);\n    return d >= (radius - borderWidth) && d <= radius;\n}\n\n\nbool inLowCircleOutline(vec2 uv, float radius, float borderWidth) {\n    float hollowCircle = sdfHollowCircle(uv, radius + borderWidth, radius);\n    float opaqueCircle = sdfCircle(uv + vec2(0.0, 0.01), radius);\n    \n    return max(opaqueCircle, hollowCircle) < 0.0f;\n}\n\nbool withinRect(vec2 uv, vec2 pos, vec2 dim) {\n    return uv.x > pos.x && uv.x <= pos.x + dim.x && uv.y >= pos.y && uv.y <= pos.y + dim.y;\n}\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nvec3 draw(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < 4; i++) {\n        col += sdfCircle(uv * vec2(i, i), 0.3) > 0.0 ? vec3(0.0) : vec3(1.0);\n        col *= sdfCircle(uv * vec2(i, i), 0.35) > 0.0 ? vec3(1.0) : vec3(0.98);\n    }\n    \n    return col;\n}\n\nfloat lumi(vec3 col) {\n    return (0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b);\n}","name":"Common","description":"","type":"common"}]}