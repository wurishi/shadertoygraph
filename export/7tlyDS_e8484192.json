{"ver":"0.1","info":{"id":"7tlyDS","date":"1648738169","viewed":96,"name":"Raytracing view dependent arrows","username":"51m0n397","description":"Rendering of arrows with consistent thickness regardless of the camera params\nUse the LEFT and RIGHT arrows to cycle between the samplers\nUse the UP and DOWN arrows to change projection\nUse the mouse + ALT or SHIFT to control the camera\n","likes":1,"published":1,"flags":48,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"stsyWS","parentname":"Raytracing view dependent lines"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LINES     3\n#define MAX_RECURSION 10\n\n\n#define CAP            0\n#define STEALTH_ARROW  1\n#define TRIANGLE_ARROW 2\n\nstruct ray3 {\n    vec3  o;\n    vec3  d;\n    float tmin;\n    float tmax;\n};\n\nstruct intersection {\n    int   id;\n    bool  hit;\n    vec2  uv;\n    float dist;\n    vec3  pos;\n    vec3  norm;\n};\n\nstruct view_dep_line_params {\n    float r0; \n    float r1;\n    vec3  pn0;\n    vec3  pn1;\n    vec3  p45an0;\n    vec3  p45an1;\n    vec3  p45bn0;\n    vec3  p45bn1;\n    vec3  ap0;\n    vec3  ap1;\n    float ar0;\n    float ar1;\n};\n\nstruct dgram_line {\n    vec3  p0;\n    vec3  p1;\n    int   e0;\n    int   e1;\n    float thickness;\n    vec4  stroke;\n    \n    view_dep_line_params view_dep_params;\n};\n\nfloat scale = 80.;\nfloat size  = 720.;\n\nconst view_dep_line_params blank_params = view_dep_line_params(0., 0., zero3, zero3, zero3, zero3, zero3, zero3, zero3, zero3, 0., 0.);\n\ndgram_line lines[NUM_LINES] = dgram_line[](\n    dgram_line(vec3(0., 0., 0.), vec3( 2., -1., 1.), CAP, STEALTH_ARROW, 10., vec4(1.0, 0.0, 0.0, 1.0), blank_params),\n    dgram_line(vec3(0., 0., 0.), vec3(-2., -1., 1.), CAP, TRIANGLE_ARROW, 10., vec4(1.0, 0.0, 0.0, 1.0), blank_params),\n    dgram_line(vec3(0., 0., 0.), vec3( 0.,  1., 0.), CAP, CAP, 10., vec4(1.0, 0.0, 0.0, 1.0), blank_params)\n);\n\nray3 evalCamera(dgram_camera cam, vec2 uv, vec2 res) {\n    float aspect = res.x / res.y;\n    vec2  film   = aspect >= 1. ? vec2(cam.film, cam.film / aspect)\n                                : vec2(cam.film * aspect, cam.film);\n    frame3 frame = lookat_frame(cam.from, cam.to, vec3(0., 1., 0.), false);\n    float  lens  = cam.lens / size * scale;\n    \n    if (!cam.orthographic) {\n        vec3 q = vec3(film.x * (0.5f - uv.x), film.y * (uv.y - 0.5f), lens);\n        vec3 e = zero3;\n        vec3 d = normalize(-q - e);\n        return ray3(transform_point(frame, e), transform_direction(frame, d), ray_eps, flt_max);\n    } else {\n        float s = length(cam.from - cam.to) / lens;\n        vec3  q = vec3(film.x * (0.5f - uv.x) * s,\n          film.y * (uv.y - 0.5f) * s, lens);\n        vec3  e = vec3(-q.x, -q.y, 0);\n        vec3  d = normalize(-q - e);\n        return ray3(transform_point(frame, e), transform_direction(frame, d), ray_eps, flt_max);\n    }\n}\n\nint getSampler() {\n    return int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n}\n\ndgram_camera getCamera() {\n    bool orthographic = bool(texelFetch(iChannel1, ivec2(0, 1), 0).x);\n    vec3 from         = texelFetch(iChannel1, ivec2(0, 2), 0).xyz;\n    vec3 to           = texelFetch(iChannel1, ivec2(0, 3), 0).xyz;\n    float lens        = texelFetch(iChannel1, ivec2(0, 4), 0).x;\n    float film        = texelFetch(iChannel1, ivec2(0, 5), 0).x;\n\n    return dgram_camera(orthographic, from, to, lens, film);\n}\n\nintersection intersectCylinder(ray3 ray, vec3 p0, vec3 p1, float r, vec3 dir, intersection isec) { \n    vec3  av = ray.d - dot(ray.d, dir) * dir;\n    float a  = dot(av, av);\n    vec3  dp = ray.o - p0;\n    float b  = 2. * dot(ray.d - dot(ray.d, dir) * dir, dp - dot(dp, dir) * dir);\n    vec3  cv = dp - dot(dp, dir) * dir;\n    float c  = dot(cv, cv) - r * r;\n\n    float t1 = 0.;\n    float t2 = 0.;\n    \n    float discr = b * b - 4. * a * c;\n    if (discr < 0.)\n        return isec; // no hit\n    else if (discr == 0.)\n        t1 = t2 = -0.5 * b / a;\n    else {\n        float q = (b > 0.) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t1      = q / a;\n        t2      = c / q;\n    }\n\n    vec3 q1 = ray.o + t1 * ray.d;\n    vec3 q2 = ray.o + t2 * ray.d;\n    \n    bool new_hit = false;\n\n    if (t1 >= ray.tmin && t1 <= isec.dist && dot(dir, q1 - p0) > 0. &&\n        dot(dir, q1 - p1) < 0.) {\n      isec.dist = t1;\n      isec.pos  = q1;\n      new_hit   = true;\n    }\n\n    if (t2 >= ray.tmin && t2 <= isec.dist && dot(dir, q2 - p0) > 0. &&\n        dot(dir, q2 - p1) < 0.) {\n      isec.dist = t2;\n      isec.pos  = q2;\n      new_hit   = true;\n    }\n    \n\n    if (!new_hit) return isec;\n\n    isec.hit  = true;\n    float d   = dot(isec.pos - p0, dir);\n    vec3  pt  = p0 + d * dir;\n    isec.norm = normalize(isec.pos - pt);\n\n    return isec;\n}\n\nintersection intersectCone(ray3 ray, vec3 p0, vec3 p1, float r0, float r1, vec3 dir, intersection isec) { \n    float ab    = distance(p1, p0);  // Distance between the two ends\n    vec3 pc     = p0 - dir * r0 * ab / (r1 - r0);  // Cone's apex point\n    float tga   = (r1 - r0) / ab;\n    float cosa2 = 1. / (1. + tga * tga);\n\n    vec3 co = ray.o - pc;\n\n    float a = dot(ray.d, dir) * dot(ray.d, dir) - cosa2;\n    float b = 2. * (dot(ray.d, dir) * dot(co, dir) - dot(ray.d, co) * cosa2);\n    float c = dot(co, dir) * dot(co, dir) - dot(co, co) * cosa2;\n\n    float t1 = 0.;\n    float t2 = 0.;\n    \n    float discr = b * b - 4. * a * c;\n    if (discr < 0.)\n        return isec; // no hit\n    else if (discr == 0.)\n        t1 = t2 = -0.5 * b / a;\n    else {\n        float q = (b > 0.) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t1      = q / a;\n        t2      = c / q;\n    }\n\n    vec3 q1 = ray.o + t1 * ray.d;\n    vec3 q2 = ray.o + t2 * ray.d;\n    \n    bool new_hit = false;\n\n    if (t1 >= ray.tmin && t1 <= isec.dist && dot(dir, q1 - p0) > 0. &&\n        dot(dir, q1 - p1) < 0.) {\n      isec.dist = t1;\n      isec.pos  = q1;\n      new_hit   = true;\n    }\n\n    if (t2 >= ray.tmin && t2 <= isec.dist && dot(dir, q2 - p0) > 0. &&\n        dot(dir, q2 - p1) < 0.) {\n      isec.dist = t2;\n      isec.pos  = q2;\n      new_hit   = true;\n    }\n\n    if (!new_hit) return isec;\n\n    isec.hit = true;\n    vec3 ppc  = isec.pos - pc;\n    isec.norm = normalize(ppc * dot(dir, ppc) / dot(ppc, ppc) - dir);\n\n    return isec;\n}\n\nintersection intersectCap(ray3 ray, vec3 pl, vec3 pc, float r, vec3 dir, intersection isec) {\n    float a = dot(ray.d, ray.d);\n    float b = 2. * dot(ray.d, ray.o - pc);\n    float c = dot(ray.o - pc, ray.o - pc) - r * r;\n    \n    float t1 = 0.;\n    float t2 = 0.;\n    \n    float discr = b * b - 4. * a * c;\n    if (discr < 0.)\n        return isec; // no hit\n    else if (discr == 0.)\n        t1 = t2 = -0.5 * b / a;\n    else {\n        float q = (b > 0.) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t1      = q / a;\n        t2      = c / q;\n    }\n    \n    vec3 p1 = ray.o + t1 * ray.d;\n    vec3 p2 = ray.o + t2 * ray.d;\n    \n    bool new_hit = false;\n    \n    if (t1 >= ray.tmin && t1 <= isec.dist && dot(p1 - pl, dir) < 0.) {\n      isec.dist = t1;\n      isec.pos  = p1;\n      new_hit   = true;\n    }\n\n    if (t2 >= ray.tmin && t2 <= isec.dist && dot(p2 - pl, dir) < 0.) {\n      isec.dist = t2;\n      isec.pos  = p2;\n      new_hit   = true;\n    }\n\n    if (!new_hit) return isec;\n\n    isec.hit = true;\n    isec.norm = normalize(isec.pos - pc);\n\n    return isec;\n}\n\nintersection intersectArrow(ray3 ray, vec3 p0, vec3 p1, float r, vec3 dir, vec3 pn0, vec3 pn1, intersection isec) {\n    float ab    = distance(p1, p0);\n    float tga   = r / ab;\n    float cosa2 = 1. / (1. + tga * tga);\n\n    vec3 co = ray.o - p0;\n\n    float a = dot(ray.d, dir) * dot(ray.d, dir) - cosa2;\n    float b = 2. * (dot(ray.d, dir) * dot(co, dir) - dot(ray.d, co) * cosa2);\n    float c = dot(co, dir) * dot(co, dir) - dot(co, co) * cosa2;\n\n    float t1 = 0.;\n    float t2 = 0.;\n\n    float discr = b * b - 4. * a * c;\n    if (discr < 0.)\n        return isec; // no hit\n    else if (discr == 0.)\n        t1 = t2 = -0.5 * b / a;\n    else {\n        float q = (b > 0.) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t1      = q / a;\n        t2      = c / q;\n    }\n\n    vec3 q1 = ray.o + t1 * ray.d;\n    vec3 q2 = ray.o + t2 * ray.d;\n    \n    bool new_hit = false;\n\n    if (t1 >= ray.tmin && t1 <= isec.dist && dot(dir, q1 - p0) > 0. &&\n        (dot(pn0, q1 - p1) < 0. || dot(pn1, q1 - p1) < 0.)) {\n        isec.dist = t1;\n        isec.pos  = q1;\n        new_hit   = true;\n    }\n\n    if (t2 >= ray.tmin && t2 <= isec.dist && dot(dir, q2 - p0) > 0. &&\n        (dot(pn0, q2 - p1) < 0. || dot(pn1, q2 - p1) < 0.)) {\n        isec.dist = t2;\n        isec.pos  = q2;\n        new_hit   = true;\n    }\n\n    if (!new_hit) return isec;\n\n    isec.hit  = true;\n    vec3 cp   = isec.pos - p0;\n    isec.norm = normalize(cp * dot(dir, cp) / dot(cp, cp) - dir);\n\n    return isec;\n}\n\nintersection interstectLine(ray3 ray, vec3 p0, vec3 p1, float r0, float r1, int e0, int e1, vec3 pn0, vec3 pn1, \n    vec3 p45an0, vec3 p45an1, vec3 p45bn0, vec3 p45bn1, vec3 ap0, vec3 ap1, float ar0, float ar1) {\n    intersection isec = intersection(-1, false, zero2, ray.tmax, zero3, zero3);\n\n    if (p0 == p1) return isec;\n\n    vec3 pa     = p0;\n    float ra    = r0;\n    int ea      = e0;\n    vec3 pb     = p1;\n    float rb    = r1;\n    int eb      = e1;\n    vec3 pna    = pn0;\n    vec3 pnb    = pn1;\n    vec3 p45ana = p45an0;\n    vec3 p45anb = p45an1;\n    vec3 p45bna = p45bn0;\n    vec3 p45bnb = p45bn1;\n    float raa   = ar0;\n    float rba   = ar1;\n    vec3 paa    = ap0;\n    vec3 pba    = ap1;\n\n    if (r1 < r0) {\n        pa     = p1;\n        ra     = r1;\n        ea     = e1;\n        pb     = p0;\n        rb     = r0;\n        eb     = e0;\n        pna    = pn1;\n        pnb    = pn0;\n        p45ana = p45an1;\n        p45anb = p45an0;\n        p45bna = p45bn1;\n        p45bnb = p45bn0;\n        raa    = ar1;\n        rba    = ar0;\n        paa    = ap1;\n        pba    = ap0;\n    }\n\n    vec3  dir = normalize(pb - pa);      // The direction of the line\n    float l   = distance(pb, pa);        // Distance between the two ends\n    float oa  = ra * l / (rb - ra);      // Distance of the apex of the cone\n                                         // along the cone's axis, from pa\n    float ob = oa + l;                   // Distance of the apex of the cone\n                                         // along the cone's axis, from pb\n    float tga   = (rb - ra) / l;         // Tangent of Cone's angle\n    float cosa2 = 1. / (1. + tga * tga); // Consine^2 of Cone's angle\n\n    if (cosa2 > 0.999999) {\n        ra = (r0 + r1) / 2.;\n        rb = ra;\n    }\n\n    float rac = ra;\n    float rbc = rb;\n    vec3  pac = pa;\n    vec3  pbc = pb;\n\n    if (ra == rb) {\n        isec = intersectCylinder(ray, pa, pb, ra, dir, isec);\n    } else {\n        float cosa = sqrt(ob * ob - rb * rb) / ob;\n\n        // Computing ends' parameters\n        rac = ra / cosa;\n        pac = pa + dir * (tga * rac);\n\n        rbc = rb / cosa;\n        pbc = pb + dir * (tga * rbc);\n\n        isec = intersectCone(ray, pa, pb, ra, rb, dir, isec);\n    }\n\n    \n    if (ea != CAP && dot(isec.pos - paa, pna) < 0.) {\n        isec.hit  = false;\n        isec.dist = ray.tmax;\n    }\n    if (eb != CAP && dot(isec.pos - pba, pnb) < 0.) {\n        isec.hit  = false;\n        isec.dist = ray.tmax;\n    }\n\n    if (ea == CAP) {\n        isec = intersectCap(ray, pa, pac, rac, dir, isec);\n    } else if (ea == TRIANGLE_ARROW) {\n        isec = intersectArrow(ray, pa, paa, raa, dir, pna, pna, isec);\n    } else {  // stealth_arrow\n        isec = intersectArrow(ray, pa, paa, raa, dir, p45ana, p45bna, isec);\n    }\n\n    if (eb == CAP) {\n        isec = intersectCap(ray, pb, pbc, rbc, -dir, isec);\n    } else if (eb == TRIANGLE_ARROW) {\n        isec = intersectArrow(ray, pb, pba, rba, -dir, pnb, pnb, isec);\n    } else {  // stealth_arrow\n        isec = intersectArrow(ray, pb, pba, rba, -dir, p45anb, p45bnb, isec);\n    }\n\n    if (isec.hit) {\n        float d  = dot(isec.pos - p0, normalize(p1 - p0));\n        vec3 pt  = p0 + d * normalize(p1 - p0);\n        float u  = clamp(sign(d) * distance(pt, p0) / l, 0.0f, 1.0f);\n        isec.uv  = vec2(u, 0);\n    }\n\n    return isec;\n}\n\nintersection intersect_lines(dgram_line[NUM_LINES] lines, ray3 ray) {\n    intersection isec = intersection(-1, false, zero2, 0., zero3, zero3);\n    \n    for (int i = 0; i < NUM_LINES; i++) {\n        intersection new_isec = interstectLine(ray, \n            lines[i].p0, lines[i].p1, \n            lines[i].view_dep_params.r0, lines[i].view_dep_params.r1,\n            lines[i].e0, lines[i].e1,\n            lines[i].view_dep_params.pn0, lines[i].view_dep_params.pn1,\n            lines[i].view_dep_params.p45an0, lines[i].view_dep_params.p45an1,\n            lines[i].view_dep_params.p45bn0, lines[i].view_dep_params.p45bn1,\n            lines[i].view_dep_params.ap0, lines[i].view_dep_params.ap1,\n            lines[i].view_dep_params.ar0, lines[i].view_dep_params.ar1\n        );\n        if (new_isec.hit) {\n            ray.tmax = new_isec.dist;\n            isec = new_isec;\n            isec.id = i;\n        }\n    }\n    \n    return isec;\n}\n\nvec4 trace_color(dgram_line[NUM_LINES] lines, ray3 ray) {\n    intersection isec = intersect_lines(lines, ray);\n    \n    vec4 radiance = zero4;\n    \n    for (int i = 0; i < MAX_RECURSION; i++) {\n        if (isec.hit) {\n            vec4 color = lines[isec.id].stroke;\n            radiance = composite(radiance, color);\n            \n            if (color.a < 1.)\n                isec = intersect_lines(lines, ray3(isec.pos, ray.d, ray_eps, flt_max));\n            else break;\n        } else break;\n    }\n    \n    return radiance;\n}\n\nvec4 trace_normal(dgram_line[NUM_LINES] lines, ray3 ray) {\n    intersection isec = intersect_lines(lines, ray);\n\n    if (isec.hit) \n        return vec4(isec.norm, 1.);\n    return zero4;\n}\n\nvec4 trace_uv(dgram_line[NUM_LINES] lines, ray3 ray) {\n    intersection isec = intersect_lines(lines, ray);\n\n    if (isec.hit) \n        return vec4(isec.uv.x, isec.uv.y, 0., 1.);\n    return zero4;\n}\n\nvec4 trace_eyelight(dgram_line[NUM_LINES] lines, ray3 ray) {    \n    intersection isec = intersect_lines(lines, ray);\n    \n    vec4 radiance = zero4;\n    \n    for (int i = 0; i < MAX_RECURSION; i++) {\n        if (isec.hit) {\n            vec4 stroke = lines[isec.id].stroke;\n            vec4 color  = vec4(stroke.xyz * abs(dot(isec.norm, ray.d)), stroke.w);\n            radiance = composite(radiance, color);\n            \n            if (color.a < 1.)\n                isec = intersect_lines(lines, ray3(isec.pos, ray.d, ray_eps, flt_max));\n            else break;\n        } else break;\n    }\n    \n    return radiance;\n}\n\nvec4 sampler(int trace_sampler, dgram_line[NUM_LINES] lines, ray3 ray) {\n    switch (trace_sampler) {\n    case COLOR_SAMPLER:\n        return trace_color(lines, ray);\n    case NORMAL_SAMPLER:\n        return trace_normal(lines, ray);\n    case UV_SAMPLER:\n        return trace_uv(lines, ray);\n    case EYELIGHT_SAMPLER:\n        return trace_eyelight(lines, ray);\n    }\n}\n\ndgram_line[NUM_LINES] computeViewDepParams(dgram_line[NUM_LINES] lines, dgram_camera cam, vec2 res) {\n    frame3 frame = lookat_frame(cam.from, cam.to, vec3(0., 1., 0.), false);\n    \n    float aspect = res.x / res.y;\n    vec2  film   = aspect >= 1. ? vec2(cam.film, cam.film / aspect)\n                                : vec2(cam.film * aspect, cam.film);\n                                \n    float camera_distance = length(cam.from - cam.to);\n    frame3 camera_frame   = lookat_frame(cam.from, cam.to, vec3(0., 1., 0.), false);\n    \n    \n    float plane_distance = -cam.lens * scale / size;\n    \n    for (int i = 0; i < NUM_LINES; i++) {\n        float radius = cam.orthographic ? lines[i].thickness * film.x * camera_distance * 3. /\n                                     (2. * cam.lens * scale)\n                               : lines[i].thickness * film.x  * 3. / (2. * size);\n                               \n        vec3 camera_p0 = transform_point(inverse_frame(frame, false), lines[i].p0);\n        vec3 camera_p1 = transform_point(inverse_frame(frame, false), lines[i].p1);\n                               \n        if(cam.orthographic) {\n            // computing the line radii\n            lines[i].view_dep_params.r0 = radius;\n            lines[i].view_dep_params.r1 = radius;\n            \n            // computing the line scree-space length\n            vec3 screen_camera_p0 = vec3(camera_p0.x, camera_p0.y, plane_distance);\n            vec3 screen_camera_p1 = vec3(camera_p1.x, camera_p1.y, plane_distance);\n\n            vec3 screen_p0 = transform_point(camera_frame, screen_camera_p0);\n            vec3 screen_p1 = transform_point(camera_frame, screen_camera_p1);\n\n            float screen_length = distance(screen_p0, screen_p1);\n\n            // computing the arrow-heads base centers\n            vec3 camera_arrow_center0 = line_point(\n                camera_p0, camera_p1, 8. * radius / screen_length);\n            vec3 camera_arrow_center1 = line_point(\n                camera_p1, camera_p0, 8. * radius / screen_length);\n\n            vec3 arrow_center0 = transform_point(\n                camera_frame, camera_arrow_center0);\n            vec3 arrow_center1 = transform_point(\n                camera_frame, camera_arrow_center1);\n\n            lines[i].view_dep_params.ap0 = arrow_center0;\n            lines[i].view_dep_params.ap1 = arrow_center1;\n\n            // computing the arrow-heads base radii\n            float arrow_radius0 = radius * 8. / 3.;\n            float arrow_radius1 = radius * 8. / 3.;\n\n            lines[i].view_dep_params.ar0 = arrow_radius0;\n            lines[i].view_dep_params.ar1 = arrow_radius1;\n\n            // computing the truncation planes normals\n            vec3 screen_camera_dir = normalize(screen_camera_p1 - screen_camera_p0);\n            vec3 screen_dir        = normalize(screen_p1 - screen_p0);\n            vec3 screen_dir_45a    = transform_direction(\n                   camera_frame, vec3(screen_camera_dir.x + screen_camera_dir.y,\n                                  screen_camera_dir.y - screen_camera_dir.x, 0));\n            vec3 screen_dir_45b = transform_direction(\n                camera_frame, vec3(screen_camera_dir.x - screen_camera_dir.y,\n                                  screen_camera_dir.y + screen_camera_dir.x, 0));\n            \n            lines[i].view_dep_params.pn0    = screen_dir;\n            lines[i].view_dep_params.p45an0 = screen_dir_45a;\n            lines[i].view_dep_params.p45bn0 = screen_dir_45b;\n            lines[i].view_dep_params.pn1    = -screen_dir;\n            lines[i].view_dep_params.p45an1 = -screen_dir_45a;\n            lines[i].view_dep_params.p45bn1 = -screen_dir_45b;\n        } else { \n            // computing the line radii\n            lines[i].view_dep_params.r0 = radius * abs(camera_p0.z / plane_distance);\n            lines[i].view_dep_params.r1 = radius * abs(camera_p1.z / plane_distance);\n            \n            // computing the line scree-space length\n            vec3 screen_camera_p0 = screen_space_point(camera_p0, plane_distance);\n            vec3 screen_camera_p1 = screen_space_point(camera_p1, plane_distance);\n\n            vec3 screen_p0 = transform_point(camera_frame, screen_camera_p0);\n            vec3 screen_p1 = transform_point(camera_frame, screen_camera_p1);\n\n            float screen_length = distance(screen_p0, screen_p1);\n\n            // computing the arrow-heads base centers\n            vec3 camera_arrow_center0 = perspective_line_point(\n                camera_p0, camera_p1, 8. * radius / screen_length);\n            vec3 camera_arrow_center1 = perspective_line_point(\n                camera_p1, camera_p0, 8. * radius / screen_length);\n\n            vec3 arrow_center0 = transform_point(\n                camera_frame, camera_arrow_center0);\n            vec3 arrow_center1 = transform_point(\n                camera_frame, camera_arrow_center1);\n\n            lines[i].view_dep_params.ap0 = arrow_center0;\n            lines[i].view_dep_params.ap1 = arrow_center1;\n\n            // computing the arrow-heads base radii\n            float arrow_radius0 = radius * 8. / 3. *\n                                 abs(camera_arrow_center0.z / plane_distance);\n            float arrow_radius1 = radius * 8. / 3. *\n                                 abs(camera_arrow_center1.z / plane_distance);\n\n            lines[i].view_dep_params.ar0 = arrow_radius0;\n            lines[i].view_dep_params.ar1 = arrow_radius1;\n\n            // computing the truncation planes normals\n            vec3 screen_camera_dir = normalize(screen_camera_p1 - screen_camera_p0);\n            vec3 screen_dir        = normalize(screen_p1 - screen_p0);\n            vec3 screen_dir_45a    = transform_direction(\n                   camera_frame, vec3(screen_camera_dir.x + screen_camera_dir.y,\n                                  screen_camera_dir.y - screen_camera_dir.x, 0));\n            vec3 screen_dir_45b = transform_direction(\n                camera_frame, vec3(screen_camera_dir.x - screen_camera_dir.y,\n                                  screen_camera_dir.y + screen_camera_dir.x, 0));\n\n            vec3 ray0 = transform_direction(camera_frame, camera_arrow_center0);\n            vec3 ray1 = transform_direction(camera_frame, camera_arrow_center1);\n\n            lines[i].view_dep_params.pn0    = orthonormalize(screen_dir, ray0);\n            lines[i].view_dep_params.p45an0 = orthonormalize(screen_dir_45a, ray0);\n            lines[i].view_dep_params.p45bn0 = orthonormalize(screen_dir_45b, ray0);\n            lines[i].view_dep_params.pn1    = orthonormalize(-screen_dir, ray1);\n            lines[i].view_dep_params.p45an1 = orthonormalize(-screen_dir_45a, ray1);\n            lines[i].view_dep_params.p45bn1 = orthonormalize(-screen_dir_45b, ray1);\n        }\n    }\n    \n    return lines;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    dgram_camera cam           = getCamera(); \n    int          trace_sampler = getSampler();\n        \n    vec2 uv = vec2(fragCoord.x/iResolution.x, 1.-fragCoord.y/iResolution.y);\n        \n    ray3 ray = evalCamera(cam, uv, iResolution.xy);\n    \n    lines = computeViewDepParams(lines, cam, iResolution.xy);\n        \n    vec4 color = sampler(trace_sampler, lines, ray);\n\n    fragColor = composite(color, vec4(1.));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float ray_eps = 1e-4f;\nconst float flt_max = intBitsToFloat(2139095039);\nconst vec2  zero2   = vec2(0., 0.);\nconst vec3  zero3   = vec3(0., 0., 0.);\nconst vec4  zero4   = vec4(0., 0., 0., 0.);\nconst float pi      = 3.14159265358979323846;\n\nconst int KEY_SHIFT   = 16;\nconst int KEY_CONTROL = 17;\nconst int KEY_ALT     = 18;\nconst int KEY_LEFT    = 37;\nconst int KEY_UP      = 38;\nconst int KEY_RIGHT   = 39;\nconst int KEY_DOWN    = 40;\n\nconst int COLOR_SAMPLER    = 0;\nconst int NORMAL_SAMPLER   = 1;\nconst int UV_SAMPLER       = 2;\nconst int EYELIGHT_SAMPLER = 3;\n\nstruct frame3 {\n    vec3 x;\n    vec3 y;\n    vec3 z;\n    vec3 o;\n};\n\nstruct dgram_camera {\n    bool  orthographic;\n    vec3  from;\n    vec3  to;\n    float lens;\n    float film;\n};\n\nframe3 identity3x4 = frame3(vec3(1., 0., 0.), vec3(0., 1., 0.), vec3(0., 0., 1.), vec3(0., 0., 0.));\n\nmat3 rotation(frame3 a) { return mat3(a.x, a.y, a.z); }\nvec3 translation(frame3 a) { return a.o; }\n\nframe3 make_frame(mat3 m, vec3 t) {\n  return frame3(m[0], m[1], m[2], t);\n}\n\nframe3 lookat_frame(vec3 eye, vec3 center, vec3 up, bool inv_xz) {\n    vec3 w = normalize(eye - center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = normalize(cross(w, u));\n    if (inv_xz) {\n        w = -w;\n        u = -u;\n    }\n    return frame3(u, v, w, eye);\n}\n\nvec3 transform_point(frame3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z + a.o;\n}\n\nvec3 transform_vector(frame3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 transform_direction(frame3 a, vec3 b) {\n    return normalize(transform_vector(a, b));\n}\n\nframe3 inverse_frame(frame3 a, bool non_rigid) {\n    if (non_rigid) {\n        mat3 minv = inverse(rotation(a));\n        return make_frame(minv, -(minv * a.o));\n    } else {\n        mat3 minv = transpose(rotation(a));\n        return make_frame(minv, -(minv * a.o));\n    }\n}\n\nmat2x3 camera_turntable(vec3 from, vec3 to, vec3 up, vec2 rotate, float dolly, vec2 pan) {\n    if (rotate != zero2) {\n        vec3  z     = normalize(to - from);\n        float lz    = length(to - from);\n        float phi   = atan(z.z, z.x) + rotate.x;\n        float theta = acos(z.y) + rotate.y;\n        theta       = clamp(theta, 0.001f, pi - 0.001f);\n        vec3  nz    = vec3(sin(theta) * cos(phi) * lz, cos(theta) * lz, sin(theta) * sin(phi) * lz);\n        from        = to - nz;\n    }\n\n    if (dolly != 0.) {\n        vec3  z  = normalize(to - from);\n        float lz = max(0.001, length(to - from) * (1. + dolly));\n        z *= lz;\n        from = to - z;\n    }\n\n    if (pan != zero2) {\n        vec3 z = normalize(to - from);\n        vec3 x = normalize(cross(up, z));\n        vec3 y = normalize(cross(z, x));\n        vec3 t = vec3(pan.x * x.x + pan.y * y.x, pan.x * x.y + pan.y * y.y, pan.x * x.z + pan.y * y.z);\n        from += t;\n        to += t;\n    }\n\n    return mat2x3(from, to);\n}\n\nvec4 composite(vec4 a, vec4 b) {\n    if (a.w == 0. && b.w == 0.) return zero4;\n    vec3 cc = a.xyz * a.w + b.xyz * b.w * (1. - a.w);\n    float ca = a.w + b.w * (1. - a.w);\n    return vec4(cc.x / ca, cc.y / ca, cc.z / ca, ca);\n}\n\nvec3 line_point(vec3 p0, vec3 p1, float u) {\n    return p0 * (1. - u) + p1 * u;\n}\n\nvec3 screen_space_point(vec3 p, float d) {\n    return vec3(p.x / p.z * d, p.y / p.z * d, d);\n}\n\nvec3 perspective_line_point(vec3 p0, vec3 p1, float u) {\n    float z = 1. / (1. / p0.z + u * (1. / p1.z - 1. / p0.z));\n    float x = z * (p0.x / p0.z + u * (p1.x / p1.z - p0.x / p0.z));\n    float y = z * (p0.y / p0.z + u * (p1.y / p1.z - p0.y / p0.z));\n    return vec3(x, y, z);\n}\n\nvec3 orthonormalize(vec3 a, vec3 b) {\n    return normalize(a - b * dot(a, b));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool keypress(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1),0).x > 0.;\n}\n\nint getSampler() {\n    return int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n}\n\n\nint handleKeyboard(int sampler) {\n    if (keypress(KEY_RIGHT)) {\n        if(++sampler > EYELIGHT_SAMPLER)\n            sampler = COLOR_SAMPLER;\n    }\n    \n    if (keypress(KEY_LEFT)) {\n        if(--sampler < COLOR_SAMPLER)\n            sampler = EYELIGHT_SAMPLER;\n    }\n    \n    return sampler;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int sampler = getSampler();\n    \n    sampler = handleKeyboard(sampler);\n    \n    fragColor = vec4(sampler, 0., 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool keystate(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.;\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.;\n}\n\nbool keytoggle(int key) {\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.;\n}\n\nvec4 getPrevMouse() {\n    return texelFetch(iChannel2, ivec2(0, 0), 0);\n}\n\n\ndgram_camera getCamera() {\n    dgram_camera cam = dgram_camera(false, vec3(0., 0., 5.), vec3(0., 0., 0.), 0.3f, 0.036f); \n    \n    bool changed = bool(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    \n    if (changed) {    \n        cam.orthographic = bool(texelFetch(iChannel0, ivec2(0, 1), 0).x);\n        cam.from         = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;\n        cam.to           = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n        cam.lens         = texelFetch(iChannel0, ivec2(0, 4), 0).x;\n        cam.film         = texelFetch(iChannel0, ivec2(0, 5), 0).x;\n    }\n\n    return cam;\n}\n\nvec4 setCamera(dgram_camera cam, vec2 coord) {\n    switch(int(coord.y)) {\n    case 0:\n        return vec4(1., 0., 0., 0.);\n    case 1:\n        return vec4(int(cam.orthographic), 0., 0., 0.);\n    case 2:\n        return vec4(cam.from, 0.);\n    case 3:\n        return vec4(cam.to, 0.);\n    case 4:\n        return vec4(cam.lens, 0., 0., 0.);\n    case 5:\n        return vec4(cam.film, 0., 0., 0.);\n    }\n}\n\n\ndgram_camera updateCamera(dgram_camera cam) {\n    if (keypress(KEY_UP)) {\n        cam.orthographic = true;\n    }\n    \n    if (keypress(KEY_DOWN)) {\n        cam.orthographic = false;\n    }\n    \n    vec4 pMouse = getPrevMouse();\n    \n    if (iMouse.z > 0. && pMouse.z > 0.) {\n        float dolly  = 0.;\n        vec2  pan    = zero2;\n        vec2  rotate = zero2;\n        \n        if (keystate(KEY_SHIFT)) {\n            pan = (iMouse.xy - pMouse.xy) * distance(cam.from, cam.to) / 200.0f;\n        } else if (keystate(KEY_ALT)) {\n            dolly = (iMouse.y - pMouse.y) / 100.0f;\n        } else {\n            rotate = (iMouse.xy - pMouse.xy) / 100.0f;\n        }\n        \n        mat2x3 from_to = camera_turntable(cam.from, cam.to, vec3(0., 1., 0), rotate, dolly, pan);\n        \n        cam.from = from_to[0];\n        cam.to   = from_to[1];\n    }\n    \n    return cam;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    dgram_camera cam = getCamera();\n    \n    cam = updateCamera(cam);\n        \n    fragColor = setCamera(cam, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    fragColor = iMouse;\n}","name":"Buffer C","description":"","type":"buffer"}]}