{"ver":"0.1","info":{"id":"M3lBWf","date":"1729023395","viewed":24,"name":"SHADER1_anton_edo","username":"anton_shuleiko","description":"shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS   300\n#define MAX_DIST    50.0\n#define EPS         0.001\n#define PI          3.14159265359\n\nstruct obj {\n    float d;\n    int id;\n};\n\nfloat sphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nobj smoothUnion(obj a, obj b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.d - a.d) / k, 0.0, 1.0);\n    return obj(mix(b.d, a.d, h) - k * h * (1.0 - h), a.id);\n}\n\nobj sdf(vec3 p) {\n    // Плавающие сферы\n    float time = iTime;\n    obj sph1 = obj(sphere(p, vec3(0.0, 1.5 * sin(time), 0.0), 1.0), 0);\n    obj sph2 = obj(sphere(p, vec3(3.0 * sin(time), 1.5 * cos(time), 0.0), 1.0), 1);\n    \n    // Тор вращается вокруг оси\n    obj tor = obj(torus(p, vec2(2.0, 0.5)), 2);\n    \n    return smoothUnion(smoothUnion(sph1, sph2, 0.5), tor, 0.5);\n}\n\nvec3 trace(vec3 ro, vec3 rd, out int id) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_ITERS; i++) {\n        vec3 pos = ro + t * rd;\n        obj dObj = sdf(pos);\n        if (dObj.d < EPS) {\n            id = dObj.id;\n            return pos;\n        }\n        t += dObj.d;\n        if (t > MAX_DIST) break;\n    }\n    id = -1;\n    return vec3(0);\n}\n\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sdf(p + vec3(eps, 0, 0)).d - sdf(p - vec3(eps, 0, 0)).d,\n        sdf(p + vec3(0, eps, 0)).d - sdf(p - vec3(0, eps, 0)).d,\n        sdf(p + vec3(0, 0, eps)).d - sdf(p - vec3(0, 0, eps)).d\n    ));\n}\n\n// Функция для получения цветового градиента\nvec3 getColor(int id, vec3 normal, vec3 lightDir) {\n    float diff = max(dot(normal, lightDir), 0.0);\n    \n    vec3 color;\n    if (id == 0) {\n        color = vec3(1.0, 0.5, 0.3);\n    } else if (id == 1) {\n        color = vec3(0.3, 0.5, 1.0);\n    } else {\n        color = vec3(0.8, 0.8, 0.8);\n    }\n    \n    // Создание эффекта переливания\n    float wave = sin(iTime + float(id) * 3.0) * 0.5 + 0.5; // волновой эффект\n    color = mix(color, vec3(1.0, 0.0, 0.5) * wave, 0.5); // смешивание с другим цветом\n    \n    return color * diff;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Камера\n    vec3 ro = vec3(3.0, 2.0, 5.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    \n    vec3 rd = normalize(uv.x * r + uv.y * u + 1.5 * f);\n    \n    int id;\n    vec3 p = trace(ro, rd, id);\n    \n    if (id != -1) {\n        vec3 normal = getNormal(p);\n        vec3 lightPos = vec3(2.0, 5.0, 3.0);\n        vec3 lightDir = normalize(lightPos - p);\n        \n        vec3 color = getColor(id, normal, lightDir);\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}