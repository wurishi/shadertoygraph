{"ver":"0.1","info":{"id":"fdSGWz","date":"1617199976","viewed":105,"name":"SimpleRT","username":"jackisgames","description":"raytrace","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//posisi adalah posisi ray\n//arah adalah arah depan ray, harus di normalisasi\n//'bola' adalah vec4 (4 angka) di definisi kan dengan posisi xyz dan radius z.\n//Bisa juga pakai vec3 tuk posisi dan float tuk radius\n//Adaptasi dari Realtime Collision Detection - Christer Ericson\nfloat InterseksiBola(vec3 posisi, vec3 arah, vec4 bola)\n{\n    vec3 m = posisi - bola.xyz;\n    float b = dot( arah , m );\n    float c = dot( m, m ) - ( bola.w * bola.w );\n    \n    float discr = b * b - c;\n    \n    float t = -b - sqrt( abs( discr ) );\n    \n    return mix( 999.0, t, step( 0.0, min( t, discr ) ) );\n}\n\n//ini cuman sky box, ganti aja ama implementasi kamu\nvec3 LatarBelakang( vec3 arah )\n{ \n    float facingSky = dot( arah, vec3( 0, 1, 0 ) );\n    \n    float angle = (iTime * .5 + atan( arah.z, arah.x)) * 7.0;\n    float wave = sin( angle );\n    float weight = .03;\n    \n    vec3 lightDirection = normalize( vec3( -1, -1, 0 ) );\n    vec3 bgNormal = -arah;\n    bgNormal.y += wave;\n    bgNormal = normalize( bgNormal );\n    \n    float lightInfluence = mix( .50, 1.0, dot( lightDirection, bgNormal ) );\n    \n    float horizon = step(0.0, arah.y - wave * weight );\n    \n    vec3 color = mix( vec3(1), vec3( 1, 0, 0), horizon );\n\n    return mix( vec3(mix(.40, 1.0, -facingSky * lightInfluence)), vec3( mix(.40, 1.0, facingSky * lightInfluence ), 0, 0), horizon );\n}\n\n//konversi frag coord ke ray\n//jadi kita tembak ray dari setiap pixels di layar\nvoid KalkulasiRay( in vec2 fragCoord, out vec3 posisi, out vec3 arah )\n{\n    posisi = vec3( 0, 1, 0);\n    float n = 1.0/max(iResolution.x, iResolution.y);\n    arah = normalize(vec3((fragCoord - iResolution.xy*0.5)*n, 0.5));\n}\n\n// https://iquilezles.org/articles/smin\nvoid sminCubic( float a, float b, vec3 va, vec3 vb, float k, out float blend, out vec3 blendV3 )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    blend = min( b, a ) - h*h*h*k*(1.0/6.0);\n    blendV3 = mix( vb, va, h );\n}\n\nvec3 Raytrace(in vec2 fragCoord )\n{\n    //ray for this pixel\n    vec3 posisiRay;\n    vec3 arahRay;\n    KalkulasiRay( fragCoord, posisiRay, arahRay );\n    \n    //bola di tengah layar\n    vec4 bola = vec4( 0, 0, 11, 3);\n    \n    //jarak dari ray ke permukaan, atau kalau miss\n    float t = InterseksiBola( posisiRay, arahRay, bola );\n    \n    //surface normal dari bola\n    vec3 normal = normalize(bola.xyz - (posisiRay + arahRay * t));\n    \n    //bola kecil, disini bolanya nya di combine kalau dekat satu sama lain\n    for( int i = 0; i < 5; i++)\n    {\n        float angle = float(i) * (3.14 * .20) * 2.0 + iTime;\n        float jarak = 1.0 + abs( sin( iTime ) * 3.0 );\n        \n        vec4 bolaKecil = vec4( bola.x + cos(angle) * jarak, bola.y , bola.z + sin(angle) * jarak, .5 + abs( sin(iTime * .1) ) );\n\n        float tk = InterseksiBola( posisiRay, arahRay, bolaKecil );\n        \n        float blend = step(t, tk );\n        \n        vec3 tnormal = normalize(bolaKecil.xyz - (posisiRay + arahRay * tk));\n        \n        //smoothing blend\n        sminCubic( t , tk, normal, tnormal, 1.1, tk, tnormal );\n        \n        normal = mix(tnormal, normal, blend );\n        \n        t = tk;\n        \n    }\n    \n    //kalau t > 0 ( ray kena permukaan bola )\n    //sample pixel dengan latar belakang dengan arah ray yang di pantul kan dengan surface normal dari bola\n    //else sample pixel dengan arah ray yang ga di pantul kan\n    return mix( LatarBelakang(reflect( arahRay, normal )),\n                LatarBelakang( arahRay ), \n                step(100.0, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor = vec4( Raytrace( fragCoord ), 0 );\n}","name":"Image","description":"","type":"image"}]}