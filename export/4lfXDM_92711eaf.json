{"ver":"0.1","info":{"id":"4lfXDM","date":"1436973899","viewed":1602,"name":"Hatching","username":"nmz","description":"Cheap Procedural hatching for arbitrary geometry.\nUsing a mix of triplanar and cube projection for texturing.","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","texturing","technique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Hatching by nmz (twitter: @stormoid)\n\n/*\n\tnimitz here, I'll post what I feel to be \"less interesting\"\n\tshaders\ton this account from now on.\n\n\tShowing here procedural hatching using a combination\n\tof triplanar and cube projection\n\n\tThe \"shadows\" you see are only done using a denser hatching param.\n\n\tAlso featuring simple sepia tone conversion.\n*/\n\n#define ITR 80\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat torus(in vec3 p, in vec2 t){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat map(vec3 p)\n{\n    float d = torus(p,vec2(.9,0.33));\n    d = min(d, -length(p)+5.);   \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nfloat texh(in vec2 p, in float str)\n{\n    p*= .7;\n    float rz= 1.;\n    for (int i=0;i<10;i++)\n    {\n        float g = texture(iChannel0,vec2(0.025,.5)*p).x;\n        g = smoothstep(0.-str*0.1,2.3-str*0.1,g);\n        rz = min(1.-g,rz);\n        p.xy = p.yx;\n        p += .07;\n        p *= 1.2;\n        if (float(i) > str)break;\n    }\n    return rz*1.05;\n}\n\nvec3 cubeproj(in vec3 p, in float str)\n{\n    vec3 x = vec3(texh(p.zy/p.x,str));\n    vec3 y = vec3(texh(p.xz/p.y,str));\n    vec3 z = vec3(texh(p.xy/p.z,str));\n    \n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat texcube(in vec3 p, in vec3 n, in float str)\n{\n\tfloat x = texh(p.yz,str);\n\tfloat y = texh(p.zx,str);\n\tfloat z = texh(p.xy,str);\n    n *= n;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\tvec3 n = (e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\tn -= max(.0, dot (n, rd))*rd;\n    return normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<21; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 6.0*h/t );\n        t += clamp( h, 0.03, 0.2 );\n        if( abs(h)<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 sepia(in vec3 col)\n{\n    return vec3(dot(col, vec3(0.393,0.769,0.189)),\n                dot(col, vec3(0.349,0.686,0.168)),\n                dot(col, vec3(0.272,0.534,0.131)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,2.+sin(time*0.5)-.7,0.);\n    ro.x += sin(time*.5)*4.;\n    ro.z += cos(time*.5)*4.;\n    \n    vec3 tgt = vec3(0,0,.5+sin(time));\n    vec3 eye = normalize( tgt - ro);\n    vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n    vec3 up = normalize(cross(eye,rgt));\n    vec3 rd = normalize( p.x*rgt + p.y*up + 1.5*eye );\n\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0.);\n    vec3 ligt = vec3(1,2,3);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos,rd);\n        float nl  = max(dot(nor,normalize(ligt)),0.);\n        float sh = shadow(pos,normalize(ligt-pos),0.1,distance(pos,ligt));\n        nl *= sh*0.8+0.2;\n        nl = 1.0-nl;\n        nl = clamp(nl,0.,1.);\n        const float st = 10.;\n        vec3 col1 = vec3(texcube(pos,nor,nl*st));\n        vec3 col2 = cubeproj(pos,nl*st);\n        col = mix(col1,col2, .5);\n    }\n    \n    if (distance(ro,ligt) < rz)\n    {\n\t\tfloat lball = pow(max(dot(normalize(rd), normalize(ligt-ro)),0.), 4000.0);\n    \tcol += lball*vec3(1)*2.;\n    }\n    \n    col = sepia(col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5; //form iq\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}