{"ver":"0.1","info":{"id":"WlBczw","date":"1593920906","viewed":90,"name":"lissajous grid","username":"stokastic","description":"Draws an NxN grid of Lissajous curves","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["curves","yeet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// output dat accumulation buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv) * 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592654\n#define TWO_PI 2.0 * PI\n#define N 5\n#define LINE_WIDTH ( 5.*float(N) / iResolution.y )\n#define STEPS_PER_CYCLE 2500\n\n// output stops after this many cycles\n#define NUM_CYCLES 10\n\n// each curve will fill this percentage of its tile\n#define FILL_RATIO 0.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x = (uv.x * aspectRatio) - (aspectRatio - 1.0) / 2.0;\n    uv.y = 1.0 - uv.y;\n    \n    float t = float(iFrame) * (1.0 / float(STEPS_PER_CYCLE));\n    \n    // compute integer tile number per fragment\n \tvec2 tile = floor(uv * float(N) + 1.0);\n    \n    // position of point on lissajous curve, per tile\n    vec2 p = vec2(sin(TWO_PI * tile.x * t), cos(TWO_PI * tile.y * t)) * (1.0 - t * 0.15);\n    \n    // distance from current pixel to point p\n    float dist = length(p * FILL_RATIO - 1.0 - 2.0 * (uv * float(N) - tile));\n    float curve = smoothstep(LINE_WIDTH, 0.0, dist);\n\n    fragColor = curve * vec4(uv.y, uv.x, 1.0, 1.0);\n    //fragColor += step(mod(uv.y * float(N), 1.0), 20.0 * d.y) + step(mod(uv.x * float(N), 1.0), 20.0 * d.y); // gridlines\n    fragColor *= step(0.0, uv.x) * step(uv.x, 1.0); // clip to [0,1] box\n    fragColor *= step(float(iFrame), float(NUM_CYCLES * STEPS_PER_CYCLE)); // nullify output after NUM_CYCLES\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// simple accumulation buffer so history is shown\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = max(texture(iChannel0, uv), 0.9998 * texture(iChannel1, uv));\n}","name":"Buffer B","description":"","type":"buffer"}]}