{"ver":"0.1","info":{"id":"4flyWl","date":"1724251300","viewed":108,"name":"[phreax] twisted carbon","username":"phreax","description":"Twisted tunnel with metallic and glow materials.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cubes","glow","iridescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2024\n\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define sabsk(x, k) sqrt(x * x + k * k)\n#define sabs(x) (sabsk(x, .5))\n#define S(a, b, x) smoothstep(a, b, x) \n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\n\nfloat tt, g_mat = 0., fadeIn;\nvec3 ro;\nfloat intro;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n//  some 2d noise for dithering\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\n// Zucconi's spectral palette\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// from https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\n\nfloat pMod(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n#define PHI 1.618033988749895\n#define SQR2 1.4152135\n#define ISQR2 1./SQR2\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\n// smooth noise\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nfloat g_glow;\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat g_id = 0.;\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n\nvec3 transform(vec3 p) {\n    p.x += sin(p.z*.5)*.1;\n    p.xy *= rot(PI*SIN(p.z*2.2+sin(2.*tt)));\n    \n    p.x += sin(p.z*4.+4.*tt)*.1;\n    p.y += cos(p.z*4.+4.*tt)*.1;\n    return p;\n}\n\nfloat g_id2 = 0.;\n\nvec2 path(float z) {\n    vec2 p = vec2(0);\n    p.x += sin(z*.5 + 5.*tt)*.9*cos(z*.5);\n    p.y += cos(z*.9-5.*tt)*.4*sin(z*.3);\n    return p;\n}\n\nfloat sdTwisted(vec3 p, float N) {\n    vec3 bp = p;\n    p = transform(p);\n    \n    if(N < 6.) {p.z += 2.*tt;}\n    \n    g_id2 = pModPolar(p.xy, N);\n    \n    \n    p.x -= .5;\n\n    g_id = pMod(p.z, .14);\n    \n\n    float r = mix(.02, 0.08, SIN(bp.z*4.+4.*tt));\n    \n\n    p.yz = p.zy;\n    float d = cyl(p, .04, r);\n    \n   // g_glow += .04/(3.+pow(abs(d), 10.));\n   return d;\n}\n\n\nfloat map(vec3 p) {   \n\n    p.xy -= path(p.z);\n    //p.y += 1.;\n    vec3 bp = p;\n    float id, id2;\n    float inner = sdTwisted(p*2., 4.)/2.;\n    id = g_id;\n    id2 = g_id2;\n\n    p.xy = sabsk(p.xy, 0.02);\n\n    p.x += sin(p.z*.9+tt)*.2;\n    pModPolar(p.xy, 6.);\n            \n    p.xy = sabsk(p.xy, 0.02);\n    \n    float outer = sdTwisted(p*1., 6.)/1.;\n    float d = smin(inner, outer, .01);\n   // d = outer;\n   \n    \n    g_mat = inner < outer ? 1. : 0.;\n    if(inner < outer) {\n        g_id = id;\n        g_id2 = id2;\n    }\n    \n    if(inner < outer && mod(id, 5.) < 1.)  {\n        g_glow += .09/(5.+pow(abs(inner), 20.));\n        \n    } else if(inner >= outer && mod(id2, 5.) < 1.) {\n            g_glow += .01/(10.+pow(abs(outer), 20.));\n    }\n\n    return d*.5;\n\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\n// iq's shadow function\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n// why not put the raymarcher in a separate function (;\nvec3 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        t += d;\n        p += rd*d;\n        if(abs(d) < 0.001 || t > 90.) break;\n    }\n    \n    \n    return vec3(t, mat, d);\n}\n\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\n\nvoid cam(inout vec3 p) {\n\n   p.xz *= rot(PI);\n   //p.z -= mod(4.*tt -1.*sin(4.*tt), 1000.);\n   p.z -= mod(8.*tt, 1000.);\n   p.xy += path(p.z);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    tt = .5*.25*iTime;\n\n    vec3  lp = vec3(4., 3., -10),\n          lp2 = vec3(-4., -3., -10);\n\n\n    fadeIn = smoothstep(1., 7., iTime);   \n    //uv = uv.yx;\n    vec3 col = vec3(0);\n    float id = 0., id2 = 0., flash = 0.;\n    \n    ro = vec3(.0, 0.0, -8.);\n    vec3 lookat = vec3(0, 0, 0), p;\n    \n   \n      //  lookat = -tunnel(lookat);\n    cam(ro);\n    cam(lp2);\n    cam(lookat);\n   \n    \n    intro = smoothstep(0., 1., iTime);\n   \n   // ro.yz *= rot(.3*tt);\n    float focal = mix(1., 1., SIN(1.*tt));\n    vec3 rd = getRayDir(uv, ro, lookat, focal);\n\n           \n    \n    float mat = 0., matId = 0.,\n          t   = 0.,\n          d   = 0.;\n     \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.106,0.255,0.275);\n    vec3 c2 = vec3(0.165,0.051,0.286);\n    \n    // light color\n    vec3 lc1 = vec3(0.894,0.843,0.957);\n    vec3 lc2 = vec3(0.314,0.984,0.984);\n    \n    vec3 bg = vec3(0.090,0.078,0.102)*.0;\n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec3 rm = raymarch(ro, rd, steps);\n        id = g_id;\n        id2 = g_id2;\n        float glow = g_glow;\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n      \n        vec3 p2 = p;\n        \n        //p = g_p;\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    \n\n        vec3 texCol = vec3(0);\n \n        flash = float(mod(id-0.*tt, 5.) < 1.);\n   \n        vec3 flashCol = getColorRamp(5, id*.1+.5*tt);\n\n        if(rm.z < 0.001) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n            \n            float shd=softshadow( p, l2+l, 2., 5. );\n       \n            float sss = smoothstep(0., 1., map(p + l * .3)) / .4;\n            float sss2 = smoothstep(0., 1., map(p + l2 * .3)) / .4;\n\n\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n\n            col = vec3(sss + dif*lc1 + dif2*lc2 + sss2) + iri;\n      \n            float ao = calcAO(p, n);\n\n            \n            col *= mix(col, col*ao, 1.);\n            if(mat < 3.) {\n                rd = reflect(rd, n);\n       \n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                refl = vec3(dot(refl, vec3(.33)));\n\n             \n                refl = invGamma(refl);\n       \n               \n                refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .6); // reflect rainbows too\n                col = mix(col, refl.rgb, .98);\n\n          \n                t = rm.x;\n              \n                float fog = 1.-exp(-t*t*0.01);\n                \n                \n                p = transform(p);\n                if(mat > 0.) {\n                    p.z += 1.*tt;\n                    p *= 3.;\n                } else p *= 2.;\n                \n                p *= 20.;\n                \n        \n                \n      \n \n                \n                float dark = SIN(p.z*10.2+PI/2. + 20.*tt);\n                matId =  mod(id, 2.);\n                \n                \n                vec3 rainbow = getColorRamp(int(mix(2., 5., matId)), SIN(p.x*4.5+p.x*10.2 + 20.*p.z + id*10.) + SIN(p.x*5.4+p.y*5.4 + id/10.)*.1 );\n                \n                vec3 col1 = 1.0*mix(col, mix(col*rainbow, rainbow, .5), 1.*.5); \n                vec3 col2 = 1.0*mix(col, mix(col*rainbow, rainbow, .5), 0.); \n            \n               col *= .9;\n               \n              \n                vec3 col3 = mix(col1, col2, .5); \n              //  col = mix(col+.3*col3, col, .6);\n               \n                if(mat < 1. ) {\n                    col *= .3;\n                    flashCol *= .4;\n                }\n                \n                col = mix(col, flashCol*.6, .6*clamp(flash, 0., 1.)*dark);\n                col = mix(col, bg, fog);\n     \n                \n            } \n            \n            \n            col = mix(col*shd, col, .5);;\n            \n\n        } else {\n           col = bg;\n\n        } \n        \n\n         col += .2*g_glow*flashCol; // inner\n\n    }\n    \n    col = saturateColor(col, 1.2);\n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    \n    col = pow(col*mix(1.8, 1.5, matId), vec3(mix(2.4, 3., matId)))*9.;\n    \n\n    \n    col = gamma(col); // gamma\n    \n    \n    fragColor = vec4(col, 1.0 - t * 0.03);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define COPY_COLOR(N, colorsK)  for(int i = 0; i < N; i++) { colors[i] = colorsK[i]; }\n\nvec3 rgb2hsl(vec3 color) {\n    float r = color.r;\n    float g = color.g;\n    float b = color.b;\n    float max = max(max(r, g), b);\n    float min = min(min(r, g), b);\n    float h, s, l;\n    l = (max + min) / 2.0;\n\n    if (max == min) {\n        h = s = 0.0; // achromatic\n    } else {\n        float d = max - min;\n        s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\n        if (max == r) {\n            h = (g - b) / d + (g < b ? 6.0 : 0.0);\n        } else if (max == g) {\n            h = (b - r) / d + 2.0;\n        } else if (max == b) {\n            h = (r - g) / d + 4.0;\n        }\n        h /= 6.0;\n    }\n    return vec3(h, s, l);\n}\n\n\nconst vec3 colors2[] = vec3[](\n    vec3(27, 231, 255) / 255.0, // Electric blue\n    vec3(110, 235, 131) / 255.0, // Light green\n    vec3(228, 255, 26) / 255.0, // Lemon Lime\n    vec3(255, 184, 0) / 255.0, // Selective yellow\n    vec3(255, 87, 20) / 255.0 // Giants orange\n);\n\nconst vec3 colors1[] = vec3[](\n    vec3(84, 13, 110) / 255.0, // Indigo\n    vec3(238, 66, 102) / 255.0, // Red (Crayola)\n    vec3(255, 210, 63) / 255.0, // Sunglow\n    vec3(59, 206, 172) / 255.0, // Turquoise\n    vec3(14, 173, 105) / 255.0 // Jade\n);\n  \n\nconst vec3 colors3[] = vec3[](\n    vec3(155, 93, 229) / 255.0, // Amethyst\n    vec3(241, 91, 181) / 255.0, // Brilliant rose\n    vec3(254, 228, 64) / 255.0, // Maize\n    vec3(0, 187, 249) / 255.0, // Deep Sky Blue\n    vec3(0, 245, 212) / 255.0 // Aquamarine\n);\n\n\nconst vec3 colors4[] = vec3[](\n    vec3(0.169, 0.761, 0.718),\n    vec3(0.357, 0.518, 0.008),\n    vec3(0.604, 0.851, 0.259),\n    vec3(0.820, 0.235, 0.196),\n    vec3(0.522, 0.075, 0.020)\n);\n\nconst vec3 colors5[] = vec3[](\n    vec3(237, 174, 73) / 255.0, // Hunyadi yellow\n    vec3(209, 73, 91) / 255.0, // Amaranth\n    vec3(0, 121, 140) / 255.0, // Caribbean Current\n    vec3(48, 99, 142) / 255.0, // Lapis Lazuli\n    vec3(0, 61, 91) / 255.0 // Indigo dye\n);\n\n\nconst vec3 colors6[] = vec3[](\n    vec3(0, 204, 255) / 255.0, // Vivid sky blue\n    vec3(0, 255, 204) / 255.0, // Aquamarine\n    vec3(255, 255, 0) / 255.0, // Yellow\n    vec3(255, 0, 204) / 255.0, // Hot magenta\n    vec3(204, 0, 255) / 255.0 // Electric purple\n);\n\nconst vec3 colors77[] = vec3[](\n    vec3(0.600,0.271,0.000), // Vivid sky blue\n    vec3(0.949,0.600,0.314), // Aquamarine\n    vec3(0.941,0.984,1.000), // Yellow\n    vec3(0.071,0.537,0.769), // Hot magenta\n    vec3(0.051,0.212,0.686) // Electric purple\n);\n\nconst vec3 colors78[] = vec3[](\n    vec3(249, 65, 68) / 255.0, // Imperial red\n    vec3(243, 114, 44) / 255.0, // Orange (Crayola)\n    vec3(248, 150, 30) / 255.0, // Carrot orange\n    vec3(249, 132, 74) / 255.0, // Coral\n    vec3(249, 199, 79) / 255.0, // Saffron\n    vec3(144, 190, 109) / 255.0, // Pistachio\n    vec3(67, 170, 139) / 255.0, // Zomp\n    vec3(77, 144, 142) / 255.0, // Dark cyan\n    vec3(87, 117, 144) / 255.0, // Payne's gray\n    vec3(39, 125, 161) / 255.0 // Cerulean\n);\n\nconst vec3 colors7[] = vec3[](\nvec3(176.,29.,30.) / 255.,\nvec3(241.,104.,38.) / 255.,\nvec3(234.,211.,95.) / 255.,\nvec3(0.,187.,173.) / 255.,\nvec3(0.,107.,228.) / 255.,\nvec3(126.,99.,180.) / 255.);\n\n\n/*const vec3 colors1[] = vec3[](\n    vec3(60, 22, 66) / 255.0, // Russian violet\n    vec3(8, 99, 117) / 255.0, // Caribbean Current\n    vec3(29, 211, 176) / 255.0, // Turquoise\n    vec3(175, 252, 65) / 255.0, // Green Yellow\n    vec3(178, 255, 158) / 255.0 // Light green\n);*/\n/*const vec3 colors2[] = vec3[](\n    vec3(112, 214, 255) / 255.0, // Pale azure\n    vec3(255, 112, 166) / 255.0, // Cyclamen\n    vec3(255, 151, 112) / 255.0, // Atomic tangerine\n    vec3(255, 214, 112) / 255.0, // Naples yellow\n    vec3(233, 255, 112) / 255.0  // Mindaro\n);*/\n\n\n\n// Allow up to 10 colors per palette\nvec3 getColorRamp_(vec3 cols[10], int N, float x ) {\n    // Calculate adjusted length to ensure end color is reachable within [0, 1]\n    float len = float(N);\n    \n    // Scale x according to the adjusted length and apply modulo for wrapping\n    float scaledX = mod(x * (len-1.), len);\n    \n    // Calculate indices. Ensure index2 wraps around to the start if necessary\n    int index1 = int(scaledX);\n    int index2 = index1 + 1;\n    if (index2 >= cols.length()) {\n        index2 = 0; // Wrap to the start to close the loop\n    }\n    \n    // Calculate the fraction between the two indices for smooth interpolation\n    float frac = fract(scaledX);\n    \n    // Interpolate between the two selected colors\n    return mix(cols[index1], cols[index2], smoothstep(0.0, .9, frac));\n}\n\nvec3 getColorRamp(int palette, float x) {\n\n    vec3 colors[10];\n    int len;\n    \n    \n    if(palette == 0) {\n        len = colors1.length();\n        COPY_COLOR(len, colors1);       \n    }\n    \n    if(palette == 1) {\n        len = colors2.length();\n        COPY_COLOR(len, colors2);\n    }\n    if(palette == 2) {\n        len = colors3.length();\n        COPY_COLOR(len, colors3);\n        \n    }\n    if(palette == 3) {\n        len = colors4.length();\n        COPY_COLOR(len, colors4);    \n    }\n    \n    if(palette == 4) {\n        len = colors5.length();\n        COPY_COLOR(len, colors5);    \n    }\n    if(palette == 5) {\n        len = colors6.length();\n        COPY_COLOR(len, colors6);    \n    }\n    if(palette == 6) {\n        len = colors7.length();\n        COPY_COLOR(len, colors7);    \n    }\n    return getColorRamp_(colors, len, x);\n\n}\n\n// mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 saturateColor(vec3 color, float saturation) {\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= saturation;\n    return hsv2rgb(hsv);\n}\n","name":"Common","description":"","type":"common"}]}