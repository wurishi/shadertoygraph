{"ver":"0.1","info":{"id":"clsSRS","date":"1674962760","viewed":23,"name":"Mr Brightside synth shader","username":"vizaxo","description":"Audio shader of a synth playing Mr Brightside","likes":0,"published":1,"flags":8,"usePreview":0,"tags":["music","audio","synth","killers","brightside"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float val = 0.5*sin(tau*quaver*iTime) + 0.5;\n    //val = adsr(time % (1./crotchet), time % (1./quaver), 0.5, time % (1./quaver), time);\n    // Output to screen\n    col = vec3(1.,0.,0.);\n    vec4 chord = chords(mod(iTime, bar*4.));\n    col = chord.xyz/(key*2.);\n    fragColor = adsr(0., 0., mod(iTime, crotchet), .01, .1, 1., 0.5)*vec4(col,1.0);\n    //fragColor = adsr(0., 5., mod(iTime, 6.), 1., 1., .5, 1.)*vec4(col,1.0);\n    fragColor = vec4(uv.x, uv.y, 1., 0.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iTime time\n\nfloat volume = 0.3;\nfloat a440 = 440.0;\n\n#define note(f) sin(tau*f*time)\n#define inst(hs, f) ((1./4.) * (hs.x*note(f) + hs.y*note(f*2.) + hs.z*note(f*3.) + hs.w*note(f*4.)))\n\n#define p1(f) note(f)\n#define M3(f) note(f*5.0/4.0)\n#define octave(f) note(f*2.0)\n#define p5(f) note((f*(3.0/2.0)))\n\n#define panL(x) vec2(x, 0)\n#define panM(x) vec2(x)\n#define panR(x) vec2(0, x)\n\n#define etPitch(f, n) note(f * pow(2.0,(float(n)/12.0)))\n\n\nfloat distort(float f){\n    float factor=1.;\n    return min(max(f, -factor), factor);\n}\n\nfloat soloNote(float f, float duration, float time) { \n    vec4 hs = vec4(1., .4, .9, .3);\n    return adsr(0., duration-.1, time, .05, .05, .9, .1) * inst(hs, f);\n}\n\n#define sn(f, d) if (t < d) return soloNote(f, d, t); t-= d;\n#define rest(d) if (t < d) return 0.; t-= d;\n\n#define scoop 0.03\n#define scoopedone (t < scoop ? one*(1.-(scoop-t)) : one)\nfloat solo(float t) {\n    float one = key; \n    float two = 9./8. * key;\n    float three = 5./4. * key;\n    float four = 4./3. * key;\n    float seven = 15./16.*key;\n    \n    rest(bar*4.);\n    \n    //jealousy\n    sn(seven, dotted(crotchet));\n    sn(one, quaver);\n    sn(one, dotted(crotchet));\n    rest(quaver);\n    \n    //turning saints\n    sn(scoopedone,crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    \n    sn(seven, dotted(crotchet));\n    sn(one, quaver);\n    sn(one, dotted(crotchet));\n    rest(quaver); \n    \n    //swimming through sick\n    sn(scoopedone,crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    \n    //lullabies\n    sn(seven, dotted(crotchet));\n    sn(one, quaver);\n    sn(one, dotted(crotchet));\n    rest(quaver);\n    \n    //choking on your\n    sn(scoopedone,crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    \n    //alabies\n    sn(seven, dotted(crotchet));\n    sn(one, quaver);\n    sn(one, dotted(crotchet));\n    rest(quaver);\n    \n    //but it's just the\n    sn(scoopedone,crotchet);\n    sn(one, crotchet);\n    sn(one, crotchet);\n    sn(two, crotchet);\n    \n    //price I pay\n    sn(four, dotted(crotchet)); \n    sn(three, quaver);\n    sn(three, dotted(crotchet));\n    rest(quaver);\n    \n    sn(four, crotchet);\n    sn(three, crotchet);\n    sn(one, crotchet);\n    sn(3./4.*one, crotchet); \n    \n    sn(two, dotted(crotchet)); \n    sn(one, quaver);\n    sn(one, dotted(crotchet));\n    rest(quaver);\n    \n    //open up my\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    sn(scoopedone, crotchet);\n    sn(two, crotchet);\n    \n    //eager eyes\n    sn(four, dotted(crotchet));\n    sn(three, dotted(crotchet));\n    sn(three, crotchet + bar);\n    \n    rest(quaver);\n    sn(5./6.*one, quaver);\n    sn(three, crotchet);\n    sn(two, crotchet);\n    sn(one, crotchet);\n    sn(two, minim);\n    \n    vec4 hs = vec4(1., .4, .9, .3);\n    float time = t;\n    if (t < bar) return adsr(0., minim-.1, t, 0.05, 0.05, .9, minim) * inst(hs, one);\n    t-=bar;\n\n    return 0.;\n}\n\nvec2 mainSound( int samp, float time )\n{        \n\n    float f1 = 440.0;\n    //vec2 note1 = panM(distort(0.5*(p1(f1) + etPitch(f1, majorScale[int(floor(time/ crotchet)) % 8]))));\n    \n    //vec2 note2 = panM(distort(0.5*(p1(f1) + p5(f1))));//+ M3(f1) + p5(f1));\n    \n    vec4 chord = chords(mod(iTime, bar*4.));\n    float bass = adsr(0., quaver-0.01, mod(iTime, quaver), .02, .05, .8, 0.01) * note(chord.x);\n    float sub = adsr(0., 3.5*crotchet, mod(iTime, bar), 0.05, .1, .8, 0.05) * note(chord.x / 2.);\n    \n    vec4 chordOct = chords(mod(iTime, bar*4.)) * 2.;\n    float backingEnv = 1.5 * adsr(0., crotchet*3.9, mod(iTime, bar), .01, .01, .8, crotchet*.1);\n    vec4 padHarmSeries = vec4(1., .2, .2, .2);\n    float b1 = inst(padHarmSeries, chordOct.x);\n    float b2 = inst(padHarmSeries, chordOct.y);\n    float b3 = inst(padHarmSeries, chordOct.z);\n    \n    vec2 backing = backingEnv * (1./3.) * (panM(b1) + panL(b2) + panR(b3));\n    if (iTime > bar*20.) {\n        bass = 0.;\n        sub = 0.;\n        backing = vec2(0.);\n    }\n    return volume*panM(.5 * sub + .5*bass + 2.*solo(iTime) + 1.*backing);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"float tau = 6.2831;\n\n\n//#define adsr(t1, t2, a, d, s, r, time) (elerp(0.0, 1.0, (time-t1)/a) + elerp(1.0, s, (time-a-t1)/d))\nfloat lerp(float a, float b, float t) {\n    t = smoothstep(0.,1.,t);\n    return a*(1.-t) + b*t;\n}\n\n\n\nfloat adsr(float t0, float t1, float t, float a, float d, float s, float r) {\n    if (t < t0)\n        return 0.;\n    else if (t < t0+a)\n        return lerp(0., 1., (t-t0)/a);\n    else if (t < t0+a+d)\n        return lerp(1., s, (t-t0-a)/d);\n    else if (t < t1)\n        return s;\n    else if (t < t1+r)\n        return lerp(s, 0., (t-t1)/r);\n    else\n        return 0.;\n}\n\n\nconst float bpm = 148.0;\nconst float bps = bpm/60.;\nconst float spb = 1./bps;\nconst float quaver = .5*spb;\nconst float crotchet = spb;\nconst float minim = 2.*spb;\nconst float bar = crotchet*4.;\nfloat dotted(float x) {\n    return 1.5*x;\n}\n\nconst float key = 138.59; //C#3\n\nvec4 maj(float root) {\n    return root*vec4(1., 5./4., 3./2., 0.);\n}\n\nvec4 minor(float root) {\n    return root*vec4(1., 6./5., 3./2., 0.);\n}\n\nvec4 chords(float time) {\n    if (time < bar)\n        return maj(key);\n    else if (time < bar*2.)\n        return maj(key * 2./3.);\n    else if (time < bar*3.)\n        return minor(key * 5./6.);\n    else\n        return maj(key * 3./4.);\n} \n","name":"Common","description":"","type":"common"}]}