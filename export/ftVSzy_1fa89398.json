{"ver":"0.1","info":{"id":"ftVSzy","date":"1640922177","viewed":54,"name":"Glass regular polyhedron","username":"lox9973","description":"Regular polyhedron with reflection and refraction. Polyhedron list: prisms {2,3}~{2,6}, platonic solids {5,3},{4,3},{3,3},{3,4},{3,5} and their truncations, stereographical projected uniform tilings {6,3},{4,4},{3,6} and their truncations.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","glass","polyhedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FOLD_STEP   4\n#define MAX_MARCH_STEP  1.5 // less than pi/2\n#define MAX_MARCH_DIST  10.\n#define EPS_MARCH_DEPTH 5e-6\n#define EPS_GEOM_DIST   1e-5\n\n#define INF_MARCH_DIST 1e9\n\nfloat2 unit_sphere_distance(float3 pos, float3 dir) {\n\tfloat B = dot(pos, dir);\n\tfloat C = dot(pos, pos) - 1.;\n\tfloat D = sqrt(max(B*B-C,0.));\n\treturn float2(-B-D, -B+D);\n}\nfloat3 polytope_normal(float3 pos, out int face, float3x3 F) {\n\tfloat3 posF = mul(pos, F);\n\tface = int(argmin3(1.-posF));\n\tfloat3x3 id3 = float3x3(1,0,0, 0,1,0, 0,0,1);\n\treturn normalize(mul(F, id3[face]));\n}\nfloat polytope_distance(float3 pos, float3 dir, float3x3 F) {\n\tfloat3 posF = mul(pos, F);\n\tfloat3 dirF = mul(dir, F);\n\tfloat3 x = (1.-posF)/dirF;\n\tfloat3 lo = select(lessThan(dirF,vec3(0)), vec3(-INF_MARCH_DIST), x);\n\tfloat3 hi = select(lessThan(dirF,vec3(0)), x, vec3(+INF_MARCH_DIST));\n\treturn max(0., max3(select(lessThan(vec3(0),lo), vec3(0), hi)));\n}\nfloat3 polytope_skybox(float3 dir) {\n\treturn dir*0.5+0.5;\n}\n\nfloat3x3 polyhedron_H;\nfloat3x3 polyhedron_F;\nint polyhedron_id;\n\nvoid init_polyhedron(int index) {\n\tswitch(index) {\n#ifdef SHADER_API_D3D11\n\tdefault:\n#endif\n#define id polyhedron_id\n#define H polyhedron_H\n#define F polyhedron_F\ncase 231: case  0: id=231; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678,  0.        ,  1.22474487));\nF=mat3(float3(2.29128785, 0.        , 1.32287566),\n       float3(0.        , 1.52752523, 0.        ),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 241: case  1: id=241; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.        ,  0.        ,  1.        ));\nF=mat3(float3(1.22474487, 0.        , 1.22474487),\n       float3(0.        , 1.73205081, 0.        ),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 251: case  2: id=251; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.14412281,  0.        ,  0.83125388));\nF=mat3(float3(0.84275535, 0.        , 1.15995323),\n       float3(0.        , 1.97343031, 0.        ),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 261: case  3: id=261; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.22474487,  0.        ,  0.70710678));\nF=mat3(float3(0.64549722, 0.        , 1.11803399),\n       float3(0.        , 2.23606798, 0.        ),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 330: case  4: id=330; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -0.70710678,  1.        ));\nF=mat3(float3(2.44948974, 0.        , 1.73205081),\n       float3(0.        , 0.81649658, 0.57735027),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 331: case  5: id=331; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -0.70710678,  1.        ));\nF=mat3(float3(1.56347192, 0.        , 1.1055416 ),\n       float3(0.        , 0.93808315, 0.66332496),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 340: case  6: id=340; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.        , -0.70710678,  0.70710678));\nF=mat3(float3(1.        , 0.        , 1.41421356),\n       float3(0.        , 0.70710678, 0.70710678),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 341: case  7: id=341; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.        , -0.70710678,  0.70710678));\nF=mat3(float3(0.74535599, 0.        , 1.05409255),\n       float3(0.        , 0.79056942, 0.79056942),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 430: case  8: id=430; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.        ,  0.70710678));\nF=mat3(float3(1.22474487, 0.        , 1.22474487),\n       float3(0.        , 0.57735027, 0.81649658),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 431: case  9: id=431; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.        ,  0.70710678));\nF=mat3(float3(1.04201077, 0.        , 1.04201077),\n       float3(0.        , 0.61039577, 0.86322998),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 350: case 10: id=350; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.14412281, -0.70710678,  0.43701602));\nF=mat3(float3(0.44902798, 0.        , 1.1755705 ),\n       float3(0.        , 0.52573111, 0.85065081),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 351: case 11: id=351; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.14412281, -0.70710678,  0.43701602));\nF=mat3(float3(0.38998724, 0.        , 1.02099984),\n       float3(0.        , 0.55974478, 0.90568607),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 530: case 12: id=530; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.14412281,  0.43701602));\nF=mat3(float3(0.66158454, 0.        , 1.07046627),\n       float3(0.        , 0.35682209, 0.93417236),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 531: case 13: id=531; // spheric\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.14412281,  0.43701602));\nF=mat3(float3(0.62698615, 0.        , 1.0144849 ),\n       float3(0.        , 0.36376403, 0.95234658),\n       float3(0.        , 0.        , 1.        ));\nbreak;\ncase 360: case 14: id=360; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.22474487, -0.70710678,  0.20695267));\nF=mat3(float3( 0.16897615,  0.        ,  0.11421176),\n       float3( 0.        ,  0.29267527,  0.        ),\n       float3(-0.16897615,  0.        ,  0.11421176));\nbreak;\ncase 361: case 15: id=361; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.22474487, -0.70710678,  0.20695267));\nF=mat3(float3( 0.16897615,  0.        ,  0.03807059),\n       float3( 0.        ,  0.29267527,  0.03807059),\n       float3(-0.16897615,  0.        ,  0.03807059));\nbreak;\ncase 630: case 16: id=630; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.22474487,  0.20695267));\nF=mat3(float3( 0.29267527,  0.        ,  0.11421176),\n       float3( 0.        ,  0.16897615,  0.        ),\n       float3(-0.29267527,  0.        ,  0.11421176));\nbreak;\ncase 631: case 17: id=631; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-0.70710678, -1.22474487,  0.20695267));\nF=mat3(float3( 0.29267527,  0.        ,  0.09180884),\n       float3( 0.        ,  0.16897615,  0.00820004),\n       float3(-0.29267527,  0.        ,  0.09180884));\nbreak;\ncase 440: case 18: id=440; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.        , -1.        ,  0.3288729 ));\nF=mat3(float3( 0.3288729 ,  0.        ,  0.21631477),\n       float3( 0.        ,  0.3288729 ,  0.        ),\n       float3(-0.3288729 ,  0.        ,  0.21631477));\nbreak;\ncase 441: case 19: id=441; // affine\nH=mat3(float3( 1.41421356,  0.        ,  0.        ),\n       float3( 0.        ,  1.41421356,  0.        ),\n       float3(-1.        , -1.        ,  0.3288729 ));\nF=mat3(float3( 0.3288729 ,  0.        ,  0.12671426),\n       float3( 0.        ,  0.3288729 ,  0.03711375),\n       float3(-0.3288729 ,  0.        ,  0.12671426));\nbreak;\n\n#undef H\n#undef F\n#undef id\n\t}\n}\n\nfloat reflectRefract(float3 i, float3 n, float eta, out float3 r, out float3 t) {\n\tfloat cosI = dot(-i, n);\n\tfloat cosT = sqrt(max(0., 1.-eta*eta * (1.-cosI*cosI)));\n\tr = i + 2.*cosI * n;\n\tt = eta * i + (eta*cosI-cosT) * n;\n\tfloat2 q = float2(cosI-eta*cosT,cosT-eta*cosI)/float2(cosI+eta*cosT,cosT+eta*cosI);\n\treturn dot(q,q)/2.;\n}\nfloat2 stereoProj(float3 p) {\n\treturn p.xy/(p.z+length(p));\n}\nfloat3 stereoProjInv(float2 p, float rr) {\n\tfloat pp = dot(p,p) - rr;\n\treturn float3(2.*p, 1.-pp) / (1.+pp);\n}\nfloat3x3 get_horo_F(float3x3 mat) {\n\tfloat2x2 m = mat2(mat);\n\tfloat2 b = mul(COL(mat,2).xy, m);\n\treturn mat3(\n\t\tstereoProjInv(mul(COL(polyhedron_F,0).xy, m) - b, COL(polyhedron_F,0).z),\n\t\tstereoProjInv(mul(COL(polyhedron_F,1).xy, m) - b, COL(polyhedron_F,1).z),\n\t\tstereoProjInv(mul(COL(polyhedron_F,2).xy, m) - b, COL(polyhedron_F,2).z));\n}\n\nbool march_polyhedron_horo_fold(inout float3 pos, inout float3x3 mat) {\n\tfor(int j=0; j<MAX_FOLD_STEP; j++) {\n\t\tbool3 folds = bool3(\n\t\t\tfold(DUAL_PAIR(dualA,COL(polyhedron_H,2)), pos, mat),\n\t\t\tfold(DUAL_PAIR(dualA,COL(polyhedron_H,0)), pos, mat),\n\t\t\tfold(DUAL_PAIR(dualA,COL(polyhedron_H,1)), pos, mat));\n\t\tif(!any(folds))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nbool march_polyhedron_fold(inout float3 pos, inout float3x3 mat) {\n\tfor(int j=0; j<MAX_FOLD_STEP; j++) {\n\t\tbool3 folds = bool3(\n\t\t\tfold(DUAL_PAIR(dualS,COL(polyhedron_H,2)), pos, mat),\n\t\t\tfold(DUAL_PAIR(dualS,COL(polyhedron_H,0)), pos, mat),\n\t\t\tfold(DUAL_PAIR(dualS,COL(polyhedron_H,1)), pos, mat));\n\t\tif(!any(folds))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nvoid polyhedron_fold_horo(inout float3 pos, inout float3x3 mat) {\n\tfoldAffine(COL(polyhedron_F,0).xy, COL(polyhedron_F,1).xy, pos.xy,\n#ifdef UNITY_COMPILER_HLSL\n\t\tmat._m02_m12,\n#else\n\t\tmat[2].xy,\n#endif\n\t\tvec2(1));\n}\nfloat march_polyhedron_horo_outside(inout float3 pos, inout float3 dir, inout float3x3 mat) {\n\tfloat3 posA = mul(mat, float3(stereoProj(pos),1));\n\n\tbool need_fold_horo = true;\n\tfloat dist = 0.;\n\tconst int max_iter = 10;\n\tfor(int i=0; i<max_iter; ++i)\n\t\tif(march_polyhedron_horo_fold(posA, mat)) {\n\t\t\tneed_fold_horo = true;\n\t\t\tfloat t = polytope_distance(pos, dir, get_horo_F(mat));\n\t\t\tif(t < EPS_GEOM_DIST || dist > INF_MARCH_DIST)\n\t\t\t\treturn dist;\n\n\t\t\tdist += t;\n\t\t\tpos += t*dir;\n\t\t\tposA = mul(mat, float3(stereoProj(pos),1));\n\t\t} else if(need_fold_horo) {\n\t\t\tneed_fold_horo = false;\n\t\t\tpolyhedron_fold_horo(posA, mat);\n\t\t}\n\treturn INF_MARCH_DIST;\n}\nfloat3 march_polyhedron_horo_inside(float3 pos, float3 dir, float3x3 mat, float eta, float density) {\n\tfloat3 posA = mul(mat, float3(stereoProj(pos),1));\n\n\tfloat4 color = float4(0,0,0,1);\n\n\tconst int max_iter = 10;\n\tbool need_fold_horo = true;\n\tfor(int i=0; i<max_iter; ++i)\n\t\tif(march_polyhedron_horo_fold(posA, mat)) {\n\t\t\tneed_fold_horo = true;\n\t\t\tfloat3x3 F = get_horo_F(mat);\n\t\t\tfloat t = polytope_distance(pos, -dir, F);\n\t\t\tif(t < EPS_GEOM_DIST) {\n\t\t\t\tint face;\n\t\t\t\tfloat3 normal = polytope_normal(pos, face, F), refrDir;\n\t\t\t\tfloat refl = reflectRefract(dir, -normal, eta, dir, refrDir);\n\t\t\t\tcolor.rgb += (1.-refl)*color.a * polytope_skybox(refrDir);\n\t\t\t\tcolor.a *= refl;\n\t\t\t\tt = -unit_sphere_distance(pos, dir).y;\n\t\t\t}\n\n\t\t\tcolor.a *= exp(-density*-t);\n\t\t\tpos -= t*dir;\n\t\t\tposA = mul(mat, float3(stereoProj(pos),1));\n\t\t} else if(need_fold_horo) {\n\t\t\tneed_fold_horo = false;\n\t\t\tpolyhedron_fold_horo(posA, mat);\n\t\t}\n\treturn color.rgb;\n}\n\nfloat march_polyhedron_outside(inout float3 pos, inout float3 dir, inout float3x3 mat) {\n\tfloat3 posS = mul(mat, pos);\n\n\tfloat dist = 0.;\n\tconst int max_iter = 20;\n\tfor(int i=0; i<max_iter; ++i)\n\t\tif(march_polyhedron_fold(posS, mat)) {\n\t\t\tfloat t = polytope_distance(posS, mul(mat, dir), polyhedron_F);\n\t\t\tif(t < EPS_GEOM_DIST || dist > INF_MARCH_DIST)\n\t\t\t\treturn dist;\n\n\t\t\tdist += t;\n\t\t\tpos  += t*dir;\n\t\t\tposS = mul(mat, pos);\n\t\t}\n\treturn INF_MARCH_DIST;\n}\nfloat3 march_polyhedron_inside(float3 pos, float3 dir, float3x3 mat, float eta, float density) {\n\tfloat3 posS = mul(mat, pos);\n\n\tfloat4 color = float4(0,0,0,1);\n\tconst int max_iter = 20;\n\tfor(int i=0; i<max_iter; ++i)\n\t\tif(march_polyhedron_fold(posS, mat)) {\n\t\t\tfloat t = polytope_distance(posS, -mul(mat, dir), polyhedron_F);\n\t\t\tif(t < EPS_GEOM_DIST) {\n\t\t\t\tint face;\n\t\t\t\tfloat3 normal = mul(polytope_normal(posS, face, polyhedron_F), mat), refrDir;\n\t\t\t\tfloat refl = reflectRefract(dir, -normal, eta, dir, refrDir);\n\t\t\t\tcolor.rgb += (1.-refl)*color.a * polytope_skybox(refrDir);\n\t\t\t\tcolor.a *= refl;\n\t\t\t\tt = -unit_sphere_distance(pos, dir).y;\n\t\t\t}\n\t\t\tcolor.a *= exp(-density*-t);\n\t\t\tpos -= t*dir;\n\t\t\tposS = mul(mat, pos);\n\t\t}\n\treturn color.rgb;\n}\n\nfloat _Eta;\nfloat _Density;\nfloat4 draw_polyhedron_horo(float3 pos, float3 dir) {\n\tfloat3x3 mat = mat3(float3(1,0,0), float3(0,1,0), float3(COL(polyhedron_F,0).xy,1));\n\tfloat2 result = unit_sphere_distance(pos, dir);\n\tfloat dist = INF_MARCH_DIST;\n\tif(result.y > 0.) {\n\t\tdist = max(result.x, 0.);\n\t\tpos += dist * dir;\n\t\tdist += march_polyhedron_horo_outside(pos, dir, mat);\n\t}\n\n\tfloat3 total = vec3(0);\n\tif(dist < INF_MARCH_DIST) {\n\t\tfloat3x3 F = get_horo_F(mat);\n\t\tint face;\n\t\tfloat3 normal = polytope_normal(pos, face, F), reflDir;\n\t\tfloat refl = reflectRefract(dir, normal, _Eta, reflDir, dir);\n\t\tfloat t = unit_sphere_distance(pos, dir).y;\n\t\tpos += t*dir;\n\t\tfloat3 inside = exp(-_Density*t) * march_polyhedron_horo_inside(pos, dir, mat, rcp(_Eta), _Density);\n\t\ttotal = lerp(inside, polytope_skybox(reflDir), refl);\n\t\tif(face == 1) {\n\t\t\tfloat F1z = COL(F,1).z * rsqrt(dot(COL(F,1),COL(F,1)));\n\t\t\ttotal *= lerp(1.0, 0.1, saturate(sqrt(2.+2.*F1z)));\n\t\t}\n\t}\n\n\treturn float4(total, dist);\n}\nfloat4 draw_polyhedron(float3 pos, float3 dir) {\n\tfloat2 rotZX = normalize(COL(polyhedron_F,0).zx);\n\tfloat3x3 mat = mat3(float3(rotZX.x,0,-rotZX.y), float3(0,1,0), float3(rotZX.y, 0, rotZX.x));\n\tfloat2 result = unit_sphere_distance(pos, dir);\n\tfloat dist = INF_MARCH_DIST;\n\tif(result.y > 0.) {\n\t\tdist = max(result.x, 0.);\n\t\tpos += dist * dir;\n\t\tdist += march_polyhedron_outside(pos, dir, mat);\n\t}\n\n\tfloat3 total = vec3(0);\n\tif(dist < INF_MARCH_DIST) {\n\t\tint face;\n\t\tfloat3 normal = mul(polytope_normal(mul(mat,pos), face, polyhedron_F), mat), reflDir;\n\t\tfloat refl = reflectRefract(dir, normal, _Eta, reflDir, dir);\n\t\tfloat t = unit_sphere_distance(pos, dir).y;\n\t\tpos += t*dir;\n\t\tfloat3 inside = exp(-_Density*t) * march_polyhedron_inside(pos, dir, mat, rcp(_Eta), _Density);\n\n\t\ttotal = lerp(inside, polytope_skybox(reflDir), refl);\n\t\tif(face == 1)\n\t\t\ttotal *= 0.1;\n\t}\n\n\treturn float4(total, dist);\n}\n// https://www.shadertoy.com/view/4lGSzV\nfloat drawInt(in vec2 where, in int what)\n{\n    int i=int((where*=0.25).y), j=int(where.x), k=1;\n    if (i>0 && i<6)\n      for (int n=3; n>0;n--)\n        if ((j+=4)<3 && j>=0) {\n            \tint l=what/k;\n                i = (i>4? 972980223: i>3? 690407533: i>2? 704642687: i>1? 696556137:972881535)/\n            \t    int(exp2(float(29-j-(l-(l/10)*10)*3)));\n                return float(i-i/2*2);\n        }\n    \telse k*=10;\n    return 0.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fov = PI/3.0;\n    float3 view = normalize(float3(tan(fov/2.0) * (fragCoord*2.0-iResolution.xy), iResolution.y));\n\n    float index = floor(frac(iTime/20.0/3.0)*20.0);\n    init_polyhedron(int(index));\n    _Eta = 0.6;\n    _Density = 0.5;\n\n\n\tfloat3 pos = vec3(0,0,-2.5);\n\tfloat speed = PI/2.;\n    \n    float2x2 rot;\n\trot = float2x2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tpos.yz = mul(rot, pos.yz);\n\tview.yz = mul(rot, view.yz);\n    \n\trot = float2x2(cos(iTime*speed), sin(iTime*speed), -sin(iTime*speed), cos(iTime*speed));\n\tpos.xz = mul(rot, pos.xz);\n\tview.xz = mul(rot, view.xz);\n\n    rot = mat2(float2(0,-1),float2(1,0));\n\tpos.yz = mul(rot, pos.yz);\n\tview.yz = mul(rot, view.yz);\n    \n\tfloat4 color;\n\tuint polyhedron_family = uint(polyhedron_id)/10u;\n\tif(polyhedron_family==36u||polyhedron_family==63u||polyhedron_family==44u)\n\t\tcolor = draw_polyhedron_horo(pos, view);\n\telse\n\t\tcolor = draw_polyhedron(pos, view);\n    \n    if(fragCoord.y < 25.)\n        color.rgb += drawInt(vec2(fragCoord.x-55.,fragCoord.y), polyhedron_id);\n    \n    fragColor = float4(sqrt(color.rgb), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n// trigonometry\n#define PI 3.14159265359\n#define rsqrt(x) inversesqrt(x)\n#define frac(x) fract(x)\n#define saturate(x) clamp(x,0.,1.)\n#define lerp(x,y,t) mix(x,y,t)\n#define select(b,t,f) mix(f,t,b)\n#define atan2(x,y) atan(x,y)\n#define ddx(x) dFdx(x)\n#define ddy(x) dFdy(x)\n#define rcp(x) (1./(x))\n#define UNITY_BRANCH ;\n\n// matrix\n#define mul(x,y) ((x)*(y))\n#define COL(x,n) (x)[n]\n#define float4x4 mat4\n#define float3x3 mat3\n#define float2x2 mat2\n\n// comparison\nfloat min2(float2 v) { return min(v.x, v.y); }\nfloat max2(float2 v) { return max(v.x, v.y); }\nfloat min3(float3 v) { return min(min(v.x, v.y), v.z); }\nfloat max3(float3 v) { return max(max(v.x, v.y), v.z); }\nfloat min4(float4 v) { return min2(min(v.xy, v.zw)); }\nfloat max4(float4 v) { return max2(max(v.xy, v.zw)); }\nfloat4 sort4(float4 v) {\n    v.xyzw = float4(min(v.xy, v.zw), max(v.xy, v.zw));\n    v.xzyw = float4(min(v.xz, v.yw), max(v.xz, v.yw));\n    return float4(v.x, min(v.y, v.z), max(v.y, v.z), v.w);\n}\nfloat argmin3(float3 v) {\n    return max3(select(equal(v, float3(min3(v))), float3(0,1,2), float3(0)));\n}\nfloat argmin4(float4 v) {\n    return max4(select(equal(v, float4(min4(v))), float4(0,1,2,3), float4(0)));\n}\n\nfloat3 dualS(float3 a) { return a; }\nfloat3 dualA(float3 a) { return float3(a.xy, 0); }\nfloat4 dualS(float4 a) { return a; }\nfloat4 dualH(float4 a) { return float4(a.xyz, -a.w); }\nfloat4 dualA(float4 a) { return float4(a.xyz, 0); }\nfloat dotS(float3 a, float3 b) { return dot(a, b); }\nfloat dotS(float4 a, float4 b) { return dot(a, b); }\nfloat dotH(float4 a, float4 b) { return dot(a.xyz, b.xyz) - a.w*b.w; }\nfloat dotA(float4 a, float4 b) { return dot(a.xyz, b.xyz); }\n\n\n#define DUAL_PAIR(dual,h) (h),dual(h)\n#define EPS_FOLD_DOT 2e-5 // upper bound for dot(pos,h) ~ 0 in preset\nbool fold(float3 h, float3 n, inout float3 pos, inout float3x3 mat) {\n\tfloat posH = dot(pos,h);\n\tif(posH > -EPS_FOLD_DOT)\n\t\treturn false;\n\tpos -= posH*n;\n\tfloat3 colH = mul(h,mat);\n\tmat = mat3(COL(mat,0)-colH[0]*n, COL(mat,1)-colH[1]*n, COL(mat,2)-colH[2]*n);\n\treturn true;\n}\nvoid foldAffine(float2 dx, float2 dy, inout float2 pos, inout float2 loc, float2 period) {\n\tbool2 less = lessThan(vec2(dot(dx,dx) - dot(dy,dy)), float2(-1,1)*EPS_FOLD_DOT);\n\tfloat2 scale = select(less, float2(3,2), float2(2,3)) * period;\n\tfloat2 coord = float2(dot(dx,pos),dot(dy,pos)) / (-scale * float2(dot(dx,dx),dot(dy,dy)));\n\tcoord = less.y ? coord : coord.yx;\n\tcoord.x = round(coord.x);\n\tfloat h = less.x == less.y ? frac(coord.x/2.) : 0.;\n\tcoord.y = round(coord.y + h) - h;\n\tcoord = less.y ? coord : coord.yx;\n\tcoord *= scale;\n\t// apply affine translation\n\tfloat2 dw = coord.x*dx + coord.y*dy;\n\tpos += dw;\n\tloc += dw;\n}\n","name":"Common","description":"","type":"common"}]}