{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//////////////////////////////////////////////////////////////\n// ShaderToy HLSL translation\n//////////////////////////////////////////////////////////////\n\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n#define const\n\nfloat saturate(float color)\n{\n\treturn clamp(color, 0.0, 1.0);\n}\n\nfloat2 saturate(float2 color)\n{\n\treturn clamp(color, 0.0, 1.0);\n}\n\nfloat3 saturate(float3 color)\n{\n\treturn clamp(color, 0.0, 1.0);\n}\n\nfloat4 saturate(float4 color)\n{\n\treturn clamp(color, 0.0, 1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////\n// Main\n//////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 glUV = fragCoord.xy / iResolution.xy;\t\n\tfloat4 cvSplashData = float4(iResolution.x, iResolution.y, iTime, 0.0);\t\n\tfloat2 InUV = glUV * 2.0 - 1.0;\t\n\t\n\t//////////////////////////////////////////////////////////////\n\t// End of ShaderToy Input Compat\n\t//////////////////////////////////////////////////////////////\n\t\n\t// Constants\n\tconst float TimeElapsed\t\t= cvSplashData.z;\n\tconst float Brightness\t\t= sin(TimeElapsed) * 0.2;\n\tconst float2 Resolution\t\t= float2(cvSplashData.x, cvSplashData.y);\n\tconst float AspectRatio\t\t= Resolution.x / Resolution.y;\n\tconst float3 InnerColor\t\t= float3( 0.50, 0.50, 0.50 );\n\tconst float3 OuterColor\t\t= float3( 0.05, 0.05, 0.90 );\n\tconst float3 WaveColor\t\t= float3( 0.70, 0.70, 1.00 );\n\t\t\n\t// Input\n\tfloat2 uv\t\t\t\t= (InUV + 1.0) / 2.0;\n\n\t// Output\n\tfloat4 outColor\t\t\t= float4(0.0);\n\n\t// Positioning \n\tfloat2 outerPos\t\t\t= -0.5 + uv;\n\touterPos.x\t\t\t\t*= AspectRatio;\n\n\tfloat2 innerPos\t\t\t= InUV * ( 2.0 - Brightness );\n\tinnerPos.x\t\t\t\t*= AspectRatio;\n\n\t// \"logic\" \n\tfloat innerWidth\t\t= length(outerPos);\t\n\tfloat circleRadius\t\t= 0.24 + Brightness * 0.1;\n\tfloat invCircleRadius \t= 1.0 / circleRadius;\t\n\tfloat circleFade\t\t= pow(length(2.0 * outerPos), 0.5);\n\tfloat invCircleFade\t\t= 1.0 - circleFade;\n\tfloat circleIntensity\t= pow(invCircleFade * max(1.1 - circleFade, 0.0), 2.0) * 60.0;\n  \tfloat circleWidth\t\t= dot(innerPos,innerPos);\n\tfloat circleGlow\t\t= ((1.0 - sqrt(abs(1.0 - circleWidth))) / circleWidth) + Brightness * 0.5;\n\tfloat outerGlow\t\t\t= min( max( 1.0 - innerWidth * ( 1.0 - Brightness ), 0.0 ), 1.0 );\n\tfloat waveIntensity\t\t= 0.0;\n\t\n\t// Inner circle logic\n\tif( innerWidth < circleRadius )\n\t{\n\t\tcircleIntensity\t\t*= pow(innerWidth * invCircleRadius, 24.0);\n\t\t\n\t\tfloat waveWidth\t\t= 0.05;\n\t\tfloat2 waveUV\t\t= InUV;\n\n\t\tfor(float i = 0.0; i < 3.0; i++) \n\t\t{\t\t\n\t\t\twaveUV.y\t\t+= 0.4 * (0.20 * cos((waveUV.x * 2.0) + (i / 7.0) + (TimeElapsed * 1.5)));\n\t\t\twaveWidth\t\t= abs(1.0 / (200.0 * waveUV.y));\n\t\t\twaveIntensity \t+= waveWidth;\n\t\t}\t\t\n\t}\t\n\t\n\t// Compose outColor\n\toutColor.rgb\t= outerGlow * OuterColor;\t\n\toutColor.rgb\t+= circleIntensity * InnerColor * 2.0;\t\n\toutColor.rgb\t+= circleGlow * InnerColor * (0.6 + Brightness * 1.2);\n\toutColor.rgb\t+= WaveColor * waveIntensity;\n\toutColor.a\t\t= 1.0;\n\n\t// Fade in\n\toutColor.rgb\t= saturate(outColor.rgb);\n\toutColor.rgb\t*= min(TimeElapsed / 2.0, 1.0);\n\n\t//////////////////////////////////////////////////////////////\n\t// Start of ShaderToy Output Compat\n\t//////////////////////////////////////////////////////////////\n\n\tfragColor = outColor;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldX3D7","date":"1371767519","viewed":552,"name":"LoadingOrb","username":"bjarnia","description":"Just some messing around.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["gbx"],"hasliked":0,"parentid":"","parentname":""}}