{"ver":"0.1","info":{"id":"4ltcW8","date":"1604340115","viewed":213,"name":"Fractal with MonteCarlo AA","username":"smarchevsky","description":"Fractal with Monte-carlo sampling","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader was created by Stanislav Marchevskyi\n// feel free to contact: staseg1987 at gmail com\n// t.me/smarchevskyi\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    vec3 col = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    col = col / (vec3(1.) + col);\n    col = vec3(1.) - pow(vec3(1.) - col, vec3(2.));\n    //col = pow(col, vec3(.8));\n    \n    fragColor = vec4(col, 0.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 calcPixel(vec3 dirAndLength){\n    vec2 dir = dirAndLength.xy;\n    float l = dirAndLength.z;\n    \n    float angle = dirToAngle(dir) / 2.;\n    float k = dot((vec2(0, 1)), dir);\n    k = abs(k) * 0.9 + 0.1;\n    //k = max(k, 0.);\n    \n    vec3 col;\n    vec3 rainb = rainbow(angle);\n    col = rainb * k * k * k;\n    col = mix(col, vec3(1.), .01);\n    \n    float scale = 1. / max(l, 0.00001); // inverse length, prevent INF\n    scale = scale / (1. + scale); // sigmoid\n    //col *= pow(scale, 4.);\n    col *= scale * scale;\n    \n    //col = mix(vec3(0.2, 0.0, 1.0), vec3(1.0, 0.5, 0.0), vec3(angle));\n\t\n    return col * min(l * 128., 1.);\n}\n\nvec2 normalizedScreenPos(vec2 fragCoord)\n{\n\treturn (fragCoord / iResolution.xy - .5) * vec2(iResolution.x / iResolution.y, 1.) * 2.;\n}\n\n// image accumulation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mouse = iMouse.xyz;\n    mouse.xy = normalizedScreenPos(mouse.xy);\n        \n    vec3 frame = texture(iChannel0, vec2(0.5) / iResolution.xy).xyz;\n    float resize = step(abs(frame.x - iResolution.x - iMouse.x) + abs(frame.y - iResolution.y - iMouse.y), 0.5);\n    frame.xy = iResolution.xy + iMouse.xy;\n    frame.z = mix(1.0, frame.z + 1.0, resize);\n    \n    \n    vec2 fractalShift = vec2(-mouse.y - 0.5, -mouse.x * 0.5);\n    // do accumulation inside accumulation \n    \n    const int ACCUMULATE_COUNT = 1; // accumulation scale, reduce it, if low FPS\n    \n    vec3 colorAcc = vec3(0);\n    for(int i = 0; i < ACCUMULATE_COUNT; i++){\n        float delta = float(i) / float (ACCUMULATE_COUNT);\n        \n        vec2 hash = hash2(vec3(iTime + delta, fragCoord + vec2(delta)));\n        \n        vec2 shiftedFragCoord = fragCoord + hash.xy * 1.4;\n        vec2 uv = normalizedScreenPos(shiftedFragCoord); // antialiased uv\n        \n        vec3 bokehBlur = vec3(cos(2. * PI * hash.y), sin(2. * PI * hash.y), pow(hash.x, .5)); // x, y, r\n        \n        vec2 fractalUV = uv;\n        // fractalUV += 0.03 * bokehBlur.xy * uv.x; // wanna some bokeh?\n        \n        // fractal core\n        for(int i = 0; i < 64; i++)\n            fractalUV = complexMult(fractalUV, fractalUV) + fractalShift;\n            \n\n        vec3 dirAndL = toDirAndLength(fractalUV);\n        colorAcc += calcPixel(dirAndL);\n    }\n    \n    \n    vec3 finalColor = colorAcc / float(ACCUMULATE_COUNT);\n\n    finalColor *= 10.;\n    // check for nan/inf to fix accumulation\n    finalColor.x = (finalColor.x < 0. || finalColor.x >= 0.) ? finalColor.x : 0.;\n    finalColor.y = (finalColor.y < 0. || finalColor.y >= 0.) ? finalColor.y : 0.;\n    finalColor.z = (finalColor.z < 0. || finalColor.z >= 0.) ? finalColor.z : 0.;\n\n    // accumulation\n    vec3 oldColor = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 accum = mix(oldColor, finalColor, 1.0 / frame.z);\n    fragColor = vec4(mix(accum, frame, step(fragCoord.x + fragCoord.y, 1.5)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define t iTime\n#define PI 3.1415926535\n#define PI_2 PI / 2.0\n#define PI_3 PI / 3.0\n\nfloat hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2) {\n\tp2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 complexMult(vec2 a, vec2 b){\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.y * a.x);\n}\n\nvec3 rainbow(float a){\n    vec3 r = vec3(cos(a), cos(a - PI_3), cos(a - PI_3 * 2.0));\n    return r * r;\n}\n\nfloat dirToAngle(vec2 dir){\n    float angle = atan(dir.y / dir.x) + PI_2;\n    if(dir.x < 0.)\n        angle += PI;\n    return angle;\n}\n\nvec3 toDirAndLength(vec2 uv){\n\t\n    \n    \n    float l = length(uv);\n    vec2 dir = uv / l;\n    l = 1. - l;\n    if(l <= 0. || l > 0.) {\n        l = max(l, 0.);\n    }\n    else {\n        l = 0.;\n        dir = vec2(0., 0.);\n    }\n    \n \t\n    return vec3(dir, l);\n}\n\n\n\n/* to ctreate black hole add this to uv calculations\n    \n    float uvls =  length(uv);\n    vec2 uvdir = uv / uvls;\n    uvls -= pow(0.3/ (uvls),8.);\n    uv = uvls * uvdir;\n*/\n","name":"Common","description":"","type":"common"}]}