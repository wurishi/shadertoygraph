{"ver":"0.1","info":{"id":"MtKBzh","date":"1541861407","viewed":270,"name":"Flob Noise [Signal Inspector]","username":"TinyTexel","description":"flob noise (https://www.shadertoy.com/view/Xs2Bz3) \nplugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// flob noise (https://www.shadertoy.com/view/Xs2Bz3) \n// plugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = pow(textureLod(iChannel0, q, 0.).rgb, vec3(1.0/2.2));\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// flob noise (https://www.shadertoy.com/view/Xs2Bz3) \n// plugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// flob noise (https://www.shadertoy.com/view/Xs2Bz3) \n// plugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n\tvec2 c1 = vec2(cos(ang), sin(ang));\n\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 SmplCircle(float s)\n{\n    return AngToVec(s * Pi2);\n}\n\nfloat FNoise(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n \n    float v4 = Hash12I(uv + vec2(-1.0, 1.0));\n    float v5 = Hash12I(uv + vec2( 1.0, 1.0));\n    float v6 = Hash12I(uv + vec2( 1.0,-1.0));\n    float v7 = Hash12I(uv + vec2(-1.0,-1.0));\n    \n    #define f SmplCircle\n    vec2 vec = (f(v0) + f(v1) + f(v2) + f(v3)) * 0.5 + f(v);\n         vec+= (f(v4) + f(v5) + f(v6) + f(v7)) * 0.25;\n    #undef f\n    \n    #if 0\n    vec = vec2(0.0);\n    float count = 7.0;\n    float w = 0.0;\n    for(float i = -count; i <= count; ++i)\n    for(float j = -count; j <= count; ++j)\n    {\n        vec2 off = vec2(i, j);\n        float w0 = exp2(-(dot(off, off)) * Pow2(0.25));\n        #if 0\n        float l = 0.5;\n        w0 = (off.x == 0.0 ? 1.0 : sin(off.x*l*Pi)/(off.x*l*Pi)) * \n             (off.y == 0.0 ? 1.0 : sin(off.y*l*Pi)/(off.y*l*Pi));\n        #endif\n        vec += SmplCircle(Hash12I(uv + off)) * w0;\n        w += abs(w0);\n    }\n    \n    //vec = (vec / w) - SmplCircle(v)*0.3333;\n    #endif\n    \n    vec = CmplxMul(vec, iTime);\n\n    float vf = 0.0;\n    \n    vf = atan(vec.x, vec.y) / Pi;\n    //vf = vf * 0.5 + 0.5;// flake noise\n    vf = abs(vf);\n    //vf = (length(vec)/w*4.0);\n    //vf = acos(normalize(vec).x)/Pi;\n    \n    return vf;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)\n        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n    p *= globalScale;\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    vec2 uv0 = floor(fragCoord + vec2(1,1.5)*iTime*.0);\n    float n = FNoise(uv0);\n    \n    col = vec3(n);\n    //col = texelFetch(iChannel0, ivec2(uv0) % 1024, 0).xxx;// proper blue noise\n    \n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// bluish noise (https://www.shadertoy.com/view/MdffRN) \n// plugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}