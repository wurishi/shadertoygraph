{"ver":"0.1","info":{"id":"lsKBRD","date":"1527866775","viewed":369,"name":"Mercury SDF","username":"kubamaruszczyk1604","description":" raymarching, reflections, blending and hard shadows","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["reflections","blend","metal","liquid","liquid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define FOV_DEG 80.0\n#define  MAX_STEPS 200\n#define LIGHT_POS vec3(-25.0,19.5,-20.0)\n\n\n// Consts / Enumerations \n#define EPS 0.001\n#define DEG_TO_RAD 0.017453\n#define M_PI 3.141592\n#define HALF_M_PI 1.5707964\n#define FLOOR_PLANE 1\n#define OBJECT  2\n#define NO_HIT  0\n\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 ApplyFog(in vec3 rgb, in float distance) \n{\n    lowp float fogAmount = 1.0 - exp(-distance * 0.013);\n    lowp vec3 fogColor =  vec3(0.01, 0.01, 0.03);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// SDFs\nfloat SphereSDF(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\n\nfloat TorusSDF(vec3 p, float R, float r)\n{\n    \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy, p.z)) - r;\n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.2;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{\n    \n    float d = length(p.xz)-radius;\n    d = max(d, p.y - 1.0);\n    d = max(d,-p.y - 1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y + y;\n}\n\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x, offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float py = p.y;;\n    float c = cos(amount * py);\n    float s = sin(amount * py);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c, -s, s, c);\n    p.xz *= rm;\n    return p;\n}\n\n\nvec3 CheckerBoard2(vec2 uv, vec3 col1, vec3 col2, float granularity)\n{\n    granularity *=0.5;\n    float uplusv = (floor(uv.x * granularity)+ floor(uv.y * granularity));\n    // bool zz = mod(uplusv, 2.0)==0.0;\n    //return zz?col1:col2; \n    return mix(col1, col2, mod(uplusv, 2.0));\n   \n}\n//o.x = diffuse coefficient; o.y = specular coefficient\nvec2 PhongModel(vec3 L, vec3 V, vec3 N)\n{\n    lowp vec2 o = vec2(0);\n    o.x = max(0.0, dot(N, L));\n    \n    lowp  vec3 R = normalize(reflect(L, N)); // L- 2.0 * dot(L, N) * N;\n    o.y = max(pow(dot(R, -V), 100.0), 0.01);  \n    return o;\n}\n\n\n//o.x = diffuse coefficient; o.y = specular coefficient\nvec2 BlinnPhongModel(vec3 L, vec3 V, vec3 N)\n{\n     vec2 o = vec2(0);\n     o.x = max(0.0, dot(N, L));\n    \n     vec3 H = normalize(L + V / length(L + V));\n     o.y  =  max(pow(dot(H, N), 100.0), 0.01);  \n     return o;\n}\n\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      \n      vec3 pn = vec3(0, -0.6, -0.3) + p*vec3(0.4, 0.2, 0.4);\n      pn =  Twist(pn, sin(iTime * 0.942) * 0.22);\n  \n      float sinf035 = sin(iTime*0.15)*0.90;\n      mat3 rmy = CreateRotationY(sinf035*4.925);\n      float sd = BoxSDF(pn.xyz,vec3(0.985)); \n      p = rmy*p + vec3(0,1.2*sin(iTime),0);\n      float  torus = \n          TorusSDF( (p + vec3(10.0 * sinf035,-5.5,0.0)), 2.09, 0.55);\n      float  torus2 = \n          TorusSDF((p + vec3(-10.0 * sinf035,-5.5 ,0.0)), 2.09, 0.55);\n      float  torus3 = \n          TorusSDF( (p + vec3(0.0, -5.5 , 10.0 * sinf035)), 2.09, 0.55);\n      float  torus4 =\n          TorusSDF((p + vec3(0.0, -5.5 , -10.0 * sinf035)), 2.09, 0.55);\n      float  torus5 = \n          TorusSDF((p + vec3(7.07* sinf035, -5.5 ,7.07 * sinf035)), 2.09, 0.55);\n      float  torus6 = \n          TorusSDF((p + vec3(-7.07* sinf035, -5.5, -7.07* sinf035)), 2.09, 0.55);\n    \n      sd = smin(torus, sd, 2.40);\n      sd = smin(torus2, sd, 2.40);\n      sd = smin(torus3, sd, 2.40);\n      sd = smin(torus4, sd, 2.40);\n      sd = smin(torus5, sd, 2.40);\n      sd = smin(torus6, sd, 2.40);\n      float pd =  PlaneSDF(p, 5.2); \n      float fin = min(sd, pd);\n      closest = OBJECT;\n      if(!(abs(fin - pd) > 0.0))\n      { \n          closest = FLOOR_PLANE;\n      }\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    float d = CombineSDF(vec3(p.x , p.y, p.z), dummy);\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - d,\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - d,\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - d\n\t\t));\n}\n\n\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;    \n       int closest = 0; \n        \n       float sd = CombineSDF(p, closest);\n        \n        \n      if(sd < EPS)\n      {\n          hit = closest;\n          return t;\n      }\n      t += sd;\n      \n    }\n    return 1000.0; // infinity\n}\n\n\nint InShadow(vec3 p, vec3 L, out float t)\n{\n    int shadowHit = NO_HIT;\n    Ray sr;\n    sr.Direction = L;\n    sr.Orgin = p + vec3(0.05);     \n    t =  Trace(sr,shadowHit);\n    \n    return shadowHit;\n}\n\nvec3 GetPlaneColor(vec3 hitAt, vec3 L, vec3 N, vec3 V)\n{\n  \n    lowp vec2 planeUV = vec2(hitAt.x + 80.0, hitAt.z) * 0.005;//200.0;  \n    lowp vec3 col = CheckerBoard2(planeUV, vec3(0.2), vec3(0.5), 30.0);\n     col+=  0.5*texture(iChannel1, V).xyz;\n    lowp float shadowT = 0.0;\n    int shadowHit = InShadow(hitAt, L,shadowT);  \n    if(shadowHit > 0)\n    {\n       col *= 0.2;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = 2.0 * uv  - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n   // vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  * HALF_M_PI / 180.0);\n    uv *=fovDist;\n\n    Ray r;\n    r.Direction = CreateRotationX(-0.3 ) * normalize(vec3(uv,1.0));\n    r.Direction *= CreateRotationY(-iTime * 0.1);\n    r.Orgin = CreateRotationY(iTime*0.1) * vec3(-0.0, 7.0,-13.0 + 1.0 * sin(iTime * 0.3));\n\n    lowp vec3 col;  \n    int hit = NO_HIT;  \n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    \n    lowp vec3 lDir = normalize(LIGHT_POS-hitAt); \n    lowp vec3 N = GetNormal(hitAt);\n    \n    if(hit == OBJECT) \n    {     \n        \n        lowp vec2 dCoeff = PhongModel(lDir, r.Direction, N);\n        lowp float b = (1.0 + sin(hitAt.y)) * 0.25;\n        col =  dCoeff.y + vec3(0.0, 0.0, b) * dCoeff.x;\n        \n        \n        \n        //Reflections\n        Ray reflR;\n        int reflHit = 0;\n        reflR.Direction = normalize(reflect(r.Direction,N));\n        reflR.Orgin = hitAt + reflR.Direction * 0.1;\n        float rt = Trace(reflR,reflHit);\n\n        if(reflHit == FLOOR_PLANE)\n        {\n           lowp vec3 pn = (reflR.Direction * rt) * vec3(2.5, 4.34, 1.5);\n           lowp vec2 planeUV = vec2(80.0  + pn.x, pn.z) * 0.005;//200.0;  \n           col = 0.2 * col + 0.8 * CheckerBoard2(planeUV, vec3(0.1), vec3(0.5), 30.0);\n          \n        }\n        else //if(reflHit ==0)\n        {\n          \n          col = 0.2 * col + 0.8 * texture(iChannel0, reflR.Direction).xyz;\n        }   \n        \n         \n        // Shadows\n        float shadowT = 0.0;\n        int shadowHit = InShadow(hitAt+ vec3(0.2)*lDir, lDir,shadowT);\n        if(shadowHit > 0)\n        {\n           col *= 0.5; \n        }\n        \n       // col *= 0.9;\n    }\n\n    else if(hit == FLOOR_PLANE) \n    {\n        col = GetPlaneColor(hitAt, lDir, N, r.Direction);\n\n    }\n    \n    //else // NO HIT\n    //{\n       // col = texture(iChannel0, normalize(r.Direction)).xyz*0.3;\n\n    //}\n    \n    col = ApplyFog(col,length(r.Orgin - hitAt));\n    \n    // Apply gamma correction\n    fragColor = vec4(pow(col, vec3(0.6)), 1.0);\n    \n    fragColor*= 1.1 - pow(length(uv)*0.6,3.0);\n}","name":"Image","description":"","type":"image"}]}