{"ver":"0.1","info":{"id":"lllXzr","date":"1434232467","viewed":278,"name":"BallPuzzle","username":"dila","description":"Looking for a more interesting way to navigate a grid. I think the tilt should really be based on the derivative of the ball position. Let me know if you have a better way to calculate it :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["wood","puzzle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 ballpos = vec3(0.0);\nconst float pcount = 5.0;\n\nvec2 map(vec3 p)\n{\n    float mt = 0.0;\n    float pd = pcount - 1.0;\n    vec2 f = (fract(p.xy*pd) * 2.0 - 1.0) / pd;\n    vec3 q = vec3(f.x, f.y, p.z);\n    float br = 0.1;\n    float c = sdBox(p+vec3(0.0,0.0,0.05), vec3(1.0+br*0.5,1.0+br*0.5,0.1));\n    float b = sdBox(p, vec3(1.2,1.2,0.1));\n    float s = length(p-ballpos) - br/sqrt(2.0);\n    float k = max(b, -c);\n    float m;\n    if (s < k) {\n        m = s;\n        mt = 1.0;\n    } else {\n     \tm = k;\n        mt = 2.0;\n    }\n    float t = max(b, sdBox(q, vec3(br,br,1.0)));\n    float g = m;\n    if (t < m) {\n     \tg = t;\n        mt = 3.0;\n    }\n    return vec2(g, mt);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n    }\n    return t;\n}\n\nvec2 gridpos(float to)\n{\n    float tscale = 1.0;\n    float tnow = (iTime + to) * tscale;\n    float tthen = (iTime + to + 1.0) * tscale;\n    \n    float xnow = floor(tnow) / iChannelResolution[0].x + 0.5;\n    float xthen = floor(tthen) / iChannelResolution[0].x + 0.5;\n    \n    vec3 snow = texture(iChannel0, vec2(xnow, 0.0)).xyz;\n    vec3 sthen = texture(iChannel0, vec2(xthen, 0.0)).xyz;\n    \n    float gs = pcount;\n    \n    snow = floor(snow * gs) / (gs-1.0);\n    sthen = floor(sthen * gs) / (gs-1.0);\n    \n    float ftime = fract(iTime);\n    ftime = smoothstep(0.0, 1.0, ftime) * 2.0;\n    \n    float nx = clamp(ftime-0.0, 0.0, 1.0);\n    float ny = clamp(ftime-1.0, 0.0, 1.0);\n    float nz = clamp(ftime-2.0, 0.0, 1.0);\n    \n    vec3 fpos = mix(snow, sthen, vec3(nx,ny,nz));\n    \n    fpos = fpos * 2.0 - 1.0;\n    \n    return fpos.xy;\n}\n\nvec3 textex(vec3 p)\n{\n\tvec3 ta = texture(iChannel1, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel1, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel1, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.5));\n    \n    vec3 o = vec3(0.0, 0.0, -1.9);\n    \n    ballpos = vec3(gridpos(-1.0), 0.0);\n    \n    vec2 ballnext = gridpos(0.0);\n    \n    float td = -0.1;\n    mat3 xfm = yrot(ballnext.x*pi*td) * xrot(ballnext.y*pi*td);\n    o *= xfm;\n    r *= xfm;\n    \n    o += vec3(0.0, 0.0, 0.0);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    \n    vec3 lpos = o;\n    \n    vec3 ldel = lpos - w;\n    float llen = length(ldel);\n    ldel /= llen;\n    vec3 refl = reflect(ldel, sn);\n    float prod = max(dot(ldel,sn), 0.0);\n    float spow = max(dot(refl,r), 0.0);\n    \n    vec3 diff = textex(w*10.0);\n    vec3 spec = vec3(0.5);\n\n    if (fd.y == 3.0) {\n        diff *= vec3(1.0, 0.5, 0.5);\n    }\n    \n    if (fd.y == 1.0) {\n        diff = vec3(1.0);\n        spec = vec3(1.0);\n    }\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 100.0);\n    \n    vec3 fc = (diff * prod + spec * spow) * fog;\n    \n    if (t > 10.0) {\n        fc = texture(iChannel1, uv).xyz;\n    }\n    \n\tfragColor = vec4(fc, 1.0);\n}","name":"Image","description":"","type":"image"}]}