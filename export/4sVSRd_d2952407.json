{"ver":"0.1","info":{"id":"4sVSRd","date":"1466076000","viewed":1231,"name":"POV-Ray tilings","username":"bergi","description":"Tiling functions from the popular [url]http://povray.org[/url] raytracer. ","likes":38,"published":3,"flags":0,"usePreview":0,"tags":["pattern","tiling","hexagonal","povray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Povray tiling & pavement functions \n   License aGPLv3 \n\n   Original code by J. Gimbert\n   See https://github.com/POV-Ray/povray/blob/master/source/core/material/pattern.cpp\n\n   Lazily converted to GLSL by S. Berke\n\n   The pattern.cpp is a useful resource for all kinds of 2d effects and part of the\n   reason for povray's popularity - in the old days, at least ;)\n   I only adjusted the function return values for the tiling functions,\n   everything else is kept as-is. There are much more tilings in the original source \n   but they will be harder to convert to GLSL ES due to the lack of arrays. \n\n   original copyright notice: \n */\n/// Persistence of Vision Ray Tracer ('POV-Ray') version 3.7.\n/// Copyright 1991-2016 Persistence of Vision Raytracer Pty. Ltd.\n///\n/// POV-Ray is free software: you can redistribute it and/or modify\n/// it under the terms of the GNU Affero General Public License as\n/// published by the Free Software Foundation, either version 3 of the\n/// License, or (at your option) any later version.\n///\n/// POV-Ray is distributed in the hope that it will be useful,\n/// but WITHOUT ANY WARRANTY; without even the implied warranty of\n/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n/// GNU Affero General Public License for more details.\n///\n/// You should have received a copy of the GNU Affero General Public License\n/// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n///\n/// ----------------------------------------------------------------------------\n///\n/// POV-Ray is based on the popular DKB raytracer version 2.12.\n/// DKBTrace was originally written by David K. Buck.\n/// DKBTrace Ver 2.0-2.12 were written by David K. Buck & Aaron A. Collins.\n  \n\n\n/* ----- Interface -----\n\n   pov_tiling*() functions return\n     x: distance to inside, outside = 1.\n     y: shape index 0-2 (when there are different shapes in one pattern)\n*/\n\nvec2 pov_tiling_square(in vec2 p);\nvec2 pov_tiling_square_offset(in vec2 p);\nvec2 pov_tiling_hexagon(in vec2 p);\nvec2 pov_tiling_triangle(in vec2 p);\nvec2 pov_tiling_lozenge(in vec2 p);\nvec2 pov_tiling_rhombus(in vec2 p);\nvec2 pov_tiling_rectangle(in vec2 p);\nvec2 pov_tiling_octa_square(in vec2 p);\nvec2 pov_tiling_square_triangle(in vec2 p);\nvec2 pov_tiling_hexa_triangle(in vec2 p);\n\n/* One function to get all, pattern = 0-9 */\nvec2 pov_tiling(in vec2 p, in int pattern)\n{\n\tif (pattern == 0) return pov_tiling_square(p);\n\tif (pattern == 1) return pov_tiling_square_offset(p);\n\tif (pattern == 2) return pov_tiling_hexagon(p);\n\tif (pattern == 3) return pov_tiling_triangle(p);\n\tif (pattern == 4) return pov_tiling_lozenge(p);\n\tif (pattern == 5) return pov_tiling_rhombus(p);\n\tif (pattern == 6) return pov_tiling_rectangle(p);\n\tif (pattern == 7) return pov_tiling_octa_square(p);\n\tif (pattern == 8) return pov_tiling_square_triangle(p);\n\tif (pattern == 9) return pov_tiling_hexa_triangle(p);\n\treturn vec2(-1, 0.);\n}\n\n\n// ########################## IMPLEMENTATION ###########################\n\n#define POV_SQRT3_2     0.86602540378443864676372317075294  ///< sqrt(3)/2\n#define POV_SQRT3       1.7320508075688772935274463415059   ///< sqrt(3)\n#define POV_SQRT2       1.4142135623730950488016887242097   ///< sqrt(2)\n#define POV_SQRT2_2     0.70710678118654752440084436210485  ///< sqrt(2)/2\n\nvec2 pov_tiling_square(in vec2 p)\n{\n    p = abs(p);\n\tvec2 x = p - floor(p);\n\tx = 2. * abs(x - .5);\n\treturn vec2(max(x.x, x.y), 0.);\n}\n\nvec2 pov_tiling_hexagon(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x += 0.5;\n\tx.x -= 3.0*floor(x.x/3.0);\n\tx.y -= POV_SQRT3*floor(x.y/POV_SQRT3);\n\t/* x,z is in { [0.0, 3.0 [, [0.0, SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t\tx.y = POV_SQRT3 - x.y;\n\t/* \n\t ** Now only [0,3[,[0,SQRT3/2[\n\t */\n\tif (x.x > 1.5)\n\t{\n\t\tx.x -= 1.5; /* translate */\n\t\tx.y = POV_SQRT3_2 - x.y; /* mirror */\n\t}\n\t/*\n\t ** And now, it is even simpler :  [0,1.5],[0,SQRT3/2]\n\t ** on the bottom left corner, part of some other hexagon\n\t ** on the top right corner, center of the hexagon\n\t */\n\tif ((POV_SQRT3*x.x + x.y) < POV_SQRT3_2)\n\t{\n\t\tx.x = 0.5 - x.x;\n\t\tx.y = POV_SQRT3_2 - x.y; /* mirror */\n\t}\n\tif (x.x > 1.0)\n\t{\n\t\tx.x = 2.0 - x.x; /* mirror */\n\t}\n\t/* Hexagon */\n\treturn vec2(clamp(\n\t\t\t\tmax(1. - x.y / POV_SQRT3_2,\n                    1. - ((POV_SQRT3 * x.x + x.y - POV_SQRT3_2) / POV_SQRT3)\n\t\t\t\t), 0., 1.), 0.);\n}\n\nvec2 pov_tiling_triangle(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x -= floor(x.x);\n\tx.y -= POV_SQRT3 * floor(x.y/POV_SQRT3);\n\tfloat delta = 0.;\n\t/* x,z is in { [0.0, 1.0 [, [0.0, SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t{\n\t\tx.y = POV_SQRT3 - x.y; /* mirror */\n\t\tdelta = 1.-delta;\n\t}\n\tif (x.x > 0.5)\n\t{\n\t\tx.x = 1.0 - x.x; /* mirror */\n\t}\n\tif (x.x != 0.0)\n\t{\n\t\tfloat slop1 = x.y / x.x;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tx.y = POV_SQRT3_2 - x.y;\n\t\t\tx.x = 0.5 - x.x;\n\t\t\tdelta = 1.-delta;\n\t\t}\n\t}\n\telse\n\t{\n\t\tx.y = POV_SQRT3_2 - x.y;\n\t\tx.x = 0.5;\n\t}\n\tfloat d1 = 1. - (x.y * 2. * POV_SQRT3);\n\tfloat d2 = 1. - ((POV_SQRT3 * x.x - x.y) * POV_SQRT3);\n\treturn vec2(max(d1, d2), delta);\n//\treturn delta>.5 ? max(d1, d2)*.5 : 1.-.5*max(d1, d2); \n\t// XXX original, not sure if this is right??\n\t//return delta*.5 + .5 * max(d1, d2);\n}\n\nvec2 pov_tiling_lozenge(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x -= floor(x.x);\n\tx.y -= POV_SQRT3*floor(x.y/POV_SQRT3);\n\t/* x,z is in { [0.0, 1.0 [, [0.0, SQRT3 [ } \n\t ** There is some mirror to reduce the problem\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t{\n\t\tx.y -= POV_SQRT3_2;\n\t\tx.x += 0.5;\n\t}\n\tif ((2.*x.y) > POV_SQRT3_2)\n\t{\n\t\tx.y = POV_SQRT3_2 - x.y;\n\t\tx.x = 1.5 - x.x;\n\t}\n\tif (x.x > 0.75)\n\t{\n\t\tx.x -= 1.0;\n\t}\n\tif (x.x != 0.0)\n\t{\n\t\tfloat slop1 = x.y / x.y;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tx.y = POV_SQRT3_2 - x.y;\n\t\t\tx.x = 0.5 - x.x;\n\t\t}\n\t}\n\tfloat d1 = 1.0 - (x.y * 4.0 * POV_SQRT3 / 3.0 );\n\tfloat d2 = 1.0 - (abs(POV_SQRT3 * x.x - x.y) * POV_SQRT3 * 2.0 / 3.0);\n\treturn vec2(max(d1, d2), 0.);\n}\n\nvec2 pov_tiling_rhombus(in vec2 p)\n{\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx += 0.5;\n\tx -= 3.0*floor(x/3.0);\n\tz -= POV_SQRT3*floor(z/POV_SQRT3);\n\t/* x,z is in { [0.0, 3.0 [, [0.0, SQRT3 [ } \n\t ** There is some mirror to reduce the problem\n\t */\n\tif ( z > POV_SQRT3_2 )\n\t{\n\t\tz = POV_SQRT3 -z; /* mirror */\n\t\tdelta = 2. - delta;\n\t}\n\tif (x > 1.5)\n\t{\n\t\tx -= 1.5 ; /* translate */\n\t\tz = POV_SQRT3_2 -z; /* mirror */\n\t\tdelta = 2. - delta;\n\t}\n\t/* Now in [0,1.5],[0,SQRT3/2] \n\t ** from left to right\n\t ** part of a horizontal (z=0)\n\t ** half a vertical \n\t ** part of a horizontal \n\t */\n\tif (x < 0.5)\n\t{\n\t\t/* mirrror */\n\t\tx = 1.0 - x;\n\t\tdelta = 2. - delta;\n\t}\n\t/* \n\t ** Let shift the [0.5,1.5],[0,SQRT3/2] to [0,1]....\n\t */\n\tx -= 0.5;\n\tif (x != 0.0)\n\t{\n\t\tfloat slop1 = z/x;\n\t\tif (slop1>POV_SQRT3)\n\t\t{ /* rotate the vertical to match the horizontal on the right */\n\t\t\tfloat dist1 = ( x / 2.0 ) + ( z * POV_SQRT3_2 );\n\t\t\tfloat dist2 = ( z / 2.0 ) - ( x * POV_SQRT3_2 );\n\t\t\tz = dist2;\n\t\t\tx = dist1;\n\t\t\tdelta = 1.;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* rotate the vertical to match the horizontal on the right */\n\t\tfloat dist1 = ( x / 2.0 ) + ( z * POV_SQRT3_2 );\n\t\tfloat dist2 = ( z / 2.0 ) - ( x * POV_SQRT3_2 );\n\t\tz = dist2;\n\t\tx = dist1;\n\t\tdelta = 1.;\n\t}\n\t/* It may be similar to lozenge (in fact, IT IS !), now */\n\n\tif ( (2.0*z) > POV_SQRT3_2 )\n\t{\n\t\tz = POV_SQRT3_2 - z;\n\t\tx = 1.5 - x;\n\t}\n\tif (x > 0.75)\n\t{\n\t\tx -= 1.0;\n\t}\n\tif (x != 0.0)\n\t{\n\t\tfloat slop1 = z / x;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tz = POV_SQRT3_2 - z;\n\t\t\tx = 0.5 -x;\n\t\t}\n\t}\n\tfloat d1 = 1.0 - (z * 4.0 * POV_SQRT3 / 3.0 );\n\tfloat d2 = 1.0 - (abs(POV_SQRT3 * x - z) * POV_SQRT3 *2.0 / 3.0);\n\treturn vec2(clamp(max(d1, d2), 0., 1.), delta);\n\t// original\n\t//return clamp( (max(d1, d2) + delta) / 3., 0., 1.);\n}\n\nvec2 pov_tiling_rectangle(in vec2 po)\n{\n\t/*\n\t ** Tiling with rectangles\n\t ** resolve to square [0,4][0,4]\n\t ** then 16 cases\n\t **\n\t **  +-----+--+  +\n\t **  |     |  |  |\n\t **  +--+--+  +--+\n\t **     |  |  |\n\t **  +--+  +--+--+\n\t **  |  |  |     |\n\t **  +  +--+--+--+\n\t **  |  |     |  |\n\t **  +--+-----+  +\n\t */\n\tfloat x = po.x, z = po.y, \n\t\t  delta = 1.;\n\tx -= 4.0*floor(x/4.0);\n\tz -= 4.0*floor(z/4.0);\n    int idx = int(x) + 4*int(z);\n\tif (idx == 0 || idx == 4)\n\t\tz -= 1.0;\n    if (idx == 1 || idx == 2)\n\t\tx -= 2.0, delta = 0.0;\n\tif (idx == 3)\n\t\tx -= 3.0;\n\tif (idx == 5 || idx == 9)\n\t\tx -= 1.0, z -= 2.0;\n\tif (idx == 6 || idx == 7)\n\t\tx -= 3.0, z -= 1.0, delta = 0.0;\n    if (idx == 8)\n\t\tz -= 2.0, delta = 0.0;\n\tif (idx == 10 || idx == 14)\n\t\tx -= 2.0, z -= 3.0;\n\tif (idx == 11)\n\t\tx -= 4.0, z -= 2.0, delta = 0.0;\n\tif (idx == 12 || idx == 13)\n\t\tx -= 1.0, z -= 3.0, delta = 0.0;\n\tif (idx == 15)\n\t\tx -= 3.0, z -= 4.0;\n\n    if (delta >= 1.0)\n\t{\n\t\tx = 2.*abs(x - 0.5);\n\t\tz = 2.*(max(abs(z), 0.5) - 0.5);\n\t}\n\telse\n\t{\n\t\tx = 2.*(max(abs(x), 0.5) - 0.5);\n\t\tz = 2.*abs(z - 0.5);\n\t}\n\treturn vec2(max(x, z), delta);\n//\treturn delta>.5 ? max(x, z)*.5 : 1.-.5*max(x, z); \n\t// XXX original\n//\treturn abs(max(x, z) + delta) / 2.;\n}\n\n\nvec2 pov_tiling_octa_square (in vec2 p)\n{\n\t/*\n\t ** Tiling with a square and an octagon\n\t */\n\tvec2 x = p;\n\tx -= (POV_SQRT2+1.0) * floor(x/(POV_SQRT2+1.0));\n\tx -= POV_SQRT2_2 + 0.5;\n\tx = abs(x);\n\tif (x.y > x.x)\n\t\tx = x.yx;\n\tif ((x.x+x.y) < POV_SQRT2_2)\n\t{\n\t\t/* Square tile */\n\t\treturn vec2((x.x+x.y) / POV_SQRT2, 0.);\n\t}\n\tfloat dist1 = 1.0-x.y;\n\tfloat dist2 = (POV_SQRT2 + POV_SQRT2_2-(x.x+x.y))/POV_SQRT2;\n\treturn vec2(max(0., 0.19+.81*max(dist1,dist2)), 1.); \n}\n\nvec2 pov_tiling_square_triangle(in vec2 p)\n{\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx -= floor(x);\n\tz -= (2.0+POV_SQRT3)*floor(z/(POV_SQRT3+2.0));\n\t/* x,z is in { [0.0, 1.0 [, [0.0, 2+SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (z > POV_SQRT3_2+1.0 )\n\t{\n\t\tz -= POV_SQRT3_2+1.0;\n\t\tx += (x>0.5)?-0.5:0.5;\n\t}\n\tif (x > 0.5)\n\t{\n\t\tx = 1.0 - x; /* mirror */\n\t}\n\tz -= 1.0;\n\tif (z > 0.0)\n\t{ /* triangle */\n\t\tif (x != 0.0)\n\t\t{\n\t\t\tif (z/x > POV_SQRT3)\n\t\t\t{\n\t\t\t\tz = POV_SQRT3_2 - z;\n\t\t\t\tx = 0.5 - x;\n\t\t\t\tdelta = 1. - delta;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tz = POV_SQRT3_2 - z;\n\t\t\tx = 0.5;\n\t\t\tdelta = 1. - delta;\n\t\t}\n\t\tfloat dist1 = 1.0 - (2. * z * POV_SQRT3);\n\t\tfloat dist2 = 1.0 - ((POV_SQRT3 * x - z) * POV_SQRT3);\n\t\treturn vec2(max(dist1, dist2), delta);\n\t}\n\telse\n\t{ /* square */\n\t\tif (z < -0.5)\n\t\t{\n\t\t\tz = -1.0 - z;\n\t\t}\n\t\tif (x > 0.5)\n\t\t{\n\t\t\tx = 1.0 - x;\n\t\t}\n\t\treturn vec2((1.000000-2.*min(abs(x),abs(z))), 2.);\n\t}\n}\n\nvec2 pov_tiling_hexa_triangle(in vec2 p)\n{\n\t/* \n\t ** Tiling with a hexagon and 2 triangles\n\t */\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx -= 2.0*floor(x/2.0);\n\tz -= 2.0*POV_SQRT3*floor(z/(POV_SQRT3*2.0));\n\t/* x,z is in { [0.0, 2.0 [, [0.0, 2*SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (z > POV_SQRT3)\n\t{\n\t\tz -= POV_SQRT3;\n\t\tx += (x<1.0)?1.0:-1.0;\n\t}\n\t/* \n\t ** Now only [0,2[,[0,SQRT3[\n\t */\n\tif (z > POV_SQRT3_2)\n\t{\n\t\tz = POV_SQRT3 - z; /* mirror */\n\t\tdelta = 1. - delta;\n\t}\n\n\tif (x > 1.0)\n\t{\n\t\tx = 2.0 - x; /* mirror */\n\t}\n\t/*\n\t ** And now, it is even simpler :  [0,1],[0,SQRT3/2]\n\t ** on the bottom left corner, part of the triangle\n\t ** on the top right corner, center of the hexagon\n\t */\n\tif ((POV_SQRT3*x+z)<POV_SQRT3_2)\n\t{\n\t\t/* Triangle */\n\t\tfloat dist1 = 1.0 - (z * 2. * POV_SQRT3);\n\t\tfloat dist2 = 1.0 + ((POV_SQRT3 * x + z) - POV_SQRT3_2) * POV_SQRT3; \n\t\t\t/*< really substracting */\n\t\treturn vec2(max(dist1,dist2), delta);\n\t}\n\telse\n\t{\n\t\t/* Hexagon */\n\t\tfloat dist1 = 2. + 2. * (z * POV_SQRT3);\n\t\tfloat dist2 = 2. + 2. * ((POV_SQRT3 * x + z - POV_SQRT3_2) ) * POV_SQRT3_2;\n\t\treturn vec2((5.0-min(dist1,dist2)) / 3., 2.);\n\t\t// TODO FIXME - magic number! Should use nextafter()\n\t}\n}\n\nvec2 pov_tiling_square_offset(in vec2 p)\n{\n\t/*\n\t ** Tiling with a square, offset of half size\n\t ** Reduce to rectangle [0,1][0,2]\n\t ** move x,[1,2] to [0,1][0,1] with new x = x+1/2\n\t */\n\tvec2 x = vec2(p.x, p.y - 2.*floor(p.y/2.));\n\tif (x.y > 1.0)\n\t{\n\t\tx.x += 0.5;\n\t\tx.y -= 1.;\n\t}\n\tx.x -= floor(x.x);\n\tx = 2.*abs(x-0.5);\n\treturn vec2(max(x.x, x.y), 0.);\n}\n\n// #################################################################\n\n\n\nfloat hash1(in vec2 p) { return fract(sin(p.x+p.y)*(73481.+p.x*1.3-p.y*1.7)); }\n\nvec3 tiling_color(in vec2 uv, in vec2 seed, in float time)\n{\n    int   pattern = int(hash1(seed++)*9.99);\n    float soft = hash1(seed++); soft *= soft * soft;\n    float thick = 0.01 + .1*hash1(seed++);\n    float scale = 2. + 5. * hash1(seed++);\n            \n    uv += 0.2*time*vec2(hash1(seed++)-.5, hash1(seed++)-.5);\n    vec2 tile = pov_tiling(uv*scale, pattern);\n    \n    vec3 col = vec3(1.);//.5+.5*cos(hash1(seed++)*vec3(1.7+uv.y,1.1+uv.x,2.1)*6.*hash1(seed++));\n\n    float rep = .2 + (1.-thick) * .8 * hash1(seed++ + tile.y);\n    tile.x = mod(tile.x+.5*rep, rep)-.5*rep;\n    col *= smoothstep(soft+0.015*scale, .0, abs(tile.x)-thick);\n        \n    if (hash1(seed) > .6)\n    \tcol = 1. - col;\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float ti = iTime*1.3; // change multiplier for animation speed\n    float mti = mod(ti, 1.);\n    \n    vec3 col1 = tiling_color(uv, vec2(1., 1.1) * floor(ti), ti),\n    \t col2 = tiling_color(uv, vec2(1., 1.1) * floor(ti+1.), ti),\n    \t col = mix(col1, col2, mti*mti*(3.-2.*mti));    \n    \n    col *= pow(1.-.707*length(suv*2.-1.), .2);\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}