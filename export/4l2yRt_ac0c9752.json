{"ver":"0.1","info":{"id":"4l2yRt","date":"1509808058","viewed":132,"name":"Cake - codevember #2","username":"cvelenosi","description":"Cake I made for the second day of Codevember 2017, still understanding the way of the raymarch. Distance functions and operators by iq (https://www.shadertoy.com/view/Xds3zN)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","beginner","cake","codevember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nvec2 objectUnion(vec2 ob1, vec2 ob2)\n{\n    return (ob1.x < ob2.x) ? ob1 : ob2;\n}\n\nvec3 waveDeform(vec3 p)\n{\n    p.y = p.y + (sin(p.x * 15.) * cos(p.z * 15.) * .05) * (p.y > 0. ? 0. : 1.);\n    return p;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCappedCylinder( vec3 p, vec2 h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n\nvec2 map(vec3 p) {\n    vec2 d = objectUnion(vec2(sdCappedCylinder(p - vec3(0, -.7, -3), vec2(1, 0.3)), 1),\n                         vec2(sdCappedCylinder(p - vec3(0, -.05, -3), vec2(1, 0.3)), 1)); \n    d = objectUnion(d, vec2(sdRoundCappedCylinder(waveDeform(p - vec3(0, 0, -3)), vec2(1, 0.25), 0.05), 2));\n    d = objectUnion(d, vec2(sdRoundCappedCylinder(p - vec3(0, -.45, -3), vec2(0.95, 0.015), 0.05), 3));\n    //d = objectUnion(d, vec2(sdCappedCylinder(p - vec3(0, 0.5, -3), vec2(0.03, 0.25)), 5));\n    d = objectUnion(d, vec2(p.y + 1., 4));                            // horizontal plane at y = -1\n    return d;\n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy).x +\n        e.yyx * map(p + e.yyx).x +\n        e.yxy * map(p + e.yxy).x +\n        e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float maxDist, float k){\n    float res = 1.;\n    float t = 0.1;\n    \n\tfor (int i = 0; i < 32; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        \n        if (h.x < 0.01)\n            break;\n    \t\n        res = min(res, k*h.x/t);\n        t += clamp(h.x, 0.02, 0.1);\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 1, 3);                           // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    \n    vec3 ta = vec3(0, .5, 0 );\n        // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(q.xy,2.0) );\n    \n    // March the distance field until a surface is hit.\n    vec2 h; \n    float t = 1.;\n    for (int i = 0; i < 256; i++) {\n        h = map(ro + rd * t);\n        t += h.x;\n        if (h.x < 0.01) break;\n    }\n\n    if (h.x < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n        \n        float shadow = calcShadow(p, normalize(light - p), length(light - p), 6.);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        //dif *= 5. / dot(light - p, light - p);\n        \n        vec3 objectColor;\n        if (h.y == 1.)\n            objectColor = vec3(0.349, 0.204, 0.031);\n        else if (h.y == 2.)\n            objectColor = vec3(0.976, 0.505, 0.815);\n        else if (h.y == 3.)\n            objectColor = vec3(0.847, 0.815, 0.847);\n        else if (h.y == 4.)\n        {\n            vec2 uv = floor(3. * p.xz);\n            objectColor = vec3(0.976, 1, 0.647);\n        }\n        else if (h.y == 5.)\n        {\n            vec3 stripeColor = vec3(0.929, 0.568, 0.129);\n         \tvec2 uv = floor(15. * p.xz);\n            float factor = mod(uv.x, 2.);\n            objectColor = factor > 0.5 ? stripeColor : vec3(1);\n        }\n        else\n            objectColor = vec3(1);\n            \n        objectColor *= shadow;\n        \n        fragColor = vec4(pow(dif, 0.4545) * objectColor, 1);     // Gamma correction\n    } else {\n        fragColor = vec4(0.588, 0.588, 0.588, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}