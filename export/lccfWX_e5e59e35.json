{"ver":"0.1","info":{"id":"lccfWX","date":"1733546064","viewed":25,"name":"comprehension","username":"vivavolt","description":"layered perspectives","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvoid rot(inout vec3 p, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    mat3 m = mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n    );\n    p = m * p;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = step(p.yzx, p.xyz) * step(p.zxy, p.xyz);\n    return m * 0.57735027;\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(234.34, 435.345));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nvec3 foldRotate(vec3 p, float timeOffset) {\n    float t = iTime * 0.2 + timeOffset;\n    rot(p, vec3(sin(t), cos(t), 0.5), t * 0.3);\n    \n    for(int i = 0; i < 5; i++) {\n        p = abs(p);\n        rot(p, vec3(0.707, 0.707, 0.0), 0.785);\n        p -= 0.5 * smoothstep(-1.0, 1.0, sin(iTime * 0.1 + timeOffset));\n    }\n    return p;\n}\n\nfloat map(vec3 p, float timeOffset) {\n    p = foldRotate(p, timeOffset);\n    float d = sdOctahedron(p, 1.0);\n    float noise = sin(p.x * 10.0 + iTime + timeOffset) * \n                 sin(p.y * 10.0) * \n                 sin(p.z * 10.0) * 0.1;\n    return d + noise;\n}\n\nvec3 calcNormal(vec3 p, float timeOffset) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy, timeOffset) - map(p - e.xyy, timeOffset),\n        map(p + e.yxy, timeOffset) - map(p - e.yxy, timeOffset),\n        map(p + e.yyx, timeOffset) - map(p - e.yyx, timeOffset)\n    ));\n}\n\nvec3 palette(float t, int layer) {\n    vec3[3] a = vec3[](\n        vec3(0.01, 0.012, 0.015),\n        vec3(0.012, 0.01, 0.015),\n        vec3(0.01, 0.013, 0.015)\n    );\n    vec3[3] b = vec3[](\n        vec3(0.03, 0.03, 0.04),\n        vec3(0.035, 0.025, 0.04),\n        vec3(0.025, 0.035, 0.04)\n    );\n    \n    float noise = hash21(vec2(t, float(layer))) * 0.01;\n    return a[layer] + b[layer] * (0.5 + 0.5 * sin(t * PI * 2.0)) + noise;\n}\n\nvec3 render(vec3 ro, vec3 rd, float timeOffset, int layer) {\n    float t = 0.0;\n    float maxd = 10.0;\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p, timeOffset);\n        \n        if(d < 0.001) {\n            vec3 n = calcNormal(p, timeOffset);\n            vec3 r = reflect(rd, n);\n            float f = dot(n, vec3(0.57735));\n            \n            float microDetail = hash21(p.xy * 100.0 + timeOffset) * 0.02;\n            vec3 baseCol = palette(f * 0.5 + 0.5 + microDetail, layer);\n            \n            float spec = pow(max(dot(r, normalize(vec3(1.0, 1.0, -1.0))), 0.0), 128.0) * 0.15;\n            col = baseCol + spec * vec3(0.05, 0.06, 0.08);\n            col *= exp(-t * 0.25);\n            break;\n        }\n        \n        if(t > maxd) break;\n        t += d * 0.5;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 noise = vec2(hash21(fragCoord), hash21(fragCoord + 1.0)) * 0.001;\n    vec2 uv = ((fragCoord + noise) * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro1 = vec3(0.0, 0.0, -4.0);\n    vec3 rd1 = normalize(vec3(uv, 2.0));\n    rot(ro1, vec3(1.0, 1.0, 0.0), iTime * 0.12);\n    rot(rd1, vec3(1.0, 1.0, 0.0), iTime * 0.12);\n    vec3 col1 = render(ro1, rd1, 0.0, 0);\n    \n    vec3 ro2 = vec3(0.0, 0.0, -4.0);\n    vec3 rd2 = normalize(vec3(uv, 2.0));\n    rot(ro2, vec3(0.0, 1.0, 1.0), -iTime * 0.15);\n    rot(rd2, vec3(0.0, 1.0, 1.0), -iTime * 0.15);\n    vec3 col2 = render(ro2, rd2, PI * 0.66, 1);\n    \n    vec3 ro3 = vec3(0.0, 0.0, -4.0);\n    vec3 rd3 = normalize(vec3(uv, 2.0));\n    rot(ro3, vec3(1.0, 0.0, 1.0), iTime * 0.13);\n    rot(rd3, vec3(1.0, 0.0, 1.0), iTime * 0.13);\n    vec3 col3 = render(ro3, rd3, PI * 1.33, 2);\n    \n    float i12 = length(col1 - col2) * 20.0 + hash21(uv + iTime) * 0.1;\n    float i23 = length(col2 - col3) * 20.0 + hash21(uv - iTime) * 0.1;\n    float i31 = length(col3 - col1) * 20.0 + hash21(uv + vec2(iTime)) * 0.1;\n    \n    vec3 finalCol = col1;\n    finalCol = mix(finalCol, col2, smoothstep(0.4, 0.6, sin(i12)));\n    finalCol = mix(finalCol, col3, smoothstep(0.4, 0.6, sin(i23)));\n    finalCol = mix(finalCol, col1, smoothstep(0.4, 0.6, sin(i31)));\n    \n    float microNoise = hash21(uv * 512.0 + iTime) * 0.01;\n    finalCol += vec3(microNoise);\n    \n    float edgeIntensity = \n        smoothstep(0.01, 0.0, abs(i12 - i23)) +\n        smoothstep(0.01, 0.0, abs(i23 - i31)) +\n        smoothstep(0.01, 0.0, abs(i31 - i12));\n    finalCol += vec3(0.02, 0.025, 0.03) * edgeIntensity;\n    \n    finalCol += (hash21(fragCoord) - 0.5) * 0.01;\n    \n    float dither = hash21(fragCoord + iTime) * 0.001;\n    finalCol = pow(finalCol + dither, vec3(0.45));\n    \n    float vignette = smoothstep(2.8, 0.3, length(uv)) * 0.99 + 0.15;\n    finalCol *= vignette;\n    \n    fragColor = vec4(finalCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}