{"ver":"0.1","info":{"id":"3ds3Rr","date":"1544747338","viewed":196,"name":"Shine A","username":"ShadowFlare","description":"Shine\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//float shininess = 1.0;\nconst int mode = 2;\nconst float pi = 2.0*acos(0.0);\n\nfloat ggx (in vec2 N, in vec2 V, in vec2 L, in float roughness, in float F0) {\n  float alpha = roughness*roughness;\n  vec2 H = normalize(L - V);\n  float dotLH = max(0.0, dot(L,H));\n  float dotNH = max(0.0, dot(N,H));\n  float dotNL = max(0.0, dot(N,L));\n  float alphaSqr = alpha * alpha;\n  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n  float D = alphaSqr / (pi * denom * denom);\n  float F = F0 + (1.0 - F0) * pow(1.0 - dotLH, 5.0);\n  float k = 0.5 * alpha;\n  float k2 = k * k;\n  return dotNL * D * F / (dotLH*dotLH*(1.0-k2)+k2);\n}\nvec2 normals(vec2 pos) {\n  vec3 _pos = vec3(pos.xy, pos.x-pos.y);\n  vec3 fdx = dFdx(_pos);\n  vec3 fdy = dFdy(_pos);\n  return normalize(cross(fdx, fdy).xy);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightPower = 1.0;\n    vec2 lightPos = iMouse.xy/iResolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 lightDir = lightPos - uv;\n    float dist = length(lightDir);\n    dist *= dist;\n    vec2 normal = normals(fragCoord);\n    float shininess = texture(iChannel0, uv).r*2.0;\n    lightDir = normalize(lightDir);\n    float lambertian = max(dot(lightDir,normal), 0.0);\n    float spec = 0.0;\n    if(lambertian > 0.0) {\n    //lambertian *= sign(dot(lightDir,normal));\n    vec2 viewDir = -normalize(uv.xy);\n\n    // this is blinn phong\n    vec2 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(normal, halfDir), 0.0);\n    spec = pow(specAngle, shininess);\n    // this is phong (for comparison)\n    if(mode == 2) {\n      vec2 reflectDir = reflect(-lightDir, normal);\n      specAngle = max(dot(reflectDir, viewDir), 0.0);\n      // note that the exponent is different here\n      spec = pow(specAngle, shininess/4.0);\n    } else if (mode == 3) {\n     \t float a = acos(specAngle);\n         spec = exp(-pow(tan(a), 2.0)/pow(shininess, 2.0))/(pi*pow(shininess, 2.0)*pow(cos(a), 4.0));\n    } else if (mode == 4) {\n     \tspec = ggx(normal, viewDir, lightDir, shininess, 1.1);\n    }\n    }\n    vec3 colorLinear = texture(iChannel2, uv).rgb +\n                     texture(iChannel1, uv).rgb * lambertian * lightColor * lightPower / dist +\n                     (texture(iChannel1, uv).rgb*5.0) * spec * lightColor * lightPower / dist;\n\t//float spec = pow(dot(normal, halfangle), n);\n    // Time varying pixel color\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n    vec3 col = colorGammaCorrected;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}\n        ","name":"Image","description":"","type":"image"}]}