{"ver":"0.1","info":{"id":"MfccWl","date":"1731329784","viewed":19,"name":"Informatique_graphique","username":"skala","description":"Informatique graphique","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["informatiquegraphique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\n\n// couts\n\n// Opérations de base :\n// \n//     Addition/Soustraction : 1\n//     Multiplication : 1\n//     Division : 3 (généralement plus coûteuse que la multiplication)\n// \n// Fonctions mathématiques :\n// \n//     Racine carrée : 20\n//     Puissance (pow) : 25\n//     Fonctions trigonométriques (sin, cos, tan) : 30\n//     Logarithme : 30\n//     Exponentielle : 30\n// \n// Opérations vectorielles :\n// \n//     Produit scalaire (dot product) : 3 (multiplications + additions)\n//     Produit vectoriel (cross product) : 6\n//     Normalisation de vecteur : 25 (inclut une racine carrée)\n\n\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nstruct Material {\n    vec3 color;      // Couleur de base de l'objet\n    float ambient;   // Coefficient ambiant\n    float diffuse;   // Coefficient diffus\n    float specular;  // Coefficient spéculaire\n    float reflective; // Niveau de réflexion (0.0 = mat, 1.0 = très réfléchissant)\n};\n\n// Déclaration des matériaux globaux\nMaterial blackMaterial;\nMaterial whiteMaterial;\nMaterial blueMaterial;\nMaterial mirrorMaterial;\nMaterial redMirrorMaterial;\nMaterial metalMaterial;\nMaterial orangeMaterial;\n\n\n// Initialisation des matériaux dans une fonction d'initialisation (par exemple dans main)\nvoid initializeMaterials() {\n    // Matériau noir\n    blackMaterial.color = vec3(0.0, 0.0, 0.0); // Noir pour les cellules\n    blackMaterial.ambient = 0.3;\n    blackMaterial.diffuse = 0.7;\n    blackMaterial.specular = 0.2;\n    blackMaterial.reflective = 0.1; // Légèrement réfléchissant\n\n    // Matériau blanc\n    whiteMaterial.color = vec3(1.0, 1.0, 1.0); // Blanc pour les cellules\n    whiteMaterial.ambient = 0.3;\n    whiteMaterial.diffuse = 0.7;\n    whiteMaterial.specular = 0.2;\n    whiteMaterial.reflective = 0.1; // Légèrement réfléchissant\n\n    // Matériau bleu\n    blueMaterial.color = vec3(0.3, 0.6, 0.9); // Couleur bleue\n    blueMaterial.ambient = 0.2;\n    blueMaterial.diffuse = 0.6;\n    blueMaterial.specular = 0.4;\n    blueMaterial.reflective = 0.0; // Mat, sans réflexion\n\n    // Matériau miroir\n    mirrorMaterial.color = vec3(1.0, 1.0, 1.0); // Couleur blanche pour le miroir\n    mirrorMaterial.ambient = 0.0;              // Pas d'ambient\n    mirrorMaterial.diffuse = 0.0;               // Pas de diffuse\n    mirrorMaterial.specular = 1.0;              // Fortement spéculaire\n    mirrorMaterial.reflective = 1.0;            // Très réfléchissant\n\n    // Matériau miroir rouge partiel\n    redMirrorMaterial.color = vec3(1.0, 0.0, 0.0); // Couleur rouge pour le miroir\n    redMirrorMaterial.ambient = 0.1;               // Un peu d'ambient pour adoucir l'effet\n    redMirrorMaterial.diffuse = 0.2;               // Réduction de la diffusion (effet partiel)\n    redMirrorMaterial.specular = 0.8;              // Spéculaire fort\n    redMirrorMaterial.reflective = 0.6;            // Réflexion partielle\n\n    // Matériau métallique pour les parties du robot\n    metalMaterial.color = vec3(0.8, 0.8, 0.8); // Gris métallique\n    metalMaterial.ambient = 0.3;\n    metalMaterial.diffuse = 0.7;\n    metalMaterial.specular = 0.9;\n    metalMaterial.reflective = 0.3;\n\n    // Matériau orange avec 95% de rugosité et une bonne diffusion\n    orangeMaterial.color = vec3(1.0, 0.6, 0.0); // Couleur orange\n    orangeMaterial.ambient = 0.3; // Luminosité ambiante\n    orangeMaterial.diffuse = 0.95; // Forte diffusion (pratiquement toute la lumière est diffusée)\n    orangeMaterial.specular = 0.05; // Très faible spécularité (95% de rugosité)\n    orangeMaterial.reflective = 0.2;\n}\n\n\n// translation of a ray\n// t : vec3 of the translation\nRay translation(Ray r,vec3 t) \n{\n  return Ray(r.o+t,r.d);\n}\n\nRay rotation(Ray r, mat3 m)\n{\n  return Ray(r.o,m*r.d);\n}\n\nRay scale(Ray r, vec3 c, float s) \n{\n    vec3 newO = c + s * (r.o - c);\n    return Ray(newO, r.d);\n}\n\nvec3 inverseTranslation(vec3 p, vec3 v) {\n    return p - v;\n}\n\nvec3 inverseScale(vec3 p, vec3 center, float factor) {\n    return center + (p - center) / factor;\n}\n\n\nvec3 inverseRotate(vec3 p, mat3 m) {\n    return transpose(m) * p;\n}\n\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n  Material m;\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Golden ratio and golden angle\nconst float PHI = 1.61803398875; // Golden ratio\nconst float GOLDEN_ANGLE = 2.0 * 3.14159265359 / PHI; // Golden angle (approximately 137.5 degrees)\n\nvec3 fibonacciSphere(float k, float n, vec3 center) {\n    // Calculate spherical coordinates\n    float theta = k * GOLDEN_ANGLE;  // Azimuthal angle (theta)\n    float phi = acos(1.0 - 2.0 * (k + 0.5) / n); // Polar angle (phi)\n    \n    // Convert spherical to Cartesian coordinates\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    \n    // Add the center offset to move the point to the desired location\n    vec3 point = center + vec3(x, y, z);  // Translate the point by adding the center\n\n    return point; // Return the 3D point moved to the 'center'\n}\n\n\nmat3 rotationMatrixZ(float theta) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    return mat3(\n        cosTheta, -sinTheta, 0.0,\n        sinTheta, cosTheta, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 rotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0,  0.0,  0.0,\n        0.0,  c,   -s,\n        0.0,  s,    c\n    );\n}\n\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Scale matrix\n// s : scaling factors (vec3 for scaling on x, y, z axes)\nmat3 Scale(vec3 s)\n{\n    return mat3(s.x, 0.0, 0.0,\n                0.0, s.y, 0.0,\n                0.0, 0.0, s.z);\n}\n\n// Création de rayons pour la caméra\nRay CreateRay(vec2 m, vec2 p) {\n  float a = 3.0 * 3.14 * m.x + 0.2;\n  float b = m.y*3.+ 0.2;\n  float le = 3.5;\n  vec3 ro = vec3(40.0*b, 0.0, 15.0*b) * mat3(\n      cos(a), sin(a), 0.0,\n      -sin(a), cos(a), 0.0,\n      0.0, 0.0, 1.0\n  );\n  vec3 ta = vec3(0.0, 0.0, 1.0);\n  vec3 w = normalize(ta - ro);\n  vec3 u = normalize(cross(w, vec3(0.0, 0.0, 1.0)));\n  vec3 v = normalize(cross(u, w));\n  vec3 rd = normalize(p.x * u + p.y * v + le * w);\n  return Ray(ro, rd);\n}\n\n\n\n// Noise and Texture\n\n\n\n\n// Fonction pour créer la matrice de torsion autour de l'axe Z\nmat3 torsionMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n// Fonction pour appliquer la torsion à un point\nvec3 applyTorsion(vec3 p, vec3 center, float spiralFactor) {\n    vec3 np = p - center;\n    float angle = spiralFactor * np.y;\n    mat3 torsionMatrix = torsionMatrixZ(angle);\n    vec3 pTorsion = torsionMatrix * np;\n    return pTorsion + center;\n}\n\n\n// Function to generate a pseudo-random number based on a seed\nfloat random(float seed) {\n    return fract(sin(seed) * 65444.41985); // Simple hash function for random number generation\n}\n\n// Function to apply stochastic movement to a point p\nvec3 applyStochasticMovement(vec3 p, float time) {\n    // Use time as a seed to create a pseudo-random value\n    float randomFactorX = random(p.x + time);\n    float randomFactorY = random(p.y + time);\n    float randomFactorZ = random(p.z + time);\n\n    // Scale the random factors to control the magnitude of the movement\n    float scale = 0.1; // Adjust this value to increase or decrease the randomness\n\n    // Apply stochastic displacement\n    return p + vec3(randomFactorX * scale, randomFactorY * scale, randomFactorZ * scale);\n}\n\n\n\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Fonction de turbulence (fBm)\nfloat turbulence(vec3 p, float frequency, int octaves, float lacunarity, float gain) {\n    float sum = 0.0;\n    float amplitude = 1.0;\n    float fq = frequency;\n\n    for (int i = 0; i < octaves; i++) {\n        sum += amplitude * abs(noise(p * fq));\n        fq *= lacunarity;\n        amplitude *= gain;\n    }\n\n    return sum;\n}\n\n// Fonction pour le déplacement stochastique de p\nvec3 displacementP(vec3 p) {\n    // Paramètres de déplacement\n    float amplitude = 0.1;\n    float frequency = 1.0;\n    int octaves = 4;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    vec3 displacement = vec3(\n        turbulence(p, frequency, octaves, lacunarity, gain),\n        turbulence(p + vec3(31.416), frequency, octaves, lacunarity, gain),\n        turbulence(p + vec3(42.1337), frequency, octaves, lacunarity, gain)\n    );\n    return p + displacement * amplitude;\n}\n\n\n\n\nvec3 Wood2 ( vec3 p ) {\n  float frequency = 10.0;  // Augmentez cette valeur pour des cercles plus petits\n  vec3 q = p + 0.2 * displacementP(p);\n  float r = 0.5 * (1.0 + sin(frequency * length(q.xy)));\n  vec3 lightWood = vec3(0.9, 0.7, 0.5);    // Bois très clair\n  vec3 darkWood = vec3(0.7, 0.5, 0.3);  \n  return mix(darkWood, lightWood, r);\n}\n\n\n// Fonction de déformation avec des sinusoïdes\nvec3 ApplyBumps(vec3 p) {\n    float frequency = 2.; // Fréquence des bosses\n    float amplitude = 0.2;  // Amplitude des bosses\n\n    // Déformer la position en appliquant des sinusoïdes\n    p.y += amplitude * sin(frequency * p.x) * cos(frequency * p.z);\n    p.x += amplitude * cos(frequency * p.y) * sin(frequency * p.z);\n    p.z += amplitude * sin(frequency * p.y) * cos(frequency * p.x);\n\n    return p;\n}\n\nMaterial createWoodMaterial(vec3 p) {\n    Material mat;\n    mat.color = Wood2(p); // Applique la texture de bois\n    mat.ambient = 0.3;\n    mat.diffuse = .5;\n    mat.specular = 0.2;\n    mat.reflective = 0.; // Légèrement réfléchissant\n    return mat;\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\n// Coût total : 24\nVal Sphere(vec3 p,vec3 c,float r, Material mat)\n{\n  return Val(length(p - c) - r, 24, mat);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\n// Coût total : 6 \nVal Plane(vec3 p, vec3 n, vec3 o, Material mat)\n{\n    return Val(dot((p-o),n),6, mat);\n}\n\n\n// Donut horizontal\n// p : point\n// c : center of skeleton\n// r1 : around radius\n// r2 : radius around\n// Coût total : 53\nVal Torus(vec3 p, vec3 c, float r1, float r2, Material mat) {\n\n    vec2 q = vec2(length(p.xz - c.xz) - r1, p.y - c.y);\n\n    return Val(length(q) - r2, 53, mat);\n\n}\n\n// Cylindre horizontal\n// p : point\n// c : center of skeleton\n// r : around radius\n// h : height\n// Coût total : 58\nVal Cylinder(vec3 p, vec3 c, float h, float r, Material mat) {\n\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - vec2(r, h);\n\n    return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 58, mat);\n\n}\n\n// Ellipsoide\n// p : point\n// c : center of skeleton\n// r1 : around radius\n// r2 : around radius nd\n// n : Normal of plane\n// Coût total : 38\nVal Ellipsoid(vec3 p, vec3 c, vec3 r, Material mat) {\n\n    return Val(length((p - c) / r) - 1.0, 38, mat);\n\n}\n\n// Capsule\n// p : point\n// cA : endpoint a\n// cB : endpoint b\n// r : around radius nd\n// Coût total : 58\nVal Capsule(vec3 p, vec3 a, vec3 b, float r, Material mat) {\n\n    vec3 pa = p - a, ba = b - a;\n\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n    return Val(length(pa - ba * h) - r, 58,mat);\n\n}\n\n// Pavé\n// p : point\n// c : center of box\n// l : length along x-axis\n// w : width along y-axis\n// h : height along z-axis\n// Coût total : 32\nVal Box(vec3 p, vec3 c, float l, float w, float h, Material mat) {\n    // Projection du point p sur les axes du pavé\n    vec3 d = abs(p - c) - vec3(l, w, h) * 0.5;\n\n    // Calcul de la distance\n    float outsideDist = length(max(d, vec3(0.0, 0.0, 0.0)));\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0);\n    float signedDist = outsideDist + insideDist;\n\n    \n    \n    return Val(signedDist, 32, mat);\n}\n\n\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b)\n{\n  if (a.v<b.v) {\n    return Val(a.v,a.c+b.c+1, a.m);\n  } else {\n    return Val(b.v,a.c+b.c+1, b.m);\n  }\n  \n}\n\nfloat Correction(float a, float b) {\n  float r = 1.;\n  float h = max(r-abs(a-b),0.)/r;\n  return r*h*h*h*(1./6.);\n}\n\nVal UnionComplexe(Val a,Val b)\n{\n  return Val(min(a.v,b.v)-Correction(a.v,b.v),a.c+b.c+1, a.m);\n}\n\nVal Intersect(Val a, Val b) \n{\n  return Val(max(a.v,b.v),a.c+b.c+1, a.m);\n}\n\nVal BooleanDifference(Val a, Val b)\n{\n  return Val(max(a.v, -b.v), a.c + b.c + 1, a.m);\n}\n\nVal boundingObject(Val bObject, Val objet) \n{\n  if (bObject.v>0.) {\n    return bObject;\n  } else {\n    return objet;\n  }\n}\n\n\n\n\nmat4 RotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    // Matrice de rotation\n    return mat4(\n        t * axis.x * axis.x + c,     t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y, 0.0,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c,     t * axis.y * axis.z - s * axis.x, 0.0,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c,     0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Complex Object\n\n\n\nVal ComplexObject(vec3 p, vec3 center, float r, Material mat_1, Material mat_2)\n{\n  // La sphère englobante a un rayon égal à r + r * 0.005\n  float boundingRadius = r + r * 0.2;\n  Val bObject = Sphere(p, center, boundingRadius, mat_1);\n\n  Val v = Val(1.0,bObject.c,mat_1);\n  int n = 100; // Number of points to sample on the sphere\n  Material mat;\n  for (int k = 0; k < n; ++k) {\n    if (k%2==1) {mat = mat_1;} \n    else {mat = mat_2;}\n    vec3 point = fibonacciSphere(float(k), float(n), center); \n    // Do something with the point, e.g., rendering it or collecting it in an array\n    v = Union(v, Sphere(p,center + (point - center) * r,r*.2,mat));\n\n  }\n  return boundingObject(bObject,v);\n}\n\n\nVal ShowcasingComplexUnion(vec3 p)\n{\n  return UnionComplexe(Sphere(p,vec3(10.,1.,1.),2.,whiteMaterial),Sphere(p,vec3(9.,4.,1.),2.,whiteMaterial));\n}\n\n\n\n// Potential field of the object\n// p : point\nVal object(vec3 p)\n{\n  float d = 12.5;\n  initializeMaterials();\n  vec3 p1 = vec3(-d,  d, 0.);\n  vec3 p2 = vec3( 0.,  d, 0.);\n  vec3 p3 = vec3( d,  d, 0.);\n\n  vec3 p4 = vec3(-d,  0., 0.);\n  vec3 p5 = vec3( 0.,  0., 0.); // centre\n  vec3 p6 = vec3( d,  0, 0);\n\n  vec3 p7 = vec3(-d, -d, 0.);\n  vec3 p8 = vec3( 0., -d, 0.);\n\n\n  Val plane = Plane(p,vec3(0.,0.,1.),vec3(0.0,0.0,-10.0),orangeMaterial);\n  Val fibonacciSphere = ComplexObject(p,p6,3.,whiteMaterial,blackMaterial);\n\n  vec3 cA = p1+vec3(0.,0.,2.);\n  vec3 cB = p1-vec3(0.,0.,2.);\n  Val capsule = Capsule(p,cA,cB,2., createWoodMaterial(p));\n  Val cylinder = Cylinder(\n     applyTorsion(inverseTranslation(p,vec3(0.,0.,3.)*(2.-sin(iTime))),p2,.2),\n     p2,5.,2.,\n     blueMaterial\n    );\n  Val cylinder2 = Cylinder(ApplyBumps(p),p3,5.,2.,whiteMaterial);\n  Val torus = Torus(inverseScale(p,p8,2.-sin(iTime)),p8,1.5,.75,blueMaterial);\n  Val complexUnionObject = ShowcasingComplexUnion(inverseRotate(p,rotationMatrixZ(3.*iTime)));\n  Val mirrorSphere = Sphere(p,p5,3.,mirrorMaterial);\n\n  Val box = Box(p, p4, 6.0, 6.0, 6.0, redMirrorMaterial);\n  Val ellipsoid = Ellipsoid(p,p7,vec3(2., 3.0, 4.),redMirrorMaterial);\n  \n  Val v = Union(plane, fibonacciSphere);\n  v = Union(v, capsule);\n  v = Union(v, cylinder);\n  v = Union(v, cylinder2);\n  v = Union(v, torus);\n  v = Union(v, complexUnionObject);\n  v = Union(v, mirrorSphere);\n  v = Union(v, box);\n  v = Union(v, ellipsoid);\n\n\n  return v;\n}\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c, out Material m)\n{\n  bool h=false;\n  \n  // Start at the origin\n  t=0.0;\n  c=0;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    m = val.m;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      // Dans SphereTrace ou lors de l'assignation du matériau\n\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),ray.d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  Material m;\n  bool hit=SphereTrace(Ray(p+Epsilon*n,l),100.,t,s,c,m);\n  if(!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Fonction d'éclairage sans récursivité\nvec3 Shade(vec3 p, vec3 n, Ray eye, Material mat) {\n  vec3 finalColor = vec3(0.0);\n\n  // Composante ambiante\n  vec3 ambient = mat.ambient * mat.color;\n\n  // Source de lumière\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n  vec3 l = normalize(lp - p);\n\n  // Calcul de l'ombre\n  float shadow = Shadow(p, n, l);\n\n  // Composante diffuse\n  vec3 diffuse = mat.diffuse * clamp(dot(n, l), 0.0, 1.0) * mat.color;\n\n  // Composante spéculaire\n  vec3 r = reflect(-l, n);\n  vec3 specular = mat.specular * pow(clamp(dot(r, -eye.d), 0.0, 1.0), 35.0) * vec3(1.0);\n\n  // Calcul de la couleur sans réflexion\n  finalColor = ambient + shadow * (diffuse + specular);\n\n  // Gestion d'un niveau de réflexion sans récursivité\n  if (mat.reflective > 0.0) {\n    // Calculer le rayon réfléchi\n    vec3 reflectDir = reflect(eye.d, n);\n    Ray reflectRay = Ray(p + n * Epsilon, reflectDir);\n    vec3 reflectColor = background(reflectRay);  // Couleur par défaut du fond\n\n    // Traçage du rayon réfléchi pour trouver une intersection\n    float t;\n    int s, c;\n    // Obtenir les propriétés de l'objet à la position réfléchie\n    Material reflectMat;\n    bool hit = SphereTrace(reflectRay, 100.0, t, s, c,reflectMat);\n    if (hit) {\n      // Position de l'intersection et normale à ce point\n      vec3 reflectPos = Point(reflectRay, t);\n      vec3 reflectNormal = ObjectNormal(reflectPos);\n      \n      \n\n      // Calcule l'éclairage pour la surface réfléchie\n      vec3 ambientReflect = reflectMat.ambient * reflectMat.color;\n      vec3 diffuseReflect = reflectMat.diffuse * clamp(dot(reflectNormal, l), 0.0, 1.0) * reflectMat.color;\n      vec3 specularReflect = reflectMat.specular * pow(clamp(dot(reflectDir, l), 0.0, 1.0), 35.0) * vec3(1.0);\n      \n      reflectColor = ambientReflect + shadow * (diffuseReflect + specularReflect);\n    }\n\n    // Mélange la couleur de l'objet avec la couleur réfléchie\n    finalColor = mix(finalColor, reflectColor, mat.reflective);\n  }\n\n  return finalColor;\n}\n\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy)\n{  \n  // Convert pixel coordinates\n  vec2 pixel = (-iResolution.xy + 2.0 * pxy) / iResolution.y;\n\n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n\n\n  // Camera\n  Ray ray = CreateRay(m, pixel);\n\n  // Trace ray\n\n  // Hit and number of steps\n  float t = 0.0;\n  int s = 0;\n  int c;\n  Material mat;\n  bool hit = SphereTrace(ray, 1000.0, t, s, c,mat);\n\n  // Shade background\n  vec3 rgb = background(ray);\n  \n  if (hit)\n  {\n    // Position\n    vec3 p = Point(ray, t);\n\n    // Compute normal\n    vec3 n = ObjectNormal(p);\n\n    // Shade object with light\n    rgb = Shade(p, n, ray,mat);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s, Steps);\n\n  // Uncomment this line to shade cost\n  //rgb = ShadeSteps(c, 25000);\n\n  color = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}