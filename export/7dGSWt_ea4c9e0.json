{"ver":"0.1","info":{"id":"7dGSWt","date":"1635489680","viewed":209,"name":"hilbert curve thru bluenoise","username":"Carandiru","description":"learning hilbert curve space","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["noise","curve","hilbert","bell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.141592654f)\n\n#define LEVEL 15U\n#define WIDTH ((1U << LEVEL))\n#define AREA (WIDTH*WIDTH)\nfloat hilbert1D(in uvec2 Position){   \n    \n    uint Index = 0u;\n    \n    for(uint CurLevel = (WIDTH>>1u); CurLevel > 0u; CurLevel >>= 1u){\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel*CurLevel*((3u*Region.x)^Region.y);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(WIDTH-1u) - Position;\n            }\n            Position.xy=Position.yx;\n        }\n    }\n    return (float(Index)/float(AREA));\n}\n\nvec2 hilbert2D(in uint Index){   \n    \n    uvec2 Position = uvec2(0u);\n    \n    for(uint CurLevel = 1u; CurLevel < WIDTH; CurLevel <<= 1){\n        uvec2 Region;\n        Region.x = 1u & (Index >> 1u);\n        Region.y = 1u & (Index ^ Region.x);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(CurLevel-1u) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n        Position += CurLevel * Region;\n        Index >>= 2u;\n    }\n    return vec2(Position);\n}\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    const float sigma = float(0.5f);  // mu is 0.0 (centered)\n    const float b = float((2.0f * sigma) * (2.0f * sigma));\n    const float c = float((2.0f * PI * sigma) / 1.253314f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt and takes input range normalized to [-2.0f...2.0f]\n                                                                      // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (x * 2.0f - 1.0f);  // converts input range from [0.0f...1.0f] to [-2.0f...2.0f]\n\n    return(exp(-(x * x) / b / c)); // range after is [0.0f...1.0f]\n}\n\n#define RESOLUTION (1024.0f)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragCoord = uv * iResolution.xy;\n    \n    float n0 = textureLod(iChannel0, (fragCoord.xy + vec2(iTime * 100.0f, 0.0f))/(RESOLUTION*16.0f), 0.0f).r;\n    float n1 = textureLod(iChannel0, (fragCoord.xy + vec2(iTime * 100.0f + 1.0f, 0.0f))/(RESOLUTION*16.0f), 0.0f).r;\n     \n    vec3 color = vec3(0);\n\n    vec2 h0 = hilbert2D(uint((n0) * RESOLUTION));\n    vec2 h1 = hilbert2D(uint((n1) * RESOLUTION));\n    \n    //c2 hx = mix(h0, h1, 0.5f);\n    \n    float d0 = hilbert1D(uvec2(h0 * RESOLUTION));\n    float d1 = hilbert1D(uvec2(h1 * RESOLUTION));\n    \n    color = 2.0f - vec3(bellcurve(d1) + bellcurve(d0));\n\n    color = pow(color * vec3(0.126f, 0.005f, 0.99f), vec3(1.0f/2.2f));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}