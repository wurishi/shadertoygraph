{"ver":"0.1","info":{"id":"4dBBWV","date":"1502138013","viewed":713,"name":"EquirectRemap","username":"diroru","description":"This is probably cheating, but alas, couldn't find a better way. The latlon-translation is mapped to two rotations in 3d space and then brought back to an equirectangular projection. Waiting to be lapidated (since \"stoned\" is a bit ambiguous).","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["projection","equirectangular","geovis","platecarre","rhumbs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat map(float v, float low1, float high1, float low2, float high2) {\n\treturn (v-low1)/(high1-low1)*(high2-low2);\n}\n\nvec2 xyzToLonLat(vec3 v) {\n    vec3 p = normalize(v);\n    float lat = map(asin(p.y), PI*0.5, -PI*0.5, 0.0, 1.0);\n    float lon = map(atan(p.x, -p.z), PI, -PI, 0.0, 1.0);\n    return vec2(lon, lat);\n}\n\nvec3 lonLatToXYZ(vec2 lonLat) {\n  float lon = map(lonLat.x, 0.0, 1.0, -PI, PI);\n  float lat = map(lonLat.y, 0.0, 1.0, -PI*0.5, PI*0.5);\n  float x = sin(lat)*sin(lon);\n  float y = cos(lat);\n  float z = sin(lat)*cos(lon);\n  return vec3(x,y,z);\n}\n\nvec3 xRot(vec3 v, float theta) {\n  float x = v.x;\n  float y = v.y*cos(theta) - v.z*sin(theta);\n  float z = v.y*sin(theta) + v.z*cos(theta);\n  return vec3(x,y,z);\n}\n\nvec3 yRot(vec3 v, float theta) {\n  float x = v.z*sin(theta) + v.x*cos(theta);\n  float y = v.y;\n  float z = v.z*cos(theta) - v.x*sin(theta);\n  return vec3(x,y,z);\n}\n\nvec3 zRot(vec3 v, float theta) {\n  float x = v.x*cos(theta) - v.y*sin(theta);\n  float y = v.x*sin(theta) + v.y*cos(theta);\n  float z = v.z;\n  return vec3(x,y,z);\n}\n\nvec2 equiRemap(vec2 lonLat, vec2 delta) {\n    vec3 v = lonLatToXYZ(lonLat);\n\tv = yRot(v,delta.x);\n    v = xRot(v,delta.y);\n    return xyzToLonLat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float graticuleSize = 0.05;\n    float graticuleWeight = 0.003;\n    //line to be visualised\n\n    //normalized lonLat\n\tvec2 lonLat = fragCoord.xy / iResolution.xy;\n    lonLat = equiRemap(lonLat, vec2(iTime*0.2,iTime*0.4));\n\tfragColor = vec4(lonLat,0.0,1.0);\n    vec2 graticuleDist = mod(lonLat + vec2(graticuleWeight*0.5),vec2(graticuleSize));\n    if (graticuleDist.x < graticuleWeight || graticuleDist.y < graticuleWeight) {\n    \tfragColor += vec4(0.5);\n    }\n    \n    //visualising a rhumb line, x is lon, y is lat\n    //normalized over \n    vec2 p0 = vec2(0.0,0.0);\n    vec2 p1 = vec2(7.0,1.0);\n    float slope = (p1.y-p0.y)/(p1.x-p0.x);\n    float theta = atan(p1.y-p0.y,p1.x-p0.x);\n    float lineHalfWeight = 0.01*(1.0+cos(theta));\n    bool b0 = atan(mod(lonLat.y,slope)-p0.y,lonLat.x-p0.x+lineHalfWeight) < theta;\n    bool b1 = atan(mod(lonLat.y,slope)-p0.y,lonLat.x-p0.x-lineHalfWeight) > theta;\n    if (b0 && b1 ){\n    \tfragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}