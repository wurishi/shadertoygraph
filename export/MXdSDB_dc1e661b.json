{"ver":"0.1","info":{"id":"MXdSDB","date":"1719536336","viewed":65,"name":"raymarching v1 - sl","username":"seannlinn","description":"first raymarching attempt","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float t) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.5,0.5,0.5);\n    vec3 d = vec3(0.3 + abs(.2*sin(iTime)), .2, .2 + .05*sin(iTime));\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// distance to the scene\nfloat map(vec3 p) {   \n    \n    p.z += iTime; // movement towards camera\n    \n    \n    // space repitition\n    p.xy = (mod(p.xy, 1.) - 0.5); // spacing = 1\n    p.z = mod(p.z, 0.125) - 0.0625; // spacing = 0.25\n    \n    p.yz *= rot2D(1.57079632679);\n    \n    float torus = sdTorus(p, vec2(.2 + 0.01*sin(iTime), .02 + 0.01*cos(iTime))); // creates torus sdf\n    \n    return torus; // returns the closest distance to the scene which practically merges the two objects\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    /// initialization\n    vec3 ro = vec3(0, 0, -3); // sets ray origin as vector3\n    vec3 rd = normalize(vec3(uv, 1)); // sets ray direction by using uv coordinates and z direction as 1, normalizes to have all values between 0 and 1   \n    vec3 col = vec3(0); // sets vec3 which represents final pixel color\n    \n    float t = 0.; // sets total distance travelled by ray from the origin\n    \n\n    /// raymarching\n    int i; \n    for (i=0; i<80; i++) {        \n        vec3 p = ro + rd * t; // finds position along ray by multiplying distance by ray direction and adding it to ray origin\n   \n        p.x += cos(t)*.3*cos(iTime);\n        p.y += sin(t)*.3*cos(iTime);\n        p.xy *= rot2D(0.5*t/0.25*.2*(sin(iTime)));\n        \n        float d = map(p); // returns current distance to the scene, which is distance that can be safely travelled without overstepping on an object\n        \n        t += d; // marches the ray forward by d each iteration\n        \n        if (d < .00001 || t > 10000.) break; // stop early if it is close enough / too far\n\n    }\n\n    /// coloring\n    col = palette(t*.05 + float(i)*0.004); // color based on distance travelled\n\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}