{"ver":"0.1","info":{"id":"4dcfz7","date":"1524429497","viewed":410,"name":"Deadpool Logo","username":"clumsyrthanu","description":"I'm hyped for the new Deadpool movie.\n\nMade using this image as a reference: https://1.bp.blogspot.com/-EMhLGtnhLso/UUey6GB-9sI/AAAAAAAAAzo/aWDORkUFYrc/s640/deadpool_logo.jpg","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["logo","comics","deadpool","marvel","movies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159;\nconst float EPSILON = 0.001;\nconst float MAX_DISTANCE = 200.0;\nconst int MAX_ITERATIONS = 250;\n\nconst vec3 LIGHT_DIRECTION = vec3(0.0,1.0,1.25);\n\nfloat pulse(float amplitude, float frequency)\n{\n    return amplitude * \n        max(sin(iTime * frequency), 0.0) * \n        max(sin(iTime * frequency * 0.5), 0.0) * \n        max(cos(iTime * frequency),0.0);\n}\n\nvec2 rotate2d(vec2 st, float a)\n{\n    mat2 rotation = mat2(vec2(cos(a), sin(a)), vec2(-sin(a), cos(a)));\n    return rotation * st;\n}\n\nfloat vignette(vec2 st)\n{\n    return min(1.0 - length(st) + 0.38, 1.0);\n}\n\nfloat rectangle(vec2 st, vec2 size)\n{   \n    float left = size.x * 0.5;\n    float up = size.y * 0.5;\n    \n    float cx = 1.0 - smoothstep(left, left + 1.5, abs(st.x));\n    float cy = 1.0 - smoothstep(up, up + 1.5, abs(st.y));\n    \n    return (cx * cy);\n}\n\nvec3 background(vec2 st)\n{\n    vec2 uv = rotate2d(st, PI * 0.25);\n    \n    vec2 uvx = mod(uv * 150.0, vec2(4.0, 8.0)) - vec2(2.0, 2.0);\n    vec2 uvy = mod(uv * 150.0 + vec2(2.0, 4.0), vec2(4.0, 8.0)) - vec2(2.0, 2.0);\n    \n    float cx = rectangle(uvx, vec2(1.0, 1.5));\n    float cy = rectangle(uvy, vec2(1.5, 1.0));\n        \n    return mix(vec3(0.370,0.004,0.011), vec3(0.520,0.100,0.018), cx + cy);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 rotateY(vec3 point, float angle)\n{\n    float r = radians(angle);\n    float x = point.x * sin(r) - point.z * cos(r);\n    float z = point.x * cos(r) + point.z * sin(r);\n    return vec3(x, point.y, z);\n}\n\nfloat logoOuterSection(vec3 position)\n{    \n    float outerCylinder = cylinder(position, vec2(2.0,1.5));\n    float innerCylinder = cylinder(position, vec2(2.5,0.5));\n    float centerBox = box(position, vec3(0.35, 2.25, 0.5));\n    \n    float ring = max(-outerCylinder, innerCylinder); // Subtract\n    float pillaredRing = min(ring, centerBox); // Union\n    \n    return pillaredRing;\n}\n\nfloat logoInnerSection(vec3 position)\n{\n    float outerCylinder = cylinder(position, vec2(2.0,0.35));\n    return outerCylinder;\n}\n\nfloat logoEye(vec3 position)\n{\n    float innerSize = 1.5;// + pulse(20.0, 6.0); // eye blink\n    float leftCylinder = cylinder(position, vec2(0.5, 0.4));\n    float rightCylinder = cylinder(position - vec3(1.25,1., 0.0), vec2(innerSize, 6.0));\n    return max(-rightCylinder, leftCylinder);\n}\n\nfloat logoEyes(vec3 position)\n{\n    vec3 p = position;\n    float leftEye = logoEye(p + vec3(1.1,0.0,0.0));\n    p += vec3(-1.1, 0.0, 0.0);\n    p.x *= -1.0;\n    float rightEye = logoEye(p);\n    return min(leftEye, rightEye);\n}\n\nfloat logo(vec3 position, out vec3 material)\n{\n    vec3 p = rotateY(position, 90.0 + 40.0 * iTime);\n    \n    float result = logoInnerSection(p);\n    material = vec3(0.130,0.130,0.130);\n    \n    float outerSection = logoOuterSection(p);\n    if (outerSection < result)\n    {\n        result = outerSection;\n        material = vec3(1.000,0.074,0.008);\n    }\n    \n    float leftEye = logoEyes(p);\n    if (leftEye < result)\n    {\n        result = leftEye;\n        material = vec3(0.965,0.965,0.965);\n    }\n        \n    return result;\n}\n\nvec3 geometry(vec2 screenPosition, vec3 origin, vec3 right, vec3 up, vec3 forward, out float distanze, out int iterations, out vec3 material)\n{\n    vec3 direction = normalize(screenPosition.x * right + screenPosition.y * up + forward);\n    \n    vec3 position = origin;\n    float totalDistance = 0.0;\n    float d = EPSILON;\n    int sectionIndex;\n        \n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        if (d < EPSILON || totalDistance > MAX_DISTANCE)\n        {\n            break;\n        }\n        \n        d = logo(position, material);\n        position += direction * d;\n        totalDistance += d;\n        \n        iterations = i;\n    }\n    \n    distanze = d;\n    \n    return position;\n}\n\nvec3 normal(vec3 position)\n{\n    vec3 epsx = vec3(EPSILON, 0.0, 0.0);\n    vec3 epsy = vec3(0.0, EPSILON, 0.0);\n    vec3 epsz = vec3(0.0, 0.0, EPSILON);\n    \n    vec3 material;\n    \n    return normalize(vec3(logo(position + epsx, material) - logo(position - epsx, material),\n                          logo(position + epsy, material) - logo(position - epsy, material),\n                          logo(position + epsz, material) - logo(position - epsz, material)));\n}\n\nvec4 color(vec3 position, vec3 lightDirection, vec3 cameraOrigin, vec3 material)\n{\n\tvec3 n = normal(position);\n        \n    float diffuse = dot(n, lightDirection);\n    float ambient = 0.1;\n    \n    return vec4(vec3(diffuse + ambient) * material, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0.0, 0.0, 6.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cameraForward = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    vec3 lightDirection = normalize(LIGHT_DIRECTION);\n    \n    float distanze;\n    int iterations;\n    vec3 material;\n    \n    vec3 position = geometry(st, cameraOrigin, cameraRight, cameraUp, cameraForward, distanze, iterations, material);\n\n    if (distanze < EPSILON)\n    {\n        fragColor = color(position, lightDirection, cameraOrigin, material);\n    }\n    else\n    {\n    \tfragColor = vec4(background(st) * vignette(st), 1.0);\n    }    \n}","name":"Image","description":"","type":"image"}]}