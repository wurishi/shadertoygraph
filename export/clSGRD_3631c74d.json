{"ver":"0.1","info":{"id":"clSGRD","date":"1672908710","viewed":226,"name":"ray trace with specular","username":"lambwww","description":"参考了https://www.shadertoy.com/view/WsBBR3，加上了镜面反射","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["raytracespecular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//光线可以看到的最远距离\nconst float maxFar=10000.;\n//光线交叉的最短距离，防止刚反弹出来又弹射\nconst float minRayHitTime=0.01;\n//光线弹射次数\nconst int bounceTime=8;\n\nconst float pi=3.1415926535;\n//交点信息\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 albedo; //颜色\n    vec3 emission; //发光\n    float percentSpecular; //镜面反射所占的比重，越大占的越多\n    float roughness; //粗糙程度，越接近0镜面反射越清晰\n    vec3 specularColor; //镜面反射的颜色\n};\n//随机数处理使用了重要性采样，这里也有点没搞清楚原理\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RandomUnitVec(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2. * pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n//判断光线是否和球体相交\n//sphere.xyz代表球心位置，sphere.w代表球的半径大小\nbool TestSphereTrace(in vec3 ro, in vec3 rd, inout SRayHitInfo info, in vec4 sphere)\n{\n    float r=sphere.w*sphere.w;\n    \n    vec3 l=ro-sphere.xyz;\n    float s=dot(l,rd);\n    float c=dot(l,l)-sphere.w*sphere.w;\n    //当射线方向原理球体，且射线原点在球外，代表没有交点\n    if(s>.0 && c>.0) //这里有点不明白为什么是s>0，为什么不是s<0，小于0不是代表两者夹角大于90°吗\n        return false;\n     \n    float m=dot(l,l)-s*s;\n    //球心向光线做垂线，如果这段线距离大于球半径，代表没有交点\n    if(m>sphere.w*sphere.w)\n        return false;\n        \n    //计算相交点，选择最近的那个点\n    float q=sqrt(r-m);\n    float t=-s-q;\n    if(t<0.)\n    {\n        t=-s+q;\n    }\n    \n    //判断交点是否在可视范围内并赋值   \n    if(t>minRayHitTime && t<info.dist)\n    {\n        info.dist=t;\n        info.normal=normalize(ro+t*rd-sphere.xyz);//计算交点的表面法线\n        return true;\n    }\n    return false;\n}\n//判断光线是否和矩形相交\n//a b c d是矩形的四个顶点，左下点开始逆时针分别是四个点\nbool TestQuadTrace(vec3 ro,vec3 rd,inout SRayHitInfo info,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n    vec3 normal=normalize(cross(c-a,c-b));//两个向量叉乘获得垂直于矩形的法向量\n    //如果法线和光线夹角小于90度，就把法线和平面一块180度翻转一下\n    //这里暂时没搞懂为什么这样做，mark一下\n    if (dot(normal, rd) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    //以ac对角线为边界，判断光线在对角线上面还是下面\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;//交点\n    //将光线和矩形求交优化为光线和三角形求交\n    if (v >= 0.0f)\n    {\n        //和三角形abc求交\n        //三角形平面内任意点可表示为p=ua+vb+wc，abc是三角形三个顶点坐标，uvw根据重心坐标的性质有u+v+w=1\n        //将等号左边的射线式子和等号右边的三角形坐标式子联立：o+td=(1-u-v)a+ub+vc\n        //整理为矩阵形式并使用Cramer法则对方程求解\n        //原理参考了文章https://zhuanlan.zhihu.com/p/405075535\n        vec3 e1=b-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*b+w*c; //等号右边的三个参数对应重心性质的三个参数\n    }\n    else\n    {\n        //和三角形acd求交\n        //自己参考资料写的：\n        vec3 e1=d-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*d+w*c;\n    }\n    \n    float dist; //求距离值\n    if (abs(rd.x) > 0.1f)\n    {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    }\n    else if (abs(rd.y) > 0.1f)\n    {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > minRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n//场景\nvoid TestSceneTrace(vec3 ro,vec3 rd,inout SRayHitInfo info)\n{\n    //上面的球\n    if(TestSphereTrace(ro,rd,info,vec4(-17.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 0.0f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(-10.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 0.2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(-3.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 0.4f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(4.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 0.6f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(11.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 0.8f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(18.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.8f;\n        info.roughness = 1.0f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    //下面的球\n    if(TestSphereTrace(ro,rd,info,vec4(-15.0f, -8.0f, 20.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.0f;\n        info.roughness = .2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(-7.0f, -8.0f, 20.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.25f;\n        info.roughness = .2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(1.0f, -8.0f, 20.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.5f;\n        info.roughness = .2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(9.0f, -8.0f, 20.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 0.75f;\n        info.roughness = .2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(17.0f, -8.0f, 20.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.9f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n        info.percentSpecular = 1.0f;\n        info.roughness = .2f;\n        info.specularColor = vec3(0.9f, 0.9f, 0.9f);      \n    }\n    //前面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(-20.,15.,25.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //上面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(-20.,15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //下面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,-15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //左\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(-20.,15.,25.),vec3(-20.,15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.7,.1,.1);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //右\n    if(TestQuadTrace(ro,rd,info,vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.1,.7,.1);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //light\n    if(TestQuadTrace(ro,rd,info,vec3(-6.,14.9,23.),vec3(6.,14.9,23),vec3(6.,14.9,18.),vec3(-6.,14.9,18.)))\n    {\n        info.albedo = vec3(0.0f, 0.0f, 0.0f);\n        info.emission = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n    }\n}\n//返回光线相交到点的颜色\nvec3 GetColorForRay(vec3 ro,vec3 rd, uint random)\n{\n    vec3 res=vec3(.0,.0,.0);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f); //我的理解就是光线的颜色\n    \n    for(int i=0;i<bounceTime;i++)\n    {\n        SRayHitInfo hitInfo; //ray和物体的交点\n        hitInfo.dist=maxFar;\n        TestSceneTrace(ro,rd,hitInfo);\n        //代表没有相交物体\n        if(hitInfo.dist==maxFar)\n        {\n            res += texture(iChannel1, rd).rgb * throughput;\n            break; //这里可以添加一个环境光让整体更亮\n        }\n        \n        ro=ro+hitInfo.dist*rd; //更新位置\n        \n        vec3 diffuseRd=normalize(hitInfo.normal+RandomUnitVec(random)); //漫反射光线\n        vec3 specularRd=reflect(rd,hitInfo.normal); //完全反射的镜面反射光线\n        //根据粗糙度对光线方向进行插值，如果粗糙度为0就是完全的镜面反射，如果粗糙度是1就是完全的漫反射\n        //如果粗糙度处于0到1中间，那么镜面反射光线就要根据粗糙度适当向漫反射光线接近\n        specularRd=normalize(mix(specularRd,diffuseRd,hitInfo.roughness)); \n        \n        res+=hitInfo.emission*throughput; //为当前像素的颜色赋值\n        \n        //使用随机值和percentSpecular最比较，如果小于percentSpecular就代表这里使用镜面反射光线计算\n        //顺便为光线赋颜色值\n        if(RandomFloat01(random) < hitInfo.percentSpecular)\n        {\n            rd=specularRd;\n            throughput*=hitInfo.specularColor;\n        }\n        else\n        {\n            rd=diffuseRd;\n            throughput*=hitInfo.albedo; //光线和物体碰撞后的颜色值，物体的颜色影响了光线，所以要进行变化\n        }\n    }\n    \n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;//修改了变形\n    \n    vec3 ro=vec3(.0,.0,.0); //ray origin\n    vec3 rd=normalize(vec3(uv,1.)-ro); //ray dirction\n    \n    //生成随机数\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //进行追踪\n    vec3 col=GetColorForRay(ro,rd,rngState);\n    //和上一帧的图像进行混合\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastFrameColor, col, 1.0/ float(iFrame+1));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}