{"ver":"0.1","info":{"id":"MfdSzj","date":"1714750917","viewed":124,"name":"Bustling Procedural City ","username":"GarlicGraphix","description":"Still trying to get raymarching down, in this one I'm trying to combine fractals with differently textured shapes. Added some silly visuals to make the city look busy, wanted to go for a kind of timelapse vibe here. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","city"],"hasliked":0,"parentid":"4cdXzj","parentname":"GarlicGraphix Raymarch Template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define GROUND 0\n#define CITY 1\n#define SKY 2\nfloat rand(float seed) {\n    return fract(sin(seed)*100000.0);\n}\nmat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec3 proj(vec3 u, vec3 v) {\n    return v*(dot(u, v)/ dot(v, v));\n}\n\n//Signed distance & smooth union from Inigo Quilez\nfloat sdSphere( vec3 ray, float size ) {\n  return length(ray)-size;\n}\n\nfloat sdBox( vec3 ray, vec3 dimensions ) {\n  vec3 q = abs(ray) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 ray, vec3 normal, float height ) {\n  normal = normalize(normal);\n  return dot(ray,normal) + height;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//Object definition\nfloat getDist(vec3 ray, int state) {\n    if (state == GROUND) {\n        return sdPlane(ray, vec3(0.0, 1.0, 0.0), 0.75);\n    } else if (state == CITY) {\n        float city = 1000.0;\n        //Generating Skyscrapers\n        for (int i = 0; i < 10; i++){\n            float zDist = floor(length(proj(ray, vec3(0.0, 0.0, 1.0))));\n            float xDist = floor(length(proj(ray, vec3(1.0, 0.0, 0.0))));\n            float towerX = rand(float(i));\n            float towerZ = float(i)*0.56;\n            float towerW = 0.07;\n            float towerH = 0.5 + 0.4- float(i)*0.05;\n            vec3 fractRay = ray;\n            fractRay.z += towerZ;\n            fractRay.x += towerX;\n            fractRay.y += 0.75;\n            fractRay.xz = fract(fractRay.xz) -0.5;\n            \n            \n            city = min(city, sdBox(fractRay, vec3(towerW, towerH, towerW*0.5)));\n        }\n        return city;\n    } else if (state == SKY) {\n        ray.xy = fract(ray.xy);\n        ray.z -= 5.0;\n        return sdBox(ray, vec3(1.0));\n    } else {\n        return 0.0;\n    }\n}\n\n//From Art of Code\nvec3 getNormal(vec3 p, int state) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p, state) - \n        vec3(getDist(p-e.xyy, state), getDist(p-e.yxy, state),getDist(p-e.yyx, state));\n    \n    return normalize(n);\n}\n\n// textures objeccts based on ray\nvec3 textureObj(vec3 ray, int state) {\n    vec3 colXZ;\n    vec3 colXY;\n    vec3 colYZ;\n    if (state == GROUND) {\n        ray = fract(ray);\n        colXZ = texture(iChannel0, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel0, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel0, ray.yz * 0.5 + 0.5).rgb;\n    } else if (state == CITY) {\n        colXZ = texture(iChannel1, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel1, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel1, ray.zy * 0.5 + 0.5).rgb;\n    } else if (state == SKY) {\n        ray.x = fract(ray.x-iTime*0.4);\n        colXZ = texture(iChannel2, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel2, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel2, ray.zy * 0.5 + 0.5).rgb;\n    }\n    \n    vec3 normal = getNormal(ray, state);\n    \n    return colXZ * abs(normal.y) + colXY * abs(normal.z) + colYZ * abs(normal.x);\n}\n\n//Returns colour of object\nvec3 raymarch(vec3 origin, vec3 ray) {\n    float totDist = 0.0;\n    int iterations = 80;\n    vec3 colour = vec3(1.0);\n    \n    for (int i = 0; i < iterations; i++) {\n        vec3 pos = origin + ray * totDist;\n        \n        float ground = getDist(pos, GROUND);\n        float city = getDist(pos, CITY);\n        float sky = getDist(pos, SKY);\n        \n        float dist = min(city, ground);\n        dist = min(dist, sky);\n        \n        totDist += dist;\n        \n        if (dist <= 0.001) {\n            iterations = i;\n            if (ground < city) {\n                colour = textureObj(pos, GROUND);\n            } else if (city < sky) {\n                colour = textureObj(pos, CITY);\n            } else {\n                colour = textureObj(pos/2.0, SKY);\n            }\n            \n            break;\n        } else if (dist >= 100.0) {\n            iterations = i;\n            colour = vec3(0.0);\n            break;\n        }\n    }\n    \n    vec3 finalRay = origin + ray * totDist;\n    return clamp(colour-totDist*0.1, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv made for raymarching\n    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;\n    \n    // Camera Definition\n    vec3 origin = vec3(iTime, 1.5, 0.0);\n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    // Camera Rotation\n    \n    origin.zy *= rot2D(-0.5);\n    ray.zy *= rot2D(-0.5);\n\n    // Time varying pixel color\n    vec3 col = raymarch(origin, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Skyscraper window effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float window = sin(uv.y*180.0);\n    vec3 col = vec3(window, window, 0.0)*0.1;\n    \n    col += texture(iChannel0, uv+iTime*0.1).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy/5.2;\n    vec3 col = texture(iChannel0, uv).rgb*0.7;\n    if (uv.x <= 0.1 || uv.x >= 0.9 || uv.y <= 0.1 || uv.y >= 0.9) {\n        col = texture(iChannel0, uv+iTime*0.2).rgb*0.7;;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= 0.01;\n    vec3 col = texture(iChannel0, uv+iTime*0.05).rgb;\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}