{"ver":"0.1","info":{"id":"3tGfzw","date":"1615238586","viewed":183,"name":"lake house","username":"saranyacodes","description":"Make a house on a lake","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["water","sky","animation","stars","house","scenery","signeddistancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//HOUSE ON THE WATER\n \n//can adjust sky clouds by changing iChannel0 to another noise preset\n//can PAN MOUSE to change viewing angle \n\n//comment out to remove\n#define STARS \n#define CLOUDS \n\n//what type of sky do you want? make sure only ONE is uncommented!\n#define BLUE_SKY\n//#define INDIGO_SKY\n//#define PINK_SKY\n//#define PURPLE_SKY\n//#define GREEN_SKY\n//#define ORANGE_SKY\n//#define RED_SKY\n\n//-------------------------------------------------------\n \n//camera values\nvec3 eye = vec3(0.0, 4.0, -20.0); \n//vec3 eye = vec3(30, 4, -50);\nvec3 ref = vec3(0.0, 0.0, 0.0); \nvec3 up = vec3(0.0, 1.0, 0.0); \nconst float FOVY = 45.0; \n\n//light and colors \nconst vec3 lightPos = vec3(10., 5., -10.);\nconst vec3 lightColor = vec3(1.0, 0.9, 0.75);\n\n//constants\nconst int RAY_STEPS = 600; //increase to get rid of white artifacts\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float AMBIENCE = 0.2;\n\n//ambient occlusion constants\nconst float AO_DIST = 0.3; //the smaller this is, the less its effective \nconst float FIVETAP_K = 2.0;\n\n// intersection object\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 origp;\n    vec3 p;\n    int object; // every object gets a unique int ID\n};\n\n//transform object \nstruct Transform {\n    vec3 trans;\n    vec3 rot;\n    vec3 scale;\n};\n\n//NOISE FUNCTIONS -----------------------------------\n// generates 1D random numbers for noise functions\nfloat random1(vec2 p) {\n    return fract(sin(dot(p,vec2(341.58, 735.42)))\n                 *40323.3851);\n}\n\n// interpolates 2D noise for fractal brownian\nfloat interpNoise2D(float x, float y) {\n    // interpolates 2D based fract (x, y) between curr and next int (x, y)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    float i1 = mix(random1(vec2(intX, intY)), random1(vec2(intX + 1, intY)), fractX);\n    float i2 = mix(random1(vec2(intX, intY + 1)), random1(vec2(intX + 1, intY + 1)), fractX);\n    return mix(i1, i2, fractY);\n    \n}\n\n// calculates 2D fractal brownian w/ octaves input\nfloat FractalBrownian2D(vec2 p, int octaves, bool animate) {\n    // Animate the point\n    vec2 point;\n    if (animate) {\n        point = p + vec2(iTime * 0.22, iTime * 0.53);\n    } else {\n        point = p;\n    }\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise2D(point.x * freq, point.y * freq) * amp;\n    }\n    return total;\n}\n\n\n// calculates 2D fractal brownian\nfloat FractalBrownian2D(vec2 p, bool animate) {\n    return FractalBrownian2D(p, 4, animate);\n}\n\n// generates 1D random numbers for noise functions\nfloat random1vec3(vec3 p) {\n    return fract(sin(dot(p,vec3(341.58, 735.42, 491.34)))\n                 *40323.3851);\n}\n\n// interpolates 3D noise for fractal brownian\nfloat interpNoise3D(float x, float y, float z) {\n    // interpolates 3D based fract (x, y, z) between curr and next int (x, y, z)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    int intZ = int(floor(z));\n    float fractZ = fract(z);\n    float i1 = mix(random1vec3(vec3(intX, intY, intZ)), random1vec3(vec3(intX + 1, intY, intZ)), fractX);\n    float i2 = mix(random1vec3(vec3(intX, intY + 1, intZ)), random1vec3(vec3(intX + 1, intY + 1, intZ)), fractX);\n    float i3 = mix(random1vec3(vec3(intX, intY, intZ + 1)), random1vec3(vec3(intX + 1, intY, intZ + 1)), fractX);\n    float i4 = mix(random1vec3(vec3(intX, intY + 1, intZ + 1)), random1vec3(vec3(intX + 1, intY + 1, intZ + 1)), fractX);\n    float j1 = mix(i1, i2, fractY);\n    float j2 = mix(i3, i4, fractY);\n    return mix(j1, j2, fractZ);\n    \n}\n\n// calculates 3D fractal brownian w/ octaves input\nfloat FractalBrownian3D(vec3 point, int octaves, bool animate) {\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise3D(point.x * freq, point.y * freq, point.z * freq) * amp;\n    }\n    return total;\n}\n\n//---------------------------------------------------\n//functions for shape transformations\n//inputs for rotations are in DEGREES \n//rotate along the X axis \nvec3 rotateX(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(p.x, cos(a) * p.y + -sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\n//rotate along the Y axis\nvec3 rotateY(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//rotate along the Z axis\nvec3 rotateZ(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(cos(a) * p.x + -sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n//transforms a point by its inverse\nvec3 transformPoint(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 newPoint = (p - trans);\n    newPoint = rotateX(rotateY(rotateZ(newPoint, -rot.z), -rot.y), -rot.x);\n    return newPoint / scale;\n}\n\n\n//SDFs (all SDFs are taken from https://iquilezles.org/articles/distfunctions)\n//box SDFs\nfloat boxSDF( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxSDF(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    vec3 q = abs(p_transformed) - 0.5;\n    float sdf = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.);\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n// sphere sdf\nfloat sphereSDF(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float sdf = distance(p_transformed, vec3(0, 0, 0)) - 0.5;\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n//triangular prism\n\nfloat triPrismSDF( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat triPrismSDF( vec3 p, vec3 trans, vec3 rot, vec3 scale )\n{\n  vec3 p_transformed = transformPoint(p, trans, rot, scale);\n  vec2 h = vec2(0.5); \n  vec3 q = abs(p_transformed);\n  float sdf = max(q.z-h.y,max(q.x*0.866025+p_transformed.y*0.5,-p_transformed.y)-h.x*0.5);\n  return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n\nfloat sphereSDF( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//SDF operations\n\nfloat unionOp( float d1, float d2 ) { return min(d1,d2); }\n\nfloat subtractionOp( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat intersectionOp( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n//---------------------------------------------------\n//define SDFs\n\n#define WATER_SDF boxSDF(pos, transform.trans, transform.rot, transform.scale)\n\n//multiply by -1 because we are using this as a SKYDOME\n#define SKY_SDF -1. * sphereSDF(pos, transform.trans, transform.rot, transform.scale)\n\n//define colors\n#define SKY_ID -1\n#define SPECULAR_ID 0 \n#define HOUSE_ID 1\n#define OUTLINE_ID 2\n#define WOOD_ID 3\n#define ROOF_ID 4\n#define FENCE_ID 5\n\n//use this function to build the sdf for the house \nvoid houseSDF(vec3 pos, out float house, out float outline, out float wood, out float roof) {\n    //float house; \n    //the position that will be transformed\n    vec3 translate = vec3(0.0); \n    vec3 stored = translate; //use for storing previous translations \n    \n    //transform = translate, rotate, scale \n    Transform transform = Transform(translate, vec3(0), vec3(1));\n    \n    //base of the house \n    translate += vec3(0, 1, 10);\n    vec3 base = translate; //store the base translation \n    float houseBase = boxSDF(pos, translate, vec3(0), vec3(9, 5, 10));\n    \n    //house cap \n    translate += vec3(0, 3.4, 0); \n    float houseCap = triPrismSDF(pos, translate, vec3(0), vec3(10.5, 4, 10));\n    \n    house = unionOp(houseBase, houseCap); \n    \n    //subtract two doors \n    translate += vec3(2, -5, 0);\n    stored = translate; \n    float subLeft = boxSDF(pos, translate, vec3(0), vec3(2, 3, 12)); //left door \n    house = subtractionOp(subLeft, house); \n    \n    translate.x += translate.x * -2.;  \n    float subRight = boxSDF(pos, translate, vec3(0), vec3(2, 3, 12)); //right door \n    house = subtractionOp(subRight, house); \n    \n    translate += vec3(0, .5, -5); \n    float rightDoorOutline = boxSDF(pos, translate, vec3(0), vec3(2., 3, 0.5)); //right door outline \n    float rightDoorSub = boxSDF(pos, translate, vec3(0), vec3(1.0, 2.0, 1)); \n    outline = subtractionOp(rightDoorSub, rightDoorOutline); \n    //outline = rightDoorSub; \n    \n    translate = stored; //reset to left door \n    translate += vec3(0, .5, -5); \n    float leftDoorOutline = boxSDF(pos, translate, vec3(0), vec3(2., 3, 0.5)); //left door outline \n    float leftDoorSub = boxSDF(pos, translate, vec3(0), vec3(1.0, 2.0, 1)); \n    outline = unionOp(outline, subtractionOp(leftDoorSub, leftDoorOutline));\n    \n    //make patio \n    translate += vec3(-2, -1.5, 0); \n    float patio = boxSDF(pos, translate, vec3(0), vec3(9., 0.5, 2)); \n    house = unionOp(house, patio); \n    \n    //make empty window outline\n    translate += vec3(0, 5, 0); \n    float windowOutline = boxSDF(pos, translate, vec3(0), vec3(1.3, 1.5, 0.5)); \n    float windowSub = boxSDF(pos, translate, vec3(0), vec3(1.3 * 0.5, 1.5 * 0.5, 1));\n    outline = unionOp(outline, subtractionOp(windowSub, windowOutline)); \n    \n    //make rest of house outline\n    translate.xy = base.xy; //reset to base\n    translate.x += 4.25; \n    float leftOutline = boxSDF(pos, translate, vec3(0), vec3(0.3, 5, 0.3)); //left outline\n    outline = unionOp(outline, leftOutline); \n    \n    translate.xy = base.xy; //reset to base\n    translate.x -= 4.25; \n    float rightOutline = boxSDF(pos, translate, vec3(0), vec3(0.3, 5, 0.3)); //right outline\n    outline = unionOp(outline, rightOutline); \n    \n    translate.xy = base.xy; //reset to base\n    \n    //diagonal outlines of roof \n    translate += vec3(-2.2, 4.0, 0); \n    float rightDiagOutline = boxSDF(pos, translate, vec3(0, 0, -56), vec3(0.3, 5.2, 0.3)); //right diagonal outline\n    outline = unionOp(outline, rightDiagOutline); \n    \n    translate.xy = base.xy; //reset to base\n    translate += vec3(2.2, 4.0, 0); \n    float leftDiagOutline = boxSDF(pos, translate, vec3(0, 0, 360 + 56), vec3(0.3, 5.2, 0.3)); //left diagonal outline\n    outline = unionOp(outline, leftDiagOutline);\n    \n    //make wooden planks along bottom of house (this will be another material)\n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    float woodPlankMiddle = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //middle plank \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpm1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: first standing block \n    wood = unionOp(woodPlankMiddle, wpm1); \n    \n    translate.z += 3.5; \n    float wpm2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: second standing block \n    wood = unionOp(wood, wpm2); \n    \n    translate.z += 3.5; \n    float wpm3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: third standing block \n    wood = unionOp(wood, wpm3); \n    \n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    translate.x += 3.8; //moving plank to the LEFT \n    float woodPlankLeft = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //left plank \n    wood = unionOp(wood, woodPlankLeft); \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpl1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: first standing block \n    wood = unionOp(wood, wpl1); \n    \n    translate.z += 3.5; \n    float wpl2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: second standing block \n    wood = unionOp(wood, wpl2); \n    \n    translate.z += 3.5; \n    float wpl3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: third standing block \n    wood = unionOp(wood, wpl3); \n    \n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    translate.x -= 3.8; //moving plank to the RIGHT \n    float woodPlankRight = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //right plank \n    wood = unionOp(wood, woodPlankRight); \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpr1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: first standing block \n    wood = unionOp(wood, wpr1); \n    \n    translate.z += 3.5; \n    float wpr2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: second standing block \n    wood = unionOp(wood, wpr2); \n    \n    translate.z += 3.5; \n    float wpr3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: third standing block \n    wood = unionOp(wood, wpr3); \n    \n    //make roof \n    translate.xy = base.xy; //reset to base\n    translate += vec3(-3, 3.8, -3); \n    float rightRoof = boxSDF(pos, translate, vec3(0, 0, -56), vec3(0.3, 6.8, 10)); //right roof \n    roof = rightRoof; \n    \n    translate.xy = base.xy; //reset to base\n    translate += vec3(3, 3.8, 0); \n    float leftRoof = boxSDF(pos, translate, vec3(0, 0, 360 + 56), vec3(0.3, 6.8, 10)); //left roof \n    roof = unionOp(roof, leftRoof); \n\n}\n\n//sceneMap3D function which actually creates the scene \nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n\n    //the position that will be transformed\n    vec3 translate = vec3(0.0); \n    \n    float house;\n    float outline;\n    float wood;\n    float roof; \n    houseSDF(pos, house, outline, wood, roof); \n    \n    //house \n    Transform transform = Transform(translate, vec3(0), vec3(2));\n    //t = HOUSE;\n    t = house; \n    obj = HOUSE_ID;\n    \n    //float for distance comparison \n    float t2; \n    \n    \n    //test for outline\n    if((t2 = outline) < t) {\n        t = t2;\n        obj = OUTLINE_ID;\n    }\n    \n    //test for wood\n    if((t2 = wood) < t) {\n        t = t2;\n        obj = WOOD_ID;\n    }\n    \n    //test for roof\n    if((t2 = roof) < t) {\n        t = t2;\n        obj = ROOF_ID;\n    }\n    \n    \n    //water and sky below -------------\n    \n    //water\n    transform = Transform(vec3(0, -3, 0), vec3(0, 0, 0), vec3(1000, 0.3, 1000));\n    if((t2 = WATER_SDF) < t) {\n        t = t2;\n        obj = SPECULAR_ID;\n    }\n    \n    // sky (a sphere surrounding the scene) \n    transform = Transform(vec3(0, 0, 0), vec3(0, 0, 0), vec3(170));\n    if((t2 = SKY_SDF) < t) {\n        t = t2;\n        obj = SKY_ID;\n    }\n    \n   \n}\n\n\n//sceneMap3D function which takes in a position and returns the distance hit at\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\n\n//raymarching function returns the distance hit at (t) and the hitobject id (hitObject) \nvoid march(vec3 origin, vec3 dir, out float t, out int hitObject) {\n    t = 0.01;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObject);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObject = -1;\n}\n\n//raycasting function returns the rayDirection based on the uv \nvec3 rayCast(vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, up));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY / 2.0);\n    vec3 H = R * length(F) * tan(FOVY / 2.0) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n//ambient occlusion function referenced from https://www.shadertoy.com/view/3sB3zV\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n//sky colors\n//referenced from here https://www.shadertoy.com/view/MlSSR1\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0, -100. ).x;\n    return f/0.9375;\n}\n\nvec3 skyCol(vec3 ro, vec3 rd, vec3 light) {\n    vec3 col = vec3(0.0); \n    \n    // sky colour        \n    //blue skies\n    vec3 blueSky = vec3(0.3,.55,0.8);\n    vec3 redSky = vec3(0.8,0.8,0.6);\n    \n#ifdef BLUE_SKY\n    //blue skies\n    blueSky = vec3(0.3,.55,0.8);\n     redSky = vec3(0.8,0.8,0.6);\n#endif \n    \n#ifdef INDIGO_SKY\n    //indigo skies \n    blueSky = vec3(76, 76, 204) / 255.; \n    redSky = vec3(0.8,0.8,0.6); \n#endif \n\n#ifdef PINK_SKY    \n    //pink skies \n    blueSky = vec3(204, 76, 140) / 255.; \n    redSky = vec3(76, 76, 204) / 255.; \n#endif\n    \n#ifdef PURPLE_SKY\n    //purple skies \n    blueSky = vec3(140, 76, 204) / 255.; \n    redSky = vec3(0.8,0.8,0.6); \n#endif\n    \n#ifdef GREEN_SKY\n    //green skies \n    blueSky = vec3(28, 126, 15) / 255.; \n    redSky = vec3(105, 204, 76) / 255.; \n#endif\n    \n#ifdef ORANGE_SKY\n    //orange \n    blueSky = vec3(244, 146, 60) / 255.; \n    redSky = vec3(0.8,0.8,0.6);\n#endif \n\n#ifdef RED_SKY\n    blueSky = vec3(222, 78, 71) / 255.; \n    redSky = vec3(0.8,0.8,0.6);\n#endif\n\n    \n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n\n    col =  sky*(1.0-0.8*rd.y);\n\n#ifdef STARS\n    // stars\n    \n    float s = texture( iChannel0, rd.xz * 1.25, -100. ).x;\n    s += texture( iChannel0, rd.xz* 4., -100. ).x;\n\n    s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n    if (s > .0)\n    {\n        vec3 backStars = vec3(s);\n        col += backStars;\n    }\n#endif\n    \n\n    // sun\n    col += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n    col += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n    col += 0.95*vec3(1.)*pow(sundot, 256.);\n\n#ifdef CLOUDS\n    // clouds\n    float cloudSpeed = 0.01;\n    float cloudFlux = 0.5;\n\n    // layer 1\n    vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n\n    vec2 sc = cloudSpeed * 50.*iTime * ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n    col = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n\n    // cloud layer 2\n    sc = cloudSpeed * 30.*iTime * ro.xz + rd.xz*(500.0-ro.y)/rd.y;\n    col = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n#endif\n\n    // horizon        \n    col = mix( col, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n    // contrast\n    col = clamp(col, 0., 1.);\n    col = col*col*(3.0-2.0*col);\n    \n    \n    // saturation (amplify colour, subtract grayscale)\n    float sat = 0.2;\n    col = col * (1. + sat) - sat*dot(col, vec3(0.33));\n    \n    return col; \n\n\n\n}\n\n//--------------------------------------\n//testing color palettes\n//referenced from https://iquilezles.org/articles/palettes\nconst vec3 a = vec3(100, 23, 250) / 255.;\n//const vec3 a = vec3(48, 7, 93) / 255.;\nconst vec3 b = vec3(0.5, 0.3, 0.);\nconst vec3 c = vec3(0.25, 0.5, 0.0);\nconst vec3 d = vec3(0., 0., 0.);\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//-------------------\n\n//DEFINE COLORS HERE --------\n//water and colors inspired by https://www.shadertoy.com/view/wdXfRH\n//test lambert colors \n#define LAMBERT_RED lightColor * vec3(1.0, 0.0, 0.0) * lambert\n#define LAMBERT_GREEN lightColor *  vec3(0.0, 1.0, 0.0) * lambert\n#define LAMBERT_BLUE lightColor * vec3(0.0, 0.0, 1.0) * lambert\n#define LAMBERT_YELLOW lightColor * vec3(1.0, 1.0, 0.0) * lambert\n\n#define HOUSE_PURPLE lightColor * palette(0.8 - smoothstep(0.15, 0.9, FractalBrownian3D(p/1.5, 4, false)), a, b, c, d)  * lambert \n#define ROOF_COLOR lightColor * vec3(255, 234, 197) / 255. * lambert\n#define WOOD_COLOR lightColor * vec3(172, 114, 14) / 255. * lambert\n\n#define SKY skyCol(p, -view, lightVec) \n//#define SKY vec3(0.85,0.82,0.85) + smoothstep(-0.1, -0.3, view.y)*vec3(-.2, -.07, -.05)\n//#define SKY palette(iTime * 0.1, a, b, c, d) //how would I improve this? \n//#define SKY vec3(0.8,0.5,0.2) + smoothstep(-0.2, -0.3, view.y)*vec3(-0, -.4, 0.5)\n//#define SKY vec3(0.0, 1.0, 0.0) \n//computes the shading \nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    //calculate lambert shading\n    float lambert = clamp(dot(lightVec, n) + AMBIENCE, 0., 1.);\n    vec3 h = normalize((view + lightVec) / 2.);\n    float hdotn = dot(h, n);\n    float specular = 0.;\n    if (hdotn > 0.) {\n        specular = clamp(max(pow(dot(h, n), 15.), 0.), 0., 1.);\n    }\n    \n    switch (hitObj) {\n        case HOUSE_ID:\n        vec3 c = (1. - HOUSE_PURPLE) * 0.4 + HOUSE_PURPLE; //creates lighter tint \n        return c; \n        //return HOUSE_PURPLE;\n        break;\n        case OUTLINE_ID:\n        return ROOF_COLOR;\n        break;\n        case WOOD_ID:\n        return WOOD_COLOR;\n        case ROOF_ID:\n        return ROOF_COLOR; \n        break;\n        case SKY_ID:\n        return SKY; \n        break;\n    \n    }\n    \n    \n    return SKY; \n\n}\n\n// water reflection logic\n// mat2 for waterMap\nconst mat2 m = mat2( 0.60, -0.80, 0.80, 0.60 );\n\n// modified from https://www.shadertoy.com/view/MsB3WR\n// maps water based on x and z of plane\nfloat waterMap( vec2 pos ) {\n    float radius = length(pos - eye.xz);\n\tvec2 posm = pos * m;\n    if (radius > 10. && radius < 50.) {\n        return (1. - smoothstep(30., 50., radius)) * (smoothstep(10., 30., radius)) \n            * abs( FractalBrownian2D(vec2(posm), true) - 0.8 )* 0.05;\n    } else {\n        return 0.;\n    }\n}\n\n\n//function which computes normals based on the sceneMap \nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, EPSILON, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n//sdf3D marches the ray and gets the t and obj hit and computes the isect and gets the material color\nIntersection sdf3D(vec3 dir) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 origIsect = eye + t * dir; // get the point of intersection on the ray\n    vec3 isect = origIsect; // store this, will need it for specular calculation \n    vec3 nor = computeNormal(isect);\n    vec3 surfaceColor = vec3(1.);\n    \n    \n    //specular logic here\n     while (hitObj == SPECULAR_ID) {\n        // compute normal of waterMap sdf\n        vec2 pos = isect.xz; \n        vec2 epsilon = vec2( EPSILON, 0. );\n        nor = vec3( 0., 1., 0. );\n\t\tnor.x = (waterMap(pos + epsilon.xy) - waterMap(pos - epsilon.xy) ) / (2. * EPSILON);\n\t\tnor.z = (waterMap(pos + epsilon.yx) - waterMap(pos - epsilon.yx) ) / (2. * EPSILON);\n\t\tnor = normalize( nor );\t\n        vec3 rayDir = reflect(dir, normalize(nor));\n        march(isect, rayDir, t, hitObj);\n        // re-compute intersection pt & normal\n        isect = isect + t * rayDir;\n    \tnor = computeNormal(isect);\n        // alter surfaceColor by reflection color\n        surfaceColor *= vec3(0.95, 0.9, 0.85);\n    } \n    \n    vec3 lightDir = normalize(lightPos - isect);\n    //hardcode lightDir\n    lightDir = normalize(vec3(0, -1, -1)); \n    \n    surfaceColor *= computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    // ambient occlusion\n    if (length(isect - vec3(0.)) < 65.) {\n        surfaceColor *= fiveTapAO(isect, nor, FIVETAP_K);\n    }\n    // output origIsect for blur and new isect for fog\n    return Intersection(t, surfaceColor, origIsect, isect, hitObj);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     eye = rotateY(eye, (iMouse.x + 200. - iResolution.x / 2.) / 5.);\n     \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    vec3 rayDir = rayCast(uv); \n\n    // setting the col to the test formula \n    vec3 col = 0.5 * (rayDir + vec3(1.0)); \n    \n    //use the ray direction to get the intersection \n    Intersection isect = sdf3D(rayDir); \n    \n    col = isect.color; \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}