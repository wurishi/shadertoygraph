{"ver":"0.1","info":{"id":"4tyyzW","date":"1535183285","viewed":277,"name":"Transparent sphere raytracer","username":"gPlatl","description":"A simple antialiased transparent sphere raytracer without consider total reflection.\nDo you know better simple transparent sphere examples? Couldn't find anything simple...","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","raytracer","sphere","antialiasing","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Transparent_Sphere_Raytracer.glsl\n//\n// https://www.shadertoy.com/view/4tyyzW\n//\n// v1.0  2018-08-25  initial version\n// v1.1  2018-08-26  antialiasing added\n// v1.2  2018-08-31  getCamera() changed\n//       2018-09-16  working on\n//\n// A simple antialiased transparent sphere raytracer without consider total reflection.\n//\n// tags: raytracer, sphere, transparent, reflection, antialiasing, 3d\n//\n// features:  \n//  - 3d background\n//  - lights: 1\n//  - transparency: yes\n//  - reflection: yes inner and outer\n//  - refraction: no\n//  - antialiased sphere rendering without multisampling\n//---------------------------------------------------------\n// see also:\n// Thick glass shell:   https://www.shadertoy.com/view/MsdcWr\n\n//------- ray -------\nstruct Ray\n{\n  vec3 origin;\n  vec3 direction;\n};\nRay ray1 = Ray(vec3(0), vec3(0,0,1));\n\n//------- sphere -------\nstruct Sphere\n{\n  vec3 center;\n  float radius;\n  vec3 color;\n};\nSphere sphere1 = Sphere(vec3(0), 2.0, vec3(0.2,0.7,2.0));\n\n// float square: f^2 = f*f\n#define sqr(f) (f*f)\n\nvec2 uv = vec2(0);\n\n//----------------------------------------------------------\n// return pixel color of cubemap\n//----------------------------------------------------------\nvec3 cubemapColor(vec3 raydir)\n{\n    return vec4(texture(iChannel1, raydir).rgb, 1.0).xyz;\n}\n//----------------------------------------------------------\n// get background color with rotating light\n//----------------------------------------------------------\nvec3 backgroundColor(float time, vec3 rd)\n{\n  vec3 light = normalize(vec3(sin(time), 0.6, cos(time)));\n  float sun = max(0.0, dot(rd, light));\n  float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n  float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, -0.5+iMouse.y/iResolution.y)));\n  return (pow(sun, 256.0)+0.4*pow(sun, 22.0))*vec3(3.0, 2.0, 1.0) +\n          pow(ground, 0.4)*vec3(0.7, 0.6, 0.4) +\n          sky*vec3(0.5, 0.6, 0.7);\n}\n//----------------------------------------------------------\n// return 2 sphere intersection point distances of ray\n//----------------------------------------------------------\nvec2 RaySphereIntersection (in Ray ray, in Sphere sphere)\n{\n  vec3  h = ray.origin - sphere.center;\n  float b = dot(ray.direction, h);\n  float c = dot(h,h) - sqr (sphere.radius);\n  float d = b*b - c;\n  if (d < 0.0) return vec2(-1.0);\n  d = sqrt(d);\n  return vec2 (-d-b, d-b);\n}\n//----------------------------------------------------------\n// return camera origin and direction\n//----------------------------------------------------------\nRay getCamera() \n{\n  uv = (2.0*gl_FragCoord.xy / iResolution.xy - 1.0)\n       * vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 mo = iMouse.xy / iResolution.y * 3.5;\n  vec3 ro = 3.0 * vec3(sin(mo.x), 2.0-mo.y, cos(mo.x));\n  vec3 z = normalize(ro);\n  vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n  vec3 rd = mat3(x, cross(z, x), z) * vec3(uv, -1.0);\n  return Ray(ro,rd);\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  Ray camera = getCamera();\n  vec3 color1 = cubemapColor (camera.direction);  \n    \n  ray1.origin = vec3(0, 0, -2.9);\n//  ray1.origin = camera.origin;\n  ray1.direction = normalize(vec3(uv, 1.0));\n  vec2 tt = RaySphereIntersection (ray1, sphere1);\n\n  // outer sphere reflection\n  vec3 S1 = ray1.origin + ray1.direction*tt.x;   // S1 = sphere intersection point 1\n  vec3 S2 = ray1.origin + ray1.direction*tt.y;   // S2 = sphere intersection point 2\n  vec3 normal = normalize(sphere1.center - S1);  // normal at S1\n  vec3 reflectedRay = reflect(ray1.direction, normal);\n  vec3 color2 = backgroundColor(iTime, reflectedRay);\n//  vec3 color2 = cubemapColor (reflectedRay);  \n  \n  // antialiased mixing background with reflected sphere color\n  color2 *= sphere1.color;          // change color of the sphere to blue\n  float aa = 1.4 * (tt.y - tt.x);   // antialiasing sphere outline factor\n  color2 = mix (color1, color2, smoothstep(0.0, 1.0, aa));\n  color2 = mix (color1, color2, smoothstep(0.0, 1.0, tt.x-0.8)); // transparency\n\n  // inner sphere reflection\n  normal = normalize(sphere1.center - S2);   // normal at S2\n  reflectedRay = reflect(ray1.direction, -normal); // get iner sphere reflection\n  color1 = backgroundColor(iTime, reflectedRay);\n  color2 = mix(color1, color2, 0.8);\n\n  fragColor = vec4(color2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}