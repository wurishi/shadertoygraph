{"ver":"0.1","info":{"id":"4XX3WH","date":"1708025525","viewed":43,"name":"bipboup3000","username":"Raphalator","description":"modélisation et création d'opérateur simple dans le cadre de lifagraphique","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["modelisation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  ro=vec3(100.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\nfloat Intersect(float a, float b){\n    return max(a,b);\n}\n\nfloat Difference(float a, float b){\n    return max(a,-b);\n}\n\nfloat Arrondi(float a, float b){\n    return a - b;\n}\n\nfloat Maigrir(float a, float b){\n    return a + b;\n}\n\nvec3 Translation(vec3 p, vec3 translation)\n{\n    return p + translation;\n}\n\nfloat Lissage(float a, float b, float r){\n    float h = max(r - abs(a - b), 0.) / r;\n    return min(a, b) - ((1. / 6.) * r * (h * h * h));\n}\n\nvec2 make_Complex_expo(float r, float theta_deg){\n    float theta_rad = radians(theta_deg);\n    vec2 z;\n    z = vec2(r*cos(theta_rad), r*sin(theta_rad));\n    return z;\n}\nvec3 Rotate(vec3 p , vec3 c, float theta){\n   vec2 rot = make_Complex_expo(1., theta);\n    return (p-c) * vec3(rot.x, 0., rot.y) + c;\n}\n\n\n\n\n//rotation de l'objet (ça marche :)) mais soucis sur le pivot pour certaine forme )\n//wikipédia https://fr.wikipedia.org/wiki/Matrice_de_rotation#:~:text=En%20math%C3%A9matiques%2C%20et%20plus%20pr%C3%A9cis%C3%A9ment,I%20est%20la%20matrice%20identit%C3%A9.\nvec3 rotateZ(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateXYZ(vec3 p, float angleX, float angleY, float angleZ) {\n    vec3 rotated_p = rotateX(p, angleX);\n    rotated_p = rotateY(rotated_p, angleY);\n    rotated_p = rotateZ(rotated_p, angleZ);\n    return rotated_p;\n}\n\n\n// Primitives\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n//Plan\n//c : Point du plan\n//p : Position\n//n : Normale au plan\nfloat Plan(vec3 p, vec3 c, vec3 n){\n    return dot(p-c, normalize(n));\n}\n\n\nfloat dCercle(vec3 p, vec3 c, vec3 n, float R){\n    vec3 hv = (p - c) - n;\n    float h = length(hv);\n    vec3 diff = p - c;\n    vec3 lv = sqrt(dot(diff, diff) - (hv * hv));\n    float l = length(lv);\n    float m = l - R;\n\n    float d = sqrt((h*h) - (m*m));\n    return d;\n}\n\n//Tore\n//c : center of skeleton\n//p : Position\n//n : Normale au plan\n//R : Rayon de rotation\n//r : Rayon de TORE\n//fonctionne mal.\n\nfloat Tore(vec3 p, vec3 c, vec3 n, float R, float r){\n   return dCercle(p, c, n, R) - r ;\n}\n\n//Tore d'internet (pas le mien)\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n//Cube\n//c : center of skeleton\n//p : Position\n//h : hauteur\n//l : largeur\n//w : profondeur\nfloat Cube(vec3 p, vec3 c, float h, float l, float w){  \n    h = h / 2.0;\n    l = l / 2.0;\n    w = w / 2.0;\n\n    // Plan du cube\n    float p1 = Plan(p, Translation(c, vec3(-h, 0.0, 0.0)), vec3(-1.0, 0.0, 0.0));\n    float p2 = Plan(p, Translation(c, vec3(h, 0.0, 0.0)), vec3(1.0, 0.0, 0.0));\n    float p3 = Plan(p, Translation(c, vec3(0.0, 0.0, w)), vec3(0.0, 0.0, 1.0));\n    float p4 = Plan(p, Translation(c, vec3(0.0, 0.0, -w)), vec3(0.0, 0.0, -1.0));\n    float p5 = Plan(p, Translation(c, vec3(0.0, l, 0.0)), vec3(0.0, 1.0, 0.0));\n    float p6 = Plan(p, Translation(c, vec3(0.0, -l, 0.0)), vec3(0.0, -1.0, 0.0));\n\n    // Intersection des plans pour former le cube\n    return Intersect(Intersect(p1, Intersect(p2, Intersect(p3, p4))), Intersect(p5, p6));\n}\n\n//Pyramid\n//c : center of skeleton\n//p : Position\n//L : Longueur\n//l : largeur\nfloat Pyramid(vec3 p, vec3 c, float l, float L){\n    L ;\n    l ;\n    \n    // Base pyramide\n    float basePlane = Plan(p, Translation(c, vec3(0.0, -L, 0.0)), vec3(0.0, -1.0, 0.0));\n\n    // Côtés pyramide\n    float p1 = Plan(p, Translation(c, vec3(l, -L, l)), normalize(vec3(1.0, 1.0, 0.0)));\n    float p2 = Plan(p, Translation(c, vec3(-l, -L, l)), normalize(vec3(-1.0, 1.0, 0.0)));\n    float p3 = Plan(p, Translation(c, vec3(0.0, -L, -l)), normalize(vec3(0.0, 1.0, -1.0)));\n    float p4 = Plan(p, Translation(c, vec3(0.0, -L, l)), normalize(vec3(0.0, 1.0, 1.0)));\n\n    // Intersection des plans \n    return Intersect(basePlane, Intersect(p1, Intersect(p2, Intersect(p3, p4))));\n}\n\n//Capsule\n//p : Position\n//a : Extrémité 1\n//b : Extremité 2\n//r : rayon\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 u = normalize(b-a);\n    if(dot(p-a,u) < 0.){\n        return length(p-a) - r;\n        }\n    else if (dot(p-b,-u) < 0.){\n        return length(p-b) - r;\n        }\n    else {\n        return sqrt( length(p-a) * length(p-a) - dot(p-a, u) * dot(p-a, u)) - r;\n    }\n}\n//Cylinder\n//p : Position\n//a : Centre 1\n//b : Centre 2\n//r : Rayon\nfloat Cylinder (vec3 p, vec3 a, vec3 b, float r){\n    float v = Capsule(p,a,b,r);\n    float p1 = Plan(p,a,a-b);\n    float p2 = Plan(p,b,b-a);\n    return Intersect(p1,(Intersect(p2,v)));\n}\n\n\n\n//code d'internet\nfloat sdCylinder(vec3 p, vec2 c) {\n    return length(p.xz - c) - c.y;\n}\n\n\n\nfloat bol(vec3 p, float r, vec3 pos){\n    float v1 = Difference(\n    Sphere(p,vec3(0. + pos.x, 0. + pos.y, r/2. + pos.z), r),\n    Cube(p,vec3(0. + pos.x, 0. + pos.y, r + pos.z), r * 2.,  r * 2.,  r * 2.));\n    \n    float v2 = Difference(\n    Sphere(p,vec3(0. + pos.x, 0. + pos.y,(r - 0.5)/2. + pos.z),r),\n    Cube(p,vec3(0.+ pos.x, 0. + pos.y,(r - 0.5) + pos.z), r * 2.,  r * 2.,  r * 2.));\n    return Difference(\n           v2 , v1);\n}\n\nfloat pierreTombale(vec3 p, vec2 pos){\n    return Arrondi(Union(Union(Lissage(\n                    Cube(p, vec3(pos.x, pos.y, 14.), 2., 2., 10.),\n                    Pyramid(rotateXYZ(p, 90., 0., 0.), vec3(pos.x,  20., pos.y), 1., 1.),\n                    2.),\n                    \n                    Cube(p, vec3(pos.x, pos.y, 15.), 2., 8., 2.) \n                    ),\n                  Difference(Difference(Union(\n                  Cube(p, vec3(pos.x, pos.y, 0.), 5., 10., 15.), \n                  Cylinder(p, vec3(2.5 + pos.x, pos.y, 7.5), vec3(-2.5+ pos.x, pos.y, 7.5), 5.)),\n                  Union(\n                  Cube(p, vec3(3.2 + pos.x, pos.y, 1.), 3., 8., 13.), \n                  Cylinder(p, vec3(3.2 + pos.x, pos.y, 7.5), vec3(1.7 + pos.x, pos.y,7.5), 4.))\n                  ),Union(Cube(p, vec3(2. + pos.x, pos.y, 7.), 1., 1., 5.),Cube(p, vec3(2. + pos.x, pos.y, 7.5), 1., 4., 1.)) \n                  )),0.02);\n}\n\nfloat pierre(vec3 p, vec2 pos){\n    return Lissage(Sphere(p, vec3(pos.x, pos.y+1., -3.), 1.), Sphere(p, vec3(pos.x, pos.y, -3.), 1.5), 0.5);\n}\n\nfloat flecheSimple(vec3 p, vec3 pos){\n    return Union(Cylinder(p, vec3(0.+pos.x, 2. + pos.y, 0. + pos.z), vec3(0. +pos.x, -10. + pos.y, 0. + pos.z), 0.2),\n              Union(Cube(p, vec3(0.+pos.x, 0. + pos.y, 0. + pos.z), 0.1 ,3., 2.),\n                    Cube(p, vec3(0.+pos.x, 0. + pos.y, 0. + pos.z), 2. ,3., 0.1)));\n}\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  float v=Union(\n    Sphere(p,vec3(3.,5.,5.),3.),\n    Sphere(p,vec3(3.,0.,5.),3.)\n  );\n  \n // float v2= DemiSphere(p , 12.);\n\n    \n  float v1 = Sphere(p, Rotate(vec3(5.,0.,0.),vec3(0.,0., 0.),iTime *10. ), 10.);\n  \n  float v2 = Pyramid(p, vec3(0., 0., 0.), 15., 10.);\n  \n  float v3 = Capsule(p, vec3(0, 20, 0), vec3(0, -20., 0), 5.);\n\n  float v4 = Tore(p,vec3(0.,0.,0.),vec3(1.,0.,0.),0.3,0.5);\n  \n  float v5 = Plan(p, vec3(0., 0., -3.), vec3(0.0, 0.0, 1.));\n  \n  float v6 = Cylinder(p, vec3(0, 20, 0), vec3(0, -20., 0), 5.);\n  \n  float v7 = bol(p, 10.,vec3(0., 0., 20.));\n  \n  float v8 = Lissage(Sphere(p, vec3(0, 0, 0), 10.), \n              Union(Union(Sphere(p, vec3(10., 0., 10.), 6.),Cylinder(p, vec3(8.5, 0., 8.5), vec3(6.5, 0., 6.5), 6.)),\n                    Union(Sphere(p, vec3(-10., 0., 10.), 6.), Cylinder(p, vec3(-8.5, 0., 8.5), vec3(-6.5, 0., 6.5), 6.) )),\n              3.); //grave cool !\n  \n  float v9 = Cube(p, vec3(0., 0., 0.), 15. ,20., 10.);\n  \n  float r1 = Capsule(rotateXYZ(p, iTime *10.,iTime *10., iTime *10.), vec3(0, 20, 0.), vec3(0, -20., 0), 5.);\n  \n  float r2 = Union(\n              pierreTombale(rotateXYZ(p, 0., 20., -60.), vec2(10., 0.)),\n              Union(Union(\n              pierre(p, vec2(10., 10.)),\n              pierre(rotateXYZ(p, 0., 4., 5.), vec2(3., 14.))),\n              pierre(rotateXYZ(p, 0., 0., 0.), vec2(10., 5.)))); //j'vais pleurer c'est trop bien\n  //rotateXYZ(p, 0., 30., 65.)\n  \n  float v10 = Lissage(Union(Sphere(p, vec3(-15., -26., -3), 12.), \n                            Sphere(p, vec3(-15.,-26., 36.), 12.)),\n                            Union(\n                            Cylinder(p, vec3(-15., -26., 30), vec3(-15., -26., -3.), 10.),\n                            bol(rotateXYZ(p,180.,0., 0.), 50., vec3(-14., 26., -30.))\n                            ),4.); //test champignon\n                            \n  float v11 = Union(Union(\n                      flecheSimple(rotateXYZ(p,0.,0., 20.), vec3(0.,18.,5.)),\n                      flecheSimple(rotateXYZ(p,-0.,10.,50.), vec3(-2.,18.,5.))),\n                      flecheSimple(rotateXYZ(p,10.,5., -0.), vec3(2.,18.,5.))\n                      );\n  \n  return   Union(Union(v5,v11), r2); \n}\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.05, 0.05, 0.2),vec3(0.7, 0.05, 0.05),d.z*.5+.5);\n  //return vec3(0.7, 0.05, 0.05);\n  //return vec3(0.05, 0.05, 0.2);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=false;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,10000.,hit,s);\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,2.);\n}\n","name":"Image","description":"","type":"image"}]}