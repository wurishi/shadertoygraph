{"ver":"0.1","info":{"id":"wdGfz1","date":"1606570014","viewed":384,"name":"Cookie Live Stream nov20 02","username":"NuSan","description":"Shader coded live in 30m during Cookie Live Stream 27 november 2020\nhttps://www.twitch.tv/cookiedemoparty","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader coded live in 30m during Cookie Live Stream 27 november 2020\n// https://www.twitch.tv/cookiedemoparty\n// I first made the background using 2D lines and circles\n// then I added the 3D shape on top that can \"distord\" the background\n\n// You can disable the 3D shape to see the 2D background\n#define SHAPE_3D 1\n\nfloat time = 0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat rnd(float t) {\n  \n  return fract(sin(t*425.512)*742.712);\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0));\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nfloat map(vec3 p) {\n  \n  float t=time*.3 + curve(time, .7)*5.0;\n  p.xz *= rot(t);\n  p.yz *= rot(t*.3);\n  \n  p = abs(p)-curve(time, .21)*5.0;\n  p = abs(p)-curve(time, .32)*2.0;\n  \n  float d = box(p, vec3(1.0+curve(time, .1)));\n  \n  vec3 p2 = p;\n  float t2 = time;\n  p2.xy *= rot(t2);\n  p2.zy *= rot(t2*1.3);\n  p2 = abs(p2)-curve(time,.4)*3.0;\n  d = min(d, length(p2.xz)-.2);\n  \n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // slowed down the time because there is no music to pump it up\n  time = mod(iTime*0.3, 300.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 col=vec3(0);\n  \n    \n  #if SHAPE_3D\n  vec3 s=vec3(0,0,-20);\n  vec3 r=normalize(vec3(-uv,1));\n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      uv += map(p+r)*.14;\n      break;\n    }\n    if(d>100.0) {\n      break;\n    }\n    p+=r*d;\n  }\n  \n  col += 0.1/(0.1+abs(map(p+r)));\n  #endif\n  \n  bool stop = rnd(floor(time*1.0+.3))>0.3;\n  float ss = 10.0 + floor(pow(curve(time, 3.0),20.0)*100.0);\n  //if(!stop) uv.x += sin(abs(uv.x+sin(time))+sin(uv.y*10+time)*0.1)*.3;\n  float off = floor(uv.x*ss)/ss;\n  if(stop) off=0.0;\n  \n  uv.y -= pow(curve(time+rnd(off+.1), .3),4.0)*.3;\n  uv.x -= (curve(time+rnd(off), .4)-.5)*.1;\n  \n  \n  \n  \n  for(float i=0.0; i<30.0; ++i) {\n    \n    vec2 p = uv;\n    float t = time*.7;\n    float t2 = curve(time + i, 0.7)*3.0;\n    p *= rot(t+i*.2 + sin(t + i));\n    p.x-=sin(t2 + i*7.3)*0.3;\n    p.x += pow(curve(time, .7),4.0)*.7-.3;\n    \n    col += vec3(1,0.7-sin(i*3.7)*.3,0.8-sin(i))*0.002*exp(-fract(time+i*.1))/(0.003+abs(p.x));\n    col += 0.001/(0.003+abs(length(p)-.3));\n  }\n  \n  col *= 0.7+curve(time,.2)*.3;\n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(curve(time*10.0 - length(uv)*10.0,1.0)*3.0+1.0));\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}