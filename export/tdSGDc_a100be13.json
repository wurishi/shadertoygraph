{"ver":"0.1","info":{"id":"tdSGDc","date":"1550127195","viewed":1549,"name":"Fast Shadow for Rectangle","username":"kanro","description":"Create a fast shadow for rect by 1-D Box","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","blur","shadow","rectangle","gaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: http://stereopsis.com/shadowrect/\n\n// blend two color by alpha\nvec4 blend(vec4 src, vec4 append) {\n  \treturn vec4(src.rgb * (1.0 - append.a) + append.rgb * append.a,\n              1.0 - (1.0 - src.a) * (1.0 - append.a));\n}\n\n// approximation to the gaussian integral [x, infty)\nfloat gi(float x) {\n\tfloat i6 = 1.0 / 6.0;\n\tfloat i4 = 1.0 / 4.0;\n\tfloat i3 = 1.0 / 3.0;\n\n    if (x > 1.5) return 0.0;\n    if (x < -1.5) return 1.0;\n\n    float x2 = x * x;\n    float x3 = x2 * x;\n    \n    if (x >  0.5) return .5625  - ( x3 * i6 - 3. * x2 * i4 + 1.125 * x);\n    if (x > -0.5) return 0.5    - (0.75 * x - x3 * i3);\n    return 0.4375 + (-x3 * i6 - 3. * x2 * i4 - 1.125 * x);\n}\n\n// create a line shadow mask\nfloat lineShadow(vec2 border, float pos , float sigma) {\n    float t = (border.y - border.x) / sigma;\n    \n    float pos1 = ((border.x - pos) / sigma) * 1.5;\n    float pos2 = ((pos - border.y) / sigma) * 1.5;\n    \n  \treturn 1.0 - abs(gi(pos1) - gi(pos2));\n}\n\n// create a rect shadow by two line shadow\nfloat rectShadow(vec4 rect, vec2 point, float sigma) {\n    \n    float lineV = lineShadow(vec2(rect.x, rect.x + rect.z), point.x, sigma);\n    float lineH = lineShadow(vec2(rect.y, rect.y + rect.w), point.y, sigma);\n    \n  \treturn lineV * lineH;\n}\n\n// draw shadow\nvec4 drawRectShadow(vec2 pos, vec4 rect, vec4 color, float sigma) {\n    vec4 result = color;\n    \n    float shadowMask = rectShadow(rect, pos, sigma);\n    \n    result.a *= shadowMask;\n    \n\treturn result;\n}\n\n// check a point in a rect\nfloat insideBox(vec2 v, vec4 pRect) {\n   vec2 s = step(pRect.xy, v) - step(pRect.zw, v);\n  return s.x * s.y;\n}\n\n// draw rect\nvec4 drawRect(vec2 pos, vec4 rect, vec4 color) {\n    vec4 result = color;\n    \n    result.a *= insideBox(pos, vec4(rect.xy, rect.xy+rect.zw));\n    return result;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float sigma = 60. * iMouse.x / iResolution.x;\n    sigma += step(iMouse.x, 0.0) * 30.;\n    \n    float z = sigma * iMouse.y / iResolution.y;\n    \n    vec4 result = vec4(1.0);\n    \n    vec3 rectColor = hsv2rgb(vec3(fract(iTime * 0.1), 0.8, 0.8));\n    \n    vec4 rect = vec4(iResolution.xy / 2.0 - 100., vec2(200.,200.));\n    vec4 color = vec4(rectColor,1.0);\n    \n    vec4 shadowRect = vec4(vec2(rect.x + sqrt(z), rect.y - sqrt(z)), rect.zw);\n    vec4 shadowColor = vec4(rectColor,sin(iTime) * 0.2 + 0.8);\n    \n  \tresult = blend(result, drawRectShadow(fragCoord, shadowRect, shadowColor, sigma));\n  \tresult = blend(result, drawRect(fragCoord, rect, color));\n    \n    fragColor = result;\n}","name":"Image","description":"","type":"image"}]}