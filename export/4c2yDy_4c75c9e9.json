{"ver":"0.1","info":{"id":"4c2yDy","date":"1726548225","viewed":26,"name":"Fork Diffusion  wuta_1 792","username":"wuta_1","description":"little modification to the original shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","mathematics"],"hasliked":0,"parentid":"3sGXRy","parentname":"Diffusion and gathering"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )\n\nconst float PI  = 3.141592653589793;\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = (2. * u - res) / min(res.x, res.y);\n    \n    \n    float t = iTime;\n    float scale = 2.;\n    z *= scale;\n    \n    const float n = 20.;\n    float f = 0.2;\n    float l = 1.;\n    for (float i = 1.; i <= n; i+=1.) {\n        vec2 p = cexp(vec2(0.,  t/ n* i )) + cexp(vec2(0., 2.* PI/ n* i));\n        float len = length(abs(z - p));\n     \tf = f * len;\n        l = min(l, len);\n    }\n    vec3 color = vec3(9. * sin(iTime), 7. * cos(iTime)+1., 4. * cos(iTime + 2.));\n    O = vec4(vec3(1. / abs(f -50.)), 1.) * vec4(color, 1.);\n    \n    float p = smoothstep(0.05, 0.0, l) * 0.1;\n    O = O + vec4(vec3(p), 1) * vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}