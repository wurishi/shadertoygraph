{"ver":"0.1","info":{"id":"M3XyR2","date":"1726417692","viewed":40,"name":"Harmonic Madness (sine, cosine)","username":"Alexander_Egorov","description":"It's kind of an abstraction.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS   700\n#define MAX_DIST    75.0\n#define EPS         0.001\n#define PI          3.14159265359\n\nstruct obj {\n    float d;\n    int id;\n};\n\nfloat torus ( in vec3 p, in vec2 t )\n{\n    vec2 q  = vec2 ( length ( p.xz) - t.x, p.y );\n    return length ( q ) - t.y;\n}\n\nfloat sphere ( vec3 p, in vec3 center, in float radius )\n{\n    return length ( p - center ) - radius;\n}\n\nfloat plane ( in vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nobj smoothSubtraction ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, -d1, h ) + k*h*(1.0-h), f.id); \n}\n\nobj smoothIntersection ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, d1, h ) + k*h*(1.0-h), f.id); \n}\n\nobj smoothUnion ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, d1, h ) - k*h*(1.0-h), f.id); \n}\n\nobj objmin(obj f, obj s) {\n    if (f.d < s.d)\n        return f;\n    return s;\n}\n\nobj sdf(in vec3 p) {\n    obj sph1 = obj(sphere ( p, vec3 ( 0.0, 3.4, 0.0 ), 1.0 * (1.0 + sin(iTime + PI * 0.75))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph2 = obj(sphere ( p, vec3 ( 3.4, 0.0, 0.0 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph3 = obj(sphere ( p, vec3 ( 0.0, 0.0, 3.4 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph4 = obj(sphere ( p, vec3 ( 0.0, -3.4, 0.0 ), 1.0 * (1.0 + sin(iTime + PI * 0.75))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph5 = obj(sphere ( p, vec3 ( -3.4, 0.0, 0.0 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph6 = obj(sphere ( p, vec3 ( 0.0, 0.0, -3.4 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    \n    obj sph_0 = objmin(objmin( sph5, sph2) , objmin( sph3, sph6));\n    \n    obj sph  = obj(sphere ( p, vec3 ( 0.0, 0.0, 0.0 ), 4.0 ) +  0.025 * cos(2.0 * p.x * p.y * p.z + iTime * 3.0), 0);\n    obj pl   = obj(plane(p, vec4 (0.0, 1.0, 0.0, 5.0)) + 0.5 * sin(length(p) - iTime), 1);\n    \n    obj tor  = obj(torus(p, vec2 (4.0 * (1.0 + sin(1.0 * iTime)), 1)) + 0.01 * (1.0 + sin(15.0 * p.y + 15.0 * p.x + p.z * 15.0 + iTime*5.0)), 2);\n    \n    return objmin(smoothUnion(smoothSubtraction(objmin(sph1, sph4), smoothSubtraction(sph_0, sph, 1.0), 0.5), tor, 3.0), pl); //objmin(sph, pl);\n    //return obj(sphere ( p, vec3 ( 0.0, 0.0, 0.0 ), 5.0) ,0);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, out int steps, out int id )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for ( steps = 0; steps < MAX_ITERS; steps++ )\n    {\n        obj    dist = sdf ( p );\n        id = dist.id;\n        \n        if ( dist.d < EPS )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist.d;\n        \n        if ( totalDist > MAX_DIST )\n            break;\n            \n        p += dist.d * dir;\n    }\n    \n    return p;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 rotate2d(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat2(\n        vec2(angle_cos, angle_sin),\n        vec2(-angle_sin, angle_cos)\n    );\n}\n\nmat3 camera(in vec3 camera_pos, in vec3 look_at_point) {\n    vec3 camera_dir = normalize(look_at_point - camera_pos);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_dir));\n    vec3 camera_up = normalize(cross(camera_dir, camera_right));\n    \n    return mat3(-camera_right, camera_up, -camera_dir);\n}\n\nvec3 generateNormal ( vec3 surfacePoint, float d )\n{ \n    float e = d;\n    float dx1 = sdf(surfacePoint + vec3(e, 0, 0)).d;\n    float dx2 = sdf(surfacePoint - vec3(e, 0, 0)).d;\n    float dy1 = sdf(surfacePoint + vec3(0, e, 0)).d;\n    float dy2 = sdf(surfacePoint - vec3(0, e, 0)).d;\n    float dz1 = sdf(surfacePoint + vec3(0, 0, e)).d;\n    float dz2 = sdf(surfacePoint - vec3(0, 0, e)).d;\n  \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //camera setup\n    vec3 camera_origin = vec3(0.0, 7.0, 0.0);\n    float camera_radius = 4.0;\n    vec3 look_at_point = vec3(0.0, 1.0, 0.0);\n\n    vec2 uv_coord = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    camera_origin.yz = camera_origin.yz * camera_radius * rotate2d(mix(PI / 2.0, 0.0, mouse.y));\n    camera_origin.xz = camera_origin.xz * rotate2d(mix(-PI, PI, mouse.x)) + vec2(look_at_point.x, look_at_point.z);\n    \n    vec3 ray_dir = camera(camera_origin, look_at_point) * normalize(vec3(uv_coord, -1));\n    \n    bool hit;\n    int id;\n    int  steps;\n    vec3 intersectionPoint = trace (camera_origin, ray_dir, hit, steps, id );\n    vec3 surfaceNormal  = generateNormal ( intersectionPoint, 0.001);\n    vec3 lightSource = vec3  ( 15.0, 25.0, 48.0 );\n    if (hit) {\n        vec3 lightVector  = normalize ( lightSource - intersectionPoint );\n        vec3 surfaceNormal  = generateNormal ( intersectionPoint, 0.001 );\n        vec3 reflected = ray_dir - 2.0 * dot(ray_dir, surfaceNormal) * surfaceNormal;\n        float specular = pow(max(dot(reflected, lightVector), 0.0), 16.0);\n        if (id == 0) {\n            fragColor = vec4 ( 2.19 / 2.0, 1.71 / 2.0, 0.37 / 2.0, 0.0 ) * max(dot(surfaceNormal, lightVector), 0.0) + specular + 0.05;\n        } else {\n            fragColor = vec4 ( sin(intersectionPoint.x * 4.0), 0.5 + 0.5  * sin(length(intersectionPoint) - iTime), sin(intersectionPoint.z * 4.0), 0.0 ) * max(dot(surfaceNormal, lightVector), 0.0) * 0.85 + 0.15;\n        }\n    } else {\n        fragColor = vec4 ( 0.1 , 0.3 , 0.45, 1.0 );\n    }\n}","name":"Image","description":"","type":"image"}]}