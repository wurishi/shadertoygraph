{"ver":"0.1","info":{"id":"DlByRy","date":"1691894180","viewed":58,"name":"Compound of three cubes","username":"zenzicubic","description":"Testing\nThis solid appears in M. C. Escher's \"Waterfall\" print","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","escher","compound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nStructs.\n*/\nstruct Hit {\n    bool hit;\n    float t;\n    vec3 pt, normal, col;\n};\n\n/*\nConstants.\n*/\n\n// Constants\n#define PI acos(-1.)\n#define TAU 2. * PI\n#define R iResolution\n#define EPS 1e-5\n#define K 0.707106781187\n\n// Camera/rendering\n#define FOCAL_LEN 1.15\n#define TOP_GRAD vec3(1.)\n#define BOTTOM_GRAD vec3(0.5, 0.7, 1.)\n#define LIGHTDIR normalize(vec3(0., 0., 1.))\n\n#define BOUNCE_COUNT 50\n#define MAX_DIST 50.\n#define ATTENUATION 0.9\n// Scene info\nmat3 lookMat;\nvec3 eye;\n\nmat3[3] matrices = mat3[](mat3(1.,0.,0.,0.,K,K,0.,-K,K), mat3(0.,1.,0.,K,0.,K,K,0.,-K), mat3(0.,0.,1.,K,K,0.,K,-K,0.));\nvec3[3] colors = vec3[](vec3(.7, .05, .05), vec3(.9, .9, .1), vec3(0., 0., .5));\n/*\nScene SDF and marching.\n*/\n\n#define nSq(v) dot(v,v)\n\n#define isCloseTo(a, b) (abs(b - a) < EPS)\n\n// Computes ray-sphere intersection\nHit boxIntersection(vec3 ro, vec3 rd, vec3 col, float maxDist) {\n    Hit hit;\n    hit.hit = false;\n    \n    float t1 = (-1. - ro.x) / rd.x;\n    float t2 = (1. - ro.x) / rd.x;\n    float t3 = (-1. - ro.y) / rd.y;\n    float t4 = (1. - ro.y) / rd.y;\n    float t5 = (-1. - ro.z) / rd.z;\n    float t6 = (1. - ro.z) / rd.z;\n    \n    float tA = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tB = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n    \n    if (tA < 0. || tA > tB || tA > maxDist) return hit;\n    \n    vec3 pt = ro + rd * tA;\n    vec3 normal;\n    if (isCloseTo(pt.x, -1.)) {\n        normal = vec3(-1., 0., 0.);\n    } else if (isCloseTo(pt.x, 1.)) {\n        normal = vec3(1., 0., 0.);\n    } else if (isCloseTo(pt.y, -1.)) {\n        normal = vec3(0., -1., 0.);\n    } else if (isCloseTo(pt.y, 1.)) {\n        normal = vec3(0., 1., 0.);\n    } else if (isCloseTo(pt.z, -1.)) {\n        normal = vec3(0., 0., -1.);\n    } else {\n        normal = vec3(0., 0., 1.);\n    }\n    \n    hit.hit = true;\n    hit.t = tA;\n    hit.pt = pt;\n    hit.normal = normal;\n    hit.col = col;\n    \n    return hit;\n}\n\n// Finds closest intersection in scene, if any\nHit raytraceScene(vec3 ro, vec3 rd) {\n    Hit hit, tmpHit;\n    float minDist = MAX_DIST;\n    \n    hit.hit = false;\n    for (int i = 0; i < 3; i ++) {\n        mat3 m = transpose(matrices[i]);\n        tmpHit = boxIntersection(m * ro, m * rd, colors[i], minDist);\n        if (tmpHit.hit) {\n            minDist = tmpHit.t;\n            tmpHit.normal = matrices[i] * tmpHit.normal;\n            hit = tmpHit;\n        }\n            \n    }\n    return hit;\n}\n\n/*\nMain code.\n*/\n\n// Gets a ray from a given point in screenspace\nvec3 getRay(vec2 p) {\n    vec2 xy = (p - .5 * R.xy) / R.y;\n    vec3 camDir = normalize(vec3(xy, -FOCAL_LEN));\n    return lookMat * camDir;\n}\n\n// Gets the ray color from the scene\nvec3 getColor(vec2 p) {\n    vec3 rd = getRay(p);\n    Hit hit = raytraceScene(eye, rd);\n    \n    if (hit.hit) {\n        return hit.col * clamp(dot(LIGHTDIR, hit.normal), .2, 1.);\n    }\n    \n    return texture(iChannel0, rd).rgb;\n}\n\nvoid computeLookMat(vec3 lookAt) {\n    vec3 F = normalize(lookAt - eye);\n\tvec3 S = normalize(cross(F, vec3(0., 1., 0.)));\n\tvec3 U = cross(S, F);\n    \n    lookMat = mat3(S, U, -F);\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    float t = .5 * iTime;\n    \n    eye = 5. * vec3(cos(t), 0., sin(t));\n    computeLookMat(vec3(0.));\n    \n    vec3 col = getColor(p);\n    \n    /* Convolve with a box blur to apply AA */\n    col += getColor(p + vec2(.5, 0));\n    col += getColor(p + vec2(0, .5));\n    col += getColor(p - vec2(.5, 0));\n    col += getColor(p - vec2(0, .5));\n    col *= .2;\n    \n    col = pow(col, vec3(0.545));\n    k = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}