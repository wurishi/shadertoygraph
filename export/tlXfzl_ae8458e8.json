{"ver":"0.1","info":{"id":"tlXfzl","date":"1597434316","viewed":304,"name":"Ray Marched Clouds","username":"Burnout6010","description":"Two ray marched cloud scenes, comes in plane and sphere shapes","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Hold & drag on window to move view\n#define PI 3.1415f\n#define planeScene 1 //0 is sphere scene, 1 is plane scene\n\n//Unused due to much lower performance\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//Massively faster than the above\nfloat noiseTexture(vec3 pos)\n{\n    return texture(iChannel0, pos * 0.037f).r;\n}\n\n//https://thebookofshaders.com/13/\nfloat fbm(vec3 pos)\n{\n    //Begin values\n    float amplitude = 0.75f;\n    float frequency = 0.2f;\n    float result = 0.f;\n    \n    //Settings\n    const float lacunarity = 2.f;\n    const float gain = 0.5f;\n    const int octave = 4;\n    \n    //Perform fractal brown motion\n    for(int i=0; i < octave; ++i)\n    {\n        result += amplitude * noiseTexture(pos * frequency);\n        amplitude *= gain;\n        frequency *= lacunarity;\n    }\n    \n    return result;\n}\n\n//Plane density\nfloat GetPlaneDens(vec3 point, vec3 normal, float height)\n{\n    return height - dot(point, normal);\n}\n\n//Sphere density\nfloat GetSphereDens(vec3 point, vec3 spherePos, float radius)\n{\n    return (radius - length(point - spherePos));\n}\n\n//Following describes the scene\nfloat GetSceneDensity(vec3 point)\n{\n    float sphereRadius = (sin(iTime) + 2.f) * 2.f;\n    \n    vec3 pMod = vec3(point.x,\n                     point.y - (iTime * 0.8f),\n                     point.z - (iTime * 15.f));\n    \n    float result;\n    //Scene\n    #if planeScene\n    \tresult = fbm(pMod * 0.2f) + GetPlaneDens(point, vec3(0.f,1.f,0.f), -35.f) * 0.018f;\n    #else\n    \tresult = fbm(point * 0.24f + iTime) + GetSphereDens(point, vec3(0.f,0.f,0.f), sphereRadius) * 0.018;\n    #endif\n    \n    return clamp(result, 0.f, 1.f);\n}\n\n//Perform the raymarching itself\nvec4 DoMarch(vec3 dir, vec3 origin)\n{\n    //Settings\n \tconst int maxStep = 64;\n    const float maxDistance = 192.f;\n    const float step = maxDistance / float(maxStep);\n    \n    //Settings light\n    vec3 lightDir = normalize(vec3(0.7f, -0.9f, -0.87f));\n    \n    //Start\n    vec4 col = vec4(0.f, 0.f, 0.f, 0.f);\n    vec3 point = origin;\n    \n    //March into the scene for a maximum amount of steps\n    for(int i=0; i < maxStep; ++i)\n    {\n        float density = GetSceneDensity(point);\n        if(density > 0.f)\n        {\n            //Ambient through density\n            vec4 cloudCol = vec4(\n                mix(vec3(0.9f, 0.9f, 0.85f), vec3(0.1f, 0.1f, 0.25f), density * 1.5f) * density, //rgb\n                density * 0.8f); //alpha\n            \n            //Sunlight\n            vec3 lightPos = point - lightDir * 0.42f;\n            float densityDif = density - GetSceneDensity(lightPos);\n            cloudCol.xyz += vec3(0.9f, 0.7f, 0.2f) * densityDif;\n            \n            //Blend with final colour\n            col += cloudCol * (1.f - col.a);\n        }\n\t\t\n        //Small optimisation\n        if(col.a > 0.99f) { break; }\n        \n        //Step towards next point\n        point += dir * step;\n    }\n    \n    return col;\n}\n\n//Creates the look at matrix for given cam pos and a target to look towards\nmat4 LookAt(vec3 camPos, vec3 target)\n{\n    vec3 forward = normalize(target - camPos);\n    vec3 right = normalize(cross(vec3(0.f, 1.f, 0.f), forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    return mat4(\n        vec4(right, 0.f),\n        vec4(up, 0.f),\n        vec4(forward, 0.f),\n        vec4(camPos, 1.f));\n}\n\n//The main program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Readjust fragcoords to have 0,0 in the middle\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //Mouse remapped to -1, 1\n    vec2 mouse = ((iMouse.xy-0.5f*iResolution.xy)/iResolution.xy) * 2.f;\n\n    //Setup ray\n    const float camDist = -75.f;\n    vec3 camPos = vec3(0.f, 0.f, 0.f)\n        + vec3(sin(-mouse.x * PI), -mouse.y - 1.f, cos(-mouse.x * PI)) * camDist;\n    vec3 camTarget = vec3(0.f, 0.f, 0.f);\n    \n    //Direction of the ray for this fragment, rotated by the LookAt matrix\n    vec3 dir = (LookAt(camPos, camTarget) * normalize(vec4(uv, 1.f, 0.f))).xyz;\n    \n    //March and obtain colour if there is a hit\n    vec4 col = DoMarch(dir, camPos);\n    \n    //Display result, blend bg with marched clouds\n    vec3 bgColour =\n        mix(vec3(0.85f, 0.85f, 0.95f), vec3(0.2f, 0.2f, 0.25f),\n            1.f - fragCoord.y/iResolution.y);\n    fragColor = vec4(mix(col.xyz, bgColour * 5.f, 0.2f - col.w * 0.2f), 1.f);\n    //manipulating opacity/bg strength effectively hides parts of the clouds that are undesired\n}","name":"Image","description":"","type":"image"}]}