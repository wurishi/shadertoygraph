{"ver":"0.1","info":{"id":"WlV3Dm","date":"1579105077","viewed":129,"name":"Heightfield Diffusion of Fluid","username":"Clocktown","description":"Click (and hold if you want) to fill in some fluid. If #define RAIN is enabled in Buf A you will get continous inflow of fluid everywhere.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["heightfield","fluid","rain","diffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5 + 0.5 * (130.0 * dot(m, g));\n}\n\nfloat height_field(vec2 fragCoord) {\n    float n = snoise(fragCoord * 0.0225);\n    vec2 center_coord = fragCoord - 0.5 * iResolution.xy;\n    center_coord /= iResolution.xy;\n    center_coord = 2. * abs(center_coord);\n    vec2 s = 100. * vec2(greaterThan(center_coord, vec2(0.98)));\n    return n + max(s.x, s.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = height_field(fragCoord);\n    float level = texture(iChannel0, fragCoord / iResolution.xy).r;\n    \n    // Do some very simple \"landscape\" shading with earth/trees/snow\n    vec3 hcol = vec3(height);\n    if(height < 0.9) {\n        hcol = height * vec3(0.2, 0.7, 0.3);\n    }\n    if(height < 0.25) {\n        hcol = height * 0.6 * vec3(2., 1., 0.5);\n    }\n    \n    // Water color - darker if more water\n    vec3 col = vec3(0, 0, max(1. - level, 0.3));\n    \n    // Mix landscape and water together\n    col = mix(hcol, col, min(level / 0.7, 1.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    // Uncomment to visualize only fluid height above heightfield height\n    //fragColor.rgb = vec3(level);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define RAIN\n#define RAIN_AMOUNT 0.05\n#define INITIAL_AMOUNT 0.07\n#define INITIAL_CIRCLE_AMOUNT 1.0\n#define SPEED 500.\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5 + 0.5 * (130.0 * dot(m, g));\n}\n\nfloat height_field(vec2 fragCoord) {\n    float n = snoise(fragCoord * 0.0225);\n    vec2 center_coord = fragCoord - 0.5 * iResolution.xy;\n    center_coord /= iResolution.xy;\n    center_coord = 2. * abs(center_coord);\n    vec2 s = 100. * vec2(greaterThan(center_coord, vec2(0.98)));\n    return n + max(s.x, s.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= 0) {\n        // Fill in some initial water everywhere that will flow to the valleys over time\n        fragColor = vec4(float(height_field(fragCoord) < 2.) * INITIAL_AMOUNT, 0, 0, 0);\n        if(length(fragCoord - 0.5 * iResolution.xy) < 100.) {\n            fragColor = vec4(float(height_field(fragCoord) < 2.) * INITIAL_CIRCLE_AMOUNT, 0, 0, 0);\n        }\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float current_level = texture(iChannel0, uv).r;\n    float current_height = height_field(fragCoord);\n    if(current_height >= 2.) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    if((current_height < 2.) && (length(iMouse.zw - fragCoord) < 50.) && (iMouse.zw != vec2(0))) {\n        // Click (and hold) adds more water\n        current_level += 0.01;\n    }\n    \n    #ifdef RAIN\n    if(current_level < 0.8)\n    \tcurrent_level += RAIN_AMOUNT * iTimeDelta;\n    #endif\n\n\n    float level_diff = 0.;\n\n    float current_fheight = current_height + current_level;\n\n    for(int x = -1; x <= 1; ++x) {\n        for(int y = -1; y <= 1; ++y) {\n            if((x == 0) && (y == 0)) {\n                continue;\n            }\n            float height = height_field(fragCoord + vec2(x, y));\n            if(height >= 2.) continue;\n            float level = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).r;\n\n            float fheight = height + level;\n\n            if((fheight >= current_fheight)) {\n                level_diff += 0.5 * 0.125 * min(SPEED * iTimeDelta * (fheight - current_fheight), level);\n            } if(fheight <= current_fheight) {\n                level_diff += 0.5 * 0.125 * max(SPEED * iTimeDelta * (fheight - current_fheight), -current_level);\n            }\n        }\n    }\n\n    fragColor = vec4(max(current_level + level_diff, 0.), 0, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}