{"ver":"0.1","info":{"id":"WltSDM","date":"1581086664","viewed":440,"name":"how to render a black hole -p2","username":"feefi","description":"how to render a black hole, part2 - ray marching with gravity","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 black_hole_pos = vec3(0.0,0,1.5); \t\t//黑洞的位置\nfloat event_horizon_radius = 0.3;\t\t//黑洞的事件视界半径\nfloat HitTest(vec3 p){\n\treturn length(p) - event_horizon_radius;\n}\nvec3 GetBg(vec3 p)\n{\n    return smoothstep(vec3(0),vec3(1.),fract(p*1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //映射到0~1之间\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.  - 1.;\t\n    uv.x *= iResolution.x / iResolution.y;\t\n\tvec3 eye = vec3(0.,0.,-2);    //eye or camera postion 相机位置\n    vec3 sd = vec3(uv.x,uv.y,-1); //screen coord 屏幕坐标\n    vec3 ray_dir = normalize( sd - eye);//ray direction 射线方向\n    \n    vec3 col = vec3(0.);\n    \n\tfloat hitbh = 0.;\n    \n    const int maxStep = 400;//光线最大步进数\n    float st = 0.;      \n    vec3 p = sd;\n    vec3 v = ray_dir;\n    float dt = 0.01;\n    float GM = 0.8;   \n    vec3 cp = black_hole_pos + 2.*vec3(1.5*sin(iTime),sin(1.31*iTime),0.);\n    for(int i = 0;i<maxStep;++i)\n    {\n       \t//F = G * M * m / r^2;\n    \t//a = F/m\n    \t//v = v + a * dt;\n    \t//p = p + v * dt;\n        p += v * dt;\n        vec3 relP = p - cp; //黑洞相对原点的位置       \n        float r2 = dot(relP,relP);\n        vec3 a = GM/r2 * normalize(-relP); //加速度的方向朝向黑洞，为-relP\n        v += a * dt;        \n        float hit = HitTest(relP); //hit表示距物体的最小距离\n\t\thitbh = step(hit,0.);   \n        if(hitbh > 0.5)break;\n    }\n    col = GetBg(p)*(1.-hitbh);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}