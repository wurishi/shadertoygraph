{"ver":"0.1","info":{"id":"XttBzN","date":"1538840857","viewed":100,"name":"Nature Project- Solar System","username":"rlarp","description":"Planets revolving around a central sun. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["solar","system"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.) \n\nstruct Shape{ // Basic constructor for the shapes we will use/create later on. \n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) { // Utility functions that uses fract() to randomize a vec2 variable. \n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){ // Rotates and gives out the rotated matrix. \n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){ // Creates a pole shape\n  return length(v)-r;\n}\n\n\nfloat sphere(vec3 v, float r){ // Creates the spheres. \n  return length(v)-r;\n}\n\nfloat mixColors(float r, float v, float z){ // Mixes the rgb components of color(s) \n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){ // Mixes the colors of shapes and then mixes the shapes too.\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){ // Creates the vine shape that almost everything is based off\n  Shape shape; // Create basic shape first (get the distance and color variables)\n  float vine; \n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 50.; // Vine Repeat\n  float vineOffset = 3.; // Leaf Offset\n\n\n\tvineOffset += cos(iTime*0.5)*1.; // Offset changes through time \n\n  // Stems\n  \tvec3 i = c;\n    i.xz *= rot(c.y*0.35+iTime*0.25); // Rotates vines around the xz axis. \n    float detail = pModPolar(i.yz, twist); \n    \n    //float x = mix(-2., 1., mod(detail, 10.));// Small Ripples\n    float x = mix(0., 1., pModPolar(i.xy, 10.)); // Mixes\n    \n    \n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = 0.25; // How wide the stem (in this case, the sun) is \n  \tvine = pole(i.xz, stemWidth+0.02*cos(i.y*x));\n\n\n  vec4 color = vec4(3.0, 0.5, 0.0, 100.); // Color of the sun \n    \n    float pattern = cos(sin(c.z*10.))/ // Gives sun the burning pattern \n        cos(sin(c.y*2.));\n\n  shape.dist = vine;\n  shape.color = color;\n  shape.color *= pattern;\n\n  return shape;\n}\n\n\nShape orb(vec3 c){ // Orbs used for the revolving planets\n  Shape shape; // Create basic shape \n  float orb;\n  shape.dist = 1.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    i.xy *= rot(iTime); // Rotates orbs about the xy axis\n    i.y = repeat(i.y, 10.5); // Repeats the orbs on the y axis every 10.5 pixels.\n    i.x = abs(i.x)-0.5; // No negatives (unless i.x < 0.5) \n    i.x = abs(i.x)-0.5; // No negatives \n    orb = sphere(i, cos(sin(iTime)*2.25)*0.);\n    \n\n  vec4 color = vec4(0.1, .95, 0.8, 1.);\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c); // Preares to map the sun\n  Shape orbs = orb(c); // Prepares to map the planets\n    \n  float df = mixShapes(vines.dist, orbs.dist, 1.); // Mixes the distance of the vines/orbs.\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*6., \n                    mixColors(orbs.dist, vines.dist, 5.)); // Mixes their colors\n\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y; // Normalize view \n\n  \n  vec3 cam = vec3(sin(iTime)*0.5, sin(iTime), sin(iTime)-11.); // Moves the point of view (camera)\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam; // Sets the scene (which we map later) to what the camera is set as. \n  fragColor = vec4(0.08);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z +=0.05){ // How many steps we are taking (how clear)\n    Shape c = map(scene); // Map the scene\n    if(c.dist < 0.2){\n      fragColor = c.color*(1.-z); // Inverts pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}