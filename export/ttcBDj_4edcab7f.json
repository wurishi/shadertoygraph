{"ver":"0.1","info":{"id":"ttcBDj","date":"1613438772","viewed":361,"name":"random emotes","username":"stb","description":"Basic random emoticons.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["procedural","random","happy","smiley","sad","emoji","emote","emotion","emoticons","smilies","skeptical","concerned","suspicious"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    random emotes\n    2021 stb\n*/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// circle inversion function\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\n// a line of width w, warped by circle inversion, offset by o\nfloat arc(in vec2 p, float w, in vec2 o) {\n    p = cInv(p, vec2(0.), 1.);\n    p = cInv(p, vec2(0., o.y), 1.);\n    p.y -= o.y;\n\n    return  length(vec2(max(0., abs(p.x-o.x)-w), p.y));\n}\n\nfloat emote(vec2 p, vec2 h, float aa) {\n    float f=1., eyes, eyebrows=-.065, mouth, head;\n    vec2 o = vec2(0., 1.);\n    \n    // look variable (where the face is facing)\n    vec2 lk = .5 * (h-.5);\n    \n    // get eyes\n    eyes = length(vec2(abs(p.x-lk.x)-.36+.25*pow(lk.x, 2.), p.y-.27-lk.y)) - .15;\n    \n    // get eyebrows (symmetrical or not)\n    if(fract(3.447*h.x) < .5)\n        eyebrows += arc(vec2(abs(p.x-lk.x)-.35, p.y-lk.y-.5*fract(1.46*lk.y)-.35), .2, 2.*fract(h*2.31)*h.y*o-.5*o);\n    else\n        eyebrows +=\n            min(\n                arc(vec2(p.x-lk.x-.35, p.y-lk.y-.25*fract(2.31*lk.y)-.4), .2, 2.*fract(h*2.31)*h.y*o-.5*o),\n                arc(vec2(-p.x+lk.x-.35, p.y-lk.y-.25*fract(-1.81*lk.y)-.4), .2, 2.*fract(-h*1.92)*h.y*o-.5*o)\n            );\n    \n    // get mouth\n    mouth = arc(p+vec2(0., .35)-.5*lk, .4*pow(h.x, .5), vec2(.35, 1.)*(fract(2.772*h)-.5)) - .08;\n    \n    // get head\n    head = abs(length(p)-1.) - .075;\n    \n    // combine everything\n    f = min(f, eyes);\n    if(fract(4.932*h.x) < .65) // some emotes have eyebrows\n        f = min(f, eyebrows);\n    f = min(f, mouth);\n    f = min(f, head);\n    \n    // result\n    return smoothstep(-aa, aa, f);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc )\n{\n    vec2 res = iResolution.xy;\n    vec2 p   = (fc-res/2.) / res.y;\n    vec2 m   = (iMouse.xy-res/2.) / res.y;\n    \n    float zoom     = iMouse.x>0. ? .0125 + .5 * iMouse.y / res.y : .2;\n    float headSize = 1.3;\n    float aa       = 2. / zoom / res.y * headSize;\n    \n    // zoom\n    p /= zoom;\n    \n    // scroll\n    p.y -= .5 * iTime;\n    \n    // one hash22 to rule them all\n    vec2 h = hash22(ceil(p)+.371);\n    \n    // get emote\n    float f = emote(headSize*(fract(p)*2.-1.), h, aa);\n    \n    // set initial color to black/white emote\n    vec3 col = vec3(f);\n    \n    // apply circles of color\n    if(length(fract(p)-.5) < .5/headSize) {\n        col *= fract(vec3(pow(h.x, .15), pow(fract(1.314*h.y), .15), fract(1.823*h.y)));\n        col *= clamp(2.*(.75-length(fract(p)-vec2(.5, .6))), 0., 1.);\n    }\n    \n    // output\n    fo = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}