{"ver":"0.1","info":{"id":"wlyyRV","date":"1612024161","viewed":370,"name":"Random-Walk Cubes","username":"coposuke","description":"It's my first that random walk.","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["randomwalk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mouse Left  : Roll\n// Mouse Right : Cell Reset (for fullscreen)\n\nstruct Result\n{\n    float dist;\n    float type;\n    vec3 position;\n    vec3 normal;\n};\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat planeDistance(vec3 planePos, vec3 planeNormal, vec3 rayPos, vec3 rayDir)\n{\n    return max(0.0, dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal));\n}\n\nfloat sdCellCube(vec3 pos)\n{\n    vec3 posAbs = abs(pos) - CELL_SIZE * 0.48;\n    return length(max(posAbs, 0.0));\n}\n\nfloat sdCube(vec3 pos, float size)\n{\n    vec3 posAbs = abs(pos) - size;\n    return length(max(posAbs, 0.0));\n}\n\nResult map(vec3 rayPos, vec3 rayDir)\n{\n    Result result;\n    result.type = 1.0;\n\n    // cell grid\n    const vec3 GridStartID = vec3(CUBE_HALFSIZE / CELL_SIZE);\n    vec3 grid = floor(rayPos / CELL_SIZE) + GridStartID;\n    vec3 gridID = mod(grid, CUBE_SIZE);\n    \n    // cell info\n    vec4  cellInfo = texture(iChannel0, getBufferCellUV(gridID, iResolution.xy));\n    float cellExist         = cellInfo.x;\n    vec3  cellDir           = getDirection(cellInfo.y);\n    float cellNeighborExist = cellInfo.z;\n    vec3  cellNeighborDir   = getDirection(cellInfo.w);\n\n    float time = fract(float(iFrame) / MOVE_FRAME);\n    vec3 pos = mod(rayPos, CELL_SIZE) - CELL_SIZE * 0.5;\n    \n    // cell cube\n    result.dist = (1.0 <= cellExist? sdCellCube(pos - CELL_SIZE * cellDir * time) : 1e+2);\n    \n    // neighbor cell cube\n    result.dist = min(result.dist,\n        (1.0 <= cellNeighborExist ? sdCellCube(pos + CELL_SIZE * (cellNeighborDir) * (1.0 - time)) : 1e+2));\n\n    // wall(3 plane)\n    float wallDist = 1e+3;\n    wallDist = min(wallDist, (abs(rayPos.x) < CUBE_HALFSIZE) ? planeDistance(vec3(CUBE_HALFSIZE * sign(rayDir.x), 0.0, 0.0), vec3(1.0, 0.0, 0.0), rayPos, rayDir) + 1e-3 : result.dist);\n    wallDist = min(wallDist, (abs(rayPos.y) < CUBE_HALFSIZE) ? planeDistance(vec3(0.0, CUBE_HALFSIZE * sign(rayDir.y), 0.0), vec3(0.0, 1.0, 0.0), rayPos, rayDir) + 1e-3 : result.dist);\n    wallDist = min(wallDist, (abs(rayPos.z) < CUBE_HALFSIZE) ? planeDistance(vec3(0.0, 0.0, CUBE_HALFSIZE * sign(rayDir.z)), vec3(0.0, 0.0, 1.0), rayPos, rayDir) + 1e-3 : result.dist);\n    result.dist = (wallDist < 1e+4) ? wallDist : result.dist;\n    \n    // center cube\n    vec3 shapeRayPos = rayPos;\n    shapeRayPos.xz *= rotate(iTime * 0.1);\n    shapeRayPos.yz *= rotate(iTime * 0.2);\n    \n    float shapeDist = sdCube(shapeRayPos, 4.0);\n    result.type = (result.dist < shapeDist) ? result.type : 2.0;\n    result.dist = min(result.dist, shapeDist);\n    \n    // anti overshoot cellgrid\n    float disableOvershoot = step(sdCube(rayPos, CUBE_HALFSIZE), 0.0);\n    vec3 cellDist = abs((step(0.0, rayDir) * CELL_SIZE - mod(rayPos, CELL_SIZE)) / rayDir);\n    result.dist = min(result.dist, min(cellDist.x, min(cellDist.y, cellDist.z)) + 1e-3 + disableOvershoot * 1e+3);\n    \n    return result;\n}\n\nvec3 computeNormal(vec3 rayPos, vec3 rayDir)\n{\n    const vec2 EPSILON = vec2(3e-2, 0.0);\n    return normalize(vec3(\n        map(rayPos + EPSILON.xyy, rayDir).dist - map(rayPos - EPSILON.xyy, rayDir).dist,\n        map(rayPos + EPSILON.yxy, rayDir).dist - map(rayPos - EPSILON.yxy, rayDir).dist,\n        map(rayPos + EPSILON.yyx, rayDir).dist - map(rayPos - EPSILON.yyx, rayDir).dist\n    ));\n}\n\nResult march(vec3 cameraPos, vec3 cameraDir)\n{\n    Result result;\n    result.type = 0.0;\n    result.dist = 0.0;\n    \n    vec3 rayPos = cameraPos;\n    float rayDist = 0.0;\n\n    for(int i = 0; i < 200; ++i)\n    {\n        rayPos = cameraPos + cameraDir * rayDist;\n        \n        Result mapResult = map(rayPos, cameraDir);\n        rayDist += mapResult.dist;\n\n        if(mapResult.dist < 1e-3)\n        {\n            result.type = mapResult.type;\n            result.dist = rayDist;\n            result.position = cameraPos + cameraDir * rayDist;\n            result.normal = computeNormal(result.position, cameraDir);\n            break;\n        }\n    }\n\n    return result;\n}\n\nvec3 materialize(in Result result, in vec3 reflectionDiffuse, in vec3 reflectionSpeculer, in vec3 lightDir)\n{\n    float NdotL = dot(result.normal, lightDir);\n    float diffuseLight = saturate(NdotL * 0.2 + 0.8);\n    \n    vec3 R = lightDir + 2.0 * result.normal * dot(result.normal, lightDir);\n    float NdotR = dot(result.normal, normalize(R));\n    float speculerLight = saturate(pow(max(NdotR, 0.0), 100.0)) * 0.8;\n    \n    vec3 gridID = floor(result.position / CELL_SIZE);\n    vec4 cellInfo = texture(iChannel0, getBufferCellUV(gridID, iResolution.xy));\n    \n    vec3 diffuseColor = vec3(0.0);\n    diffuseColor += float(result.type == 0.0) * vec3(0.23);\n    diffuseColor += float(result.type == 1.0) * vec3(0.67, 1.0, 1.0) * diffuseLight;\n    diffuseColor += float(result.type == 1.0) * speculerLight;\n    diffuseColor += float(result.type == 2.0) * vec3(0.67, 1.0, 1.0) * 0.1;\n    \n    vec3 reflectionColor = vec3(0.0);\n    reflectionColor += float(result.type == 1.0) * saturate(reflectionDiffuse * 0.3);\n    reflectionColor += float(result.type == 2.0) * saturate(reflectionDiffuse * 0.7 + reflectionSpeculer);\n    \n    return (diffuseColor + reflectionColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cameraPos = vec3(0.0, sin(iTime * 0.2) * 10.0, -20.0);\n    vec3 cameraDir = normalize(vec3(uv, 2.0));\n    \n    float cameraAngle = iMouse.x / iResolution.x * - TAU + iTime * 0.3;\n    float cameraAngle2 = sin(iTime * 0.2) * 0.4;\n    cameraPos.xz *= rotate(cameraAngle);\n    cameraDir.yz *= rotate(cameraAngle2);\n    cameraDir.xz *= rotate(cameraAngle);\n    \n    Result result = march(cameraPos, cameraDir);\n    Result reflection = march(result.position - cameraDir * 1e-2, reflect(cameraDir, result.normal));\n\n    vec3 lightDir = normalize(vec3(0.2, 0.3, -0.5));\n    lightDir = normalize(-reflection.position);\n    \n    vec3 reflectionColor = materialize(reflection, vec3(0.4), vec3(0.0), lightDir);\n    reflectionColor += float(reflection.type == 0.0) * vec3(1.0) * 0.5;\n    reflectionColor *= saturate(mix(1.0, pow(reflection.dist / 20.0, 2.0), float(0.0 < reflection.type)));\n    \n    vec3 reflectionSpeculer = vec3(0.0);\n    reflectionSpeculer += pow(1.0 + dot(cameraDir, result.normal), 4.0);\n    reflectionSpeculer = saturate(reflectionSpeculer);\n    \n    lightDir = normalize(-result.position);\n    fragColor.rgb = materialize(result, reflectionColor, reflectionSpeculer, lightDir);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), pow(result.dist / 60.0, 2.0));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), pow(length(result.position) / 40.0, 2.0));\n    fragColor.rgb = saturate(fragColor.rgb);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(value) (clamp(value, 0.0, 1.0))\n\nconst float PI = 3.1415926535798;\nconst float TAU = PI * 2.0;\n\nconst float CELL_SIZE = 1.0;\nconst float CUBE_HALFSIZE = 20.0;\nconst float CUBE_SIZE = (CUBE_HALFSIZE * 2.0) / CELL_SIZE;\nconst float MOVE_FRAME = 10.0;\n\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 hash2(vec2 uv)\n{\n    return vec2(hash(uv), hash(uv + vec2(63.357, 234.346)));\n}\n\nvec3 getDirection(float number)\n{\n    vec3 dir = vec3(0);\n    dir.x = step(1.0, number) * step(number, 2.0 - 1e-3) - step(2.0, number) * step(number, 3.0 - 1e-3);\n    dir.y = step(3.0, number) * step(number, 4.0 - 1e-3) - step(4.0, number) * step(number, 5.0 - 1e-3);\n    dir.z = step(5.0, number) * step(number, 6.0 - 1e-3) - step(6.0, number) * step(number, 7.0);\n    return dir;\n}\n\nint getBufferCellID(vec2 uv, vec2 resolution)\n{\n    return int(round(uv.y * resolution.x + uv.x));\n}\n\nint getBufferCellID(vec3 cellID)\n{\n    cellID = mod(cellID, CUBE_SIZE); // loop\n    float id = round(cellID.x + (cellID.y * CUBE_SIZE) + (cellID.z * CUBE_SIZE * CUBE_SIZE));\n    return int(mod(id, CUBE_SIZE * CUBE_SIZE * CUBE_SIZE));\n}\n\nvec3 getBufferCellID3D(int cellID)\n{\n    return vec3(\n        mod(floor(float(cellID)),  CUBE_SIZE),\n        mod(floor(float(cellID) /  CUBE_SIZE), CUBE_SIZE),\n        mod(floor(float(cellID) / (CUBE_SIZE * CUBE_SIZE)), CUBE_SIZE)\n    );\n}\n\nvec2 getBufferCellUV(int cellID, vec2 resolution)\n{\n    float num = float(cellID);\n    return vec2(mod(num, resolution.x), floor(num / resolution.x)) / resolution.xy + (0.5 / resolution.xy);\n}\n\nvec2 getBufferCellUV(vec3 cellID, vec2 resolution)\n{\n    return getBufferCellUV(getBufferCellID(cellID), resolution);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// walk\n\n\nfloat getEmptyDirectionID(int cellID, int loops)\n{\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    int choisesCount = 0;\n    \n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID3D, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID3D, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID3D, iResolution.xy)).x);\n\n        bool xIsExist = 1.0f <= xNeighborCellExist;\n        bool yIsExist = 1.0f <= yNeighborCellExist;\n        bool zIsExist = 1.0f <= zNeighborCellExist;\n        \n        // dont enter from outer Cube\n        xIsExist = xIsExist && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsExist = yIsExist && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsExist = zIsExist && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n        \n        //if(xIsExist){\n        //    choises[choisesCount] = round(1.5 + (i * 0.5)); choisesCount++;}\n        //if(yIsExist){\n        //    choises[choisesCount] = round(3.5 + (i * 0.5)); choisesCount++;}\n        //if(zIsExist){\n        //    choises[choisesCount] = round(5.5 + (i * 0.5)); choisesCount++;}\n        choises[choisesCount] = round(1.5 + (i * 0.5)) * float(xIsExist); choisesCount+= 1 * int(xIsExist);\n        choises[choisesCount] = round(3.5 + (i * 0.5)) * float(yIsExist); choisesCount+= 1 * int(yIsExist);\n        choises[choisesCount] = round(5.5 + (i * 0.5)) * float(zIsExist); choisesCount+= 1 * int(zIsExist);\n    }\n\n    int index = int(floor(hash(vec2(float(cellID), loops)) * 6.0)); // Dare increased choices mistake.\n    //int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));\n    return choises[index];\n}\n\nfloat getCellDirectionID(int cellID, int loops)\n{\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    int choisesCount = 0;\n    \n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        int  xNeighborCellID = getBufferCellID(xNeighborCellID3D);\n        int  yNeighborCellID = getBufferCellID(yNeighborCellID3D);\n        int  zNeighborCellID = getBufferCellID(zNeighborCellID3D);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID, iResolution.xy)).x);\n\n        bool xIsEmpty = xNeighborCellExist <= 0.0;\n        bool yIsEmpty = yNeighborCellExist <= 0.0;\n        bool zIsEmpty = zNeighborCellExist <= 0.0;\n        \n        // dont enter from outer Cube\n        xIsEmpty = xIsEmpty && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsEmpty = yIsEmpty && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsEmpty = zIsEmpty && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n        \n        // cell's direction matching\n        xIsEmpty = xIsEmpty && getEmptyDirectionID(xNeighborCellID, loops) == round(1.5 + (-i * 0.5));\n        yIsEmpty = yIsEmpty && getEmptyDirectionID(yNeighborCellID, loops) == round(3.5 + (-i * 0.5));\n        zIsEmpty = zIsEmpty && getEmptyDirectionID(zNeighborCellID, loops) == round(5.5 + (-i * 0.5));\n        \n        //if(xIsEmpty){\n        //    choises[choisesCount] = round(1.5 + (-i * 0.5)); choisesCount++;}\n        //if(yIsEmpty){\n        //    choises[choisesCount] = round(3.5 + (-i * 0.5)); choisesCount++;}\n        //if(zIsEmpty){\n        //    choises[choisesCount] = round(5.5 + (-i * 0.5)); choisesCount++;}\n        choises[choisesCount] = round(1.5 + (-i * 0.5)) * float(xIsEmpty); choisesCount+= 1 * int(xIsEmpty);\n        choises[choisesCount] = round(3.5 + (-i * 0.5)) * float(yIsEmpty); choisesCount+= 1 * int(yIsEmpty);\n        choises[choisesCount] = round(5.5 + (-i * 0.5)) * float(zIsEmpty); choisesCount+= 1 * int(zIsEmpty);\n    }\n\n    int index = int(floor(hash(vec2(float(cellID), loops)) * 6.0)); // Dare increased choices mistake.\n    //int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));\n    return choises[index];\n}\n\nvoid getOverlap(vec3 cellID3D, int loops, out float isOverlap, out float overlapDirID)\n{\n    isOverlap = 0.0;\n    overlapDirID = 0.0;\n\n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        int  xNeighborCellID = getBufferCellID(xNeighborCellID3D);\n        int  yNeighborCellID = getBufferCellID(yNeighborCellID3D);\n        int  zNeighborCellID = getBufferCellID(zNeighborCellID3D);\n\n        float xNeighborCellDirID = getCellDirectionID(xNeighborCellID, loops);\n        float yNeighborCellDirID = getCellDirectionID(yNeighborCellID, loops);\n        float zNeighborCellDirID = getCellDirectionID(zNeighborCellID, loops);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID, iResolution.xy)).x);\n\n        bool xIsOverlap = 1.0 <= xNeighborCellExist * step(getDirection(xNeighborCellDirID).x * i, 0.0 - 1e-3);\n        bool yIsOverlap = 1.0 <= yNeighborCellExist * step(getDirection(yNeighborCellDirID).y * i, 0.0 - 1e-3);\n        bool zIsOverlap = 1.0 <= zNeighborCellExist * step(getDirection(zNeighborCellDirID).z * i, 0.0 - 1e-3);\n        \n        // dont enter from outer Cube\n        xIsOverlap = xIsOverlap && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsOverlap = yIsOverlap && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsOverlap = zIsOverlap && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n\n        isOverlap    = max(isOverlap,    float(xIsOverlap));\n        overlapDirID = max(overlapDirID, float(xIsOverlap) * xNeighborCellDirID);\n        isOverlap    = max(isOverlap,    float(yIsOverlap));\n        overlapDirID = max(overlapDirID, float(yIsOverlap) * yNeighborCellDirID);\n        isOverlap    = max(isOverlap,    float(zIsOverlap));\n        overlapDirID = max(overlapDirID, float(zIsOverlap) * zNeighborCellDirID);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec2 isInitPixel = vec2(iResolution.xy - 1.0);\n    bool isInit = texelFetch(iChannel0, ivec2(isInitPixel), 0).r < 1.0;\n    if(floor(fragCoord) == isInitPixel)\n    {\n        fragColor.r = 1.0;\n        return;\n    }\n\n    vec2 uvLocal = mod(fragCoord, CELL_SIZE) / CELL_SIZE;\n    vec2 uvID = floor(fragCoord);\n    float time = fract(iTime);\n    \n    int cellID = getBufferCellID(uvID, iResolution.xy);\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    if(int(CUBE_SIZE * CUBE_SIZE * CUBE_SIZE) < cellID)\n        return;\n    \n    // sequence\n    int sequence = int(mod(float(iFrame), MOVE_FRAME));\n    int loops = int(float(iFrame) / MOVE_FRAME);\n\n    if(isInit || 1.0 <= iMouse.w)\n    {\n        // initialize\n        float noise = hash(vec2(cellID, length(iDate)));\n        fragColor = vec4(step(0.3, noise), 0.0, 0.0, 0.0);\n        \n        //fragColor.x = step(4.0, mod(float(cellID3D.x + cellID3D.y), 5.0)); // X Y check\n        //fragColor.x = step(4.0, mod(float(cellID3D.x + cellID3D.z), 5.0)); // X Z check\n        //fragColor.x = step(2.0, mod(float(cellID) / (SIZE), 3.0));         // Y check\n        //fragColor.x = step(1.0, mod(float(cellID) / (SIZE * SIZE), 2.0));  // Z check\n        return;\n    }\n\n    float isOverlap = 0.0, overlapDirID = 0.0;\n    getOverlap(cellID3D, loops, isOverlap, overlapDirID);\n        \n    if(sequence == 0 && 1 <= loops)\n    {\n        // move cell\n        float exist = fragColor.x;\n        fragColor.x = exist * step(fragColor.y, 0.0); // stay\n        \n        if(fragColor.x <= 0.0)\n            fragColor.x = fragColor.z;\n\n        fragColor.y = 0.0;\n        fragColor.z = 0.0;\n        fragColor.w = 0.0;\n    }\n    else if(sequence == 1)\n    {\n        // direction decision\n        int exist = int(fragColor.x);\n        if(1 <= exist)\n            fragColor.y = getCellDirectionID(cellID, loops);\n            \n        // neighbor cell direction\n        fragColor.z = step(0.9, isOverlap);\n        fragColor.w = overlapDirID;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}