{"ver":"0.1","info":{"id":"lt3SDr","date":"1478967249","viewed":172,"name":"Truchet trials 2","username":"chadiik","description":"Truchet tiles","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// half of it\n#define STROKE_THICKNESS 0.21\n#define STROKE_THICKNESS_2 vec2(STROKE_THICKNESS)\n#define ROWS 14.0\n#define I_ROW 14.0 / ROWS\n#define CYCLE_SPEED 1.0\n#define RADIANS (3.1415926535 / 180.0)\n\n//------------------------------------------------------------------------------------------------------------------\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// c.xyz = hue, saturation, brightness\nvec3 hsb2rgb(vec3 c)\n{\n    vec3 rgb = clamp(\n        \t\t\tabs(\n                        mod(\n                            c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0\n                        \t) - 3.0\n                    \t) - 1.0, 0.0, 1.0\n    \t\t\t\t);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//------------------------------------------------------------------------------------------------------------------\n\nvec2 rotate2D(vec2 uv, float angle, vec2 offset)\n{\n    uv -= offset;\n    uv = mat2(cos(angle), -sin(angle),\n              sin(angle), cos(angle)) * uv;\n    uv += offset;\n    return uv;\n}\n\nfloat circleGen(vec2 uv, vec2 center, float radius)\n{\n    float d = distance(uv, center);\n    float dr = abs(d - radius);\n    return smoothstep(-STROKE_THICKNESS, STROKE_THICKNESS, dr * 2.0);\n}\n\nfloat rectGen(vec2 uv, vec2 start, vec2 end)\n{\n    vec2 topLeft = abs(uv - start);\n    vec2 bottomRight = abs(end - uv);\n    vec2 tl = smoothstep(-STROKE_THICKNESS_2, STROKE_THICKNESS_2, topLeft);\n    vec2 br = smoothstep(-STROKE_THICKNESS_2, STROKE_THICKNESS_2, bottomRight);\n    return tl.x * tl.y * br.x * br.y;\n}\n\nvec3 twoTiles(vec2 uv, float circle1, float circle2, float rect1)\n{\n    //float intensity = 1.0 - circle1 * circle2 * (rect1 * 0.7750);\n    //float intensity = 1.0 - circle1 * circle2 + (rect1 * 0.7750);\n    rect1 = 1.7 - rect1;\n    float intensity = 1.0 - circle1 * circle2 * pow(rect1, 0.2 * I_ROW) + rect1 * 0.15 * I_ROW;\n    vec3 hsb = vec3(uv.x * 0.051, sin(iTime * 0.5) + .5, exp2(uv.y * .25) * 0.25);\n    vec3 color = vec3(hsb2rgb(hsb)) * intensity;\n    \n    return color;\n}\n\nvec3 tile1(vec2 uv)\n{\n    float circle1 = circleGen(fract(uv), vec2(0.0), 0.5);\n    float circle2 = circleGen(fract(uv), vec2(1.0), 0.5);\n    \n    float rect1 = (rectGen(fract(uv), vec2(0.0), vec2(1.0)));\n    \n    vec3 color = twoTiles(uv, circle1, circle2, rect1);\n    return color;\n}\n\nvec3 tile2(vec2 uv)\n{\n    float circle1 = circleGen(fract(uv), vec2(0.0, 1.0), 0.5);\n    float circle2 = circleGen(fract(uv), vec2(1.0, 0.0), 0.5);\n    \n    float rect1 = (rectGen(fract(uv), vec2(0.0), vec2(1.0)));\n    \n    vec3 color = twoTiles(uv, circle1, circle2, rect1);\n    return color;\n}\n\nfloat tile3(vec2 uv)\n{\n    float rect1 = (rectGen(fract(uv), vec2(0.25), vec2(0.75)));\n    \n    return 1.0 - rect1;\n}\n\nfloat noiseGen(vec2 uv)\n{\n    return rand(uv);\n}\n\nfloat noise(vec2 uv)\n{\n    float mulComp = floor(iTime * 8.0);\n    vec2 mul = vec2(mulComp);\n    \n    float addComp = 0.0;\n    vec2 add = vec2(addComp);\n    \n    float noiseVal1 = noiseGen(floor(uv) * mul + add) * 0.15 + 01.85;\n    \n    uv *= vec2(64.0, 32.0);\n    float noiseVal2 = noiseGen(floor(uv) * mul + add) * 0.5 + 0.5;\n    \n    return (noiseVal1 + noiseVal2) * .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse / vec4(iResolution.xy, iResolution.xy);\n    float ratioToY = iResolution.x / iResolution.y;\n    uv.x *= ratioToY;\n    m.x *= ratioToY;\n    uv *= ROWS;\n    //m *= ROWS;\n    \n    vec3 background = vec3(0.0);\n    \n    vec2 cell = floor(uv) * floor(iTime + 10.0);\n    float tileType = rand(cell);\n    \n    float clock = iTime * CYCLE_SPEED;\n    float motor = floor(rand(vec2(floor(clock))) * 4.0) * (90.0 * RADIANS);\n    float angle = motor;\n    vec2 offset = floor(uv);\n    \n    bool doRotation = rand(vec2(floor(clock + 0.0543)) * floor(uv)) < 0.5;\n    vec2 uvTransform = doRotation ? rotate2D(uv, angle, offset) : uv;\n    \n    vec3 tile = (tileType < 0.5 ? tile1(uvTransform) : tile2(uvTransform));\n    vec3 color = background + tile * noise(uv);\n    //color = background - tile3(uv);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"vec2 mainSound( in int samp, float time )\n{\n    float tune = sin\n            (\n                5.2831 * 440.0 * \n                (\n                    1.0 + \n                    (\n                        sin\n                        (\n                            time * 0.5\n                        )\n                    )\n                )\n            ) * exp\n            (\n                0.10 * (time)\n            );\n    \n    //return vec2(clamp(tune * 0.5, 0.0, 0.1));\n    return vec2(0.0);\n}","name":"Sound","description":"","type":"sound"}]}