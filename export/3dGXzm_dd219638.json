{"ver":"0.1","info":{"id":"3dGXzm","date":"1573600402","viewed":214,"name":"Basic : 3D Truchet","username":"Gijs","description":"wow awesome. use WASD+QE+Shift+Space+Mouse to control the camera.","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 buf = texture(iChannel0,fragCoord.xy / iResolution.xy);\n    \n    vec3 col = buf.xyz/buf.w;\n    col = pow(col,vec3(1./GAMMA)); \n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash( uint n ) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid applyFog(inout vec3 c, vec3 d, float t){\n    vec3 g = FOG_COLOR + max(dot(SUN_VECTOR,d),0.)*SUN_COLOR*0.5;\n    c = mix(g, c, exp( -t*t*FOG_INTENSITY ));\n}\n\nvec3 getNormal(vec3 p, float eps){\n    eps = max(eps,1e-7);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*getDistance( p + d.xyy ) + \n                      k.yyx*getDistance( p + d.yyx ) + \n                      k.yxy*getDistance( p + d.yxy ) + \n                      k.xxx*getDistance( p + d.xxx ) );\n}\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t){\n\tfor (;steps<MAX_STEPS;steps++){\n\t\tdis = getDistance(p + d*t);     \n        t += dis;\n        meps = abs(t)*eps;\n\n\t\tif(dis<meps){\n            t -= (meps-dis);\n            break;\n        }\n        \n        if(t>MAX_MARCH){\n            t = MAX_MARCH;\n            break;\n        }\n\t}\n}\n\nvec3 raymarcher(vec3 p, vec3 d, float eps){ \n    int   steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p,d,eps,steps,dis,meps,t);\n    vec3 hitPos    = p + d*t;\n\n    vec3 c;\n    if(dis<meps){\n\n        vec3 hitColor  = getColor(hitPos);\n        vec3 hitNormal = getNormal(hitPos,meps);\n        vec3 reflectDir = reflect(d,hitNormal);\n\n        float diffuse   = max(dot(hitNormal,SUN_VECTOR),0.);\n        float specular  = diffuse>0. ? pow(max(dot(reflectDir,SUN_VECTOR),0.),32.) : 0.;\n\n        c = hitColor*SUN_COLOR*diffuse + hitColor*AMBIENT_COLOR*.6 + SUN_COLOR*specular*.3;      \n        \n        #ifdef FOCUS_INDICATION\n        \tc += t*vec3(0.01,0,0)/abs(t-FOCAL_LENGTH);\n        #endif\n        \n        \n    }else{\n        c = AMBIENT_COLOR;\n    }   \n    \n    applyFog(c,d,t);\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragCoord ){\n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = DETAIL*ZOOM/minResolution;\n    \n    //camera\n    vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n\n    //Seed\n    uvec2 up  = uvec2(fragCoord);\n    uvec2 res = uvec2(iResolution);\n    uint seed =  up.x + res.x*up.y + res.x*res.y*uint(iFrame);\n    \n    //Scaling\n    vec2 p = fragCoord + vec2(hash(seed++),hash(seed++))-.5;//anti-aliasing\n    vec2 sp  = (p*2.-iResolution.xy)/minResolution*ZOOM;\n     \n   \t//Pixel Ray\n\tvec3 direction = normalize(cameraForward+sp.x*cameraRight+sp.y*cameraUpward);\n    \n    //Focal Point \n    vec3 focalPoint = direction*FOCAL_LENGTH;\n    \n    //Pick random point on Aperture\n    float randomAngle       = TAU*hash(seed++);\n    float randomRadius      = hash(seed++)*APERTURE;\n    vec3  randomAperturePos = (cos(randomAngle)*cameraRight+sin(randomAngle)*cameraUpward)*sqrt(randomRadius);\n    \n    //Point on Aperture to Focal Point\n    direction = normalize(focalPoint-randomAperturePos);\n    \n    //Final\n    fragcolor = vec4(\n        raymarcher(\n            cameraPosition+randomAperturePos,\n            direction,\n            eps\n        ),1.0);\n    \n    if(!(texture(iChannel1,vec2(0)).w>.0)){//No movement detected so keep previous frames\n    \tfragcolor += texture(iChannel0,fragCoord/iResolution.xy);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>3 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition  = CAMERA_POSITION;\n        cameraForward   = normalize(CAMERA_LOOK-cameraPosition);\n        cameraRight     = normalize(cross(vec3( 0, 1, 0),cameraForward));\n        cameraUpward    = cross(cameraForward,cameraRight);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    if(iMouse.xy==vec2(0)){\n    \tforward = true;\n    }\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = SPEED*iTimeDelta*ZOOM;\n    \n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    float r = (float(rollleft)-float(rollright))*0.01;\n    cameraRight  = rotate(cameraRight , r, cameraForward);\n    cameraUpward = rotate(cameraUpward, r, cameraForward);\n    \n    if(mouseLeft){\n\t\tvec2 s = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n\t\t\t\n\t\tcameraForward = rotate(cameraForward, s.x*ZOOM*iTimeDelta*2., cameraUpward);\n        cameraRight  = normalize(cross(cameraUpward, cameraForward ));\n        \n\t\tcameraForward = rotate(cameraForward,-s.y*ZOOM*iTimeDelta*2., cameraRight );\n\t\tcameraUpward = normalize(cross(cameraForward, cameraRight ));   \n\t\t\n    }\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//constants\n    #define PI  3.14159\n    #define TAU 6.28318\n\n//Truchet\n\t#define THICKNESS 0.02\n\t#define COLOR\n\n//Render\n\t#define DETAIL       1.\n    #define MAX_STEPS    128\n    #define MAX_DEPTH    3\n    #define MAX_MARCH    5.\n\n//Lighting\n    #define AMBIENT_COLOR vec3(.45,.56,1.)\n    #define SUN_VECTOR    vec3(0.57735026919)\n    #define SUN_COLOR     vec3(1.,.7,.1)\n    #define SUN_SIZE      0.0001\n\n//Fog\n\t#define FOG_COLOR     vec3(0.5,0.6,0.7)\n\t#define FOG_INTENSITY 0.1\n\n//Camera\n    #define APERTURE        .0003\n    #define FOCAL_LENGTH    1.6\n\t#define ZOOM            .9\n\t#define MOVEMENT_SPEED  10.\n\t#define SPEED           1.\n\t#define CAMERA_LOOK     vec3(.5)+vec3(0,0,1)\n\t#define CAMERA_POSITION vec3(.5)\n\t//#define FOCUS_INDICATION //uncomment this to see where the camera is in focus\n\n//Post\n\t#define GAMMA 2.2\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\nfloat hash1i( int n ) {\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x7fffffff))/float(0x7fffffff);\n}\n\n\n//performes a random octahedral(cube) symmetry on the input\nvec3 randOctaSym(vec3 p, int s){\n    if(hash1i(s++)<.5) p.x*=-1.;\n    if(hash1i(s++)<.5) p.y*=-1.;\n    if(hash1i(s++)<.5) p.z*=-1.;\n    \n    vec3 f;\n    float k = hash1i(s++);\n    if(k<0.33){\n        f = p.xyz;\n    }else if(k<0.67){\n        f = p.yzx;\n    }else{\n        f = p.zxy;\n    }\n    float l = hash1i(s++);\n    if(l<.5) f.yz = f.zy;\n    \n    return f;\n}\n\n//three straight pipes\nfloat tile1(vec3 p){\n    p = abs(p);\n    if(p.z>p.x) p.xz = p.zx;\n    if(p.x>p.y) p.xy = p.yx;\n  \treturn length(p.xz) - THICKNESS;   \n}\n\n\n//zero straight pipes\n//there is some rotational symmetry that should could be exploited\nfloat tile2(vec3 p){\n\n    vec2  q1 = vec2(length(p.xz+.5)-.5,p.y);\n    float d1 = (length(q1)-THICKNESS);\n    \n    vec2  q2 = vec2(length(vec2(p.y,-p.x)+.5)-.5,p.z);\n    float d2 = (length(q2)-THICKNESS);\n    \n    vec2  q3 = vec2(length(-p.yz+.5)-.5,p.x);\n    float d3 = (length(q3)-THICKNESS);\n    \n\treturn min(d1,min(d2,d3));   \n}\n\n//gives an \"unique\" ID to a tile with position f\nint getID(vec3 f){\n    return int(dot(f,vec3(141233,78513,1135)));\n}\n\n\n//one straight pipe\nfloat tile3(vec3 p){ \n    if(p.z>-p.x) p.xz = -p.xz; \n    vec2  q = vec2(length(p.xz+.5)-.5,p.y);\n    float d1 = (length(q)-THICKNESS);\n    float d2 = length(p.xz)-THICKNESS;  \n\treturn min(d1,d2); \n}\n\nfloat truchet(vec3 p){\n    vec3  f = floor(p+0.5);\n    vec3  m = mod(p+.5,1.)-0.5;\n    \n    int id = getID(f);\n\n    m = randOctaSym(m,id);\n    float t = hash1i(id);\n    float d = MAX_MARCH;\n    \n    if(t<0.){\n        d = tile1(m);\n    }else if(t<0.5){\n        d = tile2(m);\n    }else{\n        d = tile3(m);\n    }\n\n\n    return d;\n}\n\nfloat getDistance(vec3 p){\n    float distance     = MAX_MARCH;\n    \n    distance = min(distance,truchet(p));\n    \n    return distance;\n}\n\nvec3 getColor(vec3 p){\n    #ifdef COLOR\n        vec3  f = floor(p+0.5);\n        int id = getID(f);\n    \treturn cos(f*.5)*.5+.5;\n    #else\n    \treturn vec3(1);\n    #endif\n}   \n","name":"Common","description":"","type":"common"}]}