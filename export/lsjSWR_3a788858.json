{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/* SETTINGS */\n/* Unless otherwise stated, 0 = disabled, 1 = enabled */\n#define COLOR 2 /* 0 = gray, 1 = color, 2 = color with aberrations */\n#define VSCAN 1\n#define DESYNC 1\n#define WOBBLE 1\n#define LOWRES 1\n#define RGBGRID 1\n#define SCANLINES 2 /* 0 = off, 1 = fixed, 2 = interpolate */\n#define BORDER 1\n#define CURVE 1\n#define EDGE 1\n#define ASPECT 1\n#define NOISE 1\n\n#define DRAW_EDGE 1\n#define DRAW_BACKGROUND 1\n\n/* Knobs: toy with the values for different effect intensities */\n#define ABERRATION 1.0\n#define WOBBLINESS 1.0\n#define CURVATURE 1.0\n#define SATURATION 1.0 /* set to 100.0 for the fun */\n#define NOISYNESS 6.0\n#define BORDERNESS 1.0\n\n#define INNER_EDGE 0.02\n#define OUTER_EDGE 0.0\n\n#define VIDEO_RATE 29.98 /* for scanline interlacing */\n#define VIDEO_AR_W 4.0\n#define VIDEO_AR_H 3.0\n\n/*\nCopyright (c) 2014-2021 gigaherz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#if LOWRES\n#\tdefine VIDEO_RES vec2(320.0,240.0)\n#else\n#\tdefine VIDEO_RES iChannelResolution[0].xy\n#endif\n\n#define PI 3.1415926536\n#define TWO_PI (2.0*PI)\n\nvec4 lerp(vec4 a, vec4 b, float s){return mix(a,b,clamp(s,0.,1.));}\n\nvec4 temporalNoise(vec2 uv, vec2 sz)\n{\n    vec2 tz = iChannelResolution[2].xy;\n    vec2 tv = uv + fract(vec2(iTime * 257.0, iTime * 359.0));\n    vec2 tx = tv * sz;\n    float cl = texture(iChannel2, tx/tz).r;\n    float bl = clamp((cl - 0.5) * 2.0 + 0.5,0.0,1.0);\n    return vec4(bl,bl,bl,1.0);\n}\n\nvec4 textureLowRes(vec2 uv, vec2 sz)\n{\n#if LOWRES\n    vec2 rsz = 1.0/sz;\n\n    vec2 pp = (uv * sz);\n    vec2 tl = floor(pp);\n    vec2 tr = tl + vec2(1.0,0.0);\n    vec2 bl = tl + vec2(0.0,1.0);\n    vec2 br = tl + vec2(1.0,1.0);\n    vec2 sp = fract(pp);\n    \n    vec4 tlc = texture(iChannel0, tl*rsz);\n    vec4 trc = texture(iChannel0, tr*rsz);\n    vec4 blc = texture(iChannel0, bl*rsz);\n    vec4 brc = texture(iChannel0, br*rsz);\n    \n    vec4 t = lerp(tlc,trc,sp.x);\n    vec4 b = lerp(blc,brc,sp.x);\n    \n    return lerp(t,b,sp.y);\n#else\n    return texture(iChannel0, uv);\n#endif\n}\n\n#if 0\nvec4 textureBleed(vec2 uv, vec2 sz)\n{\n    vec2 rsz = 1.0/sz;\n    vec4 t1 = textureLowRes(uv + vec2(-1,-1)*rsz, sz);\n    vec4 t2 = textureLowRes(uv + vec2( 0,-1)*rsz, sz);\n    vec4 t3 = textureLowRes(uv + vec2( 1,-1)*rsz, sz);\n    vec4 t4 = textureLowRes(uv + vec2(-1, 0)*rsz, sz);\n    vec4 t5 = textureLowRes(uv + vec2( 0, 0)*rsz, sz);\n    vec4 t6 = textureLowRes(uv + vec2( 1, 0)*rsz, sz);\n    vec4 t7 = textureLowRes(uv + vec2(-1, 1)*rsz, sz);\n    vec4 t8 = textureLowRes(uv + vec2( 0, 1)*rsz, sz);\n    vec4 t9 = textureLowRes(uv + vec2( 1, 1)*rsz, sz);\n    \n    /* TODO: calculate */\n    vec4 tr = t5;\n    \n    return tr;\n}\n#endif\n\nvec4 textureCrtEffect(vec2 uv)\n{\n    vec2 sz = VIDEO_RES;\n    vec2 rsz = 1.0/sz;\n    vec2 vy= uv * sz.xy;  \n    vec2 ed = (uv-0.5)*2.0;\n    float edg = dot(ed,ed);\n       \n#if WOBBLE\n    float s = fract(uv.y - iTime*0.25);\n    float q = WOBBLINESS * 0.004 * (0.05 * sin(s) + 0.2 * sin(vy.y*0.1+iTime*5.0) + 0.1*sin(vy.y*0.2+iTime*301.0));\n\n    uv = fract(uv+vec2(q,0));    \n#endif\n\n    float tt;\n#if BORDER\n    tt = clamp(cos((uv.x-0.5)*PI*0.99)*22.0/BORDERNESS,0.0,1.0) * \n         clamp(cos((uv.y-0.5)*PI*0.99)*22.0/BORDERNESS,0.0,1.0);\n#else\n    tt = 1.0;\n#endif\n    \n    vec4 tex = textureLowRes(uv, sz) * tt;\n    tex = vec4((tex.r * 0.2989 + tex.g * 0.5870 + tex.b * 0.1140)); /* to grayscale */\n\n#if COLOR == 2\n    vec2 abr = edg * vec2(-1.0,-1.0) * rsz * 0.55 * ABERRATION;\n    vec2 abg = edg * vec2( 1.0, 1.0) * rsz * 0.55 * ABERRATION;\n    vec2 abb = edg * vec2( 1.0,-1.0) * rsz * 0.55 * ABERRATION;\n\n    vec4 texr = textureLowRes(uv+abr, sz) * tt;\n    vec4 texg = textureLowRes(uv+abg, sz) * tt;\n    vec4 texb = textureLowRes(uv+abb, sz) * tt;\n    \n    tex = mix(tex, vec4(texr.r, texg.g, texb.b, 1), SATURATION);\n#elif COLOR == 1\n    vec4 texr = textureLowRes(uv, sz) * tt;\n    vec4 texg = textureLowRes(uv, sz) * tt;\n    vec4 texb = textureLowRes(uv, sz) * tt;\n    \n    tex = mix(tex, vec4(texr.r, texg.g, texb.b, 1), SATURATION);\n#endif\n\n    vec4 zero = vec4(0.0);\n    vec4 tx = tex;\n    \n#if NOISE\n    tx = mix(tx,temporalNoise(uv, sz), 0.1*NOISYNESS);\n#endif\n    \n#if SCANLINES==2\n    float t = sin(iTime*PI*VIDEO_RATE) > 0.0 ? 0.5 : 0.0;\n    float yy = 0.5+0.5*sin(TWO_PI*(vy.y + t));\n    tx = lerp(tx, zero, yy*0.5);\n#elif SCANLINES==1\n    float yy = 0.5+0.5*sin(TWO_PI*vy.y);\n    tx = lerp(tx, zero, yy*0.5);\n#endif\n    \n#if VSCAN\n    tx *= (0.9 + 0.25 * s);\n#endif\n\n#if RGBGRID\n    float fr = sin(vy.x * TWO_PI) * sin(vy.y * TWO_PI);\n    float fg = sin((vy.x+0.5) * TWO_PI) * sin((vy.y-0.25) * TWO_PI);\n    float fb = sin((vy.x+0.25) * TWO_PI) * sin((vy.y+0.25) * TWO_PI);\n    \n    tx.r = tx.r * (0.9 + 0.1 * fr);\n    tx.g = tx.g * (0.9 + 0.1 * fg);\n    tx.b = tx.b * (0.9 + 0.1 * fb);\n#endif\n\n    return tx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv0 = (fragCoord.xy / iResolution.xy);\n\n#if ASPECT\n    float arx = max(1.0, (VIDEO_AR_W/VIDEO_AR_H) * iResolution.y / iResolution.x);\n    float ary = max(1.0, (VIDEO_AR_H/VIDEO_AR_W) * iResolution.x / iResolution.y);\n#else\n   \tfloat arx = 1.0;\n   \tfloat ary = 1.0;\n#endif\n    \n#if EDGE\n    uv0 = (uv0 - 0.5) * (1.0+OUTER_EDGE) + 0.5;\n#endif\n        \n\tvec2 uv = uv0;\n    \n#if CURVE\n    float sclx = arx * (1.0 + ((uv.x-0.5)*(uv.x-0.5)) * 0.34 * ary * CURVATURE);\n    float scly = ary * (1.0 + ((uv.y-0.5)*(uv.y-0.5)) * 0.25 * arx * CURVATURE);\n    \n    uv = (uv - vec2(0.5,0.5)) * vec2(scly,sclx) + vec2(0.5,0.5);\n#else\n    uv = (uv - vec2(0.5,0.5)) * vec2(ary,arx) + vec2(0.5,0.5);\n#endif\n    \n#if EDGE\n    uv = (uv - 0.5) * (1.0+INNER_EDGE) + 0.5;\n#endif\n\n    vec2 uv2 = uv;\n#if DESYNC\n    uv2.y = (fract(iTime*0.97) < 0.1) || (fract(iTime*1.11) < 0.1) ? uv.y : fract(uv.y - iTime*0.1);\n#endif\n    \n    vec4 tx = textureCrtEffect(uv2);\n    \n\n    float cut = max(-min(uv.x,uv.y),max(uv.x,uv.y)-1.0);\n    float cut2 = (max(abs(uv0.x-0.5)*ary,abs(uv0.y-0.5)*arx)*2.0 - 1.0)*100.0;\n    \n#if DRAW_BACKGROUND\n    vec4 tv2 = texture(iChannel1, uv0)*0.5;\n#else\n    vec4 tv2 = vec4(0.0);\n#endif\n#if DRAW_EDGE\n\n    vec2 uv1 = (uv0 - 0.5) * vec2(ary,arx);\n    vec4 ec = (uv1.x > 0.0) ? \n        (abs(uv1.y) > uv1.x ? vec4(0.7) : vec4(0.8)) :\n    \t(abs(uv1.y) > -uv1.x ? vec4(0.7) : vec4(0.8)) ;\n\n    vec4 tv = lerp(ec, tv2, cut2);\n#else\n    vec4 tv = tv2;\n#endif\n    \n    vec4 tv0 = lerp(tx, tv, cut*250.0);\n    \n\tfragColor = tv0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsjSWR","date":"1411009978","viewed":713,"name":"Old CRT simulation","username":"gigaherz","description":"Simulates the interlacing and artifacts of an old CRT. Different effects are configurable. WIP.\n\nWATCH FULLSCREEN","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["retro","crt","scaler"],"hasliked":0,"parentid":"","parentname":""}}