{"ver":"0.1","info":{"id":"3dsXW4","date":"1551291939","viewed":237,"name":"91 degrees","username":"nabr","description":"experimenting with sound","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["texture","experiment","atmospheric","soundscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nabr\n// https://www.shadertoy.com/view/3dsXW4\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\n\n// soundin shader by FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n} // EOL soundin shader\n\nfloat polygon(vec2 p, float n) \n{\n    float t = iTime* 2.;\n\tp =  sin(t) * p + cos( t ) * vec2(-p.y, p.x);\n    float a = atan(p.x, p.y) + 3.14;\n\tfloat r = 6.28 / n;\n\treturn cos( floor( .5 + a / r) * r - a) * length(p);\n}\n\nfloat map(vec3 p) \n{\n    float t = iTime;\n    float v = (sin(p.z + t) * .5 + .5) / 2.;\n    p.xz *= mat2(1, 0, 1, 1);\n    p.yz *= mat2(1.2, v, -v, .5);\n    p.x -= p.y + exp(1. - sin(p.z + t * 2.));\n    p = 1.571 * abs(fract(p * 0.09) - .5);\n    p = 6.28 * p * p;\n    return 0.01 + sqrt(.225 * \n                       dot(p - vec3(-.001, -1., .1),\n                           pow(p, vec3(.002, .008, .08))));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // call soundin shader \n\tif (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.051,.12))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    // ----------------------- INIT\n    vec2 st = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n    st.x *= 2. / 1.;\n\tvec3 rd = normalize(vec3(st, 0.1));\n\n    if (abs(st.y) > .65 || abs(st.x) > 1.98) \n    {\n        fragColor.rgb = vec3(.001);\n        return;\n    };\n        \n    \n    // ----------------------- RAYMARCH\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n\n    for (float i = 0.; i < 64.0; i++) \n    {\n        if (d >= 0.001 && t > 100.0) break;\n        d = .8 * map(t * rd);\n        t += max(d * d - .2, 0.013);\n    };\n        \n    // ----------------------- SHADE\n    \n    //:)\n    fragColor.rgb =\n       (.05 / abs(sin(rd.x * 2. - iTime) - cos(rd.z * 12.2)) \n        * .15 - (.5 / abs(polygon(st.xy * 5.5 + vec2(d * .1, d * .1), 3.))) \n        -cos(rd.z * 5.) + vec3(.7, 0.2, 0.32)) \n        + (vec3(.1, 0.2, 1.32) * (t * .5) * (t * 0.0152))\n        +.09*texture(iChannel3,vec2(st.x-2.6, st.y)*.4\n                   -vec2(0,int[](int(iTime*100.)%16)[0])/15. ).x;\n\n   fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// nabr\n// https://www.shadertoy.com/view/3dsXW4\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// few lines of code, just comment comment stuff out and back in again\n// to see how everything works! \n\n\n#define VOLUME .125\n\nvec2 mainSound( in int samp,float time) \n{\n    // init variables\n    float p = 0., amp = 0., w = 0., R = 0., L = 0.;\n\tvec2 overdrive = vec2(0), snd = vec2(0);\n    \n    // pitch variation on the right channel\n    p = float[](6000., 6010.78 )[int(time * .501) % 2];\n\n    // precalc whoob amplitude modulation\n    w = -log2(sin(time * 12.) * .501 + .55);\n\t\n    // panning \n    R = cos(time * p) * sin(1.001 + time * 2226.);\n    L = sin(1.011 + time * 1000.) * cos(time * 500. - w);\n    \n    // premix\n    snd = vec2(R, L);\n\t\n    // precalc variation on the right channel\n    amp = (sin(time) > .5) ? 1. : .5;\n\n    R = dot(snd * amp,\n        \t\tvec2(snd.y * snd.x + .15 * sin(time), 1. - snd.y)) \n        \t\t+ (snd.y + sin(time * .5 + snd.y) * 2.);\n\n    L = dot(snd * .5,\n        \t\tvec2(snd.y * snd.x + .21 * sin(time * 3.), 1. - snd.y)) \n        \t\t+ (snd.y + cos(time - snd.y)) * 1.8;\n\n    \n    // out\n    overdrive = max(.001 - vec2(0.75), vec2(R, L) );\n    return  overdrive * VOLUME;\n}\n\n/*\n  __  __       _______ _______ ______ _____                                        \n |  \\/  |   /\\|__   __|__   __|  ____|  __ \\                                       \n | \\  / |  /  \\  | |     | |  | |__  | |__) |                                      \n | |\\/| | / /\\ \\ | |     | |  |  __| |  _  /                                       \n | |  | |/ ____ \\| |     | |  | |____| | \\ \\                                       \n |_|  |_/_/    \\_\\_|     |_|  |______|_|  \\_\\                                      \n                          _   _ _______ _____ _____  _    _           _____ ______ \n                    /\\   | \\ | |__   __|_   _|  __ \\| |  | |   /\\    / ____|  ____|\n    ______         /  \\  |  \\| |  | |    | | | |__) | |__| |  /  \\  | (___ | |__   \n   |______|       / /\\ \\ | . ` |  | |    | | |  ___/|  __  | / /\\ \\  \\___ \\|  __|  \n                 / ____ \\| |\\  |  | |   _| |_| |    | |  | |/ ____ \\ ____) | |____ \n                /_/    \\_\\_| \\_|  |_|  |_____|_|    |_|  |_/_/    \\_\\_____/|______|\n*/\n\n\n/* // BACKUP ( same thing, for debug purposes ) \nvec2 mainSound( in int samp, float time )\n{\n    // whoob amplitude mod\n    float w =  (-log2( sin(time*12.) * .501 +  .55 )  ) ;\n    \n    // some variation\n    float mm = float[]( 6000., 6010.78 )[int(time * .501 )%2];\n    \n    // sound - rotation\n    vec2 snd = vec2(\n        (cos(time * mm ) ) * (sin(1.001+ time * 2226.)), \n        (sin(1.011+time * 1000.) ) * (cos(time * 500. -w ))) ;\n    \n    // some variation\n    float amp = (sin(time)>.5)?1.:.5;\n    \n    // out\n    return max(.001 - vec2(0.75),\n    vec2(\n        dot(snd * amp, vec2(snd.y * snd.x + .15 * sin(time), 1. - snd.y)) \n        + (snd.y + sin(time * .5 + snd.y) * 2.),\n        dot(snd * .5, vec2(snd.y * snd.x + .21 * sin(time * 3.), 1. - snd.y)) \n        + (snd.y + cos(time - snd.y)) * 1.8)\n              ) * VOLUME;\n}\n*/","name":"Sound","description":"","type":"sound"}]}