{"ver":"0.1","info":{"id":"wlSGDD","date":"1559713614","viewed":1780,"name":"Cube-mapped Double Quad Truchet","username":"BigWIngs","description":"See comments for details. Mouse to move","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","truchet","double","quad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cube-mapped Double Quad Truchet by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Playing around with truchet tiles. This makes use of the normal quad tiling\n// but has two exit points per edge instead of one making for a lot more random\n// looking effect. The lines from entry to exit point are made of segmented\n// bezier splines which isn't terribly performant but looks nice.\n// \n// In order to get this onto a sphere without any poles I used a cubemapping\n// technique which works well with quad truchet because it seemlessly fits\n// corners where three edges meet.\n//\n// I didn't make completely random entry-exit point combinations. Perhaps \n// someone can come up with a clever algorithm for this. Instead, I made a bunch\n// of presets that I choose from randomly, subsequently I rotate the entry-exit\n// points by a random offset to get the variety you see. There should be many more\n// variations though if the points were truly random. A quick calculation (and I\n// might be wrong) yields 8 factorial divided by two different combinations,\n// which is more than 20 thousand\n//\n// Set SHOWGRID to true to be able to see the truchet tiles.\n//\n// Use these to change the effect\n\n#define SHOWGRID false\n#define BEZIER_STEPS 8\n#define GRID_SIZE 5.\n#define SPLINE_WIDTH .1\n#define SPLINE_COLOR vec3(1)\n#define SPLINE_SOFTNESS .5\n#define SHADOW_WIDTH 3.\n#define CYCLE_VARIATIONS 0.\n\n// entry-exit point presets\nfloat g[64] = float[64] (\n\t0., 3., 1., 5., 2., 7., 4., 6.,\n    0., 1., 2., 3., 4., 7., 5., 6.,\n    0., 7., 1., 5., 2., 6., 3., 4.,\n    0., 4., 1., 3., 2., 5., 6., 7.,\n    0., 5., 1., 4., 2., 7., 3., 6.,\n    0., 6., 1., 5., 2., 4., 3., 7.,\n    0., 2., 1., 5., 3., 4., 6., 7.,\n    0., 7., 2., 6., 3., 4., 5., 1.\n);\n\nfloat N21(vec2 p) {\n\tp = fract(p*vec2(123.34,345.56));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat dLineSeg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n// distance to segmented cubic bezier\nfloat dBezier(vec2 p, vec4 a, vec4 b) {\n    \n    vec2 p1=a.xy, p2=p1+a.zw, p3=b.xy+b.zw, p4=b.xy;\n        \n    float d = 100.;\n    \n    vec2 pb = p1;\n    vec2 ppb;\n    \n    for(int i=0;i<BEZIER_STEPS;i++) {\n    \tfloat t = float(i+1)/float(BEZIER_STEPS);\n        \n        ppb = pb;\n        \n        vec2 p12 = mix(p1, p2, t);\n        vec2 p23 = mix(p2, p3, t);\n        vec2 p34 = mix(p3, p4, t);\n        \n        vec2 p1223 = mix(p12, p23, t);\n        vec2 p2334 = mix(p23, p34, t);\n        \n        pb = mix(p1223, p2334, t);\n        \n        d = min(d, dLineSeg(p, ppb, pb));\n    }\n    \n    return d;\n}\n\n\n// returns position and tangent that we need to draw bezier spline\nvec4 GetVec(float i, float s) {\n    \n    i = mod(i, 8.);\n    // i  ->  0   1   2   3   4   5   6   7\n    // x  -> -1   1   2   2   1  -1  -2  -2\n    // y  ->  2   2   1  -1  -2  -2  -1   1\n     \n    float a = 6.2832*i/(8./9.);\n    vec2 pos = vec2(\n        round(cos(a-.5*3.1415-.3)*2.),\n        round(cos(a-.3)*2.)\n    );\n    \n    i = floor(i/2.);\n    \n    // i  ->  0  1  2  3\n    // x  ->  0 -1  0  1\n    // y  -> -1  0  1  0\n    \n    float m2 = mod(i, 2.); \t\t// 0 1 0 1 0 1\n   \tvec2 tangent = vec2(\n        i==1. ? -1. : m2,\n        i==0. ? -1. : 1.-m2\n    );\n    \n    // you can scale tangent to get different looking splines\n    //tangent *= 3.;//mix(.25, 2.5, fract(sin(s*345.23)*5434.));\n\t \n    return vec4(pos.x, pos.y, tangent.x, tangent.y)*.25;\n}\n\n// draw a spline with a shadow\nvec4 Spline(vec2 uv, float w, int k, float n, float s) {\n\tfloat d = dBezier(uv, GetVec(g[k+0]+n, s+1.), GetVec(g[k+1]+n, s+2.));\n    float m = smoothstep(w, w*SPLINE_SOFTNESS, d);\n    \n    vec3 col = m*SPLINE_COLOR;\n    float shadow = max(m, smoothstep(w*SHADOW_WIDTH, 0., d));\n    \n    return vec4(col, shadow);\n}\n\nvec4 QuadTruchetTex(vec2 uv) {\n    vec2 gv = fract(uv)-.5;\n\tvec2 id = floor(uv);\n    float n = N21(id);  \n    \n    float t = iTime*CYCLE_VARIATIONS;\n    int k = int(floor(fract(n*3425.12+floor(t*3.))*8.))*8;\n    float s = n*10.;\n    n = floor(n*8.)+floor(t*2.);\n    float w = SPLINE_WIDTH;\n\n    // draw four entry-exit splines\n    vec4 s1 = Spline(gv, w, k, n, s);\n    vec4 s2 = Spline(gv, w, k+2, n, s+2.);\n    vec4 s3 = Spline(gv, w, k+4, n, s+4.);\n    vec4 s4 = Spline(gv, w, k+6, n, s+6.);\n    \n    // composite splines\n    vec4 col = mix(s1, s2, s2.a);\n    col = mix(col, s3, s3.a);\n    col = mix(col, s4, s4.a);\n    \n    if(SHOWGRID && (gv.x>.48||gv.y>.48)) col.r = 1.;\n    \n    return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 ro) {\n\tvec3 f = normalize(vec3(0)-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n    return rd;\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    //mattz' trick for less distortion in the corners\n    // st.xy = atan(st.xy*tan(0.868734829276))/0.868734829276;\n    \n    // iq version, no trig, short and sweet\n    //st.xy *= 3.0/(2.0+abs(st.xy));\n    //st.xy *= 1.25 - 0.25*st.xy*st.xy;\n    \n    // mattz's no trig version\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n    \n    \n    return st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // set up camera\n    vec3 ro = vec3(0,0.,-2.5);\n    ro.yz *= Rot(-M.y*3.+sin(iTime*.1));\n    vec3 rd = GetRayDir(uv, ro);\n    \n    // marching loop\n    float dO=0., dS;\n    vec3 p;\n    for(float i=0.; i<100.; i++) {\n    \tp = ro + rd * dO;\n        dS = length(p)-1.;\n        dS = min(dS, -(length(p)-4.));\t// background\n        \n        if(dS<.001) break;\n        dO += dS;\n    }\n    \n    vec4 col = vec4(0);\n    \n    // handle material\n    if(dS<.001) {\n        float d = length(p-ro);\n        vec3 n = normalize(p);\n        float fresnel = 1.+dot(rd, n);\n        fresnel *= fresnel;\n        fresnel *= fresnel;\n        \n       \tp.xz *= Rot(iTime*.1);\n        vec3 cc = WorldToCube(p);\n        col = QuadTruchetTex(cc.xy*GRID_SIZE+cc.z*10.);\n       \n        // soften edge of main sphere a bit\n        if(length(p)<1.2) col = mix(col, vec4(.5), fresnel);\n        \n        // darken background\n        col /= max(1., d*.3);\n    }\n    \n    // vignette\n    col *= vec4(1.-dot(uv,uv));\n   \t\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}