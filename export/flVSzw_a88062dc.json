{"ver":"0.1","info":{"id":"flVSzw","date":"1640543830","viewed":501,"name":"sillypath","username":"mmalex","description":"silly path tracer as a christmas distraction; I realised I'd never actually written one of these simple path tracers, cradle to grave. so I did...\na dash of delta tracking in there to make it all hazy, because nature abhors a vacuum, and so do I....","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["silly","tracer","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).xyz;\n    float vignette=1.-length(uv-0.5);\n    float exp=2.;\n    c.xyz=filmicToneMapping(c.xyz* exp * vignette);\n    float gamma=1.; // 2.2\n    fragColor = vec4(pow(c,vec3(1./gamma)),1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// silly xmas doodle. thanks to all the shaders I copy pasted from. some links where I remembered to paste them.\n\nfloat sunbright = 8.;\nfloat light2bright = 50.;\nfloat skybright = 3.;\n\nfloat dens=35.; // foggy inverse - big numbers are clear\nfloat aperture = 0.1; // controls dof\n\nfloat lightdist=1.2;\n\n// thanks to morimea for this quick fix :)\nvec3 my_normalize(vec3 v){return normalize(v+0.001*(1.-abs(sign(v))));}\n#define normalize my_normalize\n\n// random numbers thanks to https://www.shadertoy.com/view/tltGzH\nuint seed;\t//seed initialized in main\n\nuint wang_hash()\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat rnd()\n{\n    return float(wang_hash()) / 4294967296.0;\n}\nvec2 rnd2() { return vec2(rnd(),rnd()); }\nvec3 rnd3() { return vec3(rnd(),rnd(),rnd()); }\n\n// perp from https://blog.selfshadow.com/2011/10/17/perp-vectors/\nvec3 perp_hm(vec3 u)\n {\n     vec3 a = abs(u);\n     vec3 v;\n     if (a.x <= a.y && a.x <= a.z)\n         v = vec3(0, -u.z, u.y);\n     else if (a.y <= a.x && a.y <= a.z)\n         v = vec3(-u.z, 0, u.x);\n     else\n        v = vec3(-u.y, u.x, 0);\n    return v;\n}\n\n// cos weighted dir from https://www.shadertoy.com/view/4tl3z4\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n) {\n  \tvec2 r = rnd2();\n\n\tvec3  uu = normalize( perp_hm(n) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\nvec3 randomSphereDirection() {\n    vec2 h = rnd2() * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\nvec2 randomdisc() {\n    vec2 h=rnd2() * vec2(6.28318530718,1.);\n    h.y=sqrt(h.y);\n    return h.y*vec2(sin(h.x),cos(h.x));\n }\n\n// these from iq, modified\n// sphere of size ra centered at point ce\nbool sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra, inout float tmax, out vec3 outNormal )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return false; // no intersection\n    h = sqrt( h );\n    float t = -b-h;\n    if (t>0. && t<tmax) {\n        outNormal=normalize(oc+rd*t);\n        tmax=t;\n        return true;\n    } \n    t=-b+h;\n    if (t>0. && t<tmax) {\n        outNormal=normalize(oc+rd*t);\n        tmax=t;\n        return true;\n    }\n    return false;\n}\n// axis aligned box centered at the origin, with size boxSize\nbool boxIntersect( in vec3 ro, in vec3 rd, vec3 boxPos, vec3 boxSize, inout float tmax, out vec3 outNormal ) \n{\n    ro-=boxPos;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return false; // no intersection\n    if (tN>0. && tN<tmax) {\n         outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n         tmax=tN;\n         return true;\n    }\n    return false;\n    if (tF>0. && tF<tmax) {\n    // TODO wrong - swap order of step params?\n         outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n         tmax=tF;\n         return true;\n      }\n    return false;\n}\n\nvec3 skycol(vec3 rd) {\n    float d=max(rd.y,0.);\n    d=d*d;d=d*d;\n    d=d*d;d=d*d;\n    return vec3(0.05,0.1,0.4)*skybright*d;\n}\nvec3 rotatez(vec3 p, float ang) {\n    float c=cos(ang),s=sin(ang);\n   return vec3(p.x*c-p.y*s,p.y*c+p.x*s,p.z);\n}\nvec3 rotatey(vec3 p, float ang) {\n    float c=cos(ang),s=sin(ang);\n    return vec3(p.x*c-p.z*s,p.y,p.z*c+p.x*s);\n}\nvec3 rotatex(vec3 p, float ang) {\n    float c=cos(ang),s=sin(ang);\n    return vec3(p.x,p.y*c-p.z*s,p.z*c+p.y*s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int spp=8;\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);   \n    vec3 coltot=vec3(0.);\n    for (int s=min(iFrame,0);s<spp;++s) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n    vec3 col=vec3(0.);\n    uv+=rnd2()*(1./iResolution.yy);\n    vec3 ro = vec3(0.2,-0.1, -18.) + vec3(randomdisc()*aperture,0.);\n    vec3 target = vec3(0.2,-0.1,0)+vec3(uv.xy*3.5,0);\n    vec3 rd = normalize(target-ro);\n    ro=rotatex(rotatey(ro,+0.05),0.15);\n    rd=rotatex(rotatey(rd,+0.05),0.15);\n    \n    \n    \n    \n    vec3 thp=vec3(1.);\n    bool inside=false;\n    for (int bounce=min(iFrame,0);bounce<10;++bounce){\n        if (abs(ro.x)>38. || abs(ro.y)>38. || abs(ro.z)>38.) {\n            col=skycol(rd); break;\n         }\n        vec3 n;\n        float tmax=1000.;\n        int obj=0;\n            if (sphIntersect(ro,rd,vec3(-0.1,-0.1,-0.1),0.9, tmax, n)) obj=1;// glass ball\n        if (sphIntersect(ro,rd,vec3(0.9,-0.75,-1.3),0.25, tmax, n)) obj=6; // reflective ball\n        if (sphIntersect(ro,rd,vec3(1.6,-1.+0.5,1.5),0.5, tmax, n)) obj=7; // green ball\n\n        if (boxIntersect(ro,rd,vec3(0,-1.1,0),vec3(18,0.1,18), tmax,n)) obj=2; // floor\n        if (boxIntersect(ro,rd,vec3(-1.3,0,-0.3),vec3(0.1,3,1.5), tmax,n)) obj=4; // yellow\n        if (boxIntersect(ro,rd,vec3(2.2,-0.7,1.5),vec3(0.1,1,2), tmax,n)) obj=5; // blue\n\n\n        if (boxIntersect(ro,rd,vec3(0.15,0,2.5),vec3(0.2,1.5,.2), tmax,n)) obj=8 ; // red\n    \n        if (sphIntersect(ro,rd,vec3(3.,1.6,2.)*lightdist,0.4, tmax, n)) obj=3; // light\n        \n        //vec3 ro2=rotatez(ro,-0.15);\n        //vec3 rd2=rotatez(rd,-0.15);\n        if (boxIntersect(ro,rd,vec3(-3.1,2.,3.1),vec3(2.05,0.05,0.05), tmax, n)) obj=33; // light 2\n        \n        \n        float scatter_t = (-log(1.0f - rnd()) ) * dens;\n        if (tmax>scatter_t) {\n            thp*=0.999;\n           // if (inside) thp*=vec3(0.99,0.95,0.5);\n            ro=ro+scatter_t*rd;\n            float forward = 0.f;\n            rd=normalize(forward*rd+randomSphereDirection());\n            continue;\n        }\n            \n            \n\n        \n        if (obj==0) { col=skycol(rd); break; }\n        \n        if (obj==3) { col=vec3(10,9,8)*sunbright; break; }\n        if (obj==33) { col=vec3(1.5,0.5,0.5)*light2bright; break; }\n            vec3 albedo=vec3(0.7);\n        \n        ro=ro+tmax*rd;\n                    ro+=n*1e-3;\n\n        float ndotr = dot(rd,n);\n        float eta=1./1.5;\n        if( ndotr > 0. ) { // exit\n            n = -n;\n            eta=1./eta;\n        } \n        float cosThetaI = abs(ndotr);\n        float sinThetaTSq = eta * eta * (1. - cosThetaI * cosThetaI);            \n        float fresnel=1.;\n        if (sinThetaTSq < 1.)\n        {\n            float cosThetaT = sqrt(1. - sinThetaTSq);     \n            float Rs = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n            float Rp = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);    \n            fresnel = 0.5 * (Rs * Rs + Rp * Rp);\n        }\n\t\t              \n         if (obj==7) {\n             n=normalize(n+0.15*randomSphereDirection());\n             albedo=vec3(0.3,0.55,0.3);\n         /*    if (ndotr<0.) {\n                 inside=true;\n                 ro-=n*2e-3;\n                 n=-n;\n              } else {\n                  inside=false;\n               }\n         rd=cosWeightedRandomHemisphereDirection(n);\n         continue;*/\n         }\n        vec3 refl =  reflect( rd, n );        \n     \n        if (obj==1) {\n        //col=vec3(fresnel); break;\n        vec3 ref =  refract( rd, n, eta );        \n        if( ref == vec3(0) || rnd() < fresnel  ) {\n            ref = refl;\n        } else {\n            // refract\n            ro-=n*2e-3;\n            //ro+=ref*2e-3;\n            thp*=vec3(0.99,0.8,0.9);\n            //thp*=0.;\n        }\n        rd=ref;\n        } else {\n        \n            // diffuse bounce\n            if (obj==4) albedo=vec3(0.9,0.5,0.1);\n            else if (obj==8) albedo=vec3(0.9,0.1,0.1);\n            else if (obj==5) albedo=vec3(0.1,0.5,0.9);\n            \n            else if (obj==2) {\n                float c=cos(0.1),s=sin(0.1);\n                vec2 uv=vec2(ro.x*c-ro.z*s,ro.z*c+ro.x*s);\n                //vec2 uv=ro.xz;\n                \n                 float xstripe = smoothstep(0.49,0.491,abs(fract(uv.x)-0.5));\n                 float ystripe = smoothstep(0.49,0.491,abs(fract(uv.y)-0.5));\n                 float stripe=max(xstripe,ystripe);\n                 \n                 float xstripe2 = smoothstep(0.45,0.46,abs(fract(uv.x*5.)-0.5))*0.5;\n                 float ystripe2 = smoothstep(0.45,0.46,abs(fract(uv.y*5.)-0.5))*0.5;\n                  stripe=max(stripe,max(xstripe2,ystripe2)); // max(xstripe,ystripe);\n                 \n                 albedo = vec3(0.9-stripe*0.8);\n                 fresnel*=0.25;\n             }\n            if ((obj==7 ) && rnd()<fresnel) {\n                rd=refl;\n                continue;\n            } else \n            if (obj==6) {\n                rd=refl;\n                continue;\n            }\n            thp*=albedo;\n            vec3 newrd=cosWeightedRandomHemisphereDirection(n);\n                rd=newrd;\n        }\n        rd=normalize(rd);\n//        if (dot(n,rd)<0.) {col=vec3(1,0,0);       break;}\n        //ro+=rd*1e-3;\n//        col=rd*0.5+0.5;break;\n\n    }\n    col*=thp;\n    coltot+=col;\n    }\n    coltot*=(1./float(spp));\n    // Output to screen\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float frames=float(iFrame)-5.;\n    if (frames<=0.) fragColor=vec4(0.);\n    else fragColor = (lastFrameColor * frames + vec4(coltot,1.0)) / (frames+1.);\n}\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}