{"ver":"0.1","info":{"id":"4s2czD","date":"1491206741","viewed":288,"name":"RAISR hash function (modified)","username":"Walt","description":"This is an implementation of the hash function described in RAISR: Rapid and Accurate Image\nSuper Resolution.\n\nThe lower left is the source image. Upper left is the strength, upper right is the coherence, and lower right is the color-coded angle.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["imageprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float dxdu = 1.0/16.0;\t// change this to change frequencies of source\n\nfloat P(vec2 uv)\n{\n    vec2 xy = uv * dxdu;\n\tfloat p = sin (dot(xy, xy));\n//    float p = sin(dot(xy, xy)) * cos(2.7*dot(xy-vec2(0.5,1.5),xy-vec2(0.5,1.5))) * sin((xy.x+xy.y) * 2.73);\n    p = 0.5*p + 0.5;\n//    float p = sin((xy.x+xy.y)*2.73) + cos((xy.x-xy.y)*2.98); p = 0.25*p + 0.5;\n    // quantize to 8 bits\n    return floor(p * 255.0 + 0.5); \n\n//    return texture( iChannel0, xy ).g;\n}\n\nfloat Q(float x, float y)\n{\n    return P(vec2(x, y));\n}\n\n// the x and y partials need to be evaluated at the same points\n// that's why using [-1,1] kernels horiz and vert doesn't work, because\n//    O   O\n//    y r\n//    O x O\n// the x derivative is located at x and the y deriv at y -- these are not the same point\n// Roberts cross derivative is evaluated at r for both x and y, so that works\n// you can also use [-1,1]*[.5,.5] to move the derivative location from x and y to r\n\n// 4 point offset [0,1,-27,27,-1]/24\n// 3 point centered [0,-1,0,1,0]/2\n// 2 point offset [0,0,-1,1,0]/1\n#define q1  0.0\n#define q2  0.0\n#define q3  -1.0\n#define\tq4\t1.0\n#define\tq5\t0.0\n#define\tq6\t1.0\n\nfloat dqdx(float x, float y)\n{\n    return (q1*Q(x-2.,y) + q2*Q(x-1.,y) + q3*Q(x,y) + q4*Q(x+1.,y) + q5*Q(x+2.,y))/q6;\n}\n\nfloat dqdy(float x, float y)\n{\n\n    return (q1*Q(x,y-2.) + q2*Q(x,y-1.) + q3*Q(x,y) + q4*Q(x,y+1.) + q5*Q(x,y+2.))/q6;\n}\n\n// 4 point blur [0,1,3,3,1]/8\n// 3 point Scharr wts [0, 1, 3.5887, 1, 0]/5.5887\n// 2 point offset [0,0,1,1,0]/2\n#define k1   0.0\n#define k2\t 0.0\n#define k3   1.0\n#define\tk4\t1.0\n#define\tk5\t0.0\n#define\tk6\t2.0\n\nfloat Pdx(vec2 uv)\n{\n\tfloat x = uv.x, y = uv.y;\n\n\treturn (k1*dqdx(x,y-2.) + k2*dqdx(x,y-1.) + k3*dqdx(x,y) + k4*dqdx(x,y+1.) + k5*dqdx(x,y+.2))/k6;\n}\n\nfloat Pdy(vec2 uv)\n{\n\tfloat x = uv.x, y = uv.y;\n\n    return (k1*dqdy(x-2.,y) + k2*dqdy(x-1., y) + k3*dqdy(x,y) + k4*dqdy(x+1.,y) + k5*dqdy(x+2.,y))/k6;\n}\n    \nconst float PI = 3.14159265;\n\n// fast atan2, max error 0.07 radians (4 degrees man ok if you can handle that)\nfloat fatan2(in float y, in float x)\n{\n\tconst float c1 = PI/4.0;\n    const float c2 = 3.0 * c1;\n    float absy = abs(y) + 1.0e-25;   // 0, 0 returns 0\n    float r, angle;\n    if (x >= 0.0)\n    {\n        r = (x - absy) / (x + absy);\n        angle = c1 - c1*r;\n    }\n    else\n    {\n        r = (x + absy) / (absy - x);\n        angle = c2 - c1*r;\n    }\n    return (y<0.0) ? -angle : angle;\n}\n\n// .086 degree max error\nfloat fatan2d(in float y, in float x)\n{\n\tfloat ax = abs(x), ay = abs(y);\n\n    // it's ok to check against 0 as the args are going to be integers\n    if (max(ax, ay) == 0.0)\n        return 0.;\n    \n\tfloat z = min(ax, ay) / max(ax, ay);\n\tfloat atn = z * (45.0 - (z - 1.0f)*(14.02 + 3.799 * z));\n\tif (ay > ax)\n\t\tatn = 90.0 - atn;\n\tif (x < 0.0f)\n\t\tatn = 180.0 - atn;\n\tif (y < 0.0f)\n\t\tatn = -atn;\n\n\treturn atn;\t\t// in [-180.0, 180.0] roughly depending on the float math\n}\n\nconst int N = 5;\t// patch size\n\n// the hash function\n// note: angle returned is the angle of the gradient; the edge angle is perpendicular\nvoid metric(in vec2 uv, out float angle, out float strength, out float coherence, out float L1ev)\n{\n    float xi2 = 0.0, xiyi = 0.0, yi2 = 0.0;\n    float wtsum = 0.0;\n// sig = 1.25 for N = 5\n// sig = 1.2 for N = 4 appears to work best\n// sig = 1.05 for N = 3\n    const float sig = 3.0;\n    int s = N/2;\n    for (int dy=0; dy<N; ++dy)\n    for (int dx=0; dx<N; ++dx)\n    {\n        vec2 delta = vec2(dx-s, dy-s);\n//        float wt = exp(-dot(delta,delta)/(2.0*sig*sig));\n        float wt = 1.0;              // ignore the gaussian weights for now\n        float xi = Pdx(uv + delta);\n        float yi = Pdy(uv + delta);\n        xi2 += wt*xi*xi;\n        yi2 += wt*yi*yi;\n        xiyi += wt*xi*yi;\n        wtsum += wt;\n    }\n    xi2 /= wtsum;\n    yi2 /= wtsum;\n    xiyi /= wtsum;\n    \n    float a = xi2, b = xiyi, d = yi2;\n    float det = sqrt((a-d)*(a-d) + 4.0*b*b);\n    float L1 = (a+d+det)/2.0;\n    float L2 = (a+d-det)/2.0;\n\n    \n    // find the L2 eigenvector\n    vec2 L1eigen;\n    \n    if (xiyi != 0.0)\n        L1eigen = vec2(L1-yi2, xiyi);\n    else if (yi2 != 0.0)\n        L1eigen = vec2(xiyi, L1-xi2);\n    else\n        L1eigen = vec2(1, 0);\n        \n    // and the results\n//    angle = fatan2(L1eigen.y, L1eigen.x) - 3.0*PI/4.0;\t// -3 pi / 4 to compensate for the rotated Roberts operator\n//    angle = atan(L1eigen.y, L1eigen.x) - 3.0*PI/4.0;\t// -3 pi / 4 to compensate for the rotated Roberts operator\n    // reduce to [0, PI) range\n //   angle = mod(angle, PI);\n    angle = fatan2d(L1eigen.y, L1eigen.x); // - 135.0;\n    angle = mod(angle, 180.0);\n    angle *= PI/180.0;\n    strength = sqrt(L1);\n    if (L1 < 1.0e-8)        // hack constant neighborhood\n        coherence = 1.0;   // what else should it be?\n    else\n    \tcoherence = (sqrt(L1) - sqrt(L2))/(sqrt(L1) + sqrt(L2));\n}   \n\nfloat phase(in float x)\n{\n    x = mod(x, 1.0);\n    return (x < 1.0/6.0) ? 6.0 * x :\n           (x < 1.0/2.0) ? 1.0 :\n           (x < 2.0/3.0) ? 4.0 - 6.0 * x :\n           0.0;\n}\n\n// 0..1 -> red = 0 yellow = .25 bluegreen = .5 purple = .75\n// so red is 0 degrees, yellow is 30 degrees, green is 60 degrees, blue green is 90,\n// blue is 120, purple is 150\nvec4 rainbow(float x)\n{\n    return vec4(phase(x-2.0/3.0), phase(x), phase(x-1.0/3.0), 1.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int xtile = 2, ytile = 2;   \n\tvec2 uv;\n    float xsize = floor(iResolution.x / float (xtile));\n    float ysize = floor(iResolution.y / float (ytile));\n    uv.x = mod(fragCoord.x, xsize) - xsize/2.0;\n    uv.y = mod(fragCoord.y, ysize) - ysize/2.0;\n    int xsel = int(floor(fragCoord.x / xsize)), ysel = int(floor(fragCoord.y / ysize));\n    \n    float angle, strength, coherence, l1ev;\n    \n    metric(uv, angle, strength, coherence, l1ev);\n    \n    vec4 clr = vec4(0);\n    \n    switch (ysel*xtile + xsel)\n    {\n        case 0:\n        \tclr = vec4(P(uv)/255.0); break;        \n\n        case 1:\n        \tclr = rainbow(angle/PI); break;\n        \n        case 2:\n        \tclr = vec4(strength*.004); break;\n\n        case 3:\n        \tclr = vec4(coherence)*1.0; break;\n    }\n    \n\tfragColor = clr;\n}","name":"Image","description":"","type":"image"}]}