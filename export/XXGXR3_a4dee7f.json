{"ver":"0.1","info":{"id":"XXGXR3","date":"1720714029","viewed":75,"name":"2d raymarching example #2","username":"hasenpfote","description":"This is a simple raymarching demo, created while experimenting with stateless mouse interactions.\nclick and drag.\n\nPREV: https://www.shadertoy.com/view/4XGSzt","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","mouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * 2d raymarching example #2 - v1.1.0:\n *\n */\n\n//#define SHOW_NORMALS\n//#define SHOW_ISOLINES\n\nstruct PointLight{\n    vec2 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    float radius;\n    float falloff;\n};\n\nstruct SpotLight{\n    vec2 pos;\n    vec2 dir;\n    vec3 ambient;\n    vec3 diffuse;\n    float radius;\n    float falloff;\n    float inner_cone_angle;\n    float outer_cone_angle;\n};\n\nconst int MAX_MARCH_STEPS = 128;\nconst float MIN_HIT_DISTANCE = 1e-3;\nconst float SURFACE_THICKNESS = 0.025;\n\nconst vec3 LIGHT_COLOR_1 = vec3(235, 247, 238) / 255.;\nconst vec3 LIGHT_COLOR_2 = vec3( 93, 160, 231) / 255.;\nconst vec3 LIGHT_COLOR_3 = vec3(233,  66,  58) / 255.;\nconst vec3 LIGHT_COLOR_4 = vec3(249, 193,  58) / 255.;\n\n//==============================================================================\n\n// https://iquilezles.org/articles/distgradfunctions2d/\n\nfloat sd_circle(in vec2 p, in float r){\n    return length(p) - r;\n}\n\nfloat sd_box(in vec2 p, in vec2 b){\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sd_triangle_isosceles(in vec2 p, in vec2 q){\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0., 1.);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0., 1.), 1.);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sd_rounded_x(in vec2 p, in float w, in float r){\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nfloat sd_star5(in vec2 p, in float r, in float rf){\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2. * max(dot(k1,p), 0.) * k1;\n    p -= 2. * max(dot(k2,p), 0.) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0., r );\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\nfloat sd_arc(in vec2 p, in vec2 sc, in float ra, in float rb){\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y * p.x > sc.x * p.y) ? length(p - sc * ra) : abs(length(p) - ra)) - rb;\n}\n\nfloat sd_moon(in vec2 p, in float d, in float ra, in float rb){\n    p.y = abs(p.y);\n    float a = (ra * ra - rb * rb + d * d) / (2. * d);\n    float b = sqrt(max(ra * ra - a * a, 0.));\n    if(d * (p.x * b - p.y * a) > d * d * max(b - p.y, 0.))\n        return length(p-vec2(a,b));\n    return max(length(p) - ra, -(length(p - vec2(d, 0.)) - rb));\n}\n\n//==============================================================================\n\nmat2 rot(in float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\n//==============================================================================\n\n/**\n * Smooth HSV - iq\n * https://www.shadertoy.com/view/MsS3Wc\n */\nvec3 hsv2rgb(in vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nconst int MAX_COLORS = 20;\n\nvec3 distinct_color(in int index){\n    float hue = clamp(float(index) / float(MAX_COLORS), 0., 1.);\n\n    return hsv2rgb(vec3(hue, 1., 0.5));\n}\n\nvec2 op_union(in vec2 lhs, in vec2 rhs){\n    return lhs.x < rhs.x ? lhs : rhs;\n}\n\nvec2 op_subtraction(in vec2 lhs, in vec2 rhs){\n    rhs.x = -rhs.x;\n    return lhs.x > rhs.x ? lhs : rhs;\n}\n\nvec2 map(vec2 p){\n    vec2 res = vec2(1e1, 0.);\n    vec2 res1, res2, sc;\n    vec2 o;\n    mat2 m = rot(iTime);\n\n    o = vec2(0.);\n\n    if(sd_box(p - o, vec2(0.7)) < res.x){\n        o = vec2(0.5);\n        sc = vec2(sin(0.4*TAU), cos(0.4*TAU));\n        res = op_union(res, vec2(sd_arc(rot(-iTime) * (p - o), sc, 0.1, 0.02), 0.));\n        res = op_union(res, vec2(sd_arc(rot(iTime + 0.75 * TAU) * (p - o), sc, 0.2, 0.02), 0.));\n\n        res = op_union(res, vec2(sd_circle(p - vec2(-0.5, 0.5), 0.2), 1.));\n\n        o = vec2(0.5,-0.5);\n        res1 = vec2(sd_circle(p - o, 0.20), 1.);\n        res2 = vec2(sd_circle(p - o, 0.15), 1.);\n        res = op_union(res, op_subtraction(res1, res2));\n\n        o = vec2(-0.5);\n        sc = vec2(sin(0.15*TAU), cos(0.15*TAU));\n        res = op_union(res, vec2(sd_arc(rot(-iTime) * (p - o), sc, 0.1, 0.02), 2.));\n        res = op_union(res, vec2(sd_arc(rot(iTime + 0.25 * TAU) * (p - o), sc, 0.2, 0.02), 2.));\n\n        res = op_union(res, vec2(sd_box(p - vec2(-0.65, 0.), vec2(0.1, 0.5)), 2.));\n        res = op_union(res, vec2(sd_box(p - vec2(0., -0.65), vec2(0.5, 0.1)), 2.));\n    }\n\n    o = vec2(1.2, 0.) + 0.25 * vec2(cos(3. * iTime), sin(2. * iTime + 0.25 * TAU));\n\n    if(sd_box(p - o, vec2(0.1)) < res.x){\n        res1 = op_union(res, vec2(sd_star5(m * (p - o), 0.10, 0.5), 3.));\n        res2 = op_union(res, vec2(sd_star5(m * (p - o), 0.07, 0.5), 3.));\n        res = op_union(res, op_subtraction(res1, res2));\n    }\n\n    o = vec2(1.2, 0.5) + 0.25 * vec2(cos(3. * iTime), sin(4. * iTime + 0.25 * TAU));\n\n    if(sd_box(p - o, vec2(0.1)) < res.x){\n        res = op_union(res, vec2(sd_star5(m * (p - o), 0.1, 0.5), 3.));\n    }\n\n    if(sd_box(p - vec2(-1.3, 0.), vec2(0.3)) < res.x){\n        res1 = vec2(sd_moon(m * (p - vec2(-1.3, 0.)), 0.2, 0.3, 0.25), 4.);\n        res2 = vec2(sd_rounded_x(m * (p - vec2(-1.3, 0.)), 0.2, 0.05), 5.);\n\n        res = op_union(res, op_subtraction(res1, res2));\n    }\n\n    return res;\n}\n\nvec2 normal(in vec2 p){\n    const float h = 1e-4;\n    const vec2 k = vec2(1., -1.);\n\n    return normalize(k.xx * map(p + h * k.xx).x + k.xy * map(p + h * k.xy).x - (k.xx + k.xy) * map(p).x);\n}\n\nfloat raymarch(in vec2 ro, in vec2 rd, in float mint, in float maxt){\n    float t = mint;\n\n    for(int i = 0; i < MAX_MARCH_STEPS && t < maxt; i++){\n        float h = map(ro + t * rd).x;\n\n        if(h < MIN_HIT_DISTANCE)\n            return t;\n\n        t += h;\n    }\n\n    return -1.;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat shadow(in vec2 ro, in vec2 rd, in float mint, in float maxt){\n    const float w = 0.01;\n\n    float res = 1.;\n    float t = mint;\n\n    for(int i = 0; i < 64 && t < maxt; i++){\n        float h = map(ro + t * rd).x;\n\n        res = min(res, h / (w * t));\n        t += clamp(h, 0.005, 0.5);\n        if(res < -1.)\n            break;\n    }\n\n    res = max(res, -1.);\n\n    return 0.25 * (1. + res) * (1. + res) * (2. - res);\n}\n\n// https://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat ambient_occlusion(in vec2 p, in vec2 n){\n    const int max_samples = 5;\n    const float maxt = 0.1 + MIN_HIT_DISTANCE + SURFACE_THICKNESS;\n\n    float ao = 0.;\n#if 0\n    vec2 range = atan2(n.y, n.x) + 0.25 * vec2(-TAU, TAU);\n#else\n    vec2 range = atan2(n.y, n.x) + 0.125 * vec2(-TAU, TAU);\n#endif\n    for(int i = 0; i < max_samples; i++){\n        float t_true = hash11(float(i)) * maxt;\n        vec2 rd = circular_rand(hash11(float(i)), range.x, range.y);\n        float t_observed = max(0., map(p + t_true * rd).x);\n\n        ao += (t_true - t_observed) / maxt;\n    }\n\n    return clamp(1. - ao / float(max_samples), 0., 1.);\n}\n\n// https://lisyarus.github.io/blog/posts/point-light-attenuation.html\nfloat attenuation(in float x, in float radius, in float falloff){\n    float s = x / radius;\n    float s2 = s * s;\n    float numerator = (1. - s2);\n\n    return (numerator * numerator) / (1. + falloff * falloff * s2);\n}\n\nvec3 lighting(in PointLight light, in int id, in float ao, in vec2 p, in vec2 n){\n    float d = distance(p, light.pos);\n\n    if(d >= light.radius)\n        return vec3(0.);\n\n    vec2 rd = normalize(light.pos - p);\n    vec3 color = id < 0 ? vec3(1.) : distinct_color(id);\n\n    vec3 i_a = light.ambient * color * ao;\n    vec3 i_d = light.diffuse * color * max(1. - length(n), dot(n, rd));\n\n    return i_a + i_d * attenuation(d, light.radius, light.falloff);\n}\n\nvec3 lighting(in SpotLight light, in int id, in float ao, in vec2 p){\n    float cos_t = dot(normalize(light.pos - p), -light.dir);\n    float outer_cutoff = cos(0.5 * light.outer_cone_angle);\n    float d = distance(p, light.pos);\n\n    if(d >= light.radius || cos_t < outer_cutoff)\n        return vec3(0.);\n\n    float f = smoothstep(0.0, 1.0, (cos_t - outer_cutoff) / (cos(0.5 * light.inner_cone_angle) - outer_cutoff));\n    vec3 color = id < 0 ? vec3(1.) : distinct_color(id);\n    vec3 i_a = light.ambient * color * ao;\n    vec3 i_d = light.diffuse * color * f;\n\n    return i_a + i_d * attenuation(d, light.radius, light.falloff);\n}\n\nfloat shadowing(in PointLight light, in vec2 p, in bool is_surface){\n    float d = distance(p, light.pos);\n\n    if(d >= light.radius)\n        return 0.;\n\n    vec2 rd = normalize(light.pos - p);\n\n    if(is_surface){\n        float t = raymarch(light.pos, -rd, 0., d + SURFACE_THICKNESS);\n\n        if(d - t < SURFACE_THICKNESS)\n            return 1.;\n    }\n\n    return shadow(p, rd, 0., d);\n}\n\nfloat shadowing(in SpotLight light, in vec2 p, in bool is_surface){\n    vec2 delta = light.pos - p;\n    vec2 rd = normalize(delta);\n    float d = length(delta);\n\n    if(d >= light.radius || dot(rd, -light.dir) < cos(light.outer_cone_angle))\n        return 0.;\n\n    if(is_surface){\n        float t = raymarch(light.pos, -rd, 0., d + SURFACE_THICKNESS);\n\n        if(d - t < SURFACE_THICKNESS)\n            return 1.;\n    }\n\n    return shadow(p, rd, 0., d);\n}\n\nvec3 draw_light(in PointLight light, in vec2 p, in vec3 color){\n    float d = sd_circle(p - light.pos, 0.03);\n\n    return mix(0.75 * light.diffuse, color, smoothstep(0., 0.003, d - MIN_HIT_DISTANCE));\n}\n\nvec3 draw_light(in SpotLight light, in vec2 p, in vec3 color){\n    vec2 offset_pos = light.pos - 0.05 * light.dir;\n    float angle = 0.25 * TAU + atan2(light.dir.y, light.dir.x);\n    float u = 0.5 + 0.5 * smoothstep(0., 0.25 * TAU, light.outer_cone_angle);\n    float d = sd_triangle_isosceles(rot(-angle) * (p - offset_pos), vec2(0.03 * u, -0.06));\n\n    return mix(0.75 * light.diffuse, color, smoothstep(0., 0.003, d - MIN_HIT_DISTANCE));\n}\n\n//==============================================================================\n\nvec4 mouse_to_ray(){\n    vec2 delta = iMouse.xy - abs(iMouse.zw);\n    vec2 ro = mix((2. * abs(iMouse.zw) - iResolution.xy) / iResolution.y,\n                  vec2(0.),\n                  float(all(lessThan(iMouse.xy, vec2(0.5)))));\n    vec2 rd = normalize(mix(delta, vec2(1., 0.), float(length(delta) < 1e-1)));\n\n    return vec4(ro, rd);\n}\n\n//==============================================================================\n\nSpotLight light1 = SpotLight(vec2(0.), vec2(0.), 0.2 * LIGHT_COLOR_1, LIGHT_COLOR_1, 1.5, 2., 0., 0.);\nSpotLight light2 = SpotLight(vec2(-1.5,  0.6), normalize(vec2(1., -1.)), 0.1 * LIGHT_COLOR_2, LIGHT_COLOR_2, 1.5, 1., 0.25132741, 0.31415926);\nSpotLight light3 = SpotLight(vec2(-1.5, -0.6), normalize(vec2(1.,  1.)), 0.1 * LIGHT_COLOR_3, LIGHT_COLOR_3, 1.5, 1., 0.25132741, 0.31415926);\nSpotLight light4 = SpotLight(vec2(0.5, 0.5), normalize(vec2(0., -1.)), 0.1 * LIGHT_COLOR_4, LIGHT_COLOR_4, 1., 2., 1.2007865, 1.5009831);\nPointLight light5 = PointLight(vec2(0.), 0.1 * vec3(1., 1., 0.), vec3(1., 1., 0.), 0.8, 8.);\nPointLight light6 = PointLight(vec2(0.), 0.1 * vec3(1., 0., 1.), vec3(1., 0., 1.), 0.8, 8.);\nPointLight light7 = PointLight(vec2(0.), 0.1 * vec3(0., 1., 1.), vec3(0., 1., 1.), 0.8, 8.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 h = map(uv);\n    int id = int(h.y);\n    bool is_surface;\n    vec2 n;\n    float ao;\n\n    if(h.x < -SURFACE_THICKNESS){\n        is_surface = false;\n        n = normal(uv);\n        ao = 1.;\n    }else if(h.x < MIN_HIT_DISTANCE){\n        is_surface = true;\n        n = normal(uv);\n        ao = ambient_occlusion(uv, n);\n    }else{\n        is_surface = false;\n        n = vec2(0.);\n        ao = 0.;\n        id = -1;\n    }\n\n    vec3 interior_color;\n#ifdef SHOW_NORMALS\n    interior_color = 0.5 + 0.5 * vec3(n, -1.);\n#else\n    interior_color = id < 0 ? vec3(1.) : distinct_color(id);\n#endif\n    vec3 color = mix(interior_color, vec3(0.), smoothstep(0., 0.003, h.x - MIN_HIT_DISTANCE));\n\n#ifdef SHOW_ISOLINES\n    color += 0.05 * sin(300.0 * h.x);\n#endif\n\n    // lighting\n\n    vec4 ray = mouse_to_ray();\n    float u = smoothstep(0.5, 0.05, distance(ray.xy, (2. * iMouse.xy - iResolution.xy) / iResolution.y));\n\n    light1.pos = ray.xy;\n    light1.dir = ray.zw;\n    light1.inner_cone_angle = mix(0.1256637, 2.5132741, u);\n    light1.outer_cone_angle = mix(0.15707963, 3.1415926, u);\n\n    light4.dir = rot(iTime) * vec2(0., -1.);\n\n    vec2 r = 0.4 * vec2(cos(iTime), sin(iTime));\n\n    light5.pos = cos(7. / 3. * iTime) * r;\n    light6.pos = cos(3. / 2. * iTime) * r;\n    light7.pos = cos(1. / 2. * iTime) * r;\n\n#ifdef SHOW_ISOLINES\n    if(is_surface)\n#endif\n        color *= ao; // global ambient\n\n    color += lighting(light1, id, ao, uv) * shadowing(light1, uv, is_surface);\n    color += lighting(light2, id, ao, uv) * shadowing(light2, uv, is_surface);\n    color += lighting(light3, id, ao, uv) * shadowing(light3, uv, is_surface);\n    color += lighting(light4, id, ao, uv) * shadowing(light4, uv, is_surface);\n    color += lighting(light5, id, ao, uv, n) * shadowing(light5, uv, is_surface);\n    color += lighting(light6, id, ao, uv, n) * shadowing(light6, uv, is_surface);\n    color += lighting(light7, id, ao, uv, n) * shadowing(light7, uv, is_surface);\n\n    // Visualizes light sources.\n    color = draw_light(light1, uv, color);\n#if 0\n    color = draw_light(light2, uv, color);\n    color = draw_light(light3, uv, color);\n    color = draw_light(light4, uv, color);\n    color = draw_light(light5, uv, color);\n    color = draw_light(light6, uv, color);\n    color = draw_light(light7, uv, color);\n#endif\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//==============================================================================\n\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//==============================================================================\n\nfloat atan2(in float y, in float x){\n    return x == 0. ? sign(y) * TAU / 4. : atan(y, x);\n}\n\nfloat cbrt(in float x){\n    return sign(x) * pow(abs(x), 1./3.);\n}\n\nvec3 cbrt(in vec3 x){\n    return sign(x) * pow(abs(x), vec3(1./3.));\n}\n\n//==============================================================================\n\n// Hash without Sine - David Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(in float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//\n\nvec2 circular_rand(in float u, in float start, in float end){\n    float angle = mix(start, end, u);\n\n    return vec2(cos(angle), sin(angle));\n}\n\nvec2 circular_rand(in float u){\n    return circular_rand(u, 0., TAU);\n}\n\n//==============================================================================\n\nvec3 srgb_to_linear(in vec3 color){\n    vec3 lo = vec3(color / 12.92);\n    vec3 hi = pow((color + 0.055) / 1.055, vec3(2.4));\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.04045)));\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    vec3 lo = 12.92 * color;\n    vec3 hi = 1.055 * pow(color, vec3(1./2.4)) - 0.055;\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.0031308)));\n}\n","name":"Common","description":"","type":"common"}]}