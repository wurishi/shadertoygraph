{"ver":"0.1","info":{"id":"4flBzH","date":"1723401377","viewed":54,"name":"Generalized Winding Numbers","username":"grom12345","description":"from this paper: https://users.cs.utah.edu/~ladislav/jacobson13robust/jacobson13robust.html","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define thickness 0.005\n\n#define numVertices 18\n#define numLoops 3\nconst vec2 v[numVertices] = vec2[](\n    vec2(0.0, 0.4),\n    vec2(-0.4, -0.1),\n    vec2(-0.2, -0.4),\n    vec2(0.2, -0.4),\n    vec2(0.4, -0.1),\n    vec2(0.0, 0.4),\n    \n    vec2(0.0, 0.15),\n    vec2(-0.2, -0.1),\n    vec2(-0.1, -0.25),\n    vec2(0.1, -0.25),\n    vec2(0.2, -0.1),\n    vec2(0.0, 0.15),\n    \n    vec2(0.0, 0.025),\n    vec2(-0.1, -0.1),\n    vec2(-0.05, -0.175),\n    vec2(0.05, -0.175),\n    vec2(0.1, -0.1),\n    vec2(0.0, 0.025)\n);\n\nconst int numColors = numLoops + 1;\nconst vec3 colors[numColors] = vec3[](\n    vec3(0.0, 0.0, 0.0),\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, 1.0, 0.0)\n);\n\n//https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix( vec3 colA, vec3 colB, float h )\n{\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    // gain in the middle (no oaklab anymore, but looks better?)\n // lms *= 1.0+0.2*h*(1.0-h);\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\nvec3 interpolateColors(float t) {\n    t = clamp(t, 0.0, float(numColors - 1));\n    int i = int(floor(t));\n    float f = fract(t);\n    return oklab_mix(colors[i], colors[i + 1], f);\n\n}\n\nvec4 paramLine(vec2 a, vec2 b, float t){\n    vec2 c = mix(a, b, 0.5);\n    return vec4(mix(a, c, t), mix(b, c, t));\n}\n\nvec3 parameter(float t){\n\n    float fn = float(numVertices-1);\n    int id = int(t*fn);\n    float tt = (t - float(id)/fn)*fn;\n    \n    vec2 last_v = mix(v[id], v[id+1], tt);\n\n    return vec3(last_v, float(id));\n}\n\nfloat sdThickLine(vec2 p, vec4 l){ \n    vec2 pa = p - l.xy;\n    vec2 ba = l.zw - l.xy;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 d = pa - ba * h;\n    return length(d) - thickness * 0.5;\n}\n\nfloat sdPolygon(vec2 p, vec3 lid, float t, float tt) {\n    \n    int id = int(lid.z);\n    \n    float d = 1000.;\n    float s = 1.0;\n    for(int i = 0; i <= id; i++) {\n        vec2 vv;\n        if(i==id) vv = lid.xy; else vv = v[i+1];\n        d = min(d, sdThickLine(p, paramLine(v[i], vv, tt)));\n    }\n    return sqrt(d);\n}\n\nfloat crs(vec2 u, vec2 v){\n    return u.x*v.y - u.y*v.x;\n}\n\nfloat windingNumberLine(vec2 p, vec4 l){\n    vec2 u = l.xy - p;\n    vec2 v = l.zw - p;\n    return atan(crs(u, v), dot(u, v));\n}\n\nfloat windingNumber(vec2 p, vec3 lid, float t){\n    int id = int(lid.z);\n    float d = 0.;\n    for(int i = 0; i <= id; i++) {\n        vec2 vv;\n        if(i==id) vv = lid.xy; else vv = v[i+1];\n        d += windingNumberLine(p, paramLine(v[i], vv, t));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float s = iTime * 0.1;\n    float phase = step(0., fract(s)-0.5);\n    float t = phase == 1. ? .999 : fract(s*2.);\n    float tt = phase == 1. ? fract(s*2.) : 0.;\n    \n    vec3 lid = parameter(t);\n    \n    float d = sdPolygon(uv, lid, t, tt);\n    float n = windingNumber(uv, lid, tt);\n    \n    vec3 col = vec3(1.0 - smoothstep(0.0, 0.02, abs(d)));\n    float cn = n/float(numVertices)*float(numLoops);\n    col += interpolateColors(cn);\n    col += max(0., -cn)*vec3(0, 0, 1);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}