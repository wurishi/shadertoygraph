{"ver":"0.1","info":{"id":"WsffWS","date":"1588931723","viewed":140,"name":"conic sections from shadows -","username":"matthen","description":"conic sections from shadows","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadows","conicsections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define HIT_THRESHOLD 0.00001\n#define TORUS_COLOR vec3(0.878, 0.211, 0.008)\n#define FLOOR_COLOR vec3(1., 1., 1.)\n#define PI 3.14159265\n\nfloat time() {\n    return 0.8 * iTime;\n}\n\nfloat theta() {\n    float stepSize = 2. * PI;\n    float t = time();\n    float i = floor(t / stepSize);\n    float tt = fract(t / stepSize);\n    tt = smoothstep(0., 0.9, tt);\n    return stepSize * (i + tt);\n}\n\nstruct Surface {\n\tvec3 color;\n};\n\n    \nstruct SceneDistance {\n    float d;\n    Surface surface;\n};\n    \n    \n\nSceneDistance planeDist(Surface surface, vec3 p, vec3 n, float d) {\n    return SceneDistance(\n        dot(p, n.xyz) + d,\n        surface\n    );\n}\n\n\nSceneDistance sphereDist(Surface surface, vec3 p, float s) {\n    return SceneDistance(\n        length(p) - s,\n        surface\n    );\n}\n\nSceneDistance torusDist(Surface surface, vec3 p, vec2 t) {\n  return SceneDistance(\n      length(vec2(length(p.xz) - t.x, p.y)) - t.y,\n      surface    \n  );\n}\n\nSceneDistance distanceUnion(SceneDistance d1, SceneDistance d2) {\n    if (d1.d < d2.d) {\n        return d1;\n    }\n    return d2;\n}\n\nSceneDistance distanceSubtract(SceneDistance d1, SceneDistance d2) {\n    if (d2.d > -d1.d) {\n    \treturn d2;   \n    }\n    return SceneDistance(\n    \t-d1.d, d2.surface    \n    );\n}\n\nSceneDistance shellDist(SceneDistance d, float thickness) {\n    return SceneDistance(\n    \tabs(d.d) - thickness,\n        d.surface    \n    ); \n}\n\nSceneDistance boxDist(Surface surface, vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return SceneDistance(\n      length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0),\n      surface\n  );\n}\n\n\nvec3 translate(vec3 v, vec3 t) {\n\treturn v - t;\n}\n\nvec3 rotate(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    mat4 rot= mat4(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,  0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n        0.0, 0.0, 0.0, 1.0);\n    return (rot * vec4(point, 1.)).xyz;\n}\n\nvec2 torus(int i) {\n    if (i == 0) {\n        float r = 1.2;\n        return vec2(r, atan(r, 1.));\n    } else if (i == 1) {\n        return vec2(1.6, 0.4);\n    } else {\n        return vec2(0.9, 1.9);\n    }\n}\n\n\nSceneDistance scene(in vec3 pos) {\n    Surface surf1 = Surface(FLOOR_COLOR);\n    Surface surf2 = Surface(TORUS_COLOR);\n    Surface surf3 = Surface(vec3(1., 1., 1.));\n    \n\tSceneDistance grid = planeDist(surf1, pos, vec3(0., 1., 0.), 2.);\n    \n    SceneDistance screen = boxDist(\n        surf3, translate(pos, vec3(0., 2.4, 2.)),\n        vec3(5., 4.8, 0.1));\n    \n    \n    vec3 torusPos = pos;\n    \n    float t = time();\n    t += 2.3;\n   \tint i = int(mod(1. + floor(t / (2. * PI)), 3.));\n   \tint iPrev = (i - 1) % 3;\n    vec2 torusCurr = torus(i);\n    vec2 torusPrev = torus(iPrev);\n    float mixV = smoothstep(5., 2.*PI, mod(t, 2. * PI));\n    vec2 torusMix = mix(torusPrev, torusCurr, mixV);\n    \n    \n    torusPos = translate(pos, vec3(0., 2., 0.));    \n    torusPos = rotate(torusPos, vec3(1., 0., 0.), torusMix.y + 0.3 * sin(2. * PI * mixV));\n    torusPos = rotate(torusPos, vec3(0., 0., 1.), 2. * PI * mixV);\n    torusPos = translate(torusPos, vec3(0., 1., 0.));    \n    \n\tSceneDistance torus = torusDist(\n        surf2, torusPos, vec2(torusMix.x, 0.07)); \n    \n\treturn distanceUnion(screen, distanceUnion(grid, torus));\n}\n\nvec3 sceneNormal(vec3 pos, float d) {\n    float eps = 0.001;\n    return normalize(\n        vec3(\n        scene(vec3(pos.x + eps, pos.y, pos.z)).d - d,\n    \tscene(vec3(pos.x, pos.y + eps, pos.z)).d - d,\n    \tscene(vec3(pos.x, pos.y, pos.z + eps)).d - d\n     ));\n}\n\nstruct Ray {\n\tvec3 org;\n\tvec3 dir;\n};\n\nstruct MarchResult {\n\tbool hit;\n    vec3 pos;\n    vec3 norm;\n    int steps;\n    Surface surface;\n};\n\nMarchResult rayMarch(Ray ray) {\n\tMarchResult result = MarchResult(\n    \tfalse,\n        ray.org,\n        vec3(0., 0., 0.),\n        0,\n        Surface(vec3(0., 0., 0.))\n    );\n\n    for (; result.steps < MAX_STEPS; result.steps++) {\n\t\tSceneDistance sd = scene(result.pos);\n\t\tif (sd.d < HIT_THRESHOLD) {\n\t\t\tresult.hit = true;\n\t\t\tresult.norm = sceneNormal(result.pos, sd.d);\n            result.surface = sd.surface;\n\t\t\tbreak;\n\t\t}\n\t\tresult.pos += sd.d * ray.dir;\n\t}\n\treturn result;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = mint;\n    for ( int i = 0; i < 64; ++i )\n    {\n        float h = scene(ro + rd * t).d;\n        if ( h < 0.001 && i > 0) {\n            return 0.2;\n        }\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\n\nvec3 shade(MarchResult marchResult, vec4 light) {\n    float attn = 0.9;\n    if (marchResult.pos.z > 2. && marchResult.pos.y > -1.999 && light.z < 1.) {\n        marchResult.norm = vec3(0., 0., -1.);\n        marchResult.pos.z -= 0.2;\n        attn = 0.7;\n    }\n\tvec3 toLight = light.xyz - marchResult.pos;\n\t\n\tfloat toLightLen = length(toLight);\n\ttoLight = normalize(toLight);\n\t\n\tfloat comb = 0.1;\n    float vis = 0.;\n    vis = shadow(marchResult.pos, toLight, 0.01, toLightLen);\n    \n\tif (vis > 0.0) {\n\t\tfloat diff = 1. * max(0.0, dot(marchResult.norm, toLight));\n\t\tattn *= 1.0 - pow(min(1.0, toLightLen / light.w), 2.0);\n        comb += diff * attn * vis;\n\t}\n\t\n\treturn comb * marchResult.surface.color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\tvec2 scaledXY = 0.4 * ndcXY * vec2( aspectRatio, 1.0 );\n\t\n   \t\n    Ray ray;\n\tray.org = vec3(0.0, 2.6, 15.0);\n\tray.dir =  normalize(vec3(scaledXY, -1)); // OpenGL is right handed\n    \n    float theta =  theta();    \n    \n    ray.org.z -= 2.;\n\tray.org = rotate(ray.org, vec3(0., 1., 0.), theta);\n    ray.org.z += 2.;\n    \n\tray.dir = rotate(ray.dir, vec3(0., 1., 0.), theta);\n    \n    \n    \n\t// define point lights (XYZ, range)\n\tvec4 light1 = vec4(0., 2., 0.0, 12.0);\n\t\n    MarchResult marchResult = rayMarch(ray);\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif (marchResult.hit) {\n\t\t// our ray hit the scene, so shade it with 2 point lights\n\t\tvec3 shade1 = shade(marchResult, light1);\n\t\t\n\t\tfragColor = vec4(shade1, 1.0);\n\t}\n    \n    // point source of light.\n    float lightD = length(ray.org - light1.xyz);\n    if (lightD < length(marchResult.pos - ray.org)) {\n        float flare = dot(normalize(ray.dir), normalize(light1.xyz - ray.org));\n        float mixV = 0.6 * smoothstep(0.9995, 1., pow(flare, 2.));\n        mixV += 0.3 * smoothstep(0.99, 0.9999, pow(flare, 0.7));\n        fragColor.rgb = mix(\n        \tfragColor.rgb, vec3(1., 1., 1.),\n            mixV\n        );\n    } \n    \n    \n}\n","name":"Image","description":"","type":"image"}]}