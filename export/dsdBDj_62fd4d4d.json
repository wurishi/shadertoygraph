{"ver":"0.1","info":{"id":"dsdBDj","date":"1697667541","viewed":147,"name":"A Cosmos in Film","username":"Real_NC","description":"Playing around with a very simple film emulation that still looks decent.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["worley","stars","film","hash","cosmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"A Cosmos in Film\" original demo scene by Real_NC. \n    \n    All original code in this shader may be used freely for educational or \n    personal purposes. For unspecified uses, see The Shadertoy License.\n    \n    Shader Overview:\n    - Generates a texture of light intensities\n        - The texture consists of multiple layers of bloomed circles generated with worley noise\n        - uv coordinates are warped in a few ways to create visually pleasing effects\n    - Take the texture and applies cheap approximations of film\n    \n    \n    This shader is quite sloppy, don't look to closely ;)\n*/\n\nfloat hash11(float p) // courtesy of Dave Hoskins\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p) // courtesy of Dave Hoskins\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 worleyCell(vec2 p)\n{\n    p = floor(p);\n    return p + vec2(hash12(p), hash12(p.yx + 3.0));\n}\n\nvec2 worleyID(vec2 p)\n{\n    float d = 5.0;\n    float d1;\n    float ID;\n    vec2 cell;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            cell = worleyCell(p + vec2(x,y));\n            d1 = length(cell - p);\n            if(d1 < d){d = d1; ID = hash12(cell+0.3);}\n        }\n    }\n    return vec2(d, ID);\n}\n\nvec3 randomSatCol (float p)\n{\n    vec3 c = vec3(hash11(p + 7.1), hash11(p*3.14159 + 4.0), hash11(p*21.7983 + 2.0));\n    c = pow(c, vec3(1.5)); // Increases saturation\n    c /= max(c.r, max(c.g, c.b)); // Make sure at least one color channel always = 1.0\n    \n    \n    \n    return c;\n}\n\nvec3 ACESFilm(vec3 x) // Modified courtesy of https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n{\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 grain(vec2 coord)\n{\n    float t = round(iTime*30.0);\n    return 1.0 - 0.026*vec3(hash12(coord + t*24.389), hash12(coord + t*1.023), hash12(coord + t*0.49));\n}\n\nvec3 smootherGrain(vec2 coord) // blur grain, this is not an efficient way to make the grain texture but it works\n{\n    vec3 g = grain(coord) + \n             grain(coord + vec2(1,0))*.5 + \n             grain(coord + vec2(0,1))*.5 +\n             grain(coord + vec2(1,1))*.5;\n    return g * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Shader with high-contrast & bright image--------------------------------------------------------------------------------\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    uv *= (1.0+uv.y*0.1);\n    fragColor = texture(iChannel0, uv*0.1 + 3.0 + iTime*vec2(0.0003, 0.0006))*0.2;\n    vec2 w;\n    for(int i = 0; i <= 20; i++)\n    {\n        w = worleyID(iTime*vec2(0.03, 0.06) + float(i*100) + uv*(1.0 + 0.01*dot(uv,uv)*float(20-i))*(15.0 / float(i + 2)));\n        fragColor.rgb *= 0.8;\n        fragColor.rgb += randomSatCol(float(i))/(max(pow(w.x, 1.5), 0.0001)*100.0)*(w.y*0.2 + 0.8);\n    }\n    \n    //Film & Color Effects:-------------------------------------------------------------------------------------------------\n    fragColor.rgb = 1.0 - fragColor.rgb * 0.3; // invert and apply brightness correction\n    fragColor.rgb *= smootherGrain(fragCoord); // apply film grain\n    fragColor.rgb = 1.0 - fragColor.rgb;       // invert colors back to the correct orientation\n    fragColor.rgb = ACESFilm(fragColor.rgb);   // apply an ACES filmic tonemapper aproximation\n    fragColor = pow(fragColor, vec4(1.0/2.2)); // gamma correction to display on sRGB monitors\n}","name":"Image","description":"","type":"image"}]}