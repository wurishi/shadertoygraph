{"ver":"0.1","info":{"id":"lf3yz4","date":"1730303699","viewed":85,"name":"light and shadow in","username":"nayk","description":"origianls from glslsnadbox","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["shadow","light","rotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHT\n#define ENABLE_POINT_LIGHT_FLARE\n#define time iTime\n#define resolution iResolution.xy\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n\nvoid CalcPixelRandom()\n{\n// Nothing special here, just numbers generated by bashing keyboard\nvec4 s1 = sin(time * 3.3422 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\nvec4 s2 = sin(time * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\ngPixelRandom = fract(2142.4 + s1 + s2);\ngRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n#endif\n\nstruct C_Ray\n{\nvec3 vOrigin;\nvec3 vDir;\n};\n \nstruct C_HitInfo\n{\nvec3 vPos;\nfloat fDistance;\nvec3 vObjectId;\n};\n \nstruct C_Material\n{\nvec3 cAlbedo;\nfloat fR0;\nfloat fSmoothness;\nvec2 vParam;\n};\n \nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\nfloat s = sin(fAngle);\nfloat c = cos(fAngle);\n\nvec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\nreturn vResult;\n}\n \nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\nfloat s = sin(fAngle);\nfloat c = cos(fAngle);\n\nvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\nreturn vResult;\n}\n     \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\nfloat s = sin(fAngle);\nfloat c = cos(fAngle);\n\nvec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\nreturn vResult;\n}\n \nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n//if(v1.x < v2.x) return v1; else return v2;\nreturn mix(v1, v2, step(v2.x, v1.x));\n}\n \nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\nreturn mix(v2, v1, step(v2.x,v1.x));\n}\n \nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\nreturn DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n \nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\nvec3 vResult = vPos;\nvec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\nvTile = floor(vTilePos + 1.0);\nvResult.xz = (fract(vTilePos) - 1.5) * vRepeat;\nreturn vResult;\n}\n \nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\nvec3 vResult = vPos;\nvec2 vTilePos = (vPos.xz / vRepeat) + 2.5;\nvResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\nreturn vResult;\n}\n \nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\nvec3 vResult = vPos;\nvResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\nreturn vResult;\n}\n \nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\nfloat angle = atan( vPos.x, vPos.z );\n\nfloat kPI = acos(0.0);\nfloat kHalfPi = asin(1.0);\nfloat kTwoPI = kPI * 2.0;\nfloat fScale = fSteps / (kTwoPI);\nfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\nfloat s = sin(-steppedAngle);\nfloat c = cos(-steppedAngle);\n\nvec3 vResult = vec3( c * vPos.x + s * vPos.z,\n    vPos.y,\n   -s * vPos.x + c * vPos.z);\n\nreturn vResult;\n}\n \nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\nvec2 q = vec2(length(p.xy)-r1,p.z);\nreturn length(q)-r2;\n}\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\nvec2 q = vec2(length(p.yz)-r1,p.x);\nreturn length(q)-r2;\n}\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\nreturn length(vPos.xz) - r;\n}\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n{\nvec3 vDist = (abs(vPos) - vSize);\nreturn max(vDist.x, max(vDist.y, vDist.z));\n}\n \nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\nvec3 vClosest = max(min(vPos, vSize), -vSize);\nreturn length(vClosest - vPos) - fRadius;\n}\n \n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{          \nvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n       \nvec3 vSphereDomain = DomainRepeatXZ(vPos, vec2(10.0, 10.0));\n       \nvec4 vDistSphere = vec4( length(vSphereDomain) - 1.0,2.0, vSphereDomain.xy);\n       \nvResult = DistCombineUnion(vResult, vDistSphere);\n     \nvec4 vDistFloor = vec4(vPos.y + 1.0, 1.0, vPos.xz);\nvResult = DistCombineUnion(vResult, vDistFloor);\n     \nreturn vResult;\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\nC_Material mat;\n\n   \nif(vObjId.x < 1.5)\n{\n// floor\nmat.fR0 = 0.02;\nmat.fSmoothness = 0.0;\nmat.cAlbedo = vec3(0.7, 1.8, 1.3);\n}\nelse\nif(vObjId.x < 2.5)\n{\n// sphere\nmat.fR0 = 0.00;\nmat.fSmoothness = 10.0;\nmat.cAlbedo = vec3(1.05, 0.35, 1.75);\n}\n\nreturn mat;\n}\nvec3 GetSkyGradient( const in vec3 vDir )\n{\nfloat fBlend = vDir.y * 0.5 + 0.2;\nreturn mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.9, 1.0), fBlend);\n}\nvec3 GetLightPos()\n{\nvec3 vLightPos = vec3(0.0, 1.0, 3.0);\n#ifdef ENABLE_MONTE_CARLO        \nvLightPos += gRandomNormal * 0.2;\n#endif\nreturn vLightPos;\n}\nvec3 GetLightCol()\n{\nreturn vec3(32.0, 6.0, 1.0) * 10.0;\n}\n \nvec3 GetAmbientLight(const in vec3 vNormal)\n{\nreturn GetSkyGradient(vNormal);\n}\n\n#define kFogDensity 0.0025\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n#ifdef ENABLE_FOG\n// fog\nfloat fFogAmount = exp(intersection.fDistance * -kFogDensity);\nvec3 cFog = GetSkyGradient(ray.vDir);\ncol = mix(cFog, col, fFogAmount);\n#endif\n       \n// glare from light (a bit hacky - use length of closest approach from ray to light)\n#ifdef ENABLE_POINT_LIGHT_FLARE\nvec3 vToLight = GetLightPos() - ray.vOrigin;\nfloat fDot = dot(vToLight, ray.vDir);\nfDot = clamp(fDot, 0.0, intersection.fDistance);\n       \nvec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\nfloat fDist = length(vClosestPoint - GetLightPos());\ncol += GetLightCol() * 0.01/ (fDist * fDist);\n#endif    \n}\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n// tetrahedron normal\nfloat fDelta = 0.025;\n\nvec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\nvec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\nvec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\nvec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\nfloat f1 = GetDistanceScene( vPos + vOffset1 ).x;\nfloat f2 = GetDistanceScene( vPos + vOffset2 ).x;\nfloat f3 = GetDistanceScene( vPos + vOffset3 ).x;\nfloat f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\nvec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\nreturn normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.01\n#define kRaymarchMatIter 256\n#define kRaymarchStartDistance 0.1\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{        \nresult.fDistance = kRaymarchStartDistance;\nresult.vObjectId.x = 0.0;\n \nfor(int i=0;i<=kRaymarchMatIter;i++)              \n{\nresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\nvec4 vSceneDist = GetDistanceScene( result.vPos );\nresult.vObjectId = vSceneDist.yzw;\n\n// abs allows backward stepping - should only be necessary for non uniform distance functions\nif((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n{\nbreak;\n}                        \n\nresult.fDistance = result.fDistance + vSceneDist.x;    \n}\n       \n       \nif(result.fDistance >= fMaxDist)\n{\nresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\nresult.vObjectId.x = 0.0;\nresult.fDistance = 1000.0;\n}\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\nC_Ray shadowRay;\nshadowRay.vDir = vLightDir;\nshadowRay.vOrigin = vPos;\n\nC_HitInfo shadowIntersect;\nRaymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n   \nreturn step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );          \n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\nfloat fDot = dot(vNormal, -vView);\nfDot = min(max((1.0 - fDot), 0.0), 1.0);\nfloat fDot2 = fDot * fDot;\nfloat fDot5 = fDot2 * fDot2 * fDot;\nreturn fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n\nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\nreturn max(0.0, dot(vLightDir, vNormal));\n}\n\nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{          \nvec3 vHalf = normalize(vLightDir - ray.vDir);\nfloat fNdotH = max(0.0, dot(vHalf, vNormal));\n\nfloat fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\nfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\nreturn pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n\n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\nvec3 vPos = intersection.vPos;\n       \nfloat fAmbientOcclusion = 1.0;\n       \nfloat fDist = 0.0;\nfor(int i=0; i<=5; i++)\n{\nfDist += 0.1;\n\nvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\nfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                  \n}\n       \nreturn fAmbientOcclusion;\n}\n \nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\nvec3 cScene ;\n\nvec3 vSpecularReflection = vec3(0.0);\nvec3 vDiffuseReflection = vec3(0.0);\n\nfloat fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\nvec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\nvDiffuseReflection += vAmbientLight;\n\nvSpecularReflection += cReflection * fAmbientOcclusion;\n     \n\nvec3 vLightPos = GetLightPos();\n \nvec3 vToLight = vLightPos - intersection.vPos;\n      vToLight.x+=cos(iTime)*15.;\n      vToLight.z+=sin(iTime)*15.;\nvec3 vLightDir = normalize(vToLight);\nfloat fLightDistance = length(vToLight);\n\nfloat fAttenuation = 3.0 / (fLightDistance * fLightDistance);\n\nfloat fShadowBias = 0.1;            \nfloat fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\nvec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\nvDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                \nvSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n\n\nvDiffuseReflection *= material.cAlbedo;              \n\n#ifdef ENABLE_SPECULAR\nfloat fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 5.9 + 0.1);\ncScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n#else\ncScene = vDiffuseReflection;\n#endif\n\nreturn cScene;\n}\n\nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\nC_HitInfo intersection;\nRaymarch(ray, intersection, 16.0, 32);\n   \nvec3 cScene;\n\nif(intersection.vObjectId.x < 0.5)\n{\ncScene = GetSkyGradient(ray.vDir);\n}\nelse\n{\nC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\nvec3 vNormal = GetSceneNormal(intersection.vPos);\n\n// use sky gradient instead of reflection\nvec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n\n// apply lighting\ncScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n}\n\nApplyAtmosphere(cScene, ray, intersection);\n\nreturn cScene;\n}\n\nvec3 GetSceneColour( const in C_Ray ray )\n{            \n\n   \nC_HitInfo intersection;\nRaymarch(ray, intersection, 1024.0, 256);\n   \nvec3 cScene;\n       \nif(intersection.vObjectId.x < 0.5)\n{\ncScene = GetSkyGradient(ray.vDir);\n}\nelse\n{\nC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\nvec3 vNormal = GetSceneNormal(intersection.vPos);\n\n#ifdef ENABLE_MONTE_CARLO\nvNormal = normalize(vNormal + gRandomNormal / (0.0 + material.fSmoothness * 200.0));\n#endif\n\nvec3 cReflection;\n#ifdef ENABLE_REFLECTIONS    \n{\n// get colour from reflected ray\nfloat fSepration = 0.15;\nC_Ray reflectRay;\nreflectRay.vDir = reflect(ray.vDir, vNormal);\nreflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n     \ncReflection = GetSceneColourSimple(reflectRay);                                                                        \n}\n#else\ncReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                              \n#endif\n// apply lighting\ncScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n}\n       \nApplyAtmosphere(cScene, ray, intersection);\n       \nreturn cScene;\n}\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\nvec2 vPixelCoord = gl_FragCoord.xy;\n#ifdef ENABLE_MONTE_CARLO\nvPixelCoord += gPixelRandom.zw;\n#endif\nvec2 vUV = ( vPixelCoord / resolution.xy );\nvec2 vViewCoord = vUV * 2.0 - 1.0;\n\nvViewCoord *= 1.75;\n       \nfloat fRatio = resolution.x / resolution.y;\n\nvViewCoord.y /= fRatio;                          \n\nray.vOrigin = vPos;\n\nvec3 vRight = normalize(cross(vForwards, vWorldUp));\nvec3 vUp = cross(vRight, vForwards);\n   \nray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);        \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\nvec3 vForwards = normalize(vInterest - vPos);\nvec3 vUp = vec3(0.0, 3.0, 0.0);\n\nGetCameraRay(vPos, vForwards, vUp, ray);\n}\n\nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\nreturn vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n\nvec3 Gamma( const in vec3 cCol )\n\n{\n\n vec2 uv = iResolution.xy ;\n \nreturn cCol * cCol;\n}\n\nvec3 InvGamma( const in vec3 cCol )\n{\nreturn sqrt(cCol);\n}\n\n\nvec3 Tonemap( const in vec3 cCol )\n{\n \nvec3 vResult = cCol / (1.0 + cCol);\n\nreturn Gamma(vResult);\n}\n\nvec3 InvTonemap( const in vec3 cCol )\n{\n \nvec3 vResult = cCol;\nvResult = clamp(vResult, 2.01, 0.99);\nvResult = InvGamma(vResult);\nreturn - (vResult / (vResult - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef ENABLE_MONTE_CARLO            \nCalcPixelRandom();\n#endif\n       vec2 uv = (fragCoord.xy / iResolution.xy) - .5;\nC_Ray ray;\n       \nconst float fCamreaInitialHeading = 12.5;\nconst float fCamreaInitialElevation =0.4;\nconst float fCamreaInitialDist = 10.0;\nconst float fCameraHeight = -10.09;\nconst float fOrbitSpeed = 10.0;\n\n// This magic stolen from other 3d pan/zoom examples\nfloat fZoom =  3.5 + 0.4;\n\nvec2 vCenterPosition = (0.5 - ( gl_FragCoord.xy / resolution )) * 1. + uv;\nfloat fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\nfloat fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n\nvec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n\nvCameraPos += vec3(sin(iTime)*10., -fCameraHeight, 10.*cos(iTime));\n#ifdef ENABLE_MONTE_CARLO            \nfloat fDepthOfField = 2.225;\nvCameraPos += gRandomNormal * fDepthOfField;\n#endif\n       \nGetCameraRayLookat( vCameraPos, vec3(0.0, 2.0, 0.0), ray);\n\n       \nvec3 cScene = GetSceneColour( ray );  \n         \nfloat fExposure = 1.5;\ncScene = cScene * fExposure;\n         \n               \n         vec2 uv2 = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 40; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, tan(iTime*0.01));\n\t\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .5, len);\n\tv2 *= smoothstep(.5, 1.0, len);\n\tv3 *= smoothstep(.2, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n#ifdef ENABLE_MONTE_CARLO                              \nvec3 cPrev = texture2D(backbuffer, gl_FragCoord.xy / resolution).xyz;\n// add noise to pixel value (helps values converge)\ncPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\ncPrev = InvTonemap(cPrev);\n// converge speed\nfloat fBlend = 0.1;\nvec3 cFinal = mix(cPrev, cScene, fBlend);\n#else\nvec3 cFinal = cScene;\n#endif\n\ncFinal = Tonemap(cFinal);\n       \nfloat fAlpha = 1.0;\n       \nfragColor = vec4( cFinal, fAlpha );\n}\n\n\n","name":"Image","description":"","type":"image"}]}