{"ver":"0.1","info":{"id":"4cdXz7","date":"1713763981","viewed":66,"name":"Supersonic wind tunnel","username":"ukeshet","description":"Wing (NACA 2315) vs. sphere at Mach 2.\n2D compressible solver: de Laval nozzle (https://www.shadertoy.com/view/XcyGW3)\nBlob visualization: de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\nClick a field name for view. If crashes, lower CFL.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","physics","wing","finitedifferences","idealfluid","windtunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compressible 2D ideal flow simulation of objects moving at Mach 2.\n// Here: a standard wing (NACA 2315: not supersonic) vs. a sphere. \n// Note the extended shock and large standoff distance of the latter. \n//\n// 2D compressible sovler from de Laval nozzle (https://www.shadertoy.com/view/XcyGW3)\n// Blob visualization from de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\n// Demo for ICP + Astrophysics 1 courses, by ukeshet.\n//\n// Buffer A sets up initial and boundary conditions. Revise for different objects.\n// Buffer B is a simple 2D ideal fluid solver.\n// Buffer C traces T-blobs (moving at velocity*3).\n//\n// If the code crashes on your setup, lower the time stepping (CFL) parameter in Common (line 7).\n// Otherwise, raise CFL for a faster and more interesting visualization.\n//\n// Visualization cycles through field views unless you click on a field name or elsewhere.\n\n#define Bx .80 // Text box geometry.\n#define y1 .64\n#define y2 .57\n#define y3 .50\n#define y4 .43\n#define y5 .36\n#define ysh -.36\n\nvec2 uv, k;\n\nvec4 K(int c) { // Type a character\n    vec2 p=(uv-k)*22.; k.x+=.02;\n    if (p.x<.0||p.x>1.||p.y<0.||p.y>1.) return vec4(0.);\n    return textureGrad(iChannel1,p/16.+fract(vec2(c+64,15-(c+64)/16)/16.),dFdx(p/16.),dFdy(p/16.));\n}\n\nvec3 CP(float x) { // Color palette\n    x=smoothstep(-1.,1.,x)*2.-1.;\n    float x2=x*x, x4=x2*x2, x8=x4*x4;\n    return vec3(x,x2,x8*x8);\n}\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n    uv = Coo.xy/iResolution.xy;\n    float T, dx=1./iResolution.x, dy=1./iResolution.y, dt=CFL*min(dx,dy), AspR=iResolution.y/iResolution.x, t=mod(iTime,27.);\n    Dx=round(iResolution.x/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    vec4 A=texture(iChannel0, uv);\n    Col = vec4(log(A.z+.1)*2.4,log(A.w+.1)*2.1,.3*length(A.xy)/pow(G*A.w/A.z,0.5),1.);\n    int V; vec2 M;\n    if ((uv.x>Bx) && (uv.y>ysh+y5) && (uv.y<ysh+y1)) Col*=0.; // Text box and text:\n    k=vec2(.8,ysh+.57); Col += vec4(0.,(K(16)+K(50)+K(37)+K(51)+K(51)+K(53)+K(50)+K(37)).x,0.,1.);\n    k=vec2(.8,ysh+.51); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)).x,1.);\n    k=vec2(.8,ysh+.45); Col += vec4((K(4)+K(37)+K(46)+K(51)+K(41)+K(52)+K(57)).x,0.,0.,1.);\n    k=vec2(.8,ysh+.39); Col += vec4(vec2((K(20)+K(37)+K(45)+K(48)+K(232)+K(54)+K(234)+K(243)+K(233)).x),0.,1.);\n    if(iMouse.z<=0.) V=0; else { M=iMouse.xy/iResolution.xy;\n        if (M.x>Bx && M.y>ysh+y2 && M.y<ysh+y1) V=1;\n        else if (M.x>Bx && M.y>ysh+y3 && M.y<ysh+y2) V=2;\n        else if (M.x>Bx && M.y>ysh+y4 && M.y<ysh+y3) V=3;\n        else if (M.x>Bx && M.y>ysh+y5 && M.y<ysh+y4) V=4;\n        else V=5;}\n    if ((V==5) || ((V==0) && (t>7.5) && (t<15.))) { // show (rho,P,M)\n        if ((uv.x>Bx) && (uv.y>ysh+y5) && (uv.y<ysh+y4)) Col*=0.; }\n    if (V==1 || (V==0 && (t>15.) && (t<19.))) {    // show (0,P,0)\n        Col.xz*=0.; if ((uv.x>Bx) && (uv.y>ysh+y5) && (uv.y<ysh+y2)) Col*=0.; }\n    if (V==2 || (V==0 && (t>19.) && (t<23.))) {    // show (0,0,Mach)\n        Col.xy*=0.; if ((uv.x>Bx) && (((uv.y>ysh+y5) && (uv.y<ysh+y3)) || ((uv.y>ysh+y2) && (uv.y<ysh+y1)))) Col*=0.; }\n    if (V==3 || (V==0 && t>23.)) {                              // show (rho,0,0)\n        Col.yz*=0.; if ((uv.x>Bx) && (((uv.y>ysh+y3) && (uv.y<ysh+y1)) || ((uv.y>ysh+y5) && (uv.y<ysh+y4)))) Col*=0.; }\n    if (V==4 || (V==0 && (t>0.) && (t<7.5))) {      // show T blobs\n        if ((uv.x<Bx) || ((uv.y<ysh+y5) || (uv.y>ysh+y4))) {\n            Col=vec4(0.,0.,0.,1.);\n            if ( (Separatrix==false || abs(uv.y-.5)>.5*Dy) && (length(uv-vec2(Bx0,By0))>Br+.5*Dx) &&\n                ((uv.x<WxL) || (uv.x>WxR) || (dyBN1(uv)<-.5*Dx) || (dyTN1(uv)>+.5*Dx)) )  { \n                for(float ix=-1.; ix<1.5; ix+=1.) for(float iy=-1.; iy<1.5; iy+=1.) {\n                    vec2 uv1=uv+vec2(Dx*ix,Dy*iy);\n                    if (uv1.x>=0. && uv1.x<1. && uv1.y>=0. && uv1.y<1.) {\n                        vec4 B=texture(iChannel2,uv1);\n                        for (int j=0; j<4; j++) {\n                            vec3 q=unpack(B2i(B[j]));\n                            if (length(uv-vec2(Dx*floor(uv1.x/Dx),Dy*floor(uv1.y/Dy))-vec2(Dx*q.x,Dy*q.y))<.005*(1.-.8*log(1.*A.z)))\n                                Col.xyz=max(Col.xyz,CP(log(A.w/A.z+.3)*1.6*(1.+.1*q[2])));\n                        }}}}}\n        if ((uv.x>Bx) && (uv.y>ysh+y4) && (uv.y<ysh+y1)) Col*=0.;\n    }\n    if ((uv.x > WxL) && (uv.x < WxR) && ((abs(AspR*dyBN1(uv))<dy) || (abs(AspR*dyTN1(uv))<dy))) Col=vec4(1.); // mark wing\n    if (abs(length(uv-vec2(Bx0,By0))-Br)<1.1*dy) Col=vec4(1.); // mark object 2\n    if (Separatrix && (uv.y>.5-dy) && (uv.y<.5+dy)) Col=vec4(1.); // mark separatrix\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common: Geometry and parameter setup.\n// ______________________________________\n\n#define pi 3.1415926535\n\n// Time stepping (CFL) parameter:\n#define CFL .07 // lower value if code crashes on your setup.\n\n// Hydro params:\n#define rho0 1.\n#define P0 1.\n#define vIn vec2(-2.582,0.)\n#define G 1.4 // adiabatic index\n\n// Wing 1 profile (NACA 2315):\n#define Wx0 .75\n#define Wy0 .75\n#define Wdx .22\n#define WxL (Wx0-.5*Wdx)\n#define WxR (Wx0+.5*Wdx)\n#define Wm .02\n#define Wp .3\n#define Wt .15\n\n// object 2 profile (sphere):\n#define Bx0 .65\n#define By0 .25\n#define Br .02\n#define BxL (Bx0-Br)\n#define BxR (Bx0+Br)\n\n// Separate objects?\n#define Separatrix true\n\n// T-blob visualization\n#define SU 3.\n#define DT .05\n#define Nx 40.\n#define Ny 40.\nfloat Dx,Dy;\n\n// Wing geometry:\n\nfloat dyTN1(vec2 xy) { // Oriented distance from top edge of object 1\n    float Wc, x1=(Wx0+.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-(Wy0+(+5.*Wt*(.2969*pow(x1,.5)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nfloat dyBN1(vec2 xy) { // Oriented distance from bottom edge of object 1\n    float Wc, x1=(Wx0+.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-(Wy0+(-5.*Wt*(.2969*pow(x1,.5)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nvec2 NormT1(vec2 xy) { // Normal to top edge of object 1\n    float dWc, x1=(Wx0+.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc + Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB1(vec2 xy) { // Normal to bottom edge of object 1\n    float dWc, x1=(Wx0+.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc - Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\n// Object 2 geometry:\n\nfloat dyTN2(vec2 xy) { // Oriented distance from top edge of object 2\n    if (xy.y<By0) return -777.;\n    return length(xy-vec2(Bx0,By0))-Br;\n}\n\nfloat dyBN2(vec2 xy) { // Oriented distance from bottom edge of object 2\n    if (xy.y>By0) return +777.;\n    return Br-length(xy-vec2(Bx0,By0));\n}\n\nvec2 NormT2(vec2 xy) { // Normal to top edge of object 2\n    float a=atan((xy.y-By0)/(xy.x-Bx0));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB2(vec2 xy) { // Normal to bottom edge of object 2\n    float a=atan((xy.y-By0)/(xy.x-Bx0));\n    return vec2(-sin(a),cos(a));\n}\n\n\n// T-blob packing/unpacking:\n#define B1 14\n#define B2 14\n#define B3 4\nfloat b1=float((1<<B1)), b2=float((1<<B2)), b3=float((1<<B3));\n#define B2f(i) intBitsToFloat(i)\n#define B2i(i) floatBitsToInt(i)\n#define pack(qx,qy,qT) intBitsToFloat( (int(b1*qx)<<(B2+B3)) | (int(b2*qy)<<B3) | int(b3*qT) )\n#define unpack(Q) vec3(float(((Q>>(B2+B3))&((1<<B1)-1)))/b1,float(((Q>>B3)&((1<<B2)-1)))/b2,float(Q&((1<<B3)-1))/b3)\n\n// Hash\nfloat h(float I, float F) {\n    float combined = log(abs(I))/53.432 - log(abs(F))/23.364;\n    combined = fract(sin(combined*8264.2352)*4758.5453);\n    return fract(combined);\n}\n#define pack01 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N11*Dx,(1.+floor(uv.y/Dy))*n11*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N12*Dx,(1.+floor(uv.y/Dy))*n12*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N13*Dx,(1.+floor(uv.y/Dy))*n13*Dy)) )\n#define pack02 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N21*Dx,(1.+floor(uv.y/Dy))*n21*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N22*Dx,(1.+floor(uv.y/Dy))*n22*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N23*Dx,(1.+floor(uv.y/Dy))*n23*Dy)) )\n#define pack03 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N31*Dx,(1.+floor(uv.y/Dy))*n31*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N32*Dx,(1.+floor(uv.y/Dy))*n32*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N33*Dx,(1.+floor(uv.y/Dy))*n33*Dy)) )\n#define pack04 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N41*Dx,(1.+floor(uv.y/Dy))*n41*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N42*Dx,(1.+floor(uv.y/Dy))*n42*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N43*Dx,(1.+floor(uv.y/Dy))*n43*Dy)) )\n\n// Hash parameters (meaningless):\n#define n11 25236.264\n#define n12 46247.964\n#define n13 85446.343\n#define n21 74447.543\n#define n22 89345.434\n#define n23 78446.211\n#define n31 27242.754\n#define n32 93546.123\n#define n33 62147.141\n#define n41 57342.548\n#define n42 17445.547\n#define n43 56781.135\n#define N11 12411.346\n#define N12 76235.373\n#define N13 33743.748\n#define N21 72361.843\n#define N22 26898.834\n#define N23 58133.782\n#define N31 81345.853\n#define N32 82788.286\n#define N33 17457.842\n#define N41 14825.174\n#define N42 45856.723\n#define N43 56823.432\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Initial and boundary conditions.\n// Presently sets up the double-nozzle problem.\n// ____________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x, dy = 1./iResolution.y, AspR=iResolution.y/iResolution.x;\n    vec2 Asp=vec2(1.,AspR);\n\n    Col = texture(iChannel0, uv); // Fetch pixel and neighbors\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));\n\n    float dyB=AspR*dyBN1(uv),  dyT=AspR*dyTN1(uv);\n    float dyB2=AspR*dyBN2(uv), dyT2=AspR*dyTN2(uv);\n      \n    // Boundary conditions\n    if (uv.x<1.1*dx)                       // Left boundary\n        Col = vec4(-abs(AR.x),AR.yzw);     // outflow\n    if (uv.x>1.-1.1*dx)                    // Right boundary\n        Col = vec4(vIn,rho0,P0);           // ambient inflow\n    if (uv.y<1.1*dy)                       // Bottom boundary\n        Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow\n    if (uv.y>1.-1.1*dy)                    // Top boundary\n        Col = vec4(vIn,rho0,P0);           // ambient inflow\n    if (Separatrix) {\n        if ((uv.y>.5-dy) && (uv.y<.5+dy))      // Separatrix\n            Col = vec4(0.,0.,rho0,P0);         // ambient\n        if ((uv.y>.5+dy) && (uv.y<.5+2.1*dy))  // Separatrix top\n            Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow downward\n        if ((uv.y<.5-dy) && (uv.y>.5-2.1*dy))  // Separatrix bottom\n            Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow upwards\n    }\n    if (uv.x > WxL && uv.x < WxR+1.1*dx) { // Wing region\n        if ((dyB>0.) && (dyT<0.))          // inside wing 1\n            Col = vec4(0.,0.,rho0,P0);     // steady ambient\n        else {                             // outside wing 1\n            if ((dyB>0.) && (dyT<1.1*dy))  Col = vec4(AU.xy-NormT1(uv)*Asp*dot(AU.xy,NormT1(uv)*Asp),AU.zw); // slip\n            if ((dyT<0.) && (dyB>-1.1*dy)) Col = vec4(AD.xy-NormB1(uv)*Asp*dot(AD.xy,NormB1(uv)*Asp),AD.zw); // slip\n            if ((uv.x>WxR) && (uv.x<WxR+1.1*dx) && (abs(uv.y-Wy0)<3.1*dy)) //(abs(dyB-dyT)<2.1*dy))\n                Col = vec4(0.,AR.yzw);     // nose slip\n        }\n    }\n    if (uv.x > BxL && uv.x < BxR+1.1*dx) { // Object 2 region\n        if ((dyB2>0.) && (dyT2<0.))        // inside object 2\n            Col = vec4(0.,0.,rho0,P0);     // steady ambient\n        else {                             // outside object 2\n            if ((dyB2>0.) && (dyT2<1.1*dy))  Col = vec4(AU.xy-NormT2(uv)*Asp*dot(AU.xy,NormT2(uv)*Asp),AU.zw); // slip\n            if ((dyT2<0.) && (dyB2>-1.1*dy)) Col = vec4(AD.xy-NormB2(uv)*Asp*dot(AD.xy,NormB2(uv)*Asp),AD.zw); // slip\n            if ((uv.x>BxR) && (uv.x<BxR+1.1*dx) && (abs(uv.y-By0)<3.1*dy)) //(abs(dyB-dyT)<2.1*dy))\n                Col = vec4(0.,AR.yzw);     // nose slip\n        }\n    }\n\n    if (iFrame<1) {  // Initial conditions\n        float rho=rho0, P=P0;\n        vec2 vi=vIn;\n        if ((uv.x>WxL) && (uv.x<WxR) && (dyB>0.) && (dyT<0.)) { // inside wing 1\n            vi = vec2(0.);\n        }\n        if (length(uv-vec2(Bx0,By0))<=Br) { // inside ball\n            vi = vec2(0.);\n        }\n        Col = vec4(vi,rho,P);\n    }\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: 2D ideal fluid solver, by ukeshet.\n// Simplest version: nearest neighbors only, operator splitting, donor-cell advection.\n// ____________________________________________________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float CV = 1./(G-1.);\n    float minV = .01;\n\n    // Grid\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x;\n    float dy = 1./iResolution.y;\n    float dt = CFL*min(dx,dy); // lower CFL (defined in Common line 6) if crash.\n\n    // Fetch pixel and neighbours\n    vec4 A = texture(iChannel0, uv);\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));\n\n    // Edge veclocities\n    float uR = .5*(AR.x+A.x), uL = .5*(AL.x+A.x);\n    float vU = .5*(AU.y+A.y), vD = .5*(AD.y+A.y);\n\n    // Mass flux\n    float frhoR = uR*(step(0.,uR)*A.z + step(uR,0.)*AR.z);\n    float frhoL = uL*(step(0.,uL)*AL.z + step(uL,0.)*A.z);\n    float frhoU = vU*(step(0.,vU)*A.z + step(vU,0.)*AU.z);\n    float frhoD = vD*(step(0.,vD)*AD.z + step(vD,0.)*A.z);\n    float rho2 = A.z - dt*( (frhoR-frhoL)/dx + (frhoU-frhoD)/dy );\n    rho2 = max(minV,rho2);\n\n    // x-momentum flux\n    float fpxR = uR*(step(0.,uR)*A.z*A.x + step(uR,0.)*AR.z*AR.x);\n    float fpxL = uL*(step(0.,uL)*AL.z*AL.x + step(uL,0.)*A.z*A.x);\n    float fpxU = vU*(step(0.,vU)*A.z*A.x + step(vU,0.)*AU.z*AU.x);\n    float fpxD = vD*(step(0.,vD)*AD.z*AD.x + step(vD,0.)*A.z*A.x);\n    float vx2 = ( A.z*A.x - dt*( (fpxR-fpxL)/dx + (fpxU-fpxD)/dy + (AR.w-AL.w)/dx/2. ) )/rho2;\n\n    // y-momentum flux\n    float fpyR = uR*(step(0.,uR)*A.z*A.y + step(uR,0.)*AR.z*AR.y);\n    float fpyL = uL*(step(0.,uL)*AL.z*AL.y + step(uL,0.)*A.z*A.y);\n    float fpyU = vU*(step(0.,vU)*A.z*A.y + step(vU,0.)*AU.z*AU.y);\n    float fpyD = vD*(step(0.,vD)*AD.z*AD.y + step(vD,0.)*A.z*A.y);\n    float vy2 = ( A.z*A.y - dt*( (fpyR-fpyL)/dx + (fpyU-fpyD)/dy + (AU.w-AD.w)/dy/2. ) )/rho2;\n\n    // Total energy*density\n    float erho = CV*A.w+.5*A.z*(A.x*A.x+A.y*A.y);\n    float erhoR = CV*AR.w+.5*AR.z*(AR.x*AR.x+AR.y*AR.y);\n    float erhoL = CV*AL.w+.5*AL.z*(AL.x*AL.x+AL.y*AL.y);\n    float erhoU = CV*AU.w+.5*AU.z*(AU.x*AU.x+AU.y*AU.y);\n    float erhoD = CV*AD.w+.5*AD.z*(AD.x*AD.x+AD.y*AD.y);\n\n    // Energy flux\n    float feR = uR*(step(0.,uR)*erho + step(uR,0.)*erhoR);\n    float feL = uL*(step(0.,uL)*erhoL + step(uL,0.)*erho);\n    float feU = vU*(step(0.,vU)*erho + step(vU,0.)*erhoU);\n    float feD = vD*(step(0.,vD)*erhoD + step(vD,0.)*erho);\n    float erho2 = erho - dt*( (feR-feL)/dx + (feU-feD)/dy +\n                              (AR.w*AR.x-AL.w*AL.x)/dx/2. + (AU.w*AU.y-AD.w*AD.y)/dy/2. );\n\n    // Reconstruct pressure\n    float P2 = (erho2 - .5*rho2*(vx2*vx2+vy2*vy2))/CV;\n    P2 = max(minV,P2);\n\n    Col = vec4(vx2,vy2,rho2,P2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: temperature blob evolution.\n// ______________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x, dy = 1./iResolution.y;\n    float dt = CFL*min(dx,dy);\n    Dx=round(iResolution.x/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    if (iFrame<1) {\n        Col=vec4(pack01,pack02,pack03,pack04);\n    } else {\n        vec4 B=texture(iChannel1, uv);\n        for (int j=0; j<4; j++) {\n            vec2 cell=vec2(Dx*floor(uv.x/Dx),Dy*floor(uv.y/Dy));\n            vec3 q=unpack(B2i(B[j]));\n            float rx=Dx*q.x, ry=Dy*q.y;\n            vec4 A=texture(iChannel0, cell+vec2(rx,ry));\n                rx+=A.x*dt*SU;\n                ry+=A.y*dt*SU;\n            float crossed, qT=q[2];\n            if (abs(crossed=floor(rx/Dx))>0.) { // blob crossed to next cell\n                ry=Dy*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                rx=Dx*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            if (abs(crossed=floor(ry/Dy))>0.) { // blob crossed to next cell\n                rx=Dx*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                ry=Dy*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            Col[j]=pack(fract(rx/Dx),fract(ry/Dy),qT);\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}