{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nbool Flag; // = false;\nint M;\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap(sampler2D sam, in vec3 p, in vec3 n)\n{\n    vec3 m = pow(abs(n), vec3(8.0));\n\tvec4 x = texture(sam, p.yz);\n\tvec4 y = texture(sam, p.zx);\n\tvec4 z = texture(sam, p.xy);\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nfloat dot2(in vec3 v) {return dot(v,v);}\nfloat udTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb)),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc))\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map1(in vec3 p, in float t)\n{   \n    t = t * PI2 + iTime * 6.0;\n    p.y +=  -0.2 * smoothstep(0.15, 0.0, length(abs(p.zx - vec2(0.4,0.0)) - vec2(0.0, 0.4))) * step(0.0, p.y);    \n    p.z += -0.15 * smoothstep( 0.4, 0.3, length(p.yx)) * step(0.0, p.z);\n    p.z +=  0.15 * smoothstep( 0.1, 0.0, length(abs(p.yx) - vec2(0.0, 0.15))) * step(0.0, p.z);\n    p.z +=   0.1 * smoothstep( 0.1, 0.0, length(abs(p.yx - vec2(0.4,0.0)) - vec2(0.0, 0.3))) * step(0.0, p.z);\n    p.z +=  0.15 * smoothstep( 0.1, 0.0, length(p.yx - vec2(0.35,0.0))) * (1.0 - step(0.0, p.z));\n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length((p.zx) - vec2(0.4  + 0.1 * sin(t),      0.4))) * (1.0 - step(0.0, p.y));\n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length((p.zx) - vec2(0.4  + 0.1 * sin(t+1.0), -0.4))) * (1.0 - step(0.0, p.y));\n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length((p.zx) - vec2(-0.4 + 0.1 * sin(t+2.0),  0.4))) * (1.0 - step(0.0, p.y));\n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length((p.zx) - vec2(-0.4+  0.1 * sin(t+3.0), -0.4))) * (1.0 - step(0.0, p.y));\n    p.y += 0.05 * sin(t);\n    return 0.5 * (length(p) - 1.0);\t\n}\n\nfloat map2(in vec3 p)\n{   \n    return udTriangle(vec3(abs(p.x - 0.1), p.yz),\n    \tvec3( 0.7, 0.6, 1.0),\n    \tvec3(-0.1, 0.5, 1.0),\n    \tvec3( 0.4, 0.3, 1.0));\n}\n\nfloat map3(in vec3 p)\n{   \n\treturn dot(p, vec3(0.0, 1.0, 0.0)) + 1.15;\n}\n\nfloat map(in vec3 p)\n{   \n    float s = 5.0;\n    vec3 q = p;\n    vec2 f = floor(q.xz / s);\n    vec4 rand = texture(iChannel1, f * 0.05);\n    q.xz = mod(q.xz, s) - s / 2.0 + sin(rand.xy * PI2 + iTime * 0.3) * 0.5;\n    q.xz *= rotate(-PI / 4.0);\n    float de1 = map1(q, rand.z);\n    float de2 = map2(q);\n    float de3 = map3(p);\n    if (Flag)\n    {\n        if (de1 > de3 && de2 > de3)\n        {\n            M = 3;\n         } else if (de1 < de2){\n            M = 1;\n         } else {\n            M = 2;   \n         }\n    }    \n    return min(min(de1, de2), de3);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for(int i = 0; i < 64; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.02;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 sky(in vec3 p)\n{\n    vec3 col = vec3(0.1, 0.15, 0.6) + 0.3 * pow(max(0.0, 1.0 - 3.0 * p.y), 2.0);\n    float f = boxmap(iChannel2, p * vec3(0.6, 2.0, 0.6), p).x;\n    f = smoothstep(0.3, 1.0, f);\n    return mix(col, vec3(0.9), clamp (f * p.y * 5.0, 0.0, 1.0));      \n}\n\nvec3 material(in vec3 p)\n{\n    Flag = true; map(p); Flag = false;\n    if (M == 1)\n    {\n        vec3 col = boxmap(iChannel1, p * 1.2, p).rgb;\n        return mix(col, vec3(0.7, 0.4, 0.3), 0.8);\n    }\n    if (M == 2) \n    {\n        return vec3(0.03);\n    }\n    if (M == 3) \n    {\n     \tvec3 col = texture(iChannel0, (p.xz * 0.3 + iTime) * rotate(PI / 4.0)).rgb;\n        return mix(col, vec3(0.2, 0.7, 0.3), 0.6);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Flag = false;\n    \n\tvec2 p2d = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ta = vec3(0.5);\n    vec3 ro = vec3(5.0, 1.8, 2.0);\n    float time = mod(iTime, 30.0);\n    ro.xz *= rotate(-0.4 * PI * smoothstep(0.0, 15.0, time));\n    ro.y  += 2.0 * smoothstep(5.0, 20.0, time);\n    ro.xz += 18.0 * step(19.0, time);\n    ro.xz += -25.0 * smoothstep(20.0, 28.0, time);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p2d.x * cu + p2d.y * cv + 2.5 * cw);\n    vec3 lig = normalize(vec3(0.5, 0.8, 3.0));  \n    vec3 col = sky(rd);\n    float t = march(ro, rd);\n    if(t > -0.01)\n    {\n        vec3 p3d = ro + t * rd;\n        vec3 n = calcNormal(p3d);\n\t\tfloat dif = clamp((dot(n, lig) + 0.5) * 0.7, 0.2, 1.0);\n        dif *= clamp(softshadow(p3d, lig), 0.2, 1.0);\n        col = material(p3d) * dif;\n\t\tcol *= exp(-0.0005 * p3d.z * p3d.z);\n        col = pow(col, vec3(0.5));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lllGzS","date":"1423485359","viewed":235,"name":"Pigs running","username":"gaz","description":"3d","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}