{"ver":"0.1","info":{"id":"WlyfDD","date":"1614314717","viewed":72,"name":"Lichen 2","username":"baksej","description":"Lichen","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","life"],"hasliked":0,"parentid":"3tGBD1","parentname":"Lichen"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//\tadded color and initialization to https://www.shadertoy.com/view/lddGWj -- can use the mouse\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://thebookofshaders.com/11/\nfloat rnd (vec2 st) {\n    return fract(sin(dot(st.xy * .01,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rnd(i);\n    float b = rnd(i + vec2(1.0, 0.0));\n    float c = rnd(i + vec2(0.0, 1.0));\n    float d = rnd(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise01(vec2 v) {\n    return snoise(v) * .5 + .5;\n}\n\nfloat warp = .3;\nfloat noise_scale = 3.0;\n\n\n\n\n\nfloat food(vec2 uv) {\n  float nx = snoise(uv * 4. + vec2(0., 50.0)) * warp;\n    float ny = snoise(uv * 4. + vec2(0., 100.0)) * warp;\n    \n    float g = snoise01((uv + vec2(nx, ny)) * noise_scale);\n    return g -.25;\n}\n\n\n\n\nbool hot(vec2 st) {\n    float freq = .2;\n    float f = food(st/iResolution.xy) - .25;\n    return rnd(st + vec2(iTime)) < freq /** f*/;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n            \n    \n\t\n    \n    \n    //float r = rnd(fragCoord *.01+ vec2(iTime, iTime));\n    \n    \n    if (iFrame == 0){\n        float r = rnd(fragCoord + vec2(0, iDate[3])) + rnd(fragCoord + vec2(0, 2));\n       \n\n        fragColor = vec4(r < .002, 0.0, 0.0, 1);\n    }else{\n        vec2 left = fragCoord+vec2(-1,0);\n        vec2 right = fragCoord+vec2(1,0);\n        vec2 above = fragCoord+vec2(0,-1);\n        vec2 below = fragCoord+vec2(0,1);\n        \n        vec4 a = texture(iChannel0, fragCoord/iResolution.xy);\n        vec4 b = vec4(0);\n        \n        \n        float freq = .15;\n        \n        \n        // hot neighbor?\n        if (rnd(fragCoord + vec2(iTime)) < food(fragCoord/iResolution.xy)) {\n            if (hot(left)) {\n                b = texture(iChannel0, left/iResolution.xy);\n            }\n            if (hot(right)) {\n                b = texture(iChannel0, right/iResolution.xy);\n            }\n            if (hot(above)) {\n                b = texture(iChannel0, above/iResolution.xy);\n            }\n            if (hot(below)) {\n                b = texture(iChannel0, below/iResolution.xy);\n            }\n            if (b.r > 0.5 && a.r == 0.0) {\n                a.r = 1.0;\n                a.g = sin(iTime * 6.0) * .5 + .75;\n                a.b = .8;\n            }\n        }\n           \n        // i'm hot?\n        if (hot(fragCoord)) {   \n           a.r -= .01;\n           a.g -= .02;\n           a.b *= .98 - .02*snoise(fragCoord/iResolution.xy * 4. + vec2(0., 100.0));\n           \n        }\n        \n        // maybe don't factor food into hot\n        // just factor it into spread\n        \n        //a.b = food(fragCoord/iResolution.xy);\n        \n        \n        \n        // vec4 right = texture(iChannel0,(fragCoord+vec2( 0, 1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 0,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1, 0))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1, 1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1, 0))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1, 1))/iResolution.xy);\n             \n       // float r = rnd(fragCoord *.01+ vec2(0, 1));\n       // r += rnd(fragCoord *.01+ vec2(0, 2));\n        \n\n        fragColor = clamp(a, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}