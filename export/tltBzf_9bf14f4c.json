{"ver":"0.1","info":{"id":"tltBzf","date":"1707810185","viewed":85,"name":"Fractal growth","username":"wordsonplay","description":"Pseudo-laplacian growth, based on ideas from the paper:\n\nT. Kim, J. Sewall, A. Sud and M. C. Lin, \"Fast Simulation of Laplacian Growth,\" in IEEE Computer Graphics and Applications, vol. 27, no. 2, pp. 68-76, March-April 2007, doi: 10.1109/MCG.2007.33","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","growth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n    if (col.w < 1.) \n    {\n        fragColor = vec4(0);\n    }\n    else\n    {   \n        float hue = atan(col.y, col.x) / TAU + 0.5;\n        \n//        vec3 hsv = vec3(hue,0.5,1);        \n//        vec3 c = hsv2rgb(hsv);\n\n        vec3 c = pal(hue, vec3(0.7,0.5,0.1),vec3(0.3,0.3,0.),vec3(3.0,2.0,1.0),vec3(0.0,2.85,0.) );\n\n        fragColor = vec4(c, 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Noise function by  kinonik\n// https://www.shadertoy.com/view/tlcBRl\n\nfloat noise1(float seed1,float seed2){\n    return(\n        fract(seed1+12.34567*\n        fract(100.*(abs(seed1*0.91)+seed2+94.68)*\n        fract((abs(seed2*0.41)+45.46)*\n        fract((abs(seed2)+757.21)*\n        fract(seed1*0.0171))))));\n}\n\nfloat noise2(float seed1,float seed2,float seed3){\n    float buff1 = abs(seed1+100.81) + 1000.3;\n    float buff2 = abs(seed2+100.45) + 1000.2;\n    float buff3 = abs(noise1(seed1, seed2)+seed3) + 1000.1;\n    buff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.146))));\n    buff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.52))));\n    buff1 = noise1(buff1, buff2);\n    return(buff1);\n}\n\n\n// 3 seeds hard\n\nfloat noise3(float seed1,float seed2,float seed3){\n    float buff1 = abs(seed1+100.813) + 1000.314;\n    float buff2 = abs(seed2+100.453) + 1000.213;\n    float buff3 = abs(noise1(buff2, buff1)+seed3) + 1000.17;\n    buff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.14619))));\n    buff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.5215))));\n    buff1 = noise2(noise1(seed2,buff1), noise1(seed1,buff2), noise1(seed3,buff3));\n    return(buff1);\n}\n\nconst float TAU = 6.283185307179586; \n\n// HSV to RGB\n// https://gist.github.com/983/e170a24ae8eba2cd174f#file-frag-glsl-L14\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// FM palette synthesis by iq\n// https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec2 blur(vec2 uv)\n{\n    vec2 d = 1. / iResolution.xy;\n    \n    vec2 sum = vec2(0.,0.);\n    int k = 0;\n    \n    for (int i = -2; i <= 2; i++) {\n    \n        for (int j = -2; j <= 2; j++) {\n            \n            sum += texture(iChannel0, uv + d * vec2(i,j)).xy;\n            k++;\n        }\n    }\n    \n    sum = sum / float(k);\n\n    return sum;\n}\n\nvec4 init(vec2 uv, vec2 p) \n{\n    float c= step(1.-uv.y, 0.002);\n    return vec4(0,c,0,0);\n}\n\nconst float threshold = 0.99;\nconst float decay = 1.;\n\nvec4 next(vec2 uv, vec2 p) \n{\n    vec4 old = texture(iChannel0, uv);\n    vec4 new = old;\n\n    vec2 v = old.xy;\n    float t = 1. - length(v);    \n    t = 1. - (4. * t * (1.-t));     \n    t = mix(threshold, 1., t);\n    \n    float c = noise3(uv.x*0.000001, uv.y*0.000001, iTime);      \n    \n    if (c > t)\n    {\n        new.a = 1.;\n        vec2 off = vec2(noise1(uv.x, iTime),noise1(uv.y, iTime)) * 2. - vec2(1.,1.);\n        off = off * length(v) * 0.5;\n        new.xy = normalize(v + off);\n    }\n\n    if (new.a < 1.)\n    {\n        new.xy = blur(uv) * decay;    \n    }\n\n    return new;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = fragCoord / iResolution.x;\n\n    if (iFrame == 0 || iMouse.z > 0.) {    \n        fragColor = init(uv, p);\n    }\n    else \n    {\n        fragColor = next(uv, p);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}