{"ver":"0.1","info":{"id":"ltS3W3","date":"1432938505","viewed":953,"name":"KIFS Menger","username":"dom767","description":"A quick replication of a KIFS Menger system I'm working on, just testing out GLSL, based on original code from Kali + Knighty + some ideas from Syntopia","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal","menger","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n\nconst int Iterations=6;\nconst float detail=.005;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\nmat2 rot;\n\nfloat de(vec3 p); \nvec4 getColour(vec3 p);\nvec4 lerp(vec4 col1, vec4 col2, float amt);\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 light(in vec3 p, in vec3 dir,float d)\n{\n\tvec4 lightCol;\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\tvec3 ray = .8*d*((0.4*p-3.*r)+d*vec3(1.0,0.95,0.85));\n//\tlightCol = texture(iChannel0,ray.xz+ray.xy);\n    lightCol = getColour(p);\n\treturn 3.0*lightCol*diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n\t\t}\n\nvec4 raymarch(in vec3 from, in vec3 dir)\n{\n\tfloat st,d=1.0,totdist=st=0.;\n\tvec3 p;\n\tvec4 col;\n    float mind=100.;\n\tfor (int i=0; i<90; i++) \n\t{\n\t\tif (d>detail && totdist<150.)\n\t\t{\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n            mind = min(d, mind);\n\t\t\ttotdist+=d;\n\t\t}\n\t}\n\tvec4 backg=lerp(vec4(1.0,0.9,0.7,1),vec4(0.2,0.4,0.5,1),1.-mind);\n\tif (d<detail) {\n\t\tcol=light(p, dir,d); \n\t} else { \n\t\tcol=backg;\n\t}\n\tcol = col;//mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=iTime*.3;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec3 from=vec3(10.*cos(iTime*0.3),-.7,5.*sin(iTime*0.3));\n    vec3 to = normalize(vec3(0.,0.,0.) - from);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(to, up));\n    up = normalize(cross(right, to));\n    mat3 rot3 = mat3(right.x,right.y,right.z,up.x,up.y,up.z,to.x,to.y,to.z);\n    dir *= rot3;\n\n\tvec4 col=raymarch(from,dir); \n\tfragColor = col;\n}\n\nmat3 MakeRPY(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat de(vec3 p) {\n    vec3 rotAxis = vec3(0,1,0);\n//\tmat3 rot = rotationMatrix3(rotAxis, iTime*5.);\n\tp*=vec3(0.4,0.4,0.4);\n\tvec3 offset = vec3(1,1,1);\n\tfloat scale = 3. + 0.3 * sin(iTime * 0.084);\n    float rotx = 5.0 * sin(iTime * 0.01);\n    float roty = 5.0 * sin(iTime * 0.0057);\n    float rotz = 5.0 * sin(iTime * 0.0266);\n    mat3 rot = MakeRPY(rotx,roty,rotz);\n\n\tfor (int i=0; i<Iterations; i++) {\n        p*=rot;\n\t\tfloat tmp;\n\t\t\n\t\tp = abs(p);\n\t\tif (p.x-p.y<0.) {tmp=p.y;p.y=p.x;p.x=tmp;}\n\t\tif (p.x-p.z<0.) {tmp=p.z;p.z=p.x;p.x=tmp;}\n\t\tif (p.y-p.z<0.) {tmp=p.z;p.z=p.y;p.y=tmp;}\n\n\t\tp.z -= 0.5*offset.z*(scale-1.)/scale;\n\t\tp.z = -abs(-p.z);\n\t\tp.z += 0.5*offset.z*(scale-1.)/scale;\n\n\t\tp.xy = scale*p.xy - offset.xy*(scale-1.);\n\t\tp.z = scale*p.z;\n\t}\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = min(max(d.x, max(d.y, d.z)),0.) + length(vec3(max(d.x,0.),max(d.y,0.), max(d.z,0.)));\n    distance *= pow(scale, -float(Iterations));\n    return distance;\n}\n\nvec4 lerp(vec4 col1, vec4 col2, float amt)\n{\n    amt = clamp(amt,0.,1.);\n    return col1*amt + col2*(1.-amt);\n}\n\nvec4 getColour(vec3 p) {\n\tp*=vec3(0.4,0.4,0.4);\n\tvec3 offset = vec3(1,1,1);\n\tfloat scale = 3. + 0.3 * sin(iTime * 0.084);\n    float rotx = 5.0 * sin(iTime * 0.01);\n    float roty = 5.0 * sin(iTime * 0.0057);\n    float rotz = 5.0 * sin(iTime * 0.0266);\n    mat3 rot = MakeRPY(rotx,roty,rotz);\n\n    float colour=1000000.;\n\n\tfor (int i=0; i<Iterations; i++) {\n        p*=rot;\n\t\tfloat tmp;\n\t\t\n\t\tp = abs(p);\n\t\tif (p.x-p.y<0.) {tmp=p.y;p.y=p.x;p.x=tmp;}\n\t\tif (p.x-p.z<0.) {tmp=p.z;p.z=p.x;p.x=tmp;}\n\t\tif (p.y-p.z<0.) {tmp=p.z;p.z=p.y;p.y=tmp;}\n\n\t\tp.z -= 0.5*offset.z*(scale-1.)/scale;\n\t\tp.z = -abs(-p.z);\n\t\tp.z += 0.5*offset.z*(scale-1.)/scale;\n\n\t\tp.xy = scale*p.xy - offset.xy*(scale-1.);\n\t\tp.z = scale*p.z;\n\n        colour = min(colour, length(p)-0.7);\n    }\n    \n    return lerp(vec4(0.21,0.35,0.66,1.), vec4(0.76,0.65,0.21,1.), colour);\n}","name":"","description":"","type":"image"}]}