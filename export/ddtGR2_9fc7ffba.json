{"ver":"0.1","info":{"id":"ddtGR2","date":"1716530831","viewed":34,"name":"Monte Carlo Isosurface","username":"dev_dwarf","description":"Sampling aint it.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graph","plot"],"hasliked":0,"parentid":"4sB3zz","parentname":"plotting Functions"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define USE_JITTER\n\nprecision highp float;\n\nfloat hash12n(vec2 p);\nvec2 hash22n(vec2 p);\n \n float smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n \n//float function( float x ) {\n /// return sin(x);\n  // return sin(x*x*x)*sin(x) + 0.1*sin(x*x);\n//}\n\nfloat function( vec2 p ) {\n   // return (p.x*p.y - 1.0);\n   //return pow(p.x*p.y - 1.0, 2.0)/ (pow(p.x-1.0, 2.0) + pow(p.y-1.0, 2.0) - 2.0);\n    float r = length(p);\n    float o = atan(p.x,p.y);\n    float flot = floor(iTime);\n    float frat = fract(iTime);\n    \n  \n  //    return pow(p.x*p.x + p.y*p.y - 3.0, 3.0) - p.x*p.x*p.y*p.y*p.y;\n  //  return sin(cos(tan(p.x*p.y))) - sin(cos(tan(p.x))) - sin(cos(tan(p.y)));\n    \n  //  return (p.y - sin(p.x) / p.x) / ( p.y + sin(p.x) / p.x);\n   // return p.y - sin(40.0 / p.x);\n  //  return cos(p.x+p.y) - sin(iTime);\n    \n   // return (min(r*r+(cos(2.0*o)), -r*r+(cos(2.0*o)))) * 5.0*r;\n    \n   // return -( fract(cos(p.x)) - p.y*p.y );\n   // return p.x*p.x + p.y*p.y - 3.0;\n   \n   \n   //  return tan(p.x*p.y) - cos(p.x*p.x + p.y*p.y);\n   // return min(abs(p.x / sin(p.x)) + abs(p.y / sin(p.y)) - abs(p.x*p.y / sin(p.x*p.y)), abs(p.x / sin(p.x)) + abs(p.y / sin(p.y)) + abs(p.x*p.y / sin(p.x*p.y)) );\n  //  return p.y - (p.x*p.x - 3.0*p.x)/(p.x - 3.001);\n    //return p.y - p.x*sin(1.0/(p.x*p.x));\n  //  return p.y-sin(p.x)*sin(p.x*p.x*p.x);\n    return cos(p.y*p.y) - sin(p.x*p.x);\n  //  return sin(p.y) - cos(p.x*p.x);\n   // return sin(p.x*p.x*sin(p.y*p.y));\n   \n   \n    float s = sin(iTime*0.25);\n    float c = cos(iTime*0.25);\n    float x = p.x*c - p.y*s;\n    float y = p.y*c + p.x*s;\n       float po = 1.5 ;// + sin(iTime);\n    return cos(pow(abs(y), po)) - sin(pow(abs(x), po));\n   // return p.y-sin(3.0*p.x);\n}\n\nvec2 gradient( vec2 p) {\n    return vec2(2.0*p.x*sin(dot(p,p)) + p.y*sin(p.x*p.y), 2.0*p.y*sin(dot(p,p)) + p.x*sin(p.x*p.y));\n}\n\nfloat lenlaplacian( vec2 p ) {\n    float r = dot(p,p);\n    return 4.0 * (r * cos(r)) + 4.0 * sin(r) + 2.0 * (r * tan( p.x * p.y) / pow(cos(p.x * p.y), 2.0));\n}\n\n \nvec3 distAvgEval( vec2 uv, vec4 dim )\n{\n    float aspect = iResolution.x / iResolution.y;\n    float scale = 0.5 * (dim.x-dim.y) / iResolution.x;\n    const int samples = 16;\n    const float fsamples = float(samples);\n    vec2 maxdist = 0.1 * (scale) * vec2( aspect, 1.0 );\n    vec2 halfmaxdist = 0.5 * (maxdist);\n        \n    float uv_fx = function( uv );\n    float uv_x = uv.x;\n    \n    float stepsize = maxdist.x / fsamples;\n    float initial_offset_x = -0.5*fsamples * stepsize;\n    //uv.x += initial_offset_x;\n    #if defined( USE_JITTER )\n    uv.x += hash12n(uv+fract(iTime)) * stepsize;\n    #endif\n    float hit = 0.0;\n    vec2 grad = vec2(0.0);\n    vec2 ngrad = vec2(0.0);\n    float dIdx = 0.0;\n    float sumsqr = 0.0;\n    float mean;\n    float absmin = 10000.0;\n    vec2 grad_dir = vec2(0.0,0.0);\n    float grad_len = 0.0;\n    for( int i=0; i<samples; ++i )\n    {\n        //float x = uv.x + stepsize * float(i);\n        //float y = uv.y;\n        //float fx = function( x );\n     \n        //float dist = ( y - fx ); \n        vec2 xstep = vec2(stepsize, 0.0f);\n        vec2 pi = uv + maxdist*(hash22n(uv + float(i)*fract(iTime))-0.5);\n        float dist = function(pi);\n        \n         //float stroke = 1.0f;\n        //vec2 gra = vec2(dFdx(hit), dFdy(hit));\n        //float dfx = length(gra);\n       // float vt = clamp( (dist / dfx), -halfmaxdist.y, halfmaxdist.y);\n        //float vt = 1.0-step(abs(dist/dfx) - halfmaxdist.y, stroke*halfmaxdist.y);\n        float vt = clamp(dist / halfmaxdist.y - 1.0, -1.0, 1.0);\n        float prevmean = mean;\n        mean += dist / fsamples;\n        hit += (vt - hit) / float(i+1);\n        \n     \n        absmin = min(absmin, abs(dist));\n        \n        grad += vec2(dFdx(dist), dFdy(dist)) / fsamples;\n        \n        ngrad += (vec2( (dist - uv_fx) / (pi.x - uv.x), (dist - uv_fx) / (pi.y - uv.y))) / (fsamples);\n        \n        float this_len = (dist - uv_fx) / length(pi - uv);\n        if (this_len > grad_len) {\n            grad_dir = uv - pi;\n            grad_len = this_len;\n        }\n        \n        //if (pi.x != uv.x) {\n            dIdx += ((function( pi ) - uv_fx))/((pi.x - uv.x) * fsamples);\n        //}\n        sumsqr += (dist-mean)*(dist-prevmean);\n    }\n    \n    grad_dir = normalize(grad_dir);\n    \n    float I = abs(hit);\n    float var = abs(sumsqr) / (fsamples);\n    \n    float asdf = fwidth(I);\n    \n    // I - dI t = 0, t < stroke \n    float stroke = 2.0f / maxdist.y;\n    //return step(abs(I/dIdx), stroke);\n    float fill = 1.0 - abs(I/dIdx);\n   \n    //return vec3(clamp(mean*mean - 0.0002*(1.0+var*iResolution.x/dim.x), 0.0, 1.0));\n    \n    // /decent\n   // return vec3(step(mean*mean, 0.0002*(1.0+var*iResolution.x/dim.x)));\n\n      //  return vec3(step(abs(mean), 0.1*(1.0+(var*iResolution.x/dim.x))) , 1.0+var-abs(mean), abs(mean));\n      \n       vec2 exactg = gradient(uv);\n            vec2 exactgd = normalize(exactg);\n            float exactgl = length(exactg);\n            float exactvar = lenlaplacian(uv);\n\n    if (uv.x > 0.5*(dim.x + dim.y)) {\n        if (uv.y > 0.5*(dim.z + dim.w)) {\n        //    return vec3(1.0-exactgl, 0.0, 1.0-exactvar);\n            return vec3((exactgd*0.5 + 0.5), exactvar);\n        } else {\n         //   return vec3(1.0-grad_len, 0.0, 1.0-var);\n            return vec3((grad_dir*0.5 + 0.5), var);\n        }\n        \n      //  return vec3(length(ngrad) - length(grad), length(grad) - length(ngrad), length(ngrad));\n        return vec3(abs(absmin), 1.0 - length(ngrad), 1.0 - length(grad));\n    } else {\n        float stok = 1.0 ;// 3.0 + -2.5*cos(iTime);\n        float nlen = length(ngrad);\n        \n        // why cant do var * grad? why has to be mean / grad?\n       //return vec3(1.5 + (var)*iResolution.x/dim.x - (absmin/));// , normalize(grad) );// , 1.0 - abs(mean) , abs(mean));\n          vec3 v1 = vec3(1.5*grad_len + length(grad)*(var)*iResolution.x/dim.x - abs(absmin) );// , normalize(grad) );// , 1.0 - abs(mean) , abs(mean));\n        float v2 = (stok * (2.0 + var/scale) - abs(mean)/length(grad) );// , normalize(grad) );// , 1.0 - abs(mean) , abs(mean));\n        vec3 v3 = vec3(stok * (2.0 + var/scale) - absmin);\n        float v4 = clamp(stok - mean/length(grad), 0.0, 1.0);\n        \n               // float v5 = (stok * (2.0 + exactvar/scale) - abs(mean)/exactgl );// , normalize(grad) );// , 1.0 - abs(mean) , abs(mean));\n\n        //if (uv.y > 0.5*(dim.z + dim.w)) {\n          //  return 1.0-v5;\n        //} else {\n          //  return v2;\n        //}\n        \n      //  return vec3(v5);\n\n      //  if (true) {\n        if (v2 > v4) {\n           return vec3(1.0, 1.0, 0.969)*v2;\n        } else {\n           return vec3(1.0, 0.0, 0.349)*v4;\n        }\n         \n    }\n    \n //   return vec3(1.0 - I, step(mean, var), asdf);\n //   return vec3(1.0 - I, step(I/asdf, maxdist.y), var);\n  // // return vec3(1.0-I, abs(dIdx), sqrt(var));\n    //return vec3(1.0 - I, step(I - abs(dIdx*maxdist.x), stroke), fill);\n   return vec3(1.0 - I, var, fill);\n    //return vec3(sqrt(var));\n   // return vec3(1.0 - I, abs(dIdx), var);\n   // return length(grad);\n    //return 1.0 - I/length(grad);\n    //return 1.0 - I / fwidth(hit);\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv_norm = fragCoord.xy / iResolution.xy;\n\t//vec4 dim = vec4( 2.0 + 3.0*sin(iTime*0.4), 10.0 - 3.0*sin(iTime*0.4), -3.0, 3.0 );\n    //vec4 dim = vec4( -0.1 - 10.0*(1.0-sin(iTime*0.4)), 0.1 + 10.0*(1.0-sin(iTime*0.4)), -4.0 + 3.0*sin(iTime*0.4), 4.0 - 3.0*sin(iTime*0.4));\n   // vec4 dim = vec4( -0.00000001 - 0.5*(1.0-abs(cos(iTime*0.1))), 0.00000001 + 0.5*(1.0-abs(cos(iTime*0.1))), -4.0 + 3.0*sin(iTime*0.4), 4.0 - 3.0*sin(iTime*0.4));\n\n    // dim.zw = dim.xy;\n   float wind = 5.0;\n    //vec4 dim = vec4(iTime - wind, iTime + wind, -wind, wind);\n    vec4 dim = vec4(-wind, wind, -wind, wind);\n    //dim -= wind;\n    float spect = iResolution.x / iResolution.y;\n    \n  \n    \n    dim.xy *= spect;\n    \n    \n\n\n    vec2 dim_extent = dim.yw - dim.xz;\n\tuv_norm = (uv_norm ) * ( dim_extent ) + dim.xz;\n\n\tvec3 hitDistAvgStoch = distAvgEval( uv_norm - vec2(0,0), dim);\n\t\n\tfragColor = vec4( hitDistAvgStoch, 1.0 );\n}\n\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n//note: uniform pdf rand [0;1[\nvec2 hash22n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4307, p.y * p.x * 97.5901));\n}\n","name":"Image","description":"","type":"image"}]}