{"ver":"0.1","info":{"id":"MsScWy","date":"1493572130","viewed":159,"name":"Planet and moon cody","username":"ocdy1001","description":"ok","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIEW_DIST 20.0\n\nvec3 _moonPos = vec3(0.0, 1.0, 0.0);\n\nfloat shapeSphere(vec3 p, vec3 pos, float r){\n    return length(p - pos)-r;\n}\n\nfloat shapeFloor(vec3 p, float down){\n\treturn p.y + down;\n}\n\nfloat shapeTorus( vec3 p, vec3 pos, vec2 t )\n{\n    p -= pos;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\t\n    return (length(q)-t.y);\n}\n#define SHAPES 4\nvec2 map(vec3 p){\n    vec2 shapes[SHAPES];\n    shapes[0] = vec2(shapeSphere(p, vec3(0.0,1.0,0.0), 2.0), 1.0);//base\n    shapes[1] = vec2(shapeTorus(p, vec3(0.0, 1.0, 0.0), vec2(3.0, 0.07)), 2.0);  //ring2\n    shapes[2] = vec2(shapeTorus(p, vec3(0.0, 1.0, 0.0), vec2(3.7, 0.03)), 2.0);  //ring2\n    shapes[3] = vec2(shapeSphere(p, _moonPos, 0.15), 3.0);//moon\n    \n    float minf = 1000.0;\n    vec2 res = shapes[0];\n    for(int i = 1; i < SHAPES; i++){\n        if(shapes[i].x < res.x){\n            minf = shapes[i].x;\n            res = shapes[i];\n    \t}\n    }\n    return res;\n}\n\nvec2 sunmap(vec3 p, vec3 pos){\n    vec2 s = vec2(shapeSphere(p, pos, 1.0), 1.0);\n    return s;\n}\n\nvec3 calcNormal(vec3 p){\n    vec3 e = vec3(0.001,0.0,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z\t= map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n    for(float t = 0.0; t < VIEW_DIST;){\n    \tvec2 h = map(ro + t*rd);\n        if(h.x < 0.0001) return vec2(t, h.y);\n        t += h.x;\n    }\n    return vec2(0.0);\n}\n\nvec2 sun(vec3 ro, vec3 rd, vec3 sp){\n    for(float t = 0.0; t < 30.0;){\n    \tvec2 h = sunmap(ro + t*rd, sp);\n        if(h.x < 0.0001) return vec2(t, h.y);\n        t += h.x;\n    }\n    return vec2(0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd){\n    float res = 1.0;\n    for(float t = 0.1; t < 8.0;){\n        float h = map(ro + t*rd).x;\n        if(h < 0.001) return 0.0;\n        res = min(res, 8.0*h/t);\n        t += h;\n    }\n    return res;\n}\n\n//noise functions by IQ (changed it a bit)\nfloat hash( float n )\n{\n    return fract(sin(n)*4121.15393);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm( vec3 p, float hardness, float n0, float n1, float n2, float n3, float n4)\n{\n    float f = 0.0;\n\tp = p*hardness;\n    f += n0*noise( p ); p = p*2.02;\n    f += n1*noise( p ); p = p*3.03;\n    f += n2*noise( p ); p = p*3.01;\n    f += n3*noise( p ); p = p*3.05;\n    f += n4*noise( p );\n\n    return f/0.9375;\n}\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //updating    \n    _moonPos.x = sin(iTime * 0.01) * 5.5;\n    _moonPos.z = cos(iTime * 0.01) * 5.5;\n    //rendering\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t//UV\n    uv -= 0.5f;\t\t\t\t\t\t\t\t\t//set origen to be in the middle of the screen\n    uv.x *= iResolution.x / iResolution.y;\t\t//aspect ratio\n    uv *= -1.0;\t\t\t\t\t\t\t\t\t//invert space\n\tvec3 colour = vec3(0.0);\n    \n    //vec3 campos = vec3(0.0,2.0,5.0);\n    //vec3 camdir = normalize(vec3(-1.0 * 2.0*uv, -1.0));\n    float camdist = 8.0;\n    float camspeed = 0.2;\n    float camtime = 0.4*iTime*camspeed;\n    //cam goes in circles around planet\n    vec3 campos = 1.0 * vec3(cos(camtime)*camdist, 0.0, sin(camtime)*camdist);\n    vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - campos);//look at planet\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 camdir = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    vec3 lightpos = normalize(vec3(-1.0,-0.8,0.0));\n    vec3 sunpos = vec3(lightpos.x, 0.0, lightpos.z);\n    vec2 sunint = sun(campos, camdir, sunpos*20.0);\n    if(sunint.y > 0.5){\n        vec3 spos = campos + sunint.x*camdir;\n        colour = dot(calcNormal(spos), sunpos) * vec3(1.0, 1.0, 0.0);\n    }\n    \n    vec2 inter = intersect(campos, camdir);\n    if(inter.y > 0.5){\n        vec3 pos = campos + inter.x*camdir;\n        vec3 nor = calcNormal(pos);\n        \n        //float ambientL = 0.5 + 0.5*nor.y;\n        float diffuseL = max(0.0, dot(nor, lightpos));\n        float shadowL = softShadow(pos, lightpos);       \n\t\tvec3 ambient = vec3(0.0);////there is little to none ambient light in space\n        \n        colour = ambient;\n        \n        if(inter.y == 1.0){//planet\n            colour += diffuseL*1.0;//do not use shadows on this material\n        \tvec3 mixcolour0 = vec3(0.7, 0.3, 0.3);\n            vec3 mixcolour1 = vec3(0.6, 0.7, 0.8);\n            vec3 mixcolour2 = vec3(0.9, 0.1, 0.1);\n            float f = smoothstep( 0.35, 1.0, fbm(pos, 1.0, 0.6, 0.25, 0.125, 0.062, 0.03) );\n    \t\tvec3 mixcolour = mix( mixcolour0, mixcolour1, f );\n            f = smoothstep( 0.0, 1.0, fbm(pos*48.0, 1.0, 0.5, 0.25, 0.125, 0.06, 0.03) );\n    \t\tf = smoothstep( 0.6,1.0,f);\n    \t\tmixcolour = mix( mixcolour, mixcolour2, f*0.5 );\n            colour *= mixcolour;\n        }\n        else if(inter.y == 2.0){//rings\n            colour += diffuseL*shadowL;//use shadows on this material\n        \tvec3 mixcolour0 = vec3(0.4, 0.5, 0.4);\n            vec3 mixcolour1 = vec3(0.1, 0.2, 0.1);\n            float f = smoothstep( 0.4, 1.0, fbm(pos, 1.0, 0.6, 0.25, 0.125, 0.062, 0.03) );\n    \t\tvec3 mixcolour = mix( mixcolour0, mixcolour1, f );\n            colour *= mixcolour;\n        }\n        else if(inter.y == 3.0){//moon\n            colour += diffuseL*shadowL;//use shadows on this material\n        \tvec3 mixcolour0 = vec3(0.6, 0.5, 0.4);\n            vec3 mixcolour1 = vec3(0.5, 0.3, 0.2);\n            float f = smoothstep( 0.0, 1.0, fbm(nor*4.0, 1.0, 0.5, 0.25, 0.125, 0.06, 0.03) );\n    \t\tf = smoothstep( 0.3,1.0,f);\n    \t\tvec3 mixcolour = mix( mixcolour0, mixcolour1, f*2.0 );\n            colour *= mixcolour;\n        }\n    }\n    \n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}