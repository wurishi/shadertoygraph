{"ver":"0.1","info":{"id":"NdGGWV","date":"1632228727","viewed":84,"name":"newbie raymarching example","username":"wlievens","description":"raymarching example","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS = 150;\nconst float SURFACE = 0.001;\nconst float MAXIMUM = 5000.0;\nconst float SHADOW_FACTOR = 0.15;\nconst float BOUNCE_MARGIN = 0.01;\nconst float PI = 3.1415925;\n\nconst float MATERIAL_LIGHT = 5.0;\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(+c, -s, +s, +c);\n}\n\nvec2 minSample(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 maxSample(vec2 a, vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nfloat distanceSphere(vec3 position, vec4 sphere) {\n    return length(position - sphere.xyz) - sphere.a;\n}\n\nfloat distanceBox(vec3 position, vec3 center, vec3 size) {\n    vec3 d = abs(center - position) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat distanceCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opDifference(vec2 a, vec2 b) {\n    return vec2(max(a.x, -b.x), a.y);\n}\n\nvec2 opUnion(vec2 a, vec2 b) {\n    if (a.x <= b.x) {\n        return a;\n    }\n    return b;\n}\n\nvec2 opBlend(vec2 a, vec2 b, float k) {\n    float mat = a.y;\n    float h = clamp(0.5 + 0.5 * (a.x - b.x) / k, 0.0, 1.0);\n    float d = mix(a.x, b.x, h) - k * h * (1.0 - h); \n    return vec2(d, mat);\n}\n\nvec2 sampleScene(vec3 position) {\n    vec4 sphere1 = vec4(0.4, 0.8, 3.0, 0.4);\n    vec4 sphere2 = vec4(-0.5, 0.9, 3.0, 0.4);\n    sphere1.y += sin(iTime) * 0.4;\n    sphere2.x += cos(iTime) * 0.8;\n    sphere2.z += sin(iTime) * 0.8;\n    vec3 box1Center = vec3(-1.0, 1.3, 0.9);\n    vec3 box1Size = vec3(0.2) + cos(iTime) * 0.025;\n    \n    float fx = floor(mod(position.x, 2.0));\n    float fz = floor(mod(position.z, 2.0));\n    vec2 d0 = vec2(position.y, 1.0 + floor(mod(fx + fz, 2.0)));\n    vec2 d1 = vec2(distanceSphere(position, sphere1), 2.0);\n    vec2 d2 = vec2(distanceSphere(position, sphere2), 2.0);\n    vec2 d3 = vec2(distanceBox(position, box1Center, box1Size), 3.0);\n    vec2 d4 = vec2(abs(position.x + 2.0), 3.0);\n    vec3 p = position - vec3(0.0, 1.0, 1.0);\n   \n    vec2 scene = vec2(1e9, 0.0);\n    scene = minSample(scene, d0);\n    scene = minSample(scene, d1);\n    scene = minSample(scene, d2);\n    scene = minSample(scene, d3);\n    scene = minSample(scene, d4);\n    \n    vec4 c = vec4(0.5, 1.0, 1.0, 0.30);\n    float ch = 0.35;\n    int l1 = 10;\n    int l2 = 24;\n    \n    vec2 d5 = vec2(distanceCylinder(c.xyz - position, vec2(c.w, ch)), 4.0);\n    vec2 d6 = vec2(distanceCylinder(c.xyz - position, vec2(c.w * 0.99, ch + 0.01)), 4.0);\n    vec2 d7 = vec2(distanceSphere(position, vec4(c.xyz, c.w * 0.25)), MATERIAL_LIGHT);\n    d5 = opDifference(d5, d6);\n    d5 = opUnion(d5, d7);\n    if (d5.x < 0.01) {\n        for (int i1 = 0; i1 < l1; ++i1) {\n            float r1 = float(i1) / (float(l1) - 1.0);\n            for (int i2 = 0; i2 < l2; ++i2) {\n                float r2 = float(i2) / float(l2);\n                float a = PI * 2.0 * r2;\n                vec4 p = vec4(\n                    c.x + cos(a) * c.w,\n                    c.y - ch + ch * 2.0 * r1,\n                    c.z + sin(a) * c.w,\n                    0.99 * PI * c.w / float(l2)\n                );\n                vec2 d = vec2(distanceSphere(position, p), 1.0);\n                d5 = opDifference(d5, d);\n            }\n        }\n    }\n    scene = minSample(scene, d5);\n    \n    return scene;\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float rayDistance = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        vec3 position = rayOrigin + rayDirection * rayDistance;\n        vec2 scene = sampleScene(position);\n        if (scene.x < SURFACE) {\n            return vec2(rayDistance, scene.y);\n        }\n        if (rayDistance > MAXIMUM) {\n            break;\n        }\n        rayDistance += scene.x;\n    }\n\n    return vec2(MAXIMUM, 0.0);\n}\n\nvec3 estimateNormal(vec3 position)\n{\n    vec3 step = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        sampleScene(position + step.xyy).x - sampleScene(position - step.xyy).x,\n        sampleScene(position + step.yxy).x - sampleScene(position - step.yxy).x,\n        sampleScene(position + step.yyx).x - sampleScene(position - step.yyx).x\n    ));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt; )\n    {\n        vec2 h = sampleScene(ro + rd * t);\n        if( h.x < SURFACE)\n        {\n            return h.y == MATERIAL_LIGHT ? res : 0.0;\n        }\n        if (h.y != MATERIAL_LIGHT)\n        {\n            res = min(res, k * h.x / t);\n        }\n        t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4[] lights = vec4[] (\n        // vec4(2.0, 5.0, -2.0, 30.0),\n        vec4(0.5, 1.0, 1.0, 15.0)\n    );\n    // lights[0].xz += vec2(cos(iTime), sin(iTime)) * 6.0;\n    // lights[1].xz -= vec2(cos(iTime), sin(iTime)) * 4.0;\n\n    vec2 uv = 2.0 * (fragCoord / iResolution.xx) - 1.0;\n\n    vec3 cameraPosition = vec3(0.0, 1.85, -1.45);\n    // cameraPosition.z += cos(iTime) * 1.6;\n    // cameraPosition.z += 1.65;\n    vec3 cameraRay = normalize(vec3(uv, 1.0));\n    \n    vec2 target = rayMarch(cameraPosition, cameraRay);\n    float distance = target.x;\n    vec3 point = cameraPosition + cameraRay * distance;\n    vec3 normal = estimateNormal(point);\n    float material = target.y;\n    \n    float intensity = 0.1;\n    vec3 color;\n    \n    if (material == 0.0) {\n        // Sky\n        color = vec3(0.6, 0.7, 1.0);\n        intensity = 0.4;\n    } else if (material == MATERIAL_LIGHT) {\n        color = vec3(1.0, 1.0, 1.0);\n         intensity = 1.0;\n   } else {\n        if (material == 1.0) {\n            color = vec3(0.8, 0.8, 0.8);\n        }\n        if (material == 2.0) {\n            color = vec3(0.25, 0.3, 0.4);\n        }\n        if (material == 3.0) {\n            color = vec3(0.85, 0.76, 0.65);\n        }\n        if (material == 4.0) {\n            color = vec3(0.75, 0.81, 0.55);\n        }\n        \n        for (int n = 0; n < lights.length(); ++n) {\n            vec4 light = lights[n];\n            vec3 lightToPoint = light.xyz - point;\n            vec3 lightDirection = normalize(lightToPoint);\n            float lightDistance = length(lightToPoint);\n            vec3 start = point + lightDirection * BOUNCE_MARGIN;\n            float factor = shadow(start, lightDirection, 0.0, 10.0, 240.0);\n            float lightIntensity = (0.5+0.1*sin(3.0*iTime))* max(0.0, dot(normal, lightDirection)) * light.a / lightDistance / lightDistance;\n            intensity += lightIntensity * (0.2 + 0.8 * factor);\n        }\n    }\n    intensity = clamp(intensity, 0.0, 1.0);\n    \n    color *= intensity;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}