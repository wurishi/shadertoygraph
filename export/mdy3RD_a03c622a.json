{"ver":"0.1","info":{"id":"mdy3RD","date":"1679640924","viewed":69,"name":"microfacet","username":"zmyyy","description":"microfacet","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["microfacet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n#define pi 3.1415\nvec2 opU(vec2 a, vec2 b){\n    return a.x<b.x?a:b;\n}\n\nvec3 fresnel_term(vec3 F0, float hdotv){\n    vec3 Fresnel_term = F0 + (1.0 - F0) * pow(1.0 - hdotv,5.0);\n    return Fresnel_term;\n}\n\nvec3 ndfGGX(vec3 alpha, float ndoth) {\n    vec3 NDF_div = pow(pow(ndoth, 2.0) * (pow(alpha, vec3(2.0)) - 1.0) + 1.0, vec3(2.0));\n    vec3 ndfGGX_term = pow(alpha,vec3(2.0)) / (pi * NDF_div);\n    return ndfGGX_term;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float NdotL,float roughness) {\n  float alpha = pow(( roughness + 1.0 ) * 0.5, 2.);\n  float k = alpha /2.0;\n  float G1L = NdotV / ( NdotV * (1.0 - k) + k);\n  float G1V = NdotL / ( NdotL * (1.0 - k) + k);\n  float Geometry_term = G1L * G1V;\n  return Geometry_term;\n}\n\n\nmat3 setcamera(vec3 ta, vec3 p, vec3 up){\n    vec3 z = normalize(ta-p);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = normalize(cross(z,x));\n    return mat3(x,y,z);\n}\nfloat sdfrect(vec3 p){\n    \n    vec3 b = vec3(.5,.8,.5);\n    vec3 d = abs(p-vec3(.0,.0,1.0))-b;\n    return length(max(d,0.))+min(0.,max(d.x,max(d.y,d.z)));\n}\nfloat sdfcircle(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdfplane(vec3 p){\n    return p.y;\n}\n\n\n\nfloat sdfsphere(vec3 p){\n    return length(p-vec3(0.,0.3,0.0))-.3;\n}\n\nvec2 map(vec3 p){\n    return opU(vec2(sdfrect(p),2.),opU(vec2(sdfsphere(p),1.),vec2(sdfplane(p),0.)));\n}\n\nfloat calcAO(vec3 p, vec3 n){\n    float res=0.0;\n    float exdecay = .5;\n    float k = 1.0;\n    for(int i =0 ; i<5;i++){\n        float d = 0.01+0.03*float(i);\n        vec3 np = p + d * n;\n        float dis = map(np).x;\n        res += exdecay*(d - dis);\n        exdecay *= .5;\n    }\n    return clamp(1.-k*res,0.,1.);\n}\nvec2 raymarch(vec3 ori, vec3 dir){\n    float t = .1;\n    vec2 res=vec2(-1.);\n    for(int i=0;i<128&&t<20.;i++){\n        vec3 p = ori + t*dir;\n        vec2 d = map(p);\n        if(d.x<0.0001){\n            res.y=d.y;\n            break;\n        }else\n            t+=d.x;\n    }\n    res.x = t;\n    return res;\n}\nvec3 calcNormalsphere(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfsphere(p + k.xyy * h) +\n        k.yyx * sdfsphere(p + k.yyx * h) +\n        k.yxy * sdfsphere(p + k.yxy * h) +\n        k.xxx * sdfsphere(p + k.xxx * h));\n}\nvec3 calcNormalplane(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfplane(p + k.xyy * h) +\n        k.yyx * sdfplane(p + k.yyx * h) +\n        k.yxy * sdfplane(p + k.yxy * h) +\n        k.xxx * sdfplane(p + k.xxx * h));\n}\n\nvec3 calcNormalrect(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfrect(p + k.xyy * h) +\n        k.yyx * sdfrect(p + k.yyx * h) +\n        k.yxy * sdfrect(p + k.yxy * h) +\n        k.xxx * sdfrect(p + k.xxx * h));\n}\nvec3 calcNormal(in vec3 p, float id){\n    if(id>0.9&&id<1.1)\n        return calcNormalsphere(p);\n    else if(id>1.9&&id<2.1)\n        return calcNormalrect(p);\n    else\n        return calcNormalplane(p);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat tri( in float x )\n{\n    float h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nvec3 render(vec2 uv, vec3 camera){\n    mat3 cat = setcamera(vec3(0.,4.,0.),camera,vec3(0.,1.,0.));\n    vec3 color = vec3(.0);\n    vec3 dir = normalize(cat*vec3(uv,1.)-camera);\n    vec2 res = raymarch(camera,dir);\n    float t= res.x;\n    float id = res.y;\n    vec3 light = vec3(0.0, 5., -15.);\n    vec3 light_intensity = vec3(2.);\n    if(t<20.){\n        vec3 p = camera + t * dir;\n        float d = length(light-p);\n        vec3 light_dir = normalize(light-p);\n        float k = 10.0;\n        float vis = softshadow(p,light_dir,.1,20.,k);\n        vec3 n = calcNormal(p,id);\n        vec3 h = normalize(light_dir-dir);\n        vec3 wo = -dir;\n        vec3 wi = light_dir;\n        float hdotv = clamp(dot(h,wi),0.,1.);\n        float ndoth = clamp(dot(n,h),0.,1.);\n        float ndotv = clamp(dot(n,wo),0.,1.);\n        float ndotl = clamp(dot(n,wi),0.,1.);\n        if(id>0.1){\n            vec3 f0 = vec3(1.);\n            vec3 f = fresnel_term(f0,hdotv);\n            float a1 = .1;\n            float a2 = .1;\n            float g = GeometrySchlickGGX(ndotv,ndotl,a1);\n            vec3 d = ndfGGX(vec3(a2),ndoth);\n            color =  vis*g * f  * d * light_intensity /(4.*dot(n,wi)*dot(n,wo));\n            \n        }else{\n            vec2 grid = floor(4.*p.xz);\n            //float ka = 0.005, kd = 0.23 + .2 * mod(grid.x+grid.y,2.), ks =0.;\n            \n            vec3 f0 = vec3(0.23 + .2 * mod(grid.x+grid.y,2.));\n            vec3 f = fresnel_term(f0,hdotv);\n            float a = 1.;\n                \n            float g = GeometrySchlickGGX(ndotv,ndotl,a);\n            vec3 d = ndfGGX(vec3(a),ndoth);\n            color =  vis*g * f  * d * light_intensity /(4.*dot(n,wi)*dot(n,wo));\n        }\n        //float ao = calcAO(p,n);\n        //color *= ao; \n        \n    }\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // Time varying pixel color\n    /*\n    float d = sdfcircle(uv,.7);\n    vec3 col= 1.-sign(d)*vec3(.5,.5,.5);\n    col *= 1.0 - exp(-3.0*abs(d));\n    col *= 0.8 + 0.2*sin(150.0 *abs(d));\n    */\n    // Output to screen\n    vec3 col = vec3(.0);\n    for(int i=0;i<AA;i++){\n        for(int j=0;j<AA;j++){\n            vec2 offset= 2.*(vec2(float(i),float(j))/float(AA)-.5);\n            vec2 uv = ((fragCoord+offset)/iResolution.xy-0.5)*2.0;\n            col += render(uv,vec3(5.*sin(0.2*iTime),2.0,5.*cos(.2*iTime)));\n            //col += render(uv,vec3(-5.,2.,-5.));\n        }\n    }\n  \n    fragColor = vec4(col/float(AA*AA),1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\n}","name":"Image","description":"","type":"image"}]}