{"ver":"0.1","info":{"id":"3stBDr","date":"1604857674","viewed":338,"name":"GEHENNA","username":"kesson","description":"GEHENNA\n-\nTribute to Doom Eternal","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","tunnel","rays","marching","doom","generative","bloom","depth","lights","walking","gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* --- GEHENNA --- */\n\n// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAYMARCH_MAX_STEPS 100\n#define RAYMARCH_MAX_DIST 100.\n#define RAYMARCH_SURFACE_DIST .001\n#define SPEED 1.0\n#define ROTSPEED 0.25\n#define CAMDIST 4.0\n#define color vec3(1.0, 0.2, 0.2)//vec3(0.1, 1.0, 0.4)\n#define time mod(iTime, 60.0)\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n#define QUARTER_PI 0.78539816339\n\nvec3 randomVector(vec3 p) {\n\tvec3 a = fract(p.xyz*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    vec3 v = fract(vec3(a.x*a.y, a.y*a.z, a.z*a.x));\n    return v;\n}\n\nvec3 lightPos1 = vec3(0.0, 0.0, 2.9457);\nvec3 lightPos2 = vec3(0.0, 0.0, 4.8569);\nvec3 lightPos3 = vec3(0.0, 0.0, 6.7142);\nfloat light1 = 0.0;\nfloat light2 = 0.0;\nfloat light3 = 0.0;\n\nvec3 lightPosGlobal = vec3(0.0, 0.0, 30.0);\nfloat lightGlobal = 0.0;\n\nfloat cameraMovement = 0.0;\n\nfloat beamsShine = 0.0;\nfloat tmpo = 0.0;\n\nmat2 rotate(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// This creates repetitions of something along the way\nvec3 repeat(vec3 p, vec3 s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\nfloat repeat(float p, float s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n  \tfloat dd = (p.z * 0.01) ;\n\tdd = floor(dd*1.0) + smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, fract(dd*1.0)));\n    dd *= 20.1;\n    dd += time*0.1;\n\t\t// dd *= 0.1;\n  \toff.x += sin(dd) * 6.0;\n  \toff.y = sin(dd * 0.7) * 6.0;\n  \treturn off;\n}\n\nvec3 navigate(vec3 p) {\n  p += tunnel(p);\n  p.xy *= rotate((p.z * ROTSPEED) + (time*ROTSPEED));\n  p.y -= 0.3;\n  return p;\n}\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat SDG(vec3 p, float scale, float thickness, float bias, float lx, float ly) {\n  vec3 p2 = p;\n  p2 *= scale;\n  float ls = max(lx, ly)*1.6;\n  float gyroid = abs(dot(sin(p2*lx), cos(p2.zxy*ly))-bias) / (scale*ls) - thickness;\n  return gyroid;\n}\n\nfloat smin(float a, float b, float h) {\n\tfloat k = clamp((a-b) / h * 0.5 + 0.5, 0.0, 1.0);\n\treturn mix(a, b, k) - k * (1.0 - k) * h;\n}\n\nfloat getDist(vec3 p) {\n    vec3 p2 = p;\n    p2 = navigate(p2);\n\n    float box = sdBox(p2, vec3(0.0));\n\n    float lz = fract((p.z/100.0) * 0.02);\n    float t = time*0.5;\n    float lx = 1.25 + ((sin((lz+t) * 0.2576) * 0.5) + 0.5) * 0.25;\n    float ly = 1.25 + ((cos((lz+t) * 0.1987) * 0.5) + 0.5) * 0.25;\n\n    float g1 = SDG(p2, 0.543, 0.1, 1.4, lx, ly);\n\n    float g2 = SDG(p2, 10.756, 0.03, 0.3, 1.0, 2.0);\n    float g3 = SDG(p2, 20.765, 0.03, 0.3, 1.0, 1.0);\n    float g4 = SDG(p2, 40.765, 0.03, 0.3, 1.0, 1.0);\n    float g5 = SDG(p2, 60.765, 0.03, 0.3, 1.0, 1.0);\n    float g6 = SDG(p2, 120.765, 0.03, 0.3, 1.0, 1.0);\n\n    g1 -= g2*0.4;\n    g1 -= g3*0.3;\n    g1 -= g4*0.2;\n    g1 -= g5*0.2;\n    g1 += g6*0.1;\n\n    float d = g1*0.6;//max(box, g1*0.4);\n\t\n    // light bulbs\n \tfloat dl1 = length(lightPos1 - p) - 0.1;\n\tlight1 += 0.02/(0.01+dl1);\n\td = smin(d, dl1, 0.5*2.0);\n \tfloat dl2 = length(lightPos2 - p) - 0.1;\n\tlight2 += 0.02/(0.01+dl2);\n\td = smin(d, dl2, 0.5*2.0);\n \tfloat dl3 = length(lightPos3 - p) - 0.1;\n\tlight3 += 0.02/(0.01+dl3);\n\td = smin(d, dl3, 0.5*2.0);\n\n\t// Beams\n\tvec3 p4 = p2;\n\tp4.xy *= rotate(p4.z * 0.05);\n\tp4.z = repeat(p4.z, 10.0);\n\tp4.x += sin(p4.y*0.3 + p2.z * 0.08 + time * 0.5) * 2.0;\n\tfloat beams = sdCylinder(p4.xz, 0.5);\n\ttmpo = beams;\n\tbeams -= g2*0.4;\n\tbeams -= g3*0.3;\n    beams -= g4*0.2;\n    beams -= g5*0.2;\n    beams += g6*0.1;\n\tbeams *= 0.8;\n\td = smin(d, beams, 1.0);\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = RAYMARCH_SURFACE_DIST;\n\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n\t\t\tvec3 p = ro + rd * dO;\n      float dS = getDist(p);\n      dO += dS;\n      if (dO > RAYMARCH_MAX_DIST || dS < RAYMARCH_SURFACE_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 farColor(vec3 rd) {\n  vec3 col = vec3(0.0);\n  float y = rd.y * 0.5 + 0.5;\n  return color * 0.1;\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float dif = dot(n, l);\n\n    return dif;\n}\n\nvec3 calcLight(vec3 lp) {\n  vec3 lp2 = randomVector(lp);\n  float lpr = lightPos2.z;\n  float lpRotation = lp2.z + time * 0.5;\n  lp2.x = sin(lpRotation);\n  lp2.y = cos(lpRotation);\n  lp2.z = -CAMDIST+2.0 + (sin((lpr + time)*0.25) * 0.5 + 0.5) * 4.0;\n  lp2.z += cameraMovement;\n  lp2 -= tunnel(lp2);\n  return lp2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (gl_FragCoord.xy-.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n\n    //\n\n\n    // camera\n    float t = time * SPEED;\n    cameraMovement = t;\n    vec3 ro = vec3(0.0, 0.0, -CAMDIST);\n    ro.z += cameraMovement;\n    ro -= tunnel(ro);\n    vec3 ta = vec3(0.0);\n    ta.z += cameraMovement;\n    ta -= tunnel(ta);\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    float fov = 1.0;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + ww * fov);\n    \n    \n    //\n    \n\n    // lights \n    float lightRotation = time * 0.5;\n    lightPos1.x = sin(lightRotation);\n    lightPos1.y = cos(lightRotation);\n    lightPos1.z = -CAMDIST+2.0 + (sin(time*0.25) * 0.5 + 0.5) * 8.0;\n    lightPos1.z += cameraMovement;\n    lightPos1 -= tunnel(lightPos1);\n\n    lightPos2 = calcLight(lightPos2);\n    lightPos3 = calcLight(lightPos3);\n\n    float d = rayMarch(ro, rd);\n\n    if(d<RAYMARCH_MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n\n        // calc lights\n        float dif1 = clamp(getLight(p, lightPos1), 0.0, 1.0);\n        col = vec3(dif1)*normalize(pow(color, vec3(0.585)));\n        float dif2 = clamp(getLight(p, lightPos2), 0.0, 1.0);\n        col = vec3(dif2)*normalize(pow(color, vec3(0.585)));\n        float dif3 = clamp(getLight(p, lightPos3), 0.0, 1.0);\n        col = vec3(dif3)*normalize(pow(color, vec3(0.585)));\n\n        p = navigate(p);\n\n        float g2 = SDG(p, 10.756, 0.03, 0.3, 1.0, 1.0);\n        col *= smoothstep(-0.1, 0.06, g2);\n\n        float cw = -0.04 + smoothstep(0.0, -0.5, n.y) * 0.08;\n        float sh = smoothstep(cw, -0.03, g2);\n\n        float pz = pow(p.z, 10.0/p.z);\n        float g3 = SDG(p, 5.756, 0.03, 0.0, 1.0, 1.0);\n        float g4 = SDG(p, 4.756, 0.03, 0.0, 1.0, 1.0);\n\n        sh *= g3 * g4 * 0.8 + 0.2 * smoothstep(0.2, 0.0, n.y);\n\n        col += sh * normalize(pow(color, vec3(0.5)))*20.0;\n\n    }\n\n    float mindist = 3.0;\n    float maxdist = 8.0;\n    col = mix(col, farColor(rd), smoothstep(mindist, maxdist, d));\n\n    vec3 l1 = light1 * color*0.2;\n    col += l1;\n    //\n    vec3 l2 = light2 * color*0.2;\n    col += l2;\n    //\n    vec3 l3 = light3* color*0.2;\n    col += l3;\n\n\n    col = 1.0 - exp(-col * 3.0);\n    col = pow(col, vec3(1.6));\n\n\n    fragColor = vec4(col, d);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\nprecision mediump float;\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2  uv = fragCoord.xy / iResolution.xy;\n\n    vec3  c = texture(iChannel0, uv).rgb;\n\n    vec2  center = vec2(0.5, 0.5);\n    center = vec2(0.5, 0.5);\n\n    float  d = smoothstep(0.3, 1.0, 0.1 + distance(center, uv));\n\n    //  grain  effect\n    float  strength = 8.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 9;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  Z = 0.0;\n    float sigma = 0.1 + texture(iChannel0, uv).a * 7.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n        }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    float  nd = 1.0 - d;\n    vec3 c_step_2 = clamp(c_step_1 * nd, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 1.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}