{"ver":"0.1","info":{"id":"fdSyRh","date":"1643246473","viewed":270,"name":"Single-stroke digit \"font\"","username":"stegu","description":"A purely procedural \"font\": a set of reasonably simple distance field functions to produce outlines for the decimal digits 0-9 and the symbols + - = . : \nThe shapes are built from line segments and circular arcs.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["procedural","text","distance","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// This is not an artistic creation. It's just a demo and\n// placeholder for the character shapes. (In the \"Common\" tab.)\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Each character needs ~6x10 units (depending on line width)\n    vec2 uv = -3.0 + 73.0*fragCoord/max(iResolution.x, iResolution.y);\n    \n    float n0 = nixie0(uv);\n\n    float n1 = nixie1(uv - vec2(7.0, 0.0));\n    float n1a = nixie1alt(uv - vec2(7.0, 12.0));\n\n    float n2 = nixie2(uv - vec2(14.0, 0.0));\n    float n2a = nixie2alt(uv - vec2(14.0, 12.0));\n    \n    float n3 = nixie3(uv - vec2(21.0, 0.0));\n    float n3a = nixie3alt(uv - vec2(21.0, 12.0));\n\n    float n4 = nixie4(uv - vec2(27.5, 0.0));\n    float n4a = nixie4alt(uv - vec2(27.5, 12.0));\n    \n    float n5 = nixie5(uv - vec2(35.0, 0.0));\n    float n5a = nixie5alt(uv - vec2(35.0, 12.0));\n    \n    float n6 = nixie6(uv - vec2(42.0, 0.0));\n    float n6a = nixie6alt(uv - vec2(42.0, 12.0));\n\n    float n7 = nixie7(uv - vec2(49.0, 0.0));\n    float n7a = nixie7alt(uv - vec2(49.0, 12.0));\n\n    float n8 = nixie8(uv - vec2(56.0, 0.0));\n    float n8a = nixie8alt(uv - vec2(56.0, 12.0));\n\n    float n9 = nixie9(uv - vec2(63.0, 0.0));\n    float n9a = nixie9alt(uv - vec2(63.0, 12.0));\n    \n    // Throw the lot together in one large distance field\n    float n = min(min(n0, n1), min(n1a, n2));\n    n = min(min(n, n2a), min(n3, n3a));\n    n = min(min(n, n4), min(n4a, n5));\n    n = min(min(n, n6), min(n6a, n7));\n    n = min(min(n, n7a), min(n8, n8a));\n    n = min(min(n, n9), min(n5a, n9a));\n\n    // Add the punctuation characters to the party\n    float m = min(min(nixieplus(uv -vec2(0.0, 24.0)),\n                      nixieminus(uv - vec2(7.0, 24.0))),\n              min(nixiedot(uv - vec2(21.0, 24.0)),\n                      nixiecolon(uv - vec2(28.0, 24.0))));\n    m = min(m, nixieequals(uv-vec2(14.0,24.0)));\n\n    n = min(n, m);\n\n    // Show some weight variations at the top right\n\n    n = min(min(n, nixie3(uv-vec2(42.0, 24.0))-0.2),\n                min(nixie3(uv-vec2(49.0, 24.0))-0.4,\n                    nixie3(uv-vec2(56.0, 24.0))-0.6));\n\n    // Threshold the distance field and paint the glyphs\n    float w = 0.25; // Strokes become twice this wide in uv space\n    vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(0.0), aastep(w, n));\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Compute the shortest distance from p to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r.\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// Compute the shortest distance from p to a\n// circular arc with center c from p1 to p2.\n// p1, p2 are in the +angle direction (ccw),\n// to resolve the major/minor arc ambiguity, so\n// specifying p1, p2 in the wrong order will\n// yield the complement to the arc you wanted.\n// If p1 = p2, the entire circle is drawn, but\n// you don't want to use this function to draw\n// a circle. Use the simple circled() instead.\n// If p1 and p2 have different distances to the\n// c, the end of the arc will be cut off and\n// there will be a disconnected half-circle at p2.\n// To avoid this, uncomment the rescaling of v2.\nfloat arcd(vec2 c, vec2 p1, vec2 p2, vec2 p) {\n\n    vec2 v1 = p1 - c;\n    vec2 v2 = p2 - c;\n    // v2 = normalize(v2)*length(v1); // Use angle only of p2\n    vec2 v = p - c;\n\n    vec2 w = vec2(dot(v, -vec2(-v1.y, v1.x)), dot(v, vec2(-v2.y, v2.x)));\n\n    if(dot(v1, vec2(-v2.y, v2.x)) >= 0.0) { // Arc angle <= pi\n        if(all(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    } else { // Arc angle > pi\n        if(any(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    }\n}\n\n// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// The digits. Simple functions, only a lot of them.\n\n// These glyphs and their implementation as distance fields\n// are the original work of me (stefan.gustavson@gmail.com),\n// and the code below is released under the MIT license:\n// https://opensource.org/licenses/MIT\n// (If that is inconvenient for you, let me know. I'm reasonable.)\n//\n// Experts say mortals should not attempt to design character shapes.\n// \"It's just ten simple digits\", I thought, \"How hard can it be?\"\n// A week later, after countless little tweaks to proportions and\n// curvature, and with a notepad full of sketches and pen-and-paper\n// math, some of it horribly wrong because it was decades since I\n// solved this kind of equations by hand, I know the answer:\n// It can be *really* hard. But also loads of fun!\n//\nfloat nixie0(vec2 p) {\n    // Special hack instead of pasting together arcs and lines\n    float d = lined(vec2(2.0), vec2(2.0, 6.0), p);\n    return abs(d - 2.0);\n}\n\nfloat nixie1(vec2 p) {\n    float d1 = lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n    float d2 = lined(vec2(2.0, 8.0), vec2(1.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie1alt(vec2 p) { // Straight line\n    return lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n}\n\nfloat nixie2(vec2 p) {\n    const float x = 3.2368345; // Icky coordinates,\n    const float y = 4.4283002; // used twice below\n    float d1 = lined(vec2(4.25, 0.0), vec2(-0.25, 0.0), p);\n    float d2 = arcd(vec2(10.657842, -5.001899), // Also icky\n                    vec2(x, y), vec2(-0.25, 0.0), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(x, y), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie2alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(4.0, 0.0), vec2(0.0), p);\n    float d2 = lined(vec2(0.0), vec2(3.6, 4.8), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(3.6, 4.8), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3(vec2 p) {\n    // Two round parts:\n    // float d1 = arcd(vec2(2.0, 2.1), vec2(-0.1, 2.1), vec2(2.0, 4.2), p);\n    // float d2 = arcd(vec2(2.0, 6.1), vec2(2.0, 4.2), vec2(0.1, 6.1), p);\n    // Angled top, more like classic Nixie tube digits:\n    float d1 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    float d2 = lined(vec2(2.0, 4.5), vec2(4.0, 7.75), p);\n    float d3 = lined(vec2(4.0, 7.75), vec2(0.0, 7.75), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3alt(vec2 p) { // Same size loops\n    float d1 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(2.0, 4.0), p);\n    float d2 = arcd(vec2(2.0, 6.0), vec2(2.0, 4.0), vec2(0.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie4(vec2 p) {\n    // This digit is 5.0 units wide, most others are 4.0 or 4.5\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(5.0, 2.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie4alt(vec2 p) {\n    // This digit is 4.0 units wide, but looks cropped\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie5(vec2 p) {\n    float d1 = lined(vec2(4.0, 7.75), vec2(0.5, 7.75), p);\n    float d2 = lined(vec2(0.5, 7.75), vec2(0.0, 4.5), p);\n    float d3 = lined(vec2(0.0, 4.5), vec2(2.0, 4.5), p);\n    float d4 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    return min(min(d1, d2), min(d3, d4));\n}\n\nfloat nixie5alt(vec2 p) {\n    float d1 = lined(vec2(4.0, 8.0), vec2(0.0, 8.0), p);\n    float d2 = lined(vec2(0.0, 8.0), vec2(0.0, 5.0), p);\n    float d3 = lined(vec2(0.0, 5.0), vec2(2.0, 5.0), p);\n    float d4 = arcd(vec2(2.0, 3.0), vec2(4.0, 3.0), vec2(2.0, 5.0), p);\n    float d5 = lined(vec2(4.0, 3.0), vec2(4.0, 2.0), p);\n    float d6 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(min(d1, d2), min(d3, d4)), min(d5, d6));\n}\n\nfloat nixie6(vec2 p) {\n    float d1 = arcd(vec2(84.0/13.0, 2.25), vec2(3.0, 8.0), vec2(-0.25, 2.25), p);\n    float d2 = circled(vec2(2.0, 2.25), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie6alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.4, 3.2), vec2(3.0, 8.0), p);\n    float d2 = circled(vec2(2.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie7(vec2 p) { // Ugly coordinates, but these expressions are exact\n    float d1 = lined(vec2(0.0, 7.75), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d2 = arcd(vec2(-8.0, 12.0), vec2(2.5, 5.0), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d3 = arcd(vec2(10.0, 0.0), vec2(2.5, 5.0), vec2(10.0-2.5*sqrt(13.0), 0.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie7alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.0, 8.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(1.0, 0.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie8(vec2 p) {\n    float d1 = circled(vec2(2.0, 2.2), 2.2, p);\n    float d2 = circled(vec2(2.0, 6.2), 1.8, p);\n    return min(d1, d2);\n}\n\nfloat nixie8alt(vec2 p) { // Same size loops\n    float d1 = circled(vec2(2.0), 2.0, p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie9(vec2 p) {\n    float d1 = arcd(vec2(-32.0/13.0, 5.75), vec2(1.0, 0.0), vec2(4.25, 5.75), p);\n    float d2 = circled(vec2(2.0, 5.75), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie9alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(3.6, 4.8), vec2(1.0, 0.0), p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixieminus(vec2 p) {\n    return lined(vec2(0.5, 4.0), vec2(3.5, 4.0), p);\n}\n\nfloat nixieequals(vec2 p) {\n    float d1 = lined(vec2(0.5, 3.0), vec2(3.5, 3.0), p);\n    float d2 = lined(vec2(0.5, 5.0), vec2(3.5, 5.0), p);\n    return min(d1, d2);\n}\n\nfloat nixieplus(vec2 p) {\n    float d1 = lined(vec2(0.0, 4.0), vec2(4.0, 4.0), p);\n    float d2 = lined(vec2(2.0, 2.0), vec2(2.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixiedot(vec2 p) {\n    // circled with r=0 yields a point, but with more work\n    return length(p - vec2(2.0, 0.0));\n}\n\nfloat nixiecolon(vec2 p) {\n    float d1 = length(p - vec2(2.0));\n    float d2 = length(p - vec2(2.0, 5.0));\n    return min(d1, d2);\n}\n\n// End of MIT-licensed code\n","name":"Common","description":"","type":"common"}]}