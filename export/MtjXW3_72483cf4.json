{"ver":"0.1","info":{"id":"MtjXW3","date":"1447185429","viewed":377,"name":"BinaryTree3d","username":"jt","description":"(double) binary tree/quaternary tree as ray-traced closed-form expression implicit surface.\nNO recursion, NO iteration - using only fract,exp2,ceil,log2 for branching.\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","implicitsurface","binarytree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Double Binary Tree/Quaternary Tree as Ray-Traced Implicit Surface - written 2015-11-10 by Jakob Thomsen\n// Closed-form expression Implicit Surface Tree - NO recursion/iteration, using only fract,exp2,ceil,log2 for branching.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n// NOTE: the name was choosen to avoid confusion with the quad-tree data-structure.\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nvec2 mirror2(vec2 v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nvec3 BinarySubDiv(vec3 v )\n{\n    v = fract(exp2(ceil(-log2(v.z))) * v * vec3(.5, .5, 1.));\n    v.xy = mirror2(2. * v.xy);\n    return v;\n}\n\nfloat fn(vec3 v)\n{\n    v.z *= -1.0;\n    v = 0.5 * v + 0.5;\n    vec3 p = vec3(0.5, .5, 0.);\n    vec3 n = vec3(1.0, 1.0, 1.) - p;\n    v = BinarySubDiv(v);\n    v.xy = mirror2(v.xy);\n    return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01;\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * ceil(-log2(1.0-v.z));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(1.0-v.z)));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(v.z)));\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec3 c = 0.5 + 0.5 * nrm(v);\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    //v.x = uv.x * cos(t) + uv.y * sin(t);\n    //v.y = uv.x * -sin(t) + uv.y * cos(t);\n    //v.z = depth;\n    \n    // isometry\n    vec3 iso;\n//    iso.x =  v.x - v.y - v.z;\n//    iso.y = -v.x - v.y - v.z;\n//    iso.z =        v.y - v.z;\n\n//    return iso;\n    iso.x =  uv.x - uv.y - depth;\n    iso.y = -uv.x - uv.y - depth;\n    iso.z =         uv.y - depth;\n\n    v.x = iso.x * cos(t) + iso.y * sin(t);\n    v.y = iso.x * -sin(t) + iso.y * cos(t);\n    v.z = iso.z;\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;//128;\n    float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.05)\n        {\n            //m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n","name":"","description":"","type":"image"}]}