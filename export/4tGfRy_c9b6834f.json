{"ver":"0.1","info":{"id":"4tGfRy","date":"1542877212","viewed":176,"name":"光线追踪RayTrace","username":"lingel","description":"实时反射光线追踪","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author:3977270@qq.com\n//使用左手坐标系，右边x,上边y，前方z\n\n/////////////////////////////////////////////////////////////////////\n//////////// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\n//随机\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n/////////////////////////////////////////////////////////////////////////////\n////////////////////////////////矩阵\n//矩阵\nmat4 identMat=mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.0,0.0,1.0\n);\n//X轴旋转\nmat4 rotatX(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    1.0,    0.0,        0.0,        0.0,\n    0.0,    cos(rs),    -sin(rs),   0.0,\n    0.0,    sin(rs),    cos(rs),    0.0,\n    0.0,    0.0,        0.0,        1.0\n);\nreturn transpose(temp);\n}\n//Y轴旋转\nmat4 rotatY(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    cos(rs),    0.0,    sin(rs),   0.0, \n    0.0,        1.0,    0.0,       0.0, \n    -sin(rs),   0.0,   cos(rs),    0.0, \n    0.0,        0.0,    0.0,       1.0  \n);\nreturn transpose(temp);\n}\n\n//Z轴旋转\nmat4 rotatZ(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    cos(rs),    -sin(rs),   0.0,    0.0,\n    sin(rs),    cos(rs),    0.0,    0.0,\n    0.0,        0.0,        1.0,    0.0,\n    0.0,        0.0,        0.0,    1.0\n);\nreturn transpose(temp);\n}\n//三轴旋转\nmat4 rotat(vec3 r)\n{\nreturn rotatX(r.x)*rotatY(r.y)*rotatZ(r.z);\n//return rotatZ(r.z)*rotatY(r.y)*rotatX(r.x);\n}\n//位移矩阵\nmat4 translate(vec3 v)\n{\n    mat4 temp=identMat;\n    temp[3][0]=v.x;\n    temp[3][1]=v.y;\n    temp[3][2]=v.z;\n    return temp;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//射线\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n//材质\nstruct Material\n{\n    vec4 BaseColor;\n};\n//检测结果\nstruct HitResult\n{\n    float t;\n    vec3 worldNormal;\n    Material material;\n};\n\n//球体检测函数\nstruct Sphere\n{\n    float radius;\n    vec3 center;\n    Material material;\n};\n//相机\nstruct Camera\n{\nfloat FOV;\nfloat focusDistance;\n};\n//球体射线检测\nbool trace(in Ray r,in Sphere sp,out HitResult res){\n    //射线原点到球心向量\n    vec3 oc=sp.center-r.origin;\n    //将原点到球心向量投影到射线方向求长度\n    float l=dot(r.direction,oc);\n    //射线原点到球心的平方距离\n    float d=dot(oc,oc);\n    //两个直角三角形平方差。其值为一条直角边的平方\n    float det=pow(sp.radius,2.0)-(d-pow(l,2.0));//平方差\n    if(det<0.0) return false;//无解\n    res.t=l-sqrt(det);//最近点长度\n    if (res.t<0.0) res.t=l+sqrt(det);//最近点在相反方向\n    if(res.t<0.0) return false;\n    //满足条件，填充检测结果\n    res.worldNormal=normalize(r.origin+r.direction*res.t-sp.center);\n    res.material=sp.material;\n    return true;\n}\n//建立场景\nconst int count=5;\nSphere sps[5];\nCamera ca=Camera(60.0,1.0);\nvec3 cameraLocation;\nvec3 cameraRotation;\nvoid createSence(){\n    //4个球体\n    sps[0]=Sphere(3.f,vec3(0.0-sin(iTime)*20.0,3.0,-5.0),Material(vec4(1.0,0.1,0.1,1.0)));//红球\n    sps[1]=Sphere(3.f,vec3(5.0,3.0+sin(iTime)*10.0+10.0,0.0),Material(vec4(0.1,1.0,0.1,1.0)));//绿球\n    sps[2]=Sphere(3.f,vec3(-5.0+sin(iTime)*10.0+10.0,3.0,0.0),Material(vec4(0.1,0.1,1.0,1.0)));//蓝球\n    sps[3]=Sphere(10.f,vec3(0.0,10.0,10.0),Material(vec4(1.0,1.0,1.0,1.0)));//黄球\n    sps[4]=Sphere(5000.f,vec3(0.0,-5000.0,10.0),Material(vec4(1.0,1.0,1.0,1.0)*0.8));\n    cameraLocation=vec3(0.0,20.0,-30.0);//相机位置\n    cameraRotation=vec3(20.0,0.0,0.0);//相机旋转\n}\n/////追踪场景内的物体\nbool traceSence(in Ray r,out HitResult res)\n{   \n    bool re=false;\n    float maxDistance=9e10;//最大光线追踪深度\n    for(int i=0;i<count;i++)\n    {\n        HitResult tempRes;\n        if(trace(r,sps[i],tempRes))\n        {\n            if(tempRes.t<maxDistance)\n            {\n                re=true;\n                res=tempRes;\n                maxDistance=tempRes.t;\n            }\n        }\n    }\n    return re;\n}\n//////取得世界空间射线\nRay getRay(in vec2 fragCoord,in Camera ca,in mat4 caT)\n{\n    fragCoord+=random(vec2(fragCoord.x,iTime));\n    //对焦平面半高度\n    float halfH=tan(radians(ca.FOV/2.0))*ca.focusDistance;\n    //射线在对焦平面上的位置\n    vec2 uv=fragCoord-iResolution.xy/2.0;//平移\n    float rate=halfH/(iResolution.y/2.0);//绽放比例\n    uv*=rate;\n    vec3 rayTarget=vec3(uv,ca.focusDistance);\n    //局部射线方向\n    vec3 dir=normalize(rayTarget);//局部方向\n    vec3 camerOrigin=vec3(0.0,0.0,0.0);//局部位置\n    //转换到世界空间射线\n    camerOrigin=vec3(caT*vec4(camerOrigin,1.0));//世界位置\n    dir=mat3(caT)*dir;//世界方向\n    //构建射线对象\n    Ray r=Ray(camerOrigin,dir);\n    return r;\n}\n\n/////////////////////////////////////////////////////////渲染函数\n/////渲染背景\nvec4 getBackground(vec3 dir)\n{\n    dir=normalize(dir);\n    vec3 lightDir=mat3(rotatY(iTime*50.0))*normalize(vec3(1.0,1.0,-1.0));\n    float alpha=pow(dot(dir,lightDir)*0.5+0.5,16.0);\n    vec4 sunColor=vec4(1.0,0.6,0.2,1.0)*2.0;\n    vec4 up=vec4(0.2,0.2,1.0,1.0)*1.0;\n    vec4 down=vec4(1.0,0.9,0.8,1.0)*0.5;\n    return mix(mix(down,up,dir.y),sunColor,alpha);\n}\n/////渲染\nvec4 render(in Ray r)\n{   \n    const int maxDepth=32;\n    vec4 finalColor=vec4(1.0);\n    HitResult tempRes;\n    for(int i=0;i<maxDepth;i++)\n    {   r.origin+=r.direction*0.01;\n        if(traceSence(r,tempRes))\n        {\n            //辐射贡献\n            finalColor*=tempRes.material.BaseColor;\n            //用于下一次追踪的射线\n            r=Ray(r.origin+r.direction*tempRes.t,reflect(r.direction,tempRes.worldNormal));\n            \n            /*\n            vec3 normal=(dot(r.direction,tempRes.worldNormal)<0.0)? tempRes.worldNormal:-tempRes.worldNormal;\n            float rr=(dot(r.direction,tempRes.worldNormal)<0.0)? 1.3:1.0/1.3;\n            r=Ray(r.origin+r.direction*tempRes.t,refract(r.direction,normal,rr));\n\t\t\t*/\n            \n            //追踪次数结束\n            if(i+1==count){\n                finalColor*=getBackground(r.direction);\n                //finalColor*=vec4(1.0);//追踪尽头颜色\n            }\n        }\n        else\n        {\n            finalColor*=getBackground(r.direction);\n            break;\n        }\n    }\n    return finalColor;\n}\n//主函数\nvec3 s=refract(vec3(1.0,2.0,10.0),vec3(1.0,0.0,0.0),1.5);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    createSence();//创建场景\n    //相机矩阵\n    mat4 cameraMat=translate(cameraLocation)*rotat(cameraRotation);\n    fragColor+=render(getRay(fragCoord+vec2(0.5,0.5),ca,cameraMat));//着色\n    fragColor+=render(getRay(fragCoord+vec2(0.7,0.5),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.75,0.5),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.25,0.75),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.5,0.25),ca,cameraMat));\n    fragColor/=5.0;\n    vec2 uv=fragCoord/iResolution.xy;\n    //fragColor=texture(iChannel1,vec3(1.0,0.0,0.5));\n    //Gamma\n    const float inverseGamma=1.0/2.2;\n    fragColor=vec4(pow(fragColor.x,inverseGamma),pow(fragColor.y,inverseGamma),pow(fragColor.z,inverseGamma),1.0);\n    \n\n}\n","name":"Image","description":"","type":"image"}]}