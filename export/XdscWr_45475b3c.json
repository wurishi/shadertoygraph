{"ver":"0.1","info":{"id":"XdscWr","date":"1487905266","viewed":448,"name":"Hilbert's Brain","username":"marciot","description":"Warping 2D Hilbert curve onto a sphere using IQ's patched sphere parametrization.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","warping","brain","hilbertcurve","weirdscience"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535898\n\nconst float puddleY = 0.2;\n\n/* *********************** Hilbert curve ***********************/\n\n/* This is based on the following 2D shader:\n\n    https://www.shadertoy.com/view/XtjXW3\n\n   The code was refactored for legibility and is better\n   explained here:\n\n    https://www.shadertoy.com/view/MdXcWn\n\n*/\n\n#define swap(a,b) tmp=a; a=b; b=tmp;\n\n#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )\n#define plotC(U,l)  abs( length(U-(l)/2.) - .5 )\n          \n// symU and rotU apply to vectors that range from 0 to 1\nvoid symU(inout vec2 u) {\n    u.x = 1.-u.x;\n}\n\nvoid rotU(inout vec2 u) {\n    u.xy = vec2(u.y,1.-u.x);\n}\n\n\n// symV and rotV apply to unit vectors that range from -1 to 1\n\nvoid symV(inout vec2 v) {\n    v.x= -v.x;\n}\n\nvoid rotV(inout vec2 v) {\n    v.xy = vec2(v.y,-v.x);\n}\n\n\nfloat textureFunc(vec2 U ) {\n    const float iter = 2.;\n    \n    vec2 P = vec2(.5);\n    vec2 I = vec2(1,0);\n    vec2 J = vec2(0,1);\n    \n    vec2 l = -I;\n    vec2 r;\n    \n    vec2 qU;\n\tvec2 tmp;\n    \n    for (float i = 0.; i < iter; i++) {\n        qU      = step(.5,U);         // select quadrant\n        bvec2 q = bvec2(qU);          // convert to boolean\n        \n        U       = 2.*U - qU;          // go to new quadrant\n        \n        l = q.x ? (q.y ? -J : -I)            // node left segment\n                : (q.y ?  l :  J);\n                    \n\n        r = (q.x==q.y)?  I : (q.y ?-J:J);    // node right segment\n        \n        // the heart of Hilbert curve : \n        if (q.x) { // sym\n        \tsymU(U);\n            symV(l);\n            symV(r);\n            swap(l,r);\n       \t}\n        if (q.y) { // rot+sym\n            rotU(U); symU(U);\n            rotV(l); symV(l);\n            rotV(r); symV(r);\n       \t}\n    }\n    \n    float s=iter* 25.;\n    float o=length(l+r) > 0. ? plotC (U-P, l+r) : plot (U-P, l) + plot (U-P, r); \n    return pow(sin(smoothstep(.33+.01*s,.33-.01*s,o)*0.5*PI),2.);\n}\n\n/* ************************************************************ */\n\n/* Basic operations from:\n *   https://iquilezles.org/articles/distfunctions\n */\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// 3D Primitives\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// 2D Primitives (degenerate cases of IQ's 3D dist functions):\n//  https://iquilezles.org/articles/distfunctions\n\nfloat udRoundRect( vec2 p, vec2 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n/* ************************************************************ */\n\n/* The brain consists of Hilbert curves on a sphere.\n *\n * The Hilbert curve is defined over a unit square x,y=[0,1].\n * To map it onto a sphere, I draw it on the sides of a cube\n * and use IQ's patched sphere parametrization to squash it\n * into a sphere.\n *\n * Reference: https://iquilezles.org/articles/patchedsphere */\n\nvec2 sphereToCube(in vec3 pointOnSphere) {\n   return vec2(\n        pointOnSphere.x/pointOnSphere.z,\n        pointOnSphere.y/pointOnSphere.z\n    );\n}\n\nvoid sphereTangents(in vec3 pointOnSphere, out vec3 u, out vec3 v) {\n    u = vec3(\n        -(1.+pointOnSphere.y*pointOnSphere.y),\n        pointOnSphere.x*pointOnSphere.y,\n        pointOnSphere.x);\n    v = vec3(\n        pointOnSphere.x*pointOnSphere.y,\n        -(1.+pointOnSphere.x*pointOnSphere.x),\n        pointOnSphere.y);\n}\n\n/* Check if x and y are between 0 and 1. If so, return v,\n * otherwise return zeros. This allows us to use a sum of\n * vectors to test what face of the cube we are on */ \nvec2 insideBounds(vec2 v) {\n    vec2 s = step(vec2(-1.,-1.), v) - step(vec2(1.,1.), v);\n    return s.x * s.y * v;\n}\n\nfloat getSphereMappedTexture(in vec3 pointOnSphere) {\n    /* Test to determine which face we are drawing on.\n     * Opposing faces are taken care of by the absolute\n     * value, leaving us only three tests to perform.\n     */\n    vec2 st = abs(\n        insideBounds(sphereToCube(pointOnSphere    )) +\n        insideBounds(sphereToCube(pointOnSphere.zyx)) +\n        insideBounds(sphereToCube(pointOnSphere.xzy)));\n    return textureFunc(st);\n}\n\nvec3  brainCenter = vec3(0., 0.85, 0.);\nfloat brainRadius = 2.;\n\nfloat sdBrain(vec3 p) {\n    return\n\t\tgetSphereMappedTexture(p) * -0.13 +\n\t\tsdSphere(p-brainCenter, brainRadius);\n}\n\nvec3 brainColor(vec3 p) {\n    float f = smoothstep(0.1, 0.4, getSphereMappedTexture(p));\n    return mix(vec3(1.0,0.4,0.5),vec3(1.0,0.6,0.7),f);\n}\n\n/* ************************************************************ */\n\n/* The puddle is based on my lathe operator. If I take a 2D\n * rectangle and sweep it a full 360 degrees, I would get a\n * circular disc. By varying the length of that rectangle, I\n * make a puddle.\n */\n \n// Periodic sinusoidal function gives us the shape of the puddle.\nfloat puddle(float a) {\n    return  0.45 +\n            0.05 * sin(a *  1.0) +\n           -0.06 * sin(a *  2.0) +\n            0.03 * sin(a *  4.0) +\n            0.04 * sin(a *  8.0);\n}\n\n// The distance field in 2D, which is swept around to form the puddle.\n// Thin rectangle with rounded edges, to make the puddle edges round.\nfloat crossSection(vec2 p, float len) {\n    return udRoundRect(p, vec2(len, 0.0), .1);\n}\n\n// Generates the puddle. Sweeps the crossSection around while varying\n// the length according to the angle.\nfloat opPuddle( vec3 p ) {\n    float dia = puddle(atan(p.x, p.z)) * 7.;\n    return crossSection(vec2(length(p.xz), p.y - puddleY), dia);\n}\n\n/* ************************************************************ */\n\n/* Tile floor */\n\nvec3 tilePlane(vec3 p) {\n    p.xz = mod(p.xz, 1.1);\n    return p;\n}\n\nbool usePuddle;\n\n/* This function returns a distance field in 3D. It consists of\n * an infinite plane of tiles, the brain, and the puddle.\n */\nfloat map(vec3 p){\n    float d =\n        opU(\n            udRoundBox(tilePlane(p),vec3(1.,0.1,1.),0.05),\n            sdBrain(p)\n        );\n    \n    if(usePuddle) {\n    \treturn opU(d, opPuddle(p));\n    } else {\n    \treturn d;\n    }\n}\n\n// Soft shadow code modified from: https://www.shadertoy.com/view/Xds3zN\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n/* Ray-marching code based on https://www.shadertoy.com/view/MlXSWX */\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n// Standard ray marching routine. I find that some system setups don't like anything other than\n// a \"break\" statement (by itself) to exit.\nfloat march(vec3 rayOrigin, vec3 rd) {\n    const float minDist = .05;\n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<128; i++){\n\t\tdt = map(rayOrigin + rd*t);\n\t\tif(dt<minDist || t>150.){ break; } \n\t\tt += dt*0.75;\n\t}\n    return (dt < minDist) ? t : -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 1.0, 0.0);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(\n        3.0 - iMouse.x/iResolution.x*7.,\n        6.0 - iMouse.y/iResolution.y*4.,\n        -6.); // Camera position, doubling as the ray origin.\n\n    // Lights\n    vec3 light_pos  = vec3(5., 7., -1.);\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n    \n    usePuddle = true;\n    \n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\tfloat t = march(camPos, rd);\n\t\n    // The final scene color. Initated to sky color.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t > 0.){\n        float specular = 0.;\n        float diffuse  = 110.;\n        \n\t\t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        if(opPuddle(sp) < 0.05) {\n            // We have hit the puddle\n            usePuddle = false;\n            \n            vec3 refractedRd = refract(-rd, sn, 1./1.33);\n            float t = march(sp, refractedRd);\n            \n            sp = t * refractedRd+sp;\n\t        sn = getNormal(sp);\n            \n            sceneCol -= vec3(0.0, 0.4, 0.4);\n            specular = 1.0;\n        }\n        \n        // The floor is white, the brain is textured.\n        if(sp.y < 0.2) {\n            sceneCol += vec3(1.0);\n            specular = 0.7;\n        } else {\n            sceneCol += brainColor(sp);\n            specular = 0.4;\n        }\n\n    \t// Light direction vectors.\n\t    vec3 ld  = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp  = max(length(ld),  0.001);\n        \n    \t// Ambient light.\n\t    float ambience = 0.15;\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld  /= distlpsp;\n        \n    \t// Diffuse lighting.\n\t    float diff  = max( dot(sn, ld), 0.0) * 110.;\n        \n        // Light attenuation\n        diff /= distlpsp*distlpsp;\n        \n        // Specular highlights.\n\t    specular *= pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n        \n        usePuddle = false;\n        \n        // Soft shadow based on:\n        //   https://www.shadertoy.com/view/Xds3zN\n        float shadow = softshadow( sp, ld, 0.02, 2.5 );\n        \n        sceneCol *= diff*shadow*0.5 + ambience*0.5 + specular;\n    }\n\n    fragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n}","name":"Image","description":"","type":"image"}]}