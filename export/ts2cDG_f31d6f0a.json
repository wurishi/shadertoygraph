{"ver":"0.1","info":{"id":"ts2cDG","date":"1587292643","viewed":48,"name":"learning sdf","username":"mueslee","description":"learning sdf things","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\nvec2 _uv;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nvec3 opTx(in vec3 p, in mat4 t)\n{\n    return (inverse(t) * vec4(p, 1)).xyz;\n}\n\n\nfloat computeSphereDistance(vec3 p)\n{\n   // distance = length(sphere_position - camera_position) - sphere_radius;\n   vec4 sphere = vec4(0, 1, 6, 1);\n   float distance = length(p - sphere.xyz) - sphere.w;\n   return distance;\n}\n\n\nfloat computeGroundDistance(vec3 p)\n{\n   // distance = camera.y - plane.y;\n   float distance = p.y;\n   return distance;\n}\n\n\nmat2 rotate2D(float a) \n{\n   float s = sin(a);\n   float c = cos(a);\n   \n   return mat2(c, -s, s, c);\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n   mat2 rot = rotate2D(a);\n   vec3 pr = p;\n   pr.yz *= rot;\n   return pr;\n}\n\n\nvec3 rotateY(vec3 p, float a)\n{\n   vec3 pr = p;\n   mat2 rot = rotate2D(a);\n   pr.xz *= rot;\n   return pr;\n}\n\n\nvec3 rotateZ(vec3 p, float a)\n{\n   vec3 pr = p;\n   mat2 rot = rotate2D(a);\n   pr.xy *= rot;\n   return pr;\n}\n\n\nvec3 move(vec3 p, vec3 offset)\n{\n   return p - offset;\n}\n\n\nvec3 scale(vec3 p, vec3 scale)\n{\n   return p / scale;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n   float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n   return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nfloat computeTwister(vec3 p, vec3 offset)\n{\n   float twist = M_PI * 0.25 + p.y + sin(iTime + p.y + offset.x);\n   vec3 box_p = p;\n   box_p -= vec3(0.2 * twist, 1.5, 6.0 + twist + cos(iTime+p.x));\n   box_p -= offset;\n   box_p = rotateY(box_p, twist);\n   float distance_box = sdRoundBox(box_p, vec3(0.5, 10.0, 0.5), 0.05);\n   float distance_ground = computeGroundDistance(p);\n   float distance = distance_box /2.0;    \n   return distance;\n}\n   \n\nfloat computeDistance(vec3 p)\n{\n    float a = computeTwister(p, vec3(0,0,0));\n    float b = computeTwister(p, vec3(-2,0,0));\n    \n    return smin(a, b, (1.0+sin(iTime))*0.5);\n}\n\n\n\nfloat rayMarch(vec3 ray_origin, vec3 ray_direction)\n{\n    float distance_from_origin = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + distance_from_origin * ray_direction;\n        float distance_to_scene = computeDistance(p);\n        distance_from_origin += distance_to_scene;\n        \n        if (distance_to_scene < SURFACE_DISTANCE || distance_from_origin > MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    \n    return distance_from_origin;\n}\n\n\nvec3 computeNormal(vec3 point)\n{\n    // compute distance at our point \n    float distance = computeDistance(point);\n    \n    // compute distance to the surface at nearby points\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 normal = vec3(\n            distance - computeDistance(point - e.xyy),\n            distance - computeDistance(point - e.yxy),\n            distance - computeDistance(point - e.yyx)\n        );\n    \n    \n    return normalize(normal);\n}\n\n\nvec3 computeLightPos()\n{\n    vec3 light_position = vec3(0, 0, 0);\n    light_position.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n\n    return light_position;    \n}\n\n\nfloat computeShadow(vec3 point, vec3 point_normal, vec3 direction_light_to_point)\n{\n    float shade_factor = 1.0;\n    \n    // if we raymarch from the point to our light position and hit something in between\n    // then the resulting distance is smaller than the distance between point and light\n \n    // need to go a little away from the surface\n    float distance = rayMarch(point + point_normal * SURFACE_DISTANCE * 2.0, direction_light_to_point);\n    \n    if (distance < length(direction_light_to_point - point))\n    {\n        shade_factor = 0.1;\n    }\n    \n    return shade_factor;\n}\n\n\nfloat computeDiffuse(vec3 point)\n{    \n    // compute good old dot product\n    vec3 light_position = computeLightPos();\n    vec3 direction_light_to_point = normalize(light_position - point);\n    vec3 point_normal = computeNormal(point);\n    float diffuse = clamp(dot(point_normal, direction_light_to_point), 0.0, 1.0);\n    \n    // add shadow\n    diffuse *= computeShadow(point, point_normal, direction_light_to_point);\n    \n    return diffuse;\n}\n\n\nfloat computeLight(vec3 point)\n{\n    float intensity = 0.0;    \n    intensity += computeDiffuse(point);\n    return intensity;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // 0, 0 is in the middle\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    _uv = uv;\n    \n    // vec2 m = iMouse.xy / iResolution.xy;\n    // vec3 camera_pos = vec3(0, 4, -2);\n    // camera_pos = rotateX(camera_pos, -m.y);\n    // camera_pos = rotateY(camera_pos, m.x * 6.2831);\n    \n    // camera and rays fired from the camera\n    vec3 camera_pos = vec3(0, 2.0, 0);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.0));\n\n    // raymarch and get point close to scene\n    float distance = rayMarch(camera_pos, ray_dir);    \n    vec3 pos = camera_pos + ray_dir * distance;\n    \n    // get light for point\n    float light = computeLight(pos);\n    vec3 col = vec3(light);\n    \n    // only distance based rendering\n    // col = vec3(distance);\n    // col /= 7.0;\n    \n    // check computeNormal\n    // col = computeNormal(pos);\n\n    // output to screen\n    fragColor = vec4(col, 1.0);\n    //fragColor.r *= 0.4;\n    //fragColor.g *= 0.5;\n}\n\n// Ray Marching for dummies (building a ray marcher from scratch):\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n// Simple shapes explained (sphere, cube, cylinder, torus):\n// https://youtu.be/Ff0jJyyiVyw\n\n// Shader starting point:\n// https://www.shadertoy.com/view/wdGGz3\n\n// smoothstep\n// https://www.youtube.com/watch?v=60VoL-F-jIQ\n\n// operators\n// https://www.youtube.com/watch?v=Vmb7VGBVZJA\n// https://www.youtube.com/watch?v=AfKGMUDWfuE\n\n// iq\n//\n// line segments\n// https://www.youtube.com/watch?v=PMltMdi1Wzg\n//\n// quad segments\n// https://www.youtube.com/watch?v=62-pRVZuS5c\n//\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/distfunctions2d\n","name":"Image","description":"","type":"image"}]}