{"ver":"0.1","info":{"id":"4ljSDm","date":"1444255796","viewed":391,"name":"The Skies Are Boxes","username":"Hamneggs","description":"The time is nigh that I wrote something with floating cubes.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["procedural","ray","clouds","texture","global","illumination","marching","box","occlusion","ambient","texturing","fract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * \"The Skies Are Boxes\" fragment shader.\n *\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Some very bright floating cubes with color and psuedo global illumination.\n *\n *\n * Version 1.0: Initial release.\n * Version 2.0: Now with multi-pass DOF.\n * Version 2.1: Oh wait why not store depth in the renderbuffer's alpha channel?\n */\nvec4 gaussY( in sampler2D t, in vec2 uv, in float diff )\n{\n    vec2 d = vec2(0.0,diff);\n    vec4 r;\n    r += texture(t,uv+d*.000)*.5000;\n    r += texture(t,uv+d*.250)*.4013;\n    r += texture(t,uv+d*.500)*.3085;\n    r += texture(t,uv+d*.750)*.2266;\n    r += texture(t,uv+d*1.00)*.1587;\n    r += texture(t,uv-d*.250)*.4013;\n    r += texture(t,uv-d*.500)*.3085;\n    r += texture(t,uv-d*.750)*.2266;\n    r += texture(t,uv-d*1.00)*.1587;\n    return r*.39182;\n    \n}\n\n/*\n\tShadertoy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float depth = texture(iChannel0,uv).a;\n    color = gaussY(iChannel1,uv,depth*.01);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * \"The Skies Are Boxes\" fragment shader.\n *\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Ah yes, this is the image right here. This is what becomes\n * blurred based upon depth.\n *\n * Version 1.0: Initial release.\n * Version 2.0: Now with multi-pass DOF.\n */\n\n// Just some marching constants. Steps >= depth*10\n#define EPSILON \t\t0.0075\n#define MAX_DEPTH   \t50.0\n#define MAX_V_STEPS \t500\n#define N_THRESH\t\t0.825\n#define MAT_REFLECTANCE 0.60\n\n// Occlusion samples.\n#define OCC_SAMPLES \t5.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR \t\t1.3\n\n// Quick quality settings.\n#define CALC_OCCLUSION \t\t/* Ambient occlusion */\n#define CALC_BETTER_GI \t\t/* Global Illumination */\n#define CALC_ON_LIGHTS \t\t/* Oren Nayar lighting */\n// #define CALC_TEXTURES \t\t/* Silly marble texture */\n\nconst vec3 UP\t\t\t= vec3(0.0,1.0,0.0);\nconst vec3 SUN_DIR\t\t= normalize(vec3(.25, 1., -.85));\nconst vec3 CAM_POS\t\t= vec3(7.0, 2.0, 0.0);\nconst vec3 CAM_DIR\t\t= normalize(vec3(1, .1, 1));\nconst vec3 SKY_COLOR_A\t= vec3(.60,.775,.90);\nconst vec3 SKY_COLOR_B\t= vec3(.33,.55,.82);\nconst vec3 SUN_COLOR\t= vec3(3.0);\nconst vec3 GROUND_COLOR\t= vec3(.00,.15,.30);\nconst vec3 BOX_COLOR \t= vec3(.3);\nconst vec3 CUBE_SIZE\t= vec3(.8);\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade. This allows the fading in and out\n\tbetween scenes.\n*/\nfloat shutterfade( in float s, in float e, in float t, in float duration )\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tA simple camera animation function.\n*/\nvoid animate_cam( in float t, in vec2 uv, out vec3 cp, out vec3 cd, out float f )\n{\n    // Get a new offset every 20 seconds.\n    vec3 offset = vec3(7.0, 2.0, 0.0) + vec3(20.0)*floor(t*.05);\n    \n    // Fade in and out every 10 seconds.\n    f = shutterfade(0.0, 10.0, mod(t,10.0), .5);\n    \n    // Traverse along a path, resetting every 20 seconds.\n    cp = offset + vec3(2.0*mod(t,20.0), 0.0, 2.0*mod(t,20.0));\n    \n    // For the first 10 seconds we look up slightly, for the second 10 we\n    // gander downwards a bit.\n    if( mod(t,20.0)<10.0 ) cd = CAM_DIR;\n    else cd = CAM_DIR*vec3(-1.0, 1.0, 1.0);\n    \n    camera(uv, cp, cd, 1.0, cp, cd);\n}\n\n\n/*\n\tA simple hash function that returns a random value for a position.\n\tDistribution's not so great, but who cares.\n*/\nfloat hash( in vec3 p )\n{\n    return fract(sin(p.x)*753.5453123)+\n           fract(sin(p.y)*483.9862233)+\n           fract(sin(p.z)*298.1293584);\n}\n\n/*\n\tOlinde Rodrigues' vector rotation formula for rotating a vector <a>\n\taround a vector <b> <t> radians.\n*/\nvec3 rodRot( in vec3 a, in vec3 b, in float t )\n{\n    // Straight from wikipedia.\n\treturn normalize(a*cos(t) + cross(b, a)*sin(t) + b*dot(b,a)*(1.0-cos(t)));\n}\n\n/*\n\tIQ's seminal vec3->float noise function.\n*/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    // I appreciate the slight artifacting not having a 0..1 lookup\n    // induces. (Using the 64x texture). It creates walls of\n    // boxes instead of regions. This means I can get a decent\n    // looking image without shadows.\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tA shallow fbm accumulation.\n*/\nfloat fbm( in vec3 p )\n{\n    float result  = .500*noise(p    );\n    \t  result += .250*noise(p*2.0);\n    \t  result += .125*noise(p*4.0);\n    return result * 1.1428;\n}\n\n/*\n\tA simple marble texture. It really just returns a brightness\n\tcoefficient. Since the fbm function uses my broken version\n\tof iq noise, things shimmy.\n*/\nfloat marble( in vec3 p )\n{\n    p *= 100.0;\n    float offset = 2.0*( fbm(p)-.5 );\n    return 1.0-pow(fbm(p+offset),4.0);\n}\n\n/*\n\tIQ's signed box distance function.\n*/\nfloat box( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n/*\n\tA distance function that takes into account the fact\n\tthat a box may not exist in the current voxel. This is \n\tactuallyterrible on my part because it assumes that a cube\n\twill be in the nearest neighboring voxel. This causes it \n    to drastically underestimate at times, and easily can\n\tcause the max number of steps to end well before the max\n\tdistance.\n\n\tWhen the max distance strays much further than 1/10th \n\tthe number of steps the scene develops some fun artifacts,\n\twhich when mild kind of look like waves on the water.\n*/\nfloat dist( in vec3 p )\n{\n    vec3 f = fract(p);\n    vec3 i = floor(p);\n    // If the current voxel doesn't have a high enough\n    // noise value we consider it empty.\n    if(noise(i) < N_THRESH)\n    {\n        // Return the distance to the nearest wall of \n        // the current voxel, plus the distance past that\n        // border to the cube on the other side.\n        return -box(f-.5, vec3(.5+.5*(1.0-CUBE_SIZE.x)));\n    }  \t   \n\telse return box(f-.5, CUBE_SIZE*.5); // If this voxel is not empty, well...\n}\n\n/*\n\tRay marching function.\n*/\nvec3 march( in vec3 p, in vec3 d, in vec3 e )\n{\n    float c;\t// Current distance.\n    for(int i = 0; i < MAX_V_STEPS; ++i)\n    {\n        // Get the current distance.\n        c = dist(p);\n        \n        // If we're close enough, return the current position.\n        if( c<EPSILON ) return p;\n        \n        // If the current march will take us further than the clip\n        // distance, return the current position plus the clip distance.\n        else if( c>MAX_DEPTH ) return e+d*MAX_DEPTH;\n            \n\t\t// If we've gone far enough, return the current position.\n        else if( length(p-e) > MAX_DEPTH ) return p;\n            \n        // Otherwise we march on!\n        else p += d*c;\n    }\n    return p;\n}\n\n/*\n\tThe usual surface normal function.\n*/\nvec3 norm( in vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( 3.1428 - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\n\n/*\n\tReturns an object texture given a position.\n*/\n#ifdef CALC_TEXTURES\nvec3 tex( in vec3 p )\n{\n    vec3 i = floor(p);\n    if(noise(i) < N_THRESH) return vec3(.0); // False positives? Nah....\n    \n    float id = floor(hash(i)*7.0);\n    \n    // First we get the color of the block.\n    vec3 r;\n    if(id < 2.0) r = vec3(.5);\n    else if(id < 3.0) r = vec3(.4, .1, .0);\n    else if(id < 4.0) r = vec3(.0, .35, .0);\n    else if(id < 5.0) r = vec3(.35, .0, .0);\n    else if(id < 6.0) r = vec3(.35, .35, .0);\n    else if(id < 7.0) r = vec3(.01, .01, .35);\n    else r = vec3(.35);\n        \n    // Then we apply the texture (since it's just a brightness coefficient).\n    return r*marble(p);\n}\n#endif\n\n/*\n\tA simpler texture function for determining GI contributions.\n*/\nvec3 color( in vec3 p )\n{\n    vec3 i = floor(p);\n    if(noise(i) < N_THRESH) return vec3(.0);\n    \n    float id = floor(hash(i)*7.0);\n    \n    if(id < 2.0) return vec3(.5);\n    else if(id < 3.0) return vec3(.4, .1, .0);\n    else if(id < 4.0) return vec3(.0, .35, .0);\n    else if(id < 5.0) return vec3(.35, .0, .0);\n    else if(id < 6.0) return vec3(.35, .35, .0);\n    else if(id < 7.0) return vec3(.01, .01, .35);\n    else return vec3(.35);\n}\n\n/*\n\tOren-Nayar reflectance modeling, since I may no longer use Phong after\n\tthe incident at the Zanzibar Marketplace.\n*/\n#ifdef CALC_ON_LIGHTS\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n/*\n\tStandard Gouraud shading.\n*/\n#else\nfloat gouraud( in vec3 n, in vec3 ldir )\n{\n    return clamp(dot(n,ldir), 0.0, 1.0);\n}\n#endif\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\n#ifdef CALC_OCCLUSION\nfloat occlusion( in vec3 pos, in vec3 norm )\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = .6/OCC_SAMPLES;\n\tfor(float i = unit; i < .6; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n#endif\n\n/*\n\tMarches about a dome above a surface, sampling the texture at each\n\tinterval. These samples are weighted based on distance from the original\n\tpoint, summed, averaged, and returned.\n*/\n#ifdef CALC_BETTER_GI\nvec3 giColor( in vec3 p, in vec3 n )\n{\n    // Basically what we're doing here is getting the texture of several\n    // positions above the surface. (Note that the texture color is defined\n    // per voxel, not per surface point. That is the only reason this works.)\n    //\n    // To do that we're going to rotate the surface normal off-axis,\n    // and then Rodrigues' rotate it around the original normal, sampling\n    // as we go. This creates sort of a unit hemisphere above the surface.\n    // Is sampling only at the unit distance a robust plan? Nope. Does it\n    // provide plausible results? Yep.\n    \n    // The vector that is rotated around the vector.\n    vec3 r = vec3(0.0);\n    // A place to accumulate the GI contributions.\n    vec3 gi = vec3(0.0);\n   \t// A vector tangent to the surface. A vector crossed with a vector that\n    // is not that vector results in a vector tangent to both.\n    vec3 t = normalize(cross(n, n+n.zxy));\n    \n    // So here we get orbit height and radius, leaning the normal over\n    // progressively farther. Here we lean up to 4PI/10, because if we\n    // lean over to PI/2, we get some nasty artifacting since we are sliding\n    // along the surface.\n    for(float a = .0; a < 1.25664; a += .125664)\n    {\n        // Lean over the surface normal by rotating it around\n        // a vector that is orthogonal to it.\n        // Jenny are you okay Jenny?\n        r = rodRot(n, t, a);\n        // March around that orbit.\n        for(float b = 0.0; b < 6.2832; b += 1.25664)\n        {\n            // Mix it with the environment map based on the distance\n            // to the other surface at that point.\n            gi += mix(color(p+r), vec3(0.0), clamp(pow(dist(p+r),2.0), 0.0, 1.0) );\n            // Going through the extra effort to consider distance showed\n            // very little effect.\n            //gi += color(p+r);\n            r = rodRot(r, n, 1.25664);\n        }\n    }\n    return gi;\n}\n#endif\n\n/*\n\tOne of IQ's less ambitious fog/atmospheric scattering functions.\n*/\nvec3 fog( in vec3  rgb, in float dist, in vec3 skyColor, in vec3 rayDir, in vec3 sunDir, in float b )\n{\n    float fogAmount = 1.0 - exp( -dist*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( skyColor*.15, \n                           SUN_COLOR*.5,\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n/*\n\tPerforms a gentle view distance culling. This doesn't remove geometry,\n\tit just smoothes the appearance boundary at which the marching function\n\tculls.\n*/\nvec3 distCull( in vec3 fg, in vec3 bg, in float dist )\n{\n    return mix(fg, bg, pow(dist/MAX_DEPTH,16.0));\n}\n\n/*\n\tShades a pixel.\n*/\nvec3 shade( in vec3 p, in vec3 d, in vec3 e )\n{\n    // Get the depth from eye to position.\n    float dist = length(p-e);\n    \n    // Supplant a sample from the environment map\n    // if need be.\n    vec3 skyColor = calculateSkyLuminanceRGB(SUN_DIR, d, 2.25)*.05;\n    if( dist>=MAX_DEPTH ) return skyColor;\n    \n    // Create a place to store the final result of our pixel.\n    vec3 result;\n    \n    // Get the surface normal for use throughout\n    // the process.\n    vec3 n = norm(p);\n    \n    // Light intensities.\n    #ifdef CALC_ON_LIGHTS\n    float sun_i = orenNayar(n, d, SUN_DIR);\n    #else\n    float sun_i = gouraud(n, SUN_DIR);\n    #endif\n    float sky_i = clamp(n.y, 1.0, 1.25);\n    #ifdef CALC_OCCLUSION\n    float occ_i = occlusion(p,n);\n    #else\n    float occ_i = 1.0;\n    #endif\n    #ifdef CALC_BETTER_GI\n    float gli_i = .125;\n    #else\n    float gli_i = 1.0;\n    #endif\n    \n    // Light colors.\n    vec3 sun_c = SUN_COLOR;\n    vec3 sky_c = skyColor;\n    #ifdef CALC_TEXTURES\n    vec3 box_c = tex(p);\n    #else\n    vec3 box_c = color(p);\n    #endif\n    #ifdef CALC_BETTER_GI\n    vec3 gli_c = giColor(p,n);\n    #else\n    vec3 gli_c = sky_c * .75;\n    #endif\n    \n    // Go ahead and combine all of this stuff.\n    result  = sun_c * sun_i;\n    result += sky_c * sky_i * occ_i;\n    result += gli_c * gli_i * occ_i;\n    \n    // Clamp the result to the normal range.\n    result = clamp(box_c*result,0.0,1.0);\n    \n    // Apply fog.\n    result = fog(result, dist, skyColor*5., d, SUN_DIR, .0075);\n    \n    // Return the point after distance culling.\n    return distCull(result, sky_c, dist);    \n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( in vec2 uv, in vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.1;\n    vig = pow(vig,9.0);\n    return pow(c,vec3(1.0/2.2))*smoothstep(.1, .5,clamp(vig,.1,.5));\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize screen coordinates.\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Vectors for the surface position, ray direction, and eye, as\n    // well as one for the shaded value.\n\tvec3 p, d, e;\n    \n    // A constant for the shutter.\n    float f = 0.0;\n    \n    // Set up and animate the camera.\n    animate_cam(iTime, uv, p, d, f);\n    \n    // Store the camera-translated starting point as the eye point.\n    e = vec3(p);\n    \n    // March the point.\n    p = march(p,d,e);\n    \n    // Shade the point.\n    fragColor.rgb = shade(p,d,e);\n    \n    // Do some post processing and return.\n    fragColor = vec4(postProcess(uv,fragColor.rgb)*f,length(p-e)*.005);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 gaussX( in sampler2D t, in vec2 uv, in float diff )\n{\n    vec2 d = vec2(diff,0.0);\n    vec4 r;\n    r += texture(t,uv+d*.000)*.5000;\n    r += texture(t,uv+d*.250)*.4013;\n    r += texture(t,uv+d*.500)*.3085;\n    r += texture(t,uv+d*.750)*.2266;\n    r += texture(t,uv+d*1.00)*.1587;\n    r += texture(t,uv-d*.250)*.4013;\n    r += texture(t,uv-d*.500)*.3085;\n    r += texture(t,uv-d*.750)*.2266;\n    r += texture(t,uv-d*1.00)*.1587;\n    return r*.39182;\n}\n\n/*\n\tShadertoy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float depth = texture(iChannel0,uv).a;\n    color = gaussX(iChannel0,uv,depth*.01);\n}","name":"Buffer B","description":"","type":"buffer"}]}