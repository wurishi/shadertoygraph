{"ver":"0.1","info":{"id":"7tK3Rm","date":"1637421327","viewed":348,"name":"RazorpayFTX Metaballs","username":"anuraghazra","description":"Recreation of RazorpayFTX metaballs.\nhttps://razorpay.com/ftx","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","razorpay"],"hasliked":0,"parentid":"7tG3RD","parentname":"razorpay_ftx_metaballs"},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nconst int MAT_NONE = 0;\nconst int MAT_BALL = 1;\n\nfloat smoothMin(float da, float db, float k) {\n  float h = max(k - abs(da - db), 0.0) / k;\n  return min(da, db) - h * h * h * k * 1.0 / 6.0;\n}\n\nmat2 Rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdBall(vec3 p, float size) {\n  return length(p) - size;\n}\n\nvec2 GetDist(vec3 p) {\n  p.y -= 0.8;\n  float t = iTime*0.5;\n  float d = 0.0;\n\n  float of = 1.0;\n  float b1 = sdBall(p - of * vec3(cos(t * 1.1), cos(t * 1.3), cos(t * 1.7)), 0.4);\n  float b2 = sdBall(p + of * vec3(cos(t * 0.7), cos(t * 1.9), cos(t * 2.3)), 0.6);\n  float b3 = sdBall(p + of * vec3(cos(t * 0.3), cos(t * 2.9), sin(t * 1.1)), 0.7);\n  float b4 = sdBall(p + of * vec3(sin(t * 1.3), sin(t * 1.7), sin(t * 0.7)), 0.2);\n\n  float smoothness = 1.6;\n  float balls = smoothMin(b1, smoothMin(b2, smoothMin(b3, b4, smoothness), smoothness), smoothness);\n  d = balls;\n\n  int mat = MAT_NONE;\n  if (d == balls) {\n    mat = MAT_BALL;\n  } else if (d > MAX_DIST) {\n    mat = MAT_NONE;\n  }\n\n  return vec2(d, mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n  float dO = 0.;\n  float mat = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    vec2 result = GetDist(p)*side;\n    float dS = result.x;\n    dO += dS;\n    mat = result.y;\n    if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n  }\n\n  return vec2(dO, mat);\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p).x;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(\n    GetDist(p - e.xyy).x,\n    GetDist(p - e.yxy).x,\n    GetDist(p - e.yyx).x);\n\n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p),\n    r = normalize(cross(vec3(0, 1, 0), f)),\n    u = cross(f, r),\n    c = f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize(i);\n  return d;\n}\n\nvec3 RenderMat(in vec3 ro, in vec3 rd, in vec3 ref, bool last) {\n  vec3 tex = texture(iChannel0, rd).rgb;\n  vec3 col = vec3(tex);\n  vec2 d = RayMarch(ro, rd, 1.0);\n\n  ref = vec3(0);\n\n   \n  if (d.x < MAX_DIST) {\n    int mat = int(d.y);\n    float IOR = 1.33;\n    vec3 p = ro + rd * d.x;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 rdIn = refract(rd, n, 1.0/IOR);\n    vec3 refOutside = texture(iChannel0, r).rgb;\n    refOutside = vec3(refOutside.r*2.0, refOutside.g*2.0, refOutside.b);\n    \n    vec3 pEnter = p - n*SURF_DIST*3.0;\n    float dIn = RayMarch(pEnter, rdIn, -1.0).x;\n    vec3 pExit = pEnter + rdIn * dIn;\n    vec3 nExit = -GetNormal(pExit);\n    vec3 rdOut = refract(rdIn, nExit, IOR);\n    vec3 refTex = texture(iChannel0, rdOut).rgb;\n\n    if (dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n    \n    float dens = 0.1;\n    float optDist = exp(-dIn*dens);\n    float fresnel1 = pow(1.0+dot(rd, n), 1.0);\n    float fresnel2 = pow(clamp(1.0 - dot(n, -rd), 0.4, 0.8), 2.0);\n    vec3 absorptionCol = vec3(0.1, .1, 2.0);\n    \n    \n    if (mat == MAT_BALL) {\n        col = mix(refTex*optDist, refOutside, fresnel1)*3.2;\n        col *= mix(absorptionCol, vec3(1), fresnel1);\n        col *= mix(col, vec3(1.0, 0.0, 0.0), fresnel2);\n    }\n    \n    // ro = p + n * SURF_DIST * 3.0;\n    // rd = r;\n    // float fresnel = pow(clamp(1.0 - dot(n, -rd), 0.0, 1.0), 5.0);\n    // float dif = dot(n, normalize(vec3(1, 2, 3))) * .5 + .5;\n  }\n\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3(0, 3, -3);\n  ro.yz *= Rot(-m.y * 3.14 + 1.);\n  ro.xz *= Rot(-m.x * 6.2831);\n\n  vec3 rd = GetRayDir(uv, ro, vec3(0, 0.75, 0), 1.1);\n  vec3 ref = vec3(0.0);\n  vec3 fil = vec3(1);\n  vec3 col = RenderMat(ro, rd, ref, false);\n\n  // remove background\n  float d = RayMarch(ro, rd, 1.0).x;\n  if (d > MAX_DIST) {\n    col = vec3(0.06, 0.08, 0.10);\n  }\n  \n  fragColor = vec4(col.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}