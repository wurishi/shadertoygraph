{"ver":"0.1","info":{"id":"lXScWG","date":"1727643198","viewed":30,"name":"torus and sphere hw1","username":"boomix","description":"homework 1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphereandtorus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        length(p + e.xyy) - length(p - e.xyy),\n        length(p + e.yxy) - length(p - e.yxy),\n        length(p + e.yyx) - length(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0; // большое начальное значение\n    \n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec3 torusPos = vec3(float(i) * 3.0, 0.0, float(j) * 3.0);\n            \n            float time = iTime * 2.0 + float(i * j);\n            float bounce = abs(sin(time)) * 1.5;\n            vec3 spherePos = torusPos + vec3(0.0, bounce, 0.0);\n            \n            float dTorus = torus(p - torusPos, vec2(1.0, 0.3));\n            float dSphere = sphere(p - spherePos, 0.3);\n            \n            // Объединяем тор и шар\n            d = opUnion(d, opUnion(dTorus, dSphere));\n        }\n    }\n    \n    return d;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    float diff = max(dot(normal, lightDir), 0.0);\n    return vec3(1.0, 0.8, 0.6) * diff;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    float d;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * dist;\n        d = map(p);\n        if (d < 0.001) break;\n        dist += d;\n        if (dist > 50.0) break;\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    float camTime = iTime * 0.5;\n    vec3 ro = vec3(7.0 * sin(camTime), 3.0 + sin(camTime * 0.5), 7.0 * cos(camTime));\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    float dist = raymarch(ro, rd);\n    \n    vec3 color = vec3(0.0);\n    \n    if (dist < 50.0) {\n        vec3 p = ro + rd * dist;\n        vec3 normal = calcNormal(p);\n        \n        vec3 lightPos = ro;\n        vec3 lightColor = lighting(p, normal, lightPos);\n        \n        color = lightColor;\n        \n        color *= exp(-0.02 * dist);\n    }\n    \n    // Гамма-коррекция\n    color = pow(color, vec3(0.4545)); // Гамма 2.2\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}