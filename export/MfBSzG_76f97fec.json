{"ver":"0.1","info":{"id":"MfBSzG","date":"1706569649","viewed":126,"name":"interactive 2D perlin noise","username":"IlyaBelyy","description":"An interactive exploration how does choice of gradients affect perlin noise.\n\nUse mouse to set gradients.\nSee keyboard commands in the comments\n\nSame for simplex https://www.shadertoy.com/view/MfjSzK","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["2d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUse mouse to adjust gradient vectros\n\nKeyboard:\n    r - reset all gradients to random\n    n - toggle gradient normalisation\n    q - toggle gradient snapping to main directions\n    0 - diplay zero isoline\n    g - display grid\n*/\n\nvec2 load_gradient(vec2 p, bool norm_mode, bool snap_mode)\n{\n    vec2 grad = texelFetch(iChannel0, ivec2(p), 0).xy;\n\n    if (snap_mode) {\n#if 1 // snap to 8 directions\n        if (norm_mode) return normalize(round(normalize(grad)));\n        return length(grad) * normalize(round(normalize(grad)));\n#else // snap to 4 directions\n        if (abs(grad.x) < abs(grad.y)) grad.x = 0.0;\n        else grad.y = 0.0;\n#endif\n    }\n\n    return norm_mode ? normalize(grad) : grad;\n}\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 id2colour(ivec2 id)\n{\n    return hash(uvec3(id.xy + 123, id.x + id.y + 200));\n}\n\n// a textbook perlin noise implementation\nvec4 perlin(vec2 p, bool norm_mode, bool snap_mode)\n{\n    // read gradient values from buffer A\n    vec2 g00 = load_gradient(p, norm_mode, snap_mode);\n    vec2 g01 = load_gradient(p + vec2(0,1), norm_mode, snap_mode);\n    vec2 g10 = load_gradient(p + vec2(1,0), norm_mode, snap_mode);\n    vec2 g11 = load_gradient(p + vec2(1,1), norm_mode, snap_mode);\n\n    float n00 = dot(g00, (p - floor(p)));\n    float n01 = dot(g01, (p - floor(vec2(p.x, p.y + 1.0))));\n    float n10 = dot(g10, (p - floor(vec2(p.x + 1.0, p.y))));\n    float n11 = dot(g11, (p - floor(vec2(p.x + 1.0, p.y + 1.0))));\n\n    // blend quad corners to a single value\n#if 0 // linear interpolation\n    vec2 w = p - floor(p);\n#elif 1 // hermite blend as propsed by Perlin\n    vec2 w = smoothstep(0.0, 1.0, p - floor(p));\n#else // fifth degree polynomial as propsed by Perlin for simplex noise \n    vec2 w = p - floor(p);\n    w = 6.0 * w * w * w * w * w - 15.0 * w * w * w * w + 10.0 * w * w * w;\n#endif\n    float nx0 = n00 + w.x * (n10 - n00);\n    float nx1 = n01 + w.x * (n11 - n01);\n    float n = nx0 + w.y * (nx1 - nx0);\n\n    vec3 c00 = length(g00) * id2colour(ivec2(p));\n    vec3 c01 = length(g01) * id2colour(ivec2(p) + ivec2(0,1));\n    vec3 c10 = length(g10) * id2colour(ivec2(p) + ivec2(1,0));\n    vec3 c11 = length(g11) * id2colour(ivec2(p) + ivec2(1,1));\n    vec3 c = mix(mix(c00, c10, w.x), mix(c01, c11, w.x), w.y);\n\n    return vec4(normalize(c), n);\n}\n\nfloat arrow(vec2 from, vec2 dir, vec2 p)\n{\n    if (dot(p - from, dir) < 0.0) return 0.0;\n    if (2.0 * length(p - from) > length(dir)) return 0.0;\n\n    vec2 tangent = normalize(vec2(-dir.y, dir.x));\n    return smoothstep(2.0 * fwidth(p.x), 0.0, abs(dot(p - from, tangent)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = screen_to_pos(fragCoord, iResolution);\n    bool norm_mode = texelFetch(iChannel1, ivec2(78,2), 0).x == 0.0;\n    bool snap_mode = texelFetch(iChannel1, ivec2(81,2), 0).x != 0.0;\n\n    vec4 n = perlin(p, norm_mode, snap_mode);\n    fragColor.rgb = vec3(0.5 * n.w + 0.5);\n\n    // colour influence\n    if (texelFetch(iChannel1, ivec2(67,2), 0).x != 0.0) {\n        fragColor.rgb *= n.rgb;\n    }\n\n    // highlight zero value\n    if (texelFetch(iChannel1, ivec2(48,2), 0).x == 0.0) {\n        fragColor.rgb += vec3(smoothstep(fwidth(n.w), 0.0, abs(n.w)));\n        //fragColor.g += smoothstep(fwidth(n.w), 0.0, abs(n.w - 0.25));        \n        //fragColor.b += smoothstep(fwidth(n.w), 0.0, abs(n.w + 0.25));\n    }\n\n    // grid\n    if (texelFetch(iChannel1, ivec2(71,2), 0).x != 0.0) {\n        vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n        fragColor.rgb += vec3(1.0 - min(min(grid.x, grid.y), 1.0));\n    }\n\n    // gradient\n    vec2 grad = load_gradient(round(p), norm_mode, snap_mode);\n    fragColor.r += arrow(round(p), grad, p);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XlXcW4\nvec2 hash( vec2 v )\n{\n    uvec2 x = uvec2(v);\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yx)*k;\n    \n    v = vec2(x)*(1.0/float(0xffffffffU));\n    return 2.0 * v - vec2(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 grad = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n\n    // set random gradints on start or if 'r' is pressed\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(82,1), 0).x > 0.) {\n        grad = hash(fragCoord + vec2(iFrame) + vec2(30.0, 0.0));\n    } else {\n        if (iMouse.z > 0.0) {\n            // set the closest gradient towards mouse\n            vec2 mouse = screen_to_pos(iMouse.xy, iResolution);\n            if (round(mouse) == floor(fragCoord)) {\n                grad = 2.0 * (mouse - floor(fragCoord));\n                float l = length(grad);\n                if (l > 1.0) grad /= l;\n            }\n        }\n    }\n\n    fragColor = vec4(grad, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 screen_to_pos(vec2 p, vec3 resolution)\n{\n    return 5.4 * p / resolution.y;\n}\n","name":"Common","description":"","type":"common"}]}