{"ver":"0.1","info":{"id":"Nstczf","date":"1653851019","viewed":125,"name":"Our pride (Twitch)","username":"rimina","description":"A shader inspired one ribbon installation I saw in an art exhibition some time ago. Did this during my live coding stream on 19th of May 2022.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\n//Huge thanks to the live coding community,\n//I've learned so much from you!!\n\n//Some of the methods used are from IQ and from Dave Hoskins. Thank you so much for providing these methods!\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 70;\n\nconst vec3 FOG_COLOR = vec3(0.05, 0.01, 0.2);\n\nvec3 coll = vec3(0.5);\nvec3 cols = vec3(0.6);\n\n//function from https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n    return a + b*cos(6.28318 * (c*t+d) );\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid bound(float start, float stop, float off, inout float c, inout float p){\n    if(c > stop){\n        p += off*(c-stop);\n        c = stop;\n    }\n    if(c < start){\n        p += off*(c-start);\n        c = start;\n    }\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n\n    vec3 off = vec3(1.0, 2.0, 1.0);\n    vec3 c = floor((p + off*0.5)/off);\n\n    if(mod(c.x, 2.0) == 0.0 && mod(c.z, 2.0) == 0.0){\n        pp -= vec3(0.0, iTime*0.1, 0.0);\n    }\n    else{\n        pp -= vec3(0.0, -iTime*0.1, 0.0);\n    }\n\n    pp = mod(pp + off*0.5, off) - off*0.5;\n\n    bound(-8.0, 8.0, off.z, c.z, pp.z);\n    bound(-5.0, 5.0, off.x, c.x, pp.x);\n\n    float a = iTime*0.25+length(c.xz)*2.0;\n    if(mod(c.x, 2.0) == 0.0 && mod(c.z, 2.0) == 0.0){\n        rot(pp.xz, a);\n    }\n    else{\n        rot(pp.xz, -a);\n    }\n\n    float block = box(pp, vec3(0.1, 0.95, 0.1));\n\n    //vectors from https://iquilezles.org/articles/palettes/\n    coll = palette(hash12(c.xz)*60.0, vec3(0.5),\n        vec3(0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.2, 0.25));\n\n    return block;\n}\n\nfloat march(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float t = E;\n\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t += d;\n        p = ro + rd * t;\n\n        if(d < E || t > FAR){\n            break;\n        }\n    }\n\n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec3 e = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        scene(p+e.xyy) - scene(p-e.xyy),\n        scene(p+e.yxy) - scene(p-e.yxy),\n        scene(p+e.yyx) - scene(p-e.yyx)\n    ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 ld){\n  vec3 n = normals(p);\n  \n  float l = max(dot(n, ld), 0.0);\n  \n  float a = max(dot(reflect(rd, ld), n), 0.0);\n  float s = pow(a, 40.0);\n  \n  return coll*l + cols*s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0 + 2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(8.0*sin(iTime*0.025), 1.6, 12.0*cos(iTime*0.025));\n    vec3 rt = vec3(0.0, 1.25, -1.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(q, 1.0/radians(50.0)));\n\n    float t = march(ro, rd);\n    vec3 p = ro + rd * t;\n\n    vec3 ld = normalize(ro-rt);\n\n    vec3 col = vec3(0.0);\n    if(t < FAR){\n        col = shade(rd, p, ld);\n    }\n\n    float d = distance(p, ro);\n    float amount = 1.0 - exp(-d*0.06);\n\n    col = mix(col, FOG_COLOR, amount);\n    col = smoothstep(-0.2, 1.2, col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}