{"ver":"0.1","info":{"id":"WtVGWm","date":"1579104059","viewed":132,"name":"Dist 2D","username":"spalmer","description":"simple test of basic signed distance field shape functions using mouse","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Dist 2D !\n\n// for debugging 3d-style signed distance methods\n// in 2 dimensions where the problems\n// are simpler and easier to visualize\n\n// see Common tab for shape functions\n\n// \"standard\" sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = StoQ(p, R);\n    vec2 m = StoQ(iMouse.xy, R);\n    vec2 mo = iMouse.z < 0. ? m : StoQ(iMouse.zw, R);\n    float brad = .25;\n    vec2 qs = q / brad; // main object scale\n    float sd; // signed distance to shape from q\n    sd = dshape(qs) * brad;\n    float md; // signed distance to shape from m\n    md = dshape(m / brad) * brad;\n    vec2 la = mo, lb = m;\n    vec2 ld = normalize(lb - la); // good chance ld will be nans if mouse isn't down.\n    float d = 3.4e38; c.rgb = vec3(0.); // bg\n    DR(d, c.rgb, sd, vec3(.8,.4,0)); // draw actual shape by its sdf\n    bool missed = md > 0.; // if mouse not held inside shape\n    // color bg depending on \n    vec3 chit = missed ? vec3(.5,.0,.0) : vec3(0.,.5,.0);\n    \n    DR(d, c.rgb, dball((q - la) * 150.)/150., .9*chit);\n//    DR(d, c.rgb, dline(q, la, lb) - .002, .6*chit);\n    float cov = clamp(.5-.125*R.y*d, 0., 1.); // antialias edge linearly\n    vec3 cbg = vec3(0.,0.,.2); // btw coverage is important for bg blending\n    if (missed) cbg = vec3(.2,.0,.0);\n    c.rgb = mix(cbg, c.rgb, cov);\n#if 1 // iq-ish sinusoid isocontours\n    c.rgb = DebugSDF(sd); // iq's sdf visualizer\n    if (!missed) c.rgb = 1.-c.bgr; // \"reverse\" preserving hue\n#elif 1 // debug isocontours\n    c.gb += .25 * exp2(-R.y*abs(abs(sd)-.25));\n#elif 1 // debug isocontours alt\n    c.gb += .125 * (.5 + .5 * sin(75.*sd)) * (1.-exp2(-3.*abs(sd)));\n#endif\n\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n// TODO instead of the inside-outside test,\n// more useful would be a magnifier feature\n\n// TODO fake lighting by gradient\n\n//    DR(d, c.rgb, dplaine(q, vec2(0.,-.5), vec2(.5, -.5)), vec3(1,1,0));\n//    tdbg = vec3(1,0,1);\n\n//    if (sd <= 0.) c.g += .2; // fine\n//    DR(d, c.rgb, ddiamond((q - lb) * 150.), .9*chit);\n//    if (missed)\n//    {}//    DR(d, c.rgb, dball((q - mix(la, lb, -.01)) * 50.), vec3(1.,.0,.0));\n//    else {\n   //     DR(d, c.rgb, ddiamond((q - lh) * 50.)/50., vec3(.7,.9,.9));\n    //    DR(d, c.rgb, dball((q - (lb+ld*.5*lt)) * 2./sd), vec3(0,.1,0)); // tricky sdf debugging tool\n//    }\n\n//\tfloat t = tball(la / brad, normalize(lb-la)) * brad;\n//\tif (!(lt < 99.)) cbg = vec3(.0,.2,.0); // hardly ever happens, not so useful\n /*   if (lt == 0.) cbg = vec3(.1,.2,.1);\n    if (isnan(lt)) cbg = vec3(.2,.0,.2);\n    if (isnan(d)) cbg = vec3(.5,.0,.1);\n*/\n\n//     c.rgb = .5 + .5 * cos(iTime+q.xyx+vec3(0,2,4));\n\n\n#if 0\n\tvec3 tdbgx, tdbgy; // color debug swatches so I can see what fns are returning\n    if (distance(vec2(-1.65,-.9), q) < .05)\n\t\tc.rgb = tdbgx;\n     if (distance(vec2(-1.45,-.9), q) < .05)\n\t\tc.rgb = tdbgy;\n#endif\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// it would be silly not to credit iq with something here.\n// idk, I've studied his sdf functions for years.\n// but none of this so far is really his work.\n// I just whipped it all together from scratch one day.\n// He doesn't do things this way, anyhow;\n// I use more of a high-level approach here,\n// much more reuse of functions by other shapes.\n// Greatly refactored already.\n\nconst float pi = acos(-1.); //3.141592;\n\n// involves extra add by zero for one component, which should optimize away.\nconst vec2 phase90 = vec2(.5*pi, 0);\n\n// aspect-correct windowing; idk who invented the technique; seen all over shadertoy.com these days; most don't package up into a function though.\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n// utility\n\n// e^(i*rads) Euler's formula complex spinor; I hate typing out vec2(cos(rads), sin(rads)) which repeats the argument\n//vec2 cossin(float rads)\n//{\n//    return sin(phase90 + rads);\n//}\n// could just\n//\tconst vec2 phase90 = vec2(.5*pi, 0);\n// then simply \n//\tsin(phase90 + rads)\n// in fact that's *better*, as it results in a compile-time constant, but cossin does not\n\nfloat sabs(float x, float k)\n{\n    return x * mix(sign(x), x, exp2(-k*abs(x))); // FIXME should not need mix\n//    return a - sqrt(a * a + .01/k));\n}\n// from a note on wikipedia page for Smooth maximum; seems to work great!\nfloat smin(float a, float b, float k)\n{\n    return .5*(a + b - sqrt(dot(a-b, a-b) + .01/k));\n}\n\nfloat smax(float a, float b, float k)\n{\n    return .5*(a + b + sqrt(dot(a-b, a-b) + .01/k));\n//    return -smin(-a, -b, k);\n}\n// btw sqrt is the most efficient way to implement this, apparently\n\nvec2 latheX(vec2 p) { return vec2(abs(p.y), p.x); }\nvec2 latheY(vec2 p) { return vec2(abs(p.x), p.y); }\n\nvec2 lathe(vec2 p, vec2 b) // any axis\n{\n\tfloat l = length(b);\n\tfloat y = dot(p, b) / l;\n\tfloat x = length(p - y / l * b);\n\treturn vec2(x, y);\n}\n\n// signed distance\n\n// breaking things down to 1d cases is how I roll\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n// in 1d, a box, sphere, and slab are all equivalent\n// so I don't even really know what to call it.\n\n// after simple point (length),\n// ball's the easiest for distance\nfloat dball(vec2 p)\n{\n    return length(p) - 1.;\n}\n\n// distance to line segment ab from p\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - b*clamp(dot(p,b)/dot(b,b), 0., 1.));\n}\n\nvec2 nseg(vec2 a, vec2 b)\n{ // FIXME this normalize definitely breaks a==b case but caller\n    vec2 d = normalize(b - a); // should be able to test for nan as usual, right?\n \treturn vec2(-d.y, d.x); // perp 90 degree rotation\n}\n// point a fixed at origin, q and b relative origin\nfloat dpline(vec2 q, vec2 b)\n{\n    return dot(q, nseg(vec2(0), b)); // perpdot of segment normal\n}\n\nfloat dline(vec2 p, vec2 a, vec2 b)\n{\n    return abs(dpline(p - a, b - a));\n}\n// you could think of a 2D slab as a perpendicular line;\n// these concepts have considerable overlap in low dimensions.\nfloat dslab(vec2 q, vec2 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dslab(vec2 q, vec2 n, float h)\n{\n    return abs(dot(q, n)) - h;\n}\n\nfloat dslabx(vec2 q)\n{\n    return dslab(q, vec2(1, 0));\n}\n\nfloat dbox(vec2 q)\n{ // probably easier to just go ahead and fold space more, for distance calcs\n    // using similar mechanisms to the tracers is bound to be relatively inefficient.\n    const float w = 1.; //sqrt(.5); // so it fits inside unit disc bound \n    float d = //-3.4e38;\n    //d = max(d, \n        // FIXME I know the compiler can optimize these dot products with constants after inlining\n        // but it's still sloppy to rely on compiler optimizations in perf-critical code.\n        // Slows down debug builds for one thing.\n            dslab(q, vec2(1, 0)); //);\n    d = max(d, dslab(q, vec2(0, 1)));\n \td += 1. - w;\n    if (d > 0. && // early out, don't bother unless outside\n    \tall(lessThan(vec2(w), abs(q)))) // in corner voronoi regions\n        d = distance(vec2(w), abs(q)); // must replace distance\n    return d;\n}\n\n// even better:\nfloat dBox(vec2 q, vec2 e)\n{\n    q = abs(q) - e;\n    return any(lessThan(q, vec2(0))) ? max(q.x, q.y) : length(q);\n}\n\n// a rounded box is easy enough to get by poofing the unit box.\n// diamond's good now, also.\n\n// better!!!\nfloat ddiamocta(vec2 q)\n{\n\tq = abs(q); q = vec2(max(q.x, q.y), min(q.x, q.y));\n\treturn q.x - 1. > q.y \n\t\t? length(q - vec2(1,0))\n\t\t: sqrt(.5)*(q.x - 1. + q.y);\n} // TODO needs small effort to make 3D version\n// dot(q, sqrt(.5)) - 1. is a basic sharp N-D octahedronesque shape btw\n// older, not as nice, built atop dslab which in turn uses dbox, it's really long-winded and hard to follow.\n// main problem is it does not break down the coordinate properly first,\n// so is left with a more complicated situation.\nfloat ddiamond(vec2 q)\n{\n    const float rh = sqrt(.5); // rh corrects scale due to use of taxi metric\n    // taxi metrix works for the slab but not for the return value\n    float d = //-3.4e38; \n    //d = max(d,\n        dslab(q, vec2(1, 1))*rh; //);\n    d = max(d, dslab(q, vec2(1,-1))*rh);    \n    if (d > 0. && // early out, don't bother unless outside\n    \tabs(dot(abs(q), vec2(1,-1))) > 1.    \n\t    )\n        d = min(distance(abs(q), vec2(1,0)) // FIXME should be some clever way to mirror and combine these tests\n    \t\t  , distance(abs(q), vec2(0,1)));\n    return d;\n}\n\n// FIXME none of my voronoi patching is working for these, yet\n// so these shapes are all exceedingly sharp at the corners,\n// meaning you can't poof (iso-inflate, subtract) them to make them round.\n// Can't easily poof traces either, so... it's fine I guess.\n// Feels lazy though.\n\nfloat dhexagon(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(.8660254, .5)));\n    d = max(d, dslab(q, vec2(.8660254,-.5)));\n    d = max(d, dslab(q, vec2(     0, 1)));\n    // TODO corner voronoi\n//    if (d > 0.) d = max(d, distance(abs(q), vec2(1,0)))\n//    \t\t  , d = max(d, distance(abs(q), vec2(.5,.866254)));\n   // d += 1. - sqrt(.8); //.89442719 = 1/sqrt(1*1+.5*.5)\n    return d;\n}\n\nfloat doctagon(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(1   )*.707107));\n    d = max(d, dslab(q, vec2(1,-1)*.707107));\n    d = max(d, dslab(q, vec2(        1, 0)));\n    d = max(d, dslab(q, vec2(        0, 1)));\n//    if (d > 0.) d = min(d, distance(abs(q), vec2(.258819,.965926)))\n//    \t\t  , d = min(d, distance(abs(q), vec2(.965926,.258819)));\n    //d += 1. - sqrt(.75); //.8660254;\n    return d;\n}\n\n// rhombus test - similar to ddiamo but bigger\nfloat drhomb(vec2 p)\n{\n    p = abs(p);\n    const float r = sqrt(.5), R = sqrt(2.);\n    if (p.y < p.x - 1.5) return length(p - vec2(1.5,0));\n    if (p.x < p.y - 1.5) return length(p - vec2(0,1.5));\n    float d0 = dslab(p, vec2(r,r), r * 1.5); // - 0.07; //vec2(1,1)) * r; //(1. - r); //(R - 1.);\n    return d0;\n}\n// without vertex voronoi test\nfloat dpieYsharp(vec2 p, vec2 cs)\n{\n\tp.x = abs(p.x);\n\treturn length(p - cs.yx * dot(p, cs.yx)) \n\t    * sign(cs.x*p.x - cs.y*p.y);\n}\n//pdot(sc, p) //dot(cs, perp(p)) //\n// along +Y\nfloat dpieY(vec2 p, vec2 cs)\n{\n    float x = dpieYsharp(p, cs);\n    return -abs(p.x)*cs.y > p.y ? max(length(p), x) : x;\n}\n\nfloat dpie(vec2 p, vec2 d, vec2 cs) // arc? beam? cone2D? cs = cos&sin of the aperture\n{\n    return dpieY(lathe(p, d), cs); // unrotate so d -> y\n}\n\nfloat dstar5(vec2 q)\n{\n    q.x = abs(q.x); // symmetry\n    const vec2 cs = sin(phase90 + radians(18.))\n    , po0 = vec2(0,1)\n    , po1 = sin(phase90.yx + .4*pi)\n    , po2 = sin(phase90.yx + .8*pi);\n    float d1 = dpie(q - po1, -po1, cs)\n        , d2 = max(q.y-.5, dpie(q - po2, -po2, cs))\n        , d0 = dpieY(po0 - q, cs)\n    , d = 3.4e38;\n    if (dot(q, po1) > 0.) d = d1;\n    if (dot(q, po2) > 0.) d = min(d, d2);\n    if (dot(q, po0) > 0.) d = min(d, d0);\n    return d;\n}\n\nfloat dpyras(vec2 q)\n{\n    q.x = mod(q.x + 9., 4.) - 2.;\n    q.x = abs(q.x);\n    float dp = (q.y + q.x - 1.) * sqrt(.5);\n    if (q.y > q.x + 1.) dp = length(q-vec2(0,1));\n    float r = min(dp, q.y);\n    return r;\n}\n// round quarter pipes, flat top\n// various riffs on the idea can make various round bevels/chamfers/whatever\nfloat dpipe(vec2 q)\n{\n//  q.x = abs(q.x);\n    if (q.x >= max(1., q.y)) return q.y;\n    if (q.x <= 0. && q.y >= q.x + 1.) return q.y - 1.;\n    if (q.y >= 1.) return distance(q, vec2(0, 1));\n    return 1. - distance(q, vec2(1));\n}\n// now for how to use it to help make linear ramps into round pipes?\n// could probably make it thicker somehow\n// but I want to leave such things up to the caller so it stays -1..1 local scale\n//    if (any(greaterThanEqual(q, vec2(1)))) return 1. + length(q - 1.);\n// TODO now how to *trace* with ray, analytically? lol\n// it's the CSG of a few simple primitives.\n\n// simple unit circle\n\nfloat ddisc(vec2 p, vec2 c, float r)\n{\n    return length(p - c) - r;\n}\n\n\n// an axis-aligned cylinder is just a box in 2d\n\n// TODO lathe, loft, etc.\n\n// been watching Art of Code :)\n// still don't understand gyroids, especially in 2D they seem different.\nfloat dgyroid2(vec2 p) //, float r)\n{\n    float r = 6.;\n    p *= r;\n    return dot(sin(p*vec2(1,-1)), cos(p.yx*1.1)) / r;\n}\n\n// TODO I intend to convert it to exponentiation vs. iteration\n// but it already is exponentiating! atan,length + radius*(cos,sin) = pow of complex\n#if 1 // mandelbulb originally from https://shadertoy.com/view/3ttSWf\n// is now 2D!!! so it's a mandelbrot with adjustable exponent\nfloat dmandelbulb2(vec2 pos)\n{\n    pos.x -= .5; // center within bound disc\n    // FIXME ideally would have a smoothing mix zone\n    // in fact TODO may as well abstract out the LOD disc\n    //if (dot(pos,pos) >= 1.7*1.7) return length(pos)-1.3; // LOD sphere approx when query far away\n    //pos *= 1.3; // fit into unit disc\n    vec2 z = pos;\n\tfloat dr = 1.;\n\tfloat r;\n    r = length(z);\n\t// gives Power - 1 rotated mandelbrot sets! Unsure why off by one etc. but hey.\n    const float Power = 2.; //7.; // get Power - 1 \"bulbs\" but powers below 2 are not interesting; need at least 2 to get a mandelbrot set at all.\n\tfor (int i = 0; i < 9; ++i) {\n\t\tdr = pow(r, Power - 1.)*Power*dr + 1.; // some way to approximate distance, I don't understand yet\t\n\t\tfloat theta = atan(z.y, z.x);\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta * Power;\n\t\t// convert back to cartesian coordinates to recompute r? agh\n\t\tz = zr * vec2(cos(theta), sin(theta));\n\t\tz += pos;\n        r = length(z);\n\t\tif (r > 1.5) break;\t\t\n\t}\n\treturn .7 * log(r) * r / dr; // - .002; // there is no \"inside\" gradient, just zeroes there, so can't poof or anything.\n    // / 1.3\n}\n    // FIXME the thing preventing me from staying polar\n    // is the \"z += pos;\" addition of a cartesian vector, would need to polarify, and that's not trivial either\n#endif\n\n#if 0 // trying to stay cartesian using complex exponentiation instead of polar / mat2; not yet generalized to arbitrary Power\nfloat dmandelbulbE2(vec2 pos) \n{\n//    pos.x -= .5; // center within bound disc\n    // FIXME ideally would have a smoothing mix zone\n    // in fact TODO may as well abstract out the LOD disc\n    if (dot(pos,pos) >= 1.7*1.7) return length(pos)-1.3; // LOD sphere approx when query far away\n    vec2 z = pos; //vec2(0); // maybe waste an iteration?\n\tfloat dr = 1.;\n\tfloat r = 0.;\n    const float Power = 2.; //3.; //4.; // get Power - 1 \"bulbs\" but very few (<=2) bulbs are much less interesting; need at least 3 or 4\n\tr = length(z);\n//    vec2 cs = vec2(-z.x, z.y); //-z.y, z.x); // -? swap?\n//    mat2 spin = mat2(cs.x, -cs.y, cs.y, cs.x);\n    //vec2 vlog = vec2(atan(cs.y, cs.x), length(cs)); // TODO complex log\n    //vec2 vexp; // TODO complex spinor * scaler\n\tfor (int i = 0; i < 9; ++i) { // odd # iter may behave better somehow?\n\t\tdr = pow(r, Power - 1.) * Power*dr + 1.;\t// some way to approximate distance, I don't understand yet\t\n\t    vec2 cs = vec2(z.x, -z.y); //-z.y, z.x); // -? swap?\n        // yeah but by time I do complex log and exp to exponentiate this properly,\n        // I'm basically back to where iq and everybody are, with all the trigonometry transcendental computation.\n        // really hard to exponentiate a matrix though, so this is the wrong approach for sure.\n\t    mat2 spin = mat2(cs.x, -cs.y, cs.y, cs.x); // only problem is it's hardcoded to Power==1.\n        // in fact since it seems we must pow a different complex each iteration,\n        // there's nothing that may even be precomputed.  Ouch!\n        //spin *= spin; // Power==3. this way only supports even powers of two\n\t\t//spin *= spin; // Power==4.\n\t\t// scale and rotate the point\n\t\t//float zr = pow(r, Power);\n\t\t//theta = theta * Power;\n        z = spin * z;\n\t\t//z = zr * vec2(sin(theta), cos(theta));\n\t\tz += pos; // the constant term is also pos\n        r = length(z);\n\t\tif (r > 1.5) break;\n\t\t//theta = atan(z.y, z.x);\n\t}\n//    if (length(r) < 1.5) return -0.01;\n\treturn .7 * log(r) * r / dr;// - .002; // there is no real \"inside\" gradient, mostly zeroes there, so can't poof or anything.\n}\n#endif\n\n\nfloat dshapehid(vec2 q)\n{\n    return\n    //    dseg(q, vec2(-1,-1), vec2(1,1));\n    //    dslabx\n    //    dpipe\n    //    dpyras\n    //    dball\n    //    dbox\n    //    ddiamocta\n    //    ddiamond\n    //    dgyroid2\n    //    dhexagon\n    //    drhomb\n    //    doctagon\n        dstar5\n    //    dmandelbulb2\n    //    dmandelbulbE2\n        (q);\n}\n\nfloat dshapelod(vec2 q)\n{\n    //return q.y - 1.; // for dpipe, dpyras\n    return length(q) - 2.; //1.5; //\n    \t//dball\n    \t//dbox\n        //(q);\n}\n\n// maybe instead of using a *unit* disc as the lod shape, \n// necessitating rescaling the other shapes away from their \n// natural size so they'll fit, should just use one \n// that's actually bigger than the regularly-sized objects\n// (about *1.12) or even the mandelbrot (about 1.4?)\nfloat lodshape(float dshape, float dlod, float fade)\n{\n    return dshape; // HACK disable lod for perfect distances (just expensive when far away from them)\n    float b = dlod; // no abs\n    if (b >= fade) return dlod;\n    if (b <= 0.) return dshape;\n    return mix(dshape, dlod, b / fade); //pow(b / fade, .7)); //clamp(b / fade, 0., 1.));\n}\n    //float a = abs(dshape);\n\nconst float fade = 3.; //, slab = 1.;\n\nfloat dshape(vec2 q)\n{\n    return lodshape(dshapehid(q), dshapelod(q), fade);\n    return dshapehid(q); // no lod (certain shapes can't use it anyway)\n}\n\n// beware dangling else issues; use {} just in case, requires do to allow trailing semicolon\n#define DR(od, oc, nd, nc) \\\ndo { float _nd = (nd); \\\n    if (_nd < 0. || _nd < od) od = _nd, oc = nc; \\\n    } while(false)\n// want most recent negative one, not \"most inside\",\n// for overpainting, just for this test!\n\n/*!isnan(_nd) && !isinf(_nd) &&*/\n/*_nd < od) od = _nd, oc = nc;*/\n/*if (() <= .5)*/ // was trying to figure out why the first use always replaced the color\n    // well, it's because that's how it works unless you explicitly test against that case\n    // this is all because I tried to avoid using the coverage mechanic for some reason. Duh.\n\n\n\n// TODO need my LOD approximation helpers for clipping to slab, box, disc\n    \n    \n\n\n\n\n","name":"Common","description":"","type":"common"}]}