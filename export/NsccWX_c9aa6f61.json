{"ver":"0.1","info":{"id":"NsccWX","date":"1665323189","viewed":169,"name":"Median Filter __","username":"Envy24","description":"Kernel order can be changed in Common tab, line 7.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["filter","median","dilate","erode","binarysearch","quickselect","quicksort","radixsort","shakersort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define READ_PIXEL(SC) (TEX0(TO_TEX_COORDS(SC)))\n\nfloat average(vec4 color)\n{\n    return (color.x + color.y + color.z) * 0.3333333;\n}\n\nvoid fill_buffers(\n    inout float kernel[num_of_elements],\n    inout vec2 coords[num_of_elements],\n    in vec2 SC)\n{\n    float O = float(order);\n    int rw_offset = 0;\n    for (float r = -O; r <= O; r += 1.)\n    {\n        for (float c = -O; c <= O; c += 1.)\n        {\n            coords[rw_offset] = SC + vec2(r, c);\n            kernel[rw_offset] = average(READ_PIXEL(coords[rw_offset]));\n            \n            ++rw_offset;\n        }\n    }\n}\n\nvoid shaker_sort(\n    inout float kernel[num_of_elements],\n    inout vec2 coords[num_of_elements])\n{\n    int C = 0;\n    for (int L = num_of_elements - 1, E = 1; L > E; --L, ++E)\n    {  \n        while (C < L)\n        {\n            if (kernel[C] > kernel[C + 1])\n            {\n                vec2 P = coords[C]; coords[C] = coords[C + 1]; coords[C + 1] = P;               \n                float A = kernel[C]; kernel[C] = kernel[C + 1]; kernel[C + 1] = A;\n            }\n            \n            ++C;\n        }       \n        --C;\n        \n        while (C >= E)\n        {\n            if (kernel[C - 1] > kernel[C])\n            {\n                vec2 P = coords[C - 1]; coords[C - 1] = coords[C]; coords[C] = P;               \n                float A = kernel[C - 1]; kernel[C - 1] = kernel[C]; kernel[C] = A;\n            }\n            \n            --C;\n        }\n        C=E;\n    }\n}\n\nvoid radix_sort(inout float array[num_of_elements])\n{\n    const int max_num_of_digits = 3;\n    const int base = 10;\n\n    int temp[num_of_elements];\n    int digits_array[10];\n    int power = 1;\n\n    for (int k = 0; k < max_num_of_digits; ++k)\n    {\n        for (int i = 0; i < 10; ++i) { digits_array[i] = 0; }\n    \n        for (int i = 0; i < num_of_elements; ++i)\n        {\n            int value = int(array[i]);\n            int digit = (value / power) % base;\n            ++digits_array[digit];\n            temp[i] = value;\n        }\n\n        for (int i = 0; i < 9; ++i)\n        {\n            digits_array[i + 1] += digits_array[i];\n        }\n        \n        for (int i = num_of_elements - 1; i >= 0; --i)\n        {\n            float value = float(temp[i]);\n            int digit = (temp[i] / power) % base;\n            array[--digits_array[digit]] = value;\n        }\n        \n        power *= base;\n    }\n}\n\nvoid quick_sort(inout float array[num_of_elements])\n{\n    int pairs[2 * num_of_elements], rw_offset = 0;\n\n    pairs[rw_offset++] = 0; pairs[rw_offset++] = num_of_elements - 1;\n\n    while (rw_offset != 0)\n    {\n        /* Tony Hoare's partition. */\n        int high = pairs[--rw_offset], low = pairs[--rw_offset];\n\n        float pivot = (array[low] + array[high]) * 0.5;\n        int i = low, j = high;\n\n        for (int k = 0; k < num_of_elements; ++k)\n        {\n            while (array[i] < pivot) { ++i; }\n            while (array[j] > pivot) { --j; }\n\n            if (i >= j) { break; }\n\n            float t = array[i]; array[i] = array[j]; array[j] = t;\n            ++i; --j;\n        }\n        /* Tony Hoare's partition. */\n\n        if (low < j) { pairs[rw_offset++] = low; pairs[rw_offset++] = j; }\n        if (j + 1 < high) { pairs[rw_offset++] = j + 1; pairs[rw_offset++] = high; }\n    }\n}\n\n/* I tried to merge kernel and coords in one array of vec3, but\nit works slower, than this. */\nvec4 quick_select(\n    in float kernel[num_of_elements],\n    in vec2 coords[num_of_elements],\n    in int desired_idx)\n{\n    float buffer[2 * num_of_elements];\n    int lows_offs = 0, highs_offs = num_of_elements;\n\n    // Copy kenrel to lower part of buffer.\n    for (int i = 0; i < num_of_elements; ++i) { buffer[i] = kernel[i]; }\n\n    int source_offs = lows_offs;\n    int num_of_elements_ = num_of_elements;\n    int desired_idx_ = desired_idx;\n    float pivot = 0.;\n\n    // max_num_of_iter used for safety reasons, glsl compiler can crash\n    // if you use infinite cycles like \" while(true) \", but on CPU\n    // you can use infinite cycles.\n    // If you see noise, try to increase max_num_of_iter.\n    for (int i = 0, max_num_of_iter = 20; i < max_num_of_iter; ++i) \n    {\n        pivot = buffer[source_offs + desired_idx_];\n        int lows_count = 0, highs_count = 0, pivots_count = 0;\n\n        for (int i = 0; i < num_of_elements_; ++i)\n        {\n            float element = buffer[source_offs + i];\n            \n            // element should be puted in lower part?\n            if (element < pivot) { buffer[lows_offs + lows_count++] = element; }\n            // element should be puted in higher part?\n            else if (element > pivot) { buffer[highs_offs + highs_count++] = element; }\n            else { pivots_count++; }\n        }\n\n        // desired element can be found in lower part?\n        if (desired_idx_ < lows_count) {\n            source_offs = lows_offs;\n            num_of_elements_ = lows_count;\n        }\n        // desired element founded (pivot)?\n        else if (desired_idx_ < (lows_count + pivots_count)) { break; }\n        // derised element can be founded in higher part.\n        else \n        { \n            source_offs = highs_offs;\n            num_of_elements_ = highs_count;\n            desired_idx_ -= (lows_count + pivots_count);\n        }\n    }\n    \n    int median_idx = 0;\n    for (; (median_idx < num_of_elements) && (pivot != kernel[median_idx]); ++median_idx) { }\n\n    return READ_PIXEL(coords[median_idx]);\n}\n/**/\n\nvec4 binary_search_median(\n    in float kernel[num_of_elements],\n    in vec2 coords[num_of_elements],\n    in int desired_idx)\n{\n    // step 1: binary search\n    float a = 0., b = 1.;\n    for (int i=0 ; i<12; ++i)\n    {\n        float m = (a + b) / 2.;\n        int sum = 0;\n        for (int j=0 ; j<num_of_elements ; ++j)\n            sum += int(kernel[j] < m);\n        if (sum >= desired_idx)\n            b = m;\n        else\n            a = m;\n    }\n    //return vec4(a);\n    // step2: find closest index\n    int median_idx = 0;\n    for (int i=1 ; i<num_of_elements ; ++i)\n        if (abs(kernel[i] - a) <= abs(kernel[median_idx] - a))\n            median_idx = i;\n    return READ_PIXEL(coords[median_idx]);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    fill_buffers(kernel, coords, SC);\n    \n    /*Shaker sort (slowest method) *\n    shaker_sort(kernel, coords);\n    O = READ_PIXEL(coords[num_of_elements >> 1]);\n    \n    /*Radix or Quick sort*\n    float copy[num_of_elements];\n    for (int i = 0; i < num_of_elements; ++i) \n    { \n        kernel[i] = floor(kernel[i]*255.); // map from [0; 1] to [0; 255]\n        copy[i] = kernel[i];\n    }\n    radix_sort(copy); // faster than quick sort\n    //quick_sort(copy); // slower than radix sort\n    float median = copy[num_of_elements >> 1];\n    int median_idx = 0;\n    while((median_idx < num_of_elements) && (median != kernel[median_idx])) { ++median_idx; }\n    O = READ_PIXEL(coords[median_idx]);\n    \n    /*Quick select*\n    O = quick_select(kernel, coords, num_of_elements >> 1);\n    /*PyBlob's binary_search (fastest method)*/\n    O = binary_search_median(kernel, coords, num_of_elements >> 1); // median\n    //O = binary_search_median(kernel, coords, 0);                    // erode\n    //O = binary_search_median(kernel, coords, num_of_elements - 1);  // dilate\n    /**/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n\n#define DO_NOT_CHANGE 1\nconst int order = max(DO_NOT_CHANGE, 4);\nconst int row_length = order * 2 + 1;\nconst int num_of_elements = row_length * row_length;\nfloat kernel[num_of_elements];\nvec2 coords[num_of_elements];","name":"Common","description":"","type":"common"}]}