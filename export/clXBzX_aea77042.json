{"ver":"0.1","info":{"id":"clXBzX","date":"1693234224","viewed":77,"name":"Ray Marching Fractal & Shading","username":"Anto_Crasher555","description":"Made from https://www.shadertoy.com/view/mtlBz2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCH_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE_THRESHOLD 0.0005\n#define EPSILON 0.0001\n#define TAU 6.283185\n#define PI 3.141592\n\n#define COLOR_SCALE  22.118\n#define COLOR_OFFSET 1.89\n\n#define COLOR_A 0.500, 0.500, 0.500\n#define COLOR_B 0.500, 0.500, 0.500\n#define COLOR_C 1.000, 1.000, 1.000\n#define COLOR_D 0.000, 1.058, 0.058\n\nstruct PointLight {\n    vec3 center;\n    float intensity;\n    vec3 color;\n};\n\nstruct MarchRayRet {\n    float dist;\n    vec3 normal;\n    vec3 hitPoint;\n    vec3 color;\n    float reflectivity;\n};\n\nstruct MarchRet {\n    float dist;\n    vec3 normal;\n    vec3 color;\n    float reflectivity;\n};\n\nstruct RayMarchRet {\n    vec3 final;\n};\n\nstruct RayMarchingRet {\n    float dist;\n    float color;\n};\n\nstruct ReflectionBounceRet {\n    vec3 shaded;\n    vec3 reflected;\n    vec3 normal;\n    vec3 hitPoint;\n    float reflectivity;\n};\n\nstruct GetAngleBetVecRet {\n    float theta;\n    vec3 axis;\n};\n\nstruct MandelBulbRet {\n    float dist;\n    float color;\n};\n\nstruct DistanceRet {\n    float dist;\n    float color;\n};\n\n// SCENE SETTINGS\nconst int pointLightCount = 3;\n//vec3(0.279755, 0.523567, 1.0)\n//vec3(1.0, 0.360682, 0.060892)\nconst PointLight pointLights[pointLightCount] = PointLight[](\n    PointLight(vec3(-2.6, 2.0, -2.8), 9.2, vec3(1.0, 1.0, 1.0)),\n    PointLight(vec3(1.2, 2.4, -2.6), 5.1, vec3(1.0, 1.0, 1.0)),\n    PointLight(vec3(-0.1, 3.8, -3.5), 5.2, vec3(1.0, 1.0, 1.0))\n);\n\n// COLOR PALETTE\nvec3 palette(float t) {\n    vec3 a = vec3(COLOR_A);\n    vec3 b = vec3(COLOR_B);\n    vec3 c = vec3(COLOR_C);\n    vec3 d = vec3(COLOR_D);\n    return a + b*cos(TAU*(c*t+d));\n}\n\nfloat DE(vec3 p){\n\tfloat dr=1.0,r=length(p);\n\tvec3 C=p;\n\tfor(int i=0;i<10;i++){\n\t\tif(r>20.0)break;\n\t\tdr=dr*2.0*r;\n\t\tfloat psi = abs(mod(atan(p.z,p.y)+PI/8.0,PI/4.0)-PI/8.0);\n\t\tp.yz=vec2(cos(psi),sin(psi))*length(p.yz);\n\t\tvec3 p2=p*p;\n\t\tp=vec3(vec2(p2.x-p2.y,2.0*p.x*p.y)*(1.0-p2.z/(p2.x+p2.y+p2.z)),\n\t\t\t2.0*p.z*sqrt(p2.x+p2.y))+C;\t\n\t\tr=length(p);\n\t}\n\treturn min(log(r)*r/max(dr,1.0),1.0);\n}\n\nMandelBulbRet signedDistanceMandelbulb(vec3 point) {\n    float color = 0.0;\n    vec3 z = point;\n    float dr = 1.0;\n    float r = 0.0;\n    float max_pow = 11.640;\n    float power = sin(iTime) + 5.0;\n    int iters = 0;\n    for (int i = 0; i < 100; i++) {\n        iters = i;\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y, z.x);\n        float phi = acos(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi)) * zr + point;\n        color += 1.0/100.0;\n    }\n    return MandelBulbRet(0.5 * log(r) * r / dr, color\n    );\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nDistanceRet getSignedDistance(vec3 point) {\n    MandelBulbRet ret = signedDistanceMandelbulb(point);\n    return DistanceRet(ret.dist, ret.color);\n}\n\nRayMarchingRet RayMarching(vec3 rayOrigin, vec3 rayDir) {\n    float distanceAccumulator = 0.0;\n    DistanceRet signedDistance;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 point = rayOrigin + rayDir * distanceAccumulator;\n        signedDistance = getSignedDistance(point);\n        distanceAccumulator += signedDistance.dist * 0.5;\n        if (distanceAccumulator > MAX_DISTANCE || abs(signedDistance.dist) < SURFACE_DISTANCE_THRESHOLD) {\n            break;\n        }\n    }\n    \n    return RayMarchingRet(min(distanceAccumulator, MAX_DISTANCE), signedDistance.color);\n}\n\nvec3 GetNormalAtPoint(vec3 point) {\n    vec2 epsilon = vec2(EPSILON, 0.0);\n    vec3 normal = getSignedDistance(point).dist -\n                  vec3(\n                      getSignedDistance(point - epsilon.xyy).dist, \n                      getSignedDistance(point - epsilon.yxy).dist, \n                      getSignedDistance(point - epsilon.yyx).dist\n                  );\n    \n    return normalize(normal);\n}\n\n// MARCH RAY TO SCENE\nMarchRayRet shootRay(vec3 rayOrigin, vec3 rayDir) {\n    RayMarchingRet ret = RayMarching(rayOrigin, rayDir);\n    MarchRet lastRet = MarchRet(ret.dist, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n    if (ret.dist < MAX_DISTANCE) {\n        vec3 point = rayOrigin + rayDir * ret.dist;\n        vec3 normal = GetNormalAtPoint(point);\n        \n        lastRet = MarchRet(ret.dist, normal, palette(sin(ret.color + COLOR_OFFSET) * COLOR_SCALE), 1.0);\n    }\n    \n    float frenel = pow((dot(lastRet.normal, rayDir) + 1.0), 1.3);\n    return MarchRayRet(\n        lastRet.dist,\n        lastRet.normal,\n        rayOrigin + rayDir * lastRet.dist,\n        lastRet.color,\n        frenel\n    );\n}\n\n// ADD POINT LIGHT\nvec3 pointLight(vec3 normal, vec3 rayOrigin, vec3 lightPos, float intensity, vec3 color) {\n    vec3 dir = lightPos - rayOrigin;\n    float dirLen = length(dir);\n    vec3 lightVector = normalize(lightPos - rayOrigin);\n    float dotted = max(dot(normal, lightVector), 0.0);\n    float shadedHitPoint = dotted / (dirLen * dirLen);\n    MarchRayRet retShadowRay = shootRay(rayOrigin, lightVector);\n    float mult = retShadowRay.dist > dirLen ? 0.0 : 1.0;\n    vec3 retShading = color * (shadedHitPoint * mult * intensity);\n    return retShading;\n}\n\n// SHADER HIT POINT WITH COLORS / SHADOWS\nvec3 shadeHitPoint(vec3 normal, vec3 hitPoint, vec3 color) {\n    vec3 shading = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < pointLightCount; i++) {\n        PointLight light = pointLights[i];\n        shading = shading + pointLight(normal, hitPoint, light.center, light.intensity, light.color);\n    }\n    return shading * color;\n}\n\n// GET REFLECTION BOUNCE ITERATION\nReflectionBounceRet getReflectionBounce(vec3 rayOrigin, vec3 rayDirection, vec3 rayNormal) {\n    vec3 reflected = reflect(rayDirection, rayNormal);\n    MarchRayRet rayRet = shootRay(rayOrigin, reflected);\n    vec3 shadedRet = shadeHitPoint(rayRet.normal, rayRet.hitPoint, rayRet.color);\n    return ReflectionBounceRet(\n        shadedRet,\n        reflected,\n        rayRet.normal,\n        rayRet.hitPoint,\n        rayRet.reflectivity\n    );\n}\n\n// MIX COLOR WITH FACTOR\nvec3 mixColor(float factor, vec3 A, vec3 B) {\n    return A + (B - A) * factor;\n}\n\n// RAYMARCH SCENE\nRayMarchRet rayMarch(vec3 cameraPos, vec3 rayDir) {\n    MarchRayRet rayRet = shootRay(cameraPos, rayDir);\n    \n    vec3 shaded = shadeHitPoint(rayRet.normal, rayRet.hitPoint, rayRet.color);\n    \n    ReflectionBounceRet reflectedPoint1 = getReflectionBounce(rayRet.hitPoint, rayDir, rayRet.normal);\n    ReflectionBounceRet reflectedPoint2 = getReflectionBounce(reflectedPoint1.hitPoint, reflectedPoint1.reflected, reflectedPoint1.normal);\n    \n    vec3 mixed1 = mixColor(reflectedPoint1.reflectivity, reflectedPoint1.shaded, reflectedPoint2.shaded);\n    vec3 final = mixColor(rayRet.reflectivity, shaded, mixed1);\n    \n    return RayMarchRet(final);\n}\n\n// GET SCREEN RAY DIRECTION\nvec3 getRayDir(vec2 screenUV, vec3 cameraPosition, vec3 lookAt, float focalLength) {\n    vec3 forward = normalize(lookAt - cameraPosition);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 cameraCenter = cameraPosition + forward * focalLength;\n    vec3 intersectionPoint = cameraCenter + screenUV.x * right + screenUV.y * up;\n    return normalize(intersectionPoint - cameraPosition);\n}\n\n// ROTATE VECTOR\nmat2 rotVector(float angleRadians) {\n    float sineValue = sin(angleRadians);\n    float cosineValue = cos(angleRadians);\n    mat2 rotationMatrix = mat2(cosineValue, -sineValue, sineValue, cosineValue);\n    return rotationMatrix;\n}\n\n// MAIN IMAGE FUNCTION\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // CAMERA SETTINGS \n    vec3 cameraPos = vec3(0, 0.0, 2.0);\n    \n    cameraPos.yz *= rotVector(mouse.y*PI-1.);\n    cameraPos.xz *= rotVector(-mouse.x*TAU);\n    \n    const vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    const float fov = 70.0;\n\n    // UV COORDS\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // GET FOV PIXEL COORDS\n    float fovRad = fov * (3.141 / 180.0);\n    float tanHalfFov = tan(fovRad * 0.5);\n    float ny = tanHalfFov * uv.y;\n    float nx = tanHalfFov * uv.x;\n\n    // GET DIRECTION\n    vec3 cameraDirection = getRayDir(vec2(nx, ny), cameraPos, cameraTarget, 1.);\n    \n    RayMarchRet retColor = rayMarch(cameraPos, cameraDirection);\n    \n    fragColor = vec4(retColor.final, 1.0);\n}","name":"Image","description":"","type":"image"}]}