{"ver":"0.1","info":{"id":"dsGBDt","date":"1698760683","viewed":127,"name":"Giant Ball arrives Mars","username":"orangesflower","description":"my first bug scene sdf shader, plz tell me if you have better method to optimize the performance, thx!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["mount"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 10.0;\nconst float PRECISION = 0.001;\n#define C 0.707107\n\nfloat rand(float seed) {\n    return abs(fract(114514.114514 * sin(seed)));\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(vec2 seed) {\n    // 把这行隐去会有大问题，目测是因为这个seed的浮点数太大了\n    // seed  = 50.0*fract( seed*0.3183099 + vec2(0.71,0.113));\n\n    // return abs(fract(114514.114514 * sin(dot(seed, vec2(24., 14.)))));\n    return hash12(seed);\n}\n\nvec3 noise(vec2 seed) {\n    vec2 i = floor(seed);\n    vec2 f = fract(seed);\n\n    // four corner\n    float a = rand(i);\n    float b = rand(i + vec2(1., 0.));\n    float c = rand(i + vec2(0., 1.));\n    float d = rand(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3.0 - 2.0 * f ); // custom cubic curve\n    vec2 du = 6. * u * (1. - u);\n    // return c;\n    return vec3(mix( mix( a, \n                     b, u.x),\n                mix( c, \n                     d, u.x), u.y),\n                // 后面带一个噪声的导数，为了能够知道哪里梯度大哪里小然后做相应处理\n                vec2(du * (vec2(b-a, c-a) + (a - b - c + d) * u.yx)));\n}\n\n// https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise(vec2 uv) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float gn  = 0.5000*noise( uv ).x; uv = m*uv;\n    gn += 0.2500*noise( uv ).x; uv = m*uv;\n    gn += 0.1250*noise( uv ).x; uv = m*uv;\n    gn += 0.0625*noise( uv ).x; uv = m*uv;\n    return gn;\n}\n\nvec2 ZoomUV(in vec2 uv){\n    vec2 fixUv = 1. * (uv - 0.5 * iResolution.xy)/ min(iResolution.x, iResolution.y);\n    return fixUv;\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdGround(vec3 p) {\n    mat2 mat = mat2(0.6, -0.8, 0.8, 0.6);\n    float a = 0.5;\n    float b = 1.;\n    vec2 d =vec2(0);\n\n    for (int i = 0; i < 15; i++) {\n        vec3 n = noise(p.xz);\n        d = n.yz; // 导数用来mask\n        a += n.x * b / (1.3 + length(d));\n        p.xz *= mat * 1.7 ;\n        b *= 0.5;\n    }\n\n    return (p.y - a) * 0.2;\n}\n\nstruct Material {\n    vec3 ambientColor; // k_a * i_a\n    vec3 diffuseColor; // k_d * i_d\n    vec3 specularColor; // k_s * i_s\n    float alpha; // shininess\n};\n\nstruct Surface {\n    int id; // id of object\n    float sd; // signed distance\n    Material mat;\n};\n\nMaterial gold() {\n    vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n    vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n    vec3 sCol = 0.6 * vec3(1, 1, 1);\n    float a = 5.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n    vec3 aCol = 0.4 * vec3(0.8);\n    vec3 dCol = 0.5 * vec3(0.7);\n    vec3 sCol = 0.6 * vec3(1, 1, 1);\n    float a = 5.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n    vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n    vec3 dCol = vec3(0.3);\n    vec3 sCol = vec3(0);\n    float a = 1.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial ground(vec3 p) {\n    vec3 aCol = vec3(0.3647, 0.2745, 0.149);\n    vec3 dCol = vec3(0.3725, 0.1843, 0.0706);\n    vec3 sCol = vec3(0.4627, 0.3961, 0.302);\n    float a = 1.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface scene(vec3 p) {\n    // Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n    Surface sSphereGold = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), gold());\n    Surface sSphereSilver = Surface(3, sdSphere(p - vec3(0, 2, 0), 1.), silver());\n    Surface sGround = Surface(4, sdGround(p - vec3(0.,-1.,0.)), ground(p));\n\n    // Surface co = opUnion(sFloor, sSphereGold); // closest object\n    Surface co = opUnion(sSphereSilver, sGround); // closest object\n    // co = opUnion(co, sSphereSilver);\n    // co = opUnion(co, sSphereGold);\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    Surface co;\n\n    // rayMarching\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION * depth || depth > MAX_DIST) break; // 远处精度更低节省下性能\n    }\n\n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float k) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, k*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 phong(vec3 point, vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n    // ambient\n    vec3 ambient = mat.ambientColor;\n\n    // diffuse\n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 diffuse = mat.diffuseColor * dotLN;\n\n    // specular\n    float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n    vec3 specular = mat.specularColor * pow(dotRV, mat.alpha) * 0.5;\n\n    // shadow\n    vec3 shadow = vec3(softShadow(point, lightDir, 0.02, 2.5, 32.));\n\n    // return diffuse;\n    // return ambient + diffuse + specular;\n    return ambient + diffuse * shadow + specular;\n}\n\nvec3 myShade(vec3 point, vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 diffuse = mat.diffuseColor * dotLN;\n\n    // shadow\n    vec3 shadow = vec3(softShadow(point + 0.01 * lightDir, lightDir, 0.02, 2.5, 32.));\n\n\n    return diffuse * shadow;\n}\n\nvec3 sky(vec3 rd, vec3 sunLightDir){\n    vec3 col = vec3(0.3, 0.5, 0.85) - rd.y * rd.y * 0.5;\n    col = mix(col, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(rd.y, 0.0), 5.0));\n    // sun\n    vec3 sunLight = sunLightDir;\n    float sundot = clamp(dot(rd, sunLight), 0.0, 1.0);\n\n    col += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 5.0);\n    col += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 64.0);\n    col += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 512.0);\n    // col = mix(col, 0.68 * vec3(0.4, 0.65, 1.0), pow(1.0 - max(rd.y, 0.0), 16.0));\n    return col;\n}\n\nvec3 render(vec2 uv) { \n    vec3 col = vec3(0);\n    vec3 lp = vec3(0., 0., 0.); // lookat point (aka camera target)\n    vec3 ro = vec3(10. * sin(0.05 * iTime), 0.5, 10. * cos(0.05 * iTime)); // camera position\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1.)); // ray direction\n    vec3 sunDir = normalize(vec3(0., 0.4, -1.0));\n    vec3 backgroundColor = sky(rd, sunDir);\n\n    Surface co = rayMarch(ro, rd); // closest object\n\n    vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n    vec3 normal = calcNormal(p); // surface normal\n        // light #1\n    vec3 lightPosition1 = vec3(1, 5, 1);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 1.0;\n    \n    // // light #2\n    // vec3 lightPosition2 = vec3(1, 10, 1);\n    // vec3 lightDirection2 = normalize(lightPosition2 - p);\n    // float lightIntensity2 = 1.0;\n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        // final color of object\n\n        if(co.id == 4) {\n            col = lightIntensity1 * myShade(p, sunDir, normal, rd, co.mat);\n        } else {\n             col = lightIntensity1 * phong(p, sunDir, normal, rd, co.mat);\n        }\n        \n        // col += lightIntensity2 * phong(p, lightDirection2, normal , rd, co.mat);\n\n        col = mix(col, 0.75 * vec3(0.6275, 0.8078, 0.9882), 1. - exp(-0.01 *pow( co.sd, 2.5)));\n    }\n    // col = sky(rd);\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = ZoomUV(fragCoord);\n    // vec3 backgroundColor = mix(vec3(1, .341, .2), vec3(0, 1, 1), uv.y) * 1.6;\n    vec3 col = vec3(0);\n\n    col = render(uv);\n\n    // // anti-aliasing\n    // for(int m = 0; m < AA; m++){\n    //     for(int n = 0;n < AA; n++){\n    //         vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - 0.5);\n    //         col += render(ZoomUV(offset + fragCoord));\n    //     }\n    // }\n    // col = col / float(AA * AA);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}