{"ver":"0.1","info":{"id":"7ldBR7","date":"1664154775","viewed":238,"name":"HeightMap Clouds and Terrain","username":"totimannino","description":"Playing around with height maps again. Iterating on https://www.shadertoy.com/view/NlVyDV\n\nYou can see the heightmap textures by commenting in the texture channel view on the bottom of mainImage","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixOffset = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float focalLength = 1.0;\n        \n    constructScene(iTime);\n    \n    mat3 camMat = constructCameraMat(sceneCam);\n    vec3 rayDir = camMat*normalize(vec3(pixOffset, focalLength));\n    Ray ray = Ray(rayDir, sceneCam.pos);\n    \n    HitInfo hitInfo;\n    hitInfo.dist = MAX_DIST;\n    vec3 surfaceNorm; \n    vec3 surfaceColor = vec3(0.);\n    \n    HitInfo hmapHit = heightMapIntersect(ray, sceneHmap, iChannel1);\n    if(hmapHit.dist > 0. && hmapHit.dist < MAX_DIST)\n    {\n        vec3 sunDir = getSunDirection(iTime);\n        surfaceColor = hmapHit.albedo;\n        hitInfo.dist = hmapHit.dist;\n    }\n    \n    HitInfo skyHit = heightMapIntersect(ray, skyHmap, iChannel0);\n    vec3 skyNorm; \n    vec3 skyColor = vec3(0.);\n    if(skyHit.dist > 0. && skyHit.dist < MAX_DIST)\n    {\n        skyColor = skyHit.albedo;\n        hitInfo.dist = skyHit.dist;\n    }\n    \n    vec3 color = skyColor + surfaceColor;\n\n    color = mix(color,vec3(0.55,0.55,0.85), clamp((hitInfo.dist-20.)/50., 0., 1.));\n\n    fragColor = vec4(color,1.0);\n    \n    // ground color map debug\n    //fragColor = texture(iChannel1,fract(pixOffset)).rgba;\n    \n    // sky color map debug\n    //fragColor = texture(iChannel0,fract(pixOffset)).rgba;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DIST 99999999999.\n#define CLOUD_HEIGHT 5.\n\nstruct PlaneDef\n{\n    vec3 norm;\n    vec3 pos;\n};\n\nstruct HeightMapDef\n{\n    PlaneDef plane;\n    vec3 xAxis;\n    vec3 yAxis;\n    vec2 zxyScale;\n};\n\nstruct PointLightDef\n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n// Camera\nstruct CameraDef\n{\n    vec3 pos;\n    vec3 lookAt;\n    float yaw;\n};\n\nstruct Ray\n{\n    vec3 dir;\n    vec3 orig;\n};\n\nstruct HitInfo\n{\n    float dist;\n    vec3 albedo;\n    vec2 uv;\n};\n\nCameraDef sceneCam;\nHeightMapDef sceneHmap;\nHeightMapDef skyHmap;\n\nmat3 constructCameraMat(CameraDef cam) {\n\tvec3 cw = normalize(cam.lookAt-cam.pos);\n    vec3 cp;\n    if(abs(cw.x) > 0. || abs(cw.z) > 0.)\n    {\n        cp = vec3(sin(cam.yaw), cos(cam.yaw), 0.);\n    }\n    else\n    {\n        cp = vec3(sin(cam.yaw), 0., cos(cam.yaw));\n    }\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 rayHitPos(Ray ray, float t)\n{\n    return ray.orig + t*ray.dir;\n}\n\n\nfloat planeIntersect(Ray ray, PlaneDef plane)\n{   \n    float pr = dot(plane.norm, ray.dir);\n    if(abs(pr) > 0.0001)\n    {\n        return dot(plane.norm, plane.pos-ray.orig)/pr;\n    }\n    else\n    {\n        return MAX_DIST;\n    }\n}\n\nHeightMapDef createHeightMap(PlaneDef plane, vec2 scale)\n{\n    vec3 xAxis;\n    vec3 yAxis;\n    if(plane.norm.z >= 0.98)\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,1.,0.)));\n    }\n    else\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,0.,1.)));\n    }\n    \n    yAxis = cross(xAxis, plane.norm);\n    \n    return HeightMapDef(plane, xAxis, yAxis, scale);\n}\n\nvec3 heightMapNorm(vec2 fOffset, HeightMapDef hmap, vec2 delta, sampler2D samp)\n{\n    vec2 size = vec2(1./hmap.zxyScale.y,0.0);\n    const vec3 off = vec3(-1,0,1);\n    float s01 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.xy*delta)).a;\n    float s21 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.zy*delta)).a;\n    float s10 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.yx*delta)).a;\n    float s12 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.yz*delta)).a;\n    vec3 va = normalize(vec3(size.xy*delta,s21-s01));\n    vec3 vb = normalize(vec3(size.yx*delta,s12-s10));\n    vec3 vc = cross(va,vb);\n    return vc;\n}\n\nvec3 orientMapNormToWorld(vec3 mapNorm, HeightMapDef hmap)\n{\n    return mapNorm.x*hmap.xAxis + mapNorm.y*hmap.yAxis + mapNorm.z*hmap.plane.norm;\n}\n\nbool heightMapShadow2D(vec3 worldLightDir, vec2 fOffset, vec2 delta, HeightMapDef hmap, sampler2D samp)\n{\n    // this won't work. should be multiplied by tranpose instead\n    //vec3 lightDir = worldLightDir.x*hmap.xAxis + worldLightDir.y*hmap.yAxis + worldLightDir.z*hmap.plane.norm;\n    vec3 lightDir = worldLightDir; // generalize this later\n    float dd = length(delta);\n    vec3 stepDel = lightDir*dd;\n    \n    vec3 currOffset = vec3(fOffset, hmap.zxyScale.x*texture(samp, fract(fOffset)).a);\n    float currHt;\n    \n    int maxIter = 100;\n    \n    bool isHit = false;\n    for(int ii = 0; ii < maxIter; ++ii) \n    {\n        currOffset = currOffset + stepDel;\n        currHt = hmap.zxyScale.x*texture(samp, fract(currOffset.xy)).a;\n        \n        if(currOffset.z < currHt)\n        {\n            isHit = true;\n            break;\n        }\n    }\n    \n    return isHit;\n}\n\nHitInfo heightMapIntersect(Ray ray, HeightMapDef hmap, sampler2D samp)\n{\n    PlaneDef toppdef = hmap.plane;\n    toppdef.pos = hmap.plane.pos + hmap.plane.norm*hmap.zxyScale.x;\n    float t0 = planeIntersect(ray, toppdef);\n    float t1 = planeIntersect(ray, hmap.plane);\n    const int maxIter = 100;\n    float dt = 1./float(maxIter);\n    float rstep = 0.;\n    if(t1 < t0)\n    {\n        dt = -dt;\n        rstep = 1.;\n        if(t1 < 0. && t0 > 0.)\n        {\n            rstep = abs(t0/(t0-t1));\n        }\n    }\n    vec3 pos0 = rayHitPos(ray, t0) - toppdef.pos;\n    vec3 pos1 = rayHitPos(ray, t1) - hmap.plane.pos;\n    vec2 uv0 = vec2(dot(hmap.xAxis, pos0), dot(hmap.yAxis, pos0));\n    vec2 uv1 = vec2(dot(hmap.xAxis, pos1), dot(hmap.yAxis, pos1));\n    \n    vec4 bsamp = vec4(0.);\n    bool isHit = false;\n    vec2 fOffset = vec2(0.);\n    for(int ii = 0; ii <= maxIter; ++ii) \n    {\n        fOffset = (uv0 + rstep*(uv1-uv0))*hmap.zxyScale.y;\n        float dht = texture(samp, fract(fOffset)).a;\n        float currHt = 1.-rstep;\n        if(dht > currHt)\n        {\n            isHit = true;\n            float r0 = rstep - dt;\n            for(int jj = 0; jj < 4; ++jj)\n            {\n                float rmid = 0.5*(r0 + rstep);\n                fOffset = (uv0 + rmid*(uv1-uv0))*hmap.zxyScale.y;\n                bsamp = texture(samp, fract(fOffset));\n                if(bsamp.a > 1.0-rmid) rstep = rmid;\n                else r0 = rmid;\n            }\n            break;\n        }\n        else\n        {\n            rstep = rstep + dt;\n        }\n    }\n    \n    HitInfo rval;\n    if(isHit)\n    {\n        rval.dist = t0 + rstep*(t1-t0);\n        rval.albedo = bsamp.rgb;\n        rval.uv = fOffset;\n    }\n    else\n    {\n        rval.dist = MAX_DIST;\n        rval.albedo = vec3(0.0);\n        rval.uv = vec2(-1.);\n    }\n    return rval;\n}\n\n\nvec3 getSunDirection(float time)\n{\n    float s = 0.02;\n    return normalize(vec3(cos(s*time),sin(s*time),1. + 0.5*cos(0.5*s*time)));\n}\n\nvoid constructScene(float time)\n{\n    sceneHmap = createHeightMap(PlaneDef(vec3(0.,1.,0.), vec3(0.,0.,0.)), vec2(1.2, 0.1));\n    skyHmap = createHeightMap(PlaneDef(vec3(0.,-1.,0.), vec3(0.,CLOUD_HEIGHT,0.)), vec2(0.5, 0.05));\n    sceneCam = CameraDef(vec3(10. - 1.5*time, 3.0, 0.0), vec3(-1.5*time, 0., 0.), 0.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ground color+heightmap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lowerSection = 0.3;\n    vec2 fOffset = (fragCoord.xy - 0.5*iResolution.xy)/(iResolution.xy);\n    vec4 t = 0.5*textureLod(iChannel0, fract(fOffset),0.);\n    t += 0.5*textureLod(iChannel0, fract(vec2(-1.,1.)*fOffset),0.);\n    vec4 b0 = textureLod(iChannel1, fract(fOffset),0.);\n    vec4 b1 = textureLod(iChannel1, fract(3.0*fOffset),0.);\n    vec4 col = 0.7*textureLod(iChannel2, fract(4.0*fOffset),0.);\n    col += 0.3*(0.5*textureLod(iChannel2, fract(0.5*fOffset),0.)+0.5*textureLod(iChannel2, fract(0.5*vec2(1.,-1.)*fOffset),0.));\n    \n    float mixRatio = clamp(b0.r, 0.1, lowerSection)/lowerSection;\n    float height = mix(0.3*(b1.r + 0.4*t.r), b0.r, mixRatio);\n    col.rgb = mix(col.rgb, vec3(0., 0.12, 0.04), 1.0-mixRatio);\n    fragColor = vec4(col.rgb,height);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// sky color+heightmap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fOffset = (fragCoord.xy - 0.5*iResolution.xy)/(iResolution.xy);\n    vec4 b0 = textureLod(iChannel0, fract(1.0*fOffset + 0.01*iTime),0.);\n    vec4 b1 = textureLod(iChannel0, fract(3.0*fOffset + 0.1*iTime),0.);\n    float height = 0.8*b0.r+0.2*b1.r;\n    vec3 col = mix(vec3(0.7,0.7,1.0), vec3(0.9,0.9,1.0), height);\n    fragColor = vec4(col,height);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// this buffer computes the shading on the ground\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 fOffset = fragCoord.xy/iResolution.xy;\n    vec3 sunDir = getSunDirection(iTime);\n    vec4 ground = texture(iChannel0, fOffset);\n    float groundHeight = ground.a;\n    \n    constructScene(iTime);\n\n    vec2 skyOffset = fract(fOffset + (CLOUD_HEIGHT)*sunDir.xy);\n    float skyShade = 1.0 - 0.8*texture(iChannel1, vec2(1.0-skyOffset.x, skyOffset.y)).a;\n    \n    // cheating by sampling two \"random\" locations and taking the min\n    // since we know the clouds blend near 1.,1.,1.\n    // for ambient color\n    vec3 skyColorAvg = min(texture(iChannel1, vec2(0.,0.)).rgb, texture(iChannel1, vec2(0.5,0.5)).rgb);\n    \n    HitInfo hitInfo;\n    hitInfo.dist = MAX_DIST;\n    vec3 surfaceColor = vec3(0.);\n    \n    vec2 delta = vec2(1.,1.)/iChannelResolution[0].xy;\n    \n    vec3 surfaceNorm = heightMapNorm(fOffset, sceneHmap, delta, iChannel0);\n    bool inShadow = heightMapShadow2D(sunDir, fOffset, delta, sceneHmap, iChannel0);\n    \n    surfaceColor += skyColorAvg*ground.rgb*0.4;\n    if(!inShadow)\n    {\n        surfaceColor += ground.rgb*vec3(max(0.,dot(surfaceNorm,sunDir)));\n    }\n    \n    surfaceColor *= skyShade;\n    \n    fragColor = vec4(surfaceColor, groundHeight).rgba;\n}","name":"Buffer C","description":"","type":"buffer"}]}