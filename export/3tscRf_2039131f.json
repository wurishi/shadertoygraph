{"ver":"0.1","info":{"id":"3tscRf","date":"1592697459","viewed":263,"name":"Bouncy (fun)ction","username":"Rloret","description":"Testing some function I was implementing into Unity (shameless promotion https://github.com/rloretor) and got carried away.\nIt can be slow, sorry about that.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sphere","bounce","repeat","cage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 c = vec3(0,0,0);\nvec3 ext = vec3(1,1,1);\n\nfloat boxThickness =.09;\n\n//https://www.desmos.com/calculator/jssg2cmzhi\nvec3 ReflectCube(vec3 val, vec3 min, vec3 max)\n{\n    vec3 R = (min + mod((val - min), max - min));\n    vec3 t = mod(ceil((val - min) / (max - min)), 2.0);\n    return R * (2.0 * t - 1.0) + (max + min) * (1. - t);\n}\nfloat sdSphere(vec3 p,vec3 count){\n    float r =0.25;\n\tc =ReflectCube( normalize((vec3(1,3,0.1) +count))*iTime*3.,-ext+r,ext-r)   ;\n\treturn length(p-c) -r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdCross(vec3 p,float scale){\n    vec3 right =ext;\n\tvec3 forward =right;\n    vec3 up = forward;\n    right.x+=scale;\n\tup.y+=scale;\n    forward.z +=scale;\n\tright-=boxThickness;\n    up-=boxThickness;\n    forward-=boxThickness;\n    \n\treturn min(sdBox(p,right),\n               min(sdBox(p,forward),sdBox(p,up))\n              );\n}\nfloat sdCage(vec3 p,vec3 size){\n\treturn max(-sdCross(p,2.),sdBox(p,size));\n}\n\nfloat sdistToScene(vec3 p){\n\tvec3 r =vec3(3.);\n\tvec3 count = round(p/r);\n    vec3 I = min(vec3(3,2,4),round(vec3(sin(iTime*.3),cos(iTime*.2),tan(iTime*0.3))+(abs(sin(iTime)))));\n\tvec3 q = p-r*clamp(round(p/r),-I,I);\n    return min(sdCage(q,ext),sdSphere(q,count));\n}\n\n \n#define MaxSteps 100 \nbool march(inout float d,inout vec3 p,vec3 O,vec3 D){\n\tfloat dt =1.;\n    d=0.;\n     \n    for(int i = 0;  i<=MaxSteps ; i++)\n    {\n \t\tp= O+D*d;  \n    \tdt= sdistToScene(p);\n        d +=dt ;\n        if(dt<=0.0001)return true;\n    }\n\treturn false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord/iResolution.xy;\n\tfloat AR = iResolution.x/iResolution.y;\n    uv = (uv*2.0)-1.0;\n    uv.x*=AR;\n\t\n\tvec3 O = vec3(0,0,-22);\n\tvec3 D = normalize(vec3(uv.xy,2));\n\tvec3 p=O;\n    float d = 0.;\n    vec3 c =vec3(1.-dot(uv*.2,uv*.2));\n\tc*=c;\n    c*=(vec3(0.1,0.25*(uv.y*0.5 +0.5)*2.,0.3))*0.39;\n   \n    if(march(d,p,O,D)){\n    \tfragColor =1.-c.xyzz;\n    }\n    else fragColor= c.xyzz;\n    \n}\n","name":"Image","description":"","type":"image"}]}