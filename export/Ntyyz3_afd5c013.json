{"ver":"0.1","info":{"id":"Ntyyz3","date":"1661951491","viewed":294,"name":"Menger Sponge Pathtracer","username":"Poisson","description":"A modified menger sponge computed with raymarching and rendered with pathtracing.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","raymarching","fractal","raytracer","ray","raymarcher","menger","pathtracing","pathtracer","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 col = data.rgb/data.w;\n    col = pow(col, vec3(.4545)); // gamma correction\n    // constrast\n    float f0 = .4;\n    col = col*(1.+f0)-.5*f0;\n    // vignetting\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    col *= 1.-.2*dot(p,p)*dot(p,p);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define MAX_DIST 8.\n#define MAX_BOUNCES 5 // ray bounces\n#define MENGER_ITER 5 // menger fractal iterations, try set it to one\n\nfloat seed;\n\nstruct Ray {\n    vec3 o, d; // origin and direction\n};\n\nstruct Camera {\n    vec3 o, d; // origin and direction\n    float z; // zoom\n};\n\n// simple camera system\nRay getRay(vec2 uv, Camera c, float aspect) {\n    float focDist = length(c.o - c.d);\n    float hh = tan(radians(c.z)*.5);\n    float hw = aspect * hh;\n\n    vec3 f = normalize(c.o - c.d);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    \n    vec3 r = c.o - hw*focDist*s - hh*focDist*u - focDist*f;\n    vec3 h = 2.*hw*focDist*s;\n    vec3 v = 2.*hh*focDist*u;\n    \n    vec3 i = normalize(r + uv.x*h + uv.y*v - c.o);\n    \n    return Ray(c.o, i);\n}\n\n// menger sponge fractal\n// thanks to iq: https://iquilezles.org/articles/menger/\n\nfloat sdMenger(vec3 p, float thickness) {\n    vec3 q = abs(p);\n    float d = max(q.x,max(q.y,q.z))-1.;\n    \n    float s = 1.;\n    for (int m = 0; m < MENGER_ITER; m++) {\n        //p.yz *= rot(.125*PI*float(m));\n        //p.xz *= rot(.125*PI*float(m));\n        \n        vec3 a = mod(p*s, 2.) - 1.;\n        s *= 3.;\n        vec3 r = 1. - 3.*abs(a);\n        \n        r.xy *= rot(.25*PI); // try to change the angle\n        r.zx *= rot(.25*PI); // try to change the angle\n        \n        r = abs(r);\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n    \n        float c = min(da,min(db,dc)) - thickness; // try to change the thickness\n        \n        d = max(d, c/s);\n    }\n    \n    return d;\n}\n\n// scene distance\nfloat map(vec3 p) {\n    return min(p.y+1., sdMenger(p, .75));\n}\n\n// intersect the scene\nfloat intersect(Ray r) {\n    float t = 0.;\n    \n    for (int i = 0; i < 256; i++) {\n        vec3 p = r.o + r.d * t;\n        float h = map(p);\n        t += h;\n        if (h < .00001 || t > MAX_DIST) break;\n    }\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(.00001,0);\n    float h = map(p);\n    \n    return normalize(h - vec3(map(p - e.xyy),\n                              map(p - e.yxy),\n                              map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    seed = float(hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+float(iFrame);\n    vec2 o = hash2(seed) - .5;\n    vec2 uv = (fragCoord + o) / iResolution.xy;\n    \n    // setup ray\n    Camera c = Camera(vec3(0,1.+(mouse.y-.5) * 3.,-2.2), vec3(0), 60.);\n    c.o.xz *= rot(mouse.x*TAU);\n        \n    Ray r = getRay(uv, c, iResolution.x/iResolution.y);\n    \n    // pathtrace\n    vec3 col = vec3(1);\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        float t = intersect(r);\n        if (t < MAX_DIST) { // coloring and lighting\n            vec3 p = r.o + r.d * t;\n            vec3 n = calcNormal(p);\n            \n            // diffuse lighting\n            \n            col *= vec3(.9,.6,.5);\n            r.o = p + n*.002;\n            \n            r.d = normalize(n + normalize(random3D(seed)));\n            \n            // cast shadow ray\n            \n            vec3 lig = normalize(vec3(4,4,-4));\n            vec3 so = r.o;\n            vec3 sd = normalize(lig + .02*random3D(seed));\n            float dif = clamp(dot(n,sd), 0., 1.);\n            if (intersect(Ray(so,sd)) < MAX_DIST) {\n                dif *= 0.;\n            }\n            col *= mix(vec3(1.3), vec3(.5,.4,.45), 1.-dif);\n        } else { // sky\n            vec3 sky = mix(vec3(1), vec3(.6,.8,1), .5+.5*r.d.y);\n            col *= sky;\n            break;\n        }\n    } \n    \n    // output\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    if (iMouse.z > 0.) data = vec4(0);\n    data += vec4(col, 1.);\n    \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// hash functions by Nimitz: https://www.shadertoy.com/view/Xt3cDn\n\nuint hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash2(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// random functions by reinder: https://www.shadertoy.com/view/XlGcWh\n\nvec3 random3D(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi), cos(phi)), h.x);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}