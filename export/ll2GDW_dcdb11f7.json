{"ver":"0.1","info":{"id":"ll2GDW","date":"1429201302","viewed":928,"name":"Simple sun, sky and ocean","username":"invor","description":"Based on my simple sky and sun. Added a simple ocean.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","sun","water","sky","magicnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Values are chosen and computations made based on \"what looks alright\".\n\n#define horizonHeight 0.35\n\n\nfloat scaleToHorizon(float factor)\n{\n    return abs( (factor - horizonHeight) * (1.0/(1.0-horizonHeight)));\n}\n\nfloat invScaleToHorizon(float factor)\n{\n    return abs(((1.0 - factor) - (1.0-horizonHeight)) / horizonHeight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if(uv.y > horizonHeight)\n    {\n    \t// Normalized screen space coordinates of the sun controlled by mouse\n    \tvec2 sunPosition = vec2(0.5);\n    \tsunPosition = (iMouse.xy/iResolution.xy);\n        sunPosition.y = max(horizonHeight,sunPosition.y);\n    \t\n    \t// Interpolate between midday and evening sky colors based on sun height\n    \tvec3 sky_horizonColor = mix(vec3(0.8,0.4,0.1),vec3(0.6,0.6,1.0),pow(scaleToHorizon(sunPosition.y),0.3));\n    \tvec3 sky_Color = mix(vec3(0.1,0.1,0.3),vec3(0.2,0.2,0.7),pow(scaleToHorizon(sunPosition.y),0.3));\n    \t\n    \t// Sky gradient\n    \tvec3 skyGradient = mix(sky_horizonColor,sky_Color,pow(scaleToHorizon(uv.y),0.5));\n    \t\n    \t// Simple sun disc\n    \tvec3 sun_color = vec3(1.0,1.0,0.3);\n    \tvec3 sunDisc = sun_color *(length(fragCoord.xy - (sunPosition * iResolution.xy)) < (iResolution.x/50.0) ? 1.0 : 0.0);\n    \t\n    \t// Compute sun halo for horizon and zenit\n    \tfloat sunHaloFactor = (length(fragCoord.xy - sunPosition * iResolution.xy)-(iResolution.x/50.0))/length(iResolution.xy);\n    \tfloat sunHaloPoly = (1.0 - pow(sunHaloFactor,0.15+(1.0-sunPosition.y)*0.2)) * (1.0-scaleToHorizon(uv.y));\n    \tfloat sunHaloExp = exp(-pow(sunHaloFactor,2.0)/(2.0*pow(0.02,2.0)));\n    \t// Interpolate sun halo\n    \tvec3 sunHalo = sun_color * mix(sunHaloPoly,sunHaloExp,pow(scaleToHorizon(sunPosition.y),0.6));\n    \t\n    \t// Combine sky gradient, sun disc and sun halo for final color\n    \tfragColor = vec4(skyGradient+sunDisc+sunHalo,1.0);\n    \t\n    \t// Debugging\n    \t//fragColor = vec4( mix(sunHaloPoly,sunHaloExp,pow(scaleToHorizon(sunPosition.y),0.6)) *sun_color,1.0);\n    }\n    else\n    {\n        float t = clamp(iTime / 6., 0., 1.);\n \n\t\tvec2 dir = uv - vec2(uv.x,1.0);\n\t\t\n\t\tfloat dist = distance(uv, vec2(0.5,10.0));;\n\t\tvec2 offset = dir * (sin(dist * 90. - iTime*6.) + .5) / 30.;\n        \n        offset *= horizonHeight - uv.y;\n \t\n\t\tuv = uv + offset;\n    \t\t\n    \t// Normalized screen space coordinates of the sun controlled by mouse\n    \tvec2 sunPosition = vec2(0.5);\n    \tsunPosition = (iMouse.xy/iResolution.xy);\n        sunPosition.y = min(horizonHeight,(horizonHeight - ((sunPosition.y-horizonHeight)*(1.0/(1.0-horizonHeight))*horizonHeight) ));\n    \t\n    \t// Interpolate between midday and evening sky colors based on sun height\n    \tvec3 sky_horizonColor = mix(vec3(0.8,0.4,0.1),vec3(0.6,0.6,1.0),pow(invScaleToHorizon(sunPosition.y),0.3));\n    \tvec3 sky_Color = mix(vec3(0.1,0.1,0.3),vec3(0.2,0.2,0.7),pow(invScaleToHorizon(sunPosition.y),0.3));\n        \n        sunPosition.y = sunPosition.y + offset.y;\n    \t\n    \t// Sky gradient\n    \tvec3 skyGradient = mix(sky_horizonColor,sky_Color,pow(invScaleToHorizon(uv.y),0.5));\n    \t\n   \t\tfloat sun_distanceScaling = 1.0 - pow(uv.y/horizonHeight,2.0);\n    \t// Simple sun disc\n    \tvec3 sun_color = vec3(1.0,1.0,0.3);\n    \tvec3 sunDisc = sun_color *(length(fragCoord.xy - (sunPosition * iResolution.xy)) < (iResolution.x/50.0)*sun_distanceScaling ? 1.0 : 0.0);\n    \t\n    \t// Compute sun halo for horizon and zenit\n    \tfloat sunHaloFactor = (length(fragCoord.xy - sunPosition * iResolution.xy)-(iResolution.x/50.0)*sun_distanceScaling)/length(iResolution.xy);\n    \tfloat sunHaloPoly = (1.0 - pow(sunHaloFactor,0.15+(1.0-sunPosition.y)*0.2)) * (1.0-invScaleToHorizon(uv.y));\n    \tfloat sunHaloExp = exp(-pow(sunHaloFactor,2.0)/(2.0*pow(0.02,2.0)));\n    \t// Interpolate sun halo\n    \tvec3 sunHalo = sun_color * mix(sunHaloPoly,sunHaloExp,pow(invScaleToHorizon(sunPosition.y),0.6));\n    \t\n    \t// Combine sky gradient, sun disc and sun halo for final color\n    \tfragColor = vec4(skyGradient+sunDisc+sunHalo,1.0);\n        \n        // Debugging\n    \t//fragColor = vec4(sunHalo,1.0);\n    }\n}","name":"","description":"","type":"image"}]}