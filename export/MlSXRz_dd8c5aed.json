{"ver":"0.1","info":{"id":"MlSXRz","date":"1440986036","viewed":524,"name":"Lighthouse","username":"EKnapik","description":"A lighthouse on the ocean. With the moon in the background.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["water","light","ocean","spotlight","house","eknapik","lighthouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Eric M. Knapik\n// github: eknapik\n// https://github.com/EKnapik\n\n// Illuminates the moon\n#define MoonSpotPos vec3(20.0, -10.0, -10.0)\n#define MoonSpotDir normalize(MoonSpotPos-vec3(-15.0,15.0,-20.0))\n#define MoonSpotCol vec3(1.0, 1.0, 1.0)\n// Illuminates the rest of the scene\n#define LightPos vec3(-10.0, 3.0, -16.0)\n#define LightDir normalize(LightPos-vec3(-3.0, 3.0, 0.0))\n#define LightCol vec3(1.0, 1.0, 1.0)\n\nstruct SpotLight {\n\tvec3 pos;\n    vec3 dir;\n    vec3 color;\n    float intensity;\n    float spread;\n    float penFactor;\n};\n\n// Trochoid waves that would make this nicer\nfloat wave(vec3 p, float speed, float amp, float angle, float freq) {\n\treturn amp*cos(freq*(freq*(p.x*cos(angle) + p.z*sin(angle)) - speed*iTime) - speed*iTime);\n}\n\nfloat fbm(vec2 p) {\n    float ql = length( p );\n    p.x += 0.05*sin(.81*iTime+ql*2.0);\n    p.y += 0.05*sin(1.53*iTime+ql*6.0);\n    \n    float total = 0.0;\n    float freq = 0.0152250;\n    float lacunarity = 2.51;\n    float gain = 0.15;\n    float amp = gain;\n    \n    for(int i = 0; i < 5; i++) {\n    \ttotal += texture(iChannel0, p*freq).r*amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return total;\n}\n\nfloat fbm3(vec3 p) {\n    float ql = length( p );\n    \n    float total = 0.0;\n    float freq = .02250;\n    float lacunarity = 0.151;\n    float gain = 0.15;\n    float amp = gain;\n    \n    for(int i = 0; i < 5; i++) {\n    \ttotal += texture(iChannel1, p.xy*freq).r*amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return total;\n}\n\n\n//-----------OBJECT OPERATIONS-----------\nvec2 shapeMin(vec2 shape1, vec2 shape2) {\n\treturn (shape1.x < shape2.x) ? shape1 : shape2;\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec4 q = m*vec4(p,1.0);\n    return q.xyz;\n}\n//----------END OBJECT OPERATIONS----------\n\n//----------DISTNACE FUNCTIONS----------\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat distSphere(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\nfloat distOcean(vec3 pos) {\n    return pos.y + fbm(pos.xz + .5*fbm(pos.xz + fbm(pos.xz))) + wave(pos, .3, .0413, .23, 2.0) + wave(pos, .15, .12, -.35, .5);\n}\n\nfloat distMoon(vec3 pos) {\n\tfloat radius = 6.0;\n    vec3 desiredPos = vec3(-15.0,15.0,-20.0);\n    return length(pos-desiredPos)-radius;\n}\n\nvec2 distLightHouse(vec2 curShape, vec3 pos) {\n    vec2 res;\n\tres = shapeMin( curShape, vec2( sdCylinder(pos, vec2(0.4, 1.5)), 4.0)); // mainTube\n    // saftey bars\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.4, 1.5, 0.0), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.0, 1.5, 0.4), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.4, 1.5, 0.0), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.0, 1.5, -0.4), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.28, 1.5, -0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.28, 1.5, -0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.28, 1.5, 0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.28, 1.5, 0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdTorus82(pos-vec3(0.0, 1.64, 0.0), vec2(0.4, 0.05)), 5.0));\n    res = shapeMin( res, vec2( sdTorus82(pos-vec3(0.0, 1.3, 0.0), vec2(0.4, 0.05)), 5.0));\n    // window\n    res = shapeMin( res, vec2( sdBox(pos-vec3(-0.2, 0.5, 0.0), vec3(0.2, 0.3, 0.2)), 5.0));\n    // lighthouse cap\n    res = shapeMin( res, vec2( sdCone(pos-vec3(0.0, 2.5, 0.0), vec3(0.4, 0.35, 0.5)), 5.0));\n    res = shapeMin( res, vec2( distSphere(pos-vec3(0.0, 2.5, 0.0), 0.07), 5.0));\n    return res;\n}\n//---------END DISTANCE FUNCTIONS--------\n\n\n//-----------OBJ MAP AND RAYMARCH-------------\nvec2 map(vec3 pos) {\n\tvec2 shape; // the distance to this shape and the shape id\n    \t\t\t// distance to shape is x, shape id is y\n    shape = shapeMin(vec2(distOcean(pos), 1.0), vec2(distSphere(pos, 0.5), 2.0));\n    shape = shapeMin(shape, \t\t\t\t\tvec2(distMoon(pos), 3.0));\n    shape = distLightHouse(shape, pos-vec3(3.0, 1.4, -3.0));\n    return shape;\n}\n\nvec2 rayMarch(in vec3 rayOrigin, in vec3 rayDir) {\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float precis = 0.0002;\n    float material = -1.0;\n    \n    // for more accuracy increase the amount of checks in the for loop\n    for(int i = 0; i < 60; i++) {\n        vec2 shapeObj = map(rayOrigin + t*rayDir);\n        float dist = shapeObj.x;\n        if(dist < precis || t > tmax) {\n            break;\n        }\n        t += dist;\n        material = shapeObj.y;\n    }\n    \n    if( t>tmax ) {\n    \tmaterial = -1.0; // didn't hit anything so background;\n    }\n    return vec2( t, material ); // return distance and material hit for this ray\n}\n\n\n// ----- LIGHTING --------\n// Inigo Quilez's soft shadow\nfloat softshadow(vec3 rayOrigin, vec3 rayDir, float mint, float maxt) {\n\tfloat k = 8.0; // how soft the shadow is (a constant)\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<10; i++) {\n        float h = map(rayOrigin + t*rayDir).x;\n        res = min(res, k*h/t);\n        t += h; // can clamp how much t increases by for more precision\n        if( h < 0.001 ) {\n        \tbreak;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Inigo Quilez's fast normal adjusted slightly becuase objects were shading themselves\nvec3 calcNormal(vec3 pos) {\n\tvec3 epsilon = vec3(0.023, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+epsilon.xyy).x - map(pos-epsilon.xyy).x,\n        map(pos+epsilon.yxy).x - map(pos-epsilon.yxy).x,\n        map(pos+epsilon.yyx).x - map(pos-epsilon.yyx).x);\n    return normalize(nor);\n}\n\n\nfloat getLighthouseLight(vec3 rayOrigin, vec3 rayDir) {\n    float time = 0.3*iTime;\n\tmat4 rot1 = mat4(0.0, 1.0, 0.0, 0.0,\n                      -1.0, 0.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, 0.0,\n                      0.0, 0.0, 0.0, 1.0);\n    mat4 rot2 = mat4(cos(time), 0.0, -sin(time), 0.0,\n                       0.0, 1.0, 0.0, 0.0,\n                       sin(time), 0.0, cos(time), 0.0,\n                       0.0, 0.0, 0.0, 1.0);\n    mat4 trans = rot1*rot2;\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float precis = 0.0002;\n    // for more accuracy increase the amount of checks in the for loop\n    for(int i = 0; i < 60; i++) {\n        vec3 pos = rayOrigin + t*rayDir;\n        float dist = sdCone(opTx(pos-vec3(3.0, 3.1, -3.0), trans), vec3(0.3, 0.04, 13.0));\n        if(dist < precis) {\n            break;\n        }\n        if(t > tmax) {\n            return 0.0;\n        }\n        t += dist; \n    }\n    return t;\n}\n\nvec3 applyFog(vec3  rgb, float dist, vec3 rayOri, vec3 rayDir) {\n    float b = 0.01;\n    float c = 0.2;\n    float d = 0.1;\n    float lightDist = getLighthouseLight(rayOri, rayDir);\n    float lightAmount = 1.0 - exp( -lightDist*d );\n    lightAmount = 0.6;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -dist*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7)-0.4*vec3(0.45, 0.2, 0.0);\n    vec3  lightCol = vec3(1.0,0.9,0.7);\n    if(lightDist > 0.0 && lightDist < 8.0) {\n        return mix(mix(rgb, fogColor, fogAmount), lightCol, lightAmount);\n    }\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// --- COMBINE EVERYTHING TO GET PIXEL COLOR\nvec3 calColor(vec3 rayOrigin, vec3 rayDir) {\n\tvec3 matCol; // material color\n   \t// finds the t of intersect and what is it intersected with\n    vec2 result = rayMarch(rayOrigin, rayDir);\n    float t = result.x;\n    \n    vec3 pos = rayOrigin + t*rayDir;\n    vec3 nor = calcNormal( pos );\n    vec3 reflectEye = reflect(normalize(rayDir), nor); // rayDir is the eye to position\n    vec3 posToLight; // define vector that is dependant per light\n    float ambCoeff = 0.1;\n    float shadow, attenuation, spotCos, spotCoeff = 0.0;           // how much in the light\n    float diff, spec;\n    \n    // define spotlight illuminating moon and then the moonlight\n    SpotLight moonSpot = SpotLight(MoonSpotPos, MoonSpotDir, MoonSpotCol, 1.0, 0.1, 20.0);\n    SpotLight light = SpotLight(LightPos, LightDir, LightCol, 0.9, 0.4, 20.0);\n    \n    bool background = false;\n    // set the material coefficients\n    if(result.y > 0.5 && result.y < 1.5) { //water\n        matCol = vec3(0.20,0.35,0.55);\n        float fo=pow(0.023*result.x, 1.1);\n            matCol=mix(matCol,vec3(0.91,0.88,0.98),fo);\n    } else if(result.y > 1.5 && result.y < 2.5) { // sphere in water\n        matCol = vec3(0.8);\n    } else if(result.y > 2.5 && result.y < 3.5) { // moon\n        reflectEye = reflect(normalize(-rayDir), nor);\n        matCol = vec3(5.0*fbm3(pos));\n    } else if(result.y > 3.5 && result.y < 4.5) { // main lighthouse body\n        // could do some parametric barbershop coloring here\n        matCol = vec3(0.7, 0.0, 0.0);\n    } else if(result.y > 4.5 && result.y < 5.5) { // lighthouse other parts\n    \tmatCol = vec3(0.7);\n    } else {\t\t\t\t\t\t\t\t\t  // background\n        background = true;\n    }\n    \n    // calculate light addition per spotlight\n    // Bidirectional reflectance distribution function\n    vec3 brdf = vec3(0.0);\n    // Add lighting from spot on the moon\n    posToLight = normalize(moonSpot.pos - pos);\n    spotCos = dot(posToLight, moonSpot.dir);\n    spotCoeff = smoothstep( 1.0-moonSpot.spread, 1.0, spotCos );\n    if(spotCos > 1.0-moonSpot.spread) { // within the spotlight\n    \tdiff = spotCoeff*clamp(dot(nor,posToLight), 0.0, 1.0);\n        spec = spotCoeff*pow(clamp(dot(reflectEye,posToLight), 0.0, 1.0), 20.0);\n        shadow = softshadow( pos, posToLight, 0.025, 2.5 );\n        attenuation = 1.0;\n        brdf += light.color*matCol*((diff+spec)*shadow*attenuation);\n    }\n    // Add lighting from spot away from the moon\n    posToLight = normalize(light.pos - pos);\n    spotCos = dot(posToLight, light.dir);\n    spotCoeff = smoothstep( 1.0-light.spread, 1.0, spotCos );\n    if(spotCos > 1.0-light.spread) { // within the spotlight\n    \tdiff = spotCoeff*clamp(dot(nor,posToLight), 0.0, 1.0);\n        spec = spotCoeff*pow(clamp(dot(reflectEye,posToLight), 0.0, 1.0), 20.0);\n        shadow = softshadow( pos, posToLight, 0.025, 2.5 );\n        attenuation = 1.0;\n        brdf += light.color*matCol*((diff+spec)*shadow*attenuation);\n    }\n    // Add Ambient\n    brdf += ambCoeff*vec3(0.50,0.70,1.00);\n    \n    // set the brackground\n    if(background) {\n    \tbrdf = 0.2*vec3(0.0, 0.2, 0.45);\n        result.x = 20.0;\n    }\n    // perform post processing effects\n    brdf = applyFog(brdf, result.x, rayOrigin, rayDir);\n    \n \treturn vec3(clamp(brdf, 0.0, 1.0));  \n}\n\n\n\n// CAMERA SETTING\nmat3 mkCamMat(in vec3 rayOrigin, in vec3 lookAtPoint, float roll) {\n    vec3 cw = normalize(lookAtPoint - rayOrigin);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0); //this is a temp right vec for cross determination\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera or eye (where rays start)\n    vec3 rayOrigin = vec3(0.0, 1.5, 4.0);\n    vec3 lookAtPoint = vec3(-1.0, 1.5, 0.0);\n    float focalLen = 1.0; // how far camera is from image plane\n    mat3 camMat = mkCamMat(rayOrigin, lookAtPoint, 0.0);\n\n    // ray direction into image plane\n    vec3 rayDir = camMat * normalize(vec3(p.xy, focalLen));\n    \n    //render the scene with ray marching\n    vec3 col = calColor(rayOrigin, rayDir);\n\n    fragColor = vec4(col, 1.0); \n\t//fragColor = vec4(.9); // that off white\n}\n","name":"Image","description":"","type":"image"}]}