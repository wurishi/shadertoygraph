{"ver":"0.1","info":{"id":"csXXDH","date":"1668777838","viewed":201,"name":"Hexagonal tiling - template","username":"jaszunio15","description":"Hexagonal tiling template. Made just for forking in the future, no reason to write this from scratch each time.\nTemplate is fully based on The Art of Code \"Hexagonal Tiling Explained!\", I just did the unobfuscation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["template","hexagon","tiling","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHexagonal tiling template. Made just for forking in the future, no reason to write this from scratch each time.\n\nEach hexagon is vec2(1.0, sqrt(3.0)) size. UV of each hexagon starts at it's center. So hexUV.x -0.5 and 0.5 lands perfectly on\nleft and right side of the hex.\n\nThere are some ready to use properties, like hexagonal length to hex center, distance to hex edge, sector ID etc.\n\nTemplate is fully based on The Art of Code \"Hexagonal Tiling Explained!\": https://youtu.be/VmrIDyYiJBA\nI just unobfuscated the code a little to make it easier to understand.\n*/\n\nfloat HexagonalLength(vec2 uv)\n{\n    uv = abs(uv);\n    float dist = dot(uv, normalize(vec2(1.0, sqrt(3.0))));\n    dist = max(dist, uv.x);\n    return dist;\n}\n\nfloat DistanceToHexEdge(vec2 uv)\n{\n    return -HexagonalLength(uv) + 0.5;\n}\n\n#define PI 3.1419\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    uv *= 5.0;\n\n    vec3 col;\n    \n    vec2 hexSize = vec2(1.0, sqrt(3.0));\n    vec2 halfHexSize = hexSize * 0.5; \n    \n    vec2 firstHexUV = mod(uv, hexSize) - halfHexSize;\n    vec2 secondHexUV = mod(uv - halfHexSize, hexSize) - halfHexSize;\n    \n    vec2 hexUV = length(firstHexUV) < length(secondHexUV) ? firstHexUV : secondHexUV;\n    \n    float hexagonalLength = HexagonalLength(hexUV); // Hexagonal length to the center of the hexagon\n    float euclideanLength = length(hexUV); // Euclidean length to the center of hexagon\n    float distanceToEdge = DistanceToHexEdge(hexUV); // Distance to the closest edge of the hexagon\n    float sectorID = floor((atan(hexUV.x, hexUV.y) / PI) * 3.0 + 3.0); // divides hexagon into sectors, ordering from 0 to 5\n    \n    // pixel perfect border\n    float pixelSize = fwidth(uv.x);\n    float pixelPerfectBorder = smoothstep(0.5 - pixelSize, 0.5, abs(hexagonalLength));\n    \n    // Output to screen\n    fragColor = vec4(hexUV, distanceToEdge + pixelPerfectBorder, 1.0);\n}","name":"Image","description":"","type":"image"}]}