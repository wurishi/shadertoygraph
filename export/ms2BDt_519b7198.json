{"ver":"0.1","info":{"id":"ms2BDt","date":"1690429942","viewed":20,"name":"RayMarchingBiliBili","username":"LudenGhost","description":"一个小电视","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE_INFO vec4(0,1,6,1) // xyz = position , w = radius\n#define MAX_STEPS 100 // march steps int\n#define MAX_DIS 100.0\n#define SURFACE_DISTANCE 0.01 \n#define LIGHT_POS vec3(0,3,3)\n#define CAMERA_POSITION vec3(0,1.5,0)\n\n//======================================= Shape Expression =======================================\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float radius){\n// capsule is controled by 2sphere\n// input ab are position from two spheres\n// radius is the raidus of those spheres\n// p is camera position\n\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    \n    vec3 c = a + t*ab;\n    float d = length(p-c)-radius;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p,vec2 r){\n// p is camera position\n// r.x is the radius of torus\n// r.y is the radius of circul around torus \n\n    float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n}\n\nfloat dBox(vec3 p ,vec3 s){\n// p is camera position\n// s is the scale xyz of box\n    return length(max(abs(p)-s,0.));\n}\n\nfloat sdCylinder(vec3 p,vec3 a,vec3 b,float radius){\n// capsule is controled by 2sphere\n// input ab are position from two spheres\n// radius is the raidus of those spheres\n// p is camera position\n\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap)/dot(ab,ab);\n    //t = clamp(t,0.,1.);\n    \n    vec3 c = a + t*ab;\n    float x = length(p-c)-radius;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    \n    float i = min(max(x,y),0.);\n    \n    return e+i;\n}\n\n//=================================================================================================\n//======================================= RayMarching Function =======================================\n\nfloat getDist(vec3 pos){\n    vec4 sphere = SPHERE_INFO;\n    \n    float planeDist = pos.y; // distance by pos to ground\n    \n    // float sphereDist = length(pos-sphere.xyz) - sphere.w; // distance by pos to face of sphere \n    float capsuleDistance1 = sdCapsule(pos,vec3(0.8,2.5,6),vec3(0.2,1.8,6),0.18);\n    float capsuleDistance2 = sdCapsule(pos,vec3(-0.8,2.5,6),vec3(-0.2,1.8,6),0.18);\n    \n    float capsuleDistance3 = sdCapsule(pos,vec3(0.9,1.1,5.6),vec3(0.5,1.4,5.6),.17);\n    float capsuleDistance4 = sdCapsule(pos,vec3(-0.9,1.1,5.6),vec3(-0.5,1.4,5.6),.17);\n\n    float capsuleDistance5 = sdCapsule(pos,vec3(-0.6,0.6,5.5),vec3(-0.3,0.3,5.5),.1);\n    float capsuleDistance6 = sdCapsule(pos,vec3(-0.3,0.3,5.5),vec3(-0.,0.6,5.5),.1);\n    float capsuleDistance7 = sdCapsule(pos,vec3(0.3,0.3,5.5),vec3(-0.,0.6,5.5),.1);\n    float capsuleDistance8 = sdCapsule(pos,vec3(0.3,0.3,5.5),vec3(0.6,0.6,5.5),.1);\n\n    // float torusDistance = sdTorus(pos-vec3(0,.5,6),vec2(1.5,.25));\n    float boxDistance = dBox(pos - vec3(0,1,6),vec3(1.5,1.,.5));\n    // float cylinderDistance = sdCylinder(pos,vec3(2,1,3),vec3(2,1,5),.2);\n\n    float d = min(capsuleDistance1,planeDist);\n     d = min(d,capsuleDistance2);\n     d = min(d,capsuleDistance3);\n     d = min(d,capsuleDistance4);\n     d = min(d,capsuleDistance5);\n     d = min(d,capsuleDistance6);\n     d = min(d,capsuleDistance7);\n     d = min(d,capsuleDistance8);\n\n    // d = min(d,torusDistance);\n    d = min(d,boxDistance);\n    // d = min(d,cylinderDistance);\n\n    \n    return d; // if choose lengther distance ,the ray will lose from the sphere\n}\n\nfloat RayMarch(vec3 rayOrigin , vec3 rayDir){\n    float resultDistance = 0.;\n          \n    for(int i=0;i<MAX_STEPS;i++){\n       vec3 p = rayOrigin + rayDir * resultDistance;\n       float dS = getDist(p);\n       resultDistance += dS;\n       \n       if(resultDistance > MAX_DIS || dS < SURFACE_DISTANCE) break;\n    }\n    \n    return resultDistance;\n}\n\nvec3 GetNormal(vec3 p){\n    float distanceAtPointp = getDist(p);\n    vec2 e = vec2(0.01,0);\n    vec3 n = distanceAtPointp - vec3( getDist(p-e.xyy) , getDist(p-e.yxy) , getDist(p-e.yyx) );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPosition = LIGHT_POS;\n    \n    lightPosition.xz += vec2(sin(iTime),cos(iTime))*2.;\n    \n    vec3 lightVector = normalize(lightPosition-p);\n    vec3 normal = GetNormal(p);\n    \n    float dif = clamp(dot(normal,lightVector),0.,1.);\n    \n    float d = RayMarch(p+normal * SURFACE_DISTANCE * 2.0 , lightVector);\n    if(d<length(lightPosition-p))dif*=0.1;\n    \n    return dif;\n}\n//=================================================================================================\n//======================================= Main =======================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 rOrient = CAMERA_POSITION;\n    vec3 rDir = normalize(vec3(uv.x,uv.y,1)); // ray vector , shoot from camera to ScreenPixels\n\n    float d = RayMarch(rOrient,rDir);\n\n    vec3 p = rOrient + rDir * d;\n    float diffuseColor = GetLight(p);\n    col = vec3(diffuseColor);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}