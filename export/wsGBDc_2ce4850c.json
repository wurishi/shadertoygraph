{"ver":"0.1","info":{"id":"wsGBDc","date":"1608111585","viewed":95,"name":"2000 SPP Montecarlo","username":"Oberdiah","description":"Using iq's intersection funcs for tracing, then turning samples up until the noise disappears. Runs at 55fps on a 3070 at 800x450, so it's got little use. Cool to see such a high fidelity image in real-time, though. (WASD + SPACE/CTRL)","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raycasting","gi","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//camera\n#define movespeed 25.0\n\n//movement keys\n#define MOVE_FORW  87\n#define MOVE_LEFT  65\n#define MOVE_RIGHT 68\n#define MOVE_BACK  83\n#define MOVE_UP    32\n#define MOVE_DOWN  17\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nfloat getkey(int x, int y){\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nbool evaluateInput(inout vec3 rayDir, inout vec3 rayPos, inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 mousePos = iMouse.xy;\n    \n    if (mousePos.x == 0. && mousePos.y == 0.) {\n        mousePos.xy = vec2(276, 217);\n    }\n    \n    rayDir.yz *= rot(mousePos.y/iResolution.y*3.14-3.14*0.5);\n    rayDir.xz *= rot(mousePos.x/iResolution.x*3.14*2.0-3.14);\n\t\n    vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                     getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                     getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n    \n    if ( ivec2(fragCoord) == ivec2(0)) {\n        vec3 rd2 = vec3(0,0,1);\n        rd2.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        rd2.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        \n        mat3 rotate = mat3(normalize(cross(vec3(0,1,0),rd2)),vec3(0),rd2);\n        rotate[1] = cross(rotate[2],rotate[0]);\n        \n        fragColor.xyz = rayPos+move*movespeed*iTimeDelta*transpose(rotate);\n\t\treturn true;\n    }\n    return false;\n}\n\nstruct HitInfo {\n    vec3 color;\n    vec3 pos;\n    vec3 normal;\n    bool emissive;\n    bool hit;\n};\n\nfloat getVoxel(in vec3 p) {\n    return -length(p) + 5.;\n}\n\n// From https://iquilezles.org/articles/intersectors\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p ) {\n    float q = -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n    if (q < 0.) return 1000000000.;\n    return q;\n}\n\n// From https://iquilezles.org/articles/intersectors\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return 1000000000.; // no intersection\n    h = sqrt( h );\n    float q = -b-h;\n    if (q < 0.) return 1000000000.;\n    return q;\n}\n\nfloat sphereSize = 5.;\nfloat glowSize = 100.;\nfloat barHeight = 20.;\nvec4 plane1 = vec4(0, 1, 0, 7);\nvec4 plane2 = vec4(1, 0, 0, 10);\n\nHitInfo trace(in vec3 pos, in vec3 dirT) {\n    vec3 dir = normalize(dirT);\n    HitInfo hi;\n    \n    float a = plaIntersect(pos, dir, plane1);\n    float b = plaIntersect(pos, dir, plane2);\n    float s = sphIntersect(pos, dir, vec3(20, -5, 2), sphereSize);\n    float win = min(min(a, b), s);\n    \n    vec3 outPos = pos + dir * win;\n    vec3 t = vec3(outPos.xy, mod(outPos.z, 100.));\n    float centreDist = dot(t, t);\n    hi.color = vec3(0.2, 1, 0.4);\n    \n    if (a == win) {\n        hi.normal = plane1.xyz;\n        if (mod(outPos.z, 20.) < 5.) {\n            hi.color = vec3(1,0.2,0.5); \n        } else if (centreDist > 500. && centreDist < 700.) {\n            hi.color = vec3(1.0,0.1,0.5);\n            hi.emissive = true;\n        } else {\n            hi.color = vec3(1);\n        }\n    } else if (b == win) {\n        if (centreDist < glowSize) {\n            hi.color = vec3(1);\n            hi.emissive = true;\n        }\n        hi.normal = plane2.xyz;\n    } else if (s == win) {\n        hi.normal = normalize(outPos - vec3(20, -5, 2));\n        hi.color = vec3(1);\n        //hi.emissive = true;\n    }\n    hi.pos = outPos + hi.normal * 0.01;\n    \n    return hi;\n}\n\nbool applyLight(HitInfo hi, inout vec3 light) {\n    light *= hi.color * (float(hi.emissive)*-2.+1.);\n    return hi.emissive;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.65);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = texelFetch(iChannel0,ivec2(0),0).xyz;\n    \n    if (evaluateInput(rayDir, rayPos, fragColor, fragCoord)) return;\n    vec3 color;\n    uint samples = 200U;\n    sphereSize = 5. + sin(iTime/2.) * 2.5;\n    glowSize = max(sin(iTime/5.)*100. + 250., 0.);\n    \n    HitInfo startHi = trace(rayPos, rayDir);\n    \n    vec3 colPos = startHi.pos;\n    \n    vec3 light = vec3(-1);\n    \n    if (applyLight(startHi, light)) {\n        color += light*float(samples);\n    } else {\n        vec3 resetLight = light;\n        \n        for (uint i = 0U; i < samples; i++) {\n            vec3 normal = startHi.normal;\n            vec3 hitLoc = colPos;\n            for (uint reflectNo; reflectNo < 2u; reflectNo++) {\n                uint seed = uint(abs(dot(hitLoc, hitLoc)) * (float((i*34U)^(i*84U))/100.) + 167.87);\n                float c = (float((seed*0x73493U)&0xfffffU)/float(0x100000));\n                float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n                \n                float cosa = sqrt(1.-c*c);\n                vec3 r = vec3(cosa*cos(b),c,cosa*sin(b));\n                rayDir = dot(r, normal)>.0?r:-r;\n                \n                HitInfo hi = trace(hitLoc, rayDir);\n                normal = hi.normal;\n                hitLoc = hi.pos;\n                if (applyLight(hi, light)) {\n                    color += light;\n                    break;\n                }\n            }\n            light = resetLight;\n        }\n    }\n    // color = startHi.color * float(samples);\n\tvec3 col = color/float(samples);\n    \n    // burn the highlights\n    float g = dot(col,vec3(0.3333));\n    col = mix( col, vec3(g), min(g*0.15,1.0) );\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    // instafilter\n    col = 1.15*pow( col, vec3(0.9,0.95,1.0) ) + vec3(-0.04,-0.04,0.0);\n\n    // vignete\n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    // output\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}