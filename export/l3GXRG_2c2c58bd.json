{"ver":"0.1","info":{"id":"l3GXRG","date":"1720100685","viewed":86,"name":"Raycasting the oldschool way","username":"stduhpf","description":"Rendering 2D SDFs in 3D with wolfenstein-esque single row raycasting.\n\nControls: arrow keys (up: move forwards, down: move backwards, left/right : rotate camera around y axis)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["fake3d","racasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROOM_HEIGHT 1.\n\nvec2 mm_transform(vec2 uv){\n    return (uv*2.-1.)*iResolution.xy/iResolution.y;\n}\n\nvec2 mm_transform_i(vec2 uv){\n    return (uv*iResolution.y/iResolution.xy)*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 mmuv = uv*5.-vec2(0,4.);\n    \n    vec4 player = texture(iChannel1,vec2(0));\n    \n    //MINIMAP\n    if(mmuv == fract(mmuv)){\n        mmuv=mm_transform(mmuv);\n        float d = sdf2D(mmuv);\n        fragColor = vec4(sign(d)<0.) + .15*(sin(-d*100.)+1.);\n        \n        // player display\n        mat2 camera = mat2(player.w,player.z,-player.z,player.w); \n        if(distance(mm_transform(clamp(mm_transform_i(player.xy),0.,1.)),mmuv)<.02)\n                fragColor =vec4(0,0,1,1);\n        if(distance(player.xy+player.zw*.05,mmuv)<.01)\n                fragColor =vec4(0,1,0,1);\n        \n        // debug raymarching\n        #define NUM_RAYS_MINIMAP 15\n        for(int i = 0; i<NUM_RAYS_MINIMAP;i++){\n            float x = float(i)/float(NUM_RAYS_MINIMAP-1);\n            vec2 ro = player.xy;\n            vec2 rd = normalize(defaultCam(x))*camera;\n\n            float d = 0.;\n            for(int i = 0;i<MAX_STEPS;i++){\n                float h = sdf2D(ro);\n                d+=h;\n                if(h<.0001){\n                    break;\n                }\n                ro+=rd*h;\n                if(distance(ro,mmuv)<.015)\n                    fragColor =vec4(1,i,i/2 ,1);\n            }     \n        }\n        return;\n    }\n    \n    vec4 data =  texture(iChannel0,vec2(uv.x,0));\n    \n    uv.y-=.5;\n    \n    float va = data.x; // ray angle\n    float h0 = data.y; // base hit wall height\n    float z  = data.z; // center depth\n    float iv = data.a; // inverse tangent of column-dependant vertical fov (image plane height/image plane depth for y=0)\n    \n    \n    float h = ROOM_HEIGHT*h0; // apparent wall height in pixels \n    \n    float pixelHeight = 2.*uv.y/h0; // world y value (height) of the current pixel if displaying wall\n    float realDepth = length(vec2(z,pixelHeight)); // Using z instead is mostly good enough and spares a sqrt\n    \n    float floorz = iv*ROOM_HEIGHT/(-2.*uv.y); // plane distance value of the current pixel if displaying floor/ceiling\n    float realFloorDepth= length(vec2(floorz, ROOM_HEIGHT)); // Using abs(floorz) instead is mostly good enough and spares a sqrt\n    \n    //for floor texturing\n    vec2 dir = vec2(cos(va),sin(va)); // normalize(defaultCam(uv.x))*mat2(player.w,player.z,-player.z,player.w);    \n    vec2 floorCoords = player.xy + abs(floorz)*dir;\n    \n    const float foginess = 1.;\n    \n    vec3 col = abs(uv.y)*2.<h?vec3(exp2(-realDepth*foginess)):\n        exp2(-realFloorDepth*foginess)*(floorz>0.?texture(iChannel2,floorCoords).rgb:texture(iChannel3,floorCoords).rgb);\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// VIEW_WIDTH = tan(h_fov/2)\n#define VIEW_WIDTH 2.0\n\nvec2 defaultCam(float x){\n    return (vec2((x-.5)*VIEW_WIDTH,1.));\n}\n\n\n// PRIMITIVES\n\nfloat sdfBox(vec2 p, vec2 s )\n{\n    p = abs(p)-s;\n    return length(max(p,0.)) + min(max(p.x,p.y),0.);\n}\n\nfloat sdfKoch(vec2 uv,bool alt){\n    const int it = 9;\n    const vec2 n = normalize(vec2(2.*sqrt(.75),-1));\n\n    float k = 1.;\n    for(int i = 0;i<it;i++){\n        uv.x=abs(uv.x)-.5;\n\t\tvec2 ni = alt && i%2==1?n*vec2(1,-1):n;\n        if(dot(uv,ni)<0.)\n        uv = reflect(uv,ni);\n\n        uv*=3.;\n        uv.x-=1.5;\n        k*=1./3.;\n    }\n    uv.x+=1.5;\n    k*=3.;\n    uv/=3.;\n    \n    return distance(uv,vec2(clamp(uv.x,-0.,1.),0.))*k;\n}\n\n\n// SCENE\n\n#define ADDOBJ(o) d = min(d,o)\nfloat sdf2D(vec2 p){\n    float d = distance(p,vec2(.5))-.1; //cylinder\n    ADDOBJ(sdfBox(p-vec2(.2,.75),vec2(.1)));\n    ADDOBJ(sdfBox(p-vec2(-2.,0),vec2(.5)));\n    ADDOBJ(sdfKoch((p-vec2(0,-1.))*1.5,false)/1.5);\n    ADDOBJ(sdfKoch((p-vec2(0,10.))/15.,true)*15.);\n\n    return d;\n}\n\n\n\n// RAYMARCHING\n\n#define MAX_STEPS 100\nfloat trace(vec2 ro, vec2 rd){\n    \n    float d = 0.;\n    for(int i = 0;i<MAX_STEPS;i++){\n        float h = sdf2D(ro);\n        d+=h;\n        if(h<.0001){\n            return d;\n        }\n        ro+=rd*h;\n    }\n    return -1.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\n// PLAYER CONTROLS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0){\n        vec2 p = vec2(-1.5,1);\n        vec2 dir = normalize(vec2(2,-1));\n        fragColor = vec4(p,dir);\n        return;\n    }\n    vec4 bb = texture(iChannel0,vec2(0));\n    \n    vec2 p = bb.xy;\n    vec2 dir = bb.zw;\n    \n    float stepDist = 1.*iTimeDelta;\n    \n    float stepAngle = 1.6*iTimeDelta;\n    float cs = cos(stepAngle), ss = sin(stepAngle);\n    \n\n    if(texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x>0.){\n        p += dir*stepDist;\n    }\n    if(texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x>0.){\n        p -= dir*stepDist;\n    }\n    \n    if(texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x>0.){\n        dir *= mat2(cs,-ss,ss,cs);\n    }\n    if(texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x>0.){\n        dir *= mat2(cs,ss,-ss,cs);\n    }\n    \n    fragColor = vec4(p,dir);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// 1D SCANLINE RAYCASTING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y>1.)return;\n    vec4 player = texture(iChannel0,vec2(0));\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = player.xy;\n    vec2 camSetup = defaultCam(uv.x);\n    vec2 dir = normalize(camSetup)*mat2(player.w,player.z,-player.z,player.w);\n\n    float d = trace(p,dir);\n    \n    // height of the image plane (distance 1 from camera, with = VIEW_WIDTH) = tan(v_fov/2)\n    float view_height = VIEW_WIDTH * iResolution.y/iResolution.x;\n    \n    // distance to the image plane (1 in the center, a bit more closer to the the edges)\n    float img_dist = length(camSetup);\n    \n    img_dist/= view_height;\n    \n    float h = img_dist/d; // apparent wall height in pixels\n\n    //if we had more channels we could use the dir vector as is to save on some trig\n    fragColor = vec4(atan(dir.y,dir.x),h,d,img_dist); \n}","name":"Buffer B","description":"","type":"buffer"}]}