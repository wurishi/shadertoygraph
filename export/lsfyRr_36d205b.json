{"ver":"0.1","info":{"id":"lsfyRr","date":"1486778615","viewed":207,"name":"path marcher w/ dither","username":"public_int_i","description":"path marcher 2, now with dithering.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2","marcher","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2017\n\n\n//Image - Apply light adaption to render.\n\n\n#define TARGET_COLOR vec3(.5)\n#define ADAPTION_AMOUNT 1.\n\n\n//blue noise from here https://www.shadertoy.com/view/4dSyDR\nfloat hash( uint n ) { // from https://www.shadertoy.com/view/llGSzw  Base: Hugo Elias. ToFloat: https://iquilezles.org/articles/sfrand\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.;\n}\n\nfloat noise(vec2 U) {\n    U-=.5; return hash(uint(U.x+iResolution.x*U.y));\n}\n\nfloat bluenoise(vec2 U) {\n#define V(i,j)  noise(U+vec2(i,j))\n    float N = 8./9.* noise( U ) \n           - 1./9.*( V(-1,-1)+V(0,-1)+V(1,-1) +V(-1,0)+V(1,0) +V(-1,1)+V(0,1)+V(1,1) );  \n    return N*0.5;\n}\n\nvec3 dither(vec2 uv, vec3 c) {    \n    return floor(c*8.+vec3(bluenoise(uv*1024.),\n                           \tbluenoise(uv*1024.+vec2(.1093,.9843)),\n                            bluenoise(uv*1024.+vec2(.97,1.34))))/7.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0, uv),\n         b = texture(iChannel1, .5/iResolution.xy);\n    \n    //apply light adaption\n    b.xyz /= TARGET_COLOR;\n    c.xyz = mix(c.xyz,c.xyz/b.xyz,ADAPTION_AMOUNT);\n    \n    //apply dither(hide noise)\n    c.xyz = dither(uv, c.xyz);\n    \n\tfragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2017\n\n//Buf A - Rendering\n\n\n\n\nconst float PI = 3.141592,\n            PI2 = PI*2.;\n\nstruct material {\n    vec3 diffuse, specular;\n    float metallic, roughness, emission;\n};\n    \nvec3 hash33(vec3 p);\nfloat hash13(vec3 s);\n\n\nvec2 rot2(vec2 p, float a);\n\n\n#define motionBlur(p,v) (p+v*(hash13(p+fract(vec3(iFrame)/vec3(1.092384,25.28394,1564.82934)))-0.5))\n#define transparency(d,o) mix(d,1e7,clamp((hash13(p+fract(vec3(iFrame)/vec3(1.092384,25.28394,1564.82934)))-o)*1e7,0.,1.))\n\n\n\n//SCENE FUNCTIONS & VARIABLES\n\n\nconst vec3 CAMERA_POSITION = vec3(-27.,-20.,-29.);\nconst vec2 CAMERA_ROTATION = vec2(PI/3.4, PI/2.2);\n    \n    \nconst vec3 DEPTH_OF_FIELD_FOCALPOINT = vec3(5.,.7,0.);\nconst float DEPTH_OF_FIELD_POW = 1.0,\n    \t\tDEPTH_OF_FIELD_SPIKES = 8.;\n//#define DEPTH_OF_FIELD 1.\n\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//returns distance, material id\nvec2 scene(vec3 p, float e) {\n    //box\n    vec2 sr = vec2(-sdBox(p,vec3(30.)),0.);\n    \n    //light\n    if (p.y > 29.5) {\n        sr.y = 1.;\n    }\n    \n    //red wall\n    if (p.x > 29.5) {\n        sr.y = 2.;\n    }\n    \n    //green wall\n    if (p.x < -29.5) {\n        sr.y = 3.;\n    }\n    \n    //box\n    vec3 lp = p-vec3(-5.,-16.,-5.);\n    float odst = sdBox(lp,vec3(10.,10.,10.)) + textureLod(iChannel0, normalize(lp),0.0).x*2.0;\n    if (odst < sr.x) {\n        sr = vec2(odst, 0.);\n    }\n    \n    return sr;\n}\n\n//outputs material(m) from material id, position(p) and normal(n)\nvoid getMaterial(float id, vec3 p, vec3 n, out material m) {\n    \n    if (id < 1.) {\n        //floor\n       \tm = material(vec3(.4, .4, .4),//diffuse\n                     vec3(.7),//specular\n                     .8,//metallic\n                     0.,//roughness\n                     0.//emission\n                    );\n        return;\n    }\n    \n    if (id < 2.) {\n        //light\n        vec2 fp = floor(p.xz/20.);\n       \tm = material(vec3(.9,.9,.9),//diffuse\n                     vec3(.9),//specular\n                     .2,//metallic\n                     1.,//roughness\n                     max(0.,mod(fp.x+fp.y,3.)-1.)//emission\n                    );\n        return;\n    }\n    \n    if (id < 3.) {\n        //red wall\n       \tm = material(vec3(1., 0., 0.),//diffuse\n                     vec3(1., 0., 0.),//specular\n                     1.,//metallic\n                     1.,//roughness\n                     0.//emission\n                    );\n        return;\n    }\n    \n        //green wall\n       \tm = material(vec3(1., 0., 0.),//diffuse\n                     vec3(0., 1., 0.),//specular\n                     1.,//metallic\n                     1.,//roughness\n                     0.//emission\n                    );\n        return;\n\n}\n\n//returns background color from ray direction(d)\nvec3 background(vec3 d) {\n    return vec3(0.);\n    //return pow(texture(iChannel0, d).xyz,vec3(2.2));//vec3(max(0.,dot(d,vec3(-1.,0.,0.)))*10.);//pow(texture(iChannel0, d).yxz, vec3(2.2));\n}\n\n\n\n\n\n//RENDERING VARIABLES\nconst int ITERATIONS = 256;\n\nconst float MIN_EPSILON = 2e-2,\n    \t\tMAX_EPSILON = 5e-1,\n    \t\tEPSILON_FADE_DISTANCE = 1e2,\n    \n    \t\tMIN_STEP = 0.7,\n    \t\tMAX_STEP = 1.0;\n\n\n\n//2d rotation\nvec2 rot2(vec2 p, float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\n//generate seed from current iDate.w\nfloat timeSeed() {\n    float tseed = floor(iDate.w);\n    return fract(tseed*.73624+fract(iDate.w-tseed*.0928275)*1974.3252+float(iFrame)*.98726);\n}\n\n//random float3 with values from 0-1 seeded from float3\nvec3 hash33(vec3 p) {\n\treturn fract(abs(cos(p*.19487)*9284.3459 + cos(p.zxy*29.97612)*37.92384));\n}\n\n//random float from 0-1 seeded from float3\nfloat hash13(vec3 s) {\n\treturn fract(abs(cos(dot(s, vec3(7, 157, 113))))*43758.5453);\n}\n\n\n//calculate up(binorm) and right(tang) normals\nvoid calculateUpRight(vec3 normal, out vec3 tangent, out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    } else {\n\t\ttangent = normalize(vec3(0., normal.z, -normal.y));\n\t}\n    \n\tbinormal = cross(normal, tangent);\n}\n//polar->cartesian\nvec3 polarToCartesian(float sinTheta, float cosTheta, \n\t\t\t\t      float sinPhi, float cosPhi) {\n\treturn vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\n\n//BRDF functions are from\n//mplanck https://www.shadertoy.com/view/lsV3zV\n//reindeer https://www.shadertoy.com/view/4tl3z4\n\n//brdf simulating microscopic surface roughness(bumps)\nvec3 brdf(vec3 rnd, vec3 norm, float rough, vec3 view, vec3 tangent, vec3 binormal) {\t\t\t\t\n\tfloat cosTheta = pow(max(0., rnd.x), rough*(1.-1e-6)+1e-6),\n          sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta)),\n          phi = rnd.y * PI2;\n    \n\tvec3 ldir = polarToCartesian(sinTheta, cosTheta, sin(phi), cos(phi)),\n         dir = normalize(ldir.x*tangent + ldir.y*binormal + ldir.z*norm);\n\t\n    dir = reflect(view, dir*(step(0.,dot(dir,-view))*2.-1.));\n    return dir*(step(0.,dot(dir,norm))*2.-1.);\n}\n//simple cos-weighted brdf\nvec3 brdf2(vec2 r, vec3 n) {\n    vec3 uu = normalize(cross( n, vec3(0.0,1.0,1.0)));\n\tvec3 vv = cross(uu, n);\n    \n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(r.x*PI2),\n          ry = ra*sin(r.x*PI2);\n\tfloat rz = sqrt(1.0 - r.y);\n\n\treturn normalize(rx*uu + ry*vv + rz*n);\n}\n\n\nvec3 normal(vec3 p) {\n    const vec2 NE = vec2(MIN_EPSILON, 0.);\n    return normalize(vec3(scene(p+NE.xyy,MIN_EPSILON).x-scene(p-NE.xyy,MIN_EPSILON).x,\n                          scene(p+NE.yxy,MIN_EPSILON).x-scene(p-NE.yxy,MIN_EPSILON).x,\n                          scene(p+NE.yyx,MIN_EPSILON).x-scene(p-NE.yyx,MIN_EPSILON).x));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //init, 2 seconds to go fullscreen\n        return;\n    }\n    \n    vec2 R = iResolution.xy/2.;\n    vec2 uv = fragCoord.xy / R;\n    \n    \n    //cut off 3/4th the screen because we only need 1/4th for super-sampling\n    if (uv.x >= 1. || uv.y >= 1.) return;\n    \n    \n    //pixel jitter for temporal super-sampling\n    float tseed = timeSeed();\n    vec3 tseed3 = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(42.7723,2.9914,26.9783)));\n    vec2 jitter = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(.92873,.092834,2.19823))).xy-0.5;\n    vec2 nuv = ((fragCoord+jitter)*2.-R)/R.x;\n    \n    \n    \n    //raymarch path\n    vec3 rp = CAMERA_POSITION,\n         rd = normalize(vec3(nuv,1.));\n    rd.yz = rot2(rd.yz, CAMERA_ROTATION.y);\n    rd.xz = rot2(rd.xz, CAMERA_ROTATION.x);\n    \n    #ifdef DEPTH_OF_FIELD\n    vec3 cup, cright,\n         fdir = normalize(DEPTH_OF_FIELD_FOCALPOINT-rp);\n    calculateUpRight(rd, cright, cup);\n    \n    vec2 crnd = hash33(rd+tseed3*2.19827).xy-0.5;\n    float ang = atan(crnd.y,crnd.x);\n    \n    float dofAmount = DEPTH_OF_FIELD*(1.-pow(dot(rd,fdir),DEPTH_OF_FIELD_POW))*\n        \t\t\t\t\t\t\tsin(ang*DEPTH_OF_FIELD_SPIKES);\n    rd = normalize(rd+(cup*crnd.x+cright*crnd.y)*dofAmount);\n    #endif\n    \n    \n    float s = 0.;\n    \n    vec3 l = vec3(1.),\n         o = vec3(0.);\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec3 p = rp+rd*s;\n        float epsilon = MIN_EPSILON+(MAX_EPSILON-MIN_EPSILON)*min(1.,s/EPSILON_FADE_DISTANCE);\n        vec2 sr = scene(p,epsilon);\n        \n        if (sr.x < epsilon) {\n            vec3 norm = normal(p),\n                 rnd = hash33(p+tseed3),\n                tang,binorm;\n            \n            material mat;\n            getMaterial(sr.y, p, norm, mat);\n            \n            l *= mix(mat.diffuse,mat.specular,0.5+0.5*mat.metallic);\n            o += l*mat.emission;\n            \n            calculateUpRight(norm, tang, binorm);\n            \n            rd = brdf(rnd, norm, mix(mat.roughness,1.,step(0.5+0.5*mat.metallic,hash13(p-tseed3))), rd, tang, binorm);\n            rp = p+norm*MIN_EPSILON;\n            s = 0.;\n        }\n        \n        s += sr.x*(MIN_STEP+hash13(p+tseed3)*(MAX_STEP-MIN_STEP));\n    }\n    \n    float epsilon = (MIN_EPSILON+(MAX_EPSILON-MIN_EPSILON)*min(1.,s/EPSILON_FADE_DISTANCE));\n    o += l*background(rd)*step(epsilon, scene(rp+rd*s, epsilon).x);\n    fragColor = vec4(o,1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2017\n\n//Buf B - Super-sampling convolution.\n\n\n\n//generate seed from current iDate.w\nfloat timeSeed() {\n    float tseed = floor(iDate.w);\n    return fract(tseed*.73624+fract(iDate.w-tseed*.0928275)*1974.3252+float(iFrame)*.98726);\n}\n\n\n//random float3 with values from 0-1 seeded from float3\nvec3 hash33(vec3 p) {\n\treturn fract(abs(cos(p*.19487)*9284.3459 + cos(p.zxy*29.97612)*37.92384));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //init blank, 2 seconds to go fullscreen\n        fragColor = vec4(0.);\n        return;\n    }\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    //pixel jitter\n    float tseed = timeSeed();\n    vec2 jitter = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(.92873,.092834,2.19823))).xy-0.5;\n\n    vec4 r = texture(iChannel1, uv);\n    vec2 muv = fragCoord-0.5;\n    \n    vec4 s = vec4(0.);\n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            vec2 suv = floor(fragCoord/2.)+vec2(x,y);\n            vec3 c = texture(iChannel0, (suv+0.5)/iResolution.xy).xyz;\n            float portion = max(0., 1.-(length(suv*2.+jitter-muv)/1.41));\n            s += vec4(c,1.)*portion;\n        }\n    }\n    if (s.w > 0.) s /= s.w;\n    \n    fragColor = r+s;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2017\n\n//Buf C - Buf B normalized and gamma corrected\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 v = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = pow(v/v.w,vec4(1./2.2));\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Ethan Alexander Shulman 2017\n\n//Buf D - Average color calculation\n\n\n\n//generate seed from current iDate.w\nfloat timeSeed() {\n    float tseed = floor(iDate.w);\n    return fract(tseed*.73624+fract(iDate.w-tseed*.0928275)*1974.3252+float(iFrame)*.98726);\n}\n\n\n//random float3 with values from 0-1 seeded from float3\nvec3 hash33(vec3 p) {\n\treturn fract(abs(cos(p*.19487)*9284.3459 + cos(p.zxy*29.97612)*37.92384));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //init, 2 seconds to go fullscreen\n        fragColor = vec4(.2);\n        return;\n    }\n    \n    if (floor(fragCoord.x) != 0. || floor(fragCoord.y) != 0.) return;\n    \n    vec4 c = texture(iChannel0, .5/iResolution.xy);\n    \n    float tseed = timeSeed();\n    vec2 sp = floor(hash33(vec3(tseed)).xy*iResolution.xy);\n    \n    vec4 s = vec4(0.);\n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            s += texture(iChannel1, (sp+vec2(x,y)+0.5)/iResolution.xy);\n        }\n    }\n    \n    fragColor = mix(c,s/s.w,1./iResolution.x);\n}","name":"Buf D","description":"","type":"buffer"}]}