{"ver":"0.1","info":{"id":"sdtfzs","date":"1657088767","viewed":132,"name":"Thomas precession","username":"Amirk","description":"Two successive NON-COLLINEAR relativistic accelerations (\"Lorentz boosts\") add up to another linear acceleration into a new direction PLUS A ROTATION (Wigner rotation). In an orbital motion the phenomenon manifests as precession.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","tutorial","relativity","lorentz","acceleration","retardation","precession","thomas","wigner"],"hasliked":0,"parentid":"fdcfD8","parentname":"Rinddler Horizon"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//retardation effect ON/OFF:\nbool RETARD = true;\n\n/*\nWhat you should look for ;) :\nThere is a slight frame rotation (in addition to the obvious \"orbiting motion\") which makes the cylinders\nslowly progress to right in our field of vision. They will go full circles if you give them time.\nThis frame rotation is a collective phenomenon of multiple non-collinear Lorentz boosts. \nNo single boost will cause rotation.  \n\nAdditionally there are distortions and perceived bending of space, but that is dut to retardation\nwhich you can turn off from above.\n*/\n\n//Theoretical background: https://en.wikipedia.org/wiki/Wigner_rotation\n\n#define MAX_ITER 500.\n#define MAX_DIST 35.\n#define SURF .001\n\nvec4 fourvel;\nvec4 position;\n \nvec3 SIZE= vec3(.1); \n\n//ray origin in the moving coords.\nvec4 RO, rd;\n\nvec3 col = vec3(0);\nfloat vv;\n\n\n\nvec3 color( float c){\n    return vec3(1) - vec3(.8,.8,0)*smoothstep(.0,1., c)-\n            vec3(0.,.8,.8)*smoothstep(0.,1., -c);\n}\n\nvoid updateVel(){\n    // Fetch the offset from the Buffer A\n   \n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the offset from the Buffer B\n    \n    position =texelFetch( iChannel0, ivec2(5), 0 );\n}\n\n\n\nfloat sdBox(vec3 p , vec3 s){\n    p=fract(p)-.5; //this creates the grid of reference cubes\n    p= abs(p)-s;\n    return length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.05,.05));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner);\n}\n\nfloat sdAxes(vec4 p , float rad){\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes\n    \n    return  min(length(p.yz)-rad,length(p.xy)-rad);// length(p.xyz)-rad;  \n}\n\nfloat sdBall(vec4 q){\n    return length(q.xyz)-.09;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0))/(1.+length(fourvel.xyz));\n}\n\nfloat sdObject(vec4 q){\n   // q.x-=.0;\n   // q.z-=.0;\n        \n    vec4 Object4pos=position;\n    \n    q.xyz-=Object4pos.xyz;\n    \n    //vec4 qq=getInverse(q.w)*vec4(q.xyz,0);\n    q.xy*=rot(2.*q.w);\n\n    float d=sdBoxFrame(q.xyz*.8,vec3(.07,.07,.07),.005);\n   //float d=sdBox(qq,vec3(.1));\n   \n   return d*.9;\n}\n\n\nvoid getMaterial(vec4 p){\n    if(sdBall(p)<SURF*9.){\n        col=vec3(.6);\n    }\n    else{\n        p.xyz=fract(p.xyz)-.5; \n\n        if(length(p.yz)<length(p.xy)) col= vec3(1.,.3,.3);\n        else col= vec3(.3,.3,1.);\n    }\n}\n\nfloat getDist(vec4 q){\n    float dist= sdAxes(q,.05);\n    dist = min(dist,sdBall(q));\n    \n    return dist/(1.+.5*vv);\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w);\n    //the w-component determines how we look into past/future.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nfloat RayMarch2(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*sdObject(p)*.2; \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nvec3 getNormal2(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=sdObject(p);\n   vec3 n = d-vec3(sdObject(p- e.xyyy), sdObject(p- e.yxyy), sdObject(p- e.yyxy));\n   \n   return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n    \n    updateVel();\n    updatePos();\n    \n    //ray origin in lab coordinates:\n    RO=position;\n    float zoom= 1.;\n    \n    //look at in our moving coords:\n    vec4 lookAt;\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(0, 0, 1, -c);\n    else //the instantaneous geometry of spacetime/coordinates: \n        lookAt = vec4(1, 0, 0, 0);\n        \n    \n\n    if(sign(iMouse.z)>0.){\n        lookAt.zy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n  \n    mat4 TransformMat=Lorentz(initVel);\n    if(iFrame>10){\n        for(int i=1; i<=4; i++)\n           for(int j=1; j<=4; j++)\n              TransformMat[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    \n    }\n    \n    vec4 ray=getRayDir(uv, lookAt, zoom);\n    \n    rd= TransformMat*ray;      \n    vv= max(0.,-dot(fourvel.xyzw, rd.xyzw)); //length(fourvel.xyz);\n    \n    vec4 p=RO;        \n   \n    //the usual raymarch in lab coords:\n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=length(d*rd)*.25;\n          col*=dif*dif;            \n      \n    }\n   //another raymarch for the rotating box:\n   /*\n    vec4 p2=RO; \n    float d2= RayMarch2(p2, ray, 1.);\n    \n    \n     if(d2<MAX_DIST){ //if we hit an object:\n          p2= p2+ d2*ray;\n          \n          col=vec3(0.6,.3,.0)*.3;\n          vec3 n= getNormal2(p2);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=length(d2*ray)*.25;\n          col*=dif*dif;            \n      \n    }\n   */ \n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//normalize time go like 100 frames per iTime-sec\nconst float fps =60.;\n#define t float(iFrame)/fps \n#define PI 3.14159265359\n\nconst float c=1.;\nconst float scl = .01;\nvec3 initVel= vec3(.6,0,.0);\n\n    \n   \n   \nfloat gamma(vec3 beta){\n    float b= length(beta);\n    return pow(1.-b*b,-.5);\n}   \n   \nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n     \nmat4 Lorentz(vec3 v){\n \n      float beta= length(v)/c;\n      float gamma = pow(1.-beta*beta,-.5);\n     \n     if(abs(beta)<.001) return mat4(1,0,0,0,\n                                     0,1,0,0,\n                                     0,0,1,0,\n                                     0,0,0,1);\n    \n    float v2=dot(v,v);\n         \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, 0, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 0, 1, 0, 0,\n                 (gamma-1.)*v.z*v.x/v2, 0, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, 0, -gamma*v.z/c,   gamma);      \n    /*     \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);            \n      */           \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .01;\n\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=(left + up + right + down) ;\n   \n    // steer with mouse\n      //  acceleration.xy*=rot((m.y-.5)*PI);\n        acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 position= texelFetch( iChannel0, ivec2(5, 5), 0);\n    vec4 fourvel= texelFetch( iChannel0, ivec2(0, 0), 0);\n    //coordinates of the boost are in rockect coordinates\n    vec3  boost=vec3(0,0,0);\n    \n    boost = handleKeyboard();\n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = Lorentz(-initVel);\n                        \n      \n    \n    if(iFrame>10){\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++){\n                     TransformMat[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n                 }  \n        }\n        \n        vec3 force=-1.5*(position).xyz;\n        vec3 vel3= fourvel.xyz/fourvel.w/c;\n        float g=gamma(vel3);\n        vec4 fourForce=g*vec4(force,dot(force,vel3)/c);\n        vec4 fourA=inverse(TransformMat)*fourForce; \n        boost+=fourA.xyz;  \n        \n   \n    \n    \n        boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w; //to scale boost according to speed\n    \n        mat4 NextBoost= Lorentz(-boost*dt);//mat4(1)+LorentzGenerator(-boost*dt); //\n        \n        \n        //how to transform to stationary coords\n        TransformMat*=NextBoost;\n       \n        fourvel=TransformMat*vec4(0,0,0,1);\n        \n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(iFrame<=10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 fourvel = Lorentz(-initVel)*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n                fragColor= vec4(0,0,.5,0);\n            }\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++)\n                    if(ivec2(fragCoord)==ivec2(i,j))\n                        fragColor.r=TransformMat[i-1][j-1];\n                        \n        }else{ \n            \n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 fragColor =fourvel;          \n            }else if(ivec2(fragCoord)==ivec2(5,5)){\n                 fragColor=position+fourvel*dt;\n            }else{\n                //StoreMatrix:\n                for(int i=1; i<=4; i++)\n                    for(int j=1; j<=4; j++)\n                        if(ivec2(fragCoord)==ivec2(i,j)){\n                            fragColor.r=TransformMat[i-1][j-1];\n                            }\n            }\n        }\n     \n}","name":"Buffer A","description":"","type":"buffer"}]}