{"ver":"0.1","info":{"id":"7lccW8","date":"1659670472","viewed":49,"name":"Procedural Knots (one knot) DEMO","username":"mala","description":"This shader is a simplified implementation of a knotted wood texture, based on the SIGGRAPH 2022 Journal Track technical paper \"Procedural Texturing of Solid Wood with Knots.\" Project website: http://ma-la.com/procedural_knots.html ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texture","volumetric","wood","knots","smoothminimums","timefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 Maria Larsson, et al.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader is related to a research project about texturing of solid wood with knots\n// Project page: http://ma-la.com/procedural_knots.html\n\n//Smooth minumum functions reference: https://iquilezles.org/articles/smin/\n\nfloat smin_pow( float a, float b, float k ){ //Power smooth minumim. Reference: https://iquilezles.org/articles/smin/\n    a = pow(a, k); \n    b = pow(b, k);\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat smin_exp( float a, float b, float k ){ // exponential smooth min (e.g. k=32)\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nfloat smin_root( float a, float b, float k ){ // root smooth min (e.g. k=0.01)\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nfloat smin_poly( float a, float b, float k ){ // polynomial smooth min 1 (e.g. k=0.1){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float t;\n    vec3 col;\n    vec3 col_add = vec3(1.0,1.0,1.0);\n\n    //SETUP\n    float it = iTime;\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    // camera orientation\t\n    float ang = 0.7;      //static orientation\n\tvec3 ro = vec3( 2.0*cos(ang), 1.2, 2.0*sin(ang) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    \n    //GEOMETRY\n    vec3 p = vec3(0.0,0.0,0.0); //center point\n    vec3 r = vec3(0.3,0.9,0.7); //size\n   \n    //vec4 xpf = sphereLineX(ro, rd, p, r.y); //sphere\n    vec4 xpf = boxLineX(ro,rd,p,r); //box (choose one or the other)\n      \n    //Ray-Geometry intersection point (xp) and weather or not it intersects (f)\n    vec3 xp = vec3(xpf); //ray-geometry point of intersection closest to camera\n    float f = xpf.w;     //f=0.0 if no intersection, f=1.0 if there is an intersection\n    \n   \n    //TEXTURE\n    //Stem time value\n    vec3 wo = vec3(p.x+r.x,0.0,p.z); //wood stem position\n    vec3 wd = vec3(0.0,1.0,0.0);     //wood stem direction\n    float d0 = pointLineDistance(wo,wd,xp);\n    float t0 = d0;\n\n    //Knot time value\n    vec3 ko = vec3(p.x+r.x,p.y+0.2,0.0); //[1-7]\n    //vec3 ko = vec3(p.x+r.x,p.y+0.2*d0+0.3*sqrt(d0)-0.1,0.0); //[8] Knot curvature\n    vec3 kd = vec3(0.0,0.0,1.0);\n    float d1 = pointLineDistance(ko,kd,xp);\n    if (xp.z<0.0){d1 = distance(xp,ko);}\n    float t1 = d1; //[7]\n   \n       \n    //Combine stem and knots\n    //t = min(t0,t1);      // [5] minimum (sharp transition)\n    //t = smin_pow(t0,t1,2.0); // [6] smooth minimum with constant k\n    //t = smin_exp(t0,t1,3.0);\n    //t = smin_root(t0,t1,0.3);\n    //t = smin_poly(t0,t1,1.0);\n \n    //Dead knot\n    //float tx = 0.3; //time of death parameter\n    //if (t>tx){\n        //col_add = vec3(0.0,0.0,1.0);\n        //float txd = abs(t0-tx);        \n        //t1 += txd;\n        //t = smin_pow(t0,t1,2.0);\n        //t = smin_pow(t0,t1,2.0+5.0*txd);\n    //}\n    \n    //COLOR\n    float c = 1.0;                    //[1] White box\n    //float c = t0;                     //[2] Gradient distance\n    //float c = 15.0 * mod(-t0,1.0/15.0); //[3] Stripes stem t0,t1,t\n    col = vec3(c,c,c);                  //[1,2,3]\n    \n    //parameters\n    //vec3 c1 = vec3(0.35, 0.20, 0.15); //Dark wood color (on year ring)\n    //vec3 c2 = vec3(1.0, 0.88, 0.78);  //Light wood color (between year rings)\n    //vec3 ck = vec3(0.82,0.76,0.72);   //Knot color\n    //apply\n    //col = colorFromTimeValue(t, xp, c1, c2); //[9]wood color. function in COMMON\n    //float td = clamp(t1-t0+0.1,0.0,1.0); //[10] knot color param\n    //ck = mix(ck, vec3(1.0,1.0,1.0), pow(td,0.4)); //[10] knot color\n    //col = mix(col,ck*col,1.0-td); //[10] knot color \n    \n    fragColor = vec4(f*col*col_add,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI     3.14159265\n\nvec4 sphereLineX(vec3 ro, vec3 rd, vec3 p, float r){\n  float t = dot(p - ro, rd); //parameter (t) of closest point on ray from center\n  vec3 cp = ro + rd * t;     //closest point (cp) on ray from center\n  float y = length(p-cp);    //distance between center (p) and closest point (cpt)\n  vec3 xpt = vec3(0.0,0.0,0.0);\n  float ix_exists = 0.0;\n  if (y<r){                  //if there is an intersection between the sphere and the ray\n      ix_exists = 1.0;\n      float x = sqrt(r*r - y*y);\n      float t1 = t - x;      //parameter (t1) of intersection point closest to camera\n      xpt = ro + rd * t1;\n  }\n  return vec4(xpt, ix_exists);\n}\n\nmat4 translate( float x, float y, float z ){\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec4 boxLineX( vec3 row, vec3 rdw, vec3 p, vec3 r){ //Reference: https://iquilezles.org/articles/boxfunctions/ \t\t\t\t \n\n    mat4 tra = translate(p.x,p.y,p.z);\n    mat4 txi = tra;              //translation matrix\n\tmat4 txx = inverse( txi );   //inverse translation matrix\n\n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*r;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    \n    vec3 xpt = vec3(0.0,0.0,0.0);\n    float ix_exists = 0.0;\n    \n    if( tN<=tF && tF>=0.0) {\n        ix_exists = 1.0;\n        xpt = ro + tN*rd; \n    }\n    \n    return vec4(xpt,ix_exists);\n}\n\n\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\nfloat pointLineDistance(vec3 ro, vec3 rd, vec3 p){\n  float t = dot(p - ro, rd); //parameter (t) of closest point on ray from center\n  vec3 cp = ro + rd * t;     //closest point (cp) on ray from center\n  return length(p-cp);       //distance between center (p) and closest point (cpt)\n}\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n// Reference: https://www.shadertoy.com/view/4dS3Wd\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n//In the OpenGL implementation the wood colors are mapped from a 1D wood texture.\n//But shadertoy does not support uploading texture images, so here the wood colors\n//are generated procedurally using the function below\nvec3 colorFromTimeValue(float t, vec3 xp, vec3 dark_col, vec3 light_col){\n        \n    //create layered pattern\n    float d = 20.0; //density of ring pattern\n    float s = 8.0; //balance of color transition\n    t-=0.015;        //for outline of skeleton center\n    float a = d * mod(-t,1.0/d);\n    \n    //dark color and transition noise\n    float n = 25.0*float(int(-d*t));\n    float nval = noise(n)-0.5;\n    dark_col += -0.8*nval;\n    s += 5.0*nval;\n    \n    //light color noise\n    n = 19.0*float(int(d*t));\n    nval = noise(n)-0.5;\n    light_col += 0.08*nval;\n    \n    \n    //combine colors\n    vec3 col = mix(dark_col, light_col, pow(a,1.0/s));\n    return col;\n}\n\nfloat pointHeight(vec3 ro, vec3 rd, vec3 p){\n    \n    //normailized vector of point projected to normal plane of axis\n    vec3 v = p-ro;\n    float d = dot(v,rd);\n    vec3 pp = p - d*rd;\n   \n    return length(p-pp);\n}\n\n\nfloat angleOfPointAroundAxis(vec3 ro, vec3 rd, vec3 p){\n    //reference point of ang=0\n    vec3 ref = cross(rd, vec3(1.0,0.0,0.0));\n    ref = ref/length(ref);\n    \n    //normailized vector of point projected to normal plane of axis\n    vec3 v = p-ro;\n    float d = dot(v,rd);\n    vec3 pp = p - d*rd;\n    pp = pp/length(pp);\n    \n    //signed angle between projected point and reference point\n    float ang = acos(dot(pp,ref));\n    vec3 cp = cross(pp, ref);\n    if (dot(rd, cp) < 0.0) {\n        ang = 2.0*PI-ang;\n    }    \n    return ang;\n}\n\n//In the OpenGL implementation the stem radius/velocity is mapped from texture image containing the information.\n//But shadertoy does not support uploading texture images, so here the stem velocity\n//is generated procedurally using the function below\nfloat stemLocalVelocity(float d, float h, float a){\n    float v = 1.0;\n        \n    //noise varying with height in tree\n    float nval = noise(4.0*h)-0.5;\n    v += 0.1*nval;\n    \n    return v;\n    \n}\n","name":"Common","description":"","type":"common"}]}