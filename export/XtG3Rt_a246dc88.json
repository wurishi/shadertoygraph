{"ver":"0.1","info":{"id":"XtG3Rt","date":"1476046941","viewed":2102,"name":"Distance field outline mask","username":"Good","description":"Many things at once: sliders, draggable control points, numbers, configurable df outline\n\nDrag dots to change bezier\nUse sliders to change outline - from top to bottom: softness, offset, width\nPress Z and X to zoom in and out\n\n","likes":71,"published":1,"flags":48,"usePreview":0,"tags":["bezier","distance","ui","visualisation","slider","digits","gui","draganddrop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p ){\n    o = texture(iChannel0,p.xy/iResolution.xy); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////\n//   Read Write             //\n//////////////////////////////\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n// only positive in range 0-1\nvec4 packNormal( const in float value ){\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\nfloat unpackNormal( const in vec4 value ){ return dot( value, bitShR );}\n\n// only positive int\nvec4 packInt(int val){\n    vec4 res = floor(float(val)*bitShR);\n    res.yzw -= res.xyz*256.0;\n    return res;\n}\nfloat unpackInt( const in vec4 value ){ return dot(value, bitShL);}\n// +-2147483 with 3 digit float precigion\nvec4 packFloat( const in float val ){\n   bool negative = sign(val)==-1.;\n   vec4 res = floor(abs(val)*1000.0* bitShR);\n   res.gba -= res.rgb*256.0;\n   if(negative) res.r+=256.;\n   return res;\n}\nfloat unpackFloat( in vec4 val ){\n    float m = 1.0;\n    if(val.r>=256.){ val.r-=256.; m=-1.0; }   \n    return dot(val, bitShL)/1000.*m;\n}\n\n\nbool isCell(in vec2 p, in vec2 a) { return floor(p) == a;}\nvoid savePixel(vec4 val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=val;}\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nvoid saveInt(int val, vec2 address, inout vec4 col, vec2 p){if(isCell(p, address)) col= packInt(val);}\nfloat readInt(vec2 address){ return unpackInt(readPixel(address));}\nvoid saveIntVec2(vec2 val, float id, inout vec4 col, vec2 p){\n    saveInt(int(val.x), vec2(id,0.0), col, p);        \n    saveInt(int(val.y), vec2(id,1.0), col, p);\n}\nvoid saveFloat(float val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col= packFloat(val);}\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n\n////// Constants ////////////////////////////////////////////////////////////////////////\nconst float PI    = 3.14159265358979323846;\nconst float SQRT2 = 1.41421356237309504880;\n\n////// 2D Ttransformations ///////////////////////////////////////////////////////////////\nvec2 translate(vec2 p, vec2 t){\treturn p - t;}\nvec2 scale(vec2 p, float s){ return p * mat2(s, 0, 0, s);}\nvec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\nvec2 rotateCCW(vec2 p, float a){\treturn p * mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n////// 2D Matrix Ttransformations /////////////////////////////////////////////////////////\nmat3 rotate(float r){float c = cos(r), s = sin(r); return mat3(c,-s,0,  s,c,0,  0,0,1);}\nmat3 scale(float s){ return mat3(s,0,0, 0,s,0, 0,0,1);}\nmat3 translate(vec2 p) { return mat3(1,0,p.x, 0,1,p.y, 0,0,1);}\nmat3 skew(float r) { return mat3(1,tan(r),0, 0,1,0, 0,0,1);}\nmat3 skewVert(float r) { return mat3(1,0,0, tan(r),1,0, 0,0,1);}\nmat3 inverse2x3(mat3 m){\n      float a=m[0][0], b=m[0][1], c=m[0][2], d=m[1][0], e=m[1][1], f=m[1][2], t=a*e-b*d;\n      return mat3(e/t, -b/t, (f*b-c*e)/t, -d/t, a/t, (-f*a+c*d)/t, 0, 0, 1);\n}\nvec2 transform(vec2 p, mat3 m){ return (vec3(p,1)*m).xy;}\n////// Distance field functions //////////////////////////////////////////////////////////\n\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\n\nfloat dfCircle(vec2 p, float radius){\t\n    return length(p) - radius;\n}\nfloat dfLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n////// UI /////////////////////////////////////////////////////////////////////////////////\nfloat extract_bit(float n, float b){ return mod(floor(n/exp2(floor(b))),2.0);}\nfloat extract_decimal(float n, float index){ return mod(n/pow(10.0, index),10.0);}\nfloat drawDigit(int n, vec2 p){ p=floor(p);\n    int i = n==0?0x69996:n==1?0x62227:n==2?0xE168F:n==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:\n    n==6?0x68E96:n==7?0xF1244:n==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;\n    return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);\n}\nfloat drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    p-=location; p/= float(zoom);\n    float n = floor(p.x / 5.0); //current char index \n    p.x -= n*5.; //move origin\n    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds\n    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    float count = intCount + fractPrecision; //totla number of digits to print \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  \n    if(count <= n)  return 0.0; //no need to draw more\n    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   \n}\nfloat drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    float r =drawFloat(val.y,fractPrecision, p, location, zoom);\n    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);\n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nconst vec2 activeUIAddress = vec2(0,4);\n\n\nfloat slider(in float id, in vec4 conf, in vec2 loc, in vec2 sp, inout vec4 col, inout float ui){ \n    float val = readFloat(vec2(id,0));//read saved value \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);    \n    float slui = dfBoxRounded(floor(sp), vec4(loc,124,20), 5.0);\n    slui = max(-slui-2.0, slui );    \n    if(data.x==0.){ //set default value\n        val = conf.x; data.x=.05;\n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(dfBox(iMouse.xy, vec4(loc, 120, 20))<2. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        float distanceFromLeftEdege = clamp(iMouse.x, loc.x, loc.x+120.0)-loc.x;\n        val = mix(conf.y, conf.z, distanceFromLeftEdege/120.0);\n        val = floor(val/conf.w) * conf.w;        \n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }\n        \n    slui = min(slui, dfBoxRounded(floor(sp), vec4(loc+vec2(2,2),120.0*(val-conf.y)/(conf.z-conf.y),16), 3.0) );\n    \n    ui = min(ui, -drawFloat(val, 2.0, sp, loc+vec2(128,8), 1)); //val   \n    //ui = min(ui, -drawFloat(conf.y, 2.0, sp, loc+vec2(0,24), 1)); //from   \n    //ui = min(ui, -drawFloat(conf.z, 2.0, sp, loc+vec2(80,24), 1));  //to   \n    //ui = min(ui, -drawFloat(conf.w, 2.0, sp, loc+vec2(50,-10), 1)); //step    \n    ui = min(ui, slui);     \n    savePixel(data, vec2(id,3), col, sp);     \n    return val;    \n}\n\n\nvec2 controlPoint(float id, vec2 loc, mat3 stv, vec2 sp, inout vec4 col, inout float ui){\n    \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);\n    vec2 m = transform(iMouse.xy, stv); //viewport mouse position \n    vec2 pos = vec2(readFloat(vec2(id,0)),readFloat(vec2(id,1)));//read saved value \n    \n    \n    if(data.x==0.){ //set default value\n        pos = loc; data.x=.05;\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    }\n    vec2 spos = transform(pos, inverse2x3(stv));\n    \n    if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(distance(spos, iMouse.xy)<20. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n        \n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        pos = m;//drag this point\n        spos = iMouse.xy;//drag this point\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    } \n    \n    ui = min(ui, -drawVec2(pos, 2.0, sp, spos+vec2(10,-5), 1));    \n    ui = min(ui, dfCircle(sp-spos, 6.));\n    \n    savePixel(data, vec2(id,3), col, sp); \n    \n    return pos;\n}\n\n\n/////// Combine distance field functions //////////////////////////////////////////////////\nfloat merge(float d1, float d2){return min(d1, d2);}\n\n\n////// Grid //////////////////////////////////////////////////////////////////////////////\nfloat chessboard(vec2 p){ p=floor(p*2.0); return mod(p.x+p.y, 2.0);}\n\n\n/////////////////////////////////////////////////////////////////\n//    Bezier                                                  //\n///////////////////////////////////////////////////////////////\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c){\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n// Find the unsigned distance from a point to a bezier curve\nfloat usBezier(vec2 A, vec2 B, vec2 C, vec2 p){    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\n\nbool keyPress(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\n////// Masks for drawing /////////////////////////////////////////////////////////////////\n\nfloat hardFill(float d){return step(0.0, -d);}\nfloat fill(in float d, in float softness, in float offset){\n    return clamp((offset +softness*.5 - d)/softness, 0.0, 1.0);\n}\nfloat simpleFill(float d){return clamp(-d, 0.0, 1.0);}\nfloat sharpFill(in float d){return clamp(.5-d, 0.0, 1.0);} //same as fill(d, 1.0, 0.0)\nfloat stroke(in float d, in float softness, in float offset, in float width){ \n   d = abs(d-offset);\n   return clamp((width/2.0 +softness*.5 - d)/softness, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainScene(inout vec4 col, in vec2 sp ){\n    \n    float zoom = 1.;\n    \n    if (keyPress(32)) { zoom = 1./10.; } //SPACE\n    if (keyPress(90)) { zoom = 2.0; } //Z\n    if (keyPress(88)) { zoom = .5; } //X\n    \n    //viewport transformation matrix \n    mat3 screenToView = translate(-iResolution.xy / 2.0)*scale(zoom); \n    mat3 screenToView2 = translate(vec2(-iResolution.x / 2.0, -25))*scale(0.025); \n    \n    //ui elements\n    float ui = 0.;\n    vec2 pt1 = controlPoint(1.0, vec2(-125, -40), screenToView, sp, col, ui);\n    vec2 pt2 = controlPoint(2.0, vec2(-35, 122), screenToView, sp, col, ui);    \n    vec2 pt3 = controlPoint(3.0, vec2(115, 40), screenToView, sp, col, ui);     \n    \n    float softness = slider(5.0, vec4(1, 0,10, .25), vec2(20, 240), sp, col, ui);\n    float offset = slider(6.0, vec4(0, -5, 5, .25), vec2(20, 200), sp, col, ui);\n    float width = slider(7.0, vec4(2.5, 0, 10, .25), vec2(20, 160), sp, col, ui);\n    \n  \n    \n    ///////////////// output /////////////////\n    if(sp.y > 80.){ //viewport 1\n        \n        \n        vec2 p = transform(sp.xy, screenToView);  //viewport pixel position\n        // background     \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.r -= .03*chessboard(p*.05); //grid2  \n        \n        // scene\n        float lines = merge(dfLine(p, pt1, pt2), dfLine(p, pt3, pt2));\n        float bz = usBezier(pt1, pt2, pt3, p);    \n        float cc = dfCircle(p, 50.);\n\n        col = mix(col, vec4(1.0, 0.7, 0.9, 1.0), stroke(cc, softness * zoom, offset * zoom, width * zoom));         \n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), stroke(bz, softness * zoom, offset * zoom, width * zoom)); \n        col = mix(col, vec4(0.2, 0.2, 0.2, 1.0), stroke(lines, zoom, .0, .5*zoom));\n        \n    }else if(sp.y > 5.){ //viewport 2    \t\n        vec2 p = transform(sp.xy, screenToView2);         \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.rgb -= .03*chessboard(p*.5); //grid2         \n        \n        float fn = stroke(p.x, softness, offset, width);\n        float ln = p.y < fn ? -1. : 0.;\n        col = mix(col, vec4(.4, 0.4, 0.4, 1.0), simpleFill(ln));\n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), 1.0-step(simpleFill(ln)*p.y,.0));\n        col = mix(col, vec4(.3,.3,.3,1), hardFill(dfRoundedBox(p,vec2(.05,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(5,0),vec2(.025,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(-5,0),vec2(.025,10), .0)));\n    }\n    \n    if(sp.y > 5.){ //draw only on non data area\n        col = mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));\n    }\n}\n\n\nvoid mainImage( out vec4 o, in vec2 p ){ \n    o = p.y <= 5.? texture(iChannel0,p.xy/iResolution.xy) : vec4(0);  //data for next frame\n    mainScene(o, p);   \n}","name":"Buffer A","description":"","type":"buffer"}]}