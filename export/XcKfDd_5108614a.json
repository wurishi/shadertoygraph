{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Raymarched Rubik's Cube with Night Sky Background\n// by ChatGPT\n\n// Shadertoy Built-ins:\n// uniform float iTime;\n// uniform vec2 iResolution;\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat hash1(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash2(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec3 rotateX(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotateY(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotateZ(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n// Rubik's cube colors\n// Up (y=1): White (1,1,1)\n// Down(y=-1):Yellow(1,1,0)\n// Left(x=-1): Orange(1,0.5,0)\n// Right(x=1): Red(1,0,0)\n// Front(z=1): Green(0,1,0)\n// Back (z=-1): Blue(0,0,1)\n// Internal: dark grey (0.1)\nvec3 faceColor(int ix, int iy, int iz, vec3 normal) {\n    vec3 cLeft  = vec3(1.0,0.5,0.0);\n    vec3 cRight = vec3(1.0,0.0,0.0);\n    vec3 cUp    = vec3(1.0,1.0,1.0);\n    vec3 cDown  = vec3(1.0,1.0,0.0);\n    vec3 cFront = vec3(0.0,1.0,0.0);\n    vec3 cBack  = vec3(0.0,0.0,1.0);\n    vec3 cNone  = vec3(0.1,0.1,0.1);\n\n    float ax = abs(normal.x);\n    float ay = abs(normal.y);\n    float az = abs(normal.z);\n    if (ax>ay && ax>az) {\n        // x-face\n        if (normal.x>0.0) {\n            return (ix==1)? cRight : cNone;\n        } else {\n            return (ix==-1)? cLeft : cNone;\n        }\n    } else if (ay>ax && ay>az) {\n        // y-face\n        if (normal.y>0.0) {\n            return (iy==1)? cUp : cNone;\n        } else {\n            return (iy==-1)? cDown : cNone;\n        }\n    } else {\n        // z-face\n        if (normal.z>0.0) {\n            return (iz==1)? cFront : cNone;\n        } else {\n            return (iz==-1)? cBack : cNone;\n        }\n    }\n}\n\nstruct SliceRotation {\n    int axis;    // 0=x,1=y,2=z\n    int index;   // slice index: -1,0,1\n    float angle; // rotation angle\n};\n\nSliceRotation getCurrentRotation(float t) {\n    float period = 4.0;\n    float phase = mod(t, period);\n    int cycle = int(floor(t/period));\n    float r1 = hash1(float(cycle)*1.123);\n    float r2 = hash1(float(cycle)*3.321);\n    int axis = int(floor(r1*3.0));\n    int index = (int(floor(r2*3.0)) - 1);\n\n    float angle = 2.0*3.14159265*(phase/period);\n\n    SliceRotation sr;\n    sr.axis = axis;\n    sr.index = index;\n    sr.angle = angle;\n    return sr;\n}\n\nbool isInSlice(int axis, int index, int ix, int iy, int iz) {\n    int sliceCoord = 0;\n    if (axis==0) sliceCoord = ix;\n    else if (axis==1) sliceCoord = iy;\n    else sliceCoord = iz;\n    return sliceCoord == index;\n}\n\nfloat cubeSDF(vec3 p) {\n    return sdBox(p, vec3(0.495));\n}\n\nstruct HitInfo {\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n};\n\nHitInfo mapScene(vec3 p, SliceRotation sr) {\n    HitInfo hit;\n    hit.dist = 9999.0;\n    hit.color = vec3(0.0);\n    hit.normal = vec3(0.0);\n\n    for (int ix=-1; ix<=1; ix++) {\n        for (int iy=-1; iy<=1; iy++) {\n            for (int iz=-1; iz<=1; iz++) {\n                vec3 cpos = vec3(float(ix),float(iy),float(iz));\n                vec3 q = p;\n                if (isInSlice(sr.axis, sr.index, ix, iy, iz)) {\n                    float slicePos = float((sr.axis==0)? ix : (sr.axis==1)? iy : iz);\n\n                    // Translate, rotate, translate back\n                    if (sr.axis==0) { q.x -= slicePos; q = rotateX(q, sr.angle); q.x += slicePos; }\n                    if (sr.axis==1) { q.y -= slicePos; q = rotateY(q, sr.angle); q.y += slicePos; }\n                    if (sr.axis==2) { q.z -= slicePos; q = rotateZ(q, sr.angle); q.z += slicePos; }\n                }\n\n                float d = cubeSDF(q - cpos);\n                if (d < hit.dist) {\n                    hit.dist = d;\n                    float h = 0.0001;\n                    float dx = cubeSDF(q - cpos + vec3(h,0,0))-cubeSDF(q - cpos - vec3(h,0,0));\n                    float dy = cubeSDF(q - cpos + vec3(0,h,0))-cubeSDF(q - cpos - vec3(0,h,0));\n                    float dz = cubeSDF(q - cpos + vec3(0,0,h))-cubeSDF(q - cpos - vec3(0,0,h));\n                    vec3 n = normalize(vec3(dx,dy,dz));\n                    hit.normal = n;\n                    hit.pos = q;\n                    hit.color = faceColor(ix,iy,iz,n);\n                }\n            }\n        }\n    }\n\n    return hit;\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out HitInfo hit) {\n    float t = 0.0;\n    for (int i=0; i<200; i++) {\n        SliceRotation sr = getCurrentRotation(iTime);\n        vec3 p = ro + rd*t;\n        HitInfo h = mapScene(p, sr);\n        float d = h.dist;\n        if (d < 0.0005) {\n            hit = h;\n            return t;\n        }\n        t += d;\n        if (t>20.0) break;\n    }\n    return -1.0;\n}\n\nvec3 lighting(HitInfo hit) {\n    vec3 lightDir = normalize(vec3(0.5,1.0,0.3));\n    float diff = clamp(dot(hit.normal, lightDir),0.0,1.0)*0.8 +0.2;\n    return hit.color * diff;\n}\n\n// Simple starry background\n// A dark gradient + stars.\nvec3 backgroundColor(vec2 uv) {\n    // Gradient from top to bottom: top (uv.y>0) slightly lighter\n    // We'll make top a bit lighter: top color ~ (0.0,0.0,0.15), bottom: (0.0,0.0,0.05)\n    float gradient = smoothstep(-1.0,1.0, uv.y);\n    vec3 baseColor = mix(vec3(0.0,0.0,0.05), vec3(0.0,0.0,0.15), gradient);\n\n    // Add stars\n    // Scale uv for star distribution\n    vec2 suv = uv * 100.0;\n    float n = hash2(floor(suv));\n    // If n is very small, we draw a star\n    if (n < 0.0007) {\n        // star intensity\n        baseColor += vec3(1.0) * 0.8;\n    }\n\n    return baseColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Move camera further away to fit entire cube\n    vec3 ro = vec3(5.0,3.0,5.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 fw = normalize(ta - ro);\n    vec3 rt = normalize(cross(fw, vec3(0,1,0)));\n    vec3 up = cross(rt, fw);\n    vec3 rd = normalize(fw + uv.x*rt + uv.y*up);\n\n    HitInfo hit;\n    float t = raymarch(ro, rd, hit);\n\n    vec3 col;\n    if (t>0.0) {\n        col = lighting(hit);\n    } else {\n        // No hit: show background (night sky)\n        col = backgroundColor(uv);\n    }\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcKfDd","date":"1734589817","viewed":38,"name":"Bwalthers Rubiks Cube","username":"bwalthers2","description":"Its a Rubik's cube","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""}}