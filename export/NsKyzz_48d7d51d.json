{"ver":"0.1","info":{"id":"NsKyzz","date":"1654757842","viewed":53,"name":"Portal test","username":"CHN","description":"Only the object that is in the middle is real, others are just it's reflections.\n\nControls\n->Movement: Arrow keys, use N and M for vertical movement\n->Camera rotate: Mouse movement while a mouse button is pressed","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"7styzS","parentname":"Sphere ray marching1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 70;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\nconst int MAX_RECURSE_PORTAL_VIEW_COUNT = 3;\n\nvec3 norm;\nint portalIndex;\nbool isPortalDir1to2;\n\nconst float TYPE_GROUND = 0.;\nconst float TYPE_WALL = 1.;\nconst float TYPE_PORTAL = 2.;\nconst float TYPE_WALL_2 = 3.;\nconst float TYPE_BALL = 4.;\nconst float TYPE_BALL_2 = 5.;\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nconst vec2 h = vec2(0.0001, 0);\n\n#define calcNormal(p, f) normalize(vec3(f(p+h.xyy) - f(p-h.xyy), f(p+h.yxy) - f(p-h.yxy), f(p+h.yyx) - f(p-h.yyx)))\n#define calcNormal2(p, f) normalize(vec3(f(p+h.xyy).x - f(p-h.xyy).x, f(p+h.yxy).x - f(p-h.yxy).x, f(p+h.yyx).x - f(p-h.yyx).x))\n\nvec2 map(vec3 pos)\n{\n    // f = vec2(CLOSEST_DISTANCE, TYPE)\n    vec2 f = vec2(MAX_DIST, -1.);\n\n    const float groundSize = 5.;\n\n    float x = 0.;\n    \n    {\n        vec3 groundPos = vec3(.0, -2., 0.);\n        x = sdBox(pos - groundPos, vec3(groundSize, .1, groundSize));\n    \n        if(x < f.x)\n        {\n            f.x = x;\n            f.y = TYPE_GROUND;\n        }\n    }\n    \n    {\n        vec3 ballPos = vec3(cos(iTime) * -.15, sin(iTime) * 1., 0.);\n        x = sdSphere(pos - ballPos, 1.);\n    \n        if(x < f.x)\n        {\n            f.x = x;\n            f.y = TYPE_BALL;\n        }\n        \n        vec3 ball2Pos = vec3(cos(iTime) * .15, sin(iTime) * -1., 0.);\n        x = sdSphere(pos - ball2Pos, 1.);\n    \n        if(x < f.x)\n        {\n            f.x = x;\n            f.y = TYPE_BALL_2;\n        }\n    }\n    \n    {\n        vec3 wallPos = vec3(-groundSize, 0., 0.);\n        x = sdBox(pos - wallPos, vec3(.1, 2., groundSize));\n    \n        if(x < f.x)\n        {\n            f.x = x;\n            f.y = TYPE_WALL;\n        }\n        \n        wallPos = vec3(groundSize, 0., 0.);\n        x = sdBox(pos - wallPos, vec3(.1, 2., groundSize));\n    \n        if(x < f.x)\n        {\n            f.x = x;\n            f.y = TYPE_WALL_2;\n        }\n    }\n    \n    {\n        for(int i = 0; i < portalCount; ++i)\n        {\n            vec3 p = applyTRStoPointInv(portalTransforms[i], pos);\n            x = sdBox(p, vec3(.01, 3., 1.765));\n            \n            if(x < f.x)\n            {\n                f.x = x;\n                f.y = TYPE_PORTAL;\n                portalIndex = i;\n                isPortalDir1to2 = true;\n            }\n            \n            p = applyTRStoPointInv(portal2Transforms[i], pos);\n            x = sdBox(p, vec3(.01, 3., 1.765));\n            \n            if(x < f.x)\n            {\n                f.x = x;\n                f.y = TYPE_PORTAL;\n                portalIndex = i;\n                isPortalDir1to2 = false;\n            }\n        }\n    }\n    \n    return f;\n}\n\nvec2 castRay(vec3 pos, vec3 dir)\n{\n    vec2 currentInfo = vec2(MIN_DIST, -1.);\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec2 mapInfo = map(pos + currentInfo.x * dir);\n        if (abs(mapInfo.x) < EPSILON)\n        {\n            norm = calcNormal2(pos + currentInfo.x * dir, map);\n            currentInfo.y = mapInfo.y;\n            return currentInfo;\n        }\n        currentInfo.x += mapInfo.x;\n        if (abs(currentInfo.x) >= MAX_DIST)\n        {\n            return currentInfo;\n        }\n    }\n\n    return currentInfo;\n}\n   \nvec3 calculateRayDir(float fieldOfView, vec3 camRot, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    vec3 dir = vec3(xy, -z);\n    dir = applyTRStoPoint(axisAngleToTRS(vec3(1,0,0), camRot.x), dir);\n    dir = applyTRStoPoint(axisAngleToTRS(vec3(0,1,0), camRot.y), dir);\n    dir = applyTRStoPoint(axisAngleToTRS(vec3(0,0,1), camRot.z), dir);\n    return normalize(dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    loadAll(iChannel0);\n\tvec3 dir = calculateRayDir(100.0, rot.xyz, iResolution.xy, fragCoord);\n    vec2 info = castRay(pos.xyz, dir);\n\n    if(info.y == TYPE_PORTAL)\n    {\n        vec3 viewPos = pos.xyz;\n    \n        for(int i = 0; i < MAX_RECURSE_PORTAL_VIEW_COUNT; ++i)\n        {\n            vec3 posOnPortal1 = info.x * dir + viewPos;\n            vec3 posOnPortal2;\n\n            if(isPortalDir1to2)\n            {\n                posOnPortal2 = applyTRStoPointInv(portalTransforms[portalIndex], posOnPortal1);\n                posOnPortal2 = applyTRStoPoint(portal2Transforms[portalIndex], posOnPortal2);\n\n                dir = applyTRStoDirectionInv(portalTransforms[portalIndex], dir);\n                dir = applyTRStoDirection(portal2Transforms[portalIndex], dir);\n            }\n            else\n            {\n                posOnPortal2 = applyTRStoPointInv(portal2Transforms[portalIndex], posOnPortal1);\n                posOnPortal2 = applyTRStoPoint(portalTransforms[portalIndex], posOnPortal2);\n\n                dir = applyTRStoDirectionInv(portal2Transforms[portalIndex], dir);\n                dir = applyTRStoDirection(portalTransforms[portalIndex], dir);\n            }\n            \n            posOnPortal2 += 0.2 * dir;\n\n            info = castRay(posOnPortal2, dir);\n            \n            if(info.y != TYPE_PORTAL)\n            {\n                break;\n            }\n            \n            viewPos = posOnPortal2;\n        }\n    }\n\n    float dist = info.x;\n    float type = info.y;\n    vec4 color = vec4(0.);\n        \n    if(type == TYPE_GROUND)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(1., .0, .0, 1.) * lum;\n    }\n    else if(type == TYPE_WALL)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(0., .1, .0, 1.) * lum;\n    }\n    else if(type == TYPE_WALL_2)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(0., 0., .1, 1.) * lum;\n    }\n    else if(type == TYPE_PORTAL)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(0., .1, .0, 1.) * lum;\n    }\n    else if(type == TYPE_BALL)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(1., 1., 1., 1.) * lum;\n    }\n    else if(type == TYPE_BALL_2)\n    {\n        float lum = dot(norm, -dir);\n        color = vec4(1., 1., 0., 1.) * lum;\n    }\n    \n    \n    fragColor = pow(color, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_W 87\n\n#define KEY_J 74\n#define KEY_L 76\n#define KEY_K 75\n#define KEY_O 79\n\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_Z 90\n#define KEY_X 88\n\n#define varRow 0\n#define portalRow 1\n#define portal2Row 2\n#define var(name, column, row) ivec2 name = ivec2(column, row)\n\nconst float PI = 3.14159265;\n\nvar(_pos, 0, varRow);\nvar(_rot, 1, varRow);\nvar(_oldMousePos, 2, varRow);\nvar(_itrCount, 3, varRow);\nvar(_portalCount, 4, varRow);\nvar(_portalTransform, 0, portalRow);\nvar(_portal2Transform, 0, portal2Row);\n\nvec4 pos, rot, oldMousePos, rayPos, itrCount;\nint portalCount = 0;\nconst int MAX_PORTAL_COUNT = 10;\nmat4 portalTransforms[MAX_PORTAL_COUNT];\nmat4 portal2Transforms[MAX_PORTAL_COUNT];\n\n\nvec4 load(sampler2D buffer, in ivec2 coord)\n{\n\treturn texelFetch(buffer, coord, 0);\n}\n\nvoid loadMatrixArr(sampler2D buffer, in ivec2 coord, out mat4 m)\n{\n    m[0] = load(buffer, coord);\n    ++coord.x;\n    m[1] = load(buffer, coord);\n    ++coord.x;\n    m[2] = load(buffer, coord);\n    ++coord.x;\n    m[3] = load(buffer, coord);\n}\n\nvoid loadAll(sampler2D buffer)\n{\n\tpos = load(buffer, _pos);\n    rot = load(buffer, _rot);\n    portalCount = int(load(buffer, _portalCount).x);\n    \n    for(int i = 0; i < portalCount; ++i)\n    {\n        _portalTransform.x = i * 4;\n        _portal2Transform.x = i * 4;\n        loadMatrixArr(buffer, _portalTransform, portalTransforms[i]);\n        loadMatrixArr(buffer, _portal2Transform, portal2Transforms[i]);\n    }\n    \n    itrCount = load(buffer, _itrCount);\n}\n\nvec4 save(in ivec2 valCoord, in vec4 value, in ivec2 coord)\n{\n\tif(coord == valCoord)\n    {\n    \treturn value;\n    }\n    \n    return vec4(0.);\n}\n\nvoid saveMatrix(ivec2 valCoord, in mat4 m, in ivec2 coord, out vec4 saveVal)\n{\n    saveVal += save(valCoord, m[0], coord);\n    ++valCoord.x;\n    saveVal += save(valCoord, m[1], coord);\n    ++valCoord.x;\n    saveVal += save(valCoord, m[2], coord);\n    ++valCoord.x;\n    saveVal += save(valCoord, m[3], coord);\n}\n\nvec4 saveAll(in vec2 fCoord)\n{\n    ivec2 coord = ivec2(fCoord);\n    \n    vec4 saveVal = vec4(0.);\n      \n    saveVal += save(_pos, pos, coord);\n    saveVal += save(_rot, rot, coord);\n    saveVal += save(_oldMousePos, oldMousePos, coord);\n    saveVal += save(_itrCount, itrCount, coord);\n    saveVal += save(_portalCount, vec4(portalCount), coord);\n    \n    for(int i = 0; i < portalCount; ++i)\n    {\n        _portalTransform.x = i * 4;\n        _portal2Transform.x = i * 4;\n        saveMatrix(_portalTransform, portalTransforms[i], coord, saveVal);\n        saveMatrix(_portal2Transform, portal2Transforms[i], coord, saveVal);\n    }\n    \n    return saveVal;\n}\n\nmat4 axisAngleToTRS(vec3 axis, float angle)\n{\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 applyTRStoPoint(in mat4 trs, vec3 p)\n{\n    return (trs * vec4(p, 1.)).xyz;\n}\n\nvec3 applyTRStoDirection(in mat4 trs, vec3 d)\n{\n    vec3 p;\n    \n    p.x = trs[0][0] * d.x + trs[1][0] * d.y + trs[2][0] * d.z;\n    p.y = trs[0][1] * d.x + trs[1][1] * d.y + trs[2][1] * d.z;\n    p.z = trs[0][2] * d.x + trs[1][2] * d.y + trs[2][2] * d.z;\n    \n    return p;\n}\n\nvec3 applyTRStoPointInv(in mat4 trs, vec3 p)\n{\n    return (inverse(trs) * vec4(p, 1.)).xyz;\n}\n\nvec3 applyTRStoDirectionInv(in mat4 trs, vec3 d)\n{\n    mat4 temp = trs;\n    \n    temp[3].x = 0.;\n    temp[3].y = 0.;\n    temp[3].z = 0.;\n    \n    return (inverse(temp) * vec4(d, 1.)).xyz;\n}\n\nvoid setTRSposition(inout mat4 trs, vec3 p)\n{\n    trs[3].x = p.x;\n    trs[3].y = p.y;\n    trs[3].z = p.z;\n}\n\nvoid setTRSrotationEuler(inout mat4 trs, vec3 r)\n{\n    float cosY = cos(r.y);\n    float sinY = sin(r.y);\n\n    float cosP = cos(r.x);\n    float sinP = sin(r.x);\n\n    float cosR = cos(r.z);\n    float sinR = sin(r.z);\n\n    trs[0][0] = cosY * cosR + sinY * sinP * sinR;\n    trs[1][0] = cosR * sinY * sinP - sinR * cosY;\n    trs[2][0] = cosP * sinY;\n\n    trs[0][1] = cosP * sinR;\n    trs[1][1] = cosR * cosP;\n    trs[2][1] = -sinP;\n\n    trs[0][2] = sinR * cosY * sinP - sinY * cosR;\n    trs[1][2] = sinY * sinR + cosR * cosY * sinP;\n    trs[2][2] = cosP * cosY;\n}\n\nmat4 createTRSmatrix(vec3 p, vec3 r)\n{\n    mat4 m = mat4(0.);\n    setTRSposition(m, p);\n    setTRSrotationEuler(m, r);\n    \n    m[3][3] = 1.;\n    \n    return m;\n}\n\nfloat saturate(float s)\n{\n\treturn clamp(s,0.0,1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float getKeyState(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x;\n}\n\nvoid writeDefaults()\n{\n    pos = vec4(0., 0., 15., 0);\n\trot = vec4(0, 0, 0, 0);\n    \n    { // TEST CODE\n         portalCount = 2;\n         \n         portalTransforms[0] = createTRSmatrix(vec3(3., 1., 3.), vec3(0., -PI/4., 0.));\n         portal2Transforms[0] = createTRSmatrix(vec3(-3., 1., -3.), vec3(0., -PI/4., 0.));\n         \n         portalTransforms[1] = createTRSmatrix(vec3(-3., 1., 3.), vec3(0., PI/4., 0.));\n         portal2Transforms[1] = createTRSmatrix(vec3(3., 1., -3.), vec3(0., PI/4., 0.));\n    }\n    \n    itrCount.x = 14.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    loadAll(iChannel0);\n    oldMousePos = load(iChannel0, _oldMousePos);\n    \n    vec3 posDif;\n    \n    posDif.x = -getKeyState(KEY_LEFT) + getKeyState(KEY_RIGHT);\n    posDif.y = -getKeyState(KEY_N) + getKeyState(KEY_M);\n    posDif.z = -getKeyState(KEY_UP) + getKeyState(KEY_DOWN);\n    \n    posDif = applyTRStoPoint(axisAngleToTRS(vec3(0,1,0), rot.y) * axisAngleToTRS(vec3(1,0,0), rot.x), posDif);\n    \n    pos.xyz += posDif * 0.125; \n    \n    itrCount.x += -getKeyState(KEY_Z) * 1.5 + getKeyState(KEY_X) * 1.5;\n    \n    if(iFrame == 0)\n    {\n        writeDefaults();\n    \toldMousePos.xyz = iMouse.xyz;\n    }\n    \n    if (oldMousePos.z > 0. && iMouse.z > 0.) {\n    \trot.xy += vec2((-iMouse.y + oldMousePos.y) * 0.4, \n                   \t\t(iMouse.x - oldMousePos.x) * 0.4);  \n    }\n    \n   \toldMousePos.xyz = iMouse.xyz;\n    \n\tfragColor = saveAll(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}