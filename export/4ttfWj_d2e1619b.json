{"ver":"0.1","info":{"id":"4ttfWj","date":"1541092036","viewed":148,"name":"Surprised Guy","username":"Guntereno","description":"First attempt at ray-marching a signed distance field. Results of the first Electric Square ray marching workshop. (Many thanks to AJ and Huw!)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","pbr","selfshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795f \n\nconst vec3 kUp = vec3(0.0f, 1.0f, 0.0f);\n\nconst vec3 kEyeColor = vec3(0.1f, 0.1f, 0.2f);\nconst vec3 kSkinColor = vec3(0.8f, 0.5f, 0.5f);\nconst vec3 kSkinShadowColor = vec3(0.4f, 0.0f, 0.0f);\n\nvec3 envSample(vec3 dir, samplerCube channel)\n{   \n    return texture(channel, dir).rgb;\n}\n\nfloat sdSphere(vec3 point, vec3 centre, float radius)\n{\n    return length(centre - point) - radius;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n  return min(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5f + 0.5f *(d2 - d1) / k, 0.0f, 1.0f );\n    return mix( d2, d1, h ) - k * h * (1.0f - h);\n}\n\nfloat sdf(vec3 pos)\n{\n    const float headRad = 5.0f;\n    \n    // Skin\n    float skin;\n    {\n        float sphere = sdSphere(pos, vec3(0,0,0), headRad);\n\n        float theta = 0.0f;\n        vec3 holePos = vec3(headRad, 0.0f, 0.0f); \n        float nose = sdSphere(pos, holePos, 1.5f);\n\n        skin = opSmoothUnion(sphere, nose, 0.5f);\n    }\n    \n    // Eyes\n    float eyes;\n    {\n        vec2 theta = vec2(0.75f, -0.75f);\n        float phi = 1.0f;\n\n        vec2 dist;\n        for(int i=0; i<2; ++i)\n        {\n            const float kEyeRadius = 0.4f;\n            vec3 eyePos = vec3(cos(theta[i]), 0.0f, sin(theta[i])) * headRad;\n            dist[i] = sdSphere(pos, eyePos, kEyeRadius);\n        }\n\n        eyes = opUnion(dist[0], dist[1]);\n    }\n    \n    // Mouth\n    float mouth;\n    {\n        float sphere = sdSphere(pos, vec3(0,0,0), headRad);\n        float theta = 0.0f;\n        float phi = -0.7f;\n        vec3 mouthPos = vec3(cos(phi), sin(phi), 0.0f) * headRad; \n        mouth = sdSphere(pos, mouthPos, 1.5f);\n    }\n    \n    return opSmoothSubtraction(mouth, opUnion(skin, eyes), 0.5f);\n}\n\nfloat castRay(vec3 origin, vec3 dir, int numSteps)\n{\n    // Current distance along the ray\n    float t = 0.0f;\n\n    for (int i=0; i<numSteps; ++i)\n    {\n        vec3 pos = origin + (t * dir);\n        float dist = sdf(pos);\n        const float kEpsilon = 0.00001f;\n        if(dist < kEpsilon)\n        {\n            return t + dist;\n        }\n        t += dist;\n    }\n    \n    return -1.0f;\n}\n\nvec3 calcDiffuse(vec3 pos, vec3 camDir, vec3 normal, vec3 envHigh, vec3 envLow)\n{      \n    vec3 right = normalize(cross(kUp, normal));\n    vec3 up = cross(normal, right);\n       \n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    float index = 0.0f;\n    for(float phi = 0.0f; phi < 6.283f; phi += 0.05f)\n    {\n        for(float theta = 0.0f; theta < 1.57f; theta += 0.1f)\n        {\n            vec3 temp = cos(phi) * right + sin(phi) * up;\n            vec3 sampleVector = cos(theta) * normal + sin(theta) * temp;\n\n            vec3 envColor = envSample(sampleVector, iChannel0);\n            color += envColor * cos(theta) * sin(theta);\n            index ++;\n        }\n    }\n\n    return vec3( M_PI * (color / index));\n}\n\nvec3 calcReflection(vec3 camDir, vec3 normal, vec3 pos)\n{\n    vec3 reflection = normalize(reflect(camDir, normal));\n    \n    const float kOffset = 0.01f;\n    vec3 firstPos = pos + (normal * kOffset);\n    float shadowDist = castRay(firstPos, reflection, 40);\n    \n    vec3 result = vec3(0.0f);\n    if(shadowDist < -0.0f)\n    {\n        result = envSample(reflection, iChannel1);\n    }\n    else\n    {\n        result = kSkinShadowColor;\n    }\n    return result;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(kUp, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float center = sdf(pos);\n \n    // Use offset samples to compute gradient / normal\n    vec2 epsilonZero = vec2(0.001, 0.0);\n    return normalize(\n        vec3(\n            sdf(pos + epsilonZero.xyy),\n            sdf(pos + epsilonZero.yxy),\n            sdf(pos + epsilonZero.yyx)\n        ) - center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord)/ iResolution.y;\n    \n    float time = iTime;\n    //time = 0.0f;\n    float rotTheta = (M_PI * 0.5f) + sin(time * 0.5f);\n    float rotPhi = time * 4.0f;\n    float camDist = 12.0f;\n    vec3 camPos = vec3(\n        sin(rotTheta) * camDist,\n        sin(rotPhi),\n        cos(rotTheta) * camDist);\n    vec3 camTarget = vec3(0.0f, 0.0f, 0.0f);\n    \n    vec3 camDir = getCameraRayDir(uv, camPos, camTarget);\n    \n    float dist = castRay(camPos, camDir, 256);\n    \n    const vec3 skyHigh = vec3(0.9, 0.8, 0.7);\n    const vec3 skyLow = vec3(0.30, 0.36, 0.60);\n    \n    vec3 color;\n    if(dist >= 0.0f)\n    {\n        vec3 pos = camPos + (dist * camDir);\n        vec3 normal = calcNormal(pos);\n\n        float distFromCenter = length(pos);\n\n        float lerpVal =\n            step(distFromCenter, 5.01f) + // Is extruding\n            (step(abs(pos.z), 2.0f)); // Is outside of nose\n        lerpVal = step((2.0f - lerpVal), 1.9f);\n\n        vec3 objectSurfaceColour = mix(\n            kEyeColor,\n            kSkinColor,\n            lerpVal);\n\n        vec3 diffuse = objectSurfaceColour *\n            calcDiffuse(pos, camDir, normal, skyHigh, skyLow);\n\n        float fresnel = 1.0f - abs(dot(camDir, normal));\n\n        vec3 reflection = calcReflection(camDir, normal, pos);\n\n        //float power = iMouse.y/iResolution.y * 16.0f;\n        float power = 10.0f;\n        fresnel = pow(fresnel, power);\n        color = mix(diffuse, reflection, fresnel);\n        \n        // Display reflection\n        //color = reflection;\n        \n        // Display normal\n        //color = normal * vec3(0.5) + vec3(0.5);\n    }\n    else\n    {\n        color = envSample(camDir, iChannel1);\n    }\n    \n    // Gamma correct\n    color = pow(color, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}