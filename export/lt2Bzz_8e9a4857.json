{"ver":"0.1","info":{"id":"lt2Bzz","date":"1531023527","viewed":196,"name":"Rubix Cube","username":"lexmar","description":"Rubix Cube","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 100.0\n#define PI32 3.1415926535\n\nfloat sdf_sphere(vec3 p, vec3 o, float r)\n{\n    return length(p - o) - r;\n}\n\nfloat sdf_box(vec3 p, vec3 b)\n{\n \tvec3 d = abs(p) - b;\n \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) -0.05;\n} \n\nfloat sdf_union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdf_intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat sdf_subtract(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat sdf(vec3 p)\n{\n\tfloat result = sdf_box(p - vec3(-1.0, -1.0, -1.0), vec3(0.45, 0.45, 0.45));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 0.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 1.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, -1.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, 0.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, 1.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, -1.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 0.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 1.0, -1.0), vec3(0.45, 0.45, 0.45)));\n    \n    result = sdf_union(result, sdf_box(p - vec3(-1.0, -1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 0.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, -1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, 1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, -1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 0.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 1.0, 0.0), vec3(0.45, 0.45, 0.45)));\n    \n    result = sdf_union(result, sdf_box(p - vec3(-1.0, -1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 0.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(-1.0, 1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, -1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, 0.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(0.0, 1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, -1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 0.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    result = sdf_union(result, sdf_box(p - vec3(1.0, 1.0, 1.0), vec3(0.45, 0.45, 0.45)));\n    \n    return result;\n    //return sdf_sphere(p, vec3(0), 2.0);\n}\n\nvec3 sdf_normal(vec3 p)\n{\n    float eps = 0.001;\n    float dx = (sdf(p + vec3(eps, 0.0, 0.0)) - sdf(p - vec3(eps, 0.0, 0.0)))/(2.0*eps);\n    float dy = (sdf(p + vec3(0.0, eps, 0.0)) - sdf(p - vec3(0.0, eps, 0.0)))/(2.0*eps);\n    float dz = (sdf(p + vec3(0.0, 0.0, eps)) - sdf(p - vec3(0.0, 0.0, eps)))/(2.0*eps);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 intersect(vec3 p, vec3 dir)\n{\n \tfloat t = 0.0;\n    while(t < MAX_DISTANCE)\n    {\n        t = sdf(p);\n        if(t < 0.001) break;\n        p = p + t*dir;\n    }\n    \n    return p;\n}\n\nvec3 look_at(vec3 camera, vec3 look, vec3 p)\n{\n    vec3 forward = normalize(look - camera);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    \n    return p.x*right + p.y*up + p.z*forward;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouse_dx = iMouse.x - iResolution.x/2.0;\n    float mouse_dy = iMouse.y - iResolution.y/2.0;\n    \n    float phi = 3.0*PI32/2.0 - mouse_dx/150.0;\n    float thetha = -mouse_dy/150.0;;\n    vec3 eye = 10.0*vec3(cos(thetha)*cos(phi), sin(thetha), cos(thetha)*sin(phi));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float near = 1.0;\n    float w = 1.0;\n    float h = (iResolution.y/iResolution.x)*w;\n    vec3 dir = normalize(vec3(uv.x*w - w/2.0, uv.y*h - h/2.0, near));\n    dir = look_at(eye, vec3(0.0, 0.0, 0.0), dir);\n    \n    vec3 light = vec3(2.0, 4.0, -10.0);\n    \n    vec3 p = intersect(eye, dir);\n    vec3 light_dir = normalize(light - p);\n    vec3 normal = sdf_normal(p);\n    \n    float ambient_shading = 0.4; \n    float diffuse_shading = max(dot(normal, light_dir), 0.0);\n    \n    vec3 reflected_light_dir = 2.0*dot(normal, light_dir)*normal - light_dir; \n    float specular_shading = pow(dot(normalize(eye - p), reflected_light_dir), 100.0);\n    \n    if(distance(eye, p) < MAX_DISTANCE)\n    {\n        vec3 color = vec3(1.0, 0.0, 0.0);\n        if(normal.x < 0.0)\n        {\n            color = vec3(0.0, 1.0, 0.0);\n        }\n        else if(normal.x > 0.0)\n        {\n            color = vec3(0.0, 0.0, 1.0);\n        }\n        else if(normal.y < 0.0)\n        {\n            color = vec3(1.0, 1.0, 1.0);\n        }\n        else if(normal.y > 0.0)\n        {\n            color = vec3(0.0, 0.5, 1.0);\n        }\n        else if(normal.z < 0.0)\n        {\n            color = vec3(1.0, 1.0, 0.0);\n        }\n        \n        fragColor.rgb = \n            diffuse_shading*color + \n            specular_shading*vec3(1.0, 1.0, 1.0) +\n            ambient_shading*color;\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}