{"ver":"0.1","info":{"id":"M3fyRs","date":"1726555411","viewed":18,"name":"GradientBars","username":"JoshuaBatty","description":"gradient bars","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradientbars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float num_columns = 8.0;\nfloat gradient_pow = 0.20; // 0.0 -> 1.0\nfloat balance = 0.15; // 0.0 -> 1.0, controls black/white balance\nfloat speed = 0.1;\nfloat offset = 4.0; // 0.0 -> 16.0\nfloat x_iter = 2.0;\nfloat use_odd_dirs = 0.0; // 0.0 -> 1.0\nfloat invert_speed = 0.2;\nfloat phase_iter = 2.0; // 1.0 -> 16.0\nint easing_type = 0;\nbool use_columns = true; // true for columns, false for rows\n\nfloat adjust_balance(float value, float b) {\n    float gamma = exp(mix(-2.0, 2.0, b));\n    return pow(value, gamma);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Determine primary and secondary coordinates based on orientation\n    float primary = use_columns ? uv.x : uv.y;\n    float secondary = use_columns ? uv.y : uv.x;\n    \n    // Create mirrored primary coordinate\n    float mirrored_primary = abs(primary - 0.5) * x_iter;\n    float stripe_index = ceil(mirrored_primary * num_columns);\n    \n    // Sawtooth wave\n    float phase_offset = stripe_index * (1.0 / (num_columns * max(offset, 0.001)));\n    float phase = fract(iTime * speed + phase_offset);\n    float lfo = fun(phase, easing_type) * phase_iter - (phase_iter/2.0);\n    \n    // Determine if the stripe is even or odd\n    bool is_even_stripe = mod(stripe_index, 2.0) < 1.0;\n    \n    // Alternate direction for even stripes\n    float secondary_adjusted = is_even_stripe ? secondary : 1.0 - secondary;\n    secondary = mix(secondary, secondary_adjusted, use_odd_dirs);\n    \n    float gradient = pow(secondary, gradient_pow);\n    \n    // Change the direction\n    gradient = mix(gradient, 1.0-gradient, 0.5+sin(iTime*invert_speed)*0.5);\n    \n    // Determine which coordinate to use for animation\n    bool animate_primary_axis = false;\n    float animated_coord = animate_primary_axis ? fract(lfo + primary) : fract(lfo + gradient);\n    \n    // Time varying pixel color\n    float col = 0.5 + 0.5 * sin(animated_coord * 6.28318530718);\n    \n    // Adjust balance\n    col = adjust_balance(col, balance);\n    \n    // Output to screen\n    fragColor = vec4(vec3(1.0-col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Easing functions taken from https://www.shadertoy.com/view/7tf3Ws\n\nconst float PI = acos(-1.);\n\nfloat easeInSine(float x) {\n    return 1. - cos((x * PI) / 2.);\n}\n\nfloat easeInSine(vec2 uv) {\n    return uv.y - easeInSine(uv.x);\n}\n\nfloat easeOutSine(float x) {\n    return sin((x * PI) / 2.);\n}\n\nfloat easeOutSine(vec2 uv) {\n    return uv.y - easeOutSine(uv.x);\n}\n\nfloat easeInOutSine(float x) {\n    return -(cos(PI * x) - 1.) / 2.;\n}\n\nfloat easeInOutSine(vec2 uv) {\n    return uv.y - easeInOutSine(uv.x);\n}\n\nfloat easeInCubic(float x) {\n    return x * x * x;\n}\n\nfloat easeInCubic(vec2 uv) {\n    return uv.y - easeInCubic(uv.x);\n}\n\nfloat easeOutCubic(float x) {\n    return 1. - pow(1. - x, 3.);\n}\n\nfloat easeOutCubic(vec2 uv) {\n    return uv.y - easeOutCubic(uv.x);\n}\n\nfloat easeInOutCubic(float x) {\n    return x < .5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutCubic(vec2 uv) {\n    return uv.y - easeInOutCubic(uv.x);\n}\n\nfloat easeInQuint(float x) {\n    return x * x * x * x * x;\n}\n\nfloat easeInQuint(vec2 uv) {\n    return uv.y - easeInQuint(uv.x);\n}\n\nfloat easeOutQuint(float x) {\n    return 1. - pow(1. - x, 5.);\n}\n\nfloat easeOutQuint(vec2 uv) {\n    return uv.y - easeOutQuint(uv.x);\n}\n\nfloat easeInOutQuint(float x) {\n    return x < .5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\nfloat easeInOutQuint(vec2 uv) {\n    return uv.y - easeInOutQuint(uv.x);\n}\n\nfloat easeInCirc(float x) {\n    return 1. - sqrt(abs(1. - pow(x, 2.)));\n}\n\nfloat easeInCirc(vec2 uv) {\n    return uv.y - easeInCirc(uv.x);\n}\n\nfloat easeOutCirc(float x) {\n    return sqrt(abs(1. - pow(x - 1., 2.)));\n}\n\nfloat easeOutCirc(vec2 uv) {\n    return uv.y - easeOutCirc(uv.x);\n}\n\nfloat easeInOutCirc(float x) {\n    return x < .5\n      ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n      : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat easeInOutCirc(vec2 uv) {\n    return uv.y - easeInOutCirc(uv.x);\n}\n\nfloat easeInElastic(float x) {\n    float c4 = (2. * PI) / 3.;\n\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : -pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * c4);\n}\n\nfloat easeInElastic(vec2 uv) {\n    return uv.y - easeInElastic(uv.x);\n}\n\nfloat easeOutElastic(float x) {\n    float c4 = (2. * PI) / 3.;\n\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : pow(2., -10. * x) * sin((x * 10. - .75) * c4) + 1.;\n}\n\nfloat easeOutElastic(vec2 uv) {\n    return uv.y - easeOutElastic(uv.x);\n}\n\nfloat easeInOutElastic(float x) {\n    float c5 = (2. * PI) / 4.5;\n\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : x < .5\n      ? -(pow(2., 20. * x - 10.) * sin((20. * x - 11.125) * c5)) / 2.\n      : (pow(2., -20. * x + 10.) * sin((20. * x - 11.125) * c5)) / 2. + 1.;\n}\n\nfloat easeInOutElastic(vec2 uv) {\n    return uv.y - easeInOutElastic(uv.x);\n}\n\nfloat easeInQuad(float x) {\n    return x * x;\n}\n\nfloat easeInQuad(vec2 uv) {\n    return uv.y - easeInQuad(uv.x);\n}\n\nfloat easeOutQuad(float x) {\n    return 1. - (1. - x) * (1. - x);\n}\n\nfloat easeOutQuad(vec2 uv) {\n    return uv.y - easeOutQuad(uv.x);\n}\n\nfloat easeInOutQuad(float x) {\n    return x < .5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeInOutQuad(vec2 uv) {\n    return uv.y - easeInOutQuad(uv.x);\n}\n\nfloat easeInQuart(float x) {\n    return x * x * x * x;\n}\n\nfloat easeInQuart(vec2 uv) {\n    return uv.y - easeInQuart(uv.x);\n}\n\nfloat easeOutQuart(float x) {\n    return 1. - pow(1. - x, 4.);\n}\n\nfloat easeOutQuart(vec2 uv) {\n    return uv.y - easeOutQuart(uv.x);\n}\n\nfloat easeInOutQuart(float x) {\n    return x < .5 ? 8. * x * x * x * x : 1. - pow(-2. * x + 2., 4.) / 2.;\n}\n\nfloat easeInOutQuart(vec2 uv) {\n    return uv.y - easeInOutQuart(uv.x);\n}\n\nfloat easeInExpo(float x) {\n    return x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\nfloat easeInExpo(vec2 uv) {\n    return uv.y - easeInExpo(uv.x);\n}\n\nfloat easeOutExpo(float x) {\n    return x == 1. ? 1. : 1. - pow(2., -10. * x);\n}\n\nfloat easeOutExpo(vec2 uv) {\n    return uv.y - easeOutExpo(uv.x);\n}\n\nfloat easeInOutExpo(float x) {\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : x < .5 ? pow(2., 20. * x - 10.) / 2.\n      : (2. - pow(2., -20. * x + 10.)) / 2.;\n}\n\n\nfloat easeInOutExpo(vec2 uv) {\n    return uv.y - easeInOutExpo(uv.x);\n}\n\nfloat easeInBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeInBack(vec2 uv) {\n    return uv.y - easeInBack(uv.x);\n}\n\nfloat easeOutBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}\n\nfloat easeOutBack(vec2 uv) {\n    return uv.y - easeOutBack(uv.x);\n}\n\nfloat easeInOutBack(float x) {\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < .5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat easeInOutBack(vec2 uv) {\n    return uv.y - easeInOutBack(uv.x);\n}\n\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\nfloat easeOutBounce(vec2 uv) {\n    return uv.y - easeOutBounce(uv.x);\n}\n\nfloat easeInBounce(float x) {\n    return 1. - easeOutBounce(1. - x);\n}\n\nfloat easeInBounce(vec2 uv) {\n    return uv.y - easeInBounce(uv.x);\n}\n\nfloat easeInOutBounce(float x) {\n    return x < .5\n      ? (1. - easeOutBounce(1. - 2. * x)) / 2.\n      : (1. + easeOutBounce(2. * x - 1.)) / 2.;\n}\n\nfloat easeInOutBounce(vec2 uv) {\n    return uv.y - easeInOutBounce(uv.x);\n}\n\nfloat fun(float phase, int id){\n    switch(id){\n        case 0:  return easeInSine(phase);\n        case 1:  return easeOutSine(phase);\n        case 2:  return easeInOutSine(phase);\n        case 3:  return easeInQuad(phase);\n        case 4:  return easeOutQuad(phase);\n        case 5:  return easeInOutQuad(phase);\n        case 6:  return easeInCubic(phase);\n        case 7:  return easeOutCubic(phase);\n        case 8:  return easeInOutCubic(phase);\n        case 9:  return easeInQuart(phase);\n        case 10: return easeOutQuart(phase);\n        case 11: return easeInOutQuart(phase);\n        case 12: return easeInQuint(phase);\n        case 13: return easeOutQuint(phase);\n        case 14: return easeInOutQuint(phase);\n        case 15: return easeInExpo(phase);\n        case 16: return easeOutExpo(phase);\n        case 17: return easeInOutExpo(phase);\n        case 18: return easeInCirc(phase);\n        case 19: return easeOutCirc(phase);\n        case 20: return easeInOutCirc(phase);\n        case 21: return easeInBack(phase);\n        case 22: return easeOutBack(phase);\n        case 23: return easeInOutBack(phase);\n        case 24: return easeInElastic(phase);\n        case 25: return easeOutElastic(phase);\n        case 26: return easeInOutElastic(phase);\n        case 27: return easeInBounce(phase);\n        case 28: return easeOutBounce(phase);\n        case 29: return easeInOutBounce(phase);\n        default: return 0.;\n    }\n}","name":"Common","description":"","type":"common"}]}