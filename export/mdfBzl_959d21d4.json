{"ver":"0.1","info":{"id":"mdfBzl","date":"1689061520","viewed":73,"name":"waves test","username":"tianluo970922","description":"waves test","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["wavestest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n\tfloat inten = .009;\n    \n    float timeCtrl = smoothstep(0.0, 1.0, pow(iTime * 0.1, 1.0));\n  \n    //WhiteEdge\n    vec3 whiteEdge = vec3(1.000,1.000,1.000); \n\n    float whiteEdgeStart = -0.1;\n    float whiteEdgeEnd = 1.0;\n    float whiteEdgeMask = mix(whiteEdgeStart, whiteEdgeEnd, timeCtrl);\n    \n    float whiteRangeStart = 0.2;\n    float whiteRangeEnd = 1.0;\n    float whiteRangeMask = mix(whiteRangeStart, whiteRangeEnd, timeCtrl);\n    \n    float whiteOpacityStart = 0.2;\n    float whiteOpacityEnd = 0.6;\n    float whiteOpacityMask = mix(whiteOpacityStart, whiteOpacityEnd, timeCtrl);\n    \n    float whiteMask = cubicPulse(whiteEdgeMask, whiteRangeMask, uv.y);\n    \n\n    float scale = 3.0; \n    float timetest =sin((iTime * 1.0/scale - 0.25) * 3.1415926 * 4.0/2.0) * 0.5 + 0.5;\n    float offset = uv.y - iTime;\n    float y = mod(offset, scale);\n    \n    float d = smoothstep(0.2 * scale, -0.0  * scale, y) * 1.0;\n    float d1 = smoothstep(0.6  * scale, 1.0  * scale, y) * 1.0;\n    vec3 maskColor =  vec3(d) + vec3(d1);\n    maskColor *= timetest;\n    //maskColor *= sin(iTime * scale - 3.14/2.0) * 0.5 + 0.5;\n    \n    fragColor = vec4(maskColor,1.0);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}","name":"Image","description":"","type":"image"}]}