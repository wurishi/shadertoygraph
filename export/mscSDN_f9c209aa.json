{"ver":"0.1","info":{"id":"mscSDN","date":"1679859668","viewed":68,"name":"Newton parameter space","username":"zenzicubic","description":"Got the idea from 3b1b, its kinda messy tho","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","parameter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CEN vec2(-0.81, -0.84)\n#define FSCL 0.02\n#define ONE vec2(1., 0.)\n\n#define EPS 1e-5\n#define MAXIT 100\n\nvec3[3] cols = vec3[](\n    vec3(0.557,0.267,0.678),\n    vec3(0.204,0.596,0.859),\n    vec3(0.18,0.8,0.443));\nvec2[3] roots = vec2[](ONE, -ONE, vec2(0.));\n\nvec2 cmul(vec2 a, vec2 b) { return mat2(a, -a.y, a.x) * b; }\nvec2 cinv(vec2 z) { return vec2(z.x, -z.y) / dot(z, z); }\nvec2 cdiv(vec2 a, vec2 b) { return cmul(a, cinv(b)); }\n\nvec2 iterate(vec2 z) {\n    vec2 A = z - roots[0];\n    vec2 B = z - roots[1];\n    vec2 C = z - roots[2];\n    \n    return cdiv(\n        cmul(A, cmul(B, C)),\n        cmul(B, C) + cmul(A, C) + cmul(A, B));\n}\n\nvec3 test(vec2 z) {\n    roots[2] = z;\n    \n    vec2 L = (roots[0] + roots[1] + z) / 3.;\n    for (int i = 0; i < MAXIT; i ++) {\n        L -= iterate(L);\n        for (int j = 0; j < 3; j ++) {\n            if (length(L - roots[j]) < EPS) {\n                return cols[j];\n            }\n        }\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 o, in vec2 c) {\n    float t = mod(1. + iTime * 0.25, 4.);\n    float cs = sin(1.57 * t);\n    cs *= cs;\n    \n    float f = (t < 1. ? cs : (t < 2. ? 1. : (t < 3. ? 1. - cs : 0.)));\n    vec2 z = (.02 + 2.5 * f) * (2. * c - iResolution.xy) / iResolution.y;\n    o = vec4(test(z + (1. - f) * CEN), 0.);\n}","name":"Image","description":"","type":"image"}]}