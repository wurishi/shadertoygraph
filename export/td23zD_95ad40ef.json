{"ver":"0.1","info":{"id":"td23zD","date":"1548368834","viewed":318,"name":"[TWITCH] Temple Of Time","username":"Flopine","description":"This is the result of a 2 hours stream (approximately, I'm drunk right now because of the beer)\nHeavily inspired by Zelda Ocarina Of Time game. \n\nHope you like it!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","zelda","twitchlive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 100.\n#define time iTime\n#define PI 3.141592\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  a = mod(a-per/2., per)-per/2.;\n  return vec2(cos(a), sin(a))*l;\n  \n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a), -sin(a), cos(a));}\n\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\n// iq function for signed hexagone\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// iq function for triangular prism\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.xz *= rot(-time);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat room (vec3 p)\n{\n  float ground = abs(p.y+5.)-0.1;\n  float hex = sdHexPrism(vec3(p.x, p.z, p.y+2.), vec2(50.));\n  return min(ground, -hex);\n}\n\nfloat column (vec3 p)\n{\n  float width = 3.;\n  float c1 = length(p.xz)-width;\n\n  p.xz *= rot(p.y*0.5);\n  p.xz *= rot(time);\n  p.xz = moda(p.xz, PI);\n  p.x -= width;\n  float c2 = length(p.xz)-1.2;\n  return min(c1,c2);\n}\n\nfloat g2 = 0.;\nfloat columns (vec3 p)\n{\n  p.xz = moda(p.xz, PI/3.);\n  p.x -= 50.;\n  float d =  column(p);\n  g2 += 0.1/(0.1+d*d);\n  return d;\n}\n\nfloat pedestral (vec3 p)\n{\n  vec3 new_p = vec3(p.x, p.z,p.y+4.5);\n  float width = 15.;\n  float thick = 0.2;\n  float st = 2.;\n  float hexs = sdHexPrism(new_p, vec2(width, thick));\n  for (float i=1.; i<3.; i++)\n  {\n    thick += i*0.3;\n    width -= i*3.;\n    new_p.z -=i*0.5;\n    hexs = stmin(hexs, sdHexPrism(new_p, vec2(width, thick)),1., st);\n    st++;\n  }\n  return hexs;\n}\n\nfloat g1 = 0.;\nfloat triforce (vec3 p)\n{\n  p.y -= 5.;\n  float t1 = sdTriPrism(p, vec2(2., 0.2));\n  float t2 = sdTriPrism(vec3(p.x-2., p.y+3.5, p.z), vec2(2., 0.2));\n  float t3 = sdTriPrism(vec3(p.x+2., p.y+3.5, p.z), vec2(2., 0.2));\n  float d =  min(t3,min(t1, t2));\n  // glow tricks from balkhan\n  g1 += 0.1/(0.1+d*d);\n  return d;\n}\n\nfloat SDF (vec3 p)\n{\n  float r = stmin(room(p),columns(p), 5., 3.);\n  return min(triforce (p),min(r, pedestral(p)));\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3 up = normalize(cross(forward, left));\n  return forward*fov + left*uv.x + up*uv.y;\n}\n\nvec3 get_normals (vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(vec3(SDF(p+eps.xyy)- SDF(p-eps.xyy),\n                        SDF(p+eps.yxy)- SDF(p-eps.yxy),\n                        SDF(p+eps.yyx)- SDF(p-eps.yyx)   \n                        )\n                  ); \n}\n\nvec3 point_light (vec3 p, vec3 n)\n{\n  vec3 lpos = vec3(0.,5.,0.);\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(0.8,0.8,0.)*dotNL) / (0.01 * ldist * ldist);\n}\n\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float dither = random(uv);\n\n  vec3 ro = vec3(-27.*cos(time*0.2), 10., -27.*sin(time*0.2));\n  vec3 p = ro;\n  vec3 target = vec3(0.);\n  vec3 rd = normalize(get_cam(ro, target, uv, 1.));\n    \n  float shad = 0.;\n  vec3 col = vec3(0.);\n\n  for (float i=0.; i<ITER; i++)\n  {\n      float d = SDF(p);\n      if (d<0.001)\n      {\n        vec3 n = get_normals(p);\n        // hemisphere ligting\n        col = mix(vec3(0.3, 0.1, 0.3), vec3(0.5,0.9,0.9), lighting (n, vec3(-5., 10., -3.)));\n        \n        // point light\n        col += point_light(p, n);\n      \n        // fake AO\n        shad = i/ITER;\n        col *= (1.-shad);\n        break;\n      }\n    d *= 0.9 + dither*0.1;\n    p += d*rd;\n  }\n\n  float t = length(ro-p);\n  col += g1 * vec3(1.,1.,0.)*0.3;\n  col += g2 * vec3(0.1,0.2,0.4);\n    \n  // fog\n  col = mix(col,vec3(0.1, 0.2, 0.3), 1.-exp(-0.0003*t*t));\n    \n  fragColor = vec4(pow(col,vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"}]}