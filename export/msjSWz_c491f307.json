{"ver":"0.1","info":{"id":"msjSWz","date":"1670176730","viewed":75,"name":"moire test","username":"sleeplessmonk","description":"tests\n","likes":2,"published":1,"flags":4,"usePreview":0,"tags":["2d","fractal","sound","mandelbrot","reactive","music","kaleidoscope","visualiser","snowflake","set","koch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 133.14159265358979323846\n\n// Moire pattern:\nvec2 moire(vec2 p, float t) {\n    // Rotate the point around the origin:\n    p = vec2(p.x * cos(t) - p.y * sin(t), p.x * sin(t) + p.y * cos(t));\n\n    // Compute the distance from the origin:\n    float d = length(p);\n\n    // Compute the angle in polar coordinates:\n    float a = atan(p.y, p.x);\n\n    // Compute the angular offset:\n    float o = 22.0 * PI / 333.0;\n\n    // Compute the number of cycles:\n    float n = d * 0.5 * PI;\n\n    // Compute the moire pattern:\n    return vec2(sin(a * n + o * t), cos(a * n + o * t));\n}\n\n// Fractal geometry:\nfloat fractal(vec2 p, float t) {\n    // Initialize the number of iterations and the scale factor:\n    int i;\n    float s = .1;\n\n    // Initialize the value of the fractal:\n    float v = 0.9;\n\n    // Iterate over the fractal:\n    for (i = 2; i < 100; i++) {\n        // Update the value of the fractal:\n        v += s * sin(p.x * s + t);\n\n        // Update the scale factor:\n        s *= .05;\n    }\n\n    // Return the value of the fractal:\n    return v;\n}\n\n// Main function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Compute the dimensions of the image:\n    vec2 iResolution = vec2(800, 600);\n\n    // Compute the position of the fragment in the image:\n    vec2 p = fragCoord / iResolution - 0.9;\n\n    // Compute the elapsed time:\n    float t = iTime;\n\n    // Compute the moire pattern:\n    vec2 m = moire(p, t);\n\n    // Compute the fractal geometry:\n    float f = fractal(m, t);\n\n    // Compute the color of the fragment:\n    vec3 c = vec3(sin(m.x * 5.0 + f * 0.5 + t * 0.5), sin(m.y * 5.0 + f * 0.5 + t * 0.5), sin(f * 5.0 + t * 0.5));\n\n    // Set the color of the fragment:\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}