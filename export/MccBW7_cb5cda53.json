{"ver":"0.1","info":{"id":"MccBW7","date":"1733165968","viewed":11,"name":"Raymarching Lambertian","username":"Longingly","description":"A demo shader i made for practice","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing","brdf","lambertiandiffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define a struct to hold surface information\nstruct SurfaceInfo {\n    vec3 color;\n    float distance;\n    float radiance;\n};\n\nfloat sdfSphere(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat sdfPlane(vec3 p, float planeY) {\n    return p.y - planeY;\n}\n\nfloat sdfCube(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\n// Helper function to smoothly combine two SurfaceInfos\nSurfaceInfo smoothMinSurface(SurfaceInfo a, SurfaceInfo b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.distance - a.distance) / k, 0.0, 1.0);\n    SurfaceInfo result;\n    result.distance = mix(b.distance, a.distance, h) - k * h * (1.0 - h);\n    result.color = mix(b.color, a.color, h);\n    result.radiance = mix(b.radiance, a.radiance, h);\n    return result;\n}\n\n// Helper function to smoothly subtract one SurfaceInfo from another\nSurfaceInfo smoothSubSurface(SurfaceInfo a, SurfaceInfo b, float k) {\n    float h = clamp(0.5 - 0.5 * (b.distance + a.distance) / k, 0.0, 1.0);\n    SurfaceInfo result;\n    result.distance = mix(a.distance, -b.distance, h) + k * h * (1.0 - h);\n    result.color = mix(a.color, b.color, h); // Adjust as needed for subtraction\n    result.radiance = mix(a.radiance, b.radiance, h); // Adjust if radiance matters\n    return result;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Scene definition\nSurfaceInfo map(vec3 p) {\n    // k is the smoothing factor\n    const float k = 0.;\n    SurfaceInfo result;\n    \n    const int NUM_CUBES = 6;\n    SurfaceInfo cubeSurfaceInfos[NUM_CUBES];\n    vec3 cubePositions[NUM_CUBES];\n    vec3 cubeSizes[NUM_CUBES];\n    \n    // Define Outside Cube\n    cubePositions[0] = vec3(0., 0., 0.);\n    cubeSizes[0] = vec3(10., 10., 10.);\n    cubeSurfaceInfos[0].color = vec3(1.);\n    cubeSurfaceInfos[0].radiance = 0.;\n    cubeSurfaceInfos[0].distance = sdfCube(p - cubePositions[0], cubeSizes[0]);\n    \n    // Define Inside Cube\n    cubePositions[1] = vec3(0., 0., 0.);\n    cubeSizes[1] = vec3(5., 5., 5.);\n    cubeSurfaceInfos[1].color = vec3(1.);\n    cubeSurfaceInfos[1].radiance = 0.;\n    cubeSurfaceInfos[1].distance = sdfCube(p - cubePositions[1], cubeSizes[1]);\n    \n    // Calculate first result by carving the outside cube with the inside one\n    result = smoothSubSurface(cubeSurfaceInfos[0], cubeSurfaceInfos[1], k);\n\n    const int NUM_SPHERES = 3;\n    SurfaceInfo sphereSurfaceInfos[NUM_SPHERES];\n    vec3 spherePositions[NUM_SPHERES];\n    float sphereSizes[NUM_SPHERES];\n\n    // Define spheres\n    spherePositions[0] = vec3(0.0, 0.0, 0.0);\n    sphereSizes[0] = 0.2;\n    sphereSurfaceInfos[0].color = vec3(1.000,1.000,1.000); // Red diffuse sphere\n    sphereSurfaceInfos[0].radiance = 5.;\n\n    spherePositions[1] = vec3(sin(iTime) * 1.5, cos(iTime) * 1.5, sin(iTime * 2.));\n    sphereSizes[1] = 0.4;\n    sphereSurfaceInfos[1].color = vec3(0.000,0.000,1.000); // White emissive sphere (light source)\n    sphereSurfaceInfos[1].radiance = 0.;\n    \n    spherePositions[2] = vec3(cos(iTime) * 1.5, sin(iTime) * 1.5, cos(iTime * 2.));\n    sphereSizes[2] = 0.4;\n    sphereSurfaceInfos[2].color = vec3(0.082,0.918,0.082);\n    sphereSurfaceInfos[2].radiance = 0.;\n\n    // Calculate distances to the spheres\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        sphereSurfaceInfos[i].distance = sdfSphere(p - spherePositions[i], sphereSizes[i]);\n    }\n\n    // Find the closest surface\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        result = smoothMinSurface(result, sphereSurfaceInfos[i], k);\n    }\n\n    return result;\n}\n\n\n// Function to compute the normal at point p\nvec3 computeNormal(vec3 p) {\n    const float eps = 0.0001;\n    float dx = map(p + vec3(eps, 0.0, 0.0)).distance - map(p - vec3(eps, 0.0, 0.0)).distance;\n    float dy = map(p + vec3(0.0, eps, 0.0)).distance - map(p - vec3(0.0, eps, 0.0)).distance;\n    float dz = map(p + vec3(0.0, 0.0, eps)).distance - map(p - vec3(0.0, 0.0, eps)).distance;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// Random number generator\nfloat random(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy, vec2(a, b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\nvec3 anyOrthogonalVector(vec3 n) {\n    // Find a vector that is orthogonal to n\n    if (abs(n.x) > abs(n.z)) {\n        return vec3(-n.y, n.x, 0.0);\n    } else {\n        return vec3(0.0, -n.z, n.y);\n    }\n}\n\n// Function to sample a random direction in a hemisphere oriented around a normal vector\nvec3 sampleHemisphereCosine(vec3 normal, vec2 rand) {\n    // Convert random numbers to spherical coordinates\n    float phi = 2.0 * 3.14159265 * rand.x;\n    float cosTheta = sqrt(1.0 - rand.y);\n    float sinTheta = sqrt(rand.y);\n\n    // Compute the direction in tangent space\n    vec3 tangent = normalize(anyOrthogonalVector(normal));\n    vec3 bitangent = cross(normal, tangent);\n    vec3 direction = sinTheta * cos(phi) * tangent + sinTheta * sin(phi) * bitangent + cosTheta * normal;\n\n    return normalize(direction);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Compute normalized screen coordinates\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 finalColor = vec3(0.0);\n\n    const int sampleNumber = 1;\n    const int bounceTimes = 4;\n    const int maxMarches = 80;\n\n    // Loop over the number of samples\n    for (int s = 0; s < sampleNumber; s++) {\n\n\n        // Introduce a small random offset for anti-aliasing\n        vec2 jitter = vec2(random(fragCoord + float(s) + 0.1),\n                           random(fragCoord - float(s) + 0.2)) / iResolution.xy;\n        uv += jitter;\n\n        // Initialize ray origin and direction\n        vec3 ro = vec3(0.0, 0.0, -3.0);\n        vec3 rd = normalize(vec3(uv, 1.0));\n\n        vec3 accumulatedColor = vec3(0.0);\n        vec3 throughput = vec3(1.0);\n\n        // Bounce Loop\n        for (int j = 0; j < bounceTimes; j++) {\n            float t = 0.0;\n            bool hit = false;\n\n            // Ray marching loop\n            for (int i = 0; i < maxMarches; i++) {\n                vec3 p = ro + rd * t;\n                SurfaceInfo a = map(p);\n                float d = a.distance;\n\n                if (d < 0.001) {\n                    hit = true;\n\n                    // Compute normal at the hit point\n                    vec3 normal = computeNormal(p);\n\n                    // Accumulate emitted light\n                    vec3 emittedColor = a.color * a.radiance;\n                    accumulatedColor += throughput * emittedColor;\n\n                    // Update throughput with the material's albedo\n                    throughput *= a.color;\n\n                    // Russian roulette termination to avoid infinite bounces\n                    float maxThroughput = max(throughput.r, max(throughput.g, throughput.b));\n                    if (maxThroughput < 0.01) {\n                        if (random(fragCoord.xy + vec2(float(j))) > maxThroughput) {\n                            break;\n                        }\n                        throughput /= maxThroughput;\n                    }\n\n                    // Generate two random numbers for hemisphere sampling\n                    vec2 randUV = vec2(random(uv.xy - float(s) + float(j) * 0.1),\n                                       random(uv.yx + float(s) + float(j) * 3.14));\n\n                    // Sample a random direction in the hemisphere around the normal\n                    vec3 randomDir = sampleHemisphereCosine(normal, randUV);\n\n                    // Update ray origin and direction\n                    ro = p + normal * 0.001; // Offset to prevent self-intersection\n                    d = 20.;\n                    rd = randomDir;\n\n                    break; // Proceed to the next bounce\n                }\n\n                t += d;\n\n                // Exit if the ray goes too far\n                if (t > 1000.0) {\n                    break;\n                }\n            }\n\n            if (!hit) {\n                // If the ray didn't hit anything, assume background color (e.g., black)\n                break;\n            }\n        }\n\n        // Accumulate the color from this sample\n        finalColor += accumulatedColor;\n    }\n\n    // Average the final color over all samples\n    finalColor /= float(sampleNumber);\n\n    // Apply gamma correction\n    finalColor = pow(finalColor, vec3(1.0 / 2.2));\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}