{"ver":"0.1","info":{"id":"tljfW3","date":"1600045606","viewed":565,"name":"Wide-Angle Equiangular Camera","username":"fu5ha","description":"This is a modification of a cool mandelbox shader by EvilRyu to show how to make an equiangular camera and the difference in appearance vs a standard rectilinear camera.\n\nClick and drag the mouse to move the comparison line.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","camera","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original created by EvilRyu\n//\n// modified to show how to make an equidistant projection camera and the visual difference\n//\n// scroll down to the mainImage function for an explanation of how the projection is derived\n\nfloat stime, ctime, time;\nvoid ry(inout vec3 p, float a){  \n\tfloat c,s;vec3 q=p;  \n\tc = cos(a); s = sin(a);  \n\tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\nfloat fixed_radius2 = 1.9;\nfloat min_radius2 = 0.4;\nfloat folding_limit = 1.0;\nfloat scale = -2.0;\nvec3 mtl = vec3(1.0, 1.3, 1.23)*0.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t//scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat f(vec3 p){ \n\try(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.001 * t || res > 20.)\n            break;\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\n\nvec3 lighting(vec3 p,vec3 rd, float ps) {\n\t\n\tvec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); \n    vec3 l1_col = 0.3*vec3(1.5, 1.69, 0.79);\n\tvec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));\n    vec3 l2_col = vec3(0.89, 0.99, 1.3); \n    \n    vec3 e=vec3(0.5 * ps,0.0,0.0); \n \tvec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n\t\n\tfloat shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_dir));\n\tfloat dif2 = max(0.0, dot(n, l2_dir));\n\tfloat bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n\tfloat bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 5.5 * l1_col * dif1 * shadow;\n\tcol += 1.1 * l2_col * dif2;\n\tcol += 0.3 * bac1 * l1_col;\n\tcol += 0.3 * bac2 * l2_col; \n    col += 1.0 * spe; \n\t\n    float t=mod(p.y+0.1*texture(iChannel0,p.xz).x-time*150.0, 5.0);\n    col = mix(col, vec3(6.0, 6.0, 8.0), \n              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;\n\treturn col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(1.0); \n\treturn bg;\n}\nvec3 camera(float t){\n\tvec3 p=vec3(3.0*stime,2.0*ctime,5.0+1.0*stime) * (0.6 + 0.1 * stime);\n    return p;\n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    float mousey = 0.0;\n    if (iMouse.z > 0.0) {\n         mousey = 2.0 * iMouse.y / iResolution.y - 1.0;\n    }\n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.1); \n \tctime=cos(iTime*0.1); \n    time=iTime*0.01;\n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro=camera(time);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf));\n\n   \tfloat focal_length = 1.3;\n    vec2 perturbed_uv = uv;\n   \tif (uv.y > mousey) {\n        // see http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html\n        // our model is somewhat inverse from the model in the article, as instead of taking an existing\n        // light ray coming into a lens and bending it with a lens, we are starting at the camera sensor\n        // and want to construct the final ray.\n        //\n        // as such, we start with the radius of the final position, which we want to be the\n        // equidistant / equiangular projection, i.e. (theta * focal length)\n\t\t//\n        // and we want to compute the rectilinear radius, i.e. (tan(theta) * focal length)\n\t\t// and then scale the uv by the factor which will bring the equidistant radius to\n        // the rectilinear radius, namely\n        //\n        // (tan(theta) * focal length) / (theta * focal length)\n        //\n        // which simplifies to\n        //\n        // tan(theta) / theta\n        //\n        // we can compute theta by realizing that we can solve the equation\n        //\n        // equidistant radius = theta * focal length\n        // \n        // given that we already have the equidistant radius and focal length, we get\n        //\n        // theta = equidistant radius / focal length\n        \n       \tfloat theta = length(uv) / focal_length;\n    \tperturbed_uv = uv * tan(theta) / theta; // \"equidistance\" / equiangular projection\n    }\n     \n    vec3 rd = normalize(perturbed_uv.x*cs + perturbed_uv.y*cu + focal_length*cf);  // transform from view to world\n\t\n\tvec3 bg = get_background_color(uv, ro, rd); \n    vec3 col = bg;\n\n    vec3 p=ro; \n\t \n\tfloat t = intersect(ro, rd);\n\tif(t > 0.01){\n\t\tp = ro + t * rd;\n        col = lighting(p, rd, 0.004)*mtl*0.2; \n        col = mix(col, bg, 1.0-exp(-0.01*t*t)); \n    }\n\n   \tcol=post(col, q);\n\tcol = mix(vec3(1.0, 0.6, 1.0), col, smoothstep(0.0, 0.01, abs(uv.y - mousey)));\n \tfragColor=vec4(col.x,col.y,col.z,1.0);\n }","name":"Image","description":"","type":"image"}]}