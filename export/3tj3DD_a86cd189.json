{"ver":"0.1","info":{"id":"3tj3DD","date":"1559636614","viewed":515,"name":"Cat Tracer in one weekend","username":"Ohno","description":"Small party prod by Ohno! released at Outline 2019 in the 4k compo","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["triangles","demo","pathtracing","origami","tangram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n@flopine\n@lsdlive\nCC-BY-NC-SA\n\n\nCat Tracer by Ohno!\n\n\nSmall party prod released at Outline 2019 in the 4k compo.\n\nThis was a small exercice to learn and practice Pathtracing.\nThe Pathtracing base engine is coming from \"Raytracing in One Week End\" by Peter Shirley.\nRandom functions borrowed from Nimitz via reinder.\nAlso, extended with triangle/plane intersection & a faster lambert importance sampling.\n\n\n\"Raytracing in One Week End\" by Peter Shirley\nhttps://github.com/petershirley/raytracinginoneweekend\n\nUnderstanding lot of math & technics behind raytracing & pathtracing:\nhttp://www.scratchapixel.com/\n\nExcellent video course about Pathtracing by @karoly_zsolnai:\nhttps://www.youtube.com/watch?v=pjc1QAI6zS0&list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi\n\nUnderstanding hemispherical uniform sampling:\nhttp://corysimon.github.io/articles/uniformdistn-on-sphere/\n\n*/\n\nconst int MAXSAMPLE = 10; // can be set to 20-40 on strong GPU\nconst int MAXRECURSION = 4;\n\n#define CAT 1\n#define SWAN 2\n\n\nfloat bpm = .5*134. / 60.;\n\nfloat ts2 = 14.328;\nfloat ts3 = 21.492;\nfloat ts4 = 28.656;\n\nstruct Camera {\n\tvec3 origin;\n\tvec3 lower_left_corner;\n\tvec3 horizontal;\n\tvec3 vertical;\n\tvec3 u, v;\n\tfloat lens_radius;\n};\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Hit_record {\n\tfloat dist;\n\tvec3 pos, normal;\n\tvec3 mat;\n};\n\n\nfloat g_seed = 0.;\nuint base_hash(uvec2 p) {\n\tp = 1103515245U * ((p >> 1U) ^ (p.yx));\n\tuint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n\treturn h32 ^ (h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n\tuint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n\tuvec2 rz = uvec2(n, n * 48271U);\n\treturn vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// fizzer via iq\n// https://www.shadertoy.com/view/MsdGzl\nvec3 random_cos_weighted_hemisphere_direction(const vec3 n, inout float seed) {\n\tvec2 r = hash2(seed);\n\tfloat a = TAU * r.y;\n\tr.x = 2. * r.x - 1.;\n\treturn normalize(n + vec3(sqrt(1. - r.x * r.x) * vec2(cos(a), sin(a)), r.x));\n}\n\n// reinder\n// https://www.shadertoy.com/view/XlGcWh\nvec2 random_unit_disk() {\n\tvec2 h = hash2(g_seed) * vec2(1, TAU);\n\tfloat phi = h.y;\n\tfloat r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\n\nvec3 point_at_parameter(Ray r, float t) { return r.origin + t * r.direction; }\n\nCamera get_camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov,\n\tfloat aspect, float aperture, float focus_dist) {\n\n\tvec3 u, v, w;\n\tfloat theta = vfov * PI / 180.;\n\tfloat half_height = tan(theta / 2.);\n\tfloat half_width = aspect * half_height;\n\tw = normalize(lookfrom - lookat);\n\tu = normalize(cross(vup, w));\n\tv = cross(w, u);\n\treturn Camera(lookfrom,\n\t\tlookfrom - (half_width * u + half_height * v + w) * focus_dist,\n\t\t2. * half_width * u * focus_dist,\n\t\t2. * half_height * v * focus_dist, u, v, aperture / 2.);\n}\n\nRay get_ray(Camera cam, vec2 uv) {\n\tvec2 rd = cam.lens_radius * random_unit_disk();\n\tvec3 offset = cam.u * rd.x + cam.v * rd.y;\n\treturn Ray(cam.origin + offset,\n\t\tnormalize(cam.lower_left_corner + uv.x * cam.horizontal +\n\t\t\tuv.y * cam.vertical - cam.origin - offset));\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// iq\n// https://www.shadertoy.com/view/ttfGWl\nfloat triangle_intersect(in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2,\n\tout vec3 n) {\n\tvec3 v1v0 = v1 - v0;\n\tvec3 v2v0 = v2 - v0;\n\tvec3 rov0 = ro - v0;\n\n\tn = cross(v1v0, v2v0);\n\tvec3 q = cross(rov0, rd);\n\tfloat d = 1.0 / dot(rd, n);\n\tfloat u = d * dot(-q, v2v0);\n\tfloat v = d * dot(q, v1v0);\n\tfloat t = d * dot(-n, rov0);\n\n\tif (u < 0.0 || v < 0.0 || (u + v) > 1.0)\n\t\tt = 1e6;\n\n\tn = normalize(n);\n\n    // double sided triangle\n\tif (dot(n, -rd) < 0.)\n\t\tn = -n;\n\n\treturn t;\n}\n\nvoid animate_cat(inout vec3 p) {\n\t// tilt movement\n\tif (iTime <ts2 || iTime > ts3)\n\t\tp.xz *= r2d(.4*(floor(sin(bpm*iTime*PI) + 1.) - .5));\n\n\t// side movement\n\tp.x += mix(7., -0.2, smoothstep(0., ts2 + 1.5, iTime));\n\n}\n\nvoid animate_swan(inout vec3 p) {\n\tp.xy -= vec2(2, .2);\n\n\t// tilt movement\n\tif (iTime <ts2 || iTime > ts3)\n\t\tp.xz *= r2d(.3*(floor(cos(bpm*iTime*PI) + 1.) - .5));\n\n\t// side movement\n\tp.x += mix(-7., 0.2, smoothstep(0., ts2 + 1.5, iTime));\n}\n\nvoid shrink(inout vec3 v0, inout vec3 v1, inout vec3 v2, int obj_id) {\n\n\tfloat enable = smoothstep(ts2 - .1, ts2 + .5, iTime) * (1. - smoothstep(ts2 + 2.6, ts3, iTime));\n\n\tfloat ts = (float(obj_id) + iTime) * enable;\n\tv0.xz *= r2d(ts*1.);\n\tv1.xy *= r2d(ts*.5);\n\tv2.xz *= r2d(ts*1.);\n\n\tif (obj_id == CAT) {\n\t\tv0.xy += vec2(enable*sin(ts) * 2., enable*1.);\n\t\tv1.xy += vec2(enable*cos(ts) * 2., enable*1.);\n\t\tv2.xy += vec2(enable*sin(ts) * 2., enable*1.);\n\n\t}\n\telse {\n\t\tv0.xy += vec2(enable*cos(ts) * 2., enable*2.);\n\t\tv1.xy += vec2(enable*sin(ts) * 2., enable*2.);\n\t\tv2.xy += vec2(enable*cos(ts) * 2., enable*2.);\n\t}\n}\n\nbool catswan_hit(Ray r, float tmin, float tmax, inout Hit_record rec, int obj_id) {\n\tbool ret = false;\n\n\tfor (int i = 0; i < 9; i++) {\n\t\tvec3 v0 = vertices[faces[i].x];\n\t\tvec3 v1 = vertices[faces[i].y];\n\t\tvec3 v2 = vertices[faces[i].z];\n        \n\t\tif (obj_id == CAT) {\n\n\t\t\tshrink(v0, v1, v2, 1);\n\n\t\t\tv0.xy *= r2d(catpositions[i].w);\n\t\t\tv0 += catpositions[i].xyz;\n\t\t\tv1.xy *= r2d(catpositions[i].w);\n\t\t\tv1 += catpositions[i].xyz;\n\t\t\tv2.xy *= r2d(catpositions[i].w);\n\t\t\tv2 += catpositions[i].xyz;\n\n\t\t\tanimate_cat(v0);\n\t\t\tanimate_cat(v1);\n\t\t\tanimate_cat(v2);\n\t\t}\n\n\t\telse if (obj_id == SWAN) {\n\n\t\t\tshrink(v0, v1, v2, 2);\n\n\t\t\tv0.xy *= r2d(swanpositions[i].w);\n\t\t\tv0 += swanpositions[i].xyz;\n\t\t\tv1.xy *= r2d(swanpositions[i].w);\n\t\t\tv1 += swanpositions[i].xyz;\n\t\t\tv2.xy *= r2d(swanpositions[i].w);\n\t\t\tv2 += swanpositions[i].xyz;\n\n\t\t\tanimate_swan(v0);\n\t\t\tanimate_swan(v1);\n\t\t\tanimate_swan(v2);\n\t\t}\n\n        vec3 normal;\n\t\tfloat t = triangle_intersect(r.origin, r.direction, v0, v2, v1, normal);\n\t\tif (t < rec.dist && t > tmin && t < tmax) {\n\t\t\tret = true;\n\t\t\trec.dist = t;\n\t\t\trec.normal = normal;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool background_hit(Ray r, float tmin, float tmax, inout Hit_record rec) {\n\tbool ret = false;\n\n\tfor (int i = 9; i < 11; i++) {\n\t\tvec3 v0 = vertices[faces[i].x];\n\t\tvec3 v1 = vertices[faces[i].y];\n\t\tvec3 v2 = vertices[faces[i].z];\n\n        vec3 normal;\n\t\tfloat t = triangle_intersect(r.origin, r.direction, v0, v2, v1, normal);\n\t\tif (t < rec.dist && t > tmin && t < tmax) {\n\t\t\tret = true;\n\t\t\trec.dist = t;\n\t\t\trec.normal = normal;\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool plane_hit(vec4 plane, Ray r, float tmin, float tmax, inout Hit_record rec) {\n\tbool hit = false;\n\n\tvec3 n = plane.xyz;\n\tvec3 pos = n * plane.w;\n\tfloat t = dot(pos - r.origin, n) / dot(r.direction, n);\n\n\tif (t < rec.dist && t > tmin && t < tmax) {\n\t\thit = true;\n\t\trec.dist = t;\n\t\trec.normal = n;\n\t}\n\n\treturn hit;\n}\n\nbool world_hit(Ray r, float tmin, float tmax, out Hit_record rec) {\n\trec.dist = tmax;\n\tbool hit = false;\n\n\tif (plane_hit(vec4(0, 1, 0, -2.3), r, tmin, rec.dist, rec)) {\n\t\thit = true, rec.mat = vec3(1., .84, 0);\n\t}\n\n\tif (plane_hit(vec4(0, 0, 1, -5.5), r, tmin, rec.dist, rec)) {\n\t\thit = true, rec.mat = vec3(1., .5, .8);\n\t}\n    \n    if (background_hit(r, tmin, rec.dist, rec)) {\n\t\thit = true, rec.mat = vec3(.9, .2, .07);\n\t}\n\n\tif (catswan_hit(r, tmin, rec.dist, rec, CAT)) {\n\t\thit = true, rec.mat = vec3(.95);\n\t}\n    \n    if (catswan_hit(r, tmin, rec.dist, rec, SWAN)) {\n\t\thit = true, rec.mat = vec3(.95);\n\t}\n\n\trec.pos = point_at_parameter(r, rec.dist);\n\n\treturn hit;\n}\n\n// diffuse lambert only\nRay scatter(in Hit_record rec) {\n\treturn Ray(rec.pos, random_cos_weighted_hemisphere_direction(rec.normal, g_seed));\n}\n\nvec3 color(in Ray r) {\n\tvec3 col = vec3(0);\n\tvec3 atten = vec3(1);\n\tfor (int i = 0; i < MAXRECURSION; i++) {\n\t\tHit_record rec;\n\t\tif (world_hit(r, .001, MAX_FLOAT, rec)) {\n\t\t\tr = scatter(rec);\n\t\t\tatten *= rec.mat;\n\n\t\t}\n\t\telse {\n\t\t\tcol = atten * mix(vec3(1.5), vec3(.5, .7, 1), r.direction.y * .5 + .5);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tg_seed = float(base_hash(floatBitsToUint(gl_FragCoord.xy))) / float(0xffffffffU) + iTime;\n\tfloat aspect = iResolution.x / iResolution.y;\n\n    // cam position\n\tvec3 pos1 = vec3(-10, 5.4, 35);\n\tvec3 pos2 = vec3(-3, 1.5, 23);\n\tvec3 pos3 = vec3(3, 5.4, 30);\n\n\tvec3 ro = mix(\n\t\tmix(pos1, pos2, smoothstep(0., 15., iTime)),\n\t\tpos3, smoothstep(16., 31., iTime));\n\n\t//vec3 ro = vec3(25*sin(sin(iTime*.3)), 1.4 + sin(iTime), 25.*cos(sin(iTime*.5)));\n\n\n\tvec3 ta = vec3(-1.5, 0, 0);\n\n\tCamera cam = get_camera(ro, ta, vec3(0, 1, 0), 20., aspect, .5, length(ta - ro));\n\n\tvec3 col = vec3(0);\n\tfor (int s = 0; s < MAXSAMPLE; s++) {\n\t\tvec2 uv = (gl_FragCoord.xy.xy + hash2(g_seed)) / iResolution.xy;\n\t\tRay r = get_ray(cam, uv);\n\t\tcol += color(r);\n\n\t}\n\tcol /= float(MAXSAMPLE);\n\n    // gamma correct\n\tcol = clamp(col, 0., 1.);\n\tcol = pow(col, vec3(.4545));\n\n    // fading in & out\n\tcol = mix(\n\t\tmix(vec3(0), col, smoothstep(0., 1., iTime)),\n\t\tvec3(0),\n\t\tsmoothstep(ts4, ts4 + 2.5, iTime));\n\n\tfragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float MAX_FLOAT = 1e5;\nconst float PI = acos(-1.);\nconst float TAU = PI * 2.;\n\n// Made in Blender exported to .obj\n// There is 11 triangles\n// The two main shape are made from the same 9 first triangles\n\nvec3 vertices[29] = vec3[29](\n    // Swan & cat\n    vec3(-0.600000, -1.200000, -0.780600),\n\tvec3(-0.600000, 0.000000, -0.780600),\n\tvec3(0.500000, 0.000000, -0.780600),\n\tvec3(0.500000, 1.200000, -0.780600),\n\tvec3(-0.000054, -0.769646, -0.780600),\n\tvec3(-0.769148, -0.000552, -0.780600),\n\tvec3(0.769040, -0.000552, -0.780600),\n\tvec3(-0.000054, 0.768542, -0.780600),\n\tvec3(0.330067, -1.068670, -0.780600),\n\tvec3(-0.669933, 0.031330, -0.780600),\n\tvec3(0.330067, 1.031330, -0.780600),\n\tvec3(-0.503650, 1.519819, -0.780600),\n\tvec3(1.014108, 0.002062, -0.780600),\n\tvec3(-0.503650, -1.515697, -0.780600),\n\tvec3(-1.426991, -0.714951, -0.780600),\n\tvec3(0.719443, -0.714950, -0.780600),\n\tvec3(0.719442, 1.431484, -0.780600),\n\tvec3(0.494036, 0.004837, -0.780600),\n\tvec3(-0.246427, -0.735627, -0.780600),\n\tvec3(-0.250243, 0.741485, -0.780600),\n\tvec3(-0.497295, 0.000317, -0.780600),\n\tvec3(0.243168, 0.740781, -0.780600),\n\tvec3(0.246985, -0.736331, -0.780600),\n\n    // Background\n\tvec3(19.259647, -3.825654, -4.132116),\n\tvec3(0.863690, -3.825655, -4.132116),\n\tvec3(10.061668, 3.296956, -4.132116),\n\tvec3(6.265424, -3.825655, -3.809915),\n\tvec3(-21.581425, -3.825659, -3.809916),\n\tvec3(-7.658000, 6.956183, -3.809916));\n\nivec3 faces[11] = ivec3[11](\n    // Cat & Swan\n\tivec3(1, 2, 3),\n\tivec3(5, 6, 7),\n\tivec3(1, 0, 2),\n\tivec3(5, 4, 6),\n\tivec3(8, 10, 9),\n\tivec3(11, 13, 12),\n\tivec3(16, 14, 15),\n\tivec3(19, 18, 17),\n\tivec3(22, 21, 20),\n\n    // Background\n\tivec3(24, 23, 25),\n\tivec3(27, 26, 28));\n\nvec4 catpositions[9] = vec4[9](\n\tvec4(1.67, -1., 0., 0.), // piece 7a\n\tvec4(-.45, 2.2, 0., 0.), // piece 3a\n\tvec4(1.67, -1., 0., 0.), // piece 7b\n\tvec4(-.45, 2.2, 0., 0.), // piece 3b\n\tvec4(-0.78, 0.4, 0., 0.), // piece 4\n\tvec4(0.05, -0.08, 0., 0.), // piece 5\n\tvec4(0.35, -1.5, 0., 0.), // piece 6\n\tvec4(-.97, 2.92, 0., 0.), // piece 1\n\tvec4(0.07, 2.92, 0., 0.)); // piece 2\n\nvec4 swanpositions[9] = vec4[9](\n\tvec4(-0.5, .6 + 1.85, 0., 3.*PI / 4.), // piece 7a\n\tvec4(0., 0.5, 0., 0.), // piece 3a\n\tvec4(-0.42, -1. + 1.85, 0., 3.*PI / 4.), // piece 7b\n\tvec4(0., 0.5, 0., 0.), // piece 3b\n\tvec4(0.09, -.95, 0., PI), // piece 4\n\tvec4(-1.82, -0.45, 0., PI / 2.), // piece 5\n\tvec4(-0.95, -1.3, 0., 0.), // piece 6\n\tvec4(.5, -0.26, 0., PI), // piece 1\n\tvec4(0.28, 2.16, 0., -PI / 4.)); // piece 2","name":"Common","description":"","type":"common"}]}