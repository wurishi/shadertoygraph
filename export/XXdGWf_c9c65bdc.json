{"ver":"0.1","info":{"id":"XXdGWf","date":"1717611323","viewed":74,"name":"raytracing with bad shadows","username":"26apastor","description":"I'm testing a new soft shadows algorithm and it doesn't work.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","shadows","bad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EPSILON = 10e-5;\nconst float FARAWAY = 10e30;\n\n#define Z_AXIS vec3(0.0, 0.0, 1.0)\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\n// uses function instead of constructor\nCamera camera(vec3 Obs, vec3 LookAt, float aperature, float width, float height) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(Z_AXIS, C.View));\n    C.Up = cross(C.View, C.Horiz);\n    C.H = height;\n    C.W = width;\n    C.z = C.H/2.0 / tan(aperature * 0.00872664625);\n    return C;\n}\n\nstruct Material {\n    vec3 diffuseColor;\n    vec3 emissiveColor;\n    vec3 reflectiveColor;\n    float checkerboardSize;\n    vec3 specular;\n    float specularFactor;\n    vec3 transmission;\n    float refractionIndex;\n};\n\nstruct Sphere {\n    vec3 Center;\n    float R;\n};\n\nstruct Obj {\n    Sphere sphere;\n    Material material;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n// uses function instead of constructor\nRay ray(Camera C, float x, float y) {\n    Ray R;\n    R.Origin = C.Obs;\n    R.Dir = C.View * C.z + C.Horiz * (x - C.W/2.0) + C.Up * (y - C.H/2.0);\n    return R;\n}\n\nvec3 zero3 = vec3(0.0);\n\nMaterial diffuse(vec3 color) {\n    return Material(color, zero3, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\nMaterial light(vec3 color) {\n    return Material(zero3, color, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\nMaterial mirror(vec3 color, vec3 reflectiveColor) {\n    return Material(color, zero3, reflectiveColor, 0.0, vec3(1.0), 30.0, zero3, 0.0);\n}\n\nMaterial shiny(vec3 color, vec3 specularColor) {\n    return Material(color, zero3, zero3, 0.0, specularColor, 30.0, zero3, 0.0);\n}\n\nMaterial checkerboard(vec3 color, float size) {\n    return Material(color, zero3, zero3, size, zero3, 0.0, zero3, 0.0);\n}\nMaterial transparent(vec3 color, vec3 transparent) {\n    return Material(color, zero3, zero3, 0.0, vec3(1.0), 30.0, transparent, 0.9);\n}\n\n#define scene_length 4+15\nObj scene[scene_length];\n\n// uses iframe instead of parameter frame\nvoid initializeScene() {\n    \n    scene[0] = Obj(\n        Sphere(vec3(0.0, 0.0, 0.0), 0.5),\n        transparent(vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8))\n    );\n    \n    scene[1] = Obj(\n        Sphere(vec3(0.0, 0.0, 0.0), 1.0/6.0),\n        mirror(vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8))\n    );\n    \n    scene[2] = Obj(\n        Sphere(vec3(0.0, 0.0, -10000.0), 9999.5),\n        checkerboard(vec3(1.0, 0.2, 0.5), 1.0)\n    );\n    \n    {\n        float s = sin(float(iFrame)/150.0);\n        scene[3] = Obj(\n            Sphere(vec3(5.0*s, 0.0, 3.0), 2.0),\n            light(vec3(1.0, 1.0, 1.0))\n        );\n    }\n    \n    for (int i = 4; i < scene_length; i++) {\n        float beta = float(iFrame)/30.0 + float(i) * 6.28318530718 / float(scene_length - 4);\n        float s = sin(beta);\n        float c = cos(beta);\n        \n        if (((i >> 2) & 1) == 0) {\n            scene[i] = Obj(\n                Sphere(vec3(0.7*s, 0.7*c, 0.0), 0.1),\n                mirror(vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9))\n            );\n        } else {\n            scene[i] = Obj(\n                Sphere(vec3(0.7*s, 0.7*c, 0.0), 0.1),\n                transparent(vec3(0.2, 0.2, 0.2), vec3(0.7, 0.7, 0.7))\n            );\n        }\n    }\n}\n\n// out instead of array reference value\nbool intersectSphere(Ray R, Sphere S, out float t) {\n    vec3 CO = R.Origin - S.Center;\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0 * dot(R.Dir, CO);\n    float c = dot(CO, CO) - S.R * S.R;\n    float delta = b * b - 4.0 * a * c;\n    if(delta < 0.0)\n        return false;\n    t = (-b-sqrt(delta)) / (2.0 * a);\n    return true;\n}\n\n// doesnt use ! or hasZeroDimensions()\nbool isLight(Material M) {\n    return M.emissiveColor != vec3(0.0);\n}\n\n// no float result\nvec3 shadow(Ray R, Sphere L) {\n    vec3 result = vec3(1.0);\n    for (int i = 0; i < scene_length; i++) {\n        float time;\n        if (\n            !isLight(scene[i].material)\n            && intersectSphere(R, scene[i].sphere, time)\n            && time > EPSILON\n        ) {\n            if (scene[i].material.transmission == vec3(0.0)) {\n                Sphere S = scene[i].sphere;\n                vec3 rayPos = R.Origin;\n                \n                vec3 intersection_center = (S.Center + rayPos) * 0.5;\n                float d = distance(intersection_center, S.Center);\n                float intersection_radius = distance(rayPos, S.Center) * 0.5;\n                float h = 0.5 + (S.R * S.R - intersection_radius * intersection_radius)/ (2.0 * d * d);\n                vec3 inside_center = S.Center + h * (intersection_center - S.Center);\n                float inside_radius = sqrt(S.R * S.R - h * h * d * d);\n                vec3 inside_normal = (intersection_center - S.Center) / d;\n                vec3 inside_tangent = cross(Z_AXIS, inside_normal);\n                vec3 inside_bitangent = cross(inside_tangent, inside_normal);\n                vec3 p_2 = L.Center - rayPos;\n                vec3 plane_normal = normalize(inside_center - rayPos);\n                vec3 projected_p_2 = p_2 - dot(p_2, plane_normal) * plane_normal;\n                float divisor1 = plane_normal.z * projected_p_2.z / (inside_tangent.x * plane_normal.y - plane_normal.x * inside_tangent.y);\n                vec3 intermediary_planar_axis = vec3(inside_tangent.y * divisor1, inside_tangent.x * -divisor1, projected_p_2.z);\n                vec2 projected_direction = vec2(distance(projected_p_2, intermediary_planar_axis), length(intermediary_planar_axis));\n                vec3 nearest_direction = inside_center - inside_radius * (inside_tangent * projected_direction.x + inside_bitangent * projected_direction.y) / length(projected_direction);\n                vec3 R_Dir = nearest_direction - rayPos;\n                vec3 OC = -p_2;\n                float quadratic_a = dot(R_Dir, R_Dir);\n                float quadratic_b = 2.0 * dot(R_Dir, OC);\n                float quadratic_c = dot(OC, OC) - L.R * L.R;\n                float discriminant = quadratic_b * quadratic_b - 4.0 * quadratic_a * quadratic_c;\n                float time = (-quadratic_b - sqrt(discriminant)) / (2.0 * quadratic_a);\n                vec3 rayPos2 = rayPos + time * R_Dir;\n                vec3 normalPoint = (rayPos2 - L.Center) / L.R;\n                vec3 sphereDirectionNormal = -normalize(R_Dir);\n                float brightness = dot(normalPoint, sphereDirectionNormal);\n                return result * vec3(brightness);\n            } else {\n                vec3 obstructionDifference = R.Dir * time;\n                vec3 normalPoint = normalize(R.Origin + obstructionDifference - scene[i].sphere.Center);\n                float resultingIntensity = dot(obstructionDifference, normalPoint) / length(obstructionDifference);\n                result *= resultingIntensity + 1.0;\n            }\n        }\n    }\n    return result;\n}\n\nvec3 lighting(vec3 rayPos, vec3 normalPoint, Material material, Ray R) {\n    if (isLight(material)) return material.emissiveColor;\n    \n    vec3 result = vec3(0.0);\n    vec3 shadowColor;\n    \n    for (int i = 0 ; i < scene_length; i++) {\n        if(isLight(scene[i].material)) {\n            Ray secondaryRay = Ray(rayPos, scene[i].sphere.Center); // towards the light\n            shadowColor = shadow(secondaryRay, scene[i].sphere);\n            if(\n                shadowColor.x > EPSILON\n                && shadowColor.y > EPSILON\n                && shadowColor.z > EPSILON\n            ) {\n                vec3 emissiveDifference = scene[i].sphere.Center - rayPos;\n                \n                float resultingIntensity = max(0.0, dot(emissiveDifference, normalPoint) / length(emissiveDifference));\n                vec3 diffuseColor = material.diffuseColor;\n                if(material.checkerboardSize != 0.0 && sin(rayPos.x/material.checkerboardSize) * sin(rayPos.y / material.checkerboardSize) > 0.0) {\n                    diffuseColor = 1.0 - diffuseColor;\n                }\n                result += diffuseColor * scene[i].material.emissiveColor * resultingIntensity;\n               \n                // doesn't use ! or hasZeroDimensions()\n                if(material.specular != vec3(0.0)) {\n                    vec3 Er = normalPoint * 2.0 * dot(normalPoint, emissiveDifference) - emissiveDifference;\n                    vec3 View = R.Origin - rayPos;\n                    float spec = max(0.0, dot(Er, View));\n                    spec /= sqrt(dot(Er, Er) * dot(View, View));\n                    spec = pow(spec, material.specularFactor);\n                    result += material.specular * scene[i].material.emissiveColor * spec;\n                }\n            }\n        }\n    }\n    return result * shadowColor;\n}\n\nRay reflectRay(Ray inRay, vec3 rayPos, vec3 normalPoint) {\n    return Ray(\n        rayPos,\n        normalPoint * -2.0 * dot(normalPoint, inRay.Dir) + inRay.Dir\n    );\n}\n\nRay refractRay(Ray inRay, vec3 rayPos, vec3 normalPoint, float n) {\n    return Ray(\n        rayPos,\n        // uses built-in refract function\n        refract(normalize(inRay.Dir), normalPoint, n)\n    );\n}\n\nbool nearestIntersection(Ray R, out vec3 rayPos, out vec3 normalPoint, out Material material) {\n    float time = FARAWAY;\n    \n    for (int i = 0; i < scene_length; i++) {\n        float current_time;\n        if(\n            intersectSphere(R, scene[i].sphere, current_time)\n            && current_time < time\n            && current_time > EPSILON\n        ) {\n            time = current_time;\n            rayPos = R.Origin + R.Dir * time;\n            normalPoint = normalize(rayPos - scene[i].sphere.Center);\n            material = scene[i].material;\n            \n        } \n    }\n    return (time != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeScene();\n\n    //float();\n    float beta = float(iFrame)/150.0;\n    float s = sin(beta);\n    float c = cos(beta);\n    \n    Camera C = camera(\n        vec3(2.0*c, 2.0*s, 0.5),\n        vec3(0., 0., 0.0),\n        50.0,\n        iResolution.x,\n        iResolution.y\n    );\n    \n    Ray R = ray(C, fragCoord.x, fragCoord.y);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec3 rayPos;\n    vec3 normalPoint;\n    Material material;\n    \n    vec3 cumulativeReflection = vec3(1.0);\n    for(int i = 0; i < 5; i++) {\n        if (nearestIntersection(R, rayPos, normalPoint, material)) {\n            fragColor.rgb += cumulativeReflection * lighting(rayPos, normalPoint, material, R);\n            if (material.reflectiveColor != vec3(0.0)) {\n                cumulativeReflection *= material.reflectiveColor;\n                R = reflectRay(R, rayPos, normalPoint);\n            } else if (material.transmission != vec3(0.0)) {\n                cumulativeReflection *= material.transmission;\n                R = refractRay(R, rayPos, normalPoint, material.refractionIndex);\n            } else {\n                break;\n            }\n        } else {\n            fragColor.rgb += cumulativeReflection * vec3(0.5, 0.5, 1.0);\n            break;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}