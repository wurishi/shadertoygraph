{"ver":"0.1","info":{"id":"ldBBDw","date":"1500634386","viewed":835,"name":"anal distance stretch","username":"ollj","description":"mouse sets rounded \"rectangle\" size\n\na simpler approach to analytic intersection to capsule\nhttps://www.shadertoy.com/view/Xt3SzX\n\nshould just apply something like analstretching(a) to rearrange rays,overlap them, and then trace a simple sphere with them.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["sphere","distance","box","analytic","rounded","linesegment","stretch","bisymmetry","mstretch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\nif(iResolution.x>iResolution.y)u.x*=iResolution.x/iResolution.y;\nelse u.y*=iResolution.y/iResolution.x;return u*9.;}\n//above is same transformation for fragment and mouse positions.\n\n//circle radius (added to box outer border)\n//#define radius 1.\n//#define radius (sin(iTime)*.5+.5)\n#define radius (sin(iTime)*.5+1.)\n\n//remove \"#define centralize\" to not move the box center to vec2(0)\n#define centralize\n\n//uncomment to ignore mouse.y, setting mouse.y=0, skipping analstretching(y)\n//#define LineSegmentOnly\n\n//analstretching(a) is a linear funtion that looks like:\n/*\n            /\n           /\n          /\n    _____/ \n   /0    m.a\n  / \n /\n/\nwith 2 corner-discontinuities at v.a=0 and v.a=m.a\nx axis is v.a\n\n.a is the domain, using a #define to reuse the same function over multiple domains.\n\nusing this this function as a rwapper around \"distance to circle\",\nmodifying the inputs of \"distance to circle\", \nSTRETCHES the circle into a \"line segment\" or \"box\"\n\nwithout the usual dot()/dot() approach for line segments\nthat sums up multiple domains to project and stretch.\n*/\n#define analstretching(a) v.a=mix(v.a-m.a,mix(0.,v.a,step(v.a,0.)),step(v.a,m.a));\n//the special case of analstrecthing(y) is equivalent to:\n// v.y=mix(v.y-m.y,mix(0.,v.y,step(v.y,0.)),step(v.y,m.y));\n// above can likely be simplified?\n// above is a branchless oneliner of below 2 branches:\n// if(v.y>m.y)v.y-=m.y;else if(v.y>0.)v.y=0.;\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=frame(U);         //view-frame modify vertex position\n vec2 m=frame(iMouse.xy); //view-frame modify mouse  position\n m=abs(m);//below code only makes sense for m>=0;\n #ifdef LineSegmentOnly\n  m.y=0.;\n #endif\n #ifdef centralize\n  m+=m*.5;u+=m*.5;//optional frame shift to center the box on the frame\n #endif\n vec2 v=u;\n analstretching(x);\n #ifndef LineSegmentOnly\n  analstretching(y); \n #endif\n    \n  \n float f=length(v)-radius;//distance to circle\n f=smoothstep(-.1,.1,f);//smoothstep border\n #ifdef centralize\n  u-=m*.5;//inverse of above optional frame shifting\n #endif\n u=fract(u)*.1;//grid\n O=vec4(u,f,1);}\n\n/*\nto use this for analytic raytracing, as in \nhttps://www.shadertoy.com/view/Xt3SzX\n, you first need to project your ray to a 2d plane (similar to implicit torus).\nthen apply some dot() to the 2d rays, to see where they hit the line segment== x=0 axis.\nand depending on where they hit, you modify the rays?\nthen the rays of sme parameter range overlap, and then you trace a circle with these overlapping rays?\ni am not as good with dot()/dot() visualization to solve that part.\n\nbut the concept of modifying rays \nand then tracing a simpler implicit thing should be clear.\nas this works fine for tracing (but stretches the gradients for marching, where it fails)\n\n----\n\nanalstretching()\nseems to be a core function for square-segments for \"bisymemtry\", \n... segmenting complex shapes into simpler shapes, \n... unifying segments of the same exponent first, to optimize root-solving\nWhile not being essential to \"bisymmetry\", \n... it keeps being a useful subroutine for \"bisymmetry\"\n\n\n*/\n\n","name":"Image","description":"","type":"image"}]}