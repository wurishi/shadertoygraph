{"ver":"0.1","info":{"id":"XXBcRR","date":"1726825858","viewed":44,"name":"atmosphere render","username":"ruochen","description":"atmosphere render，一个简单的基于单次散射模型的大气渲染","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float speedScale = 1.0 / 4.0;\nfloat planetRadius = 6371.0e3;\nfloat atmosphereRadius = 6471.0e3;\nvec3 rayleighScatteringCoef = vec3(5.5e-6, 13.0e-6, 22.4e-6);\nfloat mieScatteringCoef = 21.0e-6;\nfloat rayleighScaleHeight = 8500.0;\nfloat mieScaleHeight = 1200.0;\nfloat mieScatteringDir = 0.758;\nfloat sunIntensity = 22.0;\n\n// show mode 0: move camera; 1: move sun position\n#define show_mode 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 fragPos = vec3(uv, 0.0);\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = fragPos - ro;\n    \n    // camera is a little bit higher than ground\n    vec3 camPos = vec3(0.0, planetRadius+100.0, 0.0);\n    vec3 sunPos = vec3(0.0, 1, 1);\n#if show_mode==0\n    float heightScale = 1e5;\n    camPos.y += cos(iTime) * heightScale + heightScale;\n#elif show_mode==1\n    sunPos = vec3(0.0, abs(cos(iTime*speedScale))*2.0-0.5, 1.0);\n#else\n\n#endif\n    \n    vec3 color = atmosphere(\n    rd,\n    camPos,\n    sunPos,\n    sunIntensity,\n    planetRadius,\n    atmosphereRadius,\n    rayleighScatteringCoef,\n    mieScatteringCoef,\n    rayleighScaleHeight,\n    mieScaleHeight,\n    mieScatteringDir\n    );\n    // Output to screen\n    //fragColor = vec4(color,1.0);\n    \n    float exposure = 1.0;\n    vec3 mapped = vec3(1.0) - exp(-color * exposure);\n    // gamma correction\n    const float gamma = 2.2;\n    mapped = pow(mapped, vec3(1.0 / gamma));\n    fragColor = vec4(mapped, 1.0);\n    \n    if(uv.y > -0.01 && uv.y < 0.01)\n    {\n        // fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float PI = 3.14159265359;\nint iSteps = 32; \nint jSteps = 8;\n\nvec2 ray_sphere_intersection(vec3 ray_origin, vec3 ray_direction, float sphere_radius)\n{\n    // ray-sphere intersection that assumes\n    // No intersection when result.x > result.y\n    float a = dot(ray_direction, ray_direction);\n    float b = 2.0 * dot(ray_direction, ray_origin);\n    float c = dot(ray_origin, ray_origin) - (sphere_radius * sphere_radius);\n    float d = (b*b) - 4.0*a*c;\n\n\n    if (d < 0.0) return vec2(1e10,-1e10);       \n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n// get atmosphere density, according to sea level\n// 获取大气密度\n// 传入位置离海平面的高度，以及散射的相关基准高度\n// 大气中任意一点的散射系数的计算，简化拆解为散射在海平面的散射系数，乘以基于海平面高度的该散射的大气密度计算公式\nfloat get_atmos_density(float height_to_sea_level, float scale_height)\n{\n    return exp(-height_to_sea_level / scale_height);\n}\n\n// single scatter model\n// 单次散射模型（太阳光进入大气，只经过一次散射改变方向）\nvec3 atmosphere(vec3 ray_dir, vec3 ray_origin,\n                vec3 pSun, float iSun,\n                float planet_radius, float rAtmos,\n                vec3 kRlh, float kMie, float scale_height_rlh, float scale_height_mie, float g)\n{\n    // Normalize the sun and view directions.\n    pSun = normalize(pSun);\n    ray_dir = normalize(ray_dir);\n\n    // 视线和大气层大小的尺寸的射线检测\n    // x为大气入射点的距离、y为大气出射点的距离（x==y代表光线和大气球体相切，x>y代表光线不经过大气）\n    vec2 atmos_hit = ray_sphere_intersection(ray_origin, ray_dir, rAtmos);\n    // 未击中，返回0\n    if (atmos_hit.x > atmos_hit.y) return vec3(0,0,0);\n\n    // 视线和星球做射线检测，取得近处的检测结果（远处的那个光被星球本体遮挡）\n    vec2 planet_hit = ray_sphere_intersection(ray_origin, ray_dir, planet_radius);\n    float light_distance = atmos_hit.y;\n        \n    // hit the planet\n    if(planet_hit.x < planet_hit.y && planet_hit.x > 0.01)\n    {\n        light_distance = planet_hit.x;\n    }\n        \n    // light sample length\n    float ds = light_distance / float(iSteps);\n\n    // Initialize the primary ray time.\n    float iStepTime = 0.0;\n\n    // Initialize accumulators for Rayleigh and Mie scattering.\n    vec3 total_scatter_rlh = vec3(0,0,0);\n    vec3 total_scatter_mie = vec3(0,0,0);\n\n    // Initialize optical depth accumulators for the primary ray.\n    float total_od_rlh = 0.0;\n    float total_od_mie = 0.0;\n\n    // Calculate the Rayleigh and Mie phases.\n    float mu = dot(ray_dir, pSun);\n    float mumu = mu * mu;\n    float gg = g * g;\n    \n    // Rayleigh phase function\n    // 瑞利散射相函数\n    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\n    // Mie phase function\n    // 米氏散射相函数\n    float pMie = (1.0 - gg) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (4.0*PI));\n\n    // sample along the ray\n    // 光线采样\n    for (int i = 0; i < iSteps; i++) {\n\n        // Calculate the primary ray sample position.\n        // 以视角位置和方向，\n        vec3 iPos = ray_origin + ray_dir * (iStepTime + ds * 0.5);\n\n        // 观察点和星球表面距离（我们这里先默认星球的中心为原点，所以直接用位置的长度就行）\n        // Calculate the height of the sample.\n\n\n        // Calculate the step size of the secondary ray.\n        // 在当前点向太阳的位置做射线检测，以大气的半径为球体。.y是代表大气的出射点，j_steps代表采样数\n        float jStepSize = ray_sphere_intersection(iPos, pSun, rAtmos).y / float(jSteps);\n        \n        // Initialize the secondary ray time.\n        float jStepTime = 0.0;\n\n        // Initialize optical depth accumulators for the secondary ray.\n        float jOdRlh = 0.0;\n        float jOdMie = 0.0;\n\n        // 在当前点到大气入射的举例上，采样计算\n        // Sample the secondary ray.\n        for (int j = 0; j < jSteps; j++) {\n\n            // Calculate the secondary ray sample position.\n            vec3 jPos = iPos + pSun * (jStepTime + jStepSize * 0.5);\n\n            // Calculate the height of the sample.\n            float jHeight = length(jPos) - planet_radius;\n\n            // Accumulate the optical depth.\n            jOdRlh += get_atmos_density(jHeight, scale_height_rlh) * jStepSize;\n            jOdMie += get_atmos_density(jHeight, scale_height_mie) * jStepSize;\n\n            // Increment the secondary ray time.\n            jStepTime += jStepSize;\n        }\n        \n        float surface_height = length(iPos) - planet_radius;\n        // 计算这一步的散射的光学深度结果\n        // Calculate the optical depth of the Rayleigh and Mie scattering for this step.\n        float od_step_rlh = get_atmos_density(surface_height, scale_height_rlh) * ds;\n        float od_step_mie = get_atmos_density(surface_height, scale_height_mie) * ds;\n\n        // Accumulate optical depth.\n        total_od_rlh += od_step_rlh;\n        total_od_mie += od_step_mie;\n        // attenuation calculation\n        // 计算衰减系数，光在经过一定距离后衰减剩下来的比例。\n        vec3 attn = exp(-(kMie * (total_od_mie + jOdMie) + kRlh * (total_od_rlh + jOdRlh)));\n\n        // Accumulate scattering.\n        total_scatter_rlh += od_step_rlh * attn;\n        total_scatter_mie += od_step_mie * attn;\n\n        // Increment the primary ray time.\n        iStepTime += ds;\n    }\n\n    // Calculate and return the final color.\n    return iSun * (pRlh * kRlh * total_scatter_rlh + pMie * kMie * total_scatter_mie);\n}","name":"Common","description":"","type":"common"}]}