{"ver":"0.1","info":{"id":"3lB3zy","date":"1559928332","viewed":155,"name":"Vortex Impulse","username":"antonOTI","description":"Trying some idea with the keyboard input, Press SPACE to WARP","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","keyboard","cookie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define REP(p, r) (mod(p + r*.5, r) - r *.5)\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nfloat map(vec3 p, out float slow)\n{\n    float bump = texture(iChannel0, p.xz * .01).x;\n    \n    p.z -= 5.;\n    p.xy *= 1. + sin(bump * .5 * PI) * .5;\n    \n    float sph = length(p - vec3(0.,0.,10.)) - 1.;\n    \n    \n    float cyl = length(p.xy) - 4.;\n    float plane = p.y + 1.;\n\n    p.z += iTime;\n    \n    p.xy *= rot(p.z*.2);\n    p = REP(p, .5);\n    \n    float lat = (length(p) - .2 - bump * .1) * step(cyl, 4.);\n    \n    \n    float dist = min(sph, plane);\n    \n\tdist = min(-cyl, dist);//max(dist, -cyl);\n    \n    dist = max(dist, -lat);\n    slow = 1. - bump * .6;\n    return dist;\n}\n\nvoid ray(inout vec3 cp, in vec3 rd, out float st, out float cd)\n{\n    st = 0.;\n    cd  = 0.;\n \tfloat slow;\n    for(; st < 1.; st += 1. / 128.)\n    {\n        cd = map(cp, slow);\n        if(cd < .01)\n        {\n            break;\n        }\n        \n        cp += rd * cd * slow;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 cp = ro;\n    \n    float st, cd;\n    \n    ray(cp, rd, st, cd);\n    \n    vec4 col = vec4(0.);\n    \n    if(st < 1.)\n    {\n        float len = distance(cp , ro);\n\n        col = vec4(exp(-len * .1)) * exp(len * .01);\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float StoreSize = 2.;\nconst float SpeedToFull = .15;\nconst float FallOf = .85;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = vec4(0.);\n\n    if(uv.y < StoreSize / iResolution.y)\n    {\n        float f = texture(iChannel0, uv).x;\n        float press = texelFetch(iChannel3, ivec2(32,0.), 0).x;\n        \n        if(press > 0.)\n        {\n        \tf = clamp(f + SpeedToFull, 0. ,1.);\n        }\n        else\n        {\n            f = f * FallOf;\n        }\n        \n        col = vec4(f);\n        \n    }\n    else\n    {\n        uv.y -= StoreSize / iResolution.y;\n        col =  texture(iChannel0, uv);\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}