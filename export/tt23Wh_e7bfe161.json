{"ver":"0.1","info":{"id":"tt23Wh","date":"1559398553","viewed":412,"name":"[twitch] Grid & box","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nIt uses analytical raytracing to find intersection with 2 boxes and a plane.\nBy bouncing rays you can get rough global illumination and depth of field by jittering the starting ray.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","gi","dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/GridBox.glsl\n\nThe shader uses analytical raytracing to find intersection with 2 boxes and a plane.\nBy bouncing rays you can get rough global illumination and depth of field by jittering the starting ray.\n*/\n\nfloat time = 0.0;\nfloat pi = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*685.655)*427.511);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 8.0));\n}\n\n\nfloat val = 0.0;\n//float val2 = max(abs(fract(time*0.1-0.5)-0.5)*4 - 1.0,0.0);\nfloat val2 = 0.0;\n\nfloat plane(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 planenorm, float dist) {\n  \n  float dn = dot(r,planenorm);\n  float dplane = (dist-dot(s,planenorm))/dn;\n  if(dplane<d && dplane>0.0) {\n    vec3 p = s + dplane * r;\n    vec3 hole = vec3(4);\n    p = abs(fract(p/hole+0.5)-.5);\n    if(max(p.x,max(p.y,p.z))>0.44) {\n      d = dplane;\n      n = planenorm * sign(dn);\n      emi = vec3(0.2,0.9,0.5) * 5.0 * val2;\n    }\n  }\n  \n  return d;\n}\n\nvoid backbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {\n  \n  vec3 invd = 1.0/r;\n  \n  vec3 t0 = ((pos-size) - s) * invd;\n  vec3 t1 = ((pos+size) - s) * invd;\n  vec3 mi = min(t0, t1);\n  vec3 ma = max(t0, t1);\n  \n  float front = min(min(ma.x,ma.y),ma.z);\n  float back = max(max(mi.x,mi.y),mi.z);\n  \n  if(front<d && front > 0.0 && front>back) {\n    d = front;\n    n = (1.0-clamp((ma-front)*1000.0,0.0,1.0)) * sign(t1-t0);\n    \n    vec3 p = s + d * r;\n    //vec2 diff=smoothstep(0.9,1.0, sin(p.zx + 10 * time * vec2(0.7,1.0)));\n    \n    //emi = vec3(dot(diff,vec2(1.0))) * step(p.y, -4.9) * 4;\n    \n    emi = vec3(0.4,0.5,0.9) * step(p.y, -4.9) * 4.0 * val * (1.0-val2);\n    emi += vec3(0.8,0.4,0.3) * step(p.z, -9.9) * 4.0 * (1.0-val) * (1.0-val2);\n  }\n}\n\nvoid frontbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {\n  \n  vec3 invd = 1.0/r;\n  \n  vec3 t0 = ((pos-size) - s) * invd;\n  vec3 t1 = ((pos+size) - s) * invd;\n  vec3 mi = min(t0, t1);\n  vec3 ma = max(t0, t1);\n  \n  float front = min(min(ma.x,ma.y),ma.z);\n  float back = max(max(mi.x,mi.y),mi.z);\n  \n  if(back<d && back > 0.0 && back<front) {\n    d = back;\n    emi = vec3(0);\n    n = (1.0-clamp(-(mi-back)*10000.0,0.0,1.0)) * sign(t1-t0);\n  }\n}\n\nvoid raytrace(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi) {\n  \n  backbox(s,d,r,n,emi, vec3(0), vec3(10,5,10));\n  \n  frontbox(s,d,r,n,emi, vec3(7,3,0), vec3(5,0.5,4));\n  \n  plane(s,d,r,n,emi, normalize(vec3(curve(time+3.2,0.8),1.0,curve(time+7.8,0.8))), 2.0 + (curve(time,0.8)-.5)*10.0);\n}\n\nvec3 hemispherenormal(vec2 rng) {\n  \n  float radius = sqrt(rng.x);\n  float angle = 2.0 * pi * rng.y;\n  \n  return vec3(radius * cos(angle), sqrt(1.0 - rng.x), radius * sin(angle));\n}\n\nvec3 hemi(float rn, int i) {\n  return hemispherenormal(fract(rn * vec2(7,17) + vec2(float(i)/7.0,floor(float(i/7))/7.0)));\n}\n\nvec2 rnd(vec2 uv) {\n  return fract(sin(uv * vec2(754.355) + uv.yx * vec2(845.312)) * vec2(387.655));  \n}\n\nfloat rnd1(vec2 uv) {\n  return fract(dot(sin(uv * vec2(754.355) + uv.yx * vec2(845.312)),vec2(387.655)));  \n}\n\nvoid cam(inout vec3 p) {\n  float t=time*0.3 + curve(time +32.0, 2.8)*4.0;\n  p.yz *= rot(sin(t*.7)*.3 + 0.4);\n  p.xz *= rot(t);\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  time = iTime * 0.2;\n  val = max(abs(fract(time*0.1)-0.5)*4.0 - 1.0,0.0);\n  val2 = max(curve(time, 1.3)*3.0-2.0,0.0);\n\n\n  vec3 s=vec3(0,0,-12);\n  vec3 t=vec3(0,0,0);\n  \n  cam(s);\n  \n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  //vec3 r=normalize(vec3(-uv, 1));\n  float fov = 1.0 + curve(time+11.0, 0.7)*0.4;\n  vec3 r = normalize(uv.x * cx + uv.y * cy + fov * cz);\n  \n  \n  vec3 col = vec3(0);\n  \n  float focus = 12.0 + curve(time, 0.7)*4.0;\n  \n  float ini = rnd1(uv);\n    \n  float dither=fract(time);\n    \n  const int steps=36;\n  for(int j=0; j<steps; ++j) {\n    float prod = 1.0;\n    vec2 randdof = vec2(j%6,j/6)+rnd(uv - vec2(3.7));\n    //randdof = vec2(cos(randdof.x), sin(randdof.x))*randdof.y;\n    vec3 dof = randdof.x * cx + randdof.y * cy;\n    dof *= 0.1;\n    vec3 vs = s + dof;\n    vec3 vr = normalize(r - dof / focus);\n        \n    for(int i=0; i<3; ++i) {\n      float d = 10000.0;\n      vec3 n = vec3(0,1,0);\n      vec3 emi = vec3(0);\n      raytrace(vs, d, vr, n, emi);\n      vs = vs + vr * d - n * 0.001;\n      \n      vec2 rand = rnd(uv + vec2(float(j)*2.1,float(i)*3.1) + dither);\n      vr = hemispherenormal(rand);\n      //vr = hemi(ini, j);\n      vr *= -sign(dot(vr,n));\n      \n      col += emi * prod;\n      prod *= 0.6;\n      \n    }\n  }\n  col /= float(steps);\n    \n  /*\n  if(d<9000.0) {\n    vec3 p = s + d * r;\n    col += fract(p/1.0 + 0.1);\n  }\n  */\n  \n  //col = n*0.5+0.5;\n  \n  \n  /*\n  float d = plane(s,r, normalize(vec3(0,1,0)), 10);\n  if(d>0.0) {\n    vec3 p=s + d * r;\n    \n  }\n  */\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}