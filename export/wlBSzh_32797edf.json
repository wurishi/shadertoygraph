{"ver":"0.1","info":{"id":"wlBSzh","date":"1565452143","viewed":306,"name":"Crazy Printer","username":"TambakoJaguar","description":"I think that this printer (or kind of Polaroid thing) got a print job from a hacker...\nIt was though to optimize and make it faster, but I think I succeeded.\nUse mouse to move around.\nYou can increase the total number of photos on line 68.","likes":16,"published":1,"flags":40,"usePreview":0,"tags":["sound","checker","funny","leds","patter","sheet","printer","photos","hacked"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getPhotoPos2(int photoNr)\n{  \n   #ifdef use_buffer\n   vec2 pos = vec2(mod(float(photoNr+1), iResolution.x)/(iResolution.x+1.), (float(photoNr)/(iResolution.x))/(iResolution.y));\n   return (texture(iChannel0, pos)).xyz;\n   #else\n   return getPhotoPos(photoNr, getPhotoTime(photoNr));\n   //return vec3(1.6*mod(float(photoNr), 5.) - 3., 1., 8. - 0.6*float(photoNr/5));                      \n   #endif\n}\n\nvec2 getPhotoAngle2(int photoNr)\n{  \n   #ifdef use_buffer\n   vec2 pos = vec2(mod(float(photoNr+1), iResolution.x)/(iResolution.x+1.), (50. + float(photoNr)/(iResolution.x))/(iResolution.y));\n   return (texture(iChannel0, pos)).xy;\n   #else\n   return getPhotoAngle(photoNr, getPhotoTime(photoNr));                   \n   #endif\n}\n\nvec3 rotatePhoto(vec3 pos, int photoNr)\n{\n   vec2 angle = getPhotoAngle2(photoNr);\n       \n   pos.yz = rotateVec(pos.yz, angle.x);\n   pos.xy = rotateVec(pos.xy, angle.y);    \n    \n   return pos;\n}\n\nfloat map_photo(vec3 pos, bool hasBump, int photoNr, bool noCurve)\n{\n    float b;\n    \n    pos-= getPhotoPos2(photoNr);\n    pos = rotatePhoto(pos, photoNr);\n      \n    if (!noCurve)\n    {\n       pos.z-= min(photoCurve.x*pow(abs(pos.x)/(0.5*photoSize.x), photoCurve.z), 0.1);\n       pos.z-= min(photoCurve.y*pow(abs(pos.y)/(0.5*photoSize.y), photoCurve.z), 0.1); \n        \n       pos.z-= photoCurve.x+photoCurve.y;\n    }\n    \n    #ifdef photo_bump\n    if (hasBump && pos.z<0.)\n       pos.z+= bump_height_photo*noise(pos*500.);\n    #endif\n    \n    vec3 d = abs(pos) - 0.5*photoSize;\n    return length(max(d,0.0));\n}\n\nvec2 map_printer(vec3 pos, bool hasBump)\n{\n    #ifdef printer_bump\n    if (hasBump)\n       pos+= bump_height_printer*noise(pos*500.);\n    #endif    \n    \n    pos.y-= 0.35;\n    pos.z-= 0.035;\n    float printer = sdRoundBox(pos, vec3(1., 0.7, 0.5), 0.033);\n    \n    pos.y-= 0.78;\n    printer = min(printer, sdBox(pos, vec3(0.75, 0.05, 0.08)));\n    \n    printer = max(printer, -sdBox(pos, vec3(0.7, 0.6, 0.05)));\n    \n    #ifdef show_leds\n    printer = max(printer, -sdBox(pos - vec3(-0.73, -0.84, -0.52), vec3(0.16, 0.06, 0.04)));\n    #endif\n    \n    return vec2(printer, PRINTER_OBJ);\n}\n\n#ifdef show_leds\nfloat map_rled(vec3 pos)\n{\n    return length(pos - vec3(-0.8, 0.3, -0.46))-0.035;\n}\n\nfloat map_gled(vec3 pos)\n{\n    return length(pos - vec3(-0.66, 0.3, -0.46))-0.035;\n}\n#endif\n\nvec2 map(vec3 pos, bool hasBump, bool allPhotos)\n{\n    vec2 res;\n    \n    vec2 floor = vec2(pos.y, float(FLOOR_OBJ));\n    res = floor;\n    \n    vec2 printer = map_printer(pos, hasBump);\n    res = opU(res, printer);\n    \n    if (allPhotos)\n       pos.y+= photoCurve.x + photoCurve.y;\n    \n    for(int pp=0; pp<nbPhotos; pp++)\n    {       \n       float phTime = getPhotoTime(pp+1); \n       if ((phTime>0. && phTime<throwPer*1.4) || allPhotos) \n       {\n          if (allPhotos)\n             pos.y-= 0.00001/float(nbPhotos);\n          vec2 photo = vec2(map_photo(pos, hasBump, pp + 1, allPhotos), PHOTO_OBJ + pp);\n          res = opU(res, photo);\n       }\n    }\n    \n    #ifdef show_leds\n    vec2 rled = vec2(map_rled(pos), RLED_OBJ);\n    vec2 gled = vec2(map_gled(pos), GLED_OBJ);\n    \n    res = opU(res, rled);\n    res = opU(res, gled);\n    #endif\n    \n    return res;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    vec3 pos;\n    vec2 res;\n    float dist;\n    float objnr = 0.;\n    \n  \tfor (int i = 0; i < 60; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tres = map(pos, false, false);\n        dist = res.x;\n        objnr = abs(res.y);\n        if (dist>maxdist)\n            break;\n        t+= dist*0.85 - float(i)*0.00008;\n  \t}\n    if (int(objnr)==FLOOR_OBJ)\n    {    \n       pos.y+= 0.004;\n       res = map(pos, false, true);\n       if (int(res.y)!=PRINTER_OBJ)\n          objnr = abs(res.y);\n    }\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, true, false).x;\n    }\n    return normalize(n);\n}\n\nvec3 getFloorColor(vec3 pos)\n{\n    vec3 colo = mod(floor(pos.x) + floor(pos.z), 2.)==0.?vec3(0.32, 0.3, 0.28):vec3(0.82, 0.8, 0.78);\n    pos.xz = pos.xz + 0.45*fbm(pos.xz*6.5);\n    \n    #ifdef floor_pattern\n    colo+= 0.03*sin(85.*fbm(pos.xz*3.2));\n    #endif\n    \n    return colo;\n}\n\nvec3 getPhotoColor(vec3 pos, int photoNr)\n{\n    vec3 colo;\n    \n    float phTime = getPhotoTime(photoNr);      \n    \n    pos-= getPhotoPos2(photoNr);\n    pos = rotatePhoto(pos, photoNr);    \n    \n    pos.z-= 15.*hash(float(photoNr)*581.5);\n    pos.xy = rotateVec(pos.xy, pi*hash(float(photoNr)*268.5));\n    pos.xy = 0.35 + 5.2*pos.xy*vec2(hash(float(photoNr)*724.8), hash(float(photoNr)*684.7));\n    \n    vec3 col1 = vec3(0.3 + 0.7*hash(float(photoNr)*514.8), 0.3 + 0.7*hash(float(photoNr)*927.5), 0.3 + 0.7*hash(float(photoNr)*238.2));\n    vec3 col2 = vec3(0.3 + 0.7*hash(float(photoNr)*138.1), 0.3 + 0.7*hash(float(photoNr)*843.7), 0.3 + 0.7*hash(float(photoNr)*196.3));\n    vec3 col3 = vec3(0.3 + 0.7*hash(float(photoNr)*459.3), 0.3 + 0.7*hash(float(photoNr)*554.2), 0.3 + 0.7*hash(float(photoNr)*749.4));\n    vec3 col4 = vec3(0.3 + 0.7*hash(float(photoNr)*276.5), 0.3 + 0.7*hash(float(photoNr)*743.5), 0.3 + 0.7*hash(float(photoNr)*312.8));\n    vec3 col5 = vec3(0.3 + 0.7*hash(float(photoNr)*472.6), 0.3 + 0.7*hash(float(photoNr)*385.4), 0.3 + 0.7*hash(float(photoNr)*924.7));\n    \n    //float n = noise(pos*7.5);\n    float n = noise2(pos.xy*2.5)+0.5;\n    if (n<0.25)\n       colo = mix(col1, col2, n*4.);\n    else if (n<0.5)\n       colo = mix(col2, col3, n*4. - 1.);\n    else if (n<0.75)\n       colo = mix(col3, col4, n*4. - 2.);\n    else\n       colo = mix(col4, col5, n*4. - 3.);\n    \n    colo = mix(photoFront, colo, min(phTime/(throwPer*blendTimeFac), 1.));        \n        \n    return vec3(colo);\n}\n\nvec3 obj_color(vec3 norm, vec3 pos, int objnr)\n{\n    vec3 colo;\n    \n    if (objnr==FLOOR_OBJ)\n       colo = getFloorColor(pos);\n    else if (objnr==PRINTER_OBJ)\n       return printerColor;\n    #ifdef show_leds        \n    else if (objnr==RLED_OBJ || objnr==GLED_OBJ)    \n       return offledColor;\n    #endif\n    else if (objnr>=2)\n    {\n        float phTime = getPhotoTime(objnr - PHOTO_OBJ + 1);\n        vec3 nn = vec3(0., 0., -1.);\n        norm = rotatePhoto(norm, objnr - PHOTO_OBJ + 1);\n        if (dot(norm, nn)<0.)\n           colo = photoBack;\n        else\n           colo = getPhotoColor(pos, objnr - PHOTO_OBJ + 1);\n    }\n\n    return colo;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<20; i++)\n    {\n    \tfloat h = map(ro + rd*t, false, false).x;\n        res = min(res, 4.5*h/t);\n        t += clamp(h, 0.01, 0.25);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return smoothstep(0.0, 0.8, res);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.4, 1., dot(norm, pl));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Ambient shading\n    col+= ocol*ambientColor*ambientint;\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.direction), shf, 100.) + 1. - shi;\n    #endif\n    \n    #ifdef show_leds        \n    if (objnr==RLED_OBJ)\n       col = (rledOn()?redledColor*(0.6 + 0.6*dot(norm, vec3(0., 0., -1.))):col + 0.2);\n    if (objnr==GLED_OBJ)\n       col = (gledOn()?greenledColor*(0.6 + 0.6*dot(norm, vec3(0., 0., -1.))):col + 0.2);\n    if (objnr==PRINTER_OBJ && rledOn())\n       col+= 0.7*max(0.1 - map_rled(pos), 0.)*redledColor;\n    if (objnr==PRINTER_OBJ && gledOn())\n       col+= 0.7*max(0.1 - map_gled(pos), 0.)*greenledColor;    \n    #endif\n    \n    // Attenuation near maxdist\n    col*= smoothstep(0.55*maxdist, 0.25*maxdist, length(pos));\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.04, 0.75);\n   else\n      iMouse2 = iMouse.xy;    \n    \n   campos = rotateVec2(campos, vec2(5.*iMouse2.x/iResolution.x, 3.*iMouse2.y/iResolution.y + 0.05));\n   camdir = camtarget - campos;     \n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n  vec2 t = trace(tpos, ray, maxdist);\n  float tx = t.x;\n  vec3 col;\n  int objnr = int(t.y);\n    \n  vec3 pos = tpos + tx*ray;\n  vec3 norm;\n  if (tx<maxdist*0.65)\n  {\n      norm = getNormal(pos, normdelta);\n\n      // Coloring\n      col = obj_color(norm, pos, objnr);\n      \n      // Shading\n      col = lampsShading(norm, pos, col, objnr);\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\nvec4 render(vec2 fragCoord)\n{  \n  lamps[0] = DirLamp(vec3(-2.5, 5, -2.), vec3(1., 1., 1.), 0.65);\n  lamps[1] = DirLamp(vec3(-2.5, 5, 5.), vec3(1., 1., 1.), 0.3);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  #ifdef floor_reflection\n  if (int(traceinf.objnr)==FLOOR_OBJ)\n  {\n     vec3 refray;\n     float rf = 1.;\n     refray = reflect(ray, traceinf.norm);\n\n     RenderData traceinf_ref = trace0(traceinf.pos, refray);\n     rf = fresnel(ray, traceinf.norm, floor_ior);\n\n     col = mix(col, traceinf_ref.col, rf);    \n  }\n  #endif\n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    time2 = startTime + iTime*timeFactor;\n    \n    // Antialiasing\n    vec4 orv;\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          #ifdef motion_blur\n          time2 = time2 + mbLength*float(j*aasamples+i)/float(aasamples*aasamples);\n          #else\n          //time2 = iTime;\n          #endif\n           \n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vec4 rv = render(fragCoord + vec2(ox, oy));\n          vs+= rv;        \n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples); \n    \n    //vec2 uv = fragCoord.xy / iResolution.xx;\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\"Crazy Printer\" by Emmanuel Keller aka Tambako - August 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// The defines to switch on and off some features\n#define specular\n//#define photo_bump\n//#define printer_bump\n#define floor_pattern\n//#define floor_reflection\n#define show_leds\n#define shadow\n#define use_buffer\n#define sound\n//#define motion_blur\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nDirLamp lamps[2];\n\n#define pi 3.141593\n\n#define FLOOR_OBJ      1\n#define PRINTER_OBJ    2\n#define RLED_OBJ       3\n#define GLED_OBJ       4\n#define PHOTO_OBJ      5\n\n// Campera options\nvec3 campos = vec3(0.5, -0.4, 10.);\nvec3 camtarget = vec3(0., 0.5, 3.);\nvec3 camdir;\nfloat fov = 3.3;\nfloat angle;\nfloat angle2;\nfloat time2;\n\n// Tracing options\nconst float mbLength = 0.008;\nconst float normdelta = 0.0001;\nconst float maxdist = 80.;\n\nconst vec3 ambientColor = vec3(0.8, 0.9, 1.);\nconst float ambientint = 0.2;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\nconst float specint = 0.28;\nconst float specshin = 75.;\n\nconst float floor_ior = 2.2;\n\nconst float shi = 0.44;\nconst float shf = 0.1;\n\nconst int nbPhotos = 100;\n\nconst vec3 photoSize = vec3 (0.8, 1.2, 0.001);\nconst vec3 photoCurve = vec3(0.025, 0.015, 4.);\nconst vec3 photoFront = vec3(0.8);\nconst vec3 photoBack = vec3(0.75);\n\nconst float bump_height_photo = 0.0001;\nconst float bump_height_printer = 0.00012;\nconst vec3 printerColor = vec3(0.28, 0.3, 0.32);\nconst vec3 offledColor = vec3(0.3);\nconst vec3 redledColor = vec3(1., 0.2, 0.1);\nconst vec3 greenledColor = vec3(0.2, 1., 0.1);\n\n// Photo motion parameters\nconst float timeFactor = 3.5;\nconst float nbPhotosPerCycle = 4.;\nconst float startTime = 0.;\nconst float blendTimeFac = 0.5;\nconst float throwPer = 3.;\nconst float h0 = 3.3;\nconst float f1 = 0.3;\nconst float f2 = 1.5;\nconst float hs = 1.9;\nconst float rf = 1.6;\nconst float maxav = 1.2;\nconst float maxdv = 0.75;\n\nvec3 posr;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.7;\n#ifdef motion_blur\nconst int aasamples = 4;\n#else\nconst int aasamples = 1;\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr, vec2 angle)\n{\n    posr = vec3(posr.x, posr.y*cos(angle.y) + posr.z*sin(angle.y), posr.y*sin(angle.y) - posr.z*cos(angle.y));\n    posr = vec3(posr.x*cos(angle.x) + posr.z*sin(angle.x), posr.y, posr.x*sin(angle.x) - posr.z*cos(angle.x)); \n    \n    return posr;\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nvec2 hash2( vec2 p )\n{\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\nfloat fbm(vec2 n)\n{\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise2(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat distRand(float val, float p)\n{\n   val = 2.*clamp(val, 0., 1.);\n   val-= 1.;\n   val = sign(val)*pow(abs(val), p);\n   val+= 1.;\n    \n   return val*0.5;\n}\n\nfloat getPhotoTime(int photoNr)\n{\n   return time2 - throwPer*(float(photoNr) - 1.)/nbPhotosPerCycle - 0.1;   \n}\n\nfloat getRa(int photoNr)\n{\n   return maxav*distRand(hash(float(photoNr)*584.5), 1.8) - maxav*0.5;\n}\n\n#ifdef show_leds\nbool rledOn()\n{\n    return nbPhotosPerCycle*time2/throwPer<float(nbPhotos) && mod(nbPhotosPerCycle*time2, throwPer)<throwPer*0.4;\n}\n\nbool gledOn()\n{\n    float t2 = mod(nbPhotosPerCycle*time2, throwPer);\n    return nbPhotosPerCycle*time2/throwPer<float(nbPhotos) && t2>throwPer*0.4 && t2<throwPer*0.9;\n}\n#endif\n\nvec3 getPhotoPos(int photoNr, float time)\n{  \n   vec3 pos;\n    \n   float lf = 1. + maxdv*distRand(hash(float(photoNr)*287.3), 1.5) - maxdv*0.5;\n   float mh = h0*lf;\n   float y0 = photoCurve.x + photoCurve.y;\n    \n   if (time<throwPer*f1/f2)\n      pos.y = mh - mh*pow(time*f2 - throwPer*f1, 2.);\n   else\n      pos.y = y0 + (mh - y0)*smoothstep(0., mh, mh - f2*(time - throwPer*f1/f2));\n    \n   pos.z = smoothstep(0., throwPer*1.22, time)*throwPer*hs;\n   pos.z = 2.*pos.z - 0.1*pow(pos.z, 2.);\n   pos.z*= lf;\n    \n   float ra = getRa(photoNr);\n   pos.x = pos.z*sin(ra);\n   pos.z = pos.z*cos(ra);\n   pos.z-= 0.03;\n       \n   return pos;\n}\n\nvec2 getPhotoAngle(int photoNr, float time)\n{\n   vec2 angle;\n   float a;\n    \n   if (time<rf*throwPer*f1/f2)\n      a = 0.5*pi*smoothstep(0.1, rf*throwPer*f1/f2, time) + pi;\n   else    \n      a = -0.5*pi;\n       \n   angle.x = a;\n    \n   float ra = getRa(photoNr);\n   angle.y = ra*(1. + 0.65*smoothstep(0.77*throwPer, throwPer, time));\n    \n   return angle;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int photoNr = int(fragCoord.x + floor(fragCoord.y)*iResolution.x);\n    \n    if (photoNr<nbPhotos)\n    {\n       time2 = startTime + iTime*timeFactor;\n       float phTime = getPhotoTime(photoNr);\n       vec3 pos = getPhotoPos(photoNr, phTime);    \n    \n       fragColor = vec4(pos, 0);\n    }\n    \n    photoNr = int(fragCoord.x + floor(fragCoord.y-50.)*iResolution.x);\n    if (photoNr>0 && photoNr<nbPhotos)\n    {\n       time2 = startTime + iTime*timeFactor;\n       float phTime = getPhotoTime(photoNr);\n       vec2 angle = getPhotoAngle(photoNr, phTime);    \n    \n       fragColor = vec4(angle, 0, 0);        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{\n    #ifdef sound\n    time2 = startTime + time*timeFactor;\n    float stime = 2.*pi*time;\n    \n    float s;\n    if (rledOn())\n    {\n       float n = 1.2*exp(-6.0*mod(time2, throwPer/float(nbPhotosPerCycle)))*(hash(time*50.) - hash(time*50. + 0.001));\n       s = smoothstep(0.2, 2.1, 0.7*sin(170.0*stime) + 0.7*sin(252.0*stime) + 0.8*sin(315.2*stime) + 1.3*sin(385.0*stime) +  1.8*sin(316.0*stime) + 1.1*sin(451.0*stime)) + n;\n    }\n    if (gledOn())\n       s = 0.7*smoothstep(0.3, 1.9, 0.4*sin(1245.0*stime) + 0.6*sin(1788.0*stime) + 1.2*sin(2360.0*stime) + 1.7*sin(2985.0*stime) +  1.8*sin(316.0*stime) + 1.1*sin(451.0*stime));\n        \n    return vec2(0.2*s);\n    #else\n    return vec2(0.);\n    #endif\n}","name":"Sound","description":"","type":"sound"}]}