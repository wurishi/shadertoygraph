{"ver":"0.1","info":{"id":"cs3GWM","date":"1677307538","viewed":134,"name":"Penrose \"fractal\" infinite zoom","username":"DjinnKahn","description":"The Penrose tiling made by recursive substitution. I haven't seen this cell coloring before, but it is simple to calculate, and shows a beautiful structure.\n\nI increment the recursive depth two iterations at a time, and handle fractional iterations.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal","zoom","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_TILES 0\n\nconst float PI = acos(0.) * 2.;\nconst float PHI = .5 + sqrt( 1.25 );\nconst vec2 O = vec2( 0. );\nconst vec2 B = vec2( 1., 0. );\nconst vec2 A = vec2( .5, tan(radians(36.))/2. );\nconst vec2 C = mix( O, A, PHI/(PHI+1.) );\nconst vec2 D = mix( B, O, (PHI + 1.) / (3. * PHI + 2.) );\nconst vec2 E = mix( O, B, PHI / (3. * PHI + 2.) );\nconst vec2 F = mix( B, A, PHI / (PHI + 1.) );\nconst vec2 G = mix( C, D, 1. / (PHI + 1.) );\n\nconst int SKINNY_RHOMB = 0;\nconst int FAT_RHOMB = 1;\n\nmat2 rot2( float a )\n{\n    return mat2( cos(a), sin(a), -sin(a), cos(a) );\n}\n\nbool isClockwise( vec2 a, vec2 b, vec2 c )\n{\n    b -= a;\n    c -= a;\n    return b.x * c.y < c.x * b.y;\n}\n\nbool inTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n    return isClockwise( b, a, p ) && isClockwise( c, b, p ) && isClockwise( a, c, p );\n}\n\nfloat distToLine( vec2 p, vec2 a0, vec2 a1 )\n{\n    a1 -= a0;\n    p -= a0;\n    vec2 n = normalize( vec2( a1.y, -a1.x ) );\n    return dot( p, n );\n}\n\nmat3x2 map( vec2 a, vec2 b, vec2 c, vec2 newA, vec2 newB, vec2 newC )\n{\n    return mat3x2( newA-newC, newB-newC, newC ) \n         * inverse( mat3x3( vec3( a-c, 0. ), vec3( b-c, 0. ), vec3( c, 1. ) ) );\n}\n\nstruct TileInfo\n{\n    vec2 pos;\n    int shape;\n    int innerness;\n};\n\nTileInfo getTileInfo( vec2 p, int depth )\n{\n    int shape = FAT_RHOMB;\n    int innerness = 0;\n              \n    for ( int i = 0; i < depth; i++ )\n    {\n        if ( shape == FAT_RHOMB && isClockwise( D, A, p ) ) { p = map(B,D,A, O,A,B) * vec3(p,1.); innerness += ((i&1)==0) ? 1 : -1; }\n        else \n        {   \n            if ( isClockwise( C, D, p ) ) { shape = FAT_RHOMB; p = map(D,C,O, O,A,B) * vec3(p,1.); }\n            else { shape = SKINNY_RHOMB; p = map(D,C,A, O,A,D) * vec3(p,1.); }        \n        }\n    }\n    \n    return TileInfo( p, shape, innerness );\n}\n\nfloat distToEdge( vec2 p, int shape )\n{\n    if ( shape == SKINNY_RHOMB )\n        return min( min( distToLine( p, O, A ), distToLine( p, A, D ) ), distToLine( p, D, O ) );\n    else\n        return min( min( distToLine( p, O, A ), distToLine( p, A, B ) ), distToLine( p, B, O ) );\n}\n\nfloat innernessAdjustment( vec2 p, int shape, float t )\n{\n    if ( isClockwise( mix( O, C, t ), E, p ) )\n        return -1.;\n            \n    if ( isClockwise( mix( B, D, t ), F, p ) )\n        return 1.;\n        \n    return 0.;\n}\n\nconst float ITERATION_ZOOM_FACTOR = (PHI+1.)/(3.*PHI+2.);\nconst vec2 FIXED_PT = vec2( PHI/(2.*PHI+1.), 0. );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float tt = mod( t, 1. );\n\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    p *= rot2( 2.*PI*t / 12. );\n    p.y = abs( p.y );\n    p *= 0.15;\n    p += vec2( .5, .0 );\n    \n    p += vec2( sin( 2.*PI * t / 6. )*.1, .0 );\n    \n    float zoom = tt + 2. + sin( 2.*PI * t / 6. ) * 1.5;\n    p = ( p - FIXED_PT ) * pow( ITERATION_ZOOM_FACTOR, zoom ) + FIXED_PT;\n        \n    if ( !inTriangle( p, O, B, A ) )\n    {\n        fragColor = vec4(vec3(.1),1.0);\n        return;\n    }\n    \n    float col = .5;\n      \n    float depth = 14. + tt * 2.;\n    \n    TileInfo tileInfo = getTileInfo( p, int( floor( depth/2. ) * 2. ) );\n    float innerness = float( tileInfo.innerness ) + innernessAdjustment( tileInfo.pos, tileInfo.shape, fract( depth/2. ) );               \n    col += innerness * .2;\n    \n#if SHOW_TILES\n    if ( distToEdge( tileInfo.pos, tileInfo.shape ) < .02 )\n        col += .1;\n#endif        \n\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}