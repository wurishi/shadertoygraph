{"ver":"0.1","info":{"id":"3lc3zM","date":"1575866433","viewed":461,"name":"Indirect Diffuse Lighting","username":"VoidChicken","description":"Indirect Diffuse Lighting\nClick mouse to move the ball.\nIn common, there are settings for denoising and progressive refine\nThe world is also lit by the skybox.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","bounce","indirect","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 k[5*5];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec4 c = texture(iChannel0, uv);\n    #ifdef MEDIAN\n    vec2 px = 1./iChannelResolution[0].xy;\n    \n    for (int i = -2; i <= 2; i++)\n    {\n         for (int j = -2; j <= 2; j++)\n         {\n             int q = (i+2)+(j+2)*5;\n             k[q] = texture(iChannel0, uv+px*vec2(i, j));\n         }\n    }\n    \n    \n    //bubble sort (yeah i know, its bad but i couldn't think of a better sorting algorithm that unrolls properly. just a prototype anyway)\n    \n    for (int q = 0; q < 20; q++)\n    {\n    \tfor (int l = 0; l < 20; l++)\n        {\n         \tif (length(k[l]) > length(k[l+1]))\n            {\n             \tvec4 t = k[l];\n                k[l] = k[l+1];\n                k[l+1] = t;\n            }\n        }\n    }\n    \n    c=k[12];\n    #endif\n    #ifdef PROGRESSIVE_REFINE\n    fragColor = c / c.w;\n    \n    #else\n    fragColor = c;\n    \n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RT_HIT 0.1\n#define RT_STEPS 24\n#define RT_LOW_STEPS 12\n#define RT_SAMPLES 45\n\nvec4 triplanar(sampler2D channel, vec3 p, vec3 n)\n{\n    n=abs(n);\n    n/=(n.x+n.y+n.z);\n\tvec4 x = texture(channel, p.yz);\n\tvec4 y = texture(channel, p.zx);\n\tvec4 z = texture(channel, p.xy); \n    return n.x*x+n.y*y+n.z*z;\n}\n\nvec3 rand(vec3 p, vec3 n, float i)\n{\n    #ifdef PROGRESSIVE_REFINE\n    i+=iTime;\n    #endif\n    vec3 v = triplanar(iChannel0,p+vec3(tan(i),tan(i+p.z),fract(tan(i+p.y)))*7919., n).rgb;\n    v=normalize(v*2.-1.);\n    float dp = dot(v, n);\n    if(dp<0.0)\n        v=reflect(v, n);\n    return v;\n}\n\n\nvec2 mmin(vec2 a, vec2 b)\n{\n\tif (b.x<a.x)\n        return b;\n    return a;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nvec2 map(vec3 p)\n{\n    vec2 m = iMouse.xy/iResolution.xy*10.-5.;\n    if (iMouse.xy==vec2(0))\n    {\n    \tm = vec2(sin(iTime*2.),cos(iTime*2.));    \n    }\n\treturn mmin(\n        \tmmin(\n                vec2(sdSphere(p+vec3(-m.x,-m.y,0.), 1.0), 0),\n                vec2(sdBox(p-vec3(0,0,1.5),vec3(3, 3, .1)), 1)\n                ),\n        \tmmin(\n                mmin(\n                    vec2(sdBox(p-vec3(3,0,0), vec3(.1,3,1.5)),3),\n                \tvec2(sdBox(p+vec3(3,0,0), vec3(.1,3,1.5)),2)),\n                mmin(\n                    vec2(sdBox(p-vec3(0,3,0), vec3(3,.1,1.5)),4),\n                \tvec2(sdBox(p+vec3(0,3,0), vec3(3,.1,1.5)),1)\n                \t)\n                )\n        );    \n}\n\n//calcNormal used from iq's directional derivative blog\n//https://iquilezles.org/articles/derivative\nvec3 calcNormal(vec3 x)\n{\n    float eps = 0.01;\n    vec2 e = vec2(eps, 0.0);\n    return normalize(vec3(map(x+e.xyy).x - map(x-e.xyy).x,\n                          map(x+e.yxy).x - map(x-e.yxy).x,\n                          map(x+e.yyx).x - map(x-e.yyx).x ));\n}\n\n\nbool isHit(vec3 p)\n{\n\treturn map(p).x < RT_HIT;\n}\n\nvec2 trace(vec3 o, vec3 d)\n{\n   \tvec2 t = vec2(0,-1);\n\n    for (int i = 0; i < RT_STEPS; i++)\n    {\n        vec2 m = map(o+d*t.x);\n        t.x+=m.x;\n        t.y=m.y;\n    }\n    return t;\n}\n\n\nvec4 getMatColor(float mat, vec3 d)\n{\n    \n\tif (mat == 0.0)\n    {\n    \treturn vec4(1.0, 1.0, 1.0, 1.0);    \n    }\n    if (mat == 1.0)\n    {\n    \treturn vec4(1.0, 1.0, 1.0, 0.0);    \n    }\n    if (mat == 2.0)\n    {\n    \treturn vec4(1.0,0.7,0.0, 0.0);    \n    }\n    if (mat == 3.0)\n    {\n    \treturn vec4(0,1,0,0.0);    \n    }\n    if (mat == 4.0)\n    {\n    \treturn vec4(1,1,1,0.0);    \n    }\n    \n    return texture(iChannel2, d) * vec4(1,1,1,0);\n}\n\nvec3 getEmission(float mat)\n{\n    \n\tif (mat == 0.0)\n    {\n    \treturn vec3(0, 0, 0);    \n    }\n    if (mat == 1.0)\n    {\n    \treturn vec3(0);    \n    }\n    if (mat == 2.0)\n    {\n    \treturn vec3(1.0 ,0.7, 0.0) * 2.;    \n    }\n    if (mat == 3.0)\n    {\n    \treturn vec3(0,2,0);    \n    }\n    if (mat == 4.0)\n    {\n    \treturn vec3(4);    \n    }\n    \n    return vec3(0);\n}\n\nfloat lambert(vec3 n, vec3 ld)\n{\n\treturn max(dot(n,normalize(ld)),0.0) / length(ld);    \n}\n\nvec3 render(vec3 n, vec3 p, vec3 i, float mat)\n{\n    if (isHit(p)) {\n        vec3 light = vec3(0, 1, 0);\n        vec3 col = getMatColor(mat, i).xyz;\n\n\n        float l = lambert(n, (light-p)) * 2.0;\n        return getEmission(mat);// + col * l;\n    }\n    return getMatColor(-1., i).xyz;\n}\n\nvec3 renderRefl(vec3 n, vec3 p, vec3 i, float mat)\n{\n \tvec3 rbase = render(n, p, i, mat);   \n  /*  vec3 refl = reflect(i, n);\n    float fres = dot(n, -i);\n    if(isHit(p))\n    {\n        vec2 bt = trace(p+n*RT_HIT,refl);\n        vec3 bh = p+n*RT_HIT + refl * bt.x;\n        rbase = mix(rbase, render(calcNormal(bh), bh, refl, bt.y), fres * getMatColor(mat, refl).w);\n    }*/\n    return rbase;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n \n\tvec3 o = vec3(0, 0, -5);\n    \n    vec3 d = vec3(uv*2.0-1.0,1.0);\n    d.x*=iResolution.x/iResolution.y;\n    d=normalize(d);\n\n    vec2 t = trace(o, d);\n    vec3 h = o + d * t.x;\n    vec3 col = getMatColor(-1.,d).xyz;\n    vec3 n = calcNormal(h);\n    if (isHit(h))\n    {\n        vec3 bcol = vec3(0);\n        float samples = 0.0;\n        for (int i = 0; i < RT_SAMPLES; i++)\n        {\n            vec3 bd = rand(h, n, float(i));\n            vec3 bo = h + n * RT_HIT;\n            \n            vec2 bt = trace(bo, bd);\n            vec3 bh = bo+bd*bt.x;\n            vec3 bn = calcNormal(bh);\n            {\n                float l = lambert(n, bd);\n                vec3 bc = renderRefl(bn, bh, bd, bt.y) * l;\n                bcol += bc;\n            }\n            samples++;\n        }\n        bcol /= samples;\n    \tcol = renderRefl(n, h, d, t.y);\n        col += getMatColor(t.y, d).xyz * max(bcol,0.0);\n    }\n    #ifdef PROGRESSIVE_REFINE\n    fragColor = mix(vec4(max(min(col,1.0),0.0), 1.0), max(texture(iChannel1, uv),0.0), 0.8);\n    #else\n    fragColor = vec4(col,1.0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//enables progressive refine\n#define PROGRESSIVE_REFINE \n\n//enables denoising\n#define MEDIAN","name":"Common","description":"","type":"common"}]}