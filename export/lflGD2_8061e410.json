{"ver":"0.1","info":{"id":"lflGD2","date":"1703840082","viewed":69,"name":"Kings Reflection","username":"JumaGFX","description":"Welcome to the Kings Domain! My first attempt at marching with reflections!\nMainly trying out reflections + sdf shapes, with some depth work.\nMy shadow method is kinda bad, shader isn't optimized, this is just for learning!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","reflections","chess"],"hasliked":0,"parentid":"lcsGDB","parentname":"Rainbow Cubes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//learning reflecting rays via https://www.shadertoy.com/view/4dt3zn\n\n//todo\n//ripple waves of kings\n//DEBUG \"false\" or \"true\" to see other info\n//REFLECTION 0. TO 1. (default 0.7)\n//COLORS 0. OR 1. to make kings scroll through colors\n#define DEBUG false \n#define REFLECTION 0.6\n#define COLORS 0. \n//MAC = PRESS (CMD + ENTER) TO COMPILE AFTER CHANGING DEBUG\n//WINDOWS = PRESS (ALT + ENTER) TO COMPILE AFTER CHANGING DEBUG\n\n//source\n#define PIHALF 1.5707\n#define PI 3.1415\n#define TAU 6.2831\n#define MAX_DIST 100.0\n#define MIN_SURF_DIST 0.0001\n#define MAX_STEPS 90.\n//CHANGE THIS TO HALF TO OPTIMIZE(MAX_STEPS*0.5)\n#define MAX_REFLECTION_STEPS (MAX_STEPS*.9)\n#define T iTime\n\nfloat s01(float s)\n{return (sin(T * s) *0.5 +0.5);}\nvec2 rot2D(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\n\n//hash12 by dave hoskins \nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//=vvv=sdfs & palette by Inigo Quilez=vvv=\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdfs(vec3 p, float r)\n{\n    return length(p)-r;\n}\n//=^^^=sdfs & palette by Inigo Quilez=^^^=\n\n\nfloat GetDistance(vec3 distancePoint)\n{   \n    /*\n    vec4 _SpherePos = vec4(0.,1.,6.0,1.);\n    vec3 sp = _SpherePos.xyz;\n    //sp.x += sin(iTime*2.) * 2.;\n    float dSphere = length(distancePoint - (sp)) - _SpherePos.w;\n    sp.xyz += vec3(2.,-0.5,0.5);\n    float dSphere2 = length(distancePoint - (sp)) - _SpherePos.w*0.5;\n    */\n    float dPlane = dot(distancePoint,normalize(vec3(0.,1.,0.)));\n    // + sin(distancePoint.z)*0.5+0.5;\n    \n    \n    vec3 p = distancePoint;\n    \n    \n    vec3 q = p;//fract(p)-0.5;\n    //q.xz = fract(p.xz)-0.5;\n    //q.xz = mod(p.xz, 4.)-2.;\n    \n    //q.y -= 1.;\n    //vec3 of = vec3(0);//vec3(0.,1.5 + sin(T*2.),0.);\n    \n    float fs = sdfs((q-vec3(0.,1.5 + sin(T*2.),0.)),0.3);\n    //p.xz = fract(p.xz*.5)-.5;\n    //p.xz *= 2.;\n    p.xz = mod(distancePoint.xz, 2.)-1.;\n    //p.xz *= 1.;\n    //p.y = mod(distancePoint.y, 8.);\n\n\n    p.y -= 1.75*sin(length((vec2(1,1)-distancePoint.xz)*.5)-(T*2.))*0.5+.75;\n    //p.y -=  length(distancePoint.xz*sin(T)*0.5+0.5);\n    \n    vec2 gridId = floor(distancePoint.xz*0.5);\n    //vec3 index = (mod(gridId.x+gridId.y,2.) > 0.) ? vec3(0.93,0.93,0.82):vec3(0.46,0.58,0.33);//1. : 0.;\n    float index = (mod(gridId.x+gridId.y,2.) > 0.) ? 1. : 0.;////\n    \n    //p.y += mix(index,1.-index, sin(iTime)*0.5+0.5);\n    if(floor(length(distancePoint.xz)) > 12.)// || (length(distancePoint.y)) > 100.  )//(distancePoint.xz)\n    {\n        return min(fs,dPlane);\n        //return min(dSphere2,min(dSphere, min(fs,dPlane)));\n    }\n    \n    if((q.x > 0. && q.x < 2.)&&(q.z < 2. && q.z > 0.)){p*=.9;p.yz = rot2D(p.yz,sin(T*2.)*0.05);\n    p.xz = rot2D(p.xz,T*2.);p.xy = rot2D(p.xy,sin(T*1.5)*0.05);\n    }\n    \n    //p.y += mix(index,1.-index, sin(iTime)*0.5+0.5);\n    vec3 k = -vec3(-1.2,0,4.);\n    //send king to origin\n    k = vec3(0);\n    \n    float base = opSmoothUnion(sdRoundedCylinder(p - vec3(0,0.2,0)+k,.25,.1,.1),\n    sdRoundedCylinder(p - vec3(0,.6,0)+k,.2 - ((p.y*p.y)*0.09),.026,.2),0.2);\n    \n    float mid = opSmoothUnion(sdRoundedCylinder(p - vec3(0,1.7,0)+k,.15 - (log(p.y*2.)*0.05),.02,1.),base,0.05);\n    \n    float midTop = opSmoothUnion(opSmoothUnion(sdRoundedCylinder(p - vec3(0,2.2,0)+k,.15,.03,.015),\n    sdRoundedCylinder(p - vec3(0,2.3,0)+k,.11,.06,.02),0.09),mid,0.1);\n    \n    float topCone = opSmoothUnion(\n    opSmoothUnion(sdRoundedCylinder(p - vec3(0,2.7,0)+k,.11,.03,.02),mid,0.05)\n    ,sdCone(p - vec3(0,2.7,0)+k,\n    vec3(0.,.6,0.),\n    vec3(0.,0.,0.),\n    0.3,0.15),0.1);\n    \n    float topHat = opSmoothUnion(\n    min(sdRoundBox(p - vec3(0,3.5,0)+k,vec3(0.03,0.3,0.05),0.02),\n    sdRoundBox(p - vec3(0,3.6,0)+k,vec3(0.15,0.05,0.05),0.02)),\n    topCone,\n    0.1);//cone x rect merge\n    float distanceToScene = min(topHat,min(midTop,min(mid,min(base,min(fs,dPlane)))));\n    //float distanceToScene = min(topHat,min(midTop,min(mid,min(base,min(dSphere2,min(dSphere,min(fs,dPlane)))))));\n    \n    return distanceToScene;\n}\n\n\nvec3 GetNormals(vec3 p)\n{\n    float d = GetDistance(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 normals = d - vec3(\n      GetDistance(p - e.xyy),\n      GetDistance(p - e.yxy),\n      GetDistance(p - e.yyx)\n    );\n    return normalize(normals);\n}\n\n\n\n\n\n\nfloat rm (vec3 rayOrigin, vec3 rayDirection, float MaxSteps)\n{\n    float dO = 0.0; //Distance from Origin\n    float dS = 0.0; //Distance from Scene\n    for (float i = 0.; i < MaxSteps; i++)\n    {\n        vec3 p = rayOrigin + rayDirection * dO;             // standard point calculation dO is the offset for direction or magnitude\n        //p.xy += rot2D(p.xy, p); //rotate the scene\n        //p.y += sin(p.z * 4. + iTime*3.)*0.1;\n        dS = GetDistance(p);                             \n        if (abs(dS) < MIN_SURF_DIST || dO > MAX_DIST) break;            // if we are close enough to a surface or went to infinity, break & return distance to the origin\n        dO += dS*0.9;\n    }\n    return dO;\n}\n\nvec3 getObjectColor(vec3 p){\n    \n    float size = 0.5;\n    vec2 gridId = floor(p.xz*size);\n    vec3 index = (mod(gridId.x+gridId.y,2.) > 0.) ? vec3(0.93,0.93,0.82)*2.:vec3(0.46,0.58,0.33)*1.;//1. : 0.;\n    \n    if(p.y>0.1){\n        if((p.x > 0.3 && p.x < 2.)&&(p.z < 2. && p.z > 0.3)){return vec3(10,10,0);}\n        //return vec3( hash12(floor(p.xz))*2.,hash12(floor(p.zx))*1.6,hash12(floor(p.xx))*3.4 );\n        \n        \n        /*\n        vec3 l = vec3(p/length(p));\n        return (1. * l) * ((1. - COLORS) + (0. + COLORS)*\n        ((sin(T)+2.)*palette(length(p.yy*PIHALF)  + iTime*5.,vec3(0.7, 0.5, 0.5),vec3(0.5, 0.2, 0.9),vec3(1.0, 0.5, 0.3),vec3(0.09, 0.33, 0.67))));\n        */\n        \n        return 1.*((1. - COLORS) + (0. + COLORS)*\n        ((sin(T)+2.)*palette(length(p.yy*PIHALF)  + iTime*5.,vec3(0.7, 0.5, 0.5),vec3(0.5, 0.2, 0.9),vec3(1.0, 0.5, 0.3),vec3(0.09, 0.33, 0.67))));\n        \n    }\n    \n    \n    return index;\n}\n\nvec3 ColorScene(in vec3 hitEP,in vec3 rd,in vec3 n,in vec4 lp, float t,vec2 uv)\n{\n    //Lighting\n    vec3 lDir = lp.xyz - hitEP;\n    float lDist = max(length(lDir),0.001);\n    lDir/= lDist;\n    //float atten = 1.-lDist*0.1;\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    float dotNL = clamp(dot(n,lDir),0.,1.);\n    \n    //DIFFUSE LIGHT = N DOT L\n    float diffuse = max(dotNL, 0.);\n    \n    //SPECULAR LIGHT (check phong lighting)\n    float specular = pow(max(dot(reflect(lDir,n),rd),0.),80.);\n    \n    //Shadow RM | s = distance from hitEP to light/blocked areas\n    float s = rm(hitEP + (n * MIN_SURF_DIST *2.),lDir, MAX_STEPS);\n    if(s < length(lDir))\n    {\n         dotNL *= smoothstep(0.7, 1., s);\n         //return vec3(0,0,1);//shows the shaded area on the sphere & the floor behind the sphere to light\n         //we dont want that, we need to shade the floor and do so via dot\n         //return vec3(dotNL);\n    }\n    \n\n    \n    // Coloring all Objects\n    vec3 objCol = getObjectColor(hitEP);\n    \n   \n    //vec3 sceneColors = (objCol*diffuse*(dotNL*0.5+0.5)) + (vec3(1., 1., .2) * specular);\n    vec3 sceneColors = ((objCol*(diffuse+0.2)*(1.*dotNL*0.5+0.5)) + (vec3(1., 1., .2) * specular )) * (atten*1.);\n    \n    float depth = smoothstep(0.,1.,t*0.02);\n\n    //vec3 p = palette(length(1.*PIHALF)  + iTime*5.,vec3(0.7, 0.5, 0.5),vec3(0.5, 0.2, 0.9),vec3(1.0, 0.5, 0.3),vec3(0.09, 0.33, 0.67));\n    //return sceneColors;\n    //return vec3(depth*1.);\n    //return vec3(mix(sceneColors, vec3(0.3,.0,0.3) ,depth*0.4 ));\n    //return clamp(vec3(mix(sceneColors, vec3(.1,.1,0.2),depth)),0.,1.);\n    //return vec3(specular + diffuse);// + vec3(0,0,0.3);\n    \n    if(DEBUG == false)\n    {\n        return vec3(mix(sceneColors, vec3(0.3,.0,0.3) ,depth*.5 ));\n    }\n    else\n    {\n        if(uv.x>(sin(T)*0.33+.66))\n        {return vec3(sceneColors);}\n        else if (uv.x>(sin(T)*0.33+.33))\n        {return vec3(mix(sceneColors, vec3(0.3,.0,0.3) ,depth*.5 ));}\n        else\n        {return vec3(depth);}\n    }\n\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 cuv = uv * 2. - 1.;\n    //cuv.x*=1.2;\n    vec3 ro = vec3(0.0,6.,0.);\n    \n    \n    //fragColor=vec4(1)*1.-iMouse.z;\n    //return;\n    \n    vec3 rd = normalize(vec3(cuv.xy,1.));\n    int rot = 1;\n    if(rot == 1)\n    {\n        //rd.xz = vec2(rot2D(rd.xz,(sin(T*1.5)*0.25 * (1. - clamp(iMouse.z,0.,1.)) ) + ( clamp(iMouse.z,0.,1.) * (3.14 - iMouse.x*0.01)) ));//sin(T*1.2)*0.2));\n        //rd.yz = vec2(rot2D(rd.yz, -PIHALF + clamp(PI*(iMouse.y/iResolution.y),0.,PI) ));\n        //rd.yz = vec2(rot2D(rd.yz,PI*0.2));\n        ro.z += -6. - sin(T)*.6;\n        rd.yz = vec2(rot2D(rd.yz,0.3+(PI*0.15)*s01(1.)));\n        ro.xz = vec2(rot2D(ro.xz,T*0.6));\n        //rd.xz += vec2(rot2D(rd.xz,(sin(T*1.5)*0.25 * (1. - clamp(iMouse.z,0.,1.)) ) + ( clamp(iMouse.z,0.,1.) * (3.14 - iMouse.x*0.01)) ));//sin(T*1.2)*0.2));\n        rd.xz = vec2(rot2D(rd.xz,T*0.6));\n        ro.y += sin((T*1.))*1.;\n        //ro.yz = vec2(rot2D(ro.yz,T));\n    }\n    else\n    {\n        rd.yz = vec2(rot2D(rd.yz,PI*0.5));\n        ro.xz += vec2(-10.+(iMouse.x*0.03),-10. + ((iMouse.y*0.04)));\n        ro.y += 5.;\n        if(iMouse.z > 0.5){ro.y = ro.y - 2.;;}\n    }\n\n\n    \n    vec3 col = vec3(0.);\n\n    //1st raymarch\n    float hitDist = rm(ro, rd, MAX_STEPS);//first hit an object or extend to inf\n    //return (distanceRM)*0.01;\n    \n    //col += hit1*0.1;\n    \n\n    //if(distanceRM > MAX_DIST)  {fragColor = vec4(0,0.4,0.8,1);return;}//skybox\n    \n    vec3 hitPos = ro + rd * hitDist;//\n    //fragColor=vec4(abs(p.zzz/50.),1);\n    //fragColor = vec4(vec3(distanceRM/50.),1.);\n    //return;\n    //if((p.x > 0. && p.x < 2.)&&(p.z < 4. && p.z > 2.))\n    vec4 _LightPos = vec4(1,3. + (sin(T*3.)*2.),1,8.);//orig 2 height + sin\n    //vec3 light = vec3(GetLight(hit1point,_LightPos));\n    //fragColor = vec4(light,1);\n    //return;\n    \n    vec3 normalsHit = GetNormals(hitPos); //test normals\n    //fragColor = vec4(normalsHit,1);\n    //return;\n    \n    //get first scene colors, hit1point , rd, normalsHit, light position, hit1\n    vec3 sceneColors = ColorScene(hitPos,rd,normalsHit,_LightPos,hitDist,uv);\n    \n    //REFLECTION RAY 2nd pass\n    rd = reflect(rd,normalsHit);\n    \n    //2nd raymarch\n    float hitRef = rm(hitPos + (normalsHit * MIN_SURF_DIST *2.),rd,MAX_REFLECTION_STEPS);\n    \n    //point of contact of the reflected ray\n    vec3 refHitPoint = hitPos + rd * hitRef;\n    \n    normalsHit = GetNormals(refHitPoint);\n    \n     //i think this method is garb for ao not sure, fake ambient occulusion based on the reflection ray\n    float fAO = smoothstep(.0,1.,hitRef);//pow(smoothstep(.0,0.4,hitRef),1.)\n    sceneColors *= vec3(clamp(fAO+0.3,0.,1.));\n    \n    sceneColors += ColorScene(refHitPoint,rd,normalsHit,_LightPos,hitRef,uv) * (REFLECTION);\n    \n    //gamma correction commented by spalmer\n    //sceneColors = pow(sceneColors, vec3(.4545)); //with gamma correction colors are off & need some work so i will keep it off untill i fix it.\n    \n\n    fragColor = vec4(sceneColors * vec3(1,1,1),1);\n    return;\n\n            \n}","name":"Image","description":"","type":"image"}]}