{"ver":"0.1","info":{"id":"NdVyWW","date":"1654892736","viewed":65,"name":"SynthÃ¨se_image","username":"schi","description":"raysphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raysphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1.0 / 0.0;    \n\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n\n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(3,  8, -2);\nconst vec3\t   cameraTarget = vec3(9,  4, -13);\nconst float    cameraFovY   = 80.0;\t\t\t\t\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0, 0.2, 0.5); // bleu\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 0, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(5.0,5.0,0);\t\t\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(0.4);\t\t// white\nconst vec3     planeCol2    = vec3(1.0);\t\t// gray\nconst Material planeMat     = Material(0.2, 1.0, 0.2,  5.0);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = cameraTarget + vec3(1, 1, -5);\n\n\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n       \n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        intersecPt = rayPos + t * rayDir;     \n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -2.0;\n}\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t\n        return -1.0;\t\t\t \n        \t\t\t\t\t\t\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n   \n    intersecPt = rayPos + t * rayDir;\n    \n    \n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    \n                 \n    float focal = 2.0 / tan(radians(cameraFovY) / 1.5);\n  \n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n   \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n\n    vec3 cy = normalize(cross( cz, cx));\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n   \n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt + planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.3) + floor(v * 0.3), 4.3) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    \n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t\n    \t\t\t\t\t\t\t\t\t\t\n    vec3  shadowRayDir   = L;\n    \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                unusedInt, unusedVec1, unusedVec2);\n    \n    \n    float shadowFactor = (shadowRes < 1.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    \n    vec3 amb, diff, spec, phong;\n     amb  = objectMat.Ka * ambiantCol *lightCol;\n     diff  = objectMat.Kd * objectCol * lightCol * max(dot(N,L), 0.);\n     spec = objectMat.Ks  * lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    phong = amb + (diff * shadowFactor) + (spec * shadowFactorSpec);\n\n    return phong;\n}\n\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 9.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    \n    spherePos = cameraTarget + rs * vec3(-sin(as), 1.0, cos(as)) + vec3(3,3,0);\n \n\n    lightPos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(1, 0.5, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.3),1.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set the time used for the animation\n    float time = iTime;\n    \n    // Animate scene objects\n    AnimateScene(time);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n\t    vec3 L = lightPos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n\t\t// Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \tfragColor = vec4(computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, L, R, V), 1);\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \tfragColor = vec4(skyCol, 1);\n}","name":"Image","description":"","type":"image"}]}