{"ver":"0.1","info":{"id":"MfVyW1","date":"1731823565","viewed":70,"name":"Voronoi 3D 101","username":"kukovisuals","description":"Voronoi spher","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","voronoi3d","voronoisphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst float PI = 3.1415926535897932384626433832795;\n\n// Hash function to generate pseudo-random but consistent positions in 3D\nvec3 vhash(vec3 UV, vec3 offset) {\n    // Matrix for hashing\n    mat3 m = mat3(\n        127.1, 311.7,  74.7,\n        269.5, 183.3, 246.1,\n        113.5, 271.9, 124.6\n    );\n    // Generate pseudo-random values\n    UV = fract(sin(UV * m) * 46839.32);\n    // Return a hashed vector\n    return vec3(\n        sin(UV.z * offset.x) * 0.5 + 0.5,\n        cos(UV.x * offset.y) * 0.5 + 0.5,\n        tan(UV.y * offset.z) * 0.5 + 0.5\n    );\n}\n\n// Voronoi function in 3D space\nvec4 voronoi(vec3 p, vec3 AngleOffset, vec3 CellDensity) {\n    vec3 g = floor(p * CellDensity);\n    vec3 f = fract(p * CellDensity);\n    float res = 8.0;\n    float md = 8.0;\n    vec3 mr;\n    vec4 Out = vec4(0.0);\n\n    // First pass to find the closest point\n    for (int z = -1; z <= 1; z++)\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec3 lattice = vec3(x, y, z);\n        vec3 offset = vhash(lattice + g, AngleOffset);\n        vec3 r = lattice + offset - f;\n        float d = dot(r, r);\n        if (d < res) {\n            res = d;\n            mr = r;\n        }\n    }\n\n    res = 8.0;\n\n    // Second pass to find the second closest point\n    for (int z = -1; z <= 1; z++)\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec3 lattice = vec3(x, y, z);\n        vec3 offset = vhash(lattice + g, AngleOffset);\n        vec3 r = lattice + offset - f;\n        float d = dot(r, r);\n        if (d > 0.0001 && d < res) {\n            res = d;\n            Out.x = d;\n            Out.y = offset.x;\n        }\n        if (dot(mr - r, mr - r) > 0.00001) {\n            md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));\n        }\n    }\n\n    // Calculate the Voronoi cell edges\n    Out.z = 1.0 - smoothstep(0.0, 0.05, md); // Adjusted for sharper edges\n    Out.w = smoothstep(0.0, 0.02, res);      // Adjusted for cell interiors\n    return Out;\n}\n\n// Rotation around Y-axis\nmat3 rotationY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n         c, 0.0, s,\n         0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Camera setup function\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(cos(rotation), -sin(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize fragment coordinates (from -1 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Correct for aspect ratio\n\n    // Camera settings\n    vec3 camPos = vec3(0.0, 0.0, 3.0);    // Camera position\n    vec3 target = vec3(0.0);              // Look-at point\n    float rotation = 0.0;                 // Keep camera static\n\n    // Set up the camera\n    mat3 camMat = SetCamera(camPos, target, rotation);\n    vec3 rayDir = normalize(camMat * vec3(uv, -2.0));\n\n    // Ray-sphere intersection\n    vec3 sphereCenter = vec3(0.0);\n    float sphereRadius = 1.3;\n    vec3 oc = camPos - sphereCenter;\n    float b = dot(oc, rayDir);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float h = b * b - c;\n\n    if (h < 0.0) {\n        // No intersection: set background color\n        fragColor = vec4(0.0);\n    } else {\n        // Compute intersection point\n        h = sqrt(h);\n        float t = -b - h; // Closer intersection point\n        vec3 pos = camPos + t * rayDir; // Point on sphere surface\n\n        // Rotate the sphere like the Earth\n        float sphereRotation = iTime * 0.1; // Adjust rotation speed as needed\n        mat3 rotY = rotationY(sphereRotation);\n        pos = rotY * pos;\n\n        // Normalize position to map onto the Voronoi function\n        vec3 p = normalize(pos) * 0.5 + 0.5;\n\n        // Voronoi pattern on the sphere\n        vec3 AngleOffset = vec3(1.0, 1.0, 1.0) * iTime * 0.1; // Animation over time\n        vec3 CellDensity = vec3(3.0); // Adjust for desired cell size\n        vec4 voro = voronoi(p * 3.0, AngleOffset, CellDensity);\n\n        // Colors for the Voronoi cells\n        // Apply the specified colors\n        vec3 colorA = vec3(0.996,0.345,0.345);\n        vec3 colorB = vec3(0.000,0.000,0.000);\n        float interpolateAB = voro.z;\n        vec3 mixedColor = mix(colorA, colorB, interpolateAB);\n\n        vec3 smoothStep = smoothstep(0.36, 0.2, mixedColor);\n        // Use the distance for coloring: closer to cell center is darker\n        fragColor = vec4(smoothStep, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}