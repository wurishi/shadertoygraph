{"ver":"0.1","info":{"id":"Ml3cRB","date":"1533012618","viewed":145,"name":"Octonionic Julia Sets, 2D slices","username":"dust","description":"A standard julia DE extended for the octonions; elements are multiplied with the Cayley-Dickson process.\nhttps://en.wikipedia.org/wiki/Cayley–Dickson_construction\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","julia","distanceestimation","audio","fractals","octonions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Ordinary complex multiplication\nvec2 CplxMul(vec2 a, vec2 b)\n{\n    return vec2((a.x * b.x) - (a.y * b.y), \n                (a.x * b.y) + (a.y * b.x));\n}\n\n// Complex conjugate defined here because I ceebs copying it all over the place\nvec2 CplxConj(vec2 c)\n{\n    return c * vec2(1.0f, -1.0f);\n}\n\n// Octonionic products require a quaternionic product under the Cayley-Dickson\n// process, define that here\nvec4 QtnProd(vec4 q, vec4 p)\n{\n    // Quaternion multiplication may be reduced to complex multiplication\n\t// First decline quaternions into ordered pairs of complex numbers\n\t// q(i0,i1,j0,j1)p(k0,k1,l0,l1) >> (i,j)(k,l) \n    // multiplication is defined by (i,j)(k,l) >> (ik - l*j, li + jk*)\n    return vec4(CplxMul(q.xy, p.xy) - CplxMul(CplxConj(p.zw), q.zw),\n                CplxMul(p.zw, q.xy) + CplxMul(q.zw, CplxConj(p.zw)));\n}\n\n// Octonionic products require a quaternionic conjugate under the Cayley-Dickson\n// process; define that here\nvec4 QtnConj(vec4 q)\n{\n    return vec4(CplxConj(q.xy), \n                q.zw * -1.0f);\n}\n\n// Octonionic Cayley-Dickson product from\n// https://en.wikipedia.org/wiki/Cayley–Dickson_construction\nmat2x4 OctoMul(mat2x4 o, mat2x4 w)\n{\n    // Octonion multiplication extends directly from quaternion multiplication, thus:\n\t// o(p,q)w(r,s) >> (pr - s*q, sp + qr*)\n    return mat2x4(vec4(QtnProd(o[0], w[0]) - QtnProd(QtnConj(w[1]), o[1])),\n                  vec4(QtnProd(w[1], o[0]) + QtnProd(o[1], QtnConj(w[0]))));\n}\n\n// No 8D vectors in GLSL, so manually define octonion length\n// here\nfloat octoLen(mat2x4 o)\n{\n    // Euclidean norm (|v| = sqrt(sum(v.x...)))\n    return sqrt(dot(o[0], o[0]) + dot(o[1], o[1]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Populate 8D starting coordinate\n    float scale = 0.8f;\n    vec2 baseCoord = vec2(-1.0, -1.0) + 2.0 * (fragCoord.xy / iResolution.xy);\n\tmat2x4 j = mat2x4(vec4(baseCoord, baseCoord),\n                      vec4(baseCoord, baseCoord)) * scale;\n   \tj[0].x *= iResolution.x / iResolution.y;\n    \n    // Fractal pan time interval\n    float sTime = max((sin(iTime) * 0.3f) - 0.2f, 0.3f);\n    \n    // Fractal seed value\n    mat2x4 c = mat2x4(sTime * 5.0f, cos(iTime), sin(iTime), sTime, // First subquaternion defined from time, audio FFT\n                      max(sin(cos(iTime)) - 0.5f, 1.0f), 0.5f, 0.0f, 0.8f) // Second subquaternion defined from audio waveform\n        \t\t\t* sTime; // Per-frame constant scaled by sin(t) for panning\n        \n    // Iterations\n    float maxDist = 2000.0;\n    mat2x4 dj = mat2x4(vec4(1,0,0,0), vec4(0));\n    float iter = 0.0;\n    float maxIter = 1024.0;\n    while (iter < maxIter &&\n           octoLen(j) < maxDist)\n    {\n        dj = 2.0 * OctoMul(j, dj);\n    \tj = OctoMul(j, j) + c;\n        iter += 1.0;\n    }\n    \n    // Final distance\n    float r = octoLen(j);\n    float dr = octoLen(dj);\n    float dist = 0.5 * r * log(r) / dr;\n    \n    // Color treatment from iq's Mandelbrot DE\n    // https://www.shadertoy.com/view/lsX3W4\n    dist = clamp(pow(4.0 * dist/scale, 0.2), 0.0, 1.0);\n  \tfragColor = vec4(dist,\n                     dist, \n                     dist,\n                     1.0);\n}","name":"Image","description":"","type":"image"}]}