{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Part from our Revision 2013 entry Intrinsic\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 rotatex(in vec3 p, float ang)\n{\n\treturn vec3(p.x,p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang)); \n}\nvec3 rotatey(in vec3 p, float ang)\n{\n\treturn vec3(p.x*cos(ang)-p.z*sin(ang),p.y, p.x*sin(ang)+p.z*cos(ang)); \n}\n\nfloat scene(in vec3 p)\t\n{\n\tfloat r = 0.4; \n\tfloat ox = float(int(p.x*50.0+50.0*r)); \n\tfloat oy = float(int(p.y*50.0+50.0*r)); \n\t\n\tp.x = mod(p.x+r, 2.0*r) - r; \n\tp.y = mod(p.y+r, 2.0*r) - r; \n\tp = rotatex(p, oy*0.1); \n\tp = rotatey(p, ox*0.1); \n\tp.z += sin(ox*ox*0.01+oy*oy*0.00+iTime)*0.01; \n\treturn length(p) - r; \n}\nvec3 get_normal(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0, 0); \n\tfloat nx = scene(p + eps.xyy) - scene(p - eps.xyy); \n\tfloat ny = scene(p + eps.yxy) - scene(p - eps.yxy); \n\tfloat nz = scene(p + eps.yyx) - scene(p - eps.yyx); \n\treturn normalize(vec3(nx,ny,nz)); \n}\n\nfloat rm2(in vec3 ro, in vec3 rd)\n{\n\tvec3 pos = ro; \n\tfloat dist = 1.0; \n\tfloat d; \n\tfor (int i = 0; i < 5; i++) {\n\t\td = scene(pos); \n\t\tpos += rd*d;\n\t\tdist -= d; \n\t}\n\treturn dist; \n}\n\nvec3 rm3(in vec3 ro, in vec3 rd)\n{\n\tvec3 color = vec3(0); \n\tvec3 pos = ro; \n\tfloat dist = 1.0; \n\tfloat d; \n\tfor (int i = 0; i < 32; i++) {\n\t\td = scene(pos); \n\t\tpos += rd*d;\n\t\tdist -= d; \n\t}\n\tif (dist < 10.0 && abs(d) < 0.1) {\n\t\tvec3 l = normalize(vec3(1,1,1)); \n\t\tvec3 n = get_normal(pos); \n\t\tvec3 r = reflect(rd, n); \n\t\tfloat fres = clamp(dot(n, -rd),0.0, 1.0);  \n\t\tfloat diff = clamp(dot(n, l), 0.0, 1.0); \n\t\tfloat spec = pow(clamp(dot(r, l), 0.0, 1.0), 40.0);  \n\t\tfloat shade = 1.0; //rm2(pos+0.05*n, n); \n\t\tcolor = mix(vec3(1,1,1)*0.8, vec3(1,1,1)*0.0, fres); \n\t\tcolor += 0.1*vec3(1,1,1)*diff*clamp(n.y, 0.0, 1.0);  \n\t\tcolor += vec3(1,1,1)*spec; \n\t\tcolor += 0.0*shade; \n\t\t//color /= dist; \n\t}\n\treturn color; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy )-1.0;\n\tp.x *= iResolution.x/iResolution.y; \n\n\tvec3 color = vec3(0.1); \n\t\n\tvec3 ro = vec3(0,-iTime*0.025,1.0);\n\tvec3 rd = normalize(vec3(p.x,p.y,-2.0)); \n\trd = rotatex(rd, 1.2); \n\tvec3 pos = ro; \n\tfloat dist = 0.0; \n\tfloat d; \n\tfor (int i = 0; i < 96; i++) {\n\t\td = scene(pos)*0.75; \n\t\tpos += rd*d;\n\t\tdist += d; \n\t}\n\tif (dist < 10.0 && abs(d) < 0.1) {\n\t\tvec3 l = normalize(vec3(0,1,0.5)); \n\t\tvec3 n = get_normal(pos); \n\t\tvec3 r = reflect(rd, n); \n\t\tfloat fres = clamp(dot(n, -rd),0.0, 1.0);  \n\t\tfloat diff = clamp(dot(n, l), 0.0, 1.0); \n\t\tfloat spec = pow(clamp(dot(r, l), 0.0, 1.0), 40.0);  \n\t\tfloat shade = rm2(pos+0.05*n, 1.0*n); \n\t\tvec3 refl = rm3(pos+0.01*n, r); \n\t\tcolor = mix(vec3(1,0.99,0.98)*0.8, vec3(1,1,1)*0.0, fres); \n\t\tcolor += 0.1*vec3(1,1,1)*diff*clamp(n.y, 0.0, 1.0);  \n\t\tcolor += vec3(1,1,1)*spec; \n\t\tcolor *= 1.0*(1.0-1.0*shade);  \n\t\tcolor += 0.5*refl*(1.0-fres);  \n\t\tcolor /= dist; \n\t}\n\t\n\t// light \"glow\"\n\tcolor += vec3(0.97,0.99,1.0)*clamp((1.0-length(p*vec2(0.5,1.0)-vec2(0.0,0.75))), 0.0, 1.0)*(0.5); \n\t\n\tfragColor = vec4(color, 1.0); \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dsGW8","date":"1368630256","viewed":640,"name":"Segmented Spheres","username":"jvb","description":"Part from our Revision 2013 PC demo entry Intrinsic","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres"],"hasliked":0,"parentid":"","parentname":""}}