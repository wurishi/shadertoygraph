{"ver":"0.1","info":{"id":"wtdcDf","date":"1610108915","viewed":199,"name":"Ray Intersections","username":"AmonAhmed","description":"Simple shader testing out different ray intersects.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["ray","math","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA_SAMPLES 3\n#define MAX_BOUNCES 5\n#define CAMERA_Y_SPEED 1.5\n#define CAMERA_X_SPEED 2.0\n\n\nvec3 calculateLighting(in vec3 color, in vec3 specColor, in vec3 normal, in float t, inout Ray ray) {\n    vec3 lightPosition = vec3(0.0,0.0,4.0);\n    vec3 lightDiffuse = vec3(0.5,0.5,0.5);\n    vec3 norm = normalize(normal);\n    vec3 fragPos = ray.a+ray.d*t;\n    vec3 lightDir = normalize(lightPosition - fragPos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = lightDiffuse * (diff * color);\n    ray.energy *= specColor;\n    return diffuse;\n}\n\n\n\n//==============================================================================\n// Sphere intersection\n//==============================================================================\nfloat sphereIntersect(in Ray r, in Sphere s, out vec3 normal)\n{\n    vec3 m = r.a - s.c;\n    float b = dot(m, r.d);\n    float c = dot(m, m) - s.r * s.r;\n    // Exit if r’s origin outside s (c > 0) and r pointing away from s (b > 0)\n    if (c > 0.0f && b > 0.0f) return -1.0;\n    float discr = b*b - c;\n    // A negative discriminant corresponds to ray missing sphere\n    if (discr < 0.0f) return -1.0;\n    // Ray now found to intersect sphere, compute smallest t value of intersection\n    float t = -b - sqrt(discr);\n    // If t is negative, ray started inside sphere so clamp t to zero\n    if (t < 0.0f) t = 0.0f;\n    normal = normalize((r.a+r.d*t) - s.c);\n    return t;\n}\n//==============================================================================\n// Triangle intersection\n//==============================================================================\n//Given line pq and ccw triangle abc, return whether line pierces triangle. If\n//so, also return the barycentric coordinates (u,v,w) of the intersection point\nfloat triangleIntersect(in Ray r, in Triangle t, out vec3 normal)\n{\nvec3 pq = -r.d*r.tMax;\nvec3 pa = t.a - r.a;\nvec3 pb = t.b - r.a;\nvec3 pc = t.c - r.a;\n// Test if pq is inside the edges bc, ca and ab. Done by testing\n// that the signed tetrahedral volumes, computed using scalar triple\n// products, are all positive\nfloat u = ScalarTriple(pq, pc, pb);\nif (u < 0.0f) return -1.0;\nfloat v = ScalarTriple(pq, pa, pc);\nif (v < 0.0f) return -1.0;\nfloat w = ScalarTriple(pq, pb, pa);\nif (w < 0.0f) return -1.0;\n// Compute the barycentric coordinates (u, v, w) determining the\n// intersection point r, r = u*a + v*b + w*c\nfloat denom = 1.0f / (u + v + w);\nu *= denom;\nv *= denom;\nw *= denom; // w = 1.0f - u - v;\n\nvec3 p = u*t.a+v*t.b+w*t.c;\nnormal = -normalize( cross( t.b-t.a, t.c-t.a ) );\nreturn distance(r.a,p);\n}\n//==============================================================================\n// Box Intersection\n//==============================================================================\n// Intersect ray R(t) = p + t*d against AABB a. When intersecting,\n// return intersection distance tmin and point q of intersection\nfloat aabbIntersect(in Ray r, in AABB a, out vec3 normal)\n{\n    float tmin = 0.0f; // set to -FLT_MAX to get first hit on line\n    float tmax = r.tMax; // set to max distance ray can travel (for segment)#\n    // For all three slabs\n    for (int i = 0; i < 3; i++) {\n        if (abs(r.d[i]) == 0.0f ) {\n            // Ray is parallel to slab. No hit if origin not within slab\n            if (r.a[i] < a.min[i] || r.a[i] > a.max[i]) return -1.0;\n        } \n        else {\n            // Compute intersection t value of ray with near and far plane of slab\n            float ood = 1.0f / r.d[i];\n            float t1 = (a.min[i] - r.a[i]) * ood;\n            float t2 = (a.max[i] - r.a[i]) * ood;\n         \n            // Make t1 be intersection with near plane, t2 with far plane\n            if (t1 > t2) {\n                float temp = t1;\n                t1=t2;\n                t2=temp;\n            }\n            // Compute the intersection of slab intersection intervals\n            if (t1 > tmin){ \n                tmin = t1;\n                normal = vec3(0.0f);\n                normal[i]=1.0f;\n            }\n            if (t2 < tmax) tmax = t2;\n            // Exit with no collision as soon as slab intersection becomes empty\n            if (tmin > tmax) return -1.0;\n        }\n    }\n// Ray intersects all 3 slabs. Return point (q) and intersection t value (tmin)\nreturn tmin;\n}\n//==============================================================================\n// Polyhedron Intersection\n//==============================================================================\n// Intersect segment S(t)=A+t(B-A), 0<=t<=1 against convex polyhedron specified\n// by the n halfspaces defined by the planes p[]. On exit tfirst and tlast\n// define the intersection, if any\nfloat polyhedronIntersect(in Ray r, in Polyhedron p, out vec3 normal)\n{\n    // Compute direction vector for the segment\n    vec3 d = r.d;\n    // Set initial interval to being the whole segment. For a ray, tlast should be\n    // set to +FLT_MAX. For a line, additionally tfirst should be set to –FLT_MAX\n    float tfirst = 0.0f;\n    float tlast = r.tMax;\n    // Intersect segment against each plane\n    for (int i = 0; i < p.n; i++) {\n        float denom = dot(p.p[i].n, d);\n        float dist = p.p[i].d - dot(p.p[i].n, r.a);\n        // Test if segment runs parallel to the plane\n        if (denom == 0.0f) {\n            // If so, return “no intersection” if segment lies outside plane\n            if (dist > 0.0f) return -1.0f;\n        } \n        else {\n            // Compute parameterized t value for intersection with current plane\n            float t = dist / denom;\n            if (denom < 0.0f) {\n                // When entering halfspace, update tfirst if t is larger\n                if (t > tfirst){\n                    tfirst = t;\n                    normal = p.p[i].n;\n                }\n            } \n            else {\n                // When exiting halfspace, update tlast if t is smaller\n                if (t < tlast){\n                    tlast = t;\n                }\n            }\n            // Exit with “no intersection” if intersection becomes empty\n            if (tfirst > tlast) return -1.0f;\n        }\n    }\n    // A nonzero logical intersection, so the segment intersects the polyhedron\n    return tfirst;\n}\n//==============================================================================\n// GroundPlane Intersection\n//==============================================================================\nfloat groundPlaneIntersect(Ray r, float gy, out vec3 normal){\n    normal = vec3(0,1,0);\n    float t = (gy-r.a.y) / r.d.y;\n    if(abs((t*r.d).x)>15.0||abs((t*r.d).z)>15.0){\n    return -1.0;}\n    return t;\n}\n//==============================================================================\n// Primitive Intersection\n//==============================================================================\nfloat primitiveIntersect(in Ray r, in Primitive p, out vec3 normal){\n    if(p.type == PRIMITIVE_SPHERE){\n        return sphereIntersect(r,p.sphere,normal);\n    }\n    else if (p.type == PRIMITIVE_TRIANGLE){\n        return triangleIntersect(r,p.triangle,normal);\n    }\n    else if (p.type == PRIMITIVE_AABB){\n        return aabbIntersect(r,p.aabb,normal);\n    }\n    else if (p.type == PRIMITIVE_POLYHEDRON){\n        return polyhedronIntersect(r,p.polyhedron,normal);\n    }\n    return -1.0;\n}\n\n\n\nvec3 raytraceStep(inout Ray ray)\n{\n    Primitive primitives[5];\n    //sphere\n    Material sphereMaterial = Material(vec3(1.0,0.0,0.0),vec3(0.9,0.9,0.9));\n    primitives[0]=CreateSpherePrimitive(vec3(0.75,0.75,1.0), 0.5,sphereMaterial);\n    //triangle\n    Material triangleMaterial = Material(vec3(0.8,0.4,0.0),vec3(0.4,0.4,0.4));\n    primitives[1]=CreateTrianglePrimitive(vec3(0.25,-0.25,1.0), vec3(1.25,-0.25,1.0),vec3(0.75,-1.25,1.0), triangleMaterial);\n    //aabb\n    Material aabbMaterial = Material(vec3(0.0,0.4,0.8),vec3(0.4,0.4,0.4));\n    primitives[2] = CreateAABBPrimitive(vec3(-1.25,0.25,2.0),vec3(-0.25,1.25,3.0), aabbMaterial);\n    //polyhedron\n    Plane planes[64];\n    \n    planes[0].n=vec3(0,0,1);\n    planes[1].n=vec3(0,0,-1);\n    planes[2].n=vec3(0,1,0);\n    planes[3].n=vec3(0,-1,0);\n    planes[4].n=vec3(1,0,0);\n    planes[5].n=vec3(-1,0,0); \n\n    planes[6].n=normalize(vec3(1.0,-1.0,1.0));\n    planes[7].n=normalize(vec3(1.0,1.0,1.0));\n    planes[8].n=normalize(vec3(-1.0,-1.0,1.0));\n    planes[9].n=normalize(vec3(-1.0,1.0,1.0));\n\n    planes[10].n=normalize(vec3(1.0,-1.0,-1.0));\n    planes[11].n=normalize(vec3(1.0,1.0,-1.0));\n    planes[12].n=normalize(vec3(-1.0,-1.0,-1.0));\n    planes[13].n=normalize(vec3(-1.0,1.0,-1.0));\n\n    vec3 polyhedronCubeMin = vec3(-1.25,-1.25,0.0);\n    vec3 polyhedronCubeMax = vec3(-0.25,-0.25,1.0);\n    planes[0].d=dot(planes[0].n,polyhedronCubeMax);\n    planes[1].d=dot(planes[1].n,polyhedronCubeMin);\n    planes[2].d=dot(planes[2].n,polyhedronCubeMax);\n    planes[3].d=dot(planes[3].n,polyhedronCubeMin);\n    planes[4].d=dot(planes[4].n,polyhedronCubeMax);\n    planes[5].d=dot(planes[5].n,polyhedronCubeMin);\n\n    float cornerStrength = 0.2;\n    planes[6].d=dot(planes[6].n,vec3(polyhedronCubeMax.x,polyhedronCubeMin.y,polyhedronCubeMax.z)+(cornerStrength*-planes[6].n));\n    planes[7].d=dot(planes[7].n,polyhedronCubeMax+(cornerStrength*-planes[7].n));\n    planes[8].d=dot(planes[8].n,vec3(polyhedronCubeMin.xy,polyhedronCubeMax.z)+(cornerStrength*-planes[8].n));\n    planes[9].d=dot(planes[9].n,vec3(polyhedronCubeMin.x,polyhedronCubeMax.yz)+(cornerStrength*-planes[9].n));;\n\n    planes[10].d=dot(planes[10].n,vec3(polyhedronCubeMax.x,polyhedronCubeMin.yz)+(cornerStrength*-planes[10].n));\n    planes[11].d=dot(planes[11].n,vec3(polyhedronCubeMax.xy,polyhedronCubeMin.z)+(cornerStrength*-planes[11].n));\n    planes[12].d=dot(planes[12].n,polyhedronCubeMin+(cornerStrength*-planes[12].n));\n    planes[13].d=dot(planes[13].n,vec3(polyhedronCubeMin.x,polyhedronCubeMax.y,polyhedronCubeMin.z)+(cornerStrength*-planes[13].n));;\n    \n    int n = 14;\n    Material polyhedronMaterial = Material(vec3(0.0,0.9,0.6),vec3(0.4,0.4,0.4));\n    primitives[3] = CreatePolyhedronPrimitive(planes,n,polyhedronMaterial);\n    \n    //objects in scene\n    vec3 color = vec3(0, 0, 0);\n    vec3 objColor = vec3(0, 0, 0);\n    vec3 specColor = vec3(0, 0, 0);\n    float t = ray.tMax;\n    vec3 normal;\n    float curT;\n    vec3 curNormal;\n    for(int i = 0; i<4; i++){\n        curT = primitiveIntersect(ray,primitives[i],curNormal);\n        if( curT > 0.0 && curT < t)\n        {\n            t = curT;\n            normal = curNormal;\n            objColor = primitives[i].material.Color;\n            specColor= primitives[i].material.Specular;\n        }\n    }\n    \n    //ground plane\n    float gy=-2.5;\n    curT = groundPlaneIntersect(ray, gy, curNormal);\n    bool groundPlane=false;\n    if( curT>0.0 && curT<t )\n    {\n        groundPlane=true;\n        t = curT;\n        normal = curNormal;\n    }\n    \n    \n    //calculating color\n    if (t < ray.tMax && t>-1.0) {\n        if(!groundPlane){\n            color = calculateLighting(objColor, specColor, normal,t,ray);\n        }\n        else{\n            color=vec3(0.8*gridTexture(4.0*(ray.a-vec3(sin(iTime)*2.0,0,0)+ray.d*t).xz));\n            ray.energy*=vec3(0.15);\n        }\n        ray.a = ray.a + ray.d*t + normal * EPSILON;\n        ray.tMax=ray.tMax-t;\n        ray.d = reflect(ray.d, normal);\n    } else {\n        ray.energy = vec3(0);\n        return texture(iChannel1, vec3(ray.d.xy,-ray.d.z)).xyz;\n    }\n\n    return color;\n}\n\n\nvec3 raytrace(in Ray ray)\n{\n    vec3 color = vec3(0, 0, 0);\n    \n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        color += ray.energy*raytraceStep(ray);\n        if (ray.energy == vec3(0)) {\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0, 0, 0);\n    vec3 ta = vec3( 0.0, 0.0, 1.0 );\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        for (int j = 0; j < AA_SAMPLES; j++) {\n            vec2 offset = vec2(float(j), float(i)) / float(AA_SAMPLES) - 0.5;\n            \n            vec2 p = (-iResolution.xy + 2.0*(fragCoord+offset))/iResolution.y;\n            \n            vec3 ro = vec3(sin(iTime)*CAMERA_X_SPEED, cos(iTime*CAMERA_Y_SPEED)*CAMERA_Y_SPEED, 5.0 ); // Position\n            \n\n            // camera matrix\n            vec3 ww = normalize( ta - ro );\n            vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n            vec3 vv =          ( cross(uu,ww));\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n            Ray ray = Ray(ro,rd,MAX,vec3(1));\n            color += raytrace(ray);\n        }\n    }\n    \n    color /= float(AA_SAMPLES*AA_SAMPLES);\n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PRIMITIVE_SPHERE 0\n#define PRIMITIVE_TRIANGLE 1\n#define PRIMITIVE_AABB 2\n#define PRIMITIVE_POLYHEDRON 3\n\nconst float PI = 3.14;\nconst float MAX=1e10;\nconst float EPSILON = 0.0001;\n\n\n\nstruct Material{\n    vec3 Color;\n    vec3 Specular;\n};\n\nstruct Ray{\n    vec3 a;\n    vec3 d;\n    float tMax;\n    vec3 energy;\n};\n\nstruct Sphere{\n    vec3 c;\n    float r;\n    Material m;\n};\nstruct Triangle{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    Material m;\n};\nstruct AABB{\n    vec3 min;\n    vec3 max;\n    Material m;\n};\nstruct Plane{\n    vec3 n;\n    float d;\n};\nstruct Polyhedron{\n    Plane[64] p;\n    int n;\n    Material m;\n};\n\nstruct Primitive{\n    int type;\n    Sphere sphere;\n    Triangle triangle;\n    AABB aabb;\n    Polyhedron polyhedron;\n    Material material;\n};\n\nPrimitive CreateSpherePrimitive(vec3 c, float r, Material m){\n    Primitive p;\n    p.type = PRIMITIVE_SPHERE;\n    Sphere s = Sphere(c,r,m);\n    p.sphere=s;\n    p.material=m;\n    return p;\n}\nPrimitive CreateTrianglePrimitive(vec3 a, vec3 b, vec3 c, Material m){\n    Primitive p;\n    p.type = PRIMITIVE_TRIANGLE;\n    Triangle t = Triangle(a,b,c,m);\n    p.triangle=t;\n    p.material=m;\n    return p;\n}\nPrimitive CreateAABBPrimitive(vec3 min, vec3 max, Material m){\n    Primitive p;\n    p.type = PRIMITIVE_AABB;\n    AABB a = AABB(min,max,m);\n    p.aabb=a;\n    p.material=m;\n    return p;\n}\nPrimitive CreatePolyhedronPrimitive(Plane planes[64], int n, Material m){\n    Primitive p;\n    p.type = PRIMITIVE_POLYHEDRON;\n    Polyhedron polyhedron = Polyhedron(planes,n,m);\n    p.polyhedron=polyhedron;\n    p.material=m;\n    return p;\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\nfloat ScalarTriple(in vec3 a, in vec3 b, in vec3 c){\n    return dot(cross(a,b),c);\n}\nfloat gridTexture( in vec2 p )\n{\n    p*=0.25;\n\tconst float N = 10.0; // grid ratio\n\n    // filter kernel\n    vec2 w = max(abs(dFdx(p)), abs(dFdy(p))) + 0.001;\n    //vec2 w = fwidth(p);\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n","name":"Common","description":"","type":"common"}]}