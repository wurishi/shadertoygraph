{"ver":"0.1","info":{"id":"XlBSRD","date":"1441820116","viewed":341,"name":"Simple spheres tracer","username":"d_nov","description":"My first shader here","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define TRACE_DEPTH 2\t// 1 = no traced reflection\n#define TIME iTime\n#define PI 3.1415926\n#define OBJECTS 9\n\nstruct Intersection\n{\n    vec3 p;\n    vec3 n;\n    float depth;\n    vec3 color;\n};\n    \nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Sphere\n{\n\tvec3 position;\n    float radius;\n    vec3 color;\n    int id;\n};\n\nSphere objects[OBJECTS];\n\nvec3 sun_color = vec3(2.0, 1.4, 0.9) * 1.5;\nvec3 sky_color = vec3(0.4, 0.7, 1.0);\nvec3 horizon_color = vec3(1.0, 1.1, 1.1) * 1.1;\nvec3 ground_color = vec3(0.3, 0.14, 0.04);\n\nfloat fresnel (vec3 rd, vec3 nrm, float _FresnelPower)\n{\n    float cos_a = max(dot(rd, nrm), 0.0);\n    float cos_b = sqrt(1.0 - (1.0 - cos_a*cos_a)/(_FresnelPower * _FresnelPower));\n    //float p_polar = abs((cos_b - _FresnelPower * cos_a) / (cos_b + _FresnelPower * cos_a));\n    float s_polar = abs((cos_a - _FresnelPower * cos_b) / (cos_a + _FresnelPower * cos_b));\n    return s_polar * s_polar;\n}\n\nfloat schlick_fresnel (vec3 rd, vec3 nrm, float _FresnelPower)\n{\n    float R0 = (1.0 - _FresnelPower) / (1.0 + _FresnelPower);\n    R0 = R0 * R0;\n    float cos_a = max(dot(rd, nrm), 0.0);\n    return R0 + (1.0 - R0) * pow((1.0 - cos_a), 5.0);\n}\n\nvoid init()\n{\n    objects[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.1, vec3(0.9, 0.9, 0.9), 0);\n    // upper\n    objects[1] = Sphere(vec3(1.2*sin(TIME/2.0), 0.8, -1.2*cos(TIME/2.0)), \t\t\t\t\t\t0.4, vec3(0.8, 1.0, 1.0), 1);\n    objects[2] = Sphere(vec3(1.2*sin(TIME/2.0 + PI), 0.8, -1.2*cos(TIME/2.0 + PI)), \t\t\t0.4, vec3(0.05, 0.05, 0.05), 2);\n    objects[3] = Sphere(vec3(1.2*sin(TIME/2.0 + PI * 0.5), 0.8, -1.2*cos(TIME/2.0 + PI * 0.5)), 0.4, vec3(1.0, 0.4, 0.4), 3);\n    objects[4] = Sphere(vec3(1.2*sin(TIME/2.0 + PI * 1.5), 0.8, -1.2*cos(TIME/2.0 + PI * 1.5)), 0.4, vec3(0.3, 0.4, 0.9), 4);\n    // lower\n\tobjects[5] = Sphere(vec3(1.2*sin(TIME/2.0), -0.8, -1.2*cos(TIME/2.0)), \t\t\t\t\t\t0.4, vec3(0.9, 0.2, 0.8), 5);\n    objects[6] = Sphere(vec3(1.2*sin(TIME/2.0 + PI), -0.8, -1.2*cos(TIME/2.0 + PI)), \t\t\t0.4, vec3(0.3, 0.8, 0.4), 6);\n    objects[7] = Sphere(vec3(1.2*sin(TIME/2.0 + PI * 0.5), -0.8, -1.2*cos(TIME/2.0 + PI * 0.5)), 0.4, vec3(0.1, 0.2, 0.2), 7);\n    objects[8] = Sphere(vec3(1.2*sin(TIME/2.0 + PI * 1.5), -0.8, -1.2*cos(TIME/2.0 + PI * 1.5)), 0.4, vec3(1.0, 0.01, 0.01), 8);    \n}\n\nvec3 sun_dir()\n{\n\treturn normalize(vec3(sin(TIME), 0.6, cos(TIME)));\n}\n\nvec3 blurred_background(vec3 rd)\n{\n    float sun = max(0.0, dot(rd, sun_dir()));\n    return mix(ground_color, sky_color, (dot(rd, vec3(0.0, 1.0, 0.0))*0.5 + 0.5)) +\n        0.24*pow(sun, 2.0)*sun_color;\n}\n\nvec3 background(vec3 rd)\n{\n\tfloat sun = max(0.0, dot(rd, sun_dir()));\n    float horizon = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0))) + max(0.0, dot(rd, vec3(0.0, -1.0, 0.0)));\n    horizon = 1.0 - horizon;\n    horizon = horizon*horizon; \n    return pow(sun, 256.0)*sun_color + mix(blurred_background(rd), horizon_color, horizon);\n}\n\nIntersection sphere(vec3 ray, vec3 dir, Sphere s)\n{ \n    Intersection pat;\n\tvec3 rc = ray - s.position;\n\tfloat c = dot(rc, rc) - (s.radius * s.radius);\n    float b = dot(dir, rc);\n    float d = b*b - c;\n    float t1 = -b - sqrt(abs(d));\n    float t2 = -b + sqrt(abs(d));\n    float t = min(t1, t2); // smaller positive root is the closest intersection\n\tfloat st = step(0.0, min(d, t));\n    pat.depth = mix(100.0, t, st);\n    \n    pat.p = ray + dir*pat.depth;\n    pat.n = normalize(pat.p - s.position);\n    pat.color = s.color;\n    return pat;\n}\n\n// sphere occlusion by IÑigo QuÐ½lez\nfloat sphOcclusion( vec3 pos, vec3 nor, Sphere s )\n{\n    vec3  r = s.position - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if (d < s.radius) {\n        res = pow(clamp((d + s.radius) / (2.0 * s.radius), 0.0, 1.0), 1.5) * s.radius;\n    }\n  \n    res = res * (s.radius * s.radius) / (l*l*l);\n    \n    res = clamp( res, 0.0, 1.0 );\n    \n    return res;\n}\n\nfloat occlusion( vec3 ro, vec3 rd )\n{\n\tfloat occ = 1.0;\n\tfor (int i = 0; i < OBJECTS; i++)\n    {\n\t    occ *= 1.0 - sphOcclusion( ro, rd, objects[i] ); \n    }\n    return occ;\t\t\t\t\t  \n}\n\nIntersection trace_scene(vec3 ro, vec3 rd)\n{ \n    Intersection pat;\n    Intersection closest_patch;\n    closest_patch.depth = 100.0;\n    \n    for (int i = 0; i < OBJECTS; i++)\n    {\n        pat = sphere(ro , rd, objects[i]);\n        if (pat.depth < closest_patch.depth) {\n            closest_patch = pat;\n        }\n    }\n    return closest_patch;\n}\n\n\nvec3 render(Ray r)\n{   \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float next_pass_intensity = 1.0;\n        \n    for (int i=0; i<TRACE_DEPTH; i++)\n    {\n        Intersection pat = trace_scene(r.ro, r.rd);\n\n        // No intersection\n        if (pat.depth > 99.0)\n        {\n            col += next_pass_intensity * background(r.rd);\n            return col;\n        }\n\n        // diffuse\n        float metallic_diff = max(dot(pat.n, sun_dir()), 0.0);\n        metallic_diff *= metallic_diff;\n\n        // light color & shadow\n        vec3 diff = 0.2 * sun_color * metallic_diff;\n        Intersection shadow_test = trace_scene(pat.p, sun_dir());\n        diff *= step (99.0, shadow_test.depth);\n\n        // ambient\n        vec3 ambient = blurred_background(pat.n);\n        ambient = ambient * occlusion( pat.p, pat.n );\n\n        //reflection\n        vec3 ref_dir = reflect(r.rd, pat.n);\n\n        // final\n        col += next_pass_intensity * pat.color * (diff + ambient);\n        \n        next_pass_intensity *= fresnel(ref_dir, pat.n, 1.9);\n        r.ro = pat.p;\n        r.rd = ref_dir;\n    }\n    \n    col += next_pass_intensity * background(r.rd);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(aspect, 1.0);\n      \n    init();\n    \n    Ray r;\n    r.ro = vec3(0.0, 0.0, -3.0);\n    r.rd = normalize(vec3(uv, 1.0));\n    \n    vec3 col = render(r);\n    \n    // glow\n    vec3 glow = blurred_background(r.rd);\n    col += glow*glow*glow / 2.0;\n\n    // exposure\n    float exposure = 1.0 - (sin(TIME - PI/2.0) * 0.5 + 0.5);\n    exposure = 1.0 - exposure*exposure;\n    col *= exposure * 0.4 + 0.3;\n    \n    // simple gamma correction \n    col = sqrt(col);\n    \n    // vignette\n    vec2 vig = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tcol = mix(col, col*col, dot(vig, vig)*0.5);\n    \n    // sky glow\n    float mask = fragCoord.y/iResolution.y;\n    col += vec3(0.15, 0.2, 0.25) * mask * mask;\n    \n    // grade\n    col = clamp(col, 0.0, 1.0);\n    //col = 3.0 * col * col - 2.0 * col * col * col;\n    col = mix(col, col*col, 0.5);\n    fragColor = vec4( col, 1.0 );\n    \n}","name":"Image","description":"","type":"image"}]}