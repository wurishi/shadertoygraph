{"ver":"0.1","info":{"id":"fdSXDV","date":"1621000145","viewed":556,"name":"Cook-Torrance BRDF","username":"jsimfors","description":"In this shader we have implemented the Rendering Equation, with Cook-Torrance BRDF, visualized in the classic Cornell Box.\n\nMade together with: GabrielR \nhttps://www.shadertoy.com/user/gabrielr","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["cornellbox","brdf","cooktorrance","renderingequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nRendering of a Cornell Box with global illumination. \nIn this shader we have implemented the Rendering Equation, \nwith Cook-Torrance BRDF, visualized in the classic Cornell Box.\n\nMade together with: GabrielR \nhttps://www.shadertoy.com/user/gabrielr\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Read the Buffer A texel\n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n\n    fragColor = vec4(sqrt(col),1.0);\n    //Apply gamma correction and write to main buffer\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Constant variables\n#define PI      3.141592653589793\n#define SAMPLES 2\n\n// Materials\nstruct material {\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float specular;\n\tfloat metalness;\n};\n\n// Planes\nstruct Plane {\n    vec3 p;\n    vec3 n;\n    material mat;\n};\n\n// Rays\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\n// Hittables\nstruct HitRecord {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material mat;\n};\n\n// Spheres\nstruct Sphere {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\n\n// To create the scene\nconst int NUM_SPHERES = 5;\nconst int NUM_PLANES = 5;\n\nSphere spheres[NUM_SPHERES];\nPlane planes[NUM_PLANES];\n\nvoid init_scene() {\n\n    // Light Sphere\n\tmaterial lightSurface;\n\tlightSurface.albedo = vec3(1.0);\n\tlightSurface.emission = vec3(70.0);\n\tlightSurface.roughness =1.0;\n\tlightSurface.specular = 1.0;\n\tlightSurface.metalness = 1.0;\n    spheres[0] = Sphere(vec3(0.0, 6.8, -2.0), 4.1, lightSurface);\n    \n    // Diffuse sphere\n\tmaterial diffuseSurface;\n\tdiffuseSurface.albedo = vec3(0.1, 0.1 ,0.10);\n\tdiffuseSurface.emission = vec3(0.0);\n\tdiffuseSurface.roughness = 0.9;\n\tdiffuseSurface.specular = 0.1;\n\tdiffuseSurface.metalness = 0.0;\n    spheres[1] = Sphere(vec3(1.3, -1.5, -2.2), 1.5, diffuseSurface);\n           \n    // Metal sphere\n\tmaterial metalSurface;\n\tmetalSurface.albedo = vec3(0.5, 0.5 ,0.5);\n\tmetalSurface.emission = vec3(0.0);\n\tmetalSurface.roughness = 1.0;\n\tmetalSurface.specular = 1.0;\n\tmetalSurface.metalness = 1.0;\n    spheres[2] = Sphere(vec3(0.0, -2.3, -0.8), 0.7, metalSurface);\n    \n    // Magenta metal sphere\n\tmetalSurface.albedo = vec3(1.0, 0.1 ,1.0);\n    spheres[3] = Sphere(vec3(-2.0, 1.3, -1.8), 0.9, metalSurface);\n    \n    // Cyan metal sphere\n\tmetalSurface.albedo = vec3(0.2, 1.0 ,1.0);\n    spheres[4] = Sphere(vec3(-1.5, -2.3, -3.0), 0.6, metalSurface);\n   \n    // Room material\n\tmaterial roomSurface;\n\troomSurface.albedo = vec3(0.8);\n\troomSurface.emission = vec3(0.0);\n\troomSurface.roughness = 1.0;\n\troomSurface.specular = 0.0;\n\troomSurface.metalness = 0.0;\n    \n\t// Floor\n    planes[0] = Plane(vec3(0.0, -3.0, 0.0), vec3(0,1,0), roomSurface);\n\n\t// Ceiling\n    planes[1] = Plane(vec3(0.0, 3.0, 0.0), vec3(0.0,-1.0,0.0), roomSurface);\n                     \n    // Back wall            \n    planes[2] = Plane(vec3(0, 0, -5), vec3(0,0,1.0), roomSurface);\n                      \n    // Left wall (red)\n\troomSurface.albedo = vec3(0.95, 0, 0);\n    planes[3] = Plane(vec3(-3, 0.0, 0.0), vec3(1.0,0.0,0.0), roomSurface);\n    \n    // Right wall (green)\n\troomSurface.albedo = vec3(0.0, 0.95, 0);\n    planes[4] = Plane(vec3(3.0, 0.0, 0.0), vec3(-1.0,0,0), roomSurface);\n}\n\n\n// -------------------------------------------------------------------------\n// Randoms\n// We have a applied these commonly used randomizer function from Shadertoy\n// Source: https://www.shadertoy.com/view/XtyyDy\n// -------------------------------------------------------------------------\n\nvec2 randState;\n\nfloat rand2D() {\n    randState.x = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n\n    return randState.x;\n}\n\nvec3 random_in_unit_sphere() {\n    // Returns a random direction in unit sphere (used in the BRDF)\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    // Change of variables \n    // Spherical Coordinates -> Carthesian Coordinates, to get (x, y, z) values \n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\n// -------------------------------------------------------------------------\n// Creating the BRDF (Bidirectional Reflective Distribution Function)\n// In this section we create our three functions that are used in the Cook-Torrance Reflectance Equation\n// These are: The Normal Distribution Function, The Geometry Function and The Fresnel Equation.\n// -------------------------------------------------------------------------\n\n// The Normal Distribution Function\nfloat DistributionGGX(vec3 N, vec3 H, float a) {\n    // N, normal of the surface\n    // H, halfway vector\n    // a, surface roughness\n    \n    // We are doing our approximations based on the Trowbridge-Reits GGX:\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    // The normal distribution function returns a value indicating how much o the surface's\n    // microfacets are aligned to the incoming halfway vector.\n    return nom / denom;\n}\n\n// The Geometry Function\nfloat GeometrySchlickGGX(float NdotV, float k) {\n    // NdotV, dot product between normal and direction of incoming light\n    // k, a remapping of the surface roughness, where:\n    // k = (surface roughness)^2/2, for IBL (image based lighting).\n    \n    // We are doing our approximations based on Schlick-GGX:\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\t\n    /* \n     The Geometry Function returns a value between 0 and 1 indicating where its \n     micro surface-details overshadows each other, causing light rays to be occluded. \n     This will affect how sharp the shadows of an object appears. \n    */\n    return ggx1 * ggx2;\n}\n\n// The Fresnel Equation\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    // cosTheta, the dot product between the surface's normal and the halfway vector.\n    // F0, vector describing the base reflectivity of the surface\n\n    /* \n     We are doing our approximation based on the Fesnel-Schlick:\n     The Fresnel Equtation describes the ration of light that gets reflected,\n     over the light that gets reflacted. \n    */\n    \n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nbool sphereIntersection(in Ray r,out HitRecord hit, float maxT) {\n    /* \n     Function used to find intersection between the traced ray and spheres.\n     r, the traced ray\n     hit, current hitrecod\n     maxT, largest distance\n    */\n    \n    float minT = 0.0001;\n    float currentT = maxT;\n    vec3 normal;\n    material mat;\n\n    for (int i = 0; i < spheres.length(); ++i) { // Loop through all spheres\n        // Code for ray-spehere intersection, the intersection is found by combining the equations and solve for t.\n        vec3 oc = r.orig - spheres[i].center; // Difference ray origin and sphere's center.\n        float a = dot(r.dir, r.dir);\n        float b = 2.0 * dot(oc, r.dir);\n        float c = dot(oc, oc) - spheres[i].radius * spheres[i].radius;\n        float det = b*b - 4.0*a*c;\n        float denominator = (2.0 * a);\n\n        // Possible intersection\n        if (denominator != 0.0 && det >= 0.0) {\n            float t1 = (-b - sqrt(det)) / denominator;\n            float t2 = (-b + sqrt(det)) / denominator;\n            float t = min(t1, t2);\n            if (minT < t && t < currentT) { \n                currentT = t;\n                normal = normalize(r.orig + t * r.dir - spheres[i].center);\n                mat = spheres[i].mat;\n            }\n        }  \n    }\n    if (currentT != maxT) {\n        hit.t = currentT;\n        hit.mat = mat;\n        hit.normal = normal;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool planeIntersection(in Ray r,out HitRecord hit, float maxT) {\n    /*\n    Checks for intersections with the plane obejcts in the scene.\n    Updates hit attribute with relevant information. \n    */\n    float minT = 0.0001;\n    float currentT = maxT;\n    vec3 normal;\n    material mat;\n    \n    for (int j = 0; j < planes.length(); ++j) {\n        vec3 p = planes[j].p;\n        vec3 n = planes[j].n;\n\n        float t = dot(p - r.orig, n) / dot(r.dir, n);\n        if (minT < t && t < currentT) {\n            currentT = t;\n            normal = n;\n            mat = planes[j].mat;\n        }\n    }\n    if (currentT < maxT) {\n        hit.t = currentT;\n        hit.mat = mat;\n        hit.normal = normal;\n        return true;\n    }\n    else\n        return false;\n}\n\n\nbool objectIntersection(in Ray r,out HitRecord hit, float maxT) {\n    /*\n    Sends a ray throught the scene and checks if any intersections occure.\n    If the ray intersects a object the hit attribute is update with relevant\n    information. \n    */\n    HitRecord hitTemp;\n    hit.t = maxT;\n    \n    bool rayIntersected = false;\n\n        // Sphere intersection\n    if (sphereIntersection(r, hitTemp, maxT)) {\n        hit = hitTemp;\n        rayIntersected = true;\n    }\n\n    // Plane intersection\n    if (planeIntersection(r, hitTemp, hit.t)) {\n        hit = hitTemp;\n        rayIntersected = true;\n    }\n    \n    return rayIntersected;\n}\n\nvec3 getReflection(Ray r, HitRecord hit) {\n    /*\n    Calculating the reflection direction based on the specular attribute of the material.\n    Either it is a perfect reflection (specular = 1), a perfect diffuse (specular = 0) or\n    something in between.\n    */\n    vec3 diffuseDir = normalize(hit.normal + random_in_unit_sphere());\n    vec3 specularDir = reflect(r.dir, hit.normal);\n\n    vec3 nextDir = mix(diffuseDir, specularDir, hit.mat.specular);\n    return normalize(nextDir);\n}\n\nvec3 BDRFcontribution(Ray firstRay, Ray secondRay, HitRecord firstHit, vec3 Li) {\n    /*\n    This function calculates the Cook-Torrance BRDF contribution at an intersection point. \n    We use the method described at https://learnopengl.com/PBR/Theory, which is the same \n    method of calculations as in Unreal Engine 4.\n    */\n\n    vec3 halfway = firstRay.dir + firstHit.normal;\n    float cosTheta = dot(secondRay.dir, firstHit.normal); // Angle between outgoing ray and surface normal\n            \n    float D = DistributionGGX(firstHit.normal, halfway, firstHit.mat.roughness); // The microfacet normals influence\n    \n    float k = (firstHit.mat.roughness * firstHit.mat.roughness) / 2.0; // Remapping of roughness for IBL\n    float G = GeometrySmith(firstHit.normal, -firstRay.dir, secondRay.dir, k); // The surface overshadowing\n    \n    vec3 F0 = vec3(0.04); // The reflectivity when looking at the surface at a 0 degrees angle\n    F0 = mix(F0, firstHit.mat.albedo, firstHit.mat.metalness); // More reflectivity depending on metalness\n    vec3 F = fresnelSchlick(cosTheta, F0); // The amount of reflectivity depending on viewing angle\n\n    vec3 numerator = D * G * F;\n    float denominator = (4.0 * max(dot(-firstRay.dir, firstHit.normal), 0.0) * max(dot(secondRay.dir, firstHit.normal), 0.0));\n    vec3 specular = numerator / max(denominator, 0.0001); \n\n    float NdotL = max(dot(secondRay.dir, firstHit.normal), 0.0);  \n    return ((1.0-firstHit.mat.specular) * (firstHit.mat.albedo / PI) + specular) * Li/float(SAMPLES) * NdotL;\n}\n\nvec3 traceRay(Ray primaryRay) {\n    /*\n    Traces primary ray in the scene and allows the ray to bounce up to 4 times.\n    The reflected light is approximated by calculating the sum of incoming light\n    which in turn is the sum of reflected light at the next ray intersections.\n    Depending on the SAMPLES-variable this function may take a long time to calculate\n    and might freeze your computer, therfore we recommend to use no value larger than 10.\n    */\n\n    float minT = 0.0001; // Minimum distance between ray origin and intersection\n    float maxT = 10e10; // Largest distance\n    \n    HitRecord primaryHit; // Struct for storing information about the intersection point\n  \n    // trace primary ray and see if we hit something       \n    vec3 L0 = vec3(0.0); // The total emitted and reflected light at the first intersection point\n    if (objectIntersection(primaryRay, primaryHit, maxT)) {\n\n        HitRecord secondHit;\n        secondHit.t = maxT;\n\n        for(int depth1 = 0; depth1 < SAMPLES; ++depth1) {\n            vec3 hitPoint = primaryRay.orig + primaryHit.t * primaryRay.dir;\n            vec3 nextDir = getReflection(primaryRay, primaryHit);\n            \n            Ray secondaryRay = Ray(hitPoint, nextDir);\n                  \n            vec3 L1 = vec3(0.0);\n            if(objectIntersection(secondaryRay, secondHit, maxT)) {\n                HitRecord thirdHit;\n                thirdHit.t = maxT;\n                \n                for(int depth2 = 0; depth2 < SAMPLES; ++depth2) {\n                    hitPoint = secondaryRay.orig + secondHit.t * secondaryRay.dir;\n                    nextDir = getReflection(secondaryRay, secondHit);\n                       \n                    Ray thridRay = Ray(hitPoint, nextDir);\n                    \n                    objectIntersection(thridRay, thirdHit, maxT);\n                    \n                    vec3 L2 = vec3(0.0);\n\t\t\t\t\tif(objectIntersection(thridRay, thirdHit, maxT)) {\n\t\t\t\t\t\tHitRecord fourthHit;\n                \t\tfourthHit.t = maxT;\n\n\t\t\t\t\t\tfor(int depth3 = 0; depth3 < SAMPLES; ++depth3) {\n\t\t\t\t\t\t\thitPoint = thridRay.orig + thirdHit.t * thridRay.dir;\n\t\t\t\t\t\t\tnextDir = getReflection(thridRay, thirdHit);\n\t\t\t\t\t\t\tRay fourthRay = Ray(hitPoint, nextDir);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tobjectIntersection(fourthRay, fourthHit, maxT);\n\n\t\t\t\t\t\t\tvec3 L3 = fourthHit.mat.emission;\n\t\t\t\t\t\t\tL2 += BDRFcontribution(thridRay, fourthRay, thirdHit, L3); // Adding Li sample contribution\n\t\t\t\t\t\t}\n\t\t\t\t\t\tL2 += thirdHit.mat.emission;\n\t\t\t\t\t}\n\t\t\t\t\tL1 += BDRFcontribution(secondaryRay, thridRay, secondHit, L2);\n                }\n                L1 += secondHit.mat.emission;\n            }\n            L0 += BDRFcontribution(primaryRay, secondaryRay, primaryHit, L1);\n        }\n        L0 += primaryHit.mat.emission;\n        primaryHit.t = maxT;\n    }\n\n    return L0;\n}\n\n\n\n// -------------------------------------------------------------------------\n// Frame accumulator\n// -------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Setting an initial random state for the fragment\n    randState = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    if (iFrame == 0) {\n        // Setting the color of the first frame to 0 to clear the buffer\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        // Image\n        // This method for creating the camera model is mainly taken from\n        // Peter Shirleys book called Ray Tracing in One Weekend.\n        float aspectRatio = iResolution.x / iResolution.y;\n        float imageWidth = 400.0;\n        float imageHeight = trunc(imageWidth / aspectRatio);\n\n        // Camera\n        float viewportHeight = 2.0;\n        float viewportWidth = aspectRatio * viewportHeight;\n        float focalLength = 10.5;\n\n        vec3 origin = vec3(0.0, 0.0, 8.0); // Camera center\n        vec3 horizontal = vec3(viewportWidth/aspectRatio, 0, 0);\n        vec3 vertical = vec3(0, viewportHeight, 0);\n        vec3 lowerLeftCorner = origin - horizontal/2.0 - vertical/2.0 - vec3(0.0, 0.0, focalLength);\n    \n        // Initalize the scene geometry\n        init_scene();\n        \n        // Calculate Ray\n        vec2 pixelSize = (1.0 / iResolution.xy);\n        vec2 randomJitter = vec2(rand2D(), rand2D());\n        vec2 jitter = vec2(pixelSize * (randomJitter - 0.5)); // Used in the direction of the primary ray for a nicer sampeling\n        \n        vec3 primaryRayDir = normalize(lowerLeftCorner * vec3(aspectRatio, 1.0, 1.0) + (uv.x + jitter.x) * horizontal * aspectRatio + (uv.y + jitter.y) * vertical);\n        Ray r = Ray(origin, primaryRayDir);\n        \n        // Trace primary ray in scene\n        vec3 pixelColor = traceRay(r);\n        \n        // Fetching the previous image frame\n        vec3 prev = texture(iChannel0, uv).xyz;\n\n        // Averaging the new frame together with the prevoius frame\n        vec3 new = (float(iFrame-1) * prev + pixelColor) / float(iFrame);\n        \n        // Output fragment color\n        fragColor = vec4(new, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}