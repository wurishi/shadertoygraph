{"ver":"0.1","info":{"id":"Dtcyz8","date":"1698863643","viewed":120,"name":"raymarched clouds","username":"lukasino1214","description":"volumetric clouds","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define PI 3.14159265359\n#define ABSORPTION_COEFFICIENT 0.9\n#define MAX_STEPS_LIGHTS 6\n#define MARCH_SIZE 0.16\n\nfloat beersLaw(float dist, float absorption) {\n    return exp(-dist * absorption);\n}\n\nfloat powderLaw(float dist, float absorption) {\n    return 1.0f - exp(-dist * 2.0f * absorption);\n}\n\nfloat beerPowderLaw(float dist, float absorption) {\n    return beersLaw(dist, absorption) * powderLaw(dist, absorption);\n}\n\nfloat sdSphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat noise( in vec3 x ) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  vec2 uv = (p.xy + vec2(37.0, 239.0) * p.z) + f.xy;\n  vec2 tex = textureLod(iChannel0, (uv+0.5) / 256.0, 0.0).yx;\n\n  return mix(tex.x, tex.y, f.z) * 2.0 - 1.0;\n}\n\nfloat fbm(vec3 p, bool lowRes) {\n  vec3 q = p + iTime * 0.5 * vec3(1.0, -0.2, -1.0);\n  float g = noise(q);\n\n  float f = 0.0;\n  float scale = 0.25;\n  float factor = 2.02;\n  int maxOctave = lowRes ? 3 : 6;\n\n  for (int i = 0; i < maxOctave; i++) {\n    f += scale * noise(q);\n    q *= factor;\n    factor += 0.21;\n    scale *= 0.5;\n  }\n\n  return f;\n}\n\nfloat scene(vec3 p, bool lowRes) {\n  \n  float dist = sdSphere(p, 1.0);\n\n  float f = fbm(p, lowRes);\n\n  return -dist + f;\n}\n\nconst vec3 SUN_POSITION = vec3(1.0, 0.0, 0.0);\n\nfloat HenyeyGreenstein(float g, float mu) {\n    float gg = g *g;\n    return (1.0 / (4.0 * PI))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));\n}\n\nfloat lightmarch(vec3 position, vec3 rayDirection) {\n  vec3 lightDirection = normalize(SUN_POSITION);\n  float totalDensity = 0.0;\n  float marchSize = 0.03;\n\n  for (int step = 0; step < MAX_STEPS_LIGHTS; step++) {\n      position += lightDirection * marchSize * float(step);\n\n      float lightSample = scene(position, true);\n      totalDensity += lightSample;\n  }\n\n  float transmittance = beersLaw(totalDensity, ABSORPTION_COEFFICIENT);\n  return transmittance;\n}\n\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection, float offset) {\n  float depth = 0.0;\n  depth += MARCH_SIZE * offset;\n  vec3 p = rayOrigin + depth * rayDirection;\n  vec3 sunDirection = normalize(SUN_POSITION);\n  \n  float totalTransmittance = 1.0f;\n  float lightEnergy = 0.0f;\n  float phase = mix(HenyeyGreenstein(0.8, dot(rayDirection, sunDirection)),\n                      HenyeyGreenstein(-0.5, dot(rayDirection, sunDirection)), 0.5);\n\n  vec4 res = vec4(0.0);\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float density = scene(p, false);\n\n    if (density > 0.0) {\n      float lightTransmittance = lightmarch(p, rayDirection);\n      float luminance = 0.025 + density * phase;\n\n      lightEnergy += totalTransmittance * luminance;\n      totalTransmittance *= lightTransmittance;\n    }\n\n    depth += MARCH_SIZE;\n    p = rayOrigin + depth * rayDirection;\n  }\n\n  return lightEnergy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv -= 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 ro = vec3(0.0, 0.0, 4.0);\n  vec3 rd = normalize(vec3(uv, -1.0));\n  \n  vec3 color = vec3(0.0);\n\n  vec3 sunColor = vec3(1.0,0.5,0.3);\n  vec3 sunDirection = normalize(SUN_POSITION);\n  float sun = clamp(dot(sunDirection, rd), 0.0, 1.0 );\n\n  color = vec3(0.5,0.5,0.90);\n  color -= 0.8 * vec3(0.90,0.75,0.90) * rd.y;\n  color += 0.5 * sunColor * pow(sun, 10.0);\n\n  float blueNoise = textureLod(iChannel1, fragCoord / 64.0, 0.0).r;\n  float res = raymarch(ro, rd, fract(blueNoise + float(iFrame%32) / sqrt(0.5)));\n  color = color + sunColor * res;\n\n  fragColor = vec4(color, 1.0);\n  //fragColor = vec4(1.0 - exp(-color), 1.0);\n}","name":"Image","description":"","type":"image"}]}