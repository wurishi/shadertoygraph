{"ver":"0.1","info":{"id":"tdl3DN","date":"1546391533","viewed":895,"name":"mountain terrain","username":"hchow","description":"rough shell for CS1230 final project. includes terrain generation using perlin noise and fog!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["terrain","mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float dMax = 10.0;\n\nfloat rand(vec2 p) {\t\n\treturn fract(sin(dot(p, vec2(12.231,64.102))) * 63360.01203);\n}\n\nfloat noise(vec2 p) {\n    float A = rand(vec2(floor(p.x), floor(p.y)));\n    float B = rand(vec2(floor(p.x) + 1.0, floor(p.y)));\n    float C = rand(vec2(floor(p.x), floor(p.y) + 1.0));\n    float D = rand(vec2(floor(p.x) + 1.0, floor(p.y) + 1.0));\n\n    float fc = fract(p.x);\n    float bicubicc = fc * fc * (3.0 - 2.0 * fc);\n\n    float fr = fract(p.y);\n    float bicubicr = fr * fr * (3.0 - 2.0 * fr);\n\n    float AB = mix(A, B, bicubicc);\n    float CD = mix(C, D, bicubicc);\n\n    float final = mix(AB, CD, bicubicr);\n\n    return final;\n}\n\n\nfloat heightmap(vec3 p) {\n    \n   \n    float dMin = dMax; // nearest intersection\n    float d; // depth\n    float material = -1.0; // material ID\n    \n    // adding octaves of height\n    float h = 0.0; // height\n    float w = 0.5; // octave weight\n    float m = 0.4; // octave multiplier\n    \n    //iterating through 10 octaves of height\n    for (int i=0; i < 9; i++) {\n        h += w * noise(p.xz * m);\n        w *= 0.5;\n        m *= 2.0;\n    }\n    \n    \n    //makes a more mountainous look\n    h += smoothstep(0.3, 1.0, h);\n    \n    d = p.y - h;\n    if (d<dMin) { \n        dMin = d;\n        material = 0.0;\n    }\n    \n    return dMin;\n}\n\n\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    const float marchDist = 0.001; // precision\n    float currHeight = 0.0; // distance\n    float nextStep = marchDist * 2.0; // step\n   \n    for (int i=0; i < 36; i++) {\n        if (abs(nextStep)> marchDist) {\n            currHeight += nextStep; // next step\n            float pos = heightmap(ro + rd * currHeight); // next intersection\n            nextStep = pos; // distance\n           \n        } else {\n            break;\n        }\n    }\n    return currHeight;\n}\n\n\n\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float x = heightmap(p - e.xyy) - heightmap(p + e.xyy);\n    float y = 2.0*epsilon;\n    float z = heightmap(p - e.yyx) - heightmap(p + e.yyx);\n    return normalize(vec3(x,y,z));\n}\n\nvec3 render( vec3 ro, vec3 rd ) {\n\n    //color of the sky\n    vec3 color = vec3(0.3,0.4,0.6);\n    float height = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 0.0));\n    vec3 world = ro + rd * height;\n    \n    \n    vec3 normal = calcNormal(world); // terrain normals\n    \n    \n    // color it like a mountain if it satisfies these heights\n    if (height < dMax) {\n        \n        // gray undertone of rock color\n        color = vec3(102.0) / 255.0;\n        \n        float slope = 1.0 - dot (normal, vec3 (0.0, 1.0, 0.0));\n        if (slope < 0.05){\n    \t\tcolor = mix(vec3(1.0, 1.0, 1.0), color, 0.15);\n    \t}\n        \n        //phong lighting model\n        float ambient = 0.4;\n        float diffuse = 2.25 * clamp(dot(normal, light), 0.0, 2.0);\n        float specular = pow(clamp(dot(rd, reflect(light, normal)), 0.0, 1.0), 32.0);\n     \n        color *= (ambient + diffuse);\n    }\n    \n    if (height > dMax){\n   \t\tfloat fog = exp(-0.005 * height * height); // exponential fog equation\n   \t\tcolor = mix(color, vec3(1.0), fog); // add fog in distance\n    }\n   \t\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = 2.0*(fragCoord/iResolution.xy) - vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float x = 0.0 + 16.0 + (0.5*iTime);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + 16.0 + sin(0.1*iTime);\n\tvec3 rayOrigin = vec3(x, y, z); // position;\n    rayOrigin.y = 0.4 * noise((rayOrigin.xz * 0.5)) + 1.5;\n    \n    const vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 target = vec3(0.0);\n    vec3 look = normalize(rayOrigin - target);\n    \n    \n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    \n    vec3 rayDirection = vec3(uv, 1.0);\n    rayDirection = normalize(rayDirection.x * cameraRight + rayDirection.y * cameraUp + rayDirection.z * cameraForward);\n    \n\n    vec3 color = render(rayOrigin, rayDirection);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}