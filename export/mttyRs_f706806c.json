{"ver":"0.1","info":{"id":"mttyRs","date":"1699558078","viewed":8,"name":"Amira Rabehi","username":"Amira","description":"Source code for ray-tracing assignment","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"DsKcRR","parentname":"Fork M1 - Ray t Amira 044"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform float time; // temps qui passe\nuniform vec2 resolution; // résolution de la fenêtre/texture\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 ka; // Composant ambiant\n    vec3 kd; // Composant diffus\n    vec3 ks; // Composant spéculaire\n    float ns; // Coefficient de brillance (shininess)\n    float reflectivity; // Coefficient de réflectivité\n};\n\n\n\nstruct Ellipsoid {\n    vec3 c;   // Centre de l'ellipsoïde\n    vec3 r;   // Rayons dans les directions x, y et z\n    int i;  // Identifiant de texture\n};\n\n\nstruct Cylindre {\n    vec3 baseCenter; // Centre de la base du cylindre\n    float radius;    // Rayon du cylindre\n    float height;    // Hauteur du cylindre\n    int i; // Identifiant de texture\n};\n\nstruct Capsule {\n    vec3 a; // Position de la première sphère\n    vec3 b; // Position de la deuxième sphère\n    float radius; // Rayon des sphères\n    int i; // Texture Id\n};\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n};\n\nstruct DirLight {\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Cube {\n    vec3 min;  // Minimum corner\n    vec3 max;  // Maximum corner\n    int i;\n};\n\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\nMaterial CheckeredTexture(vec3 p) {\n    // Définissez la taille de chaque case du damier\n    float size = 1.0;\n    vec2 pos = p.xz; // Utilisez la position x et z pour le damier 2D\n\n    // Calculez les coordonnées du damier\n    float checker = mod(floor(pos.x / size) + floor(pos.y / size), 2.0);\n\n    // Définir les propriétés matérielles pour les cases noires et blanches\n    vec3 diffuseBlack = vec3(0.1, 0.1, 0.1);\n    vec3 specularBlack = vec3(0.3);\n    float shininessBlack = 10.0;\n\n    vec3 diffuseWhite = vec3(0.9, 0.9, 0.9);\n    vec3 specularWhite = vec3(1.0);\n    float shininessWhite = 100.0;\n\n    if (checker < 1.0) {\n        // Case noire\n        return Material(vec3(0.1), diffuseBlack, specularBlack, shininessBlack, 0.0);\n    } else {\n        // Case blanche\n        return Material(vec3(0.1), diffuseWhite, specularWhite, shininessWhite, 0.8);\n    }\n}\nvec3 VolumetricCheckerTexture(vec3 p, float size) {\n    \n    float checker = mod(floor(p.x/size) + floor(p.y/size) + floor(p.z/size), 2.0);\n    return checker < 1.0 ? vec3(1) : vec3(0); // White and black checkers\n}\nvec3 ConcentricTexture(vec3 p, vec3 center, float frequency) {\n    float distance = length(p - center);\n    float colorValue = sin(frequency * distance);\n    return vec3(colorValue);\n}\n// Fonction pour générer des cercles concentriques\nvec3 concentricCircles(vec2 uv, vec2 center, float frequency, vec3 color1, vec3 color2) {\n    float distanceToCenter = distance(uv, center); // Calculer la distance au centre\n    float angle = atan(uv.y - center.y, uv.x - center.x); // Calculer l'angle par rapport au centre\n    float radialPattern = sin(distanceToCenter * frequency + angle); // Créer un motif radial en ajoutant l'angle\n    radialPattern = (radialPattern + 1.0) / 2.0; // Normaliser entre 0 et 1\n    \n    return mix(color1, color2, radialPattern); // Interpoler entre color1 et color2 basé sur radialPattern\n}\n\nvec3 RadialTexture(vec3 p, vec3 pointOnAxis, vec3 axisDirection, float frequency) {\n    p*=40.;\n    vec3 toPoint = p - pointOnAxis;\n    float distanceToAxis = length(cross(toPoint, axisDirection)) / length(axisDirection);\n    float colorValue = sin(frequency * distanceToAxis);\n    return vec3(colorValue);\n}\n// Fonction pour générer le bruit de Perlin\nfloat noise(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat fbm(vec2 uv) {\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < 4; i++) {\n        total += sin(uv.x * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nvec3 generateMarbleTexture(vec2 uv) {\n    float scale = .5; // Ajustez l'échelle pour changer la taille des veines du marbre\n    \n    // Génération de coordonnées de turbulence\n    float t = fbm(uv * scale );\n    \n    // Création de l'effet de marbre\n    float marbre = sin((uv.y * scale + t) * 2.0 * 3.14159);\n    marbre = (marbre + 3.) * 0.5; // Ajustez le contraste ici, remappez à l'intervalle [0,1]\n    \n    // Retourner la couleur calculée\n    return vec3(marbre);\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i) {\n    if(i == 1) {\n        return Material(vec3(0.2), vec3(.8, .5, .4), vec3(1.0), 50.0, 0.0);\n    } else if(i == 0) {\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.4, .5, .7) + f * vec3(.1);\n        return Material(vec3(0.1), col, vec3(0.5), 10.0, 0.0);\n    }\n    else if (i == 2) {\n        vec3 checkerColor = VolumetricCheckerTexture(p, 1.0);\n        return Material(vec3(0.9), checkerColor, vec3(0.8), 30.0, 0.0); // Checker texture\n    } \n    else if (i == 4) {\n        vec3 radialColor = RadialTexture(p, vec3(0), vec3(0, 1, 0), 1.0);\n        return Material(vec3(0.3), radialColor, vec3(0.9), 50.0, 0.0); // Radial texture\n    }\n    else if(i == 5) {\n        return Material(vec3(0.1), vec3(.8, .8, .8), vec3(1.0), 100.0, 0.8);\n    }\n    else if(i == 6) {\n        vec3 marbleColor = generateMarbleTexture(p.xy);\n        return Material(vec3(0.1), marbleColor, vec3(0.5), 10.0, 0.0);}\n    else if (i == 7) {\n        vec2 uv = p.xz;\n        vec2 center = vec2(0.5);\n        float frequency = 10.0;\n        vec3 color1 = vec3(1.0, 0.0, 4.0);\n        vec3 color2 = vec3(0.0, 0.0, 4.0);\n        vec3 concentricColor = concentricCircles(uv, center, frequency, color1, color2);\n        return Material(vec3(0.1), concentricColor, vec3(0.5), 10.0, 0.0);\n    }\n    else if (i == 8) { // Index pour la texture damier\n    return CheckeredTexture(p); // Retourne la texture damier\n}\n    return Material(vec3(0), vec3(0), vec3(0), 1.0, 0.0); // Default Material\n}\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectEllipsoid(Ray ray,Ellipsoid ellip,out Hit x)\n{\n    vec3 oc=ray.o-ellip.c;\n    oc = oc / ellip.r;\n    vec3 dir = ray.d / ellip.r;\n    \n    float a = dot( dir, dir );\n    float b = dot( oc, dir );\n    float c = dot( oc, oc );\n    float d = b*b - a*(c-1.0);\n    if(d>0.)\n    {\n        float t=(-b-sqrt(d))/a;\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-ellip.c),ellip.i);\n            \n            return true;\n        }\n    }\n    \n    return false;\n    \n}\n\n\nbool IntersectCylinder(Ray ray, Cylindre cyl, out Hit hit)\n{\n    float t_min = 1000.0;\n    vec3 n_min;\n    bool intersected = false;\n    ray.o -= cyl.baseCenter; \n    // Intersection avec les côtés du cylindre\n    vec2 d = ray.d.xz;\n    vec2 o = ray.o.xz;\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, o);\n    float c = dot(o, o) - cyl.radius * cyl.radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant >= 0.0)\n    {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float t1 = (-b - sqrtDiscriminant) / (2.0 * a);\n        float t2 = (-b + sqrtDiscriminant) / (2.0 * a);\n        float y1 = ray.o.y + t1 * ray.d.y;\n        float y2 = ray.o.y + t2 * ray.d.y;\n        \n        if (y1 >= 0.0 && y1 <= cyl.height && t1 < t_min)\n        {\n            t_min = t1;\n            n_min = normalize(vec3(2.0 * (ray.o.x + t1 * ray.d.x), 0.0, 2.0 * (ray.o.z + t1 * ray.d.z)));\n            intersected = true;\n        }\n        if (y2 >= 0.0 && y2 <= cyl.height && t2 < t_min)\n        {\n            t_min = t2;\n            n_min = normalize(vec3(2.0 * (ray.o.x + t2 * ray.d.x), 0.0, 2.0 * (ray.o.z + t2 * ray.d.z)));\n            intersected = true;\n        }\n    }\n\n    // Intersection avec les capuchons du cylindre\n    float tc1 = (-ray.o.y) / ray.d.y;\n    vec3 pc1 = ray.o + tc1 * ray.d;\n    if (length(pc1.xz) <= cyl.radius && tc1 < t_min)\n    {\n        t_min = tc1;\n        n_min = vec3(0.0, -1.0, 0.0);\n        intersected = true;\n    }\n\n    float tc2 = (cyl.height - ray.o.y) / ray.d.y;\n    vec3 pc2 = ray.o + tc2 * ray.d;\n    if (length(pc2.xz) <= cyl.radius && tc2 < t_min)\n    {\n        t_min = tc2;\n        n_min = vec3(0.0, 1.0, 0.0);\n        intersected = true;\n    }\n\n    if (intersected)\n    {\n        hit.t = t_min;\n        hit.n = n_min;\n        hit.i = cyl.i;\n    }\n\n    return intersected;\n}\n\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    x.t = 1000.0; \n\n    // Préparation du cylindre pour l'intersection\n    Cylindre cyl;\n    cyl.radius = capsule.radius;\n    cyl.height = length(capsule.b - capsule.a); // Définir la hauteur en se basant sur les points a et b de la capsule\n    cyl.i = capsule.i;\n    // Intersection avec le cylindre central\n    // Translation du rayon pour coïncider avec le cylindre au sein de la capsule\n    Ray translatedRay;\n    translatedRay.o = ray.o - capsule.a;\n    translatedRay.d = ray.d; \n\n    Hit hitCyl;\n    if (IntersectCylinder(translatedRay, cyl, hitCyl)) {\n        if (hitCyl.t < x.t) {\n            x = hitCyl;\n            if (dot(x.n, ray.d) > 0.0) { // S'assurer que la normale pointe vers l'extérieur\n                x.n = -x.n;\n            }\n        }\n    }\n\n    // Intersection avec les sphères aux extrémités de la capsule\n    Sphere sph1, sph2;\n    sph1.c = capsule.a; sph1.r = capsule.radius;\n    sph2.c = capsule.b; sph2.r = capsule.radius;\n\n    Hit hitSph;\n    if (IntersectSphere(ray, sph1, hitSph) && hitSph.t < x.t) {\n        x = hitSph;\n    }\n    if (IntersectSphere(ray, sph2, hitSph) && hitSph.t < x.t) {\n        x = hitSph;\n    }\n\n    if (x.t < 1000.0) {\n        x.i = capsule.i; // Assigne l'identifiant de texture de la capsule à la structure Hit\n    }\n    return x.t < 1000.0; // Retourner vrai si une intersection est trouvée\n}\n\n\nbool IntersectCube(Ray ray, Cube cube, out Hit x) {\n    float tmin = (cube.min.x - ray.o.x) / ray.d.x;\n    float tmax = (cube.max.x - ray.o.x) / ray.d.x;\n\n    if (tmin > tmax) {\n        float temp = tmin;\n        tmin = tmax;\n        tmax = temp;\n    }\n\n    float tymin = (cube.min.y - ray.o.y) / ray.d.y;\n    float tymax = (cube.max.y - ray.o.y) / ray.d.y;\n\n    if (tymin > tymax) {\n        float temp = tymin;\n        tymin = tymax;\n        tymax = temp;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return false;\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (cube.min.z - ray.o.z) / ray.d.z;\n    float tzmax = (cube.max.z - ray.o.z) / ray.d.z;\n\n    if (tzmin > tzmax) {\n        float temp = tzmin;\n        tzmin = tzmax;\n        tzmax = temp;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return false;\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    x.t = tmin;\n\n      // Calcul de la normale\n    vec3 normal = vec3(0);\n    float maxT = -1e10;\n\n    if (tmin == (cube.min.x - ray.o.x) / ray.d.x) {\n        maxT = tmin;\n        normal = vec3(-1, 0, 0);\n    }\n\n    if (tmin == (cube.max.x - ray.o.x) / ray.d.x && tmin > maxT) {\n        normal = vec3(1, 0, 0);\n    }\n\n    if (tmin == (cube.min.y - ray.o.y) / ray.d.y && tmin > maxT) {\n        maxT = tmin;\n        normal = vec3(0, -1, 0);\n    }\n\n    if (tmin == (cube.max.y - ray.o.y) / ray.d.y && tmin > maxT) {\n        normal = vec3(0, 1, 0);\n    }\n\n    if (tmin == (cube.min.z - ray.o.z) / ray.d.z && tmin > maxT) {\n        maxT = tmin;\n        normal = vec3(0, 0, -1);\n    }\n\n    if (tmin == (cube.max.z - ray.o.z) / ray.d.z && tmin > maxT) {\n        normal = vec3(0, 0, 1);\n    }\n\n    x.n = normal;\n    x.i = cube.i;\n    \n    return true;\n}\n\nvec3 Translate(vec3 point, vec3 translationVector) {\n    return point + translationVector;\n}\n\nvec3 Rotate(vec3 point, vec3 axis, float angle) {\n    axis = normalize(axis); \n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    mat3 identityMatrix = mat3(1.0); // Matrix identité\n\n    // Matrice de rotation autour d'un axe arbitraire\n    mat3 rotationMatrix = cosTheta * identityMatrix + (1.0 - cosTheta) * outerProduct(axis, axis) + sinTheta * mat3(0, axis.z, -axis.y, -axis.z, 0, axis.x, axis.y, -axis.x, 0);\n\n    return rotationMatrix * point;\n}\n\nvec3 Scale(vec3 point, vec3 scaleFactor) {\n    return point * scaleFactor;\n}\n// Fonction pour faire pivoter le rayon\nRay RotateRay(Ray ray, vec3 axis, float angle) {\n    Ray rotatedRay;\n    rotatedRay.o = Rotate(ray.o, axis, angle);\n    rotatedRay.d = Rotate(ray.d, axis, angle);\n    return rotatedRay;\n}\n\n// Fonction pour mettre à l'échelle le rayon\nRay ScaleRay(Ray ray, vec3 scaleFactor) {\n    Ray scaledRay;\n    scaledRay.o = Scale(ray.o, scaleFactor);\n    scaledRay.d = Scale(ray.d, scaleFactor); \n    return scaledRay;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n    const Sphere sph1 = Sphere(vec3(0., -5., 3.), 1., 7);\n    const Sphere sph2 = Sphere(vec3(-5., 2., 5.), 1., 5);\n    const Plane pl = Plane(vec3(0., 0., 3.), vec3(0., 0., 0.), 8);\n    const Ellipsoid ell = Ellipsoid(vec3(-1., 1., 3.), vec3(1., .5, .5), 4);\n    const Cylindre cyl = Cylindre(vec3(1., -2., 1.), 1., 4., 6); \n    const Capsule cap = Capsule(vec3(4., 0., 1.), vec3(4., 5., 1.), 0.5,6);\n    Ray transformedRay = RotateRay(ray, vec3(0., 1., 0.), radians(45.0));\n    Ray transformedRay2 = ScaleRay(ray, vec3(0.3, 0.5, 0.5));\n    vec3 newCenter = Translate(vec3(0., -5., 3.), vec3(2., 3., -1.));\n    Sphere sph3 = Sphere(newCenter, 1., 2);\n    float originalRadius = 1.0;\n    // Facteur d'échelle pour changer la taille de la sphère\n    float scaleFactor = 1.5;\n    // Application de l'homothétie au rayon de la sphère\n    float newRadius = originalRadius * scaleFactor;\n    // Définition de la sphère avec le nouveau rayon\n     Sphere sph4 = Sphere(vec3(0., -3., 3.), newRadius, 1);\n    \n//const Cube cube = Cube(vec3(3., 5., 3.), vec3(1., 1., 2.), 3);  \n\n\n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    if (IntersectSphere(ray, sph1, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph2, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n\n    // if (IntersectSphere(ray, sph3, current) && current.t < x.t)\n    // {\n    //     x = current;\n    //     ret = true;\n    // }\n    // if (IntersectSphere(ray, sph4, current) && current.t < x.t)\n    // {\n    //     x = current;\n    //     ret = true;\n    // }\n    if (IntersectEllipsoid(ray, ell, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    \n     if (IntersectEllipsoid(transformedRay, ell , current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n    }\n   \n    if (IntersectCapsule(ray, cap, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    // if (IntersectCube(ray, cube, current) && current.t < x.t) {\n    // x = current;\n    // ret = true;\n    // }\n\n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\n\n// Rendering\nvec3 Reflect(vec3 I, vec3 N) {\n    return I - 2.0 * dot(I, N) * N;\n}\n// Hemisphere direction\n\nvec3 Hemisphere(int seed,vec3 n)\n\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n    return d;\n}\nfloat AmbientOcclusion(vec3 p, vec3 n, int N)\n{\n    float ao = 0.0;\n    \n    for (int i = 0; i < N; i++)\n    {\n        vec3 d = Hemisphere(i, n); // Direction aléatoire dans l'hémisphère autour de la normale 'n'.\n\n        Hit x;\n\n        // Lancement d'un rayon depuis le point 'p' dans la direction 'd' pour voir s'il y a des obstacles.\n        if (!Intersect(Ray(p + n * 0.01, d), x))\n        {\n            ao += 1.0; // Increment si aucun objet n'est touché\n        }\n    }\n\n    return ao / float(N); // Moyenne des résultats pour obtenir la valeur d'occlusion ambiante.\n}\n\nvec3 Color(Material m, vec3 n, vec3 p, vec3 v)\n{\n    vec3 lightDir = normalize(vec3(1, 1, 4)); // Direction de la lumière\n    vec3 viewDir = normalize(v - p); // Direction de la vue\n\n    // Diffuse shading\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffColor = m.kd * diff;\n\n    // Specular shading\n    vec3 h = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(h, n), 0.0), m.ns);\n    vec3 specColor = m.ks * spec;\n\n    // // Ambient shading\n    // vec3 ambientColor = m.ka;\n\n    vec3 col =  diffColor + specColor; // Combine all components\n\n    // Shadow check\n    Hit osef;\n    if (Intersect(Ray(p + n * 0.001, lightDir), osef)) \n    {\n        col *= .5; // Réduisez la couleur dans l'ombre (vous pouvez ajuster ce facteur)\n    }\n\n    return col;\n}\n//Fonction color avec occlusion ambiante\n\n// vec3 Color(Material m, vec3 n, vec3 p, vec3 viewDir)\n// {\n//     vec3 lightDir = normalize(vec3(1, 1, 4)); // Direction de la lumière\n\n//     // Diffuse shading\n//     float diff = max(dot(n, lightDir), 0.0);\n//     vec3 diffColor = m.kd * diff;\n\n//     // Specular shading\n//     vec3 h = normalize(lightDir + viewDir);\n//     float spec = pow(max(dot(h, n), 0.0), m.ns);\n//     vec3 specColor = m.ks * spec;\n\n//     // Ambient shading\n//     vec3 ambientColor = m.ka;\n\n//     // Combine all components\n//     vec3 col = ambientColor + diffColor + specColor; \n\n//     // Shadow check\n//     Hit osef;\n//     if (Intersect(Ray(p + n * 0.001, lightDir), osef)) \n//     {\n//         col *= 0.5; // Réduisez la couleur dans l'ombre (vous pouvez ajuster ce facteur)\n//     }\n\n//     // Ambient Occlusion\n//     int AO_Samples =50; // Nombre d'échantillons pour l'occlusion ambiante\n//     float ao = AmbientOcclusion(p, n, AO_Samples);\n//     col *= ao; // Appliquez l'occlusion ambiante à la couleur\n\n//     return col;\n// }\n\nvec3 Shade(Ray ray)\n{\n    const int maxBounces = 5;\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 attenuation = vec3(1.0); // Commencez avec une atténuation pleine\n\n    for (int bounces = 0; bounces < maxBounces; bounces++)\n    {\n        Hit x;\n        bool hit = Intersect(ray, x);\n\n        if (hit)\n        {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.i);\n            vec3 localColor = Color(mat, x.n, p, ray.d);\n\n            accumulatedColor += attenuation * localColor * (1. - mat.reflectivity);\n\n            // Update attenuation for reflections\n            attenuation *= mat.reflectivity;\n\n            // If material has reflectivity, prepare the next ray\n            if (mat.reflectivity > 0.0) \n            {\n                ray.o = p + x.n * 0.01; // Petit décalage pour éviter l'auto-intersection\n                ray.d = Reflect(ray.d, x.n);\n            }\n            else \n            {\n                break; // Si le matériau n'est pas réfléchissant, arrêtez la boucle\n            }\n        }\n        else\n        {\n            accumulatedColor += attenuation * Background(ray.d);\n            break;\n        }\n    }\n\n    return accumulatedColor;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy + 2.*fragCoord.xy) / iResolution.y;\n    \n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Ray origin\n    vec3 ro = 12.*normalize(vec3(sin(2.*3.14*mouse.x), cos(2.*3.14*mouse.x), 1.4*(mouse.y - .1)));\n    vec3 ta = vec3(0., 0., 1.5);\n    mat3 ca = setCamera(ro, ta);\n    \n    // Ray\n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n    \n    // Render\n    vec3 col = Shade(Ray(ro, rd));\n    \n    fragColor = vec4(col, 1.);\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}