{"ver":"0.1","info":{"id":"dtdGW4","date":"1682466332","viewed":212,"name":"HDR Color Grading","username":"PKovachev","description":"Some stuff I was tinkering with in ENBSeries. Quite a bit of color space jumping.\n\nInspired by the talks of Alex Fry, Paul Malin and SandvichDISH's post on the ENB Forums.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["color","imageprocessing","contrast","saturation","hdr","tonemapping","tint","temperature","vibrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBSD 2-Clause License\n\nCopyright (c) 2023, Pavel Kovachev\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* PARAMETERS - I HAVE A LAPTOP WITH A 70% sRGB PANEL SO I CAN'T PROMISE THIS LOOKS ANY GOOD */\nconst float EExposure   = 0.2;                      /* F-Stops */\nconst float EMidGray    = 0.18;\nconst float EContrast   = 1.2;\nconst float ESaturation = 1.2;\nconst float EVibrance   = 0.2;\nconst int   ETemp       = 7700;                     /* COLOR TEMPERATURE IN DEGREES KELVIN, 6600 = WHITE */\nconst vec3  ETint       = vec3(0.9, 0.95, 0.9);     /* sRGB COLOR NORMALIZED TO 0-1 RANGE */\nconst float EDesat      = 1.0;                      /* FACTOR OF HIGHLIGHT DESATURATION */\nconst float ECurve      = 0.2;                      /* TONEMAPPER CURVE */\nconst float EShift      = 0.0;                      /* FACTOR OF HUE SHIFT DURING TONEMAPPING */\n\n/* LUMINANCE WEIGHTS */\n#define L709  vec3(0.2126, 0.7152, 0.0722)\n#define L2020 vec3(0.2627, 0.678,  0.0593)\n\n/* PRECOMPUTED LOGC4 PARAMETERS */\n#define LOGC_A    2231.8263090676883\n#define LOGC_B    0.9071358748778103\n#define LOGC_C    0.09286412512218964\n#define LOGC_S    0.1135972086105891\n#define LOGC_T    -0.01805699611991131\n\n/* PRECOMPUTED PQ PARAMETERS */\n#define PQ_C1   0.8359375\n#define PQ_C2   18.8515625\n#define PQ_C3   18.6875\n#define PQ_M1   0.159301758125\n#define PQ_M2   78.84375\n#define PQ_MAX  100.00\n\n\n/* R709 <-> R2020 MATRICES */\n/* https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.2087-0-201510-I!!PDF-E.pdf */\nconst mat3 m_r709_r2020 = mat3(\n    +0.6274,    +0.3293,    +0.0433,\n    +0.0691,    +0.9195,    +0.0114,\n    +0.0164,    +0.0880,    +0.8956);\n/* https://www.itu.int/dms_pub/itu-r/opb/rep/R-REP-BT.2407-2017-PDF-E.pdf */\nconst mat3 m_r2020_r709 = mat3(\n    +1.6605,    -0.5876,    -0.0728,\n    -0.1246,    +1.1329,    -0.0083,\n    -0.0182,    -0.1006,    +1.1187);\n\n/* R2020 <-> LMS MATRICES */\n/* https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf */\nconst mat3 m_r2020_lms = mat3(\n    +0.412109375,               +0.52392578125,            +0.06396484375,\n    +0.166748046875,            +0.720458984375,           +0.11279296875,\n    +0.024169921875,            +0.075439453125,           +0.900390625);\nconst mat3 m_lms_r2020 = mat3(\n    +3.4366066943330784267,     -2.5064521186562698975,    +0.069845424323191470954,\n    -0.79132955559892875305,    +1.9836004517922907339,    -0.19227089619336198096,\n    -0.025949899690592673413,   -0.098913714711726441685,  +1.1248636144023191151);\n\n/* LMS <-> ICTCP MATRICES */\nconst mat3 m_lms_ictcp = mat3(\n    +0.5,                       +0.5,                      +0.0,\n    +1.61376953125,             -3.323486328125,           +1.709716796875,\n    +4.378173828125,            -4.24560546875,            -0.132568359375);\n    \nconst mat3 m_ictcp_lms = mat3(\n    +1.0,                       +0.0086090370379327566,    +0.11102962500302595655,\n    +1.0,                       -0.0086090370379327566,    -0.11102962500302595655,\n    +1.0,                       +0.560031335710679118,     -0.32062717498731885184);\n \n\n/* COMMON FUNCTIONS */\nfloat min3(vec3 x)\n{\n\treturn min(x.x, min(x.y, x.z));\n}\nfloat max3(vec3 x)\n{\n\treturn max(x.x, max(x.y, x.z));\n}\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec4 saturate(vec4 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 con(vec3 x, float g, float c)\n{\n    return (x - g) * c + g;\n}\n\n/* https://github.com/CeeJayDK/SweetFX/blob/master/Shaders/Vibrance.fx */\nfloat vibrance(vec3 x, float v)\n{\n    float lo, hi, s;\n\n    lo = min3(x);\n    hi = max3(x);\n    s = hi - lo;\n    return 1.0 + (v * (1.0 - (sign(v) * s)));\n}\n\n/* COLOR SPACE CONVERSION */\nfloat lin_sRGB(float x)\n{\n    return x <= 0.0031308 ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055; \n}\nfloat sRGB_lin(float x)\n{\n\treturn x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 lin_sRGB3(vec3 x)\n{\n    x.r = lin_sRGB(x.r);\n    x.g = lin_sRGB(x.g);\n    x.b = lin_sRGB(x.b);\n    \n    return x;\n}\nvec3 sRGB_lin3(vec3 x)\n{\n    x.r = sRGB_lin(x.r);\n    x.g = sRGB_lin(x.g);\n    x.b = sRGB_lin(x.b);\n    \n    return x;\n}\n\n/* https://www.arri.com/resource/blob/278790/bea879ac0d041a925bed27a096ab3ec2/2022-05-arri-logc4-specification-data.pdf */\nfloat lin_LogC(float x)\n{\n    /* SKIPPING CONDITION CHECK SINCE SCENE COLOR IS ASSUMED POSITIVE */\n    return (log2(LOGC_A * x + 64.0) - 6.0) / 14.0 * LOGC_B + LOGC_C;\n}\n\nfloat LogC_lin(float x)\n{\n    return x < 0.0 ? x * LOGC_S + LOGC_T : (exp2(14.0 * (x - LOGC_C) / LOGC_B + 6.0) - 64.0) / LOGC_A;\n\n}\n\n/* IT'S LOGC4 BUT I'M BAD AT NAMING THINGS */\nvec3 lin_LogC3(vec3 x)\n{\n    x.r = lin_LogC(x.r);\n    x.g = lin_LogC(x.g);\n    x.b = lin_LogC(x.b);\n    \n    return x;\n}\nvec3 LogC_lin3(vec3 x)\n{\n    x.r = LogC_lin(x.r);\n    x.g = LogC_lin(x.g);\n    x.b = LogC_lin(x.b);\n    \n    return x;\n}\n\nfloat lin_PQ(float x)\n{\n    float p;\n\n    p = pow(x / PQ_MAX, PQ_M1);\n\n    return pow((PQ_C1 + PQ_C2 * p) / (1.0 + PQ_C3 * p), PQ_M2);\n}\n\nfloat PQ_lin(float x)\n{\n    float p;\n\n    p = pow(x, 1.0 / PQ_M2);\n\n    return pow(max(p - PQ_C1, 0.0) / (PQ_C2 - PQ_C3 * p), 1.0 / PQ_M1) * PQ_MAX;\n}\n\nvec3 lin_PQ3(vec3 x)\n{\n    x.r = lin_PQ(x.r);\n    x.g = lin_PQ(x.g);\n    x.b = lin_PQ(x.b);\n    \n    return x;\n}\n\nvec3 PQ_lin3(vec3 x)\n{\n    x.r = PQ_lin(x.r);\n    x.g = PQ_lin(x.g);\n    x.b = PQ_lin(x.b);\n    \n    return x;\n}\n\nvec3 r709_r2020(vec3 x)\n{\n    return x * m_r709_r2020;\n}\nvec3 r2020_r709(vec3 x)\n{\n    return x * m_r2020_r709;\n}\nvec3 r2020_lms(vec3 x)\n{\n    return x * m_r2020_lms;\n}\nvec3 lms_r2020(vec3 x)\n{\n    return x * m_lms_r2020;\n}\nvec3 lms_ictcp(vec3 x)\n{\n    return x * m_lms_ictcp;\n}\nvec3 ictcp_lms(vec3 x)\n{\n    return x * m_ictcp_lms;\n}\n\nvec3 r2020_ictcp(vec3 x)\n{\n    x = r2020_lms(x);\n    x = lin_PQ3(x);\n    x = lms_ictcp(x);\n\n    return x;\n}\nvec3 ictcp_r2020(vec3 x)\n{\n    x = ictcp_lms(x);\n    x = PQ_lin3(x);\n    x = lms_r2020(x);\n\n    return x;\n}\n\n/* https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html */\nvec3 k_rgb(int x)\n{\n    vec3 r0;\n    float t;\n\n    t = float(x) * 0.01;\n\n    if (t <= 66.0)\n    {\n        r0.r = 1.0;\n        r0.g = saturate(0.3900815787690196 * log(t) - 0.6318414437886275);\n    }\n    else\n    {\n        r0.r = saturate(1.292936186062745 * pow(t - 60.0, -0.1332047592));\n        r0.g = saturate(1.129890860895294 * pow(t - 60.0, -0.0755148492));\n    }\n    if (t >= 66.0)\n        r0.b = 1.0;\n    else\n    {\n        if (t <= 19.0)\n            r0.b = 0.0;\n        else\n            saturate(r0.b = 0.543206789110196 * log(t - 10.0) - 1.19625408914);\n    }\n    return r0;\n}\n\n/* TONEMAPPING FROM https://www.shadertoy.com/view/llSyRD WITH A FEW TWEAKS */\nfloat squish(float x)\n{\n\treturn 1.0 - exp(-x);\n}\nfloat tonemap(float x, float t)\n{\n\treturn (x < t) ? x : t + squish((x - t) / (1.0 - t)) * (1.0 - t);\n}\nvec3 tonemap3(vec3 x, float t)\n{\n\tx.r = tonemap(x.r, t);\n\tx.g = tonemap(x.g, t);\n\tx.b = tonemap(x.b, t);\n\treturn x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 r0, r1, r2;\n    vec3 t0, t1, t2;\n    vec2 uv;\n    float l0, l1;\n    \n    uv = fragCoord/iResolution.xy;\n    \n    r0 = texture(iChannel0, uv).rgb;\n    r0 = sRGB_lin3(r0);\n    r0 = r709_r2020(r0);\n    r0 *= 1.0 + r0;   /* PSEUDO HDR SINCE IDK HOW TO LOAD AN HDR IMAGE, DON'T COPY PASTE THIS */\n    r0 *= exp2(EExposure);\n    \n    t0 = k_rgb(ETemp);\n    t0 = sRGB_lin3(t0);\n    t0 = r709_r2020(t0);\n    \n    t1 = ETint;\n    t1 = sRGB_lin3(t1);\n    t1 = r709_r2020(t1);\n    \n    /* HACKY BUT CHEAP WAY TO PRESERVE LUMINANCE WITHOUT JUMPING MORE COLOR SPACES */\n    r0 *= t0 / ((t0.r + t0.g + t0.b) * 0.3333333333333333);\n    r0 *= t1 / ((t1.r + t1.g + t1.b) * 0.3333333333333333);\n    \n    r0 = lin_LogC3(r0);\n    r0 = con(r0, EMidGray, EContrast);\n    r0 = LogC_lin3(r0);\n    \n    r1 = r2020_ictcp(r0);\n    r1.yz *= ESaturation;\n    r1.yz *= vibrance(r0, EVibrance);\n    r2 = ictcp_r2020(r1);    /* EARLY EXIT FOR PER-CHANNEL TONEMAPPING LATER */\n    r1.yz *= 1.0 - (1.0 - exp2(dot(r0, L2020) * -EDesat));\n    r0 = ictcp_r2020(r1);\n\n    l0 = max3(r0);\n    l1 = tonemap(l0, ECurve);\n    r0 *= l1 / l0;\n    r0 = mix(r0, tonemap3(r2, ECurve), EShift);\n    \n    r0 = saturate(r2020_r709(r0));\n    r0 = lin_sRGB3(r0);\n    fragColor = vec4(r0, 1.0);\n}","name":"Image","description":"","type":"image"}]}