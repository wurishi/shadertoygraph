{"ver":"0.1","info":{"id":"3stBDN","date":"1605283768","viewed":192,"name":"Ray Marching (Demo)","username":"acohale97","description":"Just a good time with some ray marching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 90\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n#define INF 200\n#define RECURSIONS 4\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3  di = abs(p) - b;\n    float mc = max(di.x,max(di.y,di.z));\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross ( vec3 p) {\n    float da = sdBox(p.xyz,vec3(INF,1.0,1.0));\n    float db = sdBox(p.yzx,vec3(1.0,INF,1.0));\n    float dc = sdBox(p.zxy,vec3(1.0,1.0,INF));\n    \n    return min(da, min(db, dc));\n}\n\nfloat transform ( vec3 r, float scale ) {\n    float da = max(r.x,r.y);\n    float db = max(r.y,r.z);\n    float dc = max(r.z,r.x);\n    float c = (min(da,min(db,dc))-1.0)/(2. * scale);\n    \n    return c;\n}\n\nfloat GetDist ( in vec3 p )\n{\n    float boxDist = sdBox(p, vec3(1.0));\n    float scale = 0.5;\n    for( int i = 0; i < RECURSIONS; i++ ) {\n        vec3 a = fract( p*scale )-.5;\n        scale *= 3.;\n        vec3 r = abs(1.-6.*abs(a));\n        float dist = transform(r, scale); \n\n        if( dist > boxDist ) {\n          boxDist = dist;\n        }\n    }\n    return boxDist;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++) {\n    \tvec3 point = (ro + rd * d0);\n        float ds = GetDist(point);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    \n    return d0;\n}\n\nvec3 GetNormal (vec3 point) {\n    float dist = GetDist(point);\n    vec2 x = vec2(SURFACE_DIST, 0);\n    \n    vec3 normal = dist - vec3(\n        GetDist(point - x.xyy),\n        GetDist(point - x.yxy),\n        GetDist(point - x.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight (vec3 point) {\n    // Create Light\n\tvec3 lightPosition = vec3(0, 2, -2);\n    //lightPosition.xz += vec2(sin(iTime), cos(iTime))*2.;\n    \n    vec3 lightVector = normalize(lightPosition - point);\n    vec3 normal = GetNormal(point);\n    float diff = clamp(dot(lightVector, normal), 0., 1.);\n    \n    // Shadows\n\t//float shadowDistance = RayMarch(point + normal * SURFACE_DIST , vec3(1));\n    //if (shadowDistance < length(lightPosition - point)){\n\t//\tdiff *= 0.1;        \n    //}\n\n    return diff;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Camera\n    vec3 ray_origin = 5.5 * vec3( sin(iTime * 0.25), .1, cos(iTime * 0.25) );\n    \n    vec3 ta = vec3( 0.0, 0., 0.0 );\n    \n    mat3 ca = setCamera( ray_origin, ta, 0.0 );\n    vec3 ray_distance = ca * normalize( vec3(uv.xy,2.0) );\n    \n    \n    // Ray March\n    float dist = RayMarch (ray_origin, ray_distance);\n\n    // Lighting\n    vec3 point = ray_origin + ray_distance * dist;\n    float diff = GetLight(point);\n    col = vec3(diff);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}