{"ver":"0.1","info":{"id":"DsyfWK","date":"1698651887","viewed":64,"name":"000Tool:Const-Thickness Graph2.0","username":"foodini","description":"I wanted to make this a useful tool to anyone who wanted to just copy-paste it. See comments for details.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["function"],"hasliked":0,"parentid":"msyfRK","parentname":"000Tool:Const-Thickness Graph1.1"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe purpose of this shader is to create a tool that anyone can use to\ndraw graphs. I may change the interface to allow for drawing arbitrary\ncurves by just handing down the list of segments of the graph to draw,\nbut I don't really have a need for that at the moment, so it may be\na while.\n\nI could have gotten a better result if I'd used a Buffer to draw a\nsingle-pixel-wide curve, then used a second pass to expand the line to\nhowever many pixels of width I wanted. This would limit me to very few\ncurves, and I want to be able to draw as many as I like. Also it would\nhave made it much harder for people to steal it and use it for their\nown stuff..... which is kinda the point of me putting this out there.\n\nTo use it, copy everything from the Common tab down to (but excluding)\nthe FONTS comment. If you want font rendering in your stuff, use the\nlatest version of that tool, which is at:\n\n            https://www.shadertoy.com/view/XlGfzt\n\nThe idea is is fairly simple. Define your own f0, f1, f2, etc., in\nCommon (see the examples there). Call create_graph with the following\narguments;\n* a vec2 with the x-width and y-height of the graph space. If you are\n  rendering a single of a sin wave, you'd use (2.0*PI, 2.0)\n* a vec2 with your screenspace height and width. It is important that\n  you use PIXEL SPACE, not a uv space here. It is otherwise impossible\n  to do good antialiasing, so the renderer explicitly loops over\n  pixels. The only reason to pass anything but iResolution.xy here is\n  if you want your graph to take up a subsection of the full screen.\n* The \"anchor point\" in graph space. The next argument is the anchor\n  in screen space. A curve that renders at the graphspace anchor point\n  will show on screen at the screenspace anchor point. The two points\n  coincide. This allows you to move your origins about however you\n  like. The graphspace anchor point is where the origin of your grid\n  lines will be. There's nothing that says your anchor points have to\n  exist within the viewable area.\n* The \"anchor point\" in screen space. See above.\n* The \"heavy\" gridline interval. Let's say we're drawing a graph\n  with three full cycles of the sin wave and we want a \"heavy\" grid\n  line drawn every horizontal full cycle and one at -1 and +1. You'd\n  use vec2(2.0*PI, 2.0);\n* The \"light\" gridline inteval. For the same graph mentioned in the\n  doc on \"heavy\" gridlines, maybe we want four light gridlines per\n  horizontal cycle, and four per vertical unit: vec2(PI/2.0, 0.25)\n\n\nWARNINGS/NOTES!\n\nNote that the complexity of rendering is necessarily tied to the how\nthick your lines are. I can't see why someone would draw curves that\nare hundreds of pixels wide, but it will cost a lot of draw time.\n\nWe're dealing with floating point numbers. Watch what happens in this\ndemo as time goes by. We go from nice smooth renders to a lot of\nnoise and jitter. This is because we're doing a lot of multiplying\nof large numbers and small numbers and introducing a painful amount\nof error in our results. You're better off altering your functions\nto move around within a graph space that is near the floating point\norigin if you want to avoid this noise.\n\n\n*/\n\nfloat last_wave_node_time(float t) {\n    float past_cycles = t * fundamental_freq;\n    past_cycles -= fract(past_cycles);\n    return past_cycles / fundamental_freq;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // It's important to move the graph space along at about the\n    // same rate as the cycles of the wave go by. Otherwise, you\n    // get what looks like random oscilloscope noise. Try setting\n    // x0 to iTime and you'll see what I mean.\n    float x0 = last_wave_node_time(iTime);\n    \n    create_graph(\n        vec2(0.05, 2.25), iResolution.xy, \n        vec2(x0, 0.0), vec2(100.5, iResolution.y/2.0),  \n        vec2(0.02, 1.0), vec2(0.005, 0.25));\n\n    fragColor = draw_grid(fragCoord);\n    \n    set_line_color(vec4(1.0, 0.0, 0.0, 0.0));\n    set_line_width(6.0);\n    fragColor += draw_curve(fragCoord, 0); \n\n    set_line_color(vec4(0.0, 0.0, 1.0, 0.0));\n    set_line_width(4.0);\n    fragColor += draw_curve(fragCoord, 1); \n\n    set_line_color(vec4(0.0, 1.0, 0.0, 0.0));\n    set_line_width(2.0);\n    fragColor += draw_curve(fragCoord, 2); \n\n    init_printing(vec2(15.0), 15.0);\n    fragColor += print(iChannel0, iResolution.x, fragCoord, 1).xxxx;\n    fragColor += print(iChannel0, int[](_SPACE), fragCoord).xxxx;\n    fragColor += print(iChannel0, iResolution.y, fragCoord, 1).xxxx;\n    fragColor += print(iChannel0, int[](_SPACE), fragCoord).xxxx;\n    fragColor += print(iChannel0, iFrameRate, fragCoord, 1).xxxx;\n    \n    vec2 v2 = to_graphspace(vec2(200.5, iResolution.y/3.0));\n    fragColor += print(iChannel0, int[](_LFTANGL), fragCoord).xxxx;\n    fragColor += print(iChannel0, screenspace_to_graphspace_scale.x, fragCoord, 5).xxxx;\n    fragColor += print(iChannel0, int[](_COMMA), fragCoord).xxxx;\n    fragColor += print(iChannel0, screenspace_to_graphspace_scale.y, fragCoord, 5).xxxx;\n    fragColor += print(iChannel0, int[](_RGTANGL), fragCoord).xxxx;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \nConst-thicknes Graph Drawing. Version 2.0.1  2023.11.03 foodini@shadertoy\nUse freely, but please keep this line and the version line.\n\n\nNew in 2.0.1:\nReplaced the dist-from-segment check with one that requires no branches.\n\nNew in 2.0:\n\nI did away with the old rendering method. It depended upon computing a y-value\nat each x location and checking to see if that value was close enough to the \npixel's y value. There were some tricks in there, like checking to see if the\ngraph had crossed from being below the pixel to above it, but that had limited\nimpact and wasn't antialiasable.\n\nThis graph has antialiased lines. I may tinker with the AA width a bit, but\nI like the effect at the moment. Any wider, and 2-pixel-wide curves will look\nvery strange when very steep.\n\n*/\n\nconst float fundamental_freq = 220.0;\n\n/*\n         MAKE YOUR OWN f0, f1, f2, etc., and alter call_func to include them all!\n*/\n\nfloat f0(float t) {\n    return 0.5 * sin(3.14159265 * 2.0 * fundamental_freq * t);\n}\n\nfloat f1(float t) {\n    return f0(t) + 0.25 * sin(3.14159265 * 2.0 * fundamental_freq * t * 2.001);\n}\n\nfloat f2(float t) {\n    return f1(t) + 0.125 * sin(3.14159265 * 2.0 * fundamental_freq * t * 4.001);\n}\n\nfloat call_func(float t, int func_id) {\n    switch(func_id) {\n        case 0:\n            return f0(t);\n        case 1:\n            return f1(t);\n        case 2:\n            return f2(t);\n    }\n}\n\n\nvec2 screenspace_anchorpoint;\nvec2 graphspace_anchorpoint;\nvec2 screenspace_to_graphspace_scale;\n\nvec2 heavy_gridspacing, ss_heavy_gridspacing;\nvec2 light_gridspacing, ss_light_gridspacing;\nfloat dx, dy;\n\nfloat line_width = 2.0;\nfloat half_line_width = 1.0;\nvec4 line_color;\n\n//I tried doing this with 3d matrices, but the floating point error creep\n//was murder.\nvec2 to_graphspace(vec2 screenspace_coords) {\n    return (screenspace_coords - screenspace_anchorpoint) \n           * screenspace_to_graphspace_scale\n           + graphspace_anchorpoint;\n}\n\nvec2 to_screenspace(vec2 graphspace_coords) {\n    return (graphspace_coords - graphspace_anchorpoint) \n           / screenspace_to_graphspace_scale\n           + screenspace_anchorpoint;\n}\n\nvoid create_graph(vec2 graphspace_dimensions, vec2 screenspace_dimensions, \n                  vec2 graphspace_anchor, vec2 screenspace_anchor, \n                  vec2 heavy_spacing, vec2 light_spacing) {\n    screenspace_to_graphspace_scale = graphspace_dimensions/screenspace_dimensions;\n    \n    vec2 gs0 = to_graphspace(vec2(0.0));\n    vec2 gs1 = to_graphspace(vec2(1.0));\n    dx = gs1.x-gs0.x;\n    dy = gs1.y-gs0.y;\n    screenspace_anchorpoint = screenspace_anchor;\n    graphspace_anchorpoint = graphspace_anchor;\n    heavy_gridspacing = heavy_spacing;\n    light_gridspacing = light_spacing;\n    ss_heavy_gridspacing = heavy_gridspacing / graphspace_dimensions * screenspace_dimensions;\n    ss_light_gridspacing = light_gridspacing / graphspace_dimensions * screenspace_dimensions;\n}\n\n\n// Nothing narrowing that 2.0 is going to work well. Keep it reasonable. A\n// width of 100.0 is going to take forever to render. and it's going to look\n// like crap anyway.\nvoid set_line_width(float lw) {\n    line_width = lw;\n    half_line_width = lw/2.0;\n}\n\nvoid set_line_color(vec4 c) {\n    line_color = c;\n}\n\nvec4 draw_grid(vec2 input_screenspace) {\n    // I could use any place in space as my zero, but I might as\n    // well go where the world is familiar:\n    vec2 gs0 = to_graphspace(screenspace_anchorpoint).xy;\n    vec2 gs1 = gs0 + vec2(dx, dy);   \n    vec2 ss1 = to_screenspace(gs1).xy;\n    // TODO: we're computing this in multiple locations. Just pass\n    // fragCoord to create_graph, compute and cache all the dys, dxs,\n    // input_graphspace, etc.\n    vec2 input_graphspace = to_graphspace(input_screenspace).xy;\n        \n    if(input_screenspace.x - screenspace_anchorpoint.x <= 1.5 &&\n       input_screenspace.x - screenspace_anchorpoint.x > -1.5\n       ||\n       input_screenspace.y - screenspace_anchorpoint.y <= 1.5 &&\n       input_screenspace.y - screenspace_anchorpoint.y > -1.5) {\n        return vec4(0.8);\n    }\n    \n    if(ss_heavy_gridspacing.x != 0.0 && ss_heavy_gridspacing.y != 0.0) {\n        vec2 mod_xy = mod(abs(input_screenspace - ss_heavy_gridspacing - screenspace_anchorpoint), ss_heavy_gridspacing);\n        if(mod_xy.x <= 1.01 || mod_xy.x > ss_heavy_gridspacing.x - 1.0 ||\n           mod_xy.y <= 1.001 || mod_xy.y > ss_heavy_gridspacing.y - 1.0) {\n            return (vec4(0.65));\n        }\n    }\n\n    if(ss_light_gridspacing.x != 0.0 && ss_light_gridspacing.y != 0.0) {\n        vec2 mod_xy = mod(abs(input_screenspace - ss_light_gridspacing - screenspace_anchorpoint), ss_light_gridspacing);\n        if(mod_xy.x <= 0.501 || mod_xy.x > ss_light_gridspacing.x - 0.5 ||\n           mod_xy.y <= 0.501 || mod_xy.y > ss_light_gridspacing.y - 0.5) {\n            return (vec4(0.5));\n        }\n    }\n\n    return vec4(0.0);\n}\n\nfloat dist_from_segment(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float len_ab = length(ab);\n    float h = min(1.0, max(0.0, dot(ap, ab)/(len_ab*len_ab)));\n    return length(p - (a + h*ab));\n}\n\nvec4 draw_curve(vec2 input_screenspace, int func_id) {\n    vec2 input_graphspace = to_graphspace(input_screenspace);\n\n    vec2 previous_ss;\n    vec2 previous_gs;\n    vec2 current_ss;\n    vec2 current_gs;\n    bool first_time = true;\n    float best = 0.0;\n    for(current_ss.x = input_screenspace.x - half_line_width - 1.0;\n        current_ss.x <= input_screenspace.x + half_line_width;\n        current_ss.x += 1.0) {\n        \n        // Only current_ss.x is now valid as of this comment.\n        current_gs   = to_graphspace(current_ss);\n        // current_ss.x and current_gs.x are valid\n        current_gs.y = call_func(current_gs.x, func_id);\n        // current_ss.x and current_gs.xy are valid\n        current_ss.y = to_screenspace(current_gs).y;\n        // current_ss.xy and current_gs.xy are valid\n        \n        if(!first_time) {\n            float dist = dist_from_segment(previous_ss, current_ss, input_screenspace);\n            if(dist < half_line_width) {\n                if(dist < half_line_width - 0.5) {\n                    return line_color;\n                }\n                //Antialias the last pixel. Scale the last half line width from\n                //0.0 to 1.0. Note that current_ss might have an antialiased value\n                //on this segment test, but may have a higher antialias value when\n                //testing a later segment, so store the highest result for later\n                //return\n                float falloff = 1.0 - (dist - (half_line_width - 0.5)) * 2.0;\n                best = max(best, falloff);\n            }\n        }\n        \n        previous_ss = current_ss;\n        previous_gs = current_gs;\n        first_time = false;\n    }\n\n    return line_color * best;\n}\n\n\n    \n\n\n\n/*\nd88888b  .d88b.  d8b   db d888888b .d8888.\n88'     .8P  Y8. 888o  88 `~~88~~' 88'  YP\n88ooo   88    88 88V8o 88    88    `8bo.\n88~~~   88    88 88 V8o88    88      `Y8b.\n88      `8b  d8' 88  V888    88    db   8D\nYP       `Y88P'  VP   V8P    YP    `8888Y'\n\n\nVersion 1.0, 2023.10.23\n\n\n\n*/\n\n//TODO:\n//* Have the float's width take an ivec2 in printf %5.12f fashion.\n//* Tab should take the tab width (tab(4) should tab to an every-4 stop)\n\n#define DC(name, val) const int name = val\n\n\nDC(_NULL,127); //I may want as non-null since the font has a character there.\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\n\n\n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    //This took me a while to get my brain around: uv and char_pos are in the same\n    //vector space. What that space is is irrelevant. It can be fragCoord, a\n    //square-pixel uv, a 0->1 by 0->1 uv, a -1->1 by -1->1 uv, or anything else. The\n    //only thing that matters is whether uv is within a box \"size\" units on a side.\n    //Check to make sure that uv lies within the extents of the character to be printed:\n\n    //font_uv_offset goes from -1.0->1.0 in both dimensions and is the position \n    //within the rendered character of uv.\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    //TODO: this might be faster as a for loop with a break because of the way\n    //      for loops are unrolled? It would certainly be faster with a binary\n    //      search of ifs.\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n\n        //retval += print_int(font_channel, digits(frac_int), size/2.0, pos + vec2(0.0, size), uv, true, tmp); \n    }\n    \n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.5;\n}\n\nconst float tab_width = 8.0;\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    //return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, \n                         uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\nDECL_PRINT_STRING(1)","name":"Common","description":"","type":"common"}]}