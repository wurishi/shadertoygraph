{"ver":"0.1","info":{"id":"7sfSzS","date":"1619369603","viewed":104,"name":"smoke oracle","username":"PStepanova_324","description":"шар, цветной дым","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cghomework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nc= fragCoord/iResolution.xy;\n   fragColor = texture(iChannel0, nc) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INFIN = 1e9;\nconst float GLASS_RFR=1.5;\nconst float AIR_RFR=1.0;\nconst vec3 CAMERA_POS = vec3(0, 1.2, -6);//how high above the table\nconst float RM_STEP=0.01;\nconst int RM_Nsteps=90;\n\nconst int EMISSN=0;\nconst int DIFFSN=1;\nconst int REFLCN=2;\nconst int REFRCN=3;\n//enum mattype {EMISSN=0,DIFFSN,REFLCN,REFRCN};\n\nstruct Lsource{\n   vec3 posit;\n   float r;\n   vec3 color;\n};\n\n\nLsource lights[3]=Lsource[3](\n   Lsource (vec3(-2, 1, 2.5),0.25,vec3(0.36, 0.88, 1)),//blue\n   Lsource (vec3(3, 0.4, 1),0.3,vec3(1, 0.8, 0.25)),//yellow   \n   Lsource (vec3(-2.5, 0.3, -0.4),0.2,vec3(1, 0.49, 0.12))// orange\n   );\n\n\nfloat raytable(vec3 cam,vec3 viewpoint)//n=(010)\n{\n   float y_shift = -(1.4+cam.y)/viewpoint.y;//more added-closer to table edge\n   if (y_shift<=0.0) return INFIN;\n   vec3 pointXZ=cam + viewpoint*y_shift; //дотягиваем вектор взгляда до плоскости xz с помощью (вдоль)оси оу\n   if (abs(pointXZ.x)+abs(pointXZ.z)>=5.0 ) return INFIN;//стол квадратный\n   return y_shift;//отношение!,в которое надо вытянуть вектор взгляда\n\n}\n\nfloat rayplate(vec3 cam,vec3 viewpoint,out vec3 n)\n{\n   float y_shift = -(1.0+cam.y)/viewpoint.y;\n   if (y_shift<=0.0) return INFIN;\n   vec3 pointXZ=cam + viewpoint*y_shift;\n   if(dot(pointXZ.xz,pointXZ.xz)<0.5){\n      n=vec3(0,1,0);   \n      return y_shift;\n   }\n\n   float a=dot(viewpoint.xz,viewpoint.xz),b=dot(cam.xz,viewpoint.xz),c=dot(cam.xz,cam.xz)-0.5,discr=b*b-a*c;\n   if (discr<0.0)return INFIN;\n   \n   y_shift=(-b-sqrt(discr))/a;\n\n   if(y_shift>0.0)\n   {\n      pointXZ=cam + viewpoint*y_shift;\n      if(pointXZ.y<=-1.0) {n=normalize (vec3(pointXZ.x,0,pointXZ.z));return y_shift;}\n   }\n   \n   y_shift=(-b+sqrt(discr))/a;\n   \n   if(y_shift<0.0) return INFIN;\n   \n      pointXZ=cam + viewpoint*y_shift;\n      if(pointXZ.y<=-1.0) {n=normalize (vec3(pointXZ.x,0,pointXZ.z));return y_shift;}\n   \n   \n   return INFIN;\n}\n\nfloat raylightsource(vec3 cam,vec3 viewpoint,vec3 lightpos,float r)//ray a sphere\n{\n   //расстояние из камеры по вектору взгляда - сколько \"шагов\" взгляда нужно для пересечения с xz внутри круга-источника\n   //надо длину из 000 вектора-суммы вектора поз камеры и числа шагов взгляда\n   //чтоб учитывать радиус считаем сферу во все стороны от \"нуля\"-расстояне фикс, \n   float b=dot(cam-lightpos,viewpoint),discr=b*b-dot(cam-lightpos,cam-lightpos)+r*r;\n   if (discr<0.0)return INFIN;\n   float y_shift=-b-sqrt(discr);\n   if(y_shift>0.0)return y_shift;//n=y_shift*viewpoint + cam\n   y_shift=-b+sqrt(discr);\n   if(y_shift>0.0)return y_shift;\n   return INFIN;\n}\n\nvec3 lightsourcenorm(vec3 cam,vec3 viewpoint,vec3 lt_pos,float lt_r)\n{\n   float k=raylightsource(cam,viewpoint,lt_pos,lt_r);\n   if(k!=INFIN) return normalize(k*viewpoint + cam);\n   return vec3(0,0,0);\n}\n\nbool rayblocked(vec3 cam,vec3 lightpos)\n{\n   vec3 lpos=lightpos-cam;float dist=length(lpos);lpos=normalize(lpos);//вектор в сторону точки\n   //шар\n   if(raylightsource(cam,lpos,vec3(0,0,0),1.0)<dist)return true;\n   vec3 n;\n   return(rayplate(cam,lpos,n)<dist);//подставка   \n}\n\nvec3 lightraydiffsn(vec3 pointXZ,Lsource lights[3], vec3 n,vec3 tabletexture,vec3 randdir)//для точек итоговой плоскости-стола,учитывая все источники света\n{\n   //(cam-lightpos)+shift_y*viewvec = n = вектор из центра сферы в новом нуле к краю - вектор-радиус\n   vec3 lpos,acc=vec3(0,0,0);float att;\n   for(int i=0;i<=2;i++){\n      lpos=lights[i].posit-pointXZ;\n      if(!rayblocked(pointXZ,lights[i].posit+(lights[i].r*randdir))){\n        att=8.0/dot(lpos,lpos);\n        acc+=att*lights[i].color*max(0.0,dot(n,normalize(lpos)));}\n   }\n   return acc*tabletexture;\n}\n\n\n\nvec3 sphererefract(vec3 ray,vec3 n,float n12)//n12=n2/n1 relative refr coeff\n{\n   if (dot (ray,n)<0.0) n=-n;\n   float cos_a=dot(ray,n),\n         sin_a=sqrt(1.0-cos_a*cos_a),\n         sin_b=sin_a/n12,\n         cos_b=sqrt(1.0-sin_b*sin_b);\n   if(sin_b>1.0)return reflect(ray,n);\n   vec3 tang=normalize(ray-cos_a*n);\n   return normalize(sin_b*tang+cos_b*n);\n}\n\n\nfloat smokesdf(vec3 cam, float r)//is inside sphere, sphere_pos=(0.0.0) (world center)\n{\n   return length(cam)-r;//\"без резких переходов\"?? радиус этой стекл сферы 1.1\n}\n\nfloat BLBabsorb(float dist,float absorptivity)\n{\n   return exp(- dist* absorptivity);\n}\n\nfloat smoke_thickness(vec3 pos)\n{\n   float acc=0.0;\n   for(int i=0;i<=3;i++) acc+=texture(iChannel3, pos * ((i==0)?0.1:(0.5*float(i)))).x;\n   return acc;\n}\n\nvec4 raysmokeacc(vec3 cam,vec3 viewpoint)\n{\n   vec3 pos=cam;const float absrbt=10.0;\n   float dist=smokesdf(pos,0.8),opac=1.0,entryopac=opac,rez_absorb=0.0;//расст до, до нуля с сдвигом \"вперед\" на радиус дыма внутри для начала накопа\n   //const float RM_STEP=0.01;\n   //const int RM_Nsteps=90;\n   for(int i=0;i<RM_Nsteps;i++){\n      \n      pos=cam+viewpoint*(RM_STEP*float(i)+dist);//вытянуть вектор взгляда из точки камеры по у в отношение = длине расстояния до очередной рассм точки внутри шара дыма = расст-е максимальное + Нпройденных шагов*длину шага\n      dist=smokesdf(pos,0.8);\n      if(dist<0.0){//inside the smoke(less far away from 0.0.0 than radius)\n         entryopac=opac;\n         opac=opac*BLBabsorb(RM_STEP,//добавляем долю, которую поглотит, из того, что пришло: доля поглощенная от того, что пришло с предыд шага=доля исх, не погложенная, поэтому 1--->0\n            absrbt*(\n            smoke_thickness( pos)\n            ) * 0.3 * abs(dist));\n         rez_absorb+=entryopac-opac;//разница, которую еще поглотило на этом \"слое\"\n      }\n   }\n   vec3 smoke_col=texture(iChannel2, pos * 0.07).rgb * 3.5;\n   return vec4(smoke_col*rez_absorb,1.0-opac);\n}\n\n\n\nfloat randomnum(float frame)\n{\n   return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 randvec = vec3(randomnum(float(iFrame)),randomnum(float(iFrame+7)),randomnum(float(iFrame+13)));\n   vec3 randdir=normalize(randvec - 0.5);\n   vec2 nc = (fragCoord-iResolution.xy*0.5+2.0*randvec.xy-1.0)/iResolution.x;//antialias\n   vec3 y_axis=normalize(-CAMERA_POS);vec3 z_axis=vec3(0,1,0);vec3 x_axis_rev=normalize(cross(y_axis,z_axis));\n   z_axis=normalize(cross(x_axis_rev,y_axis));\n   vec3 viewpoint=normalize(y_axis+x_axis_rev*nc.x+z_axis*nc.y);//смотрим куда-то в межвекторье наискосок\n   \n   /*mattype*/int mt;\n   vec3 color,pointXZ,pos,normal,camera_raytr=CAMERA_POS,pov_raytr=viewpoint,color_acc=vec3(1,1,1);\n   float rez_shift_y,table_y_shift,plate_y_shift,\n         from_rfr=AIR_RFR,to_rfr=GLASS_RFR,\n         glass_r=(AIR_RFR-GLASS_RFR)*(AIR_RFR-GLASS_RFR)/((AIR_RFR+GLASS_RFR)*(AIR_RFR+GLASS_RFR));\n   float ls_y_shift[3];\n  \n  \n  float mult=1.0;int fl=0;\n  \n  \n   //итоговая пропорция шифта по у  -то что надо или бесконечность = rez_shift_y\n         \n   for (int i=0;i<10;i++){\n      rez_shift_y=INFIN;table_y_shift=raytable(camera_raytr,pov_raytr);\n      //t=(p<INFIN)?p:INFIN;//<inf => intersected ray and plane\n      if(table_y_shift<rez_shift_y){\n         rez_shift_y=table_y_shift;mt=DIFFSN;color=texture(iChannel1,pointXZ.xz *0.2).rgb;normal=vec3(0,1,0);\n      }\n\n      vec3 nplate;\n      plate_y_shift=rayplate(camera_raytr,pov_raytr,nplate);\n      if(plate_y_shift<rez_shift_y){\n         rez_shift_y=plate_y_shift;mt=DIFFSN;color=texture(iChannel1,pointXZ.xz*pointXZ.y ).rgb;normal=nplate;\n         //был канал с другой текстурой для подставки, но т.к. только четыре сторонних канала можно =>будет одна текстура на все\n      } \n\n      for(int j=0;j<=2;j++){\n        ls_y_shift[j]=raylightsource(camera_raytr,pov_raytr,lights[j].posit,lights[j].r);\n        if(ls_y_shift[j]<rez_shift_y){rez_shift_y=ls_y_shift[j];mt=EMISSN;color=lights[j].color;\n           normal=lightsourcenorm(camera_raytr,pov_raytr,lights[j].posit,lights[j].r);}     \n      }\n      \n      float ball_shift_y=raylightsource(camera_raytr,pov_raytr,vec3(0,0,0),1.1);//the glass ball\n      if(ball_shift_y<rez_shift_y){rez_shift_y=ball_shift_y;\n         mt=(randvec.x/5.0<glass_r)?REFLCN:REFRCN;\n         normal=lightsourcenorm(camera_raytr,pov_raytr,vec3(0,0,0),1.1);}\n           \n      \n     \n      if(rez_shift_y!=INFIN){\n         pointXZ=camera_raytr + pov_raytr*rez_shift_y;\n         if(fl>1)continue;\n\n         switch (mt){\n            case EMISSN: fragColor.rgb = color; fl++;\n               break;\n            case DIFFSN:fragColor.rgb += mult*0.5*lightraydiffsn(pointXZ,lights,normal,color,randdir); fl++;\n               break;\n            case REFLCN:camera_raytr=pointXZ;pov_raytr=reflect(pov_raytr,normal);camera_raytr+=pov_raytr*1e-4;\n            fragColor.rgb+=mult*lightraydiffsn(pointXZ+ pov_raytr*rez_shift_y,lights,normal,color,randdir);\n               break;\n            case REFRCN:camera_raytr=pointXZ;\n               pov_raytr=sphererefract(pov_raytr,normal,to_rfr/from_rfr);camera_raytr+=pov_raytr*1e-4;\n               to_rfr=to_rfr+from_rfr;from_rfr=to_rfr-from_rfr;to_rfr=to_rfr-from_rfr;\n               //add smoke color when inside the sphere\n               \n               vec4 col_rgba=raysmokeacc(camera_raytr,pov_raytr);\n               fragColor.rgb+=col_rgba.rgb*col_rgba.a*mult*2.0;\n               mult*=(1.0-col_rgba.a);//а-прозрачность, доля накопа\n               //1-прозр = сколько осталось взять\n               \n               \n               break;\n            default:break;\n         }         \n      }\n      else{\n         fragColor.rgb+=texture(iChannel0,pov_raytr).rgb*mult;break;//bckgr\n\n      }\n   }\n\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nc = fragCoord/iResolution.xy;\n   fragColor = texture(iChannel1, nc) +texture(iChannel0, nc);\n}","name":"Buffer B","description":"","type":"buffer"}]}