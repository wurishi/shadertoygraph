{"ver":"0.1","info":{"id":"XlfXz2","date":"1439101117","viewed":1222,"name":"[SIG15] The Excursion Funnel","username":"AlainGalvan","description":" I loved being inside Portal 2 Excursion Funnels so I did a shader for that. :D","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["swirl","portal","valve","sig15","potato","wheatley","glados","fan","halflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*************************************************************************\n* The Aperture Science Excursion Funnel\n* A Portal 2 Fan Shader for [SIG15]\n* Last Updated: Sun Aug 10 2015 @ 02:30PM EST (11:30AM PST)\n* By Alain Galvan (Alain.xyz)\n* Please mind the mess. xD\n* Sources: iq, nimitz, teh_bear, unity3d, i-saint, ashima, Youself, and way more\n**************************************************************************\n* Constants\n*************************************************************************/\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR   1.61803398\n\n#define V_FOWARD vec3(1.,0.,0.)\n#define V_UP vec3(0.,1.,0.)\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n#define MAT_GUNWHITE 1.\n#define MAT_GUNGRAY  2.\n#define MAT_GUNBLACK 3.\n#define MAT_FUNNEL   4.\n#define MAT_CHAMBER  5.\n\n/*************************************************************************\n* Utilities\n*************************************************************************/\nvec2 opU(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat opS(float d1, float d2)\n{\n\treturn max(-d2, d1);\n}\n\nvec3 opCheapBend(vec3 p, vec2 a)\n{\n\tfloat c = cos(a.x*p.y);\n\tfloat s = sin(a.y*p.y);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xy, p.z);\n}\n\nfloat pow5(float v)\n{\n\tfloat tmp = v*v;\n\treturn tmp*tmp*v;\n}\n\nvec3 opTwist(vec3 p, float a)\n{\n\tfloat  c = cos(a*p.y + a);\n\tfloat  s = sin(a*p.y + a);\n\tmat2   m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xz, p.y);\n}\n\nmat3 makeRotateX(float a)\n{\n\tfloat  c = cos(a); float  s = sin(a);\n\treturn mat3(1.0, c, -s,\n\t\t0.0, s, c,\n\t\t0.0, 0.0, 1.0);\n}\n\nmat3 makeRotateY(float a)\n{\n\tfloat  c = cos(a); float  s = sin(a);\n\treturn mat3(c, 0.0, s,\n\t\t0.0, 1.0, 0.0,\n\t\t-s, 0.0, c);\n}\n\nmat3 makeRotateZ(float a)\n{\n\tfloat  c = cos(a); float  s = sin(a);\n\treturn mat3(c, -s, 0.0,\n\t\ts, c, 0.0,\n\t\t0.0, 0.0, 1.0);\n}\n\nvec2 cartesianToPolar(vec2 p)\n{\n\tfloat l = length(p);\n\treturn vec2(acos(p.x / l), asin(p.y / l));\n}\n\n\nvec2 cartesianToPolar(vec3 p)\n{\n\treturn vec2(PI / 2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n\nvec3 DomainRotateSymmetry(const in vec3 vPos, const in float fSteps)\n{\n\tfloat angle = atan(vPos.x, vPos.z);\n\n\tfloat fScale = fSteps / (PI * 2.0);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\n\tvec3 vResult = vec3(c * vPos.x + s * vPos.z,\n\t\tvPos.y,\n\t\t-s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n\nfloat lstep(float edge0, float edge1, float x)\n{\n\treturn clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat noise(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel2, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn -1.0 + 2.0*mix(rg.x, rg.y, f.z);\n}\n\n\n// **************************************************************************\n// GLOBALS\n// **************************************************************************\n\nvec3  g_camPointAt = vec3(0.);\nvec3  g_camOrigin = vec3(0.);\nvec3  g_ldir = vec3(-.4, 1., -.3);\n\n// **************************************************************************\n// CAMERA & GLOBALS\n// **************************************************************************\nstruct CameraData\n{\n\tvec3 origin;\n\tvec3 dir;\n\tvec2 st;\n\tvec3 right;\n\tvec3 up;\n};\n\nCameraData setupCamera(in vec2 fragCoord)\n{\n\t// aspect ratio\n\tfloat invar = iResolution.y / iResolution.x;\n\tvec2 st = fragCoord.xy / iResolution.xy - .5;\n\tst.y *= invar;\n\n\t// Camera Foward Up Right\n\tvec3 iu = V_UP;\n\tvec3 iz = normalize(g_camPointAt - g_camOrigin);\n\tvec3 ix = normalize(cross(iz, iu));\n\tvec3 iy = cross(ix, iz);\n\tvec3 dir = normalize(st.x*ix + st.y*iy + .67 * iz);\n\n\treturn CameraData(g_camOrigin, dir, st, iy, ix);\n\n}\n\nvoid animate()\n{\n\t//Camera\n\tg_camOrigin = vec3(0., 1.68, 0.); //1.68\n\n\tvec2 click = iMouse.xy / iResolution.xx;\n\tclick = vec2(0.7, 0.25) * click + vec2(0., -0.05);\n\n\tfloat yaw = PI_OVER_TWO * (click.x);\n\tfloat pitch = PI_OVER_TWO * ((iResolution.x / iResolution.y) * click.y);\n\n\tg_camPointAt = g_camOrigin + vec3(cos(yaw), tan(pitch)*cos(yaw), sin(yaw));\n}\n\n/*************************************************************************\n* Distance Fields\n*************************************************************************/\n\n#define SKYBLUE vec3(0.06, 0.2, .4)\n#define SKYORANGE vec3(0.4, 0.5, 0.9)\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdPlaneZ(vec3 p)\n{\n\treturn p.z;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat segmentdf(vec3 p, vec3 a, vec3 b, float r)\n{\n\n\tvec3 ba = b - a;\n\tfloat t = dot(ba, (p - a)) / max(SMALL_FLOAT, dot(ba, ba));\n\tt = clamp(t, 0., 1.);\n\treturn length(ba * t + a - p) - r;\n}\n\nfloat sdExcursionfunnel(vec3 p) {\n\tp += vec3(0., -1.2, -1.2);\n\tp += makeRotateX(mod(p.x*0.5 + iTime, 2.*PI)) * vec3(0., 1.2, 1.2);\n\tvec2 d = abs(vec2(length(p.yz), p.x)) - vec2(.02, p.x);\n\tfloat line = length(max(d, 0.0));\n\treturn line;\n}\n\nfloat sdPGunBlaster(vec3 p) {\n\t//Blaster Radius\n\tfloat xx = p.x;\n\tfloat radius =\n\t\t0.22\n\t\t- 0.05 * lstep(1.7, 2.1, xx)\n\t\t+ 0.1  * lstep(1.55, 1.65, xx)\n\t\t- 0.05 * lstep(1.3, 1.4, xx)\n\t\t- 0.1  * lstep(0.8, 0.9, 1.8 - xx)\n\t\t+ 0.15  * lstep(1.0, 1.2, 1.75 - xx)\n\t\t+ 0.05  * lstep(1.0, 1.2, 1.4 - xx)\n\t\t- 0.05  * lstep(1.0, 1.2, 1. - xx)\n\t\t;\n\n\tvec2 d = abs(vec2(length(p.yz), xx)) - vec2(radius, 2.0);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, .0));\n}\n\nvec2 scenedf(vec3 p)\n{\n\t//Map mouse for gun tracking\n\tvec2 click = iMouse.xy / iResolution.xx;\n\tclick = vec2(0.64, 0.25) * click + vec2(0., -0.05);\n\tfloat yaw = PI_OVER_TWO * (click.x);\n\tfloat pitch = PI_OVER_TWO * ((iResolution.x / iResolution.y) * click.y);\n\tvec3 gp = (makeRotateY(-yaw)*makeRotateZ(0.02*PI + pitch) *p + vec3(-1.5*(1.+pitch), -1.1, -.5));\n\n\t//Potato Gun\n\tvec2 obj = vec2(sdPGunBlaster(gp), MAT_GUNGRAY);\n\tobj = opU(obj, vec2(sdSphere(vec3(.7, 1., 1.)*gp + vec3(0.5, 0., 0.), .35), MAT_GUNWHITE));\n\n\t//Apeture Science Excursion Funnel\n\tobj = opU(obj, vec2(sdExcursionfunnel(p), MAT_FUNNEL));\n\tobj = opU(obj, vec2(sdExcursionfunnel(p + vec3(8., 0., 0.)), MAT_FUNNEL));\n\tobj = opU(obj, vec2(sdExcursionfunnel(p + vec3(16., 0., 0.)), MAT_FUNNEL));\n\n\t//Chamber Walls\n\tvec3 mp = mod(p + vec3(iTime, 0., 0.), vec3(2.2, 4.1, 12.2)) - vec3(1.1, 2.05, 6.1);\n\tobj = opU(obj, vec2(sdBox(mp, vec3(1.0, 2.0, 1.0)), MAT_CHAMBER));\n\tobj = opU(obj, vec2(sdPlaneZ(p + vec3(0., 0., 5.15)), MAT_GUNGRAY));\n\tobj = opU(obj, vec2(sdPlaneZ((-p + vec3(0., 0., 5.15))), MAT_GUNWHITE));\n\n\treturn obj;\n}\n// *************************************************************************\n// RENDERING\n// **************************************************************************\n#define DISTMARCH_STEPS 256\n#define DISTMARCH_MAXDIST 50.\n\nvec2 distmarch(vec3 ro, vec3 rd, float maxd)\n{\n\n\tfloat epsilon = 0.0001;\n\tfloat dist = 10. * epsilon;\n\tfloat t = 0.;\n\tfloat material = 0.;\n\tfor (int i = 0; i < DISTMARCH_STEPS; i++)\n\t{\n\t\tif (abs(dist) < epsilon || t > maxd) break;\n\t\t// advance the distance of the last lookup\n\t\tt += dist;\n\t\tvec2 dfresult = scenedf(ro + t * rd);\n\t\tdist = dfresult.x;\n\t\tmaterial = dfresult.y;\n\t}\n\n\tif (t > maxd) material = -1.0;\n\treturn vec2(t, material);\n}\n\n// SHADOWING & NORMALS\n#define SOFTSHADOW_STEPS 40\n#define SOFTSHADOW_STEPSIZE .1\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n\tfloat shadow = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < SOFTSHADOW_STEPS; i++)\n\t{\n\t\tif (t < maxt)\n\t\t{\n\t\t\tfloat h = scenedf(ro + rd * t).x;\n\t\t\tshadow = min(shadow, k * h / t);\n\t\t\tt += SOFTSHADOW_STEPSIZE;\n\t\t}\n\t}\n\treturn clamp(shadow, 0.0, 1.0);\n\n}\n\n#define AO_NUMSAMPLES 6\n#define AO_STEPSIZE .1\n#define AO_STEPSCALE .4\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat ao = 0.0;\n\tfloat aoscale = 1.0;\n\n\tfor (int aoi = 0; aoi < AO_NUMSAMPLES; aoi++)\n\t{\n\t\tfloat stepp = 0.01 + AO_STEPSIZE * float(aoi);\n\t\tvec3 aop = n * stepp + p;\n\n\t\tfloat d = scenedf(aop).x;\n\t\tao += -(d - stepp)*aoscale;\n\t\taoscale *= AO_STEPSCALE;\n\t}\n\n\treturn clamp(ao, 0.0, 1.0);\n}\n// SHADING\n\nstruct SurfaceData\n{\n\tvec3 point;\n\tvec3 normal;\n\tvec3 basecolor;\n\tfloat roughness;\n\tfloat metallic;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), 0., 0.)\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 epsilon = vec3(0.001, 0.0, 0.0);\n\tvec3 n = vec3(\n\t\tscenedf(p + epsilon.xyy).x - scenedf(p - epsilon.xyy).x,\n\t\tscenedf(p + epsilon.yxy).x - scenedf(p - epsilon.yxy).x,\n\t\tscenedf(p + epsilon.yyx).x - scenedf(p - epsilon.yyx).x);\n\treturn normalize(n);\n}\n\nvoid material(float surfid, inout SurfaceData surf)\n{\n\tif (surfid - .5 < MAT_GUNWHITE)\n\t{\n\t\tsurf.basecolor = vec3(.94);\n\t\tsurf.roughness = .85;\n\t\tsurf.metallic = .4;\n\t}\n\telse if (surfid - .5 < MAT_GUNGRAY)\n\t{\n\t\tsurf.basecolor = vec3(0.1);\n\t\tsurf.roughness = 6.;\n\t\tsurf.metallic = .3;\n\t}\n\telse if (surfid - .5 < MAT_GUNBLACK)\n\t{\n\t\tsurf.basecolor = vec3(.05);\n\t\tsurf.roughness = .6;\n\t\tsurf.metallic = .4;\n\t}\n\telse if (surfid - .5 < MAT_FUNNEL)\n\t{\n\t\tsurf.basecolor = -vec3(.1, .3, .9);\n\t\tsurf.roughness = 1.;\n\t\tsurf.metallic = 0.;\n\t}\n\telse if (surfid - .5 < MAT_CHAMBER)\n\t{\n\t\tsurf.basecolor = vec3(6.5);\n\t\tsurf.roughness = 0.89;\n\t\tsurf.metallic = 0.2;\n\t}\n}\n\nvec3 integrateDirLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\tvec3 vdir = normalize(g_camOrigin - surf.point);\n\tvec3 hdir = normalize(ldir + vdir);\n\n\tfloat costh = max(-SMALL_FLOAT, dot(surf.normal, hdir));\n\tfloat costd = max(-SMALL_FLOAT, dot(ldir, hdir));\n\tfloat costl = max(-SMALL_FLOAT, dot(surf.normal, ldir));\n\tfloat costv = max(-SMALL_FLOAT, dot(surf.normal, vdir));\n\n\tfloat ndl = clamp(costl, 0., 1.);\n\n\tvec3 cout = vec3(0.);\n\n\tif (ndl > 0.)\n\t{\n\t\tfloat frk = .5 + 2.* costd*costd * surf.roughness;\n\t\tvec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1. - costl)) * (1. + (frk - 1.) * pow5(1. - costv));\n\n\t\tfloat r = max(0.05, surf.roughness);\n\t\tfloat alpha = r * r;\n\t\tfloat denom = costh*costh * (alpha*alpha - 1.) + 1.;\n\t\tfloat D = (alpha*alpha) / (PI * denom*denom);\n\n\t\tfloat k = ((r + 1.) * (r + 1.)) / 8.;\n\t\tfloat Gl = costv / (costv * (1. - k) + k);\n\t\tfloat Gv = costl / (costl * (1. - k) + k);\n\t\tfloat G = Gl * Gv;\n\n\t\tvec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n\t\tvec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\n\t\tvec3 spec = D * F * G / (4. * costl * costv);\n\t\tfloat shd = 1.0;\n\t\tcalcSoftShadow(surf.point, ldir, 0.1, 20., 5.);\n\n\t\tcout += diff * ndl * shd * lcolor;\n\t\tcout += spec * ndl * shd * lcolor;\n\t\t//Rim Light\n\t\t//cout += clamp(pow(dot(vdir, -surf.normal) + 1.5, 3.5) * 0.05, 0.0, 1.0);\n\t}\n\n\treturn cout;\n}\n\nvec3 sampleEnvLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\n\tvec3 vdir = normalize(g_camOrigin - surf.point);\n\tvec3 hdir = normalize(ldir + vdir);\n\tfloat costh = dot(surf.normal, hdir);\n\tfloat costd = dot(ldir, hdir);\n\tfloat costl = dot(surf.normal, ldir);\n\tfloat costv = dot(surf.normal, vdir);\n\n\tfloat ndl = clamp(costl, 0., 1.);\n\tvec3 cout = vec3(0.);\n\tif (ndl > 0.)\n\t{\n\t\tfloat r = surf.roughness;\n\t\tfloat k = r*r / 2.;\n\t\tfloat Gl = costv / (costv * (1. - k) + k);\n\t\tfloat Gv = costl / (costl * (1. - k) + k);\n\t\tfloat G = Gl * Gv;\n\n\t\tvec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n\t\tvec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\t\tvec3 spec = lcolor * G * F * costd / (costh * costv);\n\t\tfloat shd = calcSoftShadow(surf.point, ldir, 0.02, 20., 7.);\n\t\tcout = spec * shd * lcolor;\n\t}\n\n\treturn cout;\n}\n\nvec3 integrateEnvLight(SurfaceData surf)\n{\n\tvec3 vdir = normalize(surf.point - g_camOrigin);\n\tvec3 envdir = reflect(vdir, surf.normal);\n\tvec4 specolor = vec4(.4) * mix(texture(iChannel0, envdir), texture(iChannel1, envdir), surf.roughness);\n\n\tvec3 envspec = sampleEnvLight(envdir, specolor.rgb, surf);\n\treturn envspec;\n}\n\nvec3 shadeSurface(SurfaceData surf)\n{\n\n\tvec3 amb = surf.basecolor * .01;\n\tfloat ao = calcAO(surf.point, surf.normal);\n\n\tvec3 centerldir = normalize(-surf.point);\n\n\tvec3 cout = vec3(0.);\n\tif (dot(surf.basecolor, vec3(-1.)) > SMALL_FLOAT) //Excursion Funnel\n\t{\n\t\tcout = -surf.basecolor * surf.point.x;// + (0.2 * surf.normal);\n\n\t}\n\telse\n\t\tif (dot(surf.basecolor, vec3(1.)) > SMALL_FLOAT)\n\t\t{\n\t\t\tvec3  dir1 = normalize(vec3(0.0, 0.9, 0.1));\n\t\t\tvec3  col1 = vec3(0.3, 0.5, .9);\n\t\t\tvec3  dir2 = normalize(vec3(0.1, -.1, 0.));\n\t\t\tvec3  col2 = vec3(0.94, 0.5, 0.2);\n\t\t\tcout += integrateDirLight(dir1, col1, surf);\n\t\t\tcout += integrateDirLight(dir2, .0*col2, surf);\n\t\t\tcout += integrateDirLight(g_ldir, vec3(0.4), surf);\n\t\t\tcout += integrateEnvLight(surf);\n\t\t\tcout *= (1. - (3.5 * ao));\n\t\t}\n\treturn cout;\n\n}\n// **************************************************************************\n// POSTPROCESSING\n// **************************************************************************\n\nvec3 vignette(vec3 texel, vec2 vUv, float darkness, float offset) {\n\tvec2 uv = (vUv - vec2(0.5)) * vec2(offset);\n\treturn mix(texel.rgb, vec3(1.0 - darkness), dot(uv, uv));\n}\n\nvec3 overlay(vec3 inColor, vec3 overlay)\n{\n\tvec3 outColor = vec3(0.);\n\toutColor.r = (inColor.r > 0.5) ? (1.0 - (1.0 - 2.0 * (inColor.r - 0.5)) * (1.0 - overlay.r)) : ((2.0 * inColor.r) * overlay.r);\n\toutColor.g = (inColor.g > 0.5) ? (1.0 - (1.0 - 2.0 * (inColor.g - 0.5)) * (1.0 - overlay.g)) : ((2.0 * inColor.g) * overlay.g);\n\toutColor.b = (inColor.b > 0.5) ? (1.0 - (1.0 - 2.0 * (inColor.b - 0.5)) * (1.0 - overlay.b)) : ((2.0 * inColor.b) * overlay.b);\n\treturn outColor;\n}\n\n// **************************************************************************\n// MAIN\n// **************************************************************************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Animate globals\n\tanimate();\n\n\t// Setup Camera\n\tCameraData cam = setupCamera(fragCoord);\n\n\t// ----------------------------------------------------------------------\n\t// SCENE MARCHING\n\n\tvec2 scenemarch = distmarch(cam.origin, cam.dir, DISTMARCH_MAXDIST);\n\n\t// ----------------------------------------------------------------------\n\t// SHADING\n\n\tvec3 scenecol = vec3(0.);\n\tif (scenemarch.y > SMALL_FLOAT)\n\t{\n\t\tvec3 mp = cam.origin + scenemarch.x * cam.dir;\n\t\tvec3 mn = calcNormal(mp);\n\n\t\tSurfaceData currSurf = INITSURF(mp, mn);\n\n\t\tmaterial(scenemarch.y, currSurf);\n\t\tscenecol = shadeSurface(currSurf);\n\t}\n\n\t// distance fog\n    vec2 nuv = (fragCoord.xy / iResolution.yy) * (iResolution.y/iResolution.x);\n\tvec2 vig = nuv - vec2(0.5, 0.36);\n\tfloat dvig = dot(vig, vig);\n\tscenecol = mix(scenecol, SKYORANGE, smoothstep(0., 10., scenemarch.y));\n\tscenecol = mix(scenecol, SKYBLUE, smoothstep(0., 15., scenemarch.x));\n    scenecol += .87 - pow(dvig, 0.3);\n\n\t// Postprocessing\n\n\tscenecol = vignette(scenecol, nuv, 1.3, 0.9);\n\tscenecol += 0.5*vec3(nuv.y);\n\tfragColor.rgb = scenecol;\n\tfragColor.a = 1.;\n}","name":"Image","description":"","type":"image"}]}