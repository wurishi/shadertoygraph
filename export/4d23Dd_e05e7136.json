{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// added color.. o.O \n// Andrew Caudwell 2014\n// @acaudwell\n\n#define MAX_RAY_STEPS 100\n#define PI 3.14159265359\n\n#define DEGREES_TO_RADIANS 0.017453292\n\n#define IFS_ITERATIONS 12\n\nstruct IFS {\n    vec3  offset;\n    float scale;\n    vec3  axis;\n    float angle;\n    mat4  transform;\n};\n\nIFS IFS_constructor(vec3 offset, vec3 axis, float angle, float scale) {\n\tIFS ifs;\n\tifs.offset = offset;\n\tifs.axis   = axis;\n\tifs.angle  = angle;\n\tifs.scale  = scale;\n\t\n\treturn ifs;\n}\n\nmat4 calc_transform(inout IFS ifs) {\n    float angle = ifs.angle * DEGREES_TO_RADIANS;\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * ifs.axis;\n\n    return mat4(\n        vec4(c + t.x * ifs.axis.x, t.y * ifs.axis.x - s * ifs.axis.z, t.z * ifs.axis.x + s * ifs.axis.y, 0.0) * ifs.scale,\n        vec4(t.x * ifs.axis.y + s * ifs.axis.z, (c + t.y * ifs.axis.y),          t.z * ifs.axis.y - s * ifs.axis.x, 0.0) * ifs.scale,\n        vec4(t.x * ifs.axis.z - s * ifs.axis.y, t.y * ifs.axis.z + s * ifs.axis.x, c + t.z * ifs.axis.z, 0.0) * ifs.scale,\n        vec4(ifs.offset, 1.0)\n    );\n}\n\n#define t iTime*0.6\n\nint stage_no;\nfloat stage_t;\n\nIFS ifs_N;\nIFS ifs_lerp;\n\nvoid InitIFS() {\n\n    stage_no  = int(fract(t/float(IFS_ITERATIONS*2)) * float(IFS_ITERATIONS*2));\n    stage_t = smoothstep(0.0, 1.0, fract(t));\n\n    \n    if(stage_no >= IFS_ITERATIONS) {\n        stage_no = IFS_ITERATIONS-(stage_no-IFS_ITERATIONS)-1;\n        stage_t  = 1.0-stage_t;\n    }\n\t\n    // IFS to visualize\n    ifs_N = IFS_constructor(vec3(-1.5), normalize(vec3(-1.0)), -36.0, 1.5);\n\t\n\tifs_lerp.axis   = ifs_N.axis;\n\tifs_lerp.angle  = ifs_N.angle;\n\n\t// interpolate scale and position offset\n\tifs_lerp.offset = ifs_N.offset * stage_t;\n\tifs_lerp.scale  = 1.0 + (ifs_N.scale-1.0) * stage_t;\n\t\n\t// left mouse button disables interpolation\n\tif(iMouse.z>0.0) {\n\t\tifs_lerp = ifs_N;\n\t}\n\t\n    ifs_N.transform    = calc_transform(ifs_N);\n    ifs_lerp.transform = calc_transform(ifs_lerp);\n}\n\n// The definitive Fractal Forums thread about this class of fractals:\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-%28escape-time-ifs%29/\n\nfloat scene(vec3 p) {\n\n\tIFS ifs = ifs_N;\n\t\n\tfloat scale = 1.0;\n\t\t\t\t\n\tfor(int i=0;i<IFS_ITERATIONS;i++) {\n\n\t\tif(i==stage_no) ifs = ifs_lerp;\n\t\telse if(i>stage_no) break;\n\t\t\t\n\t\t// mirror on 2 axis to get a tree shape\n\t\tp.xy = abs(p.xy);\n\t\n\t\t// apply transform\n\t\tp = (ifs.transform * vec4(p, 1.0)).xyz;\n\t\t\n\t\tscale *= ifs.scale;\n\t}\n\t\t\n\t// divide by scale preserve correct distance\n\treturn (length(p)-2.0) / scale;\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.001,0.0);\n\n\tfloat d = scene(p);\n\t\n    float d1 = d-scene(p+o.xyy);\n    float d2 = d-scene(p+o.yxy);\n    float d3 = d-scene(p+o.yyx);\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat AO(vec3 p, vec3 normal) {\n\n    float a = 1.0;\n\n\tfloat c = 0.0;\n    float s = 0.25;\n\n    for(int i=0; i<3; i++) {\n\t    c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c)) * s / c);\n    }\n\n    return clamp(a,0.0,1.0);\n}\n\nfloat map( in vec3 p )\n{\n\tfloat e = 1.0;//2.0*texture( iChannel0, vec2(0.01,0.25) ).x;\n    return min( e +  length(p) - 1.0, p.y+1.0 );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\n\tvec3 e = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(map(p+e.xyy) - map(p-e.xyy),\n\t\t\t\t\t\t   map(p+e.yxy) - map(p-e.yxy),\n\t\t\t\t\t\t   map(p+e.yyx) - map(p-e.yyx) ) );\n\t\t\t\t\t\t   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tInitIFS();\n\t\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 1.0));\n\n    vec3 p = vec3(0.0,0.0,-4.1);\n\t\t\n\tfloat d = 0.0;\n\n\tfor(int i=0; i<MAX_RAY_STEPS; i++) {\n        d = scene(p);\t\t\n\t\t\n\t\tp += d * dir;\n\t\tif(d<0.001) break;\n    }\n\t\n\tvec3 c = vec3(0.0);\n\t\n\tif(d<0.001) {\n\t\tvec3 l = vec3(-3.0, 3.0, 3.0);\n\n\t\tvec3 n = -normal(p-dir*0.001);\n\t\t\n\t\tc = vec3(0.4);\n\n\t\tc += 1.5 * (max(0.0, dot(n, normalize(l-p)))/length(l-p));\n\n\t\tc *= AO(p, 0.5*(n+normalize(n+l)));\n\t\t\n\t\tc *= calcNormal(dir);\n\t}\n\t\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d23Dd","date":"1395286651","viewed":240,"name":"SH2014 Diffuse Cellular Broccoli","username":"yosun","description":"first try at shaders and shadertoy. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sh2014"],"hasliked":0,"parentid":"","parentname":""}}