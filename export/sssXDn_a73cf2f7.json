{"ver":"0.1","info":{"id":"sssXDn","date":"1618507389","viewed":215,"name":"Shadow maps","username":"Shcherbakov","description":"Sample from a stream: https://youtu.be/QRFu-1Q0GJM","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CAMERA_POS = vec3(0, 6, -7);\n\nbool floorTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    float floorT = floorTrace(pos, dir);\n    if (floorT >= t) {\n        return false;\n    }\n    t = floorT;\n    normal = vec3(0, 1, 0);\n    color = vec3(1, 0, 0);\n    return true;\n}\n\nbool spheresTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    const int SPHERES_COUNT = 5;\n    bool intersected = false;\n    for (int i = 0; i < SPHERES_COUNT; ++i) {\n        for (int j = 0; j < SPHERES_COUNT; ++j) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad, j - SPHERES_COUNT / 2);\n            vec2 rotate = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rotate), dot(spherePos.xz, rotate.yx * vec2(-1, 1)));\n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t) {\n                continue;\n            }\n            intersected = true;\n            t = sphere_t;\n            vec3 worldPos = pos + t * dir;\n            normal = normalize(worldPos - spherePos);\n            color = vec3(0, textureLod(iChannel0, normal, 8.0).g, 0);\n        }\n    }\n    return intersected;\n}\n\nbool spheresTrace2(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    const int SPHERES_COUNT = 3;\n    bool intersected = false;\n    for (int i = 0; i < SPHERES_COUNT; ++i) {\n        for (int j = 0; j < SPHERES_COUNT; ++j) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad + 1.0, j - SPHERES_COUNT / 2);\n            vec2 rotate = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rotate.yx * vec2(-1, 1)), dot(spherePos.xz, rotate));\n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t) {\n                continue;\n            }\n            intersected = true;\n            t = sphere_t;\n            vec3 worldPos = pos + t * dir;\n            normal = normalize(worldPos - spherePos);\n            color = vec3(textureLod(iChannel0, normal, 8.0).rr, 0) * 2.0;\n        }\n    }\n    return intersected;\n}\n\nfloat getShadow(float z, vec2 uv) {\n#if PCF\n    float shadow = 0.0;\n    for (float x = -1.5; x <= 1.5; x += 1.0) {\n        for (float y = -1.5; y <= 1.5; y += 1.0) {\n            float lightDepth = texture(iChannel1, uv + vec2(x, y) / iResolution.xy).r;\n            shadow += lightDepth < z - 1e-2 ? 0.0 : 1.0 / 16.0;\n        }\n    }\n    return shadow;\n#elif VSM\n    vec2 depth = texture(iChannel1, uv).rg;\n    depth.x -= 1e-3;\n    float d = depth.y - depth.x * depth.x;\n    return d / (d + (z - depth.x) * (z - depth.x));\n#elif ESM\n    return clamp(texture(iChannel1, uv).r * exp(1e-3 - z * ESM_FACTOR), 0.0, 1.0);\n#else\n    float lightDepth = texture(iChannel1, uv).r;\n    return lightDepth < z - 1e-3 ? 0.0 : 1.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + up * uv.y + right * uv.x);\n\n    float t = INF;\n    vec3 normal;\n    vec3 color;\n    bool inter = floorTrace(CAMERA_POS, viewVec, t, normal, color);\n    inter = spheresTrace(CAMERA_POS, viewVec, t, normal, color) || inter;\n    inter = spheresTrace2(CAMERA_POS, viewVec, t, normal, color) || inter;\n    \n    if (inter) {\n        vec3 worldPos = CAMERA_POS + t * viewVec;\n        vec3 toLight = LIGHT_POS - worldPos;\n        vec3 toPoint = normalize(-toLight);\n        vec3 lightForward = normalize(-LIGHT_POS);\n        vec3 lightUp = vec3(0, 1, 0);\n        vec3 lightRight = normalize(cross(lightForward, lightUp));\n        lightUp = cross(lightRight, lightForward);\n        \n        toPoint /= dot(lightForward, toPoint);\n        vec2 shadowUV = vec2(dot(toPoint, lightRight), dot(lightUp, toPoint));\n        shadowUV = (shadowUV / UV_SCALE * iResolution.x + iResolution.xy * 0.5) / iResolution.xy;\n        \n        float shadow = getShadow(length(toLight), shadowUV);\n        if (shadowUV.x <= 0.0 || shadowUV.x >= 1.0 || shadowUV.y <= 0.0 || shadowUV.y >= 1.0) {\n            shadow = 1.0;\n        }\n        \n        fragColor.rgb = max(0.0, dot(normal, normalize(toLight))) * color * shadow;\n    } else {\n        fragColor = texture(iChannel0, viewVec);\n    }\n    \n    uv = fragCoord / iResolution.xy;\n    //fragColor = texture(iChannel1, uv) / 10.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float INF = 1e10;\nconst vec3 LIGHT_POS = vec3(5, 5, 0);\nconst float UV_SCALE = 1.5;\nconst float ESM_FACTOR = 5.5;\n\n#define PCF 0\n#define VSM 0\n#define ESM 1\n\nfloat floorTrace(vec3 pos, vec3 dir) {\n    // (pos + t * dir).y = 0\n    float t = -pos.y / dir.y;\n    if (t < 0.0) {\n        return INF;\n    }\n    vec3 worldPos = pos + t * dir;\n    if (abs(worldPos.x) + abs(worldPos.z) > 5.0) {\n        return INF;\n    }\n    return t;\n}\n\nfloat sphereTrace(vec3 pos, vec3 dir, float r) {\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float sqrt_D = sqrt(D);\n    float t = -b - sqrt_D;\n    if (t >= 0.0) {\n        return t;\n    }\n    t = -b + sqrt_D;\n    if (t < 0.0) {\n        return INF;\n    }\n    return t;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float spheresTrace(vec3 pos, vec3 dir) {\n    const int SPHERES_COUNT = 5;\n    float t = INF;\n    for (int i = 0; i < SPHERES_COUNT; ++i) {\n        for (int j = 0; j < SPHERES_COUNT; ++j) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad, j - SPHERES_COUNT / 2);\n            vec2 rotate = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rotate), dot(spherePos.xz, rotate.yx * vec2(-1, 1)));\n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t) {\n                continue;\n            }\n            t = sphere_t;\n        }\n    }\n    return t;\n}\n\nfloat spheresTrace2(vec3 pos, vec3 dir) {\n    const int SPHERES_COUNT = 3;\n    float t = INF;\n    for (int i = 0; i < SPHERES_COUNT; ++i) {\n        for (int j = 0; j < SPHERES_COUNT; ++j) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad + 1.0, j - SPHERES_COUNT / 2);\n            vec2 rotate = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rotate.yx * vec2(-1, 1)), dot(spherePos.xz, rotate));\n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t) {\n                continue;\n            }\n            t = sphere_t;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(-LIGHT_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    uv *= UV_SCALE;\n    vec3 viewVec = normalize(forward + up * uv.y + right * uv.x);\n\n    float t = INF;\n    t = floorTrace(LIGHT_POS, viewVec);\n    t = min(t, spheresTrace(LIGHT_POS, viewVec));\n    t = min(t, spheresTrace2(LIGHT_POS, viewVec));\n    \n    fragColor = vec4(t);\n    \n    #if VSM\n    fragColor.g = t * t;\n    #elif ESM\n    fragColor = vec4(exp(t * ESM_FACTOR));\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if VSM || ESM\n    const int WIND_SIZE = 2;\n    for (int i = -WIND_SIZE; i <= WIND_SIZE; ++i) {\n        for (int j = -WIND_SIZE; j <= WIND_SIZE; ++j) {\n            fragColor += texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy);\n        }\n    }\n    fragColor /= float(2 * WIND_SIZE + 1);\n    fragColor /= float(2 * WIND_SIZE + 1);\n    #else\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}