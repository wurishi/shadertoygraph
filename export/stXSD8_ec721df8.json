{"ver":"0.1","info":{"id":"stXSD8","date":"1625739190","viewed":149,"name":"OBB of 2D cubic Bezier","username":"Capa","description":"purple ... principal-component-analysis\nyellow ... brute-force-search\ncyan ... aligning curve to x-axis\n\nnote: texts show relative sizes compared to axis-aligned-bounding-box (blue)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","cubic","boundingbox","obb","oriented"],"hasliked":0,"parentid":"stfSR7","parentname":"Cubic Bezier Analytic OBB (2D)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define CONTROL_POINTS   1\n#define CONTROL_POLYGON  1\n#define CENTER_OF_MASS   0\n\n\n#define draw( color, dist, width )                col = mix( color, col, smoothstep( width, width * 1.2, dist ) )\n#define drawSegment( color, uv, p0, p1, width )   draw( color, distSegment( uv, p0, p1 ), width )\n\n\nstruct bezier2 // cubic Bezier curve defined by its control-points\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n};\n\nstruct aabb2 // axis-aligned bounding-box\n{\n    vec2 center;\n    vec2 extent;\n};\n\nstruct obb2  // oriented bounding-box\n{\n    vec2 center;\n    vec2 extent;\n    mat2 rot;\n};\n\n\n//--------------------------------------------------------------------------------------------------------\nvec2 bezierCOM( in bezier2 curve ) // center-of-mass of cubic polynomial curve P(t) = at³ + bt² + ct + d\n{\n    // ∫ density(r) (r-R)  -->  R = ( ∫ density(r) * r ) / M\n    // \n    // if we take density as uniform and total mass (M) as 1\n    // our center-of-mass (R) equals to integral of positions (r) (divided be 1)\n    // \n    //   ∫ at³+bt²+ct+d = ∫ at³+bt²+ct+d - ∫ at³+bt²+ct+d = (a/4 + b/3 + c/2 + d) - (0)\n    // [0,1]              1                0\n    \n\tvec2 a = 3.0 * ( curve.p1 - curve.p2 ) + ( curve.p3 - curve.p0 );\n\tvec2 b = 3.0 * ( curve.p2 + curve.p0 ) - ( 6.0 * curve.p1 );\n\tvec2 c = 3.0 * ( curve.p1 - curve.p0 );\n\tvec2 d = curve.p0;\n    \n    return ( a / 4.0 + b / 3.0 + c / 2.0 + d );\n}\n\n//--------------------------------------------------------------------------------------------------------\nvec2 bezierEval( in bezier2 curve, float t )\n{\n    float s  = 1.0 - t;\n    float s2 = s * s;\n    float t2 = t * t;\n    \n    return curve.p0 * ( s2 * s       ) +  // p0 * BernsteinBasis( 0, 3, t )\n           curve.p1 * ( s2 * t * 3.0 ) +  // p1 * BernsteinBasis( 1, 3, t )\n           curve.p2 * ( t2 * s * 3.0 ) +  // p2 * BernsteinBasis( 2, 3, t )\n           curve.p3 * ( t2 * t       );   // p3 * BernsteinBasis( 3, 3, t )\n}\n\n//--------------------------------------------------------------------------------------------------------\n// float bezierEval( float v0, float v1, float v2, float v3, float t )    // 12 * MUL\n// {\n//     float s  = 1.0 - t;\n//     float s2 = s * s;\n//     float t2 = t * t;\n// \n//     return v0 * ( s2 * s       ) +\n//            v1 * ( s2 * t * 3.0 ) +\n//            v2 * ( t2 * s * 3.0 ) +           \n//            v3 * ( t2 * t       );\n// }\n\n//--------------------------------------------------------------------------------------------------------\n// float bezierEval( float v0, float v1, float v2, float v3, float t )    // 11 * MUL\n// {\n//     float s = 1.0 - t;\n//     \n//     return ( s * s * s ) * v0 + ( 3.0 * s * t ) * ( s * v1 + t * v2 ) + ( t * t * t ) * v3;\n// }\n\n//--------------------------------------------------------------------------------------------------------\nfloat bezierEval( float v0, float v1, float v2, float v3, float t )    // 6 * MUL\n{\n    float u0 = v0 + ( v1 - v0 ) * t;  // lerp( v0, v1, t );\n    float u1 = v1 + ( v2 - v1 ) * t;  // lerp( v1, v2, t );\n    float u2 = v2 + ( v3 - v2 ) * t;  // lerp( v2, v3, t );\n    \n    float w0 = u0 + ( u1 - u0 ) * t;  // lerp( u0, u1, t );\n    float w1 = u1 + ( u2 - u1 ) * t;  // lerp( u1, u2, t );\n    \n    return w0 + ( w1 - w0 ) * t;      // lerp( w0, w1, t );\n}\n\n//--------------------------------------------------------------------------------------------------------\naabb2 bezierAABB( in bezier2 curve )\n{\n    vec2 p0 = curve.p0;\n    vec2 p1 = curve.p1;\n    vec2 p2 = curve.p2;\n    vec2 p3 = curve.p3;\n    \n    // we initialize bounding-box's min & max by p0 and p3\n    \n    vec2 mi = min( p0, p3 );\n    vec2 ma = max( p0, p3 );\n    \n    // then we must also find x,y extremas along the curve\n    // we can do it by defining Bezier curve's polynomial form P(t) = at³ + bt² + ct + d\n    // \n\t//\ta = 3 * ( p1 - p2 ) + ( p3 - p0 )\n\t//\tb = 3 * ( p2 + p0 ) - ( 6 * p1 )\n\t//\tc = 3 * ( p1 - p0 )\n\t//\td = p0\n    // \n    // extremas are located at roots of derivation P'(t) = 3at^2 + 2bt + c\n    // - to simplify computation we can divide all coeffs by same number (leaving roots unchanged)\n    // - in out case by 3... so as final P'(t) coefficients we get\n\n    vec2 a = p3 - p0 + 3.0 * ( p1 - p2 );\n    vec2 b = 2.0 * ( p0 - 2.0 * p1 + p2 );\n    vec2 c = p1 - p0;\n    \n    // usual solution of quadratic equation ax^2 + bx + c = 0\n    //   x = ( -b +- sqrt(det) ) / 2a ... where: det = b² - 4ac\n    //\n    // but it can also be computed as\n    //   x = ( -0.5 b +- sqrt(det) ) / a ... where: det = (0.5b)² - ac\n    \n    vec2 b_neghalf = b * -0.5;\n    vec2 discr     = b_neghalf * b_neghalf - a * c;\n\n    // extremas for x-coordinates\n\n    if( discr.x > 0.0 ) // quadratic equation has two real roots\n    {\n        discr.x = sqrt( discr.x );\n        \n        float t0 = ( b_neghalf.x - discr.x ) / a.x;\n        float t1 = ( b_neghalf.x + discr.x ) / a.x;\n        \n        if( t0 > 0.0 && t0 < 1.0 )\n        {\n            float q = bezierEval( p0.x, p1.x, p2.x, p3.x, t0 );\n            \n            mi.x = min( mi.x, q );\n            ma.x = max( ma.x, q );\n        }\n        \n        if( t1 > 0.0 && t1 < 1.0 )\n        {\n            float q = bezierEval( p0.x, p1.x, p2.x, p3.x, t1 );\n            \n            mi.x = min( mi.x, q );\n            ma.x = max( ma.x, q );\n        }\n    }\n    \n    // extremas for y-coordinates\n\n    if( discr.y > 0.0 )\n    {\n        discr.y = sqrt( discr.y );\n        \n        float t0 = ( b_neghalf.y - discr.y ) / a.y;\n        float t1 = ( b_neghalf.y + discr.y ) / a.y;\n        \n        if( t0 > 0.0 && t0 < 1.0 )\n        {\n            float q = bezierEval( p0.y, p1.y, p2.y, p3.y, t0 );\n            \n            mi.y = min( mi.y, q );\n            ma.y = max( ma.y, q );\n        }\n        \n        if( t1 > 0.0 && t1 < 1.0 )\n        {\n            float q = bezierEval( p0.y, p1.y, p2.y, p3.y, t1 );\n            \n            mi.y = min( mi.y, q );\n            ma.y = max( ma.y, q );\n        }\n    }\n    \n    // result\n    \n    aabb2 bbox;\n    \n    bbox.center = ( mi + ma ) * 0.5;\n    bbox.extent = ( ma - mi ) * 0.5;\n    \n    return bbox;\n}\n\n// https://math.stackexchange.com/questions/4538971/aligning-b%c3%a9zier-curve/4539407#4539407\n//--------------------------------------------------------------------------------------------------------\naabb2 bezierAABB_2( in bezier2 curve )\n{\n\tvec2 mi = min( curve.p0, curve.p3 );\n\tvec2 ma = max( curve.p0, curve.p3 );\n\t\t\t\n\tfloat[2] tArr;\n\tint      tNum = 0;\n\t\t\t\n\tfor( int i = 0; i < 2; ++i )\n\t{\n\t\tfloat p0 = curve.p0[ i ];\n\t\tfloat p1 = curve.p1[ i ];\n\t\tfloat p2 = curve.p2[ i ];\n\t\tfloat p3 = curve.p3[ i ];\n\t\t\t\t\n\t\tfloat denom = p0 - 3.0 * ( p1 - p2 ) - p3;\n\t\tif( abs( denom ) <= 1e-5f )\n\t\t{\n\t\t\tdenom = 2.0 * ( p2 + p0 ) - 4.0 * p1;\n\t\t\tif( abs( denom ) > 1e-5f )\n\t\t\t{\n\t\t\t\ttArr[ 0 ] = ( p0 - p1 ) / denom;\n\t\t\t\ttNum      = 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat r = 0.0;\n\t\t\tfloat s = p2 * ( p2 - p1 ) + p1 * ( p1 - p3 ) + p0 * ( p3 - p2 );\n\t\t\tif( s > 0.0 )\n\t\t\t\tr = sqrt( s );\n            \n            float inv = 1.0 / denom;\n            float tmp = p0 - 2.0 * p1 + p2;\n\t\t\t\n\t\t\ttArr[ 0 ] = ( tmp + r ) * inv;\n\t\t\ttArr[ 1 ] = ( tmp - r ) * inv;\n\t\t\ttNum      = 2;\n\t\t}\n\t\t\t\t\n\t\tfor( int j = 0; j < tNum; ++j )\n\t\t{\n\t\t\tfloat t = tArr[ j ];\n\t\t\tif( t > 0.0 && t < 1.0 )\n\t\t\t{\n\t\t\t\tfloat c = bezierEval( p0, p1, p2, p3, t );\n\t\t\t\t\t\t\n\t\t\t\tmi[ i ] = min( mi[ i ], c );\n\t\t\t\tma[ i ] = max( ma[ i ], c );\n\t\t\t}\n\t\t}\n\t}\n    \n    aabb2 bbox;\n    \n    bbox.center = ( mi + ma ) * 0.5;\n    bbox.extent = ( ma - mi ) * 0.5;    \n\t\n\treturn bbox;\n}\n\n//--------------------------------------------------------------------------------------------------------\nbool estimateTransformation( in bezier2 curve, out vec2 translation, out mat2 rotation )\n{\n    // move/shift curve so 'p0' is at origin (sets 'p0' to zero)\n    // - following polynomials will by simplified\n    \n    vec2 p1 = curve.p1 - curve.p0;\n    vec2 p2 = curve.p2 - curve.p0;\n    vec2 p3 = curve.p3 - curve.p0;\n    \n    // polynomial coefficients of Bezier curve P(t) = at³ + bt² + ct + d\n    // - 3rd order, last coeff is zero (as p0 is zero)\n    \n    vec2 a = 3.0 * ( p1 - p2 ) + p3;\n    vec2 c = 3.0 * p1;\n    vec2 b = 3.0 * p2 - 2.0 * c;\n    \n    // expected mean of points along Bezier curve \n    // - it seams to be probably integral of P(t)... why ?!?\n    \n    vec2 mean = a / 4.0 + b / 3.0 + c / 2.0;\n    \n    // coefficients of polynomial Px(t)*Py(t)\n    // - 6th order, last two coeffs zero\n    \n    float axy = a.x * a.y;\n    float bxy = a.x * b.y + b.x * a.y;\n    float cxy = a.x * c.y + b.x * b.y + c.x * a.y;\n    float dxy = b.x * c.y + c.x * b.y;\n    float exy = c.x * c.y;\n    \n    // coefficients of Polynomials Px(t)*Px(t) and Py(t)*Py(t)\n    // - 6th order, last two coeffs zero\n    \n    vec2 aB = a * a;\n    vec2 bB = a * b * 2.0;\n    vec2 cB = a * c * 2.0 + b * b;\n    vec2 dB = b * c * 2.0;\n    vec2 eB = c * c;\n    \n    // compute definite integrals of these 3 polynomials on range [0,1]\n    // - ∫(0) is zero (all coeffs are mutliplied by 't' and it is zero)\n    // - ∫ a*x^n dx = (a*x^(n+1)) / (n+1) ... in our case 'x' is one (1^something is 1)\n    \n    float xy =  axy / 7.0 +  bxy / 6.0 +  cxy / 5.0 +  dxy / 4.0 +  exy / 3.0;\n    float xx = aB.x / 7.0 + bB.x / 6.0 + cB.x / 5.0 + dB.x / 4.0 + eB.x / 3.0;\n    float yy = aB.y / 7.0 + bB.y / 6.0 + cB.y / 5.0 + dB.y / 4.0 + eB.y / 3.0;\n    \n    // construct covariance 2x2 matrix\n    // - it is symetric so just upper triangle is needed\n    \n    float cov_00 = xx - mean.x * mean.x;\n    float cov_01 = xy - mean.x * mean.y;\n    float cov_11 = yy - mean.y * mean.y;\n    \n    // through roots of characteristic polynomial we should compute\n    // eigen-values and eigen-vectors of covariance matrix\n    // \n    // characteristic polynomial of 2x2 matrix A: ax² + bx + c where\n    //   a = + 1\n    //   b = - trace(A)\n    //   c = + determinant(a)\n    // \n    // note: again using modified method for solving quadratic equations\n    \n    float eigen_a         = + 1.0;\n    float eigen_b_neghalf = - ( cov_00 + cov_11 ) * - 0.5;\n    float eigen_c         = + ( cov_00 * cov_11 - cov_01 * cov_01 );\n    \n    float discr = eigen_b_neghalf * eigen_b_neghalf - eigen_a * eigen_c;\n    if( discr <= 0.0 )\n        return false;\n    \n    // eigen-values (lambdas) are roots\n    \n    discr = sqrt( discr );\n    \n    float lambda0 = ( eigen_b_neghalf - discr ) / eigen_a;\n    float lambda1 = ( eigen_b_neghalf + discr ) / eigen_a;\n    \n    // eigen-vectors of covariance matrix represent axes of system\n    \n    vec2 eigenvector0 = vec2( cov_01, lambda0 - cov_00);\n    vec2 eigenvector1 = vec2( cov_01, lambda1 - cov_00 );\n    \n    // result\n    \n    rotation[0] = normalize( eigenvector0 );\n    rotation[1] = normalize( eigenvector1 );        \n    \n    translation = mean + curve.p0; // restore initial shift\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------------------------------\nbool bezierOBB_PCA( in bezier2 curve, out obb2 obb )\n{\n    // try to find transformation of OBB via principal-component-analysis\n    \n    vec2 translation;\n    mat2 rotation;\n    \n    if( estimateTransformation( curve, translation, rotation ) == false )\n        return false;\n        \n    // transform Bezier's control-points into the local-space of the OBB\n    //\n    // 1) instead of using inverse of rot-matrix we can just use transpose of rot-matrix\n    //    because rot-matrix is \"orthonormal\" (each column has unit length and is perpendicular\n    //    to every other column)\n    // \n    // 2) resulting vector of [transpose(rot) * v] is same as [v * rot] !!!\n    \n    bezier2 transformed;\n    \n//  transformed.p0 = inverse( rotation ) * ( curve.p0 - translation );  // inverse(A) = transpose(A)\n//  transformed.p1 = inverse( rotation ) * ( curve.p1 - translation );  // if 'A' is orthonormal\n//  transformed.p2 = inverse( rotation ) * ( curve.p2 - translation );\n//  transformed.p3 = inverse( rotation ) * ( curve.p3 - translation );\n    \n    transformed.p0 = ( curve.p0 - translation ) * rotation;\n    transformed.p1 = ( curve.p1 - translation ) * rotation;\n    transformed.p2 = ( curve.p2 - translation ) * rotation;\n    transformed.p3 = ( curve.p3 - translation ) * rotation;    \n    \n    // compute AABB of curve in local-space\n    \n    aabb2 aabb = bezierAABB( transformed );\n    \n    // transform AABB back to world-space:\n    \n    obb.center = translation + rotation * aabb.center;\n    obb.extent = aabb.extent;\n    obb.rot    = rotation;\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------------------------------\nobb2 bezierOBB_BruteForceSearch( in bezier2 curve, float rotation_step )\n{\n    // move curve to origin for better numerical precision/stability\n    // by shifting control-points by theirs mean\n    \n    mat2 rotation;\n    vec2 translation = ( curve.p0 + curve.p1 + curve.p2 + curve.p3 ) * 0.25;\n    \n    curve.p0 -= translation;\n    curve.p1 -= translation;\n    curve.p2 -= translation;\n    curve.p3 -= translation;\n    \n    // search for \"optimal\" oriented-bounding-box by rotation curve in range (0,90]\n    // (number of steps is given by specified \"precision\")\n    \n    obb2    obb;\n    float   min_area = 1e9;\n    \n    aabb2   aabb;\n    bezier2 transformed;\n    \n    int     steps = int( ceil( 90.0 / rotation_step )); // in degrees\n    \n    rotation_step *= Deg2Rad;                           // in radians\n    \n    for( int i = 1; i <= steps; ++i )\n    {\n        // setup rotation\n        \n        float a  = rotation_step * float( i );\n        float ca = cos( a );\n        float sa = sin( a );\n        \n        rotation[0] = vec2(  ca, sa );\n        rotation[1] = vec2( -sa, ca );\n        \n        // transform Bezier's control-points into the local-space of the OBB\n        // (we already \"moved\" it to origin so only \"inverse\" rotation is needed)\n        \n        transformed.p0 = curve.p0 * rotation;\n        transformed.p1 = curve.p1 * rotation;\n        transformed.p2 = curve.p2 * rotation;\n        transformed.p3 = curve.p3 * rotation;          \n        \n        // compute AABB of curve in local-space\n        \n        aabb = bezierAABB( transformed );\n                           \n        // is it better (smaller) bounding-box?\n        \n        float aabb_area = aabb.extent.x * aabb.extent.y * 4.0;\n        \n        if( aabb_area < min_area )\n        {\n            min_area   = aabb_area;\n            obb.center = translation + rotation * aabb.center;\n            obb.extent = aabb.extent;\n            obb.rot    = rotation;\n        }\n    }\n    \n    return obb;\n}\n\n//--------------------------------------------------------------------------------------------------------\nobb2 bezierOBB_Aligned( in bezier2 curve )\n{\n    // shift curve so 'p0' is at origin (will become zero)\n    \n    bezier2 transformed;\n    \n    transformed.p0 = vec2(0);\n    transformed.p1 = curve.p1 - curve.p0;\n    transformed.p2 = curve.p2 - curve.p0;\n    transformed.p3 = curve.p3 - curve.p0;\n    \n    // rotate it around origin so 'p2' is on x-axis\n    // \n    // - columns of matrix represents axes of transformed system and we already have one:\n    //   normalized vector from origin to p2 represents x-axis of wanted rotated bounding-box\n    // - 2nd axis is perpendicular to the 1st one so we just rotate 1st one counter-clockwise\n    //   by 90 degrees\n    \n    float p3Length = length( transformed.p3 );\n    vec2  axis     = transformed.p3 / p3Length; // normalized (unit length)\n    mat2  rotation;\n    \n    rotation[0] = vec2(  axis.x, axis.y );      // column 0 ... x-axis\n    rotation[1] = vec2( -axis.y, axis.x );      // column 1 ... y-axis ... CCW x-axis by 90 degrees\n    \n    // notes:\n    // - rotating 'p0' is pointless as it is \"zero\" and none rotation will change that\n    // - rotating 'p3' will move it to \"global\" x-axis so its y-coord will be zero and x-coord\n    //   will be its distance from origin\n    \n//  transformed.p0 = transformed.p0 * rotation;\n//  transformed.p1 = transformed.p1 * rotation;\n//  transformed.p2 = transformed.p2 * rotation;\n//  transformed.p3 = transformed.p3 * rotation;\n    \n    transformed.p1 = transformed.p1 * rotation;\n    transformed.p2 = transformed.p2 * rotation;\n    transformed.p3 = vec2( p3Length, 0.0 );\n    \n    // compute AABB of curve in local-space\n    \n    aabb2 aabb = bezierAABB( transformed );\n    \n    // transform AABB back to world-space\n    \n    obb2 obb;\n    \n    obb.center = curve.p0 + rotation * aabb.center;\n    obb.extent = aabb.extent;\n    obb.rot    = rotation;\n    \n    return obb;\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    return distance( p, mix( a, b, clamp( dot( p-a, b-a ) / dot( b-a, b-a ), 0.0, 1.0 )));\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distAABB( in vec2 p, in aabb2 bbox ) \n{\n    vec2 q = abs( p - bbox.center ) - bbox.extent;\n    vec2 m = vec2( min( q.x, q.y ), max( q.x, q.y ) );\n    \n    return m.x > 0.0 ? length( q ) : abs( m.y );\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distOBB( in vec2 p, in obb2 bbox ) \n{\n//  vec2 q = abs( inverse( bbox.rot ) * ( p - bbox.center ) ) - bbox.extent;\n    vec2 q = abs( ( p - bbox.center ) * bbox.rot ) - bbox.extent;    \n    vec2 m = vec2( min( q.x, q.y ), max( q.x, q.y ) );\n    \n    return m.x > 0.0 ? length( q ) : abs( m.y );\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distBezier( in vec2 p, in bezier2 curve ) \n{\n    const int num  = 32;\n    float     dist = 1e4;\n    vec2      next = curve.p0;\n    \n    for( int i = 1; i <= num; ++i )\n    {\n        vec2 curr = next;\n             next = bezierEval( curve, float(i) / float(num) );\n             dist = min( dist, distSegment( p, curr, next ) );\n    }\n    \n    return dist;\n}\n\n//--------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float width_curve   = 0.015;\n    const float width_bbox    = 0.005;\n    const float width_polygon = 0.003;\n    const float  size_points  = 0.025;    \n    const vec2   size_text     = vec2( 8.0, 15.0 );\n\n    vec2 uv  = ( fragCoord - iResolution.xy * 0.5 ) / iResolution.y * 2.0;\n    vec4 col = vec4( 0.05, 0.05, 0.05, 1.0 );\n\n    // control points\n    \n    float   time = iTime * 0.33 - 0.7;\n    bezier2 curve;    \n    \n    curve.p0 = 0.8 * sin( time * 0.7 + vec2( 3.0, 1.0 ) );\n    curve.p1 = 0.8 * sin( time * 1.1 + vec2( 0.0, 6.0 ) );\n    curve.p2 = 0.8 * sin( time * 1.3 + vec2( 4.0, 2.0 ) );\n    curve.p3 = 0.8 * sin( time * 1.5 + vec2( 1.0, 5.0 ) );\n    \n    // get the curve's bounding boxes\n    \n    aabb2 aabb;\n    float colMul;\n    \n    if( mod( iTime, 2.0 ) < 1.0 )\n    {\n        aabb = bezierAABB  ( curve );\n        colMul = 0.7;\n    }\n    else\n    {\n        aabb = bezierAABB_2( curve );\n        colMul = 1.3;\n    }\n        \n        \n    float aabb_area = aabb.extent.x * aabb.extent.y * 4.0;\n\n    obb2  obb_pca;\n    float obb_pca_area = -1.0;\n    \n    if( bezierOBB_PCA( curve, obb_pca ) == true )\n    {\n        obb_pca_area = obb_pca.extent.x * obb_pca.extent.y * 4.0;\n    }\n    \n    obb2  obb_bfs      = bezierOBB_BruteForceSearch( curve, 0.5 );\n    float obb_bfs_area = obb_bfs.extent.x * obb_bfs.extent.y * 4.0;\n    \n    obb2  obb_ali      = bezierOBB_Aligned( curve );\n    float obb_ali_area = obb_ali.extent.x * obb_ali.extent.y * 4.0;    \n    \n    float ratio_pca = obb_pca_area / aabb_area;\n    float ratio_bfs = obb_bfs_area / aabb_area;\n    float ratio_ali = obb_ali_area / aabb_area;\n    \n    // draw control polygon\n    \n#if CONTROL_POLYGON\n    \n    drawSegment( vec4( 0.3 ), uv, curve.p0, curve.p1, width_polygon );\n    drawSegment( vec4( 0.3 ), uv, curve.p1, curve.p2, width_polygon );\n    drawSegment( vec4( 0.3 ), uv, curve.p2, curve.p3, width_polygon );\n    \n#endif    \n    \n    // draw curve\n\n    draw( vec4( 1.0, 0.0, 0.0, 1.0 ), distBezier( uv, curve ), width_curve );\n    \n    // draw axis-aligned-bounding-box\n    \n    aabb.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 0.1, 0.3, 1.0, 1.0 ) * colMul, distAABB( uv, aabb ), width_bbox );\n    \n    // draw oriented-bounding-box found via PCA\n    \n    if( obb_pca_area > 0.0 )\n    {\n        obb_pca.extent += width_curve + width_bbox * 0.5;\n        draw( vec4( 1.0, 0.0, 1.0, 1.0 ), distOBB( uv, obb_pca ), width_bbox );\n    }\n    \n    // draw oriented-bounding-box found via brute-force-search\n    \n    obb_bfs.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 1.0, 1.0, 0.0, 1.0 ), distOBB( uv, obb_bfs ), width_bbox * 1.2 );\n    \n    // draw oriented-bounding-box found by aligning curve with x-axis\n    \n    obb_ali.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 0.0, 1.0, 1.0, 1.0 ), distOBB( uv, obb_ali ), width_bbox * 0.8 );\n    \n    // draw control points\n    \n#if CONTROL_POINTS\n    \n    draw( vec4( 1.0 ), distance( uv, curve.p0 ), size_points );\n    draw( vec4( 1.0 ), distance( uv, curve.p1 ), size_points );\n    draw( vec4( 1.0 ), distance( uv, curve.p2 ), size_points );\n    draw( vec4( 1.0 ), distance( uv, curve.p3 ), size_points );\n    \n#endif\n    \n    // print relative sizes of oriented-bounding-boxes vs axis-aligned one\n\n    col = mix( col, vec4( 1.0, 0.0, 1.0, 1.0 ), PrintValue( ratio_pca, 5.0, 4.0, (fragCoord - vec2( -30.0,  7.0 )) / size_text ));\n    col = mix( col, vec4( 1.0, 1.0, 0.0, 1.0 ), PrintValue( ratio_bfs, 5.0, 4.0, (fragCoord - vec2( -30.0, 27.0 )) / size_text ));\n    col = mix( col, vec4( 0.0, 1.0, 1.0, 1.0 ), PrintValue( ratio_ali, 5.0, 4.0, (fragCoord - vec2( -30.0, 47.0 )) / size_text ));\n    \n    // center of mass\n    \n#if CENTER_OF_MASS\n\n    vec2 centerOfMass = bezierCOM( curve );\n    draw( vec4( 0.0, 1.0, 0.0, 1.0 ), length( uv - centerOfMass ), 0.015 );\n    \n#endif\n    \n    // final fragment color\n    \n    fragColor = vec4( sqrt( col.rgb ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nconst float Deg2Rad = 3.1415926535897932385 / 180.0;\n\n\n//--------------------------------------------------------------------------------------------------------\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat PrintValue( float value, float maxDigits, float decimalPlaces, vec2 pos )\n{       \n    if( pos.y < 0.0 || pos.y >= 1.0 ) return 0.0;\n    \n    bool neg = value < 0.0;\n\tvalue = abs( value );\n    \n\tfloat log10Value   = log2( value ) / log2( 10.0 );\n\tfloat biggestIndex = max( floor( log10Value ), 0.0 );\n\tfloat digitIndex   = maxDigits - floor( pos.x );\n\tfloat charBin      = 0.0;\n    \n\tif( digitIndex > ( - decimalPlaces - 1.01 ))\n    {\n\t\tif( digitIndex > biggestIndex )\n        {\n\t\t\tif( neg && (digitIndex < ( biggestIndex + 1.5 )))\n                charBin = 1792.0;\n\t\t}\n        else\n        {\n\t\t\tif( digitIndex == -1.0 )\n            {\n\t\t\t\tif( decimalPlaces > 0.0 )\n                    charBin = 2.0;\n\t\t\t}\n            else\n            {\n                float reducedRangeValue = value;\n                if( digitIndex < 0.0 )\n                {\n                    reducedRangeValue = fract( value );\n                    digitIndex += 1.0;\n                }\n                \n\t\t\t\tfloat digitValue = abs( reducedRangeValue / pow( 10.0, digitIndex ));\n                charBin = DigitBin( int( floor( mod( digitValue, 10.0 ))));\n\t\t\t}\n        }\n\t}\n    \n    return floor( mod(( charBin / pow( 2.0, floor( fract(pos.x) * 4.0 ) + ( floor(pos.y * 5.0) * 4.0 ))), 2.0 ));\n}\n","name":"Common","description":"","type":"common"}]}