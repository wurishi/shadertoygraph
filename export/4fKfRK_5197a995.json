{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\nI started this experiment by giving ChatGPT o1 an image of a geometric pattern.\nI then asked it to write a Shadertoy shader that would make that pattern.\n\nThe shader that it created is the first shader that you see at the bottom.\n\nI then asked it to golf the shader as much as possible.\nAfter a few attempts of colaborative golfing, the final version is 127 chars!\n*/\n\n// Jedi Master Fabrice is smarter than ChatGPT o1 and I!\n// 99 chars:\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u = fract(u*3./iResolution.y) -.5;\n    o = o*0.+ 99.*sin( 4.*atan(u.x,u.y) );\n}\n\n\n// Final version - 127 chars\n// Collaboration between Greg and o1\n/**\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u = fract(u*=3./iResolution.y);\n    float x=u.x, y=u.y;\n    o = vec4( x>.5 ? y>.5 ? y>x : x+y>1. : y>.5 ? x+y<1. : y<x );\n}\n/**/\n\n\n// Fifth o1 shader - 147 chars:\n// The prompt was:\n// \"I realized the the ceil(u) is not needed.\n// Can you think of anything else you can do to further reduce this shader?\"\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o = vec4(fract(u*=6./iResolution.y),mod(u,2.));\n    o = vec4(o.z<1.?o.w<1.?o.y<o.x:o.x+o.y<1.:o.w<1.?o.x+o.y>1.:o.y>o.x);\n}\n/**/\n\n\n\n// Fourth o1 shader - 158 chars:\n// The prompt was:\n// \"I have golfed your shader down to 162 characters.\n// Can you think of other clever techniques of reducing this shader?\"\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 f=fract(u*=6./iResolution.y),\n         m=mod(ceil(u),2.);\n    o=vec4(m.x<1.?(m.y<1.?f.y<f.x:f.x+f.y<1.):(m.y<1.?f.x+f.y>1.:f.y>f.x));\n}\n/**/\n\n\n// Third Greg golfing and o1 golfing - 168 chars:\n/**\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u *= 6. / iResolution.y;\n    vec2 f = fract(u),\n         c = ceil(u),\n         m = mod(c,2.);\n    float s = f.x + f.y;\n\n    // ternary conditions produce a bool, which when put in vec4(...) becomes 1.0 or 0.0\n    o = vec4(m.x<1. ? (m.y<1. ? f.y<f.x : s<1.) : (m.y<1. ? s>1. : f.y>f.x));\n}\n/**/\n\n\n// Second o1 shader - 300 chars:\n// The prompt was:\n// \"Use clever coding techniques to reduce the number of characters of this\n// shader so that it is as small as possible.\"\n/**\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.y;\n    float n = 6.;\n    float a = floor(u.x*n), b = floor(u.y*n);\n    float x = fract(u.x*n), y = fract(u.y*n);\n    float i = mod(a,2.), j = mod(b,2.);\n    float s = x+y;\n\n    // condition for black vs white\n    bool k = (i<1. ? (j<1. ? y<x : s<1.) : (j<1. ? s>1. : y>x));\n\n    fragColor = vec4(k?0.:1., k?0.:1., k?0.:1., 1.);\n}\n/**/\n\n\n\n// First o1 shader - 498 chars:\n// The prompt was:\n// \"Write a GLSL Shadertoy shader that produces the attached image.\"\n\n/**\n// Shadertoy code to produce the given black & white triangle pattern\n// Use this code at https://www.shadertoy.com/new\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates so (0,0) is bottom-left and (1,1) is top-right\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Number of cells horizontally and vertically\n    float Nx = 6.0;\n    float Ny = 6.0;\n    \n    // Determine which cell we're in\n    float xCell = floor(uv.x * Nx);\n    float yCell = floor(uv.y * Ny);\n    \n    // Fractional position within the cell (0 to 1)\n    float fx = fract(uv.x * Nx);\n    float fy = fract(uv.y * Ny);\n    \n    // Compute parity to decide which of the 4 patterns to use\n    int ix = int(mod(xCell, 2.0));\n    int iy = int(mod(yCell, 2.0));\n    \n    bool isBlack = false;\n    // Based on the (ix, iy) pattern, decide orientation and which half is black.\n    // Pattern (2x2 repeating):\n    // (0,0): top-left black triangle => black if fy < fx\n    // (1,0): top-right black triangle => black if fx + fy > 1\n    // (0,1): bottom-left black triangle => black if fx + fy < 1\n    // (1,1): bottom-right black triangle => black if fy > fx\n    if (ix == 0 && iy == 0) {\n        isBlack = (fy < fx);\n    } else if (ix == 1 && iy == 0) {\n        isBlack = (fx + fy > 1.0);\n    } else if (ix == 0 && iy == 1) {\n        isBlack = (fx + fy < 1.0);\n    } else {\n        // (ix == 1 && iy == 1)\n        isBlack = (fy > fx);\n    }\n    \n    // Output either black or white\n    vec3 color = isBlack ? vec3(0.0) : vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n/**/","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fKfRK","date":"1734204124","viewed":102,"name":"Golfing with ChatGPT o1","username":"GregRostami","description":"This shader was created by ChatGPT o1 by giving it a single reference image and was later golfed by o1 as well.\nRead the shader comments on the history of this project.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["2d","pattern","geometric","ai","golfing"],"hasliked":0,"parentid":"","parentname":""}}