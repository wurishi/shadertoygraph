{"ver":"0.1","info":{"id":"lssfRS","date":"1496789897","viewed":196,"name":"OJ - Scrubber","username":"rammoskar","description":"A non-interactive showcase of parts of the game Scrubber which we made for the Birdie lan in 2016. Gameplay from the real game can been seen here: https://www.youtube.com/watch?v=BVCrbK-m9V8","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus62( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length6(q)-t.y;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b) //, float k )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sminNode( float a, float b) //, float k )\n{\n\tfloat k = 2.0; //2\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat smoothstep2(float edge0, float edge1, float val){\n\tval = clamp(val, edge0, edge1);\n\t\n\treturn (val - edge0)/(edge1 - edge0);\n\t\n}\n\n\n#define UNCALCULATED 0\n#define UNKNOWN 1\n#define HIDDEN 2\n\nfloat cp( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0f;\n    x /= w;\n    return 1.0f - x*x*(3.0f-2.0f*x);\n}\n\n#define modTime mod(iTime, 45.0)\n#define tick iTime //uniform float tick;\n//uniform sampler2D noiseP;\n#define time (modTime + 00.0) * 5.0\n#define zp (233.0 + time * 3.0)\n#define endx clamp(zp - 800.0, 0.0, 1.0) * min(50.0, (zp - 800.0)) * 0.5 + 10.0 * cp(zp, 30.0, 443.0)\n#define playerPos vec3(\t-25.0  + 47.0 * (1.0-smoothstep(233.0, 363.0, zp)) + clamp(zp - 333.0, 0.0, 1.0)*sin((zp - 333.0) * 0.009) * 20.0 + endx, \\\n\t\t\t\t\t\t-3.0 - 7.0*cp(zp,20.0, 395.0) - 7.0 * cp(zp, 20.0, 490.0) - 7.0 * cp(zp, 20.0, 595.0) - 7.0 * cp(zp, 20.0,  693.0) - 4.0 * cp(zp, 20.0,  793.0),\\\n                         zp) \n                            \n#define time2 (mod(iTime + 0.3, 45.0) + 00.0) * 5.0\n#define zp2 (233.0 + time2 * 3.0)\n#define endx2 clamp(zp2 - 800.0, 0.0, 1.0) * min(50.0, (zp2 - 800.0)) * 0.5 + 10.0 * cp(zp2, 30.0, 443.0)\n#define playerPos2 vec3(\t-25.0  + 47.0 * (1.0-smoothstep(233.0, 363.0, zp2)) + clamp(zp2 - 333.0, 0.0, 1.0)*sin((zp2 - 333.0) * 0.009) * 20.0 + endx2, \\\n\t\t\t\t\t\t-3.0 - 7.0*cp(zp2,20.0, 395.0) - 7.0 * cp(zp2, 20.0, 490.0) - 7.0 * cp(zp2, 20.0, 595.0) - 7.0 * cp(zp2, 20.0,  693.0) - 4.0 * cp(zp2, 20.0,  793.0),\\\n                         zp2)                             \n\n#define pupt min(mod(iTime, 30.0), 3.1415 * 2.0)\n#define playerUp vec3(sin(-pupt), cos(-pupt), 0.0) //uniform vec3 playerUp;\n#define playerForward normalize(playerPos2 - playerPos)//vec3(0.0, 0.0, 1.0) //uniform vec3 playerForward;\n#define rollVel 0.0 //uniform float rollVel;\n#define pitchVel abs(playerPos.x - playerPos2.x)*0.015 //uniform float pitchVel;\n#define yawVel abs(playerPos.y - playerPos2.y)*0.015//0.0 //uniform float yawVel;\n\n#define battery 1.0 //uniform float battery;\n\n\n#define nextNodePos (modTime < 6.5 || modTime > 34.0 ? vec3(-19.88954f ,-1.027408477f ,340.05685f) : vec3(-37.05946f ,-1.5914066f ,748.065f)) //uniform vec3 nextNodePos;\n#define playerSpeed 0.0 //uniform float playerSpeed;\n\n#define MAT_CHEESE 4.0\n\n#define MAT_PLAYER 7.0\n#define MAT_BLOCK 9.0\n#define MAT_NODE 10.0\n\n#define MAT_OBSTACLE 12.0\n#define MAT_OBSTACLE_WALL 13.0\n\n\n#define shake 0.0 //uniform float shake;\n#define shakeTick 0.0 //uniform float shakeTick;\n\n#define EPS 0.01\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 unn(vec2 a, float dis, float mat)\n{\n\treturn a.x < dis ? a : vec2(dis, mat);\n}\n\n\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm; //inverse(xm * ym * zm);\n}\n\nfloat pyrField(vec2 p, float base, float h )\n{\n\tvec2 pyr = min(mod(p, base), base -  mod(p, base));\n\treturn min(pyr.x, pyr.y) * h;\n}\n\n#define TORUS 0.0\n#define OBSTACLE 1.0\n#define CAVE 2.0\n#define CHEESE 3.0\n#define NOISE_TUNNEL 4.0\n#define MOD_BLOCKS 5.0\n#define TURNING 6.0\n\n#define LEN_TORUS 350.0\n#define LEN_OBSTACLE 500.0\n#define LEN_CAVE 200.0\n#define LEN_CHEESE 100.0\n#define LEN_NOISE_TUNNEL 200.0\n#define LEN_MOD_BLOCKS 300.0\n#define LEN_TOT LEN_TORUS + LEN_OBSTACLE + LEN_CAVE + LEN_CHEESE + LEN_NOISE_TUNNEL + LEN_MOD_BLOCKS \n\nvec2 map(vec3 p, vec3 rd)\n{\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p,s)-0.5*s;\n\tvec3 n = vec3(trunc(p / s));\n\tfloat t = trunc(mod(n.z, LEN_TOT));  // % 4\n\tif (p.z <= 0.0) {\n\t\tt = 0.0;\n\t}\n\tif (t < LEN_TORUS) { \n\t\tvec3 ms = vec3(200, 40, 200);\n\t\tfloat dis = -sdTorus(mod(n + vec3(-13, -21, 37), ms) - ms * 0.5, vec2(100, 15)); //float dis = sdTorus(n % 100 - 50, vec2(40, 20));\n\n\t\tif (dis < 0.0) {\n\t\t\treturn vec2(udRoundBox(q , vec3(0.25), 0.23), MAT_BLOCK);\n\t\t} else if (p.z > 0.0){\n\t\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\t\tfloat a = max(dis - 1.73, b + EPS);\n\t\t\t\n\t\t\tfloat z =((sign(rd.z) == 1.0 ? 1.0 : 0.0) * LEN_TORUS - sign(rd.z) * mod(p.z, LEN_TOT)) / abs(rd.z);\n\t\t\treturn vec2(max(EPS, min(a, z + EPS)), -1);\n\t\t} else {\n\t\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\t\tfloat a = max(dis - 1.73, b + EPS);\n\t\t\t\n\t\t\treturn vec2(max(EPS, a), -1);\n\t\t}\n\t} else if (t < LEN_TORUS + LEN_OBSTACLE ) {\n\t\tvec3 np = vec3(n.x + sin(n.z * 0.01) * 35.0 + sin(n.z * 0.004) * 35.0,  n.y, n.z);\n\t\tvec2 res = vec2(-sdBox(np, vec3(12.0 + sin(np.z * 0.008) * 3.0, 12.0 + sin(np.z * 0.005) * 3.0, 40000.0)), MAT_OBSTACLE_WALL);\n\t\tres = unn(res, sdCylinder(vec3(np.x, np.y, mod(np.z, 200.0) - 100.0), vec3(0.0, 0.0, 4.0)), MAT_OBSTACLE);\n\t\tres = unn(res, sdCylinder(vec3(np.y, np.z, mod(np.z + 50.0, 100.0) - 50.0), vec3(0.0, 0.0, 4.0)), MAT_OBSTACLE);\n\t\tvec3 hp = vec3(np.x, np.y, mod(np.z, 300.0) - 150.0);\n\t\tres = unn(res, max(-sdHexPrism(hp, vec2(5, 5))\n\t\t\t\t\t\t\t,sdBox(hp, vec3(15.0, 15.0, 3.0))), MAT_OBSTACLE);\n\t\tif (res.x < 0.0) {\n\t\t\tif(res.y == MAT_OBSTACLE) {\n\t\t\t\treturn vec2(udRoundBox(q , vec3(0.3), 0.2), res.y); \n\t\t\t}else{\n\t\t\t\treturn vec2(udRoundBox(q , vec3(0.4), 0.1), res.y);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}  else  {\n\n\t\tfloat modSize = 39.0;\n\t\tvec3 mo = mod(n - vec3(0.0, -18.0, 0.0), modSize) - modSize * 0.5;\n\t\tfloat dis = max(-sphere(mo, 22.0), sdBox(mo, vec3(20.0))); \n\t\tif (dis < 0.0) {\n\t\t\tvec2 np = vec2(p.x + p.y * 0.5, p.y * 0.5 + p.z);\n\t\t\treturn vec2(udRoundBox(q + 0.07 * (0.5 - 0.0 /*texture(noiseP, np).x*/), vec3(0.38) , 0.1), MAT_CHEESE);\n\t\t} else { \n\t\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\t\tfloat a = max(EPS, max(dis - 1.73, b + EPS));\n\t\t\t\n\t\t\tfloat z =((sign(rd.z) == 1.0 ? 1.0 : 0.0) * LEN_CHEESE - sign(rd.z) * (p.z - (LEN_TORUS + LEN_OBSTACLE + LEN_CAVE) )) / abs(rd.z);\n\t\t\treturn vec2(min(a, z + EPS), -1);\n\t\t}\n\t} \n\t\t\n\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\treturn vec2(max(EPS, min(d.x, min(d.y, d.z)) + EPS) , -1);\n}\n\n\n\nmat3 camRot()\n{\n\tvec3 right = cross(playerForward, playerUp);\n\treturn mat3(playerForward.x, playerForward.y, playerForward.z, playerUp.x, playerUp.y, playerUp.z, right.x, right.y, right.z);\n}\n\n\nfloat player(vec3 p, mat3 invAircraftRot)\n{\n\tvec3 pt = p - playerPos; \n\tfloat s = clamp(playerSpeed * 0.005, 0.0, 0.1); \n\tfloat r = max(abs(yawVel), max(abs(pitchVel), abs(rollVel)));\n\tvec3 ptr = invAircraftRot * pt;\n\treturn smin(sdTorus(ptr, vec2(0.5 +  r,0.15 - r)), max(sdBox(ptr+vec3(0, -0.5, 0), vec3(0.5)) , sphere(ptr, 0.4f)));\n}\n\nvec2 node(vec3 p, vec3 rd)\n{\t\n\tvec3 pn = p - nextNodePos;\n\tpn = pn * rot(tick * 0.5, tick, tick * 0.75);\n\t\n\tfloat dis = sphere(pn, 3.0) +\n\t\t0.3 * sin(- tick * 4.0 + pn.y * 0.75 ) +\n\t  \t0.2 * sin( tick * 2.0 + pn.x*2.0) +\n\t\t0.4 * sin( tick * 5.0 + pn.z);\n\treturn vec2(dis, MAT_NODE); \n\t\n}\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\treturn map(p, rd);\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return 0.3;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = playerPos - playerForward * (2.0 + abs(playerSpeed)/0.5f)  + playerUp * (0.5 + abs(playerSpeed)/2.0f);\n\tvec3 eyeDir = vec3(0, -0.5, -1);\n\tvec3 tar = vec3(0 , 15, 0);\n\tvec3 forward = normalize(playerForward);\n\t\n    vec3 up = normalize(playerUp);\n    vec3 right = (cross(playerForward, up));\n\n    \n    float f = 1.0;\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x);\n    \n    \n\n    vec3 color = vec3(0, 0, 0); \n    vec3 skyColor = color;\n   \tvec3 ambient = vec3(0.5, 0.5, 0.1); \n            \n    float t = 0.0;\n    int N = 1;\n\n    vec3 ro = eye + (forward -0.05*sin((tick-shakeTick)*7.0)*shake*right) * f + right * u + up * v;\n\tvec3 rd = normalize(ro - eye);\n\tvec3 rdStart = rd;\n\tfloat ref = 1.0;\n\n\t\n\tmat3 invAircraftRot = inverse(camRot());\n\n\tbool nodeBool = true;\n\t\n\t\n\tint imax = 200; //200\n\tfloat tmax = 300.0;  // 300\n\tfor(int j = 0; j < 2; ++j)\n    {\n    \tt = 0.0;\n    \t for(int i = 0; i < imax && t < tmax; ++i)\n   \t\t {\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t        float dt = max(d, EPS);\n\t\t\tbool t2found = false;\n\t        if(d < EPS || i == imax - 1 || t + dt >= tmax)\n\t        {\n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\tvec3 oc = ro - playerPos;\n\t\t\t\tfloat val = dot(rd, oc)*dot(rd, oc) - dot(oc, oc) + 0.45;\n\t        \tfloat t2 = 0.0;\n\t\t\t\tif (val > 0.0 && length(oc) < t) {\n\t\t        \tfor(int i2 = 0; i2 < 30 && t2 < 10.0; ++i2) {\n\t\t        \t\tvec3 p2 = ro + rd * t2;\n\t\t        \t\tfloat d2 = player(p2, invAircraftRot);\n\t\t\t\t        if(d2 < EPS){\n\t\t\t\t        \tif (t2 < t) {\n\t\t\t\t        \t\tt2found = true;\n\t\t\t\t        \t\td = d2;\n\t\t\t\t        \t\tm = MAT_PLAYER;\n\t\t\t\t        \t\tp = p2;\n\t\t\t\t        \t\t\n\t\t\t\t\t\t\t    vec3 ep = vec3(0.01,0,0);\n\t\t\t\t\t\t\t    normal.x = player(p + ep.xyz, invAircraftRot) - player(p - ep.xyz, invAircraftRot);\n\t\t\t\t\t\t\t    normal.y = player(p + ep.yxz, invAircraftRot) - player(p - ep.yxz, invAircraftRot);\n\t\t\t\t\t\t\t    normal.z = player(p + ep.yzx, invAircraftRot) - player(p - ep.yzx, invAircraftRot);\n\t\t\t\t\t\t\t    normal = normalize(normal);\n\t\t\t\t        \t}\n\t\t\t\t        \tbreak;\n\t\t\t\t        }\n\t\t\t\t        t2 += d2;\n\t\t        \t}\n\t        \t} \n\t        \t\n\n\t        \t{\n\t\t\t\t\tvec3 oc = ro - nextNodePos;\n\t\t\t\t\tfloat val = dot(rd, oc)*dot(rd, oc) - dot(oc, oc) + 20.0; \n\t\t        \tfloat t3 = 0.0;\n\t\t\t\t\tif (val > 0.0 && length(oc) < t) {\n\t\t\t        \tfor(int i3 = 0; i3 < 200 && t3 < 200.0; ++i3) {\n\t\t\t        \t\tvec3 p3 = ro + rd * t3;\n\t\t\t        \t\tvec2 res = node(p3, rd);\n\t\t\t\t\t\t\tfloat d3 = res.x;\n\t\t\t\t\t        if(d3 < EPS){\n\t\t\t\t\t        \tif ((t3 < t && t3 < t2 && t2found) || (t3 < t && !t2found)) {\n\t\t\t\t\t        \t\td = res.x;\n\t\t\t\t\t        \t\tm = res.y;\n\t\t\t\t\t        \t\tp = p3;\n\t\t\t\t\t        \t\t\n\t\t\t\t\t\t\t\t    vec3 ep = vec3(0.01,0,0);\n\t\t\t\t\t\t\t\t    normal.x = node(p + ep.xyz, rd).x - node(p - ep.xyz, rd).x;\n\t\t\t\t\t\t\t\t    normal.y = node(p + ep.yxz, rd).x - node(p - ep.yxz, rd).x;\n\t\t\t\t\t\t\t\t    normal.z = node(p + ep.yzx, rd).x - node(p - ep.yzx, rd).x;\n\t\t\t\t\t\t\t\t    normal = normalize(normal);\n\t\t\t\t\t   \n\t\t\t\t\t        \t}\n\t\t\t\t\t        \tbreak;\n\t\t\t\t\t        }\n\t\t\t\t\t        t3 += d3;\n\t\t\t        \t}\n\t\t        \t}\n\t\t        \t\n\t        \t}\n\n\t        \t\n\t        \n\t        \tvec3 realNormal = normal;\n\t\t\t\tvec3 invLight = normalize(playerPos - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tfloat realDiffuse = max(0.,dot(invLight, realNormal));\n\t        \t if (m == MAT_PLAYER) {\n\t        \t\tcolor = mix(color, 0.0*vec3(0.3,0.4,0.2) * (1.0 + realDiffuse), ref); \n\t        \t\tif (j == 0) \n\t        \t\tcolor += ref*vec3(specular(realNormal, -invLight, normalize(eye - p), 70.0));\n\t        \t} else if (m == MAT_BLOCK){\n\t\t\t\t\tvec3 n = trunc(p);\n\t\t\t\t\tvec3 c = vec3(sin(n.y) * 0.1 + 0.5, sin(n.y) * 0.1 + 0.1, sin(n.y) * 0.1 + 0.1);\n\t        \t\tcolor = mix(color, 0.7*c * (1.0 + diffuse), ref);\n\t        \t\tif (j == 0) \n        \t\t\t\tcolor += ref*vec3(specular(normal, -invLight, normalize(eye - p), 70.0));\n\t \t\t\t} else if (m == MAT_NODE) {\n\t \t\t\t\tvec3 c = vec3(0.3,0.8 ,0.2)*0.6;\n\t \t\t\t\tcolor = mix(color, 0.7* c * (1.0 + diffuse), ref); \n\t        \t\tcolor += 0.5*ref*vec3(specular(normal, -invLight, normalize(eye - p), 70.0));\n\t        \t\tnodeBool = false; \t\t\t\t\n \t\t\t\t}else if (m == MAT_CHEESE) {\n \t\t\t\t\tvec3 n = trunc(p);\n \t\t\t\t\tvec3 c = vec3(1, 1, 0.5);\n \t\t\t\t\tvec3 q = mod(p, 1.0);\n \t\t\t\t\tfloat f = length(sin(n));\n \t\t\t\t\tcolor = (1.0 - 0.25*f)*mix(color, 0.7*c * (1.0 + diffuse), ref); \n \t\t\t\t\tif (j == 0) \n\t        \t\t\tcolor += ref*vec3(specular(normal, -invLight, normalize(eye - p), 70.0));\n \t\t\t\t}else if (m == MAT_OBSTACLE) {\n \t\t\t\t\tvec3 n = trunc(p);\n \t\t\t\t\tvec3 c = vec3(0.9, 0.1, 0.1);\n \t\t\t\t\tcolor = mix(color, 0.7*c * (1.0 + diffuse), ref); \n \t\t\t\t\tif (j == 0) \n\t        \t\t\tcolor += ref*vec3(specular(normal, -invLight, normalize(eye - p), 70.0));\n \t\t\t\t}else if (m == MAT_OBSTACLE_WALL) {\n \t\t\t\t\tif (mod(-tick*50.0 + (p.z), 300.0) > 5.0\n \t\t\t\t\t\t|| trunc(mod(p.z, LEN_TOT)) == LEN_TORUS || trunc(mod(p.z, LEN_TOT)) == LEN_TORUS + LEN_OBSTACLE - 1.0) {\n\t \t\t\t\t\tcolor = mix(color, 0.7*vec3(0.8) * (1.0 + diffuse), ref);\n \t\t\t\t\t} else {\n\t \t\t\t\t\tcolor = mix(color, 0.7*vec3(1, 0, 0) * (1.0 + diffuse), ref);\n \t\t\t\t\t}\n \t\t\t\t\tif (j == 0)  \n\t        \t\t\tcolor += ref*vec3(specular(normal, -invLight, normalize(eye - p), 70.0));\n \t\t\t\t}\n \t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\tfloat df = max(0.0, pow(length(playerPos - p), 2.0));\n\t\t\t\t\n\n\t\t\t\tfloat f = (1.0) / (1.0 + 0.1*df);\n\t\t\t\tfloat ang = acos(dot(forward + 0.1*sin((tick-shakeTick)*7.0)*shake*right, normalize(p - (playerPos + forward))));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfloat batteryLight = 2.0*clamp(battery, 0.0, 0.5);\n\t\t\t\tfloat maxang = 10.0*3.14/180.0 *batteryLight;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfloat f2 = (1.0 - smoothstep(maxang, maxang + 0.5*batteryLight, ang))*30.0;\n\t\t\t\t\n\t\t\t\tif(m == MAT_NODE) {\n\t\t\t\t\tf = 1.0;\n\t\t\t\t}\n\t\t\t\tif(j == 0){\n\t\t\t\t\tcolor *= clamp(max(f, (smoothstep(0.0, 1.0, batteryLight)*5.0)*f*f2), 0.0, 1.0); \n\t\t\t\t} else if (nodeBool) {\n\t\t\t\t\tcolor *= clamp((f * 10.0 * smoothstep(0.0, 1.0, batteryLight)), 0.0, 1.0);\n\t\t\t\t}\n                \n\t\t\t\tcolor = clamp(color, 0.0, 1.0);\n\t            rd = reflect(rd, realNormal);\n\t            ro = p + rd*0.02;\n\t            \n\t        \tif(m == MAT_BLOCK) {\n\t        \t\tref *= 0.0;\n\t        \t} else if (m == MAT_PLAYER){\n\t        \t\tref *= 0.8;\n\t        \t} else if (m == MAT_NODE) {\n\t        \t\tref *= 0.0; \n\t        \t} else {\n\t        \t\tref = 0.0;\n\t        \t}\n\t        \t\n\t        \tif (ref <= 0.01) {\n\t        \t\tj = 10000;\n\t        \t} \n\n\t           \tbreak;\n\t        }\n\t\n\t        t += dt;\n    \t}\n    }\n \n    \n   \n    fragColor = vec4(color * (1.0 - smoothstep(44.0, 44.8, modTime)) ,  1.0);\n}\n\n\n  ","name":"Image","description":"","type":"image"}]}