{"ver":"0.1","info":{"id":"Mf3yRS","date":"1730788283","viewed":130,"name":"Laplacian blend - simple","username":"nbardy","description":"blends movie and image with laplacian","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Discrete effect selection (20 second cycle)\n    float cycleTime = mod(iTime, 20.0);\n    int effectIndex = int(cycleTime / 6.66666);\n    \n    // Multi-scale video feature extraction\n    float offset = 1.0 / iResolution.y;\n    vec2 offsets[9] = vec2[](\n        vec2(-offset,  offset), vec2(0.0, offset), vec2(offset,  offset),\n        vec2(-offset,  0.0),    vec2(0.0, 0.0),    vec2(offset,  0.0),\n        vec2(-offset, -offset), vec2(0.0,-offset), vec2(offset, -offset)\n    );\n    \n    // Extract video features at multiple scales\n    vec3 laplacian = vec3(0.0);\n    vec3 vorticity = vec3(0.0);\n    vec2 gradient = vec2(0.0);\n    float videoIntensity = 0.0;\n    \n    for(int i = 0; i < 9; i++) {\n        vec3 pixelColor = texture(iChannel1, uv + offsets[i]).rgb;\n        laplacian += pixelColor * (i == 4 ? 8.0 : -1.0);\n        videoIntensity += length(pixelColor);\n        if(i != 4) {\n            vorticity += cross(vec3(offsets[i], 0.0), vec3(pixelColor));\n            gradient += offsets[i] * length(pixelColor);\n        }\n    }\n    videoIntensity /= 9.0;\n    \n    vec2 finalDisplacement = vec2(0.0);\n    vec3 effectColor = vec3(1.0);\n    \n    if(effectIndex == 0) {\n        // Helmholtz Wave Effect\n        float V = length(laplacian) * 4.0;\n        float phase = iTime * 2.0 + uv.x * 15.0 + uv.y * 12.0;\n        vec2 waveDir = vec2(cos(phase), sin(phase));\n        finalDisplacement = waveDir * V * videoIntensity * 0.5 *\n            (1.0 + sin(dot(uv, gradient) * 10.0));\n        effectColor = vec3(1.0, 0.9, 0.8) * (1.0 + videoIntensity);\n    }\n    else if(effectIndex == 1) {\n        // Geometric Vortex Effect\n        float curvature = length(laplacian) * 5.0;\n        vec2 vortexCenter = vec2(\n            0.5 + cos(iTime) * 0.2,\n            0.5 + sin(iTime) * 0.2\n        );\n        vec2 toCenter = uv - vortexCenter;\n        float dist = length(toCenter);\n        vec2 tangent = vec2(-toCenter.y, toCenter.x) / (dist + 0.001);\n        \n        finalDisplacement = tangent * curvature * videoIntensity * 0.6 *\n            exp(-dist * 3.0) * (1.0 + sin(iTime * 3.0));\n        effectColor = vec3(0.8, 1.0, 0.9) * (1.0 + length(vorticity) * 0.3);\n    }\n    else {\n        // Complex Singularity Effect\n        vec2 z = (uv - 0.5) * 2.0;\n        float strength = length(laplacian) * videoIntensity * 3.0;\n        \n        for(int i = 0; i < 3; i++) {\n            float angle = iTime * (1.0 + float(i) * 0.5);\n            vec2 pole = vec2(cos(angle), sin(angle)) * 0.7;\n            vec2 d = z - pole;\n            float r = length(d);\n            finalDisplacement += d * strength / (r * r + 0.01);\n        }\n        finalDisplacement *= 0.4;\n        effectColor = vec3(0.9, 0.8, 1.0) * (1.0 + videoIntensity * 0.5);\n    }\n    \n    // Apply displacement to input image\n    vec2 warpedUV = uv + finalDisplacement;\n    vec4 warpedImage = texture(iChannel0, warpedUV);\n    \n    // Enhance features based on video motion\n    float motionIntensity = length(gradient);\n    float edgeIntensity = length(laplacian);\n    \n    // Add motion trails and highlights\n    vec3 finalColor = warpedImage.rgb;\n    finalColor *= 1.0 + motionIntensity * effectColor * 0.4;\n    finalColor += edgeIntensity * effectColor * 0.2;\n    \n    // Add temporal variation\n    float pulseEffect = 0.3 * sin(iTime * 3.0 + length(finalDisplacement) * 10.0);\n    finalColor *= 1.0 + pulseEffect * videoIntensity;\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}