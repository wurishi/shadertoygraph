{"ver":"0.1","info":{"id":"McsGDl","date":"1703709232","viewed":100,"name":"Electric field inside a box","username":"wxy_equation","description":"numerical wave equation with two buffer, intepreted as oscillating electric field inside a metal box. It took 15 second to initialize. Does not support full screen.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["bl"],"hasliked":0,"parentid":"4csGDl","parentname":"Schrodinger Equation Sim"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = length(fragCoord-iResolution.xy/2.);\n    float f = fetch(iChannel0, fragCoord);\n    //field lines\n    f = abs(fract(f)-.5)/fwidth(f);\n    f = r>100.7?smoothstep(1.1,0.,f):0.;\n    //centre circle\n    f += smoothstep(1.5, 0., abs(r-100.));\n    \n    fragColor = vec4(f);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//encoding functions\nuint packUnorm4x8(vec4 x) \n{\n    x = round(clamp(x, 0., 1.) * 255.);\n    uvec4 r = uvec4(x);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackUnorm4x8(uint x) \n{\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 v = vec4(r) / 255.0;\n    return v;\n}\n\nfloat unormToFloat(vec4 x)\n{\n    return uintBitsToFloat(packUnorm4x8(x));\n}\n\nvec4 floatToUnorm(float x)\n{\n    return unpackUnorm4x8(floatBitsToUint(x));\n}\n\n//read float from latent image\nfloat fetch(sampler2D tex, vec2 coord)\n{\n    return unormToFloat(texelFetch(tex, ivec2(floor(coord)), 0));\n}\n\nmat3 Laplacian = mat3(\n0.,  1., 0.,\n1., -4., 1., \n0.,  1., 0.\n);\n\n#define PI 3.141592","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/********************displacement buffer********************/\n\n//set initial condition\nvec4 initiate(vec2 coord)\n{  \n//take grey scale from an image\n    vec4 color = texelFetch(iChannel2, ivec2(coord), 0);\n    float f = dot(color.xyz, vec3(1.))/3.;\n    return floatToUnorm(f*50.); \n}\n\n//time propagation\nvec4 propagate(vec2 coord) \n{\n    float f = fetch(iChannel0, coord);\n    float v = fetch(iChannel1, coord);\n    return floatToUnorm(f+0.1*v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0) fragColor = initiate(fragCoord);\n    else if((iFrame&1)==0) \n        fragColor = propagate(fragCoord);\n    else\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/********************velocity buffer********************/\n\n//set initial condition\nvec4 initiate(vec2 coord)\n{  \n    return floatToUnorm(0.);\n}\n\n//time propagation\nbool boundary(vec2 p) {\n//is the point inside of the boundary?\n    bool f = p.x<0.||p.y<0.||p.x>=iResolution.x||p.y>=iResolution.y;\n    f = f||length(p-iResolution.xy/2.)<100.;\n    return !f;  \n}\nfloat relax(float t0) {\n//filter out high frequency for better visual\n    return 2.*smoothstep(-t0, t0, iTime)-1.;\n}\nvec4 propagate(vec2 coord) \n{     \n    float v = fetch(iChannel1, coord);\n    float div = 0.;\n    vec2 p;\n    for(int i=-1; i<=1; i++) {\n    for(int j=-1; j<=1; j++) {\n        p = coord+vec2(i, j);\n        div += fetch(iChannel0, (boundary(p)?p:coord))*Laplacian[i+1][j+1];\n    }}\n    return floatToUnorm(relax(15.)*v+0.25*div);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0) \n        fragColor = initiate(fragCoord);\n    else if((iFrame&1)==1) \n        fragColor = propagate(fragCoord);\n    else\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}","name":"Buffer B","description":"","type":"buffer"}]}