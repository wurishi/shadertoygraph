{"ver":"0.1","info":{"id":"XttBRj","date":"1540289618","viewed":155,"name":"Multicolored recursive FBM","username":"dust","description":"Experimenting with computing multicolored + recursive fbm() values. Still using Perlin noise as a basis function.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","2d","fractal","noise","noise","perlinnoise","fbm","perlin","rgb","recursive","fbmnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv));\n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n    \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Compute fractal noise for a given pixel position\n//#define SCALING_FBM\nfloat fbm(vec2 uv)\n{\n    const uint depth = 5u;\n    const vec2 dFreq = vec2(1.01f, 1.08f);\n    const float dAmpl = 1.1f;\n    vec2 sfreq = vec2(1.01f); // Starting noise scaling frequency\n    vec2 rfreq = vec2(1.1f); // Starting noise rotational frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        f += ampl * abs(Perlin(uv));\n        float fi = float(i);\n        uv += vec2(cos(fi), \n                   sin(fi)) * (iTime * 0.25f) * rfreq;\n        #ifdef SCALING_FBM\n        \tuv *= sfreq;\n            sfreq *= dFreq + vec2(0.1f * float(i));\n        #endif\n        rfreq *= dFreq + vec2(0.1f * float(i));\n        ampl *= dAmpl;\n    }\n    return f;\n}\n\n//#define NOISE_MIRR\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    #ifdef NOISE_MIRR\n    \tfloat hAspect = (iResolution.x / iResolution.y) * 0.5f;\n    \tvec2 uv = abs((fragCoord / iResolution.y) - vec2(hAspect, 0.5f)) / cellSize;\n    #else\n    \tvec2 uv = (fragCoord / iResolution.y) / cellSize;\n    #endif\n    // Generate per-channel fbm()\n    // fbm(p + fbm(p + fbm(p)))\n    // FBM recursion function from iq through the Book of Shaders:\n    // https://iquilezles.org/articles/warp\n    // https://thebookofshaders.com/13/\n    float fbm0 = fbm(uv + vec2(\n        \t\t\t fbm(uv + vec2(\n                    \t fbm(uv)))));\n    vec2 uu = uv + vec2(1.0f, 0.0f);\n    float fbm1 = fbm(uu + vec2(\n        \t\t\t fbm(uu + vec2(\n                    \t fbm(uu)))));\n    vec2 vv = uv + vec2(0.0f, 1.0f);\n    float fbm2 = fbm(vv + vec2(\n        \t\t\t fbm(vv + vec2(\n                    \t fbm(vv)))));\n\tvec3 rgb = vec3(fbm0, fbm1, fbm2);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}