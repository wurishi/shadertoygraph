{"ver":"0.1","info":{"id":"cdBGzG","date":"1671360254","viewed":187,"name":"Papier","username":"Alpaga","description":"Change view and time with mouse.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sea","paper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment to see the plain scene\n#define SLICES\n\n\n//#define AA\n#define SHADOWS\n\nconst float fov = 40.0;\nconst int STEPS = 1000;\n\nconst int CLOUD = 0;\nconst int SKY = 1;\nconst int SEA = 2;\nconst int SUN = 3;\nconst int MOON = 4;\nconst int FISH = 5;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n};\n\nvec3 ambient = vec3(10);\nconst vec3 lightDirection = normalize(vec3(3,2,4));\nconst vec3 lightCol = .7*vec3(1,1,.5);\n\nvec2 delta = vec2(0.0,0.001);\n\nfloat time;\n\n\n// Hash function from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(vec3 p) {\n    return length(p-vec3(1,0,0))-1.;\n}\n\nfloat fbm(vec3 p) {\n    float h = 0.;\n    float f = 1.;\n    float a = 1.;\n    for(int i=0; i<3; i++) {\n        h += a*noise(a*p);\n        f *= 2.;\n        a *= .5;\n        p.xy *= mat2(.8,.6,-.6,.8);\n    }\n    return h;\n}\nfloat negTriangle(float x, float a) {\n    return x > 0. ? x : abs(mod(x+a,2.*a)-a);\n}\n// From https://www.shadertoy.com/view/Ml3Gz8\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdCloud(vec3 p) {\n    float id = floor(.1*(p.x+time));\n    p.x = mod(p.x+time,10.)-5.;\n//    p.x += mod(time,24.)-12.;\n    \n    p.y -= 2.*hash11(id);\n    float x = .2*cos(2.*time+3.*id);\n    float a = length(vec3(.3,.4,.6)*(p-vec3(2.,1.5,-.3)))-.3;\n    float b = length(vec3(.3,.3,.4)*(p-vec3(1.1+x,1.5,-.6)))-.2;\n    float c = length(vec3(.3,.3,.4)*(p-vec3(1.8,2.3+.5*x,-.6)))-.2;\n    float d = length(vec3(.3,.3,.4)*(p-vec3(2.8-x,2.,-.6)))-.2;\n    \n    float res = smin(smin(a,b,.1),smin(c,d,.1),.1);\n    return res;\n}\n// Signed distance fields\nfloat sdSky(vec3 p) {\n    return p.z+3.;\n}\n\nfloat sdSun(vec3 p) {\n    p -= vec3(-7.*cos(.1*time),7.*sin(.1*time)-3.,-3);\n    float d = length(vec3(.4,.4,.8)*p)-.5;\n    float a = abs(mod(10.*atan(p.y,p.x),6.2832)-3.1416);\n    float l = length(p.xy);\n    float r = max(l-.75*a,length(vec3(.4,.4,1.8)*p)-.9);\n    return min(d,r);\n}\nfloat sdMoon(vec3 p) {\n    p -= vec3(-7.*cos(.1*time+3.14),7.*sin(.1*time+3.14)-3.,-3);\n    float d = length(vec3(.4,.4,.8)*p)-.5;\n    p += vec3(.8,.2,-.8);\n    \n    d = max(d, .4-length(vec3(.4,.4,.4)*p));\n    return d;\n}\nfloat sdSea(vec3 p) {\n    float h = .5*sin(2.*p.x)*sin(4.*p.z-time)-p.z-3.;\n    return .3*(p.y - h);\n}\nfloat sdFish(vec3 p) {\n    float id = floor(time/4.);\n    float t = mod(time,4.)-2.;\n    float h = hash11(id);\n    float dir = sign(h - .5);\n    vec2 pos = vec2(dir*3.*t+4.*h-2.,-3.*t*t);\n    vec2 dpos = normalize(vec2(3.*dir,-6.*t));\n    p.xy -= pos;\n    p.xy = mat2(dpos.x,-dpos.y,dpos.y,dpos.x)*p.xy;\n    p.y = abs(p.y)+.5;\n    p.z += 1.+10.*mod(h,.1);\n    float body = length(p)-1.;\n    \n    p.x += 1.3;\n    float tail = max(length(p)-.9,.1-p.x+.3*p.z);\n    \n    return min(body,tail);\n}\n\nfloat sdScene(vec3 p, out int id) {\n    float d,minD = 1e6;\n    vec2 pos,dir;\n    int tmp;\n\n    // Sun\n    d = sdSun(p);\n    if(d<minD) {\n        id = SUN;\n        minD = d;\n    }\n    // Moon\n    d = sdMoon(p);\n    if(d<minD) {\n        id = MOON;\n        minD = d;\n    }\n    // Fish\n    d = sdFish(p);\n    if(d<minD) {\n        id = FISH;\n        minD = d;\n    }\n    \n    // Sea\n    d = sdSea(p);\n    if(d<minD) {\n        id = SEA;\n        minD = d;\n    }\n\n    // Cloud\n    d = sdCloud(p);\n    if(d<minD) {\n        id = CLOUD;\n        minD = d;\n    }\n   \n    // Sky\n    d = sdSky(p);\n    if(d<minD) {\n        id = SKY;\n        minD = d;\n    }\n    \n    return minD;\n}\n\n// Cuts the scene into slices of given thickness and space between them\nfloat sdSlices(vec3 p, float space, float thickness, out int id) {\n \tfloat c = space*(floor(p.z/space)+.5);\n    float minD, d;\n    int tmp;\n   \n    float n = .01*texture(iChannel0, .1*p.xy).r;\n\n    minD = length(max(vec2(\n            sdScene(vec3(p.x,p.y,c),id),\n            abs(p.z-c)-.5*thickness-n),0.));\n    d = length(max(vec2(\n            sdScene(vec3(p.x,p.y,c-space),tmp),\n            abs(p.z-(c-space))-.5*thickness-n),0.));\n    if(d<minD) {\n        minD = d;\n        id = tmp;\n    }\n    \n    return minD;\n}\nfloat sd(vec3 p, out int id) {\n    #ifdef SLICES\n    return sdSlices(p,.15,.0,id) - .005;\n    #else\n    return sdScene(p,id);\n    #endif\n}\nMaterial material(vec3 p, int id) {\n    vec3 alb, spe = vec3(.004);\n    switch(id) {\n        case CLOUD:\n            alb = vec3(1);\n            break;\n        case SKY:\n            alb = vec3(0,0,1);\n            break;\n        case SEA:\n            alb = vec3(0,.2*(p.z+3.),1);\n            break;\n        case SUN:\n            alb = vec3(1,.5+(p.z+3.),0);\n            break;\n        case MOON:\n            alb = mix(vec3(.4,.5,1),vec3(.8,.9,1),smoothstep(0.3,.5,p.z+3.));\n            break;\n        case FISH:\n            float id = floor(time/4.);\n\n            alb = mix(vec3(1,.1,.01),vec3(.01,1,.2),cos(id));\n            break;\n    }\n    return Material(alb,spe);\n}\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id))-d);\n}\n\nfloat march(vec3 start, vec3 dir, out int id, out int steps) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    steps=0;\n    for(; steps<STEPS; steps++) {\n        if(d<epsilon) break;\n        d = sd(start + total*dir,id);\n        total += d;\n    }\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon || total>5.) break;\n        d = sd(start + total*dir, id);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight) {\n    float minD = lightMarch(p+0.05*toLight, toLight);\n    return smoothstep(0.0,0.01,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);\n    \n    int id, steps;\n    \n    float d = march(start, dir, id, steps);\n\n\n    vec3 p = start + d * dir;\n\n    vec3 normal = normal(p);\n    Material mat = material(p,id);\n\n    // AO\n    color += (ambient/(1.+4.*float(steps)))*mat.albedo;\n\n    // Diffuse\n    vec3 diff = mat.albedo * max(dot(lightDirection, normal), 0.0);\n    // Specular\n    vec3 h = normalize(lightDirection-dir);\n    vec3 spec = mat.specular * pow(max(dot(h,normal),0.0), 50.0);\n\n    #ifdef SHADOWS\n    // Shadow\n    float sh = shadow(p, lightDirection);\n    #else\n    float sh = 1.;\n    #endif\n\n    color += sh*(diff + spec)*lightCol;\n\n    // Reflection of environment\n    vec3 ref = reflect(dir, normal);\n    vec3 env = vec3(1);\n    #ifdef SHADOWS\n    // Shadow\n    sh = shadow(p, ref);\n    #else\n    sh = 1.;\n    #endif\n\n    color += sh * vec3(mat.specular) * env;\n\n    return color;\n}\n\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime+8.5;\n    \n    vec3 cam = vec3(.8*sin(.1*time),.5,11);\n    vec3 center = vec3(0);//cam.x,cam.y,0);\n\n    if(iMouse.z>0.0) {\n        cam.y -= 10.*(iMouse.y-abs(iMouse.w))/iResolution.y;\n        cam.x -= 10.*(iMouse.x-abs(iMouse.z))/iResolution.x;\n        time = 100.0*iMouse.x/iResolution.x;\n    }\n    \n    mat3 m = setupCamera(cam, center, vec3(0,1,0));\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n    \n    \n    // Gamma\n    color = pow(color,vec3(.45));\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}