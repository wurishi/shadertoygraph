{"ver":"0.1","info":{"id":"csVfD1","date":"1700750669","viewed":36,"name":"sphere + plane//","username":"mazek","description":"Added a plane to the sphere shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"mdyBWh","parentname":"raymarching test#1 SPHERE//"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst float EPSILON = .0001;\n \n\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.0;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sceneSDF(vec3 samplePoint){\n    vec4 _plane = vec4(0.0,1.0,0.0, 1.0);\n    return min(sdPlane(samplePoint, normalize(_plane.xyz), _plane.w),sphereSDF(samplePoint));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n    float depth = start;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if(dist<EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth>=end){\n            return end;\n        }\n    }\n    return end;\n}\n    \n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.;\n    float z = size.y / tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));  \n}\n\nvec3 estimateNormal(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if(dotLN < 0.){\n        return vec3(0.,0.,0.);\n    }\n    if(dotRV < 0.){\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV,alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye){\n    const vec3 ambientLight = .5 * vec3(1.,1.,1.);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(3.,3.,3.);\n    vec3 light1Intensity = vec3(.85,.85,.85);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos,light1Intensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 eye = vec3(0.,0.,5.);\n    float dist = shortestDistanceToSurface(eye,dir,MIN_DIST,MAX_DIST);\n    \n    if(dist > MAX_DIST - EPSILON){\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    vec3 p = eye + dist *dir;\n    vec3 K_a = vec3(0.,0.,1.);\n    vec3 K_d = vec3(1.,1.,1.);\n    vec3 K_s = vec3(.4,.4,.4);\n    float shininess = 10.;\n    \n    vec3 color = phongIllumination(K_a,K_d,K_s,shininess,p,eye);\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}