{"ver":"0.1","info":{"id":"wlc3zH","date":"1575588488","viewed":265,"name":"[TWITCH] Inside the volcano","username":"Flopine","description":"This shader is heavily inspired by Zelda Ocarina Of Time FireTemple boss ;) \nMade it during a live on twitch you can see here: https://www.twitch.tv/flopine","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lava","twitchstream"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\n#define PI 3.141592\n#define t (time*0.5)\n\nvec2 hash22 (vec2 x)\n{return fract(sin(vec2(dot(x,vec2(12.45,16.1)),dot(x,vec2(26.1,28.14))))*1245.2);}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(16.4,17.4)))*1875.2);}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float id = floor(a/per);\n    float l = length(p);\n    a = mod (a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>=rep/2.) id = abs(id);\n    return id;\n}\n\nvec3 voro (vec2 uv)\n{\n    vec2 uv_id = floor (uv);\n    vec2 uv_st = fract(uv);\n\n    vec2 m_diff;\n    vec2 m_point;\n    vec2 m_neighbor;\n    float m_dist = 10.;\n\n    for (int j = -1; j<=1; j++)\n    {\n        for (int i = -1; i<=1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash22(uv_id + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point+t);\n            vec2 diff = neighbor + point - uv_st;\n\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = point;\n                m_diff = diff;\n                m_neighbor = neighbor;\n            }\n        }\n    }\n\n    m_dist = 10.;\n    for (int j = -2; j<=2; j++)\n    {\n        for (int i = -2; i<=2; i++)\n        {\n            if (i==0 && j==0) continue;\n            vec2 neighbor = m_neighbor + vec2(float(i), float(j));\n            vec2 point = hash22(uv_id + neighbor);\n            point = 0.5+0.5*sin(point*2.*PI+t);\n            vec2 diff = neighbor + point - uv_st;\n            float dist = dot(0.5*(m_diff+diff), normalize(diff-m_diff));\n            m_point = point;\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    return vec3(m_point, m_dist);\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{ return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nvec3 v;\nfloat g1 = 0.;\nfloat lava (vec3 p)\n{\n    p.y += 1.5;\n    v = voro(p.xz*1.5);\n    p.y += texNoise(v.xy*0.6).r*0.2;\n    p.y -= smoothstep(0.08,0.15,v.z)*0.03;\n    float d = abs(p.y)-0.2; \n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat room (vec3 p)\n{\n    vec2 uu = vec2(atan(p.z,p.x), p.y);\n    float offset = texNoise(uu*vec2(PI,.2)).r*1.5;\n    return -cyl(p.xzy, 8.+offset, 8.);\n}\n\nvec3 p_platform;\nfloat platform (vec3 p)\n{\n    p.y += 1.2;\n    float p_id = moda(p.xz, 6.);\n    p.y += sin(p_id+t)*0.5+0.5;\n    p.x -= 4.;\n    p_platform = p;\n    return box(p,vec3(.8,.3,.8))-0.05;\n}\n\nvec3 p_dragon;\nfloat dragon (vec3 p)\n{\n    p.z -= 5.;\n    p.y -= 1.;\n    p.y += sin(p.z*1.2+t);\n    p.x += sin(p.z);\n    p_dragon = p;\n    return cyl(p,0.1-p.z*0.05,15.);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    float drag = dragon(p);\n    float plat = platform(p);\n    float l = lava(p);\n    float r = room(p);\n\n    float d = min(min(drag,plat),min(max(l,cyl(p.xzy,9.,15.)),r));\n\n    if (d == l || d  == r) mat_id = 1;\n    if (d == plat) mat_id = 2;\n    if (d == drag) mat_id = 3;\n\n    return d;\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f*1. + l*uv.x + u*uv.y);\n}\n\nfloat platform_texture (vec2 uv)\n{\n    uv = abs(uv);\n    float c = max(uv.x,uv.y);  \n    return clamp(step(0.4, c)+step(c, 0.3)*step(0.1,c),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    uv += texNoise(uv*0.1 - vec2(0.,time*0.05)).rg*0.1;\n\n    vec3 ro= vec3(5.,3.5,-6.),\n        p = ro,\n        rd = getcam(ro,vec3(0.),uv),\n        l = vec3(0.,1.,-1.),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<100.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/100.;\n            break;\n        }\n        d *= 0.6+dither*0.1;\n        p += d*rd; \n    }\n\n    if (mat_id == 1)\n    {\n        col = vec3(shad);\n    }\n\n    if (mat_id == 2)\n    {\n        vec3 albedo = (platform_texture(p_platform.xz*0.5) == 0.) ? vec3(0.6,0.5,0.2) : vec3(p_platform.y, p_platform.y*0.6, p_platform.y*0.2);\n        col = albedo;\n    }\n    \n    if (mat_id == 3)\n    {\n        vec2 dragon_uv = vec2(atan(p_dragon.y,p_dragon.x),p_dragon.z); \n        vec3 albedo = vec3(-p_dragon.z,-p_dragon.z*0.4,-p_dragon.z*0.2)*0.8*voro(dragon_uv*vec2(1.,PI)).z*1.5;\n        col = albedo;\n    }\n    col *= 1.-shad; \n    col += g1*vec3(0.8,0.4,0.2)*0.18*(1.-v.z*2.);\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}