{"ver":"0.1","info":{"id":"Ml3BzB","date":"1540024631","viewed":461,"name":"horn of Geryon","username":"balkhan","description":"slow and unoptimized :)\n\nThis is my take on this : http://crawl.chaosforge.org/Horn_of_Geryon\n","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","horn","dcss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n#define FAR\t\t\t30.\n\n#define UNIFORM_ROTATION\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tid;\nvec3\th;\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.5*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tR = iResolution.xy, uv  = (f-R*.5)/R.yy;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 2.-iTime*.0);\n    \n    vec4\tinter = (march(pos, dir));\n\n    col = h*1.;\n    c_out =  vec4(col, h.x);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    id.x = 3.14*floor((a-an*.5)*count)/count;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\n// iq's hexagons\nfloat hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\tid.z = hash1((pi + ca - cb*ma).xy)*3.14;\n\treturn step(e*1., .015);;\n}\n// iq's hexagons\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    float var = .0, var1 = .0, var2 = .0;\n\n    vec3\tpr = p;\n\tpr.z-=-10.;\n    rotate(pr.zy, iTime*.1250*.0+iMouse.x*.01*2.+.0);\n    rotate(pr.xz, iTime*.2*4.0*.0+iMouse.y*.01*2. +0.*1.57);\n    \n    // compute angle x^y\n    var1 = atan(pr.x, pr.y);\n    // prepare space for toris creation\n    vec2 q = vec2(length(pr.xy)-5.0, pr.z-var1*1.*1.0 );\n\n    // I use this for texcoord in torus deformed space\n    var2 = atan(q.x, q.y);\n    vec2 tcd = 2.*vec2(vec2(1.0*var2/6.28, +2.0*var1/6.28).xy*1.);\n    // hexagon function courtesy of iq\n    var = 1.-hexagon(tcd*13.*1.);\n    // this value will be used to rotate the space\n    // since it will go into a sine, remap it [-3.14 : +3.14]\n    // we take value from texture\n    id.y = length(texture(iChannel0, .2050*vec2(+var2*1.0, q.y*-.1250*0.+1.0*var1).xy*1.\n                    ).x)*6.28-3.14;\n    // this is the triangle pattern\n    tcd = skew(tcd);\n    tcd = fract(tcd*26.);\n    // add triangle pattern to rotate value\n    id.y += 10.*max(step(tcd.x,tcd.y)*1.*sin(iTime*.125+id.z*200.+1.57), .0);\n    // add hexagon id to rotate value\n    id.y += id.z*10.;\n    // make a sine of rotate value\n    id.y = 1.14*sin(id.y*.5+iTime*.5125*3.0)/max(1., 1.+sin(var1+iTime*.0) );\n    \n    // rotate the space of the toris that will be created\n    rotate(q.xy, id.y-iTime*.125*-.0 +var1*.0);\n    \n    // making 8 toris, give them a different color each (id given in modA function)\n    q.xy = modA(q.xy, 8.);\n    // pull the toris appart from toris space center depending on angle x^y\n    q.x += -.75-.505*var1;\n\n    // compute length of toris\n\tmind = mylength(q)-.325205+.0+1.0*-.12500*var1-.06*abs(sin(id.z*1.+iTime*3.50))*2.0;//+.25*sin(iTime+id.x*5.+var1*0.);\n\n    // we NEED a cap or else depending on view direction we'll have a load of artifacts\n    // this is due to atan(x, y) near y == 0.\n    // so compute length of a toris to put on the open end of the horn\n    vec2 qq = vec2(length(pr.yz-vec2(-5., 3.14*1.0))-2.35, pr.x-.01);\n    float ming = max(abs(qq.x)-.7, abs(qq.y)-.025 )-0.;\n    \n    mind = min(mind, ming);\n    \n    // this is one way to do transparency in raymarching\n    mind = mix(mind, abs(mind)+.01, .5+.5*sin(iTime*.25+id.z));\n    \n    // return distfield * fudgevalue to lessen artifacts\n    return(mind)*1.*.5;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*1.;\n        float\td = 5.;\n        // this is the lighting\n        // the color is choosen by the id of the torus with basic sine coloring\n        h += (1.0*1.*\n            .00125/max(.1, dist.x*dist.x*.1+.0250502501*8.0) \n             )\n            *\n            vec3\n        (\n    \t\t1.+(sin(1.0*(id.x)+0.00) )\n            ,\n            1.+(sin(1.0*(id.x)+1.04) )\n            ,\n            1.+(sin(1.0*(id.x)+2.08) )\n        )\n            ;\n        if ( dist.x < E || dist.y >= FAR)\n            break;\n        ret.x++;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}