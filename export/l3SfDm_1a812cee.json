{"ver":"0.1","info":{"id":"l3SfDm","date":"1729530743","viewed":121,"name":"AuroraCube","username":"amenone","description":"JellyCube","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 距離関数\nfloat sphereSDF(vec3 p) {\n\t//p -= vec3(sin(time*2.),0.,0.);\n\treturn length(p) - 1.0;\n}\n\n// 立方体の距離関数\nfloat boxSDF(vec3 p) {\n\n\tvec3 d = abs(p) - vec3(1.5);\n\tfloat outsideDistance = length(max(d, 0.0));\n\tfloat insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\treturn outsideDistance + insideDistance;\n}\n\nvec3 calculateNormal(vec3 p) {\n\tfloat epsilon = 0.0001;\n\tvec3 n;\n\tfloat a = boxSDF(p + vec3(epsilon, 0.0, 0.0));\n\tfloat b = boxSDF(p - vec3(epsilon, 0.0, 0.0));\n\t\n\tn.x = max(a - b , b - a);\n\t\n\tfloat c = boxSDF(p + vec3(0.0, epsilon, 0.0));\n\tfloat d = boxSDF(p - vec3(0.0, epsilon, 0.0));\n\tn.y = max(c - d, d - c);\n\t\n\tfloat e = boxSDF(p + vec3(0.0, 0.0, epsilon));\n\tfloat f = boxSDF(p - vec3(0.0, 0.0, epsilon));\n\tn.z = max(e - f, f - e);\n\t\n\treturn normalize(n);\n}\n\nvec3 palette3D(vec3 t)\n{\n\tvec3 a = vec3(0.8, 0., 0.8);\n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(0.2, 1.0, 1.0);\n\tvec3 d = vec3(0.263, 0.8, 0.557);\n\n\tvec3 e = vec3(0.28, 1, 0.41);\n\tvec3 f = vec3(0.73, 0.56, 0.85);\n\tvec3 g = vec3(1, 0.25, 0.63);\n\tvec3 h = vec3(0.263, 0.8, 0.557);\n\t\n\tvec3 xNearBottom = mix(a, b,  t.x);\n\tvec3 xNearTop = mix(c, d , t.x );\n\tvec3 yNear = mix(xNearBottom, xNearTop, t.y );\n\n\tvec3 xFarBottom = mix(e, f, t.x );\n\tvec3 xFarTop = mix(g, h, t.x );\t\n\tvec3 yFar = mix(xFarBottom, xFarTop, t.y );\n\tvec3 z = mix(yNear, yFar, t.z );\n\t\n\treturn z;\n}\nvec3 palette(vec3 t)\n{\n\tvec3 a = vec3(0.8, 0., 0.8);\n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(0.2, 1.0, 1.0);\n\tvec3 d = vec3(0.263, 0.8, 0.557);\n\n\treturn a + b * cos(6.28318 * (c * t + d));\n}\n\nuvec2 uhash22(uvec2 n)\n{\n\tuvec2 k = uvec2(0x456789abu, 0x6789ab45);\n\tuvec3 u = uvec3(13, 17 ,15);\n\tn ^= (n.yx << u.xy);\n\tn ^= (n.yx >> u.yz);\n\tn *= k.xy;\n\tn ^= (n.yx << u.zx);\n\treturn n * k.xy;\n}\n\n\n// Get random value\nfloat random(in vec2 st)\n{\n\t// return frac(sin(dot(st.xy, half2(12.9898, 78.233))) * 43758.5453123);\n\tuint x = floatBitsToUint(st.x);\n\tuint y = floatBitsToUint(st.y);\n\tuvec2 n = uvec2(x,y);\n\treturn vec2( uhash22(n)).x /  float(0xffffffffu) ;\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n\tvec2 i = floor(_st);\n\tvec2 f = fract(_st);\n\n\t// Four corners in 2D of a tile\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(a, b, u.x) +\n\t(c - a)* u.y * (1.0 - u.x) +\n\t(d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 8\n\nfloat fbm ( in vec2 _st) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100.0);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5),\n\t-sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(_st);\n\t\t_st = rot * _st * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec4 getFbmFinalColor(vec2 st) {\n\t// st += st * abs(sin(time*0.1)*3.0);\n\tvec3 color = vec3(0.0);\n\n\tvec2 q = vec2(0.);\n\tq.x = fbm( st + 0.00*iTime);\n\tq.y = fbm( st + vec2(1.0));\n\n\tvec2 r = vec2(0.);\n\tr.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n\tr.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n\tfloat f = fbm(st+r);\n\n\tcolor = mix(vec3(0.935,0.336,0.054),\n\tvec3(0.666667,0.666667,0.498039),\n\tclamp((f*f)*4.0,0.0,1.0));\n\n\tcolor = mix(color,\n\tvec3(0.000,0.940,0.070),\n\tclamp(length(q),0.0,1.0));\n\n\tcolor = mix(color,\n\tvec3(0.214,0.302,1.000),\n\tclamp(length(r.x),0.0,1.0));\n\n\treturn vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}\nmat2 rot(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// カメラの設定\n\tvec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n\t// カメラの設定\n\tvec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n\tvec3 cp = vec3(0.0, -7.0, -15.0);       // カメラの位置\n\tvec3 cd = normalize(target - cp);       // カメラの視線方向\n\tvec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n\tvec3 cu = normalize(cross(cd, cs));     // 上方向\n\n\t//最初は真っ黒にする\n\tvec3 col = vec3(0.0);\n\n\tfloat fov = 2.5; // 視野角\n\tvec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n\n\t// レイマーチングのループ\n\tfloat t = 0.0;\n\tint maxSteps = 800;\n\tfloat maxDistance = 20.0;\n\tfloat epsilon = 0.00001;\n\tvec3 innerCol = vec3(0.0);\n\tvec3 baseColor = vec3(1.0);\n\t\n\tfor (int i = 0; i < maxSteps; i++) {\n\t\tvec3 currentPos = cp + t * rd;\n//\t\tvec3 originPos = currentPos;\n\t\tmat2 rotationY = rot(iTime);\n\t\tmat2 rotationX = rot(iTime*.2);\n\t\tmat2 rotationZ = rot(iTime*.7);\n\t\t\n\t\tcurrentPos.xz *= rotationY;\n\t\tcurrentPos.yz *= rotationX;\n\t\tcurrentPos.xy *= rotationZ;\n\t\t\n\t\tvec2 rotateP = p.xy * rotationX;\n\t\t\n\t\tfloat distance = boxSDF(currentPos); // 各辺1.0の箱\n\t\t\n\t\tif (distance < 0.0) {\n\t\t\tfloat depth = distance;\n\t\t\tdistance = 0.12;\n\t\t\tvec4 rotatePRandom = getFbmFinalColor(rotateP.xy);\n\t\t\tvec4 rotatePRandom2 = getFbmFinalColor(vec2(rotatePRandom.x, rotatePRandom.y + depth));\n\t\t\tinnerCol += rotatePRandom.xyz * 0.1;\n            \n            currentPos += innerCol -0.5 ;\n\t\t\tfloat sphereDistance = sphereSDF(currentPos); // 半径1.0の球\n\t\t\tif(sphereDistance < epsilon )\n\t\t\t{\n\t\t\t\tinnerCol += vec3( pow(abs(sphereDistance) ,3.)*0.1) * vec3(0.9, 0.2, 0.1);\n\t\t\t}\n\t\t}\n\t\telse if(distance < epsilon)\n\t\t{\n\t\t\tdistance = 0.06;\n\t\t\tvec3 normal = calculateNormal(currentPos);\n\t\t\tfloat normalAdd = normal.x+ normal.y+normal.z;\n\t\t\t\n\t\t\tinnerCol += vec3 (.2) * normalAdd * palette3D(normal);\n\t\t}\n\t\t\n\t\tt += distance;\n\t\tif (t > maxDistance) break;\n\t}\n\t\n\t\n\t// フラグメントカラーを設定\n\tfragColor = vec4(innerCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}