{"ver":"0.1","info":{"id":"7t3cD7","date":"1659925983","viewed":312,"name":"Path-Tracing SDF Renderer","username":"nethe550","description":"A path-tracing renderer for 3D signed distance fields.\n\nThe lighting is only loosely based on reality, and is designed to \"look\" good.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf","pathtracing","renderer","sdf3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nethe550\n// A path-tracing renderer for 3D signed distance fields.\n\n// ==================== //\n// Shading\n\nfloat diffuse(DirectionalLight light, vec3 normal) {\n    return clamp(-dot(normal, light.direction), 0.0, 1.0);\n}\n\nfloat shadow(Ray ray, float start, float end, float sharpness) {\n    float o = 1.0;\n    float penumbra = 1e20;\n    for(float t = start; t < end;) {\n    \n        float d = scene(ray.origin + ray.direction * t).dist;\n        \n        if(d < ray.collisionEpsilon) return 0.0;\n        \n        float y = d * d / (2.0 * penumbra);\n        float h = sqrt(d * d - y * y);\n        o = min(o, sharpness * h / max(0.0, t - y));\n        \n        penumbra = d;\n        t += d;\n        \n    }\n    return o;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal, float bias, float spread, float sharpness) {\n\tfloat occlusion = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++) {\n    \n        float h = 0.01 + bias * float(i) / spread;\n    \n        float d = scene(p + h * normal).dist;\n        \n        occlusion += (h - d) * s;\n        s *= 0.95;\n        \n        if (occlusion > 0.35) break;\n    \n    }\n    return clamp(1.0 - sharpness * occlusion, 0.0, 1.0) * (0.5 + 0.5 * normal.y);\n}\n\n// ==================== //\n// Fragment Entrypoint\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 clip = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    Camera camera;\n    camera.position = vec3(-2.0, 1.0, 0.0);\n    camera.target = vec3(0.0);\n    camera.focalLength = 1.5;\n    camera.farPlane = 256.0;\n    camera.up = vec3(0.0, 1.0, 0.0);\n\n    vec2 mouse = (2.0 * (iMouse.xy / iResolution.xy) - 1.0) * 4.0;\n    camera.position.xz -= camera.target.xz;\n    camera.position.x = (cos(mouse.x) - sin(mouse.x)) * 1.5;\n    camera.position.y = clamp(-mouse.y * 0.5 + 1.0, 0.0, 1.5);\n    camera.position.z = (cos(mouse.x) + sin(mouse.x)) * 1.5;\n    camera.position.xz += camera.target.xz;\n\n    DirectionalLight sun;\n    sun.direction = normalize(vec3(0.8, -0.4, 0.2));\n    sun.color = vec3(7.0, 4.5, 3.0);\n\n    vec3 color = vec3(0.0);\n\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = perspective(clip, camera);\n    ray.maxSteps = 256;\n    ray.collisionEpsilon = 0.0001;\n    ray.farPlane = camera.farPlane;\n    \n    RaycastHit fillHit = castRay(ray);\n\n    Ray shadowRay;\n    shadowRay.origin = fillHit.position + fillHit.normal * 0.001;\n    shadowRay.direction = -sun.direction;\n    shadowRay.collisionEpsilon = 0.0001;\n    float sunShadow = shadow(shadowRay, 0.02, 2.5, 32.0) * 0.9 + 0.1;\n    float ao = ambientOcclusion(fillHit.position, fillHit.normal, 0.07, 5.0, 3.0);\n    \n    if (fillHit.hit) {\n        float diffuse = clamp(dot(fillHit.normal, -sun.direction), 0.0, 1.0);\n        vec3 h = normalize(sun.direction + camera.position);\n        float specular = pow(clamp(dot(fillHit.normal, h), 0.0, 1.0), fillHit.sdf.material.glossiness);\n        \n        color = fillHit.sdf.material.color * sun.color * diffuse * sunShadow;\n        color += diffuse * specular * sun.color;\n        color *= ao;\n    }\n    else {\n        color = vec3(0.4, 0.5, 0.9) - 0.5 * (0.5 * ray.direction.y);\n        color = mix(color, vec3(0.5), exp(-10.0 * ray.direction.y));\n        \n        float sunDisc = smoothstep(0.995, 1.0, dot(ray.direction, -sun.direction)) * 0.25;\n        color += sunDisc * sun.color;\n    }\n    \n    color = pow(color, vec3(0.4545)); // gamma correction\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ==================== //\n// Structures\n\n// -------------------- //\n// SDFs\n\nstruct Material {\n    vec3 color;\n    float glossiness;\n};\n\nstruct SDF {\n    vec3 position;\n    Material material;\n};\n\nstruct SDFTest {\n    float dist;\n    SDF sdf;\n};\n\n// -------------------- //\n// Path-Tracing\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    int maxSteps;\n    float collisionEpsilon;\n    float farPlane;\n};\n\nstruct RaycastHit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    SDF sdf;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float focalLength;\n    float farPlane;\n};\n\n// -------------------- //\n// Lights\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\n// ==================== //\n// SDFs\n\nSDFTest sphere(vec3 p, SDF sdf, float radius) {\n    SDFTest t;\n    t.dist = length(p + sdf.position) - radius;\n    t.sdf = sdf;\n    return t;\n}\n\nSDFTest cube(vec3 p, SDF sdf, vec3 size, float radius) {\n    SDFTest t;\n    vec3 hs = abs(p + sdf.position) - size;\n    t.dist = min(max(hs.x, max(hs.y, hs.z)), 0.0) + length(max(hs, 0.0)) - radius;\n    t.sdf = sdf;\n    return t;\n}\n\nSDFTest plane(vec3 p, SDF sdf, float y) {\n    SDFTest t;\n    t.dist = (p + sdf.position).y - y;\n    t.sdf = sdf;\n    return t;\n}\n\nSDFTest line(vec3 p, SDF sdf, vec3 a, vec3 b, float radius) {\n    SDFTest t;\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    t.dist = length(pa - ba * h) - radius;\n    t.sdf = sdf;\n    return t;\n}\n\n// ==================== //\n// Scene\n\nSDFTest SDFUnion(SDFTest a, SDFTest b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nSDFTest scene(vec3 p) {\n \n    SDF sphere1;\n    sphere1.position = vec3(0.0, 0.0, 0.0);\n    sphere1.material.color = vec3(0.18, 0.09, 0.1);\n    sphere1.material.glossiness = 75.0;\n    \n    SDF cube1;\n    cube1.position = vec3(0.0, 0.0, 1.0);\n    cube1.material.color = vec3(0.1, 0.09, 0.18);\n    cube1.material.glossiness = 55.0;\n    \n    SDF ground;\n    ground.position = vec3(0.0);\n    ground.material.color = vec3(0.09, 0.18, 0.09);\n    ground.material.glossiness = 35.0;\n    \n    SDF lineSDF;\n    lineSDF.position = vec3(0.0);\n    lineSDF.material.color = vec3(0.18, 0.15, 0.0);\n    lineSDF.material.glossiness = 125.0;\n    \n    SDFTest sphere1T = sphere(p, sphere1, 0.25);\n    SDFTest cube1T = cube(p, cube1, vec3(0.125), 0.125);\n    SDFTest line1T = line(p, lineSDF, vec3(0.0, 0.33, 0.85), vec3(0.0, -0.125, 1.0), 0.125);\n    SDFTest groundT = plane(p, ground, -0.25);\n    \n    SDFTest t = sphere1T;\n    t = SDFUnion(t, cube1T);\n    t = SDFUnion(t, line1T);\n    t = SDFUnion(t, groundT);\n    \n    return t;\n \n}\n\n// ==================== //\n// Shading\n\nvec3 getNormal(vec3 p, float e) {\n    vec2 a = vec2(e, 0.0);\n    return normalize(vec3(\n        scene(p + a.xyy).dist - scene(p - a.xyy).dist,\n        scene(p + a.yxy).dist - scene(p - a.yxy).dist,\n        scene(p + a.yyx).dist - scene(p - a.yyx).dist\n    ));\n}\n\nvec3 getNormal(vec3 p) {\n    return getNormal(p, 0.0001);\n}\n\n// ==================== //\n// Path-Tracing\n\nRaycastHit castRay(Ray ray) {\n    RaycastHit hit;\n    hit.hit = false;\n    \n    float t = 0.0;\n    for (int i = 0; i < ray.maxSteps; i++) {\n        vec3 p = ray.origin + ray.direction * t;\n        SDFTest s = scene(p);\n        \n        if (s.dist < ray.collisionEpsilon) {\n            hit.hit = true;\n            hit.position = p;\n            hit.normal = getNormal(p);\n            hit.sdf = s.sdf;\n            return hit;\n        }\n\n        t += s.dist;\n        \n        if (t > ray.farPlane) break;\n    }\n    return hit;\n}\n\nvec3 perspective(vec2 clip, Camera camera) {\n    vec3 w = normalize(camera.target - camera.position);\n    vec3 u = normalize(cross(w, camera.up));\n    vec3 v = normalize(cross(u, w));\n    return vec3(normalize(clip.x * u + clip.y * v + camera.focalLength * w));\n}","name":"Common","description":"","type":"common"}]}