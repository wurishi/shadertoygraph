{"ver":"0.1","info":{"id":"dlGfRK","date":"1702263251","viewed":42,"name":"Taking the Mandelbulb outside","username":"BearKirb","description":"Learning skybox and reflections :D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","mandelbulb","skybox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Mand(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Bailout=2.0;\n    float Power=8.0;\n    int Iterations = 3;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr-0.01;\n}\nfloat random(in vec2 uv)\n{\n    return texture(iChannel0, uv / 64.).r;\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(in vec3 ro, in vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun*2.0;\n    \n    // clouds\n    float t = iTime * 0.5;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol, 0.68 * vec3(.418, .394, .372), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\nfloat sdBox( vec3 p, vec3 b ,float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdf(vec3 p){\n\n//float f=sdBox(p,vec3(1.0,0.2,1.0),0.1);\n//f=smin(f,sdTorus(p-vec3(0.0,0.3,0.0),vec2(0.5,0.1)),0.005);\nfloat f= Mand(p);\nreturn f;\n}\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid Rotate( inout vec2 vect, vec2 angle )\n{\nvec3 vector = vec3(vect.x,0.0,vect.y);\n\tvect.yx = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvect.xy = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 calcNormal(vec3 p) {\nfloat EPSILON = 0.00001;\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<44; i++ )\n    {\n  \n        po -= normalize(rd-ro) * sdf(po);\n        minDist=min(minDist,sdf(po));\n  \n      \n      \n    }\n          if( sdf(po)<0.04){\n        if(distance(po,ro)<0.04){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n    return 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t0.4 ) ); \n             \n    vec3 pos = vec3(0.0,0.0,-3.0); \n    \n  \n \n    \nvec2 angle = -(iMouse.xy/iResolution.xy-.5)*4.14+vec2(3.14,0.0);\n\tRotate(pos,angle);\n \n\tRotate(ray,angle);\n vec3 cameraPos = pos; \n    fragColor.rgb = Sky(cameraPos,normalize(ray));\n    float cameraPosDist=distance(vec3(0.0,0.0,0.0),cameraPos);\n    for(int x=0;x<60;x++){\n    float h=sdf(pos);\n    if(h<0.001||h>cameraPosDist+1.0){\n    break;\n    }else{\n    \n    \n    \n    pos+=ray*h;\n    }\n    }\n    if(sdf(pos)<0.015){\n    vec3 light=vec3(-1000.0,10.0,0.0);\n     vec3 normal = calcNormal(pos);\n    vec3 ambient = vec3(0.3,0.23,0.1)/1.1;\n   if(sdf(pos-normal/100.0)>0.00001){\n   normal=-normal;\n   }\n    float d = dot(normal,normalize(light-pos));\n    vec3 lambert=ambient*d;\n    vec3 reflec = Sky(vec3(0.0,0.0,0.0),reflect(ray,normal))/3.0;\n    vec3 spec = vec3(pow(d,64.0))/1.6*d;\n    fragColor.rgb = max((ambient),(ambient+lambert+spec+reflec));\n \n    }\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}