{"ver":"0.1","info":{"id":"MfScRy","date":"1722507607","viewed":40,"name":"Moving Tiled Lights","username":"NachoK00l","description":"A simple shader I made while learning the basics of GLSL","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( in float t)\n{\n    vec3 a = vec3(0.938, 0.328, 0.718);\n    vec3 b = vec3(0.659, 0.438, 0.328);\n    vec3 c = vec3(0.388, 0.388, 0.296);\n    vec3 d = vec3(2.538, 2.478, 0.168);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Parameters for fractal generation\n    float fractalSize = 10.0;\n    float speed = 0.5;\n    float brightness = 3.0;\n    float brightnessClamp = 0.4;\n\n    // Normalize coordinates to center (0,0) and scale to aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Initialize final color\n    vec3 finalColor = vec3(0.0);\n\n    // Create a unique ID for each pixel based on its position\n    float pixelId = (uv.x + uv.y) / 2.0;\n\n    // Generate fractal pattern\n    vec2 uvFract = fract(\n        sin(uv * fractalSize + iTime) / \n        (abs(sin((iTime + pixelId) * speed) * brightness) + 1.0)\n    );\n\n    // Calculate distance from center of each fractional part\n    float distance = length(uvFract);\n\n    // Smooth step the distance\n    distance = smoothstep(0.0, 1.0, distance);\n\n    // Invert and scale the distance\n    distance = brightnessClamp / distance;\n\n    // Apply color palette and scale by distance\n    finalColor = palette(distance) * distance;\n\n    // Set fragment color with full opacity\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}