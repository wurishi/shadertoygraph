{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// References: http://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR   1.61803398\n\n#define EPSILON 0.001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// MATERIAL DEFINES\n\n#define SPHERE_MATL 1.\n#define PLANE_MATL 2.\n\n#define NUM_BALLS_PER_ROW 10\n#define NUM_BALL_ROWS 6\n\n// **************************************************************************\n// SWITCHES\n\n#define FRESNEL_HORNER_APPROXIMATION 1\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\n\nvec3  g_ldir         = vec3(.5, .5, 0.);\nfloat g_lillum       = 1.;\n\nvec4  g_debugcolor   = vec4(0.);\n\n// **************************************************************************\n// UTILITIES\n\n// XXX: To get around a case where a number very close to zero can result in \n// eradic behavior with sign, we assume a positive sign when a value is \n// close to 0.\nfloat zeroTolerantSign(float value)\n{\n    float s = 1.;\n    if (abs(value) > EPSILON) {\n        s = sign(value);\n    }\n    return s;   \n}\n\nmat3 rotMatAroundYAxis( float c, float s )\n{\n    return mat3( c,  0., s , \n                 0., 1., 0.,\n                -s,  0., c);\n}\n\nmat3 rotMatAroundXAxis( float c, float s )\n{\n    return mat3( 1.,  0., 0., \n                 0.,  c,  s,\n                 0., -s,  c);\n}\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\nvec3 mergeobjs(vec3 a, vec3 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\nbool inbounds( vec3 p, vec3 bounds )\n{\n    return all(lessThanEqual(abs(p), .5 * bounds));\n}\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersectDSPlane(vec3 o, vec3 dir,\n                      vec3 pn, vec3 po)\n{\n    float dirDotN = dot(dir, pn);\n\n    // if the ray direction is parallel to the plane, let's just treat the \n    // ray as intersecting *really* far off, which will get culled as a\n    // possible intersection.\n    float denom = zeroTolerantSign(dirDotN) * max(abs(dirDotN), EPSILON);\n    float t = min(BIG_FLOAT, -dot(pn, (o - po)) / denom);    \n    return vec2(step(EPSILON, t), t);\n\n}\n\n// Returns the ray intersection distance (assumes rd is normalized) to the \n// box.  If the ray originates inside the box, then a t of zero is returned.\n// if no intersection takes place, BIG_FLOAT is returned.\nfloat intersectBox( vec3 ro, vec3 rd, vec3 bounds )\n{\n    // XXX: In need of optimization\n    float d = BIG_FLOAT;\n    if (inbounds(ro, bounds)) \n    {\n        d = 0.;\n    }\n\n    else\n    {\n        vec3 srd = sign(rd);\n        // Only try to intersect the planes that have normals that are \n        // opposing the ray direction.  Saves us from testing the other 3 \n        // walls.  We get away with this since we already handled the case \n        // where the ray originates in the box.\n        vec2 rx = intersectDSPlane(ro, rd, vec3(-srd.x, 0., 0.), \n                                  vec3(.5 * bounds.x * -srd.x, 0., 0.));\n        if (rx.x > .5 && inbounds(ro + rd * (rx.y + EPSILON), bounds))\n        {\n            d = min(d, rx.y);\n        }\n\n        vec2 ry = intersectDSPlane(ro, rd, vec3(0., -srd.y, 0.), \n                                  vec3(0., .5 * bounds.y * -srd.y, 0.));\n        if (ry.x > .5 && inbounds(ro + rd * (ry.y + EPSILON), bounds))\n        {\n            d = min(d, ry.y);\n        }\n        vec2 rz = intersectDSPlane(ro, rd, vec3(0., 0., -srd.z), \n                                  vec3(0., 0., .5 * bounds.z * -srd.z));\n        if (rz.x > .5 && inbounds(ro + rd * (rz.y + EPSILON), bounds))\n        {\n            d = min(d, rz.y);\n        }\n    }\n    return d;\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat spheredf( vec3 pos, float r ) \n{\n    return length( pos ) - r;\n}\n\nfloat planedf( vec3 pos, float yoffset ) \n{\n    return abs( pos.y + yoffset );\n}\n\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec3 ballsobj(vec3 p, float r)\n{    \n\n    // XXX: could use some optimization\n    vec3 obj = vec3(BIG_FLOAT, SPHERE_MATL, 0.);\n\n    for (int j = 0; j < NUM_BALL_ROWS; j++)\n    {\n        float xoff = float(NUM_BALL_ROWS) * 2.1 * r * (float(j)/float(NUM_BALL_ROWS-1) - .5);\n\n        for (int i = 0; i < NUM_BALLS_PER_ROW; i++)\n        {\n            float zoff = float(NUM_BALLS_PER_ROW) * 2.1 * r * (float(i)/float(NUM_BALLS_PER_ROW-1) - .5);\n            float t = spheredf(p - vec3(xoff, 0., zoff), r);\n            obj.z = mix(obj.z, float(i + j*NUM_BALLS_PER_ROW), step(t, obj.x));\n            obj.x = min(obj.x, t);\n        }\n    }\n    \n    return obj;\n}\n\n\nvec3 planeobj(vec3 p, float yoffset)\n{\n    return vec3(planedf(p, yoffset), PLANE_MATL, 1.);\n}\n\n\nvec3 scenedf(vec3 pos, vec3 rd)\n{\n\n    vec3 obj = vec3( 100., -1., -1.);\n\n    float r = .5;\n\n    float tbox = 0.;\n    if (dot(abs(rd), vec3(1.)) > EPSILON)\n    {\n        float rbuffer = 2.1 * r;\n        float aobuffer = 1.;\n\n        vec3 bounds = rbuffer * vec3(float(NUM_BALL_ROWS+1), \n                                   1., \n                                   float(NUM_BALLS_PER_ROW+1));\n        // Add a buffer to the bounding box to account for the \n        // ambient occlusion marching.\n        bounds += aobuffer;\n    \n        tbox = intersectBox( pos, rd, bounds );\n    }\n    \n    if (tbox < 10.) {\n        vec3 bobj = ballsobj( pos + rd * tbox, r );\n        // Add the distance to the bounding box\n        bobj.x += tbox;\n        obj = mergeobjs(obj, bobj);\n    }\n    \n    // vec3 bobj = ballsobj( pos, r );\n    // obj = mergeobjs(obj, bobj);\n\n    obj = mergeobjs(obj, planeobj(pos, .5));\n\n    return obj;\n}\n\n#define DISTMARCH_STEPS 60\n#define DISTMARCH_MAXDIST 50.\n\nvec3 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n    float dist = 0.01;\n    vec3 res = vec3(0., -1., -1.);\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < EPSILON || res.x > maxd ) continue;\n\n        // advance the distance of the last lookup\n        res.x += dist;\n        vec3 dfresult = scenedf( ro + res.x * rd, rd );\n\n        dist = dfresult.x;\n        res.yz = dfresult.yz;\n    }\n\n    if( res.x > maxd ) res.y = -1.0; \n    return res;\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\n#define SOFTSHADOW_STEPS 40\n#define SOFTSHADOW_STEPSIZE .1\n\nfloat calcSoftShadow( vec3 ro, \n  vec3 rd, \n  float mint, \n  float maxt, \n  float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t, rd ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 5\n#define AO_STEPSIZE .14\n#define AO_STEPSCALE .35\n\nfloat calcAO( vec3 p, vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi< AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop, n ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    vec3 point;\n    vec3 normal;\n    vec3 basecolor;\n    float roughness;\n    float specular;\n    float metallic;\n    float selfshad;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), 0., 1., 0., 0.)\n\nstruct BRDFVars\n{\n    // vdir is the view direction vector\n    vec3 vdir;\n    // The half vector of a microfacet model \n    vec3 hdir;\n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh; \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd;      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl;\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv;\n};\n\nBRDFVars calcBRDFVars(SurfaceData surf, vec3 ldir)\n{\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n    vec3 hdir = normalize(ldir + vdir);\n\n    float costh = dot(surf.normal, hdir); \n    float costd = dot(ldir, hdir);      \n    float costl = dot(surf.normal, ldir);\n    float costv = dot(surf.normal, vdir);\n\n    return BRDFVars(vdir, hdir, costh, costd, costl, costv);\n\n}\n\nvec3 calcNormal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 z = vec3( 0.0 );\n    vec3 n = vec3(\n        scenedf(p + epsilon.xyy, z).x - scenedf(p - epsilon.xyy, z).x,\n        scenedf(p + epsilon.yxy, z).x - scenedf(p - epsilon.yxy, z).x,\n        scenedf(p + epsilon.yyx, z).x - scenedf(p - epsilon.yyx, z).x );\n\n    return normalize( n );\n}\n\nvoid material(float matid,\n              float surfid,\n              inout SurfaceData surf)\n{\n    vec3 surfcol = vec3(1.);\n    if (matid - .5 < SPHERE_MATL) \n    { \n        surf.basecolor = vec3(1., 0.35, 0.5); \n        float ballrow = floor(surfid/float(NUM_BALLS_PER_ROW));\n        surf.roughness = mod(surfid, float(NUM_BALLS_PER_ROW))/float(NUM_BALLS_PER_ROW-1);\n        surf.metallic = floor(surfid/float(NUM_BALLS_PER_ROW))/float(NUM_BALL_ROWS-1);\n        surf.specular = .8;\n    } \n    else if (matid - .5 < PLANE_MATL)\n    {\n        vec4 pavem = texture(iChannel2, .1 * surf.point.xz);\n        surf.basecolor = vec3(.1 * smoothstep(.6, .3, pavem.r));\n        surf.metallic = .0;\n        surf.roughness = .6;\n        surf.specular = .02; // .05\n        \n        surf.normal.xz += .1 * pavem.bg;\n        surf.normal = normalize(surf.normal);\n\n        surf.selfshad = .3 * (1. - smoothstep(.4, .8, pavem.g));\n    }\n\n}\n\nvec3 calcDiff(BRDFVars bvars, SurfaceData surf)\n{        \n    float frk = .5 + 2.* bvars.costd * bvars.costd * surf.roughness;        \n    return surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-bvars.costl)) * (1. + (frk - 1.) * pow5(1.-bvars.costv));\n    //return surf.basecolor * ONE_OVER_PI; // lambert\n}\n\nfloat calcDistrScalar(BRDFVars bvars, float roughness)\n{\n    // D(h) factor\n    // using the GGX approximation where the gamma factor is 2.\n\n    // Clamping roughness so that a directional light has a specular\n    // response.  A roughness of perfectly 0 will create light \n    // singularities.\n    float alpha = roughness * roughness;\n    float denom = bvars.costh * bvars.costh * (alpha*alpha - 1.) + 1.;\n    float D = (alpha*alpha)/(PI * denom*denom); \n\n    // using the GTR approximation where the gamma factor is generalized\n    //float gamma = 1.;\n    //float sinth = length(cross(surf.normal, bvars.hdir));\n    //float D = 1./pow(alpha*alpha*bvars.costh*bvars.costh + sinth*sinth, gamma);\n\n    return D;\n}\n\nfloat calcGeomScalar(BRDFVars bvars, float roughness)\n{\n    \n    // G(h,l,v) factor    \n    float k = roughness / 2.;\n    float Gv = step(0., bvars.costv) * (bvars.costv/(bvars.costv * (1. - k) + k));\n    float Gl = step(0., bvars.costl) * (bvars.costl/(bvars.costl * (1. - k) + k));\n\n    return Gl * Gv;\n}\n\n\nvec3 calcFresnelColor(BRDFVars bvars, SurfaceData surf)\n{\n    // F(h,l) factor\n    vec3 F0 = surf.specular * mix(vec3(1.), surf.basecolor, surf.metallic);\n    \n#if FRESNEL_HORNER_APPROXIMATION\n    vec3 F = F0 + (1. - F0) * exp2((-5.55473 * bvars.costd - 6.98316) * bvars.costd); \n#else\n    vec3 F = F0 + (1. - F0) * pow5(1. - bvars.costd); \n#endif\n    \n    return F;    \n}\n\nvec3 integrateDirLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\n    BRDFVars bvars = calcBRDFVars( surf, ldir );\n\n    vec3 cout = vec3(0.);\n    float ndl = clamp(bvars.costl, 0., 1.);\n\n    if (ndl > 0.)\n    {\n        vec3 diff = calcDiff(bvars, surf);\n\n        // remap hotness of roughness for analytic lights\n        float rroughness = max(0.05, surf.roughness);\n        float D = calcDistrScalar(bvars, rroughness);\n        float G = calcGeomScalar(bvars, (rroughness+1.)*.5);\n        vec3 F  = calcFresnelColor(bvars, surf);\n\n        vec3 spec = D * F * G / (4. * bvars.costl * bvars.costv);\n        \n        float shd = min(1. - surf.selfshad, calcSoftShadow( surf.point, ldir, 0.1, 20., 5.));\n\n        cout  += diff * ndl * shd * lcolor;\n        cout  += spec * ndl * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 sampleEnvLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\n    BRDFVars bvars = calcBRDFVars( surf, ldir );\n\n    float ndl = clamp(bvars.costl, 0., 1.);\n    \n    vec3 cout = vec3(0.);\n\n    if (ndl > 0.)\n    {\n\n        float D = calcDistrScalar(bvars, surf.roughness);\n        float G = calcGeomScalar(bvars, surf.roughness);\n        vec3 F  = calcFresnelColor(bvars, surf);\n\n        // Combines the BRDF as well as the pdf of this particular\n        // sample direction.\n        vec3 spec = lcolor * G * F * bvars.costd / (bvars.costh * bvars.costv);\n        \n        float shd = min(1. - surf.selfshad, calcSoftShadow( surf.point, ldir, 0.02, 20., 7.));\n        \n        cout = spec * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 integrateEnvLight(SurfaceData surf, vec3 tint)\n{\n    vec3 vdir = normalize( surf.point - g_camOrigin );    \n    vec3 envdir = reflect(vdir, surf.normal);\n\n    // This is pretty hacky for a microfacet model.  We are only\n    // sampling the environment in one direction when we should be\n    // using many samples and weight them based on their distribution.\n    // So to compensate for the hack, I blend towards the blurred version\n    // of the cube map as roughness goes up and decrease the light\n    // contribution as roughness goes up.\n    vec4 specolor = .4 * mix(texture(iChannel0, envdir),\n                             texture(iChannel1, envdir),\n                             surf.roughness) * (1. - surf.roughness);\n    \n    vec3 envspec = sampleEnvLight(envdir, tint * specolor.rgb, surf);\n    return envspec;\n}\n\nvec3 shadeSurface(SurfaceData surf)\n{    \n\n    vec3 amb = surf.basecolor * .02;\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = calcAO(surf.point, surf.normal);\n\n    vec3 cout   = integrateDirLight(g_ldir, vec3(g_lillum), surf);\n    cout       += integrateEnvLight(surf, vec3(g_lillum)) * (1. - 3.5 * ao);\n    cout       += amb * (1. - 3.5 * ao);\n\n    return cout;\n\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1, 1])\n    vec2 click = iMouse.xy / iResolution.xy;    \n    // if click isn't initialized (negative), have reasonable defaults\n    click = 2.0 * click - 1.0;  \n    \n    g_time = iTime;\n\n    // camera position\n    g_camOrigin = vec3(-13.0, 6.0, 0.0);\n    \n    float roty    = PI * click.x + .1 * g_time;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    float rotx    = .4 * PI * (.5 * click.y + .5);\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n\n    g_lillum = .8;\n\t\n    // Rotate the camera around the origin\n    g_camOrigin = rotMatAroundYAxis(cosroty, sinroty) * rotMatAroundXAxis(cosrotx, sinrotx) * g_camOrigin;\n    \n    g_camPointAt   = vec3(0., -1., 0.);\n    \n    float lroty    = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n\n    // Rotate the light around the origin\n    g_ldir = rotMatAroundYAxis(coslroty, sinlroty) * g_ldir;\n\n}\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera(vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    // ----------------------------------------------------------------------\n    // Animate globals\n\n    animateGlobals();\n\n    // ----------------------------------------------------------------------\n    // Setup Camera\n\n    CameraData cam = setupCamera(fragCoord);\n\n    // ----------------------------------------------------------------------\n    // SCENE MARCHING\n\n    vec3 scenemarch = distmarch( cam.origin, cam.dir, DISTMARCH_MAXDIST );\n    \n    // ----------------------------------------------------------------------\n    // SHADING\n\n    vec3 scenecol = vec3(0.);\n    if (scenemarch.y > 0.)\n    {\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\n        vec3 mn = calcNormal( mp );\n\n        SurfaceData currSurf = INITSURF(mp, mn);\n\n        material(scenemarch.y, scenemarch.z, currSurf);\n        scenecol = shadeSurface( currSurf );\n    }\n\n    // ----------------------------------------------------------------------\n    // POST PROCESSING\n    \n    // fall off exponentially into the distance (as if there is a spot light\n    // on the point of interest).\n    scenecol *= exp( -0.003*(scenemarch.x*scenemarch.x - 20. * 20.));\n\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    // Contrast adjust - cute trick learned from iq\n    scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -0.6 );\n\n    // color tint\n    scenecol = .5 * scenecol + .5 * scenecol * vec3(1., 1., .9);\n    \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scenecol;\n    }\n\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBGRK","date":"1391908254","viewed":4243,"name":"Disney Plausible Model","username":"mplanck","description":"Playing with the microfacet model and parameters proposed by Disney at Siggraph 2012.  Roughness increases in the x axis and metallicity increases on the y axis.","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["distancemarching","microfacet"],"hasliked":0,"parentid":"","parentname":""}}