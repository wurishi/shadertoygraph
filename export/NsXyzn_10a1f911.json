{"ver":"0.1","info":{"id":"NsXyzn","date":"1641561635","viewed":105,"name":"Barnsley's game of chaos 4","username":"Envy24","description":"Speed up this shader: https://www.shadertoy.com/view/fdfcRn","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal","game","square","chaos","carpet","serpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) { O = texture(iChannel0, SC/iResolution.xy); }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                iResolution\n#define center(P)        ( (P+P-R.xy)/R.y )       // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define TEX0(x)          (texture(iChannel0, x))\n#define LMB_IS_HOLD      ( iMouse.z > 0.0 )\n\nfloat scene(in vec2 UV)\n{\n    vec2 square[8];\n    \n    // Corners and middle sides of square.\n    square[0] = vec2( 0.9,  0.9);\n    square[1] = vec2( 0.9,  0.0);      \n    square[2] = vec2( 0.9, -0.9);    \n    square[3] = vec2( 0.0, -0.9);\n    square[4] = vec2(-0.9, -0.9);\n    square[5] = vec2(-0.9,  0.0);\n    square[6] = vec2(-0.9,  0.9); \n    square[7] = vec2( 0.0,  0.9);\n    \n    /* First toss. */\n    uint rand = uint(golderRatioHash(iTime) * 8.0);\n\n    /* Seed vertex. */\n    vec2 C = square[0];\n    vec2 _C = square[0];\n    \n    float min_sq_dist = 999999.9;\n    int points_per_frame = 100;\n\n    for (int point = 0; point < points_per_frame; ++point)\n    {    \n        for (int toss = 0; toss < 4; ++toss)\n        {\n            // Update coordinates.\n            C = (C + 2.0*square[rand & 7u]) / 3.0;\n\n            /* Other tosses with feedback. */\n            rand = uint(golderRatioHash(iTime*C.x) * 8.0);\n        }\n        \n        vec2 diff = C - UV;\n        float sq_dist = dot(diff, diff);\n        min_sq_dist = min(min_sq_dist, sq_dist);\n        \n        _C = \n            min_sq_dist == sq_dist ? // Find better candidate?\n                C :\n                _C;\n    }\n\n    float radius = 2.0 / R.x;\n    float smoothness = 1.0 / R.y;\n    \n    /* Sample size remains same for different resolutions. */\n    return circleSDFSD(UV, _C, radius, smoothness);\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    /* White screen initialization. */\n    if (iFrame == 0             // Initialization at launch.\n        || LMB_IS_HOLD == true) // Reinitialization (for fullscreen mode).\n    { O = vec4(1.0); return; }\n\n    O = vec4(\n            min(\n                scene(center(P)),\n                TEX0(P/R.xy).r)\n            );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Hash with uniform distribution.\n    Works fine for range [0.1; 1e6].\n    Not always look good.\n \n    For 8388608 tested samples in range [0.0; 1.0] shows this statistics:\n        Histogram with 0.1 column width:\n            854844 825298 823153 824903 829215 834342 840773 844517 846493 865070\n            \n\n        Shannon enthropy                  =3.321747\n        Area of unit circle (Monte-Carlo) =3.119030\n        Mathematical expectation          =0.502320\n        Dispersion                        =0.084333\n        Standart deviation                =0.290402\n    \n    return value in range [0.0; 1.0].\n    \n    https://www.shadertoy.com/view/fsdXDl\n*/\nfloat golderRatioHash(float x)\n{\n    float y = (100. + x);\n    float m = mod(1e3 * y, 11.67115450f);\n    float f = fract(m * (m * y));\n    float a = (f - m) * 6.18034029f;\n\n    return fract(a * fract(a * fract(a)));\n}\n\n/* Signed distance of squared distances. \n   Should work faster without calculation square root. */\nfloat circleSDFSD(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}","name":"Common","description":"","type":"common"}]}