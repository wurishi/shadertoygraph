{"ver":"0.1","info":{"id":"NlGBWc","date":"1665343273","viewed":444,"name":"quality stars","username":"Carandiru","description":"cheap, scalable, spheremap with definable distance out, practical.\n\nfork of Nebula Clouds by mu6k https://www.shadertoy.com/view/lsBGDt\nused parts/modified Pixel Stars by _Chae4ek_ https://www.shadertoy.com/view/flcSz2\n","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["noise","volume","space","stars"],"hasliked":0,"parentid":"lsBGDt","parentname":"Nebula Clouds"},"renderpass":[{"inputs":[],"outputs":[],"code":"// high quality stars ---- cheap, scalable, spheremap with definable distance out, practical.\n\n// fork of Nebula Clouds by mu6k https://www.shadertoy.com/view/lsBGDt\n// used parts/modified Pixel Stars by _Chae4ek_ https://www.shadertoy.com/view/flcSz2\n\n#define scale (0.72)\n#define star_maximum_luminance (10000.0)\n#define distance_maximum_out (90.0)\n\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n\n// most of the code has changed, simplified and focused soley on the star spheremap\n// original noise not used any more and replaced with \"Pixel Stars\"\n/////////////////////////\n\nuvec3 murmur3( in uvec3 u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\nvec3 unorm(uvec3 n) { return(fract(vec3(n) * (1.0 / float(0xffffffffU)))); }\n\nvec3 hash33(in vec3 m) \n{\n    uvec3 mu = floatBitsToUint(m * GOLDEN_RATIO) | 0x1u;\n\n    mu = murmur3(mu);\n\n    return(1.0f - unorm(mu));\n}\n\nfloat rand(in vec3 st) {\n  vec3 r = hash33(st) * GOLDEN_RATIO_ZERO;\n  return fract(r.z * 111.111111 * 111.111111 + r.y * 111.111111 + r.x);\n}\n\nfloat pixel_stars(in vec3 st, in float t) {\n  float r = rand(round(st));\n  return 0.000001 + smoothstep(0.995*t, 1.0, r);\n}\n\nfloat stars(in vec3 st, in float t) {\n  return(pixel_stars(st, t));\n}\n\n\n/////////////////////////\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//background with stars\nfloat background(vec3 dir, float d)\n{\n    d = 1.0f / (1.0f + d*d);\n    \n    float den = abs(dir.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n    \n    float n = stars(scale * (dir*(1.0 - d)*iResolution.y), 1.0f - den);\n    \n\t\n\treturn d * star_maximum_luminance * pow(n*0.95f+den,22.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + 8.0f;\n    \n    vec2 uv = fragCoord.xy / iResolution.yy -vec2(.9,.5);\n\tvec2 m = iMouse.xy*8.0/ iResolution.yy;\n\t//rotation matrix for the camera\n\tmat3 rotmat = rotate_y((t)*.07+m.x)*rotate_x((t)*.031+m.y);\n\n\tvec3 rd = normalize(vec3(uv*(sin(t*.17)*.2+0.8),1.0-length(uv)*.2));\n\trd*=rotmat;\n    rd=normalize(rd);\n\n\t\n    // stars\n\tvec3 color = vec3(background(rd,distance_maximum_out));\n\t\n\tfragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0);\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4 \n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\n\n// private //\nuint base_hash_1D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n  n.x *= _M0;    // MLCG constant\n\n  return( n.x ^ (n.x >> 16) );\n}\n\nuvec2 base_hash_2D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n\n  return( (n.x * uvec2(_M0, _M1)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nuvec3 base_hash_3D(in uvec3 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t  // z' = Fz(z)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n\n  return( (n.x * uvec3(_M0, _M1, _M2)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nuvec4 base_hash_4D(in uvec4 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t// z' = Fz(z)\n  n.w *= _W3;\t// w' = Fw(w)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n  n.x ^= n.w;    // combine\n\n  return( (n.x * uvec4(_M0, _M1, _M2, _M3)) ^ (n.x >> 16) ); // MLCG constant\n}\n\n// public //\n\n// ####### hash(out,in)\n\nvec3 old_hash33(in vec3 xyz)\n{\n\treturn vec3(base_hash_3D(uvec3(_FSCALE * xyz))) * _FNORM;\n}\n\nvec4 old_hash44(in vec4 xyzw) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * xyzw))) * _FNORM;\n}\n","name":"Common","description":"","type":"common"}]}