{"ver":"0.1","info":{"id":"dtfXDf","date":"1675426301","viewed":97,"name":"Pshhh spirale de feu oulala","username":"Mollok","description":"Trippy wouwouw","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//float sdSphere(vec3 p, float s)\n//{\n  //return length(p)-s;\n//}\n\n#define STEPS 22\n#define NOISE_INTENSITY 3\n\n#define time iTime\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n\n//change forme du noise\nmat3 m3 = mat3( 0.00,  0.50,  0.60,\n              -0.80,  0.85, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n\nfloat grid(vec3 p)\n{\n\tfloat s = sin(p.x)*cos(p.y);\n\t//float s = sin(p.x)*cos(p.y);\n\treturn s;\n}\n\nfloat flow(in vec3 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\t//movement\n\t\tp += time*0.5;\n\t\tbp -= time*.5;\n\t\t\n\t\t//displacement map\n\t\tvec3 gr = vec3(grid(p*8.-time*1.),grid(p*3.9+4.-time*1.),grid(p*4.+4.-time*1.));\n\t\tp += gr*0.15;\n\t\trz+= (fract(noise(p)*8.)*0.5+0.5) /z;\n\t\t\n\t\t//advection factor (.1 = billowing, .9 high advection)\n\t\tp = mix(bp,p,.4);\n\t\t\n\t\t//scale and rotate\n\t\tz *= 1.5;\n\t\tp *= 2.01;\n\t\tp*=m3;\n\t\tbp *= 1.9;\n\t\tbp*=m3;\n\t}\n\treturn rz;\t\n}\n\n\n////////suite\n\n\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c, c) - 0.5 * c;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b*cos(6.28318 *(c*t+d));\n}\n\n\nfloat map(vec3 pos) // pos 3D de la marche //contient info du volume\n{\n    \n    pos = opRep(pos, vec3(3.1));\n    float f = flow(pos);\n    float an = 3.1*(0.5+0.5*cos(iTime+ 1.1 * 2.3));\n    vec2 c = vec2(sin(an),cos(an));\n    return sdCappedTorus(pos  * cos(iTime*0.2), c, 1.2 * f, 0.25 );\n\n    //float v = 0.0; //volume par def\n    \n    //v = sdSphere(pos, 1.0); // volume par def\n    \n    //return v;\n}\n\n\n\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // contact def\n    \n    for(int i = 0; i<64; i++)\n    {\n        float ray = map(ro + rd * c); // le voooolume calculÃ©\n        \n        if(ray < (0.0001*c)) // distance min = contact\n        {\n            return float(i)/32.0;\n        }\n        \n        c += ray;\n       }\n       return -1.0;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float contact = CastRay(ro, rd); // rajouter raymarch ici\n    \n    vec3 col;// couleur du pixel\n    \n    col = palette(col.x * sin(0.3), vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0));\n    \n    if(contact == -1.0) // si pas contact en raymarch\n    {\n    \n        col = vec3(0.0); // couleur fond\n    \n    }\n    else // s'il y a contact\n    {\n        col = vec3(0.5-contact, 0.2, 0.8); // couleur volume\n        col = palette(col.x, vec3(0.5), vec3(0.8), vec3(0.8, 0.6, 0.4), vec3(0.00, 0.15, 0.20));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //def cam\n    \n    vec3 cameraPos = vec3(0.0, 0.0, iTime  * 4.0);\n    vec3 cameraTar = vec3(0.0);\n    \n    //def vecteur de direction depuis la cam\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n\n    // Time varying pixel color\n    vec3 col = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}