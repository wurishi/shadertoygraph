{"ver":"0.1","info":{"id":"7l3BzN","date":"1662747960","viewed":279,"name":"Sound Bar Equalizer","username":"Falconssj","description":"\"Fake\" Sound Bar Equalizer, did for fun to learn more HLSL.\nStarted at Unreal and converted here!\n\nFeel free to play with the Global Vars!\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sound","equalizer","bar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Danilo Paulo, 09/09/2022\n// Don't forget to hit play on the iChannel0 \\/\n//------------------------------------------\n// Global Variables, feel free to play with them! :D\n\nfloat GridSize = 50.0; // Grid Sizes lower than 30 don't work very well\nfloat LineThick = 0.1; // Min 0.05, Max 0.45 for better results;\nfloat Amplitude = 1.5; // How High is the wave\nfloat Animating = 0.0;\nfloat beatTime = 0.5;\nfloat WaveCurve = 2.0;\n\nfloat getFrequencies(in vec2 uv) \n{\n\treturn texture(iChannel0, vec2(0.0001)).r;\n}\n\n//------------------------------------------\n// Hash23 Function for Random Colors\nvec3 Hash23 (vec2 UV){\n\n    vec3 RGB1 = vec3(UV.x,UV.y,UV.x) * vec3 (127.0, 312.0, 74.7);\n    vec3 RGB2 = vec3(UV.y,UV.x,UV.x) * vec3 (270.0, 183.0, 246.0);\n    vec3 RGB3 = vec3(UV.x,UV.y,UV.y) * vec3 (114.0, 272.0, 125.0);\n    \n    vec3 RGBF = fract(sin(vec3(RGB1.x + RGB1.y + RGB1.z,RGB2.x + RGB2.y + RGB2.z,RGB3.x + RGB3.y + RGB3.z)) * 43758.546875);\n    \n    return RGBF;\n\n}\n\n//------------------------------------------\n// Grid and Vertical Bars\nvec3 GridOutput (vec2 UV, vec2 grid){\n    \n    float Grid = 0.0;\n    float GridV = 0.0;\n    float GridH = 0.0;\n   \n    \n    vec2 UVTiled = UV * grid;\n    \n    vec2 GridM = fract(UVTiled);\n    GridM = ceil(clamp((1.0 - smoothstep(0.0,LineThick,GridM)) + (1.0 - smoothstep(0.0,LineThick,(1.0 - GridM))),0.0,1.0));\n    \n    \n    Grid = 1.0 - (GridM.x + GridM.y);\n    \n    \n    vec2 Square = 2.0 * min((1.0 - ceil(UVTiled)/grid),floor(UVTiled)/grid);\n    GridV = Square.x;\n    GridH = Square.y;\n    \n        \n    return vec3(Grid,GridH,GridV);\n \n}\nvec3 TimeLineOffset (vec2 UV, vec2 grid,float aspect){\n\n    \n    UV = vec2(UV.x*aspect,0.0);\n    \n    vec2 steppedTimer = UV + (ceil(fract(iTime*beatTime)*grid.y));\n    \n    steppedTimer = floor(steppedTimer * grid.y)/grid.y;\n    \n    float freq = getFrequencies(UV)*1.0;\n\n    vec2 SteppedUVs = UV * GridSize;\n    SteppedUVs= floor(SteppedUVs);\n    SteppedUVs /= GridSize;\n    vec4 a = texture(iChannel0,vec2(SteppedUVs.x,0.));\n  \n    vec3 random = Hash23(steppedTimer) * Amplitude * a.x;    \n\n    return random;\n\n}\n\n//------------------------------------------\n//Basic Functions\nfloat Sine01 (float speed){ //Sine Remapped to 0-1\n\n    return float (sin(iTime * speed) * 0.5) + 0.5;\n}\nfloat Lerp3(float X, float Y, float Z, float A){\n\n\n        float Lerp3Colors = mix(X,Y,clamp(A*2.0,0.0,1.0));\n        Lerp3Colors = mix(Lerp3Colors,Z,clamp((A*2.0)-1.0,0.0,1.0));\n\n        return Lerp3Colors;\n}\n\n\n//-------------------\n//Main \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){  \n   \n   vec2 uv = fragCoord     / iResolution.xy;\n   float aspect = iResolution.x / iResolution.y; \n   vec2 FinalGrid = vec2(GridSize*aspect,GridSize);\n   vec3 GridOut = GridOutput(uv, FinalGrid); // XYZ = (Grid / HorizontalBars / VerticalBars)\n   \n   \n   vec3 randombands = vec3(TimeLineOffset(uv, FinalGrid, aspect));// * (pow(GridOut.z,WaveCurve));\n           \n   float final = Lerp3(randombands.x, randombands.y, randombands.z, Sine01(1.0));\n   final *= Sine01(Animating); \n   float finalbg = final * 0.3;\n   final += (GridOut.y + 0.05);\n   finalbg += final;\n   finalbg = clamp(floor(finalbg),0.0,1.0) * GridOut.x * 0.25;\n   final = clamp(floor(final),0.0,1.0) * GridOut.x;\n   final = mix(finalbg,final,final*final);\n\n   vec3 FinalColor = final * mix(vec3(2.0,0.0,0.0),vec3(0.0,1.0,0.0),GridOut.y);\n    \n   fragColor = vec4(FinalColor,1.0);  \n}","name":"Image","description":"","type":"image"}]}