{"ver":"0.1","info":{"id":"cslGDl","date":"1667005831","viewed":63,"name":"ODE fixed points","username":"Envy24","description":"Drag point with mouse.\n\nhttps://www.youtube.com/watch?v=ySfs8YVMY7Q","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["field","vector","point","fixed","ode","linearization"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 12.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SCENE_SCALE               ( 2.5 )\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n#define NZMX_AR                   ( (iMouse.x+iMouse.x-R.x) / R.y )  // in range [-AR; AR]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET (vec2(0))//( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0));\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         \n/*from video*\n#define func(x) ( 0.5*(x)*(x)-2. )\n#define dfdx(x) ( (x) )\n/**\n#define func(x) ( 0.5*(x)*(x)*(x)*(x)-1.75*(x)*(x)+0.25*(x) )\n#define dfdx(x) ( 2.0*(x)*(x)*(x)-3.5*(x)+0.25 )\n/**/\n#define func(x) ( tan(sin(x)) )\n#define dfdx(x) ( 1./(cos(sin(x))*cos(sin(x)))*cos(x) )\n//#define dfdx(x, dx) ( ( func((x)+(dx)) - func(x) ) / (dx) )\n\n    /*Derivative*/\n    float fx = func(NDC.x);\n    color = \n         fx >= 0. ?\n             color :\n             color*0.95;\n    color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x)));\n\n    /* Sampled directions */\n    float count = 20.;\n    float dx = (2.*AR*SCENE_SCALE)/count, min_dist = 99., fx_ = 0., s = 0.125;\n    \n    for (float i = 0.; i <= count; i += 1.)\n    {\n        float x = -AR*SCENE_SCALE + dx * i;\n        fx = func(x)*s;\n        float dist = arrowSDF_L2(NDC, vec2(x, 0.), vec2(x+fx, 0.), 0.02, 1.);\n        min_dist = min( min_dist, dist);\n\n        fx_ = \n            min_dist == dist ?\n                fx :\n                fx_;\n    }        \n    color = mix( color, vec3(1.-fx_,0,fx_), SMAA(min_dist) );\n    \n    /* Traced point */\n    vec2 P = vec2(NZMX_AR, 0)*SCENE_SCALE;\n    \n    count = 20.;\n    for (float i = 0.; i <= count; i += 1.)\n    {      \n        color = mix( color, vec3(i/count,0,1), SMAA(diskSDF_L2(NDC, P, (3.+i/count)*UNIT)) );\n        P.x += func(P.x)*s;\n    }   \n    color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, P, 4.*UNIT)) );\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\n// Points after point E.\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R,\n    in float S) // Scale for working in screen coordinates.\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         C = E - dir * 0.05 * S, //      U--\n         U = C + up  * 0.05 * S, // B----C--E--E'\n         D = C - up  * 0.05 * S; //      D--\n         E += dir * 0.1375 * S;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.1375 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;\n}","name":"Common","description":"","type":"common"}]}