{"ver":"0.1","info":{"id":"ml23Rz","date":"1672786128","viewed":59,"name":"[myr] Strolling through boxes","username":"myrmyxo","description":"Experimenting with ray marching... Hard but so worth it !\nLegit very happy with how this looks.\nPrimitives of the box is iq's formula for it.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","flying"],"hasliked":0,"parentid":"dlS3zz","parentname":"[myr] Staircase of hands"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 200;\nconst float MIN_DIST = 0.05;\nconst float MAX_DIST = 20.;\nconst float PRECISION = 0.001;\n\nvec3 b1 = vec3(0.1,0.3,0.3);\nvec3 pos1 = vec3(-1.,0.,0);\nvec3 pos2 = vec3(-2.,1.,0);\n\nvec3 opRep(vec3 p, vec3 s)\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nfloat sdStairs(vec3 p, vec3 b, mat3 r)\n{\n    vec3 q = abs(opRep(p,vec3(2.,2.,1.))*r) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvec4 minMaterial(vec4 v1, vec4 v2)\n{\n    if(v1[0]>v2[0]){return v2;}\n    else{return v1;}\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end)\n{\n    float depth = start;\n\n    vec4 d = vec4(0.);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        vec4 d1 = vec4(sdStairs(p-pos1, b1, rotateX(iTime*3.)),0.5,0.2,0.1);\n        vec4 d2 = vec4(sdStairs(p-pos2, b1, rotateX(3.1415*0.25+2.*sin(iTime))),0.2,0.5,0.1);\n        d = minMaterial(d1, d2);\n        depth += d[0];\n        if (d[0] < PRECISION || depth > end) break;\n    }\n\n    return vec4(depth,d[1],d[2],d[3]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(sin(-iTime*0.78)*1.5, cos(iTime-1.2)*1.5, 5.-pow(iTime,1.2)*3.);\n    vec3 rd = normalize(vec3(uv.x + 0.2*-cos(-iTime*0.78), uv.y + 0.2*-sin(iTime-1.2), -1.));\n\n    vec4 d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n    if (d[0] > MAX_DIST)\n    {\n        col = vec3(0.);\n    }\n    else\n    {\n        vec3 p = ro + rd*d[0];\n        float dif = 1.-d[0]*0.04*(2.+sin(iTime));\n        col = 1.5*dif*vec3(d[1],d[2],d[3]);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}