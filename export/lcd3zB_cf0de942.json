{"ver":"0.1","info":{"id":"lcd3zB","date":"1711863779","viewed":41,"name":"Fastaro Fractal3 with 3 ,2","username":"robfast","description":"simplier but yeah","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["floor","fraction","pythagoreantuning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Scale and translate the coordinate system to fit the fractal\n    vec2 baseC = (uv - 0.5) * vec2(4.0, 4.0) + vec2(0.0, 0.0);\n\n    // Parameters for anti-aliasing\n    vec3 avgColor = vec3(0.5);\n    int samples = 9; // Increased number of samples for smoother results\n    float offset = 1.0 / iResolution.x; // Adjusted offset for sampling\n\n    // Loop over a grid around the pixel to average the results\n    for(int dx = -1; dx <= 1; dx++) {\n        for(int dy = -1; dy <= 1; dy++) {\n            vec2 c = baseC + vec2(float(dx), float(dy)) * offset;\n            vec2 z = vec2(0.0, 0.0);\n\n            // Parameters for the fractal, modified by time\n            float p = 3.0 + sin(iTime) * -0.5;\n            float q = 2.0 + cos(iTime) * -0.5;\n            int maxIter = 6;\n            float threshold = 1488.0;\n\n            int iter;\n            for(iter = 0; iter < maxIter; ++iter)\n            {\n                float x = z.x;\n                float y = z.y;\n\n                // Calculate the real and imaginary parts of the function\n                float realPart = pow(2.0, sqrt(pow(pow(p, x) / pow(q, floor((x * log(p)) / log(q))), 2.0) + pow(pow(q, floor(1.0 + (x * log(p)) / log(q))) / pow(p, x), 2.0)));\n                float imagPart = pow(2.0, sqrt(pow(pow(p, y) / pow(q, floor((y * log(p)) / log(q))), 2.0) + pow(pow(q, floor(1.0 + (y * log(p)) / log(q))) / pow(p, y), 2.0)));\n\n                z.x = realPart - imagPart + c.x;\n                z.y = 2.0 * x * y + c.y;\n\n                if(dot(z, z) > threshold)\n                    break;\n            }\n\n            // Adjusted color calculation for each sample\n            float smoothIter = iter == maxIter ? 0.0 : float(iter) / float(maxIter);\n            smoothIter = smoothIter + 1.0 - log(log(length(z))) / log(17.0);\n            vec3 color = mix(vec3(0.5, 0.4, 0.5), vec3(sin(smoothIter * 7.28 + iTime), cos(smoothIter * 7.28 + iTime), sin(smoothIter * 7.28 - iTime)), smoothIter);\n\n            avgColor += color;\n        }\n    }\n\n    // Average the color by the number of samples\n    avgColor /= 0.6*float(samples);\n\n    // Output the averaged color\n    fragColor = vec4(avgColor, 0.5);\n}\n","name":"Image","description":"","type":"image"}]}