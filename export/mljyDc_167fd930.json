{"ver":"0.1","info":{"id":"mljyDc","date":"1692391970","viewed":66,"name":"ringworld","username":"pb","description":"reflections are expensive, any help making this thing faster is appreciated","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip,bertani@gmail.com\n//Buffer A is where it is at\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    vec4 total_color;\n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float[] params = float[] ( \n0.,\n6.,\n-0.06,\n0.009,\n-0.12,\n8.,\n-0.625,\n8.,\n0.,\n0.,\n0.,\n0.,\n1.6,\n1.,\n0.,\n0.08,\n2.,\n0.,\n0.8,\n-0.32,\n-3.,\n1.,\n1.,\n0.2,\n0.2,\n0.03,\n-5.3,\n0.,\n-0.15,\n1.1,\n-0.006,\n0.,\n0.\n);\n\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define extraReflection 1.  //set this to zero if your FPS is crashing - sorry\n\nfloat num_iter, objid, inf=1e6, too_small=1e-6, distToFloor;\nvec3 ifs_color;\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 3.);\n    float nn=2.;\n    q.xz = mod(q.xz + nn, 2.*nn) - nn;\n    q.xyz -= 1.;\n    num_iter = 0.;\n    float i=0.;\n    for(; i < params[1]; i++) {\n        q.xyz = abs(q.xyz + (1.+params[32])*1.0) - (1.+params[32])*1.0*(1.+q.xyz/50.*(1.+params[19]));\n        q /= clamp(dot(q.xyz, q.xyz), 0.4+params[2], 1.0+params[3]);\n        q *= 1.2 * (1.+params[4]);\n        q *= 1. + (params[30])*q.y;\n        num_iter = i;\n    }\n    float div = 1. + params[12];\n    ifs_color = (1. + params[31]*float(num_iter) )* vec3( cos(q.x/div), cos(q.y/div), cos(q.z/div) );\n    float d1 = p.y + 6.0 +  min( -5.0, max( -5.4, (params[26] - .6*sin(iTime))));  // floor\n    if ( abs(q.w) < too_small ) q.w = sign(q.w) * too_small;\n    float d2 = length( max( abs(q.xyz) - vec3(1.2+params[5],1.3+params[6]*(1.+min(.2,max(-.1,.4*sin(iTime)))), 1.2+params[18]), 0.0) )/q.w;\n    objid = 0.0;\n    if ( d1 < d2 ) objid = 1.;  //floor\n    distToFloor = d1;\n    return min(d1 , d2);\n}\n\nfloat march(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    float eps = 1e-5, distfac=10.;\n    float hitThreshold = eps;\n    for(int i = 0; i < 100; i++) {\n        float d = de(ro + rd*t);\n        if (d < hitThreshold || t >= mx) break;\n        t += d;\n        hitThreshold = eps*(1.+t*distfac);\n    }\n    return t;\n}\n\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3  lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3  refl=-reflect(lightv,normal);\n   vec3  viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec+params[20]);\n   return (max(diffuse,0.0)+ambLight)*color + specular*vec3(1.,.5,0.);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.01 + params[25], 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx));\n    return normalize(n);\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 light_dir =  vec3(100.*cos(iTime),20.*sin(iTime),0.) ;\n    vec3 color     = vec3( params[27], params[28], params[29]);\n    float specular_power = 5.;\n    vec3 ambient_light = vec3(.5, .3, .5);\n    vec3 floor_color = vec3(.1,.4,.8);\n    float t = march(ro, rd, 100.0);\n    if(t < 100.0) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);        \n        vec3 cf = phong( pos, ro, nor, light_dir, color, specular_power, ambient_light);       \n        col = cf * (1.-objid); //lazy way of excluding floor\n        col += .3 * floor_color * objid;  // if it is the floor then add a bit of floor color to every pixel\n        float global_light_mult = exp(-0.2*(1.+params[13])*t);\n        col += params[15]*ifs_color * (1.-objid); \n        if (params[21] > 0. ) {  //first reflection\n            vec3 pos2 = ro + rd*.999*t; \n            vec3 ref = reflect(rd, nor);\n            float tt =  march( pos2, ref, 100.);\n\n            if ( tt < 100.) {\n                vec3 ppos = pos2 + ref*tt;\n                vec3 nnor = normal(ppos);\n                vec3 rref = reflect(ref, nnor);\n                vec3 cf2 = phong( ppos, ro, nnor, light_dir, color, specular_power, ambient_light); \n                col += params[23] * cf2 * (1.-objid);                    \n                col += params[23] * .1 * objid*floor_color;\n                col += params[23] * params[15] * ifs_color;\n                col *= exp(-tt-.5*distToFloor);\n\n              if ( (params[21] + extraReflection) > 1.) {  //second reflection\n                vec3 pos3 = pos2  + ref*.999*tt;\n                float ttt = march( pos3, rref, 80.);\n                if (ttt < 80. ) {\n                   vec3 pppos = pos3 + rref * ttt;\n                   vec3 nnnor = normal(pppos);\n                   vec3 cf3 = phong( pppos, ro, nnnor, light_dir, color, specular_power, ambient_light);\n                   col += params[24] * cf3 * (1.-objid);\n                   col += params[24] * .2 * objid * floor_color; \n                   col += params[24] * params[15]*ifs_color;\n                   col *= exp(-ttt-.5*distToFloor);\n                }\n              }\n            }\n        }\n        col = mix(vec3(0), col, 50.*global_light_mult );   //global lighting proportional to distance\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p  = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(.8,0.3,iTime/5.);\n    vec3 rd = normalize( vec3(p,1.2) );\n    \n    vec3 col = render(ro, rd);\n    col = 1. - exp(-.3 * (1.+params[16]) * col);\n   // col = sqrt(col);\n    \n    fragColor = vec4( col, 1.);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}