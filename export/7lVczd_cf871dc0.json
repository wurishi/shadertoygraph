{"ver":"0.1","info":{"id":"7lVczd","date":"1662058949","viewed":130,"name":"RayMarching SDF Practice","username":"slylips","description":"I am learning both GLSL and ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST  100.0\n#define MIN_DIST  0.0\n#define EPSILON   0.001\n\nfloat sphere(vec3 p)\n{\n    float dist = length(p) - 1.0;\n    //float displacement = sin(5.0 * p.x + iTime) * sin(5.0 * p.y + iTime) * sin(5.0 * p.z + iTime) * 0.25;\n    //dist += displacement;\n    \n    return dist;\n}\n\nfloat plane(vec3 p)\n{\n    float dist = p.y;// - pos.y; // axis-aligned plane\n    \n    return dist;\n}\n\nfloat box(vec3 p, vec3 size)\n{    \n    return length(max(abs(p) - size, 0.));;\n}\n\nfloat getDistance(vec3 p)\n{\n    float planeDist = plane(p);\n    float sphereDist = sphere(p - vec3(0, 1.2, -6));\n    float boxDist = box(p - vec3(-3.5, 1, -6), vec3(0.5));\n    \n    float dist = min(planeDist, boxDist);\n    dist = min(dist, sphereDist);\n    \n    return dist;\n}\n\nfloat SDF(vec3 rayOrg, vec3 rayDir)\n{\n    float totalDist = MIN_DIST;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float dist = getDistance(rayOrg + rayDir*totalDist);\n        totalDist += dist;\n        \n        if (totalDist > MAX_DIST || dist < EPSILON)\n        {\n            break;\n        }\n    }\n    return totalDist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(EPSILON, 0.);\n    float d = getDistance(p);\n    \n    vec3 n = d - vec3(getDistance(p - eps.xyy),\n                      getDistance(p - eps.yxy),\n                      getDistance(p - eps.yyx));\n    return normalize(n);\n}\n\nfloat getLighting(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz  += vec2(sin(iTime)*3., cos(iTime)*3.);\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 pNormal  = getNormal(p);\n    \n    float diffuse = clamp(dot(lightDir, pNormal), 0., 1.);\n    \n    float dist = SDF(p + 0.1*pNormal, lightDir);\n    \n    if (dist < length(lightPos - p))\n        diffuse *= 0.6;\n    \n    return diffuse;\n}\n\nvec3 getRayDir(vec2 fragCoord, vec2 size, float fov)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan( radians(fov)/2.0 );\n    \n    return normalize(vec3(xy, -z)); // looking down the -z direction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrg = vec3(0, 2, 0);\n    vec3 rayDir = normalize(vec3(uv.x-0.15, uv.y-0.2, -1)); //getRayDir(fragCoord, iResolution.xy, 45.0);\n    \n    float dist = SDF(rayOrg, rayDir);\n    \n    vec3 p = rayOrg + rayDir*dist;\n    \n    vec3 col = vec3(1, 0, 0) * vec3(getLighting(p));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}