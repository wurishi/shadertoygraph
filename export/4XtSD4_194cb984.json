{"ver":"0.1","info":{"id":"4XtSD4","date":"1719045371","viewed":65,"name":"Just Clouds (WIP)","username":"fxslava","description":"Perlin noise based","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cloudsColor(float t) {\n   vec3 color0 = vec3(32.,37.,71.);\n   vec3 color1 = vec3(50.,52.,86.);\n   vec3 color2 = vec3(57.,107.,137.);\n   vec3 color3 = vec3(129.,165.,186.);\n   vec3 color4 = vec3(221.,231.,238.);\n   \n   if (t < 0.25) {\n      return mix(color0, color1, t/.25) * (1. / 255.);\n   } else\n   if (t < 0.50) {\n      return mix(color1, color2, (t-.25) / 0.25) * (1. / 255.);\n   } else\n   if (t < 0.75) {\n      return mix(color2, color3, (t-.5) / 0.25) * (1. / 255.);\n   }\n   \n   return mix(color3, color4, (t - 0.75) / 0.25) * (1. / 255.);\n}\n\nvec3 sunPoint(vec3 eye) {\n    vec3 norm;\n    float intensity = sphereHit(sunPosition, eye, sunRadiuse, sunGalo, norm);\n    return mix(vec3(255., 228., 132.) * (1.f / 255.), vec3(1.,1.,1.),  pow(intensity, 25.0) * 0.9) * pow(intensity, 20.0);\n}\n\nvec3 lightShufts(vec3 eye) {\n    float t;\n    vec3 pos1 = eye * 0.1;\n    \n    vec3 pos2 = rayIntersectPlane(vec3(0.,0.,0.), eye, setPlane(vec3(0.,cloudsHeight + cloudsRange * 0.1, 0.), vec3(0.,1.,0.)), t);\n    pos2 = (t > 0. && t < 20.) ? pos2 : eye * 20.;\n    \n    const int Steps = 1000;\n    float d = (1.0f / float(Steps));\n    float w = length(pos1 - pos2) * d;\n    \n    float shuftColor = 0.;\n    \n    for (int i = 0; i < Steps; ++i) {\n       float s = float(i) * d;\n       \n       vec3 pos = (pos2 - pos1) * s + pos1;\n       \n       vec3 lightDir = normalize(pos - sunPosition * 100.);\n       \n       float t;\n       vec2 uv = shadowUv(sunPosition * 100., lightDir, t);\n       \n       t *= exp(-.1 * length(uv - vec2(0.5, 0.5)));\n       \n       float intensity = texture(iChannel0, uv).r;\n       float l = length(pos);\n       \n       shuftColor += w * t * pow(intensity, 4.) * exp(0.4 * l) * exp(-0.7 * l) * 0.5;\n    }\n    \n    \n    return vec3(shuftColor, shuftColor, shuftColor);\n}\n\n\nvec2 CloudsFin(vec3 org, vec3 eye, float iTime, const int Steps)\n{\n    float t;\n    vec3 pos1 = rayIntersectPlane(org, eye, setPlane(vec3(0.,cloudsHeight, 0.), vec3(0.,1.,0.)), t);\n    vec3 pos2 = rayIntersectPlane(org, eye, setPlane(vec3(0.,cloudsHeight + cloudsRange, 0.), vec3(0.,1.,0.)), t);\n    \n    float d = (1.0f / float(Steps));\n    float w = length(pos1 - pos2) * d;\n    \n    float f = 0.0f;\n    float z = 0.0f;\n    \n    if (t > 0.) {\n        for (int i = 0; i < Steps; ++i) {\n        \n           float s = float(i) * d;\n           vec3 pos = (pos2 - pos1) * s + pos1;\n           \n           f += cloudsNoise(pos * 0.1 + vec3(0., 0., iTime * 0.1)) * d;\n           \n           z = s;\n           \n           if (f > 0.1) {\n               break;\n           }\n        }\n    }\n    \n    vec3 p = (pos2 - pos1) * z + pos1;\n    vec3 lightDir = normalize(p - sunPosition * 100.);\n    vec2 uv = shadowUv(sunPosition * 100., lightDir, t);\n    vec3 c = (pos2 - pos1) * (1. - texture(iChannel0, uv).g) + pos1;\n    \n    float col = exp(-0.1 * length(c - p));\n    \n    return vec2(\n        col,\n        clamp(f * 20., 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float diagonal = length(iResolution);\n    vec2 screen_center = iResolution.xy * 0.5 / diagonal;\n   \tvec2 uv = fragCoord.xy / diagonal;\n    vec3 eye = normalize(vec3(uv - screen_center, 1.f));\n    \n    float t;\n    vec3 normal = vec3(0., 1., 0.);\n    vec3 pos = rayIntersectPlane(vec3(0.,0.,0.), eye, setPlane(shadowPlaneOrg, normal), t);\n    vec2 localHitPos  = pos.xz - shadowPlaneOrg.xz;\n    \n    vec3 rfl = reflect(eye, normal);\n    \n    float dist = length(pos);\n    float intensity = (pos.z > 0.) ? exp(-0.2 * dist) : 0.;\n    \n    vec3 shadowMask = (vec3(57.,107.,137.) / 255. + texture(iChannel0, shadowUv(vec3(0.,0.,0.), eye, t)).rgb * intensity) * 0.2;\n    \n    vec2 clouds = CloudsFin(vec3(0.,0.,0.), eye, iTime, 100);\n    \n    vec3 col = /*vec3(57.,107.,137.) / 255. +*/ sunPoint(eye);\n    \n    col = mix(col, shadowMask, (pos.z > 0.) ? 1. : 0.);\n    \n    col = mix(col, cloudsColor(clouds.x), clouds.y) + shadowMask;// + lightShufts(eye);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float shadowPlaneSizeX = 5.;\nconst float shadowPlaneSizeZ = 15.;\nconst vec3  shadowPlaneOrg   = vec3(0.,-1., 5.);\nconst vec3  shadowPlaneNorm  = vec3(0., 1., 0.);\nconst vec3  sunPosition      = vec3(0., 1., 5.);\nconst float cloudsHeight     = 1.0;\nconst float cloudsRange      = 0.4;\nconst float sunRadiuse       = 0.01f;\nconst float sunGalo          = 10.f;\n\nfloat hash(int n)\n{\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff)) / float(0x0fffffff);\n}\n\nfloat hash3(ivec3 p)\n{                    \n    int n = p.x*3 + p.y*113 + p.z*311;\n    return hash(n);\n}\n\nfloat noise(in vec3 x)\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3(i + ivec3(0,0,0)), \n                        hash3(i + ivec3(1,0,0)),f.x),\n                   mix( hash3(i + ivec3(0,1,0)), \n                        hash3(i + ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash3(i + ivec3(0,0,1)), \n                        hash3(i + ivec3(1,0,1)),f.x),\n                   mix( hash3(i + ivec3(0,1,1)), \n                        hash3(i + ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat cloudsNoise(vec3 x) {\n   \n   const mat3 m = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                       -0.60, -0.48,  0.64 );\n                    \n   vec3 q = 8.0 * x;\n   float f = 0.;\n   f  =  0.50 * noise(q); q = m * q * 2.0;\n   f +=  0.35 * noise(q); q = m * q * 1.5;\n   f +=  0.20 * noise(q); q = m * q * 2.1;\n   f +=  0.11 * noise(q); q = m * q * 2.1; \n   f +=  0.08 * noise(q); q = m * q * 2.0; \n   f +=  0.06 * noise(q); q = m * q * 2.0; \n   f +=  0.03 * noise(q); q = m * q * 2.0; \n   f +=  0.02 * noise(q); q = m * q * 2.0; \n   \n   return min(max(f - 0.7, 0.) * 100., 1.);\n}\n\n\nvec3 rayIntersectPlane(vec3 org, vec3 dir, vec4 plane, out float t)\n{\n    vec3 N = plane.xyz;\n    \n    t = (plane.w - dot(N, org)) / dot(N, dir);\n    \n    return org + dir * t;\n}\n\nvec4 setPlane(vec3 org, vec3 norm)\n{\n    return vec4(norm, dot(norm, org));\n}\n\nvec3 shadowPoint(vec2 uv)\n{\n    vec2 coord = uv * 2. - 1.;\n    return shadowPlaneOrg + vec3(shadowPlaneSizeX * coord.x, 0., shadowPlaneSizeZ * coord.y);\n}\n\nvec2 shadowUv(vec3 org, vec3 dir, out float hit)\n{\n    float t;\n    \n    vec3 pos = rayIntersectPlane(org, dir, setPlane(shadowPlaneOrg, shadowPlaneNorm), t);\n    \n    hit = (t > 0.) ? 1. : 0.;\n    \n    vec2 shadowXZ = (pos.xz - shadowPlaneOrg.xz) / vec2(shadowPlaneSizeX, shadowPlaneSizeZ);\n    \n    vec2 shadowUv = shadowXZ *.5 + .5;\n    \n    hit = (shadowUv.x > 0. && shadowUv.y > 0. && shadowUv.x < 1. && shadowUv.y < 1.) ? hit : 0.;\n    \n    return shadowUv;\n}\n\nfloat sphereHit(vec3 coord, vec3 eyeRay, float Radius, float Galo, out vec3 normal)\n{\n    vec3 nEyeRay = normalize(eyeRay);\n    vec3 coordER = dot(coord, nEyeRay) * nEyeRay;\n    vec3 radiusVec = coordER - coord;\n    float r = length(radiusVec);\n    float h2 = (r < Radius) ? sqrt(Radius *  Radius - r * r) : 0.0;\n    vec3 hitp = coordER - nEyeRay * h2;\n    normal = -(hitp - coord) / Radius;\n    \n    return 1.0f - clamp((r - Radius) / Galo, 0., 1.);\n}\n\nvec2 Clouds(vec3 org, vec3 eye, float iTime, const int Steps)\n{\n    float t;\n    vec3 pos1 = rayIntersectPlane(org, eye, setPlane(vec3(0.,cloudsHeight + cloudsRange,0.), vec3(0.,1.,0.)), t);\n    vec3 pos2 = rayIntersectPlane(org, eye, setPlane(vec3(0.,cloudsHeight,0.), vec3(0.,1.,0.)), t);\n    \n    float d = (1.0f / float(Steps));\n    \n    float f = 0.0f;\n    float z = 1.0f;\n    \n    const float th = 0.001;\n    \n    if (t > 0.) {\n        for (int i = 0; i < Steps; ++i) {\n        \n           float s = float(i) * d;\n           \n           vec3 pos = (pos2 - pos1) * s + pos1;\n           \n           f += cloudsNoise(pos * 0.1 + vec3(0., 0., iTime * 0.1)) * d;\n           z = s;\n           \n           if (f > th) {\n               break;\n           }\n        }\n    }\n    \n    return vec2(\n        clamp(f, 0., 1.),\n        z);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 dir = normalize(shadowPoint(uv) - sunPosition * 100.);\n    \n    vec2 val = Clouds(sunPosition * 100., dir, iTime, 100);\n    float f = 1. - val.x;\n    \n    fragColor = vec4(f, val.y, 0., 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}