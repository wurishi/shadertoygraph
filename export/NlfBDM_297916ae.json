{"ver":"0.1","info":{"id":"NlfBDM","date":"1650944105","viewed":106,"name":"Totalistic 9-n cellular automat","username":"Envy24","description":"9-neighbor totalistic cellular automat (Moore's neighbourhood).\n\nMore cellular automats: https://www.shadertoy.com/playlist/fXVSRy","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","9","totalistic","neighbors"],"hasliked":0,"parentid":"NtfBDM","parentname":"Totalistic 8-n cellular automat"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) \n{ \n    O = TEXF0(SC);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n#define READ_CELL(P) (TEX0(TEX_COORDS(P)).r)\n\nint read_neighbors_states(vec2 SC) \n{\n    /* Kernel:\n                tl t tr\n                 l m r\n                bl b br\n    */\n\n    float t  = READ_CELL(SC + vec2( 0,  1));\n    float tr = READ_CELL(SC + vec2( 1,  1));\n    float r  = READ_CELL(SC + vec2( 1,  0));\n    float br = READ_CELL(SC + vec2( 1, -1));\n    float b  = READ_CELL(SC + vec2( 0, -1));\n    float bl = READ_CELL(SC + vec2(-1, -1));\n    float l  = READ_CELL(SC + vec2(-1,  0));\n    float tl = READ_CELL(SC + vec2(-1,  1)); \n    float m  = READ_CELL(SC);\n\n    return // max sum == 9\n         int(l == 0.0) +\n         int(b == 0.0) +\n         int(r == 0.0) +\n         int(t == 0.0) +\n         int(tr == 0.0) +\n         int(br == 0.0) +\n         int(tl == 0.0) +\n         int(bl == 0.0) +\n         int(m == 0.0);\n}\n\nbool check_rule(\n    in int rule,\n    in vec2 SC)\n{\n    int num_of_alive_neighbors = read_neighbors_states(SC);\n    \n    float m = READ_CELL(SC);\n    \n    return \n        m == 0.0 ?\n            ((rule >> (num_of_alive_neighbors + 10)) & 1) != 0 :\n            ((rule >> num_of_alive_neighbors) & 1) != 0;\n}\n\nfloat init_one_pixel_in_center(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 M = vec2(floor(R.x * 0.5), floor(R.y * 0.5));\n    return \n        SC.y == M.y && SC.x == M.x ?\n            0.0 :\n            1.0;\n}\n\n\nfloat randomize_part_of_frame(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float hash = step(fract(sin(dot(SC, vec2(127.1,311.7))) * 43758.5453123), 0.5);\n\n    return \n       (SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y)) == true ?\n            hash :\n            1.0;\n}\n\nfloat rectangle(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    return \n       float((SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y))) - 1.0;\n}\n\nfloat circle(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float sl0 = dot(SC - C, SC - C);\n    float sl1 = dot(Offset, Offset);\n    \n    return \n       float(sl0 <= sl1);\n}\n\nfloat mainScene(in vec2 SC)\n{\n    float transition_number = 0.0;\n    \n    // Reinit every 200 frames.\n    bool s = transition(iFrame, 200, transition_number);\n    \n    // Change rule every 50 frames.\n    transition(iFrame, 50, transition_number);\n    \n    /* rules range = [0; 262143] or [0; 2^18 - 1]. */\n    int rule = 128 * int(transition_number) * 64 - 8 - 64 - 16; \n    //int rule = int(transition_number + 70000.) * 4096 - 8 - 64 - 32;\n    \n    float state = \n        check_rule(rule, SC) == ALIVE ?\n            0.0 :\n            1.0;\n        \n    return \n        s == true ?\n            //randomize_part_of_frame(SC, 0.4) :\n            rectangle(SC, 0.3) :\n            //circle(SC, 0.3) :\n            //init_one_pixel_in_center(SC) :\n            state;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(mainScene(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                        iResolution\n#define TEX0(TC)               ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n/* Every num_of_frame returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int numOfFrames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame);\n    float inv = 1.0 / float(numOfFrames);\n    \n    // Calculate previous and current quotents.\n    float qc = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < qc;\n}\n\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}","name":"Common","description":"","type":"common"}]}