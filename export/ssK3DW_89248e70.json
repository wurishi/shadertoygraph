{"ver":"0.1","info":{"id":"ssK3DW","date":"1631594538","viewed":50,"name":"ray tracer Yeganeh","username":"Unique417","description":"ray tracer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["reflection","shadow","pointlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera\n{\n    vec3 position;\n    float cameraDistance;\n};\n\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambient;\n    float reflection;\n};\n    \nconst Material material1 = Material(0.6, 0.3, 50., 1., 1.);\nconst Material material2 = Material(0.4, 0.4, 100., 0.2, 1.);\n    \n#define SPHERES_COUNT 2\nstruct Sphere \n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    Material material;\n} spheres[SPHERES_COUNT];   \n\nstruct Point_Light\n{\n    vec3 position;\n    vec3 color; // Not used for now\n    float intensity;\n} lights[1];\n    \nconst Sphere sphere1 = Sphere(vec3(0.0, 0., 0.),vec3(0.1, 0.4, 0.3), 0.1,\tmaterial1);\n\nconst Camera camera = Camera( vec3(0., 0., -0.2), 0.4);\n\nPoint_Light light1 = Point_Light(vec3(0.1, 0.2, -0.2), vec3(1., 1., 1.), 30.);                \n\n# define PLANES_COUNT 1\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n    Material material;\n} planes[PLANES_COUNT];\n\nPlane surface = Plane(vec3(0., -0.4, 0.), vec3(0., 1., 0.2),vec3(1., 1., 1.), material2);\n\n#define SPHERE 0\n#define PLANE 1\n\nvoid setupScene()\n{\n\tspheres[0] = sphere1;\n    \n    planes[0] = surface;\n    \n    lights[0] = light1;\n}    \n\nbool quadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nMaterial getMaterial(int type, int index)\n{\n    if (type == SPHERE)\n    {\n        return spheres[index].material;\n    }\n    \n    if (type == PLANE)\n    {\n        return planes[index].material;\n    }\n}\n\nbool intersectSphere(\n    vec3 origin, \n    vec3 direction, \n    Sphere sphere, \n    out float dist, \n    out vec3 surfaceNormal, \n    out vec3 Hit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (quadratic(a, b, c, t0, t1))\n    {        \n        if (t0 > t1) \n        {\n        \tfloat temp = t0;\n            t0 = t1;\n            t1 = temp;\n        } \n \n        if (t0 < 0.)\n        { \n            t0 = t1; \n            if (t0 < 0.) return false; \n        }  \n             \n        dist = t0;\n       \n        Hit = origin + dist * direction;\n        surfaceNormal = normalize(Hit - sphere.position);               \n        \n        return true;\n    }  \n     \n    return false;\n}\n\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float t, out vec3 hit) \n{    \n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        t = dot(p0l0, plane.normal) / denom; \n        \n        if (t >= 0.)\n        {\n            hit = origin + rayDirection * t;\n            return true;\n        }             \n    } \n \n    return false; \n} \n\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in Point_Light Point_Light, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - Point_Light.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.1, 2.) / pow(length(lightVector), 2.)) * Point_Light.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambient * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.0), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\nvoid shadow(vec3 hit, inout vec3 finalColor, float ambient, int type, int index)\n{\n    vec3 shadowSurfaceNormal;\n    vec3 shadowRay = lights[0].position - hit;\n    vec3 shadowRayDirection = normalize(shadowRay);\n    float distanceToLight = sqrt(dot(shadowRay, shadowRay));\n    vec3 shadowHit;\n    \n    float dist; \n    \n    for(int i = 0; i < 2; ++i)\n\t{\n        if (type == SPHERE && index == i)\n        {\n            continue;  \n        }\n    \n        if (intersectSphere(hit, shadowRay, spheres[i], dist, shadowSurfaceNormal, shadowHit))\n        {\n            if (dist > 0. && distanceToLight > dist)\n            {\n            \tfinalColor *= 2. * ambient;\n            }\n        }\n    }\n    \n    for(int i = 0; i < PLANES_COUNT; ++i)\n\t{\n \t\tif (type == PLANE && index == i)\n        {\n            continue;\n        }\n        \n        if (intersectPlane(planes[i], hit, shadowRay, dist, shadowHit))\n        {    \n            if (dist < distanceToLight)\n            {                \n \t\t\t\tfinalColor *= 2. * ambient;        \n            }\n        }\n    }     \n}\n\nvec3 rayTrace(in vec3 rayDirection, in vec3 rayOrigin)\n{\n    vec3 finalColor = vec3(0.);\n    \n    int BOUNCES = 2;\n    \n    int prevType = -1;\n    int prevIndex = -1;  \n   \n\tvec3 hit = rayOrigin; \n    vec3 passHit;\n    \n    for (int bounce = 0; bounce < BOUNCES; bounce++)\n    {    \n        float dist = 1. / 0.;\n        float objectHitDistance = dist;\n \n        vec3 surfaceNormal;\n        \n        int type = -1;\n    \tint index = -1;   \n        \n        vec3 passColor = vec3(0.);\n\n        for (int i = 0; i < SPHERES_COUNT; ++i)\n        {          \n            if (prevType == SPHERE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectSphere(rayOrigin, rayDirection, spheres[i], objectHitDistance, surfaceNormal, hit))\n            {                \n                if (objectHitDistance < dist)\n                {\n                    dist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, hit, spheres[i].color, lights[0], surfaceNormal, spheres[i].material);\n                    shadow(hit, passColor, spheres[i].material.ambient, SPHERE, i);\n                    \n                    type = SPHERE;\n                    index = i;\n                    passHit = hit;\n                }\n            }\n        }\n\n        for(int i = 0; i < PLANES_COUNT; ++i)\n        {\n            if (prevType == PLANE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectPlane(planes[i], rayOrigin, rayDirection, objectHitDistance, hit))\n            {\n                if (objectHitDistance <= dist)\n                {    \n\t\t\t\t\tdist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, hit, planes[i].color, lights[0], planes[i].normal, planes[i].material);        \n\n                    surfaceNormal = planes[i].normal;\n\n                    shadow(hit, passColor, planes[i].material.ambient, PLANE, i);\n                \n                \ttype = PLANE;\n                    index = i;                    \n                    passHit = hit;                    \n                }\n            }\n        } \n    \n        if (bounce == 0)\n        {\n            finalColor += passColor;\n        }\n        else\n        {\n        \tfinalColor += getMaterial(type, index).specular * passColor;\n        }\n        \n        if (type < 0) break;\n        \n        rayOrigin = passHit;\n        rayDirection = reflect(rayDirection, surfaceNormal);\n        \n        prevType = type;\n        prevIndex = index;\n    }\n    \n    return finalColor / float(BOUNCES);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupScene();\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 clipPlanePosition = vec3(uv.x, uv.y, camera.position.z + camera.cameraDistance);\n    vec3 rayDirection = normalize(clipPlanePosition - camera.position);\n     \n    vec3 finalColor = rayTrace(rayDirection, camera.position);\n    fragColor = vec4(finalColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}