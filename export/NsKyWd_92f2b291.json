{"ver":"0.1","info":{"id":"NsKyWd","date":"1655830546","viewed":313,"name":"Fast Approx. Specular BRDF GGX","username":"MichaelPohoreski","description":"Instructions:\n\nHold mouse down to view a fast approximation for GGX.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ibl","pbr","ggx","karis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fast Approximation for Specular BRDF \n// Copyleft {c} 2022 Michael Pohoreski\n// https://www.shadertoy.com/view/NsKyWd\n//\n// Can be plugged into glTF-Sample-Viewer\n// as a cheap replacement for u_GGXLUT\n//\n// **NOTE:** IBL Ems will be zero (!) if you use the naive approximation due to:\n//\n//     float Ems = (1.0 - (f_ab.x + f_ab.y));\n//\n// Or using descriptive names:\n//\n//     float Ems = (1.0 - vScaleBias.x + vScaleBias.y);\n//\n// Unreal Engine 4 has a higher quality approximation\n// that is enabled by default:\n//   \n// #define USE_UE4_APPROX 1\n//\n// See: \n// * glTF-Sample-Viewer\\assets\\images\\lut_ggx.png\n// * glTF-Sample-Viewer\\source\\Renderer\\shaders\\pbr.frag\n//\n// History\n// 1.2 Added UE4 GGX approximiation for mobile\n// 1.1 Added MONOCHROME output option, add note about \n// 1.0 Forked reference\n//\n// Reference:\n// * https://www.shadertoy.com/view/3lXXDB\n\n// Visualization: NOTE: VIEW_BLUE and VIEW_ERROR are mutually exclusive\n#define MONOCHROME      0\n#define VIEW_BLUE       0 // Add blue channel to make it easier to visualize as blue/magenta instea of read/green\n#define VIEW_ERROR      0 // Hold down mouse button to see approximate error\n#define USE_UE4_APPROX  1\n\n// Misc.\n#define SHOW_GRID_X     0\n#define SHOW_GRID_Y     0\n#define CROP_BAD_VALUES 1\n\n\n// 0.0 - 0.5 Blue\n// 0.5 - 1.0 Green\n// 1.0+      Red\nvec3 heatmap( float x )\n{\n//    return vec3( 1.0 - x, 0.5, x );\n//return vec3( x - 1.0, 2.0*(x - 0.5), x );\n    if( x < 0.5 ) return vec3( 0.0,  0.0, x  );\n    if( x > 1.0 ) return vec3(1.-x,  0.0, 0.0);\n    /*         */ return vec3( 0.0,x-0.5, 0.0);\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n// half3 EnvBRDFApprox( half3 SpecularColor, half Roughness, half NoV )\n#if USE_UE4_APPROX\nvec2 getGGX( vec2 uv )\n{\n    float nv        = uv.x;\n    float roughness = uv.y;\n    \n\tconst vec4   c0       = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4   c1       = vec4( 1, 0.0425, 1.04, -0.04 );\n\t      vec4   r        = roughness * c0 + c1;\n\t       float a004     = min( r.x * r.x, exp2( -9.28 * nv ) ) * r.x + r.y;\n\t       vec2 ScaleBias = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn ScaleBias;\n}\n\n#else\nvec2 getGGX( vec2 uv )\n{\n    vec2  st    = vec2(1.) - uv;\n    float d     = (st.x * st.x * 0.5) * (st.y * st.y);\n    float scale = 1.0 - d;\n    float bias  = d;\n    return vec2( scale, bias );\n}\n#endif // USE_UE4_APPROX\n\n#define PI 3.141592653589793\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Taken from https://github.com/SaschaWillems/Vulkan-glTF-PBR/blob/master/data/shaders/genbrdflut.frag\n// Based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nvec2 hammersley(uint i, uint N) \n{\n\t// Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n\tuint bits = (i << 16u) | (i >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\tfloat rdi = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i) /float(N), rdi);\n}\n\n// From the filament docs. Geometric Shadowing function\n// https://google.github.io/filament/Filament.html#toc4.4.2\nfloat G_Smith(float NoV, float NoL, float roughness)\n{\n\tfloat k = (roughness * roughness) / 2.0;\n\tfloat GGXL = NoL / (NoL * (1.0 - k) + k);\n\tfloat GGXV = NoV / (NoV * (1.0 - k) + k);\n\treturn GGXL * GGXV;\n}\n\n// From the filament docs. Geometric Shadowing function\n// https://google.github.io/filament/Filament.html#toc4.4.2\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = pow(roughness, 4.0);\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n\n// Based on Karis 2014\nvec3 importanceSampleGGX(vec2 Xi, float roughness, vec3 N)\n{\n    float a = roughness * roughness;\n    // Sample in spherical coordinates\n    float Phi = 2.0 * PI * Xi.x;\n    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n    // Construct tangent space vector\n    vec3 H;\n    H.x = SinTheta * cos(Phi);\n    H.y = SinTheta * sin(Phi);\n    H.z = CosTheta;\n    \n    // Tangent to world space\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.,0.,1.0) : vec3(1.0,0.,0.);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n    return TangentX * H.x + TangentY * H.y + N * H.z;\n}\n\n\n// Karis 2014\nconst uint numSamples = 1024u; // >= 8 has a bottom discontuinity\n\nvec2 integrateBRDF(float roughness, float NoV)\n{\n\tvec3 V;\n    V.x = sqrt(1.0 - NoV * NoV); // sin\n    V.y = 0.0;\n    V.z = NoV; // cos\n    \n    // N points straight upwards for this integration\n    const vec3 N = vec3(0.0, 0.0, 1.0);\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    for (uint i = 0u; i < numSamples; i++) {\n        vec2 Xi = hammersley(i, numSamples);\n        // Sample microfacet direction\n        vec3 H = importanceSampleGGX(Xi, roughness, N);\n        \n        // Get the light direction\n        vec3 L = 2.0 * dot(V, H) * H - V;\n        \n        float NoL = saturate(dot(N, L));\n        float NoH = saturate(dot(N, H));\n        float VoH = saturate(dot(V, H));\n\n        const float EPSILON = 1.0e-6;\n        if(NoL > EPSILON) {\n            float V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * V_pdf;\n            B += Fc * V_pdf;\n        }\n//return vec2(NoL, NoH);\n    }\n\n    return 4.0 * vec2(A, B) / float(numSamples);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float minRes  = min( iResolution.x, iResolution.y );\n\n    vec2  f = fragCoord;\n    vec2  g = f;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2  uv = g/minRes;\n    float a  = uv.y;\n    float mu = uv.x;\n\n    // Output to screen\n    vec2 expect = integrateBRDF(a, mu);\n    vec2 approx = getGGX( uv );\n    \n    // Single Scatter Energy\n    const float GRID = 128.0;\n    int gridX = int(mod( g.x, GRID));\n    int gridY = int(mod( g.y, GRID));\n#if SHOW_GRID_X\n    if ((g.x > 0.0) && (gridX == 0))\n    {\n        fragColor = vec4(0.5,0.5,1.0,1.0);\n        return;\n    }\n#endif\n#if SHOW_GRID_Y\n    if ((g.x > 0.0) && (gridY == 0))\n    {\n        fragColor = vec4(0.5,1.0,1.0,1.0);\n        return;\n    }\n#endif\n\n    vec2 result = (iMouse.z > 0.5) ? approx : expect;\n    vec3 color  = vec3( result.x, result.y, 0.0 );\n#if VIEW_BLUE\n         color.b = 1.0;\n#endif\n\n    float monoExpect = expect.x + expect.y;\n    float monoActual = result.x + result.y; // not approx\n\n#if MONOCHROME\n    //if (monoActual > 1.0)\n    //    color = vec3( monoActual - 1.0 );\n    //else\n        color = vec3( monoActual );\n#endif\n\n#if VIEW_ERROR\n    // Red  : actual >  expect \n    // Green: actual == expect\n    // Blue : actual <  expect \n    float difference = (monoActual - monoExpect)/monoExpect;\n\n    const float lo    = -0.02;\n    const float hi    = +0.02;\n    const float width = hi - lo;\n          float green = (difference - lo) / width;\n         if (difference > hi) color = vec3( difference, 0.0, 0.0 );\n    else if (difference < lo) color = vec3( 0.0, 0.0, -difference );\n    else /*  difference =0 */ color = vec3( 0.0, green, 0.0 );\n#endif\n\n    if (uv.x > 1.0)\n        color = vec3(0.);\n\n    float sum = (expect.x + expect.y);\n    float threshold = 0.8;\n\n#if CROP_BAD_VALUES\n    // Crop bottom disconuity when samples >= 8\n    if (numSamples > 8u && (uv.y < 0.017) && (uv.x < 1.0))\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    else\n#endif\n        // Scale and Bias for F0 (as per Karis 2014)\n        fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}