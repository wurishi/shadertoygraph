{"ver":"0.1","info":{"id":"wdtBDH","date":"1605035648","viewed":60,"name":"Mandelbulb DE","username":"Milk","description":"Sick mandelbulb ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 200;\nconst float MIN_DIST = 0.005;\nconst float SPEED = 0.05;\n\nstruct cameraType{\n    vec3 location;\n    float fov;\n};\n\ncameraType makeCamera(vec3 location, float fov){\n    cameraType camera;\n    camera.location = location;\n    camera.fov = fov;\n    return camera;\n}\n\nstruct lightType {\n\tvec3 pos;\n    vec3 color;\n};\n    \nstruct materialType {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float shininess;\n};\n    \nfloat trace(vec3, vec3, out bool, out int);\nvec3 estimateNormal(vec3, vec2, vec3);\nvec3 phong(vec3 p, lightType light, materialType mat, cameraType, vec2);\nvec3 lighting(vec3 p, materialType, cameraType, vec2);\nfloat DE(vec3, out int);\n    \nvec3 estimateNormal(vec3 source, vec2 uv, vec3 p) {\n    float Ex = 1.0/iResolution.x;\n    float Ey = 1.0/iResolution.y;\n    vec2 xdir = vec2(Ex,0.0);\n    vec2 ydir = vec2(0.0,Ey);\n    //vec3 zdir = vec3(0.0,0.0,E);\n    bool hit = false;\n    int iterations = 0;\n    //float p_point = trace(source, p, hit, iterations);\n    \n    vec3 ray_A = vec3(vec2(uv - xdir), 1.0);\n    vec3 ray_B = vec3(vec2(uv - ydir), 1.0);\n    vec3 A = (ray_A * trace(source, ray_A, hit, iterations)) - p;\n    vec3 B = (ray_B * trace(source, ray_B, hit, iterations)) - p;\n    vec3 n = normalize(cross(B,A));\n\n    return n;\n}\n\nmaterialType createMat(vec3 color, float diffuse, float specular, float shininess) {\n\tmaterialType mat;\n    mat.color = color;\n    mat.diffuse = diffuse;\n    mat.specular = specular;\n    mat.shininess = shininess;\n    return mat;\n}\n\nfloat softshadow( in vec3 source, in vec3 ray, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int iterations = 0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = DE(source + ray*t, iterations);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 lighting(vec3 p, materialType mat, cameraType camera, vec2 uv) {\n\tlightType light;\n    light.pos = vec3(10.0,sin(iTime) * 15.0,-4.0);\n    light.color = vec3(1.0,1.0,1.0);\n    vec3 litColor = phong(p, light, mat, camera, uv);\n    return litColor;\n}\n\nvec3 diffuse(vec3 p, lightType light, materialType mat, vec3 normal, vec3 lightNormal) {\n    //(0,0,0) is the eye/camera location\n    vec3 diffusePart = light.color * (mat.color * mat.diffuse)* dot( lightNormal, normal);\n    return max(diffusePart, 0.0);\n}\n\nvec3 specular(vec3 p, lightType light, materialType mat, vec3 normal, vec3 lightNormal, cameraType camera) {\n    vec3 r = reflect(-lightNormal,normal);\n    vec3 viewerVec = camera.location - p;\n    vec3 viewerVecNorm = normalize(viewerVec);\n    vec3 specularPart = light.color * (mat.color * mat.specular)*pow(max(dot(r,viewerVecNorm),0.0),mat.shininess);\n    return max(specularPart, 0.0);\n    \n}\n\nvec3 reflection(vec3 p, materialType mat, vec3 normal) {\n\tvec3 reflected = reflect(p, normal);\n    vec3 color = texture( iChannel1, reflected).xyz;\n    \n    return color;\n}\n\nvec3 phong(vec3 p, lightType light, materialType mat, cameraType camera, vec2 uv) {\n    vec3 surfaceNormal = estimateNormal(camera.location, uv, p);\n    vec3 lightNormal = normalize(light.pos - p);\n    \n    vec3 diffusePart = diffuse(p, light, mat, surfaceNormal, lightNormal);\n    vec3 specularPart = specular(p, light, mat, surfaceNormal, lightNormal, camera);\n    vec3 reflectionPart = reflection(p, mat, surfaceNormal);\n    \n    vec3 attenuation = vec3(1.0, 0.0,0.0);\n    float lightMag = length(light.pos - p);\n    float attenuationAmmount = 1.0/(attenuation[0] + (attenuation[1] * lightMag) + (attenuation[2] * pow(lightMag,2.0)));\n    \n    //float shadow = softshadow(p, lightNormal, 0.0, 1.0, 32.0);\n    \n    //return surfaceNormal;\n    //return diffusePart;\n    //return reflectionPart;\n    //return specularPart;\n    return (vec3(0.1,0.1,0.1) + attenuationAmmount * (reflectionPart * (diffusePart + specularPart)));\n}\n\n    \nconst float Power =  4.0;\nconst float Bailout = 100.0;\nconst int Iterations = 10;\nfloat DE(vec3 pos, out int iterations) {\n    //float power = Power;\n    float power = abs(sin(iTime * SPEED)) * Power + 4.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        if (r>Bailout) {\n            iterations = i;\n            break;\n        }\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat trace(vec3 from, vec3 direction, out bool hit, out int iterations) {\n\tfloat totalDistance = 0.0;\n\t//int steps;\n\tfor (int steps=0; steps < MAX_STEPS; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat distance = DE(p, iterations);\n\t\ttotalDistance += distance;\n        if (distance < MIN_DIST){\n            hit = true;\n            break;\n        }\n\t}\n\t//return 1.0-float(steps)/float(MAX_STEPS);\n   \treturn totalDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv*2.0) -1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tcameraType camera = makeCamera(vec3(sin(iTime*SPEED*2.0)/2.0,sin(iTime*SPEED)/2.0, -1.5), 70.0);\n    vec3 ray = vec3(uv, 1.0);\n    //vec3 rot = vec3(2.0 * 3.14 * sin(iTime * SPEED) * 0.3);\n    //mat3 rot_mat_z = mat3(cos(rot.z), -sin(rot.z), 0,\n    //                      sin(rot.z), cos(rot.z), 0,\n    //                      0, 0, 1);\n    //mat3 rot_mat_y = mat3(cos(rot.y), 0, sin(rot.y),\n    //                      0, 1, 0,\n    //                      -sin(rot.y), 0, cos(rot.y));\n    \n    bool hit = false;\n    int iterations = 0;\n    vec3 dist = vec3(trace(camera.location, ray, hit, iterations));\n\n    vec3 col = texture( iChannel0, ray ).xyz;\n    float shine = 30.0;\n    float spec = 5.0;\n    if (hit) {\n        //materialType mat = createMat(vec3(1.0 - float(iterations)/10.0,1.0 -float(iterations)/10.0,1.0 -float(iterations)/10.0),0.8, 1.0, 20.0);\n        materialType mat = createMat(vec3(1.0,0,0.7),0.8, spec, shine);\n        if (iterations > 3) {\n        \tmat = createMat(vec3(0.9, 0.7, 0.3),0.8, spec, shine);\n        }\n        if (iterations > 4) {\n        \tmat = createMat(vec3(0.5 + float(iterations)/10.0,float(iterations)/10.0,float(iterations)/5.0),0.8, spec, shine);\n        }\n        if (iterations > 5) {\n        \tmat = createMat(vec3(0.2,0.1,0.2+float(iterations)/20.0),0.8, spec, shine);\n        }\n         \n        col = lighting(ray * dist, mat, camera, uv);\n    }\n    fragColor = vec4(col ,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}