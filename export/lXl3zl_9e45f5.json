{"ver":"0.1","info":{"id":"lXl3zl","date":"1707886278","viewed":187,"name":"Learning rates for neural nets","username":"dpiponi","description":"From something said by Jascha Sohl-Dickstein.\n\nEach pixel(!) trains a (2D input, 1D output, 2 layer, 6 neuron) neural net. Two separate learning rates, one for each layer. Plots the loss for a fixed size 64 batch after 48 epochs of training.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["machinelearning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fasttanh(float x)\n{\n  return 3. * x / (3. + x * x);\n}\n\nfloat sigmoid(float tanhx, float x)\n{\n  return 0.5 + 0.5 * tanhx;\n}\n\nvec2 sigmoid(vec2 tanhx, vec2 x)\n{\n  return 0.5 + 0.5 * tanhx;\n}\n\nvec2 relu(vec2 x)\n{\n  return vec2(x.x > 0. ? 1. : 0., x.y > 0. ? 1. : 0.);\n}\n\nvec2 drelu(vec2 x)\n{\n  return max(vec2(0., 0.), x);\n}\n\nfloat dsigmoid(float tanhx, float x)\n{\n  //float d = cosh(x);\n  return 0.5 * (1. - tanhx * tanhx);/// (d * d);\n}\n\nvec2 dsigmoid(vec2 tanhx, vec2 x)\n{\n  //vec2 d = cosh(x);\n  return 0.5 * (1. - tanhx * tanhx);\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 col = 3. * abs(2. * fract(hsv.x + vec3(3., 2., 1.) / 3.) - 1.) - 1.;\n    return hsv.z * mix(vec3(1.), clamp(col, 0., 1.), hsv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    // vec2 m = iMouse.xy / iResolution.xy;\n    float lambda = 0.52;\n    \n    float w = exp(-5. + 5. * cos(0.2587 * iTime));\n    float basex = 0.2417;//0.0765;//0.1 * m.x;//0.5;//0.15;\n    float basey = 0.1122;//0.088;//0.1 * m.y;//0.5;//0.193;\n    //w = 0.0015;\n    float rate1 = basex + w * uv.x;\n    float rate2 = basey + w * uv.y;\n    \n    vec4 layer1 = vec4(0.1, 0.2, -0.1, -0.2);\n    vec2 layer2 = vec2(0.1, -0.1);\n    \n    float loss;//, n;\n    \n    for (int t = 0; t < 48; ++t)\n    {\n        loss = 0.;\n        //n = 0.;\n        \n        float dout = 0.;\n        vec2 dlayer2 = vec2(0.);\n        vec2 dh = vec2(0.);\n        vec4 dlayer1 = vec4(0.);\n\n        // Batch size 64\n        for (float x = 0.; x < 2.; x += 0.25)\n        {\n          for (float y = 0.; y < 2.; y += 0.25)\n          {\n              vec2 xy = vec2(x, y);\n              // Forward\n              float expected = mix(x, y, lambda);\n\n              vec2 h = vec2(dot(layer1.xy, xy), dot(layer1.zw, xy));\n              vec2 tanhh = tanh(h);\n              vec2 a = sigmoid(tanhh, h);\n\n              float outs = dot(layer2, a);\n              float tanhouts = tanh(outs);\n              float predicted = sigmoid(tanhouts, outs);\n\n              float error = predicted - expected;\n              loss += error * error;\n              //n += 1.;\n\n              // backprop\n              dout = 2. * error * dsigmoid(tanhouts, outs);\n              dlayer2 += dout * a;\n              dh = dsigmoid(tanhh, h) * layer2 * dout;\n              dlayer1.xz += x * dh;\n              dlayer1.yw += y * dh;              \n          } // y\n        } // x\n\n      layer1 -= rate1 * dlayer1;\n      layer2 -= rate2 * dlayer2;\n    } // t\n    \n    //loss = loss;\n\n    // Time varying pixel color\n    vec3 col = hsv2rgb(vec3(\n                    0.7 + 0.0625 * loss,\n                    0.65,\n                    0.8));\n    //vec3 col = 0.1*vec3(loss, loss, loss);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}