{"ver":"0.1","info":{"id":"sl3yz2","date":"1660134884","viewed":237,"name":"Burning Cave","username":"tk87","description":"Using two gyroid","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fire","cave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NOISE_FIRE\n\n#define SPHERE_ID 2.\n#define LIGHT_ID 3.\n\n#define SPHERE_R 1.\n#define LIGHT_R .2\n#define EPS 1e-5\n\nvec3 sunPos;\n\n\nmat2 rotate2D(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat hash(float p){\n    p = fract(p * 0.1234);\n    p *= p + 34.3;\n    return fract(p*p);\n}\nfloat hash21(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) * 1.013);\n    p3 += dot(p3, p3.yzx + 19.19) * 13.7;\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.43);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\n//https://www.shadertoy.com/view/lsf3RH\nfloat snoise(vec3 uv, float res){\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat gyroid(vec3 p, float scale, float th){\n    return (abs(dot(sin(p*scale), cos(p.yzx*scale))) - th)/scale;\n}\n\nvec2 upU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1: d2;\n}\n\nvec2 upAND(vec2 d1, vec2 d2) {\n    return (d1.x > d2.x) ? d1: d2;\n}\n\nvec2 map(vec3 p){\n    vec2 d,d2;\n    vec3 q = p;\n\n    d = vec2(gyroid(q, 1., .1)*.5, SPHERE_ID);\n\n    q=p;\n    q.y*=.5;\n#ifdef NOISE_FIRE\n    d2 = vec2(gyroid(q-snoise(q-iTime*.5,3.)*.3, 12., .03), SPHERE_ID);\n#else\n    d2 = vec2(gyroid(q-iTime*.5, 12., .03)*.8, SPHERE_ID);\n#endif\n\n    d = upAND(d, d2);\n\n    d2 = vec2(sphere(p-sunPos, LIGHT_R*2.5), LIGHT_ID);\n    d = upU(d, d2);\n\n    return d;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 h = vec2(EPS, 0.0);\n    return normalize(vec3(map(p + h.xyy).x - map(p - h.xyy).x,\n                        map(p + h.yxy).x - map(p - h.yxy).x,\n                        map(p + h.yyx).x - map(p - h.yyx).x\n        )); \n}\n\nmat3 setCamera(vec3 ro, vec3 tg, float cr){\n\tvec3 cw = normalize(tg-ro);\n\tvec3 cu = normalize(cross(cw,vec3(sin(cr), cos(cr), 0.0)));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    float td = .1;\n    vec2 d = vec2(100., -1.);\n    vec3 p;\n\n    vec3 col = vec3(0);\n\n    for(int i=0;i<80;++i){\n        p = ro + td * rd;\n        col.r += .02 / exp((length(p-sunPos) - LIGHT_R)*.1);\n        col.rg += .02 / exp((length(p-sunPos) - LIGHT_R));\n\n        d = map(p);\n\n        if(abs(d.x) < EPS || abs(d.x) > 30.){\n            break;\n        }\n            \n        td += d.x * .3;\n    }\n    \n    p = ro + td * rd;\n\n    if(d.y == SPHERE_ID) {\n        vec3 nor = calcNormal(p);\n        float diff = clamp(dot(sunPos-p, nor), 0.1, 1.0);\n\n        col.rg += (sin((p.z-sunPos.z)*10.+p.x*10.+p.y*10.)+1.)*diff*vec2(1,.4);\n        col.rg *= (.7 + .3*snoise(sin(p-sunPos)+sin(iTime), 15.));\n    }\n    else if(d.y == LIGHT_ID){\n        col *= vec3(1,.3,0) / exp(d.x) * (.5 + .4*snoise(sin(p)+sin(iTime)*.05, 30.));\n    }\n    \n    col.rgb *= 5. / exp(length((p-sunPos)) * vec3(1,.7,0) + .05);\n\n    return col;\n}\n\nvec2 path_xy(float z){\n    return vec2(-1.5-sin(z)*1.41, -cos(z)*.71);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 col = vec3(0), col2 = vec3(0);\n    \n\n    \n    vec3 ro, tg;\n\n    sunPos = vec3(path_xy(t),t);\n\n    float roz = -3.2+t;\n    vec2 roxy = path_xy(roz);\n    ro = vec3(\n        roxy,\n        roz\n    );\n    tg = vec3(path_xy(-2.+t),t);\n    //tg = vec3(0,0,t);\n\n    mat3 ca = setCamera(ro, tg, 0.);\n    vec3 rd = ca * normalize(vec3(uv, 1.));\n    \n    col = raymarch(ro, rd);\n\n    //col = pow(col, vec3(0.4545));\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}