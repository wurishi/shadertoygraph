{"ver":"0.1","info":{"id":"3tKyzz","date":"1610360285","viewed":182,"name":"shader_practice_2","username":"changwenhan","description":"Making by following this tutorial of The Art of Code:\nhttps://www.youtube.com/watch?v=KGJUl8Teipk","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 p) {\n    p = fract(p * vec2(321.456, 876.789));\n    p += dot(p, p+32.56);\n    return fract(p.x*p.y);\n}\n\nvec2 rand2(vec2 p) {\n    float n = rand(p);\n    return vec2(n, rand(p+n));\n}\n\nvec2 pointPos(vec2 id) {\n    vec2 circleCenter;\n    vec2 r = rand2(id);\n    circleCenter.x = sin((iTime+123.123)*r.x);\n    circleCenter.y = cos((iTime+123.123)*r.y);\n    circleCenter *= 0.4;\n    return circleCenter;\n}\n\n\nfloat distToLine(vec2 p ,vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat drawLine(vec2 p ,vec2 a, vec2 b) {\n    float dist = distToLine(p, a, b);\n    float w = 1. - step(0.01, dist);\n    w *= smoothstep(1.2, 0.8, length(a-b));\n    return w;\n}\n\n\nvec3 layer(vec2 uv) {\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec3 pixelColor = vec3(0.0);\n    \n    float gridLine = step(0.48, gv.x) + step(0.48, gv.y);\n    \n    vec2 circleCenter = pointPos(id);\n         \n    float circle = (1. - step(.03, length(circleCenter-gv)));\n    pixelColor += circle;\n    \n    \n    float line = 0.;\n    vec2 centerPoints[9];\n    for(int i=-1;i<2;i++) {\n        for(int j=-1;j<2;j++) {\n            vec2 offs = vec2(j,i);\n            vec2 nowId = id+offs;\n            \n            vec2 nowCircleCenter = pointPos(nowId) + offs;\n            centerPoints[(i+1)*3 + (j+1)] = nowCircleCenter;\n            line += drawLine(gv, centerPoints[(i+1)*3 + (j+1)], circleCenter);\n        }\n    }\n    line += drawLine(gv, centerPoints[1], centerPoints[3]);\n    line += drawLine(gv, centerPoints[1], centerPoints[5]);\n    line += drawLine(gv, centerPoints[7], centerPoints[3]);\n    line += drawLine(gv, centerPoints[7], centerPoints[5]);\n    \n    pixelColor += line;\n    \n    // pixelColor += gridLine*0.1;\n    \n    pixelColor = vec3(min(1., pixelColor.x));\n    \n    return pixelColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1~1\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 c_uv = uv;\n    \n    //vec2 mouse = iMouse.xy/iResolution.xy - .5;\n    //uv+=mouse*.5;\n    \n    // rotate\n    float radian = fract(iTime*.03) * 3.1415926 * 2.;\n    float s = sin(radian);\n    float c = cos(radian);\n    mat2 rotate = mat2(c, -s, s, c);\n    uv *= rotate;\n    \n    vec3 pixelColor;\n    \n    // draw each layer with zoom and opacity\n    for(int i=0;i<4;i++) {\n        float move = 10. - fract(iTime*.2+float(i)/4.) * 10.; // 10~0;\n        float opacity = smoothstep(10., 8. , move) * smoothstep(0., 2. , move);\n        float color = move/10.;\n        pixelColor += layer(uv*move*2.+float(i)*20.2) * opacity ;\n    }\n    \n    // add color\n    float r = sin(iTime)*.3 + .7;\n    pixelColor += vec3(.1);\n    pixelColor *= vec3(r, uv.x+.5, uv.y+.5);\n    \n    \n    // Output to screen\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}