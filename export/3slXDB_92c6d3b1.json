{"ver":"0.1","info":{"id":"3slXDB","date":"1552061533","viewed":1933,"name":"Boreal Starry Night","username":"BrutPitt","description":"A Boreal Starry Night.\n\nMy 2012 WebGL experiment ported to ShaderToy\nStandalone version also on github: [url]https://github.com/BrutPitt[/url]","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","line","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Show shootiong star \n#define COMET\n\n//varing light intensity for stars\n//#define FRACTAL_SKY\n//#define PULSED_STARS //for FRACTAL_SKY only\n\n//for use in shadertoy environment or similia\n#define SHADERTOY\n\n#ifdef SHADERTOY\nvec2 mouseR = vec2(0.);\nvec2 mouseL = vec2(0.);\n#else\nuniform float time;\nuniform vec2 mouseR;\nuniform vec2 mouseL;\nuniform vec2 resolution;\nuniform sampler2D skyTex;\nuniform sampler2D landTex;\n#endif\n\nconst vec3 starColor = vec3(.43,.57,.97);\n\nfloat contrast(float valImg, float contrast) { return clamp(contrast*(valImg-.5)+.5, 0., 1.); }\nvec3  contrast(vec3 valImg, float contrast)  { return clamp(contrast*(valImg-.5)+.5, 0., 1.); }\n\nfloat gammaCorrection(float imgVal, float gVal)  { return pow(imgVal, 1./gVal); }\nvec3  gammaCorrection(vec3 imgVal, float gVal)   { return pow(imgVal, vec3(1./gVal)); }\n\n//Get color luminance intensity\nfloat cIntensity(vec3 col) { return dot(col, vec3(.299, .587, .114)); }\n\n\nfloat hash( float n ) { return fract(sin(n)*758.5453); }\nhighp float rand(vec2 p) { return fract(sin(dot(p ,vec2(1552.9898,78.233))) * 43758.5453); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t    mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f  = 0.50000*noise( p ); p *= 2.02;\n          f += 0.25000*noise( p ); p *= 2.03;\n          f += 0.12500*noise( p ); p *= 2.01;\n          f += 0.06250*noise( p ); p *= 2.04;\n          f += 0.03125*noise( p );\n    return f*1.032258;\n}\n\n\nfloat fbm2( vec3 p )\n{\n    float f  = 0.50000*noise( p ); p *= 2.021;\n          f += 0.25000*noise( p ); p *= 2.027;\n          f += 0.12500*noise( p ); p *= 2.01;\n          f += 0.06250*noise( p ); p *= 2.03;\n          f += 0.03125*noise( p ); p *= 4.01;\n          f += 0.015625*noise( p );p *= 8.04;\n          f += 0.00753125*noise( p );\n    return f*1.05;\n}\n\nfloat borealCloud(vec3 p)\n{\n\tp+=fbm(vec3(p.x,p.y,0.0)*0.5)*2.25;\n\tfloat a = smoothstep(.0, .9, fbm(p*2.)*2.2-1.1);\n    \n\treturn a<0.0 ? 0.0 : a;\n}\n\nvec3 smoothCloud(vec3 c, vec2 pos)\n{\n\tc*=0.75-length(pos-0.5)*0.75;\n\tfloat w=length(c);\n\tc=mix(c*vec3(1.0,1.2,1.6),vec3(w)*vec3(1.,1.2,1.),w*1.25-.25);\n\treturn clamp(c,0.,1.);\n}\n\nfloat fractalField(in vec3 p,float s,  int idx) {\n   float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n   float accum = s/4.;\n   float prev = 0.;\n   float tw = 0.;\n   for (int i = 0; i < 24; ++i) {\n      float mag = dot(p, p);\n      p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n      float w = exp(-float(i) / 4.8);\n      accum += w * exp(-strength * pow(abs(mag - prev), 2.7));\n      tw += w;\n      prev = mag;\n   }\n   return max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n#ifdef PULSED_STARS\nfloat starField(vec2 p)\n{\n   vec3 rnd = nrand3(p * iResolution.x);\n   float intensity = pow((1.+sin((iTime+27.)*rnd.x))*.5, 7.) ;\n   return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n#else\nfloat starField(vec2 p)\n{\n   vec3 rnd = nrand3(p * iResolution.x);\n   return pow(abs(rnd.x + rnd.y + rnd.z)/2.93,9.7);\n}\n#endif\n\n#define iterations 16\n#define formuparam 0.53 //77\n\n#define volsteps 4\n#define stepsize 0.00733\n\n#define zoom   1.2700\n#define tile   .850\n#define speed  0.000\n\n#define brightness 0.0007\n#define darkmatter .1700\n#define distfading 1.75\n#define saturation .250\n\n\nvec3 starr(vec2 UV)\n{\n    float ratio = iResolution.y/iResolution.x;\n\t//get coords and direction\n\tvec2 uv=UV*.3723+vec2(0.,-.085); //-mouseL;\n\tuv.y*= ratio;\n\tvec3 dir=vec3(uv*zoom/ratio,1.);\n\n\tdir.xz*=mat2(.803, .565, .565, .803);\n\tdir.xy*=mat2(.9935,.0998,.0998,.9935);\n\n    vec3 from=vec3(-0.4299,-0.7817,-0.3568);\n\n\t//volumetric rendering\n\tfloat s=0.0902,fade=.7;\n\tfloat v=0.;\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*-9.9;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\ta*=a*a; // add contrast\n\t\tv+=fade;\n\t\tv+=s*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv = contrast(v *.009, .95)-.05;\n\tvec3 col = vec3(.43,.57,.97) * 1.7 * v;\n\n\tcol = gammaCorrection(col, .7);\n\n\treturn col + vec3(.67,.83,.97) * vec3(starField(UV)) * .9;\n}\n\n//besselham line function\n//creates an oriented distance field from o to b and then applies a curve with smoothstep to sharpen it into a line\n//p = point field, o = origin, b = bound, sw = StartingWidth, ew = EndingWidth, \nfloat shoothingStarLine(vec2 p, vec2 o, vec2 b, float sw, float ew){\n\tfloat d = distance(o, b);\n\tvec2  n = normalize(b - o);\n\tvec2 l = vec2( max(abs(dot(p - o, n.yx * vec2(-1.0, 1.0))), 0.0),\n\t               max(abs(dot(p - o, n) - d * 0.5) - d * 0.5, 0.0));\n\treturn smoothstep( mix(sw, ew, 1.-distance(b,p)/d) , 0., l.x+l.y);\n}\n\nvec3 comet(vec2 p)\n{\nconst float modu = 4.;        // Period: 4 | 8 | 16 \nconst float endPointY = -.1; // Hide point / Punto di sparizione Y\nvec2 cmtVel = mod(iTime/modu+modu*.5, 2.) > 1. ? vec2(2., 1.4)*.5 : vec2(-2., 1.4)*.5;  // Speed component X,Y\nvec2 cmtLen = vec2(.25)*cmtVel; //cmt lenght\n    \n    vec2 cmtPt = 1. - mod(iTime*cmtVel, modu);\n    cmtPt.x +=1.;\n\n    vec2 cmtStartPt, cmtEndPt;\n\n    if(cmtPt.y < endPointY) {\n        cmtEndPt   = cmtPt + cmtLen;\n        if(cmtEndPt.y > endPointY) cmtStartPt = vec2(cmtPt.x + cmtLen.x*((endPointY - cmtPt.y)/cmtLen.y), endPointY);\n        else                       return vec3(.0);\n    }\n    else {\n        cmtStartPt = cmtPt;\n        cmtEndPt = cmtStartPt+cmtLen; \n    }\n\n    float bright = clamp(smoothstep(-.2,.65,distance(cmtStartPt, cmtEndPt)),0.,1.);\n\n    vec2 dlt = vec2(.003) * cmtVel;\n\n    float q = clamp( (p.y+.2)*2., 0., 1.);\n\n    return  ( bright  * .75 *  (smoothstep(0.993, 0.999, 1. - length(p - cmtStartPt)) + shoothingStarLine(p, cmtStartPt, cmtStartPt+vec2(.06)*cmtVel,  0.009, 0.003)) +   //bulbo cmta\n             vec3(1., .7, .2) * .33 * shoothingStarLine(p, cmtStartPt,         cmtEndPt,        0.003, .0003) +          // scia ...\n             vec3(1., .5, .1) * .33 * shoothingStarLine(p, cmtStartPt+dlt,     cmtEndPt+dlt*2., 0.002 ,.0002) +         // ...\n             vec3(1., .3, .0) * .33 * shoothingStarLine(p, cmtStartPt+dlt+dlt, cmtEndPt+dlt*4., 0.001, .0001)            //\n            ) * (bright) * \n        q ; //attenuation on Y}\n}\n\n#define SMOOTH_V(V,R)  { float p = position.y-.2; if(p < (V)) { float a = p/(V); R *= a *a ;  } }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n#ifdef SHADERTOY\n    mouseL = iMouse.xy / iResolution.xy;\n#endif\n    vec2 mouseLeft = vec2(0.0);\n    vec2 mouse = mouseL;\n\n\tvec2 position = ( fragCoord / iResolution.xy );\n    vec2 uv = 2. * position - 1.;\n\t\n    position.y+=0.2;\n\n\tvec2 coord= vec2((position.x-0.5)/position.y,1./(position.y+.2));\n\n\tfloat tm = iTime * .75 * .5;\n\tcoord+=tm*0.0275 + vec2(1. - mouse.x, mouse.y);\n\tvec2 coord1=coord - tm*0.0275 + vec2(1. - mouse.x, mouse.y);\n\n\t\n    vec2 ratio = iResolution.xy / max(iResolution.x, iResolution.y);;\n    vec2 uvs = uv * ratio;\n\n// Boreal effects\n////////////////////////////////////\n    // CloudColor * cloud * intensity\n    vec3 boreal = vec3 (vec3(.1,1.,.5 )  * borealCloud(vec3(coord*vec2(1.2,1.), tm*0.22)) * .9  +\n                        //vec3(.0,.7,.7 )  * borealCloud(vec3(coord1*vec2(.6,.6)  , tm*0.23)) * .5 +\n                        vec3(.1,.9,.7) * borealCloud(vec3(coord*vec2(1.,.7)  , tm*0.27)) *  .9 +\n                        vec3(.75,.3,.99) * borealCloud(vec3(coord1*vec2(.8,.6)  , tm*0.29)) *  .5 +\n                        vec3(.0,.99,.99)  * borealCloud(vec3(coord1*vec2(.9,.5)  , tm*0.20)) *  .57);\n                        \n\n    SMOOTH_V(.5,boreal);\n    SMOOTH_V(.35,boreal);\n    SMOOTH_V(.27,boreal);\n\n    boreal = smoothCloud(boreal, position);\n    boreal = gammaCorrection(boreal,1.3);\n\n#ifdef EXTERNAL_TEXT\n\tvec2 vCoord = vec2(v_texCoord.x, 1.-v_texCoord.y);\n#endif\n\n// Sky background (fractal)\n////////////////////////////////////\n#ifdef FRACTAL_SKY\n    // point position sky fractal    \n    vec3 skyPt = vec3(uvs / 6., 0) + vec3(-1.315, .39, 0.);  //pt + pos\n    \n    skyPt.xy += vec2(- mouseLeft.x*.5*ratio.x, - mouseLeft.y * .5*ratio.y);\n\n    //fractal\n    vec3 freq = vec3(0.3, 0.67, 0.87);\n    float ff = fractalField(skyPt,freq.z, 27);\n\n    vec3 sky =  vec3 (.75, 1., 1.4) * .05 * pow(2.4,ff*ff*ff)  * freq ;\n#else\n    vec3 sky =  vec3 (0.);\n#endif\n\n// Moon\n////////////////////////////////////\n    vec2 moonPos = vec2(0.77,-.57) * ratio;\n    float len = 1. - length((uvs - moonPos) ) ;\n    // moon\n    vec3 moon = vec3(.99, .7, .3) * clamp(smoothstep(0.95, 0.957, len) - \n                                          smoothstep(0.93, 0.957, 1. - length(uvs - (moonPos + vec2(0.006, 0.006)) ) - .0045)\n                                          , 0., 1.) \n\n                                          * 2.;\n    vec3 haloMoon  = vec3(.0,  .2,  .7)  * 0.2     * smoothstep(0.4, 0.9057, len);\n         haloMoon += vec3(.5,  .5,  .85) * 0.0725  * smoothstep(0.7, 0.995,  len);\n\n// Shooting star\n////////////////////////////////////\n#ifdef COMET\n    vec3 cometA = comet(uvs);\n#endif\n\n// Terrain\n////////////////////////////////////\n         float ground = smoothstep(0.07,0.0722,fbm2(vec3((position.x-mouse.x)*5.1, position.y,.0))*(position.y-0.158)*.9+0.01);\n\n// Horizon Light\n////////////////////////////////////\n         float pos = 1. - position.y;\n         vec3 sunrise = vec3(.6,.3,.99) * (pos >  .45  ? (pos - .45)  * .65  : 0.) +  \n                        vec3(.0,.7,.99) * (pos >= .585 ? (pos - .585  ) * .6  : 0.) +\n                        vec3(.5,.99,.99)* (pos >= .67  ? (pos - .67) * .99 : 0.) ; \n\n// StarField\n////////////////////////////////////\n#ifdef FRACTAL_SKY\n         vec3 starColor = vec3(starField(uv));\n#else\n\n         vec3 starColor = starr(uv);\n         SMOOTH_V(.37,starColor);\n#endif\n\n// Intensity attenuation\n////////////////////////////////////\n         float ib = clamp(1.0-cIntensity(boreal)*3.,0.,1.);\n         ib*=ib;\n         float im = 1.0-cIntensity(moon);\n         float ih = 1.0-cIntensity(haloMoon)*8.;\n         float is = 1.0-cIntensity(sunrise)*6.;\n\n\n         sky += ((moon + haloMoon)*ib*ib) * is * is +\n                sunrise +\n#ifdef COMET\n                cometA +\n#endif\n                starColor  * ib *ib /*vec3(.3,.63,.97)*/  * im * im * ih * ih * is * is;\n\n\t\t fragColor =  vec4(boreal + sky, 1.) * ground;\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}