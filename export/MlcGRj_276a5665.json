{"ver":"0.1","info":{"id":"MlcGRj","date":"1470223842","viewed":178,"name":"Clothes Pin","username":"Sobaya","description":"clothes pin","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3ddistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nfloat poll(vec3 p) {\n  p = scale(p, vec3(1.2, 1.5, 1));\n  p = translate(p, vec3(-0.5,0.3,0));\n  vec2 d = abs(vec2(length(p.xy), p.z)) - 1.;\n  float result = min(max(d.x, d.y), 0.) + length(max(d, 0.));\n  result = max(result, -p.y);\n  return result;\n}\n\nfloat poll2(vec3 p) {\n  p = translate(p, vec3(-4.2,1.5,0));\n  p = rotate(p, vec3(0,0,1), 20.);\n  p = scale(p, vec3(2, 1.5, 15));\n  vec2 d = abs(vec2(length(p.xy), p.z)) - 1.;\n  float result = min(max(d.x, d.y), 0.) + length(max(d, 0.));\n  return result;\n}\n\nfloat body(vec3 p) {\n  float sub3 = p.y + 0.5;\n  const float freq = 0.1;\n  float triWave = (1. - abs(mod(p.x*10.,2.)-1.)) * 0.2;\n  vec3 n = normalize(vec3(-0.3, 1, 0));\n  float sub2 = dot(p - vec3(-4.2, 1.2, 0) - n * triWave, normalize(-n));\n  p = translate(p, vec3(10. / 18. + 0.3, 0,0));\n  float result = length(max(abs(p) - vec3(10,1,1), 0.0));\n  float sub = dot(p - vec3(0,0.5,0), normalize(vec3(0.15,1,0)));\n  result = max(result, sub);\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat ringOnly(vec3 p) {\n  float rate = 1. + (sin(iTime /10.) + 1.) * 0.05;\n  p = scale(p, vec3(rate,1,rate));\n  vec2 q = vec2(length(p.xy) - 4., p.z);\n  float result = length(q) - 0.3;\n  return result;\n}\n\nfloat ball(vec3 p) {\n  p = scale(p, vec3(0.5,0.5,10) );\n//  p = translate(p, vec3(0,-7,0));\n  return length(p) - 1.;\n}\n\nfloat side(vec3 p) {\n  float sub3 = length(p - vec3(0,-4,0)) - 1.2;\n  p = scale(p, vec3(0.65, 1,1));\n  p.x = abs(p.x);\n  p = translate(p, vec3(1.2,0,0));\n  p = rotate(p, vec3(0,0,1), 74. + 8. * (sin(iTime * 2.) + 1.));\n  //p = rotate(p, vec3(0,0,1), 76);\n  p = translate(p, vec3(0.5, -1.4, 0));\n  float sub2 = poll2(p);\n  float result = body(p);\n  result = smin(result, poll(p), 4.);\n  result = max(result, abs(p.z) - 1.);\n  result -= 0.5;\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat ring(vec3 p) {\n  float sub3 = length(p - vec3(0,-4,0)) - 1.2;\n  float r = ringOnly(p);\n  p = scale(p, vec3(0.65, 1,1));\n  p.x = abs(p.x);\n  p = translate(p, vec3(1.2,0,0));\n  p = rotate(p, vec3(0,0,1), 74. + 8. * (sin(iTime * 2.) + 1.));\n  //p = rotate(p, vec3(0,0,1), 76);\n  p = translate(p, vec3(0.5, -1.4, 0));\n  float sub2 = poll2(p);\n  float result = r;\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat dist(vec3 p) {\n  float result = side(p);\n  result = min(result, ring(p));\n  return result;\n}\n\nint getNearestIndex(vec3 p) {\n  float minDist = side(p);\n  int idx = 0;\n  float d = ring(p);\n  if (d < minDist) {\n    minDist = d;\n    idx = 1;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  t = (-size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  t = (-size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n\n  t = (-size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float a = -.5 * iTime;\n    float c = cos(a);\n    float s = sin(a);\n    vec3 n = normalize(vec3(1,1,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n\tvec3 eye = vec3(0,0,-15);\n\teye = rot * eye;\n\tvec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n\tconst float angle = 1.5;\n\tray = vec3(sin(uv * angle), length(cos(uv * angle)));\n\tray = rot * ray;\n\tray = normalize(ray);\n\tvec3 current = rayMarch(eye, ray);\n\n\tvec3 lightPos = vec3(1,1,-1) * 10.;\n\n\tif (abs(dist(current)) < eps) {\n    \tvec3 n = getNormal(current);\n    \tvec3 eyeVec = normalize(eye - current);\n   \t\tvec3 lightVec = normalize(lightPos - current);\n    \tvec3 refVec = reflect(-lightVec, n);\n    \tfloat diffuse = max(0.,dot(eyeVec, n));\n    \tfloat spec = max(0.,dot(eyeVec, refVec));\n    \tvec4 reflectColor = texture(iChannel0, cubeMap(current, reflect(-eyeVec, n)));\n      \tint idx = getNearestIndex(current);\n      \tif (idx == 0) {\n        \tfloat refRate = 0.05;\n        \tfragColor = vec4(0.9,0.7,0.7,1) * diffuse;\n        \tfragColor = fragColor * (1.-refRate) + reflectColor * refRate;\n        \tfragColor += pow(spec, 5.) * 0.2;\n      \t} else if (idx == 1) {\n        \tfragColor = reflectColor * 0.2 + vec4(0.5, 0.5 ,0.5, 1) * 0.8;\n        \tfragColor *= diffuse;\n        \tfragColor += pow(spec, 5.);\n      \t} else if (idx == 2) {\n            fragColor = vec4(0,0,0,1) * diffuse;\n      \t} else {\n        \tfragColor = vec4(0,0,1,1);\n      \t}\n\t} else {\n    \tfragColor = vec4(0.25);\n    \tfragColor.a = 1.;\n  \t}\n}\n","name":"Image","description":"","type":"image"}]}