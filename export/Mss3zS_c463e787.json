{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"precision mediump float;\n\n#define PI_2 1.57079632679\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat time = iTime;\n\n// Description : Array and textureless GLSL 3D simplex noise function\n// Author : Ian McEwan, Ashima Arts.\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n\nvec3 mod289( vec3 x ) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 mod289( vec4 x ) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec3 permute( vec3 x ) { return mod289(((x*34.0)+1.0)*x); }\n\nvec4 permute( vec4 x ) { return mod289(((x*34.0)+1.0)*x); }\n\nvec4 taylorInvSqrt( vec4 r ) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise( vec3 v ) {\n\tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy) );\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n  \tvec3 g = step(x0.yzx, x0.xyz);\n  \tvec3 l = 1.0 - g;\n  \tvec3 i1 = min( g.xyz, l.zxy );\n  \tvec3 i2 = max( g.xyz, l.zxy );\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\t// Permutations\n \ti = mod289(i);\n  \tvec4 p = permute( permute( permute( \n\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0 )) +\n\t\ti.y + vec4(0.0, i1.y, i2.y, 1.0 )) + \n\t\ti.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\n\t//p = permute(p + seed); // optional seed value\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  \tfloat n_ = 0.142857142857; // 1.0/7.0\n \tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\t\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );\n\t\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\t\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor(b0)*2.0 + 1.0;\n  \tvec4 s1 = floor(b1)*2.0 + 1.0;\n  \tvec4 sh = -step(h, vec4(0.0));\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3(a0.xy,h.x);\n  \tvec3 p1 = vec3(a0.zw,h.y);\n  \tvec3 p2 = vec3(a1.xy,h.z);\n  \tvec3 p3 = vec3(a1.zw,h.w);\n\n\t// Normalize gradients\n  \tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  \tm = m * m;\n  \treturn 42.0 * dot( m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)) );\n}\n\n// Dynamic fBm algorithms intended to circumvent \n// the constant comparator requirement in a GLSL for-loop\n// p = point * initial frequency; l = lucinarity; a = amplitude; g = gain\n// octaves should be a positive int but int not used to avoid casting\nfloat fBm( vec3 p, float l, float a, float g, float octaves ) {\t\n\tfloat res = 0.0; // result\n\tfloat f = 1.0;\n\tfor (float i=0.0; i<6.0; i++) {\n\t\tif (i<octaves) res += a * snoise(p * f); \n\t\ta *= g; \n\t\tf *= l;\n\t}\n\treturn res;\n}\n// Modified implementation that creates more \"ridge-like\" features\nfloat fBm_abs( vec3 p, float l, float a, float g, float octaves ) {\t\n\tfloat res = 0.0; // result\n\tfloat f = 1.0;\n\tfor (float i=0.0; i<6.0; i++) {\n\t\tif (i<octaves) res += a * abs( snoise(p * f) ); \n\t\ta *= g; \n\t\tf *= l;\n\t}\n\treturn res;\n}\n\n// Function to build a quaternion\nvec4 quaternion(vec3 axis, float angle) {\n\taxis = normalize(axis);\n\tangle *= 0.5;\n\tvec4 q = vec4(axis.xyz * sin(angle), cos(angle));\n\treturn q;\n}\n\n// Quaternion-based rotations are relatively inexpensive compared to typicl methods\nvec3 rotate( vec3 vec, vec4 quat ) {\n\treturn vec + 2.0 * cross( cross(vec, quat.xyz) + quat.w * vec, quat.xyz );\n}\n\n// Function to multiply two quaternions \n// This may be possible with fewer operations - need to investigate further\nvec4 mulQuat(vec4 q1, vec4 q2) {\n\treturn vec4( q1.x * q2.x - dot( q1.yzw, q2.yzw ),\n\t\t\t\t vec3(q1.x * q2.yzw + q2.x * q1.yzw + cross( q1.yzw, q2.yzw )) );\n}\n\t\n// Commonly used quaternions\nvec4 qY_05t = quaternion( vec3(0.0, 1.0, 0.0), mod(0.05 * time, TWOPI) ); \nvec4 qYn_05t = quaternion( vec3(0.0, 1.0, 0.0), -mod(0.05 * time, TWOPI) ); \nvec4 qY_03t = quaternion( vec3(0.0, 1.0, 0.0), mod(0.03 * time, TWOPI) ); \nvec4 qYn_01t = quaternion( vec3(0.0, 1.0, 0.0), -mod(0.01 * time, TWOPI) );\nvec4 qX_05 = quaternion( vec3(1.0, 0.0, 0.0), 0.05 );\nvec4 qZ_1 = quaternion( vec3(0.0, 0.0, 1.0), 0.1 ); \n\n// Constant Material IDs\n#define M_PLANET 0\n#define M_MOON 1\n#define M_SUN 2\n\n// Data structure for Celestial objects (planets, moon, sun)\nstruct Celestial {\n\tint material; // material ID\n\tvec3 origin; // center of object (after rotations)\n\tfloat radius; // radius of object\n};\n\t\n// Globally define the Celestial objects\nCelestial planet, moon1, moon2, moon3, sun;\n\n// Initializes the Celestial objects in this scene\nvoid initialize() {\n\tplanet.material = M_PLANET;\n\tplanet.origin = vec3(0.0);\n\tplanet.radius = 1.0;\n\t\n\t// Typical moon orbit, slightly inclined\n\tmoon1.material = M_MOON;\n\tmoon1.origin = rotate(vec3(4.0, 0.0, 0.0), mulQuat(qZ_1, qY_03t)); \n\tmoon1.radius = 0.03;\n\t\n\t// Moon with highly inclined retro-grade orbit (like Triton)\n\tmoon2.material = M_MOON;\n\tmoon2.origin = rotate(vec3(0.0, 0.0, 14.0), mulQuat(qX_05, qYn_01t));\n\tmoon2.radius = 0.055;\n\t\n\t// Distant moon with typical orbit\n\tmoon3.material = M_MOON;\n\tmoon3.origin = rotate(vec3(0.0, 0.0, 8.0), mulQuat(qX_05, qY_05t));\n\tmoon3.radius = 0.02;\n\t\n\t// At scale, sun radius would be ~423.7 (just a dot - which is no fun)\n\tsun.material = M_SUN;\n\tsun.origin = vec3(182885.0, 0.0, 0.0);\n\tsun.radius = 2000.0; \n}\n\t\n// Data structure for Result sets\t\nstruct Result {\n\tvec3 position; // intersect position\n\tvec3 normal; // normal at intersect position\n\tfloat depth; // distance from ray origin\n\tfloat edge; // sphere edge value (used for anti-aliasing)\n\tCelestial celestial; // the Celestial object data\n};\n\n// Celestial-Ray intersection test\n// params: ro=ray origin; rd=ray direction; c=Celestial object\n// return: Result(position, normal, depth, edge, celestial)\nResult hitTest(vec3 ro, vec3 rd, Celestial c) {\t\n\tResult res = Result(vec3(0.0), vec3(0.0), 1e9, 0.0, c);\n\tvec3 pd = c.origin - ro;\n\tfloat b = dot(rd, pd);\n\tfloat disc = b*b + c.radius*c.radius - dot(pd, pd+0.0001);\n\tif (disc>0.0) { // if ray hit the object\n\t\tres.edge = sqrt(disc);\n\t\t// This will give you hit inside or outside of the sphere\n\t\t// but that may be useful for something later\n\t\tfloat d = b - ( res.edge*sign(b) );\n\t\tif (d>0.0) res.depth = d;\n\t}\n\treturn res;\n}\n\n// Returns Result set that is nearest (qiuck depth sort)\nResult nearest (Result res1, Result res2) {\n\treturn (res1.depth<res2.depth) ? res1 : res2;\n}\n\nResult map (vec3 ro, vec3 rd) {\n\t// Test ray intersection with all objects - store closest result\n\tResult res = hitTest(ro, rd, sun);\n\tres = nearest(res, hitTest(ro, rd, planet));\n\tres = nearest(res, hitTest(ro, rd, moon1));\n\tres = nearest(res, hitTest(ro, rd, moon2));\n\tres = nearest(res, hitTest(ro, rd, moon3));\n\t// Store the hit position in world space\n\tres.position = ro + rd*res.depth;\n\t// Store the normal at the hit position\n\tres.normal = normalize(res.position - res.celestial.origin);\n\treturn res;\n}\n\n// Simple algorithm for calculating soft shadows cast by a \n// Celestial occluder. Treats the sun as a spherical light\n// source rather than a point light source. In theory, this\n// should create decent-looking umbras and penumbras that \n// are observed with real celestial objects\nfloat shadowMap (vec3 ro, vec3 nor, Celestial o) {\n\t\n\t// Light data\n\tfloat lRad = sun.radius;\n\tvec3 lDir = sun.origin - ro;\n\tfloat lDis = length(lDir);\n\tlDir = normalize(lDir);\n\t\n\t// Occluder data\n\tfloat oRad = o.radius;\n\tvec3 oDir = o.origin - ro;\n\tfloat oDis = length(oDir);\n\toDir = normalize(oDir);\n\t\n\t// Determine light visible \"around\" the occluder\n\tfloat l = lDis * ( length(cross(lDir, oDir)) - (oRad / oDis) );\n\tl = smoothstep(-1.0, 1.0, -l / lRad);\n    l *= smoothstep(0.0, 0.2, dot(lDir, oDir));\n\tl *= smoothstep(0.0, oRad, lDis - oDis);\n\t\n\t// Return a multiplier representing our softshadow\n\treturn 1.0-l;\n}\n\nvec4 getColor (Result res) {\n\tvec3 pos = res.position;\n\tvec3 nor = res.normal;\n\tfloat rad = res.celestial.radius;\n\tint mat = res.celestial.material;\n\t\n\tvec3 oCol = vec3(0.0); // base object color is black\n\t\n\t// Sun light\n\tvec3 lDir = normalize(sun.origin-pos); // direction\n\tvec3 lCol = vec3(1.0, 1.0, 0.8); // color\n\t\n\t// First diffuse caclulation is the same, regardless of which branch\n\t// the shader takes below. Keeping the branch instructions as short \n\t// as possible seems to help the frame rate quite a bit\n\tfloat lDif = clamp(dot(nor, lDir), 0.01, 1.0);\n\t\n\t// Background stars\n\tif (res.depth>=1e9) {\n\t\t// Simplex noise algorithm doesn't work that well with really large numbers\n\t\tfloat ns1 = snoise( pos * 2e-7 );\n\t\t\n\t\toCol = vec3(1.2) * smoothstep(0.9, 1.0, ns1);; // white stars\n\t\toCol += vec3(1.6, 1.0, 1.0) * smoothstep(0.8, 0.95, -ns1); // red-shift stars\n\t\toCol += vec3(1.0, 1.0, 1.6) * smoothstep(0.7, 0.85, ns1*ns1); // blue-shift stars\n\t\t\n\t\treturn vec4(oCol, 1.0);\n\t}\t\n\t// Planet\n\telse if (mat == M_PLANET) {\n\t\t// Rotate noise maps in different directions to simulate fluid clouds\n\t\tvec3 npPos1 = rotate(pos, qY_05t);\n\t\tvec3 npPos2 = rotate(pos, qYn_01t);\n\t\t// Banded noise\n\t\tfloat nc1 = fBm( npPos1 * vec3(0.4, 4.01, 0.4), 2.0, 0.5, 0.5, 2.0 );\n\t\t// Cloud noise\n\t\tfloat nc2 = fBm( npPos1 * vec3(1.2, 12.01, 1.2), 3.0, 0.5, 0.5, 4.0 );\n\t\tfloat nc3 = fBm( npPos2 * vec3(0.8, 6.01, 0.8), 2.0, 0.5, 0.5, 2.0 );\n\t\t\n\t\t// Add some blue bands\n\t\toCol = mix( vec3(0.4, 0.5, 1.0), vec3(0.3, 0.4, 1.0), smoothstep(-0.5, 0.5, nc1) );\n\t\t// Add some white clouds\n\t\toCol = mix( oCol, vec3(1.0), smoothstep(0.3, 1.0, nc2-nc3) );\n\t\t\n\t\t// Apply some alpha to smooth the edges; otherwise there's a\n\t\t// lot of pixelation visible with just one ray cast per pixel\n\t\tfloat a = smoothstep(0.1, rad*0.15, res.edge);\n\t\toCol *= a;\n\t\t\n\t\t// Fake bump mapping to give clouds some more depth\n\t\t// It's basically just another cloud noise map, offset\n\t\t// proportional to the angle to the light source\n\t\tvec3 axis = cross(nor, -lDir);\n\t\t// Aproximate theta - no need for perfect accuracy\n\t\tfloat costh = dot(nor, lDir);\n\t\tfloat theta = (1.0-costh*costh) * PI_2;\n\t\tvec4 q = quaternion(axis, theta*0.02);\n\t\tnpPos1 = rotate(npPos1, q);\n\t\tnc2 = fBm( npPos1 * vec3(1.2, 12.01, 1.2), 3.0, 0.5, 0.5, 4.0 );\n\t\tfloat ncbump = smoothstep(0.3, 1.0, nc2-nc3);\n\t\tncbump *= smoothstep(0.7, 0.05, nc2-nc3);\n\t\t\n\t\toCol *= (1.0-ncbump);\n\t\t\n\t\ta = smoothstep(0.0, rad*0.25, res.edge); // smooth edges\n\t\toCol = mix( oCol, vec3(0.7, 0.8, 2.4), 1.0-a); // atmosphere\n\t\t\n\t\t// Add soft shadows\n\t\tlDif *= clamp(shadowMap(pos, nor, moon1), 0.01, 1.0);\n\t\tlDif *= clamp(shadowMap(pos, nor, moon2), 0.01, 1.0);\n\t\tlDif *= clamp(shadowMap(pos, nor, moon3), 0.01, 1.0);\n\n\t\toCol *= lDif * lCol;\n\t\treturn vec4(oCol, a);\n\t}\n\t// Moons\n\telse if (mat == M_MOON) {\n\t\t// Translate back to world origin for noise mapping; otherwise,\n\t\t// the noise value will change with orbital rotation\n\t\tvec3 nmPos = pos - res.celestial.origin;\n\t\tfloat nm = fBm_abs( nmPos * 40.0, 2.0, 0.5, 0.5, 3.0 );\n\t\t\n\t\t// Dont need much detail since these moons will always\n\t\t// be pretty far from the camera\n\t\toCol = mix(vec3(0.7), vec3(0.3), nm);\n\t\tlDif *= clamp(shadowMap(pos, nor, planet), 0.01, 1.0);\n\t\toCol *= lDif * lCol;\n\t\treturn vec4(oCol, smoothstep(0.0, rad*0.15, res.edge));\n\t}\n\t// Sun\n\telse if (mat == M_SUN) {\n\t\t// Calculate squared-distance from sphere edge for alpha blending\n\t\tfloat a = res.edge / sun.radius;\n\t\ta *= a;\n\t\t\n\t\t// Sun is far away and small; no need to make it fancy\n\t\toCol = vec3(1.2, 0.8, 0.0) * a;\n\t\toCol += vec3(1.2, 1.0, 0.5) * ( max((a - 0.8), 0.0) );\n\t\toCol += vec3(1.2, 1.2, 1.2) * ( max((a - 0.7), 0.0) );\n\t\t\n\t\treturn vec4(oCol, a);\n\t}\n\treturn vec4(oCol, 1.0);\t\n}\n\nvec4 render (vec3 ro, vec3 rd) {\n\tResult res = map(ro, rd);\n\tvec4 color = getColor(res);\n\t\n\t// This attempts to correct for aliasing with a simple blending\n\t// technique. For performance reasons, only the color value of \n\t// the next object along the ray is retrieved.\n\tif (color.a<1.0) {\n\t\t// We don't want to hit the same object again, so we'll jump way\n\t\t// ahead along the ray. Our objects are spaced far enough apart\n\t\t// this works just fine for our purposes\n\t\tro = res.position + rd*res.celestial.radius*2.0;\n\t\tres = map(ro, rd);\n\t\tvec4 color2 = getColor(res);\n\t\tcolor = vec4(mix(color2.rgb, color.rgb, color.a), 1.0);\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Get aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y; // aspect ratio\n\t// Normalize screen coords\n\tvec2 pos = (fragCoord.xy / iResolution.xy) - 0.5;\n\tpos.x *= aspect;\n\t// Normalize mouse coords\n\tvec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n\tmouse.x *= aspect; \n\n\t// Initialize Celestial scene objects\n\tinitialize();\n\t\n\tvec3 cPos = vec3(0.0, 0.0, 4.5);\n\tvec3 cLook = planet.origin;\n\tvec3 cUp = vec3(0.0, 1.0, 0.0); // up vector \n\t\t\n\tvec4 qy = quaternion(vec3(0.0, 1.0, 0.0), mouse.x*TWOPI);\n\tvec4 qx = quaternion(vec3(1.0, 0.0, 0.0), -mouse.y*PI);\n\tcPos = rotate(cPos, mulQuat(qy, qx));\n\t\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\t// Cast a ray from this pixel\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\tfragColor = render(cPos, rd);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mss3zS","date":"1375991331","viewed":549,"name":"Neptunian","username":"ESpitz","description":"A procedurally generated, Neptune-like planet with orbiting moons. Rotate around the planet with mouse click and drag.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","noise","raycast","planet","shadows","moon","quaternion"],"hasliked":0,"parentid":"","parentname":""}}