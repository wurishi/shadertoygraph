{"ver":"0.1","info":{"id":"DdSGDG","date":"1668146651","viewed":64,"name":"p(t)=(tt, ttt) reparametrization","username":"Envy24","description":"Just template for sdf which requare to solve quartic equation.\nQuartic solver: https://www.shadertoy.com/view/ssKfRD","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","quartic","quintic","parametric","l2"],"hasliked":0,"parentid":"stcBRB","parentname":"Semi-Numeric Cubic Bezier SDF 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 3.0\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    return length(E-B);\n}\n\nvec2 parametric(float t)\n{\n    return vec2(t*t, t*t*t);\n}\n\nfloat curveSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    //NDC = rotateAroundZ(NDC, iTime*0.1);\n    NDC -= C;\n    \n    float coef[5] = float[5](\n        3.,\n        0.,\n        2.,\n        -3.*NDC.y,\n        -2.*NDC.x\n    );\n      \n    float minSqDist = INITIALLY_FAR;\n    vec2 roots[4], diff;\n\n    int num = solve4(roots, coef);\n\n    for (int r = 0; r < num; ++r)\n    {\n        diff = parametric(roots[r].x) - NDC;\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    diff = parametric(0.) - NDC;\n    minSqDist = min(minSqDist, dot(diff, diff));\n    \n    return sqrt(minSqDist) - r;\n}\n\nfloat arclength(float t0, float t1)\n{\n    const float a = 8./27.;\n    const float b = 9./4.;\n    float I0 = a + b * t0*t0,\n          I1 = a + b * t1*t1;\n    return I1 - I0;\n}\nfloat arclength(float t)\n{\n    const float a = 8./27.;\n    const float b = 9./4.;\n    float I0 = a,\n          I1 = a + b * t*t;\n    return I1 - I0;\n}\nfloat reparametrize(float s)\n{\n    float sign = s >= 0. ? 1. : -1.;\n    float t0 = sqrt(2.*abs(s)/3.);\n    return sign*t0;\n            \n}\nfloat reparametrize(float s, float t_max, float count)\n{\n    float sign = s >= 0. ? 1. : -1.;\n    float len = 0., dt = sign*t_max / count;\n    float t = 0.;\n    vec2 B = parametric(0.), E;\n    \n    //count += 10.;\n    \n    for (float i = 0.; i <= count && abs(len) <= abs(s); i += 1.)\n    {\n        t = i*dt;\n        E = parametric(t);\n        len += sign*length(E-B);\n        B = E;\n    }\n    \n    return t;\n}\n/* Bisection method for finding t relative to s */\nfloat reparametrize(float s, float t_max)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n    float sign = s >= 0. ? 1. : -1.;\n    s = abs(s);\n    float T[2] = float[2](0., t_max);\n    float F[2] = float[2](\n        arclength(T[0]),\n        arclength(T[1]));\n    \n    float l = 0.5;\n    \n    for (int i = 0; (i < 32) && (abs(l-s) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float t = (T[0] + T[1]) * 0.5;\n              l = arclength(t);\n\n        int w_idx = int(l>s);\n        \n        F[w_idx] = l; T[w_idx] = t;\n    }\n\n    return\n        sign * (T[0] + T[1]) * 0.5;\n}\n/**/\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    vec2 C,\n    float r,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.0;\n            //vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(curveSDF_L2(M, C, r));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    \n    float r = sinOSC(0.0, 0.3, iTime);\n    vec2 C = vec2(-1,0);\n    vec3 color = vec3(1);\n    \n   \n        color = colorize_field(curveSDF_L2(NDC, C, r), vec3(0.1, 0.4, 0.7));\n        color = add_metric_circle(NDC,  C, r, color);\n\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )        \n        float hr = 2.3;\n        float t = 0.;\n        float count = 10.;\n        float delta = (2.*hr)/(count-1.);\n        \n        for( float i = 0.; i < count; ++i )\n        {\n            t = -hr + mod(i*delta+iTime*0.5, 2.*hr);\n            color = mix(color, vec3(0,1,1), SMAA(diskSDF_L2(NDC-C, parametric(t), 3.*UNIT)) );\n            \n            /* All variants produces different results! *\n            float t_ = reparametrize(t, hr, 1000.);\n            color = mix(color, vec3(0,0,1), SMAA(diskSDF_L2(NDC-C, parametric(t_), 3.*UNIT)) );\n            /**\n            t_ = reparametrize(t, hr);\n            color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC-C, parametric(t_), 3.*UNIT)) );\n            /**/\n            t = reparametrize(t);\n            color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC-C, parametric(t), 4.*UNIT)) );\n            /**/\n        }\n        \n        /**\n        color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC-C, parametric(reparametrize(-hr)), 3.*UNIT)) );\n        color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC-C, parametric(reparametrize(hr)), 3.*UNIT)) );\n        \n        color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC-C, parametric(reparametrize(-1.)), 3.*UNIT)) );\n        color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC-C, parametric(reparametrize(1.)), 3.*UNIT)) );\n        /**/\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(Q) * cosh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(abs(Q)) * sinh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n     Returns number of real roots.       \n*/\nint solveQuartic(\n    inout vec2 roots[4],\n    in float coef[5])\n{\n    float invA = 1.0 / coef[0];\n    float B = coef[1] * invA;\n    float C = coef[2] * invA;\n    float D = coef[3] * invA;\n    float E = coef[4] * invA;\n\n    float coef_[4] = float[4](\n        1.,\n        -C,\n        D * B - 4. * E,\n        -(D * D + E * B * B - 4. * E * C)\n    );\n    vec2 roots_[3];\n\n    int num = solveCubicForReal(roots_, coef_);\n\n    float u = 0.0;\n    float D0 = 0.0;\n    float D1 = 0.0;\n\n    if (num == 3)\n    {\n        for (int r = 0; r < 3; ++r)\n        {\n            u = roots_[r].x;\n\n            D0 = B * B * 0.25 + u - C;\n            D1 = u * u * 0.25 - E;\n\n            if (D0 >= 0.0 && D1 >= 0.0)\n            {\n                break;\n            }\n        }\n    }\n    else\n    {\n        u = roots_[0].x;\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }   \n\n    D0 = abs(D0) < 1e-14 ? 0.0 : D0; D0 = sqrt(D0);\n    D1 = abs(D1) < 1e-14 ? 0.0 : D1; D1 = sqrt(D1);\n\n    float p0 = B * 0.5 + D0, p1 = B * 0.5 - D0,\n          q0 = u * 0.5 + D1, q1 = u * 0.5 - D1;\n    \n    // This line may cause problems.\n    if (abs(p0 * q1 + p1 * q0 - D) > 0.01)\n    {\n        float t = q0; q0 = q1; q1 = t;\n    } \n\n    vec2 r_[2];\n    float c_[3] = float[3]( 1.0, p0, q0 );\n\n    num = solveQuadraticForReal(r_, c_);\n\n    int wIdx = \n        num == 0 ? \n            2 : 0;\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    wIdx = \n        num == 0 ? \n        0 : 2;\n\n    c_[1] = p1; c_[2] = q1;\n\n    int n = solveQuadraticForReal(r_, c_);\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    num = num == 1 ? 2 : num;\n\n    return\n        n == 1 ? \n            num + 2 :\n            num + n;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve4(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {\n        return solveQuartic(roots, coef);\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[1], coef[2], coef[3]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}