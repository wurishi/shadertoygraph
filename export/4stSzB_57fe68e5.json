{"ver":"0.1","info":{"id":"4stSzB","date":"1460035701","viewed":185,"name":"PN texture proj","username":"mbredif","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat determinant(mat3 m) {\n  return   m[0][0]*( m[1][1]*m[2][2] - m[2][1]*m[1][2])\n         - m[1][0]*( m[0][1]*m[2][2] - m[2][1]*m[0][2])\n         + m[2][0]*( m[0][1]*m[1][2] - m[1][1]*m[0][2]) ;\n  }\n\nmat3 inverse(mat3 m) {\n  float d = 1.0 / determinant(m) ;\n  return d * mat3( m[2][2]*m[1][1] - m[1][2]*m[2][1],\n                    m[1][2]*m[2][0] - m[2][2]*m[1][0],\n                     m[2][1]*m[1][0] - m[1][1]*m[2][0] ,\n\n                   m[0][2]*m[2][1] - m[2][2]*m[0][1],\n                    m[2][2]*m[0][0] - m[0][2]*m[2][0],\n                     m[0][1]*m[2][0] - m[2][1]*m[0][0],\n   \n                   m[1][2]*m[0][1] - m[0][2]*m[1][1],\n                    m[0][2]*m[1][0] - m[1][2]*m[0][0],\n                     m[1][1]*m[0][0] - m[0][1]*m[1][0]\n                 );\n  }\n\nmat3 outerProduct(vec3 a,vec3 b)\n{\n    return mat3(a*b.x,a*b.y,a*b.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// view uniforms\n\tvec3 C = vec3(1.); // translation center \n\tmat3 M = mat3(1.); // rotation/projection matrix\n\tmat3 Minv = inverse(M);\n\tfloat size = 10.; // point size\n\n\t// per-tex uniforms\n\tvec3 Ctex = vec3(1.);\n\tmat3 Mtex = mat3(1.);\n\tvec3 ctex=Mtex*(C-Ctex);\n    \n\t// attributes\n    vec3 P = fragCoord.xyx; // 3D position\n\tvec3 N = iMouse.xyz;    // 3D normal\n    \n\t// vertex shader : view variables\n    vec3 D = P-C;\n    vec3 p0 = M*D; // usual projection without distorsion\n    mat3 A = Minv;\n    A[2] = D/p0.z;\n    vec3 N0 = N/dot(N,D);\n//    gl_PointSize = size;\n    \n\t// vertex shader : per-tex variables\n    A = (Mtex+outerProduct(ctex,N0))*A;\n     \n\t// fragment shader : per-tex variables\n\tvec2 d    = size*(gl_PointCoord-vec2(0.5));\n    vec3 ptex = A*vec3(d,1.);\n    fragColor = textureProj(iChannel0,ptex);\n}\n","name":"Image","description":"","type":"image"}]}