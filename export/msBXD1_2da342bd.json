{"ver":"0.1","info":{"id":"msBXD1","date":"1670233199","viewed":134,"name":"The terminator line","username":"ligaobo","description":"地球晨昏线","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["lighting","earth","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// world map reference: https://www.shadertoy.com/view/MdGBWG\n\n#define MAPRES vec2(144,72)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.xy * vec2(1.0, 0.5) *PI;\n    \n    float t = iTime * 0.35;\n    float mouse_x = (iMouse.x) / iResolution.x * PI * 2.0 + iTime * 0.5;\n    vec3 sun_dir = vec3(cos(mouse_x) * cos(PI / 6.0 * cos(t)),\n                        sin(mouse_x) * cos(PI / 6.0 * cos(t)),\n                        sin(PI / 6.0 * cos(t))\n                       );\n    float v = dot(computeLocalUpVector(uv), sun_dir);\n    float buf = fwidth(v);\n    \n    {\n        vec2 p = fragCoord * MAPRES / iResolution.xy;\n        vec2 uv = p / iResolution.xy;\n        \n        fragColor = vec4(0,0,0,1);\n        fragColor.rgb = mix(vec3(0.0, 0.0, 1.0), vec3(1.0), texture(iChannel0, uv).x);\n    }\n    \n        \n    // Output to screen\n    fragColor *= vec4(smoothstep(-buf, buf, v)) * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define  PI    3.14159265358979323846\n#define  PI_2  1.57079632679489661923\n#define  PI_4  0.78539816339744830962\n#define  LN_2  0.69314718055994530942\nfloat INVLN_2 = 1.0 / LN_2;\n\n#define radiusEquator 6378137.0\n#define radiusPolar 6356752.3142\n\nconst float flattening = (radiusEquator - radiusPolar) / radiusEquator;\nconst float eccentricitySquared = 2.0 * flattening - flattening * flattening;\n//-----------------------------------------------------------------------------------\n\nvec3 convertLongLatHeightToXYZ(vec3 LLH)\n{\n    float sin_latitude = sin(LLH.y);\n    float cos_latitude = cos(LLH.y);\n    float N = radiusEquator / sqrt(1.0 - eccentricitySquared * sin_latitude * sin_latitude);\n    return vec3((N + LLH.z) * cos_latitude * cos(LLH.x),\n            (N + LLH.z) * cos_latitude * sin(LLH.x),\n            (N * (1.0 - eccentricitySquared) + LLH.z) * sin_latitude\n            );\n}\n\nvec3 convertXYZToLatLongHeight(float X, float Y, float Z)\n{\n    float latitude, longitude, height;\n\n    // handle polar and center-of-earth cases directly.\n    if (X != 0.0)\n        longitude = atan(Y,X);\n    else\n    {\n        if (Y > 0.0)\n            longitude = PI_2;\n        else if (Y < 0.0)\n            longitude = -PI_2;\n        else\n        {\n            // at pole or at center of the earth\n            longitude = 0.0;\n            if (Z > 0.0)\n            { // north pole.\n              latitude = PI_2;\n              height = Z - radiusPolar;\n            }\n            else if (Z < 0.0)\n            { // south pole.\n              latitude = -PI_2;\n              height = -Z - radiusPolar;\n            }\n            else\n            { // center of earth.\n              latitude = PI_2;\n              height = -radiusPolar;\n            }\n            return vec3(longitude, latitude, height);\n        }\n    }\n    \n    // http://www.colorado.edu/geography/gcraft/notes/datum/gif/xyzllh.gif\n    float p = sqrt(X*X + Y*Y);\n    float theta = atan(Z*radiusEquator , (p*radiusPolar));\n    float eDashSquared = (radiusEquator*radiusEquator - radiusPolar*radiusPolar)/\n                          (radiusPolar*radiusPolar);\n\n    float sin_theta = sin(theta);\n    float cos_theta = cos(theta);\n\n    latitude = atan( (Z + eDashSquared*radiusPolar*sin_theta*sin_theta*sin_theta) /\n                     (p - eccentricitySquared*radiusEquator*cos_theta*cos_theta*cos_theta) );\n\n    float sin_latitude = sin(latitude);\n    float N = radiusEquator / sqrt( 1.0 - eccentricitySquared*sin_latitude*sin_latitude);\n\n    height = p/cos(latitude) - N;\n\n    return vec3(longitude, latitude, height);\n}\n\nvec3 computeLocalUpVector(vec2 LL)\n{\n    return vec3(cos(LL.x)*cos(LL.y), sin(LL.x)*cos(LL.y), sin(LL.y));\n}\n\nmat4 computeCoordinateFrame(vec2 LL)\n{\n    // compute up vector\n    vec3 up = vec3(cos(LL.x)*cos(LL.y), sin(LL.x)*cos(LL.y), sin(LL.y));\n    // compute east vector\n    vec3 east = vec3(-sin(LL.x), cos(LL.x), 0.0);\n    // compute north vector = outer product up x east\n    vec3 north = cross(up, east);\n    \n    return mat4(vec4(east, 0.0), vec4(north, 0.0), vec4(up, 0.0), vec4(vec3(0.0), 1.0));\n}\n\nmat4 computeLocalToWorldTransformFromXYZ(vec3 xyz)\n{\n    vec3 llh = convertXYZToLatLongHeight(xyz.x,xyz.y,xyz.z);\n    mat4 toworld = computeCoordinateFrame(llh.xy);\n    toworld[3] = vec4(llh, 1.0);\n    return toworld;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 1-bit land/ocean map, 2.5 degree resolution\n// auto-generated by https://github.com/rkibria/img2shadertoy\nconst vec2 bitmap_size = vec2(160, 72);\nconst int[] palette = int[] ( 0x00000000, 0x00ffffff );\nconst int[] rle = int[] ( 0x0001ff91, 0x03ff9100, 0xf8000000, 0x0008ff8f, 0xfffc0000, 0xf80fffff, 0x010aff89, 0xfe000000, 0x39ffffff, 0xff88fc3c, 0x0000030a, 0xffffc000, 0xc0003fff, 0x0100ff88, 0x80050084, 0x0000ffbf, 0x00ff87fe, 0x07008607, 0x20000078, 0xf7ffffff, 0x0f00ff83, 0x20000086, 0x20060083, 0xffff8fff, 0x00873fff, 0x00844000, 0x00007004, 0x0089f437, 0x00cd0100, 0x00921800, 0x00920c00, 0x00921c00, 0x008a1c00, 0x00860800, 0x008a3800, 0x00861000, 0x00897800, 0x00870400, 0x0089f800, 0x86400201, 0x01f80100, 0x0f000088, 0xf80b0087, 0x80000003, 0x00000007, 0x871fc3c0, 0x07f80b00, 0x0f800000, 0xc0000000, 0x00871fff, 0x000ff80b, 0x001f8000, 0xffc00000, 0x0b00871f, 0x00001ff0, 0x00001fc0, 0x1fffe000, 0xf00b0087, 0xc000003f, 0x0000063f, 0x870fffe0, 0xfff00b00, 0x3fe00000, 0xc0000004, 0x00870fff, 0x00fff00b, 0x0c3fe000, 0xfe000000, 0x0b008703, 0x0000fffc, 0x000cffe0, 0x027c0000, 0xfe0a0087, 0xe00000ff, 0x000008ff, 0x00883000, 0x01fffe05, 0x8dffe000, 0xffff0500, 0xffe00003, 0xff0b008d, 0xe00003ff, 0x000000ff, 0x87060004, 0xffff0b00, 0xfff00000, 0x02000000, 0x008703c1, 0x0007ff0a, 0x01fff000, 0x31710000, 0xff090088, 0xf000000f, 0x800003ff, 0x09008971, 0x000007fe, 0x0007fff0, 0x00896140, 0x0001fe09, 0x0ffffdf0, 0x88410100, 0xfec00b00, 0xfff80000, 0x80000fff, 0x00870600, 0x0008200a, 0xfffffc00, 0x0200c009, 0x700b0088, 0xfe000000, 0xc007ffff, 0x87010f80, 0x001e0b00, 0xfffc0000, 0x80e01eff, 0x00860107, 0x081bc00b, 0xfffc0000, 0xc3e07e7f, 0x0b008703, 0x000101c0, 0x7ffffe00, 0x07e7f0ff, 0xe00c0087, 0x00000001, 0x7fbffffc, 0x017ff7f8, 0xf00b0086, 0x00000081, 0x8ffffffc, 0x87ffffff, 0x83fc0c00, 0xf0000000, 0xfff7ffff, 0x8601ffff, 0x7ffa0700, 0xf0000000, 0xff83e77f, 0xfe070087, 0x000001ff, 0x83c00fe0, 0x853000ff, 0xff800800, 0x000003ff, 0x83c00f00, 0x85c800ff, 0xffc00e00, 0x000003ff, 0xcffb00f0, 0x043fffff, 0x0d008401, 0x07ffffc0, 0x61f00000, 0xffffcf67, 0x00850fff, 0xffffc00e, 0x8000000f, 0xfff707d7, 0x023fffff, 0xc00d0084, 0x003fffff, 0xafff8000, 0xffffffc3, 0x0900857f, 0x3fffffc0, 0xff800002, 0xff83e7ff, 0xe0070085, 0x03ffffff, 0x85fec000, 0x840100ff, 0xfff00700, 0x0001ff7f, 0xff85f890, 0x0083c000, 0xfff80108, 0x00007e1f, 0xff842840, 0x01c07f0f, 0x07000000, 0x6e03fffe, 0x7c000000, 0x0eff84fc, 0x00000101, 0xffffffc0, 0x00700603, 0x84ee7c00, 0x1f7f0eff, 0xff800000, 0x384fffff, 0xf00380f8, 0x0cff85fe, 0x8700007f, 0x7fffffff, 0x0003f878, 0x0eff87e0, 0xffc00000, 0x1e5c7bff, 0x80003ff8, 0x84df007f, 0x0d0084ff, 0xfc07f63e, 0x0000007f, 0xfffff820, 0x00841fef, 0xfd03c00c, 0x00fffc01, 0x00400000, 0x00875ffe, 0xf0e91204, 0x0083ffff, 0x1fa00302, 0x80060087, 0xfffff3f8, 0x0083f000, 0x00880300, 0xfffff004, 0x00c603ff );\n\nconst int rle_len_bytes = rle.length() << 2;\n\nint get_rle_byte( in int byte_index )\n{\n        int long_val = rle[ byte_index >> 2 ];\n        return ( long_val >> ( ( byte_index & 0x03 ) << 3 ) ) & 0xff;\n}\n\nint get_uncompr_byte( in int byte_index )\n{\n        int rle_index = 0;\n        int cur_byte_index = 0;\n        while( rle_index < rle_len_bytes )\n        {\n                int cur_rle_byte = get_rle_byte( rle_index );\n                bool is_sequence = int( cur_rle_byte & 0x80 ) == 0;\n                int count = ( cur_rle_byte & 0x7f ) + 1;\n\n                if( byte_index >= cur_byte_index && byte_index < cur_byte_index + count )\n                {\n                        if( is_sequence )\n                        {\n                                return get_rle_byte( rle_index + 1 + ( byte_index - cur_byte_index ) );\n                        }\n                        else\n                        {\n                                return get_rle_byte( rle_index + 1 );\n                        }\n                }\n                else\n                {\n                        if( is_sequence )\n                        {\n                                rle_index += count + 1;\n                                cur_byte_index += count;\n                        }\n                        else\n                        {\n                                rle_index += 2;\n                                cur_byte_index += count;\n                        }\n                }\n        }\n\n        return 0;\n}\n\n\nint getPaletteIndexXY( in ivec2 fetch_pos )\n{\n        int palette_index = 0;\n        if( fetch_pos.x >= 0 && fetch_pos.y >= 0\n                && fetch_pos.x < int( bitmap_size.x ) && fetch_pos.y < int( bitmap_size.y ) )\n        {\n                int uncompr_byte_index = fetch_pos.y * ( int( bitmap_size.x ) >> 3 )\n                        + ( fetch_pos.x >> 3);\n                int uncompr_byte = get_uncompr_byte( uncompr_byte_index );\n\n                int bit_index = fetch_pos.x & 0x07;\n                palette_index = ( uncompr_byte >> bit_index ) & 1;\n        }\n        return palette_index;\n}\n\n\nint getPaletteIndex( in vec2 uv )\n{\n        int palette_index = 0;\n        ivec2 fetch_pos = ivec2( uv * bitmap_size );\n        palette_index = getPaletteIndexXY( fetch_pos );\n        return palette_index;\n}\n\nvec4 getColorFromPalette( in int palette_index )\n{\n        int int_color = palette[ palette_index ];\n        return vec4( float( int_color & 0xff ) / 255.0,\n                                float( ( int_color >> 8 ) & 0xff) / 255.0,\n                                float( ( int_color >> 16 ) & 0xff) / 255.0,\n                                0 );\n}\n\nvec4 getBitmapColor( in vec2 uv )\n{\n        return getColorFromPalette( getPaletteIndex( uv ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = fragCoord / bitmap_size;\n        fragColor = getBitmapColor( uv );\n}","name":"Buffer A","description":"","type":"buffer"}]}