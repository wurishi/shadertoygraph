{"ver":"0.1","info":{"id":"NsyGWG","date":"1632118427","viewed":192,"name":"Fork of Tater's subdiv 3d","username":"0b5vr","description":"Fork of https://www.shadertoy.com/view/7sKGRy by @Tater\n\ndescribed some procedure in the comment excessively very well cuz I had to\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","cubes","subdivision","subdivide"],"hasliked":0,"parentid":"7sKGRy","parentname":"Iterative Subdivison Fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MDIST 150.0\n#define STEPS 300.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Based on code from bigwings comment here\n//https://www.shadertoy.com/view/Wl3fD2\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    p/=b;\n    vec3 dir = sign(rd)*.5;   \n    vec3 rc = (dir-p)/rd;\n    rc*=b;\n    float dc = min(min(rc.x, rc.y), rc.z)+0.001;\n    return dc;\n}\n\nvec3 rdg = vec3(0);\n\nstruct RectSubdivResult {\n    float volume;\n    vec3 center;\n    vec3 dimension;\n    float id;\n};\n\n/**\n * Ref: https://www.shadertoy.com/view/7sKGRy\n * @param p The input position\n * @param scale scale of the domain of the fractal\n */\nRectSubdivResult rectSubdiv( vec3 p, vec3 scale ) {\n    float t = iTime;\n\n    // several constants\n    const int ITERS = 12;\n    const int MIN_ITERS = 1;\n    const float MIN_SIZE = 0.15;\n    const float BREAK_CHANCE = 0.0;\n    const float PAD_FACTOR = 1.01;\n\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 domainMin = vec3( -0.5 ) * scale;\n    vec3 domainMax = vec3( 0.5 ) * scale;\n\n    // id of the individual cube in the fractal\n    float id = 0.0;\n    \n    // random seed of cut positions\n    float seed = floor( t / 6.0 ) + 0.1;\n\n    // size of the current box determined by domainMin / domainMax\n    vec3 dimension = domainMax - domainMin;\n    \n    for ( int i = 0; i < ITERS; i ++ ) {\n        float fi = float( i );\n\n        // divide the box into eight\n        vec3 divideHash = vec3(\n            h21( vec2( fi + id, seed ) ),\n            h21( vec2( fi + id + 2.44, seed ) ),\n            h21( vec2( fi + id + 7.83, seed ) )\n        );\n        vec3 divide = divideHash * dimension + domainMin;\n\n        // let the division line cut the box not too thin\n        divide = clamp( divide, domainMin + MIN_SIZE * PAD_FACTOR, domainMax - MIN_SIZE * PAD_FACTOR );\n        \n        // does this cut the box to the minimum preferrable size?\n        vec3 minSizeOfAxis = min( abs( domainMin - divide ), abs( domainMax - divide ) );\n        float minSize = min( minSizeOfAxis.x, min( minSizeOfAxis.y, minSizeOfAxis.z ) );\n        bool isSmallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        if ( i - 1 > MIN_ITERS && h11( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if ( isSmallEnough && i - 1 > MIN_ITERS || i == ITERS - 1 ) { willBreak = true; }\n        if( willBreak ) {\n            // id = i * 0.1 * seed;\n            break;\n        }\n\n        // update the box domain\n        domainMax = mix( domainMax, divide, step( p, divide ) );\n        domainMin = mix( divide, domainMin, step( p, divide ) );\n\n        // id will be used for coloring and hash seeding\n        vec3 diff = mix( -divide, divide, step( p, divide ) );\n        id = length( diff + 10.0 );\n    \n        // recalculate the dimension\n        dimension = domainMax - domainMin;\n    }\n    \n    // calculate volume and center of the box\n    float volume = dimension.x * dimension.y * dimension.z;\n    vec3 center = ( domainMin + domainMax ) / 2.0;\n    \n    // prepare the result\n    RectSubdivResult result;\n    result.volume = volume;\n    result.center = center;\n    result.dimension = dimension;\n    result.id = id;\n    \n    return result;\n}\n\nvec2 blocks( vec3 p, vec3 scale, vec3 rd ) {\n    float t = iTime;\n\n    const float MAX_CENTER_DIST = 4.5;\n    const float MAX_VOLUME = 5.0;\n    const float DESTRUCTION_CHANCE = 0.5;\n\n    RectSubdivResult rectSubdivResult = rectSubdiv( p, scale );\n    \n    float volume = rectSubdivResult.volume;\n    vec3 center = rectSubdivResult.center;\n    vec3 dimension = rectSubdivResult.dimension;\n    float id = rectSubdivResult.id;\n\n    //huge improvment in performance by using distance to intersection of empty cell\n    //to remove boxes (instead of using a negative box sdf)\n    //But it seems to cause artifacts rarely, idk why\n    float b = dibox( p - center, dimension, rd );\n    \n    float shr = 1.0-abs(pow(abs(cos(mod(t,6.)*pi/6.)),6.0));\n    shr = smoothstep(0.,1.,shr);\n    vec3 d = abs(center);\n    center.y -= dimension.y * ( 1.0 - shr ) * 0.5;\n    dimension.y *= shr;\n    float a = box( p - center, dimension * 0.5 );\n\n    //I found this helps to remove some of the artifacts from using the empty box intersection\n    if( abs( p.x ) > scale.x * 0.5 ) { b = -a; }\n    if( abs( p.z ) > scale.z * 0.5 ) { b = -a; }\n    \n    a = min( a, b );\n    if( max( d.x, max( d.y * 0.5, d.z ) ) > MAX_CENTER_DIST ) { a = b; }\n    else if ( volume > MAX_VOLUME ) { a = b; }\n    else if ( h11( id * 1.1 ) < DESTRUCTION_CHANCE ) { a = b; }\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec2 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec3 scl = vec3(10.0,10.,10);\n    vec3 rd2 = rdg;\n    a = blocks(p,scl,rdg)+0.02;\n    \n    a.x = max(box(p,vec3(scl*0.49)),a.x);\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.00005,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,5,-20);\n    if(iMouse.z>0.){\n    ro.zx*=rot(7.0*iMouse.x/iResolution.x);\n    }\n    else ro.zx*=rot(iTime*0.3);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1,-1));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        vec3 e = vec3(0.5);\n        \n        vec3 al = pal(d.y*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n        if(d.y==2.0) al = vec3(1.);\n        col = al;\n        \n        float diff = length(sin(n*2.)*.5+.8)/sqrt(3.);\n        col = al*diff;\n        \n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<50.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }\n        col*=shadow;\n    }\n    vec3 bg = mix(vec3(0.173,0.231,0.686),vec3(0.361,0.753,1.000),rd.y*0.5+0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n","name":"Image","description":"","type":"image"}]}