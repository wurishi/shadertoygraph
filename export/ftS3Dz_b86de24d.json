{"ver":"0.1","info":{"id":"ftS3Dz","date":"1623745408","viewed":75,"name":"Fork Class5: Re qt1 881","username":"qt1","description":"Reflections + some minor animation","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["reflections"],"hasliked":0,"parentid":"NllGDs","parentname":"Class5: Reflections"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 10000000.0\n\nfloat seed = 0.0;\n\nmat3 zRotation(float angle) {\n    return mat3(cos(angle),  sin(angle), 0,\n                -sin(angle), cos(angle), 0,\n                0,           0,          1);\n}\n\nmat3 rotAxis(vec3 axis, float angle) {\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 tranformAroundCenter(mat3 transform, vec3 center, vec3 point) {\n    return center + transform * (point - center);\n}\n\nvec3 rotAxisCenter(vec3 axis, float angle, vec3 center, vec3 point) {\n    return tranformAroundCenter(rotAxis(axis,angle),center, point);\n}\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    //return vec3(0.05, 0.05, 0.2);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\nconst int NUM_SPHERE = 4;\nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\n// create 4 spheres at different locations in different colors\nvoid makeScene(int iFrame) {\n    spheres[0] = Sphere(1.0, vec3(0.2, 0, -7), vec3(1, 1, 0));\n    spheres[1] = Sphere(0.3, vec3(-0.4, -0.5, -2.5), vec3(1, 0, 0));\n    spheres[2] = Sphere(0.2, vec3(0, 0, -2), vec3(0, 1, 0));\n    spheres[3] = Sphere(0.8, vec3(1., 1, -5.5), vec3(0, 0, 1));\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1));\n    \n    float f = float(iFrame);\n    vec3 axis=vec3(0,0,1);\n    vec3 axis3=vec3(0,0,1);\n    float w1=0.01;\n    float w2=w1*1.1;\n    float w3=w1*1.3;\n    spheres[1].center = rotAxisCenter(axis, w1*f, spheres[0].center, spheres[1].center);\n    spheres[2].center = rotAxisCenter(axis, w2*f, spheres[0].center, spheres[2].center);\n    spheres[3].center = rotAxisCenter(axis3, w3*f, spheres[2].center, spheres[3].center);\n}\n\n// samples per pixel\nconst int numSamples=4;\n\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n  \n   makeScene(iFrame);\n   \n   //vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<1*numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       // ray Origin for is at (0, 0, 0)\n       vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       vec3 col = vec3(1.0, 1.0, 1.0);\n       for (int k=0; k<100; k++) { // 100 bounces\n       \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       Intersection intersection = intersectAllObjects(ray);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       Sphere sphere;\n       \n       if (iSphere > -1) { \n           // to get around iSphere not being constant\n           for (int i=0; i<NUM_SPHERE; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           \n           // hit coordinates\n           vec3 hit = ray.origin + minT*ray.direction;\n           // normal at the point of ray-sphere intersection\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 xnorm = hitPointNormal;\n           vec3 reflDir = ray.direction - 2.0*xnorm*dot(ray.direction, xnorm);\n           ray.origin = hit;\n           ray.direction = reflDir;\n           /****\n           // vector from eye to the intersection point\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           // cosine of the angle between ray and nornal\n           float angle = dot(hitPointNormal, hitPointToEye);\n           // use the cosine of the angle to modulate color for \n           // a simple diffuse shading effect\n           samp = samp + angle*sphere.color;\n           ***/\n           //samp = sphere.color;\n           col = col*(0.4*sphere.color+0.9*vec3(1,1,1)); \n       } \n       else {\n           samp = samp + col*bgColor(ray.direction);\n           break;\n       }\n   }\n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}