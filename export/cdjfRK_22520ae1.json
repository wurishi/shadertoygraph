{"ver":"0.1","info":{"id":"cdjfRK","date":"1690126568","viewed":43,"name":"Cube floor","username":"GBA","description":"An oscillating cube floor","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["0"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 500;\nconst float MAX_DIST = 1000.;\nconst float MIN_DIST = 0.01;\nconst float PI = 3.14159;\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat map(vec3 p) {\n    vec3 c = vec3(15.0, 0.0, 15.0);\n    float minDist = 1E10;\n    for(int x = -2; x <= 2; x++)\n    for(int z = -2; z <= 2; z++) {\n        vec3 i = vec3(x, 0.0, z);\n        vec3 q = mod(p + 0.5  * c, c) - 0.5 * c;\n        vec3 p2 = p + (i * c);\n        p2.xz = floor((p2.xz - 0.5 * c.xz) / c.xz);\n        q.y -= 5. * sin(iTime + (p2.x + p2.z)) ;\n        vec3 b = c.xxx * 0.45;\n        float d = sdRoundBox(q - i * c, b, 0.5);\n        minDist = min(d, minDist);\n    }\n    return minDist;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 d = vec2(0.001, 0.0);\n    vec3 n;\n    n.x = map(p + d.xyy) - map(p - d.xyy);\n    n.y = map(p + d.yxy) - map(p - d.yxy);\n    n.z = map(p + d.yyx) - map(p - d.yyx);\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.y /= iResolution.x/iResolution.y;\n    vec3 rd = normalize(vec3(ndc, 1.5));\n    vec3 ro = vec3(10. * sin(iTime * PI), 25.0, iTime);\n    \n    vec3 col;\n    \n    vec3 p;\n    float t;\n    bool hit = false;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = ro + t * rd;\n        float d = map(p);\n        \n        if(d < MIN_DIST) {\n            hit = true;\n            break;\n        }\n        if(t > MAX_DIST) break;\n        \n        t += d;\n    }\n    if(hit) { \n        col = vec3(1.0, 0.0, 0.0);\n        vec3 n = calcNormal(p);\n        vec3 vd = normalize(ro - p);\n        col = col * (0.4 * max(dot(vd, n), 0.0) + 0.6 * max(dot(vec3(0.0, 1.0, 0.0), n), 0.0));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}