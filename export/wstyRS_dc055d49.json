{"ver":"0.1","info":{"id":"wstyRS","date":"1601204271","viewed":825,"name":"\"Clouds\" + vortex","username":"athibaul","description":"Fork of \"Clouds\" by iq.\n[url]https://www.shadertoy.com/view/XslGRr[/url]\nRaymarching some fbm.\nAdded a vortex distortion.","likes":44,"published":1,"flags":1,"usePreview":1,"tags":["procedural","3d","raymarching","volumetric","vortex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Clouds\" by iq\n// https://www.shadertoy.com/view/XslGRr\n\n// Created by inigo quilez - iq/2013\n// Modified by Alexis THIBAULT - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I simply modified the map() function, so that it evaluates at rotating points.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nvec4 qmul( vec4 a, vec4 b )\n{\n    // Quaternion multiplication\n    return vec4(a.x*b.x - dot(a.yzw,b.yzw),\n                a.x*b.yzw + b.x*a.yzw + cross(a.yzw,b.yzw));\n}\n\nvec3 rot( vec3 p, vec3 axis, float angle )\n{\n    // Rotate a vector around a given (normalized) axis\n    // Way too many operations probably, but this should work\n    vec2 cs = cos(angle + vec2(0,3.1415926*0.5));\n    vec4 q = vec4(cs.x, cs.y*axis);\n    vec4 qi = vec4(q.x, -q.yzw);\n    vec4 pp = vec4(0,p);\n    return qmul(qmul(q, pp), qi).yzw;\n}\n\n\nfloat mapt( in vec3 p, float time )\n{\n\t//vec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    \n    // Add a vortex!\n    vec3 q0 = p;\n    vec3 vcenter = vec3(0); // Vortex center\n    vec3 axis = vec3(0,1,0); // Vortex axis (should be normalized)\n    float r0 = 2.0; // Radius at which velocity is maximal\n    float h = dot(q0-vcenter, axis);\n    float r2 = dot(q0-vcenter,q0-vcenter) - h*h; // Distance of p from the axis\n    float theta = time/(r0*r0 + r2); // Rotation angle\n    q0 = vcenter + rot(q0-vcenter, axis, theta);\n    vec3 q = q0;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - q0.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map( in vec3 p )\n{\n    float scale = 10.;\n    float t = iTime/scale;\n    // Repeat animation to avoid over-winding the vortes\n    float m1 = mapt(p, scale*fract(t)+4.);\n    float m2 = mapt(p, scale*fract(t+0.5)+4.);\n    // Smoothly mix between two evaluations to avoid jumps\n    float proportion = 2.*abs(fract(t)-0.5);\n    float m = mix(sqrt(m1),sqrt(m2),proportion);\n    return m*m;\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n    for(int i=0; i<256; i++)\n    {\n       vec3 pos = ro + t*rd;\n       if( /*pos.y<-3.0 || pos.y>2.0 ||*/ sum.a>0.99 ) break;\n       float den = map( pos );\n       if( den>0.01 )\n       {\n         float dif = clamp((den - map(pos+0.3*sundir))/0.6, 0.0, 1.0 );\n         vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\n         vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n         col.xyz *= lin;\n         col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.005*t*t) );\n         col.w *= 0.4;\n         \n         col.rgb *= col.a;\n         sum += col*(1.0-sum.a);\n       }\\\n       t += max(0.05,0.01*t);\\\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    //vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n    vec3 ro = vec3(0,1.,-2);\n\tvec3 ta = vec3(0,-.5,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}","name":"Image","description":"","type":"image"}]}