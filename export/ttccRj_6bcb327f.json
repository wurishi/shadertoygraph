{"ver":"0.1","info":{"id":"ttccRj","date":"1609492769","viewed":1733,"name":"Anisotropic highlighting","username":"leixinyue","description":"Anisotropic Highlighting, used for shading hair, silk, disk, and so on.\nYou can drag the slider bar to move the \"Angel ring\".\nTo see the original Blinn-Phong highlight, you can change \"#if 0\" to \"#if 1\" in mainImage().","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["anisotropic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SphereDist(vec3 ro, vec3 rd, vec3 center, float r) {\n    vec3 oc = center - ro;\n    float lenOC = length(oc);\n    if (lenOC < r) {\n        return -1.; // ro is inside the sphere.\n    }\n    float lenProjedOC = dot(oc, rd);\n    if (lenProjedOC < 0.) {\n        return -1.;\n    }\n    vec3 projedOC = rd * lenProjedOC;\n    vec3 perpendicular = oc - projedOC;\n    float lenPerpendicular = length(perpendicular);\n    if (lenPerpendicular > r) {\n        return -1.;\n    }\n    float dist = lenProjedOC - sqrt(r*r - lenPerpendicular * lenPerpendicular);\n    return dist;\n}\n\nvec3 SphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\nvec3 SphereTangent(vec3 pos, vec3 normal) {\n    vec3 posOffseted = pos;\n    posOffseted.y += 1.;\n    float D = - dot(normal, pos);\n    float distToPlane = dot(normal, posOffseted) + D;\n    vec3 proj = posOffseted - normal * distToPlane;\n    vec3 tangent = normalize(proj - pos);\n    return tangent;\n}\n\nvec3 ViewDir(vec2 fragCoord, float fov) {\n    vec2 xy = fragCoord - iResolution.xy * .5;\n    float z = iResolution.y * .5 / tan(radians(fov * .5));\n    return normalize(vec3(xy, -z));\n}\n\nmat3 ViewToWorldMat(vec3 ro, vec3 target, vec3 up) {\n    vec3 front = normalize(target - ro);\n    vec3 right = normalize(cross(front, up));\n    up = cross(right, front);\n    return mat3(right, up, -front);\n}\n\nvec3 ShiftTangent(vec3 tangent, vec3 normal, float shift) {\n    vec3 shiftedTangent = tangent + normal * shift;\n    return normalize(shiftedTangent);\n}\n\nconst int SHIFT_KEY = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 1.5, 4.1);\n    // turing camera aroung when shift is pressing.\n    {\n        \n        if (texelFetch( iChannel1, ivec2(SHIFT_KEY,0), 0 ).x > 0.) {\n            ro = vec3(4.1*cos(iTime), 1.5, 4.1*sin(iTime));\n        }        \n    }\n    vec3 rd = ViewDir(fragCoord, 45.);\n    mat3 invViewMat = ViewToWorldMat(ro, vec3(0.,0.,0.), vec3(0.,1.,0.));\n    rd = invViewMat * rd;\n    \n    vec4 sphere = vec4(vec3(0., 0., 0.), 1.);\n    \n    float dist = SphereDist(ro, rd, sphere.xyz, sphere.w);\n    \n    if (dist > 0.) {\n        vec3 lightColor = vec3(1.,1.,1.);\n        vec3 albedo = vec3(1.,.2,.2);\n        vec3 specColor = vec3(1.,1.,1.);\n        vec3 lightDir = normalize(vec3(0.,.5,1.));\n        vec3 pos = ro + rd * dist;\n        vec3 normal = SphereNormal(pos, sphere.xyz);\n        float nl = dot(normal, lightDir);\n        vec3 viewDir = -rd;\n        vec3 halfDir = normalize(viewDir + lightDir);\n        \n#if 0\n        // Blinn-Phong specular highlight\n        float nh = dot(normal, halfDir);\n        float spec = pow(nh, 400.);        \n        col += nl * lightColor * albedo + nl * specColor * spec;\n#else\n        // anisotropic highlighting\n        // http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf\n        \n        vec3 tangent = SphereTangent(pos, normal);\n        float shift = texelFetch(iChannel0, ivec2(0), 0).r;\n        \n        shift = shift * 2. - 1.;\n        tangent = ShiftTangent(tangent, normal, shift);\n        \n        float dotTH = dot(tangent, halfDir);\n        float sinTH = sqrt(1. - dotTH * dotTH);\n        float dirAtten = smoothstep(-1., 0., dotTH);\n        \n        // Kajiya-Kay Model\n        col += nl * lightColor * albedo + step(0., nl) * dirAtten * specColor * pow(sinTH, 400.);\n#endif\n    }\n   \n    // GUI\n    vec2 uv = (fragCoord - .5) / iResolution.xy;\n    vec4 gui = texture(iChannel0, uv);\n    col = mix(col, gui.rgb, gui.a);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////// GUI //////\n\nconst float EPSILON = 0.00001;\nconst float SLIDER_BAR_HEIGHT = 0.02;\n\nstruct Rect {\n    vec2 start;\n    vec2 size;\n};\n\nstruct Slider {\n    Rect bar;\n    vec2 slider;\n};\n\nSlider CreateSlider(vec4 bar, vec2 blockSize) {\n    return Slider(\n        Rect(bar.xy, bar.zw), blockSize\n    );\n}\n\nbool IsInsideRect(vec2 coord, Rect rect) {\n    vec2 start = rect.start;\n    vec2 end = start + rect.size;\n    vec2 isInsideRect = smoothstep(start - EPSILON, start + EPSILON, coord) \n        - smoothstep(end - EPSILON, end + EPSILON, coord);\n    return isInsideRect.x * isInsideRect.y > 0.;\n}\n\nvec4 DrawSlider(vec2 coord, Slider slider, int index) {\n    // draw bar\n    bool isInsideBar = IsInsideRect(coord, slider.bar);\n    \n    //float last = textureLod(iChannel0, vec2(.5) / iChannelResolution[0].xy, 0.0).r;\n    float last = texelFetch(iChannel0, ivec2(index), 0).r;\n    vec2 mouseCoord = iMouse.xy / iResolution.xy;\n    bool isMouseInsideBar = IsInsideRect(mouseCoord, slider.bar);\n    float curX = last * slider.bar.size.x + slider.bar.start.x;\n    if (isMouseInsideBar) {\n        curX = mouseCoord.x;\n        last = (mouseCoord.x - slider.bar.start.x) / slider.bar.size.x;\n    }\n    \n    Rect realSlider = Rect(vec2(curX, slider.bar.start.y + .5 *(slider.bar.size.y - slider.slider.y)), slider.slider);\n    bool isInsideBlock = IsInsideRect(coord, realSlider);\n    \n    if (isInsideBlock) {\n        return vec4(1.,1.,1.,1.);\n    } else  if (isInsideBar) {\n        return vec4(.5,.5,.5,1.);\n    }\n    \n    return vec4(iFrame == 0 ? .5 : last, .0, 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    Slider slider1 = CreateSlider(vec4(0.01, 0.5, 0.15, 0.02), vec2(0.01, 0.03));\n    \n    fragColor = DrawSlider(uv, slider1, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}