{"ver":"0.1","info":{"id":"wsBBDz","date":"1589827946","viewed":203,"name":"Wooma trophy","username":"sukupaper","description":"Based on Wooma, a character from this animated short film : https://www.youtube.com/watch?v=5onyUu9v2ss ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cartoon","character","wooma","trophy","ssb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P 3.14159265359\nfloat t;\nfloat aa;\nvec2 mouse = vec2(0.);\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c);}\nfloat rand(vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\n\nfloat smoothunion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sph(vec3 p, float s) { return length(p) - s; }\nfloat cyl( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return max(length(max(abs(p.y) - h,0.)) - .01, length(p.xz) - r) - .01;\n}\n\nfloat ear(vec3 p) {\n    p.x *= 1.8;\n    p.z *= 1.2;\n    float s1 = sph(p + vec3(0.,0.,0.),.2);\n    float s2 = sph(p + vec3(0.,0.3,0.),.1);\n    float s3 = sph(p + vec3(0.,.6,0.),.3);\n    float d = smoothunion(smoothunion(s1,s2,0.45),s3,0.4);\n    return d*.5;\n}\nfloat headShape(vec3 p) {\n    vec3 pp;\n    float s1 = sph(p*vec3(.95,1.3,1.25),.45)/1.5;\n    \n    pp = p;\n    pp.z += pp.y*.2;\n    float s2 = sph(pp*vec3(2.1,1.8,2.5) - vec3(0.,.6,0.),.45)/2.5;\n    \n    pp.x = abs(pp.x);\n    pp.xy *= rot(-.21);\n    float s3 = sph(pp*vec3(2.6,2.5,2.9) - vec3(0.8,.7,0.),.45)/2.5;\n    float s4 = min(s2,s3);\n    \n    pp = p;\n    pp.x = abs(pp.x);\n    pp.x -= .33;\n    pp.xy *= rot(-pp.y*.2);\n    pp.xz *= rot(.21);\n    float e1 = ear(pp);\n    \n    return smoothunion(smoothunion(e1,s1,.05),s4,.15);\n}\nfloat body(vec3 p) {\n    float bd = cyl(p + vec3(0.,.7,0.),.55,.1 + pow(abs(-p.y)*.2,.89) + .02*(sin(p.y*12.)*.5+.5));\n    return max(bd, -(p.y + 1.1 + (sin(p.z*15.)+sin(p.x*15.))*.01))*.99;\n}\nfloat smash2d(vec2 p) {\n    vec2 pp = p + vec2(.2,.1);\n    return max((length(p) - .45),-(min(abs(pp.x),abs(pp.y) + .055) - .1));\n}\nfloat smash(vec3 p) {\n    return cyl(p + vec3(0.,1.21,0.),.02 + smoothstep(0.,0.001,smash2d(p.xz*.8))*.03,.7);\n}\n\nfloat anim1(float x, float sm) {\n  return smoothstep(-sm,sm,fract(x) - .5) + floor(x);\n}\n\nint matid = 0;\nvec3 eyMap;\nfloat df(vec3 p) {\n    p.yz *= rot(-.05);\n    p.y += .75;\n    p.yz *= rot((mouse.y - .5)*.3);\n    p.xz *= rot((mouse.x - .5)*.5);\n    p.y -= .75;\n    float t1 = cos(t*2.)*.5+.5;\n    \n    float smash = smash(p);\n    \n    vec3 pp;\n    \n    float hs = headShape(p);\n    float bd = body(p);\n    \n    pp = p;\n    pp.x = abs(pp.x);\n    eyMap = pp*vec3(1.,1.2,2.) + vec3(-0.13,-0.05,.72);\n    float ey = sph(eyMap,.14)/1.2;\n    \n    pp = p;\n    pp.y -= pow(abs(pp.x),2.8);\n    float mo = sph(pp*vec3(1.2 + t1*.05,4.8,1.) + vec3(0.,0.5,0.5),.5)/4.8;\n    \n    pp = p;\n    pp.x = abs(pp.x) - .25;\n    float th = sph(pp*vec3(1,.6,1.) + vec3(0.,0.08,.2),.035);\n    \n    float d;\n    d = min(bd,hs);\n    d = max(d,-mo);\n    d = min(d,ey);\n    d = min(d,th);\n    d = min(d,smash);\n    \n    if(d >= ey) matid = 3;\n    else if(d >= th) matid = 5;\n    else if(d >= mo) matid = 4;\n    else if(d >= bd) matid = 1;\n    else if(d >= hs) matid = 2;\n    else if(d >= smash) matid = 6;\n    \n    return d;\n}\n\n#define E .0001\nvec3 normal(vec3 p) {\n    vec2 u = vec2(0.,E); float d = df(p);\n    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);\n}\n\nvec3 reflection(vec3 v){\n    vec3 n = normal(v);\n    return normalize(v - 2.*dot(v,n)*n);\n}\n\n#define MAX_D 5.\n#define MIN_D 3.\n#define MAX_STEP 70\n#define EDP aa*15.\n#define LIM .001\nvec3 rm(vec3 cam, vec3 rayDir) {\n    vec3 c = vec3(0.301, 0.388, 0.635)*1.9 - rayDir.y;\n    vec3 pInit = cam + rayDir*MIN_D;\n    vec3 p = pInit;\n    float prevD = 10e9;\n    float nbReflections = 0.;\n    for(int i = 0; i < MAX_STEP; i++) {\n        float d = df(p);\n        if(prevD < EDP && d > prevD) return vec3(0.136,0.069,0.465);\n        if(d < LIM) {\n            vec3 n = normal(p);\n            vec3 light = normalize(vec3(0.244,0.909,-1.080));\n\n            float cl = clamp(dot(n,light),0.3,1.);\n            float cv = clamp(dot(n,rayDir) + 1.,0.,1.);\n\n            vec3 col = vec3(1.,0.,0.);\n            if(matid == 1) {\n                col = vec3(0.301, 0.388, 0.635) + cv*.2;\n            } else if(matid == 2) {\n                col = vec3(0.854, 0.549, 0.266) + cv*.3;\n            } else if(matid == 3) {\n                float rs = .05;\n                float a = -1.;\n                vec2 animShift = vec2(cos(t*30.),cos(t*305.));\n                vec2 shift = vec2(cos(a)*rs,sin(a)*rs) + animShift*.002;\n                return mix(vec3(0.136,0.069,0.465),vec3(1.), step(0.,(length(eyMap.xy + shift) - .04 - animShift.y*.001)));\n            } else if(matid == 4) {\n                return vec3(0.603, 0.227, 0.223)*1.5 - cv*.1;\n            } else if(matid == 5) {\n                col = vec3(1.);\n            } else if(matid == 6) {\n                col = vec3(1.000,0.762,0.130);\n            }\n            \n            return col + smoothstep(0.4,0.5,cl)*.2 * (1.+float(i)*.105);//smoothstep(0.4,0.5,cl)\n        }\n        if(distance(pInit,p) > MAX_D) return c*vec3(0.141,0.292,0.465) + float(i)/100.;\n        p += d*rayDir;\n        prevD = min(prevD,d);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    t = iTime;\n\taa = 1./iResolution.x;\n\tmouse = iMouse.xy/iResolution.xy;\n    \n    vec3 c = vec3(0.,-.25,(-5.));\n    vec3 r = normalize(vec3(uv,1.6));\n    vec3 col = rm(c,r);\n    \n    fragColor = vec4(col*1.1 - pow(length(uv)*.5, 2.),1.0);\n}","name":"Image","description":"","type":"image"}]}