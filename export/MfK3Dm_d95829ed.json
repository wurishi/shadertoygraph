{"ver":"0.1","info":{"id":"MfK3Dm","date":"1712868992","viewed":37,"name":"SHADER 2 LIZZZZAAAAA___","username":"lizzz_rap","description":"A","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int n = 8;  //n - количество многогранников\nconst int m = 24;  //m - количество вершин\n\n//ЦВЕТА\nvec3 colours_ar[n+1]=vec3[n+1](vec3(0.1, 0.3, 1.0), vec3(0.65, 0.87, 0.95), vec3(0.5, 0.6, 0.9), vec3(0.15, 0.25, 0.61), vec3(0.81, 0.93, 0.96), vec3(0.51, 0.76, 0.8), vec3(0.34, 0.66, 0.72), vec3(0.11, 0.37, 0.37), vec3(1.0, 0.0, 1.0));\n//последний цвет для сферы\n//цвет будет еще зависеть от координаты\nvec3 background = vec3(0.88, 0.86, 0.98);\nvec3 colour;\n\n\nint ind_ar[n+1] = int[](0, 3, 6, 9, 12, 15, 18, 21, 24);\nint size_ar[n] = int[n](3, 3, 3, 3, 3, 3, 3, 3);\nvec3 vert_ar[m];  //массив вершин, заполним в scene_init\nint i;\n\n//сфера\nvec3 centre = vec3(0.15, 0.8, 0.1);\n\n\nvoid scene_init(in float time, out vec3 vert_ar[m]){\n    vert_ar[0] = vec3(0.3+0.05*sin(time*0.5), 0.5+0.15*sin(time), 0.8);\n    vert_ar[1] = vec3(0.4+0.05*sin(time*0.5), 0.2+0.15*sin(time), 0.3);\n    vert_ar[2] = vec3(0.5+0.05*sin(time*0.5), 0.5+0.15*sin(time), 0.3);\n    //треугольник2 - светлоголубой\n    vert_ar[3] = vec3(0.4-0.1*sin(time), 0.3-0.1*sin(time), 0.3);\n    vert_ar[4] = vec3(0.9-0.1*sin(time), 0.3-0.1*sin(time), 0.3);\n    vert_ar[5] = vec3(0.8-0.1*sin(time), 0.4-0.1*sin(time), 0.3);\n    //треугольник3 - голубой\n    vert_ar[6] = vec3(0.5, 0.3-0.2*sin(time), 0.3);\n    vert_ar[7] = vec3(0.7, 0.7-0.2*sin(time), 0.1);\n    vert_ar[8] = vec3(0.4, 0.5-0.2*sin(time), 0.8);\n    //треугольник4 - темно-синий\n    vert_ar[9] = vec3(0.7-0.3*sin(time+30.0), 0.65, 0.7);\n    vert_ar[10] = vec3(0.6-0.3*sin(time+30.0), 0.8, 0.5);\n    vert_ar[11] = vec3(0.6-0.3*sin(time+30.0), 0.5, 0.2);\n    //ПИРАМИДУС\n    //левая\n    vert_ar[12] = vec3(0.2, 0.2, 1.0); //a\n    vert_ar[13] = vec3(0.4, 0.2, 1.0); //b\n    vert_ar[14] = vec3(0.3, 0.5, 0.5); //вершина пирамиды\n    //правая\n    vert_ar[15] = vec3(0.4, 0.2, 1.0); //b\n    vert_ar[16] = vec3(0.45, 0.3, 0.1); //c\n    vert_ar[17] = vec3(0.3, 0.5, 0.5); //вершина\n    //низ\n    vert_ar[18] = vec3(0.2, 0.2, 1.0); //a\n    vert_ar[19] = vec3(0.4, 0.2, 1.0); //b\n    vert_ar[20] = vec3(0.45, 0.3, 0.1); //c\n    //задняя\n    vert_ar[21] = vec3(0.2, 0.2, 1.0); //a\n    vert_ar[22] = vec3(0.45, 0.3, 0.1); //c\n    vert_ar[23] = vec3(0.3, 0.5, 0.5); //вершина\n    \n}\n\n\nfloat getZ(int i, vec2 uv){\n        vec3 a = vert_ar [ind_ar[i]];\n        vec3 b = vert_ar [ind_ar[i]+1];\n        vec3 c = vert_ar [ind_ar[i]+2];\n        float x1 = a.x;\n        float x2 = b.x;\n        float x3 = c.x;\n        float y1 = a.y;\n        float y2 = b.y;\n        float y3 = c.y;\n        float z1 = a.z;\n        float z2 = b.z;\n        float z3 = c.z;\n        vec3 normal = cross(b-a, c-a);\n        float d = -normal.x*a.x - normal.y*a.y - normal.z*a.z;\n        float z = (-normal.x*uv.x-normal.y*uv.y-d)/normal.z;\n        return z;\n        \n    }\n\nbool leftTurn(vec2 a, vec2 b){\n        float det = a.x * b.y - b.x * a.y;\n        if (det>=0.0) return true;\n        else return false;\n    }\n    \n    \nbool inPolyhedron(int num, vec2 vector){      \n    int size = size_ar[num], start = ind_ar[num], i;\n    vec2 a;\n    vec2 b;\n    for(i = start; i < size + start - 1; i++)    {\n        a = vec2(vert_ar[i + 1].x - vert_ar[i].x, vert_ar[i + 1].y - vert_ar[i].y);     \n        b = vec2(vector.x - vert_ar[i].x, vector.y - vert_ar[i].y); \n        if ( a.x * b.y - b.x * a.y  < 0.0)\n        return false; \n        } \n    a = vec2(vert_ar[start].x - vert_ar[i].x, vert_ar[start].y - vert_ar[i].y);\n    b = vec2(vector.x - vert_ar[i].x, vector.y - vert_ar[i].y);\n    if (a.x * b.y - b.x * a.y  < 0.0)\n        return false;\n    return true;   \n    }\n    \nbool inSphere(in vec2 uv){\n    float radius = 0.1 + 0.05*sin(iTime);\n    if ((uv.x*iResolution.x/iResolution.y-centre.x)*(uv.x-centre.x) + (uv.y-centre.y)*(uv.y-centre.y) <= radius*radius)\n        return true;\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    scene_init(iTime, vert_ar);\n    vec3 backgroundColor = 0.5*cos(iTime+uv.xyx+vec3(3,0,4));\n    colour = background;\n\n    \n    float z; \n    float zMaximum = -300.0;  \n    //цикл для МНОГОГРАННИКОВ \n     \n    for(i=0; i<n; i++){ \n        if(inPolyhedron(i, uv) == true){\n            z = getZ(i, uv); \n            if(z>zMaximum){ \n                zMaximum = z; \n                colour = vec3(colours_ar[i].x, colours_ar[i].y+2.0*(uv.x)-0.8, colours_ar[i].z); \n            } }\n    } \n    //для СФЕРЫ проверка \n    if(inSphere(uv)) \n        colour = vec3(colours_ar[n].x-0.5*(uv.y), colours_ar[n].y+2.5*(uv.x), colours_ar[n].z); \n    fragColor = vec4(colour, 1.0); \n}","name":"Image","description":"","type":"image"}]}