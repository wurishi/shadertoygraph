{"ver":"0.1","info":{"id":"mddfDj","date":"1697667433","viewed":53,"name":"Stars__","username":"3t13nn3","description":"stars","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4stGRS","filepath":"https://soundcloud.com/deadmau5/strobe-1","previewfilepath":"https://soundcloud.com/deadmau5/strobe-1","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float randomInRange(float min, float max, float seed) {\n    return mix(min, max, fract(sin(seed) * 43758.5453123));\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.7, 0.2, 0.2);\n    vec3 b = vec3(0.557, 0.3, 0.5);\n    vec3 c = vec3(1.0, 0.2, 0.416);\n    vec3 d = vec3(0.263,0.216,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    // Time varying pixel color\n    vec4 col = vec4(0.0);\n    float d = 0.f;\n    \n    for (float i = 0.0; i < float(1.0 + mod(floor(iTime/8.0),10.0)); i++) {\n        \n        float angle = (int(mod(i, 2.0)) == 0) ? iTime / 10. * (i+1.0) : -iTime / 10. * (i+1.0);\n\n        // Appliquer la rotation\n        float s = sin(angle);\n        float c = cos(angle);\n        mat2 rotation = mat2(c, -s, s, c);\n        uv = rotation * uv;\n        d = smoothstep(1.5, d, sdStar(uv, 0.5 / (i + 1.0), int(randomInRange(2.f, 10.f, i+10.0)), 3.0));\n\n        d = sin(d*8. + iTime * (1.165 / (i + 1.0)) )/ (10.f - i);\n        //d = smoothstep(0.1, sin(iTime*.4) / (i+1.0), d);\n        \n        col += (d>0.001 * (pow(i, 1.5)+1.0)) ?\n            mix(col, vec4(palette(length(uv0) + i*.12 * iTime*.4), 0.8), 1.0-smoothstep(0.0,0.5,abs(d))) :\n            mix(col, -vec4(palette(length(uv) + i*.234 / iTime*.6), 0.4), 1.7-smoothstep(0.0,0.5,abs(d)));\n        //col += (d>0.0) ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n        uv = fract(uv * 1.5) - 0.5;\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}