{"ver":"0.1","info":{"id":"Xc3BRr","date":"1732760456","viewed":45,"name":"3D Glow Practice","username":"jasmine0204","description":"Reference: 3D glow shader tutorial from https://www.shadertoy.com/view/7stGWj","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 1e-6;\n\n//Calculate glow, 这里实际结果是intensity越小越亮\nfloat getGlow(float radius, float dist, float intensity)\n{\n    return pow(radius / max(dist, EPSILON), intensity);\n}\n\n//camera\nvec3 rayDirection(vec2 fragCoord, float fov){\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (iResolution.y * 0.5) / tan(radians(fov / 2.0));\n    return normalize(vec3(xy, z));\n}\n\nmat3 lookAt(vec3 targetDir, vec3 up){\n    vec3 z = normalize(targetDir);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    return mat3(x,y,z);\n}\n\n//scene\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\n\n//https://iquilezles.org/articles/distfunctions\n//下面列出了几种模型的SDF，替换getSDF里的return值即可\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n\nfloat getSDF(vec3 position) {\n   \tfloat angle = iTime;\n    vec3 axis = normalize(vec3(1.0, 1.0, 1.0));\n    position = rotate(position, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n    return sdBoxFrame(position, vec3(0.6), 0.04);\n}\n\n//raymarching 这里用SDF距离场算出每一条光线端点离物体表面的最短距离，步进最短距离，碰撞则返回，并且累积glow，不碰撞则累积glow后继续步进直到超过max_dist返回\nfloat distanceToScene(float start, float end, vec3 cameraPos, vec3 rayDir, inout float glow){\n    \n    float depth = start;\n    float dist;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n    \n        //得到这条光线在碰撞表面前可以前进的最大安全距离（即和物体表面的最短距离）\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        //得出当前端点所在位置受到的光照\n        glow += getGlow(1e-3, dist, 0.8);\n        \n        //如果当前端点和物体表面dist已经小于阈值，说明光线在步进后将要物体碰撞/光线起始位置就在物体内部，返回\n        if(dist < EPSILON){\n            return dist;\n        }\n        \n        //步进\n        depth += max(EPSILON, .5 * dist);\n        \n        //深度超过最大值则返回\n        if (depth > end){\n            return end;\n        }\n    }\n    \n    return end;\n}\n\n//tone-mapping 要加clamp限制颜色值在0.0到1.0之间，注意计算都要用float\nvec3 ACES(vec3 x){\n    float a = 2.5;\n    float b = 0.03;\n    float c = 2.4;\n    float d = 0.6;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //常规流程，光线方向，摄像机方向，辉光值，光线步进，后处理，完事\n    vec3 rayDir = rayDirection(fragCoord, 60.0);\n    \n    vec3 cameraPos = vec3(1.0, 2.0, 1.0);\n    vec3 target = -normalize(cameraPos);\n    \n    mat3 viewMat = lookAt(target, vec3(0.0, 1.0, 0.0));\n    rayDir = viewMat * rayDir;\n    \n    float glow;\n    \n    float dist = distanceToScene(MIN_DIST, MAX_DIST, cameraPos, rayDir, glow);\n    \n    vec3 glowCol = vec3(0.1, 0.6, 0.9);\n    \n    vec3 col = glowCol * glow;\n    \n    col = ACES(col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}