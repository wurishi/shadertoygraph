{"ver":"0.1","info":{"id":"4tG3Dh","date":"1474394120","viewed":308,"name":"Yet Another Pong","username":"chazbg","description":"Simple Pong game using render to texture.\nLeft player is controlled by a simple AI.\nRight player is controlled using Left Mouse Button and mouse movement.\n\nIntentionally missing features:\n - Scoreboard\n - Better AI\n - Better ball movement\n","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["game","pong","rendertotexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ASPECT_RATIO (iResolution.x / iResolution.y)\n#define PLAYER_LENGTH 0.5\n#define PLAYER_WIDTH  0.1\n#define BALL_RADIUS   0.07\n\nstruct Ball\n{\n    vec2  pos;\n    vec2  dir;\n    float v;   // velocity\n};\n\nstruct Player\n{\n    float pos;\n};\n    \nBall getBallData()\n{\n    Ball b;\n    \n    vec4 posAndDir = texture(iChannel0, vec2(0.0));\n    \n    b.pos = posAndDir.xy;\n    b.dir = posAndDir.zw;\n    \n    return b;\n}\n\nPlayer getAIData()\n{\n    Player p;\n    \n    p.pos = texture(iChannel0, vec2(0.1, 0.0)).x;\n    \n    return p;\n}\n\nvoid drawBall(vec2 uv, inout vec4 fragColor)\n{\n    Ball b = getBallData();\n    float t = length(uv - b.pos);\n    if (t <= BALL_RADIUS)\n    {\n        fragColor = mix(vec4(0.2, 0.4, 0.1, 1.0), fragColor, 1.0 - t / BALL_RADIUS);\n    }\n}\n\nvoid drawAI(vec2 uv, inout vec4 fragColor)\n{\n    Player p = getAIData();\n    float l  = PLAYER_LENGTH / 2.0;\n    float w  = PLAYER_WIDTH;\n\tfloat topLimit = p.pos + l;\n    float botLimit = p.pos - l;\n    float hLimit   = -1.0 * ASPECT_RATIO + w;\n    \n    if (uv.x <= hLimit && uv.y <= topLimit && uv.y >= botLimit)\n    {\n        float halfHLimit = hLimit - w * 0.5;\n        float dx = abs(halfHLimit - uv.x) / (w * 0.5);\n        float dy = abs(p.pos - uv.y) / l;\n        float t = dx * dy;\n        \n        fragColor = mix(fragColor, vec4(0.3, 0.7, 0.3, 1.0), t);\n    }\n}\n\nvoid drawPlayer(vec2 uv, inout vec4 fragColor)\n{\n    Player p;\n    \n    p.pos = iMouse.y / iResolution.y * 2.0 - 1.0;\n    \n    float l  = PLAYER_LENGTH / 2.0;\n    float w  = PLAYER_WIDTH;\n\tfloat topLimit = p.pos + l;\n    float botLimit = p.pos - l;\n    float hLimit   = 1.0 * ASPECT_RATIO - w;\n    \n    if (uv.x >= hLimit && uv.y <= topLimit && uv.y >= botLimit)\n    {\n        float halfHLimit = hLimit + w * 0.5;\n        float dx = abs(halfHLimit - uv.x) / (w * 0.5);\n        float dy = abs(p.pos - uv.y) / l;\n        float t = dx * dy;\n        \n        fragColor = mix(fragColor, vec4(0.3, 0.7, 0.3, 1.0), t);\n    }\n}\n\nvoid drawMiddleLine(vec2 uv, inout vec4 fragColor)\n{\n    float t = abs(uv.x);\n    float r = 0.03;\n    if (t < r && mod(abs(uv.y), 0.1) > 0.04)\n    {\n        float blend = t / r;\n        fragColor = mix(fragColor, vec4(0.2, 0.4, 0.1, 1.0), blend);\n    }\n}\n\nvoid drawBackground(vec2 uv, inout vec4 fragColor)\n{\n    fragColor = texture(iChannel1, uv) * 0.1 + vec4(0.0, 0.1, 0.0, 1.0);\n}\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs)\n{\n\treturn uvs * 2.0 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeUVs(fragCoord.xy / iResolution.xy);\n\tuv.x *= ASPECT_RATIO;\n    \n    vec2 realuv = fragCoord.xy / iResolution.xy;\n    \n    drawBackground(realuv, fragColor);\n    drawMiddleLine(uv, fragColor);\n\tdrawBall(uv, fragColor);\n    drawAI(uv, fragColor);\n    drawPlayer(uv, fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ASPECT_RATIO      (iResolution.x / iResolution.y)\n#define PLAYER_LENGTH     0.3\n#define PLAYER_WIDTH      0.1\n#define BALL_RADIUS       0.07\n\nstruct Ball\n{\n    vec2  pos;\n    vec2  dir;\n    float v;   // velocity\n};\n\nstruct Player\n{\n    float pos;\n};\n\nvec2 rand(){\n    vec2 seed1 = vec2(iTime, iTime * 2.0);\n    vec2 seed2 = vec2(iTime + 1.0, (iTime + 1.0) * 2.0);\n    \n    vec2 res;\n    \n    res.x = fract(sin(dot(seed1, vec2(12.9898,78.233))) * 43758.5453);\n    res.y = fract(sin(dot(seed2, vec2(12.9898,78.233))) * 43758.5453);\n    \n    return res;\n}\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs)\n{\n\treturn uvs * 2.0 - 1.0;\n}\n\nBall getBallData()\n{\n    Ball b;\n    \n    vec4 posAndDir = texture(iChannel0, vec2(0.0));\n    \n    b.pos = posAndDir.xy;\n    b.dir = posAndDir.zw;\n    \n    if (b.dir == vec2(0.0))\n    {\n        b.dir = normalize(rand());\n    }\n    \n    return b;\n}\n\nvoid setBallData(Ball b, vec2 uv, inout vec4 fragColor)\n{\n    if (length(uv - vec2(0.0)) <= 0.01)\n    {\n        fragColor.xy = b.pos;\n        fragColor.zw = b.dir;\n    }\n}\n\nPlayer getAIData()\n{\n    Player p;\n    \n    p.pos = texture(iChannel0, vec2(0.1, 0.0)).x;\n    \n    return p;\n}\n\nvoid setAIData(Player p, vec2 uv, inout vec4 fragColor)\n{\n    if (length(uv - vec2(0.1, 0.0)) <= 0.01)\n    {\n        fragColor.x = p.pos;\n    }\n}\n\nPlayer getPlayerData()\n{\n    Player p;\n    \n    p.pos = iMouse.y / iResolution.y * 2.0 - 1.0;\n    \n    return p;\n}\n\nbool intersectsAI(Ball b, out vec2 n)\n{\n    bool res;\n    \n    Player p = getAIData();\n\tfloat r  = BALL_RADIUS;\n    float w  = PLAYER_WIDTH;\n    float l  = PLAYER_LENGTH / 2.0;\n    \n    float top   = p.pos + l;\n    float bot   = p.pos - l;\n    float right = -1.0 * ASPECT_RATIO  + w + r;\n    \n    res = b.pos.x <= right && b.pos.y <= top && b.pos.y >= bot;\n    \n    if (res)\n    {\n        n = vec2(1.0, 0.0);\n    }\n    \n    return res;\n}\n\nbool intersectsPlayer(Ball b, out vec2 n)\n{\n    bool res;\n    \n    Player p = getPlayerData();\n\tfloat r  = BALL_RADIUS;\n    float w  = PLAYER_WIDTH;\n    float l  = PLAYER_LENGTH / 2.0;\n    \n    float top   = p.pos + l;\n    float bot   = p.pos - l;\n    float left  = 1.0 * ASPECT_RATIO  - w - r;\n    \n    res = b.pos.x >= left && b.pos.y <= top && b.pos.y >= bot;\n    \n    if (res)\n    {\n        n = vec2(-1.0, 0.0);\n    }\n    \n    return res;\n}\n\nbool intersectsWall(Ball b, out vec2 n)\n{\n    bool res;\n    \n    vec2 pos  = b.pos;\n    float r   = BALL_RADIUS;\n    float top = 1.0 - r;\n    float bot = -1.0 + r;\n    \n    res = pos.y >= top || pos.y <= bot;\n    \n    if (res)\n    {\n        if (pos.y > 0.0)\n        {\n            n = vec2(0.0, -1.0);\n        }\n        else\n        {\n            n = vec2(0.0, 1.0);\n        }\n    }\n    \n    return res;\n}\n\nbool mustBounce(Ball b, out vec2 n)\n{\n\tbool res = false;\n    \n    res = res || intersectsAI(b, n);\n    res = res || intersectsPlayer(b, n);\n    res = res || intersectsWall(b, n);\n    \n    return res;\n}\n\nvec2 getWallNormal(vec2 ballPos)\n{\n    vec2 n;\n    \n    if (ballPos.y > 0.0)\n    {\n        n = vec2(0.0, -1.0);\n    }\n    else\n    {\n        n = vec2(0.0, 1.0);\n    }\n    \n    return n;\n}\n\nvoid updateBall(Ball b, vec2 uv, inout vec4 fragColor)\n{   \n    vec2 n;\n    if (mustBounce(b, n))\n    {\n        b.dir = reflect(b.dir, n);\n    }\n    \n    b.pos += b.dir * 0.04;\n    \n    setBallData(b, uv, fragColor);\n}\n\nvoid updateAI(Ball b, vec2 uv, inout vec4 fragColor)\n{\n    Player p = getAIData();\n    float l  = PLAYER_LENGTH / 2.0;\n\n    float dir = b.pos.y - p.pos;\n    \n    p.pos += dir * 0.02;\n\n    setAIData(p, uv, fragColor);\n}\n\nvoid tryReset(Ball b, vec2 uv, inout vec4 fragColor)\n{\n    float hLimit = 1.0 * ASPECT_RATIO;\n    \n    if (b.pos.x < -hLimit || b.pos.x > hLimit)\n    {\n        b.pos = vec2(0.0);\n        b.dir = normalize(rand());\n        \n        setBallData(b, uv, fragColor); \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = normalizeUVs(fragCoord.xy / iResolution.xy);\n    vec2 realuv = fragCoord.xy / iResolution.xy;\n    \n    Ball b = getBallData();\n    \n    updateBall(b, realuv, fragColor);\n    updateAI(b, realuv, fragColor);\n    \n    tryReset(b, realuv, fragColor);\n}","name":"Buf A","description":"","type":"buffer"}]}