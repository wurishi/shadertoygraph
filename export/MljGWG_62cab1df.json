{"ver":"0.1","info":{"id":"MljGWG","date":"1432135659","viewed":1612,"name":"38911 BASIC BYTES FREE","username":"104","description":"Text rendering. Recently optimized: chained if() is much faster than faking non-const array index access. I tried binary search in getGlyphAtIndex(), but it made no difference in perf and made the code terrible to read/maintain.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["2d","text","c64","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//-------------------------------------------------------------------------\n// general utilities\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\n\n// returns 0.0 or 1.0\nfloat extractBit(float fv, float bitIndex)\n{\n    fv = floor(fv / pow(2., bitIndex));// shift right bitIndex and remove unwanted bits to the right\n    fv /= 2.;// shift one more to put our value into decimal portion\n    fv = fract(fv);// our value is now isolated. fv is now exactly 0.0 or approx.0.5\n    return sign(fv);\n}\n\n// not exactly perfectly perfect, but darn close\nfloat pointRectDist(vec2 p, vec2 rectTL, vec2 rectBR)\n{\n  float dx = max(max(rectTL.x - p.x, 0.), p.x - rectBR.x);\n  float dy = max(max(rectTL.y - p.y, 0.), p.y - rectBR.y);\n  return max(dx, dy);\n}\n\n\n// warps (0,0)-(1,1) coords\nvec2 tvWarp(vec2 uv) {\n\tuv = (uv - 0.5) * 2.0;// uv is now -1 to 1\n\tuv *= 1.1;\n\tuv.x *= 1.0 + pow((abs(uv.y) / 4.0), 2.5);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 3.5), 2.5);\n\tuv = (uv / 2.0) + 0.5;// back to 0-1 coords\n\tuv = uv * 0.92 + 0.04;\n\treturn uv;\n}\n\nvec2 getuv(vec2 fragCoord, vec2 newTL, vec2 newSize, out float distanceToVisibleArea, out float vignetteAmt)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    \n    // warp\n    ret = tvWarp(ret / 2.) * 2.;// scale it by 2.\n    distanceToVisibleArea = pointRectDist(ret, vec2(0.0), vec2(1.));\n\n    // vignette\n    vec2 vignetteCenter = vec2(0.5, 0.7);\n\tvignetteAmt = 1.0 - distance(ret, vignetteCenter);\n    vignetteAmt = pow(vignetteAmt, 0.4);// strength\n    \n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n\n\n//-------------------------------------------------------------------------\n// font drawing code ...\n\nconst int g_glyphCount = 38;\nvoid getGlyphAtIndex(int gi, out vec4 scan0123, out vec4 scan4567)\n{\n    if(gi==0){scan0123=vec4(0x18,0x3C,0x66,0x7E);scan4567=vec4(0x66,0x66,0x66,0x00);return;}\n    if(gi==1){scan0123=vec4(0x7C,0x66,0x66,0x7C);scan4567=vec4(0x66,0x66,0x7C,0x00);return;}\n    if(gi==2){scan0123=vec4(0x3C,0x66,0x60,0x60);scan4567=vec4(0x60,0x66,0x3C,0x00);return;}\n    if(gi==3){scan0123=vec4(0x78,0x6C,0x66,0x66);scan4567=vec4(0x66,0x6C,0x78,0x00);return;}\n    if(gi==4){scan0123=vec4(0x7E,0x60,0x60,0x78);scan4567=vec4(0x60,0x60,0x7E,0x00);return;}\n    if(gi==5){scan0123=vec4(0x7E,0x60,0x60,0x78);scan4567=vec4(0x60,0x60,0x60,0x00);return;}\n    if(gi==6){scan0123=vec4(0x3C,0x66,0x60,0x6E);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==7){scan0123=vec4(0x66,0x66,0x66,0x7E);scan4567=vec4(0x66,0x66,0x66,0x00);return;}\n    if(gi==8){scan0123=vec4(0x3C,0x18,0x18,0x18);scan4567=vec4(0x18,0x18,0x3C,0x00);return;}\n    if(gi==9){scan0123=vec4(0x1E,0x0C,0x0C,0x0C);scan4567=vec4(0x0C,0x6C,0x38,0x00);return;}\n    if(gi==10){scan0123=vec4(0x66,0x6C,0x78,0x70);scan4567=vec4(0x78,0x6C,0x66,0x00);return;}\n    if(gi==11){scan0123=vec4(0x60,0x60,0x60,0x60);scan4567=vec4(0x60,0x60,0x7E,0x00);return;}\n    if(gi==12){scan0123=vec4(0x63,0x77,0x7F,0x6B);scan4567=vec4(0x63,0x63,0x63,0x00);return;}\n    if(gi==13){scan0123=vec4(0x66,0x76,0x7E,0x6E);scan4567=vec4(0x66,0x66,0x66,0x00);return;}\n    if(gi==14){scan0123=vec4(0x3C,0x66,0x66,0x66);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==15){scan0123=vec4(0x7C,0x66,0x66,0x66);scan4567=vec4(0x7C,0x60,0x60,0x00);return;}\n    if(gi==16){scan0123=vec4(0x3C,0x66,0x66,0x66);scan4567=vec4(0x66,0x3C,0x0E,0x00);return;}\n    if(gi==17){scan0123=vec4(0x7C,0x66,0x66,0x7C);scan4567=vec4(0x78,0x6C,0x66,0x00);return;}\n    if(gi==18){scan0123=vec4(0x3C,0x66,0x60,0x3C);scan4567=vec4(0x06,0x66,0x3C,0x00);return;}\n    if(gi==19){scan0123=vec4(0x7E,0x18,0x18,0x18);scan4567=vec4(0x18,0x18,0x18,0x00);return;}\n    if(gi==20){scan0123=vec4(0x66,0x66,0x66,0x66);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==21){scan0123=vec4(0x66,0x66,0x66,0x66);scan4567=vec4(0x66,0x3C,0x18,0x00);return;}\n    if(gi==22){scan0123=vec4(0x63,0x63,0x63,0x6B);scan4567=vec4(0x7F,0x77,0x63,0x00);return;}\n    if(gi==23){scan0123=vec4(0x66,0x66,0x3C,0x18);scan4567=vec4(0x3C,0x66,0x66,0x00);return;}\n    if(gi==24){scan0123=vec4(0x66,0x66,0x66,0x3C);scan4567=vec4(0x18,0x18,0x18,0x00);return;}\n    if(gi==25){scan0123=vec4(0x7E,0x06,0x0C,0x18);scan4567=vec4(0x30,0x60,0x7E,0x00);return;}\n    if(gi==26){scan0123=vec4(0x3C,0x66,0x6E,0x76);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==27){scan0123=vec4(0x18,0x18,0x38,0x18);scan4567=vec4(0x18,0x18,0x7E,0x00);return;}\n    if(gi==28){scan0123=vec4(0x3C,0x66,0x06,0x0C);scan4567=vec4(0x30,0x60,0x7E,0x00);return;}\n    if(gi==29){scan0123=vec4(0x3C,0x66,0x06,0x1C);scan4567=vec4(0x06,0x66,0x3C,0x00);return;}\n    if(gi==30){scan0123=vec4(0x06,0x0E,0x1E,0x66);scan4567=vec4(0x7F,0x06,0x06,0x00);return;}\n    if(gi==31){scan0123=vec4(0x7E,0x60,0x7C,0x06);scan4567=vec4(0x06,0x66,0x3C,0x00);return;}\n    if(gi==32){scan0123=vec4(0x3C,0x66,0x60,0x7C);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==33){scan0123=vec4(0x7E,0x66,0x0C,0x18);scan4567=vec4(0x18,0x18,0x18,0x00);return;}\n    if(gi==34){scan0123=vec4(0x3C,0x66,0x66,0x3C);scan4567=vec4(0x66,0x66,0x3C,0x00);return;}\n    if(gi==35){scan0123=vec4(0x3C,0x66,0x66,0x3E);scan4567=vec4(0x06,0x66,0x3C,0x00);return;}\n    if(gi==36){scan0123=vec4(0x00,0x00,0x00,0x00);scan4567=vec4(0x00,0x18,0x18,0x00);return;}\n    if(gi==37){scan0123=vec4(0x00,0x66,0x3C,0xFF);scan4567=vec4(0x3C,0x66,0x00,0x00);return;}    \n    scan0123 = vec4(0.);scan4567 = vec4(0.);\n}\n\n// stringIndex lets you use the same pos for a string of chars, just incrementing stringIndex.\n// this is pretty fast, but is binary. a prettier version might return a distance function but will suffer perf problems because of the complex geometry.\nvec4 drawCharacter(vec4 inpColor, vec4 glyphColor, vec2 uv, vec2 pos, vec2 charSize, float stringIndex, int glyphIndex)\n{\n    vec2 element = floor(((uv - pos) / (charSize / 8.)));// convert uv to pixel indices\n    element.x -= stringIndex * 8.0;\n    element.x = floor(7.0 - element.x);// flip X. maybe my encoding method is wrong?\n    // bounds check; most of the time uv will not land on the character so important to optimize this.\n    if(element.y < 0. || element.y > 7.) return inpColor;\n    if(element.x < 0. || element.x > 7.) return inpColor;\n\n    vec4 scan0123;\n    vec4 scan4567;\n    getGlyphAtIndex(glyphIndex, scan0123, scan4567);\n    \n    int scanLineI = int(element.y);\n    float scanLine;\n    \n    if(scanLineI == 0) scanLine = scan0123[0];\n    else if(scanLineI == 1) scanLine = scan0123[1];\n    else if(scanLineI == 2) scanLine = scan0123[2];\n    else if(scanLineI == 3) scanLine = scan0123[3];\n    else if(scanLineI == 4) scanLine = scan4567[0];\n    else if(scanLineI == 5) scanLine = scan4567[1];\n    else if(scanLineI == 6) scanLine = scan4567[2];\n    else if(scanLineI == 7) scanLine = scan4567[3];\n\n    float a = extractBit(scanLine, element.x);\n    return vec4(mix(inpColor.rgb, glyphColor.rgb, a * glyphColor.a), inpColor.a);\n}\n\n\n\n\n//-------------------------------------------------------------------------\nvec4 hardRect(vec4 inpColor, vec4 rectColor, vec2 uv, vec2 tl, vec2 br)\n{\n    if(uv.x < tl.x)\n        return inpColor;\n    if(uv.x > br.x)\n        return inpColor;\n    if(uv.y < tl.y)\n        return inpColor;\n    if(uv.y > br.y)\n        return inpColor;\n    return rectColor;\n}\n\n\nfloat nsin(float x)\n{\n    return (sin(x) + 1.0) / 2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distanceToVisibleArea;\n    float vignetteAmt;\n    vec2 uv = getuv(fragCoord, vec2(1.08,-0.1), vec2(2.6), distanceToVisibleArea, vignetteAmt);\n\n    vec4 darkBlue = vec4(0.21,0.16,0.47,1.0);\n    vec4 lightBlue = vec4(0.42,0.37,0.71,1.0);\n\n    // main background\n    fragColor = darkBlue;\n    \n    // border\n    vec2 charAreaTL = vec2(0.6, 0.3);\n    if(uv.x < charAreaTL.x)\n        fragColor = lightBlue;\n    if(uv.y < charAreaTL.y)\n        fragColor = lightBlue;\n\n    // ready.\n    vec4 charColor = lightBlue;\n    vec2 charSize = vec2(0.2);\n    charSize.x *= 0.936;// c64 aspect ratio\n    vec2 stringPos = charAreaTL + vec2(0, 1.0 * charSize.y);// line 1\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 4., 37);// *\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 5., 37);// *\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 6., 37);// *\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 7., 37);// *\n\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 9., 2);// C\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 10., 14);// O\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 11., 12);// M\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 12., 12);// M\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 13., 14);// O\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 14., 3);// D\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 15., 14);// O\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 16., 17);// R\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 17., 4);// E\n\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 19., 32);// 6\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 20., 30);// 4\n    \n    stringPos = charAreaTL + vec2(0, 3.0 * charSize.y);// line 3\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 1., 32);// 6\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 2., 30);// 4\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 3., 10);// K\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 5., 17);// R\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 6., 0);// A\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 7., 12);// M\n\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 9., 18);// S\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 10., 24);// Y\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 11., 18);// S\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 12., 19);// T\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 13., 4);// E\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 14., 12);// M\n    \n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 17., 29);// 3\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 18., 34);// 8\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 19., 35);// 9\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 20., 27);// 1\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 21., 27);// 1\n    \n    stringPos = charAreaTL + vec2(0, 5.0 * charSize.y);// line 5\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 0., 17);// R\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 1., 4);// E\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 2., 0);// A\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 3., 3);// D\n    fragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 4., 24);// Y\n\tfragColor = drawCharacter(fragColor, charColor, uv, stringPos, charSize, 5., 36);// .\n    \n    if(mod(iTime, 1.) < 0.5)\n    {\n        vec2 tl = vec2(stringPos.x, stringPos.y + charSize.y);\n        fragColor = hardRect(fragColor, charColor, uv, tl, tl + charSize);\n    }\n\n    \n\t// black out warped area\n\tfragColor = vec4(mix(vec3(0.), fragColor.rgb, dtoa(distanceToVisibleArea, 200.)), 1.0);\n\t\t\n\tfragColor.rgb *= vignetteAmt;\n\n\t//Draws the horizontal scan lines across the screen\n\tfloat scanLineFX = nsin(uv.y * 500.);\n    scanLineFX = clamp(pow(scanLineFX, 4.0), 0.3, 1.0);\n\tfragColor.rgb *= 1.0 + scanLineFX;\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n\n    //fragColor = gridOverlay(fragColor, uv);\n}\n\n","name":"","description":"","type":"image"}]}