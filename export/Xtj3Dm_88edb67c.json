{"ver":"0.1","info":{"id":"Xtj3Dm","date":"1429879632","viewed":6067,"name":"Artistic shading","username":"nimitz","description":"Wipe left/right for Standard PBR vs Artistic shading, wipe up/down for ripeness.","likes":83,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarched","shading","bumpmapping","aa","pbr","tasty","artistic","tomato"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Artistic shading by nimitz (twitter: @stomroid)\n// https://www.shadertoy.com/view/Xtj3Dm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tIdea from \"Kawacy\" (@kawanocy) http://kawacy.deviantart.com/art/Normal-vs-my-shading-526828438\n\t\n\tUsing n.l to change the Hue, Saturation and value of the material color/properties of the scenes\n\tthis is not physically correct, but produces some interesting coloring.\n\n\tAlso using a few other tricks to make the render nicer, AA form eiffie, shadows and AO inspired\n\tby iq, PBR math from epic games, hemispherical lights for bounce light apprixomation, bump mapping, \n\tdomain folding, and sRGB gamma.\n*/\n\n#define ITR 120\n#define FAR 30.\n#define time iTime\n\nconst float fov = 1.5;\n\nfloat dfog = 0.;\nfloat matid = 0.;\nvec2 mous = vec2(0.);\nfloat pxx =0.;\n\n//----------------------------Utility----------------------------\n\n//iq's ubiquitous 3d noise\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat sbox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 foldPent(in vec2 p)\n{\n    p.x = abs(p.x);\n    const vec2 pl1 = vec2(0.809, 0.5878);\n    const vec2 pl2 = vec2(-0.309, 0.951);\n   \tconst vec2 pl3 = vec2(-0.809, 0.5878);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    p -= pl3*2.*min(0., dot(p, pl3));\n    return p;\n}\n\nfloat cyl(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin(in float a, in float b)\n{\n    float k = .15;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------------------------\n\nfloat map(in vec3 p)\n{\n    float r =length(p);\n    vec2 sph = vec2(acos(p.y/r), atan(p.x, p.z));\n    \n    matid = 1.;\n    float d = r-1.; \n    d += sin(sph.y*7.)*0.02;\n    d += sin(sph.y*20.)*0.002;\n    float gbh = sin((sph.x+sph.y)*7.+0.5)*0.5+0.5;\n    d += sin(sph.y*40.)*0.001*gbh;\n    d += sin(sph.x*1.85+2.7)*0.3;\n    \n    //Leaves\n    vec3 p2 = p;\n    float rxz2 = dot(p.xz,p.xz);\n    float rxz = sqrt(rxz2);\n    rxz = exp2(rxz*6.-5.);\n    p2.xz = foldPent(p2.xz);\n    p2.y -= sqrt(rxz)*0.17 + sin(rxz*2.+p.z*p.x*10.)*0.05;\n    float leaves = sbox(p2+vec3(0,-.92-smoothstep(-0.01,.05,rxz2)*0.05,0),vec3(.07- rxz*0.1,0.002+p2.x*0.15,0.8));\n    leaves = smin(leaves, cyl(p+vec3(sin(p.y*3.5 + 0.8)*0.3 + 0.3,-1.1,0),vec2(.05,.25))); //Tail\n    if (leaves < d)matid = 2.;\n    d = min(d, leaves);\n    \n    float flor = p.y+.65;\n    if (flor < d)matid = 0.;\n    d = min(d, flor);\n    return d;\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{\n    vec2 e = vec2(-1., 1.)*2e-5;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy));   \n}\n\nfloat getAO(in vec3 pos, in vec3 nor)\n{\n\tfloat rz = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i);\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos);\n        rz += -(dd-hr)*sca;\n        sca *= 0.8;\n    }\n    return clamp(rz*-3.+1., 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax, in float sft)\n{\n\tfloat rz = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        rz = min(rz, sft*h/t);\n        t += clamp(h, 0.01, .1);\n        if(h<0.0001 || t>tmax) break;\n    }\n    return clamp(rz, 0.0, 1.0);\n}\n\nfloat bnoise(in vec3 p)\n{\n    p*= 2.5;\n    float n = noise(p*10.)*0.8;\n    n += noise(p*25.)*0.5;\n    n += noise(p*45.)*0.25;\n    return (n*n)*0.004;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.007,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n    \nvec3 lgt = normalize( vec3(-.05, .19, -0.11) );\nvec3 lcol = vec3(1.,1.,1.);\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//PBR math from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd, in float dst)\n{\n    vec3 nor = normal(pos,rd);\n  \tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n    float ripe = smoothstep(0.2,2.2,(mous.y + noise(pos*1.5)))*0.22;\n    vec3 albhsv = vec3(0.003+ripe, .99-ripe*0.5,.5);\n    float nz = (noise(pos*150.)-0.5)*0.035; //Skin imperfections\n    albhsv.z += nz;\n    albhsv.y -= nz;\n    vec3 f0hsv = vec3(0.01,.5,.15);\n    float soft = 2.;\n    float rough = 0.5;\n\tfloat mtid = matid;\n    if (matid == 0.) //floor/walls\n    {\n        albhsv = vec3(1.,.0,1.);\n        soft = 8.;\n    } \n    else if (matid == 2.) //Leaves/Tail\n    {\n        float nz2 = noise(pos*17.)*0.8;\n        nz2 += noise(pos*70.)*0.8;\n        \n        nor = bump(pos,nor,dst);\n        nl = clamp(dot(nor,lgt), 0., 1.);\n        albhsv = vec3(.25 + nz2*0.07 - (1.-mous.y)*0.05, .9,.35- nz2*0.15 - (1.-mous.y)*0.08);\n        rough = 0.7;\n    }\n    \n    //Artistic shading\n    float stp = step(mous.x,pxx);\n    albhsv.x += ((nl-.7)*0.08)* stp; //Hue variation\n    float vari = sin(nl*6.28*0.5-1.5708);\n    albhsv.y += vari*0.1*stp; //Saturation variation\n    albhsv.z += vari*0.12*stp; //Value variation\n    //albhsv.z += sin(nl*6.28*1.+3.14159)*0.13*stp; //Can be higher freqency\n    \n    vec3 alb = hsv2rgb(albhsv);\n    vec3 f0 = hsv2rgb(f0hsv);\n    \n\tvec4 col = vec4(0.);\n    \n    if (nl > 0.)\n    {\n        nl *= shadow(pos, lgt, 0.01,2.5, soft)*0.9+0.1;\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = rough*rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh); //exp2 \"optimization\"\n        vec3 spec = nl*D*F*G;\n        col.rgb = lcol*nl*(spec + alb*(1. - f0));\n        col.a = nl;\n    }\n    \n    float h = clamp(pos.y*2.+.85,0.01,1.);\n    \n    //Hemispherical bounce lights (GI fakery)\n    float bnc = clamp(dot(nor, normalize(vec3(lgt.x,0.0,lgt.z)))*.5+0.28,0. , 1.);\n    col.rgb += lcol*alb*bnc*0.25 *h* (1.-col.a);\n    float bnc2 = clamp(dot(nor, vec3(-lgt.x,lgt.y,-lgt.z))*.5+0.28,0. , 1.);\n    col.rgb += lcol*alb*bnc2*0.1 *h* (1.-col.a);\n    \n    col.rgb += 0.02*alb;\n   \tcol *= getAO(pos,nor);\n    return col.rgb;\n}\n\n//From eiffie: https://www.shadertoy.com/view/XsSXDt\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px)\n{\n    float precis = px*.01;\n    float prb = precis;\n    float t=map(ro);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n\t\td=map(ro+rd*t);\n\t\tif(df==100.0)\n        {\n\t\t\tif(d>od)\n            {\n\t\t\t\tif(od<px*(t-od))\n                {\n\t\t\t\t\tdf=od; tf=t-od;\n                    t += .05;\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\tif(t>FAR || d<precis)break;\n\t}\n\tvec3 col=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade((ro+rd*tm) - rd*(px*(tm-dm)) ,rd, tm),col,clamp(dm/(px*tm),0.0,1.0));\n\t\n    float qq=0.0;\n    if((df==100.0 || tm==tf) && t < FAR)\n    {\n        ro+=vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq=.01;\n\t}\n    dfog = tm;\n    return mix(shade((ro+rd*tf) - rd*(px*tf-df),rd, tf),col,clamp(qq+df/(px*tf),0.0,1.0));\n    \n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= 1.5/(iResolution.y*fov);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    pxx = q.x;\n    vec2 p = q - 0.5;\n\tfloat asp =iResolution.x/iResolution.y;\n    p.x *= asp;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.5,0.1):mo;\n    mous = mo;\n\t\n    vec3 ro = vec3(0., 0., 4.5+sin(time*0.2)*0.5);\n    vec3 rd = normalize(vec3(p,-fov));\n    \n    mat3 cam = rot_x(0.4+sin(time*0.7)*.1)*rot_y(sin(time*0.35)*1.3+4.);\n    ro *= cam;rd *= cam;\n    \n    vec3 bg = vec3(1.);\n    vec3 col = vec3(0);\n    \n    col = marchAA(ro, rd, bg, px);\n    \n    col = clamp(col, 0.,1.);\n    \n    col = mix(col, bg, smoothstep(FAR-20.,FAR, dfog)); //Distance fog\n    col *= smoothstep(0.,.005,abs(mous.x-pxx));//Separator\n\tcol = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.85+0.15; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}