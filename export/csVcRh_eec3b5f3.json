{"ver":"0.1","info":{"id":"csVcRh","date":"1695941960","viewed":14,"name":"3d 001","username":"kamikoto00","description":"Simple 3d render\nStill in development","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float NaN = 0. / 0.;\nconst float Inf = 1. / 0.;\nconst float PI = radians( 180. );\n\nuint createRandState( float seed ) {\n  return floatBitsToUint( seed );\n}\n\nuint createRandState( vec2 c ) {\n  return createRandState( c.x + c.y * iResolution.x );\n}\n\nfloat rand( inout uint state ) {\n  state = state * 747796405u + 2891336453u;\n  uint result = ( ( state >> ( ( state >> 28 ) + 4u ) ) ^ state ) * 277803737u;\n  result = ( result >> 22 ) ^ result;\n  return fract( float( result ) / 4294967295. );\n}\n\nfloat randomValueNormalDistribution( inout uint state ) {\n  float theta = 2. * PI * rand( state );\n  float rho = sqrt( -2. * log( rand( state ) ) );\n  return rho * cos( theta );\n}\n\nvec3 randomDirection( inout uint state ) {\n  return normalize( vec3( randomValueNormalDistribution( state ), randomValueNormalDistribution( state ), randomValueNormalDistribution( state ) ) );\n}\n\nvec3 randomHemisphereDirection( vec3 normal, inout uint randState ) {\n  vec3 dir = randomDirection( randState );\n  return faceforward( dir, dir, -normal );//dir * sign(dot(normal, dir));\n}\n\nstruct Material {\n  vec3 color;\n  float opacity;\n  float diffusion;\n  float opticalDensity;\n  float emissive;\n};\n\nMaterial createMaterial( vec3 color, float opacity, float diffusion, float opticalDensity, float emissive ) {\n  return Material( color, opacity, diffusion, opticalDensity, emissive );\n}\n\nMaterial createMaterial( vec3 color, float opacity, float diffusion, float emissive ) {\n  return createMaterial( color, opacity, diffusion, 1., emissive );\n}\n\nMaterial createMaterial( vec3 color, float opacity, float diffusion ) {\n  return createMaterial( color, opacity, diffusion, 0. );\n}\n\nMaterial createMaterial( vec3 color, float diffusion ) {\n  return createMaterial( color, 1., diffusion );\n}\n\nMaterial createMaterial( vec3 color ) {\n  return createMaterial( color, 1. );\n}\n\nconst Material defaultMaterial = Material( vec3( 0.7 ), 1., 1., 1., 0. );\n\nstruct RayHit {\n  float depth;\n  vec3 normal;\n  //vec3 pos;\n  Material material;\n  bool leave;\n};\n\nconst RayHit rayMiss = RayHit( Inf, vec3( 0 ), defaultMaterial, true );\n\nstruct Ray {\n  vec3 start;\n  vec3 dir;\n};\n/*\nRay createRay( vec3 start, vec3 dir ) {\n  return Ray( start, dir, rayMiss );\n}\n*/\n#define sqr(a) dot((a),(a))\n\nvec2 solveQuadraticEquation( float a, float b, float c ) {\n  float D = b * b - 4. * a * c;\n  if( D < 0. ) {\n    return vec2( NaN );\n  }\n  float d = sqrt( D );\n  return vec2( ( -b - d ), -b + d ) / ( 2. * a );\n}\n\nmat3 rotationX( float angle ) {\n  return mat3( 1, 0, 0, 0, cos( angle ), -sin( angle ), 0, sin( angle ), cos( angle ) );\n}\n\nmat3 rotationY( float angle ) {\n  return mat3( cos( angle ), 0, sin( angle ), 0, 1, 0, -sin( angle ), 0, cos( angle ) );\n}\n\nmat3 rotationZ( float angle ) {\n  return mat3( cos( angle ), -sin( angle ), 0, sin( angle ), cos( angle ), 0, 0, 0, 1 );\n}\n\nmat3 eulerToMatrix( vec3 euler ) {\n  vec3 r = radians( euler );\n  return rotationZ( r.z ) * rotationX( r.x ) * rotationY( r.y );\n}\n\nvec3 rotate( vec3 v, mat3 r ) {\n  return v * r;\n}\n\nvec3 rotate( vec3 v, vec3 euler ) {\n  return rotate( v, eulerToMatrix( euler ) );\n}\n\nvec3 rotateAround( vec3 v, mat3 r, vec3 a ) {\n  return a - rotate( a - v, r );\n}\n\nvec3 rotateAround( vec3 v, vec3 euler, vec3 a ) {\n  return rotateAround( v, eulerToMatrix( euler ), a );\n}\n\nvec3 rotateAroundAxis( vec3 v, vec3 axis, float deg ) {\n  return ( v - axis ) * rotationZ( radians( deg ) ) + axis;\n}\n\nstruct Sphere {\n  Material material;\n  vec3 position;\n  float radius;\n};\n\nstruct Plane {\n  Material material;\n  vec3 position;\n  vec3 rotation;\n  vec2 size;\n};\n\nstruct Triangle {\n  Material material;\n  vec3 points[3];\n};\n\nconst float near = 0.01;\n\nvoid rayCast( inout RayHit hit, Ray ray, Sphere sphere ) {\n  vec3 deltaPos = ray.start - sphere.position;\n  vec2 t = solveQuadraticEquation( sqr( ray.dir ), dot( deltaPos, ray.dir ) * 2., sqr( deltaPos ) - sqr( sphere.radius ) );\n  bool leave = t.x < 0.;\n  float depth = leave ? t.y : t.x;\n  if( !isnan( depth ) && depth > near && depth < hit.depth ) {\n    hit.depth = depth;\n    hit.material = sphere.material;\n    vec3 hitPos = ray.start + ray.dir * depth;\n    hit.normal = ( hitPos - sphere.position ) / sphere.radius;\n    if (leave) {\n      hit.normal = -hit.normal;\n    }\n    hit.leave = leave;\n  }\n}\n\nvoid rayCast( inout RayHit hit, Ray ray, Plane plane ) {\n  vec3 deltaPos = ray.start - plane.position;\n  mat3 rotator = eulerToMatrix( plane.rotation );\n  vec3 normal = vec3( 0, 1, 0 ) * rotator;\n  float t = dot( normal, ray.dir );\n  if( t == 0. ) {\n    return;\n  }\n  mat3 unrotator = transpose( rotator );\n  float depth = -( deltaPos * unrotator ).y / ( ray.dir * unrotator ).y;\n  vec3 hitPos = ray.start + ray.dir * depth;\n  vec3 planeUv = ( hitPos - plane.position ) * unrotator;\n  bool inside = all( lessThanEqual( abs( planeUv.xz ), abs( plane.size / 2. ) ) );\n  if( inside && depth > near && depth < hit.depth ) {\n    hit = RayHit( depth, t > 0. ? -normal : normal, plane.material, t > 0. );\n  }\n}\n\nvoid rayCast( inout RayHit hit, Ray ray, Triangle triangle ) {\n  vec3 a = triangle.points[1] - triangle.points[0];\n  vec3 b = triangle.points[2] - triangle.points[0];\n  vec3 normal = normalize( cross( a, b ) );\n  float d = dot( ray.dir, normal );\n  float c = dot( triangle.points[0] - ray.start, normal );\n  if( d == 0. || c == 0. ) {\n    return;\n  }\n  float depth = c / d;\n  vec3 p = ray.start + ray.dir * depth;\n  float t = distance( triangle.points[0], p );\n  if( t < length( a ) && t < length( b ) && depth > near && depth < hit.depth ) {\n    vec3 hitPos = ray.start + ray.dir * depth;\n    hit = RayHit( depth, normal, triangle.material, d > 0. );\n  }\n}\n\nconst float fov = 90.;\nconst int maxRayTrace = 6;\nconst int samplesAmount = 40;\n\nRayHit scene( Ray ray ) {\n  Material redPlastic = createMaterial( vec3( 1.0, 0.0, 0.0 ), 1., 0.2, 1., 0. );\n  Material greenPlastic = createMaterial( vec3( 0.0, 1.0, 0.0 ), 1., 1., 1., 0. );\n  Material bluePlastic = createMaterial( vec3( 0.0, 0.0, 1.0 ), 1., 1., 1., 0. );\n  Material redGlass = createMaterial( vec3( 1.0, 0.0, 0.0 ), 0.1, 0., 1.5, 0. );\n  Material greenGlass = createMaterial( vec3( 0.0, 1.0, 0.0 ), 0.1, 0., 1.5, 0. );\n  Material blueGlass = createMaterial( vec3( 0.0, 0.0, 1.0 ), 0.1, 0., 1.5, 0. );\n  Material wallMaterial = createMaterial( vec3( 0.8 ), 1., 0.1 );\n  Material waterMaterial = createMaterial( vec3(0.48, 0.89, 0.99), 0.3, 0.01, 1.33, 0. );\n  Material whiteLight = createMaterial( vec3( 1.0, 1.0, 1.0 ), 1., 0., 1., 100. );\n  Material greenLight = createMaterial( vec3( .0, 1.0, .0 ), 0., 0., 0., 10. );\n  RayHit hit = rayMiss;\n  rayCast( hit, ray, Sphere( bluePlastic, vec3( 0, 1, 3 ), 0.5 ) );\n  rayCast( hit, ray, Sphere( greenLight, vec3( 3, 2, 0 ), 1. ) );\n  //rayCast( hit, ray, Sphere( redGlass, vec3( 0, 8, 2 ), 3. ) );\n  rayCast( hit, ray, Plane( wallMaterial, vec3( 0 ), vec3( 0 ), vec2( 10 ) ) );\n  rayCast( hit, ray, Plane( wallMaterial, vec3( 0, 2.5, -5 ), vec3( 90, 0, 0 ), vec2( 10, 5 ) ) );\n  rayCast( hit, ray, Plane( wallMaterial, vec3( -5, 2.5, 0 ), vec3( 90, 90, 0 ), vec2( 10, 5 ) ) );\n  rayCast( hit, ray, Plane( wallMaterial, vec3( 0, 2.5, 5 ), vec3( 90, 180, 0 ), vec2( 10, 5 ) ) );\n  rayCast( hit, ray, Plane( wallMaterial, vec3( 5, 2.5, 0 ), vec3( 90, -90, 0 ), vec2( 10, 5 ) ) );\n  rayCast( hit, ray, Plane( waterMaterial, vec3( 0, 4, 0 ), vec3( 0 ), vec2( 10 ) ) );\n  return hit;\n}\n\nvec3 render( in Ray camRay ) {\n  uint randState = createRandState( camRay.dir.xy * iTime * iDate.w );\n  vec3 resultColor = vec3( 0 );\n  for( int i = 0; i < samplesAmount; i++ ) {\n    Ray ray = camRay;\n    vec3 mask = vec3( 1 );\n    vec3 envMask = vec3( 1 );\n    float opticalDensity = 1.;\n    for( int i = 0; i < maxRayTrace; i++ ) {\n      RayHit hit = scene( ray );\n      if( hit.depth == Inf ) {\n        //resultColor += ( ray.dir.y / 2. + 0.5 ) * mask;\n        resultColor += ( 0.5 ) * mask * envMask;\n        break;\n      }\n      Material material = hit.material;\n      resultColor += material.color * material.emissive * mask * envMask;\n      ray.start = ray.start + ray.dir * hit.depth;\n      if( rand( randState ) < material.opacity ) {\n        mask *= material.color * material.opacity;\n        ray.dir = reflect( ray.dir, hit.normal );\n      } else {\n        envMask *= ( 1. - material.opacity + material.color * material.opacity );\n        float eta;\n        if (hit.leave) {\n          eta = material.opticalDensity / opticalDensity;\n          opticalDensity /= material.opticalDensity;\n        } else {\n          eta = opticalDensity / material.opticalDensity;\n          opticalDensity *= material.opticalDensity;\n        }\n        ray.dir = refract( ray.dir, hit.normal * ray.start, eta );\n      }\n      ray.dir = normalize( mix( ray.dir, randomHemisphereDirection( hit.normal, randState ), material.diffusion ) );\n    }\n  }\n  return resultColor / float( samplesAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //vec3 camPos = vec3( 5, 7, -13 );\n  vec3 initialCamPos = vec3( 0, 10, -10 );\n  vec3 initialCamRot = vec3( 30, 0, 0 );\n  vec3 rot = vec3( 0, iTime * 10., 0 );\n    //iMouse.xy is coordinates of last position when button was/is pressed\n    //iMouse.z is iMouse.x value when button was pressed. If button is not pressed it is the same, but negative\n    //iMouse.w is iMouse.y value when button is pressed. Next frame it is negative\n  if( iMouse.z > 0. ) {\n    vec2 mouseUv = ( iMouse.xy - iResolution.xy / 2. ) / iResolution.xy * 2.;\n    rot = vec3( degrees( mouseUv.yx ) * vec2( 2, 4 ), 0 );\n  }\n  vec3 camPos = rotateAround( initialCamPos, rot, vec3( 0, 0, 0 ) );\n  vec3 camRot = initialCamRot + rot;\n  vec2 camSize = vec2( 1, 1 );\n\n  vec2 uv = ( fragCoord - iResolution.xy / 2. ) / iResolution.x;\n  vec2 uvR = radians( fov ) * uv;\n  vec3 rayDir = normalize( rotate( vec3( uvR, 1 ), camRot ) );\n  vec3 startPos = camPos + rotate( vec3( camSize * uv, 0 ), camRot );\n  fragColor = vec4( render( Ray( startPos, rayDir ) ), 1. );\n}\n","name":"Image","description":"","type":"image"}]}