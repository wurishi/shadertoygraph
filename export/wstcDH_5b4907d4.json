{"ver":"0.1","info":{"id":"wstcDH","date":"1603969319","viewed":278,"name":"Stone Circle","username":"athibaul","description":"Inspired by a story generated using an [url=https://play.aidungeon.io]artificial intelligence[/url].","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","distancemap","stonecircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (2.0*3.1415926)\n\n/**\nYou help her onto her horse and the both of you gallop back\nto the ritual. The sun is setting, casting the entire forest\ninto darkness. The moon is out, and the forest glows with an\notherworldly light. Your horse runs fast, but Zal's seems to\nmove even faster. She reaches the stone circle first and\ndismounts, running towards the center. As she runs, she pushes\nthe altar with her, overturning it so that the pentagram is\nnow upside-down.\n\n-- Text generated by AI Dungeon\nhttps://play.aidungeon.io\n*/\n\nvec2 coo;\n\nfloat sdBox( vec3 p, vec3 r )\n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvec3 tri(vec3 p)\n{\n    return abs(fract(p)-0.5)-0.25;\n}\n\nfloat map( vec3 p, out vec3 q )\n{\n    // Terrain deformation\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\n    \n    // For each point, calculate the distance to one stone only\n    float nStones = 13.;\n    float circleRadius = 5.0;\n    float d = 100.;\n    float th = atan(p.y, p.x);\n    float id = round(th/TAU * nStones);\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\n    q = p;\n    // Bring back point close to the positive x axis\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\n    \n    // Make sure the rays don't go too far into the next stone's section\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\n    dSection = max(dSection, p.z - 2.0);\n    d = min(d, dSection);\n    \n    // Random size of stone block\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\n    q.x -= circleRadius;\n    q.z -= 0.5*blockSize.z;\n    // Tilt stone by 45 degrees at most\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\n    float dBox = sdBox(q, blockSize);\n    // Deform surface a bit\n    vec3 q2 = p;\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\n    d = min(d, dBox);\n    \n    d = min(d, p.z);\n    \n    // I would like to add some stones popping off the ground,\n    // but doing it this way seems to introduce discontinuities.\n    // Use a Voronoi pattern ?\n    #if 1\n    q2 += hash32(floor(p.xy+0.5));\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\n    #endif\n    q = p;\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q; return map(p,q);\n}\n\n\nvec3 normal( vec3 p )\n{\n    vec2 e = 0.001 * vec2(1, -1);\n    return normalize(\n          e.xxx * map(p+e.xxx)\n        + e.xyy * map(p+e.xyy)\n        + e.yxy * map(p+e.yxy)\n        + e.yyx * map(p+e.yyx)\n    );\n}\n\n\n// Ambient Occlusion computation stolen from iq\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.5 ) break;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\n{\n    float transm = 1.0;\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\n    for(int i=0; i<256; i++)\n    {\n        float w = softness * t;\n        d = map(ro+t*rd);\n        transm = min(transm, smoothstep(-w,w,d));\n        if(transm < 0.01 || t > 20.) break;\n        t += d+w;\n        //t += max(d, 0.02);\n    }\n    return transm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coo = fragCoord;\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\n    vec3 camFwd = normalize(vec3(0) - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    float fov = 0.5;\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\n    \n    float d, t=0.;\n    for(int i=0; i<256; i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d*0.7;\n    }\n    vec3 p = ro+t*rd;\n    vec3 n = normal(p);\n    vec3 col;\n    \n    vec3 skyCol = vec3(1.0,1.5,2.);\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\n    //vec3 sunCol = vec3(2.,1.5,1.0);\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\n    if(t > 100.)\n    {\n        col = skyCol * 0.4;\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\n    }\n    else\n    {\n        //col = 0.5+0.5*n;\n        col = vec3(0);\n        vec3 q; map(p,q);\n        vec3 grassCol = vec3(0.3,0.5,0.2);\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\n        vec3 surfCol = mix(grassCol, stoneCol, \n                           smoothstep(0.,0.01,q.z));\n        float ao = calcAO(p, n);\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\n        \n        col += sunCol * shadow * surfCol * 8.;\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\n        //vec3 fillCol = 0.05*sunCol*grassCol;\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\n        \n        float fog = 1.-exp(-0.02*max(t-10.,0.));\n        col = mix(col, skyCol*0.4, fog);\n    }\n    \n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\n    \n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}","name":"Common","description":"","type":"common"}]}