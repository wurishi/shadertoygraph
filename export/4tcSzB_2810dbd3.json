{"ver":"0.1","info":{"id":"4tcSzB","date":"1480172188","viewed":247,"name":"sonic bird cage","username":"balkhan","description":"A little cage for the bulb :)\nDiscovering the I/O of shadertoy, funny stuff.","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","sound","mandelbulb","texture","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldBGW1","filepath":"https://soundcloud.com/glxblt/glxblt-auto-mate","previewfilepath":"https://soundcloud.com/glxblt/glxblt-auto-mate","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I_MAX\t150\n#define E_BULB\t0.01\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat\tbulb(vec3 pos);\nfloat\tde(vec3 pos);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\tuv;\nfloat\tsound;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.xy;\n    sound = (texture(iChannel0, vec2(iChannelTime[0]/iSampleRate)).r);\n    vec4\tcol = vec4(0.0);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(1.0, -1.0, 4.0);\n\tvec3\tlight = vec3(1.0, 1.0, 1.0);\n    \n    vec4\tinter = (march(pos, dir));\n    // phong shading (I'm probably doing something wrong here)\n    if (inter.w <= 6.)\n    {\n        vec3\tn = calcNormal(pos, E_BULB/1000.0, dir);\n        vec3\tvd = normalize(light - (pos+inter.w*dir));\n        float\tvdn = dot(vd, n);\n\t    col.xyz = vec3(1.0, 1.0, 1.0) * vd + dot(dir, n) * vdn;\n\t    col.xyz += vec3(dot(-dir, 2.0 * vdn * n - vd));\n    }\n    // texture\n    else\n    {\n    \tcol = vec4(texture(iChannel1, vec2(fragCoord.xy/iResolution.xy)+vec2(2.0*cos(iResolution.x+iTime/20.),2.0*sin(iResolution.y+iTime/20.))).rgb, 1.);\n        col += ((texture(iChannel0, vec2(uv.x*uv.y,iTime)).g))/5.; // ground light\n    }\n   \tfragColor = col;\n}\n\n//raymarching routine\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = min(bulb(p), de(p));\n        dist.y += dist.x;\n        if (dist.x < E_BULB || dist.y > 6.)\n           break;\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n//bulb de taken from syntopia, optimized a bit\nfloat\tbulb(vec3 pos)\n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float\ttheta;\n    float\tphi;\n    float\tzr;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n        r = length(z);\n\t\tif (r > 2.0)\n            break;\n\t\ttheta = acos(z.z/r);\n\t\tphi = atan(z.y, z.x);\n        zr = r * r;\n        zr *= zr;\n        zr *= zr;\n\t\tdr =  zr * 8.0 * dr + .50;\n\t\tzr *= r;\n\t\ttheta = theta * 8.0 + sound*35.5;\n\t\tphi = phi * 8.0 + sound*15.;\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn (0.5*log(r)*r/dr);\n}\n\n//cage de\nfloat de(vec3 pos)\n{\n\tvec3\tz = pos;\n\tfloat\tdr = 1.0;\n\tfloat\tr = 0.0;\n    float\ttheta;\n    float\tphi;\n    float\tzr;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n        r = length(z)+.73;\n\t\tif (r > 20.0)\n            break;\n\t\ttheta = atan(z.z/r, z.z*r);\n\t\tphi = atan((1.5+z.x * z.y*sin(5.*z.z*sound)/2.), (z.y - z.x*sin(5.*z.z*sound)/2.));\n        zr = r * r;\n        zr *= zr;\n        zr *= zr;\n\t\tdr =  zr * r * r * 8.0 * dr ;\n\t\tzr *= r;\n\t\ttheta = theta * 8.0 + sound/2.;\n\t\tphi = phi * 8.0 + sound/2. + 15.0 * cos(iChannelTime[0]/3.0);\n\t\tz = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z.xy = cmult(z.zy, vec2(z.y/dr, z.y/dr)); // inversion\n\t\tz += pos;\n\t}\n\treturn (2.4*log(r)*r/dr);\n}\n\n//taken from an iq shader\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.8) * right + (uv.y-0.25) * up + fov * forw));\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n","name":"Image","description":"","type":"image"}]}