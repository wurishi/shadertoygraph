{"ver":"0.1","info":{"id":"XsyfWW","date":"1528773103","viewed":189,"name":"fractal practice 1","username":"chantecleer","description":"just a combination of a few fractal shaders from here","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractalde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define FieldOfView 1.\n#define gt iGlobalTime * 0.1 // to make tunnel next\n//#define sgt(i) abs(sin(i * iGlobalTime))\n#define Giter 5 //iterations of the glowing lines fractal\n\n\n\nfloat DE(in vec3 z)\n{\t\n\t/* Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));   */\n\n    z = fract(z);// + 0.1*fract(2.*z);\n\n    float d =length(z.xy-vec2(0.5));\n    d = min(d, length(z.xz-vec2(0.5)));\n    d = min(d, length(z.yz-vec2(0.5)));\n    \n    return d-0.01;\n}\n    \nvec3 Glow(vec3 z, float b){\n    z = fract( z + 2.0) * 2. -1.; // divides plane again\n\n    //z.z = b; // THIS PART MAKES THE FLASHES!\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    //z.x += 0.2;\n    return z;\n}\n\n\nvec3 fog(float a,vec3 b,float c){ \n    //a *= c;\n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c ); // must be a fog function\n}\n\n// taes vec3 from Glow, v (random), u (ball at end of raytracer), and an int that is the transparency\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e= fog(0.01, abs(fr), d) * 2.; \n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( 1. -c * 200. / d, 0. ) / d * 70.;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float A = 3. * iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 base = vec3(.2, 0.5*sin(0.01*iTime), 0.5*cos(0.01*iTime));\n    //vec3 base = vec3(1.0, 0.7, 0.8);\n\n    vec3 camPos = 0.5*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(1.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color; float totalDistance, distance, v;\n\n    for(int i = 0; i < 32; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = min(abs(fract( pos.z ) - 0.5), DE(pos));\n        v = sin( A * .01 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance  + .001; \n        color += ( W( x, v, distance, 0.5) ) * (distance + 0.001);\n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}","name":"Image","description":"","type":"image"}]}