{"ver":"0.1","info":{"id":"DslGWB","date":"1666741356","viewed":123,"name":"RYB Color Wheel Approx","username":"onepride","description":"Not an ideal approximation, but a good starting point to find secondary colors.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["colorwheel","ryb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n#define COMPARE_RYB_RGB_WHEELS 0\n\n// ===============================================================================\n// Ittan's Color Wheel remapping \n// based on \"Paint Inspired Color Compositing\" - Nathan Gossett, Baoquan Chen\n// https://bahamas10.github.io/ryb/assets/ryb.pdf\n\nfloat cubicLerp(float A, float B, float t)\n{\n    t = t*t*(3.0-2.0*t);\n    return A+(B-A)*t;\n}\n\nvec2 cubicLerp(vec2 A, vec2 B, float t)\n{\n    t = t*t*(3.0-2.0*t);\n    return A+(B-A)*t;\n}\n\nvec4 cubicLerp(vec4 A, vec4 B, float t)\n{\n    t = t*t*(3.0-2.0*t);\n    return A+(B-A)*t;\n}\n\nvec3 ryb2rgb(vec3 ryb)\n{\n    vec3 rgb;\n    //red\n    vec4 X = cubicLerp(vec4(1.0), vec4(0.163, 0.0f, 0.5, 0.2), ryb.z);\n    vec2 Y = cubicLerp(X.xz, X.yw, ryb.y);\n    rgb.r  = cubicLerp(Y.x, Y.y, ryb.x);\n    //green\n    X      = cubicLerp(vec4(1.0, 1.0, 0.0, 0.5), vec4(0.373, 0.66, 0.0, 0.094), ryb.z);\n    Y      = cubicLerp(X.xz, X.yw, ryb.y);\n    rgb.g  = cubicLerp(Y.x, Y.y, ryb.x);\n    //blue\n    X      = cubicLerp(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.6, 0.2, 0.5, 0.0), ryb.z);\n    Y      = cubicLerp(X.xz, X.yw, ryb.y);\n    rgb.b  = cubicLerp(Y.x, Y.y, ryb.x);\n    return rgb;\n}\n// ===============================================================================\n\nvec3 hsv2rgb(vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//RGB\nvec4 SampleColorWheelRGB(vec2 uv)\n{\n    const float sat = 0.9;\n    const float rmin = 0.45;\n    const float rmax = 1.0;    \n\n    uv = uv*2.0 - 1.0;\n    float l = length(uv);\n\n\tif (l >= rmin && l <= rmax)\n\t{\n        // anti-aliasing approx\n        float c = (rmax + rmin) * 0.5;\n        float h = (rmax - rmin) * 0.5;\n\t\tl = 1.0 - abs((l - c) / h);\n\t\tl = clamp(l * iResolution.y * 0.0625, 0.0, 1.0);\n\t\t\n        // find hue\n        float theta = 3.0 + 3.0 * atan(uv.x, uv.y) / M_PI;\t\n        float hue = theta / 6.0 + 0.5;\n    \n        return vec4(hsv2rgb(vec3(hue, 1.0, 1.0)), l);\n\t}\n    return vec4(0.0);\n}\n\n//RYB\nvec4 SampleColorWheelRYB(vec2 uv)\n{\n    vec4 cw = SampleColorWheelRGB(uv);\n    return vec4(ryb2rgb(cw.rgb), cw.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 bg = vec3(0.18);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = (uv.x - 0.2)*iResolution.x/iResolution.y;\n    \n    float mouseU = iMouse.x / iResolution.x;\n\n    vec4 ryb = SampleColorWheelRYB(uv);\n    \n#if COMPARE_RYB_RGB_WHEELS\n    vec4 rgb = SampleColorWheelRGB(uv);\n    vec4 col = mix(rgb, ryb, smoothstep(iMouse.x-1.0, iMouse.x+1.0, fragCoord.x));\n#else\n    vec4 col = ryb;\n#endif\n    \n    fragColor = vec4(mix(bg, col.rgb, col.aaa), 1.0);\n}","name":"Image","description":"","type":"image"}]}