{"ver":"0.1","info":{"id":"MdSBDw","date":"1500643462","viewed":228,"name":"[SH17B] Skeleto's Quest","username":"unbird","description":"raymarch, animation, competition.\n\nStill not finished :( \n\n","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","animation","competition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Animation, game \n\n\tcontribution for the 2017 competition\n\n\tby unbird\n\n\tStill not finished :( The arms are still missing. Which are actually gameplay-relevantt\n\n\n\tControl with WASD/Cursor or left mouse button alone. Hitting is \"gestures\".\n\t\n\n\t\n\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    self reference : https://www.shadertoy.com/view/MdSBDw\n*/\n\n\n// TODO: KEYBOARD channel only used here for debugging, remove later.\n#define BITMAPFONT iChannel3\n#define KEYBOARD iChannel2\n#define STATE iChannel1\n\n#define DEBUG\n\nconst ivec2 DEBUG1    = ivec2(0,1);\nconst ivec2 POSITION  = ivec2(0,0);\nconst ivec2 VELOCITY  = ivec2(1,0);\nconst ivec2 FRAME     = ivec2(2,0);\nconst ivec2 FEET      = ivec2(3,0);\nconst ivec2 FEETSTATE = ivec2(4,0);\nconst ivec2 HEADING   = ivec2(5,0);\nconst ivec2 CAMERA    = ivec2(6,0);\nconst ivec2 MOUSE     = ivec2(7,0);\nconst ivec2 MOUSETIME = ivec2(8,0);\nconst ivec2 OBSTACLE  = ivec2(64,0);\nconst ivec2 CAMERAMOVE= ivec2(9,0);\nconst ivec2 ACTION    = ivec2(10,0);\nconst ivec2 INTERACTIVE1 = ivec2(11,0);\nconst ivec2 INTERACTIVE2 = ivec2(12,0);\nconst ivec2 INTERACTIVE3 = ivec2(13,0);\nconst ivec2 ANIM         = ivec2(14,0);\nconst ivec2 GAMESTATE    = ivec2(15,0);\nconst ivec2 ARMANIM      = ivec2(16,0);\nconst ivec2 GUI1         = ivec2(20,0);\n\nconst float PLAYERSIZE = 0.1;\nconst float TORCHES = 0.3;\n\nvec4 state(ivec2 p)\n{\n    return vec4(texelFetch(STATE, p, 0));\n}\n\nfloat sat(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// slight adjustment to make it work for the blend function\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n#ifdef DEBUG    \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.5;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( abs(fValue) ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    float v = floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n    return  0.5 - v;\n#else\n    return 0.5;\n#endif\n}\n\nvec2 gridCoord(vec2 p, int x, int y)\n{\n    float scale = 0.1;\n    float spacing = 13.;\n    vec2 scr = p * iResolution.xy * 0.5 + vec2(0.5);\n    return (p - vec2(spacing*float(x-1), spacing*float(-y-1)+iResolution.y)) * scale;        \n}\n\n// --- access to the image of ascii code c\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug\n\treturn textureGrad( BITMAPFONT, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( BITMAPFONT, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n\n// --- display int4\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0.0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        //n /=  9.999999, // 10., // for windows :-(\n        n /= 10.,\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return 0.5 - v;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    float f = trunc(n);\n    vec4 v = pInt(p, f);  \n    p.x -= 2.;\n    float ff = abs(n - f) * 1e4;\n    v += char(p, 46);      \n    p.x -= 2.;\n    v += pInt(p,ff);\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n#define C(c) U.x-=.5; O+= char(U,64+CAPS+c)\n\nfloat circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat circleLine(vec2 pos, float r, float width)\n{\n    return abs(circle(pos, r)) - width;\n}\n\n\n\n// constants\nconst float Pi     = 3.1415926535897932384626433832795;\nconst float Pi2    = 2.0 * Pi;\nconst float PiHalf = 0.5 * Pi;\nconst float RadToDegree = 180.0 / Pi;\n\nconst vec4 Red = vec4(1,0,0,1);\nconst vec4 LightRed = vec4(1,0.8,0.8,1);\nconst vec4 Yellow = vec4(1,1,0,1);\nconst vec4 Green = vec4(0,1,0,1);\nconst vec4 Orange = vec4(0.5,0.5,0,1);\nconst vec4 LightGreen = vec4(0.8,1.0,0.8,1);\nconst vec4 Blue = vec4(0,0,1,1);\nconst vec4 Purple = vec4(1,0,1,1);\nconst vec4 LightBlue = vec4(0.8,0.8,1,1);\nconst vec4 White = vec4(1,1,1,1);\nconst vec4 Gray = vec4(0.5,0.5,0.5,1);\nconst vec4 Black = vec4(0,0,0,1);\nconst vec4 TransparentWhite = vec4(1,1,1,0);\nconst vec4 Brown = vec4(0.8, 0.4, 0.2,1);\n\nvec4 darken(vec4 color)\n{\n\treturn vec4(color.rgb * 0.7, color.a);\n}\n\nvec4 lighten(vec4 color)\n{\n\treturn vec4(color.rgb * 1.4, color.a);\n}\nvec4 transparent(vec4 color)\n{\n    return vec4(color.rgb, color.a * 0.5);\n}\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat diffElaborate(float d1, float d2)\n{\n    float a = min(d1 * sign(d2), d2 * sign(d1));\n    float b = max(d1 * sign(d2), d2 * sign(d1));\n    \n    if (sign(d1) == sign(d2))\n    \treturn a;\n    else\n    \treturn b;\n}\n\nfloat diff( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rot(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circle2(vec2 p, float radius)\n{\n\treturn dot(p,p) - radius*radius;\n}\n\nfloat signxx(float x)\n{\n    return x > 0.0 ? 1.0 : -1.0;\n}\n\n// --- ellipse\n// Created by Inigo Quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// unbird parameters to change shape\nfloat ellipse(vec2 P, vec2 ab)\n{\n/*\n    // Alternate version (approximation)\n    float a = 1.0;\n    float b = 3.0;\n    float r = 0.9;\n    float f = length( p*vec2(a,b) );\n    f = length( p*vec2(a,b) );\n    f = f*(f-r)/length( p*vec2(a*a,b*b) );\n    return f;\n*/\n\n    //vec2 ab = vec2(size/3.0, size/2.0);\n    vec2 p = abs( P );\n    if( p.x > p.y ){\n        p = p.yx;\n        ab = ab.yx;\n    }\n    // unbird: slight modification to make inverted shape and ellipse line not produce artifacts at main axis\n    if(p.x < 0.0001)\n    {\n        return p.y - ab.y;\n    }\n    // unbird: another edge case. Perfect circles fail (one should use an actual circle). \n    if(abs(ab.x - ab.y) < 0.005)\n        ab.x += 0.005;\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;\n    float n = ab.y*p.y/l;\n    float m2 = m*m;\n    float n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if(d < 0.0)\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt(1.0 - co*co);\n    vec2 closestPoint = vec2(ab.x*co, ab.y*si);\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nfloat ellipseLine(vec2 pos, vec2 ab, float width)\n{\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat triangle(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangle(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircle(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circle(p, radius)) - width);\n}\n\n\nfloat box(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat line(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir) + 0.0001;\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nvec2 rot90(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\n\nvec2 rotAlign(vec2 p, vec2 dirX)\n{\n    vec2 dirY = vec2(-dirX.y, dirX.x);\n    return p.x * dirX + p.y * dirY;\n}\n\nvec2 rotAlignCCW(vec2 p, vec2 dirX)\n{\n    vec2 dirY = vec2(dirX.y, -dirX.x);\n    return p.x * dirX + p.y * dirY;\n}\n\n\nfloat arrow(vec2 p, vec2 start, vec2 end)\n{    \n    vec2 dir = end - start;\n    float d = length(dir);\n    if(d < 0.001)\n        return 1000.0;\n    dir = normalize(dir);    \n    \n    float s = line(p, start, end-dir*0.03, d * 0.02);    \n    p -= end;\n    p = rotAlign(p, dir.yx);\n    float t = triangle(p, 0.05 * d);\n    return merge(s,t);\n}\n\n\nfloat ellipseLineSafe(vec2 pos, vec2 ab, float width)    \n{\n    vec2 aab = abs(ab);\n    if(aab.x < 0.1 || aab.y < 0.1)\n    {\n        return line(pos, -ab, ab, width);\n    }\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat polygon(vec2 p, float radius, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn dot(p, plane) - radius;\n}\n\n// get normalized slice of circle\nfloat circleMod(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n\treturn angle / part;\n}\n\n// arbitrary \"polygon\". Has to be used with circleMod and some function which has f'(0) = f'(1), e.g. sin(x*2*pi)\nfloat polyShape(vec2 p, float radius, int n, float offset)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn length(p) - radius - offset;\n}\n\nfloat star(vec2 p, float radius, float innerradius, int n)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));            \n    float halfpart = 0.5 * part;\n    \n    // define 3 point of first \"tooth\" of the star\n    vec2 A = vec2(innerradius, 0);\n    vec2 B = vec2(cos(part), sin(part)) * innerradius;\n    vec2 C = vec2(cos(halfpart), sin(halfpart)) * radius;\n    \n    // derive plane equations thereof (normals and offsets)\n    vec2 plane1 = A - C;\n    plane1 = normalize(vec2(-plane1.y, plane1.x));\n    float p1c = dot(C, plane1);\n    \n    vec2 plane2 = C - B;\n    plane2 = normalize(vec2(-plane2.y, plane2.x));\n    float p2c = dot(C, plane2);\n    \n    // combine the planes\n\treturn max(dot(p, plane2) - p2c, dot(p, plane1) - p1c);\n}\n\n\nfloat spikes(vec2 p, float radius, int n, float width)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(-cos(angle), sin(angle));            \n    \n    width *= 0.5;\n    \n    float leftspike = abs(p.y) - width;    \n    \n    //part *= 0.5;\n    vec2 normal = vec2(sin(part), cos(part));\n    \n    float rightspike = -dot(p, normal) - width;\n    //return rightspike;      \n    //return leftspike;      \n    \n    return max(min(leftspike, rightspike), circle(p, radius));\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\tdist -= width * 0.5;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\tdist -= 5.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat solid(float f)\n{\n    return sat(f / 0.005);\n}\n\nvoid blend(inout vec4 back, float alpha, vec4 color)\n{\n    float a = sat(solid(alpha));\n    // basic alpha blending\n    //color = mix(color, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(alpha, 0.1));\n    back = mix(back, color, (1.0-a) * color.a);\n}\n\nvec2 cis(float alpha)\n{\n    return vec2(cos(alpha), sin(alpha));\n}\n\nfloat radial(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = Pi2 / float(n);\n    angle = mod(angle, part);   \n    return abs(angle - part * 0.5) / part / 0.5;\n}\n\nvoid dumpKeyboard(inout vec4 O, vec2 frag)\n{\n    for(float i = 0.; i < 127.; i++)\n    {\n        float k1 = texture(KEYBOARD, vec2(i / 256., 0.)).r;\n        float k2 = texture(KEYBOARD, vec2(i / 256., 0.5)).r;\n        if(k1 > 0. && k2 < 1.)\n        {          \n            blend(O, PrintValue(gridCoord(frag, 1, 3), i, 3., 0.), White);    \n            break;\n        }\n                           \n    }\n    \n    //O.r += texture(KEYBOARD, uv).r;       \n}\n    \nconst vec2 WorldBounds = vec2(1.5,3.0);\n\nconst int OBSTACLES = 7;\n\nconst vec4 Obstacles[] = vec4[]\n(\n    vec4(1.0, -2.1, 1.2, 0.3),\n    vec4(-0.9, -1.2, 0.4, 0.0),\n    vec4(-0.9, 0.5, 1.3, 0.5),\n    vec4(1.5, 1.7, 0.6, 0.0),\n    vec4(1.0, 3.0, 0.7, 0.3),\n    vec4(-1.0, 3.0, 0.7, 0.3),\n    vec4(0.0, 2.8, 0.25, 0.03)\n);\n\n\nvec2 toWorld(vec2 uv, vec4 camera)\n{\n    vec2 centerOffset = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    return (uv - centerOffset) * camera.z + camera.xy;\n}\n\nvec2 toScreen(vec2 uv, vec4 camera)    \n{\n    vec2 centerOffset = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    return (uv - camera.xy)/ camera.z + centerOffset;\n}\n\nvoid debugPrint(inout vec4 O, vec2 frag, int y, vec4 values)\n{\n    blend(O, PrintValue(gridCoord(frag, 0,  y), values.x , 6., 2.), LightBlue);\n    blend(O, PrintValue(gridCoord(frag, 10, y), values.y , 6., 2.), LightBlue);\n    blend(O, PrintValue(gridCoord(frag, 20, y), values.z , 6., 2.), LightBlue);\n    blend(O, PrintValue(gridCoord(frag, 30, y), values.w , 6., 2.), LightBlue);    \n}\n\nfloat aspect()\n{\n    return iResolution.x / iResolution.y;\n}\n\nvec4 debug1;\n\nvoid toWorldP(vec2 uv, vec4 camera, inout vec3 eye, inout vec3 ray)\n{\n    eye = vec3(camera.x, 2.0, camera.y-2.0);\n    vec3 view = vec3(camera.x, 0.0, camera.y);\n        \n    vec3 forward = view - eye;\n    \n    eye = view - forward * (camera.z + 0.1)*0.4;\n    \n    forward = normalize(forward);\n    \n    vec3 right = -normalize(cross(forward, vec3(0.0,1.0,0.0)));\n    vec3 up = -normalize(cross(right, forward));\n                               \n\t//right *= aspect();\n          \n    float fov = camera.z;\n    fov = 1.0;\n\n\tvec2 centerOffset = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    uv = uv - centerOffset;    \n                           \n\tray = forward + (uv.x * right + uv.y * up) * fov;\n}\n\nvec2 intersectGroundPlane(vec3 o, vec3 ray, inout float k)\n{\n    k = - o.y / ray.y;\n    vec3 p = o + ray * k;\n    debug1 = p.xyzz;\n    return p.xz;\n}\n\n///////////////////////// raymarch scene /////////////////////////\n\nconst float NONE = -1.0;\nconst float TERRAIN = 0.0;\nconst float WOOD = 1.0;\nconst float BONE = 2.0;\nconst float COAL = 3.0;\nconst float SIGN = 4.0;\nconst float STONE = 5.0;\nconst float GRANITE = 6.0;\n\n// color and specular\nconst vec4 Material[] = vec4[]\n(\n    vec4(1.0, 1.0, 1.0, 0.05),\n    vec4(0.8, 0.4, 0.2, 0.6),\n    vec4(0.9, 0.9, 0.7, 0.8),\n    vec4(0.001, 0.001, 0.001, 0.1),\n    vec4(0.9, 0.05, 0.05, -0.8),\n    vec4(0.3, 0.3, 0.3, 0.2),\n    vec4(0.0, 0.0, 0.0, 0.7)    \n);\n\n// sdf\nfloat plane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sphere2( vec3 p, float s )\n{\n    return dot(p,p)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat roundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat cone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\n\n\nvoid blend2(inout vec4 back, float alpha, vec4 color)\n{\n    float a = sat(alpha / 0.01);\n    // basic alpha blending\n    color = mix(color, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(alpha, 0.01));\n    back = mix(back, color, (1.0-a) * color.a);\n}\n\n\n\nfloat modPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*Pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat lengthp(vec3 p, float k)\n{\n    return pow(dot(p,p), k);\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat torus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat torus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat cylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\nfloat super(vec3 p, float radius, float r, float t)\n{\n    //return r = pow(pow(abs(p.x), r) + pow(abs(p.y), r), t * r) - pow(abs(p.z), t) - radius;    \n    return r = pow(pow(abs(p.x), 2./r) + pow(abs(p.y), 2./r), r / t) + pow(abs(p.z), 2./t) - radius;    \n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec3 rotXY(vec3 v, float a)\n{\n    v.xy *= rot(a);\n    return v;\n}\n\nvec3 rotXY(vec3 v, mat2 m)\n{\n    v.xy *= m;\n    return v;\n}\n\n\nvec3 rotXZ(vec3 v, float a)\n{\n    v.xz *= rot(a);\n    return v;\n}\n\nvec3 rotXZ(vec3 v, mat2 m)\n{\n    v.xz *= m;\n    return v;\n}\n\n\nvec3 rotYZ(vec3 v, float a)\n{\n    v.yz *= rot(a);\n    return v;\n}\n\nvec3 rotYZ(vec3 v, mat2 m)\n{\n    v.yz *= m;\n    return v;\n}\n\n\nvec2 merge( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat repeat( float p, float c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n\nvec3 twist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat pmerge( float a, float b, float k)\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat pmerge( float a, float b)\n{\n    return pmerge(a,b,32.);\n}\n\nfloat pmerge2( float a, float b, float k)\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat pmerge2( float a, float b)\n{\n    return pmerge2(a,b, 32.);\n}\n\n\n/* \nfloat smerge(float a, float b)\n{\n    return smerge(a,b,0.1);\n}\n/* */\n\nvec3 taper(vec3 p, vec3 central, vec3 vanish)\n{\n    p -= central;\n    p += p * length(p - vanish);\n    return p;\n}\n\nvoid taper(inout float x, float a, float scale)\n{\n    x += a * x *scale;\n}\n\nvoid taper(inout vec2 x, float a, float scale)\n{\n    x += a * x *scale;\n}\n\nfloat sintau2(float t)\n{\n    // just smoothstepping the triangle\n    return smoothstep(0.0, 1.0, abs(fract(t)*2.0 - 1.0))*2.0 - 1.0;\n}\n\n\n\n// --------------------------------------------------------------------------------------\n\n\nfloat skull(vec3 p)\n{\n    float e = sphere(p , 0.7);\n    if(e > 0.5)\n    \treturn e;\n    p.z =-p.z; // todo: hardwire flip\n         \n    float anim = 0.5 * sintau2(iTime*0.2)+0.5;\n    anim = 0.0;\n    p.x = abs(p.x);\n    vec3 psphere = p*vec3(1.0,1.2,1.0);\n    float r = sphere(psphere , 0.5 );\n    //r = diff(r, sphere(psphere, 0.45));\n\n    vec3 peye = p;\n    taper(peye.y, peye.x-0.3, -4.5*anim);\n    float eye = sphere(peye - vec3(0.15, 0.0, 0.4), 0.18);\n    r = diff(r, eye);\n    //vec3 pjaw = p * vec3(1. - 0.3 * p.y, 1., 1.);\n    vec3 pjaw =p;\n    \n    pjaw.z += pjaw.y * 0.4 + 0.1;\n    \n    float jaw = cylinder((pjaw+vec3(0.,0.3,-0.2)), vec2(0.22,0.1));\n    r = merge(r, jaw);\n    vec3 psocket = p;\n    psocket.z *= 0.5;\n    float socket = torus((psocket-vec3(0.2, 0.0, 0.2)).xzy, vec2(0.18, 0.05));\n    r = merge(r, socket);\n    r = merge(r, jaw);\n    \n    float tooth = cylinder(p + vec3(0.0,0.45,-0.22), vec2(0.2, 0.09));\n    r = merge(r, tooth);\n    vec3 pchin = p-vec3(0.0,-0.6,0.25);\n    float chin = torus82(pchin*vec3(1.0,0.4,1.0), vec2(0.18, 0.02));\n    chin = cylinder(p - vec3(0.0,-0.55,0.25), vec2(0.23, 0.08));\n    \n    r = merge(r, chin);\n    float chin2 = box(p+vec3(0.0,0.44,-0.05), vec3(0.2, 0.2, 0.1));\n    r = merge(r, chin2);\n    r = min(r, 100.0); // failsafe\n    return r;\n}\n\n\nfloat skull2(vec3 p)\n{\n    float s = 0.25;\n    p.z =-p.z; // todo: hardwire flip\n         \n    p.x = abs(p.x);\n    vec3 psphere = p*vec3(1.0,1.2,1.0);\n    float r = sphere(psphere , 0.5*s );\n\n    vec3 peye = p;\n    float eye = sphere(peye - vec3(0.15, 0.0, 0.4)*s, 0.18*s);\n    r = diff(r, eye);\n    \n    vec3 pjaw =p;\n    \n    pjaw.z += pjaw.y * 0.4 + 0.1*s;\n    \n    float jaw = cylinder((pjaw+vec3(0.,0.3,-0.2)*s), vec2(0.22,0.1)*s);\n    r = merge(r, jaw);\n    vec3 psocket = p;\n    psocket.z *= 0.5;\n    float socket = torus((psocket-vec3(0.2, 0.0, 0.2)*s).xzy, vec2(0.18, 0.05)*s);\n    r = merge(r, socket);\n    r = merge(r, jaw);\n    \n    float tooth = cylinder(p + vec3(0.0,0.45,-0.22)*s, vec2(0.2, 0.09)*s);\n    r = merge(r, tooth);\n    vec3 pchin = p-vec3(0.0,-0.6,0.25)*s;\n    float chin = torus82(pchin*vec3(1.0,0.4,1.0), vec2(0.18, 0.02)*s);\n    chin = cylinder(p - vec3(0.0,-0.55,0.25)*s, vec2(0.23, 0.08)*s);\n    \n    r = merge(r, chin);\n    float chin2 = box(p+vec3(0.0,0.44,-0.05)*s, vec3(0.2, 0.2, 0.1)*s);\n    r = merge(r, chin2);\n    r = min(r, 100.0); // failsafe\n    return r;\n}\n\n\nfloat skull(vec3 p, float offset)\n{\n    //p += vec3(0.0,0.0,0.0);\n    \n    p += vec3(0.0, - offset - 1.0, -0.06);\n    p.zx = - p.zx;\n\treturn skull2(p);    \n}\n\n\nfloat skullHigh(vec3 p)\n{\n    float e = sphere(p , 0.7);\n    if(e > 0.5)\n    \treturn e;\n    p.z =-p.z; // todo: hardwire flip\n         \n    float anim = 0.5 * sintau2(iTime*0.2)+0.5;\n    anim = 0.0;\n    p.x = abs(p.x);\n    vec3 psphere = p*vec3(1.0,1.2,1.0);\n    float r = sphere(psphere , 0.5 );\n    r = diff(r, sphere(psphere, 0.45));\n\n    vec3 peye = p;\n    taper(peye.y, peye.x-0.3, -4.5*anim);\n    float eye = sphere(peye - vec3(0.16, 0.0, 0.27), 0.23);\n    r = diff(r, eye);\n    //vec3 pjaw = p * vec3(1. - 0.3 * p.y, 1., 1.);\n    vec3 pjaw =p;\n    \n    pjaw.z += pjaw.y * 0.4 + 0.1;\n    \n    //pjaw = taper(p, vec3(0.), vec3(0., 0., 1.));\n    //taper(pjaw.x, pjaw.z, -0.3);\n    //taper(pjaw.x, pjaw.y, -0.6);\n    //taper(pjaw.xy, pjaw.z, -0.4);\n    //float jaw = roundBox(pjaw+vec3(0.,0.3,-0.2), vec3(0.2,0.1,0.2), 0.07);\n    float jaw = cylinder((pjaw+vec3(0.,0.25,-0.2)), vec2(0.2,0.1));\n    //return jaw;\n    //return jaw;\n    r = pmerge2(r, jaw, 23.);\n    vec3 psocket = p;\n    taper(psocket.y, psocket.x-0.3, -4.5*anim);\n    float socket = torus((psocket-vec3(0.2, 0.0, 0.4)).xzy, vec2(0.18, 0.04));\n    r = smerge(r, socket, 0.08);\n    r = smerge(r, jaw, 0.1);\n    \n    vec3 ptooth = p+vec3(0.0,0.47,-0.26);\n    ptooth.y = abs(ptooth.y);\n    ptooth = (ptooth + vec3(0.,-0.03,0.0)) * 8.;\n    \n    float i = modPolar(ptooth.xz, 20.);\n    ptooth.x *= 2.0;\n    //ptooth.y += i*0.05;\n    ptooth-=vec3(3.,0.,0.0);\n    \n    //taper(ptooth.xz, ptooth.y,  .5);\n    //float tooth = super(ptooth.xzy, 0.1, 0.2, 1.0);\n    float tooth = roundBox(ptooth, vec3(.1,.1,.1), 0.2);\n    //r = tooth;\n    //return tooth;\n    r = smerge(r, tooth, 0.1);\n    vec3 pchin = p-vec3(0.0,-0.6,0.25);\n    float chin = torus82(pchin*vec3(1.0,0.4,1.0), vec2(0.18, 0.02));\n    chin = diff(chin, plane(pchin.xzy+vec3(0.0,0.1,0.0)));\n    r = merge(r, chin);\n    float chin2 = box(p+vec3(0.0,0.44,-0.05), vec3(0.2, 0.2, 0.1));\n    r = smerge(r, chin2, 0.05);\n    r = min(r, 100.0); // railsafe\n    return r;\n}\n\nfloat femur(vec3 p)\n{\n    //p.y = abs(p.y);\n    vec3 pb = p;\n    //pb.z -= pb.y*pb.y*0.1;\n    float c = cylinder(pb-vec3(0.0,0.5,0.0), vec2(0.03, 0.5));\n    float s1 = sphere(p-vec3(-.15,0.0,0.0), 0.15);    \n    c = merge(c,s1);\n    return c;\n}\n\nfloat femurHigh(vec3 p)\n{\n    //p.y = abs(p.y);\n    vec3 pb = p;\n    pb.z -= pb.y*pb.y*0.1;\n    float c = cylinder(pb, vec2(0.03, 0.5));\n    float s1 = sphere(p-vec3(-.15,0.5,0.0), 0.08);    \n    c = smerge(c,s1, 0.1);\n    float s2 = sphere(p+vec3(0.0,0.5,0.0), 0.04);\n    c = smerge(c,s2, 0.1);\n    return c;\n}\n\n\nfloat shin(vec3 p)\n{\n    //p.y = abs(p.y);\n    \n    float c = cylinder(p-vec3(0.0,0.5,0.0), vec2(0.025, 0.5));\n    float s1 = sphere(p-vec3(0.0,0.0,0.0), 0.08);    \n    c = merge(c,s1);\n    return c;\n}\n\n\nfloat foot(vec3 p)\n{\n    vec3 pp = p * vec3(3.0,1.0,1.0);\n    pp.z += 1.5*pp.y;\n    float c = cone(pp, vec3(0.3,0.8,0.15));\n    \n    \n    float s2 = sphere(p, 0.05);\n    \n    c = merge(c,s2);\n    return c;\n}\n\nfloat hand(vec3 p)\n{\n    p = p * 0.8;\n    vec3 pp = p * vec3(1.4,0.65,1.0);\n    //pp.z -= 1.5*pp.y;\n    float c = cone(pp, vec3(0.3,0.2,0.1));    \n    float s2 = sphere(p, 0.05);    \n    c = merge(c,s2);    \n    s2 = sphere(pp+vec3(0.0,0.16,0.0), 0.1);\n    c = merge(c,s2);\n    return c;\n}\n\n\nfloat shinHigh(vec3 p)\n{\n    //p.y = abs(p.y);\n    vec3 pb = p;\n    pb.z -= pb.y*pb.y*0.1;\n    float c = cylinder(pb, vec2(0.025, 0.5));\n    float c2 = cylinder(p-vec3(0.05,0.0,0.0), vec2(0.015, 0.5));\n    c = merge(c,c2);\n    float s1 = sphere(p-vec3(0.0,0.5,0.04), 0.04);    \n    c = smerge(c,s1, 0.1);\n    float s2 = sphere(p+vec3(0.0,0.5,0.0), 0.03);\n    c = smerge(c,s2, 0.1);\n    return c;\n}\n\nfloat spine(vec3 p)\n{\n    vec3 pb = p;\n    float w = -sintau2(p.y+0.2);\n    pb.z -= 0.07*(w-p.y);  // poly ?\n    pb.y = repeat(pb.y, 0.035);\n    float c = cylinder(pb-vec3(0.0,0.0,0.3), vec2(0.017, 0.5)); // for reference\n    float s = sphere(pb,0.035-w*w*0.01);   // use another curve for radius ? \n    c = merge(s,c);\n    c = s;\n    //float b = box(p, vec3(0.5,0.5,0.5));\n    float b = box(p-vec3(0.0,0.25,0.0), vec3(0.5,0.4, 0.5));    \n    c = max(b,c);\n    return c;\n}\n\nfloat member(vec3 p)\n{\n    p.y = abs(p.y);\n    vec3 pb = p;    \n    float c = cylinder(pb, vec2(0.1, 0.5));\n    float s1 = sphere(p-vec3(0.0,0.56,0.0), 0.15);    \n    c = smerge(c,s1,0.1);\n    //float s2 = sphere(p+vec3(0.0,0.5,0.0), 0.2);\n    //c = smerge(c,s2);\n    return c;    \n}\n\nfloat ribCage(vec3 p)\n{\n    vec3 pb = p;    \n    pb.z *= 1.5;\n    float w = sin(p.y*5.);    \n    pb.z -= 0.08*(w-p.y);  // poly ?\n    \n    pb.y = repeat(pb.y, 0.05);\n    float c = cylinder(pb-vec3(0.0,0.0,0.3), vec2(0.017, 0.5)); // for reference\n    float size = w*w *0.1 + 0.1;\n    //float r = 0.035 * (0.3 - 20.0*pb.z, 0.0, 1.0);\n    float r = 0.035 * (0.7 + 1.8*pb.z + (0.8 * p.y - 0.3));\n    float s = torus(pb + vec3(0.0,0.0,size), vec2(size, r));\n    c = merge(s,c);\n    c = s;\n    //float b = box(p-vec3(0.0,0.0,0.0), vec3(0.5,0.5, 0.5));\n    float b = box(p-vec3(0.0,0.25,0.0), vec3(0.5,0.25, 0.5));    \n    \n    c = max(b,c);\n    return c;\n}\n\n\nfloat bricks(vec3 p, float c)\n{\n    p = p.xzy;\n    p.z *= 2.;       \n    p.x += floor(p.z/c) - 0.5 * c;\n    vec2 r = mod(p.zx,c)-0.5*c;            \n    \n    return roundBox(vec3(r.x, p.y, r.y), vec3(c,0.5,c) * 0.41, 0.05);\n}\n\n\nfloat doorsign(vec3 p, float x, float s)\n{\n    s = 0.3;\n    float b1 = roundBox(p-s*vec3(0.0,0.5,0.23)-s*vec3(x,0.0,0.0), s * vec3(0.03,0.2,0.05), s*0.02);    \n    float b2 = roundBox(rotXY(p-s*vec3(0.0,0.5,0.23)-s*vec3(x,0.0,0.0), Pi/3.0), s * vec3(0.03,0.2,0.05), s*0.02);\n    float b3 = roundBox(rotXY(p-s*vec3(0.0,0.5,0.23)-s*vec3(x,0.0,0.0), Pi2/3.0), s * vec3(0.03,0.2,0.05), s*0.02);\n    \n    return  min(min(b1,b2),b3);    \n}\n\nfloat door(vec3 p, float x, float s)\n{   \n    s = 0.3;\n    float door = box(p-s*vec3(0.0,0.5,0.0)-s*vec3(x,0.0,0.0), s*vec3(1.0,0.5,0.5));\n    p = p-s*vec3(0.0,0.5,0.20)-s*vec3(x,0.0,0.0);\n           \n\tp.x = repeat(p.x, s*0.1);\n    float d = roundBox(p, s*vec3(0.04,0.5,0.02), s*0.01);    \n    door = max(door, d);                \n    \n    return door;\n}\n\nfloat archway(vec3 p, float s)\n{    \n    //s = 1.0;\n    s = 0.3;\n    float t = torus88(p.xzy, s*vec2(1.0, 0.1));\n    t = max(t, box(p-s*vec3(0.0,2.0,0.0), s*vec3(2.0)));        \n    \n    //float sp = sphere(p, 1.0);\n    \n    float b = bricks((p-s*vec3(0.0,0.0,0.76)), s*0.2);\n               \n    float r = max(b,t);    \n    //return r;\n    \n    \n    p = p - vec3(0.0,0.0,0.147);\n    float b2 = bricks(p-s*vec3(0.0,0.0,0.29), s*0.2);      \n    \n    float rb = roundBox(p-s*vec3(0.0,0.5,0.0), s*vec3(0.9,0.4,0.5), s*0.1);\n    \n    float c = box(p , s*vec3(5.5,1.5,1.0));\n    b2 = max(b2, c);\n        \n    b2 = diff(b2, rb);\n        \n    r = min(r, b2);    \n    \n    return r;\n}\n\n\nfloat torchesWood(vec3 p)\n{\n    p.y -= 0.13;\n    p.x = repeat(p.x-0.6, 0.6);\n    float t = cylinder(rotYZ(p,-0.8), vec2(0.01,0.05));\n    return t;\n}\n\nfloat torchesCoal(vec3 p)\n{\n    p.y -= 0.175;\n    p.z += 0.04;\n    p.x = repeat(p.x-0.6, 0.6);\n    \n    float t = sphere(p, 0.014);\n    return t;\n}\n\n\nfloat roof(vec3 p, float s)\n{\n    s = 0.3;\n    p = p - vec3(0.0,0.0,0.147);\n    return roundBox(p-s*vec3(0.0,1.5,0.5), s*vec3(5.6,0.03,1.0), s*0.1);\n}\n\nfloat torch(vec3 p)\n{\n    float c = cylinder(p, vec2(0.08, 0.5));\n    \n    float s = sphere((p-vec3(0.0,0.5,0.0))*vec3(1.0,0.6,1.0), 0.12);\n    return min(s, c);\n}\n\nfloat planks(vec3 p, float r, float s)\n{\n    float c = box(p, s*vec3(0.5));\n    r *= s;\n\tp.x = repeat(p.x-r*0.5, r);\n    float d = roundBox(p, vec3(0.45 * r,s*0.5,s*0.01), s*0.01);    \n    return max(c, d);    \n}\n\nfloat crate(vec3 p, float s)\n{\n    float rr = 0.2;\n    float t = planks(p + s*vec3(0.0,0.0,0.5), rr, s);\n    float b = planks(p + s*vec3(0.0,0.0,-0.5), rr, s);\n    float l = planks(p.zxy + s*vec3(0.0,0.0,0.5), rr, s);\n    float r = planks(p.zxy + s*vec3(0.0,0.0,-0.5), rr, s);\n    float f = planks(p.yzx + s*vec3(0.0,0.0,0.5), rr, s);\n    float bk = planks(p.yzx + s*vec3(0.0,0.0,-0.5), rr, s);\n    \n    float a1 = min(t,b);\n    float a2 = min(l, r);\n    float a3 = min(f, bk);\n    return min(min(a1,a2), a3);    \n}\n\nfloat shield(vec3 p)\n{\n    float planks = box(p, vec3(0.5));\n\tp.x = repeat(p.x, 0.1);\n    float d = roundBox(p, vec3(0.04,0.25,0.01), 0.01);    \n    planks = max(planks, d);\n    return planks;\n}\n\n\nmat2 rotFromDir(vec2 dir)\n{\n    dir = normalize(dir);\n    return mat2(dir.y, -dir.x,\n                dir.x, dir.y);\n    \n//    vec2 dirY = vec2(-dirX.y, dirX.x);\n//    return p.x * dirX + p.y * dirY;\n    \n}\n\nfloat usin2(float t)\n{\n    return smoothstep(0.0, 1.0, abs(fract(t)*2.0 - 1.0));    \n}\n\nfloat ucos2(float t)\n{\n    return smoothstep(0.0, 1.0, abs(fract(t+0.25)*2.0 - 1.0));        \n}\n\n\n// simplified version : assume both arms are the same length. Todo: depending on use case,\n// not even the angles are needed.\nbool ik2dof(float a, vec2 end, bool leftHanded, inout float theta, inout float theta2)\n{\n\tfloat maxRadius = a + a;\t\n    float radius2 = dot(end, end);\n    \n    if(radius2 < maxRadius*maxRadius)\n    {\n        // height of triangle\n        float h = sqrt(a*a - 0.25 * radius2);\n        vec2 v = normalize(leftHanded ? rot90(end) : -rot90(end));\n        vec2 p = 0.5 * end  + v * h;        \n        theta = atan(p.y, p.x);        \n        p = end - p;\n        theta2 = atan(p.y, p.x) - theta;\n        return true;\n    }\n    else\n    {\n        theta = theta2 = atan(end.y, end.x);\n        return false;\n    }\n}\n\nvec4 animState;\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1000.0, 50.0);\n\t//res = merge(res, vec2( plane(     pos-vec3(0.,0.02,0.)), 30.0 ));\n\t\n    //res.x = merge(res.x, femur((pos+vec3(-0.2,0.4,0.0)) * 2.0 ));\n    //res.x = merge(res.x, shin((pos+vec3(-0.2,0.4,0.0)) * 2.0 ));\n    \n    //res.x = merge(res.x, foot((pos+vec3(-0.2,0.4,-1.0)) * 2.0 ));\n    //res.x = merge(res.x, hand((pos+vec3(-0.2,0.4,0.0)) * 2.0 ));\n    \n    //res.x = merge(res.x, skull(pos));\n    //res.x = merge(res.x, jelly(pos));\n    float x = sat(animState.w)*0.5;\n    float scale = 1.0;\n    res = merge(res, vec2(archway(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES), scale), STONE));\n    res = merge(res, vec2(torchesWood(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES)), WOOD));\n    res = merge(res, vec2(torchesCoal(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES)), COAL));\n    res = merge(res, vec2(roof(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES), scale), GRANITE));\n    res = merge(res, vec2(door(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES), x, scale), WOOD));\n    res = merge(res, vec2(doorsign(pos-vec3(0.0,0.0,WorldBounds.y-TORCHES), x, scale), SIGN));\n    //res.x = merge(res.x, torch(pos));\n    //res.x = merge(res.x, crate(pos, scale));    \n     \n    //res.x = merge(res.x, skeleton(pos));\n    \n    /*\n    float anim = iTime * 1.0;\n    vec3 pl = pos;\n    pl.x -= 0.2;\n    float pelvis;\n    res.x = merge(res.x, legs(pl, anim, pelvis));\n    \n    pl = pos;\n    pl.x = -pl.x;\n    pl.x -= 0.2;\n    //pl.x += 1.5;\n    \n    res.x = merge(res.x, legs(pl, anim + 0.5, pelvis));\n    res.x = merge(res.x, chest(pos,pelvis));\n    res.x = merge(res.x, skull(pos,pelvis));\n\n/* */\n    \n\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += abs(h*0.4);\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvoid rscene(vec3 ro, vec3 rd, inout vec3 n, inout float t, inout float material)\n{\n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    t = res.x;\n\tmaterial = res.y;\n    if( material >-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        n = calcNormal( pos );\n\t\t\n\t}\n\n    // fog ?\n\t//col *= exp( -0.01*t*t );\n    \n}\n\n///////////////////////// raymarch scene end /////////////////////////\n\nfloat terrainScale(vec2 x)\n{\n    float r = 2.0*max(box(x, WorldBounds, 0.0),0.0);\n    float f = 2.0;\n    for(int i = 0; i < 4; i++)\n    {\n        vec4 obstacle = Obstacles[i];\n        if(obstacle.w > 0.0)\n        {\n            r += f*max(0.2- box(x - obstacle.xy, obstacle.zw, 0.0), 0.0);\n        }\n        else    \n        {\n            r += f*max(0.2-circle(x - obstacle.xy, obstacle.z), 0.0);\n        }       \n\t}\n    float k = 1.5*max(-circle(x-vec2(0.0, WorldBounds.y), 0.7), 0.0);\n    return clamp(r-k,0.01, 1.0);\n}\n\n#define SC (250.0)\n\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat hash2( vec2 n )\n{\n    float a = sin(n.x)*43758.5453123;\n    float b = sin(n.y)*22578.1459123;\n    return fract(a+b);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    //f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n\nfloat ridgeHelper(float h, float offset)\n{\n    h = abs(h);\n    h = offset - h;\n    h = h * h;\n    return h;\n}\n\nfloat ridge(vec2 x)\n{\n\tfloat sum = 0.0;\n\tfloat freq = 0.4;\n\tfloat amp = 0.5;\n\tfloat prev = 1.0;\n\t\n\tfor(int i=0; i < 6; i++) {\n\t\tfloat n = ridgeHelper(noise(x * freq + float(i)), 0.0);\n        x = m2*x;\n\t\tsum += n*amp*prev;\n\t\tprev = n;\n\t\tfreq *= 2.6;\n\t\t//freq += Gap;\n\t\tamp *= 0.7;\n\t}\n    return sum;\t\n}\n\n\n\nfloat terrainX(vec2 uv)\n{\n    return ridge(uv);\n}\n\n\n\nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax, inout int n)\n{\n    float t = tmin;\n\tfor( int i=0; i<100; i++ )\n\t{\n        n = i;\n        vec3 pos = ro + t*rd;\n        float h = terrainX( pos.xz )*terrainScale(pos.xz)*2.0;\n \t\th = pos.y - h;       \n\t\tif( h<(0.0) || t>tmax ) break;\n\t\tt += 0.1*h;        \n\t}\n\n\treturn t;\n}\n\nconst float kMaxT = 5000.0*SC;\n\n\nvec3 terrainXNormal(vec2 pos)\n{\n    float t = 0.001;\n    vec2  eps = vec2( 0.2*t, 0.0 );\n    return normalize( vec3( terrainX(pos-eps.xy) - terrainX(pos+eps.xy),\n                            2.0*eps.x,\n                            terrainX(pos-eps.yx) - terrainX(pos+eps.yx) ) );\n}\n\n\nvec3 pointLight(vec3 color, vec3 light, vec3 lcolor, vec3 position, vec3 normal, vec3 eye, float diff, float spec, float specPow, float falloff)\n{\n\tvec3 direction = light - position;\n\tfloat dist = length(direction);\n\tdirection = normalize(direction);\n\tfloat ldn = dot(normal, direction);\n\tfloat d = sat(ldn);\n\n\tfloat rolloff = 0.3;\n\t\n\t// velvet, probably could also be called tangential like in blender\n\tfloat velvet = smoothstep(-rolloff,1.0,ldn) - smoothstep(0.0,1.0,ldn);\n\tvelvet = sat(velvet)*0.1;\n\n\t\n\t\n\tvec3 eyeDir = eye - position;\n\teyeDir = normalize(eyeDir);\n\t\n    \n\tvec3 r = normalize(eyeDir + direction);\n\tspec = spec*pow(sat(dot(r, normal)), specPow);\t\t\n\t\n\t//s = pow(dot(r, normal), specularPower);\t<- this gives a warning about the first argument of pow.\n\t\n\t\n\t\n\tfloat attenuation = sat(1.0 - dist / falloff);\n\t\t\n\tvec3 result = diff*d * color * lcolor * attenuation;\n\tresult += spec * lcolor * attenuation;\n\n\treturn result;\n}\n\nvec3 dirLight(vec3 color, vec3 ldir, vec3 lcolor, vec3 position, vec3 normal, vec3 eye, float diff, float spec, float specPow)\t\n{\n\tfloat ldn = dot(normal, ldir);\n\tfloat d = sat(ldn);\n\t\n\tvec3 eyeDir = eye - position;\n\teyeDir = normalize(eyeDir);\n\t\n\t// ... or Blinn\n\tvec3 r = normalize(eyeDir + ldir);\n\tspec = spec * pow(sat(dot(r, normal)), specPow);\t\t\n\t\t\n\tvec3 result = diff * color * lcolor;\n\t//result = 0;\n\t\n\tresult += spec * lcolor;\n\treturn result;\n}\n\nfloat distance2(vec3 ray, vec3 p, inout float lambda)\n{\n    /*\n    float lambda = sqrt(dot(ray, p) / dot(ray, ray));    \n    p = ray * lambda - p;\n    return dot(p,p);\n/* */\n    \n    \n  \tvec3 v = normalize(ray);\n    vec3 w = p;\n    float c1 = dot(w,v);\n    float c2 = dot(v,v);\n    lambda = c1 / c2;\n\n    vec3 Pb = lambda * v;\n    return distance(p, Pb);    \n}\n\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1000.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n\nfloat drawLight(vec3 p, vec3 o, vec3 ray, float range, float maxt)\n{\n    ray = normalize(ray);    \n    float dsphere = raySphereIntersect(o, ray,p, range*2.0);\n    if(dsphere > maxt)\n        return 0.0;\n\t// distance to light\n    p = p-o;    \n    float lambda;\n\tfloat ld = distance2(ray, p, lambda);\n    //if(lambda > maxt)\n      //  return 0.0;\n    float fall = exp(-ld/range)*sat(1.0 - ld/range);\n\t                    \n\t//float fall = sat((range - ld)/range);\n    \n\treturn sat(fall * fall);\n}\n\nvec3 torch(float i)\n{\n    float x = noise(vec2(iTime*9.0, i));\n    return mix(vec3(1.0, 0.9, 0.2), vec3(0.9,0.7,0.01), x);\n}\n\nvec4 signColor(float x)\n{\n    return (x < 0.0 ? Red : Green) * abs(x);        \n}\n\nvec3 playerPosition;\nvec2 playerHeading;\n\n\nconst float pelvisHeight = 1.2;\nconst float thighLength = 0.8;\n\nbool ik2dofX(float a, vec2 end, bool leftHanded, inout vec2 dir1, inout vec2 dir2)\n{\n\tfloat maxRadius = a + a;\t\n    float radius2 = dot(end, end);\n    \n    if(radius2 < maxRadius*maxRadius)\n    {\n        // height of triangle\n        float h = sqrt(a*a - 0.25 * radius2);\n        vec2 v = normalize(leftHanded ? rot90(end) : -rot90(end));\n        dir1 = 0.5 * end  + v * h;        \n        \n        dir2 = end - dir1;\n        \n        return true;\n    }\n    else\n    {\n        dir1 = dir2 = normalize(end) * a;        \n        return false;\n    }\n}\n\n\n\nvoid legAnim(float height, float thigh, vec2 pelvis, float feetAnim, float animBlend, \n             inout float hipDelta,\n             inout float pelvisDelta, inout vec2 knee, inout vec2 ankle)\n{    \n    vec2 hip = pelvis;    \n    pelvisDelta = sintau2(2.0*feetAnim+0.5) * (0.025 * height) * animBlend;\n    float hipy = hip.y;\n    hipDelta = sintau2(feetAnim+0.875) * (0.05 * height) * animBlend;\n    hipDelta += pelvisDelta;\n    hip.y += hipDelta;\n    vec2 feetPos = pelvis;\n    feetPos.y -= height;\n    float step = height * 1.2;        \n    if(feetAnim < 0.5)\n    {        \n        float f = feetAnim * 2. - 0.5;\n        feetPos.x = pelvis.x - step * f * animBlend;\n    }\n    else\n    {        \n        float f = (feetAnim - 0.5) * 2.0;\n        feetPos.x = pelvis.x + step * (f - 0.5) * animBlend;\n        float h = step * 0.3;\n        \n        float hh = 1.0 -ucos2(f);\n        f = f * 2. - 1.;        \n        //hh *= smoothstep(0.,1., f);\n        hh = sqrt(1.-f*f);  // half circle, better pronounced\n        //hh = f;\n        feetPos.y = pelvis.y - height + hh * h * animBlend;\n    }\n        \n    float pointSize = height * 0.02;\n    // end effector, relative\n    vec2 end = feetPos - hip;   \n    \n    //float theta, theta2;    \n    //bool ok = ik2dof(thigh, end, false, theta, theta2);   \n    \n    ik2dofX(thigh, end, false, knee, ankle);    \n}\n\n\nfloat legs(vec3 p, float anim, inout float pelvisDelta)\n{\n    anim = fract(anim);   \n    //anim = fract(state(INPUT1).w);\n    vec2 pelvis = vec2(0.0,0.0);\n    float animBlend = animState.y;    \n    float hipDelta;\n\t//void legAnim(float height, float thigh, vec2 pelvis, float feetAnim, float animBlend, inout float pelvisDelta)\n    vec2 knee, ankle;\n    legAnim(pelvisHeight, thighLength, pelvis, anim, animBlend, hipDelta, pelvisDelta, knee, ankle);\n    \n    //debug1 = vec4(pelvisDelta, anim, ankle);\n    mat2 m = rotFromDir(knee);\n    vec3 offset = -vec3(0.0,hipDelta,0.0);\n    //float r = femur(rotYZ(p+vec3(-0.2,0.4,0.0),anim) * 2.0 );\n    float r = femur((rotYZ(p+offset,transpose(m))) * 2.0 );\n    \n    vec3 kneepos = rotYZ(-vec3(0.0,0.5,0.0), m);\n    m = rotFromDir(ankle);    \n            \n    r = merge(r, shin((rotYZ(p+kneepos+offset,transpose(m))) * 2.0 ));\n    \n    vec3 anklePos = rotYZ(-vec3(0.0,0.5,0.0), m);\n    \n    r = merge(r, foot((p+kneepos+anklePos+offset) * 2.5));    \n    \n    return r;\n}\n\nfloat arm(vec3 p, float anim, float animscale, inout vec3 handPos)\n{    \n    p.y -= 0.5;\n    anim = usin2(fract(anim));\n    //p = rotXY(p, 0.2);\n    vec2 upperDir = normalize(vec2(1.0-anim, animscale > 0.0 ? -anim: -anim - 1.0));\n    mat2 upperM = rotFromDir(upperDir);\n    float r =femur(rotYZ(p, transpose(upperM)) * 2.5 );\n    \n    vec2 lowerDir = normalize(vec2(1.0, animscale*anim*2.0));\n    mat2 lowerM = rotFromDir(lowerDir);\n    \n    \n    vec3 elbowPos = rotYZ(-vec3(0.0, 0.4, 0.0), upperM);\n    \n    r = merge(r, shin(rotYZ(p+elbowPos, transpose(lowerM))* 2.5));\n    \n    handPos = rotYZ(-vec3(0.0,0.4,0.0), lowerM);\n    handPos += elbowPos;\n    r = merge(r, hand(-(p+handPos) * 2.5));    \n    return r;\n}\n\nfloat chest(vec3 p, float pelvis)\n{\n    p.y -= pelvis;\n    p += vec3(0.0,-0.23,0.05);\n    p.zx = -p.zx;    \n    \n    float r = spine((p) * 1.0 );\n\n    r = merge(r, ribCage(p) * 2.0 );\n    return r;\n}    \n\n\nmat2 headingRot;\n\nvec2 mapSkeleton( in vec3 pos )\n{\n    vec2 res = vec2( 1000.0, 30.0 );\n    float scale = 10.0;    \n    \n    pos -= playerPosition;\n    pos *= scale;    \n    pos.y -= 1.2;\n    pos = rotXZ(pos, headingRot);\n            \n    float pelvis = -0.5;\n    float anim = animState.x;\n            \n    vec3 pl = pos;\n    pl.x -= 0.2;\n    \n    res.x = merge(res.x, legs(pl, anim, pelvis));\n    \n    pl = pos;\n    pl.x = -pl.x;\n    pl.x -= 0.2;\n    //pl.x += 1.5;\n    \n    res.x = merge(res.x, legs(pl, anim + 0.5, pelvis));\n \n\t\n    res.x = merge(res.x, chest(pos,pelvis));\n    res.x = merge(res.x, skull(pos,pelvis));\n    \n    \n    vec3 handPos;\n    \n     pl = pos;\n    pl.y -= pelvis + 0.2;\n    pl.x -= 0.25;\n    \n    res.x = merge(res.x, arm(pl, anim, -1.0, handPos));\n    \n    pl = pos;\n    pl.y -= pelvis + 0.2;\n    pl.x = -pl.x;    \n    pl.x -= 0.25;\n    //pl.x += 1.5;\n    \n    res.x = merge(res.x, arm(pl, anim, 1.0, handPos));\n    \n    \n    res.x /= scale;\n    return res;\n}\n\nvec3 calcNormalSkeleton( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    mapSkeleton(pos+eps.xyy).x - mapSkeleton(pos-eps.xyy).x,\n\t    mapSkeleton(pos+eps.yxy).x - mapSkeleton(pos-eps.yxy).x,\n\t    mapSkeleton(pos+eps.yyx).x - mapSkeleton(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec2 castRaySkeleton( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += abs(h*0.4);\n\t    vec2 res = mapSkeleton( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nvoid mainImage( out vec4 O,  vec2 frag )\n{\n    vec4 camera = state(CAMERA);\n    vec4 mouse = state(MOUSE);\n    vec4 mouseTime = state(MOUSETIME);\n    \n    O = vec4(0.0);\n                 \n    vec2 uv = frag / iResolution.y;    \n        \n    vec3 eye, ray;\n    toWorldP(uv, camera, eye, ray);\n    \n    float lambda;\n    uv = intersectGroundPlane(eye, ray, lambda);\n    //uv = toWorldP(uv, camera);\n    \n    vec2 p = ceil(uv*10.0);\n    vec4 ground = 0.2*(.5 + .5*mod(p.xxxx + p.y, 2.));\n    //O = ground;\n    \n    vec2 U;\n    \n    // game state    \n    \n    vec2 position = state(POSITION).xy;\n    vec2 velocity = state(VELOCITY).xy;\n    vec4 feet = state(FEET);\n    vec2 heading = state(HEADING).xy;   \n    vec4 action = state(ACTION);\n \n    \n    //blend(O, circle(uv - position, PLAYERSIZE), transparent(Green));\n    //blend(O, arrow(uv, position, position + PLAYERSIZE * heading), transparent(Yellow));\n    \n    if(action.x > 0.0)\n    {\n        vec4 c = action.w > 0.0 ? Red : Green;\n        float r = iTime - action.y;\n        \n        //blend(O, circleLine(uv - (position + PLAYERSIZE * heading * 2.0), (r + 0.1) * PLAYERSIZE, PLAYERSIZE * 0.1), transparent(c));\n        //blend(O, circle(uv - (position + PLAYERSIZE * heading * 2.0), (r + 0.1) * PLAYERSIZE), transparent(c));\n    }\n \n    vec4 interactive1 = state(INTERACTIVE1);\n    vec4 interactive2 = state(INTERACTIVE2);\n\n\n        \n    /*\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 0.0), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive1.x > 0.0 ? Yellow : Black);\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 0.2), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive1.y > 0.0 ? Yellow : Black);\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 0.4), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive1.z > 0.0 ? Yellow : Black);\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 0.6), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive1.w > 0.0 ? Yellow : Black);\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 0.8), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive2.x > 0.0 ? Yellow : Black);\n    blend(O, circle(uv - vec2(mix(-WorldBounds.x, WorldBounds.x, 1.0), WorldBounds.y - PLAYERSIZE-TORCHES), PLAYERSIZE), interactive2.y > 0.0 ? Yellow : Black);                                                                \n/* */\n\t\n    vec4 obstacle = state(OBSTACLE);\n    animState = state(ANIM);\n    /*\n    for(int i = 0; i < OBSTACLES; i++)\n    {        \n        vec4 obstacle = Obstacles[i];\n        if(i == OBSTACLES - 1)\n            obstacle.x += sat(animState.w)*0.5;\n        if(obstacle.w > 0.0)\n        {\n            blend(O, box(uv - obstacle.xy, obstacle.zw, 0.0), transparent(Yellow));                \n        }\n        else    \n        {\n            blend(O, circle(uv - obstacle.xy, obstacle.z), transparent(Yellow));\n        }        \n        \n    }\n    /* */\n    \n    //blend(O, circle(uv - feet.zw, 0.03), transparent(Yellow));\n    //blend(O, circle(uv - feet.xy, 0.03), transparent(Purple));\n       \n    // keyboard dump, warning, costly\n    \n    //dumpKeyboard(O, frag);\n    \n    // debug output\n    \n    vec4 frame = state(FRAME);        \n    vec4 gui = state(GUI1);   \n          \n    \n    \n    //debugPrint(O, frag, 22, mouse);\n    \n    \n    //blend(O, PrintValue(gridCoord(frag, 0, 0) , length(velocity), 6., 3.), Red);\n    //blend(O, PrintValue(gridCoord(frag, 10, 0), position.y, 6., 3.), Green);\n    //blend(O, PrintValue(gridCoord(frag, 20, 0), camera.z, 6., 3.), Yellow);\n    \n    // world bounds\n    /* \n    blend(O, -box(uv, WorldBounds + PLAYERSIZE, 0.1), transparent(transparent(Red)));\n    \n    blend(O, circle(uv - camera.xy , 0.5 * camera.z), transparent(transparent(Blue)));\n    \n    blend(O, arrow(uv, position, position + velocity*0.5), transparent(Orange));\n    /* */\n\n    if(mouse.w > 0.)\n    {\n        vec2 a = toWorld(mouse.xy / iResolution.y, camera);\n        vec2 b = toWorld(mouse.zw / iResolution.y, camera);\n        //if(distance(a,b) > 0.1)\n        //blend(O, arrow(uv, b, a), transparent(Purple));\n    }        \n       \n    //O = mix(O, White, terrainscale);    \n    int nn;\n    //ray = normalize(ray);\n    float ff = intersect(eye, ray, 0.0, 5.0, nn);\n    vec3 tpos = ff * ray + eye;\n    float v = terrainX(tpos.xz)*terrainScale(tpos.xz);\n    vec3 tn = terrainXNormal(tpos.xz);\n    \n    float ts = sat(terrainScale(tpos.xz));\n    vec3 tcol = mix(Gray.rgb, vec3(0.01,0.2,0.01), sat(tn.y*0.7-0.3*ts));\n    \n    tcol *= vec3(0.9, 0.9, 0.9);\n    \n    tn = mix(vec3(0.0,1.0,0.0), tn, ts);\n    float NdotL = dot(tn, normalize(vec3(0.4, 0.8, 0.2)));\n    //O.xyz = mix(O.xyz, tcol*sat(NdotL), 1.0); // colt.xyz               \n \n    \n    vec3 nor;\n    float t;\n    float m;\n    rscene(eye, ray, nor, t, m);\n    \n    vec3 pos = eye + ff * ray;\n    float spec = 0.0;\n    vec3 mcol = tcol;\n    if(t < ff)\n    {\n    \tpos = eye + t * ray;\n        \n        int n = int(floor(m));\n        mcol = Material[n].rgb;\n        spec = Material[n].w;\n        \n        vec2 xx = m > STONE ? pos.xz :pos.xy;\n        if(m > SIGN)\n        {\n        \tfloat v = 0.3 * fbm(10.*xx);\n        \tmcol += m > STONE ? v*v : v;\n        }\n        ff = t;\n    }\n    else\n    {\n        nor = tn;\n    }\n    playerPosition = vec3(position.x, 0.0, position.y);\n    //ray = normalize(ray);    \n    /*\n    float dsphere = raySphereIntersect(eye, ray, playerPosition, 0.01);\n    if(dsphere < 0.0)\n    {\n        O = Red;\n        return;\n    }\n\t/* */\n\n    playerHeading = heading;\n    headingRot = rotFromDir(heading);\n\n    vec2 c = castRaySkeleton(eye, ray, 20.0);\n    if(c.x < ff)\n    {\n        pos = c.x * ray + eye;\n        mcol = Material[int(BONE)].rgb;\n        spec = Material[int(BONE)].w;\n        nor = calcNormalSkeleton(pos);\n        //O.rgb = nor * 0.5 + 0.5;\n        //return;\n        ff = c.x;\n    }\n    \n    \n    float currentZ = ff / length(ray);\n         \n    vec3 col;\n    \n    vec3 lpos = vec3(position.x,0.2,position.y) + rotXZ(vec3(0.04, 0.0, 0.04), transpose(headingRot));\n\t\n    col *= 0.1;\n \tfloat specPow = max(spec, 0.0)*100.0+1.0;\n    //vec3 dirLight(vec3 color, vec3 ldir, vec3 lcolor, vec3 position, vec3 normal, vec3 eye, float diff, float spec, float specPow, float falloff)\t\n    vec3 lightDir = normalize(vec3(-0.2, 1.0, -0.3));\n    vec3 moon = vec3(0.02, 0.02, 0.4);\n    col += dirLight(mcol, lightDir, moon, pos, nor, eye, 0.5, 0.4, specPow);\n    \n\t//vec3 pointLight(vec3 color, vec3 light, vec3 lcolor, vec3 position, vec3 normal, vec3 eye, float spec, float falloff)\n \n    float lightHeight = 0.175;\n    \n    vec3 lcolor = torch(0.0);\n    col += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7);\n       \n    col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n    col += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7);\n    \n\tif(interactive1.x > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 0.0), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(1.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\tif(interactive1.y > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 0.2), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(2.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\tif(interactive1.z > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 0.4), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(3.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\tif(interactive1.w > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 0.6), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(4.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\tif(interactive2.x > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 0.8), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(5.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\tif(interactive2.y > 0.0)\n\t{\n\t\tlpos = vec3(mix(-WorldBounds.x, WorldBounds.x, 1.0), lightHeight, WorldBounds.y - PLAYERSIZE - TORCHES); lcolor = torch(6.0); \n\t\tcol += pointLight(mcol, lpos, lcolor, pos, nor, eye, 0.7, 0.6, specPow, 0.7); col += drawLight(lpos, eye, ray, 0.1, currentZ) * lcolor;\n\t}\n\n     \n    \n    /*\n    float delta = raymarch.w - ff;\n    \n    \n    //O = error;\n    //return;\n    \n    if(delta < 0.0)\n    {\n\t    O.rgb = raymarch.rgb;\n    }\n    \n    float t = min(t, ff);\n    */\n    \n    //col *= exp( -0.5*ff*ff );\n    \n   // GUI\n    float buttonRadius = 0.07 * iResolution.y;\n    vec2 buttonPos = vec2(iResolution.x - buttonRadius, buttonRadius*1.5);\n    float minus = 0.5 + 0.5 * solid(box(frag - buttonPos, vec2(buttonRadius * 0.5, buttonRadius * 0.1), 0.));\n    minus = minus * (gui.y < 0.0 ? 2.0 : 1.0);\n    blend(O, circle(frag - buttonPos, buttonRadius), vec4(Gray.rgb * minus, 1.0));\n    buttonPos.y += 2.2 * buttonRadius;\n    float plus = min(box(frag - buttonPos, vec2(buttonRadius * 0.5, buttonRadius * 0.1), 0.),\n                       box(frag - buttonPos, vec2(buttonRadius * 0.1, buttonRadius * 0.5), 0.));\n    plus = (0.5 + 0.5 * solid(plus)) * (gui.x < 0.0 ? 2.0 : 1.0);\n    blend(O, circle(frag - buttonPos, buttonRadius), vec4(Gray.rgb * plus, 1.0));\n    \n    \n    vec4 gameState = state(GAMESTATE);\n\n    col = sqrt(col);\n   \n    O.rgb = mix(O.rgb, col, 0.6);\n    \n    if(gameState.x > 0.0)\n    {\n        float dt = iTime - gameState.y;\n        if(gameState.x < 2.0)\n        {\n            // fade in\n            O = mix(O, vec4(0.0),sat(1.0 -  dt / 4.0));\n        }\n        else\n        {\n            // fade out\n            O = mix(O, vec4(0.0), sat(dt / 4.0));\n        }        \n    }\n        \n           \n    // debug output state buffer\n    //debugPrint(O, frag, 23, interactive2);\n    //debugPrint(O, frag, 24, state(VELOCITY));\n    //debugPrint(O, frag, 25, heading.xxyy);\n    //debugPrint(O, frag, 26, debug1);\n    \n \n    float dither = hash2(frag+iTime);\n        \n    O.rgb += vec3(dither) /100.0;\n#ifdef DEBUG    \n    if(frag.y < 30.)\n    {        \n\t//\tO = mix(O, vec4(texelFetch(STATE, ivec2(frag*0.1), 0)), 0.4);\n    }\n#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Basic input, movement, collision, debug output\n    by unbird\n\n\tBuffer A\n   \n\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    self reference : https://www.shadertoy.com/view/MdSBDw\n*/\n\n\n#define MINZOOM 0.35\n#define MAXZOOM 2.4\n//#define MAXSPEED 1.0\n#define MAXSPEED 0.5\n#define ANIMSPEED 0.05\n#define ANIMBLENDSPEED 0.8\n\n#define KEYBOARD iChannel2\n#define STATE iChannel0\n\nconst ivec2 DEBUG1    = ivec2(0,1);\nconst ivec2 POSITION  = ivec2(0,0);\nconst ivec2 VELOCITY  = ivec2(1,0);\nconst ivec2 FRAME     = ivec2(2,0);\nconst ivec2 FEET      = ivec2(3,0);\nconst ivec2 FEETSTATE = ivec2(4,0);\nconst ivec2 HEADING   = ivec2(5,0);\nconst ivec2 CAMERA    = ivec2(6,0);\nconst ivec2 MOUSE     = ivec2(7,0);\nconst ivec2 MOUSETIME = ivec2(8,0);\nconst ivec2 CAMERAMOVE= ivec2(9,0);\nconst ivec2 ACTION    = ivec2(10,0);\nconst ivec2 INTERACTIVE1 = ivec2(11,0);\nconst ivec2 INTERACTIVE2 = ivec2(12,0);\nconst ivec2 INTERACTIVE3 = ivec2(13,0);\nconst ivec2 ANIM         = ivec2(14,0);\nconst ivec2 GAMESTATE    = ivec2(15,0);\nconst ivec2 ARMANIM      = ivec2(16,0);\nconst ivec2 GUI1         = ivec2(20,0);\n\nconst ivec2 OBSTACLE  = ivec2(64,0);\n\n\n#define IF(a) if(p.x == a .x)\n\nconst float PLAYERSIZE = 0.1;\nconst float TORCHES = 0.3;\n\nvec4 state(ivec2 p)\n{\n    return vec4(texelFetch(STATE, p, 0));\n}\n\nvoid store(inout vec4 O, ivec2 p, ivec2 state, vec4 value)\n{\n    if(p == state)\n        O = value;    \n}\n\n#define STORE(s, v) store(O, p, s, v);\n\nconst vec2 WorldBounds = vec2(1.5,3.0);\n\nconst int OBSTACLES = 7;\n\nconst vec4 Obstacles[] = vec4[]\n(\n    vec4(1.0, -2.1, 1.2, 0.3),\n    vec4(-0.9, -1.2, 0.4, 0.0),\n    vec4(-0.9, 0.5, 1.3, 0.5),\n    vec4(1.5, 1.7, 0.6, 0.0),\n    vec4(1.0, 3.0, 0.7, 0.3),\n    vec4(-1.0, 3.0, 0.7, 0.3),\n    vec4(0.0, 2.8, 0.25, 0.03)\n);\n\nconst float INTERACTIVES = 6.0;\nconst float INTERACTIVESIZE = 0.05;\n\n\nconst float Pi     = 3.1415926535897932384626433832795;\nconst float Pi2    = 2.0 * Pi;\nconst float PiHalf = 0.5 * Pi;\nconst float RadToDegree = 180.0 / Pi;\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\nconst int KEY_ESC   = 27;\nconst int KEY_PAUSE = 19;\nconst int KEY_NUMPLUS = 107;\nconst int KEY_NUMMINUS = 109;\n\nconst int KEY_NUMUP = 104;\nconst int KEY_NUMDOWN = 98;\nconst int KEY_NUMLEFT = 100;\nconst int KEY_NUMRIGHT = 102;\n\nfloat sat(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nbool key(int ascii)\n{\n\treturn texelFetch(KEYBOARD, ivec2(ascii, 0), 0).r > 0.0;  \n}\n\nfloat kross(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 cis(float a)\n{\n    return vec2(cos(a), sin(a));\n}\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sqr(vec2 x)\n{\n    return dot(x,x);\n}\n\nvec2 safeNormalize(vec2 x)\n{\n    if(dot(x,x) > 0.001)\n    \tx = normalize(x);    \n    return x;\n}\n\nfloat aspect()\n{\n    return iResolution.x / iResolution.y;\n}\n\nvec2 toWorld(vec2 uv, vec4 camera)\n{\n    vec2 centerOffset = vec2(0.5 * aspect(), 0.5);\n    return (uv - centerOffset) * camera.z + camera.xy;\n}\n\n\nvoid toWorldP(vec2 uv, vec4 camera, inout vec3 eye, inout vec3 ray)\n{\n    eye = vec3(camera.x, 2.0, camera.y-2.0);\n    vec3 view = vec3(camera.x, 0, camera.y);\n        \n    vec3 forward = view - eye;\n    \n    eye = view - forward * (camera.z + 0.1)*0.3;\n    \n    forward = normalize(forward);\n    \n    vec3 right = -normalize(cross(forward, vec3(0.0,1.0,0.0)));\n    vec3 up = -normalize(cross(right, forward));\n                               \n\t//right *= aspect();\n          \n    float fov = camera.z;\n    fov = 1.0;\n\n\tvec2 centerOffset = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    uv = uv - centerOffset;    \n                           \n\tray = forward + (uv.x * right + uv.y * up) * fov;\n}\n\nvec2 intersectGroundPlane(vec3 o, vec3 ray, inout float k)\n{\n    k = - o.y / ray.y;\n    vec3 p = o + ray * k;    \n    return p.xz;\n}\n\nvec2 toWorldP(vec2 uv, vec4 camera)\n{\n    vec3 eye, ray;\n    toWorldP(uv, camera, eye, ray);\n    float dummy;\n    return intersectGroundPlane(eye, ray, dummy);\n}\n\n\nvec2 toScreen(vec2 uv, vec4 camera)    \n{\n    vec2 centerOffset = vec2(0.5 * aspect(), 0.5);\n    return (uv - camera.xy)/ camera.z + centerOffset;\n}\n\nfloat box(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n\n// check and displace\nbool collision(inout vec2 position, float radius, vec4 obstacle, bool displace)\n{\n    // rectangle\n    if(obstacle.w > 0.0)\n    {\n        vec2 dd = vec2(0.01, 0.00);\n        // we can abuse this for collision checking / displacement\n        float box00 = box(position - obstacle.xy, obstacle.zw + radius, radius);        \n        if(box00 < 0.0)\n        {\n            if(displace)\n            {\n                float box10 = box(position + dd- obstacle.xy, obstacle.zw + radius, radius);\n                float box01 = box(position + dd.yx - obstacle.xy, obstacle.zw + radius, radius);\n                vec2 n = normalize(vec2(box10 - box00, box01 - box00));            \n                position = position - box00 * n;            \n            }\n            return true;\n        }\n    }\n    // circle\n    else    \n    {\n        vec2 d = position - obstacle.xy;\n        float dd = length(d);\n        if(dd < radius + obstacle.z)\n        {\n            if(displace)\n            \tposition.xy = obstacle.xy + normalize(d) * (radius + obstacle.z);\n            return true;\n        }\n    }       \n    return false;\n}\n\nvoid limit(inout vec2 v, float max)\n{\n    float r = dot(v,v);\n    if(r > max*max)\n    {\n        v = v / sqrt(r) * max;\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 uv )\n{\n    if(uv.y > 10.)\n        return;\n    ivec2 p = ivec2(uv);    \n    vec2 frag = uv;\n    \n    O -= O;\n    vec2 x = vec2(uv) / vec2(iResolution.yy);\n    float r = length(x * 2. - 1.);\n    O.g = r < 0.5 ? 1.0 : 0.0;\n    \n    vec2 dir = vec2(0.);\n    if(key(KEY_RIGHT) || key(KEY_D))\n        dir.x = 1.;    \n    if(key(KEY_LEFT)|| key(KEY_A))\n        dir.x = -1.;\n    if(key(KEY_UP)|| key(KEY_W))\n        dir.y = 1.;   \t\n    if(key(KEY_DOWN)|| key(KEY_S))\n        dir.y = -1.;\n    \n    vec2 cameraDir = vec2(0.);\n    // manual camera movement\n    if(key(KEY_NUMRIGHT))\n        cameraDir.x = 1.;    \n    if(key(KEY_NUMLEFT))\n        cameraDir.x = -1.;\n    if(key(KEY_NUMUP))\n        cameraDir.y = 1.;   \t\n    if(key(KEY_NUMDOWN))\n        cameraDir.y = -1.;                      \n    \n    \n    float zoomin = 0.0;\n    if(key(KEY_NUMPLUS))\n        zoomin = -1.0;\n    else if(key(KEY_NUMMINUS))\n        zoomin = 1.0;\n        \n    vec4 obstacle = state(OBSTACLE);\n    obstacle = vec4(1.0, 0.5, 0.1, 0.15);\n    \n    vec4 camera = state(CAMERA);\n    vec4 cameraMove = state(CAMERAMOVE);\n    \n    vec4 mouse = state(MOUSE);\n    vec4 mouseTime = state(MOUSETIME);\n            \n    if(mouse.w <= 0.0 && iMouse.w > 0.0)\n    {\n        mouseTime.x = iTime;        \n        mouseTime.z = 1.0;\n    }\n    else if (mouse.w > 0.0 && iMouse.w < 0.0)\n    {\n        mouseTime.z = 0.0;\n    }\n    vec4 oldMouse = mouse;\n    mouse = iMouse;\n    \n    vec4 gui = state(GUI1);\n    bool guiInteraction = false;\n    // GUI\n    if(mouse.z > 0.)\n    {\n        \n        float buttonRadius = 0.07 * iResolution.y;\n        vec2 buttonPos = vec2(iResolution.x - buttonRadius, buttonRadius*1.5);\n        float minus = max(circle(mouse.xy - buttonPos, buttonRadius),\n                          circle(mouse.zw - buttonPos, buttonRadius));\n        \n        \n        buttonPos.y += 2.2 * buttonRadius;\n        float plus = max(circle(mouse.xy - buttonPos, buttonRadius),\n                         circle(mouse.zw - buttonPos, buttonRadius));\n        gui.xy = vec2(plus, minus);    \n        if(plus < 0.0)\n        {\n            zoomin = -1.0;\n            guiInteraction = true;\n        }\n        if(minus< 0.0)\n        {\n            zoomin = 1.0;\n            guiInteraction = true;\n        }\n        gui = vec4(plus, minus, mouse.xy);         \n    }\n    else\n        gui = vec4(0.0);\n    \n    float mouseDownTime = iTime - mouseTime.x;\n    mouseTime.y = mouseDownTime;\n    \n    vec4 mouseWorld = vec4(toWorldP(mouse.xy / iResolution.y, camera), toWorldP(abs(mouse.zw) / iResolution.y, camera));\n        \n    vec2 position = state(POSITION).xy;\n\tvec4 heading = state(HEADING);\n    \n    vec4 action = state(ACTION);\n\n    vec4 interactive1 = state(INTERACTIVE1);\n    vec4 interactive2 = state(INTERACTIVE2);\n    vec4 animState = state(ANIM);\n    \n    if(action.x > 0.0)\n    {\n        // action animation\n        if(iTime - action.y > 0.8)\n        {\n            action.x = 0.0;\t\t\t\n        }\n    }\n    else\n    if (oldMouse.w > 0.0 && mouse.w < 0.0 && !guiInteraction)\n    {\n        if(action.x < 1.0)\n        {\n            vec2 delta = abs(mouse.zw) - oldMouse.xy;            \n            if(mouseDownTime < 0.6 && dot(delta, delta) > iResolution.x * 0.1)\n            {                \n                action.x = 1.0;\n                action.y = iTime;                \n                action.zw = delta;\n                action.w = kross(mouseWorld.xy - position, mouseWorld.zw - position);\n                heading.xy = mix(mouseWorld.xy, mouseWorld.zw, 0.3) - position;\n                heading.xy = safeNormalize(heading.xy);\n                                                \n                // check hits\n                \n                // interactives\n                if(action.w > 0.0)\n                {\n                    vec2 pos = position + PLAYERSIZE * heading.xy * 2.0;\n\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 0.0), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive1.x = 1.0;\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 0.2), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive1.y = 1.0;\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 0.4), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive1.z = 1.0;\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 0.6), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive1.w = 1.0;\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 0.8), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive2.x = 1.0;\n                    if(collision(pos, PLAYERSIZE, vec4(mix(-WorldBounds.x, WorldBounds.x, 1.0), WorldBounds.y - PLAYERSIZE-TORCHES, PLAYERSIZE, 0.0), false)) interactive2.y = 1.0;                                                                \n                    \n                }\n                                \n            }\n            else                \n            {\n                action.x = -1.0;\n            }\n        }\n        // check for \"gesture\"        \n    } \n    float t = dot(interactive1, vec4(1.0)) + dot(interactive2.xy, vec2(1.0));\n        \n    \n    if( t > 5.5)\n    {\n    \tinteractive2.w = 1.0;    \n\t\tanimState.w += iTimeDelta*0.1;\n    }\n       \n    vec4 debug1 = mouseWorld;        \n    \n    if(mouseTime.z > 0.0 && !guiInteraction)\n    {        \n        if(mouseDownTime > 0.3)\n        {\n            vec2 delta = mouseWorld.xy - position.xy;\n            if(length(delta) > 0.1)\n            dir = delta;\n        }   \n    }\n    dir = safeNormalize(dir);    \n    \n    float dt = iTimeDelta;    \n    float dte = exp(-dt);\n    \n    \n    vec2 cameraDelta = position.xy - camera.xy;\n    float cameraDist = length(cameraDelta);\n    float cameraMaxDist = 0.2;\n    if(cameraDist > cameraMaxDist * camera.z)\n    {\n        cameraDist = cameraDist - cameraMaxDist * camera.z;\n        cameraDir += safeNormalize(cameraDelta) * cameraDist*2.0;\n    }\n    \n    cameraDir = safeNormalize(cameraDir);\n    \n    vec4 gameState = state(GAMESTATE);\n    bool reset = false;\n    if(gameState.x < 1.0)\n    {\n        reset = true;\n    }\n    if(position.y > WorldBounds.y - 0.2)\n    {\n        if(gameState.x < 2.0)\n        {\n            gameState.x = 2.0;\n            gameState.y = iTime;\n        }\n        else\n        {\n            if(iTime - gameState.y > 7.0)\n            {\n                gameState.x = 0.0;\n                gameState.y = 0.0;\n                gameState.z = 0.0;\n                reset = true;\n            }\n        }\n    }\n    \n    if(p.y == 0)\n    {                \n        vec2 oldPosition = position;\n        vec2 velocity = state(VELOCITY).xy;        \n        vec2 velocityDir = safeNormalize(velocity);\n        position = position + velocity * dt;\n        if(action.x < 1.0)\n        {\n            heading.xy = mix(heading.xy, safeNormalize(velocity.xy), 0.5);\n            if(dot(heading.xy, heading.xy) < 0.1)\n            {\n                heading.xy = vec2(0.0,1.0);\n            }\n            else\n            {\n                heading.xy = normalize(heading.xy);\n            }\n        }\n\n        for(int i = 0; i < OBSTACLES-1; i++)\n        {\n        \tcollision(position, PLAYERSIZE, Obstacles[i], true);\n        }\n        collision(position, PLAYERSIZE, Obstacles[OBSTACLES-1] + vec4(sat(animState.w),0.0,0.0,0.0), true);\n        \n        // also clamp to world bounds\n        \n        position.x = clamp(position.x, -WorldBounds.x, WorldBounds.x);\n        position.y = clamp(position.y, -WorldBounds.y, WorldBounds.y);\n        \n        \n        vec2 effectiveVelocity = (position - oldPosition) / dt;\n        \n        animState.x += ANIMSPEED * length(effectiveVelocity);        \n        animState.y += ANIMBLENDSPEED * ( length(effectiveVelocity) - (MAXSPEED) / 5.0);        \n        animState.y = sat(animState.y);\n        \n        \n        \n        \n\t\tIF(VELOCITY)\n        {           \n            velocity += 5.0 * dir * dt;\n            velocity *= 1.0 - 0.06*dte;\n            limit(velocity, MAXSPEED);\n            O.xy += velocity;\n            O.zw = effectiveVelocity;\n        }\n        else IF(POSITION)\n        {                        \n            O.xy = position.xy;\n        }\n        else IF(FRAME)\n        {\n            // frame #, accumulated time\n            O.xy = state(FRAME).xy;\n            O.x += 1.;\n            O.y += iTimeDelta;                \n            O.z += iTime;\n        }\n        else if(p.x == FEET.x || p.x == FEETSTATE.x)\n        {\n            vec2 rightDir = cis(heading.x);\n            vec4 feetState = state(FEETSTATE);\n            vec4 feet = state(FEET);\n            vec2 left = feet.xy;\n            vec2 right = feet.zw;              \n            float distMax = 0.1;\n            float distMin = 0.01;\n            float distAvg = (distMin + distMax)*0.5;\n            vec2 offset = distMax*0.01*velocityDir;\n            float dr = sqr(position - right);            \n            if(dr > sqr(distMax))\n                right = position + rightDir * distAvg + offset;\n            if(dr < sqr(distMin))\n                right = position + rightDir * distAvg + offset;\n            \n            float dl = sqr(position - left);\n            if(dl > sqr(distMax) || dl < sqr(distMin))\n                left = position - rightDir * distAvg + offset;\n            if(p.x == FEET.x)\n            {\n            \tO.xy = left;\n            \tO.zw = right;\n            }\n            else                \n            {\n                O = feetState;\n            }\n        }\n        else IF(HEADING)\n        {\n            O = heading;\n        }\n        IF(CAMERAMOVE)\n        {\n            cameraMove.xy += dt * cameraDir * 1.7;\n            cameraMove *= dte * 0.99;\n            O = cameraMove;\n        }\n        else IF(CAMERA)\n        {            \n            if(camera.z < 0.0001)\n            {\n                camera.z = 1.0;\n            }\n            camera.z += 0.01 * zoomin;                                    \n            camera.xy += cameraMove.xy * dt;                                    \n            camera.z = clamp(camera.z, MINZOOM, MAXZOOM);\n            vec2 bounds = WorldBounds - vec2(0.5, 0.7 / aspect()) * camera.z;\n         \tcamera.x = clamp(camera.x, -bounds.x, bounds.x);\n        \tcamera.y = clamp(camera.y, -bounds.y, bounds.y);\n           \n            O = camera;\n        }\n        else IF(MOUSE)        \n        {            \n            O = mouse;\n        }        \n        else IF(MOUSETIME)\n        {\n            O = mouseTime;\n        }\n        else IF(OBSTACLE)\n        {\n            O = obstacle;\n        }\n        else IF(ACTION)\n        {\n            O = action;\n        }\n        else IF(INTERACTIVE1)\n        {\n            O = interactive1;\n        }\n        else IF(INTERACTIVE2)\n        {\n            O = interactive2;\n        }\n        else IF(GUI1)\n        {\n            O = gui;\n        }\n        else IF(GAMESTATE)\n        {\n            O = gameState;\n        }\n        else IF(ANIM)\n        {\n            O = animState;\n        }\n    }\n    else\n    {\n        if(p.y == 1)\n        {\n            IF(DEBUG1)\n            {\n                O = debug1;\n            }\n        }\n    }\n    // If I ever get NaNs again. (I will)\n    if(key(KEY_PAUSE) || reset)\n    {        \n        O = vec4(0.0);\n        STORE(POSITION, vec4(WorldBounds.x-PLAYERSIZE, -WorldBounds.y + PLAYERSIZE, 0, 0));\n        STORE(CAMERA  , vec4(WorldBounds.x-PLAYERSIZE, -WorldBounds.y + PLAYERSIZE, 0.5, 0));\n\n        //STORE(POSITION, vec4(0, WorldBounds.y - PLAYERSIZE, 0, 0));\n        //STORE(CAMERA  , vec4(0, WorldBounds.y - PLAYERSIZE, MINZOOM, 0));\n       \tSTORE(GAMESTATE, vec4(1.0,iTime,0.0,0.0));\n        \n        STORE(HEADING  ,vec4(0.0, -1.0, 0.0, 0.0));\n        STORE(ANIM, vec4(0.0));\n        STORE(INTERACTIVE1  ,vec4(0.0, 0.0, 0.0, 0.0));\n        STORE(INTERACTIVE2  ,vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    //O.rb = 1.0 - c.rb;\n}","name":"Buf A","description":"","type":"buffer"}]}