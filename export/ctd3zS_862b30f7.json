{"ver":"0.1","info":{"id":"ctd3zS","date":"1692869877","viewed":105,"name":"Raytraced icosahedron","username":"Nazlbit","description":"Raytraced icosahedron","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float fov = 20.0;\nconst float fov_rad = fov / 180.0 * PI;\nconst float fov_ctg = 1.0 / tan(fov_rad);\nconst float distance = 10.0;\n\nconst float phi = 1.61803398875;\nconst vec3 icosahedron_vertices[12] = vec3[](\n    vec3(-phi, 0, -1),\n    vec3(phi, 0, -1),\n    vec3(phi, 0, 1),\n    vec3(-phi, 0, 1),\n    \n    vec3(-1, -phi, 0),\n    vec3(-1, phi, 0),\n    vec3(1, phi, 0),\n    vec3(1, -phi, 0),\n    \n    vec3(0, -1, -phi),\n    vec3(0, -1, phi),\n    vec3(0, 1, phi),\n    vec3(0, 1, -phi)\n);\n\nconst uvec3 icosahedron_triangles[20] = uvec3[](\n    uvec3(0, 5, 3),\n    uvec3(0, 3, 4),\n    uvec3(0, 4, 8),\n    uvec3(0, 8, 11),\n    uvec3(0, 11, 5),\n    uvec3(1, 11, 8),\n    uvec3(1, 8, 7),\n    uvec3(1, 7, 2),\n    uvec3(1, 2, 6),\n    uvec3(1, 6, 11),\n    uvec3(2, 10, 6),\n    uvec3(2, 9, 10),\n    uvec3(2, 7, 9),\n    uvec3(3, 10, 9),\n    uvec3(3, 9, 4),\n    uvec3(3, 5, 10),\n    uvec3(4, 7, 8),\n    uvec3(4, 9, 7),\n    uvec3(5, 11, 6),\n    uvec3(5, 6, 10)\n);\n\nvec4 triangle_intersection(mat3 triangle, vec3 pr, vec3 r)\n{\n    return inverse(mat4(vec4(triangle[0], 1.0),\n                        vec4(triangle[1], 1.0),\n                        vec4(triangle[2], 1.0),\n                        vec4(-r, 0))) * vec4(pr, 1.0);\n}\n\nbool hit_or_miss(vec4 i)\n{\n    return i.x >= 0.0 &&\n           i.y >= 0.0 &&\n           i.z >= 0.0 &&\n           i.w > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 normalized = uv * 2.0 - 1.0;\n    vec3 cam_dir = vec3(-sin(iTime), 0, cos(iTime));\n    vec3 cam_right = vec3(cos(iTime), 0, sin(iTime));\n    vec3 cam_up = vec3(0, 1, 0);\n    float ratio = iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(normalized.x, normalized.y / ratio, fov_ctg));\n    r = cam_right * r.x + cam_up * r.y + cam_dir * r.z;\n    vec3 cam_pos = -cam_dir * distance;\n    \n    vec4 intersection = vec4(0, 0, 0, 1000000);\n    int index = -1;\n    for(int i = 0; i < icosahedron_triangles.length(); ++i)\n    {\n        vec3 p0 = icosahedron_vertices[icosahedron_triangles[i][0]];\n        vec3 p1 = icosahedron_vertices[icosahedron_triangles[i][1]];\n        vec3 p2 = icosahedron_vertices[icosahedron_triangles[i][2]];\n        mat3 triangle = mat3(p0, p1, p2);\n        vec4 intersection_tmp = triangle_intersection(triangle, cam_pos, r);\n        \n        if(hit_or_miss(intersection_tmp) && intersection_tmp.w < intersection.w)\n        {\n            intersection = intersection_tmp;\n            index = i;\n        }\n    }\n    if(index != -1)\n    {\n        vec3 p0 = icosahedron_vertices[icosahedron_triangles[index][0]];\n        vec3 p1 = icosahedron_vertices[icosahedron_triangles[index][1]];\n        vec3 p2 = icosahedron_vertices[icosahedron_triangles[index][2]];\n        fragColor = vec4(normalize(cross(p2 - p0, p1 - p0) + 3.0), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n}","name":"Image","description":"","type":"image"}]}