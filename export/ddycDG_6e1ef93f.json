{"ver":"0.1","info":{"id":"ddycDG","date":"1697065749","viewed":49,"name":"000Tools:Rand Vects, Perlin v2.0","username":"foodini","description":"A copy-pastable bunch of functions to make generating random numbers and perlin noise easy.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["random","tools"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float f) {\n    if(fract(f) > 0.5 && fract(f) < 0.6)\n            return vec3(0.93,0.9,0.3);\n\n    if(fract(f*20.0) < 0.2) \n        return vec3(0.7, 0.68, 0.15);\n    return vec3(0.93,0.9,0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    global_rand_state = make_rand_state(fragCoord, iResolution, iFrame);\n\n    // Square pixel space. uv.x -> [-1.0..1.0]\n    vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n\n    vec3 p = vec3(uv*5.0, iTime);\n\n    float perlin_brightness;\n\n    if(uv.x > -0.3333) {\n        if(uv.x > 0.3333) {\n            perlin_brightness = (1.0 + perlin_harmonics(p, 4))/2.0;\n        } else {\n            perlin_brightness = (1.0 + perlin(p))/2.0;\n        }\n    \n        if(uv.y > 0.0) {\n            fragColor.rgb = vec3(perlin_brightness);\n        } else {\n            fragColor.rgb = palette(perlin_brightness);\n        }\n        return;\n    }\n    \n    // None of the following is visually interesting. Just including it\n    // for demo.\n    if(fragCoord.y > 3.0 * iResolution.y/ 4.0) {\n        fragColor = vec4(uniform_float());\n    } else if(fragCoord.y > 2.0 * iResolution.y/ 4.0) {\n        fragColor = uniform_cuboid_vec4();\n    } else if(fragCoord.y > 1.0 * iResolution.y/ 4.0) {\n        fragColor = uniform_in_sphere_vec4();\n    } else {\n        fragColor = uniform_on_sphere_vec4();\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \nRandom number tools. Version 2.0  2023.11.02 foodini@shadertoy\nUse freely, but please keep these two lines.\n\nNew to version 2.0:\n* I now generate uniformally-distributed vectors within the spheres in all\n  dimensions, as well as on the spheres.\n\nRandom numbers are a pain. The simple random functions in the standard library\naren't bad for generating sequences of random numbers, but you can frequently \nsee patterns in their first returns when you compare similarly-seeded runs\nagainst each other. Some shaders use things like: \n    sin(iTime * fragCoord.x * fragCoord.y * float(chaos)); chaos += iFrame;\n    \n...which is quick, but still prone to showing patterns and is not uniformally\ndistributed from -1.0 to 1.0.\n\nYou'll find a decent (not great, but hey) random number generator here. \n\n\nGETTING RANDOM VALUES\n\nIn its simplest form, you can just seed the generator and start pulling values:\n\nglobal_rand_state = make_rand_state(fragCoord, iResolution, iFrame);\nfloat foo = uniform_float(); // gets you a value from 0.0 to 1.0.\n\n\nAll functions here accept a rand_state value. You would use this if you want\na random value that is entropic, but deterministic based upon a specific\ncondition. For example, the Perlin noise functions all need a \"random\" vector\nthat is dependent upon a specific point in space. For a given <x,y,z> vector,\nit MUST spit out the same result.\n\nTo do this, you can do:\nuint rand_seed = make_rand_seed(seed_vector);\nvec3 deterministic_vector = uniform_on_sphere_vec3(rand_seed);\n\nThe great thing about this is that when one different pixels need to agree\nupon a random value associated with a specific condition, they just have to\nall use the same values to create the seed for the generator.\n\nThere are a number of random vector functions here. I've found all of them to\nbe useful, and I hope you will as well:\n\nuniform_cuboid_vec[2-4]:\n  Returns a vector with uniformally distributed x,y,z,w values between \n  -1.0 and 1.0\n\nuniform_in_sphere_vec[2-4]:\n  Returns a vector whose endpoint is uniformally distributed within the unit\n  sphere. Imagine choosing your x,y,z,w between -1.0 and 1.0, then checking\n  to see if the length is <=1.0 and re-choosing if it is too large. It has\n  the same effect, but it's less prone to getting caught in while loops.\n\nuniform_on_sphere_vec[2-4]:\n  Returns a vector of length 1.0, whose direction is uniformally distributed\n  across the surface of the unit sphere. Essentially, this is the same as\n  \n    return normalize(uniform_in_sphere_vecX());\n    \ngaussian_vec[2-4]:\n  MOST of the x,y,z,w values will be between -1.0 and 1.0, but not all. The\n  only guarantee is that the standard deviation of the individual components\n  will be exactly (1.0/(2.0 + number_of_dimensions)). I have no idea why it\n  works out that way, but it does. I have thoroughly tested the distribution\n  of the vectors generated, and it is uniform.\n  \n\nTo test the uniformity of the generated vectors, I would generate a reference\nvector, v0, and normalize it. I'd then generate 1 BILLION other vectors (v1)\nwith the same randomizer, normalize it, then take the dot product of the two\nvectors. I'd count the number of vectors where the dot product fell between\ndifferent values. The variance between runs was in the hundredths of a\npercent.\n\nThere are more geometrically-intuitive ways to generate random vectors, but I\nfound them all to be more computationaly costly. For example, I could\ngenerate a normalized 3-vector by taking a unit vector, <1.0, 0.0, 0.0>, and\nrotating it about the y axis by a random theta, then about z by a random phi,\nbut the distribution of the phis must be such that you don't end up with as\nmany vectors within, say, 5 degrees of the y pole as you have within 5\ndegrees of the equator. It's a workable problem, but if you MUST work with\ngenerating odd distributions of random numbers, why not use a gaussian, which\nhas other uses in other applications?\n*/\n\n//TODO:\n// * Octaves of noise should be a built-in.\n\n\nconst float PI = 3.14159265359;\nconst float TAU = 3.14159265359 * 2.0;\nconst float epsilon = 1.19e-7;\n\n/*\nd8888b.  .d8b.  d8b   db d8888b.   d88888b db    db d8b   db  .o88b. .d8888.\n88  `8D d8' `8b 888o  88 88  `8D   88'     88    88 888o  88 d8P  Y8 88'  YP\n88oobY' 88ooo88 88V8o 88 88   88   88ooo   88    88 88V8o 88 8P      `8bo.\n88`8b   88~~~88 88 V8o88 88   88   88~~~   88    88 88 V8o88 8b        `Y8b.\n88 `88. 88   88 88  V888 88  .8D   88      88b  d88 88  V888 Y8b  d8 db   8D\n88   YD YP   YP VP   V8P Y8888D'   YP      ~Y8888P' VP   V8P  `Y88P' `8888Y'\n*/\n\n// Usually, you don't care about the order of random number delivery. In fact,\n// most of the time, you want it to be unpredictable. For any such consumption\n// of entropy, use the global_rand_state.\n\n// HOWEVER! Sometimes you need absolute predictability. For example, when you\n// are generating vectors for a perlin noise generator, every (x,y,z,w) vertex\n// needs to generate the same vector. If you were to use the global seed for\n// this, you'd get different anchor vectors for each caller and the result would\n// be white noise and not perlin noise. Use the noise funcs for repeatable results.\nuint global_rand_state;\n\n//Adapted from: https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nuint hash(inout uint rand_state) {\n    rand_state ^= 2747636419u;\n    rand_state *= 2654435769u;\n    rand_state ^= rand_state >> 16;\n    rand_state *= 2654435769u;\n    rand_state ^= rand_state >> 16;\n    rand_state *= 2654435769u;\n    return rand_state;\n}\n\nuint make_rand_state(vec2 fragCoord, vec3 iResolution, int iFrame){\n    return\n        uint(fragCoord.y*iResolution.x + fragCoord.x) + \n        uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nuint make_rand_state(float entropy) {\n    return uint(entropy + entropy * 65536.0);\n}\n\nuint make_rand_state(ivec2 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    return hash(x) ^ hash(y);\n}\n\nuint make_rand_state(ivec3 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    uint z = uint(entropy.z)^uint(92974672);\n    return hash(x) ^ hash(y) ^ hash(z);\n}\n\nuint make_rand_state(ivec4 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    uint z = uint(entropy.z)^uint(92974672);\n    uint w = uint(entropy.w)^uint(73496335);\n    return hash(x) ^ hash(y) ^ hash(z) ^ hash(w);\n}\n\n// returns a float in the range [0.0..1.0]\nfloat uniform_float(inout uint rand_state) {\n    return float(hash(rand_state)) / 4294967295.0; // 2^32-1\n}\n\nfloat uniform_float() {\n    return uniform_float(global_rand_state);\n}\n\nvoid gaussian_floats(inout uint rand_state, float mu, float sigma, out float z0, out float z1) {\n    float u1, u2;\n    do {\n        u1 = uniform_float(rand_state);\n    } while (u1 < epsilon);\n    u2 = uniform_float(rand_state);\n    \n    float mag = sigma * sqrt(-2.0 * log(u1));\n    z0 = mag * cos(TAU * u2) + mu;\n    z1 = mag * sin(TAU * u2) + mu;\n}\n\nvoid gaussian_floats(float mu, float sigma, out float z0, out float z1) {\n    gaussian_floats(global_rand_state, mu, sigma, z0, z1);\n}    \n\n/*          _           _     _                  _                 \n  ___ _   _| |__   ___ (_) __| | __   _____  ___| |_ ___  _ __ ___ \n / __| | | | '_ \\ / _ \\| |/ _` | \\ \\ / / _ \\/ __| __/ _ \\| '__/ __|\n| (__| |_| | |_) | (_) | | (_| |  \\ V /  __/ (__| || (_) | |  \\__ \\\n \\___|\\__,_|_.__/ \\___/|_|\\__,_|   \\_/ \\___|\\___|\\__\\___/|_|  |___/\n\nVectors that inhabit the n-dimensional cube space from [-1.0, -1.0, ...] to [1.0, 1.0, ...]\n\n*/\n\nvec2 uniform_cuboid_vec2(inout uint rand_state) {\n    return vec2(\n        uniform_float(rand_state)*2.0-1.0, uniform_float(rand_state)*2.0-1.0);\n}\n\nvec3 uniform_cuboid_vec3(inout uint rand_state) {\n    return vec3(\n        uniform_float(rand_state)*2.0-1.0, uniform_float(rand_state)*2.0-1.0, \n        uniform_float(rand_state)*2.0-1.0);\n}\n\nvec4 uniform_cuboid_vec4(inout uint rand_state) {\n    return vec4(\n        uniform_float(rand_state)*2.0-1.0, uniform_float(rand_state)*2.0-1.0, \n        uniform_float(rand_state)*2.0-1.0, uniform_float(rand_state)*2.0-1.0);\n}\n\nvec2 uniform_cuboid_vec2() {\n    return uniform_cuboid_vec2(global_rand_state);\n}\nvec3 uniform_cuboid_vec3() {\n    return uniform_cuboid_vec3(global_rand_state);\n}\nvec4 uniform_cuboid_vec4() {\n    return uniform_cuboid_vec4(global_rand_state);\n}\n\n\n/*         _                    _     _                  _                 \n ___ _ __ | |__   ___ _ __ ___ (_) __| | __   _____  ___| |_ ___  _ __ ___ \n/ __| '_ \\| '_ \\ / _ \\ '__/ _ \\| |/ _` | \\ \\ / / _ \\/ __| __/ _ \\| '__/ __|\n\\__ \\ |_) | | | |  __/ | | (_) | | (_| |  \\ V /  __/ (__| || (_) | |  \\__ \\\n|___/ .__/|_| |_|\\___|_|  \\___/|_|\\__,_|   \\_/ \\___|\\___|\\__\\___/|_|  |___/\n    |_|                                                                    \n\nReturns vectors that are uniformally distributed within the unit sphere. This is\na bit of a trick, but it relies upon the fact that the points within a unit sphere\nhave a consistent standard deviation. If we generate n-dimensional points using a\ngaussian (bell curve) distribution, their orientations in space will be uniformaly\ndistributed. However, you can still get points outside the sphere (and the cube)\nthis way. The gaussian_vec[2-4] functions hand back these raw vectors. The\nuniform_insphere_vec[2-4] functions hand back only those vectors that fall inside\nof the sphere and uniform_unit_spheroid_vec[2-4] hand back normalized forms.\n\nIt all seems like a lot of work to avoid doing:\n\n    do {\n        retval = uniform_cuboid_vec4();\n    } while (length(retval) > 1.0);\n    \n...but this process is VERY expensive in higher dimensions. The volume of the unit\nsphere in 4-space is about 5 - less than a third the volume of the cube. Looping\na dozen times or more is commonplace. Looping 50+ times is not unheard of.\n*/\n\nvec2 gaussian_vec2(inout uint rand_state) {\n    vec2 retval;\n    gaussian_floats(rand_state, 0.0, 1.0/4.0, retval.x, retval.y);\n    return retval;\n}\n\nvec3 gaussian_vec3(inout uint rand_state) {\n    // Most users of the Box-Muller gaussian generator (uniform_floats()) cache\n    // unused values. I've been bitten by caching random values in deterministic\n    // systems before and am leary. None of my uses of this function are at risk,\n    // but you don't discover that you _ARE_ at risk until you find yourself in\n    // some all-night debugging nightmare. It's not fun. Not worth the risk.\n    vec3 retval;\n    gaussian_floats(rand_state, 0.0, 1.0/5.0, retval.x, retval.y); // Re-use of y\n    gaussian_floats(rand_state, 0.0, 1.0/5.0, retval.y, retval.z); // is intended\n    return retval;\n}\n\nvec4 gaussian_vec4(inout uint rand_state) {\n    vec4 retval;\n    gaussian_floats(rand_state, 0.0, 1.0/6.0, retval.x, retval.y);\n    gaussian_floats(rand_state, 0.0, 1.0/6.0, retval.z, retval.w);\n    return retval;\n}\n\nvec2 gaussian_vec2() {\n    return gaussian_vec2(global_rand_state);\n}\nvec3 gaussian_vec3() {\n    return gaussian_vec3(global_rand_state);\n}\nvec4 gaussian_vec4() {\n    return gaussian_vec4(global_rand_state);\n}\n\n\n// The while loop is more about protecting callers who might have catastrophic\n// results from len>1.0 values than about protecting the uniform distribution\nvec2 uniform_in_sphere_vec2(inout uint rand_state) {\n    vec2 retval;\n    do {\n        retval = gaussian_vec2(rand_state);\n    } while (length(retval) > 1.0); // len>1.0 about 33,500 in 1 Billion tries\n    return retval;\n}\n\n// The while loop is more about protecting callers who might have catastrophic\n// results from len>1.0 values than about protecting the uniform distribution\nvec3 uniform_in_sphere_vec3(inout uint rand_state) {\n    vec3 retval;\n    do {\n        retval = gaussian_vec3(rand_state);\n    } while (length(retval) > 1.0); // len>1.0 about 1,500 in 1 Billion tries\n    return retval;\n}\n\n// The while loop is more about protecting callers who might have catastrophic\n// results from len>1.0 values than about protecting the uniform distribution\nvec4 uniform_in_sphere_vec4(inout uint rand_state) {\n    vec4 retval;\n    do {\n        retval = gaussian_vec4(rand_state);\n    } while (length(retval) > 1.0); // len>1.0 about 20 in 1 Billion tries\n    return retval;\n}\n\nvec2 uniform_in_sphere_vec2() {\n    return uniform_in_sphere_vec2(global_rand_state);\n}\nvec3 uniform_in_sphere_vec3() {\n    return uniform_in_sphere_vec3(global_rand_state);\n}\nvec4 uniform_in_sphere_vec4() {\n    return uniform_in_sphere_vec4(global_rand_state);\n}\n\n// Returns a uniformally-distributed normal vector\nvec2 uniform_on_sphere_vec2(inout uint rand_state) {\n    return normalize(gaussian_vec2(rand_state));\n}\n\n// Returns a uniformally-distributed normal vector\nvec3 uniform_on_sphere_vec3(inout uint rand_state) {\n    return normalize(gaussian_vec3(rand_state));\n}\n\n// Returns a uniformally-distributed normal vector\nvec4 uniform_on_sphere_vec4(inout uint rand_state) {\n    return normalize(gaussian_vec4(rand_state));\n}\n\nvec2 uniform_on_sphere_vec2() {\n    return uniform_on_sphere_vec2(global_rand_state);\n}\nvec3 uniform_on_sphere_vec3() {\n    return uniform_on_sphere_vec3(global_rand_state);\n}\nvec4 uniform_on_sphere_vec4() {\n    return uniform_on_sphere_vec4(global_rand_state);\n}\n\n/*\nd8b   db  .d88b.  d888888b .d8888. d88888b   d88888b db    db d8b   db  .o88b. .d8888.\n888o  88 .8P  Y8.   `88'   88'  YP 88'       88'     88    88 888o  88 d8P  Y8 88'  YP\n88V8o 88 88    88    88    `8bo.   88ooooo   88ooo   88    88 88V8o 88 8P      `8bo.\n88 V8o88 88    88    88      `Y8b. 88~~~~~   88~~~   88    88 88 V8o88 8b        `Y8b.\n88  V888 `8b  d8'   .88.   db   8D 88.       88      88b  d88 88  V888 Y8b  d8 db   8D\nVP   V8P  `Y88P'  Y888888P `8888Y' Y88888P   YP      ~Y8888P' VP   V8P  `Y88P' `8888Y'\n\n\nDifferent from \"random\", given the same entropy input, they will return the same\nresult every time.\n*/\n\nfloat noise(float seed) {\n    uint rand_state = uint(seed + seed*65536.0);\n    return uniform_float(rand_state);\n}\n\n//#define CUBOID_NOISE\n//#define IN_SPHERE_NOISE  // This sucks. The node vectors aren't pronounced enough.\n#define ON_SPHERE_NOISE\n#ifdef CUBOID_NOISE\n#define vector_selector2(state) uniform_cuboid_vec2(state)\n#define vector_selector3(state) uniform_cuboid_vec3(state)\n#define vector_selector4(state) uniform_cuboid_vec4(state)\n#endif\n#ifdef IN_SPHERE_NOISE\n#define vector_selector2(state) uniform_in_sphere_vec2(state)\n#define vector_selector3(state) uniform_in_sphere_vec3(state)\n#define vector_selector4(state) uniform_in_sphere_vec4(state)\n#endif\n#ifdef ON_SPHERE_NOISE\n#define vector_selector2(state) uniform_on_sphere_vec2(state)\n#define vector_selector3(state) uniform_on_sphere_vec3(state)\n#define vector_selector4(state) uniform_on_sphere_vec4(state)\n#endif\nvec2 noise(ivec2 seed) {\n    uint rand_state = make_rand_state(seed);\n    return vector_selector2(rand_state);\n}\n\nvec3 noise(ivec3 seed) {\n    uint rand_state = make_rand_state(seed);\n    return vector_selector3(rand_state);\n}\n\nvec4 noise(ivec4 seed) {\n    uint rand_state = make_rand_state(seed);\n    return vector_selector4(rand_state);\n}\n\n\n/*\nd8888b. d88888b d8888b. db      d888888b d8b   db\n88  `8D 88'     88  `8D 88        `88'   888o  88\n88oodD' 88ooooo 88oobY' 88         88    88V8o 88\n88~~~   88~~~~~ 88`8b   88         88    88 V8o88\n88      88.     88 `88. 88booo.   .88.   88  V888\n88      Y88888P 88   YD Y88888P Y888888P VP   V8P\n*/\n\n// a perlin function with a 2D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec2 p) {\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n    vec2 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec2 f3 = f*f*f;\n        vec2 f4 = f3*f;\n        vec2 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return mix( mix( dot( noise( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( noise( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( noise( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( noise( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// a perlin function with a 3D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec3 p) {\n    ivec3 i = ivec3(floor( p ));\n     vec3 f =       fract( p );\n\t\n    vec3 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec3 f3 = f*f*f;\n        vec3 f4 = f3*f;\n        vec3 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return \n        mix( mix( mix( dot( noise( i+ivec3(0,0,0) ), f-vec3(0.0,0.0,0.0) ), \n                       dot( noise( i+ivec3(1,0,0) ), f-vec3(1.0,0.0,0.0) ), u.x),\n                  mix( dot( noise( i+ivec3(0,1,0) ), f-vec3(0.0,1.0,0.0) ), \n                       dot( noise( i+ivec3(1,1,0) ), f-vec3(1.0,1.0,0.0) ), u.x), u.y),\n             mix( mix( dot( noise( i+ivec3(0,0,1) ), f-vec3(0.0,0.0,1.0) ), \n                       dot( noise( i+ivec3(1,0,1) ), f-vec3(1.0,0.0,1.0) ), u.x),\n                  mix( dot( noise( i+ivec3(0,1,1) ), f-vec3(0.0,1.0,1.0) ), \n                       dot( noise( i+ivec3(1,1,1) ), f-vec3(1.0,1.0,1.0) ), u.x), u.y), u.z);\n}\n\n// a perlin function with a 4D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec4 p) {\n    ivec4 i = ivec4(floor( p ));\n     vec4 f =       fract( p );\n\t\n    vec4 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec4 f3 = f*f*f;\n        vec4 f4 = f3*f;\n        vec4 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return \n        mix(\n            mix( mix( mix( dot( noise( i+ivec4(0,0,0,0) ), f-vec4(0.0,0.0,0.0,0.0) ), \n                           dot( noise( i+ivec4(1,0,0,0) ), f-vec4(1.0,0.0,0.0,0.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,0,0) ), f-vec4(0.0,1.0,0.0,0.0) ), \n                           dot( noise( i+ivec4(1,1,0,0) ), f-vec4(1.0,1.0,0.0,0.0) ), u.x), u.y),\n                 mix( mix( dot( noise( i+ivec4(0,0,1,0) ), f-vec4(0.0,0.0,1.0,0.0) ), \n                           dot( noise( i+ivec4(1,0,1,0) ), f-vec4(1.0,0.0,1.0,0.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,1,0) ), f-vec4(0.0,1.0,1.0,0.0) ), \n                           dot( noise( i+ivec4(1,1,1,0) ), f-vec4(1.0,1.0,1.0,0.0) ), u.x), u.y), u.z),\n            mix( mix( mix( dot( noise( i+ivec4(0,0,0,1) ), f-vec4(0.0,0.0,0.0,1.0) ), \n                           dot( noise( i+ivec4(1,0,0,1) ), f-vec4(1.0,0.0,0.0,1.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,0,1) ), f-vec4(0.0,1.0,0.0,1.0) ), \n                           dot( noise( i+ivec4(1,1,0,1) ), f-vec4(1.0,1.0,0.0,1.0) ), u.x), u.y),\n                 mix( mix( dot( noise( i+ivec4(0,0,1,1) ), f-vec4(0.0,0.0,1.0,1.0) ), \n                           dot( noise( i+ivec4(1,0,1,1) ), f-vec4(1.0,0.0,1.0,1.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,1,1) ), f-vec4(0.0,1.0,1.0,1.0) ), \n                           dot( noise( i+ivec4(1,1,1,1) ), f-vec4(1.0,1.0,1.0,1.0) ), u.x), u.y), u.z), u.w);\n}\n\nfloat perlin_harmonics(vec2 p, int octaves) {\n    float scale = 1.0;\n    float retval = 0.0;\n    \n    while(octaves > 0) {\n        retval += perlin((scale+p)*scale)/scale;\n        scale *= 1.83;\n        octaves--;\n    }\n    return retval;\n}\n\nfloat perlin_harmonics(vec3 p, int octaves) {\n    float scale = 1.0;\n    float retval = 0.0;\n    \n    while(octaves > 0) {\n        retval += perlin((scale+p)*scale)/scale;\n        scale *= 1.83;\n        octaves--;\n    }\n    return retval;\n}\n\n/*\n.88b  d88.  .d8b.  d8888b.   d88888b db    db d8b   db  .o88b. .d8888.\n88'YbdP`88 d8' `8b 88  `8D   88'     88    88 888o  88 d8P  Y8 88'  YP\n88  88  88 88ooo88 88oodD'   88ooo   88    88 88V8o 88 8P      `8bo.\n88  88  88 88~~~88 88~~~     88~~~   88    88 88 V8o88 8b        `Y8b.\n88  88  88 88   88 88        88      88b  d88 88  V888 Y8b  d8 db   8D\nYP  YP  YP YP   YP 88        YP      ~Y8888P' VP   V8P  `Y88P' `8888Y'\n*/\n\nfloat map(float m, float minin, float maxin, float minout, float maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec2 map(float m, float minin, float maxin, vec2 minout, vec2 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec3 map(float m, float minin, float maxin, vec3 minout, vec3 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec4 map(float m, float minin, float maxin, vec4 minout, vec4 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\n","name":"Common","description":"","type":"common"}]}