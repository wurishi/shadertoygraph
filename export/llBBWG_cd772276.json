{"ver":"0.1","info":{"id":"llBBWG","date":"1516982691","viewed":161,"name":"Controlled truchet tiles","username":"Daedelus","description":"Attempt at controlling truchet tiles into a designed shape without the infinity aspect to it.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tiling space by this many cells\n#define WIDTH 6\n#define HEIGHT 6\n\n// look up tables\n// -1 is invisible\n// numbers 0,1,2,3 define rotation angle (steps of 90 degrees, clockwise)\n// 4 is mirrored arcs (tiles 0 and 2 added together), 5 is the 90 degree rotated version of that\nint LUT[WIDTH*HEIGHT] = int[](\n-1, 2, 1, 2, 1, -1,\n 2, 4, 5, 4, 5,  1,\n 3, 4, 4, 4, 4,  0,\n 2, 4, 5, 5, 0, -1,\n 3, 4, 4, 5, 1, -1,\n-1, 3, 0, 3, 0, -1\n);\n// to be able to move through the generated path we need to know the order of the tiles & arcs\n// this look up table tells us what tile we're on\nint OFFSET[WIDTH*HEIGHT] = int[](\n0,1,44,41,40,0,\n3,2,7,42,31,38,\n4,5,8,29,32,37,\n11,10,15,26,35,0,\n12,13,16,21,24,0,\n0,18,19,22,23,0\n);\n// this look up table is a fallback for mirrored tiles so the two arcs have their own offset\nint MIRROR_OFFSET[WIDTH*HEIGHT] = int[](\n0,0,0,0,0,0,\n0,6,43,30,39,0,\n0,9,28,33,36,0,\n0,14,27,34,0,0,\n0,17,20,25,0,0,\n0,0,0,0,0,0\n);\n// flip animation direction\nbool FLIP[WIDTH*HEIGHT] = bool[](\n    false,false,false,false,false,false,\n    false, true, true, true, true,false,\n    false,false, true,false, true,false,\n    false, true, true,false,false,false,\n    false,false, true, true,false,false,\n    false,false,false,false,false,false\n);\n// used for looping\nconst int MAX_OFFSET = 44;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get zoomed out UVs\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 2.5;\n    \n    vec2 gUv = uv; // cache unaltered uvs\n    \n    // compute bounding box of the tiled region\n    float bounds = max(abs(uv.x)-float(WIDTH/2),abs(uv.y)-float(HEIGHT/2));\n    \n    // divide UVs into cells\n    vec2 cell = floor(uv);\n    cell = clamp(cell, vec2(-WIDTH/2, -HEIGHT/2), vec2(WIDTH/2 - 1, HEIGHT/2 - 1));\n    uv -= cell;\n    // offset UVs so 0,0 is in the center of each cell\n    uv -= 0.5;\n    \n    // get look up table index from cell\n    int idx = clamp(int(cell.x)+WIDTH/2+WIDTH*(int(cell.y)+HEIGHT/2), 0, 48);\n    // which tile?\n    int state = LUT[idx];\n    // arc color (colorized to visualize the offset lookup tables)\n    vec3 cl=vec3(0);\n    // resulting distance\n    float d;\n    if(state<0) // -1 tiles are empty\n    {\n        d = max(bounds,0.75-max(abs(uv.x),abs(uv.y)));\n    }\n    else\n    {\n        // track offset for coloring\n       \tint offset = OFFSET[idx] - 1;\n        \n        // decompose tile state to mirror and rotation\n        bool mirror = (state & 4) != 0;\n        bool flip = FLIP[idx];\n        int rotate = state & ~4;\n        if(rotate==1) // rotate 90\n            uv = vec2(-uv.y, uv.x);\n        else if(rotate==2) // rotate 180\n            uv = -uv;\n        else if(rotate==3) // rotate 270\n            uv = vec2(uv.y, -uv.x);\n        if(mirror)\n        {\n            if(uv.x>-uv.y) // mirror tile along diagonal\n            {\n                uv = -uv;\n                offset = MIRROR_OFFSET[idx] - 1; // update offset\n            }\n        }\n        \n        // put arc in corner\n        uv += 0.5;\n\t\t// circle distance field\n        // d=abs(abs(length(uv)-0.5))-0.07;\n            \n        // warp the space\n        float parameter = atan(uv.x, uv.y) / (3.14159265359 * 0.5);\n        if(flip)\n        \tparameter = 1.0 - parameter;\n        float radius = length(uv) - 0.5;\n        uv = vec2(radius * 1.3, (parameter + float(offset)));\n        uv.y = mod(uv.y, float(MAX_OFFSET));\n        \n        d = abs(uv.x) - 0.04;\n        \n        // colorize by offset\n        cl = fract(vec3(0.2, 0.05, 0.01) * float(offset));\n        \n        // slide a dot over the curve\n        float r = length(uv - vec2(0.0, mod(iTime * 4.0, float(MAX_OFFSET)))) - 0.06;\n        if(r < 0.06)\n        {\n            cl = vec3(1.0, 0.0, 0.0);\n        \td = r;\n        }\n        \n        d /= 1.3;\n    }\n    \n    float a = smoothstep(0.0, 0.04, d);\n\tfragColor = mix(vec4(cl, 1.0), \n                    0.2 * vec4(fract(d * 0.2) * 0.4 + fract(d * 0.5) * 0.3 + fract(d) * 0.2 + fract(d * 3.0) * 0.1), \n                    a);\n}\n","name":"Image","description":"","type":"image"}]}