{"ver":"0.1","info":{"id":"7sGXWt","date":"1635481794","viewed":79,"name":"Fork Sierpinski HalbFettKa 764","username":"HalbFettKaese","description":"This version has an animated vertex count","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","simple","sierpinski"],"hasliked":0,"parentid":"4djGW1","parentname":"Sierpinski Polygon"},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by Vinicius Graciano Santos - vgs/2013\n// I've learned a lot about fractals in this series of blog posts:\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n\n#define TAU 6.283185\n\n// The range that the vertex count is interpolated within\n#define SPAN vec2(1, 10)\n\n// unit circle around polygon\n#define UCIRCLE\n\nfloat fractal(in vec2 uv, float SIDES) {\n\tfloat c = cos(1.0/float(SIDES)*TAU);\n\tfloat s = sin(1.0/float(SIDES)*TAU);\n\t\n\tmat2 m = mat2(c, s, -s, c);\n\tvec2 p = vec2(1.0, 0.0), r = p;\n\t\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfloat dmin = length(uv - r);\n\t\tfor (int j = 0; j < int(ceil(SIDES)); ++j) {\n\t\t\tp = m*p;\n\t\t\tfloat d = length(uv - p); \n\t\t\tif (d < dmin) {dmin = d; r = p;}\n\t\t}\n\t\tuv = 2.0*uv - r;\n\t}\n\t\n\treturn (length(uv-r)-0.15)/pow(2.0, 7.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat vig = 0.15 + pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n\t\n\tuv = -1.0+2.0*uv;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tfloat d = fractal(uv, .5*(SPAN.x + SPAN.y) + .5*(SPAN.x - SPAN.y)*sin(iTime*0.1));\n\td = smoothstep(0.001, 0.015, d);\n\t\n\t#ifdef UCIRCLE\n\td *= 1.0-length(uv);\n\t#endif\n\t\t\n\tfragColor = vec4(vec3(pow(vig*d, 0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}