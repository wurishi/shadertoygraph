{"ver":"0.1","info":{"id":"4tGSWh","date":"1484007009","viewed":289,"name":"CS8EC v2","username":"4onen","description":"CS8EC, redone with radial mirroring to increase speed. On a dedicated graphics card, can support an infinite SIDE_COUNT.\n\nNote though, MAX_POLY_SIDE_COUNT changes do affect speed for values greater than ~256. Try not to raise that too much.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made by Matthew Dupree for fun. No profit, no credit.\n\n//Don't try stealing this to use for credit in CS8.\n//For one thing, you're probably not the only person in the class to find this.\n//If you both submit it and say \"Hey, look how smart we are!\" you two will\n//look pretty dumb to the academic counseling office.\n\n//Also, this is written in the wrong language. Go do your assignment in Python.\n\n//P.P.S. I know Python has an OpenGL library that could theoretically run this code\n//under the hood. That's not going to work either. The ShaderToy environment is\n//too complicated for someone in CS8 to replicate on-the-fly in Python.\n\n//Good luck!\n\n\n\n\n//The actual number of sides each polygon has in the shadertoy\n#define SIDE_COUNT 4\n//---------------------------------\n//CHANGE THE ABOVE VALUE FOR FUN!\n//---------------------------------\n\n//The maximum number of sides the polygon can have.\n//Necessary because loop counters can't be compared to dynamic numbers as the break condition.\n//Weird things happen if this is lower than SIDE_COUNT\n#define MAX_POLY_SIDE_COUNT 128\n\n//Pi. Does this really need explanation?\n#define PI 3.14159265358979323846264338\n//Epsilon, otherwise known as the programmer fudge factor.\n#define eps 0.01\n\n//Used to rotate things.\n//Returns a matrix that'll rotate a vector2 by angle radians about the origin.\nmat2 rotation(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,\n                s, c);\n}\n\nfloat toAngle(vec2 pos){\n    //Needed to flip the angle such that the angle given is from the vertical.\n    pos.y *= -1.0;\n    \n    //A piecewise function that smooths out atan's iffy output into a single\n    //value that increases all the way around the coordinate grid.\n    return step(0.0,pos.x)*(atan(pos.y/pos.x)-PI/2.0) \n         + step(0.0,-pos.x)*(atan(pos.y/pos.x)+PI/2.0)\n         + PI;//This PI avoid negative numbers, which make other math in here weird.\n}\n\n//Returns 1.0 when in the origin-centered rectangle given\nfloat smoothOriginRect(vec2 r, float w, float h){\n    float ret;\n    //If we have the right x coordinate, 1.0\n    ret =  smoothstep(0.0,eps,w/2.0-abs(r.x));\n    //If we have the right y coordinate, 1.0\n    ret *= smoothstep(0.0,eps,h/2.0-abs(r.y));\n    //Finally, multiply whether we have the right x and y.\n    return ret;\n}\n\n//Returns 1.0 at the very center of the given circle, dropping smoothly to the edge.\nfloat smoothPointBloom(vec2 r, vec2 center, float radius){\n    return 1.0-smoothstep(0.0,radius,length(center-r));\n}\n\n//Returns 1.0 when on the line given\n/*Inefficient version!\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth){\n    vec2 midpointRSpace = (p1+p2)/2.0;\n    \n    float angle = atan((p1.y-p2.y)/(p1.x-p2.x));\n    \n    vec2 rotatedSpaceCord = (r-midpointRSpace)*rotation(-angle);\n    \n    float lineLength = length(p1-p2);\n    \n    return smoothOriginRect(\n        rotatedSpaceCord,\n        lineLength+eps,\n        lineWidth\n    );\n}\nThis is a complete hack using rotational transformations on the r-coordinate. \nIt barely works and it does so with a lot of multiplications and trigonometric\nfunctions that could've been avoided. And, thanks to iq, (see comments) they are\nin the below version.\n*/\n\n//Returns 1.0 when on the line between the given points of width lineWidth.\n//All the credit to iq for this function. My abilities with dot products aren't\n//even close to that level of mastery.\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth)\n{\n    vec2 pa = r-p1, ba = p2-p1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    return 1.0 - smoothstep(-eps/2.0, eps/2.0, d-lineWidth/10.0 );\n}\n//Again, props to iq for the above!\n\n//Returns 1.0 when on the described polygon's edge.\nfloat polygonWireframe(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //Adjust our coordinate space so that the center of the polygon is the origin.\n    r -= center;\n    \n    //If we're outside any possible radius, break.\n    if(length(r)>radius+lineWidth) return 0.0;\n    //If the side count makes no sense, break.\n    if(sideCount<1) return 0.0;\n    \n    float ret = 0.0;\n    \n    //Point radius length up from center:\n    vec2 p0 = vec2(0.0, radius);\n    \n    //Angle of rotation swept by each edge:\n    float angle = 2.0*PI/float(sideCount);\n    //Angle of rotation of the currently checked pixel\n    float RSpaceAngle = toAngle(r);\n    //Rotation correction, such that drawing one line fills in all sides of the polygon.\n    r = rotation(-floor(RSpaceAngle/angle)*angle)*r;\n    \n    ret += line(r, p0, rotation(angle)*p0, lineWidth);\n    \n    \n    return ret;\n}\n\n//Returns 1.0 if the given point is on one of the lines of the described polygons.\n//Used to render polygons at each tip of a given polygon.\nfloat polyPointedPoly(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //Adjust our coordinate space so that the center of the polygon is the origin.\n    r -= center;\n    \n    //If we're too far from this whole shape, don't even bother trying to render.\n    if(length(r)>radius+(radius*2.0/float(sideCount))+lineWidth) return 0.0;\n    //If we're doing something stupid, don't even bother trying to render.\n    if(sideCount < 1) return 0.0;\n    \n    float ret = 0.0;\n    \n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    \n    //Angle of rotation of the currently checked fragment\n    float RSpaceAngle = toAngle(r)+angle/2.0;\n    //Rotation correction, such that drawing one line fills in all sides of the polygon.\n    r = rotation(-floor(RSpaceAngle/angle)*angle)*r;\n    \n    ret += polygonWireframe(r, p0, radius*2.0/float(sideCount), sideCount, lineWidth);\n    \n    return ret;\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point.\nvec2 getPolyPointN(vec2 center, float radius, int sideCount, int sideNum){\n    //This is the topmost point of the polygon.\n    vec2 p0 = vec2(0.0, radius);\n    //This is the angle swept between any two points of the polygon.\n    float angle = 2.0*PI/float(sideCount);\n    //This is the sideNumth point of the given polygon.\n    return center + p0*rotation(angle*float(sideNum));\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point,\n//adjusted by \"time\" to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyPointNTimeAdjust(vec2 center, float radius, int sideCount, int sideNum, float time){\n    vec2 p0 = getPolyPointN(center, radius, sideCount, sideNum);\n    vec2 p1 = getPolyPointN(center, radius, sideCount, sideNum + 1);\n    //This point is time*100 percent of the distance from p0 to p1.\n    return p0*time + p1*(1.0-time);\n}\n\n//Returns a vector2 representing the position of the sideNumth point of the polyNumth polygon,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyOfPolysPointNTimeAdjust(vec2 center, float radius, int sideCount, int polyNum, int sideNum, float time){\n    //Topmost poly center of the poly-of-polys\n    vec2 p0 = vec2(0.0, radius);\n    //Angle swept by any side of the poly-of-polys\n    float angle = 2.0*PI/float(sideCount);\n    //The center of the poly-of-polys polygon we care about.\n    vec2 p1 = p0*rotation(angle*float(polyNum));\n    //Finally, the time adjusted polygon point we actually care about.\n    return center + getPolyPointNTimeAdjust(p1, radius*2.0/float(sideCount), sideCount, sideNum, time);\n}\n\n//Main image, GLSL entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 r = -1.0 + 2.0*fragCoord/iResolution.xy;\n    r.x *= iResolution.x/iResolution.y;\n    \n    \n    //The current time, in two second loops.\n    //0.0 is 0 seconds, 1.0 is two seconds.\n    float time = mod(iTime,2.0)/2.0;\n    \n    //A list of colors. Have fun messing with these!\n    const vec3 bgColor = vec3(0.25,0.0,0.3);\n    const vec3 polyColor = vec3(5.0,0.0,5.0);\n    const vec3 lineColor = vec3(1.0,0.99,1.0);\n    const vec3 capColor = vec3(1.0);\n    \n    //Just some constants so that I don't have\n    //unlabeled numbers lying around everywhere.\n    //... Just mostly everywhere.\n    const float radius = 0.6;\n    const vec2 center = vec2(0.0);\n    \n    //Initially, set the background color.\n    vec3 ret = bgColor;\n    \n    \n    /* Inefficient version!\n    //Mix in the poly-pointed-poly on top.\n    ret = mix(ret,polyColor,polyPointedPoly(r, center, radius, SIDE_COUNT, 0.01));\n    \n    //Now the tricky bit. Cut the coordinate system such that \n    //every point is rotated into the 2pi/SIDE_COUNT space that\n    //contains one completely drawn polygon.\n    float angle = 2.0*PI/float(SIDE_COUNT);\n    r = rotation(-floor((toAngle(r)+angle/2.0)/angle)*angle)*r;\n    //Now if we draw in that 2pi/SIDE_COUNT space, it draws onto\n    //every polygon in the circle.\n\n\t\n\tAs you can see, the code in this inefficient comment used the poly-pointed-poly\n\tdraw function, then just replicated its functionality for the remaining draws.\n\t\n\tThe new version (below) just performs the poly-pointed-poly's draw operation\n\tfor it after setting up a similar coordinate space modification.\n\t*/\n    \n    \n    //Now the tricky bit. Cut the coordinate system such that \n    //every point is rotated into the 2pi/SIDE_COUNT space that\n    //contains one completely drawn polygon.\n    //This is the angle we need to cut\n    float angle = 2.0*PI/float(SIDE_COUNT);\n    //This is taking all of these slices and dropping them atop each other.\n    r = rotation(-floor((toAngle(r)+angle/2.0)/angle)*angle)*r;\n    //Now if we draw in that 2pi/SIDE_COUNT space, it draws onto\n    //every polygon space in the circle.\n    \n    //Next, mix in the poly-pointed-poly -- using only a single polygon draw!\n    //Notice, here, I'm moving the center of this polygon to where it would be\n    //on a poly-pointed-poly, and also reducing the radius to match.\n    ret = mix(ret,polyColor,polygonWireframe(r, vec2(0.0,radius), radius*2.0/float(SIDE_COUNT), SIDE_COUNT, 0.0));\n    \n    \n    \n    //Loop over every side, drawing the lines and dots.\n    for(int side=0; side<MAX_POLY_SIDE_COUNT; side++){\n        //If we're doing more sides than we have, don't bother.\n        if(side>=SIDE_COUNT) break;\n        \n        //This fetches the side points of the first and second polygons in the circle\n        vec2 p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 0, side, time);\n        vec2 p1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 1, side+1, time);\n        //Draws a line between them\n        ret = mix(ret, lineColor, line(r, p0, p1, 0.01));\n        //And draws points onto the first polygon\n        ret = mix(ret, capColor, smoothPointBloom(r, p0, 0.015));\n        \n        //This fetches the side points of the negative first and first polygons in the circle\n        vec2 pNeg1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, -1, side, time);\n        p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 0, side+1, time);\n        //Then draws lines between them.\n        ret = mix(ret, lineColor, line(r, pNeg1, p0, 0.01));\n    }\n    \n    //Finally, output the return color.\n\tfragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"}]}