{"ver":"0.1","info":{"id":"4stGW4","date":"1449668127","viewed":355,"name":"Cloudy lake","username":"Draedrus","description":"This is my first draft on terrain generation. I added day&night cycle and other stuff to make this more \"real\". I hope you will love the scene as much I love working on it :-)\nThe moon and the sun are also rendered, but not always on the camera sight ;-)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["heightmap","nightday"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\n#define NEAR 0.0\n#define FAR 5.0\n#define MOUNTS 4.0\n#define OCTAVES 8\n#define FOG_SPEED_FACTOR 0.02\n#define ASTRALSPEED 0.2\n#define CAMROTSPEED 0.08\n#define WATERLEVEL 0.2\n#define ASTRESIZE 0.3\n#define NIGHTANDDAY\n\n#define FIX2018\n#ifdef FIX2018\n#undef ASTRALSPEED\n#define ASTRALSPEED 0.1\n#endif\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n#ifdef NIGHTANDDAY\n    vec3 sunPos;\n\tvec3 moonPos;\n#else\n\tvec3 sunPos = vec3(0.1, 3.0, 0.0);\n#endif\n    Light sun;\n#ifdef NIGHTANDDAY\n    Light moon;\n#endif\nvec4 ambientColor = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 skyColor = vec4(0.6, 0.6, 0.9, 1.0);\nvec4 nightSkyColor = vec4(0.1, 0.1, 0.4, 1.0);\nvec4 waterColor = vec4(0.1, 0.4, 0.7, 1.0);\nvec4 nightWaterColor = vec4(0.01, 0.1, 0.4, 1.0);\nvec4 mountColor = vec4(0.6, 0.5, 0.5, 1.0);\nvec4 fogColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat noise(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(noise(wx+0.0)     ,      noise(wx+1.0), f.x),\n                mix(noise(wx+0.0+winy), noise(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(noise(wx+0.0+winz)     ,      noise(wx+1.0+winz), f.x),\n                mix(noise(wx+0.0+winy+winz), noise(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nvec4 clouds2(vec3 p, float y) {\n    p.z = p.z+cos(iTime*FOG_SPEED_FACTOR);\n    vec4 c = vec4(perlin(p*6.0));\n    c = mix(c, vec4(perlin(p*2.0)), y);\n    c = mix(c, vec4(perlin(p*4.0)), y);\n    return clamp(c, 0.0, 1.0);\n}\n\nvec4 blinnPhong(vec4 bColor, Light l, vec3 normal, vec3 vV, float shininess) {\n    vec3 N = normalize(normal);\n    float lambertTerm = max(dot(-l.d, N), 0.0);\n    float specular = 0.0;\n    float screenGamma = 2.2;\n\n    if(lambertTerm>0.0) {\n        vec3 viewDir = normalize(vV);\n\n        vec3 halfDir = normalize(-l.d+vV);\n        float specAngle = max(dot(halfDir, N), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    vec4 colorLinear = //ambientColor +\n        lambertTerm * bColor; // diffuse color\n    \tif(shininess>0.0)\n        colorLinear += specular * vec4(1.0); // specular color\n    vec3 colorGammaCorrected = pow(colorLinear.xyz, vec3(1.0/screenGamma));\n    return vec4(colorGammaCorrected, 1.0)*l.power;\n}\n\n/*****\n * START TERRAIN GENERATION\n *****/\n\nfloat mapTerrain(vec2 a) {\n    //return (cos(a.x*30.0)*sin(a.y*30.0))*0.1;\n    float h = perlin(vec3(a.x, a.y, a.x*a.y)*2.1)*0.3;\n    h+=smoothNoise(vec3(a.x, a.y, a.x*a.y)*2.0)*0.1;\n    h+=smoothNoise(vec3(a.x*a.x, a.y, a.x*a.y)*0.02)*4.0;\n    return h;\n}\n\nfloat map(vec3 pt) {\n    return perlin(pt);\n}\n\n/*****\n * END TERRAIN GENERATION\n *****/\n\n// again, thanks IQ for the method, without this one I could not have a terrain before long !\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - mapTerrain( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float t = -1.0;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\nvec4 pixColor(vec3 ro, vec3 rd) {\n    float t = raycast(ro, rd, NEAR, FAR);\n    vec3 pt = ro+t*rd;\n    if(t>FAR) { // sky\n        vec4 pColor = skyColor;\n        #ifdef NIGHTANDDAY\n        pColor = mix(\n            skyColor,\n            nightSkyColor,\n            max(1.0-sun.o.y/3.0, 0.0));\n        // sun\n        float t2 = IntersectSphere(ro, rd, sun.o, ASTRESIZE);\n        if(t2>0.0) {\n            pColor = mix(\n                vec4(1.0, 1.0, 0.4, 1.0),\n                vec4(1.0, 0.0, 0.0, 1.0),\n                max(1.0-sun.o.y/3.0, 0.0))*(smoothNoise((ro+rd*t2-sun.o))+0.8);\n        }\n        // moon\n        t2 = IntersectSphere(ro, rd, moon.o, ASTRESIZE);\n        if(t2>0.0) {\n            pColor = moon.diffuseColor*perlin(ro+rd*t2-moon.o);\n        }\n        #endif\n        // clouds\n        pColor+= perlin(vec3(rd.x/2.0, rd.y/2.0, rd.z/2.5))/2.5;\n        return pColor;\n    }else if(t>MOUNTS) {\n        float y = pt.y;\n        vec4 pColor = vec4(0.0);\n        pColor = mix(mountColor, vec4(1.0), smoothNoise(pt)*(y/0.3));\n        #ifdef NIGHTANDDAY\n        return mix(pColor, vec4(0.0), max(1.0-sun.o.y/3.0, 0.0));\n        #else\n        return pColor;\n       \t#endif\n    }else{ // terrain\n        vec3 normal = pt-vec3(\n            mapTerrain( vec2(pt.x, pt.y)),\n            mapTerrain( vec2(pt.x, pt.y)+0.1),\n            mapTerrain( vec2(pt.x, pt.y))\n        );\n        #ifdef NIGHTANDDAY\n        Light astre = sun;\n        if(moon.o.y>sun.o.y)\n            astre = moon;\n        #endif\n        float y = pt.y;\n        vec4 pColor = vec4(0.0);//vec4(0.1, 0.8, 0.5, 1.0)*pt.y*perlin(pt);\n        if(y<WATERLEVEL) { // water\n            pt.y = WATERLEVEL;\n            y = pt.y;\n            pColor = waterColor*perlin(rd*0.5);\n            #ifdef NIGHTANDDAY\n            \n            pColor = mix(\n                mix(pColor, max(clouds2(pt, 1.0-(FAR-t)/FAR), 0.0), 0.5),\n                nightWaterColor,\n                max(1.0-astre.o.y/3.0, 0.0));\n            \n                pColor = blinnPhong(pColor, astre, vec3(\n                    max(noise(pt.x)-0.99, 0.0),\n                    max(noise(pt.x)-0.98, 0.0)+0.02,\n                    max(noise(pt.z)-0.99, 0.0)), rd, -0.5);\n            return pColor;\n            #endif\n            return mix(pColor, max(clouds2(pt, 1.0-(FAR-t)/FAR), 0.0), 0.5);\n        }else if(y>=WATERLEVEL) { // trees\n            vec3 n = vec3(\n                cos((t+FAR)*600.0)/20.0+0.3,\n                0.3,\n               \tsin((t+FAR)*600.0)/20.0+0.3\n                );\n            pColor = mix(vec4(0.1, 0.8, 0.5, 1.0)*pt.y*perlin(pt), vec4(1.0), y/0.8);\n            \n        \t#ifdef NIGHTANDDAY\n        \t\tpColor = mix(pColor,\n                         astre.diffuseColor*\n                             max(0.0, dot(-astre.d, normalize(n)))*y*3.9,\n                         max(0.0, dot(-astre.d, normalize(normal))-0.5))*y*3.0;\n        \t\tpColor = blinnPhong(pColor, astre, n, rd, -1.0);\n            #else\n        \t\tpColor = mix(pColor,\n                         sun.diffuseColor*max(dot(-sun.d, normalize(n)),\n                                               0.0)*y*3.9,\n                         max(dot(-sun.d, normalize(normal))-0.5,\n                                               0.0))*y*3.0;\n        \t\tpColor = blinnPhong(pColor, sun, n, rd, -1.0);\n            #endif\n        }\n        #ifdef NIGHTANDDAY\n        return mix(\n            pColor+max(clouds2(pt, 1.0-(FAR-t)/FAR)*((0.25-y)/0.25), 0.0),\n            vec4(0.0),\n            max(1.0-astre.o.y/3.0, 0.0));\n\n        #else\n        //pColor = blinnPhong(pColor, sun, normal, rd);\n        return pColor+max(clouds2(pt, 1.0-(FAR-t)/FAR)*((0.25-y)/0.25), 0.0);//vec4(normal, 1.0);\n        \n       \t#endif\n    }\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 camPos(float t) {\n    return vec3(cos(t), 0.7, sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunPos = FAR*vec3(cos(iTime*ASTRALSPEED), sin(iTime*ASTRALSPEED), 0.0);\n    sun = Light(\n        sunPos,\n        normalize(vec3(0.0, 0.0, 0.0)-sunPos),\n        vec4(1.0, 1.0, 0.3, 1.0),\n        16.0,\n    \t1.0);\n#ifdef NIGHTANDDAY\n    moonPos = -sunPos;\n    moon = Light(\n        moonPos,\n        normalize(vec3(0.0, 0.0, 0.0)-moonPos),\n        vec4(0.9, 0.9, 1.0, 1.0),\n        16.0,\n    \t0.3);\n#endif\n    vec2 pixel = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    // corrections added from 2018, initial shader from 2015\n    #ifdef FIX2018\n    pixel.x *= iResolution.x/iResolution.y;\n    #endif\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n\n    vec3 ro = camPos(Time);\n    vec3 rd = vec3(pixel, 2.0)+vec3(mv, 0.0)*1.0;\n    mat3 ca = setCamera(ro, camPos(Time+3.0), vec3(0.0, 1.0, 0.0));\n\n    rd = ca*normalize(rd);\n    fragColor = pixColor(ro, rd);\n}","name":"Image","description":"","type":"image"}]}