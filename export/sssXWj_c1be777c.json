{"ver":"0.1","info":{"id":"sssXWj","date":"1619446844","viewed":162,"name":"ZA WARUDOOOOOOO","username":"eigen","description":"Za Warudo effect in shader\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["jjba"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO Get easing function formulas and chunk the animation into a time frame (using mod)\n\n// TODO set constant for canvas aspect ratio\nconst float aspectRatio = 1.77;\nconst float barrelPower=1.0;\nconst float timePeriod = 4.0;\n\n//prng\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Perlin noise \nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 randVal = random2(i);\n\n    return mix( mix( dot( randVal, f - vec2(0.0,0.0) ),\n                     dot( randVal, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( randVal, f - vec2(0.0,1.0) ),\n                     dot( randVal, f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// set a white glow on edge of circles\nvec4 whiteOutline(in float timingVal, in float radius){\n  float outerEdge = smoothstep(clamp(timingVal+0.02,0.,1.)-0.1,clamp(timingVal+0.02,0.,1.), radius);\n  float innerEdge = smoothstep(clamp(timingVal+0.01,0.,1.),clamp(timingVal+0.01,0.,1.)+0.01, radius);\n  return vec4(vec3(outerEdge-innerEdge),1.);\n}\n\n// This function takes in a texture, inverts it based on a given shape\nvec4 imageFilter(in vec2 st, in vec4 color,in vec4 filteredColor,in float timePercent){\n     //Offset\n     st -= vec2(0.5*aspectRatio,0.5);\n     float r = length(st)*.8;\n     // Generate the negative color \n\n     // this is the radius over time\n     float timingVal = timePercent ;\n     float a = 0.2*atan(st.y,st.x);\n     timingVal += (sin(a*50.)*timingVal)*noise(st+.2)*0.2;\n\n     //We multiply by the scaling of the x axis to ensure the circle covers the entire frame\n     float circlePos = smoothstep(clamp(timingVal,0.,1.),clamp(timingVal,0.,1.)+0.007, r);\n\n     // we need to add the segment of textures that have the filter applied and the segme +nt that doesnt to make a congruent image\n     return  color*vec4(circlePos)+ whiteOutline(timingVal,r) + filteredColor*vec4(1.-circlePos);\n}\n\nvec2 barrelDistort(vec2 pos, float power)\n{\n\tfloat t = atan(pos.y, pos.x);\n\tfloat r = pow(length(pos), power);\n\tpos.x   = r * cos(t);\n\tpos.y   = r * sin(t);\n\treturn 0.5 * (pos + 1.0);\n}\n\nfloat easeInCubic(in float x){\n    return x * x * x;\n}\n\nfloat easeOutCubic(in float x){\n    return 1. - pow(1. - x, 3.);\n}\n\n// Main Loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p  = -1.0 + 2.0*uv;\n    // Alter to fit the aspect ratio of the given canvas  TODO: swap to division of width and height of canvas\n    vec2 st = uv * vec2(aspectRatio,1.);\n    \n    // handle the timing block\n    float currTime = mod(iTime,timePeriod);\n    float negativeWaveTime = 0.8;\n\n    vec3 yellowShade = vec3(1,1,0);\n    if(currTime > 0. && currTime <= 1.8){\n  \n        float timeSegment = easeOutCubic(clamp(currTime,0.,.9)/0.9);\n        if (currTime > 1.1){\n        timeSegment = 1.-easeInCubic(clamp(currTime-0.9,0.,.9)/0.9);\n        }\n        float barrel_pow =1.0 + 0.2 * (1.0 +  timeSegment );\n        p = barrelDistort(p,1./(barrel_pow)); \n        uv = (p-uv)+ uv;\n    }\n   \n    vec4 tex = texture(iChannel1, uv);\n    vec4 imageNegative = vec4(1.) - tex ;\n    vec4 imageYellowNegative = vec4(.8,.8,0.,1.)-tex;\n    vec4 greyImage = vec4(dot(tex,vec4(0.299, 0.587, 0.114,0.)));\n    if(currTime <= 0.8){\n       fragColor = imageFilter(st,tex,imageNegative,clamp(currTime,0.,.8)/negativeWaveTime);\n    }else if (currTime > 0.8 && currTime <= 1.2){\n       fragColor = imageFilter(st,imageNegative,imageYellowNegative,clamp(currTime-0.8,0.,.4)/0.4);\n    }\n    else if (currTime > 1.2 && currTime <= 1.8){\n       fragColor = imageFilter(st,imageNegative,imageYellowNegative,1.-clamp(currTime-1.2,0.,.6)/0.6);\n    }\n    else if (currTime > 1.8 && currTime <= 2.4){\n       fragColor = imageFilter(st,greyImage,imageNegative,1.-clamp(currTime-1.8,0.,.6)/0.6);\n    }\n    else if (currTime > 2.4){\n       fragColor = greyImage;\n    }\n    else{\n    fragColor = tex;\n    }\n\n\n    \n}","name":"Image","description":"","type":"image"}]}