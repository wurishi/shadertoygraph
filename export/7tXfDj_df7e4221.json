{"ver":"0.1","info":{"id":"7tXfDj","date":"1651475532","viewed":158,"name":"Floats which act like ints","username":"TrueBoolean","description":"Bitwise operations are implemented as if the float had positional bits. Methods like this are needed in languages like Javascript which don't have any integer type, or old GLSL with no bit ops. So that bitwise effects can be in very high level languages.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","simple","binary","xor","sierpinski","double","int","float","bitwise","and","javascript"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Simulating bitwise effects with arithmetic only\n//For maximizing portability as well as translating to other languages (Javascript)\n//3 Types of Bitwise Effects implemeted using Floats:\n\n//Binary Count, Sierpinski Triangles, and OR/NOR\n\n//Binary printing\n//Extract bits from a float as if it were positional binary, \"fake bits\"\n//This is an approximate binary count and once the values get\n//large enough the wrong bits will start to be printed as float precision gets worse\n//This one sets up the frame differently from the others\n//In general you can get roughly one byte to one short of accurate fake bits from a 32 bit float\n//When using ints you would \"AND 1\" then \"SHIFT RIGHT 1\" to extract the bit\n\nvec2 binaryCount(vec2 FPT){\n\n    float col = 1.;   \n    for(float i = 0.; i < 16.; ++i){\n    \n        float fakebit = mod(FPT.x, 2.);\n        FPT.x /= 2.;\n        if(fakebit < 1. && floor(FPT.y) == i){\n            col = 0.;\n            break;\n        }\n    }\n    return vec2(col, 1.);\n}\n\n//Logical Bitwise OR/NOR\n//With ints, x|y\nvec2 floatingOR(vec2 FPT){\n\n    float col = 0.;   \n    for(int i = 0; i < 6; ++i){\n    \n        col /= 2.; //Now bits are placed from left to right\n        vec2 fakebit = mod(FPT, 2.);\n        FPT /= 2.;\n        if(fakebit.x < 1. || fakebit.y < 1.)\n            col += 32.; //Now bits are placed from left to right so we can't just add 1 anymore\n    }\n    return vec2(col, 64.);\n}\n\n//Sierpinski triangles fractal made of small triangles rather than squares as with AND operation\n//One of the advantages of creating our own bit effects is that they can be customized beyond AND, OR and XOR.\n//This custom effect allows the sierpinski to be made of triangles instead of squares as AND would traditionally do.\n//When using ints the closest effect similar would be x & y < 1 ? 255: 0\n\nvec2 simpleSierpinski(vec2 FPT){\n\n    float col = 0.;   \n    for(int i = 0; i < 7; ++i){\n    \n        col *= 2.;\n        vec2 fakebit = mod(FPT, 2.);\n        FPT /= 2.;\n        if(fakebit.x < fakebit.y) //BIT1 is 0 and BIT2 is 1\n            col += 1.;\n    }\n    return vec2(col, 1.);\n}\n\n//Finally every effect is put together in a multi display\nvoid mainImage(out vec4 FCOL, in vec2 FPT){\n\n    vec2 countingScreen = vec2((FPT.y/iResolution.y)*16.+iTime*12.,(FPT.x/iResolution.y)*16.);\n    vec2 split = FPT;\n    FPT *= sin(iTime)+2.;\n    FPT.x += iResolution.x*iTime/3.;\n    FPT.y -= iResolution.x*iTime/4.;\n    FPT /= iResolution.y;\n    FPT *= 64.;\n    \n    float swap = mod(iTime/5., 2.);\n    vec2 r;\n    if(split.x < iResolution.x/2.)\n        r = binaryCount(countingScreen);     \n    else if(swap < 1.)\n        r = simpleSierpinski(FPT);\n    else\n        r = floatingOR(FPT);\n        \n    FCOL = vec4(vec3(r.x/r.y), 1.);\n    FCOL.y /= 3.;\n}\n\n//Additional Reads\n\n//Fake Floating XOR\n//It might actually have more iterations with a double precision float\n//This could be extended to make a 3D XOR texture as well by iterating a second time\n//This should also make it clear how to do the less popular AND and OR textures as well\n//When using ints this effect would be x ^ y, 3D counterpart is x^y^z\n//Replace floatingOR with this function\n/*\nvec2 floatingXOR(vec2 FPT){\n\n    float col = 0.;   \n    for(int i = 0; i < 6; ++i){\n    \n        col /= 2.;\n        vec2 fakebit = mod(FPT, 2.);\n        FPT /= 2.;\n        //The XOR is the logical intersection set (AND) minus the logical union set (OR)\n        int inter = fakebit.x < 1. && fakebit.y < 1. ? 1 : 0;\n        int uni = fakebit.x < 1. || fakebit.y < 1. ? 1 : 0;\n        if(uni - inter < 1)\n            col += 64.;\n    }\n    return vec2(col, 128.);\n}\n*/\n\n/* //Simulated Logical NAND, sierpinski triangles are made of small squares instead of small triangles\nvoid mainImage(out vec4 FCOL, in vec2 FPT){\n\n    FPT *= sin(iTime)+2.;\n    FPT.x += iResolution.x*iTime/3.;\n    FPT.y -= iResolution.x*iTime/4.;\n    FPT /= iResolution.y;\n    FPT *= 64.;\n    \n    float col = 0.;   \n    for(int i = 0; i < 7; ++i){\n    \n        col *= 2.;\n        vec2 fakebit = mod(FPT, 2.);\n        FPT /= 2.;\n        if(fakebit.x < 1. && fakebit.y < 1.) //Logical NAND\n            col += 1.;\n    }\n    \n    FCOL = vec4(vec3(col+ sin(iTime*2.)),1.);\n    FCOL.y/=3.;\n}\n*/","name":"Image","description":"","type":"image"}]}