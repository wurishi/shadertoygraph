{"ver":"0.1","info":{"id":"NdfSz4","date":"1687416489","viewed":91,"name":"Electromagnetic Field SIM","username":"romeosoft","description":"Visualization of electromagnetic field.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["physics","gui","electromagneticfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n#define B0    particles[0].b\n#define B1    particles[1].b\n#define B2    particles[2].b\n#define B3    particles[3].b\n\n// from iq\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox(in vec2 p, in vec2 b, in vec4 r) {\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p) - b + r.x;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n}\n\nfloat sdParticle(in vec2 p, particle pa)\n{\n   return sdRoundBox(p, measureB(pa),measureR(pa));\n}\n\nparticle particles[5];// ui elements\n// ---------------------------------------------------------\n// Gui\n// ---------------------------------------------------------\nvec3 Gui(vec2 p)\n{\n   vec3 col = BLACK;\n   \n    // Coordnate\n    crd2 c = uxy_c(UX, UY);\n    c.o -= UY * 0.8;\n    //crd2 c2 = uxy_c(UY, -UX);\n    //c2.o -= UY * 0.5;\n    //crd2 c = blend_c(c1, c2, 0.5);\n    \n    // Particle (ui elements)\n    particles[0] = crt_pa(-UX*0.5);\n    particles[1] = crt_pa(-UX*0.25);\n    particles[2] = crt_pa(XY0);\n    particles[3] = crt_pa(UX*0.25);\n    particles[4] = crt_pa(UX*0.5);\n                                   \n   vec2 mouse =  (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n   \n   for(int i = 0; i < 5; i ++)\n   {\n        particle pa = particles[i];\n        \n        real fac = 0.5;\n        \n        if(mouse.y < -0.5 && abs(mouse.x - p_z_c(pa.pos, c).x) < 0.1)\n        {\n             pa = stateB_pa(pa, vec2(1.1,1.1));\n             \n             pa = stateR_pa(pa, \n                real(i) * vec4(1.0)\n                );\n                \n             // Gauge\n             gauge ga = crt_ga(0.1, iTime * 5.0);\n             \n             pa = pa_x_ga(pa, ga);  \n             \n             fac = 1.0;\n             \n             // UI Trigger eigen vector changes\n             if(i == 0)\n                 particles[i].b.x = -2.0;\n             else if(i == 1)\n                 particles[i].b.x = 10.0;\n             else if(i == 2)\n                 particles[i].b.x = 5.0;  \n             else if(i == 3)\n                 particles[i].b.x = 5.0;  \n        }\n        else\n        {\n             pa = stateB_pa(pa, vec2(0.5,0.5));\n             \n             pa = stateR_pa(pa, \n                real(i) * vec4(1.0)\n                );\n                \n             // Gauge\n             gauge ga = crt_ga(0.1, 1.0);\n             \n             pa = pa_x_ga(pa, ga);\n        }\n       \n       // c = rot_c(c, PI / 18. * real(i) * iTime + PI / 8. );\n        \n        vec2 pc = p_z_c(p - pa.pos, c);\n        \n        // SD Particle(ui elements)\n        float sd = sdParticle(pc, pa) / fac;\n        \n        col += abs(sd) < 0.018 ? \n            fac * vec3(0.5 + 0.25 * sin(sd * 158.58),0.75,0.28) : \n            vec3(0.0,0.0,0.0);\n    }\n    return col;\n}\n\n// ---------------------------------------------------------\n// mainImage\n// ---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    vec2 p2d = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m2d = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 col = BLACK;\n    \n    vec3 gui = Gui(p2d);\n        \n    float eyer = 2.0;\n    float eyea = -((iMouse.x) / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * PI * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.5 + left*p2d.x + up*p2d.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.08;\n    vec3 cor = vec3(0.0);\n    vec3 o1  = vec3(-1.0,0.0,0.0);\n    vec3 o2  = vec3(1.0,0.0,0.0);\n    \n    float n = 3.0;\n    float lambda = 0.05;\n    \n    if(p2d.y < -0.58)\n        n = 3.;\n    else if(B3.x >1.)\n    {\n        lambda = 0.01;\n    }\n    else\n    {\n        n = 5.;\n        lambda = 0.05;\n    }\n    \n    float T1 = (n*PI*iTime);\n    float T2 = (-n*PI *iTime);\n    for(int i = 0; i < 58; i ++)\n    {\n        p += v * dt;\n     \n        float r1 = length(p-o1);\n        float r2 = length(p-o2);\n        \n        vec3 f =\n        normalize(o1-p)*(1. / (r1*r1) * (cos(r1 / lambda + T1))) + \n        normalize(o2-p)*(1. / (r2*r2) * (cos(r2 / lambda + T2)));\n  \n        cor += (f) * 0.058 * B0.x;\n    }\n    \n    if(p2d.y < -0.58)\n        col = gui + ((cor) * 0.018);\n    else if(B3.x >1.)\n    {\n        col = (cor*0.5);\n       \n    }\n    else\n    {\n        col = ((cor * 0.25*particles[1].b.x));\n        if(B2.x >1.)\n            col = WHITE - col * 1.2;\n    }\n        \n    // Output to screen\n    fragColor = vec4(col + vec3(0.08,0.0,0.18),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n*           Visualization of Natural Phenomena using GUI Elements\n*\n*    This code aims to demonstrate the visualization of natural phenomena\n*    using GUI elements. The GUI elements chosen are simple buttons,\n*    which represent the particle's state values. The changes in the particle's\n*    state values are reflected in the properties of the buttons,\n*    while the background scene effects correspond to the changes\n*    in the particle cloud's phase.\n*/\n#define PI 3.14156\n#define real float\n#define imag float\n#define quat quaternion\n#define crd2 coord2\n\n#define CSCREEN vec2(0.5,0.5)\n\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW vec3(1,1,0)\n#define GREY vec3(0.5,0.5,0.5)\n\n#define XY0 vec2(0, 0)\n#define UX vec2(1,0)\n#define UY vec2(0,1)\n#define UC crd2(UX, UY, XY0)\n\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nvec3 blend(vec3 a, vec3 b, real t) {\n    if (t <= 0.) {\n        return a;\n    } \n    if (t >= 1.) {\n        return b;\n    } else {\n        return mix(a, b, t);\n    }\n}\n\n// ---------------------------------------------------------\n// 2D Coordinate System:\n// A coordinate system in two-dimensional space \n// consists of an origin plus two orientation axes\n// c++ version: \n// https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord2\n{\n    vec2 ux, uy; // two axial unit vectors(base vectors)\n    vec2 o;      // origin\n};\n\ncoord2 uxy_c(vec2 _ux, vec2 _uy)\n{\n    coord2 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.o = XY0;\n    return c;\n}\n\ncoord2 norm_c(coord2 c)\n{\n    c.ux = normalize(c.ux);\n    c.uy = normalize(c.uy);\n    return c;\n}\n\ncoord2 rot_c(coord2 c, real angle)\n{\n    c.ux = ROT(c.ux, angle);\n    c.uy = ROT(c.uy, angle);\n    return c;\n}\n\n// p * c\nvec2 p_x_c(vec2 p, coord2 c)\n{\n    return c.ux * p.x + c.uy * p.y + c.o;\n}\n\n// p / c\nvec2 p_z_c(vec2 p, coord2 c)\n{\n    vec2 v = p - c.o;\n    return vec2(dot(v, c.ux), dot(v, c.uy));\n}\n\nreal v_dot_c(vec2 v, coord2 c)\n{\n    return dot(v, c.ux + c.uy);\n}\n\nreal c_cross_c(coord2 a, coord2 b)\n{\n    return dot(a.uy, b.ux) - dot(a.ux, b.uy);\n}\n\ncoord2 flipx_c(coord2 c)\n{\n    c.ux = -c.ux;\n    return c;\n}\n\ncoord2 flipy_c(coord2 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\n\ncoord2 blend_c(coord2 c1, coord2 c2, real t)\n{\n    coord2 ret;\n    ret.ux = normalize(mix(c1.ux, c2.ux, t));\n    ret.uy = normalize(mix(c1.uy, c2.uy, t));\n    return ret;\n}\n\n// ---------------------------------------------------------\n// gauge (time transform)\n// ---------------------------------------------------------\nstruct gauge\n{\n  float scale; // real time\n  float theta; // imagine time\n};\ngauge crt_ga(real _scale, real _theta)\n{\n   gauge ga;\n   ga.scale = _scale;\n   ga.theta = _theta;\n   return ga;\n}\n\n// ---------------------------------------------------------\n// particle (ui element)\n// ---------------------------------------------------------\nstruct particle \n{\n  vec2 pos;\n  \n  // states, exp(states)\n  vec2 b_states;\n  vec4 r_states;\n  \n  // eigen vectors\n  vec2 b;\n  vec4 r;\n};\n\nparticle crt_pa(vec2 p)\n{\n  particle pa;\n  pa.pos = p;\n  \n  pa.b = vec2(0.58);\n  pa.r = vec4(0.18);\n  \n  pa.b_states = vec2(1.);\n  pa.r_states = vec4(1.);\n  \n  return pa;\n}\nparticle stateB_pa(particle pa, vec2 delta_b)\n{\n    particle ret = pa;\n    ret.b_states += delta_b;\n    \n    return ret;\n}\nparticle stateR_pa(particle pa, vec4 delta_r)\n{\n    particle ret = pa;\n    ret.r_states += delta_r;\n    \n    return ret;\n}\nparticle pa_x_c(particle pa, crd2 c) \n{\n  pa.pos = p_x_c(pa.pos, c);\n  return pa;\n}\nparticle pa_x_ga(particle pa, gauge ga) \n{\n  particle ret = pa;\n  ret.b *= ga.scale;\n  ret.r *= ga.scale * (1.0 + 1.0 * cos(ga.theta));\n  \n  return ret;\n}\n\nvec2 measureB(particle pa)\n{\n    return pa.b * (0.75 + 0.25 * cos(pa.b_states * PI));\n}\nvec4 measureR(particle pa)\n{\n    return pa.r * (0.75 + 0.25 * cos(pa.r_states * PI));\n}","name":"Common","description":"","type":"common"}]}