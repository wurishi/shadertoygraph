{"ver":"0.1","info":{"id":"wtSfzt","date":"1599597482","viewed":117,"name":"Hexagon tiling [hexUVs and IDs]","username":"Zumer_Vlad","description":"Based on: https://www.shadertoy.com/view/3sSGWt\n\nThe UVs align with a hexagon sitting in the UV square with the top and bottom point touching it.\nHexagons can be indexed like a 2d matrix.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","tiling","hex","hex","hexagons","hexagontiling","hextiling","hextiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Vlad-Alexandru Zumer\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nvec4 HexCoords(vec2 uv) {\n\t\n    vec2 r = vec2(1, 1.73001); // 1, sqrt3\n    vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h; // tile UV coords and move 0,0 to center of tile\n    vec2 b = mod(uv-h, r)-h; // move uv coords, tile and move 0,0 to centre of tile\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; // select which tile are in based on distance from the origin of the tile\n    // fix UVs back to square\n    gv.y = gv.y*h.y;\n    gv += 0.5;\n    \n    //id\n    \n    float isB = dot(a, a) < dot(b,b) ? 0. : 1.;\n    \n    vec2 aux = uv + isB * vec2(0.5,0.);\n    float x_id = floor(aux.x/1.);\n    float y_id = isB * 2.*floor((uv.y+.866)/1.73) + (1.-isB)* (2.*floor((uv.y)/1.73)+1.);\n    \n    //calculater id\n    vec2 id = dot(a, a) < dot(b,b) ? vec2(1.) : vec2(0.); // multiplcations needed for close to 0 rounding errors\n    return vec4(gv, x_id,y_id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float size = 20.; //30.*sin(iTime)+30.;\n    \n    uv *= size;\n    //uv += .5*size*(iResolution.xy/iResolution.y);\n    \n    vec4 hc = HexCoords(uv+vec2(0.,0. ));\n    \n    col += vec3(hc.zw/(size*iResolution.xy/iResolution.y),0.);\n    \n    // select row of ID = 1\n    \n    if(abs(hc.w - 0.) <= 0.0001 || abs(hc.z - 0.) <= 0.0001)\n    {\n        col += vec3(0.,0.,1.);\n    }\n    \n    //col = texture(iChannel0,hc.zw/(size*iResolution.xy/iResolution.y)).rgb; \n    \n    //DEBUG!!!\n    //\n    //if(abs(hc.x-0.5) < .02 || abs(hc.y-.75) < 0.02 || abs(hc.y-.25) < 0.02)\n    //{\n    //    //col += 1.;\n    //}\n    //\n    if(length(uv-vec2(.0,-0.)) < 0.05)\n    {\n       //col *= vec3(.5);\n       //col = vec3(uv-vec2(1.,0.),0.)/5.;\n       //col = vec3(1.);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}