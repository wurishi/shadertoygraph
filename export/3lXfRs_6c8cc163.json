{"ver":"0.1","info":{"id":"3lXfRs","date":"1597412636","viewed":227,"name":"Flubbers","username":"_pwd_","description":"It´s like Charlies Chocolate Factory is now producing rainbow flubber candy deluxe","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","reflection","wobble","rubber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4l2GWy","filepath":"https://soundcloud.com/vozdra/solar-fields-unite","previewfilepath":"https://soundcloud.com/vozdra/solar-fields-unite","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n//\n// Rubbercube \n// -> Charlies Chocolate Factory´s now producing rainbow flubber candy \n//\n//\n//\n//\n//\n// references\n// \"Rubbercube\" based on Demoscene Passivist´s\n// https://bit.ly/3akEOP7\n//\n// distfunctions\n// https://iquilezles.org/articles/distfunctions\n//\n// Sound via soundcloud - Solar Fields: Unite\n//\n//\n//\n//    \n//\n//\n\n\nfloat m;\nfloat time;\nvec3 sync;\nvec3 n;\nint material = 0;\n\nconst vec3 materialdiffuse = vec3(1.0, 1.0, 1.0);\nconst float materialspecularexponent = 256.0;\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// displacement(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat displace(vec3 p) \n{\n\treturn ((cos(2.*p.x)*sin(4.*p.y)*sin(2.*p.z))*cos(30.1 + sin(time)*0.01));\n}\n\n\nfloat displace1(vec3 p) \n{\n\treturn ((cos(2.*p.x)*sin(4.*p.y)*sin(2.*p.z))*cos(30.1 + sin(time)*0.01));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// x,y,z rotation(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2;\n\tp.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2;\n\tp.z = z2;\n\treturn p;\n}\n\nvec3 rotZaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\n\tp.x = x2;\n\tp.y = y2;\n\treturn p;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// polyomial smooth min (IQ)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// cylinder\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n\treturn length(p.xz-c.xy)-c.z;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// round-box\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat pRoundBox(vec3 p, vec3 b, float r) \n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// boxes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat boxes(vec3 pos) \n{\n    float deform1 = displace1(pos);\n    \n\tm = pRoundBox(rotYaxis(rotXaxis(vec3(2.0+0.45*sin(0.8*iTime+1.2),0.77,-1.5-0.40*sin(0.8*iTime+1.2)) + pos, iTime*0.3),iTime), vec3(0.21,0.21,0.21), 0.05);\n\tm = smin (m, pRoundBox(rotYaxis(rotXaxis(vec3(-2.0+0.45*sin(0.8*iTime+1.2),0.77,-1.5+0.40*sin(0.8*iTime+1.2)) + pos, iTime*0.3),iTime), vec3(0.21,0.21,0.21), 0.05),1.4);\n\n\treturn m + deform1 * 0.45;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// union\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid fUnion(inout float d1, float d2) \n{\n    d1 = smin(d1,d2,0.5);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// map\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat map(vec3 hitpoint, vec2 fragCoord) {\n\n\tfloat d = 1.0;\n\tfloat c = 1.0;\n\n    float rubberfactor = 0.0035;\n    float phi = (1.25 + sync.r) * (time+(fragCoord.y*rubberfactor));\n    mat4 xrot = mat4(\n        vec4(1.0,       0.0,      0.0, 0.0),\n        vec4(0.0,  cos(phi), sin(phi), 0.0),\n        vec4(0.0, -sin(phi), cos(phi), 0.0),\n        vec4(0.0,       0.0,      0.0, 1.0)\n    );\n    float theta = 0.75*(time+(fragCoord.y*rubberfactor));\n    mat4 yrot = mat4(\n        vec4(cos(theta), 0.0, -sin(theta), 0.0),\n        vec4(       0.0, 1.0,         0.0, 0.0),\n        vec4(sin(theta), 0.0,  cos(theta), 0.0),\n        vec4(       0.0, 0.0,         0.0, 1.0)\n    );\n    float psi = 0.15*(time+(fragCoord.y*rubberfactor));   \n    mat4 zrot = mat4(\n        vec4( cos (psi), sin (psi), 0.0, 0.0),\n        vec4(-sin (psi), cos (psi), 0.0, 0.0),\n        vec4(       0.0,       0.0, 1.0, 0.0),\n        vec4(       0.0,       0.0, 0.0, 1.0)        \n    );  \n\n    vec3 rubberPos = vec3(yrot*xrot*zrot*vec4(hitpoint,1.0));\n\tvec3 rubberPos1 = rubberPos + vec3( 2.1, 0.0, 0.0);\n\n\tfloat m = 1.75; float s = 0.13;  \n\n    float deform  = displace(rubberPos);\n    float deform1 = displace1(rubberPos);\n    \n\tfUnion(d, pRoundBox( rubberPos, vec3(0.69,0.69,0.69), 0.35) );\n\tfUnion(d, sdCylinder(vec3(1.95*cos(0.2*iTime+1.2),1.9,-1.95*sin(0.2*iTime+1.2)) + hitpoint,vec3(0.0,0.0,0.22) ) + /*noise1(hitpoint) * 0.1*/deform );\n\n\tm = boxes(hitpoint); \n    d = sminPoly (m, d, 0.99); \n        \n    fUnion(c, pRoundBox(vec3(0.5,1.9,0.5) + hitpoint, vec3(14,0.2,14) + deform * 0.15, 0.02));\n\tfUnion(c, pRoundBox(vec3(0.5,0.5,1.95) + hitpoint, vec3(12,5,0.2) + deform1 * 0.03, 0.02));   \n    \n    if( c < d ) material = 1;\n\telse material = 0;\n    \n    fUnion(c, d);  \n    return c;\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// particles ( --> by Andrew Baldwin)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat particles(vec3 direction)\n{\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) \n\t{\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// ambient occlusion\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat ao(vec3 p, vec3 n, float d, vec2 fragCoord) {\n\n\tfloat s = sign(d);\n\tfloat o = s*.5+.5;\n\tfor (float i = 5.0; i > 0.; --i) {\n\t\to -= (i*d - map(p+n*i*d*s, fragCoord)) / exp2(i);\n\t}\n\treturn o;\n\t\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// normals\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 pos, vec2 fragCoord) {\n\tvec3 e = vec3(0.0,0.001,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tmap(pos+e.yxx,fragCoord)-map(pos-e.yxx,fragCoord),\n\t\t\tmap(pos+e.xyx,fragCoord)-map(pos-e.xyx,fragCoord),\n\t\t\tmap(pos+e.xxy,fragCoord)-map(pos-e.xxy,fragCoord)\n\t\t\t)\n\t);\t\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// diffuse lightning(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 diffuse(vec3 p, vec3 col, vec3 n, vec3 lightDir)\n{\n    vec3 color = col.rgb;\n    color *= vec3(max(dot(-lightDir.xyz, n), 0.0));\n    \n    return color;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// reflection(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 reflective(vec3 p, vec3 col, vec3 n, vec3 v, vec3 lightDir, vec2 fragCoord)\n{\n    vec3 color = col;\n    \n    vec3 r  = reflect(v, n);\n    vec3 rr = reflect(-lightDir, n);\n    \n    float ks = 0.6;\n    \n    color += ks * max(0.0, dot(rr, v));\n    \n    float t = 0.0;\n    \n    for (float i = 0.0; i < 64.0; i++)\n    {\n        vec3 q = p + r * (0.2 + t);\n        float m = map(q, fragCoord);\n        vec3 refCol = vec3(m);\n        \n        if (m < 0.001)\n        {\n            vec3 n = normal(q,fragCoord);\n\n            refCol = diffuse(p, col, n, lightDir);\n            color += (1.0 - ks) * refCol * (1.0 / (1.0 + t * t * 0.1));\n\n            break;\n        }\n        \n        t += m * 0.8;\n        \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\ttime = iTime; \n\n\t\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: sound´s sync\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n\tfloat fft = texture(iChannel1, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: uv\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n\tvec2 uv      = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tuv.y        *= iResolution.y / iResolution.x;\n\tfloat fov    = min(( time*.2+.05),0.6 ); //animate fov at start\n    \n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // light(s)\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n    int numlights = 8;\n    \n    vec3 lightsposition[8];\n    lightsposition[0] = vec3( 3.0,-3.0,-3.0);\n    lightsposition[1] = vec3( 3.0,-3.0, 3.0);\n    lightsposition[2] = vec3(-3.0,-3.0, 3.0);\n    lightsposition[3] = vec3(-3.0,-3.0,-3.0);\n    lightsposition[4] = vec3( 3.0, 3.0,-3.0);\n    lightsposition[5] = vec3( 3.0, 3.0, 3.0);\n    lightsposition[6] = vec3(-3.0, 3.0, 3.0);\n    lightsposition[7] = vec3(-3.0, 3.0,-3.0);\n    \n    vec3 lightsdiffuse[8];\n    lightsdiffuse[0] = vec3( 1.0,1.0,1.0);\n    lightsdiffuse[1] = vec3( 1.0,1.0,0.0);\n    lightsdiffuse[2] = vec3( 1.0,0.0,1.0);\n    lightsdiffuse[3] = vec3( 0.0,1.0,1.0);\n    lightsdiffuse[4] = vec3( 1.0,0.0,0.0);\n    lightsdiffuse[5] = vec3( 0.0,1.0,0.0);\n    lightsdiffuse[6] = vec3( 0.0,0.0,1.0);\n    lightsdiffuse[7] = vec3( 0.5,0.25,0.75);\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: ray\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n    vec2 position = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    position.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.35, 4.9);\n    vec3 rd = vec3(position,0.0) + vec3(0.0, 0.0,3.5);\n    \n    \n    vec3 cw = normalize(rd - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    rd = normalize(rd-ro);\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: raymarching params\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n    const float baseaccuracy     = 0.05;\n    const float marchingstepsize = baseaccuracy;\n    const float marchingaccuracy = baseaccuracy/100.0;\n\tconst float maxdist          = 65.0;\n    float currentstep            = marchingstepsize;\n    float total                  = currentstep;\n    vec3 hitpoint                = ro+total*rd;\n    bool currentevaluation       = (map(hitpoint, fragCoord)<0.0);\n    \n    total += currentstep;\n    \n    bool startevaluation = currentevaluation;\n\tvec3 light_dir;\n    vec3 rColor;\n\t\n    while ( total < maxdist ) {\n        \n           hitpoint  = ro+total*rd;\n           currentevaluation = (map(hitpoint,fragCoord)<0.0);\n\t\t   \n\t\t   if (currentevaluation!=startevaluation) {\n\n               float temppos = total-marchingstepsize;\n\n               while (currentstep>marchingaccuracy) {\n                      currentstep *= 0.5;\n                      total = temppos+currentstep;\n                      hitpoint = ro+total*rd;\n                      currentevaluation = (map(hitpoint,fragCoord)<0.0);\n                      if (currentevaluation==startevaluation) {\n                          temppos = total;\n                      }                \n               }\n\n\t\t\t   n = normal(hitpoint,fragCoord); \n               n = normalize(n);  \n               \n               vec3 color = vec3(0, 0, 0);\n               \n               vec3 camera_direction = normalize(ro-hitpoint);\n               \n               for (int i=0; i<numlights; i++) {\n\n                    light_dir = normalize(lightsposition[i]-hitpoint);\n                    float diffuse  = max(dot(light_dir, n),0.0);\n                    float specular = max(dot(reflect(-light_dir, n), camera_direction),0.0);\n                    color += (lightsdiffuse[i]*diffuse).xyz*materialdiffuse.xyz;\n                    color += pow(specular, materialspecularexponent);\n                   \n               } \n               \n               if( material == 1 ) {\n                   \n                   color = reflective(hitpoint, color, n, rd, light_dir, fragCoord) * 0.65;\n                   \n               }\n               \n               float a = ao(hitpoint, n, 0.15,fragCoord);\n               vec3 cB = vec3(a);\n\t\t\t   color  *= cB;\n\n               vec2 uv2  = -0.3+2.*fragCoord.xy/iResolution.xy;\n\t\t\t   float scr = 1.-dot( uv2, uv2 ) * 0.15;\n\t\t\t\t\n\t\t\t   color *= cB;\n               \n\t\t\t   fragColor = vec4(color * 1.0 * scr-0.4 * particles(cv), 1.0);\n\t\t\t   return;\n\n           }\n\n\t\t   total += currentstep;\n        \n    }\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    return;    \n\n}","name":"Image","description":"","type":"image"}]}