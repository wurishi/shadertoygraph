{"ver":"0.1","info":{"id":"Wt2cD3","date":"1595574615","viewed":297,"name":"CaveFly Micro","username":"sdfgeoff","description":"A little game based on the CaveX Algorithm for map generation. My first attempt at physics in a shader. A great fun afternoon project. Arrow keys to fly","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["game","explore","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STATE_CHANNEL iChannel0\n#define MAP_CHANNEL iChannel1\n\n\n\nfloat TRIANGLE_sign(vec2 p1, vec2 p2, vec2 p3)\n    // Pinched from https://www.shadertoy.com/view/4s3fzj\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool TRIANGLE(vec2 vertices[3], vec2 uv)\n    // Pinched from https://www.shadertoy.com/view/4s3fzj\n{\n    bool b1 = TRIANGLE_sign(uv, vertices[0], vertices[1]) < 0.0f;\n    bool b2 = TRIANGLE_sign(uv, vertices[1], vertices[2]) < 0.0f;\n    bool b3 = TRIANGLE_sign(uv, vertices[2], vertices[0]) < 0.0f;\n    \n    return (b1 == b2) && (b2 == b3);\n}\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = get_zoom(STATE_CHANNEL);\n\n    // Coords to center of the screen\n    vec2 offset = get_view_position(STATE_CHANNEL);\n    \n    // Apply offset to get world coordinates of pixel\n    vec2 pixel_coord = offset + (uv * vec2(1.0, iResolution.y / iResolution.x));\n    vec2 world_coords = pixel_coord * zoom;\n    \n    vec2 norm_uv = uv * 2.0 - vec2(1.0);\n    norm_uv *= vec2(1.0, aspect);\n    \n    \n    \n    mat2 ori = get_ship_matrix(STATE_CHANNEL);\n    vec2 VERTS[3] = vec2[](\n        ori * SHIP_NOSE,\n        ori * SHIP_LEFT_WING,\n        ori * SHIP_RIGHT_WING\n    );\n    bool ship = TRIANGLE(VERTS, norm_uv);\n    \n    vec4 ship_position = get_ship_world_position(STATE_CHANNEL);\n    \n    vec4 map = texture(MAP_CHANNEL, uv);\n    float map_sdf = map.r;\n    \n    float light_strength = 1.0;\n    float light_rand = rand(vec2(iTime)) * ship_position.w;\n    light_strength += light_rand * 0.2;\n    \n    float light = light_strength / (length(norm_uv - ori * vec2(0.0, -0.02) ) * 8.0 + 1.0);\n    float spot = pow(clamp(dot(normalize(norm_uv), ori * vec2(0.0, -1.0)), 0.0, 1.0), 2.0);\n    light = light * 0.5 + spot * (0.3 + light_rand * 0.1 + ship_position.w * 0.2); \n    \n    // Background\n    vec4 background_texture = texture(iChannel2, mix(world_coords, uv, 0.5));\n    float background_light = light + dot(\n        background_texture.xy - vec2(0.5),\n        normalize(norm_uv)\n    ) * 0.1;\n    vec4 background = vec4(0.4, 0.2, 0.1, 1.0) * background_light + background_light;\n    \n    \n    // Rock edges\n    vec4 rock_texture = texture(iChannel3, world_coords) * 0.7;\n    float rock_light = light * dot(\n        clamp(vec2(0.5) - map.gb, -1.0, 1.0) + rock_texture.rg - vec2(0.5),\n        normalize(norm_uv)\n    ) + map_sdf;\n    \n    vec4 rock = rock_texture * rock_light + vec4(rock_light);\n    \n\n    fragColor = background;\n    fragColor = mix(fragColor, rock, float(map_sdf < 0.0));\n    \n    \n    fragColor.rgb *= vec3(!ship);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Contains state\n\n#define STATE_BUFFER iChannel0\n#define MAP_BUFFER iChannel1\n#define KEY_BUFFER iChannel2\n\n\nfloat get_key(int key_code) {\n    return texelFetch(KEY_BUFFER, ivec2(key_code,0), 0).x;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 address = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    if (address == A_SHIP_POSITION || address == A_SHIP_VELOCITY) {\n        // Physics\n        vec4 position = texelFetch(STATE_BUFFER, A_SHIP_POSITION, 0);\n        vec4 velocity = texelFetch(STATE_BUFFER, A_SHIP_VELOCITY, 0);\n            \n        \n        float c = cos(position.z);\n        float s = sin(position.z);\n        mat2 ori = mat2(\n            c, s,\n            -s, c\n        );\n\n        vec4 acceleration = vec4(0.0);\n\n\n        // Gravity\n        acceleration.y -= GRAVITY;\n\n        // Thrusters\n        vec2 forwards = ori * vec2(0.0, 1.0);\n\n        float thrust_keys = get_key(KEY_UP);// - get_key(KEY_DOWN));\n        position.w = thrust_keys; // Indicate that thrust is being applied to the ship\n\n        acceleration.z += (get_key(KEY_LEFT) - get_key(KEY_RIGHT)) * SHIP_ANGULAR_THRUST;\n        acceleration.xy += forwards * SHIP_THRUST * thrust_keys;\n\n        // Damping\n        acceleration -= velocity * SHIP_DAMPING;\n\n        // Collision with map\n        vec4 top = texture(MAP_BUFFER, vec2(0.5) + ori*SHIP_NOSE * vec2(aspect, 1.0));\n        vec4 left = texture(MAP_BUFFER, vec2(0.5) + ori*SHIP_LEFT_WING * vec2(aspect, 1.0));\n        vec4 right = texture(MAP_BUFFER, vec2(0.5) + ori*SHIP_RIGHT_WING * vec2(aspect, 1.0));\n\n        if (top.r < 0.0) {\n            position.xy -= (top.gb - vec2(0.5)) * (top.r) / 8.0;\n            velocity.xy *= 1.0 - GROUND_FRICTION;\n        }\n        if (left.r < 0.0) {\n            position.xy -= (left.gb - vec2(0.5)) * (left.r) / 8.0; \n            velocity.xy *= 1.0 - GROUND_FRICTION;\n        }\n        if (right.r < 0.0) {\n            position.xy -= (right.gb - vec2(0.5)) * (right.r) / 8.0; \n            velocity.xy *= 1.0 - GROUND_FRICTION;\n        }\n        \n\n        velocity += acceleration * iTimeDelta;\n        position += velocity * iTimeDelta;\n        \n        if (iTime < 0.1) {\n            acceleration = vec4(0.0);\n        \tposition = vec4(0.0, 0.2, 0.0, 0.0);\n        \tvelocity = vec4(0.0);\n        }\n        \n        // Save state\n        if (address == A_SHIP_POSITION) {\n            fragColor = position;\n        }\n        if (address == A_SHIP_VELOCITY) {\n            fragColor = velocity;\n        }\n    \n    }\n    \n    \n    //fragColor = vec4(0.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SHIP_SIZE 0.05\n#define SHIP_DAMPING vec4(3.0, 3.0, 10.0, 0.0)\n#define SHIP_THRUST 3.0\n#define SHIP_ANGULAR_THRUST 48.0\n#define GRAVITY 0.60\n#define GROUND_FRICTION 0.2\n\n#define SEED 10.0\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n\n#define A_SHIP_POSITION ivec2(1.0, 1.0) // red green = location blue = rotation\n#define A_SHIP_VELOCITY ivec2(1.0, 2.0) // red green = linear blue = angular\n\n\n#define SHIP_NOSE vec2(0.0, 1.0) * SHIP_SIZE\n#define SHIP_LEFT_WING vec2(0.5, -0.3) * SHIP_SIZE\n#define SHIP_RIGHT_WING vec2(-0.5, -0.3) * SHIP_SIZE\n\n\n#define aspect (iResolution.y / iResolution.x)\n\n\n\nfloat get_zoom(sampler2D state_buffer) {\n    return 4.0;\n}\n\n\nvec4 get_ship_world_position(sampler2D state_buffer) {\n    return texelFetch(state_buffer, A_SHIP_POSITION, 0);\n}\nvec4 get_ship_velocity(sampler2D state_buffer) {\n    return texelFetch(state_buffer, A_SHIP_VELOCITY, 0);\n}\n\n\nmat2 get_ship_matrix(sampler2D state_buffer) {\n    // Returns ship vertices rotated into world space\n    vec4 world_pos = get_ship_world_position(state_buffer);\n    float angle = world_pos.z;\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 get_view_position(sampler2D state_buffer) {\n    return get_ship_world_position(state_buffer).xy;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer contains the map\n// Red channel: 0 if ground, 1 if air\n\n\n#define TEX_CHANNEL iChannel0\n#define TEX_SCALE vec2(0.01, 0.02)\n\n#define STATE_CHANNEL iChannel1\n\n\nfloat rand(ivec2 ico){\n    vec2 co = vec2(ico);\n    co += SEED;\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nbool get_tile(ivec2 co) {\n    bool up = rand(co + ivec2(0, 1)) > 0.5;\n    bool down = rand(co + ivec2(0, -1)) > 0.5;\n    bool left = rand(co + ivec2(-1, 0)) > 0.5;\n    bool right = rand(co + ivec2(1, 0)) > 0.5;\n    \n    bool here = rand(co) > 0.5;\n    \n    return !((up == down) && (left == right) && (up != right)) && here;\n}\n\n\nfloat get_map_sdf(vec2 pixel_coord) {\n    \n    \n    // Calculate the tile X and Y IDs for this pixel\n    vec2 inner_coord = mod(pixel_coord, 1.0);\n    \n    ivec2 tile_ids = ivec2(pixel_coord - inner_coord);\n    \n    float a = float(get_tile(tile_ids));\n    float b = float(get_tile(tile_ids + ivec2(1.0, 0.0)));\n    float c = float(get_tile(tile_ids + ivec2(0.0, 1.0)));\n    float d = float(get_tile(tile_ids + ivec2(1.0, 1.0)));\n    \n    return mix(\n        mix(a, b, inner_coord.x),\n        mix(c, d, inner_coord.x),\n    \tinner_coord.y\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = get_zoom(STATE_CHANNEL);\n\n    // Coords to center of the screen\n    vec2 offset = get_view_position(STATE_CHANNEL);\n    \n    // Apply offset to get world coordinates of pixel\n    vec2 pixel_coord = offset + (uv * vec2(1.0, aspect));\n    vec2 world_coords = pixel_coord * zoom;\n\n    \n    float raw_sdf = 0.6 - get_map_sdf(world_coords);\n    float tex = texture(TEX_CHANNEL, world_coords * TEX_SCALE).r;\n    \n    float detailed_sdf = (raw_sdf) - tex * 0.6;\n    \n    \n    float is_ground = float(detailed_sdf > 0.0);\n    \n    vec2 norm = normalize(vec2(\n        dFdx(detailed_sdf),\n        dFdy(detailed_sdf)\n    )) + vec2(0.5);\n\n    // Output to screen\n    fragColor = vec4(\n        detailed_sdf,\n        norm.x,\n        norm.y,\n        0.0\n    );\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}