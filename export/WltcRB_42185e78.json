{"ver":"0.1","info":{"id":"WltcRB","date":"1611529998","viewed":83,"name":"A 3D SPHERE","username":"skillermaniac","description":"mah first 3d spher","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define spheres_num 3\nstruct Camera {\n    vec3 Observer;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float screenHeight;\n    float screenWidth;\n    float screen_observer_distance;\n};\nvec3 EPSILON = vec3(1e-9);\nstruct Ray {\n    vec3 Source;\n    vec3 Direction;\n};\nstruct Sphere {\n    vec3 Center;\n    float radius;\n    vec3 Color;\n    bool doesReflect;\n};\nstruct IntersectionInfo {\n    Sphere sphere;\n    vec3 IntersectionPoint;\n    bool doesIntersectASphere;\n    float tVal;\n    Ray incidenceRay;\n};\nCamera createCamera(in vec3 Observer, in vec3 LookAt, in float aperture) {\n    Camera camera;\n    camera.Observer = Observer;\n    camera.View = normalize(LookAt - Observer);\n    vec3 kAxis = vec3(0.0,0.0,1.0);\n    camera.Horiz = normalize(cross(kAxis,camera.View));\n    \n    //no need to normalize up since view and horiz are already normalized;\n    camera.Up = cross(camera.View, camera.Horiz);\n    camera.screenHeight = iResolution.y;\n    camera.screenWidth = iResolution.x;\n    camera.screen_observer_distance = (camera.screenHeight / 2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n    return camera;\n}\nRay launchRay (in Camera camera, in vec2 pixCoord) {\n    float adjustedX = pixCoord.x - camera.screenWidth / 2.0;\n    float adjustedY = pixCoord.y - camera.screenHeight / 2.0;\n    return Ray(camera.Observer, camera.screen_observer_distance * camera.View \n    + adjustedX * camera.Horiz \n    + adjustedY * camera.Up);\n}\n\n/*\n   If bool = true , the intersection will be at : M = RayOrigin + atT * Dir\n*/\nbool doesIntersectSphere(in Ray ray, in Sphere sphere, out float atT) {\n    vec3 SC = ray.Source - sphere.Center;\n    float a = dot(ray.Direction, ray.Direction);// R.dirÂ²;\n    float b = 2.0 * dot(ray.Direction, SC);\n    float c = dot(SC, SC) - sphere.radius*sphere.radius;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n    return false;\n    };\n    atT = (-b-sqrt(delta)) / (2.0*a);\n    return true;\n}\n\nIntersectionInfo getIntersectionInfo(in Ray ray, in Sphere[spheres_num] spheres) {\n    IntersectionInfo info;\n    float t = 1e25;\n    info.doesIntersectASphere = false;\n    info.incidenceRay = ray;\n    for(int i=0; i < spheres_num; i++) {\n        Sphere sphere = spheres[i];\n        float potentialT = t;\n        if(doesIntersectSphere(ray, sphere, potentialT)) {\n            info.doesIntersectASphere = true;\n            if(potentialT < t) {\n                t = potentialT;\n                info.sphere = sphere;\n                info.IntersectionPoint = ray.Source + potentialT * ray.Direction;\n                info.tVal = potentialT;\n            }\n        }\n        \n    }\n    \n    return info;\n}\n\nfloat getLightingRatio(in Sphere sphere,in vec3 IntersectionPoint, in vec3 Sun) {\n    vec3 NormaleVec = IntersectionPoint - sphere.Center;\n    vec3 IncidenceVec = Sun - IntersectionPoint;\n    float incidence = max(dot(NormaleVec,IncidenceVec)/(length(NormaleVec)*length(IncidenceVec)), 0.0);\n    return incidence;\n}\n\n\nbool applyShadow(Ray shadowRay, Sphere[spheres_num] spheres) {\n   bool shadow = false;\n   for(int i = 0 ; i < spheres_num;i++) {\n       float atT;\n       shadow = shadow || (doesIntersectSphere(shadowRay, spheres[i], atT) && atT > 1e-6 && atT < 1.0);\n       if(shadow) break;\n   }\n   return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    Camera cam =createCamera(vec3(3.0, 3.0, 1.5),\n    vec3(0.5, 0.5, 0.5),\n    50.0);\n    Sphere Sun= Sphere(vec3(0.0,2.5,0.0),0.01,vec3(1.0,1.0,1.0), false);\n    Sphere sphereA = Sphere(vec3(0.0, 0.0, 0.0), 0.5, vec3(1.0,0.0,0.0), false);\n    float rotation = iTime;\n    Sphere sphereB = Sphere(0.9*vec3(cos(rotation), sin(rotation), 0),0.1,vec3(0.0,0.0,1.0), false);\n    Sphere sphereC = Sphere(vec3(0.0,0.0,1.2), 0.3, vec3(0.0,1.0,0.0), true);\n    Sphere[spheres_num] spheres = Sphere[spheres_num](sphereB, sphereA, sphereC);\n\n    Ray ray = launchRay(cam, fragCoord);\n    float t;\n    /*if(doesIntersectSphere(ray,S, t)) {\n        vec3 IntersectionPoint = ray.Source + t* ray.Direction;\n        float incidence = getLightingRatio(S,IntersectionPoint, Sun);\n        fragColor = incidence*vec4(1.0);\n    };*/\n    IntersectionInfo info = getIntersectionInfo(ray, spheres);\n    if(info.doesIntersectASphere) {\n        vec3 IntersectionPoint = info.IntersectionPoint;\n        // Defining a shadow detector ray\n        Ray shadowRay;\n        shadowRay.Source = IntersectionPoint;\n        shadowRay.Direction =  Sun.Center - shadowRay.Source;\n        IntersectionInfo shadowInfo = getIntersectionInfo(shadowRay, spheres);\n        //SHADOW section\n        bool shadow = applyShadow(shadowRay, spheres);\n        if (!shadow) {\n            // Lighting section\n            if(!info.sphere.doesReflect) {\n                float incidence = getLightingRatio(info.sphere, IntersectionPoint, Sun.Center);\n                fragColor = vec4(incidence * info.sphere.Color,1.0);\n            \n            } else {\n                Ray incidenceRay = info.incidenceRay;\n                vec3 Center = info.sphere.Center;\n                vec3 NormaleVec = (IntersectionPoint - Center);\n                NormaleVec = normalize(NormaleVec);\n                Ray reflectedRay = Ray(info.IntersectionPoint, - (incidenceRay.Direction - (2.0 * dot(incidenceRay.Direction,NormaleVec)*NormaleVec)));\n                IntersectionInfo reflectionInfo = getIntersectionInfo(reflectedRay, spheres);\n                if(reflectionInfo.doesIntersectASphere) {\n                        float incidence = getLightingRatio(reflectionInfo.sphere, reflectionInfo.IntersectionPoint, Sun.Center);\n                        fragColor = vec4(incidence* reflectionInfo.sphere.Color,1.0);\n                        \n                        \n                 \n                }\n                \n\n            }\n            \n            // End of Lighting\n            \n        } else {\n            \n            fragColor = vec4(0.01*info.sphere.Color, 1.0);\n        }\n        \n    } else {\n        fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    }\n    \n  \n    \n}","name":"Image","description":"","type":"image"}]}