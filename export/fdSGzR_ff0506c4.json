{"ver":"0.1","info":{"id":"fdSGzR","date":"1616783356","viewed":88,"name":"Raycasting (sphère,damier,ombre)","username":"MartinG","description":"Application ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1.0 / 0.0;    \n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nconst vec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\nconst vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nconst vec3     lightPos     = vec3(8, 10, -12);\n\n//##############################################################################################\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n       \n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001) \n        return -1.0;\t\t\t\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    intersecPt = rayPos + t * rayDir;\n   \n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n  \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\n    vec3 cx = normalize(cross(-up, cz));\n\n    vec3 cy = normalize(cross( cz, cx));\n\n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n  \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Permet de determiner la première intersection du rayon par un objet\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n   \n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    \n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    \n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    \n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t\n    vec3  shadowRayDir   = L;\n    \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n//##############################################################################################\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n   \n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    if (distI > 0.0)\n    {\n     \n\t    vec3 L = lightPos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        vec3 V = -rayDir;\n        \n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n      \n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n    \tfragColor = vec4(computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, L, R, V), 1);\n    }\n    //Si aucun objet n'est entré en contact avec le rayon, c'est qu'il n'y a plus d'objet, et donc, le ciel doit être affiché\n    else\n     \tfragColor = vec4(skyCol, 1);\n}","name":"Image","description":"","type":"image"}]}