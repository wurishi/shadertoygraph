{"ver":"0.1","info":{"id":"ctSXWm","date":"1676130261","viewed":90,"name":"Jonix Jedi Hologram (translated)","username":"Olliebrown","description":"A copy of the Jonix Jedi shader with the comments translated from Swedish.  Translation via google translate (so may not be accurate).\n\nOriginal shader by Hultsborn10  (https://www.shadertoy.com/view/DtfXWN)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["starwars","hologram"],"hasliked":0,"parentid":"DtfXWN","parentname":"Jonix Jedi Hologram"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created 2023-01-30\n//\n\n\n//\"Random function\". Outputs 0.0 - 1.0\nfloat Ran(float t){\n     float p = fract(t * .1031);\n     p *= p + 33.33;\n     p *= p + p;\n     return fract(p);\n}\n\n\n//\"Random function\". Outputs 0.0 or 1.0\nfloat RanStep(float t, float d, float a){\n     //use d as \"delay\" to hold the same value for d number of seconds\n     float v = floor(t / d);\n     float p = fract(v * .1031);\n     p *= p + 33.33;\n     p *= p + p;\n     p = fract(p);\n     return step(a,p);\n}\n\n//Creates horizontal and vertical stripes in the hologram\nfloat Hologram(vec2 uv){\n     //Small vertical lines (value 0.5 - 1.0)\n     float verticalStripe = sin(uv.x*1000.0)*0.25 + 0.75;\n     //Wide horizontal lines (value 0.5 - 1.0), \"randomly\" enabled\n     float horizontal = RanStep(iTime, 5.0, 0.4)*sin(3.0*uv.y+iTime)*sin(uv.y*15.0 + iTime*5.0)*0.25 + 0.75;\n     //Show only the top part (above 0.95) with step function (output value 0.5 or 1.0)\n     horizontal = smoothstep(0.94,0.96,horizontal)*.5+0.5;\n     //Multiply together vertical and horizontal values\n     float holo = verticalStripe*horizontal;\n     return holo;\n}\n\n//Creates a bright border around the figure\nvec3 Glow(vec2 uv, vec3 GREEN){\n     //delta should correspond to a number of \"pixels\"\n     vec2 delta = 7.0 / iResolution.xy;\n     //get positions in four directions\n     vec2 upPos = vec2(uv.x, uv.y + delta.y);\n     vec2 rightPos = vec2(uv.x + delta.x, uv.y);\n     vec2 downPos = vec2(uv.x, uv.y - delta.y);\n     vec2 leftPos = vec2(uv.x - delta.x, uv.y);\n    \n     //Read out color from points in all four directions\n     //Calculate the difference against the green color (then sum all the differences)\n     vec3 texCol = texture(iChannel0, upPos).rgb;\n     float diff = length(texCol - GREEN);\n    \n     texCol = texture(iChannel0, rightPos).rgb;\n     diff += length(texCol - GREEN);\n    \n     texCol = texture(iChannel0, downPos).rgb;\n     diff += length(texCol - GREEN);\n    \n     texCol = texture(iChannel0, leftPos).rgb;\n     diff += length(texCol - GREEN);\n    \n     //diff is almost 0 when it's all green,\n     //between 0 and 2 in the edge,\n     //and more than 2 right in the center of the figure\n    \n     //Pluck away the \"center\" part of the image\n     //(ie where all four directions contain a color other than green)\n     diff *= smoothstep(2.0,0.8,diff);\n    \n     return vec3(diff);\n    \n}\n\n\n//Creates horizontal disturbances\nvec2 Scramble(vec2 uv){\n     vec2 xy = vec2(uv.x+Ran(100.0*uv.y)*0.2-0.1,uv.y);\n     return xy;\n}\n\n\nvec3 MaskGreen(vec2 st){\n     //Activate disturbances on short sporadic occasions\n     float tSc = RanStep(iTime, 0.1, 0.04);\n     vec2 uv = tSc*st + (1.0 - tSc)*Scramble(st);\n     //RGB value for green background is (13,163,37)\n     //Float RGB is(0.05,0.64, 0.145)\n     vec3 GREEN = vec3(13,163,37)/255.0;\n     //Read the rgb value of the texture at uv coordinate\n     vec3 texCol = texture(iChannel0, uv).rgb;\n    \n    \n     //A variant that becomes negative when green dominates\n     float greenDiff = texCol.r + texCol.b - texCol.g ;\n    \n     //Another variant that measures the \"color-distance\" to the green color\n     float greenDiff2 = length(texCol-GREEN);\n     //Create a smooth mask that is 0 for green and 1 for other colors\n     float BORDER = 0.6;\n     float greenMask = smoothstep(0.0, BORDER, greenDiff2);\n    \n    \n    \n     //vec3 col = texCol * greenMask + texCol * greenDiff2;\n     vec3 col = texCol * greenMask; //Apply mask to the movie\n     //col = texCol * greenDiff2;\n     col = col.rgb*vec3(1.0,1.2,1.8); //Use only the blue component for the shape\n    \n     //Add the Hologram effect\n     col *= Hologram(uv);\n    \n     //Read the background\n     //Noisy moving background\n     //vec2 st = uv*vec2(sin(uv.x + iTime),cos(uv.y + iTime));\n     //vec3 backCol = texture(iChannel1, st).rgb;\n     vec3 backCol = texture(iChannel1, st).rgb;\n    \n     //Create an inverted mask for the background\n     backCol *= smoothstep(BORDER, 0.0,greenDiff2);\n    \n     //Add movie and background together\n     col += backCol;\n    \n     //col = vec3(texCol.r, texCol.g*0.2, texCol.b);\n     //col = vec3(1.0, 0.1, 1.0)*texCol;\n    \n     //Add a light, blurred border\n     col += 0.6*Glow(uv,GREEN);\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // UV - scale coordinates from 0.0 to 1.0 both x and y\n     //0.0 is in the left bottom corner\n     vec2 uv = fragCoord/iResolution.xy;    \n        \n     //Texture\n     vec3 col = MaskGreen(uv);\n    \n     fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}