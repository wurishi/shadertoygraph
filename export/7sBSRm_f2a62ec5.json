{"ver":"0.1","info":{"id":"7sBSRm","date":"1619887402","viewed":213,"name":"Twisting donut loop","username":"Bleuje","description":"4 seconds long perfect loop","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","twister"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// code can be messy and stupid\n\n// Thanks tdhooper, iq, leon, FabriceNeyret2 and others\n\n// most important parameters\n#define motionBlur 1.0 // (integer)\n#define duration 4.0\n#define AA true\n\n// others\n#define largeRadius 9.0\n#define smallRadius 1.3\n#define segments 6.0 // (integer)\n\n\nvec2 displaceLoop (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\n\nfloat ease(float p, float g) {\n  if (p < 0.5) \n    return 0.5 * pow(2.*p, g);\n  else\n    return 1. - 0.5 * pow(2.*(1. - p), g);\n}\n\nfloat time;\n\n// volumes description\nVolume map(vec3 pos)\n{\n    float scene = 100.;\n\n    vec3 p = pos;\n\n    Volume white;\n    white.mat = 1;\n    Volume black;\n    black.mat = 2;\n    \n    // donut distortion (https://www.shadertoy.com/view/XlfBR7)\n    vec3 pDonut = p;\n    pDonut.xy = displaceLoop(pDonut.xy, largeRadius);\n    float q = (PI+pDonut.y)/TAU;\n    q = mod(q+0.75,1.0);\n    \n    float per = 4.0;\n    float ns = sin(TAU*(2.*time-per*q));\n    float ns2 = sin(TAU*(time+0.25-per*q));\n    \n    float easeRot = -4.0*TAU*(0.1*q+0.9*ease(q,3.0));\n    float propagRot = -0.9*pow((ns+1.)/2.0,3.0)-0.3*ns2;\n    float constantSpeedRot = 2.0*TAU*time/segments;\n    \n    pDonut.xz *= rot( easeRot + propagRot + constantSpeedRot );\n    pDonut.y *= largeRadius;\n    \n\n    p = pDonut;\n    p.xz *= rot(PI/segments);\n    amod(p.xz, segments);\n    float l = smallRadius * TAU/segments;\n    scene = min(scene,max(abs(p.x)-smallRadius,sdCylinder((p.xz-vec2(smallRadius,0.0))*vec2(0.5,1.0),l/2.0)));\n    black.dist = scene;\n    \n    float angle = atan(pDonut.z,pDonut.x);\n    float distToBorder = min(mod(angle,TAU/segments),mod(TAU/segments-angle,TAU/segments));\n    scene = 1000.0;\n    scene = min(scene, max(distToBorder,abs(p.x)-1.015*smallRadius));\n    white.dist = scene;\n    \n    Volume volume = select(white,black);\n    \n    p = pDonut;\n    volume.smallAngle = atan(pDonut.z,pDonut.x);\n    volume.q = q;\n\n    return volume;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\nvec3 finishColor(float travel, float shade, float angle, float q, vec3 col)\n{\n    float act = smoothstep(60.0,50.0,travel);\n    \n    float per = 5.0;\n    \n    float rad = 2.5;\n    float inputx = 4.0*mod(angle,2.0*TAU/segments);\n    float inputy = rad*cos(TAU*(time+per*q));\n    float inputz = rad*sin(TAU*(time+per*q));\n    float start = 0.6;\n    float end = 0.75;\n    float val1 = smoothstep(start,end,simplex3d(vec3(inputx,inputy,inputz)));\n    float val2 = smoothstep(start,end,simplex3d(vec3(123.365+inputx,inputy,inputz)));\n    float val3 = smoothstep(start,end,simplex3d(vec3(123.365+inputx,654.7879+inputy,inputz)));\n    float val4 = smoothstep(start,end,simplex3d(vec3(369.365+inputx,inputy,6516.4562+inputz)));\n    float val5 = smoothstep(start,end,simplex3d(vec3(123.365+inputx,654.7879+inputy,inputz)));\n    float val6 = smoothstep(start,end,simplex3d(vec3(982.365+inputx,6525621.258+inputy,6516.4562+inputz)));\n    vec3 star = act*(val1+val2+val3+val4+val5+val6)*vec3(1.0);\n    \n    float distToBorder = min(mod(angle,TAU/segments),mod(TAU/segments-angle,TAU/segments));\n    float lim = 3.0*smoothstep(0.05,0.0,distToBorder);\n    col += vec3(1.0)*lim*act;\n    float sf = pow(shade,3.0)*50.0;\n    col += vec3(1.0)*sf*act;\n    vec3 toAdd = clamp(col*4.0/(20.0+7.*travel)*10.0,0.0,1.0)+star;\n    \n    return toAdd;\n}\n\nvoid mainImage0( out vec4 color, in vec2 coordinate )\n{\n    color = vec4(0);\n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    \n    if(length(p)>0.77||length(p)<0.49) return;\n    \n    // camera\n    vec3 cameraPos = vec3(0,0,-13);\n    \n    // look at\n    vec3 z = normalize(vec3(0,0,0)-cameraPos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 0.9 + x * p.x + y * p.y);\n    \n    float mb = motionBlur;\n    \n    for(float it=0.0;it<mb;it++){\n    \n        time = mod(iTime,duration)/duration - it*0.012/mb;\n    \n        // render variables\n        float shade = 0.0;\n        vec3 normal = vec3(0,1,0);\n        float ao = 1.0;\n        float rng = hash12(coordinate + time);\n        const int count = 20;\n        float travel = 0.0;\n        float angle;\n        float q;\n        vec3 col;\n        \n        vec3 pos = cameraPos;\n        \n        int index;\n\n        // raymarch iteration\n        for (index = 0; index < count; ++index)\n        {\n            Volume volume = map(pos);\n            \n            angle = volume.smallAngle;\n            q = volume.q;\n\n            // accumulate fullness\n            shade += 0.5/float(60);\n\n            // step further on edge of volume\n            normal = getNormal(pos);\n            \n            if(volume.dist>0.05){\n\n                // dithering trick inspired by Duke\n                volume.dist *= 0.9+0.1*rng;\n\n                // keep marching\n                pos += ray * volume.dist;\n                travel += volume.dist;\n            }\n            else\n            {\n\n                // coloring\n                col = vec3(0);\n                switch (volume.mat)\n                {\n                    case mat_bright:\n                    col = vec3(1.3);\n                    break;\n\n                    case mat_dark:\n                    col = vec3(1.3);\n                    col *= pow(dot(vec3(0.0,0.0,1.0),normal)*0.4+0.5,1.1);\n                    break;\n                }\n\n                break;\n\n            }\n        }\n        \n        if(index==count)\n        {\n            col = vec3(0.0);\n        }\n        color.rgb += finishColor(travel, shade, angle, q, col);\n    }\n    \n    color.rgb /= mb;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define TAU (2.*PI)\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, vec2 c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\n\n// details about sdf volumes\nstruct Volume\n{\n    float dist;\n    int mat;\n    float ns;\n    float fc;\n    int type;\n    float smallAngle;\n    float q;\n};\n\n// union operation between two volume\nVolume select(Volume a, Volume b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// materials\nconst int mat_bright = 1;\nconst int mat_dark = 2;\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat amodIndex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); return c; }\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\n\n// 3d simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}