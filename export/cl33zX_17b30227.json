{"ver":"0.1","info":{"id":"cl33zX","date":"1682793883","viewed":90,"name":"GPT generated torus","username":"kefeld","description":"I asked GPT-4 for a rendering of a torus rotating around a slanted axis in shadertoy, after a few iterations like asking for highlights this is what it made. Human feedback on result, no human code.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","gpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Torus parameters\nconst float specularIntensity = 1.8;\nconst float shininess = 64.0;\nconst vec2 torusSize = vec2(0.35, 0.1);\nconst float ambientIntensity = 0.4;\nconst vec3 light2Color = vec3(.5, 0.2, 0.0);\nconst float light2Speed = 0.01;\nconst float shadowBias = 0.001;\n\n\n// Rotation axis\nconst vec3 rotationAxis = normalize(vec3(1.0, 1.0, 0.5));\n\n// Ray marching parameters\nconst float epsilon = 1e-4;\nconst int maxSteps = 100;\n\n// Signed distance function for the torus\nfloat sdTorus(vec3 p, vec2 tSize) {\n  vec2 q = vec2(length(p.xz) - tSize.x, p.y);\n  return length(q) - tSize.y;\n}\n\n// Rotate the point around the given axis\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n  return p * cos(angle) + cross(axis, p) * sin(angle) + axis * dot(axis, p) * (1.0 - cos(angle));\n}\n\n// Calculate the normal at a given point on the surface of the torus\nvec3 getNormal(vec3 p) {\n  const vec2 eps = vec2(0, epsilon);\n  return normalize(vec3(\n    sdTorus(p + eps.yxx, torusSize) - sdTorus(p - eps.yxx, torusSize),\n    sdTorus(p + eps.xyx, torusSize) - sdTorus(p - eps.xyx, torusSize),\n    sdTorus(p + eps.xxy, torusSize) - sdTorus(p - eps.xxy, torusSize)\n  ));\n}\n\n// Ray marching loop\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < maxSteps; ++i) {\n    vec3 p = rotate(ro + t * rd, rotationAxis, -iTime);\n    float d = sdTorus(p, torusSize);\n    if (abs(d) < epsilon) {\n      return t;\n    }\n    t += d;\n    if (t > 10.0) break;\n  }\n  return -1.0;\n}\n\nfloat shadowRay(vec3 ro, vec3 rd, float maxDist) {\n    float t = 0.0;\n    for (int i = 0; i < maxSteps; ++i) {\n        vec3 p = rotate(ro + t * rd, rotationAxis, -iTime);\n        float d = sdTorus(p, torusSize);\n        if (d < epsilon) {\n            return 0.0;\n        }\n        t += d;\n        if (t > maxDist) {\n            break;\n        }\n    }\n    return 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n  // Calculate the ray direction\n  vec3 camPos = vec3(0, 0, -3);\n  vec3 camTarget = vec3(0, 0, 0);\n  vec3 camUp = vec3(0, 1, 0);\n\n  vec3 camForward = normalize(camTarget - camPos);\n  vec3 camRight = normalize(cross(camForward, camUp));\n  vec3 camUpNew = cross(camRight, camForward);\n\n  vec3 rayDir = normalize(uv.x * camRight + uv.y * camUpNew + 2.0 * camForward);\n\n  // Perform the ray marching\n  float t = rayMarch(camPos, rayDir);\n\n  // Set the background color\n  vec3 col = vec3(0.2, 0.2, 0.3);\n\n  // If the ray hit the torus, calculate shading\n  if (t > 0.0) {\n    vec3 hitPos = rotate(camPos + t * rayDir, rotationAxis, -iTime);\n    vec3 normal = getNormal(hitPos);\n\n    float lightSpeed = 0.0;\n    vec3 lightPos = vec3(cos(iTime * lightSpeed), 1.0, sin(iTime * lightSpeed));\n    vec3 lightDir = normalize(rotate(lightPos, camForward, iTime * lightSpeed));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 light2Pos = vec3(cos(iTime * light2Speed + 3.14), 1.0, sin(iTime * light2Speed + 3.14));\n    vec3 light2Dir = normalize(rotate(light2Pos, camForward, iTime * light2Speed));\n\n\n    vec3 viewDir = normalize(camPos - hitPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n\n    float diffuse2 = max(dot(normal, light2Dir), 0.0);\n    vec3 reflectDir2 = reflect(-light2Dir, normal);\n    float spec2 = pow(max(dot(viewDir, reflectDir2), 0.0), shininess);\n    float shadow = shadowRay(rotate(hitPos + normal * shadowBias, rotationAxis, iTime), rotate(lightDir, rotationAxis, iTime), length(lightPos));\n    float shadow2 = shadowRay(rotate(hitPos + normal * shadowBias, rotationAxis, iTime), rotate(light2Dir, rotationAxis, iTime), length(light2Pos));\n\n    col = vec3(0.9, 0.4, 0.2) * (diffuse * shadow + ambientIntensity) + vec3(1.0) * specularIntensity * spec * diffuse * shadow;\n    col += light2Color * (diffuse2 * shadow2 + ambientIntensity) + light2Color * specularIntensity * spec2 * diffuse2 * shadow2;\n}\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}