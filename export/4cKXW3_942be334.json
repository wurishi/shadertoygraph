{"ver":"0.1","info":{"id":"4cKXW3","date":"1715874165","viewed":140,"name":"Heat from Fire","username":"weasel","description":"Combining my fluid sim with a reaction diffusion sim.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["flame","fire","fluid","smoke","diffusion","navierstokes","reaction","transport"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fire simulation based on my fluid sim https://www.shadertoy.com/view/XfGXRR\n\n#define TAU 6.28318530718\n\n// render flame colors\nvec3 flames(vec2 uv) {\n    vec4 fire = texture(iChannel1, uv);\n    float flame = fire.z;\n    float ash = fire.w;\n    return flame_color(max(ash, 0.0), max(0.0, flame));\n}\n\nvec3 blur(vec2 uv) {\n    float radius = GLOW_RADIUS/iResolution.y;\n    float weight = 1.0;\n    vec3 color = flames(uv) * weight;\n    \n    // blur\n    for (float i = 1.0; i <= GLOW_QUALITY; i++) {\n        float r = i/GLOW_QUALITY;\n        float w = exp(-r*3.1415);\n        color += texture(iChannel2, uv + vec2(0.0, radius*r)).rgb * w;\n        color += texture(iChannel2, uv - vec2(0.0, radius*r)).rgb * w;\n        weight += w;\n    }\n    // normalize\n    color /= weight;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // output Buffer A to screen\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float rho = data.z;\n    vec3 col = vec3(data.xy * 4.0 + 0.5, 0.0);\n    vec4 fire = texture(iChannel1, uv);\n    float flame = fire.z;\n    float ash = fire.w;\n    float fuel = fire.y;\n    vec3 col2 = vec3(0.0, 1.0, 1.0) * fuel * 0.1 * float(int(dot(fragCoord.xy, vec2(1.0))) % 2);\n    // add flame\n    col2 += flame_color(max(ash, 0.0), max(0.0, flame));\n    // add glow effect\n    col2 += blur(uv) * (0.1 + ash * 0.2) + ash * 0.02;\n    \n    // gamma correction\n    col2 = pow(col2, vec3(0.5));\n    //col2.g += ash;\n    col2 = mix(col2, vec3(0.9, 0.3, 0.5), shape(fragCoord));\n    fragColor = vec4(col2, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// use Navier-Stokes equations\n// rho Dv/Dt = f - grad p + eta * laplace v + (zeta + eta/3) * grad (div v)\n// -drho/dt = div (rho v)\n// Equation of state:\n// p = C*rho*T\n//\n// fragColor = vec4(vx, vy, rho, 0.0);\n\n#define DT 0.5\n\n#define ETA 1.0\n#define ZETA 0.5\n\n#define C 1.0\n#define CT 5.0\n\n#define IN0(x, y) texture(iChannel0, (fragCoord + vec2(float(x), float(y))) / iResolution.xy)\n#define IN(x, y) texture(iChannel0, (fragCoord - v*DT + vec2(float(x), float(y))) / iResolution.xy)\n#define IN1(x, y) texture(iChannel1, (fragCoord - v*DT + vec2(float(x), float(y))) / iResolution.xy)\n\n// fluid sim using separate transport and interaction handling\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord + 0.5) / iResolution.xy;\n        vec4 col = texture(iChannel2, uv);\n        col.xy -= 0.5;\n        col.xy *= -2.0;\n        col.z = 1.0;\n        col.w = 0.0;\n        fragColor = col;\n        return;\n    }\n    vec2 accel = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        vec2 dx = iMouse.xy - fragCoord;\n        float d = length(dx);\n        accel = 0.1 * normalize(vec2(dx.y, -dx.x) + dx) * exp(-d*d/1000.0);\n    }\n    \n    // Do an RK4 inspired search for the point that gets transported to fragCoord in one step.\n    vec4 b = IN0(0, 0);\n    vec2 k1 = b.xy + accel * DT * 0.5;\n    vec2 v = k1 / 2.0; // Read from transported field!\n    b = IN(0, 0); // reset velocity to the one at a half flow step\n    /*vec2 k2 = b.xy;\n    v = k2 / 2.0;\n    \n    b = IN(0, 0);\n    vec2 k3 = b.xy;\n    v = k3;\n    \n    b = IN(0, 0);\n    vec2 k4 = b.xy;\n    \n    v = (k1 + 2.0*k2 + 2.0*k3 + k4) / 6.0 + accel * DT;*/\n    v = b.xy + accel * DT;\n    \n    \n    b = IN(0, 0);\n    b.z += 0.00001; // avoid division by zero\n    vec4 dbdx = (IN(1.5, 0) - IN(-1.5, 0)) / 2.0 / 1.5;\n    vec4 dbdy = (IN(0, 1.5) - IN(0, -1.5)) / 2.0 / 1.5;\n    \n    vec4 laplace_b = (IN(1.5, 0) + IN(-1.5, 0) + IN(0, 1.5) + IN(0, -1.5) - 4.0 * b) / (2.0 * 1.5 * 1.5);\n    // d/dx div_v:\n    // (0,-1)  ( 0,0)  (0, 1)\n    // (2, 0)  (-4,0)  (2, 0)\n    // (0, 1)  ( 0,0)  (0,-1)\n    // - laplace x\n    // (0,-1)  (-1,0)  (0, 1)\n    // (1, 0)  ( 0,0)  (1, 0)\n    // (0, 1)  (-1,0)  (0,-1)\n    // this is the least reliable term...\n    vec2 grad_div_v = vec2((-IN(-1.5, 1.5).y - IN(0, 1.5).x + IN(1.5, 1.5).y\n                           + IN(-1.5, 0).x              + IN(1.5, 0).x\n                           + IN(-1.5, 1.5).y - IN(0, 1.5).x - IN(1.5, 1.5).y) / (4.0*1.5*1.5) + 0.5 * laplace_b.x,\n                           (-IN(-1.5, 1.5).x + IN(0, 1.5).y + IN(1.5, 1.5).x\n                           - IN(-1.5, 0).y              - IN(1.5, 0).y\n                           + IN(-1.5, 1.5).x + IN(0, 1.5).y - IN(1.5, 1.5).x) / (4.0*1.5*1.5) + 0.5 * laplace_b.y);\n    \n    // Drho/Dt = -rho * div v\n    // changed to Drho/Dt = -rho * div v + laplace rho\n    // to dampen out soundwaves, as they are difficult numerically\n    float div_v = dbdx.x + dbdy.y;\n    float drho_dt_div_rho = -div_v;\n    \n    // equation of state\n    //float p = C*b.z*IN1(0, 0).z;\n    float T = CT * IN1(0, 0).z + 1.0;\n    float dTdx = (IN1(1.5, 0).z - IN1(-1.5, 0).z) / 2.0 / 1.5;\n    float dTdy = (IN1(0, 1.5).z - IN1(0, -1.5).z) / 2.0 / 1.5;\n    vec2 grad_T = CT * vec2(dTdx, dTdy);\n    vec2 grad_p_div_rho = C*(T*vec2(dbdx.z, dbdy.z) + b.z*grad_T)/b.z;\n    \n    // material derivative Dv/Dt = 1/rho (f - grad p)\n    // Euler equation:\n    //vec2 Dv_Dt = accel - grad_p_div_rho;\n    // Navier-Stokes equation:\n    vec2 Dv_Dt = accel - grad_p_div_rho + (ETA * laplace_b.xy + (ZETA + ETA/3.0) * grad_div_v) / b.z;\n    \n    // Now that the acceleration is known the transport from above is slightly invalid.\n    // However it is still mostly correct, so just add a little correction for large accelerations.\n    // Find a better approximation of the position that flows in to the currently computed position.\n    vec2 dx = (b.xy + Dv_Dt * DT - v) * 1.0;\n    if (length(dx) > length(v)*0.05) {\n        dx = normalize(dx) * length(v)*0.05;\n    }\n    float error = length(b.xy + Dv_Dt * DT - v) * 0.0; // set to a higher value to show acceleration estimation error\n    \n    // find the position, that flows to this position in one step\n    b = IN(dx.x, dx.y); // this leads to funny runaway effects depending on the choice above\n    \n    v = b.xy + Dv_Dt * DT;\n    // limit v for stability\n    float max_v = DT*200.0*min(b.z, 5.0);\n    if (length(v) > max_v) {\n        v = normalize(v) * max_v;\n    }\n    // prevent fluid entering the shape\n    if (shape(fragCoord + 2.0 * v * DT) > 0.5) {\n        v *= 0.5;\n        if (shape(fragCoord + 2.0 * v * DT) > 0.5) {\n            v *= 0.5;\n        }\n    }\n    // drho/dt = -b rho\n    // -> solution rho(t) = rho0 * exp(-b*t)\n    float rho = (b.z + laplace_b.z * 2.0*1.5*1.5/8.0) * exp(min(drho_dt_div_rho * DT, 1.0));\n    rho = mix(clamp(rho, 0.0, 100.0), 1.0, 0.01); // correct any total mass loss over time\n    if (shape(fragCoord) > 0.5) {\n        rho = mix(b.z + laplace_b.z * 2.0*1.5*1.5/8.0, 1.0, 0.01);\n    }\n    \n    // no-slip boundary condition\n    v *= 1.0 - shape(fragCoord);\n    \n    fragColor = vec4(v, rho, error);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define INA(x, y) texture(iChannel0, (fragCoord + vec2(float(x), float(y))) / iResolution.xy)\n#define INB(x, y) texture(iChannel1, (fragCoord - v + vec2(float(x), float(y))) / iResolution.xy)\n\n#define DT 0.5\n\n#define DIFFUSE 0.5\n\n// Transport reaction diffusion\n// 1. oxygen\n// 2. burning gas\n// 3. flame\n// 4. residual/ash\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if (iFrame == 0) {\n        //fragColor = vec4(1.0, 1.0, 0.0, 0.0);\n        vec4 col = texture(iChannel2, uv).xyzy;\n        col.y *= 2.0;\n        col.z = 0.0;\n        if (length(fragCoord - iResolution.xy/2.0) < 10.0) {\n            col.z = 1.0;\n        }\n        fragColor = col;\n        return;\n    }\n    \n    if (shape(fragCoord) > 0.5) {\n        // This here makes the shapes burn if the fuel \"inside\" the shape,\n        // which diffuses to the outside is set to > 0.0.\n        fragColor = vec4(1.0, max(0.0, cos(iTime * 0.5)), 0.0, 0.0);\n        return;\n    }\n    \n    float ignite = 0.0;\n    float fuel = 0.0;\n    if (iMouse.z > 0.0) {\n        vec2 dx = iMouse.xy - fragCoord;\n        float d = length(dx);\n        fuel = exp(-d*d/1000.0) * 4.0;\n        if (iMouse.w > 0.0) {\n            ignite = exp(-d*d/100.0) * 0.5 / DT;\n        }\n    }\n    \n    vec2 v = INA(0, 0).xy * DT;\n    \n    vec4 val = INB(0, 0);\n    // NOTE: this laplace diffuses also into the blocked shape...\n    vec4 laplace = (INB(1.5, 0) + INB(-1.5, 0) + INB(0, 1.5) + INB(0, -1.5) - 4.0 * val) / (2.0 * 1.5 * 1.5);\n    laplace.w *= -0.0; // don't diffuse the ash\n    \n    float burn = val.x * val.y * val.z;\n    vec4 f = vec4(\n        -5.0*burn + 0.5*(1.0 - val.x)*(1.0 - val.y),\n        -5.0*burn + fuel*(1.0 - val.y) + max(0.01 - val.w, 0.0) * 10.0,\n        -0.2 + 20.0 * burn + ignite,\n        0.3*val.z * (max(val.w, val.y - val.x) + 0.5) - 0.03);\n    \n    vec4 new_val = val + (f*0.1 + DIFFUSE * laplace) * DT;\n    new_val = clamp(new_val, vec4(0.0), vec4(1.0));\n    fragColor = new_val;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define GLOW_RADIUS 60.0\n#define GLOW_QUALITY 15.0\n\nfloat spiral(vec2 pos, float f, float offset) {\n    float r = length(pos);\n    float angle = atan(pos.y / (pos.x + r)) * 2.0 + offset;\n    return clamp(cos(r * f + angle) * 2.0, 0.0, 1.0);\n}\n\nfloat shape(vec2 pos) {\n    // shape for collisions\n    pos.x = min(pos.x, 800.0 - pos.x);\n    vec2 pos1 = vec2(800.0, 450.0) / 2.0 - vec2(100.0, 0.0); // can't use iResolution here...\n    float r1 = 100.0;\n    float s1 = length(pos - pos1) - r1;\n    s1 *= spiral(pos - pos1, 0.15, 1.9);\n    return clamp(-s1 * 1.0, 0.0, 1.0);\n}\n\n// normalized blackbody\nfloat blackbody(float f, float T) {\n    T = T + 0.0001;\n    return f*f*f / (exp(f / T) - 1.0) / (T * T * T * T);\n}\n\nvec3 human_blackbody(float T) {\n    return vec3(blackbody(4.4, T) * 0.75 + blackbody(7.5, T)*0.25, blackbody(5.6, T) * 0.9, blackbody(6.9, T) * 1.8);\n}\n\nvec3 flame_color(float ash, float energy) {\n    // color comes from blackbody radiation,\n    // but ash increases the heat capacity and thereby reduces the temperature\n    // however ash also increases the amount of emmitters -> intensity\n    float T = energy / (ash + 0.7) * 1.5; // idea from E = N kb T\n    return human_blackbody(T) * (ash + 0.3) * 2.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// render flame colors\nvec3 flames(vec2 uv) {\n    vec4 fire = texture(iChannel1, uv);\n    float flame = fire.z;\n    float ash = fire.w;\n    return flame_color(max(ash, 0.0), max(0.0, flame));\n}\n\nvec3 blur_x(vec2 uv) {\n    float radius = GLOW_RADIUS/iResolution.x;\n    float weight = 1.0;\n    vec3 color = flames(uv) * weight;\n    \n    // blur\n    for (float i = 1.0; i <= GLOW_QUALITY; i++) {\n        float r = i/GLOW_QUALITY;\n        float w = exp(-r*3.1415);\n        color += flames(uv + vec2(radius*r, 0.0)) * w;\n        color += flames(uv - vec2(radius*r, 0.0)) * w;\n        weight += w;\n    }\n    // normalize\n    color /= weight;\n    return color;\n}\n\n// blur x axis\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(blur_x(fragCoord / iResolution.xy),1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}