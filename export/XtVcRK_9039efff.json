{"ver":"0.1","info":{"id":"XtVcRK","date":"1536934928","viewed":202,"name":"fm bass","username":"nabr","description":"best fm synth on the planet ...continued\n\nhttps://en.wikipedia.org/wiki/Phase_distortion_synthesis  \n.","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["distortion","fm","deep","bass","howtohowbetternot","wediditforthememories","moog","unison","casio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// show sound message by FabriceNeyret2\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n#define C(c) U.x -= .5; T += U.x < .0 || U.x > 1. || U.y < 0. || U.y > 1. ? vec4(0) : textureGrad(iChannel3, U / 16. + fract(vec2(c, 15 - c / 16) / 16.), dFdx(U / 16.), dFdy(U / 16.))\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz) == 0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83); C(111); C(117); C(110); C(100); C(32); C(105); C(110);// message \"Sound in\"\n    return length(T.yz) == 0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tif (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n        if(c>=0.){fragColor=vec4(c, .25 - c, .5 - c, 1);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n//  the basic idea is to get on oscilator from (complex, euler) rotation\n//  somekind of flirting with complex nummers, fft, unison etc.\n//  it's experimental \n//  means you can imagine i would like to end every sentence with: \"it sounds better to my ears\".\n\n//  judging just by ears wearing headphones \n//  parameters for baseton 440Hz \n//  middel C ( vector tau, rotation time * 2.0 ) = g 1380.0\n// basetone\n#define g 1400.\n\n// oscillation\n// fm \n#define bo 16. \n#define Brot(p, a) p = (sin(bo * a) + cos(g * a)) * p + sin(g * a) * vec2(p.y, -p.x)\n\n// add, sub left from right channel and vica versa for stereo panorama, pow for distortion\n// second creating a slope  on the basewase form to get\n// https://en.wikipedia.org/wiki/Phase_distortion_synthesis\n// casio here we go\n#define brass(p) vec2(pow(p.x + p.y, cos(p.z)), pow(p.z + p.y, sin(p.z)))\n\n\n#define tau (8. * atan(1.))\n#define mult(z, w) vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x)\n\n\n// u n c o m m e n t \n//\n// and catapult urself into a wild trippy party you had back in the 90ies \n// you just can't remember on details til now \n\n// #define WEDIDITFORTHEMEMORIES\n\n#ifdef WEDIDITFORTHEMEMORIES\n#undef bo\n#define bo 6.\n#endif\n\n\n\nvec2 mainSound( in int samp,float time )\n{\n\n    // frequencies\n    float n = (time * float[](.16, .358, .12, .271)[int(time) % 4]);\n\n    // bassline \n    // ( somewhat ) x imaginary and y,z real sound\n    // x will give you phaser, flanger effect, possible bandfilter implementation\n    vec3 bassln = vec3(tau * (tau * .25), tau, tau * .25);\n    // also nice to use with default return \n    // suggestions: \n    // bassln = vec3(tau * tau, tau, tau * .2).yxz;\n    // bassln = vec3(tau * (tau * .25), tau, tau * .25).yxz;\n\n\n    // note: later with brass in order get distortion i use pow\n    // depending on circumstances more or less an artistic decision\n    float nf = sqrt(time * n) / 2.;\n    float nf1 = sqrt(time * n);\n\n    // apply rotation, already now you get a nice synth sound\n    Brot(bassln.xy, nf);\n    Brot(bassln.zy, nf1); //sum to 45 degrees\n\n    #ifndef WEDIDITFORTHEMEMORIES\n    \n    return sign(bassln.zy)*.125; \n\t\t  // bassln.zy\n    #else\n    \n    \n    // lets be progresive and summarize the following lines \n    // under terms bandfilter, envelope, sustain \n    vec2 mixch = vec2(0.1, 1.0);\n\n    vec2 left = vec2(1.0, cos(time * tau * 2.));\n    \n    vec2 right = vec2(0.7, -1.0); //-1 cut the sound\n\t\n    vec2 env = smoothstep(0.2, 0.4, mixch * mat2(left, right));\n\n    bassln.xy = env - mult(env, bassln.yz);\n\n\n    // 2 bars choppy 4 bars bass\n    if (mod(time, 4.6) != 1. && sin(ceil(time * .5) * 2.) >= 0.0) {\n        // shorten the function for details see above \n        vec2 env1 = smoothstep(0.02, 0.1, vec2(.85, .7) * mat2(-1, 1, cos(time * tau * 12.), -1.));\n\n        float noisef = .25;\n        bassln.yz -= mult(env1, bassln.zy) / noisef;\n        bassln.zx = mult(env1, bassln.yz) / .95;\n\n    }\n\n\n    return brass(bassln) * -.25;\n    #endif\n}","name":"Sound","description":"","type":"sound"}]}