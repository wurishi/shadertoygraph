{"ver":"0.1","info":{"id":"fldGWX","date":"1636836178","viewed":105,"name":"Cosine & GGX convolution","username":"Althar","description":"An implementation of the cosine & GGX convolutions for cubemaps, using importance sampling filtering.\n\nDefault : 16 samples per pixels with importance sampling filtering\nLeft click : 128 samples per pixels unfiltered","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["filtering","convolution","cosine","pbr","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See GPU-Based Importance Sampling : https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Scroll uvs\n    vec2 uvSample = fract(uv * vec2(3.0, 1.0));\n    \n    // View directions\n    vec3 viewDir = computeSphericalCoordinates(uvSample.yx);\n    \n    // Cubemap\n    vec3 cubemap = texture(iChannel0, viewDir).xyz;\n    \n    // Importance sampling filtering\n    bool importanceSampling = true;\n    \n    // Variable sample count\n    uint maxSampleCount = 16u;\n    uint sampleCount = maxSampleCount;\n    \n    // Variable roughness\n    float maxRoughness = 1.0;\n    float roughness = max(maxRoughness * (cos(iTime) * 0.5 + 0.5), 0.0);\n    uint roughnessSampleCount = max(uint(float(maxSampleCount) * roughness), 1u);\n    \n    // Importance sampling filtering toggle\n    if (fragCoord.x < iMouse.x)\n    {\n        sampleCount        = 64u;\n        importanceSampling = false;\n    }\n    \n    // Diffuse\n    vec3 diffuseCubemap = sampleCos(iChannel0, viewDir, sampleCount, importanceSampling);\n\n    // Reflection\n    vec3 reflectionCubemap = sampleGGX(iChannel0, viewDir, roughness, sampleCount, importanceSampling);\n    \n    // Select colour\n    vec3 colour = vec3(1.0, 0.0, 1.0);\n    if (abs(fragCoord.x - iMouse.x) < 2.0)\n    {\n        colour = vec3(0.0, 0.0, 0.0);\n    }\n    else if (uv.x > 2.0 / 3.0)\n    {\n        colour = reflectionCubemap;\n    }\n    else if (uv.x > 1.0 / 3.0)\n    {\n        colour = diffuseCubemap;\n    }\n    else\n    {\n        colour = cubemap;\n    }\n\n    // Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                      (3.14159265359)\n#define ONE_OVER_PI             (1.0 / 3.14159265359)\n#define TWO_PI                  (2.0 * 3.14159265359)\n\n#define MIN_ROUGHNESS \t\t\t(0.02)\n#define MIN_ROUGHNESS_SQUARED \t(MIN_ROUGHNESS*MIN_ROUGHNESS)\n\nvec3 computeSphericalCoordinates( vec2 uv )\n{\n\tfloat theta = uv.x * TWO_PI;\n\tfloat phi   = uv.y * PI;\n\treturn vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) );\n}\n\n// Texel solid angle from : http://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\nfloat areaElement( in float x, in float y )\n{\n    return atan(x * y, sqrt(x * x + y * y + 1.0) );\n}\n \nfloat texelCoordSolidAngle( in vec2 uv, in vec2 rcpSize )\n{\n    //scale up to [-1, 1] range (inclusive), offset by 0.5 to point to texel center.\n    float u = (2.0f * (uv.x + 0.5f) * rcpSize.x) - 1.0f;\n    float v = (2.0f * (uv.y + 0.5f) * rcpSize.y) - 1.0f;\n \n    // U and V are the -1..1 texture coordinate on the current face.\n    // Get projected area for this texel\n    float x0 = u - rcpSize.x;\n    float y0 = v - rcpSize.y;\n    float x1 = u + rcpSize.x;\n    float y1 = v + rcpSize.y;\n\n    float solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);\n \n    return solidAngle;\n}\n\nfloat selectMip( in float pdf, in float bias, in uint sampleCount, in vec2 uv, in vec2 rcpSize )\n{\n    float omegaS    = 1.0 / ( float(sampleCount) * pdf );\n    float omegaP    = texelCoordSolidAngle( uv, rcpSize );\n    float mipLevel  = max( 0.5 * log2( omegaS / omegaP ) + bias, 0.0 );\n\n    return mipLevel;\n}\n\nfloat selectMip( in float pdf, in float bias, in uint sampleCount, in float rcpOmegaP )\n{\n    float omegaS    = 1.0 / ( float(sampleCount) * pdf );\n    float mipLevel  = max( 0.5 * log2( omegaS * rcpOmegaP ) + bias, 0.0 );\n\n    return mipLevel;\n}\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfloat radicalInverse_VdC( in uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d( uint i, uint N ) \n{\n    return vec2( float(i)/float(N), radicalInverse_VdC(i) );\n}\n\nvec3 hemisphereSampleCos( in vec2 uv ) \n{\n    float phi \t\t    = uv.y * 2.0 * PI;\n    float cosThetaSqr   = 1.0 - uv.x;\n    float cosTheta \t    = sqrt( cosThetaSqr );\n    float sinTheta \t    = sqrt( 1.0 - cosThetaSqr );\n    return vec3( cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta );\n}\n\nvec3 hemisphereSampleGGX( in vec2 uv, in float r )\n{\n\tfloat a \t\t\t= max( r * r, MIN_ROUGHNESS_SQUARED );\n\tfloat a2  \t\t\t= a * a;\n\tfloat phi\t\t\t= uv.y * 2.0 * PI;\n\tfloat cosThetaSqr \t= ( 1.0 - uv.x ) / ( 1.0 + ( a2 - 1.0 ) * uv.x );\n    float cosTheta \t\t= sqrt( cosThetaSqr );\n    float sinTheta \t\t= sqrt( 1.0 - cosThetaSqr );\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\nfloat distributionGGX( in vec3 n, in vec3 h, in float r )\n{\n\tfloat a         = max( r * r, MIN_ROUGHNESS_SQUARED );\n\tfloat a2 \t\t= a * a;\n\tfloat nDotH    \t= clamp(dot( n, h ), 0.0, 1.0);\n\tfloat nDotH2   \t= nDotH * nDotH;\n\treturn a2 / ( PI * pow( nDotH2 * ( a2 - 1.0 ) + 1.0, 2.0 ) );\n}\n\n// Code from gpu pro 6\nmat3 generateFrame( in vec3 n )\n{\n\tvec3 up      = abs( n.z ) < 0.999 ? vec3( 0.0, 0.0, -1.0 ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 right   = normalize( cross( up, n ) );\n\tvec3 forward = cross( n, right );\n\treturn mat3( right, forward, n );\n}\n\n// Sample cos, as implementd by most game engines out there\n// (e.g. Unity, UE4, Filament, etc)\nvec3 sampleCos( in samplerCube cubemap, in vec3 n, in uint sampleCount, in bool importanceSampling )\n{\n    vec2 rcpSize     = vec2(1.0) / vec2(textureSize( cubemap, 0 ));\n\tfloat rcpOmegaP  = 1.0 / texelCoordSolidAngle( /*uv*/vec2(0.5), rcpSize );\n    \n\tmat3 frame   \t = generateFrame( n );\n\tvec3 radiance \t = vec3(0.0);\n\n\tfor( uint i = 0u ; i < sampleCount ; ++i )\n\t{\n\t\tvec2 r  \t\t= hammersley2d( i, sampleCount );\n\t\tvec3 s  \t\t= hemisphereSampleCos( r );\n\t\tvec3 l\t\t\t= normalize( frame * s );\n\n\t\tfloat nDotL \t= clamp(dot( n, l ), 0.0, 1.0);\n\t\t\n\t\tif( nDotL > 0.0 )\n\t\t{\n            float pdf       = nDotL * ONE_OVER_PI;\n\t\t\tfloat mipLevel  = importanceSampling ? selectMip( pdf, 0.0, sampleCount, rcpOmegaP ) : 0.0;\n            \n\t\t\tradiance.xyz   += textureLod(cubemap, l, mipLevel).xyz;\n\t\t}\n\t}\n\n\treturn radiance.xyz / float(sampleCount);\n}\n\nvec3 sampleHL2Basis(in vec3 li[6], in vec3 n)\n{\n    vec3 nSquared = n * n;\n    ivec3 isNegative = ivec3(step(n, vec3(0.0)));\n    vec3 radiance = vec3(\n        nSquared.x * li[isNegative.x + 0] +\n        nSquared.y * li[isNegative.y + 2] +\n        nSquared.z * li[isNegative.z + 4]\n    );\n    \n    return radiance;\n}\n\nvec3 sampleCosApprox( in samplerCube cubemap, in vec3 n)\n{\n    // 6 basis samples\n    vec3 li[] = vec3[] (\n        textureLod(cubemap, -vec3( 1.0, 0.0, 0.0), 0.0).xyz,\n        textureLod(cubemap, -vec3(-1.0, 0.0, 0.0), 0.0).xyz,\n        textureLod(cubemap, -vec3( 0.0,-1.0, 0.0), 0.0).xyz,\n        textureLod(cubemap, -vec3( 0.0, 1.0, 0.0), 0.0).xyz,\n        textureLod(cubemap, -vec3( 0.0, 0.0,-1.0), 0.0).xyz,\n        textureLod(cubemap, -vec3( 0.0, 0.0, 1.0), 0.0).xyz\n    );\n    \n    vec3 average = (li[0] + li[1] + li[2] + li[3] + li[4] + li[5]) / 6.0;\n    \n    vec3 radiance = sampleHL2Basis(li, n);\n    \n    return (radiance * 0.5 + average * 0.5);\n}\n\nvec3 sampleGGX( in samplerCube cubemap, in vec3 n, in float roughness, in uint sampleCount, in bool importanceSampling )\n{\n    vec2 rcpSize     = vec2(1.0) / vec2(textureSize( cubemap, 0 ));\n\tfloat rcpOmegaP  = 1.0 / texelCoordSolidAngle( /*uv*/vec2(0.5), rcpSize );\n   \n\tmat3 frame   \t = generateFrame( n );\n\tvec4 radiance \t = vec4(0.0);\n\n\tfor( uint i = 0u ; i < sampleCount ; ++i )\n\t{\n\t\tvec2 r  \t\t= hammersley2d( i, sampleCount );\n\t\tvec3 s  \t\t= hemisphereSampleGGX( r, roughness );\n\t\tvec3 h          = normalize( frame * s );\n\t\tvec3 l\t\t\t= 2.0 * clamp(dot( n, h ), 0.0, 1.0) * h - n;\n\n\t\tfloat hDotL \t= clamp(dot( h, l ), 0.0, 1.0);\n\t\t\n\t\tif( hDotL > 0.0 )\n\t\t{\n            float pdf       = distributionGGX( n, h, roughness ) / 4.0;\n\t\t\tfloat mipLevel  = importanceSampling ? selectMip( pdf, 0.0, sampleCount, rcpOmegaP ) : 0.0;\n            \n            radiance.xyz   += textureLod(cubemap, l, mipLevel).xyz * hDotL;\n\t\t\tradiance.w\t   += hDotL;\n\t\t}\n\t}\n\n\treturn radiance.xyz / radiance.w;\n}","name":"Common","description":"","type":"common"}]}