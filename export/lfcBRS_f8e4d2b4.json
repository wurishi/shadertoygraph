{"ver":"0.1","info":{"id":"lfcBRS","date":"1733216596","viewed":304,"name":"Chladni Plate Simulation","username":"Nguyen2007","description":":)","likes":35,"published":3,"flags":40,"usePreview":0,"tags":["pattern","physics","chladni"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Big thanks to beans_please and 01000001 for helping me out with this project!\n\nvec4 sky(vec3 rd, float lod)\n{\n    vec4 O = textureLod(iChannel2, rd, lod);\n    return atanh(O);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    if (false)\n    {\n        uvec4 IDs = floatBitsToUint(texelFetch(iChannel0, ivec2(I), 0));\n        O = vec4(IDs[0]) / vec4(nParticle);\n        return;\n    }\n    \n    vec2 uv = getUV(I), p;\n    \n    vec3 ro = (1.6 + 10. * exp(-2. * iTime)) * vec3(cos(.1 * iTime), 1, sin(.1 * iTime)),\n         lp = .17 * ro * vec3(1, 0, 1),\n\n         ww = normalize(lp - ro),\n         uu = cross(vec3(0, 1, 0), ww),\n         vv = cross(ww, uu),\n         rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n    \n    uv = (ro - rd * ro.y / rd.y).xz;\n    \n    O = sky(rd, 0.);\n    \n    if(collider(uv) < 0.) return;\n    \n    rd.y = -rd.y;\n    \n    uint ID;\n    \n    O = .2 * sky(rd, 7.);\n    \n    float d = 1e2;\n    for (uint i = 0u; i < 4u; i++)\n    {\n        uint id = floatBitsToUint(texelFetch(iChannel0, ivec2(getI(uv)), 0))[i];\n        \n        if (id >= nParticle) continue;\n        \n        vec2 temp = getCoord(id).xy - uv;\n        \n        if(dot2(temp) < d) d = dot2(p = temp), ID = id;\n    }\n    \n    O = mix(O, 1.5 * vec4(1, .8, .6, 1), smoothstep(3. * radius, 0., sqrt(d)));\n    \n    O = mix(O, .6 * vec4(1, .8, .6, 1), exp(-iTime));\n    \n    O = tanh(O);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define resCoord ivec2(R.xy - 1.)\n\n#define nParticle uint(R.x * R.y)\n\n#define radius 1. / R.y\n\n#define getCoord(p) texelFetch(iChannel1, ivec2((p) % uint(R.x), (p) / uint(R.x)), 0)\n#define getUV(p) (2. * (p) - R.xy) / R.y\n#define getI(p) .5 * ((p) * R.y + R.xy)\n\n#define dot2(p) dot(p, p)\n\nfloat collider(vec2 p)\n{\n    float d = 1e9;\n    \n    d = min(d, p.x + 1.);\n    d = min(d, p.y + 1.);\n    d = min(d, 1. - p.x);\n    d = min(d, 1. - p.y);\n    \n    return d;\n}\n\nvec4 getParameter(float t)\n{\n    t = mod(floor(.3 * t), 8.);\n    \n    return t < 1. ? vec4(1, -1, 2, 3):\n           t < 2. ? vec4(1, -.5, 5, 2):\n           t < 3. ? vec4(.5, -1, 3.5, 5):\n           t < 4. ? vec4(1, 1, 3, 4.5):\n           t < 5. ? vec4(1, -1, 4.5, 1.5):\n           t < 6. ? vec4(1, -.5, 2, 4):\n           t < 7. ? vec4(.5, 1, 3.5, 2):\n                    vec4(1, 1, 1, 3.5);\n}\n\nfloat getAmp(float t)\n{\n    return pow(abs(sin(.3 * 3.141593 * t)), .7);\n}\n\n#define PI  3.141593\n#define TAU 6.283185\n\nfloat chladini(vec2 p, vec4 v)\n{\n    p *= PI;\n    return dot(v.xy, vec2(sin(v.w * p.x) * sin(v.z * p.y), sin(v.z * p.x) * sin(v.w * p.y))) / dot(abs(v.xy), vec2(1));\n}\n\nuvec4 seed;\n\nvec4 PCG(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    return vec4(v) / 4294967296.;\n}\n\n#define rand  rand4.x\n#define rand2 rand4.xy\n#define rand3 rand4.xyz\n#define rand4 PCG(seed)\n\nvec2 ranDir()\n{\n    float phi = TAU * rand;\n    return vec2(cos(phi), sin(phi));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Voronoi buffer\n\nuvec4 id; vec2 uv;\nvec4 dist = vec4(1e9);\n\nvoid insertList(uint i)\n{\t\n    if(any(equal(uvec4(i), id))) return;\n    \n    float d = dot2(getCoord(i).xy - uv);\n    \n    if      (d < dist.x) id = uvec4(i, id.xyz),      dist = vec4(d, dist.xyz);\n    else if (d < dist.y) id = uvec4(id.x, i, id.yz), dist = vec4(dist.x, d, dist.yz);\n    else if (d < dist.z) id = uvec4(id.xy, i, id.z), dist = vec4(dist.xy, d, dist.z);\n    else if (d < dist.w) id = uvec4(id.xyz, i),      dist = vec4(dist.xyz, d);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    if (ivec2(I) == resCoord)\n    {\n        O = vec4(R.xy, 0, 0);\n        return;\n    }\n    \n    uv = getUV(I);\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    if (texelFetch(iChannel0, resCoord, 0).xy != R.xy)\n    {\n        O = uintBitsToFloat(uvec4(rand4 * float(nParticle)));\n        return;\n    }\n    \n    for (int i = 0; i < 4; i++)  insertList(floatBitsToUint(texelFetch(iChannel0, ivec2(I), 0)[i]));\n    for (int i = 0; i < 12; i++) insertList(floatBitsToUint(texelFetch(iChannel0, ivec2(I + 3. * atanh(rand) * ranDir()), 0)[i % 4]));\n    for (int i = 0; i < 8; i++)  insertList(uint(rand * float(nParticle)));\n    \n    O = uintBitsToFloat(id);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Data buffer\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    I -= .5;\n    \n    if (ivec2(I) == resCoord)\n    {\n        O = vec4(R.xy, 0, 0);\n        return;\n    }\n    \n    if (uint(I.x + I.y * R.x) >= nParticle) return;\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    if (texelFetch(iChannel1, resCoord, 0).xy != R.xy)\n    {\n        O = vec4(2. * rand2 - 1., 0, 0);\n        return;\n    }\n    \n    O = texelFetch(iChannel1, ivec2(I), 0);\n    \n    vec2 pos = O.xy, vel = O.zw,\n         nearPos[4], nearVel[4];\n    \n    vec4 nearDist;\n    \n    float dt = .02;\n    \n    for (uint i = 0u; i < 4u; i++)\n    {\n        vec4 data2 = getCoord(floatBitsToUint(texelFetch(iChannel0, ivec2(floor(getI(pos))), 0))[i]);\n        nearPos[i] = data2.xy;\n        nearVel[i] = data2.zw;\n        nearDist[i] = distance(pos, nearPos[i]);\n    }\n    \n    vel += (30. * chladini(pos, getParameter(iTime)) * getAmp(iTime) * ranDir() - 6. * vel) * dt;\n    \n    pos += vel * dt;\n    \n    for (int i = 1; i < 4; i++)\n    {\n        if (nearDist[i] < 2. * radius && nearDist[i] > 0.)\n        {\n            vec2 n = normalize(pos - nearPos[i]);\n            pos += n * (2. * radius - nearDist[i]);\n            if (dot(nearPos[i] - pos, vel) > 0.)\n            { \n                vel -= dot(vel - nearVel[i], pos - nearPos[i]) * n;\n                vel -= 2. * dot(vel, n) * n;\n            }\n        }\n    }\n    \n    float d = collider(pos);\n        \n    vec2 normal = normalize(vec2(collider(pos + vec2(.01, 0)), collider(pos + vec2(0, .01))) - d);\n\n    if (d < 0.) pos += (.01 - d) * normal, vel = reflect(vel, normal);\n    \n    O = vec4(pos, vel);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float f0(float t)\n{\n    return 450. * length(getParameter(t).zw);\n}\n\nvec2 mainSound(int s, float t)\n{\n    return .3 * vec2(sin(f0(t) * t) * getAmp(t));\n}","name":"Sound","description":"","type":"sound"}]}