{"ver":"0.1","info":{"id":"MXSfRd","date":"1729819503","viewed":54,"name":"Raymarcher Project - Oct 2024","username":"Pyromican","description":"IoR 1.0 - 2.0\n\nFeatures: Blinn-Phong BRDF, Soft Shadows, SDF's, Dielectric Fresnel, Anti-Aliasing (RGSS), Ambient Occlusion, IoR, & Bad Reflections.\n\nUpdates: Improved the soft shadows and the Dielectric Fresnel works properly now. Also better scene :D\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","balls","materials","reflections","learning","shiny","fresnel","ior"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAYMARCH_STEPS = 500;\nconst float nearPlane = 0.0001;\nconst float farPlane = 100.0;\nconst float PI = 3.1415926535;\nconst float GAMMA = 2.2;\nconst int aaON = 4;\nconst int aaOFF = 1;\n\nvec3 camera = vec3(0.0, 3.0, 1.0);\nvec3 col = vec3(0.0);\n\nfloat attConst = 1.0;\nfloat attLinear = 0.0035f;\nfloat attQuad = 0.0005f;\n\n\nstruct Material\n{\n    vec3 ambientCol;\n    vec3 diffCol;\n    vec3 specCol;\n    float alpha;\n    float gloss;\n    float ior;\n};\n\nstruct Surface\n{\n    float sd;\n    vec3 color;\n    Material mat;\n};\n\n//----------Materials----------//\n\nMaterial Mithril()\n{\n    vec3 a = vec3(0.00155, 0.00137, 0.00255);\n    vec3 d = vec3(0.02377, 0.12027, 0.13769);\n    vec3 s = vec3(0.088845, 0.55, 0.55);\n    float alpha = 45.0;\n    float gloss = 1.0;\n    float ior = 1.0;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\n\nMaterial Black()\n{\n    vec3 a = vec3(0.1);\n    vec3 d = vec3(0.6, 0.6, 0.55); //Kinda shitty gold vec3(0.815, .418501512, .00180012)\n    vec3 s = vec3(1.0);\n    float alpha = 45.0;\n    float gloss = 0.55;\n    float ior = 1.0; \n    return Material(a, d, s, alpha, gloss, ior);\n}\n\nMaterial Circus(vec3 p)\n{\n    vec3 a = vec3(mod(floor(p.x * 2.0) + floor(p.y * 2.0) + floor(p.z * 2.0), 2.0), 0.0, 0.0) * 0.4; //mod 2.0 with a floor will force it to either be 0.0(black) or 1.0(white)\n    if (a.x == 0.0)\n        a = vec3(0.01, 0.01, 0.5);\n    \n    vec3 d = vec3(a * 0.4);\n    vec3 s = vec3(a + vec3(0.1));\n    float alpha = 235.0;\n    float gloss = 1.0;\n    float ior = 2.0;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\nMaterial Checkerboard(vec3 p)\n{\n    vec3 a = vec3(mod(floor(p.x * 2.0) + floor(p.z * 2.0), 2.0)) * 0.55; //mod 2.0 with a floor will force it to either be 0.0(black) or 1.0(white)\n    if (a.x == 0.0)\n        a = vec3(0.2);\n    \n    vec3 d = vec3(a * 0.8);\n    vec3 s = vec3(1.0);\n    float alpha = 7.5;\n    float gloss = 1.0;\n    float ior = 1.75;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\n//----------Signed Distance Fields----------//\nSurface SDFfloor(vec3 p, vec3 color, Material mat) // Waves\n{\n    float d = p.y - (0.5 * sin(p.z + iTime) - 0.5 * sin(p.x + iTime)) / 2.0 + 1.0;\n    return Surface(d, color, mat);\n}\n\nSurface SDFplane(vec3 p, vec3 color, Material mat) // Flat\n{\n    float d = p.y + 1.0;\n    return Surface(d, color, mat);\n}\n\nSurface SDFsphere(vec3 p, float radius, vec3 move, vec3 color, Material mat)\n{\n    float d = length(p - move) - radius;    \n    return Surface(d, color, mat);\n}\n\nSurface SDFframe(vec3 p, vec3 rect, vec3 move, vec3 color, Material mat)\n{\n    p = p - move;\n    p = abs(p) - rect;\n    vec3 q = abs(p + 0.20) - 0.20;\n    \n    float a = length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0);\n    float b = length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0);\n    float c = length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0);\n\n    float d = min(min(a, b), c) - 0.25;\n    return Surface(d, color, mat);\n}\n\nSurface minObjectDistance(Surface obj1, Surface obj2)\n{\n    if (obj1.sd < obj2.sd)\n        return obj1;        \n    return obj2;\n}\n\nSurface map(vec3 p)\n{\n    Material ColorB;\n    Surface d;\n    Surface sphere = SDFsphere(p, 1.55, vec3(-8.75, 1.5, -15.0), vec3(0.0), Black());\n    sphere = minObjectDistance(sphere, SDFframe(p, vec3(10.35, 4.0, 2.0), vec3(0.0, 3.5, -15.0), vec3(0.0), Circus(p)));\n  \n    \n    for (int i = 1; i < 6; i++)\n    {   \n        ColorB = Black();\n        float newIor = float(i) * 0.3;\n        //float newShine = float(i) * 1.1;\n        ColorB.ior += newIor;\n        //ColorB.alpha *= newShine;\n        sphere = minObjectDistance(sphere, SDFsphere(p, 1.55, vec3(-8.75 + 3.5 * float(i), 1.5, -15.0), vec3(0.0), ColorB));\n    }\n    \n    return minObjectDistance(sphere, SDFplane(p, vec3(0.0), Checkerboard(p)));\n}\n\n\n//----------Normals----------//\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0001;    \n    return normalize (e.xyy * map(p + e.xyy).sd +\n                      e.yyx * map(p + e.yyx).sd +\n                      e.yxy * map(p + e.yxy).sd +\n                      e.xxx * map(p + e.xxx).sd);\n}\n\n//----------Ray Marching Methods----------//\nSurface rayMarch(inout vec3 ro, inout vec3 rd)\n{\n    float depth = nearPlane; //Starting depth\n    Surface d;\n\n    for(int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        d = map(ro + rd * depth); // Calculates the SDF\n        depth += d.sd;// adds the SDF to the length of the ray\n        \n        if (d.sd < nearPlane || depth > farPlane)\n            break;\n    }   \n    d.sd = depth;\n    return d;\n}\n\nfloat softShadow(vec3 fragPos, vec3 lightPos)\n{\n    float res = 1.0;\n    float depth = 0.01; //Artifacts appear if you start lower\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        float d = map(fragPos + lightDir * depth).sd;\n        res = min(res, d/(depth * 0.25));\n        depth += d;\n        \n        if (d < nearPlane || depth > farPlane) //the lower limit of \"d\" needs to be lower than the one in the rayMarch function to avoid having a streak of light on overlapping shadows.\n            break;\n    }\n    \n    res = max(res, 0.01);\n    \n    return clamp(0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res), 0.05, 1.0);\n    //return clamp(res, 0.05, 1.0 ); //clamps the res value between nonzero numbers so it doesn't black out everything\n}\n\nfloat AmbientOcclusion(vec3 fragPos, vec3 normal)\n{\n    float occ = 0.0;\n    float weight = 1.0;\n    for(int i = 0; i < 8; i++)\n    {\n        float len = 0.01 + 0.02 * float(i * i);\n        vec3 p = fragPos + normal * len;\n        float dist = map(p).sd;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\n//----------BRDF (Blinn Phong)----------//\nvec3 BlinnPhong(vec3 normal, vec3 lightPos, vec3 fragPos, Material mat)\n{ \n    //ambient\n    float occ = AmbientOcclusion(fragPos, normal);\n    vec3 ambient = mat.ambientCol;\n    ambient *= occ;\n    //return vec3(0.9) * occ; //Occlusion test\n    \n    //diffuse\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.diffCol;\n        \n    //specular with normalization\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 viewDir = normalize(camera - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = max(dot(normal, halfwayDir), 0.0);\n    spec = pow(spec, mat.alpha) * ((mat.alpha + 2.0) / (4.0 * PI * (2.0 - exp(-mat.alpha/2.0))));\n    vec3 specular = spec * mat.specCol;\n    \n    //phong\n    return (ambient + diffuse + specular);\n}\n\nvec3 reflectBP(vec3 normal, vec3 lightPos, vec3 fragPos, Material mat, vec3 reflectDir)\n{\n    //ambient\n    vec3 ambient = mat.ambientCol;\n    \n    //diffuse\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.diffCol;\n    \n    //specular with normalization\n    vec3 viewDir = normalize(camera - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = max(dot(reflectDir, halfwayDir), 0.0);\n    spec = pow(spec, mat.alpha) * ((mat.alpha + 2.0) / (4.0 * PI * (2.0 - exp(-mat.alpha/2.0))));\n    vec3 specular = spec * mat.specCol;\n    \n    return ambient + diffuse + specular;\n}\n\n//----------Anti-Aliasing----------//\n// Takes four evenly spaced rotated supersamples in each pixel\nvec2 RGSS(int num)\n{\n    if (num == 0) return vec2(0.125, 0.375);\n    if (num == 1) return vec2(-0.125, -0.375);\n    if (num == 2) return vec2(0.375, -0.125);\n    else return vec2(-0.375, 0.125);  \n}\n\n\nfloat dielectricFresnel(vec3 normal, vec3 rd, Material object)\n{\n    float NdotV = dot(normal, -rd);\n    \n    float fresnel = clamp(pow(1.0 - NdotV, 5.0), 0.0, 1.0);\n    float k = pow(object.gloss - object.ior, 2.0) / pow(object.gloss + object.ior, 2.0);\n    fresnel += (1.0 - fresnel) * k;\n    fresnel += pow(1.0 - NdotV, 5.0) * pow(1.0 - object.gloss, 2.0);\n    //return mix(0.01, 1.0, fresnel);\n    return fresnel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 background;\n    Surface d;\n    int i;\n    for (i = 0; i < aaON; i++) //Toggle Anti-aliasing on/off with \"aaON/aaOFF\"\n    {\n        vec2 uv = ((fragCoord + RGSS(i)) - 0.5 * iResolution.xy)/iResolution.y; //aspect ratio       \n        vec3 rd = normalize(vec3(uv, -1.0)); //Turns the uv into a 3D vector by making it point outwards\n        background = mix(vec3(0.871, 0.631, 0.576), vec3(0.507, 0.784, 0.898), uv.y + 0.7);\n        //background = mix(vec3(0.507, 0.784, 0.898), vec3(0.871, 0.631, 0.576), uv.y + 0.9);\n        //background = vec3(1.0);\n\n        d = rayMarch(camera, rd);\n        Material shine = d.mat;\n        float attenuation = 1.0 / (attConst + attLinear * d.sd + attQuad * d.sd * d.sd);\n        vec3 fragPos = camera + rd * d.sd;\n        vec3 normal = vec3(calcNormal(fragPos));\n        vec3 reflectDir = reflect(rd, normal);\n        vec3 lightPos = vec3(30.0 * cos(iTime * 0.420), 30.0, 30.0 * sin(iTime * 0.420) - 15.0);\n        vec3 b_phong = vec3(0.0f);\n\n        if (d.sd <= farPlane)\n        {\n            float fresnel = dielectricFresnel(normal, rd, d.mat);\n            vec3 ref = fragPos + normal * 0.005;   \n            \n            //Reflections\n            for (int i = 0; i < 1; i++)\n            {   \n                Surface bounce = rayMarch(ref, reflectDir);\n                if (bounce.sd <= farPlane)\n                    shine = Material(shine.ambientCol + bounce.mat.ambientCol * fresnel, shine.diffCol + bounce.mat.diffCol * fresnel, shine.specCol + bounce.mat.specCol * fresnel, shine.alpha, shine.gloss, shine.ior);\n\n                else\n                    shine = Material(shine.ambientCol + background * fresnel, shine.diffCol + background * fresnel, shine.specCol + background * fresnel, shine.alpha, shine.gloss, shine.ior);                   \n                \n                //reflectDir = normalize(reflectDir, fragPos);\n            }\n        \n        b_phong += BlinnPhong(normal, lightPos, fragPos, shine);             \n        float softShadow = softShadow(fragPos + normal * 0.003, lightPos);\n        col += b_phong * softShadow * attenuation;\n        \n        }\n        \n        else col += background; //Rays go into the v o i d ~\n    }\n    \n    col /= float(i);\n    col = mix(col, background, 1.0 - exp(-0.000005 * d.sd * d.sd * d.sd)); //fog\n    fragColor.rgb = pow(col.rgb, vec3(1.0/GAMMA));\n    }","name":"Image","description":"","type":"image"}]}