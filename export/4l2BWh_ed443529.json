{"ver":"0.1","info":{"id":"4l2BWh","date":"1515602913","viewed":364,"name":"blurred reflections","username":"helo3D","description":"Blurring a cube map input.\nMipmaps did not seem to work for texture() with a samplerCube.\nI'm certain a lot of optimisation can be done here. Please let me know what you find, I'm here to learn!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflection","blur","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SAMPLING_RATE = 16; // x^2 samples\n\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nvec3 randVec3(int i)\n{\n    float s = float(i); // seed\n\treturn vec3( fract( sin(s*6793.6)*2986.3 )*2.0-1.0\n               , fract( sin(s*9365.3)*9374.5 )*2.0-1.0\n               , fract( sin(s*2347.2)*8264.7 )*2.0-1.0\n               );\n}\n\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nvec3 sampledBlur(float r, samplerCube t, vec3 v, int maxS)\n{\n    r = fract(r); // limit radius to [0..1]\n    vec3 c = texture(t, v).rgb;\n    //.----------------\n    //| RANDOM SAMPLING - look up texture maxS^2 times in a radius r around v\n    vec3 rv;\n    float w, tw = 0.0;\n    for (int i=0; i<maxS*maxS; i++)\n    {\n        rv = v + randVec3(i) * r;\n        tw = length(rv); // account for sampling distance\n    \tc += texture(t, rv).rgb * tw;\n        w += tw*1.0; // values less than 1 like 0.85 fake bloom of bright areas\n        \t\t\t // could be handy for specularity\n    }\n\treturn c/(w+1.0); // divide result by accumulated weight w\n}\n\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //.-------------------\n    //| BASIC PREPARATIONS\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 as = vec2(iResolution.x/iResolution.y, 1.0); // aspect ratio\n    vec3 v = normalize(vec3(uv*2.0-1.0, 1)); // replace with simple camera\n    float t = iTime;\n    //.---------------\n    //| FOCUS POSITION - ether rotate in a circle or follow mouse\n    vec2 p = vec2(0.5+sin(t)*0.3, 0.5+cos(t)*0.3); // \n    vec2 m = iMouse.xy / iResolution.xy;\n    if (m != vec2(0.0))\n    \tp = m;\n    //.---------------\n    //| SAMPLE TEXTURE - compute sampling radius based on focus and sample texture\n    float s = smoothstep(0.15, 1.5, distance(uv*as, p*as));\n    vec3 c = sampledBlur(s * 0.25, iChannel0, v, SAMPLING_RATE);\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}