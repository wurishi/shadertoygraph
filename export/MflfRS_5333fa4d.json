{"ver":"0.1","info":{"id":"MflfRS","date":"1723953367","viewed":53,"name":"terrain with red fog effect","username":"akr51","description":"ray marching with smooth noise effect to create terrain with fog effect","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ITR 100\n#define DST 60.0\n#define SRF 0.001\n\n\n\nfloat noise(vec2 uv)\n{\n\n\n    return fract(sin(dot(uv, vec2(12.0, 101.0))) * 1010.0); \n\n\n}\n\n\n\n\n\n\n\nfloat smooth_noise(vec2 uv)\n{\n\n\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 w = (f * f * (3.0 - 2.0 * f));\n    float n[4];\n    int d = 0;\n    \n    for (float r = 0.0; r <= 1.0; r++)\n    {\n        \n        for (float c = 0.0; c <= 1.0; c++) \n        {\n        \n            n[d++] = noise(i + vec2(r, c));\n            \n        \n        }\n    \n    }\n    \n    \n    float n0 = mix(n[0], n[2], w.x);\n    float n1 = mix(n[1], n[3], w.x);\n    return mix(n0, n1, w.y);\n\n\n}\n\n\n\nfloat turbulence(vec2 uv, float octvs)\n{\n\n\n    float t = -0.5;\n    \n    for (float f = 1.0; f <= octvs; f++)\n    {\n    \n    \n        float power = pow(2.1, f);\n        t += abs(smooth_noise(uv * power) / power);\n        \n    \n    }\n    \n    return t;\n\n\n}\n\n\n\n\nfloat plane(vec3 sp)\n{\n\n    sp.z += iTime * 2.0;\n    sp.x += iTime * 0.5;\n    return sp.y + turbulence(sp.xz, 3.0) * 0.7;\n\n\n}\n\n\n\nvec2 map(vec3 sp)\n{\n\n    \n    float dst[1];\n    dst[0] = plane(sp);\n    \n    float id = 0.0;\n    \n    for (int i = 1; i < 1; i++) \n    {\n    \n        if (dst[i] < dst[0])\n        {\n        \n            dst[0] = dst[i];\n            id = float(i);\n        \n        \n        }\n    \n    \n    }\n\n    return vec2(dst[0], id);\n\n}\n\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\n\n    float d0 = 0.0;\n    float id = 0.0;\n    \n    for (int i = 0; i < ITR; i++) \n    {\n    \n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp);\n        id = ds.y;\n        d0 += ds.x * 0.90;\n        \n        if (d0 > DST || abs(ds.x) < SRF) break;\n        \n    \n    }\n    \n    return vec2(d0, id);\n    \n}\n\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p).x - vec3(map(p - d.xyy).x, map(p - d.yxy).x, map(p - d.yyx).x));\n    \n\n}\n\n\n\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\n\n    vec3 l = normalize(lp - p);\n    vec3 n = nml(p);\n    float df = clamp(dot(n, l), 0.0, 1.0);\n    \n    vec2 ds = mrch(p + n * 0.02, l);\n    \n    if (ds.x < length(lp - p))\n    {\n    \n    \n        df *= 0.1;\n        \n    \n    }\n\n    return df;\n\n\n}\n\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n\n\n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    vec2 rr = iResolution.xy;\n    vec2 uv = (u + u - rr) / rr.y;\n    \n    uv.x *= (1.0 + cos(uv.y * 5.0) * 0.1);\n    \n    vec3 ro = vec3(cos(iTime * 0.25), 0.4 + sin(iTime) * 0.5 + 0.6, -5.0);\n    vec3 fx = vec3(0.0, 0.1,  0.0);\n    vec3 rd = dir(uv, ro, fx);\n    vec3 lp = vec3(0.0, 0.8, 0.3);\n    \n    vec3 cl = vec3(0.0);\n    \n    vec2 d0 = mrch(ro, rd);\n    \n    float fog_dst = d0.x;\n    float fog_falloff = exp(-fog_dst * 0.08);\n    vec3 fog_color = vec3(2.6, 0.4, 0.1);\n    \n    if (d0.x > 0.0 && d0.x < DST)\n    {\n    \n    \n        vec3 sp = ro + rd * d0.x;\n        float lt = lighting(sp, lp);\n        cl += lt + turbulence(sp.xz, 6.0);\n    }\n    \n    cl = mix(fog_color, cl, fog_falloff); \n    cl = pow(cl + 0.1, vec3(5.0));\n    \n    c_out = vec4(vec3(cl), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}