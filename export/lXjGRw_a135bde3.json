{"ver":"0.1","info":{"id":"lXjGRw","date":"1708324234","viewed":120,"name":"Voss-McCartney Pink Noise","username":"Cellulose","description":"Just a simple audio/video demo of Voss-McCartney pink noise algorithm (see Common tab) using Melissa O'Neill's PCG as a hash.\nThis noise uses no interpolation; McCartney's technique offsets noise layers making square artifacts harder to spot.","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["noise","sound","dsp","pinknoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See Common code for pink noise algorithm.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float noise = pinkNoise2D(uvec2(\n        uint(fragCoord.x) + uint(4*iFrame),\n        uint(fragCoord.y) + uint(iFrame)));\n\n    // Time varying pixel color\n    vec3 col = vec3(\n        exp2(-noise*1.5),\n        exp2(-noise*4.0),\n        exp2(-noise*1.5)\n        );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// See Common code for pink noise algorithm.\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( .25 + .25 * pinkNoise(uint(samp)) );\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"uint pcg_hash(uint x)\n{\n    // A variation on Melissa O'Neill's PCG random technique\n    uint state = x * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n// return value 0~1 but tends toward central values\nfloat pinkNoise(uint x)\n{\n    float sum_y = 0.0, sum_w = 0.0, w = 1.0;\n    x *= 2u; // Adds a layer of white noise\n    for (int i = 0; i < 10; ++i)\n    {\n        uint p = (x/2u);\n        sum_y += w * (float(pcg_hash(p)) / 4294967296.0);\n        sum_w += w;\n        x = (x + 1u) / 2u; // offset for consistent variation per step\n    }\n    return sum_y / sum_w;\n}\n\n// return value 0~1 but tends toward central values\nfloat pinkNoise2D(uvec2 x)\n{\n    float sum_y = 0.0, sum_w = 0.0, w = 1.0;\n    x *= 2u; // Adds a layer of white noise\n    for (int i = 0; i < 10; ++i)\n    {\n        uint p = (x.x/2u) ^ ((x.y/2u) << 16);\n        sum_y += w * (float(pcg_hash(p)) / 4294967296.0);\n        sum_w += w;\n        x = (x + 1u) / 2u; // offset for consistent variation per step\n    }\n    return sum_y / sum_w;\n}\n","name":"Common","description":"","type":"common"}]}