{"ver":"0.1","info":{"id":"DsKyRh","date":"1695778578","viewed":178,"name":"3D Curly Noise","username":"CollinInMySternum","description":"This is my first shader posted to Shadertoy, and I wasn't able to find any good swirly domain warping for anything on this website, so I figured I would post my approach here.\nSCENE AND PREVIEW FROM Inigo Quilez\nThe actual curl function is on line 83.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","swirl","curl","domainwarping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 10\n#define flowintensity 1.0\n#define numOctaves 2\n#define flowoffset 1.0\n\n\n// VALUE NOISE AND PREVIEW SCENE FROM : https://www.shadertoy.com/view/XsXfRH - Inigo Quilez\n\n// Computes the analytic derivatives of a 3D Value Noise. This can be used for example to compute normals to a\n// 3d rocks based on Value Noise without approximating the gradient by haveing to take central differences (see\n// this shader: https://www.shadertoy.com/view/XttSz2)\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\nvec4 noised( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+ivec3(0,0,0));\n    float b = hash(i+ivec3(1,0,0));\n    float c = hash(i+ivec3(0,1,0));\n    float d = hash(i+ivec3(1,1,0));\n    float e = hash(i+ivec3(0,0,1));\n\tfloat f = hash(i+ivec3(1,0,1));\n    float g = hash(i+ivec3(0,1,1));\n    float h = hash(i+ivec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n//MY LIL FUNCTION TO MAKE SWIRLY NOISE :)))\n//Subtract original position by the cross product of the noise derivative and the surface normal\n//More iterations is smoother\n\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    //Plug warped coordinates back into the fbm (or any other 3d function)\n    //AND BOOM, SWIRLS\n    //Remap from [-1, 1] to [0, 1] range\n    return (fbm(p).x + 1.0) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n    if( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        f = curl(pos * 10.f, normalize(nor));\n        \n        f *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n    \n    col = sqrt(col);\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}