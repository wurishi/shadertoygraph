{"ver":"0.1","info":{"id":"4dfcR7","date":"1487377737","viewed":560,"name":"Douglas Wheeler White Neon","username":"SalikSyed","description":"Nice little shader demonstrating that you can analytically solve for the total light from a line segment to a point. This cheats a little bit and assumes that the relationship is 1 / distance rather than 1/distance^2 ... but it still works and runs fast!","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["lightart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\n#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\n\n\nfloat integrate(vec2 start, vec2 end, vec2 pt) {\n    // start = start of segment, end = end of segment, point = point in space.\n    /* compute line segment to point light path integral... generated with\n \t\twolfram alpha ... good luck understanding this :) */\n\tfloat r = start.x;\n\tfloat s = end.x;\n\tfloat p = start.y;\n\tfloat q = end.y;\n\n\tfloat t = pt.x;\n\tfloat u = pt.y;\n\tfloat x = 1.0;\n\tfloat v1 = (log(sqrt(p*p - 2.0*p*q + q*q + (r - s)*(r - s)) * sqrt(p*p *x*x + 2.0* q * (x - 1.0)*(u - p*x) - 2.0*p*u*x + q*q*((x - 1.0)*(x - 1.0))+ r*r*x*x + 2.0*s*(x - 1.0)*(t - r*x) - 2.0*r*t*x + s*s*(x - 1.0)*(x - 1.0) + t*t + u*u) + p*p*x - 2.0*p*q*x + p*q - p*u + q*q*x - q*q + q*u + r*r*x - 2.0*r*s*x + r*s - r*t + s*s*x - s*s + s*t))/sqrt(p*p - 2.0*p*q + q*q + ((r - s)*(r - s)));\n\tx = 0.0;\n\tfloat v2 = (log(sqrt(p*p - 2.0*p*q + q*q + (r - s)*(r - s)) * sqrt(p*p *x*x + 2.0* q * (x - 1.0)*(u - p*x) - 2.0*p*u*x + q*q*((x - 1.0)*(x - 1.0))+ r*r*x*x + 2.0*s*(x - 1.0)*(t - r*x) - 2.0*r*t*x + s*s*(x - 1.0)*(x - 1.0) + t*t + u*u) + p*p*x - 2.0*p*q*x + p*q - p*u + q*q*x - q*q + q*u + r*r*x - 2.0*r*s*x + r*s - r*t + s*s*x - s*s + s*t))/sqrt(p*p - 2.0*p*q + q*q + ((r - s)*(r - s)));\n\treturn 1000.0*(v1 - v2);\n}\n\n\nfloat compute_light_from_segment(vec2 start, vec2 end, vec2 pt) {\n    return integrate(start, end, pt);\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    \n    vec2 outerMin = vec2(PADDING_X, PADDING_Y);\n    vec2 outerMax = vec2(250, 250);\n\n   \tfloat d = 0.0;\n    float sz = 1.3;\n    // compute the light contribution from each fluorescent segment\n    d += compute_light_from_segment(outerMin - vec2(sz, 0.0), vec2(outerMin.x, outerMax.y)  - vec2(sz, 0.0), pos);\n    d += compute_light_from_segment(vec2(outerMax.x, outerMin.y) + vec2(0.0, -sz), outerMin + vec2(0.0, -sz), pos);\n    d += compute_light_from_segment(vec2(outerMin.x, outerMax.y) + vec2(0.0, sz), outerMax+ vec2(0.0, sz), pos);\n    d += compute_light_from_segment(vec2(outerMax.x, outerMin.y)+ vec2(sz, 0.0), outerMax+ vec2(sz, 0.0), pos);\n\n    \n    vec4 mixColor =  vec4(111.0/255.0, 112.0/255.0, 106.0/255.0, 1.0);\n    if (pos.x > outerMin.x && pos.x < outerMax.x && pos.y > outerMin.y && pos.y < outerMax.y) {\n        mixColor = vec4(104.0/255.0, 109.0/255.0, 113.0/255.0, 1.0);\n    }\n    \n    vec4 mixColor2 = vec4(98.0/255.0, 94.0/255.0, 91.0/255.0, 1.0);\n    \n    float alpha = (sin(iTime) + 1.0) / 2.0;\n    \n    mixColor = alpha * mixColor + (1.0 - alpha) * mixColor2;\n    \n    fragColor = mix(max(0.04, 0.01*sin(iTime*0.2))* d * mixColor, mixColor, 0.4);\n}","name":"Image","description":"","type":"image"}]}