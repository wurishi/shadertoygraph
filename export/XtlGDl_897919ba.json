{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nmat2 rotate(in float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x * b.y - b.x * a.y;\n}\n\n// from https://www.shadertoy.com/view/XsX3zf\nfloat deBezier(in vec2 p, in vec2 b0, in vec2 b1, in vec2 b2) \n{\n  b0 -= p; b1 -= p; b2 -= p;\t\n  float a=Cross(b0,b2), b=2.0*Cross(b1,b0), d=2.0*Cross(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=Cross(d0p,d20), bp=2.0*Cross(d10,d0p);\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return length(mix(mix(b0,b1,t),mix(b1,b2,t),t));\n\n}\n\nfloat deStreamline(in vec2 p, in vec2 control, in vec2 offset, in float size)\n{\n    vec2 controlR = vec2(size + offset.x, 0.0);\n    vec2 controlL = vec2(-(size + offset.y), 0.0);\n    vec2 deltaR = controlR - control;\n    vec2 deltaL = controlL - control;\n    float t = 1.0 - 2.0 * offset.x / (controlR.x - control.x);\n    vec2 jointR = control + deltaR * t;\n    t = 1.0-2.0 * offset.y / (control.x - controlL.x);\n    vec2 jointL = control + deltaL * t;    \n    return min(min(min(\n        deBezier(p, jointR, controlR, jointR*vec2(1.0,-1.0)),\n    \tdeBezier(p, jointL, controlL, jointL*vec2(1.0,-1.0))),\n\t\tdeBezier(p, jointL, control, jointR)),\n    \tdeBezier(p, jointL * vec2(1.0, -1.0), control * vec2(1.0, -1.0), jointR * vec2(1.0, -1.0)));\n}\n\nfloat deExclamationMark(in vec3 p)\n{\n    // bounding box\n    vec3 bb = vec3(1.0, 3.2, 1.0);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    vec2 control = vec2(0.7, 0.7);\n    vec2 offset = vec2(0.2, 0.2);\n    float size = 1.55;\n    p.xz *= rotate(atan(p.z,p.x));\n    return min(deStreamline(0.8 * p.yx, control, offset, size), length(p - vec3(0.0,-2.7, 0.0)) - 0.3);\n}\n\nfloat deQuestionMark(in vec3 p)\n{\n    // bounding box\n    vec3 bb = vec3(1.5, 3.2, 0.4);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    vec2 v = vec2(0.0, -1.2);\n    vec2 h = vec2(0.0, 0.7);\n    vec2 a0 = v + h;\n    vec2 a1 = v * rotate(PI2 / 6.0) + h;\n    vec2 a2 = v * rotate(PI2 * 2.0 / 6.0) + h;\n    vec2 a3 = v * rotate(PI2 * 3.0 / 6.0) + h;\n    vec2 a4 = v * rotate(PI2 * 4.0 / 6.0) + h;\n    vec2 a5 = v * rotate(PI2 * 5.0 / 6.0) + h;\n    //vec2 b0 = a0 + 0.5 * (a1 - a0);\n    vec2 b1 = a1 + 0.5 * (a2 - a1);\n    vec2 b2 = a2 + 0.5 * (a3 - a2);\n    vec2 b3 = a3 + 0.5 * (a4 - a3);\n    vec2 b4 = a4 + 0.5 * (a5 - a4);\n    vec2 b5 = a5 + 0.5 * (a0 - a5);    \n    float de = 100.0;\n    //de = min(de, deBezier(p, b0, a1, b1));\n    de = min(de, deBezier(p.xy, b1, a2, b2));\n    de = min(de, deBezier(p.xy, b2, a3, b3));\n    de = min(de, deBezier(p.xy, b3, a4, b4));\n    de = min(de, deBezier(p.xy, b4, a5, b5));\n\tde = min(de, deBezier(p.xy, b5, a0, vec2(0.0,-1.8)));\n\treturn min(length(vec2(de,p.z))-0.3, length(p - vec3(0.0,-2.7, 0.0)) - 0.3);\n}\n\nfloat map(in vec3 p)\n{\n    p.x += 6.0;\n    p.y -= 0.4;\n    p.zx *= rotate(iTime * -0.5);\n    float s = 6.0;\n    float a = PI / s - atan(p.z, p.x);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p.zx *= rotate(a);\n    p.x -= 8.0 ;\n    return min(\n        deExclamationMark(p + vec3(1.2, 0.0, 0.0)),\n        deQuestionMark(p - vec3(1.2, 0.0, 0.0)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 20.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.15 + p.y * 0.2);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n   \t\tcol = vec3(0.8) * dif;\n    }\n   \tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtlGDl","date":"1426258307","viewed":218,"name":"3D !?","username":"gaz","description":"3d","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bezier","de"],"hasliked":0,"parentid":"","parentname":""}}