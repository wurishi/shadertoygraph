{"ver":"0.1","info":{"id":"sl3XWM","date":"1639208190","viewed":400,"name":"[TDF2021] Lightning Tunnel","username":"gam0022","description":"Shader showdown quarter-final at Tokyo Demo Fest 2021 coded in 25 minutes.\n\nhttps://twitter.com/gam0022/status/1469562828831195140","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","volume","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original Bonzomatic Shader\n// https://gist.github.com/gam0022/6332d497d886bdf9d3dbd714b88d852c\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n    if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvec4 map(vec3 p) {\n    vec3 pos = p;\n    p = mod(p, 1.) - 0.5;\n    vec4 m = vec4(1, 1, 1, 1);\n\n    float s = 1.;\n    for (int i = 0; i < 5; i++) {\n        p = abs(p) - 0.5;\n        rot(p.xy, -0.5);\n        p = abs(p) - 0.4 + 0. * cos(TAU * time / 4.);\n        rot(p.yz, -0.1);\n\n        float a = 1.4;\n        p *= a;\n        s *= a;\n    }\n\n    U(m, sdBox(p, vec3(0.5, 0.05, 0.05)) / s, 1., 1., 0.);\n    U(m, sdBox(p, vec3(0.5 + 0.5 * (cos(TAU * time / 4.)), 0.06, 0.05)) / s, 0., 0.1, 0.5);\n    U(m, sdBox(p, vec3(0.2, 0.6, 0.1)) / s, 0., saturate(cos(TAU * (time + pos.z / 8.))), -0.5);\n\n    return m;\n}\n\nvec3 fbm(vec3 p) { return sin(p) + sin(p * 2.) / 2. + sin(p * 4.) / 4.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec2 m;\n    m.x = atan(uv.x / uv.y) / 3.14;\n    m.y = 1. / length(uv) * .2;\n    float d = m.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 0, time);\n    vec3 ray = vec3(uv, 1.1 + cos(TAU * time / 8.));\n    ray += 0.1 * fbm(vec3(1, 2, 3) + TAU * time / 4.);\n    // rot(ray.xy, time);\n    // rot(ray.yz, time);\n    ray = normalize(ray);\n\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + ray * t;\n        vec4 m = map(p);\n        float d = m.x;\n        if (m.y == 1.) {\n            t += d;\n            if (d < 0.001) {\n                col += 0.005 * float(i);\n                break;\n            }\n        } else {\n            t += abs(d) * 0.5 + 0.01;\n            col += saturate(0.001 * vec3(1. + m.w, 1, 1. - m.w) * m.z / abs(d));\n        }\n    }\n\n    col = mix(vec3(0), col, exp(-0.7 * t));\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}