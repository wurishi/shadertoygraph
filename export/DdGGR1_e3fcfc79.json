{"ver":"0.1","info":{"id":"DdGGR1","date":"1678238281","viewed":158,"name":"Britney's on the TV","username":"ianertson","description":"Use the mouse to look around :)","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","ray","raymarch","tv","lights","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 40.\n#define STEPS 64\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_SOFA 3\n#define ID_SOFA_SEAT 4\n#define ID_SOFA_BACK 5\n#define ID_SOFA_PILLOW 6\n#define ID_TABLE 7\n#define ID_TV_TABLE 8\n#define ID_WALL 9\n#define ID_TV 10\n#define ID_FLOOR_LAMP 11\n#define ID_FLOOR_LAMP_BASE 12\n#define ID_FLOOR_LAMP_NECK 13\n#define ID_FLOOR_LAMP_HEAD 14\n\n\nfloat rand(in vec2 p, in float seed) {\n    vec2 p2 = (p-(seed*2.29283125))*2.0-1.0;\n    float r1 = fract(dot(p, p2)*3.2928312512);\n    return fract(sin(r1*6.282387812) * dot(p-p2, vec2(32.209328125, 44.92838195)));\n}\n\nvec3 noiseLod(in vec2 p, in float seed, in float lod) { return textureLod(iChannel3, (p+(seed*1.902823812))/256., lod).xyz; }\nvec3 noise(in vec2 p, in float seed) { return textureLod(iChannel3, (p+(seed*1.902823812))/256., 0.0).xyz; }\nvec3 snoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(noise(id, seed), noise(id + vec2(1, 0), seed), lv.x),\n        mix(noise(id + vec2(0, 1), seed), noise(id + vec2(1, 1), seed), lv.x),\n        lv.y);\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(noiseLod(id, seed, lod), noiseLod(id + vec2(1, 0), seed, lod), lv.x),\n        mix(noiseLod(id + vec2(0, 1), seed, lod), noiseLod(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y);\n}\n\nvec3 snoise(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float freq, in float lod, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * snoiseLod(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat pillowSDF(in vec3 p, in vec3 size) {\n    vec3 n = texNoise(iChannel3, p, 1.1, 3.39214, vec2(0.0));\n    \n    p.y *= (1.0+(n.y*0.5));\n    float d = boxSDF(p - vec3(0, size.y, 0), size);\n    \n    float rad = (size.x+size.y+size.z)/3.;\n    float sp = sphereSDF(p - vec3(0, rad, 0), rad);\n    \n    d = mix(d, sp, (n.x+n.y+n.z)/3.);\n\n    \n    return d;\n}\n\nfloat sofaSDF(in vec3 p, inout int id, inout int skip) {\n    id = ID_SOFA;\n    float dist = FAR;\n    float s = 0.1;\n    vec3 seatSize = vec3(2.0, 0.4, 0.9);\n    float seat = skip == ID_SOFA_SEAT ? FAR : boxSDF(p - vec3(0, seatSize.y, 0), seatSize) - s;\n    \n    vec3 backSize = vec3(2.0, 0.5, 0.16);\n    float back = skip == ID_SOFA_BACK ? FAR : boxSDF(p - vec3(0, seatSize.y + (backSize.y+0.59), seatSize.z-backSize.z), backSize) - s;\n    \n    vec3 pillowSize = vec3(0.5, 0.2, 0.5);\n    float pillow = pillowSDF(vec3(abs(p.x), p.y, p.z) - vec3(abs(seatSize.x-(pillowSize.x)), seatSize.y + 0.29 + s, -(0.2)), pillowSize);\n    \n    float bumpZ = (seatSize.z-backSize.z)*0.8;\n\n    \n    float bump = boxSDF(vec3(abs(p.x), p.y, p.z) - vec3(abs((seatSize.x)-seatSize.x/3.), seatSize.y+0.5, backSize.z-(bumpZ/2.)), vec3(seatSize.x/3.6, 0.01, bumpZ)); \n    float bumpCenter = boxSDF(p - vec3(0., seatSize.y+0.5, backSize.z-(bumpZ/2.)), vec3(seatSize.x/3.6, 0.01, bumpZ)); \n    bump = min(bump, bumpCenter);\n   \n    seat = smin(seat, bump, 0.2);\n    SAMPLE(seat, ID_SOFA_SEAT);\n    SAMPLE(back, ID_SOFA_BACK);\n   \n    SAMPLE(pillow, ID_SOFA_PILLOW);\n    \n    return dist;\n}\n\nfloat tableSDF(in vec3 p) {\n    float dist = FAR;\n    float scale = 1.;\n    float sx = 1.2 * scale;\n    float sz = 0.6 * scale;\n    float h = 1.0 * scale;\n    float boardT = 0.05 * scale;\n    \n    \n    float board = boxSDF(p - vec3(0, h, 0), vec3(sx, boardT, sz));\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-sx*0.9), 0.0, abs(-sz/2.)), vec3(0, 0, 0), vec3(0, h-(0.04*scale), 0), 0.1*scale);\n\n    dist = min(board, leg);\n    \n    return dist;\n}\n\nfloat tvTableSDF(in vec3 p) {\n    float dist = FAR;\n    float scale = 1.;\n    float sx = 1.9 * scale;\n    float sz = 0.6 * scale;\n    float h = 0.8 * scale;\n    float boardT = 0.05 * scale;\n    \n    \n    float board = boxSDF(p - vec3(0, h, 0), vec3(sx, boardT, sz));\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-sx*0.9), 0.0, abs(-sz/2.)), vec3(0, 0, 0), vec3(0, h-(0.04*scale), 0), 0.1*scale);\n\n    dist = min(board, leg);\n    \n    return dist;\n}\n\nfloat roomSDF(in vec3 p, inout int id, in int skip) {\n    id = ID_WALL;\n    \n    float width = 8.0;\n    \n    vec3 size = vec3(8.0);\n    float box = boxSDF(p, size);\n    float inside = boxSDF(p, size*0.9);\n    box = max(box, -inside);\n    \n    return box;\n}\n\nfloat tvSDF(in vec3 p) {\n    vec3 size = vec3(0.8, 0.8, 0.5);\n    float s = 0.05;\n    float f = smoothstep(1.2, 0.0, max(0.0, -p.z));\n    float body = boxSDF(p - vec3(0, size.y, 0), vec3(size.x, size.y*f, size.z)) - s;\n    float cavity = boxSDF(p - vec3(0, size.y, 0.5), vec3(size.x*0.8, (size.y*0.8), size.z*0.3));\n    body = smax(body, -cavity, 0.1);\n    return body;\n}\n\nfloat floorLampSDF(in vec3 p, inout int id, in int skip) {\n    float dist = FAR;\n    id = ID_FLOOR_LAMP;\n    float h = 2.6;\n    float base = cylSDF(p, vec3(0.0), vec3(0.0, 0.2, 0.0), 0.3);\n    float neck = cylSDF(p - vec3(0, 0.2, 0), vec3(0.0), vec3(0.0, h, 0.0), 0.05);\n    \n    float f = smoothstep(0.0, 0.9, length(p.xz)*max(0.0, -p.y+3.1));\n    float head = cylSDF(p - vec3(0, h, 0), vec3(0.0), vec3(0.0, 0.5, 0.0), 0.25+f);\n    \n    SAMPLE(base, ID_FLOOR_LAMP_BASE);\n    SAMPLE(neck, ID_FLOOR_LAMP_NECK);\n    SAMPLE(head, ID_FLOOR_LAMP_HEAD);\n    \n    return dist;\n}\n\n#define TV_POS vec3(0, 0.8, -4)\nfloat sdf(inout Data data, in vec3 p) {\n    data.id = ID_NONE;\n    int skip = data.skip;\n    int id = 0;\n    float dist = FAR;\n    \n    \n    float ground = groundSDF(p);\n   // float box = boxSDF(p - vec3(0, 0.5, 0), vec3(0.5));\n    int sofaId = 0;\n    float sofa = sofaSDF(p - vec3(0, 0, 2.6), sofaId, skip);\n    \n    float table = tableSDF(p);\n    float tvTable = tvTableSDF(p - vec3(0, 0, -4.));\n    float tv = tvSDF(p - TV_POS);\n    \n    int roomPart = 0;\n    float room = roomSDF(p, roomPart, skip);\n   \n    int lampId = 0;\n    float floorLamp = floorLampSDF(p - vec3(6., 0, -6.), lampId, skip);\n    \n    SAMPLE(floorLamp, lampId);\n    SAMPLE(tv, ID_TV);\n    SAMPLE(room, roomPart);\n    SAMPLE(ground, ID_GROUND);\n    //SAMPLE(box, ID_BOX);\n    SAMPLE(sofa, sofaId);\n    SAMPLE(table, ID_TABLE);\n    SAMPLE(tvTable, ID_TV_TABLE);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float d = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float r = 1.0;\n    float h = 1.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        \n        h = next;\n        r = min(r, h/0.5);\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(d) >= far) break;\n    }\n    return clamp((d/(1.0+d)), AMBIENT, 1.0);\n}\n\nfloat getAO(in vec3 p, in vec3 n){\n\tfloat o = 0.0;\n    float sc = 1.0;\n    Data data = NEW_DATA;\n    for(int i = ZERO; i < 6; i++) {\n        float h = 0.01 + 0.12*float(i)/4.0;float d = sdf(data, p + h*n);o += (h-d)*sc;\n        sc *= 0.94;if(o > 0.43) break;\n    }\n    return pow(clamp(1.0 - 1.0*o, 0.0, 1.0) * (0.8 + 0.2*n.y), 2.);\n}\n\nvec3 brickTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    const float tile = 4.0;\n    \n    float idy = floor(uv.y*tile);\n    \n    vec2 uuv = uv;\n    uuv.x += (idy/tile)/2.;\n    uuv *= tile;\n    \n    vec3 hf1 = snoise(uv, 0.398287185, 96., 2);\n    vec3 hf2 = snoise(uv, 1.93772812, 96., 2);\n    vec3 lf = snoise(uv, 3.333392211, 6., 6);\n    \n    \n    vec2 id = floor(uuv);\n    vec2 lv = fract(uuv);\n    vec2 alv = abs(lv*2.0-1.0);\n    float thick = mix(mix(0.01, 0.06, hf1.x*hf2.z), 0.07, lf.x*lf.x*lf.y);\n    float g = max(0.0, floor(max(alv.x, alv.y)+thick));\n    float ga = max(0.0, 1.0-ceil(min(lv.x, lv.y)-0.016));\n    \n    \n    vec3 idr1 = noise(id, 3.292189315);\n    vec3 idr2 = noise(id*4.293123, 0.028781234);\n    \n    vec3 b1 = rgb(132, 78, 68);\n    vec3 b2 = rgb(133, 65, 51);\n    vec3 b3 = rgb(176, 76, 43);\n    vec3 b4 = rgb(117, 65, 38);\n    \n    vec3 brickCol = mix(mix(mix(b1, b2, hf1.x), b3, hf1.y), b4, hf1.z);\n    brickCol = mix(mix(mix(b4, b3, idr1.x), b2, idr1.y), b1, idr1.z);\n    brickCol = mix(brickCol, brickCol*brickCol, idr2.x);\n    col += brickCol;\n    \n    vec3 w1 = rgb(138, 131, 116);\n    vec3 w2 = rgb(201, 195, 178);\n    vec3 w3 = rgb(169, 147, 125);\n    vec3 w4 = rgb(94, 83, 77);\n    \n    vec3 sepCol = mix(mix(mix(w1, w2, hf2.x), w3, hf2.y), w4, hf2.z);\n    \n    col = mix(col, sepCol, g);\n    \n    col = mix(col, col*col, lf.x*lf.x);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    col = mix(col, col*col, mix(grain.x*idr1.z, grain.y*idr2.z*lf.y, lf.z));\n    col = mix(col, col*col, ga);\n    \n    m.spec = clamp(g*hf2.y, grain.z*grain.x*0.5, 1.0);\n    \n    return col;\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 2.3339281, 60., 4);\n    vec3 lf1 = snoise(uv, 0.9288737, 20., 4);\n    float grain = textureLod(iChannel3, uv/2., 0.0).r;\n    \n    vec3 w1 = rgb(133, 107, 82);\n    vec3 w2 = rgb(143, 110, 78);\n    vec3 w3 = rgb(99, 58, 36);\n    vec3 w4 = rgb(171, 102, 61);\n    \n    vec3 woodCol = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += woodCol;\n    \n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 lvs = lv*lv*(3.0-2.0*lv);\n    vec2 lvc = lv*2.0-1.0;\n    vec2 alv = abs(lvc);\n    \n    const float seed = 3.3928195;\n    float idr = mix(mix(rand(id, seed), rand(id+vec2(1, 0), seed), lvs.x),\n                mix(rand(id+vec2(0, 1), seed), rand(id+vec2(1, 1), seed), lvs.x), lvs.y);\n    \n    \n\n    \n    float ra = max(0.0, 0.4 + 0.2*((0.5-idr)*0.5));\n    float fe = ra*(0.9*mix(1.0, 0.5, idr*idr*idr*0.7));\n    lvc += vec2(cos(idr*6.), sin(idr*6.))*0.5*idr;\n    col = mix(col, mix(col*col, col*idr, idr), smoothstep(0.6-0.3, 0.6+0.3, idr) * max(0.0, 1.0-smoothstep(ra-fe, ra+fe, length(lvc))));\n    \n    \n    \n    float s = pow(exp((cos((idr*idr*idr*(9.21223*(0.5+length(lvc))))*(lvc.x-((0.1+(idr*2.))*\n        sin((lvc.y-sin(lvc.x*M_PI*(0.5+(idr))))*M_PI)))*TAU)) - 1.), 3.0);\n    \n    col = mix(col, mix(w3, w4, hf1.x*lf1.z)*col, clamp(s*lf1.x*hf1.z*2., 0.0, 1.0));\n    col = mix(col, col*col, grain*grain);\n    \n    m.spec = clamp(s*s*grain, grain*lf1.x, 1.0);\n    \n    return col;\n}\n\nvec3 woodTexture2(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(176, 142, 115);\n    vec3 c2 = rgb(74, 48, 42);\n    vec3 c3 = rgb(195, 135, 90);\n    vec3 c4 = rgb(86, 51, 29);\n    \n    vec3 alt = snoiseLod(uv, 8.83159, 190., 0.5, 6);\n    vec3 lf = snoiseLod(uv, 2.223221, 2., 0.5, 6);\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    float k = smoothstep(0.4, 0.5, lf.x);\n    \n    float lines = ((alt.z+alt.x+alt.y)/3.)*cos(((lf.z+uv.x+alt.y)-sin(uv.y*(TAU+lf.x)))*(TAU)+cos((uv.x-uv.y)*(TAU)));\n    lines = pow(max(0.0, 0.7*(1.0-abs(lines))), 3.0);\n    \n    col = mix(col, c2*c2*c2, lines*alt.y);\n    col = mix(col, c4, clamp(0.1*fract(10.38921*(tan(lines*6.831)+cos(alt.x+alt.y+alt.z*lf.x))), 0.0, 1.0));\n    col += luma(col);\n    col = col*col*col*col;\n    m.spec = clamp(lines*(alt.x+k), alt.z*lf.z, 1.0);\n    \n\n    return col;\n}\n\nvec3 rustyMetalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(141, 142, 137);\n    vec3 c2 = rgb(166, 154, 142);\n    vec3 c3 = rgb(105, 103, 102);\n    \n    vec3 hf = snoise(uv, 0.3282815, 48., 2);\n    vec3 hf2 = snoise(uv, 1.223214, 48., 2);\n    vec3 hf3 = normalize(abs(cross(hf*2.0-1.0, hf2*2.0-1.0)));\n    vec3 reg = snoise(uv, 0.938216, 3.2, 6);\n    vec3 hf4 = normalize(abs(reflect(cross(reg, hf3), hf2)));\n    \n    vec3 bg = mix(mix(c1, c2, hf.x), c3, hf.y);\n    col += bg;\n    \n    vec3 rust1 = rgb(165, 138, 61);\n    vec3 rust2 = rgb(136, 86, 28);\n    vec3 rust3 = rgb(115, 84, 49);\n    \n    vec3 fg = mix(mix(rust1, rust2, hf2.x), rust3, hf2.y);\n    \n    float rustReg = clamp(pow((reg.x+hf3.y)/1.2, 4.0)*pow(reg.y, 4.)*4., 0.0, 1.0);\n    \n    col = mix(col, fg, rustReg);\n    \n    float cracks = abs((hf3.z*reg.z)-(hf.z*reg.y));\n    cracks = smoothstep(0.02+(hf4.y*0.2), (0.1+(hf4.z*0.2)), cracks);\n    cracks = pow(cracks, 4.0)*reg.z*reg.z;\n    col = mix(col, c2, clamp(cracks*2., 0.0, 1.0));\n    \n    m.spec = clamp(((1.0-rustReg)+(0.2*cracks)), 0.2, 1.0);\n    m.rough = clamp((rustReg+cracks)/2., 0.2, 0.8);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE fabricTexture\nvec3 fabricTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 lf = snoise(uv, 3.3929124, 1.5, 3);\n    vec3 hf = snoise(uv, 9.3236663, 32.0, 6);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    float tile = 8.0 * (lf.y*8.);\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    vec2 lv2 = fract(uv*64.);\n    float grid = max(0.0, 1.0 - ceil(min(lv2.x, lv2.y)-0.3));\n    \n    float checker = clamp(mod((id.x-id.y)+hf.x-lf.y, 2.), 0.0, 1.0);\n    col += checker;\n    \n    vec3 c1 = rgb(129, 114, 109);\n    vec3 c2 = rgb(66, 53, 45);\n    vec3 c3 = rgb(98, 98, 98);\n    vec3 c4 = rgb(158, 129, 104);\n    \n    vec3 baseCol = mix(mix(mix(c1, c2, hf.x), c3, hf.y), c4, hf.z);\n    \n    vec3 baseCol2 = mix(baseCol, baseCol*baseCol, checker);\n    col = baseCol2;\n    col = mix(col, col*col, grain.x);\n    col = mix(col, baseCol, clamp(0.4+grain.x,0.0, 1.0));\n    float gridM = grid*lf.x*lf.y;\n    col = mix(col, vec3(hf.x), gridM);\n    \n    m.spec = clamp(gridM, 0.0, 1.0);\n    \n    return col;\n}\n\n\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = woodTexture2(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoTV(inout Data data) {\n    vec3 col = vec3(0.77);\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    float lum = clamp(dot(n, vec3(0, 0, 1)), 0.0, 1.0);\n    \n   // ;\n    vec2 uvFront = p.xy;\n    uvFront -= vec3(0, 0.8, -4).xy;\n    uvFront.x = 0.5 - uvFront.x;\n    uvFront.y /= 1.5;\n    if (p.x > -0.649 && p.x < 0.649 && p.y > 1. && p.y < 2.2) {\n    //vec3 grain = textureLod(iChannel3, uvFront, 0.0).xyz;\n    \n    vec3 video = textureLod(iChannel2, uvFront, 0.).xyz*8.;\n    col = mix(col, video, lum);\n   \n    } else {\n        col = rustyMetalTexture(uv*0.5, p, data.m);\n    }\n    \n    data.m.lum = lum*smoothstep(-0.2, 1.0, max(0.0, -p.x+0.68))*smoothstep(-0.2, 1.0, max(0.0, p.x+0.68))\n        *smoothstep(-0.2, 1.0, max(0.0, p.y-1.)) *smoothstep(-0.2, 1.0, max(0.0, -p.y+2.2));\n    \n    return col;\n}\n\nvec3 getAlbedoRoom(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 col = vec3(0.0);\n    \n    if (n.y < 0. && p.y > 1.) {\n        col = woodTexture2(uv*0.5, p, data.m);\n    } else {\n        col = brickTexture(uv, p, data.m);\n    }\n    return col;\n}\n\nvec3 getAlbedoTable(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = woodTexture(uv*2., p, data.m);\n    return col;\n}\n\nvec3 getAlbedoFloorLampHead(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = texture(iChannel0, uv*0.7).rgb;\n    return col;\n}\n\nvec3 getAlbedoFloorLampBase(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = rustyMetalTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoFloorLampNeck(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = rustyMetalTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoSofaPillow(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = texture(iChannel0, uv*0.7).rgb;\n    data.m.spec = 0.0;\n    return col;\n}\n\nvec3 getAlbedoSofa(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = fabricTexture(uv*0.25, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_TV: return getAlbedoTV(data); break;\n        case ID_WALL: return getAlbedoRoom(data); break;\n        case ID_TABLE: return getAlbedoTable(data); break;\n        case ID_TV_TABLE: return getAlbedoTable(data); break;\n        case ID_FLOOR_LAMP_HEAD: return getAlbedoFloorLampHead(data); break;\n        case ID_FLOOR_LAMP_BASE: return getAlbedoFloorLampBase(data); break;\n        case ID_FLOOR_LAMP_NECK: return getAlbedoFloorLampNeck(data); break;\n        case ID_SOFA_PILLOW: return getAlbedoSofaPillow(data); break;\n        case ID_SOFA: return getAlbedoSofa(data); break;\n        case ID_SOFA_SEAT: return getAlbedoSofa(data); break;\n        case ID_SOFA_BACK: return getAlbedoSofa(data); break;\n        \n    }\n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 L2 = normalize(light.p - p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float NdotL = cdot(n, L2);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = NdotL > 0.00001 ? getShadow(data.id, p+(n*NEAR*2.0), L, data.d, light.type == LIGHT_AMBIENT ? FAR : distance(\n        light.p,\n        p\n    )) : 1.0;\n    shadow = max(shadow, data.m.lum);\n    att += data.m.lum;\n    \n    //float ao = getAO(p+(n*NEAR*2.), n);\n    //ao = max(ao, max(AMBIENT+0.2, data.m.lum));\n    \n    return (diffuse + spec) * att * shadow;// * ao;\n}\n\n#define NUM_LIGHTS 2\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 video1 = textureLod(iChannel2, vec2(0.0), 8.).xyz;\n    vec3 video2 = textureLod(iChannel2, vec2(0.5), 8.).xyz;\n    vec3 video3 = textureLod(iChannel2, vec2(1.), 8.).xyz;\n    vec3 video = (video1 + video2 + video3)/3.;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(6., 2.67, -6.), vec3(0.0), vec3(0.97, 0.71, 0.69), 3.0, LIGHT_POINT);\n    lights[1] = Light(vec3(0, 1.5, -3.5), vec3(0.0, 0.0, -1.), video, 4.0, LIGHT_DIR);\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd, diffuse);\n        }\n    }\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -7.);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (length(m.xy) > 0.001 && m.z > 0.001) {\n       ro.yz *= rot(m.y*TAU);\n       ro.xz *= rot(m.x*TAU);\n        \n       rd.yz *= rot(m.y*TAU);\n       rd.xz *= rot(m.x*TAU);\n    } else {\n       ro = vec3(cos(T)*6., 1.5, 4.);\n       rd = look(uv, TV_POS, ro);    \n    }\n    \n    ro.y += 1.;\n    ro.y = clamp(ro.y, 1.0, 6.0);\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col /= 1.0 + max(col - 0.4, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n#define AMBIENT 0.07\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n    float lum;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) : \n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n        normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, \n            pow(distance(light.p, p), 2.0))); break;\n        case LIGHT_DIR: {\n            vec3 L2 = normalize(light.p - p);\n            vec3 H = normalize(L + L2);\n            float NdotL2 = max(AMBIENT, dot(n, H));\n            return light.c * NdotL2 * light.s * \n            max((smoothstep(0.8, 1.0, dot(L2, L) ) + \n                (smoothstep(1.5, 0.0, distance(light.p, p)))\n             ), AMBIENT*0.25);\n        }\n        break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.xz, round(adot(n, vec3(0, 1, 0)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n","name":"Common","description":"","type":"common"}]}