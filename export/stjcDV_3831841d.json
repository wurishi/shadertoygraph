{"ver":"0.1","info":{"id":"stjcDV","date":"1650294365","viewed":130,"name":"Construction of a Torus fractal","username":"Amirk","description":"This is a second version of the fractal torus shader. Here the building process is animated.\nYou could iterate the process indefinitely.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch","torus"],"hasliked":0,"parentid":"NtBcDV","parentname":"Torus fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 100.\n#define MAX_DIST 100.\n#define SURF 0.01\n#define PI 3.1416\n\nvec3 col; \nfloat td=0.; //torus distance\nfloat time=0.;\n\nmat2 Rot(float a){\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\n\n\nfloat sdTorus(vec3 p, float r1,float r2){\n//p.xy*=Rot(-iTime*.3);\nfloat px= length(p.xz)-r1;\n\nreturn length(vec2(px,p.y))-r2;\n}\n\n\n\n\nfloat sdRhombic(vec3 p){\n  float c=cos(3.1415/5.);\n  float s= sqrt(0.75-c*c);\n  vec3 n= vec3(-.5,-c,s);\n  p=abs(p);\n  \n  p-=2.*min(0.,dot(p,n))*n;\n\n  p.xy=abs(p.xy);\n  p-=2.*min(0.,dot(p,n))*n;\n  \n  p.xy=abs(p.xy);\n  p-=2.*min(0.,dot(p,n))*n;\n  \n  float d=p.z-1.;\n  \n  return d;\n}\n\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\nfloat level1(vec3 p){\n //p.xy*=Rot(iTime*.1);\n\n float d=100.;\n  float a= 2.*PI/6.;\n  for(int i=0; i<6;i++){\n    td=sdTorus(p-vec3(1.2,0,0),.6,.3);\n    d=min(d,td);\n    p.xy*=Rot(a);\n  }\n  p.yz*=Rot(PI/2.);\n  d= mix(d, sdTorus(p, 1.2,.9),smoothstep(11.,9.,time));\n  return d;\n}\n\nfloat level2(vec3 p){\n //p.yz*=Rot(iTime*.05);\n\n float d=100.;\n  float a= 2.*PI/6.;\n  for(int i=0; i<6;i++){\n    td=level1(p-vec3(0,3.,0));\n    d=min(d,td);\n    p.yz*=Rot(a);\n  }\n  p.xy*=Rot(PI/2.);\n  d= mix(d, sdTorus(p, 3.,2.1),smoothstep(7.,5.,time)); \n  return d;\n}\n\nfloat getDist(vec3 p){\n //p.xz*=Rot(iTime*0.02);\n\n float d=100.;\n  float a= 2.*PI/6.;\n  for(int i=0; i<6;i++){\n    td=level2(p-vec3(0,0,8));\n    d=min(d,td);\n    p.xz*=Rot(a);\n  }\n  p.xz*=Rot(PI/2.);\n  d= mix(d, sdTorus(p, 8.,5.1),smoothstep(3.,1.,time)); \n  return d;\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\nfloat dO=0.;\nfloat i=0.;\nwhile(i<MAX_ITER){\n  vec3 p= ro+dO*rd;\n  float dS=getDist(p);\n\n  dO+=dS;\n  \n  if(dO>MAX_DIST||dS<SURF) break;\n  \n  i++;\n}\n\nfloat halo= pow(5.*i/MAX_ITER,2.);\ncol+=vec3(halo)*vec3(0.3,0.1,1);\n\nreturn dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\n\nvec3 getLight(vec3 p, vec3 lightPos){\n\nlightPos.xz+=2.*vec2(cos(iTime),sin(iTime));\nvec3 l= normalize(vec3(1,2,3));\nvec3 n= getNormal(p);\n\nfloat dif=0.;\n\ndif =dot(l, n)*.5+.5;\n\nreturn dif*n*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n    col =vec3(0);\n    time= 12.-abs(fract(iTime/24.)*24.-12.);\n    \n    \n    //camera: \n    float zoom= .9;\n    vec3 ro= vec3(0,16,-16);\n    \n    ro.yz*=Rot(-m.y*3.14);\n    ro.xz*=Rot(-m.x*3.14);\n    \n    vec3 lookAt=vec3(0,0,0);\n    \n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n\n    float d= RayMarch(ro,rd);\n\n    vec3 lightPos= vec3(0,7,5);\n\n\n    if(d<MAX_DIST) col+= getLight(ro+d*rd, lightPos);\n\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}