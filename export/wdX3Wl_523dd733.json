{"ver":"0.1","info":{"id":"wdX3Wl","date":"1547765126","viewed":213,"name":"[TWITCH] Amaterasu inspiration","username":"Flopine","description":"Result from 2 twitch sessions, each of 1 hour and a half. \nHeavily inspired by the masterpiece game Okami :D ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","toonshading","twitch","okami"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n#define time iTime\n#define EPS 0.01\n\n#define MAT_SHIELD 0.\n#define MAT_BACK 1.\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  a = mod (a-per/2., per)-per/2.;\n  return vec2(cos(a),sin(a))*l; \n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n  if (a.x < b.x) return a;\n  else return b;\n}\n\n\nfloat spiral (vec2 p, float sa, float b)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n\n  float n = (log(l/sa)/b - a) / (2.*PI);\n\n  float upper_ray = sa * exp(b *(a + 2.*PI*ceil(n)));\n  float lower_ray = sa * exp(b *(a + 2.*PI*floor(n)));\n\n  return min(abs(upper_ray - l), abs(l-lower_ray));\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\n\nfloat roots (vec3 p)\n{\n  p.x += sin(p.z)*0.3;\n  p.xz = moda(p.xz, 2.*PI/7.);\n  p.x -= 3.;\n  p.y += sin(p.x)*0.5;\n  return cyl(p.yzx, 0.2-p.x*0.2, 2.);\n}\n\n\nfloat base (vec3 p)\n{\n  p.xy -= vec2(0.8,2.5);\n  p.x -= sin(p.y)*0.7;\n  return cyl(p.xzy, 1.08-p.y*0.2, 2.);\n}\n\n\nfloat bud (vec3 p)\n{\n  float s = length(p)-2.35;\n  p.x = spiral(p.xy, PI/5., .3);\n  float d = cyl (p.xzy, 0.4-p.y*0.15, 1.5);\n  d = max(s, d);\n  return d;\n}\n\n\nfloat island (vec3 p)\n{\n  p.y += 2.5;\n  float s = length(vec3(p.x*0.5, p.y+2.7, p.z*0.5))-5.;\n  return s;\n}\n\n\nfloat pic (vec3 p)\n{\n  p.x += 0.7;\n  p.x += sin(p.y*0.5);\n  float c3 = cyl(vec3(p.x*2., p.z, p.y), 0.5-p.y*0.5, 1.5);\n  return c3;\n}\n\n\nfloat pics (vec3 p)\n{\n  p.yz = moda(p.yz, 2.*PI/8.);\n  p.y -= 6.;\n  return min(cyl(vec3(p.x, p.z, p.y+3.), 0.3, 2.),pic(p));\n}\n\n\nfloat rings (vec3 p)\n{  \n  float c1 = cyl(p.yzx, 2.5, 0.1);\n  float c2 = max(-cyl(p.yzx, 3.5,1.), cyl(p.yzx, 4., 0.05));\n  return min (c1, c2);\n}\n\n\nfloat top_shield (vec3 p)\n{\n  p.xy *= rot(-PI/2.);\n  float s = max(-p.y,length(p)-1.8);\n  p.xz = moda(p.xz, PI/2.);\n  float c = cyl(vec3(p.y-1., p.z, p.x), 0.5, 5.);\n  return max(-c, s);\n}\n\n\nvec2 shield (vec3 p)\n{\n  float t1 = floor(time);\n  float t2 = fract(time);\n\n  t2 = pow(t2, 4.);\n  float anim1 = PI/5.*(t1+ t2);\n  float anim2 = floor(time)+sin(fract(time)*PI/2.);\n\n  float anim = mix(anim1, anim2, 0.2);\n  p.yz *= rot(anim);\n  return vec2(min(min(rings(p), pics(p)),top_shield(p)), MAT_SHIELD);\n\n}\n\n\nvec2 background (vec3 p)\n{\n  float tree = smin(bud(vec3(p.x-2.85, p.y-5.9, p.z+0.1)),smin(roots(p),base(p), 0.5), 0.1);\n  return vec2(min(island(p), tree), MAT_BACK);\n}\n\n\nvec2 SDF (vec3 p)\n{\n  vec2 b = background(p);\n  p += vec3(3.,-4., 5.);\n  return mat_min(shield(p/0.5)*0.5, b);\n}\n\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.1,0.);\n  return normalize(vec3(SDF(p+eps.xyy).x - SDF(p - eps.xyy).x,\n                        SDF(p+eps.yxy).x - SDF(p - eps.yxy).x,\n                        SDF(p+eps.yyx).x - SDF(p - eps.yyx).x\n                        )\n                   );\n}\n\n\nfloat lighting(vec3 p)\n{\n  vec3 n = getnorm(p);\n  return dot(n, normalize(vec3(2.,10., -3.)))*0.5+0.5;\n}\n\n\nvec3 color_ramp(float t)\n{\n  float sm = smoothstep(0., 0.5, t);\n  float sm2 = smoothstep(0.5, .8, t);\n  vec3 col1 = mix(vec3(0.8, 0., 0.7), vec3(0.9,0.2,0.), sm);\n  return mix(col1,vec3(0.9,0.8,0.), sm2);\n}\n\n\nvec3 getcam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target - ro);\n  vec3 right = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3 up = normalize(cross(forward, right));\n  return forward * fov + right * uv.x + up * uv.y;\n}\n\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(time*.3);\n  return vec3(0.8,0.1,0.)+floor(cos(atan(uv.y, uv.x)*12.));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(10.,5.,-10.0); \n  vec3 p = ro;\n  vec3 target = vec3(-2.5, 3., 0.);\n  vec3 rd = getcam(ro, target, uv, 1.);\n    \n  vec3 col = vec3(0.);\n  float shad, pd, t=0., tmax=50.;\n  vec2 d = vec2(0.);\n  float outline = 1.;\n\n  for(float i = 0.; i<ITER; i++)\n  {\n    pd = d.x;\n    d = SDF(p);\n  // Tricks from lnae : https://www.shadertoy.com/view/4tdyRj\n  if (d.x > pd + EPS && d.x < 0.14) outline = 0.;\n\n  if (d.x < EPS || t > tmax) break;\n    t+=d.x*0.4;\n    p = ro + rd * t;\n  }\n\n  if (t<=tmax)\n  {\n    if(d.y == MAT_BACK) col = mix(vec3(0.4,0.1,0.), vec3(0.9,0.8,0.8), lighting(p));\n    if (d.y == MAT_SHIELD) col = color_ramp(lighting(p));\n  }\n  else col = vec3(0.8) + pales(uv-vec2(0.8))*(1.-length(uv))*0.4;\n\n  col *= outline;\n  col += texture(iChannel0, uv*0.5).rgb * 0.1;\n\n  fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}