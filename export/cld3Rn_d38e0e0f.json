{"ver":"0.1","info":{"id":"cld3Rn","date":"1681871119","viewed":83,"name":"Christmas Bubbles","username":"cerebral_m","description":"A friend sent me his ray-sphere-intersection test and immediately I felt inspired to finish off the shading, taking it in the direction of several classic POV-ray renders that I remember being inspired by in my childhood.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"mlc3Rr","parentname":"ray sphere intersection3754struc"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SPHERE_RADIUS 1.75    // size of spheres\n#define SPHERE_COUNT 30       // number of spheres\n#define REFLECTIONS 6         // number of reflections, expensive\n#define FILL_LIGHTS 5.        // number of fill lights, expensive\n#define BIAS 0.001            // don't remember if this gets used\n#define COLOUR_OFFSET 68.     // colour pallete\n#define SOFT_STEPS 80         // sphere-marching steps for soft shadows\n#define SHADOW_SHARPNESS 13.  // hardness of soft shadows\n#define SHADOW_QUALITY 5      // 2 or higher=soft shadows, 1=hard shadows only on first bounce, 0=none\n#define FILL_SHADOWBIAS 3     // reduce shadow quality for the more numerous fill lights\n#define AO_RADIUS 0.45        // AO radius\n#define AO_POWER 0.3          // AO flatness\n#define AO_GAIN 0.03          // AO de-buttcrack-ifier\n#define SKY_GAIN 0.75         // brightness of sky, and therefore also \"ambient\" contribution\n\n// define materials\nvec3 colourOfID (int ID)\n{ return pow(hash31(float(ID)*235.+COLOUR_OFFSET),vec3(.25))*vec3(0.85)+vec3(0.1); }\n\n\n// for tracing a ray\nstruct RayToTrace\n{\n    // ray parameters    \n    vec3 origin;\n    vec3 direction;\n    \n    float dist; // how far is ray allowed to travel/how far did it travel?\n    \n    int emitter; // object ID of emitting surface, to ignore\n};\n\n// for returning from raytracing\nstruct RayHit\n{\n    vec3 pos; // location of hitpoint\n    int ID; // material ID of surface ray hit (-1 if nothing)\n    vec3 normal; // normal of surface ray hit\n};\n\n\n// given a ray origin, ray direction, and sphere position\n// return distance along ray to nearest (first?) hitpoint on sphere\nfloat sphere(vec3 ro, vec3 rd, vec3 s, float r)\n{\n    vec3 tos = s-ro;\n    float t = dot(rd,tos);\n    vec3 p = ro + rd*t;\n    float y = length(s-p);\n    \n    if(y < r)\n    {\n        float x = sqrt(r*r-y*y);\n        return t-x;\n        \n    } else return 1000.;\n}\n\n// get sphere position from the cache\nvec3 SpherePos(int i)\n{\n    vec3 rand =  hash31(float(i));            \n    return sin(rand*6.1+iTime*.15)*3.5;\n}\n\n// trace rays through spheres, return hit information\nRayHit SphereIntersection(RayToTrace rayIn)\n{\n    RayHit hit;\n    hit.normal = rayIn.direction; // probably don't need this, just initiliazing it with something\n    hit.pos = rayIn.origin+rayIn.direction * rayIn.dist; // sky hitpoint\n    hit.ID = -1; // sky ID\n    \n    //test against each sphere\n    for(int i = 1; i<= SPHERE_COUNT;i++)\n    {\n        if(i == rayIn.emitter) // no self reflection (we prefer unhealthy coping mechanisms)\n            continue;\n    \n        //random animated position for each sphere\n        vec3 pos = SpherePos(i);\n        \n        \n        float dist2hit = sphere(rayIn.origin, rayIn.direction, pos, SPHERE_RADIUS);\n        \n        //if hitpoint is closer then limit (or closest hit point), update hitpoint data\n        if(dist2hit < rayIn.dist && dist2hit > 0.)\n        {\n            rayIn.dist = dist2hit;\n            hit.pos = rayIn.origin+rayIn.direction*dist2hit;//calculate hitpoint\n            hit.ID = i;\n            hit.normal = normalize(hit.pos-pos);\n        }       \n    }\n   \n    return hit;\n}\n\n\n// cone tracing, for soft shadows\nfloat ConeTrace(vec3 pos, vec3 dir, bool isFill)\n{\n    float gain = 1.;\n\n    float dist = 0.005; // launching bias, for saving time\n\n    int iterations = SOFT_STEPS; // less marching steps for fill lights\n    if(isFill)\n        iterations /= 4;\n\n\n    for(int j = 0; j<iterations; j++) //sphere marching, because of course it is\n    {\n        float d = 999.;\n        for(int i = 1; i<= SPHERE_COUNT;i++) //iterate over all ... spheres, get dist to nearest surface\n        {\n            vec3 spos = SpherePos(i);\n            float sd = length(pos+(dir*dist)-spos);\n            sd -= SPHERE_RADIUS;\n        \n            if(sd < d)\n                d = sd;\n        }\n        \n        // minimum ratio between step size and distance flown represents the narrowest cone\n        gain = min(gain, d/dist*SHADOW_SHARPNESS);\n    \n        dist += d;\n        \n        if(d<0.0001 || dist>20.) // save performance on hits or breakaways\n            break;\n    }\n    \n    return max(gain,0.);\n}\n\n\n\n\n\n// AO\nfloat SphereOcclusion(vec3 pos, int emitter)\n{\n    float AO = 1.;\n    //accumulate AO influence from each sphere\n    for(int i = 1; i<= SPHERE_COUNT;i++)\n    {\n        if(i == emitter) // no self occlusion\n            continue;\n    \n        vec3 spos = SpherePos(i);\n        \n        float d = length(pos-spos);\n        d -= SPHERE_RADIUS;\n        d /= AO_RADIUS;\n        d = clamp(d,0.,1.);\n        \n        AO = min(AO, d);\n    }\n    \n    return pow(AO,.6);\n}\n\n\n\n\n\n\n// given surface point, normal, and light location, return light\n// light quality is white inverse-square N*L light\n// phong term\n// and with shadows\n\nfloat doALight(vec3 p, vec3 normal , vec3 l, vec3 view, int ID, int shadowQuality, bool isFill)\n{\n    vec3 toLight = l-p;\n\n    vec3 lv = normalize(toLight); // light direction\n    float ld = length(toLight); // light distance\n    \n    float bias = 0.2; // (bias to prevent the soft shadows from artifacting)\n    \n    float light = max(dot(lv,normal)-bias,0.); // N*L term\n                           \n    view = reflect(view, normal); // do phong\n    float phong = max(dot(view,lv),0.1); // simple reflect*L highlight for the OGs\n    phong = pow(phong, 160.); // raise to power to make the highlight sharper\n    light += phong * 1.6; // apply phong\n      \n    \n    \n    light /= pow(ld, 2.0); // inverse-square term\n      \n    \n    \n    // shadow term\n    \n    // hard shadows\n    if(shadowQuality == 1)\n    {\n        // prepare ray from position to light location\n        RayToTrace ray;\n        ray.direction = lv;\n        ray.origin = p;\n        ray.dist = ld;\n        ray.emitter = ID; // don't self-shadow\n    \n        // apply switch light off if ray hits anything other then the sky\n        if(SphereIntersection(ray).ID != -1)\n            light = 0.;      \n    }\n    \n    // soft shadows\n    if(shadowQuality > 1)\n        light *= ConeTrace(p,lv,isFill);\n    \n    \n    return light;\n}\n\n\n\n\n\n// do all the lights, don't self shadow (use ID to ignore shaded sphere)\n// use shadowQuality to limit soft shadows to direct visibility, not reflections\nvec3 getLighting(vec3 p, vec3 normal, vec3 view, int ID, int iteration)\n{\n    vec3 light = vec3(0.);\n    \n    \n    // main orbiting light, casting the main shadows\n    vec3 pos = vec3(vec2(cos(iTime),sin(iTime))*20., -3);\n    int sq = SHADOW_QUALITY - iteration;\n    light += vec3(doALight(p, normal, pos, view, ID, SHADOW_QUALITY-iteration, false))*600.;\n    \n    \n    // fill light shadow quality, NO soft fill lights after first bounce\n    sq = SHADOW_QUALITY - iteration - FILL_SHADOWBIAS;\n    if(iteration > 0 && sq > 1)\n        sq = 1;\n        \n    // fill lights, arranged in a circle around the camera\n    for(float i = 0.; i<6.283185307; i+=6.283185307/FILL_LIGHTS)\n    {\n        pos = vec3(vec2(sin(i+iTime/5.),cos(i+iTime/5.))*7.,-9.);\n                        \n        float fillLight = doALight(p, normal, pos, view, ID, sq, true);\n        fillLight = fillLight/FILL_LIGHTS*180.; // gain\n        \n        // give each fill light a random colour :)\n        light += fillLight * pow(colourOfID(int(i*100.)),vec3(4.));\n    }\n    \n    return light;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    // initialize ray package\n    RayToTrace ray;\n    ray.origin = vec3(0.,0.,-10.);\n    ray.direction = normalize(vec3(uv,3.));\n    ray.dist = 999.;\n    ray.emitter = -1;\n        \n    \n    vec3 pathColour = vec3(1.);    // transmissibility of the whole path so far\n    vec3 pixelColour = vec3(0.0);  // accumulated light reaching the pixel so far\n    \n    \n    \n    // info about the first bounce\n    vec3 screenPos;\n    int screenID;\n    \n    \n    \n    \n    // bounce loop\n    for(int i = 0;i<REFLECTIONS  ;i++)\n    {\n        // trace ray through spheres :eyes:\n        RayHit hit = SphereIntersection(ray);\n  \n        // record results of first hit only\n        if(i == 0)\n        {\n            screenPos = hit.pos;\n            screenID = hit.ID;\n        }\n  \n        // stop if hit sky\n        if(hit.ID == -1)\n            break;\n        \n        // get material\n        vec3 surfaceColour = colourOfID(hit.ID);\n        \n        // do lighting\n        vec3 bounceColour = getLighting(hit.pos,hit.normal,ray.direction,hit.ID, i)*.75;\n        bounceColour *= surfaceColour;\n     \n        // accumulate through path\n        pixelColour += bounceColour * pathColour;\n        \n        // accumulate path attenuation\n        float fresnel = pow(1.1-dot(hit.normal,-ray.direction),3.); \n        pathColour *= surfaceColour * (0.55 + fresnel*0.7);\n        \n        // reflect ray\n        ray.dist = 999.; // just in case this is a pass-by-reference language...?\n        ray.direction = reflect(ray.direction, hit.normal);\n        ray.origin = hit.pos;\n        ray.emitter = hit.ID; // make sure sure ray doesn't hit whatever it just hit again\n    }\n    \n    // hit the sky (set to false for night mode :) )\n    if(true)\n    {\n        // get material\n        vec3 surfaceColour = colourOfID(-1);\n                    \n        // accumulate through path\n        // if we haven't hit anything, the path is fully open/white\n        // if we have been reflecting around, pathColour will\n        // attenuate how much sky gets to this pixel appropriately\n        pixelColour += surfaceColour * pathColour * SKY_GAIN;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    // gamma\n    pixelColour = pow(pixelColour*1., vec3(1.6));\n    \n    // AO after gamma ... looks nice, idk\n    pixelColour *= min(1.,pow(SphereOcclusion(screenPos, screenID),AO_POWER)+AO_GAIN);\n     \n           \n  \n    fragColor = vec4(pixelColour,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n","name":"Common","description":"","type":"common"}]}