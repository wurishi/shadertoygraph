{"ver":"0.1","info":{"id":"lccfDj","date":"1733493630","viewed":115,"name":"moving in tunnel 2","username":"nayk","description":"source fractal 62 remake by chatgpt","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r) mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define Q(p) p *= 2.*r(round(atan(p.x, p.y) * 4.) / 4.)\n#define r(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O = vec4(0);\n    vec3 n1, p, q, r = iResolution;\n    vec3 d = normalize(vec3((C * 2. - r.xy) / r.y, 1));\n\n    // Параметры торуса\n    float R = 1.0; // Большой радиус\n    float r_torus = 0.3; // Малый радиус\n\n    for (float i = 0., a, s, e, g = 0.; ++i < 70.; O.xyz += mix(vec3(0.5, 0.2, 2.4), H(g * .1), .8) * 5. / e / 8e3)\n    {\n        p = g * d;\n        vec2 c22 = p.xz * p.yz;\n\n        // Вращение торуса\n        float ang = 205.;\n        float ang2 = iTime * 0.1;\n        float ang3 = iTime * 0.2;\n\n        p.xz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n        p.xz *= mat2(cos(ang2), sin(ang2), -sin(ang2), cos(ang2));\n        p.xy *= mat2(cos(ang3), sin(ang3), -sin(ang3), cos(ang3));\n\n        a = 30.;\n        Q(p.yx);\n        p.z += iTime;\n        p = mod(p - a, a * 2.) - a;\n        s = 2.;\n\n        for (int j = 0; j < 8; j++)\n        {\n            p = .3 - abs(p);\n            p.x < p.z ? p = p.zyx : p;\n            p.z < p.y ? p = p.xzy : p;\n            p.x < p.x ? p = p.zxy : p;\n            s *= e = 1.5 + sin(iTime * .01) * .05;\n            p = abs(p) * e - vec3(10. * 3., 120, 8. * 5.);\n        }\n\n        // Уравнение торуса\n        float dist = length(vec2(length(p.xy) - R, p.z)) - r_torus;\n\n        // Определение цвета пикселя на основе расстояния до поверхности торуса\n        if (dist < 0.01) {\n            O.xyz += mix(vec3(1.0, 0.5, 0.2), vec3(0.2, 0.5, 1.0), sin(iTime * 0.5)); // Цветовой градиент\n        }\n\n        g += e = length(p.yzzz) / s;\n    }\n}","name":"Image","description":"","type":"image"}]}