{"ver":"0.1","info":{"id":"mlySzt","date":"1686287062","viewed":111,"name":"TheNosiriN portfolio shader 1","username":"TheNosiriN","description":"Looking at this shader again it kinda looks cinematic-ish, so I'm using it for my portfolio website but I need to save it as public+api to do so ._.","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["gonna"],"hasliked":0,"parentid":"7slXDs","parentname":"gonna fix 5"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by: TheNosiriN\n\n// Dave_Hoskins Hash: https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//\n\n\nvec3 ACES(vec3 x){\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    #ifdef MARGIN\n    //if (abs(C.x-R.x/2.) >= mR/margin.x){ O=vec4(0); return; }\n    if (abs(C.y-R.y/2.) >= mR/margin.y){ O=vec4(0); return; }\n    #endif\n    \n    vec2 uv = C/R;\n    float col = 0.0;\n    \n    #ifdef DOF\n    // Xor's Bokeh: https://www.shadertoy.com/view/fldfWH\n    float focus = 1.5*(1.-get_cam_movement(iTime));\n    for(vec2 i = vec2(0,11); i.x<100.; i++){\n        col += pow(\n            texture(iChannel0,(C+R.y*focus*sin(i)/6e2*sqrt(i).x)/R).x, \n        5.+col-col);\n    }//\n    col = pow(col/100.,.2+col-col);\n    vec2 tex = texture(iChannel0, uv).xy;\n    //col = smoothstep(0.1, 0.2, tex.y);\n    //col = mix(tex.x, col, smoothstep(0.1, 0.15, tex.y));\n    col = mix(tex.x, col, smoothstep(0.075, 0.1, tex.y));\n    #else\n    col = texture(iChannel0, uv).x;\n    #endif\n        \n    col = max(col - hash13(vec3(C, float(iFrame)))*0.05, 0.); //film grain\n    col *= 0.3 + 0.8*pow(32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2); //vignette\n    col *= smoothstep(0.0, 7.0, iTime*0.75); //fade in\n    \n    O = vec4(vec3(col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float cammove = 0.0;\n\n\nfloat sunflare(vec2 uv){\n    float ang = atan(uv.y, uv.x);\n\tfloat d = length(uv);\n    d = pow(d, 0.1);\n\tfloat f = 1.2/(length(uv)*25.0+1.2);\n\tf = pow(f, 2.0);\n\tf = f+f*(sin((ang+1.0/18.0)*12.0)*.1+d*.1+.8);\n    return f;\n}\nfloat anflare(vec2 uv, float intensity, float stretch, float brightness){\n    uv.x *= 1.0/(intensity*stretch);\n    uv.y *= 0.5;\n    return smoothstep(0.009, 0.0, length(uv))*brightness;\n}\n\n\n\n// from: https://jbaker.graphics/writings/DEC.html\nmat2 rotaterad(float angle){\n\tfloat s = sin(angle), c = cos(angle);\n    return mat2( c, s, -s, c );\n}\nconst mat2 rotPId4 = mat2(0.7071067811865476, 0.7071067811865475, -0.7071067811865475, 0.7071067811865476);\nfloat de7(vec3 p, float t){\n    float d=1., a=1., iter = step(0.01, t)*treeIter+1.;\n    for(float j=0.;j++<iter;)\n      p.xz=abs(p.xz)*rotPId4,\n      d=min(d,max(length(p.zx)-.3,p.y-.4)/a),\n      p.yx *= rotaterad(t*0.55+float(j)/6.),\n      p.y -= t*15.,\n      p *= 1.8,\n      a *= 1.9;\n    return d;\n}\n///\n\n\n\nvec2 space(vec3 p){\n    float h = sin(p.x*0.05+cos(p.z*0.05))*10.;\n    vec2 np = p.xz;\n    //float detail = clamp(length((p-focusPoint).xz)-MAX_DIST/3., 0.0, 5.0);\n    //detail = mix(detail, cammove, cammove);\n    for (float i=0., a=1.; i<groundIter; i++){\n        #ifdef ROCK_SLIME\n        np.xy -= (iTime*0.3*i/3.) * vec2(1, mod(i,2.)*2.-1.);\n        #endif\n        float re = textureLod(iChannel0, np*0.002, groundLOD+1.0).r;\n        h += (re*2.-1.)*a*(h*0.4);\n        np = mat2(0.8,-0.6,0.6,0.8) * np * 4.;\n        a *= 0.325;\n    }\n    float d = p.y+10.+h;\n    float mat = 0.0;\n        \n    p -= focusPoint;\n    p.xy *= rotate(30.);\n    p.xz *= rotate(-10.);\n    \n    #ifdef SHOW_TREE\n    float crad = 0.1;\n    float t = easeOutQuint(smoothstep(0.05,0.0,cammove));\n    vec3 cp = p;\n    cp = cp/crad;\n    cp.xz += vec2(sin(cp.y), cos(cp.y))*0.5;\n    float cd = max(de7(cp, t)*crad*4.2, length(p)-(t+1.8));\n    d = smin(d, cd, 1.);\n    //if (d == cd){ mat = 1.0; }\n    #else\n    /*vec3 cp = p;\n    cp.xy *= rotate(30.);\n    cp.xz *= rotate(-10.+iTime*10.);\n    float cd = sdRhombus(p, 1., 0.9, 0.5, 0.08 )/0.3;\n    d = min(d, cd);\n    if (d == cd){ mat = 1.0; }*/\n    #endif\n\n    vec3 q = abs(p)-4.5;\n    float qr = max(q.x,max(q.y,q.z));\n    qr = max(qr, -length(p-vec3(1.0,0,1.2))+7.15);\n    #ifndef SHOW_FROSTED_GLASS\n    qr -= dot2(textureLod(iChannel0, p.xy*0.1, cutLOD).rgb)*0.075;\n    d = smin(d, qr*1.5, 2.5);\n    #else\n    qr -= dot2(textureLod(iChannel0, p.xy*0.1, cutLOD).rgb)*0.035;\n    d = min(d, qr);\n    if (d == qr){ mat = 2.0; }\n    #endif\n            \n    return vec2(d*0.3, mat);\n}\n\nfloat planet(vec3 eye, vec3 dir){\n    float rad = PLANET_RADIUS;\n    float a = dot(dir, dir);\n    float b = 2.*dot(eye,dir);\n    float c = dot(eye,eye)-rad*rad;\n    float d = b*b-4.*a*c;\n\n    if(d<0.)return -1.;\n    return (-b-sqrt(d))/(2.*a);\n}\n\n\n\nvec3 screenray(vec3 eye, vec3 dir, float maxd){\n    float d, i; vec2 ind;\n    for (; i<100. && d<maxd; i++){\n        ind = space(eye + dir * d);\n        if (abs(ind.x) < 0.001 * d)break;\n        d += ind.x;\n    }\n    return vec3(d, i/100., ind.y);\n}\n\n\nfloat shadowray(vec3 eye, vec3 dir, float maxd) {\n    float d, i, r=1., ph=1e10;\n    for(; i<100. && d<maxd; i++){\n     \tvec3 p = eye + dir * d;\n        float ind = space(p).x;\n        if (abs(ind) < 0.001 * d)return 0.;\n        \n        float y = ind*ind/(2.0*ph),\n        nd = sqrt(ind*ind-y*y);\n        r = min( r, 10.0*nd/max(0.0,d-y) );\n        d += ind;\n    }\n\n    return r;\n}\n\n\nvec3 normal(vec3 P){\n    vec3 ep = vec3(-4, 4, 0) * 0.001;\n    return normalize(\n        space(P+ep.xyy).x * ep.xyy + \n        space(P+ep.yxy).x * ep.yxy + \n        space(P+ep.yyx).x * ep.yyx + \n        space(P+ep.xxx).x * ep.xxx\n    );\n}\n\n\n\nfloat shade(vec3 eye, float dist, float md, vec3 P, vec3 N){\n    float shading = saturate(dot(N, light)*0.5+0.25);\n    shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n    if (shading >= 0.0){ shading *= shadowray(P,light,50.)+0.1; }\n\n    return saturate( (shading+0.1)+(dist/md)*0.1 );\n}\n\nfloat shade_planet(vec3 eye, float dist, vec3 P, vec3 N){\n    float shading = saturate(dot(N, light)*0.5+0.25);\n    return mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n}\n\n\n\nvec3 mousecam(float len, vec2 m){\n    vec2 r = vec2(-m.x * 6.284, m.y * 3.142);\n    return len * vec3(cos(r.x)*sin(r.y), cos(r.y), sin(r.x)*sin(r.y));\n}\n\n\nvec2 makePixel(vec2 C){\n    float col = 0.0;\n    vec2 uv = (C-R*0.5)/R.y;\n    cammove = get_cam_movement(iTime);\n\n    vec3 eye = vec3(0,-1.5,10);\n    vec3 lookAt = vec3(3,-3., 0);\n    \n    vec2 ms = iMouse.xy/R;\n    ms = 1.0-ms;\n    ms = vec2(ms.x-0.5, ms.y);\n    eye += vec3(sin(ms.x), cos(ms.x)*sin(ms.y), sin(ms.y))*3.;\n    \n    eye = mix(eye+focusPoint+vec3(2,0,0), eye, cammove);\n    lookAt = mix(focusPoint+vec3(1.5,0.5,0), lookAt, cammove);\n    \n    vec3 f = normalize(lookAt - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -mix(2.0, 0.9, cammove) )), 0)\n    ).xyz;\n    \n    float rot = -(1.-cammove)*MAX_CAM_ANGLE;\n    dir.xy *= rotate(rot);\n    \n    vec3 gdir = dir;\n    gdir.y += sin(uv.x*2.0+1.3)*0.1*cammove;\n    //vec3 dist = screenray(eye, gdir, MAX_DIST);\n    float dof = MAX_DIST;\n    \n    \n    for (int i=0; i<2; ++i){\n        float maxd = MAX_DIST/float(i+1);\n        vec3 dist = screenray(eye, gdir, maxd);\n        if (dist.x < maxd){\n            vec3 P = eye + gdir * dist.x;\n            vec3 N = normal(P);\n            \n            vec3 dofp = P-focusPoint;\n            dof = length((dofp).xz * vec2(.4,1).xy);\n            //dof = abs(dofp.z)+6.;\n            \n            if (dist.z == 1.0){\n                eye = P;\n                gdir = normalize(reflect(gdir, N));\n                col += 0.1;\n            }else\n            if (dist.z == 2.0){\n                eye = P + gdir * 2.;\n                gdir = normalize(refract(gdir, N, 0.5));\n            }\n            else{\n                float sh = shade(eye, dist.x, maxd, P, N);\n                col += mix(sh*0.3, sh, saturate(1.0-pow(dist.y,3.0)*3.0));\n                break;\n            }\n            \n        }else{\n            float pd = planet(eye-vec3(-120.,-2,-1000.), dir);\n\n            if (pd > -1.){\n                eye.z += 900.;\n                vec3 P = eye + dir * pd;\n                vec3 N = normalize(P);\n                vec3 np = P;\n                np.yz *= rotate(-iTime*0.75);\n                N = normalize(N + (textureLod(iChannel1, np.yz*0.01, 1.).rgb));\n\n                float sh = shade_planet(eye, pd, P, N)*2.0-1.;\n                col = mix(col, 1.0, max(sh, -0.1));\n            }\n            break;\n        }\n    }\n    \n    \n    #ifdef SHOW_LENS_FLARE\n    vec3 sdir = dir;\n    sdir.xz *= rotate(-22.);\n    sdir.yz *= rotate(-7.5);\n    sdir.xy *= rotate(-rot);\n    \n    col += sqrt(sunflare(sdir.xy*1.1));\n    float an = pow(anflare(sdir.xy, 600.0, 0.6, 0.63), 3.9);\n    an += smoothstep(0.0025, 1.0, an)*10.0;\n    an *= smoothstep(0.0, 1.0, an);\n    col += an;\n    col = saturate(col);\n    #else\n    col = sqrt(saturate(col));\n    #endif\n    \n    return vec2(col, dof/MAX_DIST);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    #ifdef MARGIN\n    //if (abs(C.x-R.x/2.) >= mR/margin.x){ O=vec4(0); return; }\n    if (abs(C.y-R.y/2.) >= mR/margin.y){ O=vec4(0); return; }\n    #endif\n    \n    vec2 col = makePixel(C);\n    \n    O = vec4(col, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Made by: TheNosiriN\n\n//#define LOW_QUALITY // use this if you're having troubles\n#define HIGH_QUALITY // for beefy machines\n\n#define MARGIN //remove anoying margins\n#define DOF\n#define SHOW_LENS_FLARE\n#define SHOW_TREE\n//#define SHOW_FROSTED_GLASS\n#define ROCK_SLIME\n\n#define R (iResolution.xy)\n#define mR min(R.x,R.y)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.1415972\n\n#define PLANET_RADIUS 500.\n#define MAX_DIST 100.0\n#define MAX_CAM_ANGLE 15.0\n\n\n#if defined(HIGH_QUALITY)\nconst float treeIter = 8.0;\nconst float groundIter = 4.0;\nconst float groundLOD = 0.0;\nconst float cutLOD = 1.0;\n\n#elif defined(LOW_QUALITY)\nconst float treeIter = 6.0;\nconst float groundIter = 3.0;\nconst float groundLOD = 1.0;\nconst float cutLOD = 3.0;\n\n#else\nconst float treeIter = 7.0;\nconst float groundIter = 3.0;\nconst float groundLOD = 0.0;\nconst float cutLOD = 2.0;\n#endif\n\n\nconst vec2 margin = vec2(1.65, 2.4);\nconst vec3 light = normalize(vec3(0.9,0.5,-1));\nconst vec3 focusPoint = vec3(0,-10.,-30);\n\nfloat dot2(vec3 p){ return dot(p,p); }\n\n\n\nmat2 rotate(float angle){\n\tangle *= 3.142 / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\n\nfloat easeOutQuint(float x) {\n    return 1.0 - pow(1.0 - x, 5.0);\n}\nfloat get_cam_movement(float time){\n    return smoothstep(0.,1., cos(time*0.03 + 0.6)*.5+.5 );\n}\n\n\nvec3 cubenorm(vec3 p){\n    p = abs(p);\n    return normalize(sign(p - max(p.x, max(p.y,p.z))));\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}","name":"Common","description":"","type":"common"}]}