{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\nvoid MakeViewRay(in vec2 fragCoord, out vec3 eye, out vec3 ray)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.,0.,0.+iTime*.1);\n\teye = vec3(2.5,3.,-2.5) * 1.5 + lookAt; \t\n//\teye = RotY(eye,iTime*.4);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n}\n\n#if 1\n\n#define CHEAPER_NOISES\n\nfloat Noise( in vec3 x, float lod_bias )\n{\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\t//not terribly noticeable for higher freq noises anyway\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec2 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yx;\n#else\t\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yx;\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n#else\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) \n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\tr = r-0.5;\n\t\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat Noise(vec3 p, float lod) {\n\tp*= 0.3;\n\t\n\t /* 1. find current tetrahedron T and its four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \t\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0))*.65+.45;\n}\n\n#endif\n\nvec4 BlendUnder(vec4 accum,vec4 col)\n{\n\tcol = clamp(col,vec4(0),vec4(1));\t\n\tcol.rgb *= col.a;\n\taccum += col*(1.0 - accum.a);\t\n\treturn accum;\n}\n\nvec4 March(vec4 accum, vec3 viewP, vec3 viewD, vec2 mM)\n{\n\t//exponential stepping\n#define SHQ\t\n//#define MEDQ\t\n//#define YUCKQ\t\n#ifdef SHQ\n\t#define STEPS\t128\t\n\tfloat slices = 512.;\n#endif\t\n#ifdef MEDQ\n\t#define STEPS\t64\t\n\tfloat slices = 256.;\n#endif\t\n#ifdef YUCKQ\t\n\t#define STEPS\t32\t\n\tfloat slices = 128.;\n#endif\n\t\n\tfloat Far = 10.;\n\t\n\tfloat sliceStart = log2(mM.x)*(slices/log2(Far));\n\tfloat sliceEnd = log2(mM.y)*(slices/log2(Far));\n\t\t\t\n\tfloat last_t = mM.x;\n\t\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\t\t\t\n\t\tsliceStart += 1.;\n\t\tfloat sliceI = sliceStart;// + float(i);\t//advance an exponential step\n\t\tfloat t = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\n\t\tvec3 p = viewP+t*viewD;\n\t\tvec3 uvw = p;\n\t\tuvw.y/=10.;\n\t\tuvw.y += iTime;\n\t\tuvw *= 30.;\n\t\t\n\t\tfloat h = (1.-((p.y+1.)*0.5));\n\t\tfloat dens = Noise(uvw,-100.);// * h;\n\t\t\tdens*=dens;\n\t\t\tdens*=dens;\n\t\tdens -= 0.25;\n\t\tdens *= (t-last_t)*1.5;\n\t\t\n\t\taccum = BlendUnder(accum,vec4(vec3(1.),dens));\n\t\t\t\n\t\tlast_t=t;\n\t}\n\t\n\tvec3 p = viewP+mM.y*viewD;\n\tvec3 uvw = p;\n\tuvw *= 20.;\n\tuvw.y += iTime*20.;\n\tfloat dens = Noise(uvw,-100.);\n\tdens=sin(dens);\n\tdens*=dens;\n\tdens*=dens;\n\tdens*=.4;\n\taccum = BlendUnder(accum,vec4(1.,1.,1.,dens));\n\t\n\treturn accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(fragCoord, viewP, viewD);\n\n\t//ground plane\n\tfloat floor_height = -1.;\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,p.xz*0.125,floor_intersect_t*2.-16.).xyz;\n\tc = pow(c,vec3(2.2));\n\tc *= 0.8;\n\tfloat ceil_intersect_t = (-viewP.y + 1.) / (viewD.y);\n\n\tvec4 a = March(vec4(0), viewP, viewD, vec2(ceil_intersect_t,floor_intersect_t));\n\tc = BlendUnder(a,vec4(c,1.)).xyz;\n//\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sj3Wc","date":"1394704768","viewed":2772,"name":"wet","username":"Antonalog","description":"the weather feels kinda bilinear here sometimes.","likes":74,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""}}