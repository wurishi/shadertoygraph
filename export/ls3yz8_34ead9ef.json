{"ver":"0.1","info":{"id":"ls3yz8","date":"1517900197","viewed":174,"name":"Drawint","username":"ramagosula","description":"Drawing. Buffer A and B ping pong back and forth. \n#define DRAW lets you draw a circle\n\nSeveral functions exist, blur, blob, spreadingSquares\n\nfavorite function: spreadingGame\n--most generate patterned expanding square or diamond\n--Mix and Match\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["draw","drawing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///CREDIT IQ\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n//---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenPercent = (vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y));\n    \n    // Time varying pixel color\n    vec3 col = vec3(1,1,1);\n    float radius = 0.01;\n    col *= smoothstep(1.0,0.999,length(screenPercent - uv)/radius);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec3 colorOffset = vec3(0.000000,0.000000,0.0000);\n    \n    fragColor = vec4(texture(iChannel0,uv + vec2(1.0,1.0)*colorOffset.x).r,texture(iChannel0,uv+colorOffset.y).g,texture(iChannel0,uv+colorOffset.z).b,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DRAW \n\nconst int DIAMOND = 0;\nconst int SQUARE = 1;\nconst int CIRCLE = 2;\n\nint drawType = CIRCLE;\n    \n    \nconst float drawRadius = 1.0;\nconst float stretchX = 1.10;//0.350;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t#ifdef DRAW\n    vec2 screenPercent = (vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y));\n    \n    // Time varying pixel color\n    vec3 col = vec3(1,1,1);\n    \n    //float dist = length(screenPercent - uv)/drawRadius;\n    float dist = 0.0;\n    if(drawType == DIAMOND)\n    {\n    \tdist = (abs(fragCoord.x - iMouse.x)*stretchX + abs(fragCoord.y - iMouse.y))/drawRadius;\n    }\n    if(drawType == SQUARE)\n    {\n    \tdist = max(abs(fragCoord.x - iMouse.x)*stretchX , abs(fragCoord.y - iMouse.y))/drawRadius;\n    }\n    if(drawType == CIRCLE)\n    {\n    \tdist = length(vec2(abs(fragCoord.x - iMouse.x)*stretchX , abs(fragCoord.y - iMouse.y)))/drawRadius;\n    }\n    //dist = length(screenPercent - uv)/drawRadius;\n    \n    \n    col *= smoothstep(1.0,0.999,dist);\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv) + vec4(col,1.0);\n    #else\n    fragColor = texture(iChannel0,uv);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PI = 3.1415926535897932;\nfloat c_textureSize = 64.0;\n\n#define c_onePixel  (1.0 / c_textureSize)\n#define c_twoPixels  (2.0 / c_textureSize)\n\nfloat c_x0 = -1.0;\nfloat c_x1 =  0.0;\nfloat c_x2 =  1.0;\nfloat c_x3 =  2.0;\n\nvec3 NearestTextureSample (vec2 P)\n{\n\tfloat textureSize = iResolution.x*iResolution.y;\n    vec2 pixel = P * textureSize;\n    \n    float onePixel = 1.0/textureSize;\n    vec2 frac = fract(pixel);\n    pixel = (floor(pixel) / textureSize);\n    return texture(iChannel0, pixel + vec2(onePixel/2.0)).rgb;\n}\n\nvec4 blur(vec2 uv)\n{\n    vec3 gen = vec3(1.0,1.0,1.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n\tgen *= (tl + tm + tr + ml + mm + mr + bl + bm + br)/9.0;\n    \n    return vec4(gen,1.0);\n}\n\nvec4 squareDraw(vec2 uv)\n{\n    vec3 gen = vec3(1.0,1.0,1.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;\n\tgen *= clamp(sum,0.0,1.0);\n    \n    return vec4(gen,1.0);\n}\n\nvec4 blobDrawer(vec2 uv)\n{\n    vec3 gen = vec3(1.0,1.0,1.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;\n\tgen *= smoothstep(0.0,1.0,sum/9.0);\n    \n    return vec4(gen,1.0);\n}\n\nvec4 spreadingSquares(vec2 uv)\n{\n    vec3 gen = vec3(0.0,0.0,0.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    float total = 0.0;\n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;\n    if((abs(sum-2.0) < 0.001) )\n    {\n    \ttotal += 1.0;   \n    }\n    \n    if((abs(sum-1.0) < 0.001) )\n    {\n    \ttotal += (1.0-mm);   \n    }\n    gen += vec3(1.0,1.0,1.0)*total;   \n    \n    return vec4(gen,1.0);\n}\n\n//results:\n//*: notable/different\n//g: good\n//f: fine\n//-s: -square\n//-d: -diamond\n//b: boring\n//w: worthless\n//p: prepare-need to start with a lot of stuff onscreen, otherwise worthless\n\n//most boring collapse to points\n//most good game of life-ey are diamonds eventually\n\n// a\\b\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n// 0|\tw\tw\tp\tg\tfs\tg*\tw\tw\tw\tw\n// 1| \tw\tw\tfs\tfs\tfs\tfs\tfs\tg*\tg*\tg*\n// 2|\tb\tfs\tfs\tfd\tfd\tfd\tfd\tfd\tfd\tfd\n// 3|\tg*\tfs\tfd\tw\tb\tb\tb\tb\tb\tb\n// 4|\tfs\tfs\tgd\tb\tg\tb\n// 5|\tfs\tfs\tg\tb\tb\tb\n// 6|\tg\tfs\tg\tb\tb\tb\n// 7|\tg\tfs\tf\tb\tb\tb\n// 8|\tg*\tfs\tg\tb\tb\tb\n// 9|\tg*\tfs\tg\tb\tb\tb\nvec4 spreadingGame(vec2 uv,float a, float b)\n{\n    vec3 gen = vec3(0.0,0.0,0.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    float total = 0.0;\n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;\n    if((abs(sum-a) < 0.001) )\n    {\n    \ttotal += 1.0;   \n    }\n    \n    if((abs(sum-b) < 0.001) )\n    {\n    \ttotal += (1.0-mm);   \n    }\n    gen += vec3(1.0,1.0,1.0)*total;   \n    \n    return vec4(gen,1.0);\n}\n\nvec4 gameOfLife(vec2 uv)\n{\n    vec3 gen = vec3(0.0,0.0,0.0);\n   \t\n    float textureSize = iResolution.x*iResolution.y;    \n    float onePixel = 1.0/textureSize;\n    \n    float total = 0.0;\n    //\n    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;\n    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;\n    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;\n    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;\n    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;\n    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;\n    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;\n    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;\n    float sum = tl + tm + tr + ml + mr + bl + bm + br;\n    if(mm < 0.001)\n    {\n        if((abs(sum-3.0) < 0.001) )\n        {\n            total += 1.0;   \n        }\n    }\n    else\n    {\n       if((abs(sum-3.0) < 0.001) )\n        {\n            total += 1.0;   \n        }\n\n        if((abs(sum-1.0) < 0.001) )\n        {\n            total += 0.0;   \n        } \n    }\n    \n    gen += vec3(1.0,1.0,1.0)*total;   \n    \n    return vec4(gen,1.0);\n}\n//results:\n//*: notable/different\n//g: good\n//f: fine\n//-s: -square\n//-d: -diamond\n//b: boring\n//w: worthless\n//p: prepare-need to start with a lot of stuff onscreen, otherwise worthless\n\n//most boring collapse to points\n//most good game of life-ey are diamonds eventually\n\n// a\\b\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n// 0|\tw\tw\tp\tg\tfs\tg*\tw\tw\tw\tw\n// 1| \tw\tw\tfs\tfs\tfs\tfs\tfs\tg*\tg*\tg*\n// 2|\tp\tfs\tfs\tfd\tfd\tfd\tfd\tfd\tfd\tfd\n// 3|\tg*\tfs\tfd\tw\tb\tb\tb\tb\tb\tb\n// 4|\tfs\tfs\tgd\tb\tg\tb\n// 5|\tfs\tfs\tg\tb\tb\tb\n// 6|\tg\tfs\tg\tb\tb\tb\n// 7|\tg\tfs\tf\tb\tb\tb\n// 8|\tg*\tfs\tg\tb\tb\tb\n// 9|\tg*\tfs\tg\tb\tb\tb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 speed = vec2(0.0,0.01);\n    float scale = 1.4;\n    vec4 tex = texture(iChannel0,uv*scale + speed);\n    fragColor = tex ;\n    fragColor = vec4(NearestTextureSample(uv),1.0);\n    fragColor = spreadingGame(uv,2.0,3.0);//modify the arguments for interesting results\n    //fragColor = blur(uv);//modify the arguments for interesting results\n\n}","name":"Buffer B","description":"","type":"buffer"}]}