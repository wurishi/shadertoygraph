{"ver":"0.1","info":{"id":"fdtyD8","date":"1653463925","viewed":97,"name":"Polynomial Regression Curve Fit","username":"Envy24","description":"BufferA - drawing spline\nBufferB - drawing control points\nBufferC - drawind dashed convex hull\nImage - mixing and coloroing\n\nFour passes used for better readability of code.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["curve","interpolation","polynomial","regression","fitting"],"hasliked":0,"parentid":"7dccDH","parentname":"Cubic Regression Curve Fitting"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 spline      = TEXF0(SC);\n    vec4 knot        = TEXF1(SC);\n    vec4 convex_hull = TEXF2(SC);\n    \n    float min = MIN3(spline.r, knot.r, convex_hull.r);\n    \n    O = \n        min == 1.0 ?\n            vec4(1) :                            // Background color\n            min == spline.r ?\n                vec4(0, spline.r, spline.r, 1) : // Spline color\n                min == knot.r ?\n                    vec4(0, knot.r, 0, 1) :      // Knot color\n                    vec4(convex_hull);           // Convex hull  color\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define INITIALLY_FAR               9e30\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n#define TEXF2(SC)                 ( texelFetch(iChannel2, ivec2(SC), 0) )\n#define MIN3(a, b, c)             ( min(min((a), (b)), (c)) )\n#define NMY                       ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n#define RANDOM\n\n/* \n    1 - linear,\n    2 - quadratic,\n    3 - cubic,\n    4 - quartic,\n    5 - quintic,\n    e.t.c.\n*/\nconst int degree = 5; // This constant set degree of polynomial\n\n/* Don't change this constants. */\nconst int num_of_coeffs = degree + 1;        \nconst int shift_size = 1 + 2 * degree;\nconst int row_size = degree + 1;\nconst int matrix_size = row_size * row_size;\nconst int extended_size = 2 * matrix_size;\n/* Don't change this constants. */\n\n/*\n    For\n        linear    minimum 2 control points,\n        quadratic minimum 3 control points, \n        cubic     minimum 4 control points,\n        quartic   minimum 5 control points,\n        quintic   minumum 6 control points,\n        e.t.c.\n       \n*/\nconst int num_of_ctrls = max(degree + 1, /*Your number of points*/ 8); \nvec2 ctrls[num_of_ctrls];\n/**\nvec2 ctrls[num_of_ctrls] = vec2[num_of_ctrls](\n\t\tvec2(-1.5,  0.0),\n\t\tvec2(-0.75,  0.0),\n\t\tvec2(0.75,  0.0),\n        vec2(1.5,  0.0)\n);\n/**/\n\nfloat circleSQSDF(\n    in vec2 S,   // sample coordinates\n    in vec2 C,   // circle center\n    in float R,  // circle radius\n    in float SM) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float x = S.x - C.x, y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = x * x + y *y - R * R;\n    \n    float ss = SM * SM;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize_ctrls(float time)\n{\n    uint T = uint(time);\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        ctrls[k] = vector2HashUI32(T + uint(k), 2u * T + uint(k * 2));\n    }\n}\n\nvoid randomize_ctrls2(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    float xMin = -1.7;\n    float dx = 3.4 / float(num_of_ctrls - 1);\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = vector2HashUI32(x, y);\n        vec2 n = vector2HashUI32(x + 1u, y + 2u);\n    \n        ctrls[k] += (c * (1. - t) + n * t);\n        ctrls[k].x = xMin + float(k) * dx;\n        //ctrls[k] *= vec2(0.3, 0.8);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* if return_value >= N OR return_value == -1, then matrix is probably singular. */\nint to_upper_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < N - 1;)\n    {\n        float diag = M[sub * rowSize + sub];\n\n        if (diag == 0.0)\n        {\n            int r = sub + 1;\n            while (M[r * rowSize + sub] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // probably singular matrix\n\n            for (int c = 0; c < rowSize; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[sub * rowSize + c];\n                M[sub * rowSize + c] = t;\n            }\n\n            diag = M[sub * rowSize + sub];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = sub + 1; r < N; ++r)\n        {\n            if (M[r * rowSize + sub] == 0.0) { continue; }\n\n            float ratio = M[r * rowSize + sub] / diag;\n\n            for (int c = sub; c < rowSize; ++c)\n            {\n                M[r * rowSize + c] -= M[sub * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\n/* if return_value >= N OR return_value == -1, then matrix is probably singular. */\nint to_lower_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int Ndec = N - 1;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < Ndec;)\n    {\n        int mirror = (Ndec - sub);\n        float diag = M[mirror * rowSize + mirror];\n\n        if (diag == 0.0)\n        {\n            int r = mirror - 1;\n\n            while (M[r * rowSize + mirror] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // probably singular matrix\n\n            for (int c = 0; c < N; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[mirror * rowSize + c];\n                M[mirror * rowSize + c] = t;\n            }\n\n            diag = M[mirror * N + mirror];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = mirror - 1; r >= 0; --r)\n        {\n            if (M[r * rowSize + mirror] == 0.0) { continue; }\n\n            float ratio = M[r * rowSize + mirror] / diag;\n\n            for (int c = rowSize - 1; c > mirror - 1; --c)\n            {\n                M[r * rowSize + c] -= M[mirror * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\nvoid Jordan_Gauss_inverse(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    to_upper_triangle(M, N);\n    to_lower_triangle(M, N);\n\n    int rowSize = 2 * N;\n\n    for (int r = 0; r < N; ++r)\n    {\n        float invDiag = 1.0 / M[r * rowSize + r];\n\n        for (int c = 0; c < N; ++c)\n        {\n            M[N + r * rowSize + c] *= invDiag;\n        }\n        M[r * rowSize + r] *= invDiag;\n    }\n}\n\nvoid read_right_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[wOffset++] = M[r * rowSize + N + c];\n        }\n    }\n}\n\nvoid write_right_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + N + c] = I[wOffset++];\n        }\n    }\n}\n\nvoid read_left_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            O[wOffset++] = M[r * rowSize + c];\n        }\n    }\n}\n\nvoid write_left_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;          \n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + c] = O[wOffset++];\n        }\n    }\n}\n\nvoid identity(\n    inout float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[r * N + c] = float(r == c);\n        }\n    }\n}\n\nvoid shifted_matrix(\n    inout float[matrix_size] M,\n    in float[shift_size] shift_vec,\n    in int shift_size)\n{\n    int shift = 0;\n    for (int r = 0; r < row_size; ++r)\n    {\n        for (int c = 0; c < row_size; ++c)\n        {\n            int w_offset = r * row_size + c;\n            int r_offset = (c + shift) % shift_size;\n            M[w_offset] = shift_vec[r_offset];\n        }\n        ++shift;\n    }\n}\n\nvoid calculatePolynomialCoefficients(\n    in vec2[num_of_ctrls] ctrls,     // control points\n    inout float[num_of_coeffs] coef) // polynomial coefficients\n{\n    float shift[shift_size]; // vector of coefficients for system matrix\n    float w[row_size];       // vector of coefficients for solving system of equations\n    \n    for (int i = 0; i < shift_size - 1; ++i) {shift[i] = 0.; }\n    for (int i = 0; i < row_size; ++i) { w[i] = 0.; }\n    \n    for (int j = 0; j < num_of_ctrls; ++j)\n    {\n        float x = ctrls[j].x;\n        float y = ctrls[j].y;\n    \n        float power = x;\n        \n        for (int i = shift_size - 2; i >= 0; --i)\n        {\n           shift[i] += power;\n           power *= x;\n        }\n        \n        float product = y;\n        \n        for (int i = row_size - 1; i >= 0; --i)\n        {\n           w[i] += product;\n           product *= x;\n        }\n    }\n    shift[shift_size - 1] = float(num_of_ctrls);\n\n    float M[extended_size]; // 2 matricies for Jordan Gauss inverse\n    float I[matrix_size];   // buffer and inverse matrix\n    \n    // Set and write system matrix\n    shifted_matrix(I, shift, shift_size);\n    write_left_matrix(M, I, row_size);\n    \n    // Set and write identity matrix\n    identity(I, row_size);\n    write_right_matrix(M, I, row_size);\n    \n    // Find and read inverse matrix\n    Jordan_Gauss_inverse(M, row_size);\n    read_right_matrix(M, I, row_size);\n    \n    // Matrix-Vector multiplication\n    for (int r = 0; r < row_size; ++r)\n    {\n        coef[r] = 0.;\n        for (int c = 0; c < row_size; ++c)\n        {\n            coef[r] += I[r * row_size + c] * w[c];\n        }\n    }\n}\n\nvec2 find_closest_curve_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n \n    float xMin = ctrls[0].x;\n    float xMax = ctrls[num_of_ctrls - 1].x;\n    float dx = (xMax - xMin) * 0.003;\n       \n    float coef[num_of_coeffs];\n    calculatePolynomialCoefficients(ctrls, coef);\n\n    for (float x = xMin; x < xMax; x += dx)\n    {\n        vec2 P;\n        P.x = x;\n        P.y = coef[num_of_coeffs - 1]; // d\n        \n        // Evaluate polynomial.\n        float power = x;\n        for (int i = num_of_coeffs - 2; i >= 0; --i)\n        {\n            P.y += coef[i] * power;\n            power *= x;\n        }\n \n        vec2 diff = P - NDC;\n        float sqDist = dot(diff, diff);\n\n        minSqDist = min(minSqDist, sqDist);\n\n        closestP = \n            minSqDist == sqDist ? \n                P :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_ctrls(iTime);\n    randomize_ctrls2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_curve_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.01,\n        0.011));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 find_closest_control_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        vec2 diff = ctrls[k] - NDC;\n        float sqDist = dot(diff, diff);\n       \n        minSqDist = min(minSqDist, sqDist);\n        \n        closestP = \n            minSqDist == sqDist ? \n                ctrls[k] :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_ctrls(iTime);\n    randomize_ctrls2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_control_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.02,\n        0.018));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 find_closest_convex_hull_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n    \n    int num_of_lines = num_of_ctrls - 1; // 2 knots per line\n     \n    for (int l = 0; l < num_of_lines; ++l)\n    {\n        for (float t = 0.; t <= 1.; t += 0.1)\n        {\n            vec2 P = ctrls[l] * (1. - t) + ctrls[l + 1] * t;\n\n            vec2 diff = P - NDC;\n            float sqDist = dot(diff, diff);\n\n            minSqDist = min(minSqDist, sqDist);\n\n            closestP = \n                minSqDist == sqDist ? \n                    P :\n                    closestP;\n        }\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_ctrls(iTime);\n    randomize_ctrls2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_convex_hull_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.008,\n        0.0088));\n}","name":"Buffer C","description":"","type":"buffer"}]}