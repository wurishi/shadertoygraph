{"ver":"0.1","info":{"id":"ssGBR3","date":"1658568315","viewed":125,"name":"thinfilm spectral w/hwss","username":"naclyyy","description":"thin film interference based on https://sciencedemonstrations.fas.harvard.edu/presentations/thin-film-interference\n(potentially wrong) thin film formula derived from https://en.wikipedia.org/wiki/Thin-film_interference#Soap_bubble\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["spectral","fraunhoffer","hwss"],"hasliked":0,"parentid":"NdGBRc","parentname":"Fraunhoffer interference"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// this is from https://en.wikipedia.org/wiki/SRGB#From_CIE_XYZ_to_sRGB\nmat4 xyz_to_rgb = mat4(vec4(3.2406, -1.5372, -0.4986, 0.0), vec4(-0.9689, 1.8758, 0.0415, 0.0), vec4(0.0557, -0.2040,\n            1.0570, 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iFrame == 0) {\n        data = vec4(0.0);\n    }\n    data = transpose(xyz_to_rgb) * (data.xyzw / (1.0 + float(iFrame)));\n    \n    \n    vec3 res = vec3(lessThan(data.xyz, vec3(0.0031308)));\n    \n    // linear->srgb conversion as defined in https://en.wikipedia.org/wiki/SRGB#From_CIE_XYZ_to_sRGB\n    data.xyz = res * (12.92 * data.xyz) + (1.0 - res) * (1.055 * pow(data.xyz, vec3(1.0f / 2.4f)) - 0.055);\n    \n    fragColor = vec4(data.xyz, 1.0f);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//reference image0: https://static.projects.iq.harvard.edu/files/styles/os_files_xlarge/public/science-demonstrations/files/thinfilminterference-freeze-wide-2-640x360.jpg\n//reference image1: https://static.projects.iq.harvard.edu/files/styles/os_files_xlarge/public/science-demonstrations/files/thinfilminterference-freeze-top-2-640x360.jpg\n\n//source article with reference images: https://sciencedemonstrations.fas.harvard.edu/presentations/thin-film-interference\n\n// color stuff\n// from https://en.wikipedia.org/wiki/CIE_1931_color_space#Analytical_approximation\n\n\nfloat gaussian(float x, float mu, float sigma1, float sigma2){\n    float denom;\n    if (x < mu) {\n        denom = sigma1;\n    } else {\n        denom = sigma2;\n    }\n    float _sqrt = (x - mu) / denom;\n    return exp(-(_sqrt * _sqrt) / 2.0);\n}\n\n\nfloat x_bar(float angstroms) {\n    return (1.056 * gaussian(angstroms, 5998.0, 379.0, 310.0)\n        + 0.362 * gaussian(angstroms, 4420.0, 160.0, 267.0)\n        -0.065 * gaussian(angstroms, 5011.0, 204.0, 262.0));\n}\n\nfloat y_bar(float angstroms) {\n    return (0.821 * gaussian(angstroms, 5688.0, 469.0, 405.0)\n        + 0.286 * gaussian(angstroms, 5309.0, 163.0, 311.0));\n}\n\nfloat z_bar(float angstroms) {\n    return (1.217 * gaussian(angstroms, 4370.0, 118.0, 360.0)\n        + 0.681 * gaussian(angstroms, 4590.0, 260.0, 138.0));\n}\nvec4 wavelength_to_xyz(float wavelength) {\n    float angstroms = wavelength * 10.0;\n    return vec4(x_bar(angstroms), y_bar(angstroms), z_bar(angstroms), 0.0);\n}\n\n\n// frame seeded xoroshiro https://www.shadertoy.com/view/wtVyzt\n\n// rng implementation from https://www.shadertoy.com/view/MdVBWK\n// rng\n// SIMD Implementation of xoroshiro64**\n// next2 generates two uniformly distributed unsigned ints (32 bits),\n// with a 4*32 bits state. The state must be seeded so it is not\n// everywhere zero.\n//\n// Note that using correlated values as seeds (such as pixel coordinates)\n// results in correlated sequences in the generator output. This is why\n// seeds should be hashed before being used for a PRNG.\n//\n// Reference implementation by David Blackman and Sebastiano Vigna:\n//   http://xoshiro.di.unimi.it/\n//   http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n\nuvec2 rotl2(uvec2 x, int k) {\n    return (x << k) | (x >> (32 - k));\n}\n\n// Generates 2 uniform integers, updates the state given as input\nuvec2 next2(inout uvec4 s) {\n    uvec2 s0 = s.xz;\n    uvec2 s1 = s.yw;\n    uvec2 rs = rotl2(s0 * 0x9E3779BBu, 5) * 5u;\n    \n    s1 ^= s0;\n    s.xz = rotl2(s0, 26) ^ s1 ^ (s1 << 9);\n    s.yw = rotl2(s1, 13);\n    \n    return rs;\n}\n\n// Converts a vector of unsigned ints to floats in [0,1]\nvec4 tofloat(uvec4 u) {\n    //Slower, but generates all dyadic rationals of the form k / 2^-24 equally\n    //return vec4(u >> 8) * (1. / float(1u << 24));\n\n    //Faster, but only generates all dyadic rationals of the form k / 2^-23 equally\n    return uintBitsToFloat(0x7Fu << 23 | u >> 9) - 1.;\n}\n\n// Simple coordinate hash\nvoid hash(inout uvec4 x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = (x >> 16) ^ x;\n}\n\n\n\nvec4 sinc(vec4 val)\n{\n  return sin(val) / val;\n}\n\n//reference: https://en.wikipedia.org/wiki/Double-slit_experiment#Classical_wave-optics_formulation\nvec4 Fraunhoffer(vec4 lambda, float theta, float d, float b)\n{\n  float pi = 3.141592f;\n  float s = sin(theta);\n  vec4 c = cos(pi * d * s / lambda);\n  vec4 sc = sinc(pi * b * s / lambda);\n  return c * c * sc * sc;\n}\n\nvec4 film_interference(vec4 lambda, float theta, float film_thickness, float ior, bool add_half_phase) {\n    float pi = 3.14159265;\n    float s = sin(theta);\n    float c = cos(theta);\n    // optical path difference\n    float opd = 2.0 * ior * film_thickness * c;\n    vec4 magnitude = opd / lambda;\n    // if magnitude is near some integer multiple, then the interference is constructive,\n    // otherwise, the interference is destructive\n    vec4 phase = 2.0 * pi * (magnitude + float(add_half_phase) * 0.5);\n    vec4 cosine = cos(phase);\n    vec4 interference = (cosine + 1.0) / 2.0;\n    return interference;\n}\n\nvec4 distribute_wavelengths(float x, vec2 bounds) {\n    vec4 samples = mod(vec4(x, x + 0.25, x + 0.5, x + 0.75),1.0);\n    return bounds.x + (bounds.y - bounds.x) * samples;\n}\n\nfloat calculate_theta_2(float uvy, float cam_height, float view_distance) {\n    // view distance is used to calculate what theta2 should be.\n    // we're essentially pathtracing from a pinhole camera, and calculating what theta2 needs to be for theta1 to hit a distant light source\n    \n    \n    \n    // camera is a pinhole camera at (view_distance, camera_vertical_pos)\n    \n    float theta_cam = atan((cam_height-uvy)/view_distance);\n    float theta_2 = asin(sin(theta_cam)/1.2);\n    \n    \n    return theta_2;\n}\n\n\n#define USE_FRAUNHOFFER false\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Seed the generator: this requires setting 4 uints\n    //  int pixel coords\n    uvec4 s = uvec4(fragCoord, 0, 0);\n    //  Enumerate all pixels in row-major order\n    s.x = 4u * (s.y * uint(iResolution.x) + s.x);\n    s.yzw = s.x + uvec3(1, 2, 3);\n    //  Hash coordinates used in the state\n    //  This is what decorrelates the different parts of the state\n    hash(s);\n    \n    s += uvec4(iFrame, iFrame + 1, iFrame + 2, iFrame + 3);\n    \n    hash(s);\n    \n    \n    // HERE: change wavelength bounds if desired. currently encompasses most of the visible range.\n    vec2 wavelength_bounds = vec2(400, 780);\n    vec4 samples = tofloat(uvec4(next2(s), next2(s)));\n    \n    // kinda unfortunate we only use one float, but it improves color noise so it's worth it (probably)\n    vec4 lambda = distribute_wavelengths(samples.x, wavelength_bounds);\n    \n    \n    float boost_const = 1.0f;\n    float specular_offset = 0.01f;\n    \n    // apparently soapy water has an index of refraction of about 1.2\n    float index_of_refraction = 1.2;\n    // film width variables are in nanometers\n    float max_film_width = 3000.0;\n    \n    float film_thickness_01 = 1.0 - uv.y;\n    float film_thickness = 100.0 + film_thickness_01 * max_film_width;\n    \n    \n    \n    // raw spectral response wrt lambda\n    vec4 col_raw;\n    if (USE_FRAUNHOFFER) {\n        float period = 0.1;\n        col_raw = specular_offset + boost_const * Fraunhoffer(lambda, uv.x * period, 50.0 / period, 5000.0 / period); //all constants here are arbitrary and depend on the interferometer geometry\n    } else {\n        if (uv.x < 0.5) {\n            // left half, don't use theta 2\n            col_raw = specular_offset +  film_interference(lambda, 0.0, film_thickness, index_of_refraction, true );\n        } else {\n            // right half, use theta 2\n            // light angle and view angle matter, somewhat.\n            float theta_2 = calculate_theta_2(1.0 - uv.y, 1.0, 2.0);\n            col_raw = specular_offset +  film_interference(lambda, theta_2, film_thickness, index_of_refraction, true );\n        }\n        \n    }\n    \n    // spectral data converted to CIE XYZ\n    vec4 col_xyz = wavelength_to_xyz(lambda.x) * col_raw.x;\n    col_xyz += wavelength_to_xyz(lambda.y) * col_raw.y;\n    col_xyz += wavelength_to_xyz(lambda.z) * col_raw.z;\n    col_xyz += wavelength_to_xyz(lambda.w) * col_raw.w;\n    \n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    if( iFrame==0 ) {\n        data = vec4(0.0);\n    }\n    data += col_xyz;\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}