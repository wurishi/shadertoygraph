{"ver":"0.1","info":{"id":"7tSGRG","date":"1625304477","viewed":351,"name":"Sierpinski's Experiment","username":"smjty","description":"Keep opening the Sierpinski's triangle. If you like to see a more simplified version, delete two lines I've pointed out in the code","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["fractal","triangle","animation","loop","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Twitter: @smjtyazdi\n#define PI 3.14159265\nconst float scale = 0.1;\n\nvec2 trans(vec2 p){\n    vec2 a = vec2(1.,0.);\n    vec2 b = vec2(0.5,0.5*sqrt(3.));\n    float ab = dot(a,b);\n    \n    float aa = (dot(p,a) - dot(p,b)*ab) / ( 1. - ab*ab);\n    float bb = (dot(p,b) - dot(p,a)*ab) / ( 1. - ab*ab);\n    \n    return vec2(aa,bb);\n}\n\nvec2 rot(vec2 p ,float t){\n    return vec2(p.x*cos(t) + p.y*sin(t) , p.y*cos(t)-p.x*sin(t));\n}\n\nfloat sierp2(vec2 p,float kk){\n\n    float col = 1.;\n    \n    vec2 base = vec2(0.);\n    float scale = 1.;\n    \n    for(float k=0.;k<kk;k+=1.){\n        vec2 g = trans(p-base)*scale;\n        scale*=2.;\n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n        g.x += -1.;\n\n        base += vec2(1.,0.)/scale*2.;\n\n        \n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n        g.x +=1.;\n        g.y += -1.;\n        base += vec2(-0.5,0.5*sqrt(3.))/scale*2.;\n\n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n       col = 1.;\n        \n        break;\n    }\n    \n    \n    return col;\n}\n\nfloat sierp_mix(vec2 p,float time){\n    return mix(sierp2(p,4.),sierp2(p,5.),time);\n}\n\n\nfloat render(vec2 p,float time){\n \n    float col = 1.;\n    \n    float time_ind = floor(time);\n    time = mod(time,1.);\n    \n    \n    time = 0.5 - 0.5*cos(time*PI);\n    \n    p = rot(p,2.*PI/3.*mod(time_ind,3.)); //Delete this if you like to see the simplified version\n    \n    float tt = PI/3.*(-time);\n    p.y += sin(PI/3.)*2./3.;\n    \n    p *= exp(-(time)*log(2.));\n    \n    \n    \n    float d = 1. + 2.*cos(tt+PI/3.);\n    float dy= sqrt(3.)*1.0 + 2.*sin(tt+PI/3.);\n    \n    float ind = mod(round(p.x/d)+1.,2.)*2.-1.;\n    float indy = mod(round(p.y/dy)+1.,2.)*2.-1.;\n    p.x = p.x - round(p.x/d)*d;\n    p.y = p.y - round(p.y/dy)*dy; //Delete this if you like to see the simplified version\n    p.y *= ind*indy;\n  \n    col = sierp_mix(rot(p-vec2(-d/2.,0.),tt)*2.,time)*sierp_mix(rot(p-vec2(d/2.,0.),PI-tt-PI/3.)*2.,time)*sierp_mix((p-vec2(-0.5,sin(tt+PI/3.)))*2.,time);\n  \n    \n    return col;\n}\n\n\nfloat rend(vec2 p ,float time){\n    float d = 1./(scale*iResolution.y)/2.;\n    return (render(p,time)+render(p+vec2(d,0.),time)+render(p+vec2(0.,d),time)+render(p+vec2(d),time))/4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   vec2 p = (fragCoord.xy  - iResolution.xy/2.0)/(scale*iResolution.y);\n   \n\n   float time = iTime;\n   \n   \n   vec3 col;\n   \n   for(float k=0.;k<3.;k+=1.){\n       float res = rend(p,time-k/3./60.);\n       \n       if(k==2.)col.x=1.-res;\n       if(k==1.)col.y=1.-res;\n       if(k==0.)col.z=1.-res;\n   }\n   \n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}