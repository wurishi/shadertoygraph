{"ver":"0.1","info":{"id":"Ddf3RN","date":"1676228482","viewed":73,"name":"spline library/graphing calc","username":"16807","description":"I wrote this since I wanted to build a library of splines in glsl and needed a shader that could troubleshoot them. Click the screen to pan. Each dot marks a distance of 1 unit. \n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spline","splines","graphingcalculator","polynomial","polynomials","graphiccalculator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat linear_polynomial_call(in float[2] p, in float x)\n{\n    return p[0] + x*p[1];\n}\n\nfloat quadratic_polynomial_call(in float[3] p, in float x)\n{\n    return p[0] + x*(p[1] + x*p[2]);\n}\n\nfloat cubic_polynomial_call(in float[4] p, in float x)\n{\n    return p[0] + x*(p[1] + x*(p[2] + x*p[3]));\n}\n\nfloat quartic_polynomial_call(in float[5] p, in float x)\n{\n    return p[0] + x*(p[1] + x*(p[2] + x*(p[3] + x*p[4])));\n}\n\nfloat quintic_polynomial_call(in float[6] p, in float x)\n{\n    return p[0] + x*(p[1] + x*(p[2] + x*(p[3] + x*(p[4] + x*p[5]))));\n}\n\n\n\nfloat[3] linear_polynomial_integral(in float[2] p, in float x)\n{\n    return float[3](0.0, p[0], p[1]/2.0);\n}\n\nfloat[4] quadratic_polynomial_integral(in float[3] p, in float x)\n{\n    return float[4](0.0, p[0], p[1]/2.0, p[2]/3.0);\n}\n\nfloat[5] cubic_polynomial_integral(in float[4] p, in float x)\n{\n    return float[5](0.0, p[0], p[1]/2.0, p[2]/3.0, p[3]/4.0);\n}\n\nfloat[6] quartic_polynomial_integral(in float[5] p, in float x)\n{\n    return float[6](0.0, p[0], p[1]/2.0, p[2]/3.0, p[3]/4.0, p[4]/5.0);\n}\n\nfloat[7] quintic_polynomial_integral(in float[6] p, in float x)\n{\n    return float[7](0.0, p[0], p[1]/2.0, p[2]/3.0, p[3]/4.0, p[4]/5.0, p[5]/6.0);\n}\n\n\nfloat linear_polynomial_derivative(in float[2] p, in float x)\n{\n    return p[1];\n}\n\nfloat[2] quadratic_polynomial_derivative(in float[3] p, in float x)\n{\n    return float[2](p[1], 2.0*p[2]);\n}\n\nfloat[3] cubic_polynomial_derivative(in float[4] p, in float x)\n{\n    return float[3](p[1], 2.0*p[2], 3.0*p[3]);\n}\n\nfloat[4] quartic_polynomial_derivative(in float[5] p, in float x)\n{\n    return float[4](p[1], 2.0*p[2], 3.0*p[3], 4.0*p[4]);\n}\n\nfloat[5] quintic_polynomial_derivative(in float[6] p, in float x)\n{\n    return float[5](p[1], 2.0*p[2], 3.0*p[3], 4.0*p[4], 5.0*p[5]);\n}\n\n\nfloat[2] linear_polynomial_compose(in float[2] p, in float x0)\n{\n    return float[2](\n        p[0]+p[1]*x0, \n             p[1]);\n}\nfloat[3] quadratic_polynomial_compose(in float[3] p, in float x0)\n{\n    return float[3](\n        p[0] +p[1]*x0 +p[2]*x0*x0, \n              p[1]    +p[2]*x0,\n                       p[2]\n    );\n}\nfloat[4] cubic_polynomial_compose_offset(in float[4] p, in float x0)\n{\n    return float[4](\n        p[0] +p[1]*x0 +    p[2]*x0*x0 +    p[3]*x0*x0*x0,\n              p[1]    +2.0*p[2]*x0    +3.0*p[3]*x0*x0,\n                           p[2]       +3.0*p[3]*x0,\n                                           p[3]\n    );\n}\nfloat[5] quartic_polynomial_compose_offset(in float[5] p, in float x0)\n{\n    return float[5](\n        p[0] +p[1]*x0 +    p[2]*x0*x0 +    p[3]*x0*x0*x0 +    p[4]*x0*x0*x0*x0,\n              p[1]    +2.0*p[2]*x0    +3.0*p[3]*x0*x0    +4.0*p[4]*x0*x0*x0,\n                           p[2]       +3.0*p[3]*x0       +6.0*p[4]*x0*x0,\n                                           p[3]          +4.0*p[4]*x0,\n                                                              p[4]\n    );\n}\nfloat[6] quintic_polynomial_compose_offset(in float[6] p, in float x0)\n{\n    return float[6](\n        p[0] +p[1]*x0 +    p[2]*x0*x0 +    p[3]*x0*x0*x0 +    p[4]*x0*x0*x0*x0 +    p[5]*x0*x0*x0*x0*x0,\n              p[1]    +2.0*p[2]*x0    +3.0*p[3]*x0*x0    +4.0*p[4]*x0*x0*x0    +5.0*p[5]*x0*x0*x0*x0,\n                           p[2]       +3.0*p[3]*x0       +6.0*p[4]*x0*x0      +10.0*p[5]*x0*x0*x0,\n                                           p[3]          +4.0*p[4]*x0         +10.0*p[5]*x0*x0,\n                                                              p[4]             +5.0*p[5]*x0,\n                                                                                    p[5]\n    );\n}\n\nfloat[2] linear_newton_polynomial(\n    in float x1, \n    in float x2,\n    in float y1, \n    in float y2\n){\n    float dfdx = (y2-y1) / (x2-x1);\n    return float[2](y1-x1*dfdx, dfdx);\n}\n\nfloat[3] quadratic_newton_polynomial(\n    in float x1, \n    in float x2, \n    in float x3,\n    in float y1, \n    in float y2, \n    in float y3\n){\n    float dydx_12  = (y2-y1) / (x2-x1);\n    float dydx_23  = (y3-y2) / (x3-x2);\n    float dy2dx2 = (dydx_23-dydx_12) / (x3-x1);\n    return float[3](\n        y1 - dydx_12*x1 + dy2dx2*x1*x2,\n             dydx_12    - dy2dx2*x1    \n                        - dy2dx2*x2,\n             dy2dx2\n    );\n}\n\nfloat[4] cubic_newton_polynomial(\n    in float x1, \n    in float x2, \n    in float x3,\n    in float x4,\n    in float y1, \n    in float y2, \n    in float y3,\n    in float y4\n){\n    float dydx_12 = (y2-y1) / (x2-x1);\n    float dydx_23 = (y3-y2) / (x3-x2);\n    float dydx_34 = (y4-y3) / (x4-x3);\n    float dy2dx2_13 = (dydx_23-dydx_12) / (x3-x1);\n    float dy2dx2_24 = (dydx_34-dydx_23) / (x4-x2);\n    float dy3dx3    = (dy2dx2_24-dy2dx2_13) / (x4-x1);\n    return float[4](\n        y1 - dydx_12*x1 + dy2dx2_13*x1*x2 - dy3dx3*x1*x2*x3,\n             dydx_12    - dy2dx2_13*x1\n                        - dy2dx2_13*x2    + dy3dx3*x1*x2\n                                          + dy3dx3*x1*x3\n                                          + dy3dx3*x2*x3,\n                          dy2dx2_13       - dy3dx3*x1\n                                          - dy3dx3*x2\n                                          - dy3dx3*x3,\n                                            dy3dx3\n    );\n}\n\n\n/* \nNOTE: The following is an alternate implementation to \"cubic_spline()\".\nIt avoids a call to inverse() that should in principle make it faster,\nand it provides a good way to verify other spline functions, \nhowever its implementation is more complex and cannot be easily adapted to higher order splines.\n*/\nfloat[4] cubic_algebraic_spline(\n    in float x0, // lower bound of spline\n    in float x1, // upper bound of spline\n    in float y0, // value of y at x1\n    in float y1, // value of y at x1\n    in float d0, // derivative of y at x0\n    in float d1  // derivative of y at x1\n){\n    /*\n    First, we construct a new coordinate system based around (x0,y0) as the origin. \n    In this coordinate system, the coordinates (x1,y1) are denoted (X,Y).\n    */\n    float Y = y1-y0;\n    float X = x1-x0;\n    /*\n    in the new coordinate system, we know that x0=0 and y0=0, \n    so we can adopt a simpler system of equations:\n       Y =  aX² +  cX³\n      d1 = 2aX  + 3cX²\n    we divide Y and d1 by X² and X respectively to get:\n       Y =  a +  cX\n      d1 = 2a + 3cX\n    */\n    float u = (Y-d0*X)/(X*X);\n    float v = (d1-d0)/X;\n    /*\n    We then solutions for this system of equations, which results in a polynomial Ax+Bx²+Cx³:\n    */\n    float A = d0;\n    float B = (3.0*u-v);\n    float C = ((v-2.0*u)/X);\n    /*\n    The polynomial above is composed with (x-x0) and the result is offset by y0, \n    which returns us to the original coordinate system.\n    We perform function composition manually to avoid constructing arrays twice.\n    */\n    return float[4](\n        y0 -A*x0 +B*x0*x0  -C*x0*x0*x0,\n            A    -B*x0*2.0 +C*x0*x0*3.0,\n                 +B        -C*x0*3.0,\n                           +C\n    );\n    //return quadratic_polynomial_compose_offset(float[4](y0,A,B,C), -x0);\n}\n\n\n\n\n\nvec2 spline_sample_factors(vec2 exponents, float x)\n{\n    return vec2(\n        pow(x, exponents.x),\n        pow(x, exponents.y)\n    );\n}\n\nvec2 spline_derivative_factors(vec2 exponents, float x)\n{\n    return vec2(\n        exponents.x * pow(x, exponents.x-1.0),\n        exponents.y * pow(x, exponents.y-1.0)\n    );\n}\n\nvec2 spline_2nd_derivative_factors(vec2 exponents, float x)\n{\n    return vec2(\n        (exponents.x-1.0) * exponents.x * pow(x, exponents.x-2.0),\n        (exponents.y-1.0) * exponents.y * pow(x, exponents.y-2.0)\n    );\n}\n\nvec2 spline_integral_factors(vec2 exponents, float x)\n{\n    return vec2(\n        pow(x, exponents.x+1.0) / (exponents.x+1.0),\n        pow(x, exponents.y+1.0) / (exponents.y+1.0)\n    );\n}\n\n\nvec3 spline_sample_factors(vec3 exponents, float x)\n{\n    return vec3(\n        pow(x, exponents.x),\n        pow(x, exponents.y),\n        pow(x, exponents.z)\n    );\n}\n\nvec3 spline_derivative_factors(vec3 exponents, float x)\n{\n    return vec3(\n        exponents.x * pow(x, exponents.x-1.0),\n        exponents.y * pow(x, exponents.y-1.0),\n        exponents.z * pow(x, exponents.z-1.0)\n    );\n}\n\nvec3 spline_2nd_derivative_factors(vec3 exponents, float x)\n{\n    return vec3(\n        (exponents.x-1.0) * exponents.x * pow(x, exponents.x-2.0),\n        (exponents.y-1.0) * exponents.y * pow(x, exponents.y-2.0),\n        (exponents.z-1.0) * exponents.z * pow(x, exponents.z-2.0)\n    );\n}\n\nvec3 spline_integral_factors(vec3 exponents, float x)\n{\n    return vec3(\n        pow(x, exponents.x+1.0) / (exponents.x+1.0),\n        pow(x, exponents.y+1.0) / (exponents.y+1.0),\n        pow(x, exponents.z+1.0) / (exponents.z+1.0)\n    );\n}\n\nvec4 spline_sample_factors(vec4 exponents, float x)\n{\n    return vec4(\n        pow(x, exponents.x),\n        pow(x, exponents.y),\n        pow(x, exponents.z),\n        pow(x, exponents.w)\n    );\n}\n\nvec4 spline_derivative_factors(vec4 exponents, float x)\n{\n    return vec4(\n        exponents.x * pow(x, exponents.x-1.0),\n        exponents.y * pow(x, exponents.y-1.0),\n        exponents.z * pow(x, exponents.z-1.0),\n        exponents.w * pow(x, exponents.w-1.0)\n    );\n}\n\nvec4 spline_2nd_derivative_factors(vec4 exponents, float x)\n{\n    return vec4(\n        (exponents.x-1.0) * exponents.x * pow(x, exponents.x-2.0),\n        (exponents.y-1.0) * exponents.y * pow(x, exponents.y-2.0),\n        (exponents.z-1.0) * exponents.z * pow(x, exponents.z-2.0),\n        (exponents.w-1.0) * exponents.w * pow(x, exponents.w-2.0)\n    );\n}\n\nvec4 spline_integral_factors(vec4 exponents, float x)\n{\n    return vec4(\n        pow(x, exponents.x+1.0) / (exponents.x+1.0),\n        pow(x, exponents.y+1.0) / (exponents.y+1.0),\n        pow(x, exponents.z+1.0) / (exponents.z+1.0),\n        pow(x, exponents.w+1.0) / (exponents.w+1.0)\n    );\n}\n\n\nfloat[4] cubic_spline(\n        in float xa,     in float xb,\n        in float ya,     in float yb,\n        in float ya_ddx, in float yb_ddx){\n    float b = xb-xa;\n    vec2 exponents = vec2(2,3);\n    vec2 known_outputs = vec2(\n        yb - ya - ya_ddx*b,\n        yb_ddx  - ya_ddx\n    );\n    mat2 known_factors = transpose(\n        mat2(\n            spline_sample_factors    (exponents, b),\n            spline_derivative_factors(exponents, b)\n        )\n    );\n    vec2 k2k3 = inverse(known_factors) * known_outputs;\n    return cubic_polynomial_compose_offset(\n        float[4](ya, ya_ddx, k2k3.x, k2k3.y), \n        -xa);\n}\n\nfloat[5] quartic_spline_with_known_midpoint(\n        in float xa,     in float xb, in float xc,\n        in float ya,     in float yb, in float yc,\n        in float ya_ddx,              in float yc_ddx){\n    float b = xb-xa;\n    float c = xc-xa;\n    vec3 exponents = vec3(2,3,4);\n    vec3 known_outputs = vec3(\n        yb - ya - ya_ddx*b,\n        yc - ya - ya_ddx*c,\n        yc_ddx  - ya_ddx\n    );\n    mat3 known_factors = transpose(\n        mat3(\n            spline_sample_factors    (exponents, b),\n            spline_sample_factors    (exponents, c),\n            spline_derivative_factors(exponents, c)\n        )\n    );\n    vec3 k2k3k4 = inverse(known_factors) * known_outputs;\n    return quartic_polynomial_compose_offset(\n        float[5](ya, ya_ddx, k2k3k4.x, k2k3k4.y, k2k3k4.z), \n        -xa);\n}\n\nfloat[6] quintic_spline_with_2_known_midpoints(\n        in float xa,     in float xb, in float xc, in float xd,\n        in float ya,     in float yb, in float yc, in float yd,\n        in float ya_ddx,                           in float yd_ddx){\n    float b = xb-xa;\n    float c = xc-xa;\n    float d = xd-xa;\n    vec4 exponents = vec4(2,3,4,5);\n    vec4 known_outputs = vec4(\n        yb - ya - ya_ddx*b,\n        yc - ya - ya_ddx*c,\n        yd - ya - ya_ddx*d,\n        yd_ddx  - ya_ddx\n    );\n    mat4 known_factors = transpose(\n        mat4(\n            spline_sample_factors    (exponents, b),\n            spline_sample_factors    (exponents, c),\n            spline_sample_factors    (exponents, d),\n            spline_derivative_factors(exponents, d)\n        )\n    );\n    vec4 k2k3k4k5 = inverse(known_factors) * known_outputs;\n    return quintic_polynomial_compose_offset(\n        float[6](ya, ya_ddx, k2k3k4k5.x, k2k3k4k5.y, k2k3k4k5.z, k2k3k4k5.w),\n        -xa);\n}\n\n\nfloat[6] quintic_spline(\n        in float xa,       in float xb,\n        in float ya,       in float yb,\n        in float ya_ddx,   in float yb_ddx,\n        in float ya_d2dx2, in float yb_d2dx){\n    float b = xb-xa;\n    vec3 exponents = vec3(3,4,5);\n    vec3 known_outputs = vec3(\n        yb      - ya - ya_ddx*b -      ya_d2dx2*b*b,\n        yb_ddx       - ya_ddx   -  2.0*ya_d2dx2*b,\n        yb_d2dx                 -      ya_d2dx2\n    );\n    mat3 known_factors = transpose(\n        mat3(\n            spline_sample_factors        (exponents, b),\n            spline_derivative_factors    (exponents, b),\n            spline_2nd_derivative_factors(exponents, b)\n        )\n    );\n    vec3 k3k4k5 = inverse(known_factors) * known_outputs;\n    return quintic_polynomial_compose_offset(\n        float[6](ya, ya_ddx, ya_d2dx2, k3k4k5.x, k3k4k5.y, k3k4k5.z),\n        -xa);\n}\n\nfloat[6] quintic_spline_with_known_midpoint(\n        in float xa,     in float xb,     in float xc,\n        in float ya,     in float yb,     in float yc,\n        in float ya_ddx, in float yb_ddx, in float yc_ddx){\n    float b = xb-xa;\n    float c = xc-xa;\n    vec4 exponents = vec4(2,3,4,5);\n    vec4 known_outputs = vec4(\n        yb - ya - ya_ddx*b,\n        yc - ya - ya_ddx*c,\n        yb_ddx  - ya_ddx,\n        yc_ddx  - ya_ddx\n    );\n    mat4 known_factors = transpose(\n        mat4(\n            spline_sample_factors    (exponents, b),\n            spline_sample_factors    (exponents, c),\n            spline_derivative_factors(exponents, b),\n            spline_derivative_factors(exponents, c)\n        )\n    );\n    vec4 k2k3k4k5 = inverse(known_factors) * known_outputs;\n    return quintic_polynomial_compose_offset(\n        float[6](ya, ya_ddx, k2k3k4k5.x, k2k3k4k5.y, k2k3k4k5.z, k2k3k4k5.w),\n        -xa);\n}\n\n\nfloat F(float x)\n{\n    return sin(x);\n}\nfloat dFdx_(float x)\n{\n    return cos(x);\n}\nfloat d2Fdx2(float x)\n{\n    return -sin(x);\n}\n\nfloat G(float x)\n{\n    /*\n    */\n    return quintic_polynomial_call(\n        quintic_spline_with_known_midpoint(\n            1.0,        2.0,        3.0, \n            F(1.0),     F(2.0),     F(3.0), \n            dFdx_(1.0), dFdx_(2.0), dFdx_(3.0)), \n        x\n    );\n    return quintic_polynomial_call(\n        quintic_spline(\n            1.0,        3.0, \n            F(1.0),     F(3.0), \n            dFdx_(1.0), dFdx_(3.0),\n            d2Fdx2(1.0),d2Fdx2(3.0)),\n        x\n    );\n    return quintic_polynomial_call(\n        quintic_spline_with_2_known_midpoints(\n            1.0,   1.6,   2.3,   3.0,\n            F(1.0),F(1.6),F(2.3),F(3.0),\n            dFdx_(1.0),          dFdx_(3.0)),\n        x\n    );\n    return quartic_polynomial_call(\n        quartic_spline_with_known_midpoint(\n            1.0,        2.0,    3.0, \n            F(1.0),     F(2.0), F(3.0), \n            dFdx_(1.0),         dFdx_(3.0)),\n        x\n    );\n    return cubic_polynomial_call(\n        cubic_spline(\n            1.0,       3.0, \n            F(1.0),    F(3.0), \n            dFdx_(1.0),dFdx_(3.0)),\n        x\n    );\n    return cubic_polynomial_call(\n        cubic_algebraic_spline(\n            1.0,       3.0, \n            F(1.0),    F(3.0), \n            dFdx_(1.0),dFdx_(3.0)),\n        x\n    );\n    return cubic_polynomial_call(\n        cubic_newton_polynomial(\n            1.0,   1.6,   2.3,   3.0,\n            F(1.0),F(1.6),F(2.3),F(3.0)),\n        x\n    );\n    return quadratic_polynomial_call(\n        quadratic_newton_polynomial(\n            1.0,   2.0,   3.0,\n            F(1.0),F(2.0),F(3.0)),\n        x\n    );\n    return linear_polynomial_call(\n        linear_newton_polynomial(\n            1.0,   2.0,\n            F(1.0),F(2.0)),\n        x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_mouse = iMouse.xy/iResolution.xy;\n    vec2 xy_mouse = 2.0*uv_mouse - 1.0;\n    vec2 xy = 2.0*uv - 1.0 -xy_mouse;              // origin of coordinate system is at the center of the screen\n    xy.x *= iResolution.x/iResolution.y; // coordinate system is scaled so that units of x and y appear equal of length on the screen\n    xy   *= 5.0;                         // zoom out\n    float x = xy.x;                      // declare convenience variables, x and y\n    float y = xy.y;\n    \n    const float tick_width = 0.05;\n    const float line_width = 0.05;\n    \n    if (distance(round(xy),xy) < tick_width)\n    {\n        fragColor= vec4(abs(x*y)<0.5? 1.0 : 0.2);\n    }\n    else if (distance(F(x),y) < line_width)\n    {\n        fragColor=vec4(1,0,0,1);\n    }\n    else if (distance(G(x),y) < line_width)\n    {\n        fragColor=vec4(0,1,0,1);\n    }\n    else \n    {\n        fragColor = vec4(0);\n    }\n}","name":"Image","description":"","type":"image"}]}