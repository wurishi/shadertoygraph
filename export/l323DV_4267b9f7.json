{"ver":"0.1","info":{"id":"l323DV","date":"1712050462","viewed":23,"name":"3D Aniamted Sphere CHESS LIGHT","username":"Samuix","description":"3D RED ANIMATED SPHERE ON CHESS TABLE WITH LIGHT CASTING BUT WITHOUT SPHERE SHADOW","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3dspherechesslightcasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\nfloat depth = 1.0;\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n//##############################################################################################\n\nfloat raySphere( vec3 rayPos ,vec3 rayDir, vec3 spherePos, float sphereRadius,out vec3 intersecPt, out vec3 normal)\n{\n    float I = 0.0;\n\n    //vec3 CA = rayPos - spherePos;\n    vec3 AC = spherePos - rayPos;\n\n\n    // R² - ((AC.AC) - v²)\n    // v² = dot(CA,rayDir)*dot(CA,rayDir)\n    \n    float V = dot(AC,rayDir);\n    float disc = sphereRadius * sphereRadius - (dot(AC,AC) - V*V);\n    \n    if(disc >= 0.0)\n    {\n        float d = sqrt(disc);\n        intersecPt = rayPos + (V - d)*rayDir;\n        normal = normalize(intersecPt - spherePos);\n\n    }\n    \n    return disc;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    //axes of the camera\n    vec3 cz = normalize(cameraPos - cameraTarget); // camera looking at, on the z axe so -> its the z axe for the rayDir\n    vec3 cx = normalize(cross(cz,vec3(0,1,0))); // X axe determined by a temporary axe and cross product\n    vec3 cy = normalize(cross(cz,cx)); // Y axe calculed by cross product\n    \n    // focal distance\n    float f = depth/(tan(cameraFovY/2.0));\n    \n    // rayPos -> where the ray start (from the cam)\n    rayPos = cameraPos; // from where the ray starts\n\n   // pixCoord = vec2(f*pixCoord.x/,f*pixCoord.y)\n    //rayDirpixCoord\n    vec3 PO = f*cz;\n    vec3 OS = pixCoord.x*cx - pixCoord.y*cy;\n    \n    rayDir = normalize(PO + OS);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 Ia = ambiantCol * objectMat.Ka;\n    vec3 Id = lightCol * objectCol * objectMat.Kd * max(dot(L,N),0.0);\n    vec3 Is = lightCol * objectMat.Ks * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    //vec3 Is = vec3(0.,0.,0.);\n\n    vec3 I = Ia + Id + Is;\n    \n    return I;\n}\n\n//##############################################################################################\n//##############################################################################################\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n vec2 apply_transform(vec2 point){\n    point = (2.*point.xy - iResolution.xy)/iResolution.y;\n    return vec2(point.x,point.y);\n}\n\n \n//----------------------------------------------------------------------------------------------\n \n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n \n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n\t// Test ray-sphere intersection and get the intersection point and associated normal\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    \n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    \n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n \n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n \n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    animateScene(time*1.0);\n\n\n    //lightPos.z = cameraPos.x + apply_transform(iMouse.xy).x*iResolution.y;\n    //lightPos.y = cameraPos.y + apply_transform(iMouse.xy).y*iResolution.y;\n\n    fragCoord = apply_transform(fragCoord.xy);\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\t// Test ray-sphere intersection and get the intersection point and associated normal\n    // vec3 intersecS, normalS;\n    //float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    \n   vec3 intersecI, normalI;\n     int objectId;\n    float dist = computeNearestIntersection(rayPos,rayDir, objectId, intersecI, normalI);\n    \n    Material objectMat;\n    vec3 color = getObjectColorAtPoint(objectId,intersecI,objectMat);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (dist > 0.0)\n    {\n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos- intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n        //vec3 R = normalize(reflect(L,normalS));\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -normalize(rayDir);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \tfragColor = vec4(computePhongShading(color, objectMat, normalI, L, R, V), 1);\n        //fragColor = vec4(1, 0, 0, 1);\n\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n        fragColor = vec4(color, 1);\n        \n    //fragColor = vec4((distS > 0.0 ? 1.0 : 0.0), 0, 0, 1);\n\n}","name":"Image","description":"","type":"image"}]}