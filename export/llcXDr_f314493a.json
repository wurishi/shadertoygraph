{"ver":"0.1","info":{"id":"llcXDr","date":"1491557459","viewed":189,"name":"Fluid sphere","username":"decrooks","description":"Fluid sphere","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","sphere","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n};\n    \nstruct MapValue {\n    float \t  signedDistance;\n    vec2 texCoord;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    Ray \t ray;\n    Material material;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\n\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\n\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0);\n    whiteMat = Material(LightColor(0.75*vec3(1.0,1.0,0.9),0.3*vec3(1.0,1.0,0.9)) ,shininess );\n\n}\n\n/////////////////////////   SDFs   ///////////////////////////////////\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  p -= center;\n  float r =   length(p);\n  mv.texCoord = vec2(0.5+ atan(p.y,p.x)/TWO_PI, acos(p.z/r)/PI);\n  mv.signedDistance = r - radius;\n  return mv;\n}\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Map The Scene ////////////////////////////////\n\nMapValue map(vec3 p){\n   \tfloat t  = iTime;\n   \t\n    \n \n  MapValue obj  = sphere(p,vec3(0.0),0.5, whiteMat);\n    \n   \n    \n  return obj;\n}\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Raytracing ///////////////////////////////////\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    \n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion || dist>maxDistance) break;\n       \n    }\n    \n    vec4 color = texture(iChannel0,mv.texCoord);\n    mv.material.color.diffuse = color.rgb;\n    \n    return Trace(dist,p,ray,mv.material);\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = traceRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,0.0,1.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\n/////////////////////// Lighting ////////////////////////////////\n\nvec3 diffuseLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\nvec3 specularLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    //blinn-phong\n    //https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 viewDir = -trace.ray.direction;\n\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(halfDir, normal), 0.0);\n    float specular = pow(specAngle, trace.material.shininess);\n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\nvec3 pointLighting(in Trace trace, vec3 normal, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, normal, light.color.diffuse, lightDir);\n    \n   \n     color += specularLighting(trace, normal, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, vec3 normal, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, normal, light.color.diffuse, light.direction);\n    \n    color += specularLighting(trace, normal, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(0.3);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(0.3),specular));\n  \t//light2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(0.6),specular)); \n   // light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    dirLight = DirectionalLight(normalize(vec3(-2.0,0.5,1.0)),LightColor(vec3(1.0),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace, vec3 normal){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, normal,light1);\n\tcolor += pointLighting(trace, normal,light2) ;\n    color += pointLighting(trace, normal,light3) ;\n\tcolor += directionalLighting(trace, normal,dirLight);\n    \n    return color;\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,0.0,0.0);\n    \n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,1.3);\n   \tTrace trace = traceRay(ray,12.0);\n    \n    \n    \n\tvec3 normal = calculateNormal(trace.p);\n    vec3 color = lighting(trace,normal);\n    \n   \treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n  \n \n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Spherical Fluid Simulation\n\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define TWO_PI 2.0*3.14159265359\n\nvec3 random3(vec3 v) {\n\tv  =   v.xyz*vec3(18.9898,78.233,63.341) \n         + v.zxy*vec3(26.91133,36.311343,23.311417) \n         + v.yzx*vec3(19.6785,14.91741,20.141237);\n    vec3 result = -1.0 + 2.0*fract(sin(v)*76123.512378);\n    return result.zxy;\n}\n\n\nvec3 quinticSmoothstep(vec3 u){\n    return u*u*u*(u*(u*6.0-15.0)+10.0);\n}\n\nvec3 smoothstepDerivitive(vec3 u){\n    return 30.0*u*u*(u*(u-2.0)+1.0);\n}\n\nvec4 gradientNoiseD(vec3 v){\n    \n    //https://iquilezles.org/articles/morenoise\n    vec3 i = floor(v);\n    vec3 f = fract(v);\n    //vec3 s = smoothstep(0.0,1.0,f);\n   \tvec3 s = quinticSmoothstep(f);\n    vec3 ds = smoothstepDerivitive(f);\n    \n    float a000 = dot(random3(i),f);\n    float a100 = dot(random3(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0));\n    float a010 = dot(random3(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0));\n    float a001 = dot(random3(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0));\n    float a110 = dot(random3(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0));\n    float a101 = dot(random3(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0));\n    float a011 = dot(random3(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0));\n    float a111 = dot(random3(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0));\n   \n \n    vec3 k1;\n    k1.x = a100 - a000;//1\n    k1.y = a010 - a000;//2\n    k1.z = a001 - a000;//3\n    \n    vec3 k2;\n    k2.x = a000 - a100 -a010 + a110;//4\n    k2.y = a000 - a001 -a010 + a011;//5\n    k2.z = a000 - a001 -a100 + a101;//6\n    \n    float k3 = -a000 + a100 +a010 + a001 - a110 - a101 - a011 + a111;\n    \n    vec4 result;\n    result.x = a000 + dot(k1,s) + k2.x*s.x*s.y + k2.y*s.y*s.z + k2.z*s.z*s.x + k3*s.x*s.y*s.z;\n    \n    //derivitives\n    result.y = ds.x * (k1.x + k2.x*s.y + k2.z*s.z + k3*s.y*s.z);\n    result.z = ds.y * (k1.y + k2.y*s.z + k2.x*s.x + k3*s.z*s.x);\n    result.w = ds.z * (k1.z + k2.z*s.x + k2.y*s.y + k3*s.x*s.y);\n    \n    return result;\n      \n}\n\n\n//time varying fractal noise + derivites dx/dx and dn/dy;\nvec4 noise2td(vec2 v){\n  \n    vec4 value = vec4( 0.0);\n    float a = 0.5;\n   float flowRate = 0.3;\n    float t = flowRate*iTime;\n   //vec3 v3 = vec3(v + flowRate*iTime,flowRate*iTime);\n    \n    \n    vec3 sphere = vec3(sin(v.y)*cos(v.x),sin(v.y)*sin(v.x),cos(v.y));\n    vec3 orbit = vec3(cos(t),sin(t),0.0);\n    vec3 p = orbit + sphere;\n    \n   \tfor(int i=0;i<5;i++){   \n\n        value +=  a*gradientNoiseD(p);\n        v *= 2.0;\n        a *= 0.5;\n    }\n    \n    return value;\n}\n    \n\n/*    \n    The function curlOfNoise() generates a random vector flow field from noise.\n \n    The intuive notion that a vector field is flowing smoothly\n    corresponds to the mathematical condition that it is divergence free:\n \n        Div F = 0\n \n    We can satisfy this condtion by writing F = Curl H because Div Curl H = 0 for any H.  We also want our field to flow in 2d, so we require Fz = 0.\n    Fz depends on the derivites of the x and y components, so setting these to any constant solves this conditon.\n    Setting H = (0,0,E(x,y)) gives:\n \n        F = (dE/dy, -dE/dx,0)\n \n    for any scalar function of x and y.\n    So setting  E(x,y) = noise(x,y) gives a random divergence free flow field, as required.\n \n*/\n\n\nvec2 curlOfNoise(vec2 v) {\n   \t//convert from texture coordinates (x,y) in [0,1] to spherical coordinates (phi,theta) with phi in [-Pi, pi] and theta in [0,pi].\n    v = vec2(TWO_PI*(v.x-0.5),PI*v.y);\n    \n    vec4 n = noise2td(v);\n    \n    //noise returns the derivites in 3d space (dn/dx,dn/dy,dn/dy)\n    vec3 dn_dp = n.yzw;\n    \n    //Find deriviteves in spherical coordinates with chain rule\n    vec3 dp_dtheta = vec3(cos(v.y)*cos(v.x),cos(v.y)*sin(v.x),-sin(v.y));\n    vec3 dp_dphi = vec3(-sin(v.y)*sin(v.x),sin(v.y)*cos(v.x),0.0);\n\n    float dn_dtheta = dot(dn_dp,dp_dtheta);\n    float dn_dphi = dot(dn_dp,dp_dphi);\n    \n    return vec2(dn_dtheta,-dn_dphi);\n}\n\n\n\n\n//Add somme ink to the fluid or there will be nothing to see.\nvoid addInk(inout vec4 color,vec2 v) {\n    float t = iTime;\n    vec2 p = 0.35*vec2(sin(t),cos(t));\n    float d = distance(p,v);\n    if(d<0.01) color = vec4(1.0);\n       \n   \tp = 0.15*(1.0 +0.1*sin( 0.1*t))*vec2(sin(0.55*t),cos(0.55*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(1.0);\n   \n    p = 0.21*(1.0 +0.2*sin( 0.1*t))*vec2(sin(0.4*t),cos(0.4*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(0.0,0.0,1.0,1.0);\n \n    p = 0.25*(1.0 +0.5*sin( 0.15*t))*vec2(sin(0.75*t),cos(0.75*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(0.0,0.0,0.3,1.0);\n    \n    p = 0.2*(1.0 +0.3*sin( 0.1*t))*vec2(sin(0.45*t),cos(0.45*t));\n    d = distance(p,v);\n    if(d<0.03) color = vec4(0.0,0.0,0.0,1.0);\n    \n   // if(abs(v.y) >0.49 )  color = vec4(1.0,1.0,1.0,1.0);\n   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    float advectionRate = 1.5;\n   \tvec2 advection = advectionRate*curlOfNoise(v)+vec2(1.5,0.0);\n    \n    vec2 samplePoint = mod(iResolution.xy + fragCoord.xy + advection ,iResolution.xy);\n    vec2 f = fract(samplePoint);\n    vec2 i = floor(samplePoint);\n    vec2 i00 = i/iResolution.xy;\n    vec2 i10 = mod((i + vec2(1.0,0.0))/iResolution.xy,1.0);\n    vec2 i01 = mod((i + vec2(0.0,1.0))/iResolution.xy,1.0);\n    vec2 i11 = mod((i + vec2(1.0,1.0))/iResolution.xy,1.0);\n    \n    \n    vec4 s00 = texture(iChannel0,i00);\n    vec4 s10 = texture(iChannel0,i10);\n    vec4 s01 = texture(iChannel0,i01);\n    vec4 s11 = texture(iChannel0,i11);\n                   \n    vec4 fluid = mix(mix(s00,s01,f.y),mix(s10,s11,f.y),f.x);\n      \n   \tvec2 u = (fragCoord.xy -0.5*iResolution.xy)/iResolution.y;\n    addInk(fluid,u);\n \n\tfragColor = fluid;\n}","name":"Buf A","description":"","type":"buffer"}]}