{"ver":"0.1","info":{"id":"cdcBRB","date":"1697285385","viewed":33,"name":"RayMarch(RTX)","username":"Tr0y777","description":"im learn GLSL and method ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","rtx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere\nvec4 sph = vec4(.0, .5, .0, .5);\n// Box 1\nvec3 cube1 = vec3(.0, .5, .0);\nvec3 rad1 = vec3(.5, .5, 1.5);\n// Box 2\nvec3 cube2 = vec3(.0, 2., .0);\nvec3 rad2 = vec3(.5, 1., .5);\n// Box 3\nvec3 cube3 = vec3(.0, 3.5, .0);\nvec3 rad3 = vec3(.5, .5, .5);\n\nfloat sdCube(vec3 pos, vec3 cube, vec3 rad) {\n\tpos -= cube;\n\tvec3 d = abs(pos)-rad;\n\treturn length(max(d, .0)) + min(max(d.x, max(d.y, d.z)), .0);\n}\n\nfloat sdSph(vec3 pos) {\n\tpos -= sph.xyz;\n\treturn length(pos) - sph.w;\n}\n\nfloat sdPln(vec3 pos) {\n\treturn pos.y;\n}\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 sdf(vec3 pos) {\n\tvec2 res = vec2(1e10, -1.);\n\n\tres = opU(res, vec2(sdPln(pos), .0));\n\tres = opU(res, vec2(sdSph(pos), 1.));\n\t// res = opU(res, vec2(sdCube(pos, cube1, rad1), 2.));\n\t// res = opU(res, vec2(sdCube(pos, cube2, rad2), 2.));\n\t// res = opU(res, vec2(sdCube(pos, cube3, rad3), 3.));\n\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat t = .0;\n\tfloat eps = .01;\n\tint nul = 500;\n\tfor (int i = 0; i < nul; i++) {\n\t\tvec3 pos = ro + rd*t;\n\t\tvec2 res = sdf(pos);\n\t\tif (res.x < eps) {\n\t\t\treturn vec2(t, res.y);\n\t\t}\n\tt += res.x;\n\t}\n\treturn vec2(t, -1.);\n}\n\nvec3 calcNorm(vec3 pos) {\n\tconst float h = .0001;\n\tconst vec2 k = vec2(1., -1.);\n\n\treturn normalize(k.xyy*sdf(pos + k.xyy*h).x +\n\t\t\t\t\t\t\t\t\tk.yyx*sdf(pos + k.yyx*h).x +\n\t\t\t\t\t\t\t\t\tk.xxx*sdf(pos + k.xxx*h).x +\n\t\t\t\t\t\t\t\t\tk.yxy*sdf(pos + k.yxy*h).x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 light = normalize(vec3(sin(iTime), -.5, cos(iTime)));\n\n\tvec3 ro = vec3(5., 1., .0);\n\tvec3 rd = vec3(-1, (fragCoord.y - iResolution.y / 2.) / iResolution.x, -fragCoord.x / iResolution.x + .5);\n\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n \tfloat m = res.y;\n\n\tvec3 col = vec3(.0, .0, .0);\n\tif (m != -1.) {\n\t\tvec3 pos = ro + rd*t;\n\t\tif (m == .0) {\n            vec3 gridCol = mod(floor(pos.x) + floor(pos.z), 2.) == .0 ? vec3(1.) : vec3(.7, .7, .7);\n\t\t\tcol = gridCol;\n\t\t\tfloat ao = clamp(length(pos.xz)/.3, .0, 1.);\n\t\t\tcol *= .25 + .75*ao;\n\t\t} else if (m == 1.) {\n\t\t\tcol = vec3(1., .0, .0);\n\t\t} else if (m == 2.) {\n\t\t\tcol = vec3(1., .0, .0);\n\t\t} else if (m == 3.) {\n\t\t\tcol = vec3(1., .5, .85);\n\t\t}\n\t\tvec3 nor = calcNorm(pos);\n\n\t\tfloat dif = clamp(dot(nor, -light), .0, 1.);\n\t\tcol = .25*col + .75*col*dif;\n\t}\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}