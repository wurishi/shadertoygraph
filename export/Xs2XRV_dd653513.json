{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// webgl mandelbrot shader test\n// by Franc[e]sco\n// adapted by TekF\n\n#define SPLIT_SCREEN_FAKE_DOUBLE_SINGLE_COMPARE\n\n// my work & home PCs get very different results, so toggle some things\n// it seems to be caused by the precision of the pan value\n#if (1)\n\t// Work PC (GeForce GTX 770)\n\tconst vec4 pan = vec4(-0.31750109, 0.48999993, 0.00000000000000588, .0);\n\tconst float period = 175.0; // higher quality results at this position, so can zoom closer\n#else\n\t//Home PC (Radeon HD 7700)\n\tconst vec4 pan = vec4(-0.3175011, 0.49, .00000000011, .0);\n\tconst float period = 142.0;\n#endif\n\n//const vec4 pan = vec4(-0.300853, 0.441, 0.00000000000000032, -0.0000000000238951); // does anyone have a good point to zoom on?\n//const vec4 pan = vec4(-0.3151, 0.445, 0, -.000000013);\n\n\nconst int maxIterations = 256;\nconst vec3 colourPhase = vec3(5,7,11)/80.0;\nconst vec3 colourPhaseStart = vec3(1);\n\nconst float initialZoom = 3.5;\n\n\nvec2 DoubleMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\t// c = a*b\n\t// (c.y+c.x) = (a.x+a.y)*(b.x+b.y);\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n\t// if we add it to the big, it might lose precision in the middle of the number\n\t// which would be as bad as a float, so:\n\n// trying out some ideas to make the \"doubles\" more robust:\n\t\n// try to add it to c.x, and detect how much underflowed to add to c.y\n// I don't expect this will work, because the compiler will optimise it out\n/*c.x = l+r;\nfloat rf = c.x-l; // the part of r that actually made it after rounding.\nr = r - rf;\nc.y += r;*/\n// note that a.x*b.x already underflows, so using the full precision will make that a more serious problem.\n// => need upper & lower halfs of .x's... uh...\n\nc.x = l;\nc.y += r;\n\n/*\nThis introduces more errors!\ncould try taking the difference between c.x and c.x+r, and that remainder is the value to add to c.y\n// do something more robust, otherwise the vals can both lose too much precision\n\tfloat cp = log2(abs(c.x));\n\tfloat rp = log2(abs(r));\n\tconst float precis = 20.0;\n\tif ( rp > cp-precis )\n\t{\n\t\t// chop rp up into 2 bits, put the bigger bits in the top val\n\t\tfloat cut = exp2(cp-precis);\n\t\tfloat r2 = fract(r/cut)*cut;\n\t\tc.y += r2;\n\t\tc.x += r-r2;\n\t}\n\telse\n\t{\n\t\tc.y += r;\n\t}\n*/\n\treturn c;\n}\n\nvec3 fractal( vec2 pos ) {\n\t\n\t// randomly tweaked the calculations for semi-constant zooming\n\t// I don't really know what I'm doing here, but it works\n\tfloat T = abs(fract((iTime/period)*.5+.5)*2.0-1.0001)*period; // using exactly 1.0 breaks it, I don't know why\n\tfloat zoom = pow(initialZoom, (-T + initialZoom + 1.0) / 5.0);\n\n\tvec4 Z = vec4(0), C = vec4(0);\n\tint iterations;\n\tbool ignore = false;\n\t\n\t// convert to texels, center the set on screen and apply zoom\n\tvec2 pixel;\n\tpixel = (pos / iResolution.xy - 0.5) * zoom; \n    float aspectRatio = iResolution.x / iResolution.y;\n\tpixel.y /= aspectRatio; // fix aspect ratio\n\n\tfloat a = iTime*.05;\n\tpixel = pixel*cos(a)+vec2(1,-1)*sin(a)*pixel.yx;\n\n\n#ifdef SPLIT_SCREEN_FAKE_DOUBLE_SINGLE_COMPARE\n    if (pos.x > iResolution.x / 2.0) {\n\t\tC.xy = pixel;\n    }\n    else {\n        C.zw = pixel;\n    }\n#else\n\tC.zw = pixel;\n#endif\n    \n\tC -= pan;\n\t\n\tfor (int i = 0; i < maxIterations; i++) {\n\t\tif (ignore)\n\t\t\tbreak;\n\t\t\n\t\t// complex number operations\n\t\t// Z = Z*Z + C\n\t\tvec4 Z2;\n\t\t//Z.x * Z.x - Z.y * Z.y, \n\t\tZ2.xz = DoubleMul(Z.xz,Z.xz) - DoubleMul(Z.yw,Z.yw);\n\t\tZ2.yw = 2.0*DoubleMul(Z.xz,Z.yw);\n\t\tZ = Z2 + C; // apply panning\n\t\t\n\t\t// stop immediately if the point is outside a radius of 2 from (0,0) (the bounds of the mandelbrot set)\n\t\t//if ( dot((DoubleMul(Z.xz,Z.xz) + DoubleMul(Z.yw,Z.yw)),vec2(1)) > 4.0 ) // smooth\n\t\tif ( max(abs(dot(Z.xz,vec2(1))),abs(dot(Z.yw,vec2(1)))) > 2.0 ) // scallops\n\t\t\tignore = true;\n\t\t\n\t\titerations = i;\n\t}\n\t\n\t//return pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(2.2));\n\treturn pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(1.5));\n\t//return 1.0-abs(sin(colourPhase.xyz * float(iterations) + colourPhaseStart));//*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//fragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;\n\t\n/*\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.75) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.75) );\n\tfragColor.rgb /= 8.0;*/\n\t\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\n\tfragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs2XRV","date":"1413866545","viewed":236,"name":"Mandelbrot \"doubles\" (split)","username":"rogerdahl","description":"Small modification of [url=https://www.shadertoy.com/view/XdsXWN\"]this shader[/url] by TekF. Adds the split screen feature suggested by iq that lets the single and double precision be compared.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["doubleprecision"],"hasliked":0,"parentid":"","parentname":""}}