{"ver":"0.1","info":{"id":"3ssXRH","date":"1550608576","viewed":1471,"name":"2D global illumination","username":"darkeclipz","description":"Testing 2D global illumination with SDF's.\n\nIdea from https://www.shadertoy.com/view/lldcDf.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","global","illumination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MaxSteps 12.\n#define MinDistance 0.01\n#define Samples 60.\n\nmat2 r2(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}    \n\n// from iq\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 r = abs(p) - b;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n    //vec2 d = abs(p) - b;\n  \t//return length(max(d,0.0));\n}  \n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 lightColor = vec3(0);\nfloat light(vec2 p) {\n    lightColor = vec3(.6,.8,1.);\n    float box = sdBox(p - vec2(1.,0), vec2(.2));\n    float circle = sdCircle(p + vec2(1.,0), .2);\n    if(box > circle) lightColor = vec3(1,.9,.8);\n    return smin(box, circle, 1.);\n}  \n\nfloat centerBox(vec2 p) {\n    p *= r2(iTime);\n\tfloat box = sdBox(p, vec2(.3)); \n    box = max(box, -sdCircle(p - vec2(0,.5), .49) + cos(iTime) * .02);\n    box = max(box, -sdCircle(p - vec2(0,-.5), .49) + cos(iTime) * .02);\n    return box;\n}\n\nvec3 objectColor = vec3(1,0,0);\nint objectId = 0;\nfloat scene(vec2 p) {\n    objectId = 0;\t\n    float box = centerBox(p);\n    float light = light(p);\n    if(box > light) {\n    \tobjectId = 1;\n        objectColor = vec3(0,0,1);\n    }\n    return min(box, light);\n}    \n\n// from iq\nvec2 calcNormal(vec2 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec2 n = normalize( vec2(scene(vec2(p.x + h, p.y)) - scene(vec2(p.x - h, p.y)),\n                      scene(vec2(p.x, p.y + h)) - scene(vec2(p.x, p.y - h)))) ;    \n    return n;\n}\n\nfloat march(vec2 ro, vec2 rd) {\n\tfloat t = 0.;\n    for(float i=0.; i < MaxSteps; i++) {\n\t\tvec2 p = ro + t * rd;\n        float dt = scene(p);\n        if(dt < MinDistance) return t+0.00001;\n        t += dt;\n    }       \n    return 0.;\n}    \n\nfloat seed = 0.;\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*U-R)/R.y;\n    vec3 col = vec3(0);\n\n    for(float i=0.; i < Samples; i++) {\n        \n        float r = (i + random(uv + i + iTime)) / Samples * 2. * 3.1415;\n        vec2 rd = vec2(cos(r), sin(r));\n        vec3 sampleColor = vec3(0);\n        \n        float t = march(uv, rd);\n        if(t > 0.) {\n            vec2 p = uv + t * rd;\n            \n            // light\n            if(objectId == 1) {\n            \tsampleColor = lightColor;    \n            }\n            \n            // box\n            if(objectId == 0) {\n            \tvec2 nor = calcNormal(p);\n                vec2 rrd = reflect(rd, nor);\n                float rt = march(p, rrd);\n                \n                if(rt > .0) {\n                    if(objectId == 0) {\n                    \tsampleColor = mix(sampleColor, lightColor, 0.5);\n                    }\n                }\n            }\n        }\n        col += sampleColor;\n    }        \n    \n    \n    \n    // cant figure out how to fix the \n    // center object color, so its hardcoded here\n\tif(centerBox(uv) < MinDistance)\n        col = vec3(0.);\n    \t// TODO: - sample it from a scene without the object iself\n        //       - create a smooth map between the two lights, now it\n        //         abruptly jumps because the other light is closer.\n    \n    \n\n    // Output to screen\n    O = vec4(col/Samples*2.,1.0);\n}","name":"Image","description":"","type":"image"}]}