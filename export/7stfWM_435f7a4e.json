{"ver":"0.1","info":{"id":"7stfWM","date":"1656610393","viewed":73,"name":"My simple circle","username":"IdeaSquirrel","description":"Explaining the code from The Art of Code beginners tutorial, adding notes and (somewhat loosely) referencing The Book of Shaders.\n\nSimply a self-learning exercise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Code from The Art of Code YT channel\n    https://www.youtube.com/watch?v=u5HAYVHsasc\n    \n    Absolute beginner stuff I'm trying to get my head around.\n    Coupling these with The Book of Shaders to try and get a foundation on\n    shader programming.\n    \n    I won't give up my Java / JS day-job :D\n    \n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n        https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/ \n         => Normalizing Coordinates\n        \n        This calculation includes accounting for aspect ratio.\n        https://www.desmos.com/calculator/n1eqkulkr2 (shader running locally at 1200x675 hence the preset values there)\n        \n        the resolution is multiplied by 0.5 to centre the origin within the screen space\n    */\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    // distance of the pixel from the origin\n    float d = length(uv);\n    \n    // arbitrary radius value\n    float r = 0.3;\n            \n    /*\n        the above is simplistic but results in jaggies where the circle edge is defined\n        better to use a smoothstep function (https://thebookofshaders.com/glossary/?search=smoothstep)\n        \n        Graph: https://www.desmos.com/calculator/4daqbd1zz8\n        \n        excellently explained by The Art of Code at https://www.youtube.com/watch?v=60VoL-F-jIQ\n        \n        conceptually smoothstep applies \n            edge0 < x < edge1 \n        where \n            any value of x <= edge0 => 0\n            any value of x >= edge1 => 1\n            any value edge0 < x < edge1 is an interpolated value between 0 and 1\n            \n                --- 1\n               /\n              /\n         0 ---    \n        \n        in our case, we want to smooth the transition from black to white so that it's not so sudden\n        intuitively we'd use: \n            smoothstep(r - 0.01, r, d)\n        which would give us\n            r - 0.01 < d < r\n        so\n            any value of d within the circle would be black\n            any value of d along the circle edge (r - 0.01 < d < r) would be an interpolated value\n            any value of d outside the circle would be white\n            \n        this gives us a black circle on a white background\n        \n        inverting the first two parameters give us a white circle on black background by applying\n        \n        1 (r) ---\n                 \\\n                  \\\n                   ---- 0 (r - 0.01) \n    */\n    //float col = smoothstep(r, r - .01, d);\n    float col = smoothstep(r + 1.5/iResolution.y, r - 1.5/iResolution.y, d);\n\n    /*\n        From https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/ (Antialiasing)\n        and Fabrice's comment on https://www.shadertoy.com/view/fsdfRS\n    */\n    // Output to screen\n    fragColor = vec4(vec3(pow(col, 1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}