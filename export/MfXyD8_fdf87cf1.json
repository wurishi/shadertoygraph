{"ver":"0.1","info":{"id":"MfXyD8","date":"1724052784","viewed":44,"name":"Automate Cellular","username":"Arbethi","description":"Exploration of applying iteratively a kernel on a texture in the same way as cellular automata\n","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["convolution","kernel","pde"],"hasliked":0,"parentid":"Dl3yRH","parentname":"Iterative Convol"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 Hue( float h,float a,float b )\n{\n    h=a*h+b;\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n    return rgb;\n\n\t//return c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv2=2.*fragCoord/(iResolution.xy)-1.;\n    uv2=uv2*0.5+0.5;\n    vec2 toCenter = vec2(0.5)-uv2;\n    float angle=mod(atan(toCenter.y,-toCenter.x)/(2.*3.1415926),1.);\n    angle=floor(angle*6.)/6.;\n    \n    ivec2 fc=ivec2(fragCoord.xy);\n    vec4 tex=texture(iChannel0,uv);\n    float x=tex.x;\n    float x2=texture(iChannel0,uv-1./iResolution.xy).x;\n    float h=hash2(uv);\n    //vec3 rgb=x*5.*Hue(angle,1.,0.2);\n    fragColor =  vec4(x);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Keyboard Control\n// left / right arrow : change convolution mode\n// up / down arrow    : change pixel resolution\n// 1/2/3              : change mouse mask\n// space              : reset screen\n// s                  : switch slow motion\n\n\nfloat partition2(vec2 uv)\n{\n    uv=uv*0.5+0.5;\n    vec2 toCenter = vec2(0.5)-uv;\n    float angle=mod(atan(toCenter.y,-toCenter.x)/(2.*3.1415926),1.);\n    return floor(subdiv*angle);\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n        \n    float scale=texelFetch(iChannel2,ivec2(0,0),0).x+1.;\n    int selection=int(texelFetch(iChannel2,ivec2(1,0),0).x);\n    int reset = int(texelFetch(iChannel2,ivec2(2,0),0).x);\n    int mouse_type = int(texelFetch(iChannel2,ivec2(3,0),0).x);\n    int speed = int(texelFetch(iChannel2,ivec2(4,0),0).x)==0?1:10;\n    if (reset==1)\n    {\n        Q=vec4(0.);\n        return;\n    }\n    U=floor(U/scale)*scale;\n    ivec2 fc = ivec2(U);\n    vec2 uv=2.*U/(iResolution.xy)-1.;\n    vec2 M= (iMouse.xy-U)/scale;\n    \n    vec4 texel=texelFetch(iChannel0,fc,0);\n    float angle=partition2(uv);\n    if (selection==0)\n        selection=int(angle)+1;\n    \n    \n    if (iFrame<10 && (fc.x*fc.y)%30<5 )\n    {\n    \tQ = vec4(1.);\n        return;\n    }\n        \n        \n    if (mouse_type==0)\n    {\n        if(length(M)<20./scale){\n            Q = 2.*vec4(step(1.*hash2(U+mod(iTime,2.)), 0.3));\n            return;\n        } \n    }\n    if (mouse_type==1)\n    {\n        if(length(M)<20./scale){\n            Q = vec4(1.);\n            return;\n        } \n    }\n    \n    float h=0.;\n    \n    if (hash(U+iTime)>0.9)\n    {\n    float x=dot(texture(iChannel1,U/iResolution.xy).xyz,vec3(0.333));\n    x=step(0.5,x);\n    //h=2.*x-1.;\n    \n        //h=max(h,x);\n    //Q=vec4(vec3(x),1.0);\n    //return;\n    }\n    if(iFrame%speed==0)\n    {\n        float u1=apply_bs(texel.x, fc, iChannel0, scale, selection);\n        Q=vec4(min(1.,u1+h), 0.0, 0.0, 1.0);\n    }\n    else\n    Q=texel;\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int conv_width = 3;\n\n// UTILS\nfloat subdiv=6.;\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec4 u(int i,int j,ivec2 fc, sampler2D s, float scale)\n{\n    return texelFetch(s, fc+int(scale)*ivec2(i,j),0);\n}\n\nconst mat3 kernellife = mat3(\n    1.,1.,1.,\n    1., 0.,1.,\n    1.,1.,1.\n);\n\nvec4 convol3(mat3 K, ivec2 fc,sampler2D s, bool binary, float scale)\n{\n    vec4 x=vec4(0.);\n    for (int i = -conv_width/2; i < conv_width/2+1; i++)\n    {\n        for (int j = -conv_width/2; j < conv_width/2+1; j++)\n        {\n            if (!binary)\n                x += K[i+conv_width/2][j+conv_width/2] * u(i,j,fc,s, scale);\n            else\n                \n                x += K[i+conv_width/2][j+conv_width/2] * step(0.5,u(i,j,fc,s, scale));\n        }\n    }\n    return x;\n}\n\n\nfloat hash2(vec2 p)\n{\n    vec2 m1=vec2(3.12,3.87);\n    float m2=437588.;\n    // return fract(pow(p.x+p.y,0.5)*1./sin(p.x*p.y));\n    return fract(sin(dot(p,m1))*m2);\n}\n\n//Cellular automata variant\n\n//Cellular automata variant\nfloat activation_bs(float x, float u1,int selection)\n{\n    //day&night\n    if (selection==1)\n    {\n    const int b_size = 4;const int s_size = 5;int BS[b_size+s_size] = int[](3,6,7,8,3,4,6,7,8);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }//maze\n    if (selection==2)\n    {\n    const int b_size = 1;const int s_size = 5;int BS[b_size+s_size] = int[](4,1,2,3,4,6);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }//gameoflife\n    if (selection==3)\n    {\n    const int b_size = 1;const int s_size = 2;int BS[b_size+s_size] = int[](3,2,3);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }//longlife\n    if (selection==4)\n    {\n    const int b_size = 4;const int s_size = 5;int BS[b_size+s_size] = int[](4,6,7,8,3,5,6,7,8);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }//seed\n    if (selection==5)\n    {\n    const int b_size = 1;const int s_size = 2;int BS[b_size+s_size] = int[](1,1,2);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }//coral\n    if (selection==6)\n    {\n    //const int b_size = 5;const int s_size = 3 ;int BS[b_size+s_size] = int[](1,3,4,6,8,0,2,3);\n    //const int b_size = 3;const int s_size = 1 ;int BS[b_size+s_size] = int[](3,4,5,5);\n    //const int b_size = 1;const int s_size = 2;int BS[b_size+s_size] = int[](1,1,2);\n    const int b_size = 1;const int s_size = 5;int BS[b_size+s_size] = int[](3,4,5,6,7,8);\n\n        for(int i=0;i<b_size;i++)\n            if (u1==0. && x==float(BS[i]))\n                return 1.;\n        for(int i=b_size;i<s_size+b_size;i++)\n            if (u1!=0. && x==float(BS[i]))\n                return 0.;\n        return -1.;\n    }\n}\n\nfloat apply_bs(float tex ,ivec2 fc, sampler2D sampler, float scale, int selection){\n    float lp = convol3(kernellife,fc,sampler, true, scale).x;\n    float u1=tex;\n    u1=u1+activation_bs(lp, u1,selection); \n    u1=clamp(u1,0.,1.);\n    return u1;\n        }\n        ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"    #define keyDown(ascii)    ( texelFetch(iChannel0,ivec2(ascii,1),0).x > 0.)\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        ivec2 U=ivec2(fragCoord.xy);\n        if ((U.x == 0) && (U.y == 0))\n        {\n            float scale_state=texelFetch(iChannel1,U,0).x;\n            float modifier=0.;\n            if (keyDown(38))\n            {\n                modifier=1.;\n            }\n\n            if (keyDown(40) )\n            {\n                modifier=-1.;\n            }\n            fragColor.x=clamp(scale_state+modifier,0.,20.);\n        }\n        if ((U.x == 1) && (U.y == 0))\n        {\n            float scale_state=texelFetch(iChannel1,U,0).x;\n            float modifier=0.;\n            if (keyDown(39))\n            {\n                modifier=1.;\n            }\n\n            if (keyDown(37) )\n            {\n                modifier=-1.;\n            }\n            fragColor.x=clamp(scale_state+modifier,0.,subdiv);\n        }\n        if ((U.x == 2) && (U.y == 0))\n        {\n            float modifier=0.;\n            if (keyDown(32))\n            {\n                modifier=1.;\n            }\n            fragColor.x=modifier;\n        }\n        if ((U.x == 3) && (U.y == 0))\n        {\n            if (keyDown(97))\n            {\n                fragColor.x=0.;\n            }\n            else if (keyDown(98))\n            {\n                fragColor.x=1.;\n            }\n            else if (keyDown(99))\n            {\n                fragColor.x=2.;\n            }\n            else if (keyDown(100))\n            {\n                fragColor.x=3.;\n            }\n            else\n                fragColor.x=texelFetch(iChannel1,U,0).x;\n        }\n        \n        if ((U.x == 4) && (U.y == 0))\n        {\n            float scale_state=texelFetch(iChannel1,U,0).x;\n            if (keyDown(83))\n            {\n            fragColor.x=1.-scale_state;\n            }\n            else\n            fragColor.x=scale_state;\n        }\n\n    }","name":"Buffer B","description":"","type":"buffer"}]}