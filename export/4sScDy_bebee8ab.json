{"ver":"0.1","info":{"id":"4sScDy","date":"1493508176","viewed":162,"name":"Mandelbrot : Douady-Hubbard","username":"JCDjcd","description":"Display Mandelbrot set along with the Douady-Hubbard potential (harmonic function).\nAs it can be seen, the potential is continuous between regions of different exiting iterations (pink+blue,red+black,yellow+green,purple+blue,orange+green,cyan+white ...).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","potential","douady","hubbard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\nvec2 iteration(vec2 z,vec2 c)\n{\n\tfloat x = z.x*z.x-z.y*z.y + c.x;\n    float y = 2.0*z.x*z.y + c.y;\n    return vec2(x,y);\n} // iteration()\n\n//--------------------------------------------------------------------------\nvec4 compute(vec2 c)\n{\n    // ==========\n    //  STEP #1\n    // ==========\n    // do the iterations until the exit circle of radius 2\n    vec2 \tz \t= c;\n    int \tn\t= 1000; // max\n    int \ti;\n    for(i=0;i<n;i++)\n    {\n        if(z.x*z.x+z.y*z.y > 4.0)\n        {\n            break;\n        }\n        z = iteration(z,c);\n    } // for()\n    \n    if(i < n)\n    {\n        // ==========\n        //  STEP #2\n        // ==========\n        // continue the iteration in the diverging part\n        // in order to estimate the Douady-Hubbard potential V\n        // defined by V = lim[n -> +Inf] log( |z[n]| )/2^n\n        int n_diverging = 4; //can't go further because of float (see with higher precision)\n        int j;\n        for(j=0;j<n_diverging;j++)\n        {\n            z = iteration(z,c);\n        } // for()\n        float logV = log(log(z.x*z.x+z.y*z.y))-float(i+n_diverging+1)*log(2.0);\n        \n        // For colorization, we overlap the potential with the number of\n        // iteration before exiting the circle of radius 2.\n        float r = 0.5+0.5*cos(logV*30.0);\n        float g = 0.5+0.5*sin(1.25*3.1415926535*float(i));\n        float b = 0.5+0.5*cos(1.25*3.1415926535*float(i));\n        return vec4(r,g,b,1.0);\n    }\n    else\n    {\n    \treturn vec4(0.0,0.0,0.0,1.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get min/max of the resolution (in most case the width).\n    float m \t= min(iResolution.x,iResolution.y);\n    float M \t= max(iResolution.x,iResolution.y);\n    vec2 uv \t= ((fragCoord.xy-0.5*iResolution.xy) / m)*3.0;\n    float alpha = iTime*2.0*3.1415926535/5.0;\n    float beta \t= iTime*2.0*3.1415926535/9.0;\n    float scale = (1.0+2.0*(0.5+0.5*cos(beta)));\n    uv \t\t\t= vec2(uv.x*cos(alpha)-uv.y*sin(alpha),uv.x*sin(alpha)+uv.y*cos(alpha));\n    uv \t\t\t= vec2(uv.x/scale,uv.y/scale);\n    fragColor \t= compute(uv);\n} // mainImage()\n\n\n\n","name":"Image","description":"","type":"image"}]}