{"ver":"0.1","info":{"id":"wljXD1","date":"1565883896","viewed":943,"name":"[Music Video] Beauty of the sea","username":"peet","description":"A different view of an endless sea following a lonely wanderer, put to music (if it plays correctly!). \nUsing iq's SDF operations/noise, Dave_Hoskins caustics, Wojtajam's BCS and robobo1221's atmosphere converted to 3d.","likes":37,"published":1,"flags":64,"usePreview":1,"tags":["raymarching","reflection","ripples","sea","sunset","sun","refraction","music","water","camera","snake","caustics","atmosphere","fresnel","reef"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4tXXDX","filepath":"https://soundcloud.com/awolnation/10-sail","previewfilepath":"https://soundcloud.com/awolnation/10-sail","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// NOTE: The music should start with the shader, if it does not click play then  //\n// stop on the sound in channel2, then click reset time button \"|<\" then play |> //\n// you should be able to get the shader and music to start together              //\n///////////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////////\n// The beauty of the sea ////////////////////////////////////////////////// peet //\n///////////////////////////////////////////////////////////////////////////////////\n// Put together from everything i've learned from all you awesome guys. ///////////\n// Where there was an option between realism and aestehtics, I chose aesthetics ///\n// Hope you like it :) ////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define DE_ITERATIONS 50\t\t\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define WAVEHEIGHT\t0.55\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MSAA_X 1.0\t\t\t\t\n#define MSAA_Y 1.0\t\t\t\t\n\n///////////////////////////////////////////////////////////////////////////////////\n\nLight g_light = Light(vec3(0.0, 0.0, 1.0), vec3(100.0, 100.0, 100.0)*0.25);\nvec3 g_camera = vec3(0.0);\n\n#define BASIC 0\n#define ERROR 1\n\nMaterial g_basic = Material(vec3(0.5, 0.5, 0.5), 0.5, 0.01);\nMaterial g_error = Material(vec3(1.0, 0.0, 1.0), 1.0, 0.0);\n\nMaterial g_mats[10];\n\nconst float g_movespeed = 3.0;\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 tritex(sampler2D tex, vec3 p, vec3 n)\n{\n \treturn  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's texture based noise function (37,17) FTW!\n\nfloat noise( in vec3 x )\n{\n    x *= 5.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// cheap environment backdrop - modified from bananaft's code\n\nvec3 getfogcolour()\n{    \n    return getAtmosphericScattering(-g_light.dir, g_light.dir);\n}\n\nvec3 getlightcolour()\n{    \n    return getAtmosphericScattering(normalize(-g_light.dir - YAXIS*0.2), g_light.dir);\n}\n\nfloat getcloudtexture(vec3 p)\n{   \n    float c = 0.0;\n    float weightsum = 0.0;\n    float weight = 0.6;\n    vec3 scale = vec3(0.0005, 0.0, 0.002);\n    \n    p+=vec3(0.1, 0.0, 0.2)*iTime*100.0;\n    \n    for (int i=0; i<4; i++)\n    {\n        weightsum+=weight;\n        //c += texture(iChannel1, p.xz*scale.z*1.0).r*weight;\n    \tc += (noise(p*scale)*weight + noise(p*scale + YAXIS*1.0)*weight)*0.5;\n        scale *= 1.9;\n        weight *= 0.45;\n    }\n    c/=weightsum;\n    return c;\n}    \n    \nvec3 environment(vec3 origin, vec3 dir)\n{\n    float t = planeIntersect(origin, dir, vec4(0.0, -1.0, 0.0, 800.0));\n\n    float c = getcloudtexture(origin+t*dir);\n//    float delta = -(getcloudtexture(origin+(t+100.0)*dir) - c);\n    float delta = getcloudtexture(origin+t*dir + 100.0*g_light.dir) - c;\n    \n    float alpha = clamp((1.0 - t/4000.0), 0.0, 1.0);\n    if (t<0.0)\n        alpha = 0.0;\n    \n    float cloudthreshold = 0.4;\n    alpha *= clamp((c-cloudthreshold)/(0.75), 0.0, 1.0);\n    \n    vec3 col=vec3(c*40.0)*getlightcolour() + vec3(clamp(-g_light.dir.y, 0.0, 10.0))*80.0;\n    //col += getlightcolour()*clamp((50.0+delta*8000.0), 0.0, 14000.5);\n                                               \n\tvec3 sundir = g_light.dir; \n    vec3 env = getAtmosphericScattering(dir, sundir)*180.0;\n    return mix(env, col, alpha);\n\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// Fresnel\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    float a = clamp(1.0-dot(n,-d), 0.0, 1.0);\n    return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n}\nfloat fresnelT(vec3 d, vec3 n)\n{\n\treturn 1.0 - fresnelR(d,n);    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// DISTANCE ESTIMATION ////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat anim(in vec3 pos)\n{\t// return the x offset at a given position(based on z)\n    return sin(pos.z*3.0 + (iTime-pos.z*0.1)*8.0)*0.4;\n}\n\nvec2 sceneSDF( vec3 pos )\n{\n    vec2 res = vec2( TOO_FAR, ERROR );\n    vec2 res2 = vec2( TOO_FAR, ERROR );\n    \n    pos.z -= iTime*g_movespeed;\n        \n    for (float i=0.0; i<=32.0; i++)\n    {\n        float rad = 0.06 + sin(3.14159*i/32.0)*0.02;\n        vec3 p=vec3(0.0,-0.2,6.5 - i*3.0/32.0);\n        p.x=anim(p);\n        res = opsU(res, vec2(sdSphere((pos-p)*vec3(1.0, 0.4, 1.0), rad), 8.0), rad*1.75);\n    }    \n    return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF system (Distance Estimate)\n\nResult resultsDE(vec3 p)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), TOO_FAR, TOO_FAR, 0.0, g_error);\n\n    // normal generation\n    result.normal = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        result.normal += e*sceneSDF(p+EPSILON*e).x;\n    }\n    result.normal = normalize(result.normal);        \n    \n    vec2 res = vec2(TOO_FAR, ERROR);    \n    res = sceneSDF(p);\n            \n    result.mat=g_basic;\n        \n    result.pos = p;\n    result.dist = res.x;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch solid (Distance Estimate - based on value returned by sceneSDF())\n\nResult raymarchDE(Ray ray, float distfactor, float maxtravel)\n{\n\tfloat travelled=0.0;\n    for (int i=0; i<DE_ITERATIONS; i++)\n    {\n    \tvec2 res = sceneSDF(ray.pos);\n                        \n        ray.pos += res.x*ray.dir*distfactor; \n        travelled += res.x*distfactor;\n        \n        if (travelled>maxtravel)\n            break;\n    }     \n    \n    Result result = resultsDE(ray.pos);\n    result.travelled=travelled;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// HEIGHTFIELD ////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat waterfield(vec3 p)\n{\t\n    const float wavespeed = 1.0;\n    float time = iTime;\n    float cosa=cos(0.79);\n    float sina=sin(0.79);\n    mat2 rot = mat2(cosa, sina, -sina, cosa);\n    \n    vec2 phase = vec2(p.x, p.z);\n    float w = 0.0;\n    float mag = 1.0;\n    float magtotal = 0.0;\n    for (int i=0; i<3; i++)\n    {\n\t    phase.x += time * 1.73 * (mag*wavespeed);\n\t    phase.y += time * 1.51 * (mag*wavespeed);\n        w += (sin(phase.x) + cos(phase.y*0.3)) * mag;\n        phase=rot*phase;\n        magtotal += (mag*2.0);\n        mag *= 0.675;\t// should be approx 0.5\n        phase *= 1.5;   // should be approx 2.0     \n    }\n    w/=magtotal;\t// -1 to 1\n    \n    float y = w*WAVEHEIGHT*clamp(-g_light.dir.y, 0.0, 1.0)+0.0;\n    \n    vec3 snaketail = vec3(0.0, 0.0, g_movespeed*iTime + 6.0);\n    vec3 totail = snaketail - p;\n    if (totail.z > 0.0 && abs(totail.x)<totail.z)\n    {\n        float wake = sin(length(totail)*10.0-iTime*20.0)*0.1;\n        wake *= 1.0 - (totail.x*totail.x)/(totail.z*totail.z);//(1.0-abs(totail.x)/totail.z)*(1.0-abs(totail.x)/totail.z);\n        wake *= clamp(totail.z*0.25, 0.0, 1.0)*clamp((6.0-totail.z)*0.1, 0.0, 1.0);\n    \ty+=wake*clamp(-g_light.dir.y, 0.0, 1.0);    \n    }\n    \n    return y;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat heightfield(vec3 p)\n{\t\n    p*=0.035;    // scale down terrain frequency    \n    float mag = 1.0;\n    float magtotal = 0.0;\n    float h = 0.0;\n\tfor (int i=0; i<5; i++)\n    {\n        magtotal += mag;\n        h += noise(vec3(p.x, 0.0, p.z))*mag;\n        mag *= 0.5;\n        p *= 2.03;\n    }\n    h = h/magtotal; //0 to 1\n    h = (h*h*h*h-0.2)*32.0;\n    h *= -sign(h);\n    return h-noise(p*0.25)-(2.0-noise(p*0.1)*4.0);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat terrain(vec3 p, bool water)\n{\n    if (water)\n\t\treturn waterfield(p) / clamp((dot(g_camera-p, g_camera-p)*0.01), 1.0, 100000.0);    \n    else\n\t\treturn heightfield(p) - 0.2;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch heightfield (based on value returned by heightfield())\n\nResult raymarchHF(Ray ray, float mindist, float maxdist, float stepsize, bool water)\n{\n    Result result;\n    float dist = mindist;\n    float h = 1.0;\n    float dh = 1.0;\n    float lastdh = -1.0;\n    float lastdist = 0.0;\n    float fracstep = 0.5;\n    \n    float maxy = water?WAVEHEIGHT:0.0;\n    dist = max(dist, planeIntersect(ray.pos, ray.dir, vec4(0.0, 1.0, 0.0, -maxy)));\n        \n    for (float i=0.0; i<90.0; i++)\n    {\n        vec3 pos = ray.pos + ray.dir*dist;\n        h = terrain(pos, water);\n        dh = pos.y - h;\n        if (dh<(0.001*i) || dist>maxdist)\n        {\n            break;    \n        }\n        lastdh = dh;\n        lastdist = dist;\n        dist+=stepsize;\n        stepsize+=(0.0004*i);\n    }\n    \n    if (dist<maxdist)\n    {\n        fracstep = lastdh/(lastdh-dh);    \n        dist = mix(lastdist, dist, fracstep);\n    }\n    result.dist = dist;\n    result.travelled = dist;\n    result.pos = ray.pos + ray.dir*dist; \n    const float dn = 0.1;\t\n    result.normal.x = terrain(result.pos, water) - terrain(result.pos+XAXIS*dn, water);\n    result.normal.y = dn;\n    result.normal.z = terrain(result.pos, water) - terrain(result.pos+ZAXIS*dn, water);\n    result.normal = normalize(result.normal);\n    result.mat = g_basic;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// Heightfield integrator\n\nvec3 integrateHF( Ray inputray )\n{\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n\tconst float maxdist = 400.0;\n            \n    float IOR = 1.4;\n    if (inputray.pos.y < waterfield(inputray.pos))\n        IOR = 1.0/IOR;\n        \n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    \n    Ray ray=inputray;            \n    Result result = raymarchHF(ray, 1.0, maxdist, 0.01, true);\n\n    if (result.dist>=maxdist)\n    {\n        colour = environment(ray.pos, ray.dir);\n\t    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n\t    return colour;    \n    }\n\n    float fR=fresnelR(ray.dir, result.normal);\n    float fT=1.0 - fR;\n    vec3 watercolour = 2.0*vec3(0.0, 0.3, 0.2)*clamp(-g_light.dir.y, 0.0, 1.0);\n    \n    {\n        vec3 refracted = refract(ray.dir, result.normal, 1.0/IOR);\n        // underwater terrain intersection\n        Ray groundray;\n        groundray.pos = result.pos;\n        groundray.dir = refracted;\n        \n\t    Result snakeresult = raymarchDE(groundray, 1.0, 3.0);\n        if (snakeresult.travelled < 3.0)\n        {\n            vec3 snakepos = groundray.pos + groundray.dir*(snakeresult.travelled);\n            vec3 snakeposl = snakepos - vec3(0.0, 0.0, iTime*g_movespeed);\n            vec3 snakecol = vec3(200.0);\n            float f = mod(snakeposl.z, 0.15);\n            if (f<(((snakepos.y+0.2)*0.2+0.0375)))\n                snakecol = vec3(0.0);\n            if (snakeposl.z>6.3)\n            {\n\t            if (snakeposl.y>-0.05)\n                    snakecol = vec3(0.0);\n    \t\t\telse\n\t\t\t\t\tsnakecol = vec3(1.0, 0.8, 0.2)*100.0;\n            }\n            \n            Result sr = resultsDE(snakepos);        \n            snakecol*=0.25+vec3(tritex(iChannel1, snakeposl, sr.normal).r)*0.75;        \n            snakecol = mix(snakecol, watercolour, clamp(snakeresult.travelled*snakeresult.travelled*0.01, 0.3, 1.0));        \n            colour = snakecol*clamp(dot(sr.normal, -g_light.dir), 0.0, 1.0)*fT*g_light.colour;        \n        }\n        else\n        {                    \n            Result groundresult = raymarchHF(groundray, 0.1, 100.0, 0.1, false);\n            vec3 ground = groundresult.pos;\n            float grounddist = length(result.pos-ground);\n\n            // texturing\n            vec3 groundcol = texture(iChannel1, ground.xz*0.3).xyz;\n            groundcol*=(groundcol+vec3(0.6));\n\n            // caustics (Thanks Dave!)\n            vec2 h = mod(groundresult.pos.xz, 10.0)*groundresult.pos.y*0.1;            \n            vec3 cc = caustic(h, iTime);        \n            groundcol*=0.5 + dot(cc,cc)*0.5;\n            groundcol+=dot(cc,cc)*0.5*clamp(-g_light.dir.y, 0.0, 1.0);\n\n            groundcol *= clamp(dot(groundresult.normal, -g_light.dir), 0.0, 1.0);\n            groundcol = mix(groundcol, watercolour, clamp(grounddist*grounddist*0.01, 0.0, 1.0));        \n            groundcol = groundcol*groundcol;\n            colour = mix(colour, groundcol*40.0, fT)*g_light.colour;  \n        }\n    }\n    \n    Ray reflectray;\n    reflectray.pos = result.pos + result.normal*0.02f;\n    reflectray.dir = reflect(ray.dir, result.normal);\n\n    vec3 ambient = environment(reflectray.pos, reflectray.dir);\n    colour += fR*(ambient);                                     \n\n    colour.xyz = mix(colour.xyz, environment(inputray.pos, inputray.dir), result.dist/maxdist);    \n    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 'Camera'\n\nRay CreateRay(vec2 uv)\n{\n    // moveable cam\n    vec3 p0, p1;\n    p0=vec3(0.0, 2.0, 0.0);\n    p1=vec3(0.0, 0.0, 3.0);\n\n    vec2 vmouse;    \n    if (iMouse.x<20.0)\n    {\n        // auto!\n        const float introtime=17.3;\n        const float beat = 4.02;\n        if (iTime<introtime)\n        {\n        \tvmouse = vec2(0.5+sin(iTime*0.3)*0.1, 0.25+sin(iTime*0.2)*0.15);\n        }\n        else\n        {\n        \tfloat t = mod(iTime-introtime, beat);\n            float s = floor((iTime-introtime) / beat);\n            vec2 v1 = vec2(perlin(s, 1.0), 0.1+sqrt(perlin(s, 2.0))); \n            vec2 v2 = vec2(perlin(s, 3.0), 0.1+perlin(s, 4.0)*perlin(s, 4.0));\n            \n            if (mod(s,10.0)>=6.0 && mod(s,10.0)<=8.0)\n            {\n            \tv1.y = 0.1+v1.y*0.25;    \n            \tv2.y = 0.1+v2.y*0.25;    \n            }\n            \n            t=clamp(t/2.5, 0.0, 1.0);                   \n            vmouse=mix(v1, v2, t*t*(3.0-2.0*t));            \n        }\n    }    \n    else\n    {\n        vmouse = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    }    \n\tp0=vec3(0.0 + 16.0*vmouse.x - 8.0, 16.0*vmouse.y, 0.0);\n    \n    p0.z += iTime*g_movespeed;        \n    p1.z += iTime*g_movespeed;    \n                        \n    Ray ray;\n    float roll = 0.0;\n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, 0.0) + p0;\n    ray.dir = dir*0.8 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir); \n    return ray;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{               \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA_X*MSAA_Y);\n             \n    // materials\n    g_mats[BASIC]=g_basic;\n    g_mats[ERROR]=g_error;\n    \n    vec3 sundir = normalize(vec3(0.0, -0.87+sin((iTime*0.5+5.0)*0.3), -1.0));\n    g_light.dir = sundir;\n    g_light.colour = getlightcolour();\n    \n    for (float x=0.0; x<MSAA_X; x++)\n    {\n        for (float y=0.0; y<MSAA_Y; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA_X))*x;\n            uv.y += (1.0/(iResolution.y*MSAA_Y))*y;\n            \n    \t\tRay ray=CreateRay(uv);\n\t\t    g_camera = ray.pos;\n                                    \n#ifdef DITHER            \n            float dither = hashfloat(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension    \n            ray.pos += ray.dir*dither*0.1;\n#endif //DITHER            \n            \n            const float outofboundsdist = 3.0;\n            const float maxvaliddist = 0.02;\n            fragColor.xyz += integrateHF(ray)*factor;              \n       \t}        \n    }    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;    \n    fragColor = brightnessMatrix( 0.05 ) * contrastMatrix( 1.5 ) * \n        saturationMatrix( 1.2 ) * fragColor;\n    fragColor.xyz -= (uv.y*uv.y + uv.x*uv.x)*0.2;             \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n\n#define TOO_FAR 100000000.0\n#define EPSILON 0.0001\n#define PI 3.14159\n\nvec3 XAXIS = vec3(1.0, 0.0, 0.0);\nvec3 YAXIS = vec3(0.0, 1.0, 0.0);\nvec3 ZAXIS = vec3(0.0, 0.0, 1.0);\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 dir;\n    vec3 colour;\n};\n            \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float dist;\n    float mindist;\n    float travelled;\n    Material mat;\n};\n    \nstruct SDFResult\n{\n\tfloat dist;\n    int matindex;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return rotation;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF's & other spatial query functions\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// custom implementation of SD tri which skews space to bend the sail\nfloat sdSail( vec3 p, vec3 a, vec3 b, vec3 c, float time )\n{\n    vec3 ba = b - a; \n    vec3 cb = c - b; \n    vec3 ac = a - c; \n    vec3 nor = normalize(cross( ba, ac ));\n    vec3 acc = normalize(cross(ba, nor));\n    float wid = dot(cb, acc);\n    float w = dot(p-b, acc);\n    float x = clamp((w/wid), 0.0, 1.0);\n    float def = clamp(0.04405594 + 7.036014*x - 14.29915*x*x + 7.222222*x*x*x, 0.0, 1.0);\n    //float def = sin(x*3.14159);\n    def *= (0.6+0.2*cos((x+p.z)*3.14159*2.0 + time*3.0));\n    p+=def*nor*0.07;\n    float certainty = 1.0 - def*0.5;\n\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 pc = p - c;\n    \n    if (sign(dot(cross(ba,nor),pa)) + sign(dot(cross(cb,nor),pb)) + sign(dot(cross(ac,nor),pc))<2.0)\n    {\n        return certainty*sqrt(min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) ));\n        \n    }\n    else\n    {\n    \treturn certainty*sqrt(dot(nor,pa)*dot(nor,pa)/dot2(nor));    \n    }\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 ) \n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x,d1.y):d2; \n}\n\nvec2 opI( vec2 d1, vec2 d2 ) \n{ \n    return (d1.x>d2.x) ? d1:d2; \n}\n\nvec2 opsU( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d2.y); \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat hashfloat( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat planeIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat sinbetween(float angle, float min, float max)\n{\n\treturn min + (1.0+sin(angle))*0.5*(max-min);\n}\n\nfloat perlinbetween(float a, float b, float min, float max)\n{\n\treturn min + (perlin(a,b))*(max-min);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// Non physical based atmospheric scattering made by robobo1221\n\nconst float pi = 3.14159265359;\nconst float invPi = 1.0 / pi;\n\nconst float zenithOffset = -0.02;\nconst float multiScatterPhase = 0.1;\nconst float density = 0.7;\n\nconst float anisotropicIntensity = 0.0; //Higher numbers result in more anisotropic scattering\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0) * (1.0 + anisotropicIntensity); //Make sure one of the conponents is never 0.0\n\n#define smooth(x) x*x*(3.0-2.0*x)\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.35e-2), 0.75)\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = x * -y;\n\t     absorption = exp2(absorption) * 2.0;\n\t\n\treturn absorption;\n}\n\nfloat getSunPoint(vec2 p, vec2 lp){\n\treturn smoothstep(0.03, 0.026, distance(p, lp)) * 50.0;\n}\n\nfloat getRayleigMultiplier(vec2 p, vec2 lp){\n\treturn 1.0 + pow(1.0 - clamp(distance(p, lp), 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n\tfloat disk = clamp(1.0 - pow(distance(p, lp), 0.1), 0.0, 1.0);\n\t\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 getAtmosphericScattering(vec3 dir, vec3 sundir)\n{\n    // convert vec3's into the screen coordinates that robobo1221's code expected\n    vec2 p;\n    vec2 lp;\n    sundir = sundir;\n    sundir.y = -sundir.y;\n    p.x = 0.0;\n    p.y = atan(dir.y, length(dir.xz))/(pi*0.5);    \n    lp.y = atan(sundir.y, length(sundir.xz))/(pi*0.5);\n\t\t\n    vec3 dirflat = dir;\n    dirflat.y=0.0;\n    dirflat=normalize(dirflat);\n    vec3 sundirflat = sundir;\n    sundirflat.y=0.0;\n    sundirflat=normalize(sundirflat);\n    lp.x = 0.0 + acos(clamp(dot(-sundirflat, dirflat), -1.0, 1.0)) /(pi*0.5);\n        \n\tfloat zenith = zenithDensity(p.y);\n\tfloat sunPointDistMult =  clamp(length(max(lp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, lp);\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lp.y + multiScatterPhase));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 sun = getSunPoint(p, lp) * absorption;\n\tvec3 mie = getMie(p, lp) * sunAbsorption;\n\t\n\tvec3 totalSky = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n         totalSky += sun + mie;\n\t     totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\n\ttotalSky = jodieReinhardTonemap(totalSky);\n\ttotalSky = pow(totalSky, vec3(2.2)); //Back to linear\t\n\treturn totalSky;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// Dave Hoskins's amazing tileable water caustic\n\n#define TAU pi*2.0\n#define CASUTIC_ITER 3\n\nvec3 caustic(vec2 p, float time)\n{\n    p = mod(p*TAU, TAU)-250.0;\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < CASUTIC_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(CASUTIC_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 3.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nmat4 brightnessMatrix( float brightness )\n{\n    return mat4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}","name":"Common","description":"","type":"common"}]}