{"ver":"0.1","info":{"id":"WsXcD8","date":"1711361161","viewed":67,"name":"Sphere tiling (cube, dodo)","username":"voland","description":"Sphere tiling","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["geom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c,-s,s,c);\n}\n\n\nmat3 rot(float a, float b, float c){\n    float sa = sin(a), sb = sin(b), sc = sin(c);\n    float ca = cos(a), cb = cos(b), cc = cos(c);\n    mat3 Rx = mat3(1,0,0,\n                   0,ca,-sa,\n                   0,sa,ca);\n    \n    mat3 Ry = mat3(cb,0,sb,\n                   0,1,0,\n                   -sb,0,cb);\n    \n    mat3 Rz = mat3(cc,-sc,0,\n                   sc,cc,0,\n                   0,0,1);\n    //return Rz * Ry * Rx;\n    return Rx * Ry * Rz;\n}\n\n\nfloat circ(vec2 _p, vec2 c, in float r){\n    vec2 p = _p - c;\n    return step(dot(p,p),r * r);\n}\nvec4 sphere (vec2 _p, vec3 c, in float r){\n    vec2 p =  _p - c.xy;\n    float a = circ(_p, c.xy ,r);\n    vec2 st;// TODO: it depends on type of projection we use(sperical, cylindrical, box)...\n    float z = sqrt(r*r - p.x * p.x - p.y * p.y);\n    return vec4(st, z + c.z, a);\n}\n\nvec3 [6] cube(){\n    vec3 [6]c;\n\tc[0] = vec3(1, 0, 0);\n\tc[1] = vec3(0, 1, 0);\n\tc[2] = vec3(0, 0, 1);\n    \n\tc[3] = vec3(-1, 0, 0);\n\tc[4] = vec3(0, -1, 0);\n\tc[5] = vec3(0, 0, -1);\n    return c;\n}\n\n\nvec3 [12] dodo(){\n\tfloat a = 0.809, b=0.309, c=0.588, d=0.951, r = 1.118;\n    vec3 p[12];\n\tp[0] = vec3(a, 0.5, c);\n\tp[1] = vec3(b, -0.5, d);\n\tp[2] = vec3(-b, 0.5, d);\n    \n\tp[3] = vec3(-a, -0.5, c);\n\tp[4] = vec3(-1,0.5, 0);\n    p[5] = vec3(0, 1.118, 0);\n    \n    for (int i=0; i < 6; i++){\n        p[6 + i] = -p[i];\n    }\n    \n\t\n    return p;\n}\n\n// our custom mix\nvec4 mix(vec4 col1, vec3 col2, vec4 object){\n    vec3 col = mix (col1.rgb, col2, object.a * step(col1.w, object.z));\n    return vec4(col,  max(col1.w, object.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 m = 10.0 * (iMouse.xy/iResolution.xy - vec2(0.5));\n    \n    mat3 ro = rot(m.y, -m.x, 0.0);\n    \n    float negInfinity = -1000.0;\n  \t\n    // color + z\n    vec4 col = vec4(.0,.0,.0,negInfinity);\n    \n    vec4 s1 = sphere(p, vec3(0), 1.0);\n    \n    vec3 me = vec3(p, s1.z);\n    \n    // cube\n    vec3 poly[] = dodo();\n\n    \n    float minD = -1000.0;\n    int minI;\n    for (int i = 0; i < poly.length(); i++){\n        vec3 n = ro * poly[i];\n        // float d = dot (poly[i], me);\n        float d = dot (n, me);\n        if (d > minD) {minD = d; minI = i;}\n        \n    }\n    \n    // col = mix(col, vec3(0, 1.0 / float(minI),1), s1);\n    vec3 polyCol = vec3(minD * 0.9,  float(minI)/ float(poly.length()), 1);\n    col = mix(col, polyCol, s1);\n    \n\t\n    \n    \n\n    // Output to screen\n    fragColor = col;//vec4(col.rgb,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}