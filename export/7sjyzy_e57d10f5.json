{"ver":"0.1","info":{"id":"7sjyzy","date":"1643936265","viewed":230,"name":"Phyllotactic spiral (tech demo)","username":"stegu","description":"A planar Fibonacci spiral pattern with animated growth. This is a reasonably accurate (although idealized) simulation of the real growth pattern of flower heads.\nInverse mapping, constant time. A classic, stateless, procedural surface shader.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animated","fibonacci","sunflower","growth","botany"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 20.0*fragCoord/min(iResolution.x, iResolution.y)-10.0;\n    // Variable speed (with brief reversals) for visual interest\n    float N = iTime*10.0 + 13.0*sin(iTime);\n    \n    vec3 nn = inversePF(uv, floor(N), fract(N));\n    float d = length(uv-nn.xy);\n    if(nn.z>floor(N)) d = 1.0; // Hide points with index > intN\n\n    const float r = 0.78; // Cell radius, this is close to kissing distance\n    // Tint the zero-angle reference cell yellow, the rest are gray\n    vec3 cellcolor = vec3(1.0, 1.0, step(nn.z,N-1.0))*d/r; // white at d=r\n    vec3 bgcolor = vec3(0.0,0.6,0.0);\n    vec3 mixcolor = mix(bgcolor, cellcolor, 1.0-aastep(r,d));\n    mixcolor = mix(mixcolor, vec3(1.0,0.0,0.0), aaline(0.0, uv.x, 3.0));\n    mixcolor = mix(mixcolor, vec3(1.0,0.0,0.0), aaline(1.0, uv.x, 3.0)\n        *(1.0-aastep(0.2,length(vec2(1.0,0.0)-uv)))); // Tick mark at x=1\n    mixcolor = mix(mixcolor, vec3(1.0,0.0,0.0), aaline(0.0, uv.y, 3.0));\n\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Anti-aliased implicit line around v = t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n#define Phi 0.618033988749895\n\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * Phi - floor(k * Phi);\n}\n\n//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius of ~sqrt(N) around the origin.\n// Modified version of the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL, modified for planar mapping,\n// added gradual blending between N and N+1 points.\n// This version is Copyright 2022 Stefan Gustavson, released\n// under the terms of the MIT license (\"use freely with\n// credit\"): https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the position of the nearest\n// neighbor in .xy, and its integer index (k) in .z.\n// A linear morph between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N, the index needs to be\n// recomputed as (intN - k). The point set is not limited\n// to N points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n// Mask on k>N if you want to limit the number of cells.\n//\nvec3 inversePF(vec2 p, float intN, float fracN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fracN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,  // Note how simple this B is, compared to\n                  2.0*PI*B1, F1); // the spherical mapping in the reference\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    float ci = i + 0.5 + fracN;\n    vec2 c = floor(invB * vec2(ctheta, ci));\n\tfloat dsqmin = 4.0; // Actual min dsq is always less than this\n    float r, dsq;\n    vec2 q;\n\tfor (float s = 0.0; s < 4.0; s++) { // This loop is a little awkward\n\t\ti = dot(vec2(F0, F1),\n\t\t\tvec2(mod(s, 2.0), floor(s*0.5)) + c); // (0,0),(1,0),(0,1),(1,1)\n        i = abs(i); // abs() eliminates some misses near the origin\n        theta = 2.0*PI*fracmodphi(i-intN); // Set theta=0 at index intN\n\t\tr = sqrt(i+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q); // Most numerically sound measure\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = i;\n\t\t}\n\t}\n    // The algorithm finds the closest point in the set for fracN=0,\n    // but it has a few glitches close to some Voronoi boundaries\n    // near the origin, where points move around a lot with fracN.\n    // The most blatant error is that we sometimes miss cell 0\n    // near the origin. Let's fix that, because it encroaches on\n    // the useful circular portion of cell 0, but leave the rest.\n    // (Straightening out the loop above and just adding this at\n    // the end would make it less of a \"repeated code\" boo-boo,\n    // but GLSL compilers inline almost everything anyway.)\n    if(r2 < 3.0) {\n        theta = 2.0*PI*fracmodphi(0.0-intN);\n\t\tr = sqrt(0.0+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q);\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = 0.0;\n\t\t}\n    }\n    return nn;\n}\n","name":"Common","description":"","type":"common"}]}