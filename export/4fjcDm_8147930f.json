{"ver":"0.1","info":{"id":"4fjcDm","date":"1722435952","viewed":36,"name":"sdNbx","username":"alcomposer","description":"Draws a rounded rectangle with a triangle flag inset (puredata nbx style)\n\nMouse click to turn from rounded to square corners","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 3   \n\nvoid getTri(inout vec2 array[3], float size){\n    array[0] = vec2(0.0f);\n    array[1] = vec2(0.0f, 1.0f) * size;\n    array[2] = vec2(-1.0f, 1.0f) * size;\n}\n\nfloat sdRoundedRect(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b + vec2(r);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x*v1.y - v0.y*v1.x;\n}\n\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPoly(in vec2 p, in vec2[N] poly) {\n    vec2[N] e;\n    vec2[N] v;\n    vec2[N] pq;\n    // data\n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N))); //i+1\n\t\te[i] = poly[i2] - poly[i];\n        v[i] = p - poly[i];\n        pq[i] = v[i] - e[i]*clamp( dot(v[i],e[i])/dot(e[i],e[i]), 0.0, 1.0 );\n    }\n    \n    //distance\n    float d = dot(pq[0], pq[0]); \n\tfor( int i=1; i<N; i++) {\n    \td = min( d, dot(pq[i], pq[i]));\n    }\n\t\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    int wn =0; \n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N)));\n        bool cond1= 0. <= v[i].y;\n        bool cond2= 0. > v[i2].y;\n        float val3= cross2d(e[i],v[i]); //isLeft\n        wn+= cond1 && cond2 && val3>0. ? 1 : 0; // have  a valid up intersect\n        wn-= !cond1 && !cond2 && val3<0. ? 1 : 0; // have  a valid down intersect\n    }\n    float s= wn == 0 ? 1. : -1.;\n    return sqrt(d) * s;\n}\n\nfloat intersect(float shape1, float shape2){\n    return max(shape1, shape2);\n}\n\nfloat subtract(float base, float subtraction){\n    return intersect(base, -subtraction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outerCol = vec4(1.0f);\n    vec4 innerCol = vec4(vec3(0.0f), 1.0f);\n    vec4 bgCol    = vec4(0.56f, 0.84f, 1.0f, 1.0f);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centre = fragCoord - iResolution.xy * 0.5f;\n    \n    vec2 rectSize = vec2(iResolution.x * 0.25f, iResolution.x * 0.125f);\n    \n    float tSize = rectSize.y * 0.5f;\n    \n    vec2 tri[3]; \n    getTri(tri, tSize);\n    \n    float roundRect = sdRoundedRect(centre, rectSize, (iMouse.z > 0.5f) ? 0.0f : 1.0f * (rectSize.y * 0.33f));\n    float triFlag = sdPoly(centre - vec2(rectSize.x, rectSize.y * 0.5), tri);\n\n    float final = subtract(roundRect, triFlag);\n    \n    float outer = fwidth(final);\n    float outerDel = smoothstep(-outer, outer, final);\n    \n    float inner = fwidth(final);\n    float innerDel = smoothstep(-inner, inner, final + rectSize.x * 0.05f);\n    \n    // Output to screen\n    vec4 object = mix(mix(outerCol, innerCol, innerDel), outerCol, outerDel);\n    fragColor = mix(object, bgCol, outerDel);\n}","name":"Image","description":"","type":"image"}]}