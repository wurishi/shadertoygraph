{"ver":"0.1","info":{"id":"MtyfDK","date":"1544055626","viewed":118,"name":"Phase Locked Loop 2","username":"rory618","description":"Here is a demonstration of a phase locked loop simulated in the time domain. It's purpose is to synthesize a wave with the same or some multiple of a reference frequency.\nMore on PLL's:\nhttps://youtu.be/A9qt0JYdvFU\nhttps://youtu.be/SS7z8WsXPMk ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["electronics","pll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 fx(float x, int i, float am){\n    \n    float a = texture(iChannel0, vec2(x-1., float(i)+.5) / iResolution.xy).x;\n    float b = texture(iChannel0, vec2(x, float(i)+.5) / iResolution.xy).x;\n    float c = texture(iChannel0, vec2(x+1., float(i)+.5) / iResolution.xy).x;\n    return am*vec2(b, (c-a)/2.);\n}\n\nvoid plot(inout vec4 fragColor, in vec2 fragCoord, int j, float y, float a){\n    vec2 z = fragCoord-vec2(0., iResolution.y*y);\n    float x = z.x;\n    vec2 fxv;\n    \n    float d = length(z-vec2(x,fx(x,j,a).x));\n    for(int i = 0; i < 5; i++){\n    \tfxv = fx(x,j,a);\n    \tx += (z.y-fxv.x+(z.x-x)/fxv.y)/(fxv.y+1./fxv.y);\n        \n    \td = min(d, length(z-vec2(x,fx(x,j,a).x)));\n    }\n    \n    \n    fragColor = min(fragColor,vec4(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n\tplot(fragColor,fragCoord,0,.2,8.);\n\tplot(fragColor,fragCoord,1,.8,8.);\n\tplot(fragColor,fragCoord,2,.4,16.);\n\tplot(fragColor,fragCoord,3,.6,128.);\n\tplot(fragColor,fragCoord,4,.2,8.);\n    \n\tplot(fragColor,fragCoord,10,.2,1.);\n\tplot(fragColor,fragCoord,10,.4,1.);\n\tplot(fragColor,fragCoord,10,.6,1.);\n\tplot(fragColor,fragCoord,10,.8,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f_ref = 2.+sin(iTime/10.)/8.;\n    float f_vco = 6.0;\n    \n    if(fragCoord.x<1.){\n    \tvec2 ref = get(vec2(0,REF_OSC), iChannel0, R.xy);\n    \tvec2 vco = get(vec2(0,VCO), iChannel0, R.xy);\n    \tvec2 pfcomp = get(vec2(0,PF_COMP), iChannel0, R.xy);\n    \tvec2 lf = get(vec2(0,LOOP_FILTER), iChannel0, R.xy);\n    \tvec2 f_div = get(vec2(0,FRQ_DIV), iChannel0, R.xy);\n        if(iFrame<3){\n            ref = vec2(1,0);\n            vco = vec2(1,0);\n            f_div = vec2(1,0);\n        }\n        \n        //reference oscillator implimented as phasor being multiplied by another phasor corresponding to f_ref each timestep\n        ref = cprod(ref,cis(1./sample_rate*f_ref*2.*pi));\n        \n        //same implimentation for VCO, note the term (lf.x+1.) which uses the loop filter output as a tuning input for the vco\n        vco = cprod(vco,cis((.25*lf.x+1.)/sample_rate*f_vco*2.*pi));\n        \n        //Using a simple multiplier for the phase comparator\n        pfcomp.x = ref.x*f_div.x;\n        \n        //loop filter implimented as running average\n        lf.x = mix(lf.x,pfcomp.x,.002);\n        \n        //Miller frequency divider\n        f_div = normalize(mix(f_div, cprod(vco,conj(csqr(f_div)))*6., .06));\n        \n        \n        set(vec2(0,REF_OSC), ref, fragCoord, fragColor);\n        set(vec2(0,VCO), vco, fragCoord, fragColor);\n        set(vec2(0,PF_COMP), pfcomp, fragCoord, fragColor);\n        set(vec2(0,LOOP_FILTER), lf, fragCoord, fragColor);\n        set(vec2(0,FRQ_DIV), f_div, fragCoord, fragColor);\n    } else {\n        fragColor = texture(iChannel0, (fragCoord-vec2(1,0))/R.xy);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define I1 vec2(0,1)\n#define R1 vec2(1,0)\n#define pi 2.*asin(1.)\n#define e exp(1.)\n\nfloat creal(vec2 z) {\n    return z.x;\n}\nfloat cimag(vec2 z) {\n    return z.y;\n}\nvec2 conj(vec2 z) {\n    return vec2(z.x,-z.y);\n}\nvec2 cprod(vec2 a, vec2 b){\n    return mat2(a,-a.y,a.x) * b;\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nfloat cabs(vec2 z) {\n    return length(z);\n}\nfloat cabs2(vec2 z) {\n    return dot(z,z);\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n}\nfloat carg(vec2 z) {\n    return atan(z.y,z.x);\n}\nvec2 cis(float t){\n    return cos(t - I1*pi/2.);\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*cis(z.y);\n}\nvec2 clog(vec2 z) {\n    return R1*log(cabs(z))+I1*carg(z);\n}\nvec2 cpow(vec2 a, vec2 b) {\n    return cexp(cprod(b,clog(a)));\n}\n\n\n#define R iResolution\n#define REF_OSC 0\n#define VCO 1\n#define PF_COMP 2\n#define LOOP_FILTER 3\n#define FRQ_DIV 4\n\n#define sample_rate 60.\n\nvec2 get(vec2 x, sampler2D ch, vec2 R){\n    return texture(ch, (x+.5)/R).xy;\n}\nvoid set(vec2 x, vec2 v, vec2 fragCoord, inout vec4 fragColor){\n    if(floor(fragCoord)==x){\n        fragColor.xy=v;\n    }\n}","name":"Common","description":"","type":"common"}]}