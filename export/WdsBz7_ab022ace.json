{"ver":"0.1","info":{"id":"WdsBz7","date":"1588018038","viewed":127,"name":"Scope Lab","username":"akohdr","description":"Simple toy for playing around with waves.  Models two free running oscillators red/green and their sum and product blue/yellow.  Note develops numerical artifacts after it's been running for a while, remember to reset.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["oscilloscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    vec2 rz = iResolution.xy,\n         uv = p/rz;\n    \n    float ft = float(iFrame)/60.,\t\t    // frame based time to keep trace stable\n          pt = ft+((.0015*8.)/rz.x)*p.x;\t// pixel timebase\n    \n    vec4 vt = vec4(TAU, PI, 1, .1)*pt,\t\t// factor timebase\n         m4 = signals(vt);\t\t\t\t\t// trace signals\n   \n\tk  = scope(k, m4, p, rz, uv);\t\t\t// generate scope display\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by Andrew Wild - akohdr/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define O4 vec4(1,2,3,4)\n\n#define PI12 0.261799387799149436538553615273291907016430783281258818414578716\n#define PI8  0.392699081698724154807830422909937860524646174921888227621868074\n#define PI4  0.785398163397448309615660845819875721049292349843776455243736148\n#define PI3  1.047197551196597746154214461093167628065723133125035273658314864\n#define PI2  1.570796326794896619231321691639751442098584699687552910487472296\n#define PI   3.141592653589793238462643383279502884197169399375105820974944592\n#define TAU  6.283185307179586476925286766559005768394338798750211641949889185\n\n#define uf(x) mod(x,1.)\n#define ufn(x) (.5+.5*(x))\n#define pfn(x) mod(x,TAU)\n#define usin(x) ufn(sin(x))\n#define uvc(x) clamp(x,vec4(-1),vec4(1))\n\n#define rusaw(x) uf(x)\n#define lusaw(x) (1.-rusaw(x))\n#define lsaw(x) (2.*lusaw((x)/TAU)-1.)\n#define rsaw(x) (2.*rusaw((x)/TAU)-1.)\n#define saw(x) lsaw(x)\n#define usaw(x) ufn(saw(x))\n\n#define sqr(x) (2.*floor(lsaw(x))+1.)\n#define usqr(x) ufn(sqr(x))\n#define fsqr(x) (1.+2.*floor(sin(x)))\n#define ssqr(x) (clamp(2.*sin(x),-1.,1.))\n#define qsqr(x,a,m) (clamp(m*tri(x)+a,0.,1.))\n#define psqr(x,a) qsqr(x,a,PI)\n#define Qsqr(x,a,m) (clamp(m*tri(x)+a,-1.,1.))\n\n#define ssin(x) sin(PI*(sin((x))+sin((x)/2.)))\n#define tri(x) (2.*abs(saw((x)-PI2))-1.)\n#define utri(x) ufn(tri(x))\n#define triu(x) (2.*utri((x)/TAU)-1.)\n#define stri(x) (tan(sin(x))/PI2)\n\n#define sinc(x) (sin(x)/(x))\n#define ssinc(x) sinc(mod((x),4.5*TAU)-PI+.1)\n\n\n\n\n// Generated Traces\nfloat r_trace(float f, float t) {\n    f *= (1.+.0000003*sin(61.*t));\t\t// frequency instability\n    return \n         (1.+.15*sin(101.*t))*\t\t\t// amplitude instability\n//\t\tsaw\n//\t\trsaw\n//\t\ttri\n//\t\tsqr\n//\t\tsin\n    \n//\t\tssin\n//\t\tstri\n\t\tssqr\n    (f*t);\n}\n\nfloat g_trace(float f, float t) {\n    f *= (1.+.0000005*sin(63.*t));\t\t// frequency instability\n    return\n        (1.+.1*sin(103.*t))*\t\t\t// amplitude instability\n//\t\tsaw\n//\t\trsaw\n//\t\ttri\n//\t\tsqr\n//\t\tsin\n    \n//\t\tssin\n\t\tstri\n//\t\tssqr\n    (f*t);\n}\n\n\n// Calculated traces\nfloat b_trace(vec4 m4, float f, float t) {\n    return m4.x + m4.y;\n}\n\nfloat y_trace(vec4 m4, float f, float t) {\n    return m4.x * m4.y;\n}\n\n\n\n\n\n\n\n\nvec4 signals(vec4 vt) {\n\n    float f = 3.*220.;\t// tweaked freq. to display stable untriggered trace\n    \n\t// phase slippage\n    vec2 rt = vt.x+sin(vt.w)*.002*vec2(sin(vt.y),3.*sin(vt.z));\n    \n\t// generate red/green traces\n    vec4 m4 = vec4(\n                r_trace(f, rt.x),\n                g_trace(f, rt.y), 0, 0);\n    \n\t// calculate blue/yellow traces\n    m4 += vec4(0,0,\n                b_trace(m4, f, rt.x),\n                y_trace(m4, f, rt.x));\n    \n    return m4;\n}\n\nvec4 scope( out vec4 k,  vec4 m4, \n                vec2 p,  vec2 rz, vec2 uv)\n{\n    m4 /= 4.;\t\t\t// Y scaling\n    m4 *= vec4(-1);\t\t// compensate for vertical flip (see later)\n\n    m4 += O4-2.5;\t\t// offset channel display\n\n    float d = .002, \n          x = uv.x, \n          y = 1.-uv.y,  // vertical flip to put red on top\n      focus = 10.;\t    // beam thickness\n    \n    k += vec4(smoothstep(focus,0., \n              abs(rz.y-(1.-m4*rz.y/2.)-y*rz.y*2.))+.7*(\n        \n#define GRID\n//#define FINE_GRID        \n\n#ifdef GRID\n              mod(y-.125,.25   )<d ? .5:\t// y = 4n\n              mod(y,.125  )<d ? .2:\t\t\t// y = 2n\n\t\t\t  mod(y,.0625 )<d ? .1:\t  \t\t// y = n\n              abs(x-.25   )<d ? .5:\t\t\t// x = 0\n              abs(x-.75   )<d ? .4:\t\t\t// x = 4\n              mod(x,.125  )<d ? .3:\t\t\t// x = n\n#ifdef FINE_GRID\n\t          abs(y-.5    )<d ? .5: \t\t// y = 0\n\t          mod(x,.0625 )<d ? .2:\t\t\t// x = n/2\n\t          mod(x,.03125)<d ? .1:\t\t\t// x = n/4\n#endif\n#endif\n              0.));\n    \n    k += vec4(k.a,k.a,k.b,-k.a);\t\t\t// add yellow trace / brighten blue\n    \n    k += vec4(.1,.15,.1,0);\t\t\t\t\t// phosphorus esque tint\n\n    vec2 vu = uv*(1. - uv.yx);\n    k *= pow(vu.x*vu.y * 15.0, .25); \t\t// vignette\n\n    return k;\n}\n","name":"Common","description":"","type":"common"}]}