{"ver":"0.1","info":{"id":"MfBBDV","date":"1726916867","viewed":47,"name":"cloud egg hlsl","username":"oleg304","description":"Forked from textured ellipsoids","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","cloud"],"hasliked":0,"parentid":"XsfXW8","parentname":"textured ellipsoids"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ks,ps, ki,pi;  // smoothness/thichness parameters\nvec3 R;              // ellipsoid radius\nmat3 m;\n\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define ddx     dFdx\n#define ddy     dFdy\n#define float2x2 mat2   \n#define float3x3 mat3\n#define mul(a, b) b*a \n#define SamplerState float\n#define Texture2D float\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n// float3 rg = Texture2DSample(tex, texSampl, uv);\n#define ddx dFdx\n#define ddy dFdy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n// static const int constArray[4] = { 1, 2, 3, 4 };\n\n//struct Func {\n\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\n#define PI 3.1415927\n\nfloat hash( float n ){return frac(sin(n)*43758.5453);}\nfloat noise(float3 x ){\n    float3 p = floor(x),f = frac(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),\n                        lerp( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n                        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\nfloat snoise(float3 x ){ return 2.*noise(x)-1.; }\n\nfloat fbm(float3 p ){\n\tp += iTime; \n    float f=.5*noise(p); p=mul(m,p)*2.02;\n    f+=.25*noise(p); p=mul(m,p)*2.03;\n    f+=.125*noise(p); p=mul(m,p)*2.01;\n    f+=.0625*noise(p);\n    return f;\n}\n\nfloat3x3 lookat(float3 O, float3 T, float d) {\n\tfloat3 OT = normalize(T-O);\tfloat3x3 M;\n    M[0] = OT; M[2] = float3(normalize(float3(0.,0.,1.)-OT.z*OT)/d);\n\tM[1] = float3(cross(M[2],OT));\n\treturn M;\n}\n\nbool intersect_ellipsoid(float3 O,float3 D, out float3 P, out float3 N, out float l) {\n\tfloat3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \n\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\n\tfloat d = OD*OD - (OO-1.)*DD;\t\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\n\t// ray intersects the ellipsoid (and not in our back)\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\t\t\n\tfloat t = (-OD-sqrt(d))/DD;\t// return intersection point, normal and thickness\n\tP = O+t*D;\n\tN=normalize(P/(R*R));\n\tl = 2.*sqrt(d)/DD;\n\treturn true;\n}\n\nfloat4 draw_obj(float3 O, float3x3 M, float2 pos, int mode, float4 col0) {\n  float l;\n  float3 L = normalize(float3(-.4,0.,1.));  // light source\n  float3 D = normalize(mul(float3(1.,pos),M));\t// ray\t\n\tfloat3 P,N; \n\tif (! intersect_ellipsoid(O,D, P,N,l)) return float4(0.,0.,0.,0.);\t\n\tfloat3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\n\t     Nn = normalize(P/R);\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\n\tfloat A, l0 = 3.;\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\n\tl = clamp(l-6.*ni,0.,1e10);\n\tfloat As = pow(ks*nd, ps), Ai = 1.-pow(.7,pi*l);\t // silhouette and interior\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\n\tif (mode==2) A = 1.- (1.-As)*(1.-Ai);  \t// mul Ti and Ts\n\telse A = (mode==0) ? Ai : As; \n\tA = clamp(A,0.,1.); \n\tnl = .8*( nl + ((mode==0)?fbm(Pm-10.):fbm(P+10.)));\n#if 0 // noise bump\n\tN = normalize(N -.1*(ddx(A)*M[1]+ddy(A)*M[2])); \n\tnl = clamp(dot(N,L),0.,1.);\n#endif\t\n\tfloat4 col = float4(1.,1.,1.,1.)*lerp(nl,1.,AMBIENT);\n\treturn lerp(col0,col,A);\n}\n\nfloat4 res (float2 uv, float t, float amp, Texture2D tex0, SamplerState ts, float2 mRot){   \n   // iTime = time, amplitude = amp; tex = tex0; texSampl = ts;  \n   m = float3x3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);\n   R = float3(2.,3.,2.);\n   uv -= float2(.9,.5);\n   uv*=2.;   \n\tfloat2 mouse = 2.*(mRot-float2(.85,.5));\n\tfloat z = .2;\n\tks=1.+mouse.x, ps=mouse.y*8.;\n\tks=1.; ps=3.; ki=.9; pi=3.;\t\n\t//if (iMouse.x>0.){t=-PI/2.*mouse.x; z=-PI/2.*mouse.y;}\n\tfloat3 O = float3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\n\tfloat compas = t-.2*uv.x; float2 dir = float2(cos(compas),sin(compas));    \n\tfloat4 fColor = clamp(float4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); // sky\n\tfloat3x3 M = lookat(O,float3(0.,0.,0.),5.); \n\tfloat2 dx = float2(1.,0.);\t\t\n    fColor=draw_obj(O,M, uv, 2,fColor);\t    \n   return fColor; \n}\n\n//float iTime, amplitude,ks,ps, ki,pi; Texture2D tex; SamplerState texSampl; float3x3 m; float3 R;}; Func f; return f.res(tc, t0, amp, tex, texSampler);\n\n//// HLSL -> ShaderToy\nvoid mainImage(out float4 fragColor, in float2 fragCoord) {    \n    float2 uv\t= fragCoord.xy / iResolution.y;\n    Texture2D tex;\n    fragColor = vec4(res(uv, iTime, 140., tex, 1., iMouse.xy));\n}","name":"Image","description":"","type":"image"}]}