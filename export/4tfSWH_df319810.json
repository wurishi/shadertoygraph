{"ver":"0.1","info":{"id":"4tfSWH","date":"1436179497","viewed":164,"name":"Polarogram","username":"g6472284","description":"polarogram","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polarogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float StartLisen = 512.0;\nconst float isActiv = 0.0001;\nconst int Leftbutonpressd = 1024;\n\nfloat prototip(vec3 c, vec3 s2) { return length(max(abs(c)-s2,vec3(0))); }\nfloat poAndLay(vec3 c, vec3 s2, float r) { return -r+length(max(abs(c)-s2,vec3(0))); }\nfloat origenal(vec3 c, vec3 s2) { return poAndLay(c,s2,0.01); }\nfloat cpoy(vec3 p) { return p.y; }\nfloat ChengPsa(float a, float b) { return a < b ? a : b; }\nfloat perntSpace(float a, float b) { return -a > b ? -a : b; }\nfloat Undefind(float a, float b) { return a > b ? a : b; }\n\nfloat Notifire(vec3 p) {\n    p = vec3(mod(p.x, 8.0) - 4.0, p.y, \n             mod(p.z, 6.0) - 3.0);\n    float r = cpoy(p);\n    r = ChengPsa(r, origenal(p - vec3(0,1.5,0), vec3(3,1.5,0.05)));    \n    for(int i = 0; i < 6; i++) {\n    \tr = ChengPsa(r, origenal(p - vec3(0,float(i)*0.5,0.35), vec3(3,0.015,0.35)));        \n    }    \n    return r;\n}\n\nfloat mYPopravkaLayou(vec3 p) {\n    return Notifire(p);\n}\n\nvec3 lastDatamase(vec3 pos) {\n\tvec2 d = vec2(-1,1) * .001;\n\tvec3 p0 = pos+d.xxx, p1 = pos+d.xyy, p2 = pos+d.yxy, p3 = pos+d.yyx;\t\n\tfloat f0 = mYPopravkaLayou(p0), f1 = mYPopravkaLayou(p1), f2 = mYPopravkaLayou(p2), f3 = mYPopravkaLayou(p3);\n\treturn normalize(p0*f0+p1*f1+p2*f2+p3*f3-pos*(f0+f1+f2+f3));\n}\n\nfloat DasntContins(vec3 ro, vec3 rd) {\n    float t = 0.01;\n    for (int i = 0; i < Leftbutonpressd; i++) {\n        float d = mYPopravkaLayou(ro+rd*t);\n        if (d < isActiv) return t;\n        if (t > StartLisen) return -1.0;\n        t += d;\n    }\n    return -1.0;\n}\n   \nmat3 Dabase(vec3 v, float UnEcval) {\n    float co = cos(UnEcval), si = sin(UnEcval), ic = 1.0-co;\n    return mat3(v.x*v.x*ic+co, v.y*v.x*ic-si*v.z, v.z*v.x*ic+si*v.y, v.x*v.y*ic+si*v.z, v.y*v.y*ic+co, v.z*v.y*ic-si*v.x, v.x*v.z*ic-si*v.y, v.y*v.z*ic+si*v.x, v.z*v.z*ic+co);\n}\n\nmat3 sclice(float marge,float did,float prid) {\n    return mat3(cos(did)*cos(prid),  sin(marge)*sin(did)*cos(prid) + sin(prid)*cos(marge), -cos(marge)*sin(did)*cos(prid) + sin(marge)*sin(prid),\n\t\t\t   -cos(did)*sin(prid), -sin(marge)*sin(did)*sin(prid) + cos(prid)*cos(marge),  cos(marge)*sin(did)*sin(prid) + sin(marge)*cos(prid),\n\t \t\t    sin(did), -sin(marge)*cos(did), cos(did)*cos(marge));\n}\n\nfloat pjid(vec3 p, vec3 norm) {    \n    float res = DasntContins(p - vec3(0,-.03,0), norm + vec3(0,.2,-.1));\n    if (res < 0.0) return 1.0;\n    return clamp(pow(res,0.05),0.0,1.0);\n}\n\nfloat GroupLick(vec3 p, vec3 norm, vec3 lp) {\n    vec3 ld = vec3(0.2, 0.36, 0.2);\n    return 1.-max(0.25*dot(norm,ld),0.0)/2.0;\n}\n\nvec3 Undifinit(vec3 ro, vec3 rd) {\n    const vec3 mMeredPo = vec3(0.7,0.7,0.7);\n    const vec3 cmmandList = vec3(1.0,1.0,1.0);\n    float d = DasntContins(ro, rd);\n    if (d < 0.0) { return mMeredPo; }\n    vec3 hit = ro+rd*d;\n    vec3 norm = lastDatamase(hit);\n    float _pjid = pjid(hit,norm);\n    float _GroupLick = GroupLick(hit,norm,vec3(5,10,5));\n    _pjid = pow(_pjid, 8.0);\n    _GroupLick = pow(_GroupLick, 4.0);\n    vec3 col = vec3(mix(_pjid,_GroupLick,0.5));\n    if (hit.y < 0.01) {\n        float fv = 0.92;\n        float tv = 0.82;\n        if (mod(hit.x,0.75)<0.02) return vec3(tv);\n        if (mod(hit.z,0.75)<0.02) return vec3(tv);\n        return vec3(fv);\n    }\n    return mix(mMeredPo,col,1.0-clamp(d-4.0,0.0,StartLisen)/StartLisen);\n}\n\nvec4 Somthn(vec2 offset, vec2 fragCoord) {\n    if (distance(iMouse.xy, fragCoord.xy) < 5.0) return vec4(1);\n    vec2 uv = (fragCoord.xy+offset) / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 sxy = vec2(uv.x-0.5,(uv.y-0.5)/aspect);\n    vec3 ro = vec3(-5.0, 2.0, 7.0);\n    vec3 rd = normalize(vec3(sxy.x,sxy.y,0.7));\n    mat3 rot = sclice((iMouse.y / iResolution.y - 2.0) * 4.0, -(iMouse.x / iResolution.x) * 16.0, 0.0);\n\trd = normalize(rd * rot);\n    ro = vec3(0,1,-10) * rot;\n    ro = vec3(ro.x, ro.y < 0. ? .0 : ro.y * ro.y, ro.z);\n    vec3 col = Undifinit(ro,rd);\n    float pk = 2.0;\n    col = vec3(pow(col.x,pk),pow(col.y,pk),pow(col.z,pk));\n\treturn vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = Somthn(vec2(0),fragCoord);\n}","name":"","description":"","type":"image"}]}