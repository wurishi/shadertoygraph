{"ver":"0.1","info":{"id":"tt2SRd","date":"1566941885","viewed":172,"name":"Fire Kamehameha","username":"TheRomanOne","description":"Tried to make a 2D animation with 3D  SDFs.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["torus","fire","rings","sin","animation","kamehameha"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\nI wanted to see if I could make a 2D \"kamehameha\" like\nblast with 3D SDFs\n\nI probably don't need ALL the code that's here\nfor a simple scene like this, but I enjoyed setting\nthis whole \"engine\" up and play around with it.\n\nFirst time I try this approach from scratch, I mostly\nwanted to see how much I understand..\n\n*/\n\n#define eps 0.001\n#define max_dist 1000.\n#define PI 3.141592654\n\n#define BACKGROUND 0.\n#define DOUBLE_RING 0.\n#define CRYSTAL 1.\n#define KAMEHAMEHA 2.\n\nfloat time;\n\n\nmat2x2 rot(float deg)\n{\n    float ang = deg * PI / 180.;\n    float s = sin(ang), c = cos(ang);\n    return mat2x2(c, s, -s, c);\n}\n\nfloat torus(vec3 p, vec3 pos, vec2 width, float radius)\n{\n    p += pos;\n    \n    vec2 q = vec2(length(p.xz)-width.x - radius,p.y);\n    return length(q)-width.y;\n}\n\nfloat doubleRing(vec3 p)\n{\n    float dtime = sqrt(sqrt(2.*time));\n    vec3 pivot = vec3(0, 0, 0.);\n    \n    //p-= pivot;\n    //p += pivot;\n    \n    float compl;\n    \n    compl= sin((dtime));\n    \n    // Bottom ring\n    vec3 pos1 = pivot;\n    float rad1 = .5 * compl;\n    vec2 w1 = vec2(.01) + .02 * vec2(0., sin(dtime*3.25));\n    float t1 = torus(p, pos1, w1, rad1);\n    \n    // Top ring\n    vec3 pos2 = pos1 + vec3(0, -.2, 0.);\n    float rad2 = .35 * compl;\n    vec2 w2 = vec2(.01) + .02 * vec2(0., sin(3.25*dtime));\n    float t2 = torus(p, pos2, w2, rad2);\n    //time = tt;\n    \n    return min(t1, t2);\n}\n\nfloat ball(vec3 p, vec3 pos, float rad)\n{\n    return length(p - pos) - rad;\n}\n\nfloat kamehameha(vec3 p, vec3 pos, vec3 c )\n{\n    p += pos;\n    float r = .1;\n    \n    p.y -= clamp( p.y, 0.,.3)+.07;\n    float l = length(p) - r - 1.1*sin(p.y * max(.0, .9 + .05*sin(time*50.)));\n    \n    return l+time/10.;\n    \n}\n\nvec2 blast(vec3 p)\n{\n    p.xz *= rot(55.);\n    p.yz *= rot(-55.);\n    float d = doubleRing(p);\n    float b = ball(p, vec3(0, -.1, 0), .04);\n    \n    float k = kamehameha(p, vec3(0, .2, 0), vec3(.1));\n    float obj = 0.;\n    \n    if(k < d)\n    {\n        d = k;\n        obj = KAMEHAMEHA;\n    }\n    \n    if(b < d)\n    {\n        d = b;\n        obj = CRYSTAL;\n    }\n    \n    return vec2(obj, d);\n}\n\nvec2 map(vec3 p)\n{    \n    return blast(p);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(eps, 0, 0)).y - map(p - vec3(eps, 0, 0)).y,\n        map(p + vec3(0, eps, 0)).y - map(p - vec3(0, eps, 0)).y,\n        map(p + vec3(0, 0, eps)).y - map(p - vec3(0, 0, eps)).y\n        ));\n}\n\nvec3 lighting(vec3 newRay, vec3 light, vec2 data)\n{\n    vec3 col;\n    \n    if(data.x == KAMEHAMEHA)\n    {\n        vec3 kLight = vec3(0, 0, -5);\n        kLight.yz *= rot(-time*2500.);\n        kLight.xz *= rot(-time*1500.);\n        float dt = dot( deriv(newRay), kLight );\n        \n        if(dt > .5 * sin(newRay.x*10. + 10.*time))\n            col = vec3(1., .2, 0.);\n        else col = vec3(1., 0, 0);\n\n        vec3 kLight2 = vec3(0, 1, 0);\n        kLight2.yz *= rot(-time*2000.);        \n        \n        dt = dot( deriv(newRay), kLight2 );\n        \n        if(dt < .5 * sin(newRay.x*10. + 10.*time))\n            col *= vec3(1., .5, .9);\n        else if(dt < .7)\n            col = vec3(1., 1., 0);\n        \n            \n        \n        kLight = vec3(-5.*sin(time*100.), -sin(time), -7);\n        //kLight.yz *= rot(-time*2500.);\n        //kLight.xz *= rot(-time*1500.);\n        dt = dot( deriv(newRay), kLight )/5.;\n        \n        if(dt > .4 * cos(newRay.x*time))\n            col = vec3(1.);\n        \n        //col = vec3(dt);\n    }else\n    {\n        float dt = dot( deriv(newRay), light );\n\n        if(data.x == DOUBLE_RING)\n            col = vec3(240., 0., 56.)/255.;\n\n        else if(data.x == CRYSTAL)\n            col = vec3(0, 0, 1);\n\n        if(dt > .5 + .2 * sin(newRay.x*10. + 10.*time))\n            col = vec3(0.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 camPos = vec3(.2, 0., 0);\n    vec3 ro = camPos + vec3(0., 0, -1.);\n\n    vec3 ta = camPos + vec3(0., 0, 1);\n    \n    // Don't really need cam vectors since I'm not moving\n    // the camera around..\n    \n    /*vec3 fw = normalize(ta - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up = cross(fw, ri);*/\n    vec3 rd = /*mat3x3(ri, up, fw) **/ vec3(uv, 1);\n    \n    \n    // THIS line is what sets the pace of the animation\n    //time = mod(iTime, PI/2. - .1);\n    \n    if(iMouse.z> 0.)\n\t\ttime = mod(iMouse.x/iResolution.y, PI-.5);\n    else\n    //if(time > PI/2.-5.)\n        time = mod(iTime, PI-.5);\n    \n    float dist, t;\n    vec3 newRay;\n    vec2 data;\n    for(int i = 0; i < 256; i++)\n    {\n        newRay = ro + t * rd;\n        data = map(newRay);\n        dist = data.y;\n        if(dist < 0.01)\n            break;\n        else if(t > max_dist)\n        {\n            newRay = vec3(max_dist);\n            break;\n        }\n        t += dist *.7;\n    }\n    \n    // Time varying pixel color\n    \n    vec3 col = vec3(0);\n    if(dist < max_dist)\n    {\n        vec3 light = normalize(vec3(1, 1, -2));\n        col = lighting(newRay, light, data);\n        col *= lighting(newRay, vec3(0, sin(time*5.), -1. + sin(time)), data);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}