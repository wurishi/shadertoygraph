{"ver":"0.1","info":{"id":"wlXfRs","date":"1597442094","viewed":81,"name":"Fantasy zeppelin ","username":"johnyboy94","description":"Not as detailed yet as I'd like.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SIZE 50.\n#define STEPS 100.\n#define SHARPNESS 0.01\n\n#define PI 3.14159\n\n//#define DIST_ORIGIN\n#define DIST_SURFACE\n//#define NORMALS\n\n\n\n// By Neil Mendoza, changed to be mat3\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\nvec3 toSphCoords(vec3 cart)\n{\n    return vec3(length(cart), atan(cart.y/cart.x), atan(length(cart.xy) / cart.z));\n}\n\n\n\nvec3 toCylCoords(vec3 cart)\n{\n    return vec3(length(cart.xy), atan(cart.y / cart.x), cart.z);    \n}\n\n\n\nfloat sdBox(in vec3 p, in vec3 c, in vec3 b)\n{\n\tvec3 q = abs(p - c) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\t// Nani the f***?\n    // Q is the vector between abs current position relative to the cube center\n    // Then find the length of positive only q (negative is inside) and biggest positive value of q.xyz\n    // After writing all this, I still don't know how that works.\n}\n\n\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r)\n{\n    return (distance(p, c) - r);\n}\n\n\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r)\n{\n\tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float projLength = dot(ab, ap) / dot(ab, ab);\n    projLength = clamp(projLength, 0., 1.);\n    \n    vec3 closestPoint = a + (projLength * ab);\n    \n    // Add stripes, use spherical coordinates, swizzle so it aligns the capsule\n    //(maybe only works because it's axis aligned? I really am not sure)\n    vec3 cylCoords = toCylCoords(normalize(p - closestPoint).zyx);\n    \n    // Horizontal stripes\n    float hsDensity = .3;\n    float hsThickness = .033;\n   \n    float stripes = max(0., mod(cylCoords.y, hsDensity) - (hsDensity - hsThickness));\n    \n    // Onion rings... I mean vertical stripes\n    float csDensity = .8;\n    float csThickness = 0.02;\n    float crossStripes = max(0., mod(p.x, csDensity) - (csDensity - csThickness));\n    \n    float meridians = max(crossStripes, stripes);\n    \n    return (distance(p, closestPoint) - r) - meridians * 0.1;\n}\n\n\n\nfloat sdPlane(vec3 pos, vec4 plane)\n{\n\treturn dot(pos, plane.xyz) + plane.w;\n}\n\n\n\n// generic ellipsoid - improved approximated distance by iq\nfloat sdEllipsoid(in vec3 p, in vec3 r) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    \n    return k0*(k0-1.0)/k1;\n}\n\n\n\nfloat sdEllipsoidStriped(in vec3 p, in vec3 r) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    \n    /* My own adition */\n    float stripes = dot(normalize(p), vec3(1., -1., -1.));\n    stripes = abs(mod(stripes, 0.3) - 0.15);\n\n    /* Added to the final result*/\n    return (k0*(k0-1.0)/k1) + stripes * .4;\n}\n\n\n\nfloat sdTailV(in vec3 p, in vec3 r)\n{                       \n    // Vertical part\n    float stripes = p.y;\n    stripes = abs(mod(stripes, .4) - 0.2);\n    \n    p.z += sign(p.z) * stripes * stripes;\n    \n    float heightCutoff = .8;\n    float deform =  pow(max(-(p.y - (heightCutoff)), 0.), .2);\n    \n\tp.x += sign(p.x) * deform;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    \n\n    return k0*(k0-1.0)/k1; \n}\n\n\n\nfloat sdTailH(in vec3 p, in vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    \n    float box = sdBox(p, vec3(r.x, 0., 0.), vec3(r.x, 2., 6.));\n    \n\tfloat ell = k0*(k0-1.0)/k1; \n    \n    //return box;\n    return max(ell, -box);\n}\n\n\n\nfloat sdLHull(in vec3 p, in vec3 c, in vec3 r)\n{\n    float ell = sdEllipsoid(p - c, r);\n    float box1 = sdBox(p, vec3(c.x, c.y + r.y, c.z), vec3(r.x * 2., r.y, r.z * 2.)); \n    float box2 = sdBox(p, vec3(c.x + r.x * 1.5, c.y, c.z), r);\n    \n    ell = max(ell, -box1);\n    ell = max(ell, -box2);\n    \n    return ell;\n}\n\n\n\nfloat distToScene(in vec3 pos)\n{\n    // Scene geometry, plane always tangent to the sphere\n    const float r = 2.;\n    const vec4 plane = vec4(0., 1., 0., r);\n    \n    const vec3 ellPos = vec3(0., 2., 5.);\n    const vec3 ellRad = vec3(4., 2., 2.);\n    \n    const vec3 boxPos = vec3(0., .9, 5.);\n    const vec3 boxDim = vec3(1.6, 0.8, .5);\n    \n    const vec3 tailPos = vec3(1.75, 2.0, 5.0);\n    const vec3 tailRad = vec3(3.5, 3.0, 0.2);\n    \n\n    \n    // March and combine\n    float planeDist = sdPlane(pos, plane);\n    float d = planeDist;\n    \n    // Baloon\n    //float ellDist = sdEllipsoidStriped(pos - ellPos, ellRad);\n    //float d = min(planeDist, ellDist);\n    \n    float bodyDist = sdCapsule(pos, vec3(-4., 2., 5.), vec3(1.8, 2., 5.), 1.8);\n    d = min(d, bodyDist);\n\n    // Upper hull\n    float upHullDist = sdBox(pos, boxPos, boxDim) - 0.2;\n    d = min(d, upHullDist);\n    \n    // Middle hull\n    float midHullDist = sdBox(pos, vec3(0.3, 0.0, 5.),  vec3(0.6, 0.3, 0.3)) - .1;\n    d = min(d, midHullDist);\n    \n\t// Lower hull\n    float lHullDist = sdLHull(pos, vec3(-.5, -.3, 5), vec3(4., 1., 1.));\n    d = min(d, lHullDist);\n    \n    \n    // Tail\n    float tailVert = sdTailV(pos - tailPos, tailRad); \n    float tailHori = sdTailH(pos - vec3(2.2, 1.6, 5.), vec3(2.5, 0.3, 2.3));\n    //sdEllipsoid(pos - vec3(1.5, 2., 5.) , vec3(3., 0.1, 2.));\n                                \n    d = min(d, tailVert);\n    d = min(d, tailHori);\n    \n \n    return d;\n}\n\n\n\nvec3 getRayDir(in vec2 uv, in float focalDist)\n{\n    return normalize(vec3(uv.x, uv.y, focalDist));\n    //return vec3(uv.x, uv.y, focalDist);\n}\n\n\n\nvec3 getNormal(in vec3 pos)\n{\n\tfloat d = distToScene(pos);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n        distToScene(pos - e.xyy),\n        distToScene(pos - e.yxy),\n        distToScene(pos - e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat obscure(in vec3 pos, vec3 lPos)\n{\n    return 1.;\t// Some other time maybe\n}\n\n\n\nvec3 illuminate(in vec3 pos, in vec3 normal)\n{\t\n    float sTime = iTime * .33;\n    \n    vec3 lPos = vec3(8., 4. + 2. * sin(sTime) , 4.) * 2.;\n    \n    lPos.xz = mat2(vec2(cos(sTime), sin(sTime)), vec2(-sin(sTime), cos(sTime))) * lPos.xz;\n    lPos.z = -abs(lPos.z);\n    \n    vec3 lDir = lPos - pos;\n    \n    float att = length(lDir);\n    lDir /= att;\n    att *= att;\n    \n    vec3 lc = vec3(0.9, 0.8, .7) * 1.;\n    float li = 333. / att; \n    \n    float diffuse = dot(normal, lDir);\n    \n    float shadow = obscure(pos, lPos);\n    \n    return lc * clamp(diffuse * li * shadow, 0.15, 1.);\n}\n\n\n\nvec3 rayMarch(in vec3 ro, in vec3 rd)\n{\n    // Setup\n    vec3 col = vec3(0.);\n    float distOrigin = 0.;  \n    float ds = 0.;\n    \n    for(float i = 0.; i < STEPS; i++)\n    {\n        vec3 pos = ro + (distOrigin * rd);\n         \n        ds = distToScene(pos);\n        \n        distOrigin += ds;\n        \n        if(ds < SHARPNESS || distOrigin > SCENE_SIZE)\t//5, 2\n        \tbreak;   \n    }\n    \n    vec3 pos = ro + distOrigin * rd;\n    vec3 normal = getNormal(pos);\n    \n    #ifdef DIST_ORIGIN\n    \tcol = vec3(distOrigin / SCENE_SIZE);\n    \tcol *= illuminate(pos, normal);\n\t#endif\n    \n    #ifdef DIST_SURFACE\n    \tfloat prox = step(ds, SHARPNESS);\t// smoothstep(SHARPNESS, 0., ds * ds);\n    \tcol = vec3(prox) * illuminate(pos, normal);\n    #endif\n   \n    #ifdef NORMALS\n    \tcol = normal;\n    #endif\n    \n    return col; \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n        \n    vec3 ro = vec3(2.5, 2., -.5);\n    vec3 rd = getRayDir(uv, 1.);\n    \n    // Move between floor and zeppelin calculations and it looks like the zep sways, rather than the camera\n    mat3 rotMat = rotationMatrix(normalize(vec3(.25, 1., 0.1)), .4 + sin(iTime * .4) * .1) ;\n\trd = rotMat * rd;\n    \n    vec3 col = rayMarch(ro, rd);\n    \n    //gama correction adjusts to brightness, if i got this right, but it's very crude currently...\n    float gammaFactor = 1.2 + sin(iTime * .33) * .4;\n    col = pow(col, vec3(1. / gammaFactor));\t\n    \n    fragColor = vec4(col, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}