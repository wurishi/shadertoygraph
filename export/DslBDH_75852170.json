{"ver":"0.1","info":{"id":"DslBDH","date":"1689968422","viewed":113,"name":"Modular Path Tracing Renderer","username":"Oman395","description":"Extremely modular renderer with support for global illumination, phong lighting for direct-only illumination, and is very easy to add new shapes to (ish).","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","gi","globalillumination","pathtracing","rt","pt","modular","customizable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* Modular GI Renderer\nMade by Oran RH\nOman395 on shadertoy/github\n\nThis is the culmination of all the work that I've done on shaders so far. It takes pretty much every technique I've learned (sans a few that require more modern opengl)\nand uses them in a way that is extremely modular and extensible. Everything is written with customization in mind; major functions that could be modfied are refactored\nout, as are constants, and with clever use of switch statements and preprocessor macros it should support any shape you can write an SDF for (with a couple caveats).\n\nThe rendering itself is decent-- there's a lot of room for improvement, and a lot of algorithms for GI with path tracing that I could implement at some point. In\nparticular I'm interested in an algorithm I've heard about that uses forward and backward propogation of light to make it *way* more effecient. Additionally, I have some\nideas for how to speed things up-- not sure how well they'd work, but there you go.\n \nNote: Image/Buffer B have very little actual code, because they are just for averaging frames; look in buffer A for a bit of detail, but most of the code is in\ncommon (so that I can call the functions from other buffers if needed).\n\n* How to add a new object type\n1. Add a #define [object type name] to the top of the page\n\n2. Define the struct for the object type, and take note of which object id is unused that you plan to use for this type. For a sphere, it would look like this:\n#ifdef TORUS\nstruct Torus {\n    Object object;\n    vec2 radiuses;\n};\n#endif\nRemember, if you forget the ifdef/endif, this will cause problems if you try to render a scene without any of the object type! I will not include this warning again.\n\n3. Define its array. For a sphere, it might look something like:\nSphere spheres[] = Sphere[](\n    // Sphere definitions (I don't want to clog this up by including it)\n);\n\n4. Add its sdf. Define a function called \"sdf\", with the inputs of the position and the object, that returns a float.\n\n5. Add the new object type to the sdScene function. Simply copy a previous one, replace all instances of it's type with the new one, and change the number assigned\nto dMinObj to the one chosen in step 2. Note: MAKE SURE THAT YOU ARE DOING THIS IN THE FUNCTION THAT DOES NOT HAVE \"ignoreType\"/\"ignoreId\" AS A PARAMETER! Also, make\nsure that you remember the #ifdef AND #endif!\n\n6. Repeat for ignoreType/ignoreId. Make sure to copy down the previous loop from the function with ignoreType/ignoreId, because everything *will* break if you don't.\n\n7. Add the new object type to getMaterial(). This one is super simple-- just copy a previous one, change the case to be the id chosen in step 2, and change the old object\ntype array to the new one.\n\nThat should be it! Common mistakes include forgetting to change certain references to other object types when copying, as well as mixing up ids. If you still can't find\nthe bug, try following the steps again, but manually typing out the addition, rather than copying a previous one.\n\n* TODOS\n- Scattering\n- Improved performance\n - Better tracing algorithm?\n- Better pRNG\n - Potentially just need better seed generation\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    #ifdef USE_SIRBIRD_DENOISER\n    fragColor = vec4(sirBirdDenoise(iChannel0, uv, iResolution.xy), 1);\n    #endif\n    #ifdef USE_HDR_TONEMAP\n    // Shamelessly stolen from https://learnopengl.com/Advanced-Lighting/HDR\n    // reinhard tone mapping\n    vec3 mapped = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n    // gamma correction \n    mapped = pow(mapped, vec3(1.0 / GAMMA));\n    fragColor = vec4(mapped, 1);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// These are just for use when there aren't any of a particular shape in a given scene; I can't define empty arrays, but I can just #ifdef it out :3\n#define BOXES\n#define SPHERES\n#define TORUS\n\n// More of a general setting, literally just defines whether a plane should be used as a ground\n// !! IF YOU ARE USING THIS WITH CUSTOM OBJECT TYPES, MAKE SURE TO SET PLANE_OBJ_ID TO AN UNUSED OBJECT ID\n#define USE_PLANE\n\n// The following are rendering modes/related settings. Each rendering mode is incompatible with eachother; as well, they will change the Material struct; if you change\n// this, make sure that all material definitions are fixed!\n//\n// Global Illumination related settings\n#define GLOBAL_ILLUMINATION\n// Average values across frames normally (without being able to reset)\n// #define AVG_VALS_NORMAL\n// Average values across frames with extra logic for resetting time when R is pressed, or the mouse is held down\n#define AVG_VALS_WITH_RESET\n#define USE_REFRACTION\n\n// Camera settings\n#define USE_HDR_TONEMAP\n// #define USE_SIRBIRD_DENOISER\n\nconst float PI = 3.14159265;\nconst float TAU = PI * 2.0;\nconst vec2 EPSILON = vec2(0.0001, 0); // Arbitrary small value; used in normal calculation, the smaller it is the higher precision normals.\n// if it's too small (or large) things will break!\n\n// Height of plane, if USE_PLANE is defined\nconst float PLANE_HEIGHT = -1.0;\nconst int PLANE_OBJ_ID = 3;\n\n// Ray marching settings\nconst int MAX_MARCH_COUNT = 96;\nconst float MAX_DIST = 10.0;\nconst float MIN_DIST = 0.0001;\n\n// If a ray moving away from the center is outside this radius, it will instantly be determined whether it should just intersect with the ground, or go into the sky\nconst float SCENE_BOUND_RADIUS = 4.0;\n\n// Global illumination settings\nconst int MAX_BOUNCE = 10;\nconst int SAMPLE_COUNT = 1;\n\n// Camera settings\nconst vec3 CAM_ORIGIN = vec3(0, -0.25, -7);\nconst vec2 CAM_DIR_ORIGIN = vec2(0, 0);\nconst float FOCUS_DIST = 2.5;\nconst float GAMMA = 2.2; // Only if USE_HDR_TONEMAP is defined\n\n// Denoiser settings (if USE_SIRBIRD_DENOISER is defined)\nconst int SAMPLES = 80; // HIGHER = NICER = SLOWER\nconst float DISTRIBUTION_BIAS = 0.1; // between 0. and 1.\nconst float PIXEL_MULTIPLIER = 1.5; // between 1. and 3. (keep low)\nconst float INVERSE_HUE_TOLERANCE = 20.0;// (2. - 30.)\n\n// ifdefs aren't technically necessary here, but I can't define default values for parameters or anything, so it makes material declaration a lot cleaner\nstruct Material {\n    vec4 color;\n    #ifdef GLOBAL_ILLUMINATION\n    vec4 emission;\n    float roughness;\n    #ifdef USE_REFRACTION\n    bool isRefractive;\n    float refractiveIndex;\n    float reflectPercentage;\n    #endif\n    #endif\n};\n\nstruct MarchData {\n    vec3 position;\n    int type;\n    int id;\n};\n\nstruct CamData {\n    vec3 camPos;\n    vec3 rayDir;\n    vec2 uvN;\n    vec2 mouse;\n};\n\n// Current object types:\n// 0: Sphere\n// 1: Box\n// 2: Torus\n// !!! REMEMBER TO DEFINE THESE CORRECTLY WHEN CREATING STRUCTS THAT HAVE AN OBJECT STRUCT AS A MEMBER !!!\nstruct Object {\n    Material material;\n    vec3 position;\n    int type;\n};\n\n#ifdef SPHERES\nstruct Sphere {\n    Object object;\n    float radius;\n};\n#endif\n\n#ifdef BOXES\nstruct Box {\n    Object object;\n    vec3 bounds;\n};\n#endif\n#ifdef TORUS\nstruct Torus {\n    Object object;\n    vec2 radiuses;\n};\n#endif\n\n// Mostly just used as a debug material when creating several shapes, it saves time by making it so that I don't need to write out a whole new material for each object\nconst Material defaultMaterial = Material(\n    vec4(1) \n    #ifdef GLOBAL_ILLUMINATION\n    ,\n    vec4(0),\n    1.0 \n    #ifdef USE_REFRACTION\n    ,\n    false,\n    1.0,\n    0.0\n    #endif\n    #endif\n);\n\n#ifdef USE_PLANE\nconst Material planeMaterial = defaultMaterial;\n#endif\n\n#ifdef SPHERES\nSphere spheres[] = Sphere[](\n    Sphere(\n        Object(\n            Material(\n                vec4(1, 0, 0, 1),\n                vec4(0),\n                1.0\n                #ifdef USE_REFRACTION\n                ,\n                false,\n                1.0,\n                0.0\n                #endif\n            ),\n            vec3(-1, -0.6, -1),\n            0\n        ),\n        0.4\n    ),\n    Sphere(\n        Object(\n            Material(\n                vec4(0),\n                vec4(10),\n                1.0\n                #ifdef USE_REFRACTION\n                ,\n                false,\n                1.0,\n                0.0\n                #endif\n            ),\n            vec3(0, 1, 0),\n            0\n            ),\n        0.5\n    ),\n    Sphere(\n        Object(\n            Material(\n                vec4(1),\n                vec4(0),\n                0.0\n                #ifdef USE_REFRACTION\n                ,\n                false,\n                1.0,\n                0.0\n                #endif\n            ),\n            vec3(0, -0.6, 0),\n            0\n            ),\n        0.4\n    ),\n    Sphere(\n        Object(\n            Material(\n                vec4(1),\n                vec4(0),\n                0.0\n                #ifdef USE_REFRACTION\n                ,\n                true,\n                1.4,\n                0.0\n                #endif\n            ),\n            vec3(1, -0.6, 1),\n            0\n        ),\n        0.4\n    )\n);\n#endif\n\n#ifdef BOXES\nBox boxes[] = Box[](\n    Box(\n        Object(\n            Material(\n                vec4(0, 1, 0, 1),\n                vec4(0),\n                1.0\n                #ifdef USE_REFRACTION\n                ,\n                false,\n                1.0,\n                0.0\n                #endif\n            ),\n            vec3(1, -0.6, -1),\n            1\n        ),\n        vec3(0.4, 0.4, 0.4)\n    )\n);\n#endif\n\n#ifdef TORUS\nTorus toruses[] = Torus[](\n    Torus(\n        Object(\n            Material(\n                vec4(0, 0, 1, 1),\n                vec4(0),\n                1.0\n                #ifdef USE_REFRACTION\n                ,\n                false,\n                1.0,\n                0.0\n                #endif\n            ),\n            vec3(-1, -0.8, 1),\n            2\n        ),\n        vec2(0.4, 0.2)\n    )\n);\n#endif\n\n// Suboptimal rotation function, but it works for the camera, and that's what matters\nvec3 rotateXY(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTimse, vec2 iMouse) {\n    return rotateXY(vec3(0,0,CAM_ORIGIN.z), iMouse * vec2(PI, -PI)) + vec3(CAM_ORIGIN.xy, 0);\n    return rotateXY(CAM_ORIGIN, iMouse * vec2(PI, -PI));\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return iMouse * vec2(PI, -PI);\n}\n\n// Only used in global illumination (for now)\nvec4 getAmbientLight(vec3 rd) {\n    return vec4(0.0);\n}\n\n// Ditto\nvec4 getSkyTex(vec3 rd) {\n    return vec4(0);\n}\n\nfloat sdf(vec3 pos, Sphere s) {\n    return distance(pos, s.object.position) - s.radius;\n}\n\nfloat sdf(vec3 pos, Box box) {\n    vec3 b = box.bounds;\n    vec3 d = abs(pos - box.object.position) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdf(vec3 pos, Torus tor) {\n    vec2 t = tor.radiuses;\n    vec3 p = pos - tor.object.position;\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\n// X = dist, Y = id of object hit, Z = id of type of object\nvec3 sdScene(vec3 pos) {\n    float dMin = MAX_DIST;\n    vec2 dMinObj = vec2(-1);\n    // If there are none of an object, I can't declare empty arrays, which means I need to remove all references to the arrays that would have existed if the object type\n    // did exist.\n    #ifdef SPHERES\n    for (int i = 0; i < spheres.length(); i++) {\n        float d = sdf(pos, spheres[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(0, i);\n        }\n    }\n    #endif\n    #ifdef BOXES\n    for (int i = 0; i < boxes.length(); i++) {\n        float d = sdf(pos, boxes[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(1, i);\n        }\n    }\n    #endif\n    #ifdef TORUS\n    for (int i = 0; i < toruses.length(); i++) {\n        float d = sdf(pos, toruses[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(2, i);\n        }\n    }\n    #endif\n    return vec3(dMin, dMinObj);\n}\n\n// Same as above, but includes the ability to ignore a specific object; this is required because on bounces after the first ray hits, the distance to the object that the\n// ray hit will always be below the minimum; as such, if we don't ignore the specific object, the ray will never actually bounce. TODO: Account for the (minute) possibility\n// that a shape may curve in on itself\nvec3 sdScene(vec3 pos, int ignoreType, int ignoreId) {\n    float dMin = MAX_DIST;\n    vec2 dMinObj = vec2(-1);\n    #ifdef SPHERES\n    for (int i = 0; i < spheres.length(); i++) {\n        if (i == ignoreId && ignoreType == 0) continue;\n        float d = sdf(pos, spheres[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(0, i);\n        }\n    }\n    #endif\n    #ifdef BOXES\n    for (int i = 0; i < boxes.length(); i++) {\n        if (i == ignoreId && ignoreType == 1) continue;\n        float d = sdf(pos, boxes[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(1, i);\n        }\n    }\n    #endif\n    #ifdef TORUS\n    for (int i = 0; i < toruses.length(); i++) {\n        if (i == ignoreId && ignoreType == 2) continue;\n        float d = sdf(pos, toruses[i]);\n        if (d < dMin) {\n            dMin = d;\n            dMinObj = vec2(2, i);\n        }\n    }\n    #endif\n    return vec3(dMin, dMinObj);\n}\n\nvec3 getNormal(vec3 pos) {\n    vec3 dist1 = sdScene(pos);\n    float planeD = pos.y - PLANE_HEIGHT;\n    if(dist1.x > planeD) return vec3(0,1,0);\n    vec3 f = vec3(\n        sdScene(pos + EPSILON.xyy).r,\n        sdScene(pos + EPSILON.yxy).r,\n        sdScene(pos + EPSILON.yyx).r\n    );\n    return normalize(f - dist1.r);\n}\n\nMaterial getMaterial(MarchData impact) {\n    switch (impact.type) {\n        #ifdef SPHERES\n        case 0:\n            return spheres[impact.id].object.material;\n            #endif\n            #ifdef SPHERES\n        case 1:\n            return boxes[impact.id].object.material;\n            #endif\n            #ifdef TORUS\n        case 2:\n            return toruses[impact.id].object.material;\n            #endif\n            #ifdef USE_PLANE\n        case PLANE_OBJ_ID:\n            return planeMaterial;\n            #endif\n    }\n}\n\nObject getObject(MarchData impact) {\n    switch (impact.type) {\n        #ifdef SPHERES\n        case 0:\n            return spheres[impact.id].object;\n            #endif\n            #ifdef SPHERES\n        case 1:\n            return boxes[impact.id].object;\n            #endif\n            #ifdef TORUS\n        case 2:\n            return toruses[impact.id].object;\n            #endif\n    }\n}\n\n// Standard ray marching algorithm, nothing special here. Look it up if you don't know it because lord knows I'm not explaning it in a comment\nMarchData march(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    int type, id;\n    for (int i = 0; i < MAX_MARCH_COUNT; i++) {\n        vec3 distData = sdScene(pos);\n        float dist = distData.r;\n        #ifdef USE_PLANE\n        // If we're using a plane, we check to see if casting a ray and going straight to the intersect with the plane would be shorter than the normal sdScene.\n        // If it is, we move there.\n        float distPlaneIntersect = ((pos.y - PLANE_HEIGHT) / rd.y);\n        if (abs(distPlaneIntersect) < dist && rd.y < 0.0) {\n            pos += rd * abs(distPlaneIntersect);\n            return MarchData(pos, int(PLANE_OBJ_ID), 0);\n        }\n        #endif\n        if (distance(ro, vec3(0)) > SCENE_BOUND_RADIUS && dot(rd, normalize(vec3(0) - ro)) < 0.0) {\n            // If we are past the bounding sphere, and facing away from the center, we can safely say that the ray should either move to intercept the plane, or just\n            // go of into space.\n            #ifdef USE_PLANE\n            if (rd.y < 0.0 ) {\n                pos += rd * abs(distPlaneIntersect);\n                return MarchData(pos, PLANE_OBJ_ID, 0);\n            }\n            #endif\n            return MarchData(pos + rd * MAX_DIST, -1, -1);\n        }\n        if (dist < MIN_DIST) {\n            return MarchData(pos, int(distData.g), int(distData.b));\n        }\n        if (dist > MAX_DIST) {\n            break;\n        }\n        type = int(distData.y);\n        id = int(distData.z);\n        pos += dist * rd;\n    }\n    if(sdScene(pos).x < 0.1) return MarchData(pos, type, id);\n    return MarchData(pos, -1, -1);\n}\n\nMarchData march(vec3 ro, vec3 rd, int ignoreType, int ignoreId) {\n    vec3 pos = ro;\n    for (int i = 0; i < MAX_MARCH_COUNT; i++) {\n        vec3 distData = sdScene(pos, ignoreType, ignoreId);\n        float dist = distData.r;\n        #ifdef USE_PLANE\n        float distPlaneIntersect = ((PLANE_HEIGHT - pos.y) / rd.y);\n        if (distPlaneIntersect < dist && rd.y < 0.0 && ignoreType != PLANE_OBJ_ID) {\n            pos += rd * distPlaneIntersect;\n            return MarchData(pos, int(PLANE_OBJ_ID), 0);\n        }\n        #endif\n        if (distance(ro, vec3(0)) > SCENE_BOUND_RADIUS && dot(rd, normalize(vec3(0) - ro)) < 0.0) {\n            #ifdef USE_PLANE\n            if (distPlaneIntersect > 0.0 && ignoreType != PLANE_OBJ_ID) {\n                pos += rd * distPlaneIntersect;\n                return MarchData(pos, PLANE_OBJ_ID, 0);\n            }\n            #endif\n            return MarchData(pos + rd * MAX_DIST, -1, -1);\n        }\n        if (dist < MIN_DIST) {\n            return MarchData(pos, int(distData.g), int(distData.b));\n        }\n        if (dist > MAX_DIST) {\n            break;\n        }\n        pos += dist * rd;\n    }\n    return MarchData(pos, -1, -1);\n}\n\n#ifdef USE_REFRACTION\nMarchData marchThroughObject(vec3 ro, vec3 rd, int type, int id) {\n    vec3 pos = ro;\n    pos += rd * 0.01;\n    vec3 dist = sdScene(pos);\n    for(int i = 0; i < MAX_MARCH_COUNT; i++) {\n        vec3 d = sdScene(pos);\n        if(i > 6 && abs(d.x) < MIN_DIST) {\n            pos += rd * abs(d.x) * 2.0;\n            return MarchData(pos, type, id);\n        }\n        pos += abs(d.x) * rd;\n    }\n    return MarchData(pos, type, id);\n}\n#endif\n\n#ifdef HARD_SHADOW\n// Draws a ray from the light to the spot that we want to check for illumination, and if the intersection point of the ray is close enough to the spot we are checking,\n// assume that it isn't occluded.\nfloat getShadow(vec3 pos, vec3 normal, vec3 light) {\n    if (dot(normal, normalize(light - pos)) < 0.0) return 0.0;\n    vec3 ro = light;\n    vec3 rd = normalize(pos - light);\n    MarchData impact = march(ro, rd);\n    if (distance(impact.position, pos) < 0.01) return 1.0;\n    return 0.0;\n}\n#endif\n\n// https://stackoverflow.com/questions/53500550/generating-a-pseudo-random-number-between-0-an-1-glsl-es\nfloat initRand(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// Thank you SO MUCH for this it's much better than literally every noise function I've tried lol\n// Quick note-- seeds are a bit finnicky, I've found best results to be running the starting conditions (i.e. uv, iTime, etc) through one function, then multiplying it\n// by a somewhat high value (10^5?) works pretty well!\n// Begin copy paste block\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec2 hash23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n\n}\n\n// End copy paste block\n\nCamData getCamData(float iTime, vec2 iMouse, vec2 uv, vec2 iResolution, inout vec2 seed) {\n    vec2 uvN = (uv - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1);\n    uvN += (hash22(seed) - 0.5) * 2.0 * (1.0 / iResolution.xy);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS_DIST));\n    rayDir = rotateXY(rayDir, dir);\n    return CamData(pos, rayDir, uvN, mouse);\n}\n\n#ifdef GLOBAL_ILLUMINATION\n// https://www.shadertoy.com/view/fdS3zw\n// Begin copy paste block (comments are my own);\n\n// Uniform random direction in the hemisphere facing with the normal. I think this is used in some GI algorithms?\nvec3 uniformSampleHemisphere(vec3 N, inout vec2 seed) {\n    vec2 u = hash22(seed);\n\n    float r = sqrt(1.0 - u.x * u.x);\n    float phi = 2.0 * PI * u.y;\n\n    vec3 B = normalize(cross(N, vec3(0.0, 1.0, 1.0)));\n    vec3 T = cross(B, N);\n\n    return normalize(r * sin(phi) * B + u.x * N + r * cos(phi) * T);\n}\n\n// The function _actually_ used for getting the random bounce direction of a ray off a diffuse object\nvec3 cosineSampleHemisphere(vec3 n, inout vec2 seed) {\n    vec2 u = hash22(seed);\n\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n\n    vec3 B = normalize(cross(n, vec3(0.0, 1.0, 1.0)));\n    vec3 T = cross(B, n);\n\n    return normalize(r * sin(theta) * B + sqrt(1.0 - u.x) * n + r * cos(theta) * T);\n}\n\n// End copy paste block (comments are my own)\n\nvoid refractStep(inout vec3 ro, inout vec3 rd, inout vec4 color, inout vec4 light, inout vec2 seed, vec3 normal, Material material, MarchData impact) {\n    vec3 originalPos = ro;\n    vec3 ord = rd;\n    rd = refract(rd, normal, 1.0 / material.refractiveIndex);\n    if(length(rd) == 0.0) rd = ord;\n    impact = marchThroughObject(ro, rd, impact.type, impact.id);\n    ro = impact.position;\n    normal = getNormal(ro);\n    rd = refract(rd, -normal, material.refractiveIndex);\n    light += material.emission * color;\n    color *= material.color;\n}\n\n// Single global illumination step. Everything is inout, and it returns a boolean, indicating whether or not to continue (it would only not continue if the ray\n// ended up with a color that's close enough to zero, or either went off into the sky infinitly or couldn't march enough steps to reach it's target.\nbool giStep(inout vec3 ro, inout vec3 rd, inout vec4 color, inout vec4 light, inout int prevCollisionId, inout int prevCollisionType, inout vec2 seed) {\n    MarchData impact = march(ro, rd, prevCollisionType, prevCollisionId);\n    ro = impact.position;\n    prevCollisionId = impact.id;\n    prevCollisionType = impact.type;\n    if (impact.type == -1) {\n        light += getAmbientLight(rd) * color;\n        return false;\n    }\n    Material material = getMaterial(impact);\n    vec3 normal = getNormal(impact.position);\n    #ifdef USE_REFRACTION\n    if(material.isRefractive) {\n        refractStep(ro, rd, color, light, seed, normal, material, impact);\n        return true;\n    }\n    #endif\n    light += material.emission * color;\n    color *= material.color;\n    rd = cosineSampleHemisphere(normal, seed) * material.roughness + reflect(rd, normal) * (1.0 - material.roughness);\n    seed += 100.0;\n    if (length(color) < 0.001) return false;\n    return true;\n}\n\n// Complete global illumination path. Refactored out of main() in buffer A.\nvec4 giFull(vec3 pos, vec3 rayDir, inout vec2 seed) {\n    vec4 lightAcc = vec4(0);\n    for (int i = 0; i < SAMPLE_COUNT; i++) {\n        int prevCollisionId = -1;\n        int prevCollisionType = -1;\n        vec4 color = vec4(1);\n        vec4 light = vec4(0);\n        vec3 ro = pos;\n        vec3 rd = rayDir;\n        int c = 0;\n        for (int i = 0; i < MAX_BOUNCE; i++) {\n            c++;\n            if (!giStep(ro, rd, color, light, prevCollisionId, prevCollisionType, seed)) {\n                if (i == 0 && prevCollisionId == -1) light = getSkyTex(rd);\n                break;\n            }\n        }\n        lightAcc += max(light, 0.0);\n    }\n    return lightAcc;\n}\n#endif\n\n#ifdef USE_SIRBIRD_DENOISER\n#define GOLDEN_ANGLE 2.3999632 //3PI-sqrt(5)PI\n\n#define pow(a,b) pow(max(a,0.),b) // @morimea\n\nmat2 sample2D = mat2(cos(GOLDEN_ANGLE),sin(GOLDEN_ANGLE),-sin(GOLDEN_ANGLE),cos(GOLDEN_ANGLE));\n\nvec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution) {\n    \n    vec3 denoisedColor           = vec3(0.);\n    \n    const float sampleRadius     = sqrt(float(SAMPLES));\n    const float sampleTrueRadius = 0.5/(sampleRadius*sampleRadius);\n    vec2        samplePixel      = vec2(1.0/imageResolution.x,1.0/imageResolution.y); \n    vec3        sampleCenter     = texture(imageTexture, uv).rgb;\n    vec3        sampleCenterNorm = normalize(sampleCenter);\n    float       sampleCenterSat  = length(sampleCenter);\n    \n    float  influenceSum = 0.0;\n    float brightnessSum = 0.0;\n    \n    vec2 pixelRotated = vec2(0.,1.);\n    \n    for (float x = 0.0; x <= float(SAMPLES); x++) {\n        \n        pixelRotated *= sample2D;\n        \n        vec2  pixelOffset    = PIXEL_MULTIPLIER*pixelRotated*sqrt(x)*0.5;\n        float pixelInfluence = 1.0-sampleTrueRadius*pow(dot(pixelOffset,pixelOffset),DISTRIBUTION_BIAS);\n        pixelOffset *= samplePixel;\n            \n        vec3 thisDenoisedColor = \n            texture(imageTexture, uv + pixelOffset).rgb;\n\n        pixelInfluence      *= pixelInfluence*pixelInfluence;\n        /*\n            HUE + SATURATION FILTER\n        */\n        pixelInfluence      *=   \n            pow(0.5+0.5*dot(sampleCenterNorm,normalize(thisDenoisedColor)),INVERSE_HUE_TOLERANCE)\n            * pow(1.0 - abs(length(thisDenoisedColor)-length(sampleCenterSat)),8.);\n            \n        influenceSum += pixelInfluence;\n        denoisedColor += thisDenoisedColor*pixelInfluence;\n    }\n    \n    return denoisedColor/influenceSum;\n    \n}\n#endif","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float v = .152;\n    vec2 p = (fragCoord.xy * v + iTimeDelta * 60.0 * iTime * 1500. + 50.0);\n    vec2 seed = mod(p * v + iTime * 1531.19238124 + 50.31285, 100000.0);\n    seed = hash22(seed) * 1500.0;\n    CamData camData = getCamData(iTime, iMouse.xy, uv, iResolution.xy, seed);\n    vec2 uvN = camData.uvN;\n    vec3 pos = camData.camPos;\n    vec3 rayDir = camData.rayDir;\n    #ifdef GLOBAL_ILLUMINATION\n    vec4 lightAcc = giFull(pos, rayDir, seed);\n    fragColor = lightAcc / float(SAMPLE_COUNT);\n    #else\n    fragColor = impact.obj.id != -1 ? vec4(1) : vec4(0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_R = 82;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef AVG_VALS_WITH_RESET\n    // Not going to get into it here, but this figures out whether the R key is held down.\n    bool reset = texture(iChannel2, vec2(KEY_R, 0) / 256.0).r > 0.9 || iFrame == 0 || iMouse.z > 0.0;\n    // Frame count is stored at (0,0), with the value generated using the formula 1 / (1 + x), where x is the true time. This allows the value to be neatly scaled between\n    // 0 and one, as well as being reversible with (1 / x) - 1.\n    int f = int((1.0 / texture(iChannel1, vec2(0)).r) - 1.0);\n    if(length(uv) <= length(1.0 / iResolution.xy)) {\n        if(reset) fragColor = vec4(1);\n        else fragColor = vec4(1.0 / float(f + 3));\n        return;\n    }\n    if(reset) {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    vec4 prev = texture(iChannel1, uv);\n    // Literally just averages all frames prior\n    if(f == 0 || iFrame == 0) fragColor = prev;\n    else fragColor = texture(iChannel0, uv) * (1.0 / float(f)) + prev * (1.0 - 1.0 / float(f));\n    #elif defined(AVG_VALS_NORMAL)\n    // Same thing here, but without all the input processing shit\n    if(iFrame == 0) fragColor = texture(iChannel0, uv);\n    else fragColor = texture(iChannel0, uv) * (1.0 / float(iFrame)) + texture(iChannel1, uv) * (1.0 - 1.0 / float(iFrame));\n    #else\n    fragColor = texture(iChannel0, uv);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}