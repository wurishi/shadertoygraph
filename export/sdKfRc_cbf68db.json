{"ver":"0.1","info":{"id":"sdKfRc","date":"1658632718","viewed":182,"name":"mandelbulb render","username":"PolloMagico","description":"raymarched mandelbulb with ambient occlusion, soft shadows, reflections, tonemapping and cook-torrance brdf ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","sdf","mandelbulb","pbr","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nconst vec3 u_TrapColors[3] = vec3[](\n    vec3(0.0, 0.8, 1.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(1.0, 0.1, 0.1)\n);\nconst vec3 u_SunDir = vec3(0.747474, 0.0,  -0.7474747);\nconst float u_Metalness = 0.7;\nconst float u_Roughness = 0.4;\nconst bool u_Rotate = true;\nconst float u_Brightness = 0.0;\nconst float u_Contrast = 1.02;\nconst float u_Fog = 0.5;\nconst bool u_RaytracedReflection = true;\nconst float u_ShadowHardness = 2.0;\nconst float u_AOStrength = 1.0;\n\n// https://iquilezles.org/articles/intersectors/\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\nfloat map(vec3 p, out vec4 col) {\n    if(u_Rotate) {\n        p = rotate(p, sin(iTime*0.25), cos(iTime*0.25), 0.0);\n    }\n    vec3 w = p;\n    float m = length(w);\n\tfloat dz = 1.0;\n    \n    vec4 trap = vec4(abs(w), m);\n\n\tfor(int i = 0; i < 4; i++)\n    {\n        if(m > 16.0) {\n            break;\n        }\n\n\t\tdz = 8.0*pow(m,7.0)*dz + 1.0;\n\n        float b = 8.0*acos( w.y/m);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(m,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n\t\tm = length(w);\n        trap = min(trap, vec4(abs(w), m));\n    }\n    col = vec4(m, trap.yzw);\n\n    return 0.5*log(m)*m/dz;\n}\n\n\nvec3 estimateNormal(vec3 p, float t) {\n    vec4 tmp;\n    const float h = 0.002; \n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, tmp ) + \n                      k.yyx*map( p + k.yyx*h, tmp ) + \n                      k.yxy*map( p + k.yxy*h, tmp ) + \n                      k.xxx*map( p + k.xxx*h, tmp ) );\n\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float k )\n{\n    vec2 sph = isphere(vec4(0.0, 0.0, 0.0, 1.25), ro, rd);\n    sph.x = max(0.0, sph.x);\n    sph.y = min(sph.y, 10.0);\n\n    float res = 1.0;\n    float t = sph.x;\n    vec4 tmp;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t, tmp);\n        res = min( res, k*h/t );\n        if(t > sph.y || res<0.001) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 skybox(vec3 d) {\n    return mix(vec3(0.51,0.79,1), vec3(0.85,0.97,1), max(0.0, d.y));\n}\n\nvec2 raycast(vec3 o, vec3 d, out float i, out vec4 col) {\n    vec2 sph = isphere(vec4(0.0, 0.0, 0.0, 1.25), o, d);\n    sph.x = max(0.0, sph.x);\n    sph.y = min(sph.y, 10.0);\n\n    float t = sph.x;\n    for(i = 0.0; i < 1000.0; ++i) {\n        float m = map(o + t*d, col);\n        if(t > sph.y) {\n            break;\n        }\n        if(m < 0.001) {\n            return vec2(t, 1.0);\n        }\n        t += m;\n    }\n    return vec2(-1.0, -1.0);\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nfloat NDF_Approx(float roughness, float ndotv )\n{\n\t// Same as EnvBRDFApprox( 0.04, Roughness, NoV )\n\tconst vec2 c0 = vec2(-1, -0.0275);\n\tconst vec2 c1 = vec2(1, 0.0425);\n\tvec2 r = roughness * c0 + c1;\n\treturn min( r.x * r.x, exp2( -9.28 * ndotv)) * r.x + r.y;\n}\n\n// Trowbridge-Reitz GGX\nfloat normalDistribution(vec3 h, vec3 n, float a) {\n    float nh = max(dot(n, h), 0.0);\n    float a2 = a*a;\n    float denom = (nh*nh*(a2-1.0)+1.0);\n    return a2 / (PI*denom*denom);\n}\n\n// Schlick-GGX\nfloat geometrySub(float ndotv, float k) {\n    return ndotv / (ndotv * (1.0 - k) + k);\n}\n\nfloat geometry(vec3 d, vec3 n, vec3 l, float ndotl, float a) {\n    float r = a + 1.0;\n    float k = r*r / 8.0;\n    float nv = max(dot(d,n), 0.0);\n    return geometrySub(ndotl, k)*geometrySub(nv, k);\n}\n\n// fresnel equation\nvec3 fresnel(float costheta, vec3 f0) {\n    return f0 + (vec3(1.0)-f0) * pow(1.0 - costheta, 5.0);\n}\n\nvec3 trapToCol(vec4 trap) {\n    vec3 col = vec3(0.01);\n\tcol = mix( col, u_TrapColors[0], clamp(trap.y,0.0,1.0) );\n\tcol = mix( col, u_TrapColors[1], clamp(trap.z*trap.z,0.0,1.0) );\n    col = mix( col, u_TrapColors[2], clamp(pow(trap.w,6.0),0.0,1.0) );\n    return col * 0.5;\n}\n\n// Cook-Torrance microfacet model\nvec3 render(vec3 o, vec3 d, out float t) {\n    float i;\n    vec4 trap;\n    vec2 hit = raycast(o, d, i, trap);\n    t = hit.x;\n    if(hit.y < 0.0) {\n        return skybox(d);\n    } \n    vec3 dcol = trapToCol(trap);\n\n    vec3 point = o + hit.x * d;\n    float sun_intensity = 5.0;\n    float indirect_intensity = 0.64;\n    float ambient = 0.4; // (indirect diffuse)\n\n    float roughness = u_Roughness;\n    float metallic = u_Metalness;\n\n    roughness *= roughness; // better for input\n    vec3 v = -d;\n    vec3 l = -normalize(u_SunDir);\n    vec3 n = estimateNormal(point, hit.x);\n    vec3 h = normalize(l+v);\n    vec3 r = reflect(d, n);\n    float ndotl = max(0.0, dot(n, l));\n    float hdotv = max(0.0, dot(h, v));\n    vec3 f0 = mix(vec3(0.04), dcol, metallic);\n\n    float ndf = normalDistribution(h, n, roughness);\n    float g = geometry(v, n, l, ndotl, roughness);\n    vec3 f = fresnel(hdotv, f0);\n    float denom = 4.0*max(dot(n,v), 0.0) * ndotl + 0.0001;\n    vec3 specular = ndf*g*f/denom;\n    vec3 diffuse = dcol / PI;\n\n    vec3 kd = (1.0 - f) * (1.0 - metallic);\n    vec3 direct = kd * diffuse + specular;\n    float sh = shadow(point+0.01*n, l, u_ShadowHardness*u_ShadowHardness);\n    direct *= sh * ndotl * sun_intensity;\n    \n    vec3 indirect_dif = dcol * ambient / PI;\n\n    float itmp;\n    vec4 spec_trap;\n    vec3 indirect_specular = vec3(0.0);\n    if(u_RaytracedReflection) {\n        vec2 rhit = raycast(point + 0.001 * n, r, itmp, spec_trap);\n        vec3 rpoint = point + 0.001 * n + rhit.x * r;\n        float choose = max(0.0, sign(rhit.y));\n        indirect_specular = mix(skybox(r), trapToCol(spec_trap), max(0.0, sign(rhit.y)));\n    }\n    float ao = min(1.0, 20.0 / max(u_AOStrength*2.0 * i, 0.01));\n    vec3 indirect = indirect_dif * dcol * kd + indirect_specular * NDF_Approx(roughness, abs(dot(n, v)) + 1e-5); \n    return (direct + indirect * indirect_intensity)*ao;\n}\n\nvec3 brightnessContrast(vec3 value, float brightness, float contrast)\n{\n    return (value - 0.5) * contrast + 0.5 + brightness;\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 tonemap(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 gamma(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3( 0.0, 0.0,  3.0 );;\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, -1.0);\n\tvec3 cameraRight = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraUp = vec3(0.0, iResolution.y/iResolution.x, 0.0);\n\t\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 rd = normalize( \n        + cameraDir\n        + cameraRight * (uv.x-0.5)\n        + cameraUp * (uv.y-0.5) \n    );\n    float t;\n    vec3 col = render(ro, rd, t);\n    col = brightnessContrast(col, u_Brightness, u_Contrast);\n    col = tonemap(col);\n\n    vec3 lambda = exp(vec3(1.0, 2.0, 4.0) * (-0.05 * u_Fog * u_Fog) * t) * max(0.0, sign(t)) + max(0.0, -sign(t));  // fog\n    col = lambda * col + (1.0 - lambda) * vec3(0.7, 0.7, 0.7);\n    //col = col / (col + 1.0);\n    col = gamma(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}