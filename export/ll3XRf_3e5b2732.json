{"ver":"0.1","info":{"id":"ll3XRf","date":"1480815700","viewed":210,"name":"Bryan's Sky","username":"bsugiarto","description":"Sky","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Bryan's Sky */\n#define MOD2 vec2(.166,.173)\n\n/* uses fractal function to return a float which creates a pattern like effect */\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n\n/* Noise function takes in a vec2 and mixes with hash function to create cloud pattern */\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash(p), Hash(p+ vec2(1.0, 0.0)),f.x),\n                    mix( Hash(p+ vec2(.0, 1.0)), Hash(p+ vec2(1.0, 1.0)),f.x),f.y);\n    return res;\n}\n\n\n/* Noise function takes in a vec2 and mixes with the Noise function to create cloud pattern */\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n\n/* sky function takes in ray direction and returns the sky color*/\nvec3 GetSky(in vec3 rd)\n{\n\t/* sun config */\n\tvec3 sunLight  = normalize( vec3(  0.33, 0.2,  0.3 ));\n\tvec3 sunColour = vec3(1.0, .58, .39);\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\n\t/* base sky */\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\t\n\t/* sun rays */\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\t\n\t/* actual sun */\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .4);\n\n\t/* clouds */\n\tvec2 cl = rd.xz * (1.0/rd.y);\n\tv = FractalNoise(cl) * .3;\n\tsky = mix(sky, sunColour, v*v);\n\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\n/* main image function */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\n\tfloat gTime = (iTime*5.0+m+468.0)*.006;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n\t/* get camera \"look at\" */\n    vec2 p = vec2(200.0 * sin(3.54 * gTime), 200.0 * cos(3.54 * gTime) );\n\tvec3 camTar = vec3(p.x + 5.0,  0.0, -94.0 + p.y);\n\t\n\t/* set camera rotation */\n\tfloat rotate = .3 * sin(gTime*3.0+.5);\n\tvec3 cw = normalize(vec3(camTar.x, 0, camTar.z));\n\tvec3 cp = vec3(sin(rotate), cos(rotate),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\n\t/* set \"look at\" and rotation */\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n    \n\t/* create sky from get sky function */\n\tvec3 col;\n\tcol = GetSky(dir);\n    col += vec3(.2,.2,.2);\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}