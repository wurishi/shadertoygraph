{"ver":"0.1","info":{"id":"msjXDd","date":"1671163564","viewed":148,"name":"Image-Based Lighting","username":"4LT","description":"Pre-computed diffuse reflections","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","lighting","diffuse","precomputed","imagebased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The \"good stuff\" is under the Cube A tab\n\n\nconst float speed = 0.02;\nconst float tau = 2.0 * acos(-1.0);\nconst float f = 1.0;\nconst float gamma = 0.4545;\nconst float camDist = 3.5;\n\nvec4 sphereHit(vec3 cam, vec3 rayDir) {\n    float b = 2.0 * dot(cam, rayDir);\n    float c = dot(cam, cam) - 1.0;\n    \n    float det = b*b - 4.0*c;\n    \n    if (det < 0.0) {\n        return vec4(0.0);\n    } else {\n        float root = (-b - sqrt(det)) / 2.0;\n        return vec4(cam + rayDir * root, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    float w = 2.0;\n    float h = w / aspect;\n    \n    float theta = tau * speed * iTime;\n    vec3 target = vec3(0.0);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * vec2(w, h) - vec2(w/2.0, h/2.0);\n\n    vec3 cam = vec3(sin(theta), sin(theta * 3.0), cos(theta));\n    cam = normalize(cam) * camDist;\n\n    vec3 lookAt = normalize(target - cam);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(lookAt, up));\n    up = normalize(cross(right, lookAt));\n    \n    vec3 rayDir = normalize(lookAt * f + right * uv.x + up * uv.y);\n    \n    vec4 rayHit = sphereHit(cam, rayDir);\n    vec3 col;\n    if (rayHit.w > 0.0) {\n        col = textureLod(iChannel0, rayHit.xyz, 3.0).xyz;\n        col = pow(col, vec3(gamma));\n    } else {\n        #ifndef DEBUG\n            col = texture(iChannel1, rayDir).xyz;\n        #else\n            col = debugCube(rayDir);\n        #endif\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define PRECALC 1\n\n// Pre-compute cube for ambient-lit diffuse surface\n\nconst int randCt = 20;\nconst float tau = 2.0 * acos(-1.0);\nconst vec3 forward = vec3(0.0, 0.0, 1.0);\nconst float invGamma = 1.0/0.4545;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 color;\n    \n    // Compute only when iChannel0 is not already populated\n    // Can't use iFrame check b/c iChannel1 might not have loaded\n    if (PRECALC != 1 || texture(iChannel0, vec3(0.0, 1.0, 0.0)).xyz == vec3(0.0)) {\n        // things we need to rotate random rays from forward -> rayDir\n        float fDotR = dot(forward, rayDir);\n        vec3 fCrossR = cross(forward, rayDir);\n        \n        // color is an accumulation of samples in this branch\n        color = vec3(0.0);\n        \n        vec3 seedRay = rayDir;\n        \n        // Monte Carlo time!\n        for (int i = 0; i < randCt; i++) {\n            // MAKE SUM NOYZE!!! (constants are fairly abritrary)\n            // Not very good hashing, but w/e\n            float add = 1.376937998;\n            float add_mod = 0.1973456;\n            float m = 1.111234;\n            float rand = float(i) + add;\n            add = mod(rand + add, add_mod);\n            rand = mod(rand + add + float((floatBitsToInt(rayDir.x + 2.0) ^ i) & 0xFF), m);\n            add = mod(rand + add, add_mod);\n            rand = mod(rand + add + float((floatBitsToInt(rayDir.y + 2.0) ^ i) & 0xFF), m);\n            add = mod(rand + add, add_mod);\n            rand = mod(rand + add + float((floatBitsToInt(rayDir.z + 2.0) ^ i) & 0xFF), m);\n            \n            // spherical coordinates of random ray\n            // Note that the rays should \"bundle up\" towards the pole (phi near 0)\n            // I believe this is desirable, but not sure if phi should be uniform or\n            // if rays need to be further pushed towards the pole.\n            float phi = mod(rand, m) / m * tau / 4.0;\n            m = 0.011139;\n            float theta = mod(rand, m) / m * tau;\n            \n            //phi = 0.0;\n                        \n            // spherical -> cartesian random ray            \n            vec3 randDir;\n            float horz = sin(phi);\n            randDir.x = cos(theta) * horz;\n            randDir.y = sin(theta) * horz;\n            randDir.z = cos(phi);\n            \n            vec3 randDirRot;\n            \n            // avoid division by zero\n            if (fCrossR == vec3(0.0, 0.0, 0.0)) {\n                // keep or flip\n                randDirRot = randDir * sign(fDotR);\n            } else {\n                // Reduced form of angle-axis rotation (https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula)\n                // Angle and axis info are encoded in our source and destination vectors (forward and rayDir),\n                // so use that to simplify the equation (no length computations!)\n                randDirRot = randDir * fDotR\n                    + cross(fCrossR, randDir)\n                    + fCrossR * (dot(fCrossR, randDir)) * (1.0 - fDotR) / dot(fCrossR, fCrossR);\n            }\n                        \n            #ifndef DEBUG\n                color+= pow(texture(iChannel1, randDirRot).xyz, vec3(invGamma));\n            #else\n                color+= debugCube(randDirRot);\n            #endif\n        }\n        \n        // sum -> average\n        color/= float(randCt);\n    } else {\n        color = texture(iChannel0, rayDir).xyz;\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"//#define DEBUG\n\nvec3 debugCube(vec3 ray) {\n    const vec3 red = vec3(1.0, 0.0, 0.0);\n    const vec3 green = red.yxz;\n    const vec3 blue = red.yzx;\n    const vec3 white = vec3(1.0, 1.0, 1.0);\n    \n    vec3 absRay = abs(ray);\n    \n    if (absRay.x > absRay.y && absRay.x > absRay.z) {\n        if (ray.x >= 0.0) {\n            return red;\n        } else {\n            return white - red;\n        }\n    }else if (absRay.y > absRay.x && absRay.y > absRay.z) {\n        if (ray.y >= 0.0) {\n            return green;\n        } else {\n            return white - green;\n        }\n    }else {\n        if (ray.z >= 0.0) {\n            return blue;\n        } else {\n            return white - blue;\n        }\n    }\n}","name":"Common","description":"","type":"common"}]}