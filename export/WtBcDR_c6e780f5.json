{"ver":"0.1","info":{"id":"WtBcDR","date":"1594062483","viewed":119,"name":"Temporal color-banding diffusion","username":"chronos","description":"Diffusing color-banding in a gradient using temporal jitter / dithering.\nGo fullscreen and click and drag left to see banding. Click and drag right to see a smooth gradient.\nThe results may vary depending on your display. I'm using a 4k 60hz monitor.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["banding","gradient","dither","diffuse","jitter","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\nThis is an attempt to remove color-banding from a long gradient using random flickering to round color values.\nThe probability of rounding one way or the other is based on how close the true gradient value is to\nthe value the color would normaly have been rounded to.\n\nI'm sure many others have done this before, probably also right here on shadertoy,\nand probably much better than I ever could, but I've had this idea for some time and never seen it discussed ( haven't looked either )\nand wanted to see whether I could take this idea all the way to implementation without looking at any references.\n\nsome notes:\n\nI think that ideally, you wouldn't want a fractional color value of, 127.5 say,\nto flicker randomly (if indeed the values were truely random), but rather alternate between 127 and 128 each frame.\nThe probabilistic may perhaps be better in the case of animated images.\nThe method obviously trades of some temporal resolution for some perceived color resolution.\nThe method could be combined with spatial dithering to make the probabilities dependent of which what the neighbors will round,\nso that the error from this method can also be diffused spatially and that rounding in the direction that would make the average error\nin the neighborhood closer to zero has higher probability.\n\n\n*/\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n// noise function adapted from https://www.shadertoy.com/view/4ssXRX  by shadertoy user hornet\nfloat n1rand( vec2 n )\n{\n\treturn fract(sin(dot(n + 0.07*fract( iTime ), vec2(12.9898, 78.233)))* 43758.5453);\n}\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n\n#define USE_RAND_ROUNDING 1\n#define SHOW_ERROR 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat randval = n1rand(uv);\n    \n    float frameWidth = floor(iResolution.x); // paranoid floor\n    float X = floor(fragCoord.x);\n    float U = X/(frameWidth-1.); // [0, 1] range\n    float trueval = U * 255.; //[0., 255] range\n    float flooredVal = floor(U * 255.); //[0., 255] range, still inclusive\n    float fractVal = fract(U * 255.);   //[0., 1.) range, not inclusive\n    float rounding = (fractVal >= 0.5 ? 1.: 0.);\n    float rand_rounding = randval <= fractVal ? 1. : 0.;\n    \n#if USE_RAND_ROUNDING\n   \tfloat roundedval = flooredVal + rand_rounding;\n#else\n    float roundedval = flooredVal + rounding; // rounded \n#endif\n    \n    float normalized_roundedval = roundedval / 255.; // range [0., 1.] inclusive\n    \n    float err = roundedval - trueval; // [-0.5, 0.5) range, not inclusive. Pos: too high rounded value, neg: to low rounded value\n    float abserr = abs(err);\n    \n    float positive_err = err  > 0. ? abserr : 0.;\n    float null_err     = err == 0. ? abserr : 0.;\n    float negative_err = err  < 0. ? abserr : 0.;\n    \n    vec3 colorErr = vec3(negative_err, positive_err, null_err);\n    vec3 col = colorErr; // visualize this to see error (rounded up: green, rounded down: red)\n    \n#if !SHOW_ERROR \n    float slider = iMouse.x / iResolution.x;\n    col = vec3(mix(U, normalized_roundedval, slider)); //col = vec3(normalized_roundedval);\n#endif\n\n    \n    //float gamma = 0.45454545454;\n    //col = pow(col, vec3(gamma));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}