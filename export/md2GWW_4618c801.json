{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// YouTube video of livecoding.\n// https://youtu.be/xAZE95dak04\n\n// Corrected normal vector.\n\n#define hash(x) fract(sin(x)*5723.2622)\nconst float pi = acos(-1.);\nconst float pi2 = acos(-1.)*2.;\n\n// If you have a strong PC, make it bigger.\nconst int nS = 8; // Number of samples.\n\nconst float w = .03; // Width of the fiber.\n\n// Rotation matrix in two dimensions.\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash12(vec2 p) {\n    float v = dot(p, vec2(1.8672, 1.3723));\n    return hash(v);\n}\n\n// 1D perlin noise.\nfloat perlin1d(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.-2.*f);\n    \n    return mix(f*(hash(i)*2.-1.), (f-1.)*(hash(i+1.)*2.-1.), u); // from -0.5 to 0.5\n}\n\nfloat fiberShape(float x, float time) {\n    float s = .03;\n    float curve = smoothstep(.25-s, .25+s, abs(fract(time*.11) - .5));\n    return perlin1d(x) * (1. - w * 2.) * curve;\n}\n\n// Smooth stair-like noise.\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float s = .1;\n    float u = smoothstep(.5-s, .5+s, fract(x));\n    \n    return mix(floor(hash(i)*n), floor(hash(i+1.)*n), u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization of coordinates.\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * .5;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ac = vec3(0);\n    \n    for(float j=0.; j<float(nS); j++) { // Sampling for Motion blur and DOF.\n        float time = iTime;\n        //vec2 seed = fragCoord.xy + fract(time) + j * sqrt(983.);\n        vec2 seed = fragCoord.xy + fract(time)*500. + j * sqrt(983.);\n        \n        // Motion blur.\n        time += hash12(seed) * .05;\n        \n        vec3 ro = vec3(0, 1, -time);\n        vec3 ta = vec3(0, -.5, -time-.5);\n        \n        // Camera movement.\n        ro.x += (stepNoise(ro.z, 5.) - 2.) * .5;\n        ro.y += stepNoise(ro.z - 500., 5.) * .5;\n        \n        vec3 dir = normalize(ta - ro);\n        vec3 side = normalize(cross(dir, vec3(0,1,0)));\n        vec3 up = normalize(cross(side, dir));\n        \n        float fov = 40.;\n        fov += (stepNoise(ro.z - 1000., 2.) * 2. - 1.) * 20.;\n        vec3 rd = normalize(uv.x*side + uv.y*up + dir/tan(fov/360.*pi));\n        float L = length(ta - ro);\n        vec3 fp = ro + rd * L;\n        \n        // Depth of field (DOF).\n        vec3 ros = ro;\n        float r = sqrt(hash12(seed*1.1));\n        float theta = hash12(seed*1.2) * pi2;\n        ros.xy += r * vec2(cos(theta), sin(theta)) * L * .05;\n        vec3 rds = normalize(fp - ros);\n        \n        bool hit = false;\n        float t; // Ray length to the object.\n        vec2 id, q;\n        \n        for(float i=0.; i<50.; i++) { // Raycasting (intersection detection) to the fibers (50 planes).\n            t = -(ros.y + i*.05) / rds.y;\n            vec2 p = ros.xz + t * rds.xz;\n            //p += vec2(hash(i), hash(i*1.1)) * 500.;\n            p.x += hash(i) * 500.;\n            p *= rot(i*2.);\n            \n            id = vec2(i, floor(p.x));\n            \n            p.x = fract(p.x) - .5;\n            p.y += hash12(id) * 500.;\n            p.x -= fiberShape(p.y, time);\n            \n            if(t > 0. && abs(p.x) < w) {\n                q = p;\n                hit = true;\n                break;\n            }\n        }\n        \n        if(hit) { // Ray hit a fiber.\n            vec3 add = vec3(1);\n            \n            vec3 lightDir = normalize(vec3(-5, 2, -2));\n            vec3 normal = normalize(vec3(q.x, sqrt(w*w - q.x*q.x), 0));\n            \n            // Modify normal vector using the rotation angle (i*2.) and the gradient of fiber shape.\n            float e = 1e-4;\n            float grad = (fiberShape(q.y + e, time) - fiberShape(q.y - e, time)) / (e*2.);\n            float a = atan(grad);\n            normal.xz *= rot(-id.x*2. + a);\n            \n            // Shading.\n            float diff = max(dot(normal, lightDir), 0.);\n            float spec = pow(max(dot(reflect(lightDir, normal), rds), 0.), 20.);\n            float m = .5;\n            float lp = 3.;\n            add *= diff * (1.-m) * lp + spec * m * lp + .2;\n            \n            // Streaming light.\n            q.y = fract(q.y * .03 - time * .2) - .5;\n            //add += smoothstep(.01, 0., abs(q.y)) * 5.;\n            add += smoothstep(.01, 0., abs(q.y)) * 3.;\n            \n            // Flickering light.\n            float T = time + hash12(id);\n            //add += step(hash12(id*1.1 + floor(T)), .05) * step(fract(T*3.), .8) * 5.;\n            add += step(hash12(id*1.1 + floor(T)), .05) * step(fract(T*3.), .8) * 3.;\n            \n            // Black fog.\n            //add *= exp(-t*t*.1);\n            //add *= exp(-id.x*id.x*.001);\n            add *= exp(-t*t*.1 -id.x*id.x*.001);\n            \n            ac += add;\n        }\n    }\n    \n    col += ac / float(nS);\n    col = pow(col, vec3(1./2.2)); // Gamma correction.\n    \n    fragColor = vec4(col, 1);\n}\n\n// Original version. Normal vector is wrong.\n/*\n#define hash(x) fract(sin(x)*5723.2622)\nconst float pi = acos(-1.);\nconst float pi2 = acos(-1.)*2.;\n\n// Rotation matrix in two dimensions.\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash12(vec2 p) {\n    float v = dot(p, vec2(1.8672, 1.3723));\n    return hash(v);\n}\n\n// 1D perlin noise.\nfloat perlin1d(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.-2.*f);\n    \n    return mix(f*(hash(i)*2.-1.), (f-1.)*(hash(i+1.)*2.-1.), u);\n}\n\n// Smooth stair-like noise.\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float s = .1;\n    float u = smoothstep(.5-s, .5+s, fract(x));\n    \n    return mix(floor(hash(i)*n), floor(hash(i+1.)*n), u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization of coordinates.\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * .5;\n    \n    vec3 col = vec3(0);\n    \n    float w = .03; // Width of the fiber.\n    \n    vec3 ac = vec3(0);\n    for(float j=0.; j<8.; j++) { // Sampling for Motion blur and DOF.\n        float time = iTime;\n        vec2 seed = fragCoord.xy + fract(time) + j * sqrt(983.);\n        \n        // Motion blur.\n        time += hash12(seed) * .05;\n        \n        vec3 ro = vec3(0, 1, -time);\n        vec3 ta = vec3(0, -.5, -time-.5);\n        \n        // Camera movement.\n        ro.x += (stepNoise(ro.z, 5.) - 2.) * .5;\n        //ro.y += stepNoise(ro.z - 500. - 1./3., 5.) * .5;\n        ro.y += stepNoise(ro.z - 500., 5.) * .5;\n        \n        vec3 dir = normalize(ta - ro);\n        vec3 side = normalize(cross(dir, vec3(0,1,0)));\n        vec3 up = normalize(cross(side, dir));\n        \n        float fov = 40.;\n        //fov += (stepNoise(ro.z - 1000. - 2./3., 2.) * 2. - 1.) * 20.;\n        fov += (stepNoise(ro.z - 1000., 2.) * 2. - 1.) * 20.;\n        vec3 rd = normalize(uv.x*side + uv.y*up + dir/tan(fov/360.*pi));\n        float L = length(ta - ro);\n        vec3 fp = ro + rd * L;\n        \n        // Depth of field (DOF).\n        vec3 ros = ro;\n        float r = sqrt(hash12(seed*1.1));\n        float theta = hash12(seed*1.2) * pi2;\n        ros.xy += r * vec2(cos(theta), sin(theta)) * L * .05;\n        vec3 rds = normalize(fp - ros);\n        \n        bool hit = false;\n        float t; // Ray length to the object.\n        vec2 id, q;\n        \n        for(float i=0.; i<50.; i++) { // Raycasting (intersection detection) to the fibers (planes).\n            t = -(ros.y + i*.05) / rds.y;\n            vec2 p = ros.xz + t * rds.xz;\n            p += vec2(hash(i), hash(i*1.1)) * 500.;\n            p *= rot(i*2.);\n            \n            id = vec2(i, floor(p.x));\n            \n            p.x = fract(p.x) - .5;\n            p.y += hash12(id) * 500.;\n            float s = .03;\n            float curve = smoothstep(.25-s, .25+s, abs(fract(time*.11) - .5));\n            p.x += perlin1d(p.y) * (1. - w * 2.) * curve;\n            \n            q = p;\n            \n            if(t > 0. && abs(p.x) < w) {\n                hit = true;\n                break;\n            }\n        }\n        \n        if(hit) { // Ray hit a fiber.\n            vec3 add = vec3(1);\n            \n            vec3 lightDir = normalize(vec3(-5, 2, -2));\n            vec3 normal = normalize(vec3(q.x, sqrt(w*w - q.x*q.x), 0));\n            \n            float e = 1e-4;\n            float grad = (perlin1d(q.y + e) - perlin1d(q.y - e)) / (e*2.);\n            float a = atan(grad);\n            \n            normal.xz *= rot(-id.x*2. - a);\n            \n            // Shading.\n            float diff = max(dot(normal, lightDir), 0.);\n            float spec = pow(max(dot(reflect(lightDir, normal), rds), 0.), 20.);\n            float m = .5;\n            float lp = 3.;\n            add *= diff * (1.-m) * lp + spec * m * lp + .2;\n            \n            // Streaming light.\n            q.y = fract(q.y * .03 - time * .2) - .5;\n            add += smoothstep(.01, 0., abs(q.y)) * 5.;\n            \n            // Flickering light.\n            float T = time + hash12(id);\n            add += step(hash12(id*1.1 + floor(T)), .05) * step(fract(T*3.), .8) * 5.;\n            \n            // Black fog.\n            add *= exp(-t*t*.1);\n            add *= exp(-id.x*id.x*.001);\n            \n            ac += add;\n        }\n    }\n    \n    col += ac / 8.;\n    col = pow(col, vec3(1./2.2)); // Gamma correction.\n    \n    fragColor = vec4(col, 1);\n}\n*/","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"md2GWW","date":"1667622040","viewed":4257,"name":"[Inércia 2022] Glowing Fibers","username":"Kamoshika","description":"This is the shader I made at Shader Royale of Inércia Demoparty 2022.\nThankfully, it won first place!\n\nInércia Demoparty 2022\nhttps://2022.inercia.pt/index.php?page=About","likes":162,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","livecoding","fibers","fiber"],"hasliked":0,"parentid":"","parentname":""}}