{"ver":"0.1","info":{"id":"MsS3D1","date":"1469776008","viewed":632,"name":"Simple material system ","username":"kig","description":"Added a simple material system to the spectral dispersion shader.","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","materials","dispersion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray\n{\n\tvec3 p;\n\tvec3 d;\n\tvec3 light;\n\tvec3 transmit;\n};\n\nstruct material\n{\n\tvec3 transmit;\n\tfloat ior;\n    float diffuse;\n    float roughness;\n};\n\nstruct sphere\n{\n\tvec3 p;\n\tfloat r;\n\tmaterial m;\n};\n    \nstruct hit\n{\n    float distance;\n    vec3 normal;\n    material m;\n};\n\nfloat raySphereDet(ray r, sphere s, inout float b)\n{\n\tvec3 rc = r.p-s.p;\n\tfloat c = dot(rc, rc);\n\tc -= s.r*s.r;\n\tb = dot(r.d, rc);\n\treturn b*b - c;\n}\n\nfloat rayIntersectsSphere(ray r, sphere s, inout vec3 nml, inout sphere dst, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(r, s, b);\n\tif (d < 0.0) {\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d);\n\tfloat nd = sign(t);\n\tif (t < 0.0) {\n\t\tt += 2.0*sqrt(d);\n\t}\n\tif (t < 0.0 || t > closestHit) {\n\t\treturn closestHit;\n\t}\n\tnml = nd * normalize(s.p - (r.p + r.d*t));\n\tdst = s;\n\treturn t;\n}\n\nfloat rayIntersectsPlane(ray r, vec3 p, vec3 pnml, inout vec3 nml, float closestHit)\n{\n\tfloat pd = dot(pnml, r.d);\n\tfloat dist = dot(pnml, p-r.p) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\treturn dist;\n\t}\n\treturn closestHit;\n}\n\nfloat rayIntersectsDisk(ray r, vec3 p, vec3 pnml, float r1, float r2, material m, inout vec3 nml, inout material dst, float closestHit)\n{\n\tvec3 tmp;\n\tfloat dist = rayIntersectsPlane(r, p, pnml, tmp, closestHit);\n\tfloat len = length(r.p + dist*r.d - p);\n\tif (dist != closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tdst = m;\n\t\treturn dist;\n\t}\n\treturn closestHit;\n}\n\nfloat rayIntersectsAABB(ray r, vec3 p, vec3 dims, material m, inout vec3 nml, inout material dst, float closestHit)\n{\n    vec3 invRay = 1.0 / r.d;\n    vec3 aabbMin = p - dims;\n    vec3 aabbMax = p + dims;\n    vec3 v1 = (aabbMin - r.p) * invRay;\n    vec3 v2 = (aabbMax - r.p) * invRay;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n    float enter = max(n.x, max(n.y, n.z));\n    float exit = min(f.x, min(f.y, f.z));\n    \n    float t = enter <= 0.0 ? exit : enter;\n\n    if (exit > 0.0 && enter < exit && t > 0.0 && t < closestHit)\n    {\n        vec3 np = ((r.p + r.d * t) - p);\n        nml = -normalize(np/dims * step(dims-0.0001, abs(np)));\n        dst = m;\n        return t;\n    }\n    return closestHit;\n}\n\nvec3 shadeBg(vec3 nml)\n{\n    vec3 lightPos_ = vec3(\n        -cos(iTime)*-12.0, \n        3.5+sin(iTime*2.05)*8.0, \n        (sin(iTime)*12.0-5.4)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 4.0, 2.0);\n\tvec3 bgCol = vec3(0.2, 0.2, 0.2);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tfloat isp = max(-sunPow, 0.0);\n\tbgCol += max(-0.5, bgDiff)*vec3(0.25, 0.5, 0.75);\n\tbgCol += bgCol*(2.0*pow(isp, 2.0) + pow(sp, 128.0));\n\tbgCol += sun*(pow(sp, 256.0) + 0.1*pow(sp, 2.0));\n\treturn max(vec3(0.0), bgCol);\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nbool getBit(float n, float i)\n{\n\treturn (mod(n / pow(2.0, i), 2.0) < 1.0);\n}\n\nfloat scene(inout ray r, inout vec3 nml, inout material m) {\n\tfloat dist;\n\tsphere s, dst;\n\ts.m.transmit = vec3(1.0);\n\ts.m.ior = 1.15;\n\tdst = s;\n\t\n\t// Test a bunch of spheres for ray-sphere intersection.\n\tdist = 10000.0;\n\ts.p = vec3(0.0);\n\ts.r = 0.5;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(1.0, 1.0, -1.0);\n\ts.r = 0.95;\n\ts.m.transmit = vec3(0.8, 0.8, 0.9);\n\ts.m.ior = 1.3;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(1.0, -1.0, 1.0);\n\ts.m.transmit = vec3(0.5, 0.6, 0.5);\n\ts.m.ior = 3.0;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(-1.0, -1.0, -1.0);\n\ts.m.transmit = vec3(1.0, 0.6, 0.4);\n\ts.m.ior = 1.13;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(-1.0, 1.0, 1.0);\n\ts.m.transmit = vec3(0.3, 0.3, 0.3);\n\ts.m.ior = 1.9;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.m.transmit = vec3(0.95);\n\ts.m.ior = 1.5;\n    dist = rayIntersectsAABB(r, vec3(0.0), vec3(0.2, 1.0, 0.2), s.m, nml, dst.m, dist);\n\ts.m.transmit = vec3(0.8,0.5,0.4);\n\ts.m.ior = 3.2;\n\tdist = rayIntersectsDisk(r, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 0.9, s.m, nml, dst.m, dist);\n\tm = dst.m;\n\treturn dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 uv = (1.0 - 2.0 * (fragCoord.xy / iResolution.xy)) * aspect;\n\n\tmat3 rot = rotationXY( vec2( iTime, iTime*0.32 ) );\n\n\tray r;\n\tr.p = vec3(uv*0.2, -3.0);\n\tr.d = normalize(vec3(uv, 1.0));\n\tr.d *= rot;\n\tr.p *= rot;\n\tr.transmit = vec3(1.0);\n\tr.light = vec3(0.0);\n\n\tfloat epsilon = 0.015;\n\tfloat rayCount=0.0, rayBounceCount=0.0;\n\tbool rayComplete = false;\n\n\tvec3 rgb = vec3(0.0);\n\t\n\t// Max number of paths shot out of camera.\n\t// Double to add a recursion level.\n\tfloat maxRays = 32.0;\n\tfloat maxBounceCount = 5.0;\n\t\n\t// Evaluate a bunch of ray segments.\n\t// Bump maxRays to 64.0, maxBounceCount to 7.0 and the ray segments to 64*7 \n\t// for some more flares.\n\tfor (int i=0; i<32*5*3; i++) {\n\t\t\n\t\tvec3 nml;\n\t\tmaterial m;\n\t\tfloat dist = scene(r, nml, m);\n\t\t\n\t\tif (dist != 10000.0) {\n\t\t\t// Move ray to surface.\n\t\t\tr.p += r.d*dist;\n\t\t\t\n\t\t\t// Fresnel term, increase reflectivity on surfaces parallel to ray.\n\t\t\tfloat f = pow(1.0 - clamp(0.0, 1.0, dot(nml, r.d)), 5.0);\n\t\t\t\n\t\t\t// Whether to reflect or refract on this step.\n\t\t\t// The idea is to generate all permutations of a reflect/refract\n\t\t\t// path by using an N-bit number where each bit determines whether\n\t\t\t// the bounce at this step reflects or refracts.\n\t\t\t//\n\t\t\t// (rayCount >> rayBounceCount) & 1\n\t\t\tif (!getBit(floor(rayCount / 3.0), rayBounceCount)) {\n\t\t\t\tr.d = reflect(r.d, nml);\n\t\t\t\t// Fade the ray by the surface's absorption.\n\t\t\t\t// Use the Fresnel term to boost reflection strength.\n\t\t\t\tr.transmit *= (1.0+f)*m.transmit;\n\t\t\t} else {\n\t\t\t\t// Figure out which wavelength we're tracing.\n\t\t\t\t// 0 = red, 1 = green, 2 = blue\n\t\t\t\tfloat c = mod(rayCount, 3.0);\n\t\t\t\t// Simulate air -> diamond refraction.\n\t\t\t\t// Change index of refraction by the wavelength.\n\t\t\t\tfloat eta = 1.000239 / pow(m.ior, (c*0.07)+1.0);\n                if (dot(r.d, nml) > 0.0) {\n                    nml = -nml;\n                    eta = 1.0 / eta;\n                }\n\t\t\t\tr.d = refract(r.d, -nml, eta);\n\t\t\t\t// Fade the ray by the volume's transmission.\n\t\t\t\t// Use the Fresnel term to reduce transmission.\n\t\t\t\tr.transmit *= (1.0-f)*m.transmit;\n\t\t\t}\n\t\t\t\n\t\t\trayBounceCount++;\n\t\t\tif (rayBounceCount > maxBounceCount) {\n\t\t\t\trayComplete = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Offset ray to avoid double-colliding with same surface.\n\t\t\tr.p += r.d*epsilon;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// Add background light to the ray.\n\t\t\tr.light = r.transmit * shadeBg(-r.d);\n\t\t\t// Use only the wanted wavelength.\n\t\t\tfloat c = mod(rayCount, 3.0);\n\t\t\tif (c == 0.0) {\n\t\t\t\trgb.r += r.light.r; \n\t\t\t} else if (c == 1.0) {\n\t\t\t\trgb.g += r.light.g;\n\t\t\t} else {\n\t\t\t\trgb.b += r.light.b;\n\t\t\t}\n\t\t\trayComplete = true;\n\t\t\t\n\t\t}\n\t\t\n\t\tif (rayComplete) {\n\t\t\t\n\t\t\trayComplete = false;\n\t\t\trayCount++;\n\t\t\t\n\t\t\t// If the ray didn't hit anything or\n\t\t\t// if we've done enough rays, quit.\n\t\t\tif ((rayBounceCount == 0.0 && rayCount == 3.0) || rayCount == maxRays) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// Reset bounce count.\n\t\t\trayBounceCount = 0.0;\n\t\t\t\n\t\t\t// Reset ray back to camera.\n\t\t\tr.p = vec3(uv*0.2, -3.0);\n\t\t\tr.d = normalize(vec3(uv, 1.0));\n\t\t\tr.d *= rot;\n\t\t\tr.p *= rot;\n\t\t\t\n\t\t\t// Make ray transparent again.\n\t\t\tr.transmit = vec3(1.0);\n\t\t}\n\t}\n\t\n\t// Gamma curve the average ray light.\n\tfragColor = vec4(1.0 - exp(-rgb*3.0/rayCount * 2.5), 1.0);\n}","name":"Image","description":"","type":"image"}]}