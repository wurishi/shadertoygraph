{"ver":"0.1","info":{"id":"Xf3SDS","date":"1714399721","viewed":74,"name":"Collatz Computer-Fastaro","username":"robfast","description":"weird one","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","recursion","collatzconjecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 p) {\n    // A simple hashing function\n    p = 50.0 * fract(p * 0.3183099 + vec2(0.1,0.1));\n    return fract(p.x * p.y);\n}\n\nfloat generateStartingValue(float n, float x) {\n    // Using the provided sequence formula to generate a starting value\n    return ((4.0 + 3.0 * n) * pow(4.0, x) - 1.0) / 3.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n float slowTime = mix(iTime, iTime,0.01);\n\n\n    // Dynamically changing base value, now incorporates random element\n    float base = 2.0 + floor(mod(slowTime, 0.2));\n    float x = base; // Starting value based on position\n\n    // Generate a random starting value from the sequence\n    float randomStart = generateStartingValue(hash(uv), x);\n\n    float sequenceValue = randomStart;\n    int steps = 0;\n     int maxSteps = 2;\n\n    // Simulate the Collatz sequence\nwhile (sequenceValue > 1.0 && steps < maxSteps) {\n    if (mod(sequenceValue, 2.0) == 0.0) {\n        sequenceValue *= 0.5;\n    } else {\n        sequenceValue = 3.0 * sequenceValue + 1.0;\n    }\n    steps++;\n}\n\n    // Visual representation based on the number of steps\n   float radius = smoothstep(0.0, 1.0, float(steps) / float(maxSteps));\n\n    float angle = atan(uv.y, uv.x);\n\n    // Polar to cartesian coordinates conversion\n    vec2 pos = vec2(radius * cos(angle), radius * sin(angle));\nfloat hueRangeStart = 0.5; // Start of hue range\nfloat hueRangeEnd = 0.75; // End of hue range\nfloat hue = smoothstep(0.0, 1.0,hueRangeStart + mod((3.0*sequenceValue + 1.0) / 4.0 + (3.0*iTime+1.0)/32.0, hueRangeEnd - hueRangeStart));\n\n    float saturation = 1.0;\n    float value = 3.2;\n    vec3 hsv = vec3(hue, saturation, value);\n    vec3 rgb = log(abs((hsv2rgb(hsv)+2.0))); // Convert HSV to RGB\n\n    // Scaling and centering the position\n    vec2 screenPos = 0.5 + 0.5 * pos;\n    if (screenPos.x >= 0.0 && screenPos.x <= 1.0 && screenPos.y >= 0.0 && screenPos.y <= 1.0) {\n        fragColor = vec4(mix(vec3(0.0,0.0,88.0)+88.0/rgb,rgb-1.0,1.0), 0.2);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}