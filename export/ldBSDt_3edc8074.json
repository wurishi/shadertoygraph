{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Adaptation from article\n// http://www.anu.edu.au/physics/Searle/Obsolete/Seminar.html (link broken today!)\n\n// An explanation on phenomenon involved: \n// http://people.physics.anu.edu.au/~cms130/TEE/site/tee/learning/formulas/formulas.html\n// http://people.physics.anu.edu.au/~cms130/TEE/site/tee/learning/cd/cd.html\n// http://vimeo.com/76102645\n\n// Only valid for static objects\n// TODO: if objects have speed (big speed) we have to calculate intersection of timed ray and moving objects\n// TODO: if objects have speed (big speed) calculate doppler effect from relative speed of object\n// TODO: if objects have speed (big speed) calculate shadows at good time \n\nconst float gIntensity = 1.; \t// Proportion Solid angle light flux ?\nconst float gDoppler = 1.;  \t// Proportion Red/Blueshift rays ?\n\n\n// +------------------------------------------------------+\n// |               Classic Ray Marching                   |\n// +------------------------------------------------------+\n\nconst vec2 eps = vec2(0.001, 0.0);\n\nfloat sdBox(vec3 p, vec3 b) { \n    vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); \n} \n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\n#define RAYON .2\n\n\n\nvec2 map(vec3 p) {\n //   p.xy *= mat2(cos(-.091),sin(-.091),-sin(-.091), cos(-.091));\n    float d1 = abs(dot(p,vec3(0,-1,0))-.15);\n    p += vec3(.2, .52, -.4);\n    p = mod(p,1.6) - .8;\n    float d2 = sdBox(p,vec3(.15));\n//    float d3 = length(p.xy)-.02;\n//    d3 = min(d3, length(p.yz)-.02);\n//    d3 = min(d3, length(p.zx)-.02);\n    return\n        //(d3<d2&&d3<d1) ? vec2(d3, mod(length(p),.15)<.1?30:80) : \n    (d1<d2) ? vec2(d1, 1.) : vec2(d2,41); \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k ) {\n\tfloat res = 1.0;\n    float h,t = mint;\n    for( int i=0; i<30; i++ ) {\n\t\tif( t>maxt ) break;\n        else {\n\t\t\th = map( ro + rd*t ).x;\n\t\t\tres = min( res, 7.*h/t );\n\t\t\tt += 0.028;\n\t\t}\n    }\n    return clamp( res-.6, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n} \n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n\tvec2 res;\n    for( int i=0; i<60; i++ ) {\n        if (abs(h)<precis||t>maxd ) break;\n        else {\n            t += h;\n            res = map( ro+rd*t);\n            h = res.x;\n        }\n    }\n    return vec2( t, t>=maxd ? -1. : res.y );\n}\n\n\nvec3 calcNormal(in vec3 p) {\n\treturn normalize(vec3(map(p+eps.xyy).x - map(p-eps.xyy).x, map(p+eps.yxy).x - map(p-eps.yxy).x, map(p+eps.yyx).x - map(p-eps.yyx).x));\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd ){ \n    vec3 col = vec3(0);\n    vec2 res = castRay(ro,rd,20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n        if (m == 1.) {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        } else {\n\t\t\tcol = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        }\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.025, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += .2*bac*vec3(0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(1.0)*col*spe + 0.7*fre*(0.5+0.5*col);\n\t}\n\n\tcol *= exp( -0.01*t*t );\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\n// +------------------------------------------------------+\n// |                 Relativistic Kit                     |\n// +------------------------------------------------------+\n\n\n// Wavelengths\n#define lUltraViolet    340.0\n#define lBlue           460.0\n#define lGreen          520.0\n#define lRed            700.0\n#define lInfraRed       1000.0\n\nfloat initRayForSpeed(in vec3 rd, in vec3 velocity, out vec3 ray, out float intensity) {\n    float beta = length(velocity), // = (velocity of observer) / (speed of light)\n    \t  gamma = 1./sqrt(1. - beta*beta);\n    \n \tif (beta == 0.) { // No speed => classical case\n        ray = rd;\n        intensity = 1.;\n        return 1.;\n    }\n    \n  // - Angular Compression -----------------------------------\n  // http://en.wikipedia.org/wiki/Relativistic_aberration  \n\tvec3 vn = normalize(velocity); \t// Velocity normal\n\tfloat cosa = dot(rd,vn); \t\t// Length of parallel component to velocity\n\tvec3 p = rd - cosa*vn;   \t\t// Perpendicular component to velocity\n    float cosb = (cosa - beta) / (1. - cosa*beta);\n    ray = cosb*vn + sqrt(1.-cosb*cosb)*normalize(p); \n\n  // - The Intensity Effect ---------------------------------\n    \n    intensity = gamma*(1. - beta*cosb)*(1. - beta*cosb);\n    intensity = 1. + (intensity - 1.)*gIntensity; // Partial intensities for clarity\n\n  // - The Doppler Effect -----------------------------------\n  // http://en.wikipedia.org/wiki/Relativistic_Doppler_effect\n//    float c = acos(cosa) - acos(cosb);\n//    return (gDoppler == 0.) ? 1. : (1. + vlen*cos(c))/sqrt(1. - vlen*vlen);\n    return (gDoppler == 0.) ? 1. : gamma*(1. - beta*cosb);\n}\n\n\nfloat shiftColor(in float sb, in vec3 c, in float cuv, in float cir) {\n    if(sb < lUltraViolet) return cuv * sb / lUltraViolet;\n    if(sb < lBlue)        return (c.b - cuv) * (sb - lUltraViolet) / (lBlue - lUltraViolet) + cuv;\n    if(sb < lGreen)       return (c.g - c.b) * (sb - lBlue)        / (lGreen - lBlue)       + c.b;\n    if(sb < lRed)         return (c.r - c.g) * (sb - lGreen)       / (lRed - lGreen)        + c.g;\n    if(sb < lInfraRed)    return (cir - c.r) * (sb - lRed)         / (lInfraRed - lRed)     + c.r;\n    return (lInfraRed / sb) * cir;\n}\n\nvec3 RelativisticRayTracing(in vec3 ro, in vec3 rd, in vec3 velocity) {\n    vec3 r; //, o;    \t\t// New ray\n    float doppler;   \t\t// Spectrum shift\n    float illumination, intensity;\n\n// - Shift ray ------------------------------------------------------------\n    doppler = initRayForSpeed(rd, velocity, r, intensity);  \n    \n///////////////////////////////////////////////////////////////////////////////////////\n\n    // Do classical RayTracing or RayMarching here   :)\n    vec3 c = render(ro,r);\n    \n///////////////////////////////////////////////////////////////////////////////////////\n    \n// - Dimming + Spectrum shift ---------------------------------------------    \n    if (gIntensity != 0.) c /= intensity;\n    if (gDoppler != 0.) {\n\t    doppler = 1. + (doppler - 1.) * gDoppler;\n        // Off spectrum predictions\n        float cuv = (0.5*c.b + 0.25*c.g + 0.125*c.r), // ultraviolet\n        \t  cir = (0.5*c.r + 0.25*c.g + 0.125*c.b); // infrared\n        return vec3 (shiftColor(lRed/doppler,   c, cuv, cir), // Shifted wavelengths\n        \t\t\t shiftColor(lGreen/doppler, c, cuv, cir),\n        \t\t     shiftColor(lBlue/doppler,  c, cuv, cir));\n    } else {\n        return c;\n    }\n}\n\n\n// +------------------------------------------------------+\n// |                       Main                           |\n// +------------------------------------------------------+\n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 fragCoord) {\n    return LookAt(cp-ro, vec3(0,1,0))*normalize(vec3((2.*fragCoord-iResolution.xy)/iResolution.y, 2.6));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime*.06;\n    // beta = velocity of observer / speed of light\n    float beta = clamp( (iMouse.z>0.0) ? iMouse.y/iResolution.y : mod(time,1.1)-.04, 0.,1.);\n\t\n    \n\tvec3 rd, ro = vec3(0,1.2,-20),\n    \tlook = ro + vec3(cos(9.32*iMouse.x/iResolution.x), -.02, sin(9.32*iMouse.x/iResolution.x) );\n    vec3 cSum = vec3(0);\n    for (int i=0; i<2;i++) {\n        for (int j=0; j<2;j++) {\n\t\t\tfragCoord = fragCoord.xy+.5*vec2(i,j);\n\t\t\trd = RD(ro, look, fragCoord);\t\n            if (fragCoord.y/iResolution.y > .96) {\n                cSum += (fragCoord.x/iResolution.x < beta) ? mix(vec3(.3,1,.3), vec3(1,0,0), beta) : vec3(.3);  \n            } else {\n                cSum += RelativisticRayTracing(ro, rd, beta*vec3(1,0,0)/*normalize(look-ro)*/);\n            }   \n        }\n\t}\n    fragColor = vec4(cSum/4., 1);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldBSDt","date":"1417035400","viewed":1003,"name":"Relativistic Starter Kit","username":"iapafoto","description":"Relativistic Camera kit - adaptation of a very old article :\nhttp://www.anu.edu.au/physics/Searle/Obsolete/Seminar.html\nCamera does not move nor objects, only velocity is changing in the demo\n","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","relativistic","relativity"],"hasliked":0,"parentid":"","parentname":""}}