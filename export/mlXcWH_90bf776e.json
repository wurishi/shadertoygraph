{"ver":"0.1","info":{"id":"mlXcWH","date":"1690664881","viewed":113,"name":"Yet Another 'GPU Gems 3' Scatter","username":"LVutner","description":"Fairly cheap volumetrics in screen space. Enjoy.\n\nLeft side - No jitter, no mip sampling\nRight side - jitter + mip sampling\nBlur enabled by default.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["godrays","scattering","sunrays","screenspace","gpugems"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Fairly cheap screen space volumetrics\n    \n    1. Radial blur with jitter (bayer matrix) + mips\n    2. Two-pass guided filter (mask/depth works as guide)\n    \n    As result, few samples gives a good and smooth result.\n\n    Done for fun, hope it's useful to someone.\n\n    LV\n*/\n\n//Blur + tonemap + gamma\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texcoord = fragCoord.xy / iResolution.xy;\n\n    vec3 color = VL_COLOR * guided_filter(iChannel0, texcoord, 1.0 / iResolution.xy, false).x;\n\n    color /= 1.0 + color;\n\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor.xyz = color;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Fairly cheap screen space volumetrics\n    \n    1. Radial blur with jitter (bayer matrix) + mips\n    2. Two-pass guided filter (mask/depth works as guide)\n    \n    As result, few samples gives a good and smooth result.\n\n    Done for fun, hope it's useful to someone.\n\n    LV\n*/\n\n#define VL_SAMPLES 8 //quality\n#define VL_MIP_MULT 8.0 //mip multiplier (0.0 disables mip usage)\n\n#define VL_COLOR vec3(1.0, 0.4, 0.3) //color\n#define VL_POSITION vec2(0.5, 0.5) //position of the light in screen space\n\n#define BLUR_ENABLED //enables blur\n#define BLUR_RADIUS 2 //blur radius\n\n//https://bartwronski.com/2019/09/22/local-linear-models-guided-filter/\n//Credits: MartyMcFly (MF OPTIMIZATION. Conversations about filtering and sampling patterns)\nvec2 guided_filter(sampler2D tex, vec2 texcoord, vec2 rcp_resolution, bool hp_offset)\n{\n\tvec2 center_tap = texture(tex, texcoord).xy;\n\n    #ifndef BLUR_ENABLED\n        return center_tap;\n    #endif\n\n    float half_pixel_offset = hp_offset ? -0.5 : 0.5;\n\n\tvec4 x_x2_y_xy = vec4(0.0);\n\n\tfor(int i = -BLUR_RADIUS; i <= BLUR_RADIUS; i++)\n\tfor(int j = -BLUR_RADIUS; j <= BLUR_RADIUS; j++)\n\t{\n        vec2 offset = vec2(i, j) + half_pixel_offset;\n\t\tvec3 offset_tap = vec3(texture(tex, texcoord + offset * rcp_resolution).xy, 1.0);\n\t\tx_x2_y_xy += offset_tap.yyxx * offset_tap.zyzy; //marty mcfly style\n    }\n\tx_x2_y_xy *= 1.0 / float((BLUR_RADIUS * 2 + 1) * (BLUR_RADIUS * 2 + 1));\n\n\tfloat cyx = (x_x2_y_xy.w - x_x2_y_xy.x * x_x2_y_xy.z);\n\tfloat vx = (x_x2_y_xy.y - x_x2_y_xy.x * x_x2_y_xy.x) + 1e-6;\n\n\tfloat beta = cyx / vx;\n\tfloat alpha = x_x2_y_xy.z - beta * x_x2_y_xy.x;\n\n\tfloat filtered_val = clamp(beta * center_tap.y + alpha, 0.0, 1.0);\n    return vec2(filtered_val, center_tap.y);\n}\n\n//https://www.shadertoy.com/view/4ssfWM\n//Credits: Jodie\nfloat bayer4(vec2 a)\n{\n    uvec2 b = uvec2(a);\n    uint c = (b.x^b.y)<<1u;\n    return float(\n        ((c&4u|b.y&2u)>>1u)|\n        ((c&2u|b.y&1u)<<2u)\n    )/4.0/4.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Generate occlusion mask\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texcoord = fragCoord.xy / iResolution.xy;\n    texcoord *= 2.5; //scale it down\n    texcoord.x += iTime * 0.1; //scroll\n    fragColor.xyz = vec3(smoothstep(0.5, 0.7, texture(iChannel0, texcoord).x)); //threshold\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Raymarch some rays\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texcoord = fragCoord.xy / iResolution.xy;\n    float jitter = bayer4(gl_FragCoord.xy);\n    bool check = gl_FragCoord.x > 0.5 * iResolution.x;\n\n    //Sample depth/mask\n    float depth = textureLod(iChannel0, texcoord, 0.0).x;\n\n    //Calculate ray pos and inc\n    vec2 ray_position = texcoord;\n    vec2 ray_increment = (VL_POSITION - texcoord) / float(VL_SAMPLES);\n\n    //Offset the initial ray\n    ray_position += ray_increment * (check ? jitter : 0.5);\n\n    //Calculate miplevel\n    float miplevel = check ? clamp(log2(distance(texcoord, VL_POSITION) * VL_MIP_MULT), 0.0, 10.0) : 0.0;    \n\n    //Accumulated color\n    float color = 0.0;\n\n  \tfor (int i = 0; i < VL_SAMPLES; i++)  \n  \t{\n    \tcolor += textureLod(iChannel0, ray_position, miplevel).x; //sample mask/depth\n        ray_position += ray_increment; //step the ray       \n\n  \t} \n    color /= float(VL_SAMPLES);\n\n    //Output\n    fragColor.x = color;\n    fragColor.y = depth;\n    fragColor.z = 0.0;\n    fragColor.w = 1.0;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Fairly cheap screen space volumetrics\n    \n    1. Radial blur with jitter (bayer matrix) + mips\n    2. Two-pass guided filter (mask/depth works as guide)\n    \n    As result, few samples gives a good and smooth result.\n\n    Done for fun, hope it's useful to someone.\n\n    LV\n*/\n\n//Blur + tonemap + gamma\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texcoord = fragCoord.xy / iResolution.xy;\n\n    fragColor.xy = guided_filter(iChannel0, texcoord, 1.0 / iResolution.xy, true);\n    fragColor.zw = vec2(0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}