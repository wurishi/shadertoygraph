{"ver":"0.1","info":{"id":"3d2GWc","date":"1550173447","viewed":197,"name":"Triangle Dot Clock","username":"wagyx","description":"I liked the concept. What about you ? It feelds like a planetary system to me, a werid one though..\nsource: https://odditymall.com/3angle-triangle-watch-face\nuses hsv coloring and color interpolation","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["triangle","clock","colorwheel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI2 6.28318530718\n\nconst vec3 green= vec3(0.,1.,0.);\nconst vec3 black= vec3(0.);\nconst vec3 white= vec3(1.0);\n\nvec2 rotate( vec2 v, float angdeg) {\n    float angrad= radians(angdeg);\n    float c= cos(angrad);\n    float s= sin(angrad);\n    return mat2(c,-s,s,c)*v;\n}\n\n//from iq\nfloat sdCircle( vec2 p, float r ) {\n  return length(p) - r;\n}\n\n//from iq\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n//from iq\nfloat sdAnnularShape( in float dist, in float r ){\n  return abs(dist) - r;\n}\n\n//from iq\nfloat sdRoundedShape( in float d, in float r )\n{\n  return d - r;\n}\n\nvec2 pol2cart(vec2 v) {\n\treturn v.x*vec2(cos(v.y),sin(v.y));\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat cross2d(vec2 u, vec2 v){\n    return u.x*v.y-u.y*v.x;\n}\n\n// https://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\n// Compute barycentric coordinates (u, v, w) for\n// point p with respect to triangle (a, b, c)\nvec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c){\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n    float invden = 1./cross2d(v0,v1);\n    float v = cross2d(v2,v1) * invden;\n    float w = cross2d(v0,v2) * invden;\n    return vec3(1.0f - v - w, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/min(iResolution.y,iResolution.x);\n    vec3 col= black; // background color\n    float smoothing= 0.003; //antialiasing\n    \n    //time = iDate.w // true time in seconds\n\tvec3 hms= vec3(iDate.w / 60.0 /60.0, mod(iDate.w / 60.0, 60.0), mod(iDate.w, 60.0));\n    //hms= floor(hms); //uncomment for discrete clock\n\t// convert to angle\n\thms= vec3(mod(hms.x,12.)/12., hms.yz/60.);\n    vec3 colhou= hsv2rgb(vec3(hms.x,1.,1.));\n    vec3 colmin= hsv2rgb(vec3(hms.y,1.,1.));\n    vec3 colsec= hsv2rgb(vec3(hms.z,1.,1.));\n    \n    //circle\n\tfloat radius= 0.4;\n    vec2 center= vec2(0.,0.);\n    uv-=center;\n    //digits\n    float i = round(atan(uv.y, uv.x) * 12.0 / PI2);\n    float angle = (PI2 / 12.0) * i;   \n\tfloat circd= sdCircle(uv-vec2(cos(angle), sin(angle))*radius, radius/50.);\n    //float circd= sdAnnularShape(sdCircle(uv, radius), radius/100.);\n    //col+= smoothstep(circd-0.005,circd,0.);\n\n    \n    //triangle\n\tvec3 anghms= (0.25-hms)*PI2+ vec3(0.,1e-6,2e-6); // prevents degenerate case\n    vec2 p0 = pol2cart(vec2(radius, anghms.x));\n    vec2 p1 = pol2cart(vec2(radius, anghms.y));\n\tvec2 p2 = pol2cart(vec2(radius, anghms.z));\n    float triangd= sdTriangle(uv, p0,p1,p2);\n    float rdtri= sdRoundedShape(triangd, radius*0.01);\n    float anntri= sdAnnularShape(triangd, radius*0.01);\n    //col= mix(col, black, smoothstep(triangd-smoothing,triangd,0.));\n        \n\n    //endpoints\n    float circd0= sdCircle(uv-p0, radius*0.15);\n    float ann0= sdAnnularShape(circd0, radius*0.005);\n    float circd1= sdCircle(uv-p1, radius*0.1);\n    float ann1= sdAnnularShape(circd1, radius*0.005);\n\tfloat circd2= sdCircle(uv-p2, radius*0.05);\n    float ann2= sdAnnularShape(circd2, radius*0.005);\n\n    // dots\n    float freq= 20.;\n    vec2 uv2= freq*rotate(uv ,45.) ;\n    uv2= 2.*fract(uv2)-1.;\n    float dotd= sdCircle(uv2, 0.5);\n\tdotd= sdAnnularShape(dotd, 0.1);\n    //color interpolation\n    vec3 barcoord= barycentric(uv, p0,p1,p2);\n    vec3 coldots= barcoord.x*colhou + barcoord.y*colmin + barcoord.z*colsec;\n\n    col= mix(col, coldots,float(rdtri<0.) *smoothstep(dotd-0.05,dotd+0.05,0.));\n    //col= mix(col, 0.6*black, smoothstep(anntri-smoothing,anntri,0.));\n    \n    col= mix(col, black, smoothstep(circd0-smoothing,circd0,0.));\n    col= mix(col, colhou, smoothstep(ann0-smoothing,ann0,0.));\n    col= mix(col, black, smoothstep(circd1-smoothing,circd1,0.));\n    col= mix(col, colmin, smoothstep(ann1-smoothing,ann1,0.));\n    col= mix(col, black, smoothstep(circd2-smoothing,circd2,0.));\n    col= mix(col, colsec, smoothstep(ann2-smoothing,ann2,0.));\n\tcol= mix(col, 0.6*white, smoothstep(circd-smoothing,circd,0.));\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}