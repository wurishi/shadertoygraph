{"ver":"0.1","info":{"id":"sldcDs","date":"1660805288","viewed":186,"name":"Planet w/ Atmosphere SDF","username":"nethe550","description":"There are some artifacts with the simplex noise on the planet's surface because of precision errors from ray-marching.\n\nIf your computer can handle it, I highly recommend viewing it in QUALITY mode. (uncomment line 11)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lighting","space","planet","scattering","atmosphere","scatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Planet w/ Atmosphere SDF\n// nethe550\n//\n// Heavily inspired by the atmosphere from\n// Sebastian Lague, adapted for path-traced SDFs.\n//\n// ( https://www.youtube.com/watch?v=DxfEbulyFcY )\n\n// comment / uncomment these depending on your computer hardware\n//#define PERFORMANCE\n#define QUALITY\n\n\n// wavelengths of light scattered (red, green, blue)\n#define WAVELENGTHS vec3(700, 532, 440)\n\n// strength of atmospheric scattering\n#define SCATTER_STRENGTH 20.0\n\n// bias of scattered colours\n#define SCATTER_BIAS vec3(400.0, 400.0, 400.0)\n\n// whether to correct colour-space to more accurately reflect human perception\n//#define USE_GAMMA_CORRECTION\n\n// zoom level of camera\n#define CAMERA_ZOOM 1.25\n\n#define PI 3.14159265358979\n\n#ifdef QUALITY\n    #define DO_SPECULAR\n    #define MAX_STEPS 512\n    #define COLLISION_EPSILON 0.0001\n    #define SUN_NOISE\n    #define TERRAIN_OCTAVES 8\n    #define DEPTH_SAMPLES 15\n    #define SCATTER_POINTS 15\n#else\n    #ifdef PERFORMANCE\n        #define MAX_STEPS 128\n        #define COLLISION_EPSILON 0.01\n        #define TERRAIN_OCTAVES 4\n        #define DEPTH_SAMPLES 8\n        #define SCATTER_POINTS 8\n    #endif\n#endif\n\n\nstruct Material {\n    vec3 color;\n    #ifdef DO_SPECULAR\n        float glossiness;\n    #endif\n};\n\nstruct SDF {\n    vec3 position;\n    float radius;\n    bool atmosphere;\n    float atmosphereThickness;\n    float atmosphereDensity;\n    float scatteringStrength;\n    int depthSamples;\n    int inScatterPoints;\n    Material material;\n};\n\nstruct SDFTest {\n    float dist;\n    SDF sdf;\n};\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    int maxSteps;\n    float collisionEpsilon;\n    float farPlane;\n};\n\nstruct RaycastHit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    float dist;\n    int steps;\n    SDF sdf;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float focalLength;\n    float farPlane;\n};\n\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\n\nSDFTest sphere(vec3 p, SDF sdf) {\n    SDFTest t;\n    t.dist = length(p + sdf.position) - sdf.radius;\n    t.sdf = sdf;\n    return t;\n}\n\nSDFTest planet(vec3 p, SDF sdf, vec3 offset, int octaves, float amplitude, float frequency, float persistence, float lacunarity) {\n\n    // rotate planet\n    float a = iTime * -0.05;\n    vec3 tempP = p;\n    float cosA = cos(a);\n    float sinA = sin(a);\n    p.x = tempP.x * cosA + tempP.z * sinA;\n    p.z = tempP.z * cosA - tempP.x * sinA;\n\n    SDFTest t;\n    float sphereDist = sphere(p, sdf).dist;\n    float sum = 0.0;\n    float prevAmplitude = amplitude;\n    for (int i = 0; i < octaves; i++) {\n        \n        sum += amplitude * snoise((p + offset) * frequency);\n        \n        amplitude *= persistence;\n        frequency *= lacunarity;\n        \n    }\n    sum += snoise((p + offset)) * 0.5 + 0.5; // bias oceans\n    t.dist = sphereDist + sum * 0.0125;\n   \n    float n = 1.0 - (0.5 + 0.5 * sum);\n    \n    sdf.material.color = gradient(n, 0.0, 1.0);\n    \n    t.sdf = sdf;\n    \n    return t;\n    \n}\n\nSDFTest SDFUnion(SDFTest a, SDFTest b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nSDFTest scene(vec3 p) {\n \n    SDF planetSDF;\n    planetSDF.radius = 0.5;\n    planetSDF.position = vec3(0.0);\n    planetSDF.atmosphere = true;\n    planetSDF.depthSamples = DEPTH_SAMPLES;\n    planetSDF.inScatterPoints = SCATTER_POINTS;\n    planetSDF.scatteringStrength = SCATTER_STRENGTH;\n    planetSDF.atmosphereDensity = 4.3;\n    planetSDF.atmosphereThickness = 0.25;\n    \n    planetSDF.material.color = vec3(0.18);\n    #ifdef DO_SPECULAR\n        planetSDF.material.glossiness = 135.0;\n    #endif\n    \n    return planet(p, planetSDF, vec3(0.0), TERRAIN_OCTAVES, 1.0, 5.0, 0.5, 2.0);\n \n}\n\n\nvec3 getNormal(vec3 p, float e) {\n    vec2 a = vec2(e, 0.0);\n    return normalize(vec3(\n        scene(p + a.xyy).dist - scene(p - a.xyy).dist,\n        scene(p + a.yxy).dist - scene(p - a.yxy).dist,\n        scene(p + a.yyx).dist - scene(p - a.yyx).dist\n    ));\n}\n\nvec3 getNormal(vec3 p) {\n    return getNormal(p, 0.0001);\n}\n\n\nRaycastHit castRay(Ray ray) {\n    RaycastHit hit;\n    hit.hit = false;\n    hit.dist = 0.0;\n    hit.steps = 0;\n    float t = 0.0;\n\n    for (int i = 0; i < ray.maxSteps; i++) {\n        \n        hit.steps++;\n        \n        hit.position = ray.origin + ray.direction * t;\n        SDFTest s = scene(hit.position);\n        hit.sdf = s.sdf;\n        hit.dist = s.dist;\n        \n        if (s.dist < ray.collisionEpsilon) {\n            hit.hit = true;\n            hit.normal = getNormal(hit.position);\n            break;\n        }\n        \n        t += s.dist;\n        \n        if (t > ray.farPlane) break;\n    }\n    return hit;\n}\n\nvec3 perspective(vec2 clip, Camera camera) {\n    vec3 w = normalize(camera.target - camera.position);\n    vec3 u = normalize(cross(w, camera.up));\n    vec3 v = normalize(cross(u, w));\n    return vec3(normalize(clip.x * u + clip.y * v + camera.focalLength * w));\n}\n\n\nfloat diffuse(DirectionalLight light, vec3 normal) {\n    return max(0.0, -dot(normal, light.direction));\n}\n\nfloat densityAtPoint(vec3 point, SDF sdf) {\n    float distToSurface = length(point - sdf.position) - sdf.radius;\n    float dist01 = distToSurface / sdf.atmosphereThickness;\n    return exp(-dist01 * sdf.atmosphereDensity) * (1.0 - dist01);\n}\n\nfloat opticalDepth(SDF sdf, vec3 origin, vec3 direction, float rayLength, int depthSamples) {\n    vec3 samplePoint = origin;\n    float stepSize = rayLength / (float(depthSamples) - 1.0);\n    float opticalDepth = 0.0;\n    for (int i = 0; i < depthSamples; i++) {\n        float localDensity = densityAtPoint(samplePoint, sdf);\n        opticalDepth += localDensity * stepSize;\n        samplePoint += direction * stepSize;\n    }\n    return opticalDepth;\n}\n\nvec3 atmosphere(SDF sdf, DirectionalLight sun, vec3 origin, vec3 direction, float rayLength, int inScatterPoints, float bias) {\n    float scatterR = pow(SCATTER_BIAS.r / WAVELENGTHS.r, 4.0) * sdf.scatteringStrength;\n    float scatterG = pow(SCATTER_BIAS.g / WAVELENGTHS.g, 4.0) * sdf.scatteringStrength;\n    float scatterB = pow(SCATTER_BIAS.b / WAVELENGTHS.b, 4.0) * sdf.scatteringStrength;\n    vec3 scatterCoefficients = vec3(scatterR, scatterG, scatterB);\n    \n    vec3 inScatterPoint = origin;\n    float stepSize = rayLength / (float(inScatterPoints) - 1.0);\n    vec3 inScatteredLight = vec3(0.0);\n    for (int i = 0; i < inScatterPoints; i++) {\n        float sunRayLength = sphereIntersect(sdf.position, sdf.radius + sdf.atmosphereThickness, inScatterPoint, -sun.direction, bias).y;\n        float sunRayOpticalDepth = opticalDepth(sdf, inScatterPoint, -sun.direction, sunRayLength, sdf.depthSamples);\n        float viewRayOpticalDepth = opticalDepth(sdf, inScatterPoint, -direction, stepSize * float(i), sdf.depthSamples);\n        vec3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatterCoefficients);\n        float localDensity = densityAtPoint(inScatterPoint, sdf);\n        \n        inScatteredLight += localDensity * transmittance * scatterCoefficients * stepSize;\n        inScatterPoint += direction * stepSize;\n    }\n    return inScatteredLight;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 clip = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    Camera camera;\n    camera.position = vec3(-2.0 / CAMERA_ZOOM, 0.0, 0.0);\n    camera.target = vec3(0.0);\n    camera.focalLength = 1.5;\n    camera.farPlane = 10.0;\n    camera.up = vec3(0.0, 1.0, 0.0);\n    if (iMouse.z != 0.0) {\n        vec2 angle = ((2.0 * iMouse.xy - iResolution.xy) / iResolution.y).yx * vec2(1.57, -3.14);\n        camera.position = cameraOrbit(camera.position, camera.target, 1.0, angle);\n    }\n    \n    DirectionalLight sun;\n    sun.direction = vec3(1.0, 0.0, 0.0);\n    sun.color = vec3(7.0, 4.5, 3.0);\n    \n    Ray fill;\n    fill.origin = camera.position;\n    fill.direction = perspective(clip, camera);\n    fill.maxSteps = MAX_STEPS;\n    fill.collisionEpsilon = COLLISION_EPSILON;\n    fill.farPlane = camera.farPlane;\n    \n    vec3 color = vec3(0.0);\n    \n    RaycastHit fillHit = castRay(fill);\n    \n    // skybox\n    vec3 skybox = vec3(texture(iChannel0, fill.direction));\n    if (!fillHit.sdf.atmosphere) color += skybox;\n    else {\n        // fade out stars by the ray distance through the atmosphere\n        float distThroughAtmosphere = sphereIntersect(fillHit.sdf.position, fillHit.sdf.radius + fillHit.sdf.atmosphereThickness, fill.origin, fill.direction, 0.0).y;\n        color += skybox * smoothstep(0.0, 0.5, max(0.0, (fillHit.sdf.radius + fillHit.sdf.atmosphereThickness) - distThroughAtmosphere));\n    }\n    \n    // fade out skybox when looking near sun\n    float angleToSun = acos(dot(fill.direction, sun.direction) / (length(fill.direction) * length(sun.direction)));\n    color *= smoothstep(3.75, 0.0, angleToSun);\n    \n    // sun\n    float sunSpot = pow(max(0.0, dot(fill.direction, -sun.direction)), 512.0);\n    #ifdef SUN_NOISE\n        // noise\n        vec3 offset = (vec3(iTime * 7.0, cos(iTime), sin(iTime)) - 0.5) * 0.25;\n        float noise = 0.8 + 0.2 * snoise(fill.direction * 150.0 + offset * 0.75) * pow(sunSpot, 0.25);\n        sunSpot *= noise;\n    #endif\n    color += sun.color * sunSpot;\n    \n    // fill\n    if (fillHit.hit) {\n        \n        float sunDiffuse = diffuse(sun, fillHit.normal);\n        \n        vec3 hv = normalize(sun.direction + camera.position);\n        color = fillHit.sdf.material.color * sunDiffuse * sun.color;\n        \n        #ifdef DO_SPECULAR\n            float specular = pow(clamp(dot(fillHit.normal, hv), 0.0, 1.0), fillHit.sdf.material.glossiness) * sunDiffuse;\n            color += normalize(sun.color) * specular;\n        #endif\n        \n    }\n    \n    // atmosphere\n    if (fillHit.sdf.atmosphere) {\n        \n        vec2 hitInfo = sphereIntersect(fillHit.sdf.position, fillHit.sdf.radius + fillHit.sdf.atmosphereThickness, fill.origin, fill.direction, 0.0);\n        float distToAtmosphere = hitInfo.x;\n        float distThroughAtmosphere = hitInfo.y;\n        \n        if (distThroughAtmosphere > 0.0) {\n            vec3 pointInAtmosphere = fill.origin + fill.direction * (distToAtmosphere + fill.collisionEpsilon);\n            \n            color += atmosphere(\n                fillHit.sdf, \n                sun, \n                pointInAtmosphere, \n                fill.direction, \n                distThroughAtmosphere - fill.collisionEpsilon * 2.0, \n                fillHit.sdf.inScatterPoints,\n                0.2\n            );\n            \n        }\n        \n    }\n    \n    #ifdef USE_GAMMA_CORRECTION\n        color = pow(color, vec3(0.4545));\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// A basic starmap using simplex noise\n// nethe550\n\n#define STAR_SIZE_MIN 0.8\n#define STAR_SIZE_MAX 0.9\n#define STAR_DENSITY 256.0\n#define STAR_COLOR_SCALE 10.0\n#define STAR_COLOR_OFFSET_R 0.1\n#define STAR_COLOR_OFFSET_G 0.005\n#define STAR_COLOR_OFFSET_B 0.0\n#define STAR_COLOR_BIAS_R 0.9\n#define STAR_COLOR_BIAS_G 0.6\n#define STAR_COLOR_BIAS_B 0.8\n\n\nfloat starnoise(vec3 s) {\n    return (0.5 + 0.5 * snoise(s * STAR_COLOR_SCALE));\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    \n    float n = snoise(rayDir * STAR_DENSITY);\n    n = smoothstep(STAR_SIZE_MIN, STAR_SIZE_MAX, n);\n    \n    vec3 color = vec3(n);\n    color *= n * vec3(\n        starnoise(rayDir + STAR_COLOR_OFFSET_R) * STAR_COLOR_BIAS_R, \n        starnoise(rayDir + STAR_COLOR_OFFSET_G) * STAR_COLOR_BIAS_G, \n        starnoise(rayDir + STAR_COLOR_OFFSET_B) * STAR_COLOR_BIAS_B\n    );\n    \n    // Output to cubemap\n    fragColor = vec4(color, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n \n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n  \nfloat hash(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// angle-axis rotation\n// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\nvec3 rodriguesRotation(vec3 v, vec3 axis, float angle) {\n    return v * cos(angle) + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - cos(angle));\n}\n\n// combining two angle-axis rotations into orbit rotation\nvec3 cameraOrbit(vec3 position, vec3 target, float radius, vec2 angle) {\n    vec3 newPosition = position;\n    newPosition -= target;\n    // x rotation\n    newPosition = rodriguesRotation(newPosition, vec3(0.0, 1.0, 0.0), angle.y);\n    // y rotation\n    vec3 perpendicular = normalize(cross(target - newPosition, vec3(0.0, 1.0, 0.0)));\n    newPosition = rodriguesRotation(newPosition, perpendicular, angle.x);\n    newPosition += target;\n    return newPosition * radius;\n}\n\nfloat scale(float number, float inMin, float inMax, float outMin, float outMax) {\n    return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\n#define DARK_BLUE vec3(0.0, 0.0, 0.09)\n#define BLUE vec3(0.0, 0.0, 0.18)\n#define LIGHT_BLUE vec3(0.0, 0.09, 0.18)\n#define YELLOW vec3(0.18, 0.18, 0.0)\n#define LIGHT_GREEN vec3(0.04, 0.18, 0.0)\n#define GREEN vec3(0.0, 0.18, 0.0)\n#define DARK_GREEN vec3(0.0, 0.09, 0.0)\n#define BROWN vec3(0.04, 0.02, 0.0)\n#define GREY vec3(0.09, 0.09, 0.09)\n#define WHITE vec3(0.18)\n\nvec3 gradient(float t, float minValue, float maxValue) {\n    \n    float divisionStep = (maxValue - minValue) * 0.1;\n    float divisionStep2 = divisionStep * 2.0;\n    float divisionStep3 = divisionStep * 3.0;\n    float divisionStep4 = divisionStep * 4.0;\n    float divisionStep5 = divisionStep * 5.0;\n    float divisionStep6 = divisionStep * 6.0;\n    float divisionStep7 = divisionStep * 7.0;\n    float divisionStep8 = divisionStep * 8.0;\n    float divisionStep9 = divisionStep * 9.0;\n    \n    \n    vec3 c = DARK_BLUE;\n    \n    c = mix(c, \n        DARK_BLUE,\n        clamp(t, minValue, minValue + divisionStep) * 10.0\n    );\n    c = mix(c,\n        BLUE,\n        (clamp(t, minValue + divisionStep, minValue + divisionStep2) - divisionStep) * 10.0\n    );\n    c = mix(c,\n        LIGHT_BLUE,\n        (clamp(t, minValue + divisionStep2, minValue + divisionStep3) - divisionStep2) * 10.0\n    );\n    c = mix(c,\n        YELLOW,\n        (clamp(t, minValue + divisionStep3, minValue + divisionStep4) - divisionStep3) * 10.0\n    );\n    c = mix(c,\n        LIGHT_GREEN,\n        (clamp(t, minValue + divisionStep4, minValue + divisionStep5) - divisionStep4) * 10.0\n    ); \n    c = mix(c,\n        GREEN,\n        (clamp(t, minValue + divisionStep5, minValue + divisionStep6) - divisionStep5) * 10.0\n    );\n    c = mix(c,\n        DARK_GREEN,\n        (clamp(t, minValue + divisionStep6, minValue + divisionStep7) - divisionStep6) * 10.0\n    );\n    c = mix(c,\n        BROWN,\n        (clamp(t, minValue + divisionStep7, minValue + divisionStep8) - divisionStep7) * 10.0\n    );\n    c = mix(c,\n        GREY,\n        (clamp(t, minValue + divisionStep8, minValue + divisionStep9) - divisionStep8) * 10.0\n    );\n    c = mix(c,\n        WHITE,\n        (clamp(t, minValue + divisionStep9, maxValue) - divisionStep9) * 10.0\n    );\n    \n    return c;\n}\n\n// returns vec2(distToSphere, distThroughSphere)\n// ray origin inside sphere, distToSphere = 0\n// ray misses sphere, distToSphere = 1e20, distThroughSphere = 0\nvec2 sphereIntersect(vec3 center, float radius, vec3 origin, vec3 direction, float bias) {\n\n    vec3 offset = origin - center;\n    float a = dot(direction, direction);\n    float b = 2.0 * dot(offset, direction);\n    float c = dot(offset, offset) - radius * radius;\n    float d = b * b - 4.0 * a * c; // discriminant from quadratic\n    \n    if (d > 0.0) {\n        float s = sqrt(d);\n        float distToSphereNear = max(bias, ((-b - s) / (2.0 * a)));\n        float distToSphereFar = (-b + s) / (2.0 * a);\n        \n        // ignore intersections behind ray\n        if (distToSphereFar >= bias) {\n            return vec2(distToSphereNear, distToSphereFar - distToSphereNear);\n        }\n    }\n    \n    // no intersection\n    return vec2(1e20, 0.0);\n\n}","name":"Common","description":"","type":"common"}]}