{"ver":"0.1","info":{"id":"wldGDn","date":"1576080126","viewed":204,"name":"2D Procedural noise functions","username":"jesusdz","description":"Two different kinds of fractal noise (fractional Brownian motion and ridged fractal noise).\nUsing two implementations of 2D procedural noise:\n- Perlin noise (see issue below in the comments)\n- Interpolated hash-based noise values","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PROCEDURAL_PERLIN_NOISE\n\n#if defined(PROCEDURAL_PERLIN_NOISE)\n\n#define USE_FAST_GRADIENT\n\n#if !defined(USE_FAST_GRADIENT)\n// Partial FNV1 hash function\nfloat hash(float v)\n{\n\tconst int prime = 16777619;\n    const int offset = -2128831035;\n \n    int key = int(floor(v));\n    int i = offset;\n    i *= prime;\n    i ^= key;\n    i *= prime;\n    i ^= key;\n    \n    return float(i);\n}\n\nvec2 gradient(vec2 p)\n{\n    float x = hash(89.0*p.x + 97.0*p.y);\n    float y = hash(p.y + x);\n    vec2 grad = (sin(vec2(x, y)));\n    return grad;\n}\n\n#else\n\n// trial and error achievement...\nfloat hash2(vec2 v)\n{\n    return sin(201.987*dot(v, vec2(23.54,31.87)))*147.546;\n}\n\nvec2 gradient(vec2 p)\n{\n    float v = hash2(p);\n    return sin(vec2(v, v * 33.9));\n}\n\n#endif\n\nfloat noise(vec2 p)\n{\n    // cell corners\n    vec2 c1 = floor(p);\n\tvec2 c2 = c1 + vec2(1,0);\n\tvec2 c3 = c1 + vec2(0,1);\n\tvec2 c4 = c1 + vec2(1,1);\n\n    // corner gradients\n    vec2 gc1 = gradient(c1); // bot-left\n    vec2 gc2 = gradient(c2); // bot-right\n    vec2 gc3 = gradient(c3); // top-left\n    vec2 gc4 = gradient(c4); // top-right\n\n    // fractional part\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f); // cubic curve instead of linear\n    //f = f*f*f*(10.0 + f*(6.0*f - 15.0)); // quintic curve\n    \n    // horizontal interp. at y=0\n    float d1 = dot(p - c1, gc1);\n    float d2 = dot(p - c2, gc2);\n    float i1 = mix(d1, d2, f.x);\n\n    // horizontal interp. at y=1\n    float d3 = dot(p - c3, gc3);\n    float d4 = dot(p - c4, gc4);\n    float i2 = mix(d3, d4, f.x);\n\n    // vertical interpolation\n    float i3 = mix(i1, i2, f.y);\n\n    return i3 * 0.5 + 0.5;\n}\n\n#else\n\n// Taken from iq's shader \"Noise - value - 3D\":\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec2 p)\n{\n    // cell corners\n    vec2 c1 = floor(p);\n\tvec2 c2 = c1 + vec2(1,0);\n\tvec2 c3 = c1 + vec2(0,1);\n\tvec2 c4 = c1 + vec2(1,1);\n\n    // pseudo-random values at corners\n    float r1 = hash(vec3(c1,0.0)); // bot-left\n    float r2 = hash(vec3(c2,0.0)); // bot-right\n    float r3 = hash(vec3(c3,0.0)); // top-left\n    float r4 = hash(vec3(c4,0.0)); // top-right\n\n    // fractional part\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f); // cubic curve instead of linear\n    //f = f*f*f*(10.0 + f*(6.0*f - 15.0)); // quintic curve\n    \n    // Interpolation\n    float i1 = mix(r1, r2, f.x);\n    float i2 = mix(r3, r4, f.x);\n    float i3 = mix(i1, i2, f.y);\n\n    return i3;\n}\n\n#endif\n\n// fractional Brownian motion\nfloat fBm(vec2 p, int octaves)\n{\n    float f = 1.0; // frequency\n    float a = 0.5; // amplitude\n    float asum = 0.0; // sum of amplitudes\n    \n    float value = 0.0;\n    for (int i = 0; i < octaves; ++i)\n    {\n        value += a*noise(f*p + float(i)); // abs(noise) makes turbulence\n        asum += a;\n        a *= 0.5;\n        f *= 2.0;\n    }\n    \n    value /= asum;\n    return value;\n}\n\nfloat rnoise(in vec2 p)\n{\n    float n = 1.0 - abs(2.0 * noise(p) - 1.0);\n\treturn n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom\n    float zoom = 2.0 + 12.0*iMouse.y/iResolution.y;\n    \n    // normalized pixel coordinates (from -1 to 1)\n    vec2 p = zoom * (2.0*fragCoord - iResolution.xy)/iResolution.y;// + iTime*10.5;\n    \n    // noise value\n    float n = 0.0;//noise(p);\n    \n    if (p.x < 0.0)\n    {\n    \t// fractional Brownian motion\n    \tn = fBm(p, 4);\n    \t//n = fBm(vec2(53.0*fBm(p + 0.5*iTime, 1), 15.0*fBm(p+iTime*vec2(-0.5,0.5),1)), 1);\n    }\n    else\n    {\n        // fractal ridged noise\n        //n = 1.2 * rnoise(0.6*p);\n        //n = 1.0;\n        n = 0.6 * noise(0.3*p);\n        n += 0.22 * rnoise(0.5*p);\n        n += 0.13 * rnoise(1.0*p);\n        n += 0.05 * rnoise(1.7*p);\n        \n        n *= noise(0.1*p + vec2(345.0,765.1));\n        //n *= smoothstep(0.2,0.6,noise(0.02*p + vec2(654.4,123.5)));\n        //n = step(0.35, n) * n;\n    }\n    \n    n *= smoothstep(0.5,1.0,abs(fragCoord.x-0.5*iResolution.x));\n    \n    // final color\n    vec3 col = vec3(n);\n\n    // pseudo-gamma correction\n    col = sqrt(col);\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}