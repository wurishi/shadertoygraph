{"ver":"0.1","info":{"id":"slXfWN","date":"1650892070","viewed":385,"name":"Integer Raymarcher 2, Walls Maze","username":"TrueBoolean","description":"The bitwise texture generated from XOR maps better to axis-aligned walls than it does to angled walls or circular walls, being a 3D texture. By checking which bit is set you can have the ray ignore a section and continue onward, appearing as many tunnels","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","tunnel","fast","raymarcher","maze","integer","bitwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 512\n#define SCALE 8\nvoid mainImage(out vec4 FCOL, in vec2 FPT){\n    \n    ivec2 PT = ivec2(FPT-iResolution.xy/2.);\n    int SIZE = int(min(iResolution.x, iResolution.y))/SCALE;\n    ivec2 look = ivec2(int(sin(iTime)*float(SIZE)));\n    int scroll = int(iTime*256.)/3;\n      \n    ivec2 sum = ivec2(0);\n    ivec2 ray = sum;\n    int z;\n    for(z=scroll; z < ITER+scroll; ++z){\n        sum += PT;\n        sum += look;\n        ray = sum>>8;\n        if((z&64) != 0 && abs(ray.x) > SIZE || abs(ray.y) > SIZE)\n            break;      \n    }\n    ivec3 COL = ivec3((ray.x^ray.y^z)&255);\n    if(abs(ray.y) > SIZE)\n        COL.x >>= 1;\n    if(abs(ray.x) > SIZE)\n        COL.y >>= 1;\n    if(z == ITER+scroll)\n        COL = ivec3(0);\n    \n    FCOL = vec4(vec3(COL)/float(ITER), 1.);\n}","name":"Image","description":"","type":"image"}]}