{"ver":"0.1","info":{"id":"cdGyWK","date":"1696622166","viewed":29,"name":"06. Golden","username":"Ladus","description":"Inktober 2023 Day 6. My first attempt at normals and lighting in a 2d example","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["golden","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sd shapes by Inigo Quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec2 normalizeScreenSpace(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 1.-(iResolution.y/iResolution.x);\n    uv = (uv - vec2(0.5))*2.;\n    return uv;\n}\n\nfloat coinf(vec2 starSpace, out float mask) {\n    float edgeThickness = 1.5;\n    \n    float star = sdStar5(starSpace, 0.5, 0.5);\n    star = 1.-smoothstep(0.0,0.05*edgeThickness, star);\n    \n    float coin = sdCircle(starSpace, 0.6);\n    float innerCoin = 1.-smoothstep(0.02,0.02+(0.01*edgeThickness), coin);\n    innerCoin -= smoothstep(0.3,0.9,star);\n    float outerCoin = 1.-smoothstep(0.1,0.1+(0.02*edgeThickness), coin) * 1.-smoothstep(0.03*edgeThickness,0.0, coin);\n    \n    float result = 0.;\n    result = max(innerCoin, star);\n    result = max(result, outerCoin);\n    result = max(result, 0.5);\n    \n    mask = 1.-smoothstep(0.1+(0.02*edgeThickness),0.1+(0.02*edgeThickness), coin);\n    return result;\n}\n\nvec2 getNormal(vec2 uv) {\n    float mask = 0.;\n    float normalOffsetSampleDistance = 0.01;\n    vec2 color = vec2(0.,0.);\n    \n    float top = coinf(uv-vec2(0.,0.-normalOffsetSampleDistance), mask);\n    float bottom = coinf(uv-vec2(0.,0.+normalOffsetSampleDistance), mask);\n    float left = coinf(uv-vec2(0.-normalOffsetSampleDistance,0.), mask);\n    float right = coinf(uv-vec2(0.+normalOffsetSampleDistance,0.), mask);\n    \n    color = vec2(top-bottom, left-right)*mask*1.;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = normalizeScreenSpace(fragCoord);   \n    float loopingTime = sin(iTime/2.5 * 2.);\n    \n    vec3 gold = vec3(1.0,1.0,0.3);\n    vec3 goldBase = vec3(1.0,0.6,0.);\n    vec3 blue = vec3(.5,.2,1.)+vec3(0.2);\n    \n    // coin alpha\n    vec2 coinSpace = uv;\n    \n    coinSpace.x *= 1.1 + (sin((loopingTime*2.)-1.)*0.15);\n    \n    float mask = 0.;\n    float coin = coinf(coinSpace, mask);\n    \n    vec2 lightDirection = vec2(0.2,sin(loopingTime)*2.);\n    vec2 normal = getNormal(coinSpace);\n    \n    vec3 coinColor = (goldBase * coin);\n    \n    // Create background with vignette\n    vec3 background = mix(\n        blue,\n        vec3(0.),\n        vec3(clamp(0.,1.,pow(distance(uv, vec2(0.,0.)), 1.)/3.))\n    );\n    \n    // Apply light based on the normal direction and the light direction\n    float lightMask = dot(normal,lightDirection);\n    \n    // Add a light beam moving across the coin\n    lightMask = max(lightMask, pow(sin((uv.x+1.6) +sin(loopingTime)*1.2), 16.)*mask*0.4);\n    lightMask = max(lightMask, lightDirection.x*0.2*mask);\n    \n    vec3 directionalHighlight = vec3(lightMask)*gold*1.2;\n    \n    // Apply base color, and add light\n    vec3 color = mix(background, coinColor, mask);\n    color += directionalHighlight;\n    \n    // Output\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}