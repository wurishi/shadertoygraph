{"ver":"0.1","info":{"id":"lcd3Dr","date":"1713054500","viewed":59,"name":"BestenFallsKongenial 010","username":"Bestenfalls","description":"what should i say, and why? play around on the iMouse controlls","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","sound","newbee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize and center pixel coordinates\n    vec2 uv = (fragCoord.xy - vec2(0.0, iResolution.y)) / min(iResolution.x, iResolution.y);\n\n    // Separate x and y components of normalized mouse\n\n    float cv0 = iMouse.x / iResolution.x;\n    float cv1 = iMouse.y / iResolution.y;\n\n    // Separate z and w components of iMouse\n    \n    float cv2 = iMouse.z / iResolution.x;\n    float cw3 = iMouse.w / iResolution.y;\n\n    // Apply separate dampening factors for each component of iMouse\n    float dampingX = 0.01;\n    float dampingY = 0.01;\n    float dampingZ = 0.01;\n    float dampingW = 0.01;\n\n    cv0 = mix(cv0, 0.5, dampingX);\n    cv1 = mix(cv1, 0.5, dampingY);\n    cv2 = mix(cv2, 0.5, dampingZ);\n    cw3 = mix(cw3, 0.5, dampingW);\n\n    // Apply zoom, rotation, and speed variation\n    uv *= -1.0 + cv0 * 8.0;\n    float angle = radians(iMouse.y);\n    uv = vec2(uv.x * cos(angle) - uv.y * sin(angle), uv.x * sin(angle) + uv.y * cos(angle));\n    //uv += normalizedMouse * 0.1 * (cv2 / iResolution.x);\n\n    // Adjust time based on speed variation\n    float adjustedTime = iTime * (1.0 + cv1 * 5.0 * (cv2 / iResolution.x));\n\n    // Calculate variation angle\n    float variation = cw3;\n    float variationAngle = adjustedTime * 2.0 * 3.14159 * variation;\n\n    // Introduce damping for smooth variation\n\n    float previousVariationAngle = iTime * 1.0 * 3.14159 * fract(cw3);\n    variationAngle = mix(previousVariationAngle, variationAngle, dampingW);\n\n    // Apply variation angle to UV coordinates\n    uv += vec2(cos(variationAngle + uv.y), sin(variationAngle + uv.x));\n\n    // Time-varying pixel color with added movement\n    float fft1 = texture(iChannel0, vec2(0.0, 0.75)).r;\n    float fft2 = texture(iChannel0, vec2(0.0, 0.25)).r;\n    float fft3 = texture(iChannel0, vec2(0.0, 0.5)).b;\n    \n    vec3 col = 0.5 + 0.5 * sin(adjustedTime + uv.x * fft1 + vec3(0, 0.7, 4.0));\n    col *= 0.5 + 0.5 * cos(-adjustedTime + uv.y * fft2 + vec3(0, 2.0, 0.2));\n    col *= 5.0 - abs(tan(-adjustedTime * fft3 + uv.x * uv.y + vec3(0.4, 1.0, 0.5)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}