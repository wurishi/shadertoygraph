{"ver":"0.1","info":{"id":"mtGyDy","date":"1700603530","viewed":48,"name":"CSE_386_Final","username":"talluta","description":"CSE 386 final project made by Tyler Peters, Alex Talluto and Ethan Page. Gyroids :D. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uses open-source code from \"RayMarching starting point\" by Martijn Steinrucken as shown in start.txt\n// Permission to use said starting point was given via email by Prof. Cecchetto.  \n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\n// Function for rotation\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Creates a gyroid at point p with the beloq equation. Can set the scale of gyroid, section thickness, and the bias. \n// Needed from a tutorial and was required to create the shapes. \nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    \n    //Multiplying p, p.zxy, and scale by floats can change appearance of gyroid for cooler results, or can be left as is\n    return abs(dot(sin(p), cos(p.zxy))-bias)/(scale)-thickness;\n}\n\n// Function to calculate the camera spline path\nvec3 SplineCircular(float t, float radius) {\n    float angle = t * TAU;\n    return vec3(cos(angle) * radius, sin(angle) * radius, 0.0);\n}\n\n// Function for camera movement. Was in starting code but refactored it\n// to use with splines. \nvec3 Transform(vec3 p) {\n    // Circular path parameters\n    float circularPathTime = mod(iTime * 0.22, 1.0);  // Adjust speed with 0.2 or any other value\n    float circularPathRadius = 0.65; // adjust radius as needed\n    \n    // Calculate the position on the circular path using the spline function\n    vec3 circularPathPosition = SplineCircular(circularPathTime, circularPathRadius);\n\n    // Offset camera position along the circular path\n    p += circularPathPosition;\n\n    // Other camera movements (the original camera movements)\n    //p.z -= iTime * 0.01;\n    //p.y -= 0.3;\n    //p.y += sin(iTime * 0.05) * 0.2;\n    //p.x += cos(iTime * 0.03) * 0.2;\n\n    return p;\n}\n\n\n// Main function that combines the gyroids. Needed tutorial to teach how to create the gyroids\n// in order to create gyroids at all, but all below gyroids/parameters are our own\nfloat GetDist(vec3 p) {\n    p = Transform(p);\n    \n    //Change these parameters to mess with gyroids.\n    //If the scale parameters (second param.) of each gyroid are not easy multiples of each other,\n    //you'll get more organic shapes. They can be any float value and can create some really\n    //interesting designs\n    float g1 = sdGyroid(p, 5.75, .03, 1.5);\n    float g2 = sdGyroid(p, 10.36, .03, .3);\n    float g3 = sdGyroid(p, 15.36, .03, .3);\n    float g4 = sdGyroid(p, 38.36, .03, .3);\n    float g5 = sdGyroid(p, 62.36, .03, .3);\n    \n    //Each +/- operator and float value can be changed for different effect. Called \"bump maps\".\n    //Works by modifying the first gyroid's parameters g1 with those of the other 4 that are multiplied\n    //by any random float value. What you're seeing is gyroid g1 as a result of these modifications. \n    g1 -= g3*.2;\n    g1 -= g4*.1;\n    g1 += g5*.2;\n    g1 += g2*.1;\n    \n    // Clean up rendering a bit. Changing float value can result in a cool trippy effect\n    float d = g1*.7;\n    \n    \n    return d;\n}\n\n// RayMarching function\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// Function to calculate and return a normal given point p\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// Starter code function to get a ray's direction\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n// Phong lighting function to aid in calculating phong ambience\n// (Figuring out how to get this to work with what we're doing took a lot longer than we thought. Same with ambient occlusion.)\nvec3 PhongLighting(vec3 normal, vec3 viewDir, vec3 lightDir, vec3 col, float shininess) {\n    float diffuseIntensity = max(dot(normal, -lightDir), 0.0);\n    vec3 diffuse = col * diffuseIntensity;\n    \n    // Direction of the reflections\n    vec3 reflectDir = reflect(lightDir, normal);\n    float specularIntensity = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = col * specularIntensity;\n\n    return diffuse + specular;\n}\n\n// Sets a distant background to give depth perception \nvec3 bg(vec3 rd) {\n    vec3 col = vec3(0);\n    float y = rd.y*.5+.5;\n    \n    // BG color parameters\n    col+= (1.-y)*vec3(.1, .1, .6);\n    return col;\n}\n\n// Attempt at calculating ambient occlusion\nfloat CalculateAmbientOcclusion(vec3 p, vec3 n) {\n    float occlusion = 1.0;\n    float weight = 1.0;\n    for (int i = 0; i < 5; i++) {\n        vec3 randDir = normalize(vec3(sin(float(i)), cos(float(i)), sin(float(i) * 2.0 + 1.0)));\n        float d = RayMarch(p + n * 0.001, randDir);\n        occlusion += smoothstep(0.001, 0.01, d) * weight;\n        weight *= 0.5;\n    }\n    return occlusion;\n}\n\n// Display the stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    // Test variables for changing animation effect over time\n    float t = iTime * .2;\n    float x = 12.;\n    \n    //Phong parameters (self-explanatory\n    vec3 lightDir = normalize(vec3(5.0, 5.0, 5.0)); \n    vec3 lightColor = vec3(1.0, 1.0, 1.0); \n    float shininess = 9.0;\n    vec3 ambientColor = vec3(1.0, 1.0, 1.0);\n    \n    \n    // Camera rotation\n    vec3 ro = vec3(0, 0, -.02);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    // Camera looks at origin\n    vec3 lookat = vec3(0, 0, 0);\n    \n    // Camera direction\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    // If a ray hits something, do the following:\n    if(d<MAX_DIST) {\n    \n        // Get point p and normal n\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        p = Transform(p);\n        vec3 r = reflect(rd, n);\n        \n        // Phong and ambient occlusion calculations (for below var. ambient)\n        vec3 phongCol = PhongLighting(n, normalize(-rd), lightDir, col, shininess);\n        float ao = CalculateAmbientOcclusion(p, n);\n        \n        // More phong calculations\n        vec3 ambient = ambientColor * phongCol * (1.0 - ao);;\n        float diffuseIntensity = max(dot(n, -lightDir), 0.0);\n        vec3 diffuse = lightColor * diffuseIntensity * col;\n        \n        vec3 viewDir = normalize(-rd);\n        vec3 reflectDir = reflect(lightDir, n);\n        float specularIntensity = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n        vec3 specular = lightColor * specularIntensity;\n                \n        // Apply lighting effect\n        col = ambient + diffuse + specular;\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col += n*.3+.5;\n        \n\n        // Taking a below parameter +/- t times a float can result in really cool effects that change with time.\n        // Doing the same with x instead of t can also result in some cool stuff. \n        float g2 = sdGyroid(p+t, 10.36, .03, .3);\n        float g3 = sdGyroid(p, 5.36, .03, .3);\n        col *= S(-.1, .06, g2);\n    }\n    // Background depth perception control\n    col = mix(col, bg(rd), S(0., 7., d));\n    \n   // d = sdGyroid(vec3(uv.x, uv.y, iTime*.8), 50., .01, 7.);\n    \n    // Visibility (determined by the float in vec3)\n    fragColor = vec4(pow(col, vec3(.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}