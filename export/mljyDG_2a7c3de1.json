{"ver":"0.1","info":{"id":"mljyDG","date":"1692244197","viewed":18,"name":"RayMarch_F","username":"fan_M","description":"study ray march demo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\nfloat map(vec3 p)\n{\n    return length(p) - 1.0;\n}\n//计算曲面的法线就是这个曲面的梯度，也就是对xyz求偏导数\nvec3 GetNormal(vec3 p)\n{\n    float d = map(p);\n    vec2 e = vec2(0.001, 0.0);\n    float fdx = d - map(p-e.xyy);\n    float fdy = d - map(p-e.yxy);\n    float fdz = d - map(p-e.yyx);\n    return normalize(vec3(fdx, fdy, fdz));\n}\n\n\nfloat Raymarch(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    \n    for(int i = 0; i < 255; i++)\n    {\n        vec3 p = ro + rd*d;\n        float d0 = map(p);\n        if(d0 <= 0.001 || d >= 40.)\n            break;\n        d+=d0;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float scale = iResolution.x / iResolution.y;\n    float w = 1. / iResolution.y;\n    \n    uv -= 0.5;\n    uv.x *= scale;\n    vec3 col = vec3(0.0);\n\n   vec3 ro = vec3(0.0, 0.0, -3.);\n   vec3 rd = normalize(vec3(uv, 1.));\n   \n   float d = Raymarch(ro, rd);\n   vec3 color = vec3(0.2,0.7,1.0);\n   vec3 lightPos = vec3(0 ,5, -5);\n   lightPos.xz *= rot(iTime / 1.5);\n   if(d<40.0)\n   {\n       vec3 p = ro + rd*d;\n       vec3 n = GetNormal(p);       \n       vec3 lightDir = normalize(lightPos - p);\n       float diffuse = dot(n, lightDir);\n       //diffuse = diffuse*0.5 + 0.5;\n       //col+= diffuse * color;\n       col+= diffuse;\n   }\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}