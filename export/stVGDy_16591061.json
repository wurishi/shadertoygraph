{"ver":"0.1","info":{"id":"stVGDy","date":"1638290970","viewed":258,"name":"Forgotten Pile of Floppy Regrets","username":"UnstableLobster","description":"Had this one lying around for a while.\nFelt like polishing it a bit and publishing.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Change resMult on the common tab to set the underlying resolution of the\n    simulation while keeping rendering definition.\n    \n    The rendering side is painfully slow, could probably be accelerated\n    reusing a buffer as a particle distance field tracker.\n*/\n\n#define SHADOWS\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n\tSET_GLOBALS\n\n    O = vec4(1.0);\n    \n    float d = 100.0;\n    float sd = 100.0;\n    particle P;\n    \n    vec2 ppos = (pos)*resMult;\n    \n    //rendering\n    int I = int(ceil(particle_size*0.5))+2; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = ppos + vec2(i,j);\n        tpos = floor(tpos);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n\n        if (P0.M == 0.0) continue;\n\n        float nd = distance(ppos, P0.NX) - P0.R - 0.5;    \n        if (nd < d)\n            P = P0;\n\n        d = min(d, nd);\n\n    }  \n    \n    //shadows\n#ifdef SHADOWS\n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 sp = -vec2(3.0, 2.0);\n        vec2 tpos = ppos + vec2(i,j) + sp;\n        tpos = floor(tpos);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n\n        if (P0.M == 0.0 || d <= 0.0) continue;\n         \n        float nsd = distance(ppos + sp, P0.NX) - P0.R-0.5;    \n        sd = min(sd, nsd);\n    } \n#endif\n\n    O.xyz = vec3(0.0);\n    \n    //inner color\n    if (d < 0.0)\n    {\n        float pid = float(P.pID) / float(P.D.x * P.D.y);\n        pid = sin(pid*PI + tTime + deRand(vec2(0.0), P.ID).y*5651.254 )*0.5+0.5;\n        \n        //velocity color\n        vec2 V = (P.NX - P.X)*1.0/dt;    \n        V = V*rot(deRand(vec2(0.0), P.ID).z*19841.3584);\n        vec3 c = vec3(V/2.5*0.5+0.5, deRand(vec2(404.0), P.ID).x);\n        c = mix(vec3(0.0), c, pow( saturate(length(V)/2.5), 0.5) );\n\n        float t = saturate(-d);\n        \n        float g = abs( sin(1.0-d) );\n        vec3 pc = vec3(g);\n        pc = mix(pc, c, 1.0-saturate(g));\n        pc *= 0.3 + deRand(vec2(0.0), P.ID).y * 0.7;\n        \n        float ring = floor(-d/PI);\n        if (int(ring) == 1)\n            pc = mix(pc, vec3(0.0), 1.0-saturate(g));\n     \n        O.xyz = mix(vec3(0.0), pc, t);\n    }\n    //shadow\n    if (sd < 0.0)\n        O.xyz = vec3(0.1) * (0.3 + deRand(vec2(0.0), P.ID).y * 0.7);\n    \n    if (pos.x < 3.0\n    ||  pos.x > R.x - 3.0\n    ||  pos.y < 3.0\n    ||  pos.y > R.y - 3.0)\n    O.xyz = vec3(0.5);  \n    \n    O.xyz = 1.0 - O.xyz; \n    //O = pow(O, vec4(0.9));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define A(p) texel(ch0, p)\n#define B(p) texel(ch1, p)\n#define C(p) texel(ch2, p)\n#define D(p) texel(ch3, p)\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define snormalize(x) ((length(x) > 0.0) ? normalize(x) : x)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*2.0))\n#define dot2(x) dot(x,x)\n\n#define sinT(x) (sin((x-0.5)*PI)*0.5+0.5)\n\n#define dt 1.0\n\n\n\n\n\n//0-1\n#define resMult 1.0\n\n//---------//\n// Globals //\n//---------//\n#define SET_GLOBALS R = iResolution.xy; time = iTime; Mouse = iMouse; deltaTime = iTimeDelta; tTime = float(iFrame)*(1.0/60.0);\nvec2 R;\nvec4 Mouse;\nfloat time;\nfloat deltaTime;\nfloat tTime;\n\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    return -sdBox(p - R*0.5*resMult, R*vec2(0.5, 0.5)*resMult) - 5.0; \n}\n\n#define hh 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n\n    uint X = packHalf2x16(x);\n    return uintBitsToFloat(X); \n}\n\n\n\n//-------------\n// RNG https://www.shadertoy.com/view/wltcRS\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nvec4 deRand(vec2 p, int frame)\n{\n    uvec4 t = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    pcg4d(t);\n    return vec4(t)/float(0xffffffffu);\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n\n\n//-------------\n// Particles\n//-------------\n\n//max particles per side, particles per cube\n#define maxPPS 6\n#define maxPPC maxPPS*maxPPS\n\n//max particle diameter in pixels\n#define particle_size 10.0\n#define relax_value 1.05 / 3.0\n\nstruct particle\n{\n    vec2 X;\n    vec2 NX;\n    float M;\n    int ID; //blockID\n    int pID;//particleID\n    //\n    float R;\n    ivec2 D;\n};\n\nvoid setParticleData(inout particle P)\n{\n    vec4 t = deRand(vec2(0.0), P.ID);\n    \n    P.D = ivec2( floor(mix(vec2(2.0), vec2(float(maxPPS)+0.9), saturate(t.xy))) );\n    P.R = round( mix(particle_size * 0.5 * 0.5 + 0.01, particle_size * 0.5, saturate(t.z)) );\n}\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    \n    P.X = decode(data.x) + pos;\n    P.NX = decode(data.y) + pos;\n    \n    vec2 MI = decode(data.z);\n    P.M = MI.x;\n    P.ID = int(MI.y);\n    P.pID = int(data.w);\n    \n    setParticleData(P);\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    P.NX = P.NX - pos;\n    return vec4(encode(P.X), encode(P.NX), encode(vec2(P.M, float(P.ID))), float(P.pID));\n}\n\n\n\n//-------------\n// Sim\n//-------------\nvec2 calcFriction(particle P, particle P0)\n{\n    vec2 F = vec2(0.0);\n    \n    vec2 dx = P0.NX - P.NX;\n    float d = length(dx);\n    float r = P.R + P0.R;\n    float m = P0.M/(P.M+P0.M);\n        \n    //friction\n    vec2 n = normalize(dx);\n    vec2 p = vec2(n.y, -n.x);\n    vec2 v = P.NX - P.X;\n    vec2 v0 = P0.NX - P0.X;\n    vec2 vv = v - v0;\n     \n    vec2 tang = p * dot(p, vv);\n     \n                  \n    float staticFriction = 1.0;\n    float kineticFriction  = 1.0;\n        \n    //hmmm\n    if (length(tang) < staticFriction * (r - d))\n        F += m * tang;\n    else\n    {\n        float upper = kineticFriction * (r - d);\n        F += m * tang * min(upper/length(tang), 1.0);\n    }\n    \n    if (d > r) return vec2(0.0);\n    return F;\n}\n\nvoid Forces(sampler2D ch, inout particle P, vec2 pos)\n{\n    vec2 F = vec2(0.0);\n    \n    //int I = int(ceil(particle_size))+4; \n    int I = int(ceil(length(vec2(particle_size)))); \n    range(i, -I, I) range(j, -I, I)\n    {\n        if (i == 0 && j == 0) continue;\n        \n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0) continue;\n        \n        vec2 dx = P0.NX - P.NX;\n        float d = length(dx);\n        float r = P.R + P0.R;\n        float m = P0.M/(P.M+P0.M);\n        \n        //jellyness\n        float k = 0.75;\n        float s = 1.0 - pow(1.0 - k, 1.0/3.0);     \n        //m *= s;\n    \n        //global collision\n        F -= normalize(dx) * max(r - d, 0.0) * m;\n            \n            \n        //not the same cube    \n        if (P.ID != P0.ID)\n        {\n            F -= calcFriction(P, P0);\n            continue;\n        }\n            \n        //squares\n        int PY = P.pID / P.D.x; //hmm\n        PY = int(floor(float(P.pID) / float(P.D)));\n        int P0Y = int(floor(float(P0.pID) / float(P0.D)));\n        \n        //left right\n        if (abs(abs(P.pID - P0.pID)-1) == 0 && PY == P0Y && P.D.x > 1)\n            F -= normalize(dx) * (r - d) * m;\n            \n        //up down\n        else if (abs(abs(P.pID - P0.pID)-P.D.x) == 0)\n            F -= normalize(dx) * (r - d) * m;\n            \n        //diagonals\n        else if (abs(abs(P.pID - P0.pID)-(P.D.x-1)) == 0 && PY != P0Y)\n            F -= normalize(dx) * (r - d/sqrt(2.0)) * m; \n        else if (abs(abs(P.pID - P0.pID)-(P.D.x+1)) == 0 && PY != P0Y && abs(PY - P0Y) <= 1)\n            F -= normalize(dx) * (r - d/sqrt(2.0)) * m;     \n    }\n\n    //border\n    vec2 dp = P.NX;\n    vec2 n = bN(dp).xy;\n    float d = border(dp)-P.R;\n    if (d < 0.0)\n        F -= n*d;\n        \n    //border friction\n    float fA = 100.05;\n    if (d <= 0.0)\n    {\n        vec2 v = P.NX - P.X;\n        vec2 p = vec2(n.y, -n.x);\n        vec2 tang = p * dot(p, v);\n        //tang = (P.NX - P.X);\n        \n        //fA *= (1.0 + d);\n        //F -= tang*min(fA,length(tang)); //*d;\n        F -= tang;\n    }\n      \n    P.NX += F * relax_value;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid Integrate(sampler2D ch, inout particle P, vec2 pos)\n{\n    int I = 3; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        \n        if (tpos.x < 0.0 || tpos.y < 0.0) continue;\n       \n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0) continue;\n\n        //falls in this pixel\n        if (P0.NX.x >= pos.x-0.5\n        &&  P0.NX.x < pos.x+0.5\n        &&  P0.NX.y >= pos.y-0.5\n        &&  P0.NX.y < pos.y+0.5)\n        {\n            vec2 P0V = (P0.NX - P0.X)/dt;\n        \n            //external forces\n            if(iMouse.z > 0.0)\n            {\n                vec2 dm = P0.NX - iMouse.xy*resMult;\n                float d = length(dm/30.0);\n                P0V += normalize(dm) * exp(-d*d)*0.5;\n                \n                //vec2 dx = (Mouse.xy - P0.NX); \n                //P0V += 0.005*exp(-0.05*length(dx))*dx; \n            }\n\n            P0V += vec2(0., -0.0075);\n\n            float mv = 2.5;\n            if (length(P0V) > mv) P0V = mv * normalize(P0V);\n\n            //\n            P0.X = P0.NX;     \n            P0.NX = P0.NX + P0V*dt;\n            P = P0;\n            break;\n        }\n    }\n}\n\n\n\nparticle spawnCube(inout particle P, vec2 start, float ps, ivec2 size, vec2 pos)\n{\n    P.M = 0.0;\n    \n    if (pos.x >= start.x && pos.x < start.x + ps*float(size.x)\n    &&  pos.y >= start.y && pos.y < start.y + ps*float(size.y)\n    &&  mod(pos.x, ps) < 1.0 && mod(pos.y, ps) < 1.0)\n    {\n        P.X = pos;\n        P.NX = pos + (rand2()-0.5)*0.35;\n        P.M = P.R;\n        P.pID = int(round(floor((pos.x-start.x)/ps)) + round(floor((pos.y-start.y)/ps))*float(size.x));\n    }\n    return P;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    if (pos.x > R.x*resMult || pos.y > R.y*resMult) return;\n\n    rng_initialize(pos, iFrame);\n\n    particle P;  \n     Integrate(ch0, P, pos);\n   \n    //init\n    if (iFrame == 0)\n    {     \n        R *= resMult;\n        \n        vec2 maxSize = floor(floor(R)/(particle_size*float(maxPPS)) );\n        vec2 tAmnt = floor(R/maxSize);\n        vec2 ID = floor(pos / tAmnt);\n        float tID = ID.x + ID.y*maxSize.x;     \n        vec2 vid = ID*tAmnt;\n        \n        P.ID = maxPPC*int(tID);\n        setParticleData(P);\n        vec2 pShift = floor( (deRand(vec2(0.0), P.ID).xy-0.5)*float(maxPPS)*0.5 );\n        spawnCube(P, floor(vid) + ( tAmnt - vec2(P.D)*P.R*2.0)*0.5 + pShift, P.R*2.0, ivec2(P.D), pos);\n    }\n    \n    O = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    if (pos.x > R.x*resMult || pos.y > R.y*resMult) return;\n    \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Forces(ch0, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    if (pos.x > R.x*resMult || pos.y > R.y*resMult) return;\n    \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Forces(ch0, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    if (pos.x > R.x*resMult || pos.y > R.y*resMult) return;\n    \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Forces(ch0, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer D","description":"","type":"buffer"}]}