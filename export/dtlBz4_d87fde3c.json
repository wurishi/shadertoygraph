{"ver":"0.1","info":{"id":"dtlBz4","date":"1692748663","viewed":33,"name":"Walk On Boundary WIP","username":"chronos","description":"Computing winding numbers using the Walk-on-Boundary algorithm from the paper:\nhttps://rsugimoto.net/WoBforBVPsProject/\n\nSee newer version: https://www.shadertoy.com/view/DllBWM","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["numbers","on","walk","boundary","winding","windingnumber","wob","walkonboundary"],"hasliked":0,"parentid":"dtSyzV","parentname":"Walk on Spheres WNF Convergence"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Newest verison as of 26.08.23:\n// https://www.shadertoy.com/view/DllBWM\n// in that one i found the correct weighting factor. In this one it is approximated by guessing\n\n#define USE_sRGB 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec4 bufA = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    int segment_count = get_segment_count(iFrame);\n\n    // comment/uncomment to compare in different ways.\n    //if(iMouse.z < .5) // press to flip between\n    //if(uv.x > mouse.x) // slide with mouse\n    if(uv.x > 0.) // split vertically down middle\n    {\n        // Note that we have to divide by the alpha channel here, to average the results.\n        // This can lose precisions after a while, so a better method of accumulation\n        // that is more numerically stable for large accumulation times could be used instead.\n        float walk_on_spheres_result = bufA.r / bufA.a;        \n        color = winding_number_to_color(walk_on_spheres_result);\n    }\n    else\n    {\n        float winding_number = 0.;\n\n        for(int i = 0; i < segment_count; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n        \n        color = winding_number_to_color(winding_number);\n        if(abs(uv.x) > .51 || abs(uv.y) > .51)\n            color *= 0.;\n    }\n    \n    // This is just for visualizing error:\n    if(false)\n    {\n        float walk_on_spheres_result = bufA.r / bufA.a;\n        float winding_number = 0.;\n\n        for(int i = 0; i < num_segments; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n                \n        color = vec3(winding_number >= .9999 ? 1. : 0.);\n        \n        color = vec3(walk_on_spheres_result >= .9999 ? 1. : 0.);\n        \n        color = clamp(vec3(\n                    walk_on_spheres_result - winding_number,\n                    0.,\n                    winding_number - walk_on_spheres_result\n                ), 0., 1.);\n    }\n   \n    for(int i = 0; i < num_segments; i++)\n    {\n        float normal_alpha = .5*draw_interior_normal(segments[i], uv);\n        vec3 normal_color = vec3(1);\n        color = mix(color, normal_color, normal_alpha);\n    }\n\n#if USE_sRGB\n    fragColor = vec4(linearToSRGB(color), 1.0);\n#else\n    fragColor = vec4(color, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Walk on boundary algorithm\n// Accumulate average over time\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    fragColor = vec4(0);\n\n    if(iFrame < 1 || restart_signal(iFrame)) return;\n\n    int segment_count = get_segment_count(iFrame);\n\n    vec4 buffer = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    const int num_iterations = 4; // N\n    \n    for(int it = 0; it < num_iterations; it++)\n    {\n        vec3 acc_color = vec3(0);\n        \n        // !!!!!!!!!!!!!!!!!!!\n        // Setting this to 0.5 gives a closer result than either 0. or 1.\n        // I don't know why this worked the best yet. I'd think there'd be energy loss instead of gain...\n        // Perhaps something is wrong in the russian roulette version of the estimator.\n        float acc_weight = 0.5;     \n        \n        {\n            // Recursive Estimate\n            float iteration_sign = 1.;\n            \n            vec2 ray_pos = uv;\n            vec2 ray_dir = random_point_on_sphere(1., hash(vec3(fragCoord.xy, 10.*(float(it*128) -1.) + iTime)));\n            int prev_seg_idx = -1;\n            \n            float throughput = 1.;\n            \n            for(float i = 0.; i < 2560.; i++)\n            {\n                // ray intersection sampling\n                vec2 intersection_point;\n                segment seg;\n                bool bFoundIntersection = false;\n                \n                for(int seg_idx = 0; seg_idx < segment_count; seg_idx++)\n                {\n                    // Do not intersect the segment we hit last time, just continue with the others.\n                    // Seems like this method causes some trouble. Not sure...\n                    if(seg_idx == prev_seg_idx) continue;\n                    \n                    seg = segments[seg_idx];\n                    \n                    // Find ray / segment intersection, if it exists\n                    vec2 alpha_t = get_intersection_params(ray_pos, ray_dir, seg);\n                    float alpha = alpha_t.x;\n                    float t = alpha_t.y;\n                    if(t >= 0. && alpha >= 0. && alpha <= 1. )\n                    {\n                        bFoundIntersection = true;\n                        prev_seg_idx = seg_idx;\n                        intersection_point = mix(seg.from, seg.to, alpha);\n                        break;\n                    }\n                }\n\n                // This should never happen on the interior. But it does.\n                // Not sure why. Could be numerical imprecision that I do not handle correctly,\n                // Or it may just be a bug, maybe some cornercase.\n                \n                if(!bFoundIntersection)\n                {\n                    acc_color *= 0.;\n                    acc_weight *= 0.;\n                \n                    if(abs(uv.x) > .51 || abs(uv.y) > .51)\n                        acc_color = vec3((1./0.)/(1./0.)); // Poison the well with NaNs\n                    \n                    break; // Just break and try again next iteration.\n                }\n                \n                // Set up russian roulette\n                float russian_roulette_spin = hash(vec3(fragCoord + iResolution.xy, iFrame * num_iterations + it));\n                float russian_roulette_probability = get_russian_roulette_probability(i);\n                bool should_terminate = russian_roulette_spin < russian_roulette_probability;\n                float russian_roulette_weight = get_russian_roulette_weight(russian_roulette_probability);\n                \n                // Boundary value, notated u_D in the paper\n                // Using the side of the ray position, since the function is zero exactly on the boundary.\n                // It should therefore be determined by the side we approach from, which is always the side of the \n                // origin of the ray.\n                vec3 U_D = sign( vec3(segment_side(ray_pos, seg)) ) / 2.;\n                \n                // This is the termination condition in the paper, but they mention it has bias,\n                // Since it just truncates the path, just like in MC light transport / rendering.\n                // They do not show how to do russian roulette there, so I'm trying to roll my own here.\n                // Be warned, it is probably wrong!\n                \n                //should_terminate = i >= path_length - 1.;\n                \n                \n                if(should_terminate)\n                {\n                    // The last sample does not have the factor 2. See paper.\n                    acc_color += iteration_sign * U_D * throughput;\n                    \n                    acc_weight += 1.; // Idk, seems to work. Just used to average everything. See declaration!\n                    break;\n                }\n                else\n                {\n                    acc_color += iteration_sign * 2. * U_D * throughput;\n                    \n                    throughput *= 1./russian_roulette_weight;\n                    \n                    // Flip iteration sign for the rest of the unrolled recursion\n                    iteration_sign *= -1.;\n                }\n                ray_pos = intersection_point;\n                \n                ray_dir = random_point_on_sphere(1., hash(vec3(fragCoord.xy, 10.*(float(it*128) + i) + iTime)));\n                if(sign(dot(get_normal(seg, vec2(0)), ray_dir)) < 0.)\n                {\n                   ray_dir *= -1.;\n                }\n            }\n            \n        }\n        buffer += vec4(acc_color, acc_weight);\n    }\n    \n    fragColor = buffer;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float eps = 0.001;\n\nconst float GAMMA = 2.4;\nfloat linearToSRGB(float channel)\n{\n    const float a = 12.92;\n    const float b = 1.055;\n    const float c = 0.055;\n    const float threshold = 0.0031308;\n    \n    return channel <= threshold ? a * channel : (b * pow(channel, 1./GAMMA) - c);\n}\nvec3 linearToSRGB(vec3 color)\n{\n    color = clamp(color, 0., 1.);\n    return vec3(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b));\n}\n\nint get_segment_count(int frame);\nvec2 random_point_on_sphere(float radius, float rnd_01)\n{\n    float random_angle = 2. * PI * rnd_01;\n    return radius * vec2(cos(random_angle), sin(random_angle));\n}\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n\n// Line segment\nstruct segment\n{\n    vec2 from, to;\n};\n\nstruct intersect_result\n{\n    bool bIntersects;\n    float intersection_direction; // positive, negative or zero\n    vec2 position;\n};\n\n// exterior product\nfloat wedge(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat segment_side(vec2 p, segment s)\n{\n    vec2 a = p - s.from;\n    vec2 b = p - s.to;\n    return wedge(a, b);\n}\n\nvec2 segment_normal(segment s)\n{\n    return normalize(s.to - s.from).yx * vec2(-1,1);\n}\n\nvec2 get_normal(segment s, vec2 ray_pos)\n{\n    vec2 N = segment_normal(s);\n    N *= sign(dot(N, ray_pos - s.from));\n    return N;\n}\n\nfloat scalar_project_to_vector(vec2 point, vec2 v)\n{\n    return dot(point, v) / dot(v,v);\n}\n\nfloat scalar_project_to_line(vec2 from, vec2 to, vec2 point)\n{\n    vec2 dir = to - from;\n    return scalar_project_to_vector(point-from, dir);\n}\n\nvec2 project_point_to_segment(vec2 point, segment s)\n{\n    float t = scalar_project_to_line(s.from, s.to, point);\n    t = clamp(t, 0., 1.);\n    \n    return s.from + t * (s.to - s.from);\n}\n\n// ray_segment intersection\nbool intersects(vec2 ray_pos, vec2 ray_dir, segment seg)\n{\n    // return whether segment endpoint are on different sides of ray\n    segment ray_seg;\n    ray_seg.from = ray_pos;\n    ray_seg.to = ray_pos + ray_dir;\n    return sign(segment_side(seg.from, ray_seg)) != sign(segment_side(seg.to, ray_seg));\n}\n\n// Assuming there is an intersection, finds the intersection point (line / line)\nfloat get_intersection_t(vec2 ray_pos, vec2 ray_dir, segment seg)\n{\n    vec2 N = get_normal(seg, vec2(0));\n\n    float total_length = scalar_project_to_vector(ray_pos - seg.from, N);\n\n    float step_size = -dot(ray_dir, N);\n\n    // solve step_size * steps = total_length\n    float steps = total_length / step_size;\n\n    return steps;\n}\n\nvec2 get_intersection_params(vec2 ray_pos, vec2 ray_dir, segment seg)\n{\n    vec2 d1 = seg.to - seg.from;\n    vec2 d2 = ray_dir;\n    \n    // return (alpha, t)\n    return inverse(mat2(-d1, d2)) * (seg.from - ray_pos);\n}\n\nvec2 get_intersection_point(vec2 ray_pos, vec2 ray_dir, segment seg)\n{\n    vec2 N = get_normal(seg, vec2(0));\n\n    float total_length = scalar_project_to_vector(ray_pos - seg.from, N);\n\n    float step_size = -dot(ray_dir, N);\n\n    // solve step_size * steps = total_length\n    float steps = total_length / step_size;\n\n    return steps * ray_dir + ray_pos;\n}\n\nfloat distance_to_segment(vec2 point, segment s)\n{\n    return distance(project_point_to_segment(point, s), point);\n}\n\nfloat winding_number_segment(vec2 p, segment s)\n{\n    vec2 a = normalize(s.from-p);\n    vec2 b = normalize(s.to-p);\n    float d = dot(a,b);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat2(a,b))) * angle / (2. * PI);\n}\n\nvec3 winding_number_to_color(float winding_number)\n{\n    //return mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+tanh(1.*winding_number))); // smooth, nonlinear, asymptotically towards 0 and 1\n    vec3 color = mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+winding_number));\n    \n    // Isosurface at w = 1/2\n    //color += smoothstep(.5-0.02, .5+0.0, winding_number) * smoothstep(.5 + 0.02, .5 + 0.0, winding_number);\n    return color;\n}\n\nconst int num_segments = 4;\nsegment segments[num_segments] = segment[num_segments]\n(\n    segment(vec2(-.51, -.51), vec2(  .51, -.51)), // bottom left to bottom right\n    segment(vec2(-.51,  -.51), vec2( -.51, .51)), // top left to bottom left\n    segment(vec2( .51, .51), vec2(  .51,  -.51)), // bottom right to top right\n    segment(vec2( .51,  .51), vec2( -.51,  .51))  // top right to top left\n    \n);\n\nvec4 border(vec2 p, int seg_idx)\n{        \n    float dist = distance_to_segment(p, segments[seg_idx]);\n\n    // The winding number function very near a line segment is -1/2 turns on one side, and 1/2 turns on the other\n    // that is, corresponding to -180 degrees and +180 degrees respectively.\n    vec3 col = sign( vec3(segment_side(p, segments[seg_idx])) ) / 2.;\n    \n    return vec4(col, dist);\n}\n\nconst int frames_per_scene = 1200;\n\nbool restart_signal(int frame)\n{\n    return false;//frame % frames_per_scene == 0;\n}\n\nint get_segment_count(int frame)\n{\n    return 4;//1 + ((frame / frames_per_scene) % 4); // [1, 4] inclusive\n}\n\nfloat draw_normal(segment s, vec2 uv)\n{\n    vec2 midpoint = 0.5 * (s.from + s.to);\n    segment N;\n    N.from = midpoint;\n    N.to = midpoint + segment_normal(s)* 0.1;\n    return float(distance_to_segment(uv, N) < 0.01);\n}\n\nfloat draw_interior_normal(segment s, vec2 uv)\n{\n    vec2 midpoint = 0.5 * (s.from + s.to);\n    segment N;\n    N.from = midpoint;\n    N.to = midpoint + get_normal(s, vec2(0))* 0.1;\n    \n    return float(distance_to_segment(uv, N) < 0.01);\n}\n\n// From earlier attempt. this is for when each iteration is a single walk on spheres on *all* segments at once.\n// It would be much better if this could be used, similar to how it would be done for SDF ray marching\n/*\nvec4 border(vec2 p)\n{        \n    vec3 col = vec3(0);\n    float dist = 9e9;\n\n    for(int i = 0; i < num_segments; i++)\n    {        \n        float d = distance_to_segment(p, segments[seg_idx]);\n        \n        if(d < dist)\n        {\n            dist = d;\n            \n            float seg_side = segment_side(p, segments[i]);\n            \n            col = sign( vec3(seg_side) ) / 2.;\n        }\n    }\n    \n    return vec4(col, dist);\n}\n*/\n\n\n\n// Russian roulette\n\nfloat get_russian_roulette_probability(float i)\n{\n    float iteration_penalty = i;\n\n    // Increase to make it more likely to take more iterations\n    // Decrease to make it more likely to terminate early\n    const float survival_constant = 2.5;\n\n    float russian_roulette_probability = iteration_penalty / (survival_constant + iteration_penalty);\n    return russian_roulette_probability;\n}\n\nfloat get_russian_roulette_weight(float russian_roulette_probability)\n{\n    return 1. / (1.-russian_roulette_probability);\n}","name":"Common","description":"","type":"common"}]}