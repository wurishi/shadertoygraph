{"ver":"0.1","info":{"id":"WdGSDR","date":"1574435648","viewed":171,"name":"flower_sdf_breakdown","username":"skaplun","description":"This is quite messy breakdown version. For cleaner, more effective version - checkout the original shader https://www.shadertoy.com/view/tsKSz1\nGlass cube made by @Crow","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define THICKNESS .001\n#define ZERO (min(iFrame,0))\nconst vec3 lightPos = vec3(0., 5., 0.);\nBreakdownAnimationState bas;\n\nfloat sdVesica(vec2 p, float r, float d){\n    p = abs(p);\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ){\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y), 0.0) + length(max(w, 0.));\n}\n\nvec4 opMin(vec4 a, vec4 b){\n\tif(a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\nvec4 flower(vec3 orPos, out float alpha){\n    alpha = 1.;\n    if(bas.id <= A_PHASE_SHRINK || bas.id >= A_PHASE_PETAL_EXPAND_ALL){\n        vec3 mp = orPos;\n        float size = 1.;\n\t\tfloat id;\n        \n        {\n            float delta = PI/5.;\n            float l = length(mp.xz);\n            float a = atan(mp.x, mp.z);\n            float vertAng = mod(a, delta) - delta/2.;\n            vec3 mp = vec3(l * sin(vertAng), mp.y, l * cos(vertAng));\n        \n        \tl = length(mp);\n            const float VERT_PETALS_COUNT = 30.;\n            const float petalAngleRange = PI/VERT_PETALS_COUNT;\n            a = atan(mp.y, mp.z);\n            size = pow(smoothstep(PI*1.4, 0., a), .1) * pow(smoothstep(PI*1.4, .25, a), 1.5);\n            a = atan(mp.y -cos(l * (5.5 + .5 * fbm1x(a * .137, iTime))) * .1, mp.z);\n            id = floor(a/petalAngleRange);\n        }\n\n        mp = orPos;\n        float rotAng = 0.;\n        if(bas.id <= A_PHASE_SHRINK || bas.id > A_PHASE_PETAL_ADD_OFFSET)\n            rotAng = PI * .31 * hash11(id * .471);\n        else if(bas.id >= A_PHASE_PETAL_ADD_OFFSET)\n        \trotAng = PI * .31 * hash11(id * .471) * bas.phase;\n        float hid = 0.;\n        {\n            float delta = PI/5.;\n            float l = length(mp.xz);\n            float a = atan(mp.x, mp.z) + rotAng;\n            float vertAng = mod(a, delta) - delta/2.;\n            if(bas.id == A_PHASE_PETAL_EXPAND_ALL){\n            \tfloat na = atan(mp.x, -mp.z) + rotAng;\n                na = 1. - (na + PI)/(PI*2.);\n                vertAng = mix(a, mod(a, delta) - delta/2., step(distance(na, bas.phase), bas.phase));\n            }\n            hid = floor(a/delta);\n            float f = fbm1x(hid, iTime) * .025;\n            mp = vec3(l * sin(vertAng + f), mp.y, l * cos(vertAng + f));\n        }\n\t\t\n        float l = length(mp);\n        const float VERT_PETALS_COUNT = 30.;\n        const float petalAngleRange = PI/VERT_PETALS_COUNT;\n        float a = atan(mp.y, mp.z);\n        size = pow(smoothstep(PI*1.4, 0., a), .1) * pow(smoothstep(PI*1.4, .25, a), 1.5);\n        a = atan(mp.y -cos(l * (5.5 + .5 * fbm1x(a * .137, iTime))) * .1, mp.z);\n        float ma = mix(a - .1, mod(a, petalAngleRange) - petalAngleRange/2., step(distance(a, PI/4.), PI/4.));\n        mp = vec3(mp.x, l * sin(ma), l * cos(ma));\n\t\t\n        vec4 leaf = vec4(MAX_FLOAT);\n        vec2 vesicaCoords = mp.xz - vec2(0., .7 * pow(size, 4.));\n        float v = sdVesica(vesicaCoords, size, .7 + pow(1.-size, .5) * .3);\n        leaf = opMin(leaf, vec4(opExtrussion(mp, v, .0001), vesicaCoords, v));\n        \n        return leaf;\n    }\n    \n    vec3 mp = orPos;\n    float size = 1.;\n    float id = 0.,\n          l = 0.,\n          a = 0.,\n          petalAngleRange = 0.;\n    \n    if(bas.id >= A_PHASE_PETAL_MOD_VT_GROW){\n    \tfloat l = length(mp);\n        const float VERT_PETALS_COUNT = 30.;\n        petalAngleRange = PI/VERT_PETALS_COUNT;\n        a = atan(mp.y, mp.z);\n        if(bas.id == A_PHASE_PETAL_CHANGE_SIZE)\n        \tsize = mix(size, pow(smoothstep(PI*1.4, 0., a), .1) * pow(smoothstep(PI*1.4, .25, a), 1.5), pow(bas.phase, .5));\n        if(bas.id > A_PHASE_PETAL_CHANGE_SIZE)\n        \tsize = pow(smoothstep(PI*1.4, 0., a), .1) * pow(smoothstep(PI*1.4, .25, a), 1.5);\n        if(bas.id == A_PHASE_PETAL_CHANGE_SHAPE)\n        \ta = atan(mp.y -cos(l * (5.5 + .5 * fbm1x(a * .137, iTime))) * .1 * pow(bas.phase, .5), mp.z);\n        if(bas.id > A_PHASE_PETAL_CHANGE_SHAPE)\n        \ta = atan(mp.y -cos(l * (5.5 + .5 * fbm1x(a * .137, iTime))) * .1, mp.z);\n        id = floor(a/petalAngleRange);\n        l = length(mp.yz);\n        float localPhase = PI/4.;\n        if(bas.id == A_PHASE_PETAL_MOD_VT_GROW)\n            localPhase *= bas.phase;\n        float ma = mix(a - .1, mod(a, petalAngleRange) - petalAngleRange/2., step(distance(a, localPhase), localPhase));\n        mp = vec3(mp.x, l * sin(ma), l * cos(ma));\n    }\n\t\n    if(bas.id == A_PHASE_SHRINK)\n        size = (1. - bas.phase);\n    else if(bas.id == A_PHASE_PETAL_GROW)\n        size *= pow(bas.phase, .1);\n    \n    vec4 leaf = vec4(MAX_FLOAT);\n    if(bas.id == A_PHASE_PETAL_MOD_HR_GROW ||\n       bas.id == A_PHASE_PETAL_MOD_HR_SHRINK){\n    \tfor(float i=float(ZERO); i<10.; i++){\n            float a = PI/5. * i;\n            float iphase = floor(bas.phase * 10.);\n            float fphase = mod(bas.phase, .1) * 10.;\n            \n            if(bas.id == A_PHASE_PETAL_MOD_HR_GROW){\n                if(i > iphase)\n                    break;\n                if(i != 0. && i == iphase)\n                    a -= PI/5. * (1. - fphase);\n            }else{\n            \tif(i != 0. && i < iphase)\n            \t\tcontinue;\n                if(i != 0. && i == iphase)\n                    a += PI/5. * fphase;\n            }\n            \n            vec3 rp = mp;\n            rp.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            a = radians(2.);\n            rp.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            vec2 vesicaCoords = rp.xz - vec2(0., .7 * pow(size, 4.));\n            float v = sdVesica(vesicaCoords, size, .7 + pow(1.-size, .5) * .3);\n            leaf = opMin(leaf, vec4(opExtrussion(rp, v, .0001), vesicaCoords, v));\n    \t}\n    }else{\n    \tvec2 vesicaCoords = mp.xz - vec2(0., .7 * pow(size, 4.));\n        float v = sdVesica(vesicaCoords, size, .7 + pow(1.-size, .5) * .3);\n        leaf = opMin(leaf, vec4(opExtrussion(mp, v, .0001), vesicaCoords, v));\n    } \n\tfloat centralSphere = length(orPos - vec3(0., .1, 0.)) - .15;\n    return opMin(leaf, vec4(centralSphere, vec2(0.), 1.));\n}\n\n#define EPSILON .0001\nvec3 estimateFlowerNormal(vec3 p) {\n    float noUse;\n    return normalize(vec3(\n        flower(vec3(p.x + EPSILON, p.y, p.z), noUse).x - flower(vec3(p.x - EPSILON, p.y, p.z), noUse).x,\n        flower(vec3(p.x, p.y + EPSILON, p.z), noUse).x - flower(vec3(p.x, p.y - EPSILON, p.z), noUse).x,\n        flower(vec3(p.x, p.y, p.z  + EPSILON), noUse).x - flower(vec3(p.x, p.y, p.z - EPSILON), noUse).x\n    ));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float noUse;\n\tfloat occ = 0., sca = 1.;\n    for(int i=ZERO; i<5; i++){\n        float hr = .01 + 0.05 * float(i)/1.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = flower(aopos, noUse).x;\n        occ += -(dd - hr) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 3. * occ, 0., 1.) * (.5 + .5 * nor.y);\n}\n\nconst float maxHei = 1.;\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax){\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    float noUse;\n    for( int i=ZERO; i<16; i++){\n\t\tfloat h = flower(ro + rd * t, noUse).x;\n        float s = clamp(h/t, 0., 1.);\n        res = min( res, s*s*(3.0-2.0*s));\n        t += clamp(h, .005, .025);\n        if(res<.01 || t>tmax) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\n#define aa (100./iResolution.y)\nvec4 flowerColor(vec3 pos, vec4 dist, vec3 worldDir){\n\tvec3 nor = estimateFlowerNormal(pos);\n    if(bas.id > A_PHASE_OCC_2_NRM)\n        return vec4(nor, 1.);\n    vec3 ref = reflect(worldDir, nor);\n        \n    float n = fbm(dist.yz * 2.5) + abs(dist.w) * 6.;\n    float mv = pow(abs(dist.w), .5);\n    mv = smoothstep(mv, mv + aa, n);\n\n    //vec3 col = mix(vec3(1., 1., 0.), vec3(1., 0., 0.), pow(abs(dist.y), .1));\n    vec3 col = mix(vec3(.1, 0., .05), vec3(.3, .3, 0.), mv);\n        \n    // lighting\n    float occ = max(calcAO(pos, nor), .33);\n    if(bas.id > A_PHASE_INIT)\n    \treturn vec4(mix(vec3(occ), nor, pow(bas.phase, 8.)), 1.);\n    vec3  lig = normalize(lightPos - pos);\n    vec3  hal = normalize(lig-worldDir );\n    float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, worldDir),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow(pos, lig, .15, .5);\n    dom *= calcSoftshadow(pos, ref, .15, .5);\n\n    float spe = pow(clamp(dot(nor, hal), 0., 1.), 16.) *\n        dif * (.04 + .96*pow( clamp(1.0+dot(hal,worldDir),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.80*dif*vec3(1.30,1.00,0.70);\n    lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n    lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n    lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 7.00*spe*vec3(1.10,0.90,0.70);\n\n    col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*dist.x*dist.x*dist.x ) );\n\n    return vec4(col, 1.);\t\n}\n\nconst int MAX_MARCHING_STEPS = 128;\nvec4 marchFlower(vec3 eye, vec3 marchingDirection) {\n\tconst float precis = .02;\n    float t = 0., l = 0.;\n    float alpha;\n    vec4 bg = (bas.id == A_PHASE_INIT || bas.id == A_PHASE_END) ? vec4(0.) : vec4(1.);\n    for( int i=ZERO; i<MAX_MARCHING_STEPS; i++ ){\n\t    vec3 pos = eye + marchingDirection * t ;\n        vec4 h = flower(pos, alpha);\n        if( h.x < precis ){\n            vec4 clr = flowerColor(pos, h, marchingDirection);\n            if (bas.id == A_PHASE_PETAL_EXPAND_ALL)\n                clr = mix(bg, clr, max(alpha, bas.phase));\n            return clr;\n        }\n        t += h.x * .2;\n    }\n    return bg;\n}\n\n//---material--------------------------------------------------\nstruct Mat{\n    vec4 basCol; \n    float spe;\n    float refr;\n};\n\nMat GetMat(float matNumber){\n    return Mat(vec4(.5, 0.7, 0.8, .1), 0.9, 1.5);\n}\n\nfloat SdBox( vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return abs(min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)));\n}\n\nvec2 Map(vec3 pos){\n    pos.y -=.2;\n    float  a = radians(45.);\n    pos.yz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    pos.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    float size = 1.5;\n    if(bas.id == A_PHASE_INIT)\n        size = 1.5 + pow(bas.phase, 32.) * 10.;\n    if(bas.id == A_PHASE_END)\n        size = 1.5 + pow(bas.phase, 128.) * 10.;\n    return vec2(SdBox(pos, vec3(size)), 1.);    \n}\n\nvec2 CastRay(vec3 camPos, vec3 rayDir, float nearClip, float farClip){\n    float dis = nearClip;\n    float mat = -1.0;\n    for(int i=ZERO; i<36; i++)\n    {\n\t    vec2 res = Map(camPos + rayDir * dis);\n        if(res.x < 0.01) \n            break;\n        \n        dis += res.x;\n        mat = res.y;\n        if(dis >= farClip)\n        {\n            dis = farClip;\n            mat = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(dis, mat);\n}\n\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(.0001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy).x - Map(pos - eps.xyy).x,\n                    Map(pos + eps.yxy).x - Map(pos - eps.yxy).x,\n                    Map(pos + eps.yyx).x - Map(pos - eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat GetFresnel( float cosi, float cost, float etai, float etat )\n{\n    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);\n    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);\n    return (rs * rs + rp * rp) * 0.5;\n}\n\nvec4 color(vec3 camPos, vec3 rayDir){\n    //vec3 lightDir = normalize(lightPosvec3(-1.3, -1.0, -0.7));\n    vec3 lightCol = vec3(1.0, 1.0, 1.0);     \n    vec3 amb = vec3(0.2);\n    \n    vec3 col = vec3(0.0);\n    float lerp = 1.0;\n    vec3 pos = camPos;\n    vec3 vDir = rayDir;\n    float nearClip = 0.1;\n    float farClip = 15.0;\n    float isInside = 0.0;\n        \n    for(int i = ZERO; i < 5; i++){\n        vec3 stepCol = vec3(0.0);\n        vec2 res = CastRay(pos, vDir, nearClip, farClip);\n        float d = res.x;\n        float m = res.y;\n        if(m > 0.0){\n            Mat mat = GetMat(m);\n            vec3 lastPos = pos;\n            pos += vDir * d;\n            vec3 lightDir = normalize(lightPos - pos);\n            vec3 nor = GetNormal(pos);\n            vec3 ligDir = -lightDir;\n            vec3 viewDir = -vDir;\n            vec3 halfDir = normalize(ligDir + viewDir);\n            float nh = max(dot(nor, halfDir), 0.0);\n            float nl = max(dot(nor, ligDir), 0.0);\n            float nv = max(dot(nor, viewDir), 0.0);\n       \t\tvec3 reflDir = normalize(reflect(vDir, nor));\n            \n            float specular = pow(nh, mat.spe * 128.0);\n            \n            vec3 reflCol = texture(iChannel0, reflDir).rgb;\n            float refr = mix(1.0 / mat.refr, mat.refr, isInside);\n            vec3 refrDir = normalize(refract(vDir, nor, refr));\n            float nr = max(dot(-nor, refrDir), 0.0);\n            float fresnel = 0.;\n            if(isInside > 0.5)\n                fresnel = GetFresnel(nv, nr, refr, 1.0);\n            else\n                fresnel = GetFresnel(nv, nr, 1.0, refr);\n            fresnel = max(fresnel, 0.001);\n                        \n            stepCol = (mat.basCol.rgb + specular) * lightCol * nl \n                + reflCol * fresnel\n                + mat.basCol.rgb * amb;\n            \n            float alpha = mat.basCol.a;\n            \n            if(isInside > .5){\n                vec4 flowerCol = marchFlower(lastPos, vDir);\n                stepCol = mix(stepCol, flowerCol.rgb, flowerCol.a);\n                alpha = mix(alpha, 1.0, step(0.999, flowerCol.a));\n            }\n            col = mix(col, stepCol, lerp);\n            \n            if(alpha < 1.)\n            {                \n                if(1.0 - refr * refr * (1.0 - nv * nv) < 0.0)\n                {\n                    vDir = reflDir;                    \n                }\n                else\n                {                    \n                \tvDir = refrDir;\n                    isInside = mix(1.0, 0.0, step(0.5, isInside));\n                }\n                \n                nearClip = 0.05;\n                farClip = 4.0;                                \n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            stepCol = texture(iChannel0, vDir).rgb;\n            col = mix(col, stepCol, lerp);\n            break;\n        }\n    }\n    \n    return vec4(col, 1.);\n}\n\nRay createCameraRay(in vec2 fragCoord){\n\tvec3 eye;\n    if(bas.id == A_PHASE_INIT){\n    \t//float a = iMouse.x/iResolution.x * 6.28;//sin(iTime * .5) * PI;\n        float a = bas.phase * PI;\n        float dist = 11. - pow(bas.phase, 4.) * 5.;\n        eye = vec3(dist * cos(a), pow(bas.phase, .1) * 2., dist * sin(a));\n    }else if(bas.id < A_PHASE_PETAL_MOD_HR_SHRINK ||\n             bas.id == A_PHASE_PETAL_ADD_OFFSET){\n        eye = vec3(-5., 4., 0.);\n    }else if(bas.id == A_PHASE_PETAL_MOD_HR_SHRINK){\n    \teye = vec3(-5., 4. - 4. * pow(bas.phase, 4.), 0.);\n    }else if(bas.id == A_PHASE_PETAL_EXPAND_ALL){\n    \teye = vec3(-5., 4. * pow(bas.phase, 1.), 0.);\n    }else if(bas.id == A_PHASE_END){\n    \tfloat a = bas.phase * PI;\n        float dist = 6. + pow(bas.phase, 4.) * 5.;\n        eye = vec3(dist * cos(a), 4. - pow(bas.phase, .1) * 2., dist * sin(a));\n        //eye = vec3(-5., 4., 0.);\n    }else{\n    \teye =  vec3(-5., 0., 0.);\n    }\n    \n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., .2, 0.), vec3(0., 1., 0.)) * viewDir;\n    return Ray(eye, worldDir);\n}\n\nvec4 render(in vec2 fragCoord){\n    Ray ray = createCameraRay(fragCoord);\n\treturn (bas.id == A_PHASE_INIT || bas.id == A_PHASE_END) ? color(ray.origin, ray.direction) : marchFlower(ray.origin, ray.direction);\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    bas = getBreakdownAnimationState(uv, iTime);\n    fragColor = vec4(0.);\n    for(int y = ZERO; y < AA; ++y)\n        for(int x = ZERO; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.);\nfloat frame, time;\n\n#define A_PHASE_INIT 0\n#define A_PHASE_OCC_2_NRM 1\n#define A_PHASE_SHRINK 2\n#define A_PHASE_PETAL_GROW 3\n#define A_PHASE_PETAL_MOD_HR_GROW 4\n#define A_PHASE_PETAL_MOD_HR_SHRINK 5\n#define A_PHASE_PETAL_MOD_VT_GROW 6\n#define A_PHASE_PETAL_CHANGE_SIZE 7\n#define A_PHASE_PETAL_CHANGE_SHAPE 8\n#define A_PHASE_PETAL_EXPAND_ALL 9\n#define A_PHASE_PETAL_ADD_OFFSET 10\n#define A_PHASE_END 11\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n#define HASHSCALE1 .1031\nfloat hash11(float p){\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv){\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\nmat3 xrot(float t){\n    return mat3(1., 0., 0., 0., cos(t), -sin(t), 0., sin(t), cos(t));\n}\n\nmat3 yrot(float t){\n    return mat3(cos(t), 0., -sin(t), 0., 1., 0., sin(t), 0., cos(t));\n}\n\nmat3 zrot(float t){\n    return mat3(cos(t), -sin(t), 0., sin(t), cos(t), 0., 0., 0., 1.);\n}\n\nstruct BreakdownAnimationState{\n\tint id;\n    float phase; \n};\nconst int PHASES_COUNT = 12;\nconst float PHASES_DURATIONS[PHASES_COUNT] = float[PHASES_COUNT](2., 3., 4., 4.5, 6., 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 14.);\n\nBreakdownAnimationState getBreakdownAnimationState(vec2 uv, float time){\n\ttime = mod(time, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    \n    int id = 0;\n    for(int i=1; i<=PHASES_COUNT; i++){\n        if(time < PHASES_DURATIONS[i-1]){\n        \tid = i-1;\n            break;\n        }\n    }\n    float phase = (time - (id == 0 ? 0. : PHASES_DURATIONS[id-1]))\n        \t\t/ (PHASES_DURATIONS[id] - (id == 0 ? 0. : PHASES_DURATIONS[id-1]));\n    \n    return BreakdownAnimationState(id, phase);\n}","name":"Common","description":"","type":"common"}]}