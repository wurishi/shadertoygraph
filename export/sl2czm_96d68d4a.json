{"ver":"0.1","info":{"id":"sl2czm","date":"1650385840","viewed":304,"name":"TP4 maquette","username":"lea_02010","description":"Ce shader contient l'ensemble du tp4 de lifgraphique c'est-à-dire une maquette d'un paysage.","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["lifgraphique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Permet de renvoyer un vecteur où l'on a appliqué du bruit\n// p : Point \nvec3 Noise3D (vec3 p)\n{\n    return vec3(Noise (p+vec3(1., 17., 36.)),\n                Noise (p+vec3(78., -4., -26.)),\n                Noise (p+vec3(-0.5, 8., -15.)));\n}\n\n// Permet de renvoyer un vecteur où l'on a appliqué une turbulance\n// p : Point\n// octave : nombre de fois que l'on répète la boucle\n// e : l'amplitude de la première octave \n// l : longueur d'onde de la première octave\nvec3 turbulance3D (vec3 p, int octave, float e, float l) \n{\n    vec3 t = vec3(0.); \n    for (int i = 0; i<octave;i++){\n        t += e*(1.0/pow (2.0,float (i)))*Noise3D (p / (l/pow(2.0,float(i))));\n    }\n    return t; \n}\n\n// Permet de renvoyer un réel où l'on a appliqué une turbulance à partir d'un \n// vecteur 3D\n// p : Point\n// octave : nombre de fois que l'on répète la boucle\n// e : l'amplitude de la première octave \n// l : longueur d'onde de la première octave\nfloat turbulance (vec3 p, int octave, float e, float l) \n{\n    float t=0.;\n    for (int i = 0; i<octave;i++){\n        t += e*(1.0/pow (2.0,float (i+1)))*Noise (p /(l/pow(2.0,float(i))));\n    }\n    return t; \n}\n\n\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// On créer du bruit à partir d'un vecteur 2D\n// x : Point \nfloat Noise2D(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\n// Permet de renvoyer un réel où l'on a appliqué une turbulance à partir d'un\n// vecteur 2D\n// p : Point\n// octave : nombre de fois que l'on répète la boucle\n// e : l'amplitude de la première octave \n// l : longueur d'onde de la première octave\nfloat turbulance2D (vec2 p, int octave, float e, float l) \n{\n    float t=0.;\n    \n    for (int i = 0; i<octave;i++){\n        t += e*(1.0/pow (2.0,float (i)))*Noise2D (p / (l/pow(2.0,float(i))));\n    }\n    return t; \n}\n\n// Partie entière d'un réel\n// x : Réel\nint part_e (float x)\n{\n    if (x>0.0) return int (x); \n    else return int (x)-1; \n}\n\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=2000.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//-----------------------------\n\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\n// Lipschitz constant\nconst float K=1.0;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Couleur spéculaire\n// ca : Couleur ambiante\n// cd : Couleur diffuse \n// s : coéfficient de pondération speculaire\n// a : coéfficient de pondération ambiant\n// d : coéfficient de pondération diffu\n// sigma \nstruct T {\nvec3 c; \nvec3 ca; \nvec3 cd; \nfloat s; \nfloat a;\nfloat d; \nfloat sigma; \n};\n\n// Terrain -----------------------------------------------------------------------------------------------\n\n\n// Calcul d'une surface, on travaille en 2D pour l'instant \n\n\n// Smooth compactly supported polynomial ; Définit là où on va travailler !\n// x : Réel\n// r : Rayon\n// pris sur un autre shader\nfloat Smooth( in float x, in float r)\n{\n    x/=r;\n    x=clamp(x,0.0,1.0);\n    float y=(1.0-x*x);\n    return y*y*y;\n}\n\n// Permet de définir une bosse \n// p : Point \n// h : Hauteur de la bosse\n// c : Centre de la bosse \n// r : Rayon de la bosse\n// pris sur un autre shader\nfloat bosse (in vec2 p, in float h, in vec3 c, in float r)\n{\n    // Calcul la distance entre p et la distance de c à l'axe des z \n    float d = length (p-c.xy); \n    // Permet de progressivement monter jusqu'à la bonne hauteur de la bosse \n    // Il ne va pas y avvoir de forte pente \n    float u = Smooth (d,r); \n    return mix (h, c.z, u); \n}\n\n\n// Permet de définir le cratère de notre volcan\n// p : Point\n// c : Centre du cratère\n// hter : hauteur du terrain de base \n// hmin : hauteur minimum du cratère \n// hmax : hauteur maximum du cratère \n// r : rayon du cratère \n// pris sur un autre shader\nfloat volcan (in vec2 p, in vec2 c, float hter, float hmin, float hmax, float r)\n{\n    float d = length(p-c); // distance entre p et c \n    // Si d est plus grand que le rayon de notre cratère alors on ne change rien \n    // c'est que le point est en dehors du cratère \n    // Si la hauteur du terrain est plus petite que la hauteur minimum du cratère \n    // c'est qu'on est sous le cratère donc on ne change rien non plu\n    if(hter < hmin || d > r) return hter; \n    \n    // Sinon on forme le cratère\n    else return hmin + (hter-hmin)*(hter-hmin)/(hmax-hmin);\n}\n\n// Terrain heightfield\n// p : Position in the plane\n// pris sur un autre shader\nfloat Terrain( in vec2 p )\n{\n\t// Matrice de rotation \n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=300.0; // Longueur d'onde de base \n    const float a0=150.0; // Amplitude de base \n    \n\t// Echelle \n    p = p/l0;\n    \n    // Sorte de turbulance \n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = Noise2D(p);\n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn -a0+a0*a;\n}\n\n\n// Water ------------------------------------------------------------------------------------------------\n\n// Fait une vague qui bouge en fonction du temps\n// position : position sur la map\n// direction : selon cos et sin de la position\n// speed : vitesse des vagues\n// frequency : frequence\n// timeshift : temps selon lequel elle bouge\n// pris sur un autre shader\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, \n            float timeshift) \n{\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\n// Fait l'ensemble des vagues\n// position : position sur la map\n// interations : nombre d'octaves\n// pris sur un autre shader\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, iTime);\n        position += normalize(p) * res.y * weight * 0.048;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\n// Water heightfield\n// x : Position in the plane\n// pris sur un autre shader\nfloat Water( in vec2 x )\n{\n\treturn 10.0*getwaves(x/200.0, 13);\t// On peut changer le 10 pour faire des vagues plus ou moins prononcées\n    //return 0.0;\t// A decommenter si on veut de l'eau plate\n} \n\n// Conversion en volume, on passe en 3D en faisant une conversion\n\n// Implicit surface defining the terrain\n// p : Point\n// index : index de l'objet\n// pris sur un autre shader\nV ImplicitWater(in vec3 p, int index)\n{\n\tfloat h = p.z - Water( p.xy );\n    return V(h,index);\n}\n\n\n\n// Implicit surface defining the terrain\n// p : Point\n// index : index de l'objet\nV ImplicitTerrain(in vec3 p, int index)\n{\n    // Création de notre terrain en assemblant le terrain de base et le volcan\n    float z = Terrain( p.xy );\n          z = bosse ( p.xy, z, vec3 (200., 200., 200.), 150.); \n          z = volcan (p.xy, vec2 (200., 200.), z,  150., 120., 150.); \n    float h = (p.z - z)/3.0; // diviser par la pente max\n    return V (h, index);\n}\n\n\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Carrée d'un nombre \n// a : Réel\nfloat sqr (float a){\n    return a*a;\n}\n\n// Translation autour de l'axe définit par t \n// p : Point\n// t : vecteur de translation\nvec3 translation (vec3 p, vec3 t)\n{\n    return vec3(p-t);\n}\n\n// Rotation sur l'axe des x\n// p : Point \n// r : Angle en radian de la rotation\nvec3 rotationX ( vec3 p, float r) \n{\n    mat3 rot = mat3(1.0,  0.0,    0.0,\n                    0.0, cos(r), -sin(r),\n                    0.0, sin(r), cos(r));\n    return rot*p;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n\n// Différence de d1-d2, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Difference(V a,V b)\n{\n    if (a.v> -b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(-b.v,b.i);\n    }\n}\n\n// Sphere \n// p : Point\n// c : Centre\n// r : Rayon\n// index : index de l'objet\nV Sphere(vec3 p, vec3 c,float r, int index)\n{\n    vec3 d = translation (p, vec3(2.*iTime, 0.,0.)); \n    return V (length(p-c)-r, index);\n}\n\n\n// Cube \n// p : point\n// c : centre\n// r : rayon\n// index : index de l'objet\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n   return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Disque \n// c : Centre \n// n : Normal\n// p : Point\n// r : Rayon\n// index : Index de l'objet\nV disque (vec3 c, vec3 n, vec3 p, float r, int index){\n    vec3 pc = p-c;\n    float dpc = length (pc);\n    return V (sqrt (sqr(dot (pc, n)) + sqr(sqrt(sqr (dpc) - sqr(dot (pc, n))) -r )), index);\n}\n\n// Segment \n// a,b : Extremums\n// p : Point\n// index : Index de l'objet\nV segment (vec3 a, vec3 b, vec3 p, int index){\n    vec3 u = (b-a)/length (b-a); \n    float l = dot (p-a, u); \n    return V (sqrt (sqr(length (p-a))-sqr(l)), index);\n}\n\n\n// Cylindre\n// a,b : Extremum\n// p : Point\n// r : Rayon \n// index : Index de l'objet\nV Cylindre (vec3 a, vec3 b, vec3 p, float r, int index){\n    vec3 u = (b-a)/length (b-a); //vect unitaire de ab\n    vec3 bp = p-b; // Vecteur BP\n    vec3 ap = p-a; // Vceteur AP\n    if ( dot (ap, u) < 0.0)\n        return V( disque (a,u,p,r,index).v, index); \n    \n    if (dot (bp,u) > 0.0)\n        return V (disque (b,u,p,r, index).v, index); \n        \n    else return V (segment (a,b,p,index).v-r, index) ; \n}\n\n// Cylindre infini\n// p : Point\n// dir : vecteur directeur du cylindre, il définit la direction de celui-ci\n// r : Rayon \n// index : Index de l'objet\nV Cylindreinf (vec3 p, vec3 dir, float r, int index){\n\n    // On crée une animation pour avoir une impression de fumée qui monte\n    p = translation (p, vec3 (0., 0.,15.)*iTime); \n    // On créer une turbulance sur le point p pour avoir une impression de \n    // fumée et pas de juste un cylindre\n    p += turbulance3D (p, 3, 25., 70.); \n    vec3 a = vec3 (0.); \n    return V (segment (a,dir,p,index).v-r, index) ;\n}\n\n// Capsule\n// a,b : Extremum\n// p : Point\n// r : Rayon\n// index : Index de l'objet\nV Capsule (vec3 a, vec3 b, vec3 p, float r, int index)\n{\n    vec3 u = (b-a)/length (b-a); //vect unitaire de ab\n    vec3 bp = p-b; // Vecteur BP\n    vec3 ap = p-a; // Vceteur AP\n    float dap = length (ap); // Longueur AP\n    float dbp = length (bp); // Longueur BP\n    if (dot (ap, u) < 0.0){\n        return V (dap-r, index);\n    }\n    if (dot (bp,u) > 0.0){\n        return V (dbp-r, index );\n    }\n    else {return V (segment (a,b,p, index).v-r, index) ;}\n}\n\n// Cone \n// p : Point\n// c : vecteur qui prend le sinus et cosinus de l'angle du cone \n// h : hauteur du cône\n// index : Index de l'objet\n// pris sur Indigo Quilez puis modifié un peu\nV sdConelisse( in vec3 p, in vec2 c, float h, int index )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,1.0);\n    \n  vec2 w = vec2( length(p.xy), -p.z );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return V (sqrt(d)*sign(s), index);\n}\n\n// Permet de faire le ballon de la mongolfière\n// p : Point \n// h : Hauteur du ballon\n// c : Centre de la montgolfière \n// index : Index de l'objet\nV ballon (vec3 p, float h, vec3 c, int index)\n{\n    // On créer le centre de notre ballon à partir de la hauteur\n    vec3 centreballon = c + vec3 (0.,0., 1.85*h);\n    \n    // On assemble un cone et une sphère correctement placé \n    V bal = Union (sdConelisse (translation (rotationX (p, 3.1415), \n                                             vec3(0.,0., -h/2.99)), \n                               vec2 (0.60, 0.70), h, index), \n                   Sphere(p, centreballon, 10.*h/10., index)); \n    // On enlève la petite pointe du cone à l'aide de la différence avec un cube             \n      bal = Difference (bal, Cube (p, c+vec3 (0.,0., h/3.), h/4., index)); \n    return bal;   \n}\n\n// Permet de faire la montgolfière \n// p : Point \n// h : Hauteur de la mongolfière\n// c : Centre du panier de la mongolfière\n// index : Index de l'objet\nV montgolfiere (vec3 p, float h, vec3 c, int index)\n{\n    // On créer la taille de notre panier en fonction de la hauteur de la mongolfière\n    float hpanier = h/6.; \n    V panier = Cube (p, c, hpanier,index); \n    \n    // On créer le ballon de la montgolfière que l'on a créer avec la fonction ballon \n    // On fixe l'entier de l'index pour pouvoir mettre une texture différentes entre \n    // le ballon les cordes et le panier\n    V b = ballon (p, h, c, 5);\n    \n    // On créer les 4 cordes qui relie le panier au ballon à partir des paramètre de \n    // la mongolfière \n    vec3 a = c + vec3(h/6.) - vec3 (h/30.); \n    vec3 d = a + vec3 (0.,0.,h/2.); \n    V corde1 = Cylindre (a, d, p, h/30., index); \n    \n    a = c - vec3(h/6.) + vec3 (h/30.); \n    d = a + vec3 (0.,0.,h); \n    V corde2 = Cylindre (a, d, p, h/30., index); \n    \n    a = c + vec3(-h/6.,h/6.,h/6.) - vec3 (-h/30., h/30., h/30.); \n    d = a + vec3 (0.,0.,h); \n    V corde3 = Cylindre (a, d, p, h/30., index); \n    \n    a = c + vec3(h/6.,-h/6.,h/6.) - vec3 (h/30., -h/30., h/30.); \n    d = a + vec3 (0.,0.,h); \n    V corde4 = Cylindre (a, d, p, h/30., index); \n    \n    // On assemble nos différents éléments construits précédemment \n    V montgo = Union(b, panier);\n          montgo = Union (montgo, corde1); \n          montgo = Union (montgo, corde2);\n          montgo = Union (montgo, corde3);\n          montgo = Union (montgo, corde4);\n          \n    return montgo; \n    \n}\n\n//Permet de dessiner la courbe que la mongolfière suit dans ces déplacements. \nvec3 rotationMong ()\n{\n    float r = 400.; // Rayon de la sphère \n    vec3 t;\n    // équation d'une sphère\n    // iTime/2. correspond à la longitude, le iTime va permettre l'animation\n    // 0.5 corrspond à la latitude de la sphère \n    t.x = r*cos(iTime/2.)*cos(0.5); \n    t.y = r*sin(iTime/2.)*cos(0.5); \n    t.z = r*sin(0.5);\n    return t; \n}\n\n\n// Scene --------------------------------------------------------------------------\n\n\n// Potential field of the object\n// p : point\nV Object(vec3 p)\n{\n\n    // On assemble nos différents élément à partir des fonctions précédentes\n    V u = Union (ImplicitTerrain(p, 0), ImplicitWater (p, 1)); \n      u = Intersection ( u, Sphere(p,vec3(0.0,0.0,0.0),450.0, 2));\n      u = Union (u, Cylindreinf (translation (p, vec3 (220., 220., 0.)), \n                                 vec3 (0., 0., 1.), 25., 3)); \n      u = Union (u, montgolfiere (translation (p, rotationMong()), \n                                  40., vec3 (0.), 4));\n\n  return u;\n}\n\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = Object(p);\n  float v = vp.v;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n// Texture de l'eau\n// p : Point \nT TextureWater(in vec3 p)\n{\n  return T(vec3(1.),\n            vec3(0.4,0.4,1.0), \n            vec3(0.7),\n            0., 0.45, 0.5, 28.);   \n}\n\n// Texture d'un blanc mat\n// p : Point\nT Tblanc(in vec3 p)\n{\n    return T(vec3(1., 0.75, 0.31),\n            vec3(1.), \n            vec3(0.7, 0.63, 0.52),\n            0., 0.5, 0., 28.); \n}\n\n// Texture de la roche des montagnes \n// p : Point \nT roche (in vec3 p)\n{\n    // On utilise la même technique que pour le sable du TP2\n    vec3 r = vec3(0.25);\n    vec3 r2 = vec3(0.11);\n     \n    vec3 c = mix (r, r2, Noise(p/3.));\n    \n    return T(vec3(1., 0.75, 0.31), \n             c,\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.2, 28.);  \n    \n}\n\n// Création de la texture de Bois \n// p : Point\nT Corde (in vec3 p)\n{\n  // Définition de la couleur de la corde\n  vec3 c1 = vec3(0.7, 0.55, 0.3);\n  return T (vec3(1., 0.75, 0.31),\n            c1, \n            vec3(0.7, 0.63, 0.52),\n            0., 0.5, 0.5, 28.);\n}\n\n// Texture de l'herbe\n// p : Point \nT herbe (vec3 p)\n{\n     // On utilise la même technique que pour le sable du TP2\n\n    // Définition des deux couleurs qui composeront l'herbe \n    vec3 vert = vec3(0.0,0.1,0.0);\n    vec3 v = vec3(0.05,0.3,0.05); \n    \n    // On fait une interpolation linéaire entre les deux couleurs \n    // avec comme valeur d'interpolation Noise(p/0.05) on choisit \n    // cette valeur qui va renvoyer une valeur au hasard\n    // Plus on divise p plus on obtiendra un grain de sable fins\n    vec3 c = mix (vert, v, Noise(p/2.));\n    \n    return T(vec3(1., 0.75, 0.31), \n             c,\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.5, 28.);  \n}\n\n// Texture du terrain \n// p : Point \nT Tterrain (vec3 p) \n{\n    // Définition des deux couleur du terrain \n    vec3 verdure = herbe(p).ca; \n    vec3 caillou = roche (p).ca; \n    // On fait arriver l'herbe progressivement\n    float s = 0.; \n    s = smoothstep(10.0, 50.0, p.z+20.0*Noise(p));\n    vec3 col = mix(verdure, caillou, s);\n    return T(vec3(1., 0.75, 0.31), \n             col,\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.5, 28.); \n    \n}\n\n// Texture grise pour la fumée du volcan \n// p : Point \nT Tfum(in vec3 p)\n{   \n    return T(vec3(1., 0.75, 0.31), \n             vec3 (0.8),\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.5, 28.); \n}\n\n// Texture Damier pour le ballon de la mongolfière \n// p : Point \nT Damier(in vec3 p)\n{\n  //Définition des textures du damier \n  T color1 = T(vec3(1., 0.75, 0.31), \n               vec3(1.,0., 0.68),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n  T color2 = T(vec3(1., 0.75, 0.31), \n               vec3(1., 0.55, 0.),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n  T color3 = T(vec3(1., 0.75, 0.31), \n               vec3(1., 0., 0.),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n  T color4 = T(vec3(1., 0.75, 0.31), \n               vec3(0., 0.7, 1.),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n               \n  // Ici on divise p avant de récupèrer la partie entière sinon on aurait de \n  // trop petit carrée\n  vec3 t = rotationMong();\n  p -= t;\n  p /= 20.;\n  int x = part_e(p.x);\n  int y= part_e (p.y);\n  int z = part_e (p.z);\n  \n  // On sépare l'espace en 4 puis donne une texture différente à chaque espace\n  \n  if ((x+y+z) % 4 == 0) \n    return color1; \n  if ((x+y+z) % 4 == 1) \n    return color2; \n  if ((x+y+z) % 4 == 2) \n    return color3; \n             \n  else return color4; \n}\n\n// Compute color \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= Object(p);\n    if (vp.i==0){\n        return Tterrain(p); \n    }\n    if (vp.i==1){\n        \n        return TextureWater(p);\n    }\n    if (vp.i==2){\n        return Tblanc(p); \n    }\n    if (vp.i==3){\n        return Tfum(p); \n    }\n    if (vp.i==4){\n        \n        return Corde(p);\n    }\n    if (vp.i==5){\n        return Damier(p); \n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tT col;\n    int it;\n    vec3 color;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    V vp = Object(p);\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n);\n    // Ciel qui est un dégradé de couleur du rouge vers le jaune orangé\n    if( b==false )\n    {\n        color = mix(vec3(0.8,0.4,0.), vec3(0.6,0.1,0.),rd.z*rd.z*10.0);\n    }\n\telse \n\t{\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n        \n        vec3 ambiant = col.a*col.ca; \n        vec3 dif = col.d*fre * col.cd;\n        float s = Shadow (p+0.01*n,n,hal); \n        vec3 specular = col.c*col.s*pow(clamp(dot(ref, hal), 0.,1.), col.sigma); \n        color = ambiant + s*(dif+specular); \n        \n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(color), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true ;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"}]}