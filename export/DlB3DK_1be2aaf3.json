{"ver":"0.1","info":{"id":"DlB3DK","date":"1673895977","viewed":121,"name":"RAY TRACER SUPER 666 SHADER JEH","username":"brndd","description":"jeh","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["h"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//For some stupid reason mat3(1.0/9.0) doesn't actually seem to initialize a mat\n//with all fields set to 1.0/9.0, so we do it like this.\n#define B 1.0/9.0\nconst mat3 boxBlur = mat3(B, B, B,\n                          B, B, B,\n                          B, B, B);\n\nconst mat3 sharpen = mat3(0, -1,  0,\n                         -1,  5, -1,\n                          0, -1,  0);\n\nconst mat3 edge = mat3(-1, -1, -1,\n                       -1,  8, -1,\n                       -1, -1, -1);\n\n//Apply one of the postprocessing kernels\nvec3 applyKernel3(mat3 kernel, vec2 fragCoord)\n{\n    vec3 accumulator = vec3(0.0);\n    for (int x = 0; x < 3; x++)\n    {\n        for (int y = 0; y < 3; y++)\n        {\n            ivec2 coords = ivec2(fragCoord.xy - 0.5) + ivec2(x - 1, y - 1);\n            coords = clamp(coords, ivec2(0), ivec2(iResolution.xy) - 1);\n            #if ENABLE_BLOOM == 1\n            vec3 col = texelFetch(iChannel1, coords, 0).rgb;\n            #else\n            vec4 data = texelFetch(iChannel0, coords, 0);\n            vec3 col = data.rgb / data.a;\n            #endif\n            accumulator += col * kernel[x][y];\n        }\n    }\n    return accumulator;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if ENABLE_POSTPROCESSING == 0\n    ivec2 coords = ivec2(fragCoord.xy - 0.5);\n    coords = clamp(coords, ivec2(0), ivec2(iResolution.xy) - 1);\n    #if ENABLE_BLOOM == 1\n    vec3 col = texelFetch(iChannel1, coords, 0).rgb;\n    #else\n    vec4 data = texelFetch(iChannel0, coords, 0);\n    vec3 col = data.rgb / data.a;\n    #endif\n    #endif\n\n    #if ENABLE_POSTPROCESSING == 1\n    vec3 blurred = applyKernel3(boxBlur, fragCoord);\n    vec3 sharpened = applyKernel3(sharpen, fragCoord);\n    vec3 edged = applyKernel3(edge, fragCoord);\n    \n    vec3 blend = vec3(0.0);\n    //Smoothly step through the different postprocessing filters over time\n    float t = mod(iTime, 3.0);\n    blend = mix(blurred, sharpened, smoothstep(0.0, 1.0, t));\n    blend = mix(blend, edged, smoothstep(1.0, 2.0, t));\n    blend = mix(blend, blurred, smoothstep(2.0, 3.0, t));\n    vec3 col = blend;\n    #endif\n    \n    col = col / vec3(1.0) + col; //Reinhad tone mapping\n    col = pow(col, vec3(1.0/2.2)); //sRGB conversion\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////\n//Configurable options\n\n//Enable DOF?\n#define DOF 1\n\n//Allow repositioning the camera with the mouse?\n#define UNLOCK_CAMERA 0\n\n//Use PBR BSDFs? If disabled, will use Lambertian instead.\n#define USE_PBR 1\n\n//Enable the (incorrectly implemented & ugly) bloom filter?\n#define ENABLE_BLOOM 1\n\n//Enable the annoying cycling postprocessing blend effect\n#define ENABLE_POSTPROCESSING 1\n\n//Focus distance for DoF\n//Default value: distance between camera and the center of the light-sphere\nconst float focal_distance = length(vec3(0, 3.5, 0) + vec3(0, 7.0, 15));\n//This is the \"f-stop\" value for DoF, except it's not really an f-stop value\n//This is an intentionally extreme value to demonstrate the effect.\nconst float aperture_size_multiplier = 0.2;\n\n//\n////////////////////////////\n\n//Gaussian blur stuff\nconst ivec2 blur_direction_x = ivec2(1, 0);\nconst ivec2 blur_direction_y = ivec2(0, 1);\nconst int blur_M = 16; //blur size is 2M+1 = 33\nconst float blur_coeffs[blur_M + 1] = float[blur_M + 1](\n\t0.04425662519949865,\n\t0.044035873841196206,\n\t0.043380781642569775,\n\t0.04231065439216247,\n\t0.040856643282313365,\n\t0.039060328279673276,\n\t0.0369716985390341,\n\t0.03464682117793548,\n\t0.03214534135442581,\n\t0.0295279624870386,\n\t0.02685404941667096,\n\t0.02417948052890078,\n\t0.02155484948872149,\n\t0.019024086115486723,\n\t0.016623532195728208,\n\t0.014381474814203989,\n\t0.012318109844189502\n);\n\n/*\n * Transformation functions\n */\nmat4 x_rotate(float theta)\n{\n\treturn mat4(1, 0, 0, 0,\n\t\t    \t0, cos(theta), sin(theta), 0,\n\t\t\t\t0, -sin(theta), cos(theta), 0,\n\t\t\t\t0, 0, 0, 1);\n}\n\nmat4 y_rotate(float theta)\n{\n\treturn mat4(cos(theta), 0, -sin(theta), 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\tsin(theta), 0, cos(theta), 0,\n\t\t\t\t0, 0, 0, 1);\n}\n\nmat4 z_rotate(float theta)\n{\n\treturn mat4(cos(theta), sin(theta), 0, 0,\n\t\t\t\t-sin(theta), cos(theta), 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1);\n}\n\nmat4 translate(vec3 translation)\n{\n\tmat4 translation_matrix = mat4(1.0);\n\ttranslation_matrix[3] = vec4(translation, 1.0);\n\treturn translation_matrix;\n}\n\nmat4 scale(vec3 scaling)\n{\n\tmat4 scaling_matrix = mat4(1.0);\n\tscaling_matrix[0] = vec4(scaling.x, 0, 0, 0);\n\tscaling_matrix[1] = vec4(0, scaling.y, 0, 0);\n\tscaling_matrix[2] = vec4(0, 0, scaling.z, 0);\n\treturn scaling_matrix;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Some settings\n#define MAX_ITERS 100\n#define MAX_DIST 100.0\n#define MAX_BOUNCES 50\n#define EPSILON 0.0001\n\n//Some constants\n#define PI 3.1415926538\n#define INV_PI 1.0 / PI\n#define TAU PI * 2.0\n\n//Global light settings\nconst vec3 sun_direction = normalize(vec3(1, 2, -1));\nconst vec3 sun_color = vec3(0.8, 0.65, 0.65);\n\n\n////////////////////////////\n//Materials\n#define MAT_TYPE_LAMBERTIAN 0\n#define MAT_TYPE_DIELECTRIC 1\n#define MAT_TYPE_METALLIC 2\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    float emissionStrength;\n    float specular;\n    float opacity;\n    vec3 tint; //Transparent objects multiply light passing through them by their tint\n    float ior;\n};\n\nconst Material mat_white_emissive =Material(\n    MAT_TYPE_LAMBERTIAN,\n    vec3(1.0),\n    0.0,\n    1.0,\n    2.0,\n    0.0,\n    1.0,\n    vec3(1.0),\n    1.0);\n\nconst Material mat_white_lambertian = Material(\n    MAT_TYPE_LAMBERTIAN,\n    vec3(1.0),\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    1.0,\n    vec3(1.0),\n    1.0);\n\nconst Material mat_green_dielectric = Material(\n    MAT_TYPE_DIELECTRIC,\n    vec3(0.1, 0.95, 0.1),\n    0.0,\n    0.5,\n    0.0,\n    0.5,\n    1.0,\n    vec3(1.0),\n    1.5);\n\nconst Material mat_red_dielectric = Material(\n    MAT_TYPE_DIELECTRIC,\n    vec3(0.95, 0.1, 0.1),\n    0.0,\n    0.5,\n    0.0,\n    0.5,\n    1.0,\n    vec3(1.0),\n    1.5);\n\nconst Material mat_blue_metallic = Material\n    (MAT_TYPE_METALLIC,\n    vec3(0.1, 0.1, 0.95),\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    vec3(1.0),\n    2.0);\n\nconst Material mat_yellow_dielectric = Material(\n    MAT_TYPE_DIELECTRIC,\n    vec3(0.95, 0.95, 0.1),\n    0.0,\n    0.5,\n    0.0,\n    0.5,\n    1.0,\n    vec3(1.0),\n    1.5);\n\nconst Material mat_mirror = Material(\n    MAT_TYPE_METALLIC,\n    vec3(1.0),\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    vec3(1.0),\n    2.0);\n\nconst Material mat_glass = Material(\n    MAT_TYPE_LAMBERTIAN,\n    vec3(1.0),\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    vec3(1.0),\n    1.5);\n\nconst Material mat_glass_red = Material(\n    MAT_TYPE_LAMBERTIAN,\n    vec3(1.0),\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    vec3(1.0, 0.5, 0.5),\n    1.5);\n\n//This material is probably impossible in the real world\nconst Material mat_glass_green = Material(\n    MAT_TYPE_METALLIC,\n    vec3(1.0),\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.2,\n    vec3(0.5, 1.0, 0.5),\n    1.5);\n\n//\n////////////////////////////\n\n\n////////////////////////////\n// PRNG\nuvec4 pcg4d(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v += v.yzxy*v.wxyz;\n    v ^= v >> 16u;\n    v += v.yzxy*v.wxyz;\n    return v;\n}\n\nvec4 rand4(uvec4 seed)\n{\n    return vec4(pcg4d(seed)) / float(0xffffffffu);\n}\n\n////////////////////////////////////////////////////////\n//A min function that also returns the material\n//This could/should probably be refactored to use structs\nvoid min2(inout float dist_a, float dist_b, inout Material mat_a, Material mat_b)\n{\n    if (dist_a <= dist_b)\n    {\n        return;\n    }\n    else\n    {\n        dist_a = dist_b;\n        mat_a = mat_b;\n    }\n}\n////////////////////////////////////////////////////////\n//Geometry functions\n//from https://iquilezles.org/articles/distfunctions/\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n//\n////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////\n//Ray marching\n\n//The main SDF function for scene geometry\nvoid SDF(vec3 p, out float dist, out Material mat)\n{\n    float sphereDist = sdSphere(p - vec3(0, 3.5, 0), 1.0);\n    dist = sphereDist;\n    mat = mat_white_emissive;\n    \n    float torusDist = sdTorus(p - vec3(0, 2.0, 0), vec2(3.0, 0.5));\n    min2(dist, torusDist, mat, mat_yellow_dielectric);\n    \n    float groundDist = p.y;\n    min2(dist, groundDist, mat, mat_white_lambertian);\n    \n    float box1Dist = sdBox(p - vec3(5.0, 5.0, 0.0), vec3(0.5, 10.0, 5.0));\n    min2(dist, box1Dist, mat, mat_red_dielectric);\n    \n    float box2Dist = sdBox(p - vec3(0.0, 5.0, -5.0), vec3(5.0, 10.0, 0.5));\n    min2(dist, box2Dist, mat, mat_blue_metallic);\n    \n    float box3Dist = sdBox(p - vec3(-5.0, 5.0, 0.0), vec3(0.5, 10.0, 5.0));\n    min2(dist, box3Dist, mat, mat_green_dielectric);\n    \n    float box4Dist = sdBox(p - vec3(0.0, 15.5, 0.0), vec3(5.0, 0.5, 5.0));\n    min2(dist, box4Dist, mat, mat_white_lambertian);\n    \n    float box5Dist = sdBox(p - vec3(0.0, 7.0, 10.0), vec3(5.0, 3.0, 1.0));\n    float box6Dist = sdBox(p - vec3(0.0, 5.0, 10.0), vec3(10.0, 10.0, 0.5));\n    float sub56 = opSubtraction(box5Dist, box6Dist);\n    min2(dist, sub56, mat, mat_white_lambertian);\n    \n    float glassSphereDist = sdSphere(p - vec3(0.0, 7.0, 10.0), 1.0);\n    min2(dist, glassSphereDist, mat, mat_glass);\n    \n    float glassRed = sdSphere(p - vec3(-3.0, 6.0, 10.0), 1.0);\n    min2(dist, glassRed, mat, mat_glass_red);\n    \n    float glassGreen = sdSphere(p - vec3(3.0, 6.0, 10.0), 1.0);\n    min2(dist, glassGreen, mat, mat_glass_green);\n}\n\n//Why have this? Because it's slightly faster when we don't need mat id\n//and I like pain and bugs\nfloat SDF(vec3 p)\n{\n    float d = sdSphere(p - vec3(0, 3.5, 0), 1.0);\n    d = min(d, sdTorus(p - vec3(0, 2.0, 0), vec2(3.0, 0.5)));\n    d = min(d, p.y);\n    d = min(d, sdBox(p - vec3(5.0, 5.0, 0.0), vec3(0.5, 10.0, 5.0)));\n    d = min(d, sdBox(p - vec3(0.0, 5.0, -5.0), vec3(5.0, 10.0, 0.5)));\n    d = min(d, sdBox(p - vec3(-5.0, 5.0, 0.0), vec3(0.5, 10.0, 5.0)));\n    d = min(d, sdBox(p - vec3(0.0, 15.5, 0.0), vec3(5.0, 0.5, 5.0)));\n    float box5 = sdBox(p - vec3(0.0, 7.0, 10.0), vec3(5.0, 3.0, 1.0));\n    float box6 = sdBox(p - vec3(0.0, 5.0, 10.0), vec3(10.0, 10.0, 0.5));\n    float sub = opSubtraction(box5, box6);\n    d = min(d, sub);\n    d = min(d, sdSphere(p - vec3(0.0, 7.0, 10.0), 1.0));\n    d = min(d, sdSphere(p - vec3(-3.0, 6.0, 10.0), 1.0));\n    d = min(d, sdSphere(p - vec3(3.0, 6.0, 10.0), 1.0));\n    \n    return d;\n}\n\nvoid RayMarch(vec3 origin, vec3 direction, out float dist, out Material mat)\n{\n    float distOrigin = 0.0;\n    for (int i = 0; i < MAX_ITERS; i++)\n    {\n        vec3 p = origin + direction * distOrigin;\n        float distScene;\n        SDF(p, distScene, mat);\n        distOrigin += distScene;\n        if (distOrigin > MAX_DIST || distScene < EPSILON)\n            break;\n    }\n    dist = distOrigin;\n}\n\nvoid RayMarchInside(vec3 origin, vec3 direction, out float dist, out Material mat)\n{\n    float distOrigin = 0.0;\n    for (int i = 0; i < MAX_ITERS; i++)\n    {\n        vec3 p = origin + direction * distOrigin;\n        float distScene;\n        SDF(p, distScene, mat);\n        distOrigin += -distScene;\n        if (distOrigin > MAX_DIST || -distScene < EPSILON)\n            break;\n    }\n    dist = distOrigin;\n}\n\n//Simpler version of RayMarch() (ignores material) for shadows\nfloat Shadow(vec3 origin, vec3 direction, float hardness)\n{\n    float distOrigin = 0.0;\n    float shadow = 1.0;\n    for (int i = 0; i < MAX_ITERS; i++)\n    {\n        vec3 p = origin + direction * distOrigin;\n        float distScene = SDF(p);\n        \n        if (distScene < EPSILON)\n            return 0.0;\n        shadow = min(shadow, hardness * distScene/distOrigin);\n        distOrigin += distScene;\n    }\n    return shadow;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    return normalize(vec3(SDF(p + e.xyy) - SDF(p - e.xyy),\n                          SDF(p + e.yxy) - SDF(p - e.yxy),\n                          SDF(p + e.yyx) - SDF(p - e.yyx)));\n}\n\nmat3 create_tangent_space(vec3 normal)\n{\n    const float one_over_sqrt_3 = 1.0 / sqrt(3.0);\n    vec3 major;\n    if(abs(normal.x) < one_over_sqrt_3) major = vec3(1,0,0);\n    else if(abs(normal.y) < one_over_sqrt_3) major = vec3(0,1,0);\n    else major = vec3(0,0,1);\n    vec3 tangent = normalize(cross(normal, major));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n//Cosine hemisphere sampling\nvec3 chSample(mat3 tangent_space, float u0, float u1)\n{\n    float r = sqrt(u0) * cos(2.0 * PI * u1);\n    float g = sqrt(u0) * sin(2.0 * PI * u1);\n    float b = sqrt(1.0 - u0);\n    return normalize(tangent_space * vec3(r, g, b));\n}\n\n//Used for DoF\nvec2 sample_regular_polygon(vec2 u, float angle, int sides)\n{\n    float side = floor(u.x * float(sides));\n    u.x = fract(u.x * float(sides));\n    float side_radians = 6.28318530718/float(sides);\n    float a1 = side_radians * side + angle;\n    float a2 = side_radians * (side + 1.0) + angle;\n    vec2 b = vec2(sin(a1), cos(a1));\n    vec2 c = vec2(sin(a2), cos(a2));\n    u = u.x+u.y > 1.0 ? 1.0 - u : u;\n    return b * u.x + c * u.y;\n}\n\n////////////////////////////\n//BSDFs and PDFs\n//I hate the PBR antichrist\n\n//Lambertian BSDF\nvec3 lamBSDF(vec3 albedo, vec3 incoming, vec3 normal)\n{\n    float LdotN = dot(incoming, normal);\n    if (LdotN > 0.0)\n        return albedo / PI;\n    else\n        return vec3(0.0);\n/*\n    float LdotN = max(dot(incoming, normal), 0.0);\n    return albedo * LdotN;*/\n}\n\n//Cosine hemisphere PDF\nfloat chPDF(vec3 incoming, vec3 normal)\n{\n    float cosTheta = max(dot(incoming, normal), 0.0);\n    return cosTheta > 0.0 ? cosTheta/PI : 0.001;\n    //return max(dot(incoming, normal), 0.001);\n}\n\n//Schlick's Fresnel term approximation, as used with... dielectric reflections and nothing else I guess\nfloat schlick1(vec3 incoming, vec3 outgoing, Material mat)\n{\n    vec3 halfvec = normalize(incoming + outgoing);\n    float HdotL = clamp(dot(halfvec, incoming), 0.0, 1.0);\n    float f0 = 0.04;\n    return f0 + (1.0 - f0) * pow((1.0 - HdotL), 5.0);\n}\n\n//The PBR functions below are mostly stolen from this Youtube tutorial:\n//https://www.youtube.com/watch?v=gya7x9H3mV0\n//I had my own implementations at first, but couldn't get things working so I replaced them with this.\n//It still didn't work afterwards because the mistake was elsewhere, but I'm too lazy to replace these\n//and they're better than my own implementations anyway.\n\n//Schlick's Fresnel term approximation, as used with the PBR equations below\nvec3 pbrSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat GGX(float NdotH, float roughness)\n{\n    float alpha = roughness * roughness;\n    float alphaSq = alpha * alpha;\n    float NdotHSq = NdotH * NdotH;\n    float b = (NdotHSq * (alphaSq - 1.0) + 1.0);\n    return alphaSq * INV_PI / (b * b);\n}\n\nfloat GGX_Schlick(float NdotV, float roughness)\n{\n    float alpha = roughness * roughness;\n    float k = alpha / 2.0;\n    return max(NdotV, 0.001) / (NdotV * (1.0 - k) + k);\n}\n\nfloat Smith(float NdotV, float NdotL, float roughness)\n{\n    return GGX_Schlick(NdotL, roughness) * GGX_Schlick(NdotV, roughness);\n}\n\nvec3 pbrBRDF(vec3 light, vec3 view, vec3 normal, Material mat)\n{\n    vec3 H = normalize(view + light);\n    float NdotV = clamp(dot(normal, view), 0.0, 1.0);\n    float NdotL = clamp(dot(normal, light), 0.0, 1.0);\n    float NdotH = clamp(dot(normal, light), 0.0, 1.0);\n    float VdotH = clamp(dot(normal, light), 0.0, 1.0);\n    \n    vec3 F0 = vec3(0.16 * mat.specular * mat.specular);\n    F0 = mix(F0, mat.albedo, mat.metallic);\n    \n    vec3 F = pbrSchlick(VdotH, F0);\n    float D = GGX(NdotH, mat.roughness);\n    float G = Smith(NdotV, NdotL, mat.roughness);\n    \n    if(isnan(G))\n        return vec3(1.0, 0.0, 1.0);\n    vec3 spec = (F * D * G) / (4.0 * max(NdotV, 0.001) * max(NdotL, 0.001));\n    \n    vec3 rhoD = mat.albedo;\n    rhoD *= vec3(1.0) - F;\n    rhoD *= (1.0 - mat.metallic);\n    vec3 diff = rhoD * INV_PI;\n    \n    return diff + spec;\n}\n\n//This may be the GGX PDF function, no I did not figure it out myself\n//I asked ChatGPT to write it for me lmao https://i.imgur.com/4k5vjpJ.png\n//...that also means it may be incorrect, but the results look alright & I'm short on time\n//so I'll roll with it.\n//This is not considered good practice because the machine spirit is not (yet) all-knowing.\nfloat pbrPDF(vec3 n, vec3 h, float roughness) {\n    float cosTheta = dot(n, h);\n    float tanTheta = sqrt(max(1.0 - cosTheta * cosTheta, 0.0)) / cosTheta;\n    float alpha = roughness * roughness;\n    float denom = (alpha + 1.0) * pow(cosTheta, 4.0);\n\n    return alpha / (PI * denom * tanTheta);\n}\n\n//The full(er) Schlick approximation for use with refractions\nfloat schlickFull(vec3 view, vec3 normal, float n1, float n2)\n{\n    float NdotV = dot(normal, view);\n    float k;\n    if (n1 < n2)\n        k = NdotV;\n    else\n    {\n        float NdotVSq = NdotV * NdotV;\n        float ratioSq = (n1/n2) * (n1/n2);\n        k = 1.0 - ratioSq * (1.0 - NdotVSq);\n        //if the inside of the sqrt is negative the result would be imaginary,\n        //but in GLSL they would be undefined so we'll just have k be negative in this case\n        if (k > 0.0)\n            k = sqrt(k);\n    }\n    \n    if (k >= 0.0)\n    {\n        float F0 = (n1 - n2) / (n1 + n2);\n        F0 *= F0;\n        return F0 + (1.0 - F0) * pow((1.0 - k), 5.0);\n    }\n    return 1.0; //TOTAL INTERNAL REFLECTION!!!1\n}\n//\n////////////////////////////\n\n////////////////////////////\n//Camera view matrix generator\nmat4 lookAt(vec3 camPos, vec3 point, float aspect)\n{\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n\n    vec3 z = normalize(camPos - point);\n    vec3 x = normalize(cross(upVector, z));\n    vec3 y = normalize(cross(z, x));\n    \n    x *= aspect;\n    \n    return mat4(\n        vec4(x, 1.0),\n        vec4(y, 1.0),\n        vec4(z, 1.0),\n        vec4(camPos, 1.0)\n    );\n}\n\n////////////////////////////\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //This rand is used for both DoF and antialiasing.\n    //It's different for each pixel, which is desireable for DoF\n    //but may not be desireable for AA... but it looks alright so whatever.\n    uvec4 seed = uvec4(fragCoord.x, fragCoord.y, iFrame, 0.0);\n    vec4 rand = rand4(seed);\n    \n    //Antialiasing by jiggling the rays\n    vec2 uv = (fragCoord + rand.xy - vec2(0.5, 0.5))/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    //Camera position and rotation\n    vec3 lookAtPoint = vec3(0.0, 7.0, 0.0);\n    vec3 rayOrigin = vec3(0.0, 7.0, 15.0);\n    #if UNLOCK_CAMERA == 1\n    {\n        float distMult = mix(0.2, 2.0, iMouse.y / iResolution.y);\n        rayOrigin.z *= distMult;\n        float theta = iMouse.x / iResolution.x * TAU;\n        mat4 rot = y_rotate(theta + radians(-180.0));\n        rayOrigin = (vec4(rayOrigin, 1.0) * rot).xyz;\n    }\n    #endif\n    mat4 view = lookAt(rayOrigin, lookAtPoint, aspect);\n    \n    vec3 rayDir;\n    #if DOF == 1\n    {\n        vec2 aperturePoint = sample_regular_polygon(rand.xy, 0.0, 8) * aperture_size_multiplier;\n        vec3 rayTarget = vec3((2.0*uv.x-1.0), 2.0*uv.y-1.0, -1.0) * focal_distance;\n        rayOrigin = vec3(aperturePoint, 0.0);\n        rayDir = normalize(rayTarget - rayOrigin);\n        rayOrigin = (view * vec4(rayOrigin, 1.0)).xyz;\n        rayDir = normalize((view * vec4(rayDir, 0.0)).xyz);\n    }\n    #else\n        rayDir = normalize((view * vec4(uv * 2.0 - 1.0, -1.0, 0.0)).xyz);\n    #endif\n    \n    ////////////////////////////\n    //Path tracing logic\n    vec3 col = vec3(0.0);\n    vec3 curOrigin = rayOrigin;\n    vec3 curDir = rayDir;\n    vec3 attenuation = vec3(1.0);\n    bool inside = false; //Tracks whether we're outside or inside an object (for refractions)\n    for (int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float dist;\n        Material mat;\n        if (inside)\n            RayMarchInside(curOrigin, curDir, dist, mat);\n        else\n            RayMarch(curOrigin, curDir, dist, mat);\n        if (dist <= MAX_DIST) //if ray hit something\n        {\n            vec3 p = curOrigin + curDir * dist;\n            vec3 normal = Normal(p);\n            vec3 nextDir;\n            \n            //Roll new random value for each bounce\n            //There's room for perf optimization here, as we roll this even for metallic mats\n            //which don't actually need it.\n            uvec4 seed = uvec4(fragCoord, iFrame, i);\n            vec4 rand = rand4(seed);\n            \n            #define OP_NOP 0\n            #define OP_DIFFUSE 1\n            #define OP_REFLECT 2\n            #define OP_REFRACT 3\n            int operation = OP_NOP;\n            \n            //\"Sun\"light next-event estimation\n            if (!inside)\n            {\n                float shadow = Shadow(p + normal + EPSILON * 2.0, sun_direction, 16.0);\n                if (shadow > 0.0)\n                {\n                    float cos_theta = dot(sun_direction, normal);\n                    //Since the sun is a point light, let's use the fake shadow smoothing technique\n                    //from exercise 2. Maybe eventually we'll make the sun an area light.\n\n                    //PBR is disabled here because it keeps accumulating NANs for some reason\n                    //and I have no idea why, also it produces weird looking shadows too\n                    #if USE_PBR == -1\n                    vec3 BSDF = pbrBRDF(sun_direction, -curDir, normal, mat);\n                    //if (any(isnan(BSDF)))\n                    //    BSDF = vec3(10.0, 0.0, 10.0);\n                    #else\n                    vec3 BSDF = lamBSDF(mat.albedo, sun_direction, normal);\n                    #endif\n                    col += attenuation * BSDF * cos_theta * sun_color * shadow;\n                }\n            }\n\n            switch (mat.type)\n            {\n                case MAT_TYPE_METALLIC:\n                    //Simulate roughness via randomness... If our random number is below the\n                    //mat's roughness, we calculate diffuse lighting. Otherwise we reflect.\n                    //I don't know if this is the right way to do it, but it seems to work.\n                    if (rand.w < mat.roughness)\n                        operation = OP_DIFFUSE;\n                    //Awful refraction, this probably won't look very good with anything\n                    //except 1.0 and 0.0 opacity\n                    else if (rand.x > mat.opacity)\n                        operation = OP_REFRACT;\n                    else\n                        operation = OP_REFLECT;\n                    break;\n                case MAT_TYPE_DIELECTRIC:\n                    float f = schlick1(normal, -curDir, mat);\n                    if (rand.z < f && rand.w >= mat.roughness)\n                        operation = OP_REFLECT;\n                    else if (rand.x > mat.opacity && rand.w >= mat.roughness)\n                        operation = OP_REFRACT;\n                    else\n                        operation = OP_DIFFUSE;\n                    break;\n                case MAT_TYPE_LAMBERTIAN:\n                    if (rand.x > mat.opacity && rand.w >= mat.roughness)\n                        operation = OP_REFRACT;\n                    else\n                        operation = OP_DIFFUSE;\n                    break;\n                default:\n                    operation = OP_DIFFUSE;\n                    break;\n            }\n            \n            //Perform the actual shading\n            switch (operation)\n            {\n                case OP_DIFFUSE:\n                {\n                    mat3 tangent_space = create_tangent_space(normal);\n                    nextDir = chSample(tangent_space, rand.x, rand.y);\n                    col += attenuation * mat.emissionStrength;\n                    vec3 albedo = mat.albedo;\n                    #if USE_PBR == 1\n                    vec3 BSDF = pbrBRDF(albedo, -curDir, normal, mat);\n                    vec3 H = normalize(-curDir + nextDir);\n                    float PDF = pbrPDF(normal, H, mat.roughness);\n                    #else\n                    vec3 BSDF = lamBSDF(albedo, -curDir, normal);\n                    float PDF = chPDF(nextDir, normal);\n                    #endif\n                    attenuation *= BSDF;\n                    attenuation *= abs(dot(nextDir, normal));\n                    attenuation /= PDF;\n                    break;\n                }\n                case OP_REFLECT:\n                {\n                    attenuation *= mix(vec3(0.95), mat.albedo, mat.metallic);\n                    col += attenuation * mat.emissionStrength;\n                    nextDir = reflect(curDir, normal);\n                    break;\n                }\n                case OP_REFRACT:\n                {\n                    float n1, n2;\n                    //Currently we only support going from material to air.\n                    vec3 N;\n                    if (!inside)\n                    {\n                        N = normal;\n                        n1 = 1.0;\n                        n2 = mat.ior;\n                    }\n                    else\n                    {\n                        N = -normal;\n                        n1 = mat.ior;\n                        n2 = 1.0;\n                    }\n                    float F0 = (n1 - n2) / (n1 + n2);\n                    F0 *= F0;\n                    if (rand.x < F0)\n                        nextDir = reflect(curDir, N);\n                    else\n                        nextDir = refract(curDir, N, n1/n2);\n                    inside = !inside;\n                    if (inside)\n                        normal = -normal;\n                    //Some kind of tinting effect that's almost certainly not realistic\n                    attenuation *= mat.tint * (1.0 - mat.opacity);\n                    break;\n                }\n                default:\n                    break;\n            }\n            \n            curOrigin = p + normal * EPSILON * (inside ? 3.0 : 2.0);\n            curDir = nextDir;\n            \n            #undef OP_NOP\n            #undef OP_DIFFUSE\n            #undef OP_REFLECT\n        }\n        else //cubemap\n        {\n            \n            vec3 envColor = texture(iChannel1, curDir).rgb;\n            envColor = pow(envColor, vec3(2.2));\n            float grey = 0.21 * envColor.r + 0.71 * envColor.g + 0.07 * envColor.b; //make it AESTHETIC\n            col += attenuation * grey;\n            break;\n        }\n    }\n\n    //Accumulate into buffer\n    if (iFrame > 1 && iMouse.z <= 0.0)\n    {\n        vec4 oldData = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0);\n        fragColor = oldData + vec4(col, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(col, 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#if ENABLE_BLOOM == 1\n//Gaussian pass 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sum = vec3(0.0);\n    \n    for (int i = -blur_M; i < blur_M; i++)\n    {\n        ivec2 coords = ivec2(fragCoord.xy - 0.5) + blur_direction_x * i;\n        coords = clamp(coords, ivec2(1), ivec2(iResolution.xy) - 1);\n        vec4 data = texelFetch(iChannel0, coords, 0);\n        vec3 col = data.rgb / data.a;\n        float brightness = (col.r + col.g + col.b) / 3.0;\n        if (brightness < 0.8)\n            col = vec3(0.0);\n        sum += col * blur_coeffs[abs(i)];\n    }\n\n    fragColor = vec4(sum, 1.0);\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n}\n#endif\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#if ENABLE_BLOOM == 1\n//Gaussian pass 2 & bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sum = vec3(0.0);\n    \n    for (int i = -blur_M; i < blur_M; i++)\n    {\n        ivec2 coords = ivec2(fragCoord.xy - 0.5) + blur_direction_y * i;\n        coords = clamp(coords, ivec2(1), ivec2(iResolution.xy) - 1);\n        vec4 data = texelFetch(iChannel0, coords, 0);\n        sum += (data.rgb) * blur_coeffs[abs(i)];\n    }\n    \n    ivec2 coords = ivec2(fragCoord.xy - 0.5);\n    coords = clamp(coords, ivec2(0), ivec2(iResolution.xy) - 1);\n    vec4 data = texelFetch(iChannel1, coords, 0);\n    vec3 col = data.rgb / data.a;\n    \n    fragColor = vec4(col + sum, 1.0);\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n}\n#endif\n","name":"Buffer C","description":"","type":"buffer"}]}