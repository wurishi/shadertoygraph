{"ver":"0.1","info":{"id":"7l3yWs","date":"1660848637","viewed":194,"name":"Polygonal-Profile Linked Toruses","username":"fizzer","description":"Two torus-like shapes with even-sided polygon cores and profiles arranged the right way can link with each other without penetrating.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["torus","tori","linked"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float pi = 3.14159265358979323;\n\nconst float r0 = 0.5;\nconst float r1 = r0 * 2.;\nfloat n = 12.0;\n\nfloat polygon(vec2 p, float aofs)\n{\n    float a = mod(atan(p.y, p.x) + aofs * pi / n, 2.0 * pi / n) - pi / n;\n    p = vec2(cos(a), sin(a)) * length(p);\n    return p.x;\n}\n\nfloat ring(vec3 p, vec2 aofs)\n{\n    vec2 q = vec2(polygon(p.xy, aofs.x) - r1, p.z);\n    return polygon(q, aofs.y) - r0;\n}\n\nfloat map(vec3 p)\n{\n    float d0 = ring(p + vec3(+r1 / 2.,0,0), vec2(1, 1));\n    float d1 = ring(p.xzy + vec3(-r1 / 2.,0,0), vec2(1, 1));\n    \n    // Un-comment the following line to see the intersection of the two\n    // rings, which is only a very thin surface where they touch.\n    \n    //return max(d0, d1);\n    \n    return min(d0, d1);\n}\n\n// SDF gradient\nvec3 grad(vec3 p)\n{\n    vec2 e = vec2(1e-4, 0);\n    return vec3(map(p + e.xyy), map(p + e.yxy), map(p + e.yyx)) -\n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n}\n\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    n = 4. + mod(floor(iTime) * 2., 24.);\n\n    // Camera position and target.\n    vec3 campos = vec3(0, 0, 4);\n    vec3 camtarget = vec3(0, 0, 0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 2.));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n    \n    mat3 m = rotY((iMouse.x / iResolution.x - .5) * pi) * rotX(-(iMouse.y / iResolution.y - .5) * pi);\n    ro = m * ro;\n    rd = m * rd;\n    \n    // Raymarching.\n    float t = 0.;\n    for(int i = 0; i < 120; ++i)\n    {\n        float d = map(ro + rd * t);\n        if(d < 1e-4)\n            break;\n        if(t > 100.)\n            break;\n        t += abs(d);\n    }\n    \n    if(t > 80.)\n    {\n        fragColor.rgb = vec3(.5);\n        return;\n    }\n    \n    vec3 rp = ro + rd * t;\n    \n    vec3 n = normalize(grad(ro + rd * t));\n\n    fragColor.rgb = n * .5 + .5;\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"}]}