{"ver":"0.1","info":{"id":"4fcfWH","date":"1732994905","viewed":22,"name":"Shader Advent Day-24 #3","username":"mrange","description":"CC0: Shader Advent reflection shader example","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["3d","reflectionadvent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Shader Advent reflection shader example\n\n// Macro definitions for built-in Shadertoy inputs\n#define TIME        iTime        // Current time in seconds since shader start\n#define RESOLUTION  iResolution  // Viewport resolution (width, height, 1)\n// 2D rotation matrix creation macro - creates a rotation matrix for 2D transformations\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Material optical properties\nconst float refr_index = 0.8;    // Refractive index - determines how much light bends \n                                 // when passing through the material (< 1 means light \n                                 // bends less than in typical materials)\n\n// Mathematical and visual constants\nconst float pi      = acos(-1.);        // More precise way to define pi using arccos\nconst float tau     = 2.*pi;            // Full circle rotation (2π)\nconst float upSat   = 1.2;              // Saturation boost for color intensity\nconst float phi     = (sqrt(5.)+1.)/2.; // Golden ratio - aesthetically pleasing proportion\nconst float beerHue = 0.9;              // Hue value for coloration (Beer's law)\n\n// Global rotation matrix for dynamically rotating internal objects\nmat3 g_rot;\n\n// Ray marching configuration for internal object rendering\n// Ray marching is a technique to visualize 3D surfaces by stepping along a ray\nconst int   maxRayMarchesInsides   = 50;   // Maximum number of steps to find surface \n                                           // (prevents infinite loops)\nconst float toleranceInsides       = .001; // Minimum distance to consider a surface hit\nconst float normalEpisolonInsides  = 0.001;// Small offset for calculating surface normals\nconst int   maxBouncesInsides      = 5;    // Limit on light bounces/reflections inside object\nfloat g_glowDistanceInsides;               // Tracking glow effect distance\n\n// Ray marching settings for external box rendering\nconst int   maxRayMarchesShapes = 70;      // More steps for complex external surfaces\nconst float toleranceShapes     = .001;    // Minimum distance to surface hit\nconst float maxRayLengthShapes  = 20.;     // Maximum ray travel distance to prevent \n                                           // unnecessary computation\nconst float normalEpisolonShapes= 0.01;    // Slightly larger normal calculation precision\nfloat g_glowDistanceShapes;                // Tracking glow effect for external box\n\n// Scene composition parameters\nconst vec3 sunDir    = normalize(vec3(1.0));    // Directional light source \nconst vec3  boxDim   = vec3(1., phi*phi, phi);  // Box dimensions using golden ratio \n                                                // for aesthetically pleasing proportions\nconst float boxEdge  = 0.005;                   // Thickness of box's frame/outline\nconst float bottom   = -boxDim.y-0.033;         // Ground level, slightly below the box\n\nconst vec3 rayOrigin = normalize(vec3(0.0, 3.0, -5.))*8.; // Camera position \nconst vec3 lookAt    = vec3(0.0, 0.5*bottom, 0.0);        // Define a \"look-at\" point, where the camera is focusing\n\n// Approximate HSV to RGB conversion by XorDev\n// Creates smoother, more visually appealing color transitions compared to standard conversion\n// License: Unknown, author: XorDev, found: https://x.com/XorDev/status/1808902860677001297\nvec3 hsv2rgb_approx(vec3 hsv) {\n  // Trigonometric color transformation\n  // Uses cosine waves with offset to create non-linear color transitions\n  return (cos(hsv.x*tau+vec3(0.,4.,2.))*hsv.y+2.-hsv.y)*hsv.z/2.;\n}\n#define  HSV2RGB_APPROX(hsv) ((cos(hsv.x*tau+vec3(0.,4.,2.))*upSat*hsv.y+2.-upSat*hsv.y)*hsv.z/2.)\n\n// ACES Filmic Tone Mapping Approximation\n// Compresses high dynamic range images to display on standard screens\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  // Ensure no negative values\n  v = max(v, 0.0);\n  \n  // Reduce overall intensity\n  v *= 0.6;\n  \n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  \n  // Apply tone mapping and clamp to valid color range\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// \"Fancy\" animated rotation matrix\n// Generates a time-dependent rotation matrix for dynamic effects\n// I got it from Chat AI so likely \"borrowed\" from shadertoy.\nmat3 animatedRotationMatrix(float time) {\n  // Define three independent angles for rotation over time\n  float angle1 = time * 0.5;       // Primary rotation (slower)\n  float angle2 = time * 0.707;     // Secondary rotation (based on √2 for variety)\n  float angle3 = time * 0.33;      // Tertiary rotation (even slower)\n\n  // Precompute trigonometric values for efficiency\n  float c1 = cos(angle1); float s1 = sin(angle1);\n  float c2 = cos(angle2); float s2 = sin(angle2);\n  float c3 = cos(angle3); float s3 = sin(angle3);\n\n  // Construct a 3x3 rotation matrix\n  // Combines rotations across multiple axes with varying speeds\n  // Rows represent the transformed basis vectors\n  return mat3(\n      c1 * c2,                // X-axis scaling with first two rotations\n      c1 * s2 * s3 - c3 * s1, // Y-axis rotation and scaling\n      s1 * s3 + c1 * c3 * s2, // Z-axis interaction with all three rotations\n      \n      c2 * s1,                // X-axis influenced by secondary and tertiary rotations\n      c1 * c3 + s1 * s2 * s3, // Y-axis affected by all three angles\n      c3 * s1 * s2 - c1 * s3, // Z-axis with secondary and tertiary dependencies\n      \n      -s2,                   // X-axis negation for secondary rotation\n      c2 * s3,               // Y-axis scaling for secondary and tertiary rotations\n      c2 * c3                // Z-axis scaling for the primary and secondary angles\n  );\n}\n\n// Soft minimum - smoothly interpolates between two values\n// Creates a smooth blend instead of a hard transition\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// Soft maximum - complementary to soft minimum\nfloat pmax(float a, float b, float k) {\n  // Implemented by negating soft minimum\n  return -pmin(-a, -b, k);\n}\n\n// 2D box distance function - calculates signed distance to a 2D box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// 3D box distance function - calculates signed distance to a 3D box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Torus distance function - calculates distance to a donut-shaped object\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat torus(vec3 p, vec2 t) {\n  // Computes distance from point to torus surface\n  // t.x is ring radius, t.y is tube radius\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\n// Box frame distance function - calculates distance to a wireframe box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxFrame(vec3 p, vec3 b, float e) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// \"Super\" sphere - a boxy looking \"sphere\". Has nice normals\nfloat ssphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25)-r;\n}\n\n// Render the surrounding world environment\n// Responsible for creating the background scene including sky and ground plane\nvec3 renderWorld(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  \n  // Calculate distance to floor plane using ray-plane intersection\n  // Uses ray origin (ro) and ray direction (rd) to compute intersection point\n  float bt = -(ro.y-bottom)/(rd.y);\n  \n  // Generate sky color using HSV approximation\n  // Color varies based on ray direction (up/down angle)\n  // - Hue is fixed at blue-cyan (0.6)\n  // - Saturation depends on vertical ray angle\n  // - Brightness uses a quadratic falloff to create gradient effect\n  col = hsv2rgb_approx(vec3(\n    0.6,                                // Fixed hue for sky color\n    clamp(0.3+0.9*rd.y, 0.0, 1.0),      // Saturation varies with vertical angle\n    1.5*clamp(2.0-2.*rd.y*rd.y, 0.0, 2.) // Brightness with non-linear falloff\n  ));\n  \n  // If ray intersects ground plane, render ground details\n  if (bt > 0.) {\n    // Compute intersection point on ground plane\n    vec3 bp = ro + rd*bt;\n    vec2 bpp = bp.xz;\n    \n    // Create grid coordinate system\n    // Round coordinates to snap to grid points\n    vec2 npp = round(bpp);\n    vec2 cpp = bpp - npp;\n    vec2 app = abs(cpp);\n    \n    // Grid line distance field with view-angle compensation\n    // Reduces aliasing by adjusting line width based on view angle\n    float gfre = 1.+rd.y;\n    gfre *= gfre;\n    gfre *= gfre;\n    \n    // Compute grid line distance\n    // Dynamically adjusts line width based on view angle to reduce aliasing\n    float gd = min(app.x, app.y) - mix(0.01, 0.0, gfre);\n    \n    // Ground base color using HSV approximation macro\n    // Soft grayish tone with slight warmth\n    const vec3 bbcol = HSV2RGB_APPROX(vec3(0.7, 0.2, 1.25));\n    \n    // Distance-based fade effect\n    // Reduces ground detail and brightness at far distances\n    float bfade = mix(1., 0.2, exp(-0.3*max(bt-15., 0.)));\n    \n    // Anti-aliasing width adjustment\n    float aa = mix(0.0, 0.08, bfade);\n    \n    // Blend ground color with fading and grid line effects\n    // Creates soft, slightly faded grid appearance\n    vec3 bcol = mix(bbcol, bbcol*bfade, smoothstep(aa, -aa, gd));\n    \n    // Blend ground with sky, creating distance fog effect\n    col = mix(col, bcol, exp(-0.008*bt));\n  }\n  \n  return col; \n}\n\n// Distance field function for objects inside the box\n// Calculates signed distances to various internal geometric shapes\nfloat dfInsides(vec3 p) {\n  // Negative box distance (we are inside the box)\n  float dbox = -box(p, boxDim);\n  \n  // Create a copy of point for rotation\n  vec3 p0 = p;\n  // Apply global rotation matrix to the point\n  p0 *= g_rot;\n  \n  // Create box frame with slight thickness\n  float dboxFrame = boxFrame(p, boxDim, 0.) - boxEdge;\n  \n  // \"Super\" sphere with a glowing torus\n  float dsphere = ssphere4(p0, 0.7);\n  float dtorus  = torus(p0, 0.707*vec2(1.0, 0.025));\n  \n  // Combine sphere and torus with smooth boolean operation\n  // Creates a more interesting shape by subtracting torus from sphere\n  dsphere = pmax(dsphere, -(dtorus-0.05), 0.05);\n  \n  // Initialize distance to a large value\n  float d = 1E3;\n  \n  // Combine the shapes\n  d = dbox;\n  d = min(d, dsphere);\n  d = min(d, dtorus);\n  \n  // Compute glow distance\n  float gd = 1E3;\n  gd = dboxFrame;\n  gd = min(gd, dtorus);\n  \n  // Global variable to track minimum glow distance\n  // Used for creating glowing edge/surface effects\n  g_glowDistanceInsides = min(g_glowDistanceInsides, gd);\n  \n  return d;\n}\n\n// Ray marching algorithm for interior of box\n// Finds intersection point by stepping along the ray\nfloat rayMarchInsides(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n\n  // Optional backstep technique to reduce rendering artifacts\n  // Inspired by Inigo Quilez's techniques\n  // Helps smooth out issues when ray intersects surface at shallow angles\n#if defined(BACKSTEP_INSIDES)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  \n  int i;\n  for (i = 0; i < maxRayMarchesInsides; ++i) {\n    // Compute distance to nearest surface\n    float d = dfInsides(ro + rd*t);\n    \n    // Track closest approach for potential backstep\n#if defined(BACKSTEP_INSIDES)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    \n    // Stop if we're close enough to a surface\n    if (d < toleranceInsides) {\n      break;\n    }\n    \n    // Step along ray\n    t += d;\n  }\n  \n  // Backstep technique for missed rays\n#if defined(BACKSTEP_INSIDES)\n  if(i==maxRayMarchesInsides) { t=dti.y; };\n#endif  \n  \n  return t;\n}\n\n// Compute surface normal using gradient of distance field\n// Essential for lighting, reflections, and shading calculations\nvec3 normalInsides(vec3 pos) {\n  // Small offset for numerical gradient calculation\n  const vec2 eps = vec2(normalEpisolonInsides, 0.0);\n  \n  // Compute normal by sampling distance field in small directions\n  return normalize(vec3(\n      dfInsides(pos+eps.xyy)-dfInsides(pos-eps.xyy)\n    , dfInsides(pos+eps.yxy)-dfInsides(pos-eps.yxy)\n    , dfInsides(pos+eps.yyx)-dfInsides(pos-eps.yyx))\n    );\n}\n\n// Render the interior of the box\n// Handles multiple light bounces, absorption, and glow effects\nvec3 renderInsides(vec3 ro, vec3 rd, float db) {\n  // Accumulated color from multiple reflections\n  vec3 agg = vec3(0.0);\n  \n  // Reflection intensity factor\n  float ragg = 1.;\n  \n  // Total distance traveled\n  float tagg = 0.;\n    \n  // Multiple bounce light simulation\n  for (int bounce = 0; bounce < maxBouncesInsides; ++bounce) {\n    // Stop if reflection is too weak\n    if (ragg < 0.1) break;\n    \n    // Reset glow distance for this bounce\n    g_glowDistanceInsides = 1E3;\n    \n    // Find intersection point\n    float it  = rayMarchInsides(ro, rd, db);\n    float glowDistanceInsides = g_glowDistanceInsides;\n    \n    // Accumulate total distance\n    tagg += it;\n    \n    // Compute intersection point and surface normal\n    vec3 ip     = ro+rd*it;\n    vec3 in_    = normalInsides(ip);\n    \n    // Compute reflection vector\n    vec3 ir     = reflect(rd, in_);\n    \n    // Fake fresnel effect (reflection intensity based on view angle)\n    float ifre  = 1.+dot(in_,rd);\n    ifre *= ifre;\n    \n    // Color absorption using Beer's law\n    // Simulates how light is absorbed when traveling through a medium\n    const vec3 beerCol = -HSV2RGB_APPROX(vec3(beerHue+0.5, 0.5, 1.0)); \n    vec3 beer = ragg*exp(0.2*beerCol*tagg);\n    \n    // Glow color for internal edges and surfaces\n    const vec3 glowCol = HSV2RGB_APPROX(vec3(0.95, 0.7, 2E-3));\n    \n    // Add glow effect with distance-based blurring\n    // Creates soft, glowing internal edges\n    agg += glowCol*beer*((1.+tagg*tagg*4E-2)*6./max(glowDistanceInsides, 5E-4+tagg*tagg*2E-4/ragg));\n    \n    // Update reflection intensity\n    ragg *= mix(0.6, 0.8, ifre);\n    \n    // Stop reflecting if we hit a non-reflective surface\n    if (glowDistanceInsides < 2.*toleranceInsides) {\n      ragg = 0.;\n    }\n    \n    // Prepare for next bounce\n    ro = ip;        // New ray origin\n    rd = ir;        // New ray direction (reflection)\n    \n    // Adaptive step distance for next ray\n    // Helps prevent self-intersection artifacts\n    db = min(max(glowDistanceInsides,0.05), 0.25);\n  }\n  \n  return agg;\n}\n\n// Distance field function for external box\nfloat dfShapes(vec3 p) {\n  // Compute distance to solid box\n  float dbox = box(p, boxDim);\n  \n  // Compute distance to box frame for glow effect\n  float dboxFrame = boxFrame(p, boxDim, 0.) - boxEdge;\n  \n  // Initialize distance to a large value\n  float d = 1E3;\n  \n  // Set primary distance to box\n  d = dbox;\n  \n  // Soften box edges using smooth maximum operation\n  // Creates a more organic, less sharp edge appearance\n  d = pmax(d, -(dboxFrame-2.*boxEdge), 8.*boxEdge);\n  \n  // Include box frame in distance calculation\n  d = min(d, dboxFrame);\n  \n  // Track glow distance for visual effects\n  float gd = 1E3;\n  gd = dboxFrame;\n  \n  // Update global glow distance\n  // Used for creating glowing edge/surface effects\n  g_glowDistanceShapes = min(g_glowDistanceShapes, gd);\n  \n  return d;\n}\n\n// Ray marching algorithm for external box\n// Finds intersection point by stepping along the ray\nfloat rayMarchShapes(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n\n  // Optional backstep technique to reduce rendering artifacts\n#if defined(BACKSTEP_SHAPES)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  \n  int i;\n  for (i = 0; i < maxRayMarchesShapes; ++i) {\n    // Compute distance to nearest surface\n    float d = dfShapes(ro + rd*t);\n    \n    // Track closest approach for potential backstep\n#if defined(BACKSTEP_SHAPES)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    \n    // Stop if we're close to a surface or exceed max ray length\n    if (d < toleranceShapes || t > maxRayLengthShapes) {\n      break;\n    }\n    \n    // Step along ray\n    t += d;\n  }\n  \n  // Backstep technique for missed rays\n#if defined(BACKSTEP_SHAPES)\n  if(i==maxRayMarchesShapes) { t=dti.y; };\n#endif  \n  \n  return t;\n}\n\n// Compute surface normal using gradient of distance field\nvec3 normalShapes(vec3 pos) {\n  // Small offset for numerical gradient calculation\n  const vec2 eps = vec2(normalEpisolonShapes, 0.0);\n  \n  // Compute normal by sampling distance field in small directions\n  return normalize(vec3(\n      dfShapes(pos+eps.xyy)-dfShapes(pos-eps.xyy)\n    , dfShapes(pos+eps.yxy)-dfShapes(pos-eps.yxy)\n    , dfShapes(pos+eps.yyx)-dfShapes(pos-eps.yyx))\n    );\n}\n\n// Render external box and their interactions\nvec3 renderShapes(vec3 ro, vec3 rd) {\n  // Start with world background rendering\n  vec3 col = renderWorld(ro, rd);\n  \n  // Calculate distance to floor plane\n  float bt = -(ro.y-bottom)/(rd.y);\n  vec3 bp = ro+rd*bt;\n  \n  // Compute floor distance for fake shadow effect\n  float bd = dfShapes(bp);\n  \n  // Reset glow distance tracking\n  g_glowDistanceShapes = 1E3;\n  \n  // Ray march to find intersection with external box\n  float st = rayMarchShapes(ro, rd, 0.);\n  float sglowDistance = g_glowDistanceShapes; \n  \n  // Compute intersection point and surface properties\n  vec3 sp = ro+rd*st;\n  vec3 sn = normalShapes(sp);\n  \n  // Compute reflection and refraction vectors\n  vec3 sr = reflect(rd,sn);\n  vec3 srr= refract(rd,sn, refr_index);\n  \n  // Fake fresnel effect (reflection intensity based on view angle)\n  float sfre = 1.+dot(rd,+sn);\n  sfre *= sfre;\n  sfre = mix(0.05, 1.0,sfre);\n  \n  // Reflection color\n  const vec3 refCol = HSV2RGB_APPROX(vec3(beerHue, 2./3., 1./3.));\n  \n  if (st < maxRayLengthShapes && (bt < 0.0 || st < bt)) {\n    // Ray hit the object\n    // Render reflections on object's surface\n    vec3 rwcol = renderWorld(sp, sr);\n    vec3 ricol = vec3(0.);\n    \n    // Render inside of object if not hitting glow\n    if (sglowDistance > 2.*toleranceShapes) {\n      ricol = renderInsides(sp, srr, min(max(sglowDistance,0.05), 0.25))*(1.-sfre);\n    }\n    \n    // Handle total internal reflection\n    // Can occur when refraction index is > 1\n    if (srr == vec3(0.0)) {\n      col = rwcol*sqrt(sfre)*refCol;\n    } else  {\n      // Mix between inside rendering and surface reflections\n      col = mix(ricol*smoothstep(0., 0.25, sglowDistance), rwcol*refCol, sfre); \n    }\n    \n  } else if (bt > 0.0) {\n    // Ray hit the floor\n    // Apply fake shadow effect\n    col *= mix(1.0, 0.125, exp(-bd));\n  }\n  \n  // Add glow effect to the rendering\n  const vec3 glowCol = HSV2RGB_APPROX(vec3(0.66,0.5, 4E-3));\n  col += glowCol/max(sglowDistance, toleranceShapes);\n  \n  return col; \n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  // Set the starting point of the ray in 3D space\n  vec3 ro = rayOrigin;\n\n  // Define the \"up\" direction, used for camera orientation\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  // Apply a slight rotation to the ray origin for dynamic effects\n  ro.xz *= ROT(0.1 * TIME);\n\n  // Compute a time-based rotation matrix for animating objects\n  g_rot = animatedRotationMatrix(0.707 * TIME);\n\n  // Set up the ray direction using a \"look-at\" camera model\n  // Normalize the direction from the ray origin to the look-at point\n  vec3 ww = normalize(lookAt - ro);\n\n  // Compute the right vector by crossing the up vector with the direction\n  vec3 uu = normalize(cross(up, ww));\n\n  // Compute the true \"up\" vector (orthogonal to both ww and uu)\n  vec3 vv = cross(ww, uu);\n\n  // Define the field of view (FOV); larger values mean a wider view\n  const float fov = 2.0;\n\n  // Compute the ray direction for this pixel\n  // Combine the perspective (FOV) and the camera's orientation\n  vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);\n\n  // Initialize the color accumulator\n  vec3 col = vec3(0.0);\n\n  // Render the scene by tracing the ray (ro: origin, rd: direction)\n  col = renderShapes(ro, rd);\n\n  // Saturate the colors a bit\n  col -= 0.03 * vec3(2.0, 3.0, 1.0) * (length(p) + 0.25);\n\n  // Apply a vignette effect to darken edges of the screen\n  col *= smoothstep(1.7, 0.8, length(pp));\n\n  // Tone map the color from high dynamic range (HDR) to standard [0,1] range\n  col = aces_approx(col);\n\n  // Simulate a gamma correction for RGB to sRGB conversion\n  col = sqrt(col);\n\n  // Return the final color\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize fragment coordinates to a [0,1] range\n  vec2 q = fragCoord / RESOLUTION.xy;\n\n  // Map coordinates to a [-1,1] range for ray tracing\n  vec2 p = -1.0 + 2.0 * q;\n\n  // Keep a copy of the original coordinates for effects like vignette\n  vec2 pp = p;\n\n  // Correct the aspect ratio of the coordinates\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n\n  // Initialize the final color\n  vec3 col = vec3(0.0);\n\n  // Compute the color for this fragment using the effect function\n  col = effect(p, pp);\n\n  // Output the final color with full alpha (1.0)\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}