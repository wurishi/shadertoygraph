{"ver":"0.1","info":{"id":"DsG3DD","date":"1678510000","viewed":88,"name":"weird cube thing","username":"benjidial","description":"this started as a raymarcher, and then turned into something else - try changing the values of prec in Buffers A and B","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy)\n            + texture(iChannel1, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//inputs\n\nconst vec4 cubeCenter = vec4(0.0, 0.0, 0.0, 1.0);\nconst float cubeRadius = 1.0;\n\nconst vec4 sphereCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat sphereRadius(float time) {\n  return sin(time) + 1.0;\n}\n\nconst vec4 lightPos = vec4(2.0, 10.0, 3.0, 1.0);\n\nconst vec3 shapeDiffusionColor = vec3(1.0, 0.0, 0.0);\n\nconst vec4 camPos = vec4(3.0, 3.0, 3.0, 1.0);\nconst vec4 camTarget = cubeCenter;\nconst float camVertFovDegrees = 40.0;\n\nconst float maxRenderDist = 10.0;\nconst float prec = 0.0002;\n\n//calculated from inputs\n\nconst vec4 camForward = normalize(camTarget - camPos);\nconst vec4 camForwardFlat = normalize(camForward.xwzw);\nconst float camTheta = asin(camForward.y);\nconst vec4 camUp = -sin(camTheta) * camForwardFlat + vec4(0.0, cos(camTheta), 0.0, 0.0);\nconst vec4 camRight = vec4(cross(camForward.xyz, camUp.xyz), 0.0);\n\nconst vec4 cpCenter = camPos + camForward;\nconst float camVertFov = camVertFovDegrees * 3.14159 / 180.0;\nconst float cpHeight = 2.0 * tan(camVertFov / 2.0);\n\n//functions\n\nvec2 clampToSquare(vec2 point, vec2 squareCenter, float squareRadius) {\n  return clamp(point, squareCenter - squareRadius, squareCenter + squareRadius);\n}\n\nvec4 nearestCubePoint(vec4 pos) {\n  vec2 xyClamp = clampToSquare(pos.xy, cubeCenter.xy, cubeRadius);\n  vec2 xzClamp = clampToSquare(pos.xz, cubeCenter.xz, cubeRadius);\n  vec2 yzClamp = clampToSquare(pos.yz, cubeCenter.yz, cubeRadius);\n  \n  vec4 candidates[6] = vec4[](\n    vec4(xyClamp, cubeCenter.z - cubeRadius, 1.0),\n    vec4(xyClamp, cubeCenter.z + cubeRadius, 1.0),\n    vec4(xzClamp.x, cubeCenter.y - cubeRadius, xzClamp.y, 1.0),\n    vec4(xzClamp.x, cubeCenter.y + cubeRadius, xzClamp.y, 1.0),\n    vec4(cubeCenter.x - cubeRadius, yzClamp, 1.0),\n    vec4(cubeCenter.x + cubeRadius, yzClamp, 1.0)\n  );\n\n  vec4 choice;\n  float dist = maxRenderDist;//hmm\n\n  for (int i = 0; i < 6; ++i)\n    if (distance(candidates[i], pos) < dist) {\n      dist = distance(candidates[i], pos);\n      choice = candidates[i];\n    }\n\n  return choice;\n}\n\nvec4 nearestSpherePoint(vec4 pos) {\n  return sphereCenter + sphereRadius(iTime) * normalize(pos - sphereCenter);\n}\n\nvec4 nearestPoint(vec4 pos) {\n  vec4 cp = nearestCubePoint(pos);\n  vec4 sp = nearestSpherePoint(pos);\n  return (cp + sp) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 cpOffset = (fragCoord - 0.5 * iResolution.xy) * cpHeight / iResolution.y;\n  vec4 cpHit = cpCenter + cpOffset.x * camRight + cpOffset.y * camUp;\n\n  vec4 rayDir = normalize(cpHit - camPos);\n  vec4 rayPos = camPos;\n\n  while (length(rayPos) < maxRenderDist) {\n    vec4 shapePoint = nearestPoint(rayPos);\n    float dist = distance(rayPos, shapePoint);\n    if (dist < prec) {\n      vec4 shapeNormal = normalize(rayPos - shapePoint);\n      vec4 lightDir = normalize(lightPos - shapePoint);\n      vec3 diffusion = shapeDiffusionColor * dot(shapeNormal, lightDir);\n      fragColor = vec4(diffusion, 1.0);\n      return;\n    }\n    rayPos += rayDir * dist;\n  }\n  \n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//inputs\n\nconst vec4 cubeCenter = vec4(0.0, 0.0, 0.0, 1.0);\nconst float cubeRadius = 1.0;\n\nconst vec4 sphereCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat sphereRadius(float time) {\n  return sin(time) + 1.0;\n}\n\nconst vec4 lightPos = vec4(2.0, 10.0, 3.0, 1.0);\n\nconst vec3 shapeDiffusionColor = vec3(0.0, 1.0, 0.0);\n\nconst vec4 camPos = vec4(3.0, 3.0, 3.0, 1.0);\nconst vec4 camTarget = cubeCenter;\nconst float camVertFovDegrees = 40.0;\n\nconst float maxRenderDist = 10.0;\nconst float prec = 0.0003;\n\n//calculated from inputs\n\nconst vec4 camForward = normalize(camTarget - camPos);\nconst vec4 camForwardFlat = normalize(camForward.xwzw);\nconst float camTheta = asin(camForward.y);\nconst vec4 camUp = -sin(camTheta) * camForwardFlat + vec4(0.0, cos(camTheta), 0.0, 0.0);\nconst vec4 camRight = vec4(cross(camForward.xyz, camUp.xyz), 0.0);\n\nconst vec4 cpCenter = camPos + camForward;\nconst float camVertFov = camVertFovDegrees * 3.14159 / 180.0;\nconst float cpHeight = 2.0 * tan(camVertFov / 2.0);\n\n//functions\n\nvec2 clampToSquare(vec2 point, vec2 squareCenter, float squareRadius) {\n  return clamp(point, squareCenter - squareRadius, squareCenter + squareRadius);\n}\n\nvec4 nearestCubePoint(vec4 pos) {\n  vec2 xyClamp = clampToSquare(pos.xy, cubeCenter.xy, cubeRadius);\n  vec2 xzClamp = clampToSquare(pos.xz, cubeCenter.xz, cubeRadius);\n  vec2 yzClamp = clampToSquare(pos.yz, cubeCenter.yz, cubeRadius);\n  \n  vec4 candidates[6] = vec4[](\n    vec4(xyClamp, cubeCenter.z - cubeRadius, 1.0),\n    vec4(xyClamp, cubeCenter.z + cubeRadius, 1.0),\n    vec4(xzClamp.x, cubeCenter.y - cubeRadius, xzClamp.y, 1.0),\n    vec4(xzClamp.x, cubeCenter.y + cubeRadius, xzClamp.y, 1.0),\n    vec4(cubeCenter.x - cubeRadius, yzClamp, 1.0),\n    vec4(cubeCenter.x + cubeRadius, yzClamp, 1.0)\n  );\n\n  vec4 choice;\n  float dist = maxRenderDist;//hmm\n\n  for (int i = 0; i < 6; ++i)\n    if (distance(candidates[i], pos) < dist) {\n      dist = distance(candidates[i], pos);\n      choice = candidates[i];\n    }\n\n  return choice;\n}\n\nvec4 nearestSpherePoint(vec4 pos) {\n  return sphereCenter + sphereRadius(iTime / sqrt(2.0)) * normalize(pos - sphereCenter);\n}\n\nvec4 nearestPoint(vec4 pos) {\n  vec4 cp = nearestCubePoint(pos);\n  vec4 sp = nearestSpherePoint(pos);\n  return (cp + sp) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 cpOffset = (fragCoord - 0.5 * iResolution.xy) * cpHeight / iResolution.y;\n  vec4 cpHit = cpCenter + cpOffset.x * camRight + cpOffset.y * camUp;\n\n  vec4 rayDir = normalize(cpHit - camPos);\n  vec4 rayPos = camPos;\n\n  while (length(rayPos) < maxRenderDist) {\n    vec4 shapePoint = nearestPoint(rayPos);\n    float dist = distance(rayPos, shapePoint);\n    if (dist < prec) {\n      vec4 shapeNormal = normalize(rayPos - shapePoint);\n      vec4 lightDir = normalize(lightPos - shapePoint);\n      vec3 diffusion = shapeDiffusionColor * dot(shapeNormal, lightDir);\n      fragColor = vec4(diffusion, 1.0);\n      return;\n    }\n    rayPos += rayDir * dist;\n  }\n  \n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}