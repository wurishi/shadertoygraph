{"ver":"0.1","info":{"id":"md3cWs","date":"1695651786","viewed":59,"name":"M1 informatique graphique","username":"AbdelazizHerda","description":"Practice","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Torus{\n    vec3 center;// Center\n    float r;// Radius of the tube\n    float R;// Radius from center\n    int i;// Texture Id\n};\n\nstruct Box{\n    vec3 min; // Min corner\n    vec3 max; // Max corner\n    int i;    // Texture Id\n};\n\nstruct Capsule{\n    vec3 a; // First point\n    vec3 b; // Second point\n    float r; // Radius\n    int i; // Texture Id\n};\n\nstruct Cylindre{\n    vec3 origin; // Center\n    float height; // Height\n    float radius; // Radius\n    int i; // Texture Id\n};\n\nstruct Ellipsoide{\n    vec3 center; // Center\n    vec3 radii;  // x, y, z directions\n    int i; // Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nMaterial UniformTexture() {\n    return Material(vec3(1.0, 0.5, 0.2));  // Par exemple, une couleur orange\n}\n\nMaterial CheckerTexture(vec3 p, float size) {\n    vec3 blackColor = vec3(0.0, 0.0, 0.0);\n    vec3 whiteColor = vec3(1.0, 1.0, 1.0);\n    vec3 pattern = mod(floor(p / size), 2.0);\n    float checker = mod(pattern.x + pattern.y + pattern.z, 2.0);\n    vec3 col = mix(blackColor, whiteColor, checker);\n    return Material(col);\n}\n\nMaterial CentricTexture(vec3 p) {\n    float r=sqrt(p.x+p.y);\n    float color = 1.5 + 0.5 * cos (13.1415927 * r ) ;\n    return Material(vec3(color, 2.0 - color, 1.0));\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {   \n        return CheckerTexture(p, 0.2);    \n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col);\n    }\n    else if(i==2)\n    {\n        return UniformTexture();\n    }\n    else if(i==3) \n    {\n        return CentricTexture(p);\n    }\n    return Material(vec3(0));\n}\n\n//rotate ray\nRay rotateRay(Ray ray, mat3 m)\n{\n    Ray newRay;\n    newRay.o = (ray.o) * m;\n    newRay.d = (ray.d) * m;\n    return newRay;\n}\n\nRay translateRay(Ray ray, vec3 t)\n{\n    Ray newRay;\n    newRay.o = ray.o + t;\n    newRay.d = ray.d;\n    return newRay;\n}\n\nRay rayHomothesis(Ray ray, vec3 t)\n{\n    Ray newRay;\n    newRay.o = (ray.o * t);\n    newRay.d = (ray.d * t);\n    return newRay;\n}\n\n\n// Sphere intersection \n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 translation = vec3(1.0, 3.0, -3.0);\n  \n    \n    vec3 oc=(ray.o-sph.c);\n    vec3 od = ray.d;\n    float b=dot(oc,od);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Cylindre intersection\n// ray : the ray\n//   x : returned intersection information\nbool IntersectCylinder(Ray ray, Cylindre cy, out Hit x)\n{\n    float minSol = 1000.0;\n    vec3 normal;\n    vec3 ro = (ray.o - cy.origin);\n    vec3 rd = ray.d;\n    \n    // calcul des coefficients de l'equation du second degré\n    // t²(rd.x² + rd.y²) + 2t(ro.x * rd.x + ro.y * rd.y) + ro.x² + ro.y² - r² = 0\n    float a = rd.x * rd.x + rd.y * rd.y;\n    float b = 2.0 * (rd.x * ro.x + rd.y * ro.y);\n    float c = ro.x * ro.x + ro.y * ro.y - cy.radius * cy.radius;\n        \n    float det = b*b - 4.0*a*c;\n\n    if (det > 0.0) {\n        float x1 = (-b - sqrt(det)) / (2.0 * a);\n        float x2 = (-b + sqrt(det)) / (2.0 * a);\n    \n        // Check voir si x1 est une solution valide\n        float z1 = ro.z + x1 * rd.z;\n        if (x1 > 0.0 && z1 >= 0.0 && z1 <= cy.height) {\n            minSol = x1;\n            normal = normalize(vec3(ro.x + x1 * rd.x, ro.y + x1 * rd.y, 0.0));\n            x = Hit(minSol, normal, cy.i);\n            return true;\n        }\n\n        // voir si x2 est une solution valide\n        float z2 = ro.z + x2 * rd.z;\n        if (x2 > 0.0 && z2 >= 0.0 && z2 <= cy.height) {\n            if (x2 < minSol) {\n                minSol = x2;\n                normal = normalize(vec3(ro.x + x2 * rd.x, ro.y + x2 * rd.y, 0.0));\n                x = Hit(minSol, normal, cy.i);\n                return true;\n            }\n        }\n\n    }\n    for (float sign = 1.0; sign >= -1.0; sign -= 2.0) {\n        float t = (sign * cy.height - ro.z) / rd.z;\n        vec3 p = ro + t * rd;\n        if (t > 0.0 && dot(p, p) <= cy.radius * cy.radius) {\n            if (t < minSol) {\n                minSol = t;\n                normal = vec3(0.0, 0.0, sign);\n            }\n        }\n    }\n\n    if (minSol < 1000.0) {\n        x = Hit(minSol, normal, cy.i);\n        return true;\n    }    \n    return false;\n}\n\n// Box intersection\n// ray : the ray\n//   x : returned intersection information\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    vec3 invDir = 1.0 / ray.d;\n    vec3 tNear = (box.min - ray.o) * invDir;\n    vec3 tFar = (box.max - ray.o) * invDir;\n    vec3 tMin = min(tNear, tFar);\n    vec3 tMax = max(tNear, tFar);\n    \n    float t0 = max(max(tMin.x, tMin.y), tMin.z);\n    float t1 = min(min(tMax.x, tMax.y), tMax.z);\n    \n    if (t0 > t1 || t1 < 0.) {\n        return false;\n    }\n    \n    float t = (t0 > 0.) ? t0 : t1;\n    vec3 point = Point(ray, t);\n    \n\n    vec3 normal;\n    if (abs(point.x - box.min.x) < 0.001) {\n        normal = vec3(-1.0, 0.0, 0.0);\n    } else if (abs(point.x - box.max.x) < 0.001) {\n        normal = vec3(1.0, 0.0, 0.0);\n    } else if (abs(point.y - box.min.y) < 0.001) {\n        normal = vec3(0.0, -1.0, 0.0);\n    } else if (abs(point.y - box.max.y) < 0.001) {\n        normal = vec3(0.0, 1.0, 0.0);\n    } else if (abs(point.z - box.min.z) < 0.001) {\n        normal = vec3(0.0, 0.0, -1.0);\n    } else if (abs(point.z - box.max.z) < 0.001) {\n        normal = vec3(0.0, 0.0, 1.0);\n    }\n    \n    x = Hit(t, normal, box.i);\n    return true;\n}\n\n\n// Hellipsoide intersection\n// ray : the ray\n//   x : returned intersection information\nbool IntersectEllipsoide(Ray ray, Ellipsoide ell, out Hit x) \n{\n    float minSol = 1000.0;\n    vec3 normal;\n    vec3 ro = ray.o - ell.center;\n    vec3 rd = ray.d; \n  \n    // implémentation de l'equation (x - v)^(-1) A (x - v) = 1\n    // ou bien (x/a)^2 + (y/b)^2 + (z/c)^2 - 1 = 0\n    vec3 invRell = 1.0/ell.radii; // Le vecteur de invRell devient (1/a, 1/b, 1/c)\n    // mettre à l'echelle ro et rd \n    vec3 origin_over_radii = ro * invRell;\n    vec3 dest_over_radii = rd * invRell;\n    // calcule des coefficients de l'equation du second degré\n    float a = dot(dest_over_radii, dest_over_radii);\n    float b = 2.0 * dot(origin_over_radii, dest_over_radii);\n    float c = dot(origin_over_radii, origin_over_radii) - 1.0;\n\n    float det = b*b - 4.0*a*c;\n    if (det > 0.0) {\n        float sol1 = (-b - sqrt(det)) / (2.0 * a);\n        float sol2 = (-b + sqrt(det)) / (2.0 * a);\n        if (sol1 > 0.0) {\n            minSol = sol1;\n            normal = normalize(vec3(ro.x + sol1 * rd.x, ro.y + sol1 * rd.y, ro.z + sol1 * rd.z));\n            x = Hit(minSol, normal, ell.i);\n            return true;\n        }\n        if (sol2 > 0.0) {\n            minSol = sol2;\n            normal = normalize(vec3(ro.x + sol2 * rd.x, ro.y + sol2 * rd.y, ro.z + sol2 * rd.z));\n            x = Hit(minSol, normal, ell.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    float tMin = 0.0;\n    float tMax = 1000.0; \n    float eps = 0.01;\n\n    for(int i = 0; i < 200; ++i) { \n        vec3 p = Point(ray, tMin);\n        vec3 pa = p - cap.a;\n        vec3 ba = cap.b - cap.a;\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        float dist = length(pa - ba * h) - cap.r;\n\n        if (dist < eps) {\n            x = Hit(tMin, normalize(p - (cap.a + ba * h)), cap.i);\n            return true;\n        }\n\n        tMin += dist;\n\n        if (tMin >= tMax) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n// Torus intersection\n// ray : the ray\n//   x : returned intersection information\n// This is based on the ray marching implementation from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nbool IntersectTorus(Ray ray, Torus tor, out Hit x) {\n    float tMin = 0.0;\n    float tMax = 1000.0; \n    float epsilon = 0.01; \n\n    for(int i = 0; i < 100; ++i) {\n        vec3 p = Point(ray, tMin);\n        vec3 localP = p - tor.center;\n        localP = localP /*+ translation*/;\n        vec2 q = vec2(length(localP.xz)-tor.r, localP.y);\n        float dist = length(q) - tor.R;\n\n        if (dist < epsilon) {\n            vec3 nor = normalize(vec3(\n                length(vec2(length(vec3(localP.x + epsilon, localP.y, localP.z).xz)-tor.r, vec3(localP.x + epsilon, localP.y, localP.z).y)) - tor.R - dist,\n                length(vec2(length(vec3(localP.x, localP.y + epsilon, localP.z).xz)-tor.r, vec3(localP.x, localP.y + epsilon, localP.z).y)) - tor.R - dist,\n                length(vec2(length(vec3(localP.x, localP.y, localP.z + epsilon).xz)-tor.r, vec3(localP.x, localP.y, localP.z + epsilon).y)) - tor.R - dist\n            ));\n\n            x = Hit(tMin, nor, tor.i);\n            return true;\n        }\n\n        tMin += dist;\n\n        if (tMin >= tMax) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    const Sphere sph1=Sphere(vec3(1.,10.,1.),1.,1); \n    const Sphere sph2=Sphere(vec3(3.5,1.,1.),1.,1);\n    const Cylindre cy = Cylindre(vec3(1.0, 1.0, 4.0), 1.0, 0.5, 3);    \n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    const Ellipsoide ell = Ellipsoide(vec3(-2.0, 5.0, 3.0), vec3(1.0, 0.50, 0.50), 2);\n    const Torus tor = Torus(vec3(3.0, 4.0, 3.0), 0.5, 0.25, 2);\n    const Capsule capsule = Capsule(vec3(3., 2., 1.5), vec3(1., 2., 2.5), 0.5, 2);\n    const Box box = Box(vec3(-1.,-1.,1.), vec3(0.5,0.5,2.5), 1); \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n        mat3 rotationMatrix = mat3(\n        cos(iTime), -sin(iTime), 0.0,\n        sin(iTime), cos(iTime), 0.0,\n        0.0, 0.0, 1.0\n    );\n    Ray rotatedRay = rotateRay(ray, rotationMatrix);\n    vec3 translation = vec3(sin(iTime) * 3.5, 0., 0.);\n    Ray translatedRay = translateRay(ray, translation);\n    vec3 scale = vec3(1.0 + sin(iTime)/2.0, 1.0, 1.0);\n    Ray rayHomothesis = rayHomothesis(ray, scale);\n\n    /*if(IntersectSphere(newRay,sph1,current)&&current.t<x.t){\n        current.n = normalize(rotationMatrix * current.n);\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(newRay,sph2,current)&&current.t<x.t){\n        current.n = normalize(rotationMatrix * current.n);\n        x=current;\n        ret=true;\n    }*/\n    \n    if(IntersectCylinder(ray,cy,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectEllipsoide(rayHomothesis,ell,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectTorus(translatedRay,tor,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectBox(ray, box, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    \n    if(IntersectCapsule(rotatedRay, capsule, current) && current.t < x.t){\n        current.n = normalize(rotationMatrix * current.n);\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    return ret;\n}\n\nvec3 Hemisphere(int seed,vec3 n)\n\n{\n\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n\n    float b=fract(sin(164.19*float(seed)));\n\n\n\n    float u=2.*3.1415*a;// Random angle\n\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n\n\n    return d;\n\n}\n\n// ambient occlusion\n// p : Point\n// n : Normal\n// k : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int k)\n{\n    float r=0.;\n    for(int i=0;i<k;++i)\n    {\n        vec3 d=Hemisphere(k+i,n);\n        Hit osef;\n        if(Intersect(Ray(p+0.1,d),osef))\n        {\n            r+=1.;\n        }\n    }\n    return 1.-r/float(k);\n}\n\n// Phong illumination\n// l : Light direction\n// v : View direction\n// n : Normal\n// r : Reflected light direction\n// m : Material\nvec3 Phong(vec3 l,vec3 v,vec3 n,vec3 r,Material m)\n{\n    float diff=clamp(dot(n,l),0.,1.); // Couleur de l'ombre\n    //ambient\n    vec3 ambient=m.d*.1*diff;\n    //diffuse\n    float d=max(0.,dot(n,l));\n    vec3 diffuse=d*m.d;\n    //specular\n    float s=pow(max(0.,dot(v,r)),10.);\n    vec3 specular=s*vec3(1.);\n    return ambient+diffuse+specular;\n}\n\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.0,.0,.0),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n \n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n, vec3 p)\n{\n    vec3 light=normalize(vec3(0,0.5,0.5));\n    Hit osef;\n    if(!Intersect(Ray(p+n*0.01,light),osef)){\n    vec3 col=Phong(light,normalize(-p),n,normalize(light-2.*n*dot(n,light)),m);\n    col += vec3(0.1, 0.1, 0.1);\n    col *= AmbientOcclusion(p,n,64);\n    return col;\n    }\n    else{\n    return vec3(.1,.1,.1);\n    }\n}\n\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        return Color(mat,x.n, p);\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}