{"ver":"0.1","info":{"id":"M3tSRB","date":"1719263593","viewed":59,"name":"Neural CA Pt.1","username":"26apastor","description":"My first attempt at a cellular automata using a neural network.\nUV Gradient (0.0, 1.0)","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","neural"],"hasliked":0,"parentid":"dsGyzK","parentname":"Lenia Pt.4 (Optimized)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float con = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col = vec4(pow(col.x, con), pow(col.y, con), pow(col.z, con), 1.0);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float max_radius = 1.0;\nconst float noise_radius = 10.0;\nconst float mouse_radius = 10.0;\nconst float invRadius = 0.1;\nconst float rt2Rad = 0.14142135;\nconst float T = 5.0;\nconst float rho = 0.5;\nconst float omega = 0.15;\nconst float noise_base = 0.15;\n\nconst float nop = 0.0;\n\nvec3 top_weight1    = vec3( -0.05, -0.2, -1.0); float bias1 = 0.4;\nvec3 mid_weight1    = vec3(-0.7, 0.2,-0.2); \nvec3 bottom_weight1 = vec3( 0.09, -0.4, 0.1); \n\nvec3 top_weight2    = vec3( 0.4, 0.9, 0.3); float bias2 = -0.8;\nvec3 mid_weight2    = vec3(0.5, -0.5,-0.1); \nvec3 bottom_weight2 = vec3( -0.2, -0.9, 0.1); \n\nvec3 top_weight3    = vec3( -0.3, 0.7, -0.02); float bias3 = 0.2;\nvec3 mid_weight3    = vec3(0.9, -0.5, 0.6); \nvec3 bottom_weight3 = vec3( -0.2, 0.08, -0.3); \n\nvec3 final_weight = vec3(0.8, -0.5, -0.4); float final_bias = -0.2;\n\nvec3 gaussian_bell(vec3 x, vec3 m, vec3 s) {\n    return exp(-(((x - m) * (x - m)) / s) / s / 2.0);\n}\n\nfloat gaussian_bell(float x, float m, float s) {\n    return exp(-pow((x - m) / s, 2.0) / 2.0);\n}\n\nfloat activation(float sum, vec2 fragCoord) {\n    return fragCoord.x / iResolution.x + -1.0/sum;\n}\n\nfloat getCell(vec2 xy) {\n    xy = mod(xy / iResolution.xy, 1.0);\n    vec3 rgb = texture(iChannel0, xy).rgb;\n    return rgb.r + rgb.g + rgb.b;\n}\n\nvec3 getColor(float g) {\n    vec3 c1 = vec3(gaussian_bell(g, 1.0, 0.5), gaussian_bell(g, 0.0, 0.5), gaussian_bell(g, -1.0, 0.5));\n    float s1 = c1.r + c1.g +  c1.b;\n    return c1 / s1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 sum = vec3(0.0);\n    \n    for (float x = -max_radius; x <= max_radius; x++) {\n        int coord = int(x+max_radius);\n        sum.x += getCell(fragCoord + vec2(x,  1.0)) * top_weight1[coord];\n        sum.x += getCell(fragCoord + vec2(x,  0.0)) * mid_weight1[coord];\n        sum.x += getCell(fragCoord + vec2(x, -1.0)) * bottom_weight1[coord] + bias1;\n        sum.x = activation(sum.x, fragCoord);\n        \n        sum.y += getCell(fragCoord + vec2(x,  1.0)) * top_weight2[coord];\n        sum.y += getCell(fragCoord + vec2(x,  0.0)) * mid_weight2[coord];\n        sum.y += getCell(fragCoord + vec2(x, -1.0)) * bottom_weight2[coord] + bias2;\n        sum.y = activation(sum.y, fragCoord);\n        \n        sum.z += getCell(fragCoord + vec2(x,  1.0)) * top_weight3[coord];\n        sum.z += getCell(fragCoord + vec2(x,  0.0)) * mid_weight3[coord];\n        sum.z += getCell(fragCoord + vec2(x, -1.0)) * bottom_weight3[coord] + bias3;\n        sum.z = activation(sum.z, fragCoord);\n    }\n    \n    float final = activation(sum.x * final_weight.x + sum.y * final_weight.y + sum.z * final_weight.z + final_bias, fragCoord); vec3 c = getColor(final);\n    \n    vec4 pc = texture(iChannel0, uv);\n    vec3 color = clamp(pc.x + pc.y + pc.z + sum / T, 0.0, 1.0) * c;\n    \n    if (iFrame < 1)\n        color = vec3(noise_base + noise(fragCoord/noise_radius + mod(iDate.w,1.)*100.));\n    if (iMouse.z > 0.) {\n        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);\n        if (d <= mouse_radius/iResolution.x)\n        \tcolor = vec3(0.3 + noise(fragCoord/mouse_radius + mod(iDate.w,1.)*100.));\n    }\n    fragColor = clamp(vec4(color, 1.0), -1.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Chakazul's use of this hash function is genius and all credits to him in his implementation of lenia: https://www.shadertoy.com/user/Chakazul\n*/\n\n// Noise simplex 2D by iq - https://www.shadertoy.com/view/Msf3WH\n\nfloat sine(float x) {\n    float continuation = mod(x, 3.14159265359) - 1.57079632679;\n    float a = continuation/2.6;\n    return continuation * (1.0 - a * a) * (2.0 * floor(mod(x/3.14159265359, 2.0)) - 1.0);\n}\n\nvec2 sine(vec2 xy) {\n    return vec2(sine(xy.x), sine(xy.y));\n}\n\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sine(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}","name":"Common","description":"","type":"common"}]}