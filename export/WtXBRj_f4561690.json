{"ver":"0.1","info":{"id":"WtXBRj","date":"1597202268","viewed":75,"name":"My Shader - In Progress","username":"PierceV32","description":"My Shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//THIS CODE HAS BEEN MODIFIED FROM ITS ORIGINAL SOURCE (THE ORIGINAL IS NOT BY ME)\n\n\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed 0.0  //disk rotation speed\n\n#define _Steps  0. //disk texture layers\n#define _Size 1.1 //size of BH\n\n#define _MaxDistance 15.0\n\n//#define _BHSize = 10.0\n\nfloat hash(float x){ return fract(sin(x)*152754.742);}\n//float hash(vec2 x){\treturn hash(x.x + hash(x.y));}\n\n//float hash(float x){ return fract(sin(x)*15.0); }\nfloat hash(vec2 x){\treturn hash(x.x + hash(x.y)); }\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;\t\n    float b = mix(bl, br, fr.x);\t\n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\n/*bool isInBox(vec3 pos, vec3 boxPos, vec3 box)\n{\n    bool isInBox = true;\n    \n\tif (pos.x )\n        \n    return isInBox;\n}*/\n\nfloat sdSphere(vec3 pos, float radius, vec3 spherePos)\n{\n    //if (abs(pos.x - spherePos.x))\n    return length(pos-spherePos) - radius;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos, in vec3 spherePos)\n{\n    float M_PI = 3.1416;\n\tvec3 p = pos-spherePos;\n\tfloat phi = atan(p.z, p.x);\n\tfloat theta = asin(p.y);\n\tfloat u = 1.0 - (phi + M_PI) / (2.0 * M_PI);\n\tfloat v = (theta + M_PI / 2.0) / M_PI;\n\treturn vec2(u,v);\n}\n\n\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*3., 100.); //(poor quality) \"stars\" created from value noise\n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    //vec4 nebulae = texture(iChannel0, (uv*1.5 ));\n    //nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    //nebulae.xyz *= 0.25;\n    \n    /*nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n \n\tnebulae.xyz += stars;*/\n\t//return vec4(stars, 1.0);\n    if (brightness < 0.00) { brightness = 0.00; }\n    return vec4(brightness, brightness, brightness, 1.0);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 raymarch(vec3 ray, vec3 camPos)\n{   \n    \n    vec3 BHPos = vec3(-2.0,0.0,0.0);\n    vec3 spherePos = vec3(2.0,0.0,0.0);\n    vec3 spherePos2 = vec3(0.0,0.0,2.0);\n    vec3 spherePos3 = vec3(0.0,0.0,-2.0);\n    \n    int steps = 7000;\n    float stepSize = 0.05;\n    float BHRadius = 0.14;\n    float sphereRadius = 0.25;\n    float sphereRadius2 = 0.1;\n    float sphereRadius3 = 0.25;\n    \n    vec3 position = camPos;\n    //position -= float(sphereSteps)*ray*0.5; \n    \n    vec4 color = vec4(0.0);\n    \n    for(int i = 0; i < steps; i++)\n    {              \n        \n        float dotpos = dot(position,BHPos);\n        float dist = length(BHPos-position);\n        float invDist = 1.0/dist; //1/distance to BH\n        //float centDist = dotpos * invDist; \t//distance to BH\n        float centDist = dist;\n        float stepDist = 1.0; //0.92  //conservative distance to disk (y==0)   \n        float farLimit = centDist * 1.5; //limit step size far from to BH\n        float closeLimit = centDist*BHRadius + BHRadius/2.0*centDist*centDist*(1./_Size); //limit step size closse to BH\n        stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n        float invDistSqr = invDist * invDist;\n        float forceK = 0.007; //0.625;\n        float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n        ray = normalize(ray - (bendForce * invDist )*position);  //bend ray towards BH\n\n        position += stepSize * ray;\n        \n        dist = length(BHPos-position);\n        \n        float sphDist = sdSphere(position, sphereRadius, spherePos);\n        float sphDist2 = sdSphere(position, sphereRadius2, spherePos2);\n        float sphDist3 = sdSphere(position, sphereRadius3, spherePos3);\n        \n        if(dist < _Size*BHRadius) //ray sucked in to BH\n        {\n            color = vec4(0.0, 0.0, 0.0, 1.0);\n        \treturn color;\n        }\n\n        if(dist >= _MaxDistance || i == steps-1) //ray escaped BH\n        {     \n            color = background(ray);\n            //color = vec4(0.0);\n            return color;\n        }\n        \n        if (dist >= _Size*BHRadius && dist < _Size*0.5 && abs(position.y-BHPos.y) < _Size*0.005) //ray hit accretion disk\n        {         \n            color = vec4(1.0,1.0,0.0,1.0);\n            return color;\n            //vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n            //pos.y = 0.;\n            //pos += abs(_Size * 0.001 /ray.y) * ray;  \n            //col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n        }\n            \n        if (sphDist < sphereRadius)\n        {       \n            /*while (sphDist < sphereRadius) {\n        \t\tspherePos -= ray * sphereRadius*0.1; \n                sphDist = sdSphere(position, sphereRadius, spherePos);\n        \t}*/\n            vec3 lightDir = normalize(spherePos-spherePos2);\n            float lightDot = dot(spherePos-position,lightDir)+0.2;\n            color = vec4(0.0, lightDot, lightDot, 1.0);  \n        \treturn color;   \n        }\n        \n        if (sphDist2 < sphereRadius2) \n        {           \n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            \n            //vec2 uv = getSphereUV(position, spherePos2);\n            //float random = rand(uv);\n            //color = vec4(random, random, random, 1.0);\n            //color = vec4(random, 0.0, 0.5, 1.0);\n            \n            /*float h = max(0.0, 1.4 - y - pow(abs(x - 0.5), 3.0));\n\t\t\tcolor.r = pow(h, 3.0);\n\t\t\tcolor.g = pow(h, 7.0);\n\t\t\tcolor.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);*/\n        \treturn color;   \n        }\n        \n        else if (sphDist3 < sphereRadius3) \n        {           \n            vec3 lightDir = normalize(spherePos3-spherePos2);\n            float lightDot = dot(spherePos3-position,lightDir)+0.2;\n            color = vec4(lightDot, 0.0, 0.0, 1.0);  \n            \n            /*vec2 uv = getSphereUV(position, spherePos3);\n            //color = vec4(uv.x, 0.0, uv.y, 1.0);\n            color = texture(iChannel0, vec2(uv.x, uv.y));\n            color = vec4(color.r*lightDot, color.g*lightDot, color.b*lightDot, 1.0);\n        \t*/\n\t\t\treturn color;   \n        }\n        \n    } \n \n    //o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    //return o ;\n    \n \treturn color;   \n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 rayDir = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 camPos = vec3(0.0,0.0,-10.0);  //-12.0\n        //vec3 rayDir = normalize(vec3(0.0, 0.0, 1.0));\n        vec2 angle = vec2(0.07*iTime,0.14); //*iTime     \n        //float dist = length(camPos);\n        Rotate(camPos,angle);\n        Rotate(rayDir,angle);\n\n        vec4 col = vec4(1.0, 0.0, 1.0, 1.0); \n        vec4 glow = vec4(0.); \n        vec4 outCol = vec4(100.);\n        \n        //vec4 sphereColor = raymarchSphere(rayDir, camPos, spherePos);\n        //outCol = sphereColor;\n        //return;\n        \n        vec4 sphereColor = raymarch(rayDir, camPos);\n        colOut = sphereColor;\n        \n        return;\n\n        //for (int h = 0; h < 32; h++) //reduces tests for exit conditions (to minimise branching)\n            //{\n                /*float dotpos = dot(BHPos,camPos);\n                float dist = length(BHPos-camPos);\n                float invDist = 1.0/dist; //1/distance to BH\n                float centDist = dotpos * invDist; \t//distance to BH\n                float stepDist = 0.92 * abs(pos.y /(pos.y));  //conservative distance to disk (y==0)   \n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n                float invDistSqr = invDist * invDist;\n                float forceK = 0.025; //0.625;\n                float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n                rayDir =  normalize(rayDir - (bendForce * invDist )*pos);  //bend ray towards BH\n                pos += stepDist * rayDir; */\n                \n                //glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            //}\n\n            /*float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.1) //ray sucked in to BH\n            {\n                //outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;\n                outCol = vec4(1.0);\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {     \n                outCol = vec4(1.0, 0.0, 0.0, 0.5);\n                //vec4 bg = background(ray);\n                //outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);\n                break;\n            }\n            \n            else  //ray hit accretion disk\n            {           \n                vec4 sphereColor = raymarchSphere(rayDir, camPos, spherePos);\n                outCol = sphereColor;\n                //col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }*/\n        \n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n","name":"Image","description":"","type":"image"}]}