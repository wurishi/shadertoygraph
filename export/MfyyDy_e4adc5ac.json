{"ver":"0.1","info":{"id":"MfyyDy","date":"1732314522","viewed":126,"name":"oai","username":"rektdeckard","description":"openai gpt4o clone","likes":3,"published":1,"flags":4,"usePreview":1,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define NUM_OCTAVES 4\n#define pi 3.14159265358979323844\n#define E 2.71828182846\n\n\nstruct ColoredSDF {\n    float distance;\n    vec4 color;\n};\n\nstruct SDFArgs {\n    vec2 st;\n    float amount;\n    float duration;\n    float time;\n    float mainRadius;\n};\n\n\nfloat scaled(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat fixedSpring(float t, float d) {\n    float s = mix(\n        1.0 - exp(-E * 2.0 * t) * cos((1.0 - d) * 115.0 * t),\n        1.0,\n        scaled(0.0, 1.0, t)\n    );\n    return s * (1.0 - t) + t;\n}\n\nfloat cnoise(vec3 P);\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    float res = mix(\n        mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x),\n        mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x),\n        u.y\n    );\n    return res * res;\n}\n\nfloat fbm(vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n    return max(base + blend - vec3(1.0), vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n    return blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity);\n}\n\nvec4 permute(vec4 x) {\n    return mod((x * 34.0 + 1.0) * x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P);\n    vec3 Pi1 = Pi0 + vec3(1.0);\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P);       \n    vec3 Pf1 = Pf0 - vec3(1.0);\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.z);\n    vec4 iz1 = vec4(Pi1.z);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(vec4(0.0), gx0) - 0.5);\n    gy0 -= sz0 * (step(vec4(0.0), gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(vec4(0.0), gx1) - 0.5);\n    gy1 -= sz1 * (step(vec4(0.0), gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(\n        vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))\n    );\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(\n        vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))\n    );\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(\n        vec4(n000, n100, n010, n110),\n        vec4(n001, n101, n011, n111),\n        fade_xyz.z\n    );\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nColoredSDF applyListenAndSpeakState(\n    ColoredSDF sdf,\n    SDFArgs args,\n    float micLevel,\n    vec4 avgMag,\n    vec4 cumulativeAudio,\n    int binCount,\n    vec3 bloopColorMain,\n    vec3 bloopColorLow,\n    vec3 bloopColorMid,\n    vec3 bloopColorHigh,\n    sampler2D uTextureNoise,\n    bool listening,\n    bool isAdvancedBloop\n) {\n    float entryAnimation = fixedSpring(scaled(0.0, 2.0, args.duration), 0.92);\n\n    float radius =\n        (listening ? 0.37 : 0.43) * (1.0 - (1.0 - entryAnimation) * 0.25) +\n        micLevel * 0.065;\n\n    float maxDisplacement = 0.01;\n\n    float oscillationPeriod = 4.0;\n\n    float displacementOffset =\n        maxDisplacement * sin(2.0 * pi / oscillationPeriod * args.time);\n\n    vec2 adjusted_st = args.st - vec2(0.0, displacementOffset);\n\n    if (!isAdvancedBloop) {\n        sdf.color = mix(sdf.color, vec4(bloopColorMain, 1.0), args.amount);\n        sdf.distance = mix(sdf.distance, length(adjusted_st) - radius, args.amount);\n        return sdf;\n    }\n\n    vec4 uAudioAverage = avgMag;\n    vec4 uCumulativeAudio = cumulativeAudio;\n\n    float scaleFactor = 1.0 / (2.0 * radius);\n    vec2 uv = adjusted_st * scaleFactor + 0.5;\n    uv.y = 1.0 - uv.y;\n\n    float noiseScale = 1.25;\n    float windSpeed = textureLod(iChannel1, vec2(0.1,0.1), 0.0 ).x / 10.0;\n    float warpPower = 0.19;\n    float waterColorNoiseScale = 18.0;\n    float waterColorNoiseStrength = 0.01;\n    float textureNoiseScale = 1.0;\n    float textureNoiseStrength = 0.08;\n    float verticalOffset = 0.09;\n    float waveSpread = 1.0;\n    float layer1Amplitude = 1.0;\n    float layer1Frequency = 0.2;\n    float layer2Amplitude = 1.0;\n    float layer2Frequency = 0.1;\n    float layer3Amplitude = 1.0;\n    float layer3Frequency = 0.05;\n    float fbmStrength = 1.0;\n    float fbmPowerDamping = 0.55;\n    float overallSoundScale = 1.0;\n    float blurRadius = 1.0;\n    float timescale = 1.0;\n\n    float time = args.time * timescale * 0.85;\n\n    vec3 sinOffsets = vec3(\n        uCumulativeAudio.x * 0.15 * overallSoundScale,\n        -uCumulativeAudio.y * 0.5 * overallSoundScale,\n        uCumulativeAudio.z * 1.5 * overallSoundScale\n    );\n    verticalOffset += 1.0 - waveSpread;\n\n    float noiseX = cnoise(\n        vec3(\n            uv * 1.0 + vec2(0.0, 74.8572),\n            (time + uCumulativeAudio.x * 0.05 * overallSoundScale) * 0.3\n        )\n    );\n    float noiseY = cnoise(\n        vec3(\n            uv * 1.0 + vec2(203.91282, 10.0),\n            (time + uCumulativeAudio.z * 0.05 * overallSoundScale) * 0.3\n        )\n    );\n\n    uv += vec2(noiseX * 2.0, noiseY) * warpPower;\n\n    float noiseA =\n        cnoise(vec3(uv * waterColorNoiseScale + vec2(344.91282, 0.0), time * 0.3)) +\n        cnoise(\n            vec3(uv * waterColorNoiseScale * 2.2 + vec2(723.937, 0.0), time * 0.4)\n        ) *\n            0.5;\n    uv += noiseA * waterColorNoiseStrength;\n    uv.y -= verticalOffset;\n\n    vec2 textureUv = uv * textureNoiseScale;\n    float textureSampleR0 = texture(uTextureNoise, textureUv).r;\n    float textureSampleG0 = texture(\n        uTextureNoise,\n        vec2(textureUv.x, 1.0 - textureUv.y)\n    ).g;\n    float textureNoiseDisp0 =\n        mix(\n            textureSampleR0 - 0.5,\n            textureSampleG0 - 0.5,\n            (sin(time + uCumulativeAudio.a * 2.0) + 1.0) * 0.5\n        ) *\n        textureNoiseStrength;\n    textureUv += vec2(63.861 + uCumulativeAudio.x * 0.05, 368.937);\n    float textureSampleR1 = texture(uTextureNoise, textureUv).r;\n    float textureSampleG1 = texture(\n        uTextureNoise,\n        vec2(textureUv.x, 1.0 - textureUv.y)\n    ).g;\n    float textureNoiseDisp1 =\n        mix(\n            textureSampleR1 - 0.5,\n            textureSampleG1 - 0.5,\n            (sin(time + uCumulativeAudio.a * 2.0) + 1.0) * 0.5\n        ) *\n        textureNoiseStrength;\n    textureUv += vec2(272.861, 829.937 + uCumulativeAudio.y * 0.1);\n    textureUv += vec2(180.302 - uCumulativeAudio.z * 0.1, 819.871);\n    float textureSampleR3 = texture(uTextureNoise, textureUv).r;\n    float textureSampleG3 = texture(\n        uTextureNoise,\n        vec2(textureUv.x, 1.0 - textureUv.y)\n    ).g;\n    float textureNoiseDisp3 =\n        mix(\n            textureSampleR3 - 0.5,\n            textureSampleG3 - 0.5,\n            (sin(time + uCumulativeAudio.a * 2.0) + 1.0) * 0.5\n        ) *\n        textureNoiseStrength;\n    uv += textureNoiseDisp0;\n\n    vec2 st = uv * noiseScale;\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(\n        st * 0.5 +\n        windSpeed * (time + uCumulativeAudio.a * 0.175 * overallSoundScale)\n    );\n    q.y = fbm(\n        st * 0.5 +\n        windSpeed * (time + uCumulativeAudio.x * 0.136 * overallSoundScale)\n    );\n\n    vec2 r = vec2(0.0);\n    r.x = fbm(\n        st +\n        1.0 * q +\n        vec2(0.3, 9.2) +\n        0.15 * (time + uCumulativeAudio.y * 0.234 * overallSoundScale)\n    );\n    r.y = fbm(\n        st +\n        1.0 * q +\n        vec2(8.3, 0.8) +\n        0.126 * (time + uCumulativeAudio.z * 0.165 * overallSoundScale)\n    );\n\n    float f = fbm(st + r - q);\n    float fullFbm = (f + 0.6 * f * f + 0.7 * f + 0.5) * 0.5;\n    fullFbm = pow(fullFbm, fbmPowerDamping);\n    fullFbm *= fbmStrength;\n\n    blurRadius = blurRadius * 1.5;\n    vec2 snUv =\n        (uv + vec2((fullFbm - 0.5) * 1.2) + vec2(0.0, 0.025) + textureNoiseDisp0) *\n        vec2(layer1Frequency, 1.0);\n    float sn =\n        noise(\n            snUv * 2.0 + vec2(sin(sinOffsets.x * 0.25), time * 0.5 + sinOffsets.x)\n        ) *\n        2.0 *\n        layer1Amplitude;\n    float sn2 = smoothstep(\n        sn - 1.2 * blurRadius,\n        sn + 1.2 * blurRadius,\n        (snUv.y - 0.5 * waveSpread) *\n        (5.0 - uAudioAverage.x * 0.1 * overallSoundScale * 0.5) +\n        0.5\n    );\n\n    vec2 snUvBis =\n        (uv + vec2((fullFbm - 0.5) * 0.85) + vec2(0.0, 0.025) + textureNoiseDisp1) *\n        vec2(layer2Frequency, 1.0);\n    float snBis =\n        noise(\n            snUvBis * 4.0 +\n            vec2(\n                sin(sinOffsets.y * 0.15) * 2.4 + 293.0,\n                time * 1.0 + sinOffsets.y * 0.5\n            )\n        ) *\n        2.0 *\n        layer2Amplitude;\n    float sn2Bis = smoothstep(\n        snBis - (0.9 + uAudioAverage.y * 0.4 * overallSoundScale) * blurRadius,\n        snBis + (0.9 + uAudioAverage.y * 0.8 * overallSoundScale) * blurRadius,\n        (snUvBis.y - 0.6 * waveSpread) * (5.0 - uAudioAverage.y * 0.75) + 0.5\n    );\n\n    vec2 snUvThird =\n        (uv + vec2((fullFbm - 0.5) * 1.1) + textureNoiseDisp3) *\n        vec2(layer3Frequency, 1.0);\n    float snThird =\n        noise(\n            snUvThird * 6.0 +\n            vec2(\n                sin(sinOffsets.z * 0.1) * 2.4 + 153.0,\n                time * 1.2 + sinOffsets.z * 0.8\n            )\n        ) *\n        2.0 *\n        layer3Amplitude;\n    float sn2Third = smoothstep(\n        snThird - 0.7 * blurRadius,\n        snThird + 0.7 * blurRadius,\n        (snUvThird.y - 0.9 * waveSpread) * 6.0 + 0.5\n    );\n\n    sn2 = pow(sn2, 0.8);\n    sn2Bis = pow(sn2Bis, 0.9);\n\n    vec3 sinColor;\n    sinColor = blendLinearBurn(bloopColorMain, bloopColorLow, 1.0 - sn2);\n    sinColor = blendLinearBurn(\n        sinColor,\n        mix(bloopColorMain, bloopColorMid, 1.0 - sn2Bis),\n        sn2\n    );\n    sinColor = mix(\n        sinColor,\n        mix(bloopColorMain, bloopColorHigh, 1.0 - sn2Third),\n        sn2 * sn2Bis\n    );\n\n    sdf.color = mix(sdf.color, vec4(sinColor, 1.0), args.amount);\n\n    sdf.distance = mix(sdf.distance, length(adjusted_st) - radius, args.amount);\n\n    return sdf;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy - 0.5;\n    float viewRatio = iResolution.y / iResolution.x;\n    st.y *= viewRatio;\n\n    ColoredSDF sdf;\n    sdf.distance = 1000.0;\n    sdf.color = vec4(1.0, 1.0, 0.5, 1.0);\n\n    float time = iTime;\n\n\n    float micLevel = textureLod(iChannel1, vec2(0.1,0.1), 0.0 ).x + textureLod(iChannel1, vec2(0.1,0.1), 0.0 ).y;\n    float touchDownTimestamp = 0.0;\n    float touchUpTimestamp = 0.0;\n    float stateIdle;\n    float stateSpeak;\n    float listenTimestamp = 0.0;\n    float speakTimestamp = 0.0;\n    float readyTimestamp = 0.0;\n    float silenceAmount = 0.0;\n    float silenceTimestamp = 0.0;\n    vec4 avgMag = vec4(0.5, 0.6, 0.7, 0.8);\n    vec4 cumulativeAudio = vec4(1.0, 1.2, 1.4, 1.6);\n    bool isDarkMode = true;\n    bool isNewBloop = true;\n    bool isAdvancedBloop = true;\n    vec3 bloopColorMain = vec3(micLevel, 1.0 - micLevel, 1);\n    vec3 bloopColorLow = vec3(0.83921568859368563, 0.5058823823928833, 0.9960784316062927);\n    vec3 bloopColorMid = vec3(0.9431372761726379, 0.9372549057006836, 1);\n    vec3 bloopColorHigh = vec3(1, 0.9921568632125854, 0.9372549057006836);\n\n\n    float t = mod(time, 10.0);\n    float stateIdleAmount = 1.0;\n    float stateSpeakAmount = 0.0;\n        stateIdleAmount = 0.0;\n        stateSpeakAmount = 1.0;\n\n    SDFArgs args;\n    args.st = st * 2.0;\n    args.time = time;\n    args.mainRadius = 0.2;\n\n    SDFArgs idleArgs = args;\n    SDFArgs speakArgs = args;\n\n    idleArgs.amount = stateIdleAmount;\n    speakArgs.amount = stateSpeakAmount;\n\n    idleArgs.duration = time - readyTimestamp;\n    speakArgs.duration = time - speakTimestamp;\n\n    if (speakArgs.amount > 0.0) {\n        int binCount = 1;\n        sdf = applyListenAndSpeakState(\n            sdf,\n            speakArgs,\n            micLevel,\n            avgMag,\n            cumulativeAudio,\n            binCount,\n            bloopColorMain,\n            bloopColorLow,\n            bloopColorMid,\n            bloopColorHigh,\n            iChannel0,\n            false,\n            isAdvancedBloop\n        );\n    }\n\n    float clampingTolerance = 0.0075 / 1.0; \n    float clampedShape = smoothstep(clampingTolerance, 0.0, sdf.distance);\n    float alpha = sdf.color.a * clampedShape;\n\n    fragColor = vec4(sdf.color.rgb * alpha, alpha);\n}\n","name":"Image","description":"","type":"image"}]}