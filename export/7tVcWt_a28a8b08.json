{"ver":"0.1","info":{"id":"7tVcWt","date":"1662470795","viewed":229,"name":"Monte Carlo Diffusion","username":"Ultraviolet","description":"Another shader inspired by Monte Carlo Geometry Processing.\n\nHere we solve the heat equation (Delta U = 0 on domain | U = U_0 on boundary) using the walk on sphere algorithm.\nClick to add a temporary white source.\n\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","montecarlo","laplace","heatequation","walkonsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 p )\n{\n    O = texture(iChannel0, p/R.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float epsilon = 2.;\n\nconst float NB_SAMPLES = 10.;\nconst float MAX_ITER = 10.;\nconst float MAX_FRAMES = 10.;\n\n\nfloat boundaryDist(vec2 p) {\n    float res = min(min(p.x, p.y), min(R.x-p.x, R.y-p.y) -1.);\n    if(iMouse.z>0.5)\n        return min(length(iMouse.xy-p), res);\n    return res;\n}\n\nfloat sin2(float t) {\n    return sin(t)*sin(t);\n}\n\nvec4 boundaryValue(vec2 p) {\n    vec2 xy = p/(R.x+R.y)*PI*2.;\n    vec4 res = vec4(sin2(xy.x*1.35485136), sin2((xy.y+xy.x)*1.0123456), sin2(xy.y*0.98453715), 0.);\n    \n    if(iMouse.z>0.5 && length(iMouse.xy-p) < 10.*epsilon)\n        return vec4(1.);\n    return res;\n}\n\nvec4 value(vec2 p) {\n    if(iFrame == 0)\n        return vec4(0.);\n\n    return texture(iChannel0, p/R.xy);\n}\n\nvec2 sampleOnCircle(vec2 center, float radius, float id) {\n    float alpha = 2.*PI*hash14(vec4(center, iFrame, id));\n    return center + radius*vec2(cos(alpha), sin(alpha));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    float b_dist = boundaryDist(p);\n    \n    vec4 val = vec4(0.);\n    \n    for(float j=0.; j<NB_SAMPLES; ++j) {\n        vec2 cur_p = p;\n        for(float i=0.; i<MAX_ITER; ++i) {\n            b_dist = boundaryDist(cur_p);\n            if(b_dist < epsilon) {\n                break;\n            }\n            cur_p = sampleOnCircle(cur_p, b_dist, i*NB_SAMPLES+j);\n        }\n\n        val += boundaryValue(cur_p);\n    }\n    \n    val /= NB_SAMPLES;\n    \n    float t = min(MAX_FRAMES, float(iFrame));\n    \n    fragColor = (value(p)*t + val)/(t+1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define PI 3.1415\n\n\nfloat hash14(vec4 p4)\n{\n\tp4  = fract(p4 * .1031);\n    p4 += dot(p4, p4.wzyx + 31.32);\n    return fract((p4.x + p4.y) * p4.z + p4.w);\n}\n","name":"Common","description":"","type":"common"}]}