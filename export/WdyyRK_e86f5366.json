{"ver":"0.1","info":{"id":"WdyyRK","date":"1603186487","viewed":135,"name":"Hexagonal Tiling on GlassSphere","username":"shadermonkey","description":"It was just some random shader when I was testing my raytracing spherical glass, and adding hexagonal tiling background, but it looks quite cool!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","light","sphere","abstract","glass","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ng 1.5\n#define PI 3.141529\nstruct Ray{\n    vec3 o;\n    vec3 d;\n    float i;\n};\n    \nRay GetRay(vec2 uv, vec3 camPos, vec3 dir, float zoom){\n    Ray r;\n    r.o = camPos;\n    vec3 f = normalize(dir);\n    vec3 right = cross(vec3(.0,1.,.0), f);\n    vec3 u = cross(f,right);\n    \n    vec3 c = r.o + f*zoom;\n    vec3 i = c + uv.x *right + uv.y *u;\n    r.d = normalize(i -r.o);\n    r.i = 1.;\n    return r;\n}\nmat3 Rotate(vec3 u, float t){\n    float a = 1.-cos(t);\n    return mat3(cos(t) + u.x*u.x*a, u.x*u.y*a - u.z*sin(t), u.x*u.z*a + u.y*sin(t),\n                u.y*u.x*a + u.z*sin(t), cos(t)+u.y*u.y*a, u.y*u.z*a - u.x*sin(t),\n                u.z*u.x*a - u.y*sin(t), u.z*u.y*a+u.x*sin(t), cos(t) + u.z*u.z*a);\n}\nvec3 ClosestPoint(Ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nfloat DistRay(Ray r, vec3 p) {\n\treturn length(p-ClosestPoint(r, p));\n}\nfloat GetRefractedAngle(float ni, float thetai, float nf){\n    return asin(ni/nf*sin(thetai));\n}\n\nvec2 Root(float a, float b, float c){\n    float x1 = -b;\n    float x2 = pow(pow(b,2.)-4.*a*c,.5);\n    return vec2((x1+x2)/(2.*a), (x1-x2)/(2.*a));\n}\n\n//Random with iMouse.x as parameter\nfloat Random(float s){ //[0,1]\n    return fract(cos((iMouse.x +.2)*s)*73.17);\n}\n\nRay SphereRefract(Ray ray, vec3 p, float r){\n   \tfloat d = DistRay(ray, p);\n    //return ray;\n    if(d < r){\n        float ai = asin(d/r);\n        float ar = GetRefractedAngle(1., ai, ng);\n        float t = Root(pow(length(ray.d),2.), 2.*(dot(ray.o,ray.d) - dot(ray.d, p)), pow(length(ray.o - p),2.) - pow(r,2.)).y;\n        vec3 pi = ray.o + t * ray.d;\n        vec3 ni = normalize(pi - p);\n        vec3 rdir = ray.d*Rotate(normalize(-cross(ray.d,ni)), ai-ar);\n    \tfloat d2 = 2.*r*cos(ar);\n        vec3 pf = rdir * d2 + pi;\n        vec3 nf = normalize(pf - p);\n        vec3 rdir2 = rdir*Rotate(normalize(-cross(rdir, nf)), ai - ar);\n        Ray ray2;\n        ray2.d = rdir2;\n        ray2.o = pf + rdir2*(t + d2);\n        ray2.i = pow((r-d)/r*2.,1.);\n        return ray2;\n    } else return ray;\n}\n\nfloat S2(float d, float w, float v){\n    return smoothstep(d+w/2., d - w/2., v) * smoothstep(d-w/2., d+w/2.,v);\n}\n\nvec3 DrawBG(Ray ray, float z, float r){\n    float dz = (z - ray.o.z);\n    float dx = ray.d.x/ray.d.z*dz;\n    float dy = ray.d.y/ray.d.z*dz;\n    vec2 uv = vec2(ray.o.x + dx , ray.o.y + dy);\n    uv.y+= iTime;\n    \n    //tiling 1\n    vec2[2] p;\n    float d1 = r*(1.+cos(PI/3.));\n    float nx = floor((uv.x + d1)/(2.*d1));\n    float d2 = r*sin(PI/3.);\n    float ny = floor((uv.y + d2)/(2.*d2));\n    p[0].x = nx*2.*d1;\n    p[0].y = ny*2.*d2;\n    \n    //tiling 2\n    float nx2 = floor(uv.x/(2.*d1));\n    float ny2 = floor(uv.y/(2.*d2));\n    p[1].x = nx2*2.*d1 + d1;\n    p[1].y = ny2*2.*d2 + d2;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 2; i++){\n        vec2 dv = uv-p[i];//delta vector\n        float l = length(dv);//delta length\n        float a = mod(abs(atan(dv.y/dv.x)),PI/3.);\n        float hl = r*sin(PI/3.)/sin(PI*2./3. - a);//hexagonal length\n        vec3 color1 = vec3(sin(abs(uv.xy)),cos(uv.y))*2.;\n        col += S2(hl, .15,l)*color1;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    vec2 m = iMouse.xy/iResolution.xy;\n    float d= 10.;\n    float r = 1.;\n    float dt = 2.*r*sin(PI/3.)/d;\n    float dp = PI/3.;\n    vec3 o = vec3(0.);\n\n    Ray ray = GetRay(uv, o, vec3(0.,0.,1.), 1.);\n    ray = SphereRefract(ray, vec3(0.,.0,1.5), .5);\n    col += DrawBG(ray, d, 1.)*ray.i;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}