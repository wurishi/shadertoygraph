{"ver":"0.1","info":{"id":"3tcSD2","date":"1585225201","viewed":266,"name":"Quarks","username":"vegardno","description":"Just some dancing RGB lights","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // metaballs\n\tvec3 col0 = texture(iChannel0, uv).rgb;\n    \n    // volumetric lighting\n    vec3 col1 = texture(iChannel1, uv).rgb;\n\n    vec3 col = mix(col0 + col1, max(col0, col1), .3);\n\n    // Actually looks much cooler without the gamma correction...\n    //col = pow(col, vec3(1. / gamma));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sphereSDF(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\n// https://iquilezles.org/articles/smin\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml\nmat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 pos(vec3 p, int i)\n{\n    float freq = 5.;\n    float phase = float(i) * (radians(360. / 3.));\n    float smin_k = 5.;\n\n    mat4 axisRotation = rotate(4. * iTime, normalize(vec3(i == 0, i == 1, i == 2)));\n    return (axisRotation * vec4(p, 1) + vec4(sin(freq * iTime + phase), 0, 0, 1)).xyz;\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = 1000.;\n    \n\tmat4 timeRotation = rotate(4. * iTime, normalize(vec3(-1, -1.5, 0)));\n    p = (timeRotation * vec4(p, 1)).xyz;\n    \n    vec3 pos_r = pos(p, 0);\n    vec3 pos_g = pos(p, 1);\n    vec3 pos_b = pos(p, 2);\n\n\td = smin(d, sphereSDF(pos_r, .2), 5.);\n    d = smin(d, sphereSDF(pos_g, .2), 5.);\n    d = smin(d, sphereSDF(pos_b, .2), 5.);\n\n    return d;\n}\n\nvec3 sceneColor(vec3 p)\n{\n    mat4 timeRotation = rotate(4. * iTime, normalize(vec3(-1, -1.5, 0)));\n    p = (timeRotation * vec4(p, 1)).xyz;\n    \n    vec3 pos_r = pos(p, 0);\n    vec3 pos_g = pos(p, 1);\n    vec3 pos_b = pos(p, 2);\n    \n    return pow(vec3(1, 0, 0), vec3(gamma)) * (1. / (.1 + length(pos_r)))\n        + pow(vec3(0, 1, 0), vec3(gamma)) * (1. / (.1 + length(pos_g)))\n        + pow(vec3(0, 0, 1), vec3(gamma)) * (1. / (.1 + length(pos_b)));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    vec3 m;\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(60.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 rgb = vec3(0);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(rgb, 1);\n\t\treturn;\n    }\n\n    vec3 pos = eye + dir * dist;\n    \n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    vec3 normal = (rotate(iTime, normalize(vec3(.3, .5, .7))) * vec4(calcNormal(pos), 1.)).xyz;\n\n    vec3 col = (.2 + texture(iChannel1, normal).rgb) * sceneColor(pos);\n    \n    fragColor = vec4(rgb + .9 * max(.1, dot(lightDir, normal)) * col, 1);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float gamma = 2.2;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\n\nconst vec2 ScreenLightPos = vec2(.5, .5);\nconst int NUM_SAMPLES = 16;\nconst float Density = .5;\nconst float Weight = .7;\nconst float Decay = .85;\nconst float Exposure = .4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate vector from pixel to light source in screen space.\n    vec2 texCoord = fragCoord / iResolution.xy;\n    vec2 deltaTexCoord = (texCoord - ScreenLightPos.xy);\n    \n    float Density = .75 + .2 * sin(2. * radians(360.) * iTime);\n    \n    // Divide by number of samples and scale by control factor.\n    deltaTexCoord *= 1.0f / float(NUM_SAMPLES) * Density;\n    \n\t// Store initial sample.\n    vec3 color = texture(iChannel0, texCoord).rgb;\n    \n    // Set up illumination decay factor.\n    float illuminationDecay = 1.0f;\n    \n    // Evaluate summation from Equation 3 NUM_SAMPLES iterations.\n    for (int i = 0; i < NUM_SAMPLES; i++)   {\n        // Step sample location along ray.\n        texCoord -= deltaTexCoord;\n        \n        // Retrieve sample at new location.\n        //vec3 sample_ = texture(iChannel0, texCoord).rgb;\n        vec3 sample_ = texture(iChannel0, texCoord + deltaTexCoord * rand(texCoord)).rgb;\n        \n        // Apply sample attenuation scale/decay factors.\n        sample_ *= illuminationDecay * Weight;\n        \n        // Accumulate combined color.\n        color += sample_;\n        \n        // Update exponential decay factor.\n        illuminationDecay *= Decay;\n    }\n    \n    // Output final color with a further scale control factor.\n    fragColor = vec4( color * Exposure, 1);\n}","name":"Buf B","description":"","type":"buffer"}]}