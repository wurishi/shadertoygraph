{"ver":"0.1","info":{"id":"wdlSDr","date":"1551109603","viewed":82,"name":"основная часть","username":"nirvanabc","description":"чтобы получше рассмотреть середину рекомендуется повращать","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI=3.14159265;\n\n\nvec2 obj_floor(in vec3 p, int color)\n{\n  return vec2(p.y+10.0 + 0.8 * sin(iTime), color);\n}\n\n\nvec2 obj_cone( in vec3 p, in vec3 c, int color)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), color);\n}\n\n\nvec2 obj_cylinder( vec3 p, vec2 h, int color)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)), color);\n}\n\n\nvec2 obj_torus(in vec3 p, int color)\n{\n  vec2 r = vec2(2.1,0.5);\n  vec2 q = vec2(length(p.xy)-r.x,p.z);\n  float d = length(q)-r.y + 0.1 * sin(iTime);\n  return vec2(d, color);\n}\n\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\nvec2 op_sub(vec2 a, vec2 b, int color)\n{\n  float d = max(a.x, -b.x);\n  if (d == a.x)\n    return vec2(d, 2);\n  else return vec2(d, color);\n}\n\nvec2 obj_sphere(in vec3 p, float r, float k, int color)\n{\n  float d = length(p)- r + k * sin(iTime);\n  return vec2(d, color);\n}\n\nvec2 twist_torus(vec3 p, int color)\n{\n    float  c = cos(1.0*p.y+5.0);\n    float  s = sin(1.0*p.y+5.0);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_torus(vec3(m*p.xz,p.y), color);\n}\n\n\nvec2 twist_t_bad(vec3 p, int color)\n{\n    float  c = cos(1.0*p.y);\n    float  s = sin(2.0*p.z);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_torus(vec3(m*p.xz,p.y), color);\n}\n\n\nvec2 twist_s_bad(vec3 p, float r, float k, int color)\n{\n    float  c = cos(1.6*p.y);\n    float  s = sin(1.*p.x);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_sphere(vec3(m*p.xz, p.y), r, k, color);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\t\n  \tvec2 dist = op_sub(obj_sphere(p + 0.03*sin(20.0*p.x)*sin(20.0*p.y)*sin(2.0*p.z), 1.9, 0.7, 1), obj_cylinder(p, vec2(2,1), 2), 1);\n    dist = obj_union(obj_torus(p, 3), dist);\n    dist = obj_union(obj_sphere(p+ 0.3*sin(7.0*p.x)*sin(7.0*p.y)*sin(7.0*p.z), 1.5, 0.3, 1), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,0,4), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,0,-4), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,4,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(4,0,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(-4,0,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(obj_cone(p - vec3(0.0,3.50,-3.0), vec3(0.8,0.6,0.7), 7), dist);\n    dist = obj_union(obj_cone(p - vec3(0.0,3.50,3.0), vec3(0.8,0.6,0.7), 7), dist);\n    dist = obj_union(dist, vec2( 0.6 * \n                                 twist_t_bad(p - vec3(0.0,0.0, 0.0), 6)));\n    \n  return obj_union(obj_floor(p, 0), dist);\n}\n\n\nvec3 floor_color(in vec3 p)\n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0.4, 0.7,0.2);\n    else\n      return vec3(1,2.1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1.9,1,1);\n    else\n      return vec3(0.3,0,1);\n   }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n\n  // Camera up vector.\n  vec3 vuv=vec3(0,1,0); \n  \n  // Camera lookat.\n  vec3 vrp=vec3(0,0,0);\n\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*10.0; \n\n  // Camera setup.\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n  \n\n  // Raymarching.\n  const vec3 e=vec3(0.02,0.007,0.001);\n  const float maxd=100.0; //Max depth\n  vec2 d=vec2(0.1,0.0);\n  vec3 c,p,N;\n\n  float f=1.0;\n  for(int i=0;i<256;i++)\n  {\n    if ((abs(d.x) < .001) || (f > maxd)) \n      break;\n    \n    f+=d.x;\n    p=prp+scp*f;\n    d = distance_to_obj(p);\n  }\n  \n  if (f < maxd)\n  {\n    // y is used to manage materials.\n    if (d.y==0.0) \n      c = floor_color(p);\n    else if (d.y == 1.0)\n      c = vec3(0.9,0.1,0.5);\n    else if (d.y == 2.0)\n      c = vec3(0.1,0.1,1.8);\n    else if (d.y == 3.0)\n      c = vec3(0.2,0.2,0.6);\n    else if (d.y == 4.0)\n      c = vec3(0.7,0.1,0.6);\n    else if (d.y == 5.0)\n      c = vec3(0.1,1.4,1.2);\n    else if (d.y == 7.0)\n      c = vec3(1.1,1.9,0.2);    \n    else c = vec3(0.,1.0,0);\n        \n    \n    vec3 n = vec3(d.x-distance_to_obj(p-e.xyy).x,\n                  d.x-distance_to_obj(p-e.yxy).x,\n                  d.x-distance_to_obj(p-e.yyx).x);\n    N = normalize(n);\n\tvec3 L = vec3(sin(iTime)*20.0,10,cos(iTime)*20.0);\n    float b=dot(N,normalize(prp-p+L));\n    //phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,16.0))*(1.0-f*.01),1.0);\n  }\n  else \n    fragColor=vec4(0.2,0,0.5,1); //background color\n}\n","name":"Image","description":"","type":"image"}]}