{"ver":"0.1","info":{"id":"fs2XWK","date":"1621637501","viewed":292,"name":"Flight 2001","username":"ilyaev","description":"Space flight ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarch","flight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 15.\n#define SURF_DIST .001\n#define MAT_BALL  1.\n#define MAT_WALLS  2.\n#define SINGLE_SCENE false\n#define TUNNEL_SPEED .4\n\n\nfloat smin( float a, float b)\n{\n    float k = .4;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    //  return fract(sin(n.x*123.231 + n.y*4432.342)*33344.22);\n}\n\nvec3 renderDebris(vec3 p) {\n    float Width = 1.;\n    float Height = 1.;\n\n    float Thick = .1;\n\n    float Step = 3.5;\n\n    vec3 c = vec3(0., 0., Step);\n    vec3 q = p;\n    if (SINGLE_SCENE != true) {\n        q = mod(p + 0.5 * c, c) - 0.5 * c;\n    }\n\n    q.yz *= Rot(3.14/2.);\n\n    float id = round(p.z / Step) + 4.;\n\n    float n = n21(vec2(id, 1.));\n\n    // if (n > .9) {\n    if (mod(id, 4.) == 0.) {\n        q.xz *= Rot(id * 1. + sin(iTime) * .5 + iTime*clamp((n - .5)*3., 0., 1.));\n    }\n\n    float left = sdBox(abs(q) - vec3(Width*.9, Width / 2., 0.), vec3(Thick, Width/2., Width));\n    float right = sdBox(abs(q) - vec3(0., Width / 2., Width), vec3(Width, Width/2., Thick));\n\n\n    float rad = .05 + 0.05 * n;\n\n    float circ = length(q + vec3(sin(iTime*n + id) * .9 * n, sin(iTime*n)*.2, cos(iTime*n*1.2 + id * 2.)*.9*n)) - rad;\n    float d = circ;\n\n    d = smin(d, min(left, right));\n\n    \n\n    float mat = MAT_WALLS;\n\n    return vec3(d, id, mat);\n}\n\n\nvec3 GetDist(vec3 p) {\n    return renderDebris(p);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 res = vec3(0.);\n    float k = 0.;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        res = GetDist(p);\n        float dS = res.x;\n        dO += dS*.7;\n        k += 1.;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n\n    return vec4(dO, res.y, res.z, k);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Transform(vec3 p) {\n    if (SINGLE_SCENE == true) {\n        return p;\n    }\n     return p + vec3(0. + cos(iTime)*.2,0. + sin(iTime)*.3,-iTime*2.);\n}\n\nvec3 renderPlasma(vec2 uv) {\n    for(float i = 1.0; i < 3.0; i++){\n        uv.x += .6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 3.5 * uv.y + iTime);\n    }\n    vec3 col = .5 + 0.5*sin(iTime*5. + uv.yyy + vec3(iTime,2. + iTime,4. + iTime));\n    //return col/(2.1*abs(cos(iTime-uv.x)));\n    float nums = 0. + floor(n21(vec2(floor(iTime), 43))*5.);\n\n    return col/(2.1*abs(cos(uv.x * nums)));\n    // return col/(2.1*abs(cos(uv.x * 2.)));\n}\n\nvec3 renderField(vec2 uv, float index) {\n    vec3 col = vec3(.02);\n\n    vec2 ouv = uv;\n    float l = pow(TUNNEL_SPEED/length(uv), .30);\n    float a = atan(uv.x, uv.y);\n\n    float warp = iTime / 3.;\n\n    // uv = vec2(a - sin(abs(uv.x*uv.y)/58.), l + warp);\n    // uv = vec2(a - abs(uv.y/30.)*sin(iTime*5.)*cos(iTime*3. + uv.x/2.), l + warp);\n    // uv = vec2(a, l + warp + uv.x*uv.y/10.);\n    uv = vec2(a, l + warp);\n\n    ouv = uv;\n\n    vec2 cells = vec2(10., 10.);\n\n    uv *= cells;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    float n = n21(id + index * 100.);\n    float n1 = fract(n*123.543 + index * 2.);\n    float n2 = fract(n*4435.332 + index * 4.);\n\n    if (index == 2.) {\n        col.rgb = renderPlasma(ouv/2.)*l/15.; //*smoothstep(0.3, .9, ouv.x);\n    }\n\n    float star = step(uv.x, n) - step(uv.x, n-.05);\n    star *= step(uv.y, n1) - step(uv.y, n1-(.3*n2));\n\n    col.rgb += vec3(star) * (1. - l/2.);\n    // col.rgb = vec3(step(length(uv - vec2(n1,n2)), .1*n2)) * .4;\n\n    return col;\n}\n\nvec3 renderTunnelTexture(vec2 uv) {\n\n    // uv.y += sin(iTime)*.02;\n    // uv.x += cos(iTime/2.)*.05;\n\n    vec3 col = vec3(0.);\n    col.rgb =\n        renderField(uv, 0.)\n        + renderField(uv*13., 1.)\n        + renderField(uv/3., 2.);\n\n    return col;\n}\n\nvec3 getBackground(vec2 uv) {\n    return renderTunnelTexture(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    // ro.xz *= Rot(-m.x*6.2831);\n\n    ro.yz *= Rot(-3.14/3.9);\n    ro.xz *= Rot(3.14);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n\n    vec4 rm = RayMarch(Transform(ro), rd);\n    float d = rm.x;\n    float k = rm.a;\n    float mat = rm.z;\n    float id = abs(rm.y);\n\n    if(d<MAX_DIST) {\n        vec3 p = Transform(ro) + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 ref = getBackground(Transform(r).xy*2.);// /  texture(iChannel0, Transform(r).xy).rgb;\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 sc = clamp(vec3(sin(id*10.) + .2, cos(id*20.), cos(id)/sin(id)), vec3(0.0, .3, 0.), vec3(1., .1, 0.3));\n        // vec3 sc = vec3(1., 0. ,0.);\n        if (mat == MAT_WALLS) {\n            col = vec3(dif) * (1. - k/10.);\n            col *= sc;\n            col *= ref * 5.;\n        } else {\n            col = vec3(dif) * ref * sc;\n        }\n        col = pow(col, vec3(.4545));\t// gamma correction\n    } else {\n            // uv.xy *= Rot(iTime/3.);\n            col = getBackground(uv);\n        }\n\n    \n    // col *= p;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}