{"ver":"0.1","info":{"id":"wlfcz2","date":"1592491815","viewed":175,"name":"Walk Camera","username":"spalmer","description":"Simple fly camera and basic first person controller\nwith capsule collision, boilerplate ray marcher.\nControlled by Mouse+Arrows+PgUp/Dn+WASD+C+Space.\nG toggles gravity & fly/walk modes.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["collision","raymarch","camera","walk","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of Fly Camera at http://shadertoy.com/view/tdsfR4\n// adds walk first person controller with gravity!\n\n#define BluNoiz iChannel3\n#define BNzRes iChannelResolution[3].xy\n\nconst float\n  fogdensity = .002\n, maxdepth = 6e3 //1e2 //3.4e38 //8.5e4 //\n, shfalloff = 2. //.5 // exponent of curve\n, shd = 10. //8. //4. //16. //24. // soft shadow trace distance\n, sc = 3.2  // soft shadow crispness\n, sfuzz = .0 //.05 // HACK fade contribution with scan range - HACK for penumbra (not mixed correctly though, so doesn't really work well)\n, aod = .3 // ao distance\n, ambient = .25 // balance between ambient and direct light\n, nitebrite = .06 // how dark the lighting gets at night, essentially night time ambient light level\n, lfloor = .02 // lighting floor, limits how deep shadows can get, fake global ambient\n;\n\nconst vec3\n, csun = vec3( 1., .95, .79) // light color\n, csky = vec3(.11, .33, .99) // fake, gets dimmed by sun angle though\n;\n\n// maybe should think of a better idea, but it's multipurpose DoF and SSAA and temporal motion blur\n// so at least we get some mileage out of the extra work done tracing and lighting the scene multiple times\nconst int SSAA = 4; //6; //1; //5; //12; //7; //3; //48; //32; //16; // how strong is your GPU?\n// attempting to scale by resolution,\n// automatically reducing samples as needed.\n// only smaller windows will get the full count.\nconst int marchsteps = 96; //64; //128; //\n\nconst int shadowsteps = 24; //32; //16; //8; //\n\nvec3 sunDir; // animated in mainImage\n\n// compute material (albedo for now) from id\nvec3 Material(int i, vec3 p, vec3 n, float d)\n{\n    float tscale = 32.;\n    vec3 a, t = abs(sin(tscale*p + .25*tau));\n    float f = dot(1.-n*n, t) // triplanar texture\n         * exp2(-4.*tscale/iResolution.y*d) * .25 // distance fade\n        + .5\n      , e = .1*f; // don't want any black components, desaturate a bit\n    switch (i) {\n      default:\n      case mSky:   a = vec3(  e  ); break;\n      case mGray:  a = vec3(  f  ); break;\n      case mRed:   a = vec3(f,e,e); break;\n      case mGreen: a = vec3(e,f,e); break;\n      case mBlue:  a = vec3(e,e,f); break;\n    }\n    return a;\n}\n         \nfloat Shadow(vec3 p, vec3 n, vec3 l, float hd, float d, float rnd, int ssteps)\n{\n    float nl = max(0., dot(n, l))\n    , ao = /*sqrt*/(clamp((Scene(p + n * aod).d - hd) / aod, 0., 1.));\n    if (nl > 1e-4) {\n    \tvec3 sht = sunDir * shd\n    \t, hp = p + n * .002; // self-shadow bias hit position\n        int iters = max(1, int(rnd + float(ssteps) / (1.+.002*d)));\n        float sh = 1.; // min shadow factor found so far\n        for (int i = iters; i-- > 0; ) {\n    \t\tfloat f = (float(i) + 1.) / float(iters)\n    \t\t// must distribute the samples nonlinearly\n\t\t\t// to support long shadow trace distances.\n\t\t\t// need more samples close to the receiver.\n\t\t\t, ff = f * f\n\t\t\t, v = max((Scene(p + sht * ff).d - hd + sfuzz * f) * sc / shd / nl / ff, 0.);\n\t\t\tsh = min(sh, v); //sh = min(sh, v * (2.-f)); //sh *= mix(v, 1., f); //sh *= v; //\n        }\n        // hoisted sqrt and part of clamp out of loop\n        sh = /*sqrt*/(min(sh, 1.));\n        sh = pow(sh, shfalloff);\n\t    nl *= sh; // fake soft shadow attenuates direct lighting\n    }\n    //nl = max(nl, ao);\n    //nl *= max(0., mix(ao, 1., .2));  // fake AO\n    //nl = mix(nl, 1., ambient);  // HACK ambient floor\n    //float af = min(mix(ao, 1., ambient), 1.);\n    //nl = mix(nl, 1., af);\n    // FIXME I still don't like how I've mixed the factors, really.\n    // FIXME ambient light should have a color from the surrounding environment bounces,\n    // so should be based on albedo of nearby surfaces\n    // as a major HACK can use our *own* albedo since it does contribute somewhat due to interreflections\n    float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient\n    nl *= (1.-ambient); // leave room for ambient factor\n    nl += ah * ao; // hemi ambient only where not occluded\n    //nl /= (1. + ambient); // I like this mixing better\n    nl = clamp(nl, 0., 1.);\n    // must have some minimum lighting floor to prevent harsh black ao in shadows\n    nl = mix(nl, 1., lfloor); // after clamping\n//    nl = 1.; // HACK disable lighting\n    return nl;\n}\n\nvec3 Light(int m, vec3 p, vec3 v, float d, float rnd)\n{\n    float h = 3e-4 * (d + 1.) //2e-3 * clamp(d, .01, 100.) //\n    , hd;\n    vec3 n = SceneNormal(p, h, hd, IZERO)\n    , albedo = Material(m, p, n, d)\n    , c = albedo;\n    float nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO)\n    , fogscale = fogdensity // / dmax * 8.5e4; // TODO scale by dmax somehow?\n    , fexp = exp2(-fogscale * d);\n    // TODO replace with custom illumination\n    c *= nl * mix(sunDir.y, 1., .5+.5*nitebrite);\n    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color\n        + (1.-fexp) * .7 * pow(clamp(1.-abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog\n        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)\n        + .87*pow(max(0., dot(-v, sunDir) * .5 + .5), 16.); // fake mie, sun halo\n    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)\n    c = clamp(c, 0., 1.);\n    return c;\n}\n\nvec3 Render(vec3 ro, vec3 rd, float rnd, out float depth)\n{\n    Marched mr = March(ro, rd, 2e-3, maxdepth, marchsteps + IZERO);\n    Rescue(mr, ro, rd, maxdepth); // HACK\n    float t = mr.t // trace depth to first hit\n        , hd; // distance at hit point\n    int m = mr.m;\n    vec3 hp = ro + rd * t\n    , c = Light(m, hp, -rd, t, rnd);\n    //c *= n * .5 + .5; // DEBUG hit normal\n    depth = mr.t;\n    return c;\n}\n\n// vogel disc based super sampler\n// handles depth of field, blur, antialiasing effects\nvec3 RenderSS(vec3 ro, vec3 evel, vec2 q, mat3 cam, float hfovy\n     , int supersamples, float focuscos, float focaldepth\n     , float rnd)\n{\n\tconst float phi = .5*(sqrt(5.) + 1.)\n    , temporal = 0. //12. // temporal jitter animation rate?\n    , ssgamma = .45; // really does help!\n\tvec3 c = vec3(0); float s = sqrt(max(0., 1. - focuscos*focuscos)), tot = 0.;\n\tfor (int i = supersamples; --i >= 0; ) {\n\t\tfloat f = (float(i) + .5) / float(supersamples) //float(i) / (float(supersamples) - .5) //\n\t\t, a = phi * tau * (f + rnd + temporal*fract(iTime))\n\t\t, omff = 1. //exp2(-4. * f * s) //1.-f*f //sqrt(f) //\n        , od\n\t\t;\n\t\tvec2 vogeldisc = sin(a + vec2(.25*tau, 0)) * sqrt(f) * s;\n\t\tvec3 vd = normalize(vec3(q + vogeldisc, 1./sin(hfovy)))\n\t\t, rd = normalize(cam * vd) // view ray\n\t\t, vj = cam * vec3(vogeldisc,0) // vogel disc jitter in world space\n\t\t, vp = ro - evel * f * iTimeDelta - vj * (1. * focaldepth)\n\t\t, rc = Render(vp, rd, fract(rnd + f), od)\n\t\t;\n        rc = pow(rc, vec3(ssgamma));\n\t\tc.rgb += rc * omff; \n        tot += omff;\n\t} // may even want to blend these *after* gamma correction\n    c /= tot;\n    c = pow(c, vec3(1./ssgamma));\n\treturn c;\n}\n\nvoid SetupTime(float t)\n{\n    time = t;\n\tfloat sunangle = .1*time; //.9; //\n\tsunDir = normalize(vec3(.2,1,1)*sin(vec3(sunangle)+vec3(0,0,.25*tau))); //vec3(.1, .9,.2)); //\n}\n\nvec3 Draw(vec2 p, float rnd)\n{\n\tState state;\n\tvec2 R = iResolution.xy;\n\tivec2 i = ivec2(p);\n\tLoadState(state, BufA, ivec2(R));\n    SetupTime(iTime);\n\tvec2 q = (p + p - R) / R.y;\n\tmat3 view = Camera(state.eyeaim);\n\tfloat hfovy = tau/12. //radians(30.) //\n\t//, blur = 2. // pixels ??!\n\t, foclen = 1.\n\t, focus = .99998 //cos(hfovy * blur/iResolution.y) //\n\t;\n\tint ss = SSAA + IZERO;\n    ss = max(1, int(float(ss) * min(1., 720. / R.y) + .5));\n\tss = max(ss, 1);\n\t//if (iTimeDelta >= .034) ss = 1;\n\treturn RenderSS(state.eyepos, state.eyevel, q, view\n\t  , hfovy, ss, focus, foclen, rnd);\n}\n\nfloat rnoise(vec2 p)\n{\n\treturn fetch(BluNoiz, ivec2(p) & ivec2(BNzRes-1.)).x; // blue noise is great\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float rnd = rnoise(p);\n\tvec3 c = Draw(p, rnd);\n\tc = pow(c, vec3(.4545)); // to approx sRGB gamut\n\tc += .6 / 256. * rnd; // dither\n\to = vec4(c, 1);\n}\n\n//\tvec4 data = fetch(BufA, ivec2(p)); c = data.rgb; // + data.a; // DEBUG show buffer A\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// enable gravity feature\n#define WALK 1\n// enable antigravity feature\n#define FLY  1\n// camera fixed if neither is enabled\n#define COLLISION 1\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n\n#define IZERO min(iFrame, 0)\n\nconst float tau = 2. * acos(-1.); //6.28318531; //\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\n// Rodrigues' formula rotation by \n// arbitrary unit axis and radian angle\nvec3 prot(vec3 p, vec3 axis, float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return c * p\n        + (1.-c) * dot(p, axis) * axis\n        + s * cross(p, axis);\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution; // window resolution\n    vec3 eyepos;\n    vec3 eyevel;\n    vec2 eyeaim;\n    vec2 aimbase; // involved in mouse lookaround\n    bool mbdown; // mouse button was down?\n};\n\nconst int\n  slotResMBD     = 0 // w unused\n, slotEyePos     = 1 // w unused\n, slotEyeVel     = 2 // w unused\n, slotAzElBase   = 3 // azimuth and elevation of aim, also recorded on mouse up\n, slotCount      = 4\n;\n\nbool IsStatePixel(ivec2 i, ivec2 R)\n{\n   \treturn i.y == R.y-1 && i.x >= R.x-1-slotCount;\n}\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResMBD].xy);\n    state.mbdown = data[slotResMBD].z > .5;\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyevel = data[slotEyeVel].xyz;\n    state.eyeaim = data[slotAzElBase].xy;\n    state.aimbase = data[slotAzElBase].zw;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) { // IsStatePixel(p)\n      case slotResMBD:\n        c = vec4(R, state.mbdown ? 1. : 0., 0);\n        break;\n      case slotEyePos:\n        c = vec4(state.eyepos, 0.);\n        break;\n      case slotEyeVel:\n        c = vec4(state.eyevel, 0.);\n        break;\n      case slotAzElBase:\n        c = vec4(state.eyeaim, state.aimbase);\n        break;\n      default:\n        break;\n    }\n}\n\nfloat dsphere(vec3 q, float r) // r is radius\n{\n    return length(q) - r;\n}\n// iq's approach, different style; e is box half-extent\nfloat dbox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n\treturn all(lessThan(q, vec3(0))) \n        ? max(max(q.x,q.y),q.z)\n        : length(max(q, 0.));\n}\n// I whipped up a highly configurable aniso torus/washer/pipe/spun box widget\n// e is tricky to explain:\n// e.x = hollow hoop major radius,\n// e.y = minor axis 1 (pipe height),\n// e.z = minor axis 2 (tube wall thickness),\n// e.w = thickness poof radius\n// FIXME reparameterize more explicitly\nfloat dtubey(vec3 q, vec4 e)\n{\n\tvec2 p = vec2(length(q.xz) - e.x, q.y);\n    p = abs(p) - e.zy;\n\treturn all(lessThan(p, vec2(0))) \n        ? max(p.x,p.y)\n        : length(max(p, 0.)) - e.w;\n}\n\n\n// material ids\nconst int\n  mSky   = 0\n, mGray  = 1\n, mRed   = 2\n, mGreen = 3\n, mBlue  = 4\n;\n\nstruct Hit\n{\n    float d; // signed distance to surface\n    int m; // material id\n};\n/* TODO other convenient quantities\ninclude local texture coordinate\n*/\n// HACK so Common tab can access this uniform;\n// iTime must be copied here at start of mainImage!\nfloat time; // for animating the scene\n//void SetupScene(float t) { time = t; }\n\nHit Scene(vec3 p)\n{\n    float dp = p.y // ground plane +Y\n    , r = .5 // ball radius\n    , tr = .5 // torus radius\n    , tz = 1.5 // torus size\n    , db = dsphere(p - vec3(0,r,0), r) // non-moving ball above origin\n    , dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)) // large box for testing collision\n    , dr = dtubey(p - vec3(0,-.0125,0), vec4(64,.0,.625,.125)) // large low cylindrical tube around origin\n    , dc = 3.4e38 // other stuff\n    ;\n    dx = min(dx, dr);\n    db = min(db, \n       dsphere(p - prot(vec3(0,r,2.*r), vec3(0,1,0), .5*time), r)); // ball above origin    \n    dc = min(dc, dtubey((p - vec3(10,tz+tr,0)).yzx, vec4(tz,0,0,0)) - tr); // big torus to stress shadows\n\tdc = min(dc, dtubey((p - vec3(-10,tz + .1,0)).zxy, vec4(tz,tz,.1,0)) - 0.);\n    Hit h; // = Hit(3.4e38, mSky);\n    h = Hit(dp, mGray);\n    if (h.d > db) h = Hit(db, mRed);\n    if (h.d > dx) h = Hit(dx, mGreen);\n    if (h.d > dc) h = Hit(dc, mBlue);\n    return h;\n}\n\n// bounding clip plane height for entire scene - nothing is taller than this\nconst float hmax = 10.;\n\n// loop using uniform to limit compile time bloat with complex scene\nvec3 SceneNormal(vec3 p, float h, out float d, int izero)\n{\n\tvec3 n, o = vec3(0,0,h);\n\tvec4 s;\n\tfor (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))\n\t\ts[i] = Scene(p + o).d;        \n\tn = s.yzw - (d = s.x);\n\tif (dot(n,n) < 1e-7) n = vec3(0,1,0);\n\telse n = normalize(n);\n\treturn n;\n}\n\nstruct Marched \n{\n\tfloat t;   // distance to intersection\n\tint m;     // material id\n\tfloat nmd; // nearest miss distance\n};\n\nMarched March(vec3 ro, vec3 rd, float thresh, float dmax, int iters)\n{\n\tMarched c = Marched(dmax, mSky, dmax);\n\tint i = iters;\n\tfloat t = 0.;\n\twhile (i-- > 0) {\n\t\tvec3 mp = ro + rd * t;\n\t\tHit h = Scene(mp);\n\t\tfloat d = h.d, ad = abs(d);\n\t\tt += d;\n\t\tc.m = h.m, c.nmd = h.d;\n\t\tif (rd.y >= 0. && (ad > dmax\n\t\t\t|| mp.y > hmax))\n\t\t\tbreak; //t = dmax;\n\t\tif (ad < thresh * t || t >= dmax)\n\t\t\tbreak;\n\t}\n\tc.t = t = clamp(t, 0., dmax);\n\tif (abs(c.nmd) > thresh * 2. * t) \n\t\tc.m = mSky;\n\tif (c.m == mSky)\n\t\tc.t = dmax; // caller won't be able to tell how far it got though\n\treturn c;\n}\n\n// HACK rescue failed marches for planar scenes\nvoid Rescue(inout Marched c, vec3 ro, vec3 rd, float dmax)\n{\n    if (c.m == mSky)\n        if (rd.y >= 0. && ro.y > 0.)\n            c.t = dmax;\n        else {\n            c.t = ro.y / -rd.y;\n            c.m = mGray;\n            c.nmd = 0.;\n        }\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float \n  eyeradius = .25 // collision size\n, eyespeed = 8.   // eye max velocity; shift doubles it\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n, eyeh = 1.5      //0. //.75 - eyeradius // eye height above floor\n, eyeacc = 3.     // eye acceleration\n, eyeldamp = 4.   // eye contact friction\n, eyevdamp = .1   // eye air resistance\n;\nconst vec3 grav = vec3(0,-9.8,0); // gravity force\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    vec2 turn; // keyboard turning\n    float dt; // delta time seconds\n    bool button;\n    bool attract;\n    // debug features TODO\n};\n\nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n, KEY_PGUP  = 33\n, KEY_PGDN  = 34\n// key bindings to local directions\n// can be customized as necessary\n#if 0\n  // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n  // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n  // QWERTY WASD\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n// FIXME up/down controls probably not great for\n// non-QWERTY layouts, but can swap to PGUP/DN\n, KEY_UW    = KEY_SPACE // up\n, KEY_DW    = KEY_C     // down\n// FIXME turn keys will only really work for QWERTY\n, KEY_TURNL = KEY_Q // KEY_DEL\n, KEY_TURNR = KEY_E // KEY_END\n//, KEY_F     = 70\n//, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_TAB   = 9\n;\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n\n#define Kbd      iChannel3\n\nfloat key(int vk)\n{\n    return step(.5, fetch(Kbd, ivec2(vk, 0)).x);\n}\n\nbool option(int vk)\n{\n    return fetch(Kbd, ivec2(vk, 2)).x > .5;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    inp.attract = !inp.button && dot(inp.mouse, inp.mouse) < 4.;\n    if (inp.attract) { // icon?\n        inp.mouse.x = .02*iTime; // slow spin\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    }\n    inp.move =\n      vec3(key(KEY_RT) - key(KEY_LF)\n         , key(KEY_UW) - key(KEY_DW)\n         , key(KEY_FW) - key(KEY_BW))\n    + vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n         , key(KEY_PGUP ) - key(KEY_PGDN)\n         , key(KEY_UP   ) - key(KEY_DOWN)) // arrows alternate controls\n      ;\n    inp.turn = vec2(key(KEY_TURNR) - key(KEY_TURNL), 0);\n    inp.dt = iTimeDelta;\n}\n// vertically-oriented capsule as collision shape\n// ofs = half-seg-offset from center to one end of the core segment,\n// radius of capsule segment poof\n// HACK just tests closest of a string of spheres along the capsule\nvoid CollideCapsule(inout vec3 pos, vec3 ofs, float radius)\n{\n    vec3 p = pos, no; float d = 3.4e38;\n\tint ncapsph = IZERO + 5; //7; //9; //3; //\n\tfor (float d2, st = 2./float(ncapsph), j = -1.; j <= 1.; j += st) {\n\t\tvec3 ns = SceneNormal(p + j * ofs, .1*radius, d2, IZERO);\n\t\tif (d2 < d) { d = d2; no = ns; }\n\t}\n\tpos -= no * min(0., d  - radius);\n}\n\nbool CollideEye(inout vec3 p)\n{\n\tfloat eh = .5 * eyeh - eyeradius;\n\tvec3 po = p; // HACK not best way to detect collision; too late anyway\n\t// FIXME should actually distribute the movement throughout all these iterations - see fixes in Plumbing Maze\n\t// multiple collision iterations to prevent tunnelling at low fps\n\tfor (int i = 3; --i >= 0; ) { // repeating helps with getting stuck in crevices\n\t\tp.y -= eh; // capsule center is below the eyes\n\t\tCollideCapsule(p, vec3(0,eh,0), eyeradius);\n\t\tp.y += eh;\n//\t\tpos.y = max(pos.y, radius + abs(ofs.y)); // HACK prevent going beneath ground plane just in case\n\t} // FIXME the response when stepping up onto steps can be extremely bouncy\n\treturn dot(po-p,po-p) > 1e-8; // must be very sensitive; probably breaks at high fps\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    if (FLY==0 && WALK==0) return;\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed, dt = inp.dt;\n    spd *= 1. + key(KEY_SHIFT);\n    vec3 op = state.eyepos\n    , move = inp.move * dt * spd \n    , p = op\n    ;\n    bool usegravity = !option(KEY_G) // 'G' = 71\n    , walking = WALK!=0 && (FLY==0 || usegravity)\n    , flying = (FLY!=0 && !walking); //FLY!=0 && (WALK==0 || !usegravity)    \n    if (walking) {\n        move = view * move; // to world space\n\t\t// should not be able to fly simply by looking down or up,\n        // so remove portion of input directed along gravity vector\n        move -= grav * dot(move, grav) / dot(grav, grav);\n        // TODO reduce air control - need grounded state\n        // gravity requires velocity state\n    \tstate.eyevel += dt * grav; // gravity force - wrong for Euler integration\n        state.eyevel += 2. * dt * dt * grav; // correction for above issue - unsure if right\n        state.eyevel += move * eyeacc; // control force\n        state.eyevel *= exp2(-dt*vec3(eyeldamp,eyevdamp,eyeldamp)); // damping\n    \tp += dt * state.eyevel; // momentum\n    } else if (flying) {\n     \tp += view * move;\n    }\n    bool collided = false;\n  #if COLLISION    \n    collided = CollideEye(p);\n    // TODO save collided to grounded state?\n  #endif\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, dt);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 5e3 ? .5 : 1.;\n    if (walking && collided && inp.move.y > 0. && dot(state.eyevel, grav) >= 0.)\n        state.eyevel -= .5*grav; // up is jump // TODO sqrt (.5*h)\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = oa;\n    if (state.mbdown && inp.button)\n        a = (inp.mouse - abs(iMouse.zw)) / R * vec2(2) + state.aimbase;\n    a += inp.turn * mix(.5, 1., key(KEY_SHIFT)) * inp.dt;\n    a.x = fract(a.x);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    if (dot(inp.turn,inp.turn) < 1e-3) // only if not key turning, because that doesn't work well\n    \ta = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate mouse aim\n    else\n    // key turning should update the aimbase,\n    // to prevent it snapping back when the mouse is next clicked.\n        state.aimbase = state.eyeaim;\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,eyeh+.5*eyeradius,-4);\n        state.aimbase = \n        state.eyeaim = vec2(0.,.5);\n        state.mbdown = false;\n    } else { // update state\n        MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n        if (state.mbdown && !inp.button) // on mouse up\n    \t    state.aimbase = state.eyeaim; // record aim base\n        state.mbdown = inp.button;\n    }\n}\n\n// Filled with Bayer texture, converted to signed, as example.\nvec4 ExampleData(ivec2 i)\n{\n#define Bayer    iChannel2\n#define BayerRes iChannelResolution[2].xy\n    return fetch(Bayer, i % ivec2(BayerRes)) * 2. - 1.;\n    return vec4(0);\n}\n\nvoid InitData(inout vec4 c, ivec2 p)\n{\n    c = ExampleData(p);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    time = iTime;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    bool init = iFrame == 0;\n    if (!init && i.y < R.y-1 || i.x < R.x-slotCount) discard; // big optimization\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n\t// Usually prior data is loaded and passed through unchanged.\n    vec4 c = fetch(BufA, i);\n    if (init) InitData(c, i);\n    SaveState(c, state, i);\n    o = c;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}