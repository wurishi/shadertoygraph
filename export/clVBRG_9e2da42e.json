{"ver":"0.1","info":{"id":"clVBRG","date":"1704285653","viewed":109,"name":"New year 2024","username":"Shcherbakov","description":"ny","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 ORIGIN = vec3(0, 0, 0);\nvec3 CAMERA_POS = vec3(0, 1, -3);\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    const int numOctaves = 5;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*texture(iChannel0, f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbm( in vec3 p )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*m/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\n\nfloat sph( ivec3 i, vec3 f, ivec3 c )\n{\n   // random radius at grid vertex i+c\n   float rad = 0.5*fbm(vec3(i+c).xy, 4.0);\n   // distance to sphere at grid vertex i+c\n   return length(f-vec3(c)) - rad; \n}\n\nfloat sdBase( vec3 p )\n{\n   ivec3 i = ivec3(floor(p));\n    vec3 f =       fract(p);\n   // distance to the 8 corners spheres\n   return min(min(min(sph(i,f,ivec3(0,0,0)),\n                      sph(i,f,ivec3(0,0,1))),\n                  min(sph(i,f,ivec3(0,1,0)),\n                      sph(i,f,ivec3(0,1,1)))),\n              min(min(sph(i,f,ivec3(1,0,0)),\n                      sph(i,f,ivec3(1,0,1))),\n                  min(sph(i,f,ivec3(1,1,0)),\n                      sph(i,f,ivec3(1,1,1)))));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 5;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        n = smax(n,d-0.1*s,0.3*s);\n        d = smin(n,d      ,0.3*s);\n        q = m*q;\n        q.y *= 0.35;\n        s = 0.415*s;\n\n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n} \n\nconst float precis = 0.0005;\n\nvec2 map( in vec3 p, in float dis )\n{\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    \n    // terrain\n    vec2 dt = sdFbm( p / 2.0, dis*precis, d );\n         \n    return dt;\n}\n\nfloat tmax = 150.0;\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n\n    // raymarch\n    float t = tmin;\n    vec2 h = vec2(0.0,0.0);\n\tfor( int i=0; i<512; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\th = map( pos, t );\n        if( abs(h.x)<(precis*t) || t>tmax ) break;\n\t\tt += h.x   * 1.5; // overstepping\n\t}\n\n\treturn (t<tmax) ? vec3(t,abs(h.y),(h.y<0.0)?2.0:1.0) : vec3(tmax, -1.0, -1);\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\nvec3 traceSnow(vec3 pos, vec3 view)\n{\n    float dist = 0.0;\n    float d = 0.0;\n\n    return raycast(pos, view);\n}\n\nvec3 lightPos = vec3(0, 10, 0);\nvec3 lightDir = vec3(0, -1, 0);\nfloat innerAngle = 30.0;\nfloat outerAngle = 90.0;\nvec3 globeColor = vec3(0.8, 0.8, 1) * 0.1;\nvec3 lightColor = vec3(1, 1, 0.85);\n\nvec3 fog(vec3 pos, vec3 view, float dist, out vec3 fade)\n{\n    vec3 res = vec3(0.0);\n    float st = 0.5;\n    fade = vec3(1.0);\n    pos += view * 0.5;\n    while (dist > 0.0) {\n        vec3 sampleCol = vec3(pow(fbm((pos + vec3(sin(iTime * 0.5), iTime, 0)) * 1.3), 6.3) * 0.8);\n        vec3 toLight = normalize(lightPos - pos);\n        float coneAtten = clamp(1.0 - (dot(lightDir, -toLight) - cos(innerAngle / 180.0))\n        / (cos(outerAngle / 180.0) - cos(innerAngle / 180.0)), 0.0, 1.0);\n        vec3 prevFade = fade;\n        fade *= exp(-0.5 * sampleCol * st);\n        vec3 absorb = prevFade - fade;\n        sampleCol *= (\n            globeColor * 2.0\n            + lightColor * coneAtten * 4.0\n        ) * 8.0;\n        res += sampleCol * absorb;\n        pos += view * st;\n        dist -= st;\n    }\n    return res;\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = texture(iChannel0,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float rotateSpeed = -0.1;\n    float rad = 11.0;\n    CAMERA_POS = vec3(sin(iTime * rotateSpeed) * rad, 4, cos(iTime * rotateSpeed) * rad);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    uv /= 0.5;\n    vec3 centerView = normalize(ORIGIN - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(centerView, up));\n    up = cross(right, centerView);\n    vec3 viewVec = normalize(centerView + uv.x * right + uv.y * up);\n    \n    vec3 traceStart = CAMERA_POS;\n    float dist = traceSnow(traceStart, viewVec).x;\n    vec3 pos = traceStart + viewVec * dist;\n    vec3 normal = calcNormal(pos, dist);\n\n    vec3 toLight = normalize(lightPos - pos);\n    float coneAtten = clamp(1.0 - (dot(lightDir, -toLight) - cos(innerAngle / 180.0))\n        / (cos(outerAngle / 180.0) - cos(innerAngle / 180.0)), 0.0, 1.0);\n    vec3 pointSpecularVec = normalize((\n        texture(iChannel0, pos.xz / 32.0).xyz - vec3(0.5, 0, 0.5)) * vec3(2, 1, 2)\n    );\n    float specLighing = pow(\n        max(dot(toLight, reflect(viewVec, pointSpecularVec)), 0.0), 32.0);\n        \n    vec3 globeDir = vec3(0, 1, 0);\n    float fadeOut = 1.0 - smoothstep(tmax * 0.4 * 0.3, tmax * 0.4, dist);\n    float globeSpecLighing = pow(\n        max(dot(globeDir, reflect(viewVec, pointSpecularVec)), 0.0), 32.0);\n    vec3 snowColor = vec3(0.7);\n    fragColor.rgb = vec3(\n        (\n            max(dot(normal, toLight), 0.0) * snowColor\n            + pow(specLighing, 4.0)\n        )\n    * max(coneAtten, 0.0)) * lightColor\n    + vec3(\n        (\n            max(dot(normal, globeDir), 0.0) * snowColor\n            + globeSpecLighing * 3.0\n        )\n    ) * globeColor;\n    \n    vec3 fogMult;\n    vec3 fogAdd = fog(CAMERA_POS, viewVec, dist, fogMult);\n    fragColor.rgb = fragColor.rgb * fogMult + fogAdd;\n}","name":"Image","description":"","type":"image"}]}