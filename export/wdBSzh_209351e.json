{"ver":"0.1","info":{"id":"wdBSzh","date":"1552861343","viewed":297,"name":"Delta Tracking","username":"Agorq","description":"An implementation of a basic inhomogenous volume renderer. Ported the code from Matthias Raab's  \"Ray Tracing Inhomogeneous Volumes\" chapter.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","volumerendering","deltatracking","inhomogeneous"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 U ) {\n    vec2 uv = U / iResolution.xy;\n    float exposure_scale = 2.0f;\n    // Update display buffer (simple Reinhard tone mapper + gamma).\n    vec3 col = texture(iChannel0,uv).rgb * exposure_scale;\n    col *= (1.0f + col * 0.1f) / (1.0f + col);\n    col.x = min(max(pow(col.x, 2.2f), 0.0f), 1.0f);\n    col.y = min(max(pow(col.y, 2.2f), 0.0f), 1.0f);\n    col.z = min(max(pow(col.z, 2.2f), 0.0f), 1.0f);\n    \n\tO = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654f\n#define TAU ( PI * 2.0f )\n\n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint HashHugo( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;    \n    \n    return n;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nuint max_interactions = 1024u;\n// Camera\nvec3 cam_pos = vec3(0.0f, 0.0f, 1.0f);\nvec3 cam_dir = vec3(0.0f, 0.0f, -1.0f);\nvec3 cam_right = vec3(1.0f, 0.0f, 0.0f);\nvec3 cam_up = vec3(0.0f, 1.0f, 0.0f);\nfloat cam_focal = 1.0f;\n    \n// Volume definition\nfloat majorant = 50.0f;\nfloat max_extinction = 50.0f;\nfloat albedo = 0.8f; // sigma / kappa\n\n////////////////////////////////////////////////////////////////////////////////////\n\nbool intersect_volume_box(inout float tmin, in vec3 raypos, in vec3 raydir) {\n    float x0 = (-0.5f - raypos.x) / raydir.x;\n    float y0 = (-0.5f - raypos.y) / raydir.y;\n    float z0 = (-0.5f - raypos.z) / raydir.z;\n    float x1 = ( 0.5f - raypos.x) / raydir.x;\n    float y1 = ( 0.5f - raypos.y) / raydir.y;\n    float z1 = ( 0.5f - raypos.z) / raydir.z;\n    tmin = max(max(max(min(z0,z1), min(y0,y1)), min(x0,x1)), 0.0f);\n    float tmax = min( min( max(z0, z1), max(y0, y1 ) ), max(x0, x1) );\n    return (tmin < tmax);\n}\n\nbool in_volume(in vec3 pos) {\n    return max(abs(pos.x),max(abs(pos.y),abs(pos.z))) < 0.5f;\n}\n\nfloat get_extinction(in vec3 p) {\n    float r = 0.2f;\n    float a = (PI * 16.0) * p.y;\n    float dx = (cos(a) * r - p.x) * 2.0f;\n    float dy = (sin(a) * r - p.z) * 2.0f;\n\treturn pow(max((1.0f - dx * dx - dy * dy), 0.0f), 8.0f) * max_extinction;\n}\n\nbool sample_interaction(in uint seed, inout vec3 ray_pos, in vec3 ray_dir) {\n    float t = 0.0f;\n    vec3 pos;\n    do {\n        t -= log(1.0f - FRand(seed)) / majorant;\n        pos = ray_pos + ray_dir * t;\n        if (!in_volume(pos)) return false;\n    } while (get_extinction(pos) < FRand(seed) * majorant);\n    ray_pos = pos;\n    return true;\n}\n\nvec3 trace_volume(in uint seed, in vec3 ray_pos, in vec3 ray_dir) {\n    float t0;\n    float w = 1.0f;\n    if (intersect_volume_box(t0, ray_pos, ray_dir)) {\n        ray_pos += ray_dir * t0;\n        uint num_interactions = 0u;\n        while (sample_interaction(seed, ray_pos, ray_dir)) {\n            // Is the path length exceeded?\n            if (num_interactions++ >= max_interactions) return vec3(0.0f, 0.0f, 0.0f);\n            w *= albedo;\n            // Russian roulette absorption\n            if (w < 0.2f) {\n                if (FRand(seed) > w * 5.0f) {\n                    return vec3(0.0f, 0.0f, 0.0f);\n                }\n                w = 0.2f;\n            }\n            // Sample isotropic phase function\n            float phi = TAU * FRand(seed);\n            float cos_theta = 1.0f - 2.0f * FRand(seed);\n            float sin_theta = sqrt (1.0f - cos_theta * cos_theta);\n            ray_dir = vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\n        }\n    }\n    // Look up the environment.\n    float f = (0.5f + 0.5f * ray_dir.y);\n    return vec3(0.5f, (1.0f - f), f) * w;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ) {\n    uint seed = uint( iTime * 23.456 ) + uint(U.x *23.45f) * 12326u + uint(U.y * 36.43) * 42332u;\n    // Trace from the pinhole camera.\n    vec2 uv = U / iResolution.xy;\n    vec2 invRes = 1.0f / iResolution.xy;\n    float pr = (2.0f * (U.x + FRand(seed)) * invRes.x - 1.0f);\n    float pu = (2.0f * (U.y + FRand(seed)) * invRes.y - 1.0f);\n    float aspect = iResolution.y * invRes.x;\n    vec3 ray_pos = cam_pos;\n    vec3 ray_dir = normalize( cam_dir * cam_focal + cam_right * pr + cam_up * aspect * pu);\n    vec3 value = trace_volume(seed, ray_pos, ray_dir);\n    // Accumulate.\n    vec3 prev = texture(iChannel0,uv).rgb;\n    vec3 col = prev + (value - prev) / (float(iFrame) + 1.0f);\n    O = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}