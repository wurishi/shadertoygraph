{"ver":"0.1","info":{"id":"wlKcW3","date":"1611900962","viewed":112,"name":"Color Blind Gamut Compressor","username":"Hatchling","description":"Compresses an normal color vision gamut into a color blind gamut.\nUses bright/dark and blue/yellow to express differences in red/green, exposing details that would be normally invisible to r/g color blind people.\nUses oklab space.\nSee comments.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["colorblindoklabgamutblindcolor"],"hasliked":0,"parentid":"ttKcW3","parentname":"Fork Fork waawa Hatchling 361"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TOP HALF - Shows the results from the gamut optimization.\n//            Takes a few seconds to converge.\n//            Modifies pixel values in oklab space so that\n//            the distances between between neighboring pixels in \n//            the current image (Buffer B)\n//            match the distances between neighboring pixels in \n//            the target image (Buffer A).\n\n// BOTTOM LEFT - What red/green colorblind people would see.\n//               The reddish brick texture is absent.\n\n// BOTTOM RIGHT - What people with normal vision would see.\n//                The reddish brick texture is only visible to r/g\n//                sensitive vision.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    vec4 modified = texture(iChannel1, uv);\n    \n    if(uv.y < 0.5)\n        fragColor = original;\n    else\n        fragColor = modified;\n    \n    if(uv.x < 0.5)\n        fragColor.g = 0.;\n        \n    fragColor.rgb = clamp(Srgb3(oklab_to_rgb(fragColor.rgb)), 0., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n    fragColor = vec4(0.5, 0., 0., 1.);\n    fragColor.r = cos(position.y * 4.0 * 3.1415 * 2.0 / 3.0) * 0.25 + 0.5;\n    fragColor.g = (texture(iChannel0, fragCoord/iResolution.xy).r - 0.5);\n    fragColor.b = sin((position.y - position.x) * 4.0 * 3.1415 * 2.0 / 3.0) * 0.25;\n    fragColor.gb *= 0.5;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    //if(labResult.x != 0.)\n    //    labResult.yz /= labResult.x;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    //c.yz *= c.x;\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 targetC = texture(iChannel0, uv).xyz;\n    vec3 currentC = texture(iChannel1, uv).xyz;\n    \n    if(iFrame == 0)\n        currentC = targetC;\n        \n    float xxx = float(iFrame) * 1.61803398874989484820 * 1.61803398874989484820;\n    xxx -= floor(xxx);\n    xxx *= 10.;\n    float yyy = 1. / (1. + float(iFrame) / 250.0f);\n    float zzz = 1. / (1. + float(iFrame) / 150.0f);\n    \nzzz *= zzz;\n    float offset = 0. + pow\n    (\n        2.0, \n        10. - xxx\n     ) * zzz;\n     float rotation = float(iFrame) * 1.61803398874989484820 * 3.1415927 * 2.;\n     float sinRot = sin(rotation);\n     float cosRot = cos(rotation);\n  \n     \n    vec3 total = vec3(0);\n    int count = 0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*offset;\n            \n            vec2 offset2DRotated = vec2\n            (\n                cosRot * offset2D.x - sinRot * offset2D.y,\n                sinRot * offset2D.x + cosRot * offset2D.y\n            );\n            \n            vec2 coord = (fragCoord+offset2DRotated)/iResolution.xy;\n            \n            if(coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.)\n                continue;\n                \n                \n            vec3 target = texture\n            (\n                iChannel0, \n                coord\n            ).xyz;  \n            \n            vec3 current = texture\n            (\n                iChannel1, \n                coord\n            ).xyz;\n            \n            if(iFrame == 0)\n                current = target;\n            \n            vec3 targetDiff = (targetC - target)*vec3(1,1,1);\n\n            count++;\n            total += current + targetDiff - currentC;\n        }    \n    }\n    \n    if(count > 0)\n        currentC += total * yyy / float(count);\n        \n    currentC.g = 0.;\n        \n    total = vec3(0);\n    count = 0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*offset;\n            \n            vec2 offset2DRotated = vec2\n            (\n                cosRot * offset2D.x - sinRot * offset2D.y,\n                sinRot * offset2D.x + cosRot * offset2D.y\n            );\n            \n            vec2 coord = (fragCoord+offset2DRotated)/iResolution.xy;\n            \n            if(coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.)\n                continue;\n                \n                \n            vec3 target = texture\n            (\n                iChannel0, \n                coord\n            ).xyz;  \n            \n            vec3 current = texture\n            (\n                iChannel1, \n                coord\n            ).xyz;\n            \n            if(iFrame == 0)\n                current = target;\n            \n            vec3 currentDiff = currentC - current;\n            \n            if(length(currentDiff) < 0.00001)\n                continue;\n            float targetDist = length((targetC - target)*vec3(1,3,1));\n            count++;\n            total += current + normalize(currentDiff)*targetDist - currentC;\n        }    \n    }\n    \n    if(count > 0)\n        currentC += total * yyy / float(count);   \n    \n    vec2 targetHueDir = normalize(targetC.yz);\n    currentC.g = 0.;//clamp(currentC.g, -0.1, 0.1);\n    \n    fragColor.rgb = oklab_to_rgb(currentC.rgb);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    fragColor.rgb = rgb_to_oklab(fragColor.rgb);\n}","name":"Buffer B","description":"","type":"buffer"}]}