{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\n#define MAX_STEP 512\n#define EPILSON 0.001\n#define NORMAL_EPILSON 0.1\n#define FOG_START 0.7\n\n\n\nconst float viewDist = 200.0;\nfloat viewDist8 = viewDist*0.8;\nfloat fogViewMult = 1.0/FOG_START;\n\n\n\nvec3 lightDir = normalize(vec3(40.0,40.0,40.0));\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\n\n\n\n//calculate normal of triangle\nvec3 calculateNormal(in vec3 p1, in vec3 p2, in vec3 p3) {\n    vec3 u = p2-p1;\n    vec3 v = p3-p1;\n    \n    return cross(u,v);\n}\n\n\n\n//distance functions\n//a lot are take from iq's site https://iquilezles.org/articles/distfunctions\n\nfloat sphere(in vec3 p, in float radius) {//signed\n    return length(p)-radius;\n}\nvec3 sphereNormal(in vec3 p, in float radius) {\n    return normalize(vec3(\n        sphere(vec3(p.x+NORMAL_EPILSON,p.y,p.z),radius)-sphere(vec3(p.x-NORMAL_EPILSON,p.y,p.z),radius),\n        \n\t\tsphere(vec3(p.x,p.y+NORMAL_EPILSON,p.z),radius)-sphere(vec3(p.x,p.y-NORMAL_EPILSON,p.z),radius),\n        \n        sphere(vec3(p.x,p.y,p.z+NORMAL_EPILSON),radius)-sphere(vec3(p.x,p.y,p.z-NORMAL_EPILSON),radius)\n        ));\n}\n\nfloat roundBox(in vec3 p, in vec3 boxExt, in float round) {//unsigned\n    return length(max(abs(p)-boxExt,0.0))-round;\n}\nvec3 roundBoxNormal(in vec3 p, in vec3 boxExt, in float round) {\n    return normalize(vec3(\n        roundBox(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt, round)-roundBox(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt,round),\n        \n\t\troundBox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt, round)-roundBox(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt,round),\n        \n        roundBox(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt, round)-roundBox(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt,round)\n        ));\n}\n\nfloat box(in vec3 p, in vec3 boxExt) {//unsigned\n    return length(max(abs(p)-boxExt,0.0));\n}\nvec3 boxNormal(in vec3 p, in vec3 boxExt) {\n    return normalize(vec3(\n        box(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt)-box(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt),\n        \n\t\tbox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt)-box(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt),\n        \n        box(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt)-box(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt)\n        ));\n}\n\n\n\nfloat torus(in vec3 p, in vec2 size) {//signed\n \treturn length(\n        \t\tvec2(length(p.xz)-size.x,p.y)\n                 )-size.y;\n}\nvec3 torusNormal(in vec3 p, in vec2 size) {\n    return normalize(vec3(\n        torus(vec3(p.x+NORMAL_EPILSON,p.y,p.z), size)-torus(vec3(p.x-NORMAL_EPILSON,p.y,p.z),size),\n        \n\t\ttorus(vec3(p.x,p.y+NORMAL_EPILSON,p.z), size)-torus(vec3(p.x,p.y-NORMAL_EPILSON,p.z),size),\n        \n        torus(vec3(p.x,p.y,p.z+NORMAL_EPILSON), size)-torus(vec3(p.x,p.y,p.z-NORMAL_EPILSON),size)\n        ));\n}\n\n\nfloat capsuleLine(in vec3 p, in vec3 v1, in vec3 v2, in float r) {//signed\n    vec3 pa = p - v1, ba = v2 - v1;\n    return length(pa - ba * clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 )) - r;\n}\nvec3 capsuleLineNormal(in vec3 p, in vec3 v1, in vec3 v2, in float r) {\n    return normalize(vec3(\n        capsuleLine(vec3(p.x+NORMAL_EPILSON,p.y,p.z), v1, v2, r)-capsuleLine(vec3(p.x-NORMAL_EPILSON,p.y,p.z), v1, v2, r),\n        \n\t\tcapsuleLine(vec3(p.x,p.y+NORMAL_EPILSON,p.z), v1, v2, r)-capsuleLine(vec3(p.x,p.y-NORMAL_EPILSON,p.z), v1, v2, r),\n        \n        capsuleLine(vec3(p.x,p.y,p.z+NORMAL_EPILSON), v1, v2, r)-capsuleLine(vec3(p.x,p.y,p.z-NORMAL_EPILSON),v1,v2,r)\n        ));\n}\n\n\nfloat cylinder(in vec3 p, in vec2 size) {//signed\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - size;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 cylinderNormal(in vec3 p, in vec2 size) {\n    return normalize(vec3(\n        cylinder(vec3(p.x+NORMAL_EPILSON,p.y,p.z), size)-cylinder(vec3(p.x-NORMAL_EPILSON,p.y,p.z), size),\n        \n\t\tcylinder(vec3(p.x,p.y+NORMAL_EPILSON,p.z), size)-cylinder(vec3(p.x,p.y-NORMAL_EPILSON,p.z), size),\n        \n        cylinder(vec3(p.x,p.y,p.z+NORMAL_EPILSON), size)-cylinder(vec3(p.x,p.y,p.z-NORMAL_EPILSON), size)\n        ));\n}\n\n\n\n//ray tracing functions\nfloat rayBox(in vec3 rayPos, in vec3 rayDir, in vec3 boxMin, in vec3 boxMax, out float tmin, out float tmax) {\n    vec3 dirFrac = vec3(1.0)/rayDir;\n    float d = 0.0;\n\n    vec3 tMinExt = (boxMin-rayPos)*dirFrac;\n    vec3 tMaxExt = (boxMax-rayPos)*dirFrac;\n    \n    tmin = max(max(min(tMinExt.x, tMaxExt.x), min(tMinExt.y, tMaxExt.y)), min(tMinExt.z, tMaxExt.z));\n    tmax = min(min(max(tMinExt.x, tMaxExt.x), max(tMinExt.y, tMaxExt.y)), max(tMinExt.z, tMaxExt.z));\n\n    \n    if (tmax < 0.0) {\n        return 0.0;\n    }\n\n    if (tmin > tmax) {\n        return 0.0;\n    }\n\n    return tmin;    \n}\n\n\nfloat raySphere(in vec3 p, in vec3 dir, in float sphereRad) {\n    \n    float c = dot(p, p) - (sphereRad*sphereRad);\n    float b = dot(dir, p);\n\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    \n    if (!(d < 0.0 || t < 0.0)) {\n        return t;\n    } else {\n    \treturn 0.0;\n    }\n    \n}\n\n\n\n\n//scene functions\n\nfloat s;\n\nconst vec3 NE = vec3(NORMAL_EPILSON,0.0,0.0);\n\nconst vec2 colRepeat = vec2(12.0,16.0);\nfloat columns(in vec3 p) {\n    vec2 pos = mod(p.xz,colRepeat)-0.5*colRepeat;\n    float powY = -pow(p.y,sin(iTime*0.2)+1.0);\n    pos.x += sign(pos.x)*powY;\n    pos.y += sign(pos.y)*powY;\n    \n    return length(max(abs(pos)-vec2(0.5),0.0))*(s/viewDist8+0.2);\n}\nvec3 columnsNorm(in vec3 p) {\n    return normalize(vec3(columns(p+NE.xyz)-columns(p-NE.xyz),\n                     columns(p+NE.yxz)-columns(p-NE.yxz),\n                     columns(p+NE.yzx)-columns(p-NE.yzx)));\n}\n\n\nvoid scene(in vec3 rayPos, out int hitId, out float hitDist) {\n    float db;\n    \n    hitId = 0;\n\thitDist = rayPos.y+3.0;\n    \n    db = columns(rayPos);\n    if (db < hitDist) {\n        hitId = 1;\n        hitDist = db;\n    }\n}\n\n\nvoid trace(in vec3 rayStartPos, in vec3 rayStartDir, in float maxDist, out int hitId, out float hitDist) {\n    \n    s = 0.0;\n    vec3 rayPos;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        //get new ray pos\n        rayPos = rayStartPos+rayStartDir*s;\n        \n\t\tscene(rayPos,hitId,hitDist);\n        \n        if (hitDist < EPILSON*s) {\n            hitDist = s;\n            return;\n        }\n        \n\n        s += hitDist;\n        if (s >= maxDist) {\n            break;\n        }\n    }\n    \n    hitDist = maxDist;\n    hitId = -1;//hit id is -1 if nothing is hit\n}\n\n\n\n\n\n//AMBIENT OCCLUSION\n\n#define AO_ITERATIONS 2\n#define AO_PRECISION 0.2\n#define AO_INTENSITY 0.7\n#define AO_ATTEN 0.5\n\nfloat ao(in vec3 p, in vec3 norm) {\n\tfloat sum = 0.0;\n\tfloat atten = 1.0;\n\tfloat s = AO_PRECISION;\n    \n    int hitId = 0;\n    float hitDist = 0.0;\n    \n\tfor (int i = 0; i < AO_ITERATIONS; i++) {\n        scene(p+norm*s,hitId,hitDist);\n        \n\t\tsum += (s-hitDist)*atten;\t\t\n\t\ts += AO_PRECISION;\t\n\t\tatten *= AO_ATTEN;\n\t}\n\t\n\treturn 1.0-max(0.0,sum*AO_INTENSITY);\n}\n\n\n//main\n\nconst vec3 PLANE_NORM = vec3(0.0,1.0,0.0);\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //calculate camera\n    cameraPosition = vec3(iTime*1.4,0.0,iTime*3.0);\n    \n    cameraDirection = normalize(vec3(sin(iTime*0.5)*0.3,-0.2+sin(iTime*0.3)*0.1,1.0));\n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);   \n   \n        \n  \tvec3 rayStartDir = normalize((cUv.x*cameraRight +\n                  \t\t\t\tcUv.y*cameraUp +\n        \t\t  \t\t\t\tcameraPosition + cameraDirection)-cameraPosition);\n    vec3 rayStartPos = cameraPosition;\n    \n\n    //scene\n    \n    int hitId;\n    float hitDist;\n    trace(rayStartPos,rayStartDir,viewDist,hitId,hitDist);\n    \n    vec3 hitPos = rayStartPos+rayStartDir*hitDist;\n    \n    \n    if (hitId == 0) {\n        vec4 samp = vec4(0.6)+texture(iChannel2,hitPos.xz*0.5)*0.2;\n        vec3 norm = vec3(0.0,1.0,0.0);\n        \n\t\tfragColor = samp*0.2+samp*ao(hitPos,norm);\n        return;\n    }\n    \n    if (hitId == 1) {\n        vec3 norm = columnsNorm(hitPos);\n        vec4 samp = vec4(0.6)+texture(iChannel2,hitPos.xz+hitPos.yy)*0.2;\n        \n        fragColor = samp*0.2+max(0.0,dot(-cameraDirection,norm))*samp;\n        return;\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlfGzl","date":"1424129422","viewed":166,"name":"arches","username":"public_int_i","description":"arches\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["arches"],"hasliked":0,"parentid":"","parentname":""}}