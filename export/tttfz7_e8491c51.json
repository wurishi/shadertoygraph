{"ver":"0.1","info":{"id":"tttfz7","date":"1612462891","viewed":110,"name":"3d noise shader","username":"itsjonebone","description":"extending my 2D noise shader ( https://www.shadertoy.com/view/3lcfz7 ) to 3D.\nInspired by Andrew Schneider's chapter in GPU Pro 7 \na much nicer version, made by piyushslayer, is available here:\nhttps://www.shadertoy.com/view/3dVXDc","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cloud","perlin","worley"],"hasliked":0,"parentid":"3lcfz7","parentname":"2D Perlin and inverse Worley"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// image will be comprised of t x t tiles\nfloat t = 1.0; \n// noises start generation with freq x freq cells\nfloat freq = 5.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // create tiles\n    uv *= t;\n    // add time XY animation\n    uv -= 0.05 * iTime;\n    uv = fract(uv);\n    \n    // make uv 3D with time varying third dimension\n    vec3 uvw = vec3(uv, fract(0.025 * iTime));\n    \n    vec3 col = vec3(0.0);\n  /// => comment/uncomment these lines to see individual parts\n    //col += worley(uvw * freq, freq);\n    //col += worleyFBM(uvw, freq);\n    //col = vec3(perlin(uvw, freq));\n    //col = vec3(perlinFBM(uvw, freq, 7));\n    col = vec3(puffyPerlin(uvw, freq));\n    //col = vec3(perlin_worley(uvw, freq));\n    \n    //if (fragCoord.x > iResolution.x / 2.) col = vec3(remap(cloud(uvw, freq), 0.69, 1., 0., 1.));\n    //else col = vec3(cloud(uvw, freq));\n    \n    \n    // Output color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// *** noisemaking in here *** ////\n\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec3 poi_gen (vec3 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    // NB: side effect of fract is that all values will be positive \n    return fract(sin(vec3(\n                dot(gridIndex + 1.0, vec3(127.4, 723.8, 872.4)),\n                dot(gridIndex + 1.0, vec3(387.4, 275.4, 567.6)),\n                dot(gridIndex + 1.0, vec3(837.7, 208.7, 576.4)) )) * 25787.33);\n}\n\n/// Inverse Worley Noise \nfloat worley(vec3 p, float freq) {\n    // split p into id and position\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    \n    float minDist = 1000.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 poi = poi_gen(mod(id + offset, vec3(freq))); // use mod for tiling\n                poi += offset;\n                vec3 diff = poi - pos;\n                minDist = min(minDist, length(diff));\n            }\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec3 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n//// PERLIN\n// Perlin noise is a varient of gradient noise\n// gradient noise works by interpolating between random values at cell corners\n// Perlin noise does the same interpolation of values\n// but the Perlin values are found by taking the dot product of \n// a normal vector in a random direction from a cell corner\n// and the vector from that cell corner to the point in question\n// for more check out http://physbam.stanford.edu/cs448x/old/Procedural_Noise(2f)Categories.html\n\n/// Perlin Hash\nvec3 hash(vec3 p) {\n    vec3 poi = poi_gen(p);\n    // my poi_gen function makes values between 0 and 1\n    // this limits the directionality if we used poi_gen alone to get vectors\n    // below is a simplified remap from 0...1 to -1...1 \n    poi = vec3(-1.) + (poi * 2.);\n    return normalize(poi);\n}\n\n/// Perlin noise generator \n// get vectors using perlin hash\n// dot vectors by (offset - pos)\n// interpolate values\nfloat perlin(vec3 uvw, float freq) {\n    vec3 p = uvw * freq;\n    // split into ID and position\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    \n    // dotted vals\n    float a0 = dot(hash(mod(id + vec3(0., 0., 0.), freq)), pos - vec3(0., 0., 0.));\n    float b0 = dot(hash(mod(id + vec3(1., 0., 0.), freq)), pos - vec3(1., 0., 0.));\n    float c0 = dot(hash(mod(id + vec3(0., 1., 0.), freq)), pos - vec3(0., 1., 0.));\n    float d0 = dot(hash(mod(id + vec3(1., 1., 0.), freq)), pos - vec3(1., 1., 0.));\n    \n    float a1 = dot(hash(mod(id + vec3(0., 0., 1.), freq)), pos - vec3(0., 0., 1.));\n    float b1 = dot(hash(mod(id + vec3(1., 0., 1.), freq)), pos - vec3(1., 0., 1.));\n    float c1 = dot(hash(mod(id + vec3(0., 1., 1.), freq)), pos - vec3(0., 1., 1.));\n    float d1 = dot(hash(mod(id + vec3(1., 1., 1.), freq)), pos - vec3(1., 1., 1.));\n    \n    //smooth interpolation\n    //vec3 u = smoothstep(0., 1., pos);\n    \n    // quintic interpolation (6pos^5 - 15pos^4 + 10pos^3)\n    vec3 u = pos * pos * pos * (pos *(pos * 6.0 - 15.0) + 10.0);\n    \n    // interpolation based on iq's blog article on gradient noise\n    // https://iquilezles.org/articles/gradientnoise\n    return a0 + \n           u.x *(b0 - a0) + \n           u.y *(c0 - a0) + \n           u.z *(a1 - a0) + \n           u.x * u.y * (a0 - b0 - c0 + d0) + \n           u.y * u.z * (a0 - c0 - a1 + c1) + \n           u.z * u.x * (a0 - b0 - a1 + b1) + \n           u.x * u.y * u.z * (-a0 + b0 + c0 - d0 + a1 - b1 - c1 + d1);\n    \n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec3 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n    return noise;\n}\n\n/// Puffy Perlin\n// had to do some witchcraft here to look like figure 4.5 in GPU Pro 7\n// tbh not sure why it was like this\nfloat puffyPerlin(vec3 p, float freq) {\n    float puff = abs(abs(perlinFBM(p, freq, 7)) * 2. - 1.);\n    return remap(puff, 1., 0., 0., 1.);\n}\n\n//// PerlinWorley\n\n/// Perlin-Worley noise combined\n// puffy Perlin noise is remapped with Worley as the new min\nfloat perlin_worley(vec3 uv, float freq) {\n    float w = worleyFBM(uv, freq);\n    float p = puffyPerlin(uv, freq);\n    return remap(p, 0., 1., w, 1.);\n}\n\n/// cloud\n// a combination of Perlin-Worley noise and a few octaves of Worley noise\n// described in GPU Pro 7 within the \"Cloud Sampler\" section\nfloat cloud(vec3 uv, float freq) {\n    float pw = perlin_worley(uv, freq);\n    float wg = worleyFBM(uv, freq);\n    float wb = worleyFBM(uv, freq * 2.);\n    float wa = worleyFBM(uv, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}