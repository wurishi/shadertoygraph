{"ver":"0.1","info":{"id":"l3dSDH","date":"1718982385","viewed":46,"name":"My First Ray Marched World","username":"Joshy20XX","description":"My first public ray marched world with different materials.\n\nSources:\n-------------\nInspirnation's Ray Marching Tutorial:\nhttps://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\n\nShane's Raymarched Reflections:\nhttps://www.shadertoy.com/view/4d\n\n\n\n\n\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner","tutorialexample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rtime iTime\n#define PI 3.14159265359\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float REFLECT_PRECISION = 0.002;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\n//X rotation\nmat3 rotX(float theta) {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, cos(theta), -sin(theta)),\n        vec3(0, sin(theta), cos(theta))\n    );\n}\n\n//Y rotation\nmat3 rotY(float theta) {\n    return mat3 (\n        vec3(cos(theta), 0, sin(theta)),\n        vec3(0, 1, 0),\n        vec3(-sin(theta), 0, cos(theta))\n    );\n}\n\n//Z rotation\nmat3 rotZ(float theta) {\n    return mat3 (\n        vec3(cos(theta), -sin(theta), 0),\n        vec3(sin(theta), cos(theta), 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//Identity matrix\nmat3 identity() {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(sdFloor(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(sdSphere(p - vec3(5. * cos(rtime)/11. * -5.1, sin(rtime)/5. * 9.0, -5), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(sdSphere(p - vec3(1. * cos(rtime)/5. * -15.5, sin(rtime)/5. * 2.0, 3), 1.), 2.5); // ID = 2.5\n  vec2 sphereMiddle = vec2(sdSphere(p - vec3(2. * cos(rtime)/8. * 4.1, sin(rtime)/5. * 1.0, 5.), 1.), 3.5); // ID = 3.5\n\n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  res = opU(res, sphereMiddle);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec2 rayMarch_ref(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < REFLECT_PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 getRefColor(in vec3 ro, in vec3 rd, float id, vec3 normal) {\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - ro);\n    vec3 attenuation = vec3(1.0);\n    float dif = clamp(dot(normal, lightDirection), 0.5, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.); //Frensel material tutorial: https://inspirnathan.com/posts/58-shadertoy-tutorial-part-12\n    attenuation *= 0.5;\n    vec3 sceneColor = dif * attenuation;\n    vec3 difColor = vec3(0.039,0.678,1.000);\n    \n    if (id > 0.) sceneColor = dif * vec3(0.2 + .3*mod(floor(ro.x) + sin(ro.z), 2.0));\n    if (id > 1.) sceneColor = dif + 9. * vec3(1.000,0.000,0.000);;\n    if (id > 2.) sceneColor = (dif * difColor) + frensel * vec3(0.000,0.059,0.400);\n    \n    return sceneColor;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    //Trace ray\n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n    \n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    //Material properties\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.); //Render SDF with Frensel model\n    vec3 difColor = vec3(0.039,0.678,1.000);\n    \n    // get ray direction\n    vec3 ref_Rd = rd;\n    vec3 ref_Ro = ro;\n    vec3 ref_Normal = calcNormal(p);\n    \n    //render reflection \n    ref_Ro += ref_Rd * d; //Update the reflected ray's origin\n    ref_Rd = reflect(ref_Rd, ref_Normal);\n    res = rayMarch_ref(ref_Ro + ref_Normal * .003, ref_Rd);\n    \n    float d_ref = res.x; //reflection signed distance value\n    \n    float ref_id = res.y; //the id of the reflected object\n    col += getRefColor(ref_Ro, ref_Rd, ref_id, normal);\n    \n    vec3 reflection = vec3(d_ref) + col; //reflection material\n    \n    if (id > 0.) col = dif * vec3(0.2 + .3*mod(floor(p.x) + sin(p.z), 2.0)); //tiled floor\n    if (id > 1.) col = dif * vec3(0.800,0.498,0.498); //Front sdf sphere\n    if (id > 2.) col = (dif * difColor) + frensel * vec3(0.000,1.000,0.482); //Middle sdf sphere\n    if (id > 3.) col = (dif * difColor) * reflection + frensel * vec3(0.259,0.475,0.580); //Back sdf sphere\n    \n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(7.5, .7, -6.); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotY((sin(1.5) * -.65) * (2. * PI));\n\n  vec3 col = render(ro, rd);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}