{"ver":"0.1","info":{"id":"Mt3BRj","date":"1540328824","viewed":279,"name":"Square cubed","username":"AntoineC","description":"Squishing rhombus to morph from squares to cubes!","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","loop","minimalist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Square Cubed\" by Antoine Clappier - Oct 2018\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n\n#define Pi     3.14159265359\n#define Tau    6.28318530718\n\n#define ToRad(a)     ((a)*Pi/180.0)\n#define ToDeg(a)     ((a)*180.0/Pi)\n\n#define Rot(a)       mat3(cos(ToRad(a)),-sin(ToRad(a)),0.,sin(ToRad(a)),cos(ToRad(a)),0.,0.,0.,1.)\n#define RotP(a,p)    (Translate(-p)*Rot(a)*Translate(p))\n#define Rot45        Rot(45.0)\n#define Scale(s)     mat3(1./(s),0.,0.,0.,1./(s),0.,0.,0.,1.0)\n#define Translate(t) mat3(1.,0.,0.,0.,1.,0.,-(t).x,-(t).y,1.0)\n\n\n#define Count 2.0\n#define Duration 15.0\n\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n\n// IQâ€™s Exact signed distance of a Rhombus\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat RhombusSd(in vec3 p, in vec2 size) \n{\n    vec2 q = abs(p.xy);\n\n    float h = clamp( (-2.0*ndot(q,size) + ndot(size,size) )/dot(size,size), -1.0, 1.0 );\n    float d = length( q - 0.5*size*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*size.y + q.y*size.x - size.x*size.y );\n}\n\nfloat RhombusSd(in vec2 p, in vec2 size) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,size) + ndot(size,size) )/dot(size,size), -1.0, 1.0 );\n    float d = length( q - 0.5*size*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*size.y + q.y*size.x - size.x*size.y );\n}\n\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n\n\nvec4 Tile(vec2 uvi, vec2 uvf, float eps, float t)\n{\n    // Tweeners:\n    float t0 = smoothstep(    0.0, 1.0/3.0, t);\n    float t1 = smoothstep(1.0/3.0, 2.0/3.0, t);\n    float t2 = smoothstep(2.0/3.0,     1.0, t);\n    float ts = mix(t0, 1.0-t2, step(0.5,t));\n \n    // Cube/hexagon center:\n    float cc = sqrt(3.0)/6.0;\n    vec2 ccc = vec2(cc-0.5, 0.5-cc);\n    \n    // Post rotation and translation:\n    mat3 post;\n    post =  Translate(ccc*(t2-t0));\n    post *= Rot(180.*t1);\n    \n   \n    // Rhombus transforms:\n    mat3 tfm0, tfm1, tfm2;\n    tfm0  = Rot45*Translate(vec2(-0.5,0.5));\n    tfm0 *= post;\n\n    tfm1 =  Rot(135.)*Translate(vec2(-0.5,-0.5));\n    tfm1 *= RotP(30.*(t0-t2), vec2(-1.0,0.0));\n    tfm1 *= post;\n    \n    tfm2  = Rot(135.)*Translate(vec2(0.5,0.5));\n    tfm2 *= RotP(30.*(t2-t0), vec2(0.0,1.0));\n    tfm2 *= post;\n                     \n    // Rhombus size:\n    vec2 s = vec2(1.0, mix(1.0, sqrt(3.0)/3.0, ts)) / sqrt(2.0);\n    \n    // Draw Rhombus:\n    vec3 uvh = vec3(uvf,1.0);\n    vec4 c = vec4(0.0);\n    eps *= 1.5;\n    c = mix(vec4(vec3(0.2),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm2*uvh, s)));\n    c = mix(vec4(vec3(0.8),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm0*uvh, s)));\n    c = mix(vec4(vec3(0.5),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm1*uvh, s)));\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates:\n    float eps = 2.0/iResolution.y;\n    vec2  uv =  eps*(fragCoord - 0.5*iResolution.xy);\n\tfloat t  = fract(iTime/Duration);\n    \n    // Rotate field:\n    float tr = 0.3*t+0.7*smoothstep(0.0, 1.0, t);\n    uv = (Rot(-180.*tr)*vec3(uv,1.)).xy;\n    \n    // Tiling:\n    vec2 uvf, uvi;\n    uv = uv*Count - vec2(0.5);\n    uvi = floor(uv);\n    uvf = 2.0*fract(uv)-1.0;\n    eps *= 2.0*Count;\n\n    // Render tile:\n    vec4 tile = Tile(uvi, uvf, eps, t);\n    vec4 col = mix(vec4(0.0), tile, tile.a);\n  \n    // Output:\n    fragColor = col;\n    \n}","name":"Image","description":"","type":"image"}]}