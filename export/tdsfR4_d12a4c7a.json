{"ver":"0.1","info":{"id":"tdsfR4","date":"1589815765","viewed":347,"name":"Fly Camera","username":"spalmer","description":"Simple fly camera\nwith sphere collision, boilerplate ray marcher.\nControlled by Mouse+Arrows+PgUp/Dn+WASD+C+Space.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["collision","raymarch","camera","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// my goal here is to do something like Debug Camera\n// but with a few important changes:\n// *  use no code from any other shaders,\n//    so I can minimize references and citations in new shaders,\n// *  use ray marching, not ray tracing\n// *  plan for a scene with more complicated materials and objects\n// *  simplify the heck out of the camera representation\n//    since I'm sure it can be stored as 2 fullturns euler angles and position\n//    (drat! forgot about mouse, resolution, etc..)\n// *  anticipate the buffer being used for other data\n// *  no numeric output support\n// *  TODO parameterize lighting for BxDF, not diffuse+specular hacks\n// *  TODO find some way to antialias the silhouette marches without supersampling\n\n// btw walking first person controller at http://shadertoy.com/view/wlfcz2\n\n// Image tab doesn't access input state directly (no mouse, keyboard, timing)\n// but everything comes from State produced by BufferA tab.\n\n// maybe it should keep this extremely simple lighting and fog!\n// I usually wind up stuck with oversimplified crappy lighting\n// because everything leans toward the approach used instead of\n// toward light transfer functions like it should be, so maybe\n// I should spend time on that here.  It's not so bad rn,\n// the shadows are getting somewhere, but still need work imho.\n\n// atmo looks halfway decent now, it's all hacks though;\n// seriously, this is still sort of a 'starter' sky dome\n\n#define BluNoiz iChannel3\n#define BNzRes iChannelResolution[3].xy\n\nconst float\n  fogdensity = .002\n, maxdepth = 6e3 //1e2 //3.4e38 //8.5e4 //\n, shfalloff = 2. //.5 // exponent of curve\n, shd = 4. //10. //8. //16. //24. // soft shadow trace distance\n, sc = 2.5  // soft shadow crispness\n, sfuzz = .0 //.05 // HACK fade contribution with scan range - HACK for penumbra (not mixed correctly though, so doesn't really work well)\n, aod = .3 // ao distance\n, ambient = .25 // balance between ambient and direct light\n, nitebrite = .06 // how dark the lighting gets at night, essentially night time ambient light level\n, lfloor = .02 // lighting floor, limits how deep shadows can get, fake global ambient\n;\n// TODO if let it get this dark, should add twinkly stars at night!  \n// Or a moon, but then this template will be really heavyweight.\nconst vec3\n, csun = vec3( 1., .95, .79) // light color\n, csky = vec3(.11, .33, .99) // fake, gets dimmed by sun angle though\n;\n// btw tweaking light color may be confusing;\n// may wonder why your scene colors look tinted!\n\n// maybe should think of a better idea, but it's multipurpose DoF and SSAA and temporal motion blur\n// so at least we get some mileage out of the extra work done tracing and lighting the scene multiple times\nconst int SSAA = 4; //6; //1; //5; //12; //7; //3; //48; //32; //16; // how strong is your GPU?\n// attempting to scale by resolution,\n// automatically reducing samples as needed.\n// only smaller windows will get the full count.\nconst int marchsteps = 96; //64; //128; //\n\nconst int shadowsteps = 16; //24; //32; //8; //\n\nvec3 sunDir; // animated in mainImage\n\n// compute material (albedo for now) from id\nvec3 Material(int i, vec3 p, vec3 n, float d)\n{\n    //n *= 0.; // HACK show ALL sides of texture at full strength\n    float tscale = 32.;\n    vec3 a, t = abs(sin(tscale*p + .25*tau));\n    float f = dot(1.-n*n, t) // triplanar texture\n         * exp2(-4.*tscale/iResolution.y*d) * .25 // distance fade\n        + .5\n      , e = .1*f; // don't want any black components, desaturate a bit\n    switch (i) {\n      default:\n      case mSky:   a = vec3(  e  ); break;\n      case mGray:  a = vec3(  f  ); break;\n      case mRed:   a = vec3(f,e,e); break;\n      case mGreen: a = vec3(e,f,e); break;\n      case mBlue:  a = vec3(e,e,f); break;\n    }\n    return a;\n}\n         \nfloat Shadow(vec3 p, vec3 n, vec3 l, float hd, float d, float rnd, int ssteps)\n{\n    float nl = max(0., dot(n, l))\n    , ao = /*sqrt*/(clamp((Scene(p + n * aod).d - hd) / aod, 0., 1.));\n    if (nl > 1e-4) {\n    \tvec3 sht = sunDir * shd\n    \t, hp = p + n * .002; // self-shadow bias hit position\n        int iters = max(1, int(rnd + float(ssteps) / (1.+.002*d)));\n        float sh = 1.; // min shadow factor found so far\n        for (int i = iters; i-- > 0; ) {\n    \t\tfloat f = (float(i) + 1.) / float(iters)\n    \t\t// must distribute the samples nonlinearly\n\t\t\t// to support long shadow trace distances.\n\t\t\t// need more samples close to the receiver.\n\t\t\t, ff = f * f\n\t\t\t, v = max((Scene(p + sht * ff).d - hd + sfuzz * f) * sc / shd / nl / ff, 0.);\n\t\t\tsh = min(sh, v); //sh = min(sh, v * (2.-f)); //sh *= mix(v, 1., f); //sh *= v; //\n        }\n        // hoisted sqrt and part of clamp out of loop\n        sh = /*sqrt*/(min(sh, 1.));\n        sh = pow(sh, shfalloff);\n\t    nl *= sh; // fake soft shadow attenuates direct lighting\n    }\n    //nl = max(nl, ao);\n    //nl *= max(0., mix(ao, 1., .2));  // fake AO\n    //nl = mix(nl, 1., ambient);  // HACK ambient floor\n    //float af = min(mix(ao, 1., ambient), 1.);\n    //nl = mix(nl, 1., af);\n    // FIXME I still don't like how I've mixed the factors, really.\n    // FIXME ambient light should have a color from the surrounding environment bounces,\n    // so should be based on albedo of nearby surfaces\n    // as a major HACK can use our *own* albedo since it does contribute somewhat due to interreflections\n    float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient\n    nl *= (1.-ambient); // leave room for ambient factor\n    nl += ah * ao; // hemi ambient only where not occluded\n    //nl /= (1. + ambient); // I like this mixing better\n    nl = clamp(nl, 0., 1.);\n    // must have some minimum lighting floor to prevent harsh black ao in shadows\n    nl = mix(nl, 1., lfloor); // after clamping\n//    nl = 1.; // HACK disable lighting\n    return nl;\n}\n\nvec3 Light(int m, vec3 p, vec3 v, float d, float rnd)\n{\n    float h = 3e-4 * (d + 1.) //2e-3 * clamp(d, .01, 100.) //\n    , hd;\n    vec3 n = SceneNormal(p, h, hd, IZERO)\n    , albedo = Material(m, p, n, d)\n    , c = albedo;\n    float nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO)\n    , fogscale = fogdensity // / dmax * 8.5e4; // TODO scale by dmax somehow?\n    , fexp = exp2(-fogscale * d);\n    // TODO replace with custom illumination\n    c *= nl * mix(sunDir.y, 1., .5+.5*nitebrite);\n    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color\n        + (1.-fexp) * .7 * pow(clamp(1.-abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog\n        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)\n        + .87*pow(max(0., dot(-v, sunDir) * .5 + .5), 16.); // fake mie, sun halo\n    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)\n    c = clamp(c, 0., 1.);\n//    if (hd <-2e-3*d) c = vec3(20,1,0); // DEBUG orange where march penetrated surface - usually only happens in the far distance where rays hit at very shallow angles, presumably due to numerical inaccuracy\n//    if (hd > 2e-3*d) c = vec3(10,0,9); // DEBUG violet where march missed surface\n    //c *= n * .5 + .5; // DEBUG hit normal\n    return c;\n}\n// TODO Plumbing Maze has a head lamp / flashlight, seems we could use one at night time\nvec3 Render(vec3 ro, vec3 rd, float rnd, out float depth)\n{\n    Marched mr = March(ro, rd, 2e-3, maxdepth, marchsteps + IZERO);\n    Rescue(mr, ro, rd, maxdepth); // HACK\n    float t = mr.t // trace depth to first hit\n        , hd; // distance at hit point\n    int m = mr.m;\n    vec3 hp = ro + rd * t\n    , c = Light(m, hp, -rd, t, rnd);\n    depth = mr.t;\n    return c;\n}\n\n// input is a vector in view space\n// result will be normalized which would\n// ordinarily result in a planar projection\n// if nothing else were done\nvec3 ProjectionSetup(vec3 v)\n{\n    // can convert to some other vector form though to obtain various lens effects\n#if 0\n    // spherical (fisheye) has severe problems because it warps straight lines in most situations\n    // but actually results in the least distortion in screen corner regions compared to center\n    // since in theory it preserves angles perfectly.  Unfortunately nobody has such a monitor to view it on.\n    v.xy *= .16*tau/v.z; return vec3(sin(v.xy), cos(v.x) * cos(v.y));\n#elif 0\n    // TODO parabolic hackery\n    //v.z -= .3 * abs(v.x) * abs(v.y); // FIXME very linear though results in a bend in the middle\n    v.z -= .04 * dot(v.xy, v.xy);\n#elif 0\n    // TODO panini\n    // think a real panini only works on one axis\n    // need adjustable cylinder size, this is hard-coded at radius 2 offset -1\n    v.xy *= .08*tau/v.z; return vec3(2. * sin(v.xy), 2. * cos(v.x) * cos(v.y) - 1.);\n#endif\n    // else planar is what we started with\n    return v;\n}\n\n// vogel disc based super sampler\n// handles depth of field, blur, antialiasing effects\n// technique only works well for scenes simple enough\n// to be rendered many times per frame; more complex\n// scenes would require a temp buffer and some CoC work.\nvec3 RenderSS(vec3 ro, vec2 q, mat3 cam, float hfovy\n     , int supersamples, float focuscos, float focaldepth\n     , float rnd)\n{\n\tconst float phi = .5*(sqrt(5.) + 1.)\n    , temporal = 0. //12. // temporal jitter animation rate?\n    , ssgamma = .45; // really does help!\n    float zoom = 1./sin(hfovy);\n\tvec3 c = vec3(0); float s = sqrt(max(0., 1. - focuscos*focuscos)), tot = 0.;\n\tfor (int i = supersamples; --i >= 0; ) {\n\t\tfloat f = (float(i) + .5) / float(supersamples) //float(i) / (float(supersamples) - .5) //\n\t\t, a = phi * tau * (f + rnd + temporal*fract(iTime))\n\t\t, omff = 1. //exp2(-4. * f * s) //1.-f*f //sqrt(f) //\n        , od\n\t\t;\n\t\tvec2 vogeldisc = sin(a + vec2(.25*tau, 0)) * sqrt(f) * s;\n        vec3 projected = ProjectionSetup(vec3(q + vogeldisc, zoom))\n\t\t, vd = normalize(projected)\n\t\t, rd = normalize(cam * vd) // view ray\n\t\t, vj = cam * vec3(vogeldisc,0) // vogel disc jitter in world space\n\t\t, vp = ro - vj * (1. * focaldepth) // + .5/iResolution.y)\n\t\t, rc = Render(vp, rd, fract(rnd + f), od)\n\t\t;\n        rc = pow(rc, vec3(ssgamma)); //rc*rc; //sqrt(rc); //\n\t\tc.rgb += rc * omff; \n        tot += omff;\n\t} // I may even want to blend these *after* gamma correction\n    c /= tot;\n    c = pow(c, vec3(1./ssgamma)); //sqrt(c) //c*c //\n\treturn c;\n}\n// just a simple average, which is a poor filter\n// but not much more I can do without more distribution control\n// TODO integrate temporal motion blur somehow by\n// affecting global time by f progress fraction\n// and hopefully tracking camera motion blur vs. scene also\n// How complicated do you want this template to get?!\n\nvoid SetupTime(float t)\n{\n    time = t;\n\tfloat sunangle = .9; //.1*time; //\n\tsunDir = normalize(vec3(.2,1,1)*sin(vec3(sunangle)+vec3(0,0,.25*tau))); //vec3(.1, .9,.2)); //\n}\n\nvec3 Draw(vec2 p, float rnd)\n{\n\tState state;\n\tvec2 R = iResolution.xy;\n\tivec2 i = ivec2(p);\n\tLoadState(state, BufA, ivec2(R));\n    SetupTime(iTime);\n//\tif (abs(distance(p, abs(state.mouse)) - 5.) < 2.) return vec3(0,1,0); // DEBUG state.mouse\n    // to signed aspect correct uv given screen pixel and resolution - aka StoQ\n\tvec2 q = (2.*p - R) / min(R.x, R.y); // handle portrait or landscape\n\tmat3 view = Camera(state.eyeaim);\n\tfloat hfovy = radians(30.) //tau/12. //\n\t//, blur = 2. // pixels ??!\n\t, foclen = 1.\n\t, focus = .99998 //cos(hfovy * blur/iResolution.y) //\n\t;\n\tint ss = SSAA + IZERO;\n    ss = max(1, int(float(ss) * min(1., 720. / R.y) + .5));\n    //ss /= int(log2(R.y)/log2(512.)) + 2;\n\t//ss -= int(R.y/240.); // scale with resolution\n\tss = max(ss, 1);\n    //return vec3(state.eyeaim * .5 + .5,0);\n    //return vec3(state.aimbase * .5 + .0,0);\n    //return vec3(state.mbdown ? 1. : 0.);\n\t//if (iTimeDelta >= .034) ss = 1;\n\treturn RenderSS(state.eyepos, q, view\n\t  , hfovy, ss, focus, foclen, rnd);\n}\n\nfloat bluenoise(vec2 p)\n{   // looks better than anything else I've tried!\n\treturn fetch(BluNoiz, ivec2(p) & ivec2(BNzRes-1.)).x;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float rnd = bluenoise(p);\n\tvec3 c = Draw(p, rnd);\n\tc = pow(c, vec3(.4545)); // to approx sRGB gamut\n\tc += .6 / 256. * rnd; // dither\n\to = vec4(c, 1);\n}\n\n/*\n// made just for this toy\nfloat Dither(vec2 p)\n{\n\treturn sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n// It's not ideal though.  Fine for dithering.\n// Not so great for jittering rays.\n// but now I've stored bayer in BufferA\n// or just use blue noise directly from iChannel3\n*/        //Dither(p); \n    \t//fract(333.*dot(q, vec2(phi, tau/5.));\n    \t//fetch(BufA, ivec2(p) & 7).x; // bayer texture baked into most of buffer A\n\n//\tvec4 data = fetch(BufA, ivec2(p)); c = data.rgb; // + data.a; // DEBUG show buffer A\n\n/*\n// for more serious debugging\n#define Font iChannel1\n// numeric display based on https://shadertoy.com/view/llySRh\n// using font in iChannel1; otherwise I'd put it in Common\nfloat char(vec2 p, int c)\n{\n    if (p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15 - c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    float scale = 64./(1.+dot(fwidth(q), vec2(1)));\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n\n// display unsigned int up to 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint4(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n), d = 4; d-- > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    return v;\n}\n\nfloat pSign(vec2 p, inout float n)\n{\n    float v = 0.;\n    if (n < 0.) v += char(p + vec2(.5,0), 45), n = -n;\n    return v;\n}\n\n// display signed int4\nfloat pInt(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); // p.x -= 2.;\n    v += pUint(p, n);\n    return v;\n}\n\n// display signed float4.4\nfloat pFloat(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); p.x -= 2.;\n    v += pUint(p, floor(n)); p.x -= .5;\n    v += char(p, 46); p.x -= 2.;\n    v += pUint4(p, fract(n)*1e4);\n    return v;\n}\n\n//    ivec2 R = ivec2(iResolution)\n//    , i = ivec2(p);\n//    if (i.x < R.x / 4 && i.y < R.y / 4) {\n//        State state;\n//        LoadState(state, BufA, R);\n//        p = (p - float(R) / 96.) / 32.;\n//        c += vec3(pFloat(p, state.eyeaim.y));\n//        c += vec3(pFloat(p - vec2(0,2), state.aimbase.y));\n//    }\n*/\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// enable antigravity feature\n#define FLY  1\n// camera fixed if neither is enabled\n#define COLLISION 1\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n\n#define IZERO min(iFrame, 0)\n\nconst float tau = 2. * acos(-1.); //6.28318531; //\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n/*\n// Rodrigues' formula rotation by \n// arbitrary unit axis and radian angle\nvec3 prot(vec3 p, vec3 axis, float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return c * p\n        + (1.-c) * dot(p, axis) * axis\n        + s * cross(p, axis);\n}\n*/\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution; // window resolution\n    vec2 aimbase; // involved in mouse lookaround\n    vec3 eyepos;\n    vec2 eyeaim;\n    bool mbdown; // mouse button was down?\n};\n// FIXME I have so many data values now that \n// I may as well just not pack them, for simplicity.\n// I have considered only using the alpha channel, \n// but that would result in considerably more fetches.\n// May coexist better with certain buffer contents.\nconst int\n  slotResMBD     = 0 // w unused\n, slotEyePos     = 1 // w unused\n, slotAzElBase   = 2 // azimuth and elevation of aim, also recorded on mouse up\n, slotCount      = 3\n;\n\nbool IsStatePixel(ivec2 i, ivec2 R)\n{\n   \treturn i.y == R.y-1 && i.x >= R.x-1-slotCount;\n}\n\n// want to reserve space in Buffer A for data pixels\n// but don't want to use row 0 since it makes sharing\n// buffer with other code more awkward;\n// however Common tab has no access to iResolution or iChannelResolution\n// and GLES here does not have reliable textureSize for the sampler\n// my solution is to measure these offsets *backward* from R = \n// ivec2(iResolution), so slotResolution actually goes at R-1\n// slotCamPos goes at R - 1 - ivec2(1,0) etc.\n// One problem with putting it here is that it then becomes\n// extremely reliant on the window size not changing,\n// and requires reinitialization on every resize.\n// putting it at 0,0 the other way handles it more gracefully, but\n// at expense of putting a fudge factor in any other buffer access!\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResMBD].xy);\n    state.mbdown = data[slotResMBD].z > .5;\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyeaim = data[slotAzElBase].xy;\n    state.aimbase = data[slotAzElBase].zw;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) { // IsStatePixel(p)\n      case slotResMBD:\n        c = vec4(R, state.mbdown ? 1. : 0., 0);\n        break;\n      case slotEyePos:\n        c = vec4(state.eyepos, 0.);\n        break;\n      case slotAzElBase:\n        c = vec4(state.eyeaim, state.aimbase);\n        break;\n      default:\n        break;\n    }\n}\n\nfloat dsphere(vec3 q, float r) // r is radius\n{\n    return length(q) - r;\n}\n// iq's approach, different style; e is box half-extent\nfloat dbox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n\treturn all(lessThan(q, vec3(0))) \n        ? max(max(q.x,q.y),q.z)\n        : length(max(q, 0.));\n}\n// similar to iq style segment\nfloat dseg(vec3 q, vec3 a, vec3 b)\n{\n    q -= a; b -= a; \n    return length(q - clamp(dot(q, b) / dot(b, b), 0., 1.) * b);\n}\n\n// material ids\nconst int\n  mSky   = 0\n, mGray  = 1\n, mRed   = 2\n, mGreen = 3\n, mBlue  = 4\n;\n\nstruct Hit\n{\n    float d; // signed distance to surface\n    int m; // material id\n};\n/* TODO other convenient quantities\ninclude local texture coordinate\nor total iterations utilized\nor closest near-miss distance\nCompiler dead-code elimination\nshould remove unreferenced portions\nwhen used and inlined, but adding\ntoo many seems wasteful oftentimes.\nIf not done here, though, certain info\nmay require re-checking the entire scene anyway.\nI really dislike duplicating the scene code!\n*/\n// HACK so Common tab can access this uniform;\n// iTime must be copied here at start of mainImage!\nfloat time; // for animating the scene\n//void SetupScene(float t) { time = t; }\n\n// original complicated tiled spheres test scene\n// moved to https://shadertoy.com/view/WlXczN\n// Now I have a new complicated test scene!\nHit Scene(vec3 p)\n{\n    float dp = p.y // ground plane +Y\n    , r = 1. // ball radius\n    , or = .5 // other radius\n    , db = dsphere(p - vec3(0,r,0), r) // non-moving ball above origin\n    , dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)) // large box for testing collision\n    , dc = dseg(p, vec3(-10,or,0), vec3(-10,1.+or,0)) - or // capsule\n    ;\n    dc = min(dc, dseg(p, vec3(10,or+.25,5), vec3(10,or+.25,-5)) - or);\n    Hit h; // = Hit(3.4e38, mSky);\n    h = Hit(dp, mGray);\n    if (h.d > db) h = Hit(db, mRed);\n    if (h.d > dx) h = Hit(dx, mGreen);\n    if (h.d > dc) h = Hit(dc, mBlue);\n    return h;\n}\n\n// bounding clip plane height for entire scene - nothing is taller than this\nconst float hmax = 4.;\n\n// loop using uniform to limit compile time bloat with complex scene\nvec3 SceneNormal(vec3 p, float h, out float d, int izero)\n{\n    vec3 n, o = vec3(0,0,h);\n    vec4 s;\n    for (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))\n        s[i] = Scene(p + o).d;        \n    n = s.yzw - (d = s.x);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\nstruct Marched \n{\n    float t;   // distance to intersection\n    int m;     // material id\n    float nmd; // nearest miss distance\n};\n\nMarched March(vec3 ro, vec3 rd, float thresh, float dmax, int iters)\n{\n    Marched c = Marched(dmax, mSky, dmax);\n    int i = iters;\n    float t = 0.;\n    while (i-- > 0) {\n        vec3 mp = ro + rd * t;\n        Hit h = Scene(mp);\n        float d = h.d, ad = abs(d);\n        t += d;\n        //if (ad < abs(c.nmd)) {\n            c.m = h.m, c.nmd = h.d;\n            if (rd.y >= 0. && (ad > dmax\n            \t|| mp.y > hmax))\n                break; //t = dmax;\n        \tif (ad < thresh * t || t >= dmax)\n        \t\tbreak;\n        //}\n    }\n    c.t = t = clamp(t, 0., dmax);\n    if (abs(c.nmd) > thresh * 2. * t) \n        c.m = mSky;\n    if (c.m == mSky)\n        c.t = dmax; // caller won't be able to tell how far it got though\n    return c;\n}\n\n// HACK rescue failed marches for planar scenes\nvoid Rescue(inout Marched c, vec3 ro, vec3 rd, float dmax)\n{\n    if (c.m == mSky)\n        if (rd.y >= 0. && ro.y > 0.)\n            c.t = dmax;\n        else {\n            c.t = ro.y / -rd.y;\n            c.m = mGray;\n            c.nmd = 0.;\n        }\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float \n  eyeradius = .25 // collision size\n, eyespeed = 8.   // eye max velocity; shift doubles it\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n//, eyeacc = 3.     // eye acceleration\n//, eyedamp = .1    // air resistance\n;\n// because ShaderToy.com isn't universal\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    vec2 turn; // keyboard turning\n    float dt; // delta time seconds\n    bool button;\n    bool attract;\n    // debug features TODO\n};\n\nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n, KEY_PGUP  = 33\n, KEY_PGDN  = 34\n// key bindings to local directions\n// can be customized as necessary\n#if 0\n  // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n  // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n  // QWERTY WASD\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n// FIXME up/down controls probably not great for\n// non-QWERTY layouts, but can swap to PGUP/DN\n, KEY_UW    = KEY_SPACE // up\n, KEY_DW    = KEY_C     // down\n// FIXME turn keys will only really work for QWERTY\n, KEY_TURNL = KEY_Q // KEY_DEL\n, KEY_TURNR = KEY_E // KEY_END\n//, KEY_F     = 70\n//, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_TAB   = 9\n;\n// DO NOT use control because unwanted browser commands\n// alt is likely unwise also\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n\n#define Kbd      iChannel3\n\nfloat key(int vk)\n{\n    return step(.5, fetch(Kbd, ivec2(vk, 0)).x);\n}\n\nbool option(int vk)\n{\n    return fetch(Kbd, ivec2(vk, 2)).x > .5;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    inp.attract = !inp.button && dot(inp.mouse, inp.mouse) < 4.;\n    if (inp.attract) { // icon?\n        inp.mouse.x = .02*iTime; // slow spin\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    }\n    inp.move =\n      vec3(key(KEY_RT) - key(KEY_LF)\n         , key(KEY_UW) - key(KEY_DW)\n         , key(KEY_FW) - key(KEY_BW))\n    + vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n         , key(KEY_PGUP ) - key(KEY_PGDN)\n         , key(KEY_UP   ) - key(KEY_DOWN)) // arrows alternate controls\n      ;\n    inp.turn = vec2(key(KEY_TURNR) - key(KEY_TURNL), 0);\n    inp.dt = iTimeDelta;\n}\n\n// simple sphere collision shape\nvoid CollideSphere(inout vec3 pos, float radius)\n{\n    float d;\n    vec3 n = SceneNormal(pos, radius, d, IZERO);\n    pos -= n * min(0., d - radius);\n}\n\nvoid CollideEye(inout vec3 p)\n{\n\t// FIXME should actually distribute the movement throughout all these iterations - see fixes in Plumbing Maze\n\t// multiple collision iterations to prevent tunnelling at low fps\n\tfor (int i = 3; --i >= 0; ) { // repeating helps with getting stuck in crevices\n    \tCollideSphere(p, eyeradius);\n//\t\tpos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n\t}\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    mat3 view = Camera(state.eyeaim);\n    float d, spd = eyespeed, dt = inp.dt;\n    // TODO\n//  eyeacc     // eye acceleration\n//\teyedamp    // air resistance\n    spd *= 1. + key(KEY_SHIFT);\n    vec3 op = state.eyepos\n    , move = inp.move * dt * spd \n    , p = op\n    ;\n  #if FLY\n\tp += view * move;\n   #if COLLISION    \n    CollideEye(p);\n   #endif\n  #endif\n    state.eyepos = p;\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = oa;\n    // FIXME went thru trouble to abstract everything into Inputs\n    // and wound up HACK using iMouse.zw directly here anyway\n    // HACK handling shadertoy.com new iMouse.w sign behavior here\n    // in supposedly platform-abstracted code :(\n    if (state.mbdown && inp.button)\n        a = (inp.mouse - abs(iMouse.zw)) / R * vec2(2,2) + state.aimbase;\n    bool keyturn = dot(inp.turn,inp.turn) > 1e-3;\n    if (keyturn)\n        a += inp.turn * mix(.5, 1., key(KEY_SHIFT)) * inp.dt;\n    a.x = fract(a.x);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    if (!keyturn) // only if not key turning, because that doesn't work well\n    \ta = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate mouse aim\n    // key turning should update the aimbase,\n    // to prevent it snapping back when the mouse is next clicked.\n    if (keyturn)\n        state.aimbase = state.eyeaim;\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, inout bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,2.*eyeradius,-4);\n        state.aimbase = \n        state.eyeaim = vec2(0.,.5);\n        state.mbdown = false;\n    } else { // update state\n\t\tMoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n        if (state.mbdown && !inp.button) // on mouse up\n    \t    state.aimbase = state.eyeaim; // record aim base\n        state.mbdown = inp.button;\n    }\n}\n\nvec4 ExampleData(ivec2 i)\n{\n#define Bayer    iChannel2\n#define BayerRes iChannelResolution[2].xy\n\t// Filled with texture, converted to signed, as example.\n    return fetch(Bayer, i % ivec2(BayerRes)) * 2. - 1.;\n    return vec4(0);\n}\n\nvoid InitData(inout vec4 c, ivec2 p)\n{\n    c = ExampleData(p);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    time = iTime;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    bool init = iFrame == 0;\n    if (!init && i.y < R.y-1 || i.x < R.x-slotCount) discard; // big optimization\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n\t// Usually prior data is loaded and passed through unchanged.\n    vec4 c = fetch(BufA, i);\n    if (init) InitData(c, i);\n    SaveState(c, state, i);\n    o = c;\n}\n\n// designed to support various dynamic state\n// once initialized, certain pixels can discard\n// if that works out advantageously;\n// for instance a texture atlas could skip all \n// the other state loading etc. once computed.\n// But since every single pixel does the same\n// state loading, which is trivial, \n// it doesn't add up to squat anyway.\n// Unless at full screen resolution, using all 4 Buffer tabs,\n// my gpu seems to be able to keep up with updating all\n// the buffer pixels all the time in most cases.\n// And that makes things a bit simpler since then needn't\n// worry about the double-buffering or late-loaded textures.\n// discard can help performance for wasted pixels,\n// but be careful about the double-buffering.\n\n","name":"Buffer A","description":"","type":"buffer"}]}