{"ver":"0.1","info":{"id":"M32fzy","date":"1729638497","viewed":61,"name":"Voronoi Studies - 00","username":"zschzen","description":"voronoi studies @ iquilezles.org","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","studies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uses functions from Inigo Quilez's articles and implementations:\n// https://iquilezles.org/articles/voronoilines/\n// https://iquilezles.org/articles/distfunctions2d/\n// https://iquilezles.org/articles/smoothvoronoi/\n\n\nvec2 voronoi(vec2 x, float time) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 mg, mr;\n    float md = 8.0;\n    float md2 = 8.0;\n    \n    for(int j = -1; j <= 1; j++) {\n        for(int i = -1; i <= 1; i++) {\n            vec2 g = vec2(float(i), float(j));\n\n            vec2 o = hash2d(n + g);\n            o += 0.2 * vec2(\n                sin(time * 0.5 + o.x * 6.28),\n                cos(time * 0.7 + o.y * 6.28)\n            );\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            \n            if(d < md) {\n                md2 = md;\n                md = d;\n                mr = r;\n                mg = g;\n            } else if(d < md2) {\n                md2 = d;\n            }\n        }\n    }\n    return vec2(sqrt(md), sqrt(md2));\n}\n\nvec3 pulseColor(float t) {\n    return 0.5 + 0.5 * cos(t + vec3(0.0, 2.0, 4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Animated scaling and rotation\n    float time = iTime * 0.5;\n    float scale = 10.0 + sin(time * 0.2) * 2.0;\n    mat2 rot = mat2(cos(time * 0.1), -sin(time * 0.1),\n                    sin(time * 0.1), cos(time * 0.1));\n    vec2 pos = rot * uv * scale;\n    \n    // Get animated voronoi\n    vec2 v = voronoi(pos, time);\n    float d = v.x;\n    float d2 = v.y;\n    float edge = d2 - d;\n    \n    // Animated edge width\n    float edgeWidth = 0.05 + 0.03 * sin(time * 2.0);\n    float edgeIntensity = smoothstep(0.0, edgeWidth, edge);\n    \n    // Create animated cell colors\n    vec3 cellColor = pulseColor(d * 4.0 + time);\n    \n    // Add wave pattern inside cells\n    float wave = sin(d * 20.0 - time * 3.0) * 0.5 + 0.5;\n    cellColor *= 0.8 + 0.2 * wave;\n    \n    // Create pulsing edge color\n    vec3 edgeColor = pulseColor(time * 2.0);\n    \n    // Combine colors with animated glow\n    vec3 col = mix(edgeColor, cellColor, edgeIntensity);\n    \n    // Add distance-based glow\n    float glow = exp(-d * 4.0) * 0.5;\n    col += glow * pulseColor(time * 3.0 + d * 10.0);\n    \n    // Add subtle vignette\n    float vignette = 1.0 - dot(uv, uv) * 0.5;\n    col *= vignette;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define UVSCALE 20.\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n///  2d hash based on 2d coordinates.\nvec2 hash2d(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}","name":"Common","description":"","type":"common"}]}