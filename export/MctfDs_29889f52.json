{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Procedural brick pattern function\nvec3 brickTexture(vec3 baseColor, vec3 position) {\n    float brickSize = 0.2;  // Size of each brick\n    float mortarSize = 0.05; // Space between bricks\n\n    // UV mapping for brick grid\n    vec2 uv = position.xz / brickSize;\n    uv.x += floor(position.y / brickSize) * 0.5; // Offset every other row\n\n    // Compute brick and mortar pattern\n    vec2 brickCoord = fract(uv);\n    float isMortar = step(1.0 - mortarSize, brickCoord.x) + step(1.0 - mortarSize, brickCoord.y);\n\n    // Adjust brick color while preserving base color\n    vec3 recoloredBrick = baseColor * vec3(0.7, 0.2, 0.2); // Slightly reddish\n    vec3 mortarColor = vec3(0.9); // Light gray mortar\n\n    // Return blended color based on mortar\n    return mix(recoloredBrick, mortarColor, isMortar);\n}\n\n// Signed Distance Functions (SDFs) for 3D shapes\nfloat sdfSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdfCone(vec3 p, float height, float radius) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0.0, height);\n    vec2 mantleDir = normalize(vec2(radius, -height));\n    float mantle = dot(tip, mantleDir);\n    float side = length(tip - mantle * mantleDir);\n    float base = length(q - vec2(radius, 0.0));\n    return min(side, base);\n}\n\nfloat sdfCylinder(vec3 p, float height, float radius) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height / 2.0);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Scene Distance Function\nfloat map(vec3 p, out vec3 objectColor, float seed) {\n    // Rotate the space for turntable effect\n    float angle = iTime * 0.5; // Slow rotation\n    float s = sin(angle), c = cos(angle);\n    mat2 rotation = mat2(c, -s, s, c);\n    p.xz = rotation * p.xz;\n\n    // Pick an object type based on the random seed\n    float objectType = mod(floor(seed), 3.0); // Sphere, Cone, or Cylinder\n\n    if (objectType == 0.0) { // Sphere\n        objectColor = vec3(1.0, 0.3, 0.3); // Base red color\n        return sdfSphere(p, 0.5);\n    } else if (objectType == 1.0) { // Cone\n        objectColor = vec3(0.3, 1.0, 0.3); // Base green color\n        return sdfCone(p, 1.0, 0.5);\n    } else { // Cylinder\n        objectColor = vec3(0.3, 0.3, 1.0); // Base blue color\n        return sdfCylinder(p, 1.0, 0.4);\n    }\n}\n\n// Raymarching Function\nfloat raymarch(vec3 ro, vec3 rd, out vec3 hitColor, float seed) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t * rd;\n        vec3 objectColor;\n        float dist = map(p, objectColor, seed);\n        if (dist < 0.01) {\n            // Apply brick texture with recoloring\n            hitColor = brickTexture(objectColor, p);\n            return t;\n        }\n        t += dist;\n        if (t > 10.0) break;\n    }\n    return -1.0; // No hit\n}\n\n// Lighting\nvec3 getLighting(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 objectColor) {\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    return objectColor * diffuse + vec3(1.0) * specular * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Screen coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 3.0); // Ray origin\n    vec3 rd = normalize(vec3(uv, -1.0)); // Ray direction\n\n    // Random seed based on time\n    float seed = floor(iTime);\n\n    // Background color\n    vec3 bgColor = vec3(0.8, 0.8, 1.0); // Light sky-blue\n    vec3 color = bgColor;\n\n    // Raymarching\n    vec3 hitColor;\n    float t = raymarch(ro, rd, hitColor, seed);\n    if (t > 0.0) {\n        vec3 p = ro + t * rd;\n        vec3 normal = normalize(vec3(\n            map(p + vec3(0.01, 0.0, 0.0), hitColor, seed) - map(p - vec3(0.01, 0.0, 0.0), hitColor, seed),\n            map(p + vec3(0.0, 0.01, 0.0), hitColor, seed) - map(p - vec3(0.0, 0.01, 0.0), hitColor, seed),\n            map(p + vec3(0.0, 0.0, 0.01), hitColor, seed) - map(p - vec3(0.0, 0.0, 0.01), hitColor, seed)\n        ));\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        vec3 viewDir = normalize(-rd);\n        color = getLighting(normal, lightDir, viewDir, hitColor);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MctfDs","date":"1733659950","viewed":18,"name":"Animation test #2","username":"thatsience","description":"Test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["notags"],"hasliked":0,"parentid":"","parentname":""}}