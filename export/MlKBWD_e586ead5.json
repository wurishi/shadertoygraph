{"ver":"0.1","info":{"id":"MlKBWD","date":"1542721788","viewed":517,"name":"Megapolis","username":"skaplun","description":"Repro of Dave's work - https://twitter.com/beesandbombs/status/1049378744161525760\nAnimations need to be much smoother. Mb, add some bounce effect while towers grows","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","rayboxintersection","2dvolex","traversing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIME_MULT .25\n#define TIMING fract(iTime * TIME_MULT)\n#define IDLE_TIME .05\n#define IDLE(x) (abs(x - .5) > (.5 - IDLE_TIME))\n#define UP vec3(0., -1., 0.)\n\nconst vec3 lightPos = vec3(-150., 300., -300.);\nconst vec3 lightColor = vec3(56., 145., 196.)/255.;\n\nbool boxAtPos(const in vec2 modPoint, out Box box){\n\tfloat t = TIMING;\n    float mt = ceil(iTime * TIME_MULT);\n    float cellStartTime = rnd(modPoint * mt) * .5 + IDLE_TIME;\n    if(t < cellStartTime)\n        return false;\n    float h = smoothstep(cellStartTime, cellStartTime + .175, t) * 2.;\n    float w = .25 + smoothstep(cellStartTime + .225, cellStartTime + .4, t) * .75;\n    w = w * .5 + .01;\n\n    box = Box(vec3(modPoint.x, 0., modPoint.y), vec3(w, h, w));\n    return true;\n}\n\nbool shadowed(const in vec3 pos){\n\tvec3 lightDir = normalize(lightPos - pos);\n    Ray toLightRay = Ray(pos + lightDir * .01, lightDir);\n    Ray2D toLightRay2D = Ray2D(toLightRay.origin.xz, normalize(toLightRay.dir.xz));\n    vec2 modPoint = vec2(floor(toLightRay.origin.x), floor(toLightRay.origin.z)) + .5;\n    HitRecord rec;\n    for (int i=0; i<10; i++) {\n        Box box;\n        if(boxAtPos(modPoint, box) && box_hit(box, toLightRay, EPS, rec))\n        \treturn true;\n        modPoint += getNextCellAlongVec(toLightRay2D, modPoint);\n        //TODO additional break condition should be envolved(based on top plane)\n    }\n    return false;\n}\n\n#define SHADOWS\nvec3 shadeSurphace(vec3 pos, vec3 normal){\n\tfloat t = TIMING;\n    vec3 norm = normalize(normal);\n\tvec3 lightDir = normalize(lightPos - pos);\n    float diff = max(dot(norm, lightDir), 0.0);\n#ifdef SHADOWS\n    if(!IDLE(t) && shadowed(pos))\n        diff = min(diff, .1);\n#endif\n    return (diff + .2) * lightColor;\n}\n\nvec3 clrInside(in float lmin, in float lmax, const in Ray inray){\n    float t = TIMING;\n    if(IDLE(t))\n        return shadeSurphace(vec3(0.), vec3(0., 1., 0.));\n    \n    Ray2D projectedRay = Ray2D(inray.origin.xz, normalize(inray.dir.xz));\n    HitRecord rec;\n    vec3 intersection = inray.origin + inray.dir * (lmin + .01);\n    vec2 modPoint = vec2(floor(intersection.x), floor(intersection.z)) + .5;\n    for(int i=0; i<10; i++){\n        Box box;\n        if(boxAtPos(modPoint, box) && box_hit(box, inray, EPS, rec))\n            return shadeSurphace(rec.point, rec.normal);\n        modPoint += getNextCellAlongVec(projectedRay, modPoint);\n        //TODO additional break condition should be envolved(based on bottom plane)\n    }\n    return shadeSurphace(inray.origin + inray.dir * lmax, vec3(0., 1., 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(-5., 8., 10.);\n    //vec3 eye = vec3(15. * sin((iResolution.x - iMouse.x) * .01), 5., 15. * cos((iResolution.x - iMouse.x) * .01));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lmin, lmax;\n    \n    if (hit(Ray(eye, worldDir), Plane(vec3(0.), UP), Plane(vec3(0., 2., 0.), UP), lmin, lmax)) {\n        fragColor = vec4(clrInside(lmin, lmax, Ray(eye, worldDir)), 1.);\n    }else{\n    \tfragColor = vec4(.5, 0., 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPS .00001\n#define MAX_FLOAT 1e5\n\nstruct Ray{vec3 origin, dir;};\nstruct Ray2D{vec2 origin, dir;};\nstruct Plane{vec3 origin, normal;};\nstruct Box{vec3 origin; vec3 bounds;};\nstruct HitRecord{float dist; vec3 point; vec3 normal;};\nstruct Line{vec2 p0, p1;};\n    \nfloat rnd(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec3 box_normal_at(const in Box box, const in vec3 point) {\n    vec3 normal;\n    vec3 localPoint = point - box.origin;\n    float mindist = MAX_FLOAT;\n    float dist = abs(box.bounds.x - abs(localPoint.x));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(1., 0., 0.);\n        normal *= sign(localPoint.x);\n    }\n    \n    dist = abs(box.bounds.y - abs(localPoint.y));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(0, 1., 0);\n        normal *= sign(localPoint.y);\n    }\n    dist = abs(box.bounds.z - abs(localPoint.z));\n    if (dist < mindist) { \n        mindist = dist; \n        normal = vec3(0, 0, 1.);\n        normal *= sign(localPoint.z);\n    } \n    return normal;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray, const in float t_min, inout HitRecord rec){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + inbox.bounds;\n    vec3 minbounds = inbox.origin + -inbox.bounds;\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    //if(tx.MIN > t_min && tx.MIN < t_max){\n    if(tx.MIN > t_min){\n    \trec.dist = tx.MIN;\n        rec.point = inray.origin + inray.dir * rec.dist;\n        rec.normal = box_normal_at(inbox, rec.point);\n        return true;\n    }\n        \n    return false;\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out float dist) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= EPS){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit(in Ray inray, in Plane bottom, in Plane top, out float min_dist, out float max_dist){\n    plane_hit(inray, top, min_dist);\n    plane_hit(inray, bottom, max_dist);\n    return true;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nbool testLinesIntersect(const in Line ray, const in Line edge, out float dist){\n    float s1_x = ray.p1.x - ray.p0.x,\n          s1_y = ray.p1.y - ray.p0.y,\n    \t  s2_x = edge.p1.x - edge.p0.x,\n          s2_y = edge.p1.y - edge.p0.y,\n    \t  s = (-s1_y * (ray.p0.x - edge.p0.x) + s1_x * (ray.p0.y - edge.p0.y))\n        \t\t/ (-s2_x * s1_y + s1_x * s2_y);\n    \t  dist = ( s2_x * (ray.p0.y - edge.p0.y) - s2_y * (ray.p0.x - edge.p0.x))\n        \t\t/ (-s2_x * s1_y + s1_x * s2_y);\n\treturn (s >= 0. && s <= 1. && dist >= 0. && dist <= 1.);\n}\n\nvec2 getNextCellAlongVec(const in Ray2D xzVecProj, const in vec2 curCellCenter){\n    float maxDist = -1., curDist = -1.;\n    vec2 result = vec2(0.);\n    Line sightLine = Line(xzVecProj.origin, xzVecProj.origin + xzVecProj.dir * 50.);\n    Line front = Line(vec2(curCellCenter.x - .5, curCellCenter.y + .5), vec2(curCellCenter.x + .5, curCellCenter.y + .5));\n    if(testLinesIntersect(sightLine, front, curDist) && curDist > maxDist){\n    \tmaxDist = curDist;\n        result = vec2(0., 1.);\n    }\n        \n    \n    Line back = Line(vec2(curCellCenter.x - .5, curCellCenter.y - .5), vec2(curCellCenter.x + .5, curCellCenter.y - .5));\n    if(testLinesIntersect(sightLine, back, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(0., -1.);\n    }\n    \n    Line left = Line(vec2(curCellCenter.x - .5, curCellCenter.y + .5), vec2(curCellCenter.x - .5, curCellCenter.y - .5));\n    if(testLinesIntersect(sightLine, left, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(-1., 0.);\n    }\n    \n    Line right = Line(vec2(curCellCenter.x + .5, curCellCenter.y + .5), vec2(curCellCenter.x + .5, curCellCenter.y - .5));\n    if(testLinesIntersect(sightLine, right, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(1., 0.);\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}