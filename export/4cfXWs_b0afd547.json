{"ver":"0.1","info":{"id":"4cfXWs","date":"1705857398","viewed":206,"name":"Nonplanar Polygon Examples","username":"mgillesp","description":"Examples of Harnack tracing nonplanar polygons (https://markjgillespie.com/Research/harnack-tracing/)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","distancefield","sdf"],"hasliked":0,"parentid":"mldBWM","parentname":"Interpolation Method Comparison"},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.01;\nconst int iter_max = 1000;\nconst float animation_speed = 0.;\nconst float shift = 4. * PI;\n\n//== Scene parameters\nconst bool draw_ground_plane   = true;\nconst bool draw_shadow = true;\nconst bool draw_boundary = true;\nconst bool draw_vertices = true;\nconst float boundary_radius = 0.01;\nconst vec3 center = vec3(0, 0, 10);\n\nconst vec3 light = vec3( 0., 10., 0. );\n\nconst vec3 groundNormal = normalize( vec3( 0., 1., 0. ) );\nconst float groundLevel = -.05;\n\n//====== named polygons\n//  P0 : default\n//  P1 : nonconvex_planar_quad\n//  P2 : nonconvex_nonplanar_quad\n//  P3 : nonconvex_planar_octagon\n//  P4 : nonconvex_nonplanar_octagon\n//  P5 : nice_nonplanar_octagon\n//  P6 : approaching_circles_0\n//  P7 : approaching_circles_1\n//  P8 : approaching_circles_2\n//  P9 : approaching_circles_3\n//  P10 : approaching_circles_4\n#define P5\n\n//====== polygon data\n#ifdef P0\n#define nV 4\nvec3 points[nV] = vec3[](vec3( 1, 0.5, 1 ), vec3( -1, -0.5, 1 ), vec3( -1, 0.5, -1 ), vec3( 1, -0.5, -1 ) );\n#define nE 4\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(0, 0.3, 4.5);\nconst vec3 look_dir  = vec3(0, -0.066519, -0.997785);\nconst vec3 up_dir    = vec3(0, 0.997785, -0.066519);\nconst vec3 right_dir = vec3(1, 0, 0);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0, -2.98023e-08, -4.50999);\nconst float fovY = 45.;\n#endif // P0\n#ifdef P1\n#define nV 4\nvec3 points[nV] = vec3[](vec3( 1, 0, 1 ), vec3( 0, 0, -1 ), vec3( -1, 0, 1 ), vec3( 0, 0, -0.5 ) );\n#define nE 4\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-0.13421, 1.61109, -1.70277);\nconst vec3 look_dir  = vec3(-0.0326956, -0.738674, 0.67327);\nconst vec3 up_dir    = vec3(-0.0358295, 0.674064, 0.737804);\nconst vec3 right_dir = vec3(-0.998823, 5.35511e-09, -0.048505);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.216645, -0.165526, -2.3321);\nconst float fovY = 45.;\n#endif // P1\n#ifdef P2\n#define nV 4\nvec3 points[nV] = vec3[](vec3( 1, 0.1, 1 ), vec3( 0, 0.2, -1 ), vec3( -1, 0.1, 1 ), vec3( 0, 0, -0.5 ) );\n#define nE 4\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(2.21541, 2.34211, -0.386022);\nconst vec3 look_dir  = vec3(-0.675447, -0.727956, 0.117693);\nconst vec3 up_dir    = vec3(-0.717151, 0.685624, 0.124959);\nconst vec3 right_dir = vec3(-0.171658, -7.567e-10, -0.985157);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0, -0.0312159, -3.24677);\nconst float fovY = 45.;\n#endif // P2\n#ifdef P3\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 0, -1 ), vec3( 1, 0, 1 ), vec3( 0.333333, 0, 1 ), vec3( 0.333333, 0, -0.333333 ), vec3( -0.333333, 0, -0.333333 ), vec3( -0.333333, 0, 1 ), vec3( -1, 0, 1 ), vec3( -1, 0, -1 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 4 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-0.0607489, 2.22407, -2.3215);\nconst vec3 look_dir  = vec3(-0.00879901, -0.727956, 0.685568);\nconst vec3 up_dir    = vec3(-0.00934285, 0.685622, 0.727898);\nconst vec3 right_dir = vec3(-0.999918, -3.63798e-10, -0.0128344);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0905372, -0.16437, -3.21004);\nconst float fovY = 45.;\n#endif // P3\n#ifdef P4\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 0, -1 ), vec3( 1, 0.1, 1 ), vec3( 0.333333, 0.2, 1 ), vec3( 0.333333, 0, -0.333333 ), vec3( -0.333333, 0, -0.333333 ), vec3( -0.333333, 0.2, 1 ), vec3( -1, 0.1, 1 ), vec3( -1, 0, -1 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 4 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-0.0607489, 2.22407, -2.3215);\nconst vec3 look_dir  = vec3(-0.00879901, -0.727956, 0.685568);\nconst vec3 up_dir    = vec3(-0.00934285, 0.685622, 0.727898);\nconst vec3 right_dir = vec3(-0.999918, -3.63798e-10, -0.0128344);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0905372, -0.16437, -3.21004);\nconst float fovY = 45.;\n#endif // P4\n#ifdef P5\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 0, 0 ), vec3( 0.707107, 1, 0.707107 ), vec3( 0, 0, 1 ), vec3( -0.707107, 1, 0.707107 ), vec3( -1, 0, 0 ), vec3( -0.707107, 1, -0.707107 ), vec3( 0, 0, -1 ), vec3( 0.707107, 1, -0.707107 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 4 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 0 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-0.292529, 1.28655, 2.26295);\nconst vec3 look_dir  = vec3(0.143125, -0.430362, -0.891238);\nconst vec3 up_dir    = vec3(0.0682378, 0.902657, -0.424917);\nconst vec3 right_dir = vec3(0.98735, -2.32831e-10, 0.15856);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0699826, 0.179788, -2.61237);\nconst float fovY = 45.;\n#endif // P5\n#ifdef P6\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 1, 0.2 ), vec3( -4.37114e-08, 2, 0.2 ), vec3( -1, 1, 0.2 ), vec3( 1.19249e-08, 0, 0.2 ), vec3( 1, 1, -0.2 ), vec3( -4.37114e-08, 0, -0.2 ), vec3( -1, 1, -0.2 ), vec3( 1.19249e-08, 2, -0.2 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 4 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-3.55106, 2.38865, 0.0667124);\nconst vec3 look_dir  = vec3(0.899237, -0.437463, -0.000401298);\nconst vec3 up_dir    = vec3(0.437463, 0.899237, -0.00019516);\nconst vec3 right_dir = vec3(0.00044612, -3.51884e-09, 1);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0651277, 0.594493, -4.23822);\nconst float fovY = 45.;\n#endif // P6\n#ifdef P7\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 1, 0.3 ), vec3( -4.37114e-08, 2, 0.3 ), vec3( -1, 1, 0.3 ), vec3( 1.19249e-08, 0, 0.3 ), vec3( 1, 1, -0.3 ), vec3( -4.37114e-08, 0, -0.3 ), vec3( -1, 1, -0.3 ), vec3( 1.19249e-08, 2, -0.3 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 4 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-3.55106, 2.38865, 0.0667124);\nconst vec3 look_dir  = vec3(0.899237, -0.437463, -0.000401298);\nconst vec3 up_dir    = vec3(0.437463, 0.899237, -0.00019516);\nconst vec3 right_dir = vec3(0.00044612, -3.51884e-09, 1);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0651277, 0.594493, -4.23822);\nconst float fovY = 45.;\n#endif // P7\n#ifdef P8\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 1, 0.455 ), vec3( -4.37114e-08, 2, 0.455 ), vec3( -1, 1, 0.455 ), vec3( 1.19249e-08, 0, 0.455 ), vec3( 1, 1, -0.455 ), vec3( -4.37114e-08, 0, -0.455 ), vec3( -1, 1, -0.455 ), vec3( 1.19249e-08, 2, -0.455 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 4 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-3.55106, 2.38865, 0.0667124);\nconst vec3 look_dir  = vec3(0.899237, -0.437463, -0.000401298);\nconst vec3 up_dir    = vec3(0.437463, 0.899237, -0.00019516);\nconst vec3 right_dir = vec3(0.00044612, -3.51884e-09, 1);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0651277, 0.594493, -4.23822);\nconst float fovY = 45.;\n#endif // P8\n#ifdef P9\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 1, 0.5 ), vec3( -4.37114e-08, 2, 0.5 ), vec3( -1, 1, 0.5 ), vec3( 1.19249e-08, 0, 0.5 ), vec3( 1, 1, -0.5 ), vec3( -4.37114e-08, 0, -0.5 ), vec3( -1, 1, -0.5 ), vec3( 1.19249e-08, 2, -0.5 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 4 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-3.55106, 2.38865, 0.0667124);\nconst vec3 look_dir  = vec3(0.899237, -0.437463, -0.000401298);\nconst vec3 up_dir    = vec3(0.437463, 0.899237, -0.00019516);\nconst vec3 right_dir = vec3(0.00044612, -3.51884e-09, 1);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0651277, 0.594493, -4.23822);\nconst float fovY = 45.;\n#endif // P9\n#ifdef P10\n#define nV 8\nvec3 points[nV] = vec3[](vec3( 1, 1, 0.7 ), vec3( -4.37114e-08, 2, 0.7 ), vec3( -1, 1, 0.7 ), vec3( 1.19249e-08, 0, 0.7 ), vec3( 1, 1, -0.7 ), vec3( -4.37114e-08, 0, -0.7 ), vec3( -1, 1, -0.7 ), vec3( 1.19249e-08, 2, -0.7 ) );\n#define nE 8\nvec2 edges[nE] = vec2[](vec2( 0, 1 ), vec2( 1, 2 ), vec2( 2, 3 ), vec2( 3, 0 ), vec2( 4, 5 ), vec2( 5, 6 ), vec2( 6, 7 ), vec2( 7, 4 ) );\n//== Camera Parameters\nconst vec3 cam_pos   = vec3(-3.55106, 2.38865, 0.0667124);\nconst vec3 look_dir  = vec3(0.899237, -0.437463, -0.000401298);\nconst vec3 up_dir    = vec3(0.437463, 0.899237, -0.00019516);\nconst vec3 right_dir = vec3(0.00044612, -3.51884e-09, 1);\nconst mat3 default_cam_mat = mat3(right_dir, up_dir, look_dir);\nconst vec3 cam_space_cam_pos   = vec3(0.0651277, 0.594493, -4.23822);\nconst float fovY = 45.;\n#endif // P10\n\nconst bool drawTanBackground = false;\nconst bool rotate = false;\n                        \n// only intersect from positive direction\nbool intersectPlane( vec3 ro, vec3 rd, vec3 n, float d, out float t ) {\n    // dot(n, ro + t rd - origin) == d\n    t = ( d - dot( n, ro ) ) / dot( n, rd );\n    return dot( rd, n ) < 0. && t >= 0.;\n}\n\nfloat dist(vec3 pt1, vec3 pt2){ return sqrt(dot(pt1-pt2, pt1-pt2)); }\nfloat dist2(vec3 pt1, vec3 pt2){ return dot(pt1-pt2, pt1-pt2); }\n\nfloat closestPointOnLine( vec3 pt ) {\n    float minD2 = 100000.f;\n    for (int i = 0; i < nE; i++){\n        vec3 p1 = points[int(edges[i].x)];\n        vec3 p2 = points[int(edges[i].y)];\n        vec3 m = p2 - p1;\n        vec3 v = pt - p1;\n        //dot = |a|*|b|cos(theta) * n, isolating |a|sin(theta)\n        float t = clamp( dot(m,v)/dot(m,m), 0.0, 1.0 );\n        float d2 = dist2( v, t * m );\n        minD2 = min( minD2, d2 );\n    }\n    return sqrt( minD2 );\n}\n\nfloat triangleSolidAngle( vec3 p0, vec3 p1, vec3 p2, vec3 p ){\n    vec3 a = p0 - p;\n    vec3 b = p1 - p;\n    vec3 c = p2 - p;\n    \n    float la = length( a );\n    float lb = length( b );\n    float lc = length( c );\n    \n    return 2.f * atan(dot(a, cross(b,c)), la*lb*lc + dot(a,b)*lc + dot(b,c)*la + dot(a,c)*lb );\n\n}\n\nfloat triangulatedSolidAngle( vec3 x ) {\n    // compute the vectors xp from the evaluation point x\n    // to all the polygon vertices, and their lengths Lp\n    vec3 xp[nV+1]; float Lp[nV+1];\n    for (int i = 0; i < nV; i++) { // center = pts[N]\n        xp[i] = points[i] - x;\n        Lp[i] = length( xp[i] );\n    }\n    xp[nV] = center - x;\n    Lp[nV] = length( xp[nV] );\n\n\n    vec2 running_angle = vec2(1., 0.); // accumulate angle sum as vector phase\n    for (int i = 0; i < nE ;i++){\n        int a = int(edges[i].x);\n        int b = int(edges[i].y);\n        int c = nV;\n        \n        vec3 n = cross( xp[a], xp[b] );\n        \n        vec2 tri_angle = vec2(Lp[a] * Lp[b] * Lp[c] + dot(xp[a], xp[b]) * Lp[c] +\n                    dot(xp[b], xp[c]) * Lp[a] + dot(xp[a], xp[c]) * Lp[b],\n                dot(xp[c], n));\n        \n        running_angle = mul(running_angle, tri_angle);\n    }\n    return 2. * atan(running_angle.y, running_angle.x);\n}\n\nvec3 gradient( in vec3 p ) {\n    vec3 grad = vec3( 0., 0., 0. );\n    for (int i = 0; i < nE; i++){\n         vec3 p0 = points[int(edges[i].x)];\n         vec3 p1 = points[int(edges[i].y)];\n         vec3 g0 = p0 - p;\n         vec3 g1 = p1 - p;\n         vec3 n = cross( g1, g0 );\n         grad += n / dot( n, n ) * ((-dot(g0,g1) + dot(g0,g0))/length(g0) + (-dot(g0,g1) + dot(g1,g1))/length(g1));\n    }\n    return grad;\n\n}\n\nbool closeToLevelset( float ang, float lowBound, float highBound, float tol, float gradNorm ){\n    float eps = tol * gradNorm;\n    return min( ang - lowBound, highBound - ang ) < eps;\n}\n\nfloat getMaxStep(float fx, float R, float lo_bound, float up_bound, float shift){\n    float w    = (fx + shift) / (up_bound + shift);\n    float v    = (fx + shift) / (lo_bound + shift);\n    float lo_r = -R / 2. * (v + 2. - sqrt(v * v + 8. * v));\n    float up_r =  R / 2. * (w + 2. - sqrt(w * w + 8. * w));\n    \n    return min(lo_r, up_r);\n}\n\nbool harnack(vec3 ro, vec3 rd,  inout vec3 pos, inout bool maxSteps, float tmax){ \n    int iters = 0;\n    float t = 0.f;\n    float levelset = 2. * PI + .75 * PI * sin(animation_speed * iTime);\n    maxSteps = false;\n    \n    float loBound = 0.;\n    float hiBound = 4. * PI;\n    float t_overstep = 0.;\n\n    while (t < tmax){\n        iters++;\n\n        pos = ro + t * rd + t_overstep * rd;\n        if (iters > iter_max){\n            maxSteps = true;\n            return false;\n        }\n\n        vec3 gradF = gradient( pos );\n        \n        float h = triangulatedSolidAngle( pos );\n        float val = mod( h - levelset, 4. * PI ); \n        \n        if (closeToLevelset(val, loBound, hiBound, epsilon, length( gradF ))) {\n            return true;\n        }\n\n        float R =  closestPointOnLine( pos );\n        float r = getMaxStep( val, R, loBound, hiBound, shift );\n        \n        // overstep was valid if r >= t_overstep\n        float stepSize = (r >= t_overstep) ? t_overstep + r : 0.;\n        t_overstep = (r >= t_overstep) ? r * .75 : 0.;\n        t += stepSize;\n     }\n     return false;\n}\n\nbool intersect_sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r, out float t, out vec3 n ) {\n    t = dot( rd, p-ro ) / dot( rd, rd );\n    float d = length( ro + t * rd - p );\n    \n    if ( d > r ) return false;\n    \n    float s = sqrt( r * r - d * d );\n    if ( t - s >= 0. ) {\n        t -= s;\n    } else {\n        t += s;\n    }\n    \n    n = normalize( ro + t * rd - p );\n    \n    return t > 0.;\n}\n\nbool traceVertices(vec3 ro, vec3 rd, out vec3 position, out vec3 normal){\n    float t; vec3 n; \n    for (int i = 0; i < nV; i ++){\n        bool didHit = intersect_sphere( ro, rd, points[i], .03, t, n );\n        if (didHit){\n            position = ro + t*rd;\n            normal = normalize( position - points[i] );\n            return true;\n        }\n    }\n    bool didHit = intersect_sphere( ro, rd, center, .03, t, n );\n    if (didHit){\n        position = ro + t*rd;\n        normal = normalize( position - center );\n        return true;\n    }\n    \n    return false;\n}\n\n\n\nbool intersect_cylinder( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, out float t, out vec3 n ) {\n    vec3 crd = normalize( b-a );\n    \n    float qa = dot( rd, rd - crd * dot( crd, rd ));\n    float qb = 2. * dot( ro - a, rd - crd * dot( crd, rd ));\n    float qc = dot ( ro - a, (ro - a) - crd * dot( crd, ro-a )) - r * r;\n    \n    t = -qb / (2. * qa);\n    \n    float disc = qb * qb - 4. * qa * qc;\n    if ( disc < 0. ) return false;\n    \n    float s = sqrt( disc ) / ( 2. * qa );\n    \n    if ( t - s >= 0. ) {\n        t -= s;\n    } else {\n        t += s;\n    }\n    \n    if ( t <= 0. ) return false;\n     \n\n    vec3 p = ro + t * rd; // intersection point on ray\n    float tc = dot( crd, p-a ); // intersection location along cylinder\n    if ( tc < 0. || tc > length( b-a ) ) return false;\n    vec3 pc = a + tc * crd;\n    n = normalize( p - pc );\n    return true;\n}\n\nbool intersect_boundary( in vec3 ro, in vec3 rd, out vec3 p, out vec3 n ) {\n    float t = 11.;\n    float ti;\n    vec3 ni;\n    if ( draw_vertices ) {\n        for ( int i = 0; i < nV; i++ ) {\n            // check vertex\n            if ( intersect_sphere( ro, rd, points[i], boundary_radius, ti, ni ) ) {\n                if ( ti < t ) {\n                    t = ti; n = ni;\n                }\n            }\n        }\n    }\n    if ( draw_boundary ) {\n        for (int i = 0; i < nE; i++ ) {\n            // check edge\n            if ( intersect_cylinder( ro, rd, points[int(edges[i].x)], points[int(edges[i].y)], boundary_radius, ti, ni ) ) {\n                if ( ti < t ) {\n                    t = ti; n = ni;\n                }\n            }\n        }\n    }\n    \n    if ( t < 11. ) {\n        p = ro + t * rd;\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvec3 diffuseShade( vec3 pos, vec3 normal, vec3 light, vec3 materialColor ) {\n    return materialColor * max( dot( normalize( light - pos ), normal ), 0.3 );\n}\n\nvec3 fresnelShade( vec3 pos, vec3 ray, vec3 normal, vec3 materialColor ) {\n    return vec3( pow( 1. - abs( dot( ray, normal ) ), 4. ) );\n}\n\n// ( from https://www.shadertoy.com/view/7tKfz1 )\nvec3 normalShade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5, metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = min( mix(diff,refl * color_mod,metallic) + spec, vec3(1., 1., 1.) );\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec3 shade(vec3 pos, vec3 ray, vec3 normal, vec3 materialColor) {\n    // return min( normalShade( ray, normal, materialColor ), vec3( 1 ) );\n    return min(\n            diffuseShade( pos, normal, light, materialColor )\n            + 0.3 * normalShade( ray, normal, materialColor )\n            + 0.6 * fresnelShade( pos, ray, normal, materialColor ),\n            vec3(1., 1., 1.)\n        );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1\n#endif\n\nbool shoot_ray( vec3 ro, vec3 rd, float tmax, inout bool maxSteps, out float t, out vec3 pos ) {\n    return harnack( ro, rd, pos, maxSteps, tmax );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Calculate camera configuration from keyboard & mouse input buffer\n    // (from https://www.shadertoy.com/view/7tKfz1)\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    if ( rotate ) camRot += vec2( .25 * sin( .2 * iTime ), .15 * iTime );\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y) * default_cam_mat;\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1., 0), 0);\n    vec3 camPos = 1.2 * v2wRotMat * (cam_space_cam_pos + vec3(0, 0, 1) * camPosD.w);\n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n         // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        // vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0 + o / iResolution.y;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, 1.0));\n        #else    \n        // vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, 1.0));\n        #endif\n\n\t    // create view ray\n        // vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        vec3 rd = v2wRotMat * vDir;\n        vec3 ro = camPos;\n        \n        // ground shading\n        float tGround;\n        bool hitGround = draw_ground_plane && intersectPlane( ro, rd, groundNormal, groundLevel, tGround );\n        bool groundShadowed = false; float groundDist;\n        if ( hitGround ) {\n            vec3 groundPos = ro + tGround * rd;\n            vec3 lightDir = normalize( light - groundPos );\n            bool maxSteps;\n            vec3 ignorePos;\n            groundShadowed = draw_shadow && shoot_ray( groundPos + 0.01 * lightDir, lightDir, length( light - groundPos ), maxSteps, tGround, ignorePos);\n        }\n\n        // raymarch\n        const float tmax = 10.0;\n        vec3 pos;\n        \n        vec3 vertexPos, vertexNormal;\n        bool hitVertex  = (draw_vertices || draw_boundary) && intersect_boundary(ro, rd, vertexPos, vertexNormal);\n       \n        bool maxSteps;\n        float t;\n        bool didHit = shoot_ray( ro, rd, tmax, maxSteps, t, pos );\n    \n        // shading/lighting\t\n        vec3 col = vec3(1.);\n        if ( drawTanBackground ) col = vec3(242., 241., 233.) / 255.;\n        if (false && maxSteps) {\n            col =  vec3(1.f,0.0,0.0);\n        } else if (hitVertex && (length(vertexPos-ro) < length(pos-ro))){\n            vec3 baseColor = vec3( 0., 0., 0. );\n            col = shade( vertexPos, rd, vertexNormal, baseColor );\n        } else if( didHit ) {\n            vec3 nor = normalize( gradient( pos ) );\n            \n            vec3 baseColor = (dot( nor, rd ) < 0.) ? vec3(0.2,0.3,0.7) : vec3(0.8,0.3,0.2);\n            vec3 outwardNormal = dot( nor, rd ) > 0. ? -nor : nor;\n            col = shade( pos, rd, outwardNormal, baseColor );\n        } else if ( hitGround ) {\n            if ( groundShadowed ) {\n                col *= 0.8;\n            }\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846;\n\n// find a vector orthogonal to v\nvec3 orthogonal( vec3 v ) {\n    if ( abs( v.x ) <= abs( v.y ) && abs( v.x ) <= abs( v.z ) ) {\n        return normalize( vec3( 0., -v.z, v.y ) );\n    } else if ( abs( v.y ) <= abs( v.x ) && abs( v.y ) <= abs( v.z ) ) {\n        return normalize( vec3( v.z, 0., -v.x ) );\n    } else {\n        return normalize( vec3( -v.y, v.x, 0. ) );\n    }\n}\n\n\n//===== Complex arithmetic (from https://www.shadertoy.com/view/NlG3DD)\nvec2 cexp( float s ) {\n    return vec2( cos( s ), sin( s ) );\n}\n\nfloat arg( vec2 z ) {\n    return atan( z.y, z.x );\n}\n\n// complex multiplication\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\n// complex inverse\nvec2 inv(vec2 a) {\n   return conj(a)/dot(a,a);\n}\n\n// complex division\nvec2 div(vec2 a, vec2 b) {\n    return mul(a,inv(b));\n}\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n// (taken from https://www.shadertoy.com/view/7tKfz1)\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// (from https://www.shadertoy.com/view/7tKfz1)\n//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = -1.;  // down (disabled for screenshots)\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            // fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            // fragColor.y = -0.5 + iTime * 0.3;\n            fragColor = vec4(0.);\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, 1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}