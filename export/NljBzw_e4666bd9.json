{"ver":"0.1","info":{"id":"NljBzw","date":"1652895781","viewed":142,"name":"2d rayMarch","username":"saltlemon","description":"2d\nlearn from https://www.zhihu.com/column/milocode","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//need some time to compiled，can reduce the MAX_STEP,N or MAX_DEPTH(in this progress,3 is the max) to get fast compiled\n//can change the myscean function to change output。\n#define MAX_STEP 25\n#define MAX_DISTANCE 2.0f\n#define EPSILON 1e-6f\n#define TWO_PI 6.28318530718f\n#define N 64\n#define BIAS 1e-4f\n#define MAX_DEPTH  3\n#define DI(x,y,z,w) creatDIns(x,y,z,w)\n#define U(x,y) myunion(x,y)\n#define I(x,y) myintersect(x,y)\n#define S(x,y) mysubtract(x,y)\nmat2 rot(float angle){\n    return mat2(\n    -sin(angle),cos(angle),\n    cos(angle),sin(angle)\n    );\n}\nfloat smax(float a,float b,float k){\n    float h=clamp((b-a)/k+0.5,0.,1.);\n\treturn mix(a,b,h)+h*(1.-h)*k*.5;   \n}\nfloat smin(float a,float b,float k){\n    float h=clamp((b-a)/k+0.5,0.,1.);\n\treturn mix(b,a,h)-h*(1.-h)*k*.5;   \n}\nstruct d_ins{\n    float d,emissive,reflectivity, eta;\n};\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * 103.1);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x * p3.y) * p3.z);\n}\nfloat N31(vec3 p){\n    return fract(sin(p.x*127.+p.y*276.+p.z*986.)*298.);\n    //return hash33(vec3(x,y,z)).x;\n}\n\nd_ins myunion(d_ins a,d_ins b){\n    d_ins r;\n    \n   // r.d=smin(a.d,b.d,0.2);\n    if(a.d<b.d)\n        r=a ;\n    else\n        r=b;\n    r.d=min(a.d,b.d);\n    return r;\n}\nd_ins myintersect(d_ins a,d_ins b){\n \n    d_ins r;\n    //r.d = smax(a.d,b.d,0.1);\n    if(a.d>b.d){\n        r= b ;       \n    }\n    else{\n        r= a;\n    }\n    r.d = max(a.d,b.d);\n    return r;\n}\nd_ins mysubtract(d_ins a,d_ins b){\n    //d_ins r = a;\n    //if(a.d>-b.d)\n        //r.d=a.d ;\n    //else\n        //r.d=-b.d;\n    //return r;\n    d_ins temp=a;\n    temp.d=-b.d;\n    return myintersect(a,temp);\n}\nd_ins creatDIns(float d,float emissive,float reflectivity,float eta){\n    d_ins c;\n    c.d=d;\n    c.emissive=emissive;\n    c.reflectivity=reflectivity;\n    c.eta=eta;\n    return c;\n}\nfloat circleSDF(vec2 uv, vec2 center, float r) {\n    return length(uv-center) - r;;\n}\nfloat sdBox(vec2 uv,in vec2 center, in vec2 b )\n{\n    vec2 d = abs(uv-center)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat boxSDF(vec2 uv, float cx, float cy, float theta, float sx, float sy) {\n    float x=uv.x;\n    float y=uv.y;\n    float costheta = cos(theta), sintheta = sin(theta);\n    float dx = abs((x - cx) * costheta + (y - cy) * sintheta) - sx;\n    float dy = abs((y - cy) * costheta - (x - cx) * sintheta) - sy;\n    float ax = max(dx, 0.0f), ay = max(dy, 0.0f);\n    return min(max(dx, dy), 0.0f) + sqrt(ax * ax + ay * ay);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat planeSDF(vec2 uv, float px, float py, float nx, float ny) {\n    float x=uv.x;\n    float y=uv.y;\n    return (x - px) * nx + (y - py) * ny;\n}\nd_ins myscean(vec2 uv){\n    \n    d_ins d1=DI(circleSDF(uv,vec2(-0.5,0.3)*rot(iTime),0.1),1.0,0.0,1.0);\n    d_ins d2=DI(boxSDF(uv, 0.0f, 0.0f, 0.0f, 0.3f,0.1f),0.0,0.1,1.62);\n    return U(d1,d2);\n}\nvec2 getReflect(vec2 inVec,vec2 norVec) {\n    float idotn2 = dot(inVec,norVec)*2.0;\n    //float idotn2 = (ix * nx + iy * ny) * 2.0f;\n    //*rx = ix - idotn2 * nx;\n    // *ry = iy - idotn2 * ny;\n    return inVec-idotn2*norVec;\n}\nvec3 getRefract(vec2 inVec,vec2 norVec, float eta) //outVec.x  outVec.y  checkFlag(0=No refract  1 = refract)\n{\n    float idotn =dot(inVec,norVec);\n    float k = 1.0f - eta * eta * (1.0f - idotn * idotn);\n    if (k < 0.0)\n        return vec3(0.0,0.0,0.0); // 全内反射\n    float a = eta * idotn + sqrt(k);\n    vec2 outVec = eta*inVec-a*norVec;\n    return vec3(outVec,1.0);\n}\nvec2 getGradient(vec2 uv) {\n    float nx = (myscean(vec2(uv.x+EPSILON,uv.y)).d- myscean(vec2(uv.x-EPSILON,uv.y)).d)* (0.5 / EPSILON);\n    float ny = (myscean(vec2(uv.x,uv.y+EPSILON)).d- myscean(vec2(uv.x,uv.y-EPSILON)).d) * (0.5 / EPSILON);\n    return vec2(nx,ny);\n}\nfloat trace3(vec2 uv, vec2 dxy) {\n    float t = 0.0f;\n    float flag = myscean(uv).d > 0.0f ? 1.0f : -1.0f;\n    for (int i = 0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        d_ins sd = myscean(uv+t*dxy);\n        if (sd.d < EPSILON){\n            return sd.emissive;\n        }\n        t += sd.d*flag;\n    }\n    return 0.0f;\n}\nfloat trace2(vec2 uv, vec2 dxy) {\n    float t = 0.0f;\n    float flag = myscean(uv).d > 0.0f ? 1.0f : -1.0f;\n    for (int i = 0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        vec2 nowUV =uv+t*dxy;\n        d_ins sd = myscean(nowUV);\n        if (sd.d * flag  < EPSILON){\n            float sum = sd.emissive;\n            if (2<MAX_DEPTH && (sd.reflectivity > 0.0f||sd.eta>0.0f)) {\n                vec2 norVec = getGradient(nowUV)*flag;\n                if (sd.eta > 0.0f) {\n                    vec3 refractResult = getRefract(dxy,norVec,flag < 0.0f ? sd.eta : 1.0f / sd.eta);\n                    vec2 refractVec = refractResult.xy;\n                    float refractFlag = refractResult.z;\n                    if (refractFlag>0.5)\n                        sum += (1.0f - sd.reflectivity) * trace3(nowUV-norVec*BIAS,refractVec);\n                    else\n                        sd.reflectivity = 1.0f; // 全内反射\n                }\n                if (sd.reflectivity > 0.0f) {\n                    vec2 reflecVec = getReflect(dxy,norVec);\n                    //gradient(x, y, &nx, &ny);\n                    //reflect(dx, dy, nx, ny, &rx, &ry);\n                    sum += sd.reflectivity * trace3(nowUV+norVec*BIAS,reflecVec);\n                }\n            }\n            return sum;\n        }\n        t += sd.d*flag;\n    }\n    return 0.0f;\n}\nfloat trace1(vec2 uv, vec2 dxy) {\n   float t = 0.0f;\n    float flag = myscean(uv).d > 0.0f ? 1.0f : -1.0f;\n    for (int i = 0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        vec2 nowUV =uv+t*dxy;\n        d_ins sd = myscean(nowUV);\n        if (sd.d * flag  < EPSILON){\n            float sum = sd.emissive;\n            if (1<MAX_DEPTH && (sd.reflectivity > 0.0f||sd.eta>0.0f)) {\n                vec2 norVec = getGradient(nowUV)*flag;\n                if (sd.eta > 0.0f) {\n                    vec3 refractResult = getRefract(dxy,norVec,flag < 0.0f ? sd.eta : 1.0f / sd.eta);\n                    vec2 refractVec = refractResult.xy;\n                    float refractFlag = refractResult.z;\n                    if (refractFlag>0.5)\n                        sum += (1.0f - sd.reflectivity) * trace2(nowUV-norVec*BIAS,refractVec);\n                    else\n                        sd.reflectivity = 1.0f; // 全内反射\n                }\n                if (sd.reflectivity > 0.0f) {\n                    vec2 reflecVec = getReflect(dxy,norVec);\n                    //gradient(x, y, &nx, &ny);\n                    //reflect(dx, dy, nx, ny, &rx, &ry);\n                    sum += sd.reflectivity * trace2(nowUV+norVec*BIAS,reflecVec);\n                }\n            }\n            return sum;\n        }\n        t += sd.d*flag;\n    }\n    return 0.0f;\n}\nfloat trace(vec2 uv, vec2 dxy) {\n    float t = 0.0f;\n    float flag = myscean(uv).d > 0.0f ? 1.0f : -1.0f;\n    for (int i = 0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        vec2 nowUV =uv+t*dxy;\n        d_ins sd = myscean(nowUV);\n        if (sd.d * flag  < EPSILON){\n            float sum = sd.emissive;\n            if (0<MAX_DEPTH && (sd.reflectivity > 0.0f||sd.eta>0.0f)) {\n                vec2 norVec = getGradient(nowUV)*flag;\n                if (sd.eta > 0.0f) {\n                    vec3 refractResult = getRefract(dxy,norVec,flag < 0.0f ? sd.eta : 1.0f / sd.eta);\n                    vec2 refractVec = refractResult.xy;\n                    float refractFlag = refractResult.z;\n                    if (refractFlag>0.5)\n                        sum += (1.0f - sd.reflectivity) * trace1(nowUV-norVec*BIAS,refractVec);\n                    else\n                        sd.reflectivity = 1.0f; // 全内反射\n                }\n                if (sd.reflectivity > 0.0f) {\n                    vec2 reflecVec = getReflect(dxy,norVec);\n                    //gradient(x, y, &nx, &ny);\n                    //reflect(dx, dy, nx, ny, &rx, &ry);\n                    sum += sd.reflectivity * trace1(nowUV+norVec*BIAS,reflecVec);\n                }\n            }\n            return sum;\n        }\n        t += sd.d*flag;\n    }\n    return 0.0f;\n}\n\n\nfloat mysample(vec2 uv) {\n    float sum = 0.0f;\n    d_ins i;\n    for (int i = 0; i < N; i++) {\n       // float a = TWO_PI *N31(x,y,float(i));\n       float a = TWO_PI *((float(i)+hash13(vec3(uv,float(i))))/float(N));\n        sum += trace(uv, vec2(cos(a),sin(a)) );\n        if (sum>100.)\n            break;\n    }\n    return sum / float(N);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    float myIns=mysample(uv);\n    //myIns = hash13(vec3(fragCoord,0.2));\n    vec3 col = vec3(myIns);\n    //col = vec3(getGradient(uv).x*0.5+0.5,1.-getGradient(uv).y*0.5-0.5,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}