{"ver":"0.1","info":{"id":"lltBR4","date":"1538858516","viewed":478,"name":"Ambient Occlusion","username":"GraphicsFromScratch","description":"ao trick.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf(in vec3 p, out int matid)\n{\n    float sphere_sdf = length(p) - 1.0;\n    float floor_sdf = abs(p.y);\n    \n    float sdf = min(sphere_sdf, floor_sdf);\n    if (sdf == sphere_sdf)\n    {\n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\nvec3 sdf_n(in vec3 p)\n{\n    vec3 res = vec3(0);\n    \n    int ignored;\n    res.x = sdf(p + vec3(0.001, 0, 0), ignored) - sdf(p, ignored);\n    res.y = sdf(p + vec3(0, 0.001, 0), ignored) - sdf(p, ignored);\n    res.z = sdf(p + vec3(0, 0, 0.001), ignored) - sdf(p, ignored);\n    \n    return normalize(res);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int matid)\n{\n\tfloat t = 0.0;\n    matid = -1;\n    for (int i = 0; i < 256; ++i)\n    {\n        int curr_matid = -1;\n\t\tfloat d = sdf(ro + t*rd, curr_matid);\n        if (d < 0.01)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 2.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n    float e = 0.1;\n    float res = 0.0;\n    \n#define AO_ITER 5\n    \n    int ignored;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITER; ++i)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(p + d * n, ignored)));\n        weight *= 0.5;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 1, -3);\n    vec3 at = vec3(0, 0, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.73 * cam_z);\n\t\n    vec3 col = vec3(0);\n    \n    int matid = -1;\n    float t = intersect(ro, rd, matid);\n    if (matid != -1)\n    { \n        vec3 l = normalize(vec3(0.5, 0.5, 0.4));\n        vec3 n = sdf_n(ro + t*rd);\n        vec3 sun_light = vec3(1);\n        float projected_ratio = max(0.0, dot(l, n));\n        vec3 direct_light = shadow(ro + t*rd, l) * sun_light * projected_ratio;\n        vec3 indirect_light = ao(ro + t*rd, n) * vec3(0.3);\n        \n        vec3 albedo = vec3(0.9);      \n\t\tcol = albedo * (direct_light + indirect_light);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}