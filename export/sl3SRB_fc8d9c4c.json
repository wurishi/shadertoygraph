{"ver":"0.1","info":{"id":"sl3SRB","date":"1639320294","viewed":191,"name":"liquid sdf","username":"snolot","description":"Test to create liquid sphere that work with gyroscope on mobile phone. follow my previous shader: https://www.shadertoy.com/view/7lcSRB . want to add some. noise/ripples on surface, need. more work ;)\n\nNEW: Add dynamic cubemap","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","metaball","blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n//#define DYNAMIC_CUBEMAP 1\n\nconst vec3 lightPosition = vec3(0, 3, 4);\nconst vec3 lightColor    = vec3(0.2, 0.2, 0.2) * 2.;\n\nfloat displacement(vec3 p){\n    return sin(p.x)*sin(p.y)*sin(p.z);\n}\n\nfloat opDisplace(vec3 p){\n    vec3 offset = 0.1*iTime * normalize(vec3(1.0, -1.0, 0.1));\n    return displacement(5.0*(p+offset));\n}\n\n\n\nfloat getDistSphere(in vec3 p) \n{\n    \n    vec4 s = vec4(0, 0, 0, 1.25);\n    \n    float sphereDist = length(p - s.xyz) - s.w;    \n    return sphereDist;\n}\n\nfloat getDistCube(in vec3 p) \n{\n\n    p.y += max(opDisplace(p* p.x *.1) + ( (iMouse.y+.5) / iResolution.y) * 7., .95);//sin(iTime) * 1.25;\n\n    vec3 b = vec3(1.5,1.5,1.5);\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat smoothUnion(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2-d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0  -h); \n}\n\nfloat getDist(in vec3 p)\n{\n    float delta = texture(iChannel1, (p.xy + p.xz + p.yz) / 4.).r;\n    \n    float height = p.y+.1;\n    // Displace the surface for larger waves\n    // Add more displacement lower down\n    float strength = mix(0.02, 1.1, smoothstep(-0.1, -2., height));\n    if(height < -1.){\n        // No displacement at the very bottom\n        strength = mix(strength, 0.0, smoothstep(-.5, -2.92, height));\n    }\n    \n    float dist = strength * opDisplace(p);\n    \n    return opSmoothIntersection( getDistSphere(p),getDistCube(p)+dist,.05);\n}\n\nvec3 getNormal(in vec3 p) \n{\n    int body;\n    float d = getDist(p);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy), \n        getDist(p - e.yxy), \n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nvec3 getLight(in vec3 p, in vec3 rd)\n{    \n\tvec3 normal = getNormal(p);\n    vec3 lightDir = normalize(p - lightPosition);\n    \n    float cosa = pow(0.5+0.5*dot(normal, -lightDir), 3.0);\n    float cosr = max(dot(-rd, reflect(lightDir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.72);\n    vec3 diffuse = vec3(0.8 * cosa);\n    vec3 phong = vec3(0.5 * pow(cosr, 16.0));\n    \n    return lightColor * (ambiant + diffuse + phong);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0., 3., 0.);\n    \n    // Camera movement\n    float focalLength = 4.;\n    float rotation = iTime / 2.;\n    ro = vec3(cos(rotation), 0., sin(rotation)) * focalLength;\n    vec3 rd = normalize(vec3(0.) - ro);\n    vec3 right = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 up = cross(right, rd);\n   \trd =  normalize(uv.x * right + uv.y * up + rd);\n    ro.y += .4;\n    int body;\n    \n     \n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;   \n        \n        vec3 n = getNormal(p);\n        \n        float occ = 0.5+0.5*n.y;\n        \n        col = vec3(getLight(p, rd)) * 2.; \n        /*vec3 reflected = mix(texture(iChannel1, (p.xy + p.xz + p.yz) / 4.).rgb, \n                             texture(iChannel0, reflect(rd, n)).rgb, \n                             1. - texture(iChannel0, reflect(rd, n)).r / 3.);*/\n        //texture( iChannel0, nor, lod ).xyz*(0.5+0.5*nor.y)\n        #ifdef DYNAMIC_CUBEMAP\n        col = occ *.3 + texture( iChannel2, n, 1. ).xyz * occ *2.;//mix(col, reflected, 0.95);\n        #else\n        col = occ *.3 + texture( iChannel0, n, 1. ).xyz * occ *2.;//mix(col, reflected, 0.95);\n        #endif\n    }\n    else\n    {\n        //col = texture(iChannel0, rd).rgb;\n        #ifdef DYNAMIC_CUBEMAP\n            col = textureLod( iChannel2, rd, 1. ).xyz;\n        #else\n            col = textureLod( iChannel0, rd, 1. ).xyz;\n        #endif\n        //col = vec3(0.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader shows how to use the Cubemap pass to generate and cacache,\n// a cubemap texture. Caching is totally optional, you can regenerate the \n// cubemap every frame if you want so.\n//\n// The signature of the cubemap renderer is:\n//\n// void mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n//                    in vec3 fragRayOri, in vec3 fragRayDir )\n//\n// where fragRayOri is the center of the cubemap - (0,0,0) by default,\n// and fragRayDir is the ray direction for a given pixel\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return -1.0+2.0*mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n\nfloat map( in vec3 q )\n{\n    float h = q.y;\n\n    q *= 0.01*vec3(0.5,1.0,0.5);\n    \n\tfloat f;\n    f  = 0.500000*abs(noise( q )); q = q*2.02;\n    f += 0.250000*abs(noise( q )); q = q*2.03;\n    f += 0.125000*abs(noise( q )); q = q*2.01;\n    f += 0.062500*abs(noise( q )); q = q*2.02;\n    f += 0.031250*abs(noise( q )); q = q*2.03;\n  //f += 0.015625*abs(noise( q ));\n    f = -1.0 + 2.0*f;\n    \n    f = mix( f, -0.1, 1.0-smoothstep( h, 50.0, 60.0 ));\n    f = mix( f, -0.1, 1.0-smoothstep( h, 250.0, 300.0 ));\n    f += 0.87;\n\n    return f;\n}\n\n\nvec3 sundir = normalize( vec3(-1.0,0.5,1.0) );\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = (50.0-ro.y)/rd.y;\n    \n\tif( t>0.0 )\n    {\n        for(int i=0; i<512; i++ )\n        { \n            vec3  pos = ro + t*rd;\n            float den = map( pos );\n            if( den>0.001 )\n            { \n                // lighting\n                float dif = clamp( (den - map(pos+50.0*sundir))*1.0, 0.0, 1.0 ); \n                vec3 lin = vec3(0.5,0.7,0.9)*0.5 + vec3(1.0, 0.7, 0.5)*dif*5.0;\n                vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.1,0.2,0.3), sqrt(clamp(den,0.0,1.0) )), den );\n                col.xyz *= lin;\n                col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0005*t) );\n                col.a *= 0.1;\n                // front to back blending    \n                col.rgb *= col.a;\n                sum = sum + col*(1.0-sum.a);\n                // early skip\n                if( sum.a > 0.99 || pos.y>300.0) break;\n            }\n            t += 2.0;\n        }\n    }\n    \n    return clamp( sum, 0.0, 1.0 );\n}\n\n\nvoid mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n                  in vec3  fragRayOri, in vec3 fragRayDir )\n{\n    // cache\n    if( iFrame>1 )\n    {\n        discard;\n    }\n    \n    //---------------------------------\n    \n    // dome    \n    vec3 col = vec3(0.5,0.7,0.8) - max(0.0,fragRayDir.y)*0.4;\n    \n    // sun\n    float s = pow( clamp( dot(fragRayDir,sundir),0.0,1.0),32.0 );\n    col += s*vec3(1.0,0.7,0.4)*3.0;\n\n    // ground\n    float t = (-5.0-fragRayOri.y)/fragRayDir.y;\n    if( t>0.0 )\n    {\n        vec3 pos = fragRayOri + t*fragRayDir;\n        \n        vec3 gcol = vec3(0.2,0.1,0.08)*0.9;\n        \n        float f = 0.50*noise( pos );\n              f+= 0.25*noise( pos*1.9 );\n              f+= 0.125*noise( pos*3.9 );\n        gcol *= 0.5 + 0.5*f;\n\n        col = mix( gcol, col, 1.0-exp(-0.0005*t) );\n    }\n\n\n    // clouds\n    vec4 res = raymarch( fragRayOri, fragRayDir, col );\n    col = col*(1.0-res.w) + res.xyz;\n\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Cube A","description":"","type":"cubemap"}]}