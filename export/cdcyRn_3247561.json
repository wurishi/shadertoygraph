{"ver":"0.1","info":{"id":"cdcyRn","date":"1710464447","viewed":97,"name":"Sangaku spheres","username":"zenzicubic","description":"Reflective spheres in an icosidodecahedron","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["spheres","geometry","sangaku"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nProgrammed by Zenzicubic, 2023.\nA visualization of reflections in spheres at the vertices of an icosidodecahedron\narranged around a central sphere. This is the solution to a particular sangaku problem.\nSee https://mathworld.wolfram.com/TangentSpheres.html.\n*/\n\nstruct Hit {\n    bool hit;\n    float t;\n    vec3 pt, normal;\n    int objIdx;\n};\n\nstruct Material {\n    float kSpecular, kDiffuse, glossiness;\n    float reflectivity;\n};\n\n// General and rendering\n#define MAX_DIST 1000.\n#define EPS 1e-3\n#define FOCAL_LEN 2.5\n#define BOUNCE_CT 10\n\n// Lighting and coloring\n#define LIGHT_POS vec3(0., 5., 0.)\n#define AMBIENT .4\n#define INTENSITY .7\n#define GAMMA vec3(.545)\n\n// Scene data\nvec3 eye;\nmat3 viewMat;\n\nconst float RT5 = sqrt(5.);\nconst float PHI = (1. + RT5) * .5;\nconst float C0 = .5 * PHI, C1 = .5 + C0;\n\nvec3[30] verts = vec3[](\n    vec3(0., 0., PHI),\n    vec3(0., 0., -PHI),\n    vec3(PHI, 0., 0.),\n    vec3(-PHI, 0., 0.),\n    vec3(0., PHI, 0.),\n    vec3(0., -PHI, 0.),\n    vec3(.5, C0, C1),\n    vec3(.5, C0, -C1),\n    vec3(.5, -C0, C1),\n    vec3(.5, -C0, -C1),\n    vec3(-.5, C0, C1),\n    vec3(-.5, C0, -C1),\n    vec3(-.5, -C0, C1),\n    vec3(-.5, -C0, -C1),\n    vec3(C1, .5, C0),\n    vec3(C1, .5, -C0),\n    vec3(C1, -.5, C0),\n    vec3(C1, -.5, -C0),\n    vec3(-C1, .5, C0),\n    vec3(-C1, .5, -C0),\n    vec3(-C1, -.5, C0),\n    vec3(-C1, -.5, -C0),\n    vec3(C0, C1, .5),\n    vec3(C0, C1, -.5),\n    vec3(C0, -C1, .5),\n    vec3(C0, -C1, -.5),\n    vec3(-C0, C1, .5),\n    vec3(-C0, C1, -.5),\n    vec3(-C0, -C1, .5),\n    vec3(-C0, -C1, -.5)\n);\n\n/*\nIntersectors.\n*/\n\n// Sphere intersector.\nHit hitSphere(vec3 ro, vec3 rd, vec3 cen, float rad, float dMax, int idx) {\n    Hit hit;\n    hit.hit = false;\n    vec3 pt = ro - cen;\n    \n    // Compute coeffs and discriminant\n    float a = dot(rd, rd);\n    float b = dot(pt, rd);\n    float c = dot(pt, pt) - rad * rad;\n    \n    float disc = b * b - a * c;\n    if (disc < 0.) return hit;\n    \n    // Solve and test solution\n    disc = sqrt(disc);\n    a = 1. / a;\n    float t = min((-b - disc) * a, (disc - b) * a);\n    if (t < 0. || t > dMax) return hit;\n    \n    // Compute hit point and normal\n    pt = ro + rd * t;\n    vec3 nrm = (pt - cen) / rad;\n    return Hit(true, t, pt, nrm, idx);\n}\n\n// The main scene intersector.\nHit hitScene(vec3 ro, vec3 rd) {\n    Hit hit;\n    hit.hit = false;\n    float dMax = MAX_DIST;\n    \n    // Central sphere\n    Hit tmpHit = hitSphere(ro, rd, vec3(0.), .5 * RT5, dMax, 0);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        dMax = hit.t;\n    }\n    \n    // Outer spheres\n    for (int i = 0; i < 30; i ++) {\n        tmpHit = hitSphere(ro, rd, verts[i], .5, dMax, 1);\n        if (tmpHit.hit) {\n            hit = tmpHit;\n            dMax = hit.t;\n        }\n    }\n    \n    return hit;\n}\n\n/*\nLighting and color.\n*/\n\n// Gets the scene lighting.\nfloat getLighting(Hit hit, Material mat) {\n    // Hard shadow testing\n    vec3 P = hit.pt, N = hit.normal;\n    vec3 lightDir = normalize(LIGHT_POS - P);\n    vec3 shadowPt = P + EPS * N;\n    \n    if (hitScene(shadowPt, lightDir).hit) return 0.;\n    \n    // Phong model\n    vec3 V = normalize(eye - P);\n    vec3 R = reflect(-lightDir, N);\n    \n    float dotLN = dot(lightDir, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.) return 0.;\n    \n    float contrib = dotLN * mat.kDiffuse;\n    if (dotRV > 0.) {\n        // Compute specular\n        contrib += mat.kSpecular * pow(dotRV, mat.glossiness);\n    }\n    return contrib;\n}\n\n// Gets material and color for each object.\nvoid getObjectInfo(Hit hit, out vec3 col, out Material mat) {\n    if (hit.objIdx == 0) {\n        col = vec3(.5);\n        mat = Material(.7, .7, 5., .7);\n    } else if (hit.objIdx == 1) {\n        col = vec3(.1, .1, .6);\n        mat = Material(.7, 1., 15., .5);\n    }\n}\n\n/*\nCamera functions.\n*/\n\n// Computes the view matrix.\nvoid computeViewMat(vec3 lookAt) {\n    vec3 F = normalize(lookAt - eye);\n    vec3 S = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = cross(S, F);\n    viewMat = mat3(S, U, -F);\n}\n\n// Computes ray direction.\nvec3 getRay(vec2 p) {\n    p = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 camDir = normalize(vec3(p, -FOCAL_LEN));\n    return viewMat * camDir;\n}\n\n/*\nThe main rendering function.\n*/\n\nvec3 render(inout vec3 ro, inout vec3 rd, out float reflectivity) {\n    vec3 dir = rd;\n    Hit hit = hitScene(ro, dir);\n    reflectivity = 0.;\n    \n    // Compute reflected point and direction\n    vec3 N = hit.normal;\n    ro = hit.pt + EPS * N;\n    rd = reflect(rd, N);\n    \n    if (hit.hit) {\n        // Compute lighting and coloring if hit\n        vec3 col;\n        Material mat;\n        getObjectInfo(hit, col, mat);\n        \n        float contrib = getLighting(hit, mat) * INTENSITY + AMBIENT;\n        reflectivity = mat.reflectivity;\n        return col * contrib;\n    }\n    \n    return texture(iChannel0, dir).rgb;\n}\n\n/*\nTracing.\n*/\n\nvec3 trace(vec2 p) {\n    vec3 ro = eye;\n    vec3 rd = getRay(p);\n    float refl, coeff = 1.;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < BOUNCE_CT; i ++) {\n        col += render(ro, rd, refl) * coeff;\n        coeff *= refl;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 k, in vec2 c) {\n    // Move camera\n    float t = .5 * iTime;\n    eye = vec3(6. * cos(t), 4., 6. * sin(t));\n    computeViewMat(vec3(0.));\n    \n    vec3 col = trace(c);\n    k = vec4(pow(col, GAMMA), 1.);\n}","name":"Image","description":"","type":"image"}]}