{"ver":"0.1","info":{"id":"4lV3zc","date":"1475947051","viewed":555,"name":"Voronoi lines","username":"stb","description":"An extension of the voronoi pattern in which lines connect cell offsets less than 1 unit apart. Mouse x adjusts amount of cell jitter; mouse y adjusts line thickness.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","voronoi","lines","random","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// update: fixed adjustment of line thickness with mouse y (maybe broken for OpenGL only)\n\n// comment to disable perspective\n#define MODE7\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031, .11369, .13787) // int range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x+p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// get hash offset (jitter and p are assigned in main)\n#define getH(d) jitter * hash22(floor(p-d)) - d;\n\n// basic line function (ends are clipped not rounded)\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 n = normalize(p1-p0);\n    p -= p0;\n    float l = .5 * length(p1-p0);\n    return abs(dot(p, vec2(n.y, -n.x))) + step(l, abs(dot(p, n)-l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy-res/2.) / res.y + 1.e-4; // a small value is added to avoid errors where floor meets fract\n\t\n    // init p, with zoom\n\tvec2 p = 16. * uv;\n    \n    // 'mode 7'\n    #ifdef MODE7\n    \tp.y -= 10.;\n    \tp = - 5. * vec2(p.x/p.y, 20./p.y);\n    #endif\n    \n    // scrolling\n    p.x += iTime;\n    \n    // adjust cell jitter with mouse x\n    // usually this would be a fixed number or 1.0 (not considered)\n    float jitter = iMouse.z>0. ? min(1., iMouse.x / res.x) : 1.;\n    \n    // random offsets of neighbors (clockwise starting north)\n    vec3 v = vec3(-1., 0., 1.);\n    vec2 o[10];\n    o[0] = getH(v.yz);\n    o[1] = getH(v.zz);\n    o[2] = getH(v.zy);\n    o[3] = getH(v.zx);\n    o[4] = getH(v.yx);\n    o[5] = getH(v.xx);\n    o[6] = getH(v.xy);\n    o[7] = getH(v.xz);\n    o[8] = o[0];\t // trying to prevent excess code\n\to[9] = o[1];\t// <--'\n    \n    // center offset\n    vec2 c = getH(0.);\n    \n    // center cell dot (we won't know which lines connect, so all line caps contribute)\n    float f = length(fract(p)-c);\n    \n    // check neighbors and combine into f:\n    for(int n=0; n<8; n++) {\n        \n        // dots from neighbors\n        f = min(f, length(fract(p)-o[n]));\n        \n        // lines between center and neighbors\n        if(distance(c, o[n]) < 1.)\n\t\t\tf = min(f, line(fract(p), c, o[n]));\n        \n        // lines between adjacent neighbors\n        if(distance(o[n], o[n+1]) < 1.)\n\t\t\tf = min(f, line(fract(p), o[n], o[n+1]));\n        \n        // lines between every other neighbor\n        if(distance(o[n], o[n+2]) < 1.)\n\t\t\tf = min(f, line(fract(p), o[n], o[n+2]));\n    }\n    \n    // adjust line thickness with mouse y\n    f = iMouse.x>0. ? min(1., f / (1.-iMouse.y/res.y)) : f;\n    \n    #ifdef MODE7\n    \tfragColor = vec4(mix(f*vec3(1.3, 1., .7), vec3(.8, .8, 1.), clamp(p.y/70., 0., 1.)), 1.);\n    #else\n    \tfragColor = vec4(f*vec3(1.3, 1., .7), 1.);\n    #endif\n}","name":"Image","description":"","type":"image"}]}