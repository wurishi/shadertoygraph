{"ver":"0.1","info":{"id":"css3z8","date":"1665659088","viewed":424,"name":"Uneven Crooked Bricks","username":"Arnklit","description":"An attempt at crooked uneven bricks.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["intersection","bilinear","skewed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT Licence 2022 - Kasper Arnklit Frandsen\n\n//https://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\n// Copyright 2001, softSurfer (www.softsurfer.com); 2008, LSL-port by Nexii Malthus\nvec2 get_line_intersection(vec4 line1, vec4 line2) {\n\tvec2 A = line1.xy;\n\tvec2 B = line1.zw;\n\tvec2 C = line2.xy;\n\tvec2 D = line2.zw;\n\n    vec2 b = B - A;\n\tvec2 d = D - C;\n    float dotperp = b.x * d.y - b.y * d.x;\n\t// if I had to worry about parallel lines, but I shouldn't have to here\n    // if (dotperp == 0) return <-1,-1,-1>;\n\tvec2 c = C-A;\n    float t = (c.x * d.y - c.y * d.x) / dotperp;\n\treturn vec2(A.x + t * b.x, A.y + t * b.y);\n}\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// inverse biliniar by iq. https://www.shadertoy.com/view/lsBSDm\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    k2 /= k0; k1 /= k0; k0 = 1.0;\n    \n\t// if edges are parallel, this is a linear equation\n    if( abs(k2)<0.001 )\n    {\n        res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );\n    }\n    // otherwise, it's a quadratic\n\telse\n    {\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        \n        if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )\n        {\n           v = (-k1 + w)*ik2;\n           u = (h.x - f.x*v)/(e.x + g.x*v);\n        }\n        res = vec2( u, v );\n    }\n    \n    return res;\n}\n\nbool point_left_of_line(vec4 line, vec2 c) {\n\tvec2 a = line.xy;\n\tvec2 b = line.zw;\n\treturn ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) > 0.0;\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec2 skewed_uneven_cut(vec2 x, float randomness) {\n\tvec2 value = x;\n\tvalue = 0.5 + (rand2(value) - 0.5) * randomness;\n\treturn value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(6.0);\n    float randomness = sin(iTime);\n    \n    vec2 uv = fragCoord/iResolution.x + iTime * 0.1;\n    \n\tvec2 scaled_uv = uv * size;\n\t\n\tvec2 cell_id = floor(scaled_uv);\n\tvec2 cell_uv = fract(scaled_uv);\n\t\n\t// Instead of creaing one value for each tile, we create two that we can use for a line\n\t// to cut with.\n\tvec2 current = skewed_uneven_cut(cell_id, randomness);\n\tvec2 top = skewed_uneven_cut( cell_id + vec2(0.0, -1.0), randomness);\n\tvec2 top_right = skewed_uneven_cut( cell_id + vec2(1.0, -1.0), randomness);\n\tvec2 right = skewed_uneven_cut( cell_id + vec2(1.0, 0.0), randomness);\n\tvec2 bottom_right = skewed_uneven_cut( cell_id + vec2(1.0, 1.0), randomness);\n\tvec2 bottom = skewed_uneven_cut( cell_id + vec2(0.0, 1.0), randomness);\n\tvec2 bottom_left = skewed_uneven_cut( cell_id + vec2(-1.0, 1.0), randomness);\n\tvec2 left = skewed_uneven_cut( cell_id + vec2(-1.0, 0.0), randomness);\n\tvec2 top_left = skewed_uneven_cut( cell_id + vec2(-1.0, -1.0), randomness);\n\n\tvec2 brick_uv = vec2(0.0);\n\tvec2 a, b, c, d;\n\t\n\t\t// Horizontal\n\tif (mod(cell_id.x + cell_id.y, 2.0) > 0.5) {\t\t\n\t\t// The nine lines for horizontal cuts\n\t\tvec4 current_line = (cell_id.xyxy + vec4(vec2(-1.0, current.x), vec2(2.0, current.y))) / size.xyxy;\n\t\tvec4 top_line = (cell_id.xyxy + vec4(vec2(top.x, -2.0), vec2(top.y, 1.0))) / size.xyxy;\n\t\tvec4 top_right_line = (cell_id.xyxy + vec4(vec2(0.0, -1.0 + top_right.x), vec2(3.0, -1.0 + top_right.y))) / size.xyxy;\n\t\tvec4 right_line = (cell_id.xyxy + vec4(vec2(1.0 + right.x, -1.0), vec2(1.0 + right.y, 2.0))) / size.xyxy;\n\t\tvec4 bottom_right_line = (cell_id.xyxy + vec4(vec2(0.0, 1.0 + bottom_right.x), vec2(3.0, 1.0 + bottom_right.y))) / size.xyxy;\n\t\tvec4 bottom_line = (cell_id.xyxy + vec4(vec2(bottom.x, 0.0), vec2(bottom.y, 3.0))) / size.xyxy;\n\t\tvec4 bottom_left_line = (cell_id.xyxy + vec4(vec2(-2.0, 1.0 + bottom_left.x), vec2(1.0, 1.0 + bottom_left.y))) / size.xyxy;\n\t\tvec4 left_line = (cell_id.xyxy + vec4( vec2(-1.0 + left.x, -1.0), vec2(-1.0 + left.y, 2.0))) / size.xyxy;\n\t\tvec4 top_left_line = (cell_id.xyxy + vec4(vec2(-2.0, -1.0 + top_left.x), vec2(1.0, -1.0 + top_left.y))) / size.xyxy;\n\t\t\n\t\t// if above h cut\n\t\t\n\t\tif (!point_left_of_line(current_line, uv)) {\n\t\t\t// if left of v cut\n\t\t\tif (point_left_of_line(top_line, uv)) {\n\t\t\t\ta = get_line_intersection(top_left_line, left_line);\n\t\t\t\tb = get_line_intersection(top_line, top_left_line);\n\t\t\t\tc = get_line_intersection(current_line, top_line);\n\t\t\t\td = get_line_intersection(current_line, left_line);\n\t\t\t} else {\n\t\t\t\ta = get_line_intersection(top_right_line, top_line);\n\t\t\t\tb = get_line_intersection(right_line, top_right_line);\n\t\t\t\tc = get_line_intersection(current_line, right_line);\n\t\t\t\td = get_line_intersection(current_line, top_line);\n\t\t\t}\n\t\t} else {\n\t\t\t// if right of v cut\n\t\t\tif (!point_left_of_line(bottom_line, uv)) {\n\t\t\t\ta = get_line_intersection(current_line, bottom_line);\n\t\t\t\tb = get_line_intersection(current_line, right_line);\n\t\t\t\tc = get_line_intersection(bottom_right_line, right_line);\n\t\t\t\td = get_line_intersection(bottom_right_line, bottom_line);\n\t\t\t} else {\n\t\t\t\ta = get_line_intersection(left_line, current_line);\n\t\t\t\tb = get_line_intersection(bottom_line, current_line);\n\t\t\t\tc = get_line_intersection(bottom_line, bottom_left_line);\n\t\t\t\td = get_line_intersection(left_line, bottom_left_line);\n\t\t\t}\n\t\t}\n\t\tbrick_uv = (invBilinear(uv, a, b, c, d));\n\t// Vertical\n\t} else { \n\t\t// The nine lines for horizontal cuts\n\t\tvec4 current_line = (cell_id.xyxy + vec4(vec2(current.x, -1.0), vec2(current.y, 2.0))) / size.xyxy;\n\t\tvec4 top_line = (cell_id.xyxy + vec4(vec2(-1.0, -1.0 + top.x), vec2(2.0, -1.0 + top.y))) / size.xyxy;\n\t\tvec4 top_right_line = (cell_id.xyxy + vec4(vec2(1.0 + top_right.x, -2.0), vec2(1.0 + top_right.y, 1.0))) / size.xyxy;\n\t\tvec4 right_line = (cell_id.xyxy + vec4(vec2(0.0, right.x), vec2(3.0, right.y))) / size.xyxy;\n\t\tvec4 bottom_right_line = (cell_id.xyxy + vec4(vec2(1.0 + bottom_right.x, 0.0), vec2(1.0 + bottom_right.y, 3.0))) / size.xyxy;\n\t\tvec4 bottom_line = (cell_id.xyxy + vec4(vec2(-1.0, 1.0 + bottom.x), vec2(2.0, 1.0 + bottom.y))) / size.xyxy;\n\t\tvec4 bottom_left_line = (cell_id.xyxy + vec4(vec2(-1.0 + bottom_left.x, 0.0), vec2(-1.0 + bottom_left.y, 3.0))) / size.xyxy;\n\t\tvec4 left_line = (cell_id.xyxy + vec4( vec2(-2.0, left.x), vec2(1.0, left.y))) / size.xyxy;\n\t\tvec4 top_left_line = (cell_id.xyxy + vec4(vec2(-1.0 + top_left.x, -2.0), vec2(-1.0 + top_left.y, 1.0))) / size.xyxy;\n\t\t\n\t\t// if left of v cut\n\t\tif (point_left_of_line(current_line, uv)) {\n\t\t\t// if above h cut\n\t\t\tif (!point_left_of_line(left_line, uv)) {\n\t\t\t\ta = get_line_intersection(top_left_line, top_line);\n\t\t\t\tb = get_line_intersection(current_line, top_line);\n\t\t\t\tc = get_line_intersection(current_line, left_line);\n\t\t\t\td = get_line_intersection(top_left_line, left_line);\n\t\t\t} else {\n\t\t\t\ta = get_line_intersection(bottom_left_line, left_line);\n\t\t\t\tb = get_line_intersection(current_line, left_line);\n\t\t\t\tc = get_line_intersection(current_line, bottom_line);\n\t\t\t\td = get_line_intersection(bottom_left_line, bottom_line);\n\t\t\t}\n\t\t} else {\n\t\t\t// if above h cut\n\t\t\tif (!point_left_of_line(right_line, uv)) {\n\t\t\t\ta = get_line_intersection(current_line, top_line);\n\t\t\t\tb = get_line_intersection(top_right_line, top_line);\n\t\t\t\tc = get_line_intersection(top_right_line, right_line);\n\t\t\t\td = get_line_intersection(current_line, right_line);\n\t\t\t} else {\n\t\t\t\ta = get_line_intersection(current_line, right_line);\n\t\t\t\tb = get_line_intersection(bottom_right_line, right_line);\n\t\t\t\tc = get_line_intersection(bottom_right_line, bottom_line);\n\t\t\t\td = get_line_intersection(current_line, bottom_line);\n\t\t\t}\n\t\t}\n\t\tbrick_uv = (invBilinear(uv, a, b, c, d));\n\t}\n\t\n\t// Render the bricks\n    float brick_height = 1.0 / size.y;\n\tfloat round = 0.3 / brick_height;\n\tfloat mortar = 0.0 / brick_height;\n\tfloat bevel = 0.05 / brick_height;\n\n    float brick;\n\tvec2 dist = (min(brick_uv.xy, 1.0 - brick_uv.xy) * -2.0)*size.yx+vec2(round+mortar);\n    brick = length(max(dist, vec2(0))) + min(max(dist.x, dist.y), 0.0) - round;\n\tbrick = clamp(-brick/bevel, 0.0, 1.0);\n\t\n    // Output to screen\n    fragColor = vec4(vec3(brick),1.0);\n}","name":"Image","description":"","type":"image"}]}