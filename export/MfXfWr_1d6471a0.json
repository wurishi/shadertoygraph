{"ver":"0.1","info":{"id":"MfXfWr","date":"1723599426","viewed":31,"name":"raytracer test kitrae","username":"kitrae","description":"yuh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define MAX_REFLECTIONS 5\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\n#define NUM_SPHERES 7\n#define NUM_LIGHTS 3\nSphere spheres[NUM_SPHERES];\nLight lights[NUM_LIGHTS];\nvec3 sphereColors[NUM_SPHERES];\nfloat sphereReflectivity[NUM_SPHERES];\nfloat sphereRoughness[NUM_SPHERES];\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat opSubtraction(float d1, float d2) { return max(-d1, d2); }\n\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvoid initScene() {\n    spheres[0] = Sphere(vec3(0, 1, -5), 1.0);\n    spheres[1] = Sphere(vec3(2, 1.5, -7), 1.5);\n    spheres[2] = Sphere(vec3(-2, 1.2, -6), 1.2);\n    spheres[3] = Sphere(vec3(0, 0.5, -3), 0.5);\n    spheres[4] = Sphere(vec3(-1, 0.7, -4), 0.7);\n    spheres[5] = Sphere(vec3(1, 0.3, -2), 0.3);\n    spheres[6] = Sphere(vec3(-1.5, 0.4, -3.5), 0.4);\n\n    sphereColors[0] = vec3(0.8, 0.2, 0.2);\n    sphereColors[1] = vec3(0.2, 0.8, 0.2);\n    sphereColors[2] = vec3(0.2, 0.2, 0.8);\n    sphereColors[3] = vec3(0.8, 0.8, 0.2);\n    sphereColors[4] = vec3(0.2, 0.8, 0.8);\n    sphereColors[5] = vec3(0.8, 0.2, 0.8);\n    sphereColors[6] = vec3(0.5, 0.5, 0.5);\n\n    sphereReflectivity[0] = 0.1;\n    sphereReflectivity[1] = 0.3;\n    sphereReflectivity[2] = 0.5;\n    sphereReflectivity[3] = 0.7;\n    sphereReflectivity[4] = 0.9;\n    sphereReflectivity[5] = 0.2;\n    sphereReflectivity[6] = 0.6;\n\n    sphereRoughness[0] = 0.1;\n    sphereRoughness[1] = 0.05;\n    sphereRoughness[2] = 0.2;\n    sphereRoughness[3] = 0.01;\n    sphereRoughness[4] = 0.15;\n    sphereRoughness[5] = 0.3;\n    sphereRoughness[6] = 0.08;\n\n    lights[0] = Light(vec3(5, 5, -5), vec3(1.0, 0.9, 0.9));\n    lights[1] = Light(vec3(-5, 3, -5), vec3(0.5, 0.5, 1.0));\n    lights[2] = Light(vec3(0, 5, 0), vec3(1.0, 1.0, 1.0));\n}\n\nfloat sphereSDF(vec3 p, Sphere s) {\n    return length(p - s.center) - s.radius;\n}\n\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = planeSDF(p);\n    \n    // Create a box for CSG operations\n    float box = sdBox(p - vec3(0, 2.5, -5), vec3(1.5, 1.5, 1.5));\n    \n    // Perform CSG operations\n    d = opUnion(d, opSubtraction(sphereSDF(p, spheres[0]), box));\n    \n    for (int i = 1; i < NUM_SPHERES; i++) {\n        d = opSmoothUnion(d, sphereSDF(p, spheres[i]), 0.1);\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * sceneSDF(p + e.xyy) + \n                     e.yyx * sceneSDF(p + e.yyx) + \n                     e.yxy * sceneSDF(p + e.yxy) + \n                     e.xxx * sceneSDF(p + e.xxx));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++) {\n        if(t < maxt) {\n            float h = sceneSDF(ro + rd * t);\n            if(h < 0.001) return 0.0;\n            res = min(res, k * h / t);\n            t += h;\n        }\n    }\n    return res;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float scale = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = n * hr + p;\n        float dd = sceneSDF(aopos);\n        occ += -(dd - hr) * scale;\n        scale *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sceneSDF(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 rd, float roughness) {\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 lightPos = lights[i].position;\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(n, lightDir), 0.0);\n        vec3 h = normalize(lightDir - rd);\n        float spec = pow(max(dot(n, h), 0.0), 32.0 / (roughness + 0.01));\n        \n        float shadow = softShadow(p, lightDir, 0.02, length(lightPos - p), 16.0);\n        \n        diffuse += diff * lights[i].color * shadow;\n        specular += spec * lights[i].color * shadow;\n    }\n    \n    float ao = ambientOcclusion(p, n);\n    vec3 ambient = vec3(0.03) * ao;\n    \n    return ambient + diffuse + specular;\n}\n\nvec4 getColor(vec3 p) {\n    if (p.y < SURF_DIST) {\n        float check = mod(floor(p.x) + floor(p.z), 2.0);\n        return vec4(mix(vec3(0.1), vec3(0.2), check), 0.1);\n    }\n    \n    float d = MAX_DIST;\n    vec4 col = vec4(0);\n    float rough = 1.0;\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        float di = sphereSDF(p, spheres[i]);\n        if (di < d) {\n            d = di;\n            col = vec4(sphereColors[i], sphereReflectivity[i]);\n            rough = sphereRoughness[i];\n        }\n    }\n    return vec4(col.rgb, rough);\n}\n\nmat3 getCameraRotation(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 getSkyColor(vec3 rd) {\n    float t = 0.5 * (rd.y + 1.0);\n    vec3 sky = mix(vec3(0.5, 0.7, 1.0), vec3(0.2, 0.2, 0.6), t);\n    return sky + 0.2 * pow(max(dot(rd, normalize(vec3(1, 2, -3))), 0.0), 20.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 reflection = vec3(1);\n    \n    for (int i = 0; i <= MAX_REFLECTIONS; i++) {\n        float d = rayMarch(ro, rd);\n        \n        if (d < MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = getNormal(p);\n            vec4 material = getColor(p);\n            \n            vec3 light = getLight(p, n, rd, material.a);\n            col += reflection * material.rgb * light;\n            \n            ro = p + n * SURF_DIST * 2.0;\n            rd = reflect(rd, n);\n            reflection *= material.rgb * material.a;\n        } else {\n            col += reflection * getSkyColor(rd);\n            break;\n        }\n        \n        if (length(reflection) < 0.01) break;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    initScene();\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // Camera control with zoom\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float zoom = 1.0 / (1.0 + 5.0 * mouse.y); // Zoom based on vertical mouse position\n    \n    float camDist = 10.0 * zoom;\n    float camHeight = 1.0 + 3.0 * mouse.y;\n    float camAngle = mouse.x * 2.0 * 3.14159;\n    \n    vec3 ro = vec3(camDist * cos(camAngle), camHeight, camDist * sin(camAngle));\n    vec3 ta = vec3(0, 0, -5);\n    \n    mat3 camRotation = getCameraRotation(ro, ta);\n    vec3 rd = camRotation * normalize(vec3(uv.x, uv.y, zoom));\n    \n    vec3 col = render(ro, rd);\n    \n    // Tone mapping (ACES)\n    col = (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    // Vignette effect\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.25);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}