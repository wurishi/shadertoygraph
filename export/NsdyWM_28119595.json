{"ver":"0.1","info":{"id":"NsdyWM","date":"1653535304","viewed":57,"name":"2D Graph Thingy","username":"Modern_XP","description":"It's a graph I guess.\nI'm still working on it.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n// Feel free to change these up. :)\nbool DarkMode = true;\n//\nvec2 GridPosition = vec2(0.0, 0.0);\nvec2 GridScale = vec2(5.0, 5.0);\nvec2 GridSize = vec2(1.0, 1.0);\nvec2 SubGridSize = vec2(0.2, 0.2);\nfloat GridLineThickness = 0.05;\n//\nvec3 LineColor = vec3(1.0, 0.625, 0.5);\nfloat LineThickness = 0.05;\n//\nfloat TimeScale = 3.0;\n// This is the function being graphed as a line.\n// Input Coords: The \nfloat LineFunction(in vec2 InputCoords, in float Time) {\n    float Result = 0.0;\n    //\n    Result = exp(InputCoords.x);\n    Result = (length(InputCoords)-1.0);\n    //\n    return Result;\n}\n//\nvec2 PreviousMousePos = vec2(0), CurrentMousePos;\n//\nvec2 GetGridDistance(vec2 Coords, vec2 Interval) {\n    vec2 A0 = Coords/Interval;\n    return abs(-floor(2.0 * mod(A0, vec2(1))) + mod(A0, vec2(1))) * Interval;\n}\n//\nvoid DrawGrid(inout vec3 Image, vec2 Coords, vec2 GridIntervals, vec2 SubGridIntervals){//, float LineThickness) {\n    vec3 XAxisColor = vec3(1,0,0);\n    vec3 YAxisColor = vec3(0,1,0);\n    vec3 GridColor = vec3(0.75);\n    vec3 SubGridColor = vec3(0.25);\n    //\n    vec2 GridLineThickness = LineThickness/GridIntervals;\n    vec2 SubGridLineThickness = LineThickness/SubGridIntervals;\n    //\n    //bool Origin = max(abs(Coords.x),abs(Coords.y)) < (LineThickness/2.0);\n    //bvec2 GridAxes = bvec2( lessThan(abs(Coords.yx), vec2(LineThickness/2.0)) );\n    //bvec2 GridLines = bvec2( lessThan(fract((Coords.yx/GridIntervals) + (GridLineThickness/2.0)), GridLineThickness) );\n    //bvec2 SubGridLines = bvec2( lessThan(fract((Coords.yx/SubGridIntervals) + (SubGridLineThickness/2.0)), SubGridLineThickness) );\n    //\n    float OriginDistance = max(abs(Coords.x),abs(Coords.y));\n    vec2 AxisDistances = abs(Coords.yx);\n    vec2 GridLineDistances = GetGridDistance(Coords, GridIntervals);\n    vec2 SubGridLineDistances = GetGridDistance(Coords, SubGridIntervals);\n    //\n    vec3 ColorBuffer = Image;\n    //\n    Image = mix(Image, SubGridColor, smoothstep(LineThickness / 2.0, 0.0, min(SubGridLineDistances.x, SubGridLineDistances.y)));\n    //\n    Image = mix(Image, GridColor, smoothstep(LineThickness / 2.0, 0.0, min(GridLineDistances.x, GridLineDistances.y)));\n    //\n    Image = mix(Image, XAxisColor, smoothstep(LineThickness / 2.0, 0.0, AxisDistances.x));\n    Image = mix(Image, YAxisColor, smoothstep(LineThickness / 2.0, 0.0, AxisDistances.y));\n    //\n    Image = mix(Image, XAxisColor + YAxisColor, smoothstep(LineThickness / 2.0, 0.0, OriginDistance));\n    //      // Axis //                 // Gridlines //            // Sub-Gridlines //\n    //Image = (GridAxes.x ? XAxisColor : (GridLines.x ? GridColor : (SubGridLines.x ? SubGridColor : Image)));\n    //Image = (GridAxes.y ? YAxisColor : (GridLines.y ? GridColor : (SubGridLines.y ? SubGridColor : Image)));\n    //      // Origin //\n    //Image = (Origin ? (XAxisColor+YAxisColor) : Image);\n}\n//\nvoid mainImage( out vec4 OutColor, in vec2 FragCoord ) {\n    // I wanna get the ability to drag the graph around for easier viewing done at some point.\n    //vec4 Mouse = texture(iChannel0, vec2(0,0));\n    //GridPosition += (Mouse.zw - Mouse.xy) * GridScale;\n    //\n    vec3 ResultColor = vec3(DarkMode ? 0.0 : 1.0);\n    vec2 NormalizedFragCoord = (FragCoord * 2.0 - iResolution.xy) * GridScale / iResolution.y;\n    vec2 GridCoord = NormalizedFragCoord + GridPosition;\n    //\n    DrawGrid(ResultColor,GridCoord,GridSize,SubGridSize);\n    //\n    float FunctionResult = LineFunction(GridCoord, mod(iTime, TimeScale));\n    float LineValue = abs(FunctionResult-GridCoord.y) - abs(dFdx(FunctionResult) * 1.5);\n    //float LineValue = abs(FunctionResult-GridCoord.y);\n    //float LineValue = FunctionResult-GridCoord.y;\n    ResultColor = vec3((LineValue < LineThickness) ? vec3(1,0.625,0.5) : ResultColor);\n    ResultColor = mix(ResultColor, LineColor, smoothstep(1.5 * fwidth(LineValue), 0.0, abs(LineValue)-LineThickness));\n    //\n    //ResultColor = distance(GridCoord,Mouse.xy) < 0.05 ? vec3(1,1,0.5) : ResultColor;\n    //ResultColor = distance(GridCoord,Mouse.zw) < 0.05 ? vec3(1,0.5,0.85) : ResultColor;\n    //\n    OutColor = vec4(ResultColor,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    vec4 NormalizedMousePos = texture(iChannel1, vec2(0,0));\n    fragColor = NormalizedMousePos;\n    //\n    if (texelFetch(iChannel2, ivec2(9,0),0).x != 0.0) { fragColor = vec4(0); }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Gets and saves normalized mouse position.\n// Total position saved in Buffer A.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, vec2(0,0));\n    vec4 Result = (iMouse.xyzw * 2.0 - iResolution.xyxy) / iResolution.y;\n    fragColor.xy = Result.xy;\n    if (distance(iMouse.xy, iMouse.zw) <= 0.01) { fragColor.zw += Result.xy; }\n    if (texelFetch(iChannel1, ivec2(9,0),0).x != 0.0) { fragColor = vec4(0); }\n}","name":"Buffer B","description":"","type":"buffer"}]}