{"ver":"0.1","info":{"id":"ddtczM","date":"1695044905","viewed":26,"name":"Plane Wave Emission","username":"EdgarDorausch","description":"Plane Wave Emission\n\n=== INPUT: ===\n - Space key to toggle between simulation and analytical solution.\n - Use mouse (drag horizontally) to change k_x.","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["planewave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cexp(p) vec2(cos(p), sin(p))\n\n#define PI 3.14159265359\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\n\nfloat hLinePos = 0.1;\nconst float w = 5.0;\nconst float num_tx = 128.0;\nfloat k_x = 0.1;\nfloat k_y;\nfloat y_damp = 10.0;\nconst float c = 0.1;\n\nconst float k0 = w/c;\n\n\nvec3 rbcolormap(float val) {\n\n    return vec3(clamp(val, 0.0, 1.0), 0.0, clamp(-val, 0.0, 1.0));\n}\n\n\n// From: https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat printNumber(vec2 fragCoord, float number) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -4; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) a[c++] = 10; // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec2 muv = iMouse.xy/iResolution.x;\n    \n    // temporal and spatial variables\n    float t = iTime;\n    float x = uv.x;\n    float y = uv.y;\n    \n\n    \n    \n    \n    k_x = (muv.x-0.5)*4.0*k0;\n    float k_x_array = k_x;\n \n    if(abs(k_x) < k0) {\n         k_y = sqrt(k0*k0 - k_x*k_x);\n         y_damp = 0.0;\n    } else {\n        y_damp = sqrt(k_x*k_x - k0*k0);\n        k_y = 0.0;\n        k_x_array = k_x;\n        // k_x = sign(k_x)*k0;\n        \n    }\n    \n    \n    \n    \n    vec2 arrayWave = cexp(k_x_array*x - w*t);\n    \n    vec2 bulkWave = cexp(k_x*x + k_y*(uv.y-hLinePos) - w*t);\n    \n    \n\n    // Time varying pixel color\n    vec3 col =vec3(0.0);\n    \n    col += clamp(0.8-300.0*abs(uv.y-hLinePos), 0.0, 1.0);\n    \n    if(uv.x > 0.25 && uv.x < 0.75)\n        col += clamp(2.0-300.0*abs(uv.y-hLinePos), 0.0, 1.0);\n    \n    if(uv.y < hLinePos)\n     col += rbcolormap(arrayWave.x);\n     \n    if(uv.y > hLinePos){\n    \n     if(texelFetch( iChannel0, ivec2(KEY_SPACE,2),0 ).x == 0.0) {\n         col += rbcolormap(bulkWave.x) * exp(-y_damp*(y-hLinePos));\n     } else {\n    \n     \n\n         vec2 sparse_balk_wave = vec2(0.0);\n         float num_sum = 0.0;\n\n         for(float sx=0.25; sx<=0.75; sx+=1.0/num_tx ){\n             num_sum+=1.0;\n             float s_dist = length(uv - vec2(sx, hLinePos));\n             vec2 sparse_source_field = cexp(k0*s_dist + k_x_array*sx)/(s_dist*s_dist+0.001)*(y-hLinePos);\n             sparse_balk_wave += sparse_source_field;\n\n              //col += rbcolormap(pow(sparse_source_field, 5.0))*0.008;\n         }\n         \n         sparse_balk_wave = product(sparse_balk_wave, cexp(-w*t));\n\n         col += rbcolormap(sparse_balk_wave.x/num_sum)*1.0;\n     }\n     \n    }\n    \n    col = mix(col, GREEN, printNumber(fragCoord, k_x_array));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}