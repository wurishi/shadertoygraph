{"ver":"0.1","info":{"id":"XtyBDd","date":"1619701305","viewed":216,"name":"Orca","username":"skaplun","description":"old but gold","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["2d","interactive","animation","sliced"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 layerCenter(int l){\n\treturn T(vec2(l, 0)).xy;\n}\n\nfloat getRad(float x){\n\treturn pow(sin(x * PI) * .6, .7);\n}\n\nvec2 color(vec2 uv, int l){\n    vec2 cntr = layerCenter(l);\n    cntr.y -= smoothstep(10., 30., float(l)) * .4;\n    \n    if (l <= 30){\n        float rad = getRad(float(l + 1)/float(34));\n    \trad -= smoothstep(10., 30., float(l)) * .1;\n        float outer = step(distance(uv, cntr), rad);\n        vec2 clr = vec2(1. - outer, outer);\n\n        clr.x = max(clr.x, step(distance(uv, cntr - vec2(0., rad * 2. + .025 * float(l))), rad * 2.));\n        float coef = smoothstep(-10., 20., abs(float(l - 15)));\n        clr.x = max(clr.x, step(1., float(l)) * (1. - distance(uv.y, cntr.y + rad) * (10. + 10. * smoothstep(3., 0., float(l))) * pow(coef, .5)) * .5);\n\n\n\n        if(l >= 2 && l <= 10){\n            float spotSize = (.125 - .01 * distance(float(l), 4.));\n            vec2 lC = uv - cntr + rotate2D(vec2(rad * 1.25 - rad * 1.25 * .5 * float(l)/float(8), 0.), PI * .85);\n            lC = rotate2D(lC, PI * .15);\n            float c = step(abs(lC.y), pow(cos(abs(lC.x) * PI * 4.), .5) * spotSize) * step(abs(lC.x), .2);\n\n            lC = uv - cntr + rotate2D(vec2(rad * 1.25 - rad * 1.25 * .5 * float(l)/float(8), 0.), PI * .15);\n            lC = rotate2D(lC, PI * -.15);\n            c = max(c, step(abs(lC.y), pow(cos(abs(lC.x) * PI * 4.), .5) * spotSize) * step(abs(lC.x), .2));\n\n            clr.x = max(clr.x, c);\n\n            if(l == 5 || l == 4){\n                vec2 lC = uv - cntr;\n                lC.x = abs(lC.x);\n                float eye = step(.035, distance(lC, vec2(.35, .08)));\n                clr.x *= eye;\n                clr.y = max(clr.y, 1. - eye);\n            }\n        }\n\n        if (l >= 15 && l <= 21){\n            float coef = smoothstep(13., 22., float(l));\n            float height = pow(sin(coef * PI), 1.25) * 1.25;\n            float thikness = 4. + abs(coef - .5) * 5.;\n            vec2 lC = uv - cntr - vec2(0., rad);// + rotate2D(vec2(rad * 1.25 - rad * 1.25 * .5 * float(l)/float(8), 0.), PI * .85);\n            //lC = rotate2D(lC, PI * .15);\n            float c = step(abs(lC.y), pow(cos(abs(lC.x) * PI * thikness), .6) * height) * step(abs(lC.x), .2) * step(-.1, lC.y);\n            clr.x = min(clr.x, 1. - c);\n            clr.y = max(clr.y, c);\n\n            //clr.x = max(clr.x, step(rad, length(uv - cntr)) * (abs(uv.y - cntr.y + height) * 2.) * .25);\n            clr.x = max(clr.x, (1. - distance(cntr.y + rad + height, uv.y) * abs(coef - .5) * 10.) * .4);\n        }\n\n        if (l >= 10 && l <= 15){\n            float coef = smoothstep(9., 16., float(l));\n            float height = pow(sin(coef * PI), .5) * .5;\n            float r = rad + pow(coef, .75) * rad;\n            float thikness = 5. + abs(coef - .5) * 5.;\n            vec2 lC = rotate2D(uv - cntr + rotate2D(vec2(r, 0.), PI * 1.8), PI * .7);// + vec2(0., rad);\n            float c = step(abs(lC.y), pow(cos(abs(lC.x) * PI * thikness), .3) * height) * step(abs(lC.x), .2);\n            clr.x = min(clr.x, 1. - c);\n            clr.y = max(clr.y, c);\n\n            lC = rotate2D(uv - cntr + rotate2D(vec2(r, 0.), PI * 1.19), PI * .3);// + vec2(0., rad);\n            c = step(abs(lC.y), pow(cos(abs(lC.x) * PI * thikness), .3) * height) * step(abs(lC.x), .2);\n            clr.x = min(clr.x, 1. - c);\n            clr.y = max(clr.y, c);\n\n            vec2 anchorPtnt = cntr + rotate2D(vec2(rad * .6, 0.), PI * .7);\n            clr.x = max(clr.x, step(rad, length(uv - cntr)) * (1. - abs(uv.y - anchorPtnt.y) * 6.) * .5);\n        }\n\n        return clr;\n    }else{\n        float coef = smoothstep(30., 35., float(l));\n        float height = pow(sin(coef * PI), .5) * .5;\n        float rad = 0.3;\n        float r = rad + pow(coef, 2.5) * rad;\n        float thikness = 5. + abs(coef - .5) * 5.;\n        vec2 lC = rotate2D(uv - cntr + rotate2D(vec2(r, 0.), PI * 1.9), PI * .7);// + vec2(0., rad);\n        float c = step(abs(lC.y), pow(cos(abs(lC.x) * PI * thikness), .3) * height) * step(abs(lC.x), .2);\n        lC = rotate2D(uv - cntr + rotate2D(vec2(r, 0.), PI * 1.1), PI * .3);// + vec2(0., rad);\n        c = max(c, step(abs(lC.y), pow(cos(abs(lC.x) * PI * thikness), .3) * height) * step(abs(lC.x), .2));\n        \n        return vec2(1. - c, c);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y * 1.25;\n    float clr = .9;\n    //vec2 lClr = color(uv, 29);\n    //\tclr = mix(clr, lClr.x, lClr.y);\n    \n    for (int i=LAYERS_CNT-1; i >= 0; i--) {\n        vec2 lClr = color(uv, i);\n    \tclr = mix(clr, lClr.x, lClr.y);\n    }\n    \n        \n\t\n    fragColor = vec4(vec3(clr), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPEED 50.\n#define FOLLOW_SPEED 5.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(int(fragCoord.y) == 0 && int(fragCoord.x) < LAYERS_CNT){\n        bool isFirst = int(fragCoord.x) == 0;\n        vec2 prevCenterPoint = (iFrame == 0)?vec2(.5):T(ivec2(fragCoord.x, 0)).xy;\n        vec2 targetPoint = isFirst\n            \t\t\t\t? (iMouse.xy*2.-iResolution.xy)/iResolution.y\n            \t\t\t\t: T(ivec2(fragCoord.x, 0) - ivec2(1, 0)).xy;\n        vec2 dir = targetPoint - prevCenterPoint;\n        float l = length(dir);\n        float speed = isFirst ? 5. : SPEED;\n        if(l > .000001/*EPS*/){\n            prevCenterPoint += normalize(dir) * min(l, iTimeDelta * l * speed);// * (1. + smoothstep(float(LAYERS_CNT), 1., fragCoord.x) * .5);\n        }\n        fragColor = vec4(prevCenterPoint.xyxy);\n        //vec2 pos = vec2(-1.5 + float(fragCoord.x)/float(LAYERS_CNT) * 3., 0.);\n        //fragColor = vec4(pos.xyxy);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPS 1e-6\n#define PI 3.1415\n#define LAYERS_CNT 35\n#define T(U) texelFetch(iChannel0, ivec2(U), 0)\n\n/*\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= .5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += .5;\n    return _st;\n}\n*/\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n}","name":"Common","description":"","type":"common"}]}