{"ver":"0.1","info":{"id":"ltSyRm","date":"1507883169","viewed":245,"name":"Sliding mandelbrot","username":"yqy","description":"Changing mandelbrot parameter smoothly.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float param2 = 1024.f;\nconst float d = 0.00003f;\nconst float PI = radians(180.f);\nconst float TAU = radians(360.f);\n\n#define div(a, b) int((a) / (b))\n#define sqr(a) ((a) * (a))\n#define cub(a) (sqr(a) * (a))\n\n#define map3(f, v) vec3(f((v).x), f((v).y), f((v).z))\n\nint   idiv (int a, int b) { return a/b + (a%b>0?1:0); }\nint   imod (int a, int b) { return a>=0 ? a%b : b-1+(a+1)%b; }\nfloat add2 (vec2 a) { return a.x + a.y; }\nfloat sub2 (vec2 a) { return a.x - a.y; }\nbool  bxor2(bvec2 a) { return a.x ^^ a.y; }\nvec2  flip2(vec2 a) { return vec2(a.y, a.x); }\n\nvec2 cx_conj(vec2 a) { return vec2(a.x, -a.y); }\nvec2 cx_inv (vec2 a) { return cx_conj(a) / add2(a*a); }\nvec2 cx_mul (vec2 a, vec2 b) { return vec2(sub2(a*b), add2(a*flip2(b))); }\nvec2 cx_div (vec2 a, vec2 b) { return cx_mul(a, cx_conj(b)); }\n\nvec3 hsv2rgb(float h, float s, float v) {\n    h = fract(h) * 6.f;\n    float c = v * s;\n    float x = c * (1.f - abs(mod(h, 2.f) - 1.f));\n    float m = v - c;\n\n    #define ret(a, b, c)\\\n        return vec3(a + m, b + m, c + m)\n\n    switch (int(h)) {\n        case 0: ret(c, x, 0.f);\n        case 1: ret(x, c, 0.f);                                                                                                          \n        case 2: ret(0.f, c, x);                                                                                                          \n        case 3: ret(0.f, x, c);                                                                                                          \n        case 4: ret(x, 0.f, c);                                                                                                          \n        case 5: ret(c, 0.f, x);                                                                                                          \n    }                                                                                                                                  \n                                                                                                                                       \n    #undef ret                                                                                                                         \n}                                                                                                                                      \n                                                                                                                                       \nvec3 lab2xyz(float l, float a, float b) {                                                                                              \n    const vec3 w = vec3(0.95047f, 1.f, 1.08883f);                                                                                          \n    vec3 c = vec3((l + 16.f) / 116.f)                                                                                                      \n           + vec3(a / 500.f, 0.f, -b / 200.f);                                                                                               \n    #define f(t)\\\n        t > 6.f / 29.f\\\n            ? cub(t)\\\n            : (116.f * t - 16.f) * 27.f / 24389.f\n    return w * map3(f, c);                                                                                                             \n    #undef f                                                                                                                           \n}                                                                                                                                      \n                                                                                                                                       \nvec3 lab2rgb(float l, float a, float b) {\n    const mat3 m = mat3(\n         3.2404542f, -1.5371385f, -0.4985314f,\n        -0.9692660f,  1.8760108f,  0.0415560f,\n         0.0556434f, -0.2040259f,  1.0572252f\n    );\n    #define f(t)\\\n        t > 0.00304f\\\n            ? 1.055f * pow(t, 1.f / 2.4f) - 0.055f\\\n            : 12.92f * t\n    vec3 c = lab2xyz(l, a, b) * m;\n    return map3(f, c);\n    #undef f\n}\n\nvec3 labhsv(float h, float s, float v) {\n    h *= TAU;\n    s *= 100.f;\n    v *= 100.f;\n    return lab2rgb(v, s * sin(h), s * cos(h));\n}\n\nfloat foo(vec2 v)\n{\n    return log2(abs(log2(sqr(v.x) + sqr(v.y))));\n}\n\nfloat mandel(vec2 c, float n)\n{\n    vec2 z = vec2(0.f);\n    vec2 z_tmp;\n    int i = 0;\n    while (length(z) < param2 && (i < int(n) - 1))\n    {\n        z = cx_mul(z, z) + c;\n        ++i;\n    }\n    float a = n - float(int(n));\n    z = z * (1. - a) + (cx_mul(z, z) + c) * a;\n    return float(i + 1) - foo(z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = fragCoord.xy / iResolution.xy;\n    pp.x = pp.x * 4.f - 8.f/3.f;\n    pp.y = pp.y * 8.f/3.f - 4.f/3.f;\n\n    float param1 = pow(abs(sin(iTime / 10.f)), 1.6) * 32.f + 1.f;\n    float m = mandel(pp, param1) / param1;\n    float mx = mandel(pp + vec2(d, 0.f), param1) / param1;\n    float my = mandel(pp + vec2(0.f, d), param1) / param1;\n    float grad = atan((m - mx) / d, -(m - my) / d);\n\n    fragColor = vec4(labhsv(m / 12.f, (m + 0.6f) / 2.3f, abs(grad)/PI), 1.f);\n}","name":"Image","description":"","type":"image"}]}