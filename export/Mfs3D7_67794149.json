{"ver":"0.1","info":{"id":"Mfs3D7","date":"1703166243","viewed":20,"name":"Fork Fork Sketc karakure17 230","username":"karakure178","description":"This time I tried warping the uv coordinates by scaling them according to noise instead of rotating them. The grid grows outwards when the noise value is high (the red spots) and stays in place for low noise (white)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"Mcs3D7","parentname":"Fork Sketch #11 karakure17 777"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n// -------------------------------------------\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n// -------------------------------------------\n\n// 参考：https://www.shadertoy.com/view/dtXfWX\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\nfloat grid(in vec2 uv, in float size)\n{\n    uv = fract(uv);\n    return smoothstep(0.0, size*0.05, uv.y);\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nmat2 scale2D(float scalar)\n{\n    return mat2(scalar, 0.0,\n                0.0, scalar);\n}\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(in vec2 uv, in float sampleNum)\n{\n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    return val;\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// ------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 10.0;\n    float normalGrid = grid(uv, 1.0);\n    float noise = noise(uv + vec2(2.0)*iTime, 0.2);\n    uv *= 1.0 - 0.2*noise;\n    float warpedGrid = grid(uv, 30.0);\n    \n    vec2 st = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    st = tile(st,4.); \n    st = rotate2D(st, PI*0.25);\n    vec3 col = vec3(box(st,vec2(0.7))); \n    \n    vec3 HSV = vec3(0.0, 0.0, 0.0);\n    HSV[0] = 0.0;\n    HSV[1] = 0.0;\n    HSV[2] = step(0.3,  warpedGrid);// 二値化している\n    vec3 is_col = hsv2rgb(HSV);\n    \n    if(col == is_col){\n        fragColor = vec4(0.0,0.0,0.0,1.0);       \n    }else{\n        fragColor = vec4(1.0,1.0,1.0,1.0);       \n    }\n    //fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}