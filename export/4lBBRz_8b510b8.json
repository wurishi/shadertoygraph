{"ver":"0.1","info":{"id":"4lBBRz","date":"1514150440","viewed":3824,"name":"Pseudo Pixel Sorting","username":"AndrewR","description":"My first shader, for Resolume FFGL plugin. Sorting every pixel in a column is too resource intensive for 1080p, so I broke the columns into 10 sections & faded between each color. Works well enough w/ only 30FPS hit in Resolume. Feedback is appreciated!","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["pixel","glitch","sort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision lowp int;\nprecision mediump float;\n\n//\"Random\" function borrowed from The Book of Shaders: Random\nfloat random ( vec2 xy )\n{\n    return fract( sin( dot( xy.xy, vec2(12, 78) ) ) );\n}\n\nfloat luminance(vec4 color)\n{\n    return ( (color.r * 0.3) + (color.g * 0.6) + (color.b * 0.1) ) * color.a;\n}\n\n// Returns the y coordinate of the first pixel that is brighter than the threshold\nfloat getFirstThresholdPixel(vec2 xy, float threshold)\n{\n\tfloat luma = luminance( texture( iChannel0, xy / iResolution.xy ) );\n\n\t//Looking at every sequential pixel is very resource intensive,\n\t//thus, we'll increment the inspected pixel by dividing the image height in sections,\n\t//and add a little randomness across the x axis to hide the division of said sections\n    float increment = iResolution.y / (30.0 + (random( xy.xx ) * 6.0)); \n\n    //Check if the luminance of the current pixel is brighter than the threshold,\n    //if not, check the next pixel\n\twhile( luma <= threshold )\n\t{\n\t\txy.y -= increment;\n        if( xy.y <= 0.0 ) return 0.0;\n\t\tluma = luminance( texture( iChannel0, xy / iResolution.xy ) );\n\t}\n    \n\treturn xy.y;\n}\n\n//Puts 10 pixels in an array\nvec4[10] putItIn( vec2 startxy, float size, vec4 colorarray[10] )\n{\n    vec2 xy;\n    int j;\n    \n    for( j = 9; j >= 0; --j )\n    {\n        //Divide the line of pixels into 10 sections,\n        //then store the pixel found at the junction of each section\n        xy = vec2(startxy.x, startxy.y + (size / 9.0) * float(j));\n        \n        colorarray[j] = texture( iChannel0, xy / iResolution.xy );\n    }\n    \n    return colorarray;\n}\n\n//An attempt at Bubble sort for 10 pixels, sorting them from darkest to brightest, top to bottom\nvec4[10] sortArray(vec4 colorarray[10])\n{\n    vec4 tempcolor;\n    int j;\n    int swapped = 1;\n    \n    while( swapped > 0 )\n    {\n        swapped = 0;\n\t\tfor( j = 9; j > 0; --j )\n    \t{\n        \tif( luminance(colorarray[j]) > luminance(colorarray[j - 1]) )\n        \t{           \n            \ttempcolor = colorarray[j];\n            \tcolorarray[j] = colorarray[j - 1];\n            \tcolorarray[j - 1] = tempcolor;\n            \n            \t++swapped;\n        \t}\n    \t}\n    }\n    \n    return colorarray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n\tfloat firsty = getFirstThresholdPixel( vec2(fragCoord.x, iResolution.y), 0.0 );\n    float secondy = getFirstThresholdPixel( vec2(fragCoord.x, firsty - 1.0), 0.5);\n\n    //Only work on the pixels that are between the two threshold pixels\n    if( fragCoord.y < firsty && fragCoord.y > secondy )\n    {\n\t\tfloat size = firsty - secondy;\n\n\t\tvec4 colorarray[10];\n\t\tcolorarray = putItIn( vec2(fragCoord.x, secondy), size, colorarray );\n\t\tcolorarray = sortArray( colorarray );\n\t\n\t\tfloat sectionSize = size / 9.0;\n\t\tfloat location = floor( (fragCoord.y - secondy) / sectionSize );\n\t\tfloat bottom = secondy + (sectionSize * location);\n\t\tfloat locationBetween = (fragCoord.y - bottom) / sectionSize;\n\n        //A simple method for \"fading\" between the colors of our ten sampled pixels\n\t\tvec4 topColor = colorarray[int(location) + 1] * locationBetween;\n\t\tvec4 bottomColor = colorarray[int(location)] * (1.0 - locationBetween);\n\t\t\n\t\tfragColor = topColor + bottomColor;\n    }\n    else\n    {\n\t\tfragColor = texture( iChannel0, (fragCoord.xy / iResolution.xy) );\n    }\n}","name":"Image","description":"","type":"image"}]}