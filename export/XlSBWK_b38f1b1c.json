{"ver":"0.1","info":{"id":"XlSBWK","date":"1517116635","viewed":424,"name":"ray marching and reflection","username":"youko","description":"just a sketch","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Ye Liu 2018/01/28\n\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEP = 32; \n\n//geometry property\nvec3 sphere_p = vec3(3,0.0,0.0);\nfloat sphere_r = 1.0;\n\nvec3 box_p = vec3(-2,0.0,0.0);\nvec3 box_s = vec3(1.0,1.0,1.0);\n\n//vec3 mirror_p = vec3(0,0,-2);\nvec4 mirror_n = vec4(0.0,0.0,1.0,0.0);\n\n//camera \nvec3 eye = vec3(0.0, -1.0, 4.0);\nvec3 up = vec3(0,1,0);\n/*vec3 right = vec3(1,0,0);*/\nvec3 eyeLookAt = vec3(0.0, 0.0, 0.0);\n\n//sdf\nfloat sdSphere(vec3 p, float radius) {\n\n    return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 size ){  \n    vec3 d = abs(p) - size;  \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n ){  \n    return dot(p,n.xyz) + n.w;\n}\n\nfloat distanceField(vec3 p) {\n    float d1 = sdSphere(p+sphere_p, sphere_r);    \n    float d2 = sdBox(p+box_p,box_s);\n    float d3 = sdPlane(p,mirror_n);\n    return min(d3,min(d1, d2));\n}\n\nvec2 distanceField2(vec3 p) {\n    float i=0.0;\n    float d1 = sdSphere(p+sphere_p, sphere_r);    \n    float d2 = sdBox(p+box_p,box_s);\n    float d3 = sdPlane(p,mirror_n);\n    float m = min(d3,min(d1, d2));\n    if(m==d3){\n        i = 3.0;\n    }\n    return vec2(m,i);\n}\n\n//light!\nvec3 getNormal(vec3 p){\n    vec3 normal = normalize(vec3(\n        distanceField(vec3(p.x + EPSILON, p.y, p.z)) - distanceField(vec3(p.x - EPSILON, p.y, p.z)),\n        distanceField(vec3(p.x, p.y + EPSILON, p.z)) - distanceField(vec3(p.x, p.y - EPSILON, p.z)),\n        distanceField(vec3(p.x, p.y, p.z  + EPSILON)) - distanceField(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    return normal;\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0*sin(0.3 * iTime),\n                          2.0*cos(0.3 * iTime),\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    vec3 light2Pos = vec3(2.0 * cos(0.37 * iTime),\n                          2.0 * sin(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    \n    return color;\n}\n\n//trace\n/*float trace(vec3 o, vec3 r){\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = o + r * depth;\n        float dist = distanceField(p);\n        if (dist < EPSILON) {\n               return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}*/\n\n\n\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //uv\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    float ea=0.0;\n    vec3 eyeOrigin = vec3(eye.z*sin(ea)+eye.x*cos(ea),\n                          eye.y,\n                          eye.z*cos(ea)-eye.x*sin(ea));\n    vec3 eyeDir = normalize(eyeLookAt - eyeOrigin);\n    vec3 eyeRight = normalize(cross(up, eyeOrigin));\n    vec3 eyeUp = normalize(cross(eyeDir, eyeRight));\n    \n    //ray\n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    vec3 o = eyeOrigin;\n    vec3 r = rayDir;\n    float reflection = 0.0;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);//ambient\n    vec3 K_d = vec3(0.7, 0.2, 0.2);//diffuse\n    vec3 K_s = vec3(1.0, 1.0, 1.0);//specular\n    float shininess = 5.0;\n    vec3 color=vec3(0.0,0.0,0.0);\n           \n    //float dist=trace(o,r);\n    float dist = MAX_DIST;\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 pos = o + r * depth;\n        vec2 cal_d=  distanceField2(pos);\n        float d = cal_d.x;\n        float index = cal_d.y;\n        if (d < EPSILON) {\n            dist = depth;\n            if(index == 3.0){\n                o = dist * r;\n                r=reflect(r,normalize(mirror_n.xyz));\n            }else{\n                vec3 p = eye + dist * rayDir;\n                vec3 N = getNormal(p);\n                color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);   \n            }\n                \n        }\n        depth += d;\n        \n    }\n      \n     fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}