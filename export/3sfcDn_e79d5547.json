{"ver":"0.1","info":{"id":"3sfcDn","date":"1584506202","viewed":449,"name":"just a reflection","username":"scry","description":"spin off of https://www.shadertoy.com/view/wdXcz7\nWatch until 120 seconds at least! :) Beyond that it will just reverse loop, line 10 determines when it loops\nTrippy!","likes":3,"published":3,"flags":1,"usePreview":0,"tags":["reflexion","sphere","fog","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Gallardo - xjorma/2020\n// Modified by scry\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n#define loop 120.\n#define mTime abs(mod(iTime+loop,loop*2.)-loop)\n#define iTime mTime*mTime*0.005\nconst float period = 21.;\nconst float scale = 0.;\n\nfloat alt(vec3 p)\n{\n    return (sin(p.x / period) + sin(p.z / period)) * scale;\n}\n\n\nfloat rand(vec3 n)\n{ \n    return fract(sin(dot(n, vec3(12.9898, 4.1414,14.6313))) * 43758.5453);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p)\n{\n    //float ud = 12.45;\n    float ud = 3.8;\n    ud += sin(iTime*2.9)*0.006;\n    ud *= sin(((iTime+19.5)*0.01)-0.1);\n    vec3 v = vec3(ud,ud,ud);\n    vec3 i = floor((p + v / 2.) / v );\n    vec3 o = vec3(0, alt(i), 0);\n    vec3 q = mod(p + o + v / 2., v) - v / 2.0;\n    float r = step(abs(i.y), 15.5);\n    return sdSphere(q, r * 1.1);\n}\n\n\n#define EPS  0.001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<200;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd || abs(cp.y) > 35.)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 c1 = mix(vec3(0.), vec3(0,0,1), (sign(rd.y) + 1.) / 2.); \n    vec3 c2 = mix(vec3(1), c1, abs(rd.y));\n    return c2; \n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(ro);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = 1. - dot(n, -rd);\t\t\t\t\t\t\t\t\t\\\n        /*vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);*/\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(sin((iTime+48.)*0.01)*0.9, cos((iTime)*0.06)*0.6, sin((iTime+32.)*0.008)*0.9), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.4 , ref);\t\t\t\t\t\t\t\t\\\n        color = applyFog(color, t / DIST, getSkyColor(rd));\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\nGEN_RENDER(render4,  1., lastRecur)\nGEN_RENDER(render3,  1., render4)\nGEN_RENDER(render2,  1., render3)\nGEN_RENDER(render1, 15., render2)\nGEN_RENDER(render , 50., render1)\n    \nmat3 buildLookAtMatrix( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = buildLookAtMatrix(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        //float theta\t= radians(30.);\n        //float phi\t= radians(90.);\n        float theta\t= radians(30.+iTime*0.009);\n        float phi\t= radians(90.+iTime*0.011);\n        //vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ro = iTime*0.5*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        mat3 ca = buildLookAtMatrix( ro, ta );\n\t\t\n        vec3 rd =  ca*normalize(vec3(p,2.0));\n        \n        //ro.z +=iTime*0.1;\n        //ro.x += 5.+iTime;  \n\n        \n        vec3 col = render(ro ,rd);\n\t\tvec2 uv = fragCoord.xy/iResolution.xy;\n        vec3 ran = vec3(rand(vec3(rand(uv.xyy),rand(uv.xyx+10.4),iTime)));\n        vec3 ccol = col;\n        col -= 0.75;\n        col *= 11.5;\n        col += 20.95;\n        col *= 0.21;\n        col = mod(col,0.5);\n        //col -= 0.5;\n        col *= 1.5;\n        col = mix(col,ccol,0.3);\n        //col = (ran*0.6)-(col*0.03);\n        //col = mix(col,ran,0.9);\n        //col += rand(uv.xyx+iTime)*0.4;\n        //if (abs(sin((iTime*0.02)+0.1)) > uv.x) {col.r = 1.;}\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.3);\n    \n\tfragColor = vec4( pow(tot, vec3(1.5)), 1.0 );    \n}","name":"Image","description":"","type":"image"}]}