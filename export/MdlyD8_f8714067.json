{"ver":"0.1","info":{"id":"MdlyD8","date":"1488059529","viewed":1416,"name":"Portland, OR","username":"sepehr","description":"If someone wanted to render Portland, OR in a shader. This is pretty much what it will look like.","likes":28,"published":1,"flags":32,"usePreview":1,"tags":["fluid","metaball","rain","raindrop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on:\n// 1. https://www.shadertoy.com/view/4l3Gz2\n// 2. https://www.shadertoy.com/view/ltdGDn\n\n// Rain will pour faster as time goes on\n// TODO: wind direction change based on camera\n\n// Uncomment to see the rain texture only\n// #define DRAW_RAIN_ONLY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\tvec3 noise = texture(iChannel0, uv).rgb;\n    \n    #ifndef DRAW_RAIN_ONLY\n    \n    \tvec3 rflct = reflect(noise, vec3(uv - vec2(0.5 - sin(iTime / 5.) / 5., 0.5), 0.5));\n    \tvec3 color = texture(iChannel1, rflct).rgb;\n    \n    #else\n    \n    \tfloat Y = dot(noise.rgr, vec3(0.299, 0.587, 0.114));\n    \tvec3 color = vec3(Y,Y,Y);\n    \n    #endif\n    \n    fragColor = vec4(color, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer generates a Perlin map used by all other buffers\n// Moved here so Perlin calculations do not happen every iteration\n\n// Basic Perlin 1D noise\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat perlinf(float a)\n{\n    return fract(sin(dot(vec2(a,a) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = fragCoord.x + fragCoord.y * iResolution.y;\n    fragColor.r = perlinf(3.0 * i);\n    fragColor.g = perlinf(3.0 * i + 1.0);\n    fragColor.b = perlinf(3.0 * i + 2.0);\n    // This gives us faster rain as we go\n    fragColor.a = tan(iTime * 1e-3);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer generates middle sized drops\n\nfloat density = 4.5;\nfloat metasze = 0.01;\nvec4  noffset = vec4( 10.0, 1500.0, -90.0, 0.9 );\n\n#define clamp01(a) clamp(a, 0., 1.)\n#define sstep01(a) smoothstep(0., 1., a)\n\nvec4 getPerlinMap(int index)\n{\n    float x = float(mod(float(index), iResolution.y)) / iResolution.x;\n    float y = float(mod(float(index), iResolution.y)) / iResolution.y;\n    return texture(iChannel1, vec2(x,y));\n}\n\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n   \treturn mat2(+c, -s, +s, +c) * (uv - center) + center;\n}\n\nfloat metaBall(vec2 uv)\n{\n\treturn length(fract(uv) - vec2(0.5));\n}\n\nfloat metaNoise(vec2 uv)\n{\n\tfloat metaball = metasze;\n    \n    for(int i = 0; i < 20; i++)\n    {\n        vec4 n = getPerlinMap(i) * noffset;\n    \tvec2 c = vec2(n.y, n.z) + n.a;\n    \tvec2 uvr = rotuv(uv*n.x, n.x + n.a, c);\n    \t\n        metaball *= clamp01(metaBall(uvr) * density);\n    }\n    \n    return sstep01(metaball);\n}\n\nvec3 calculateNormals(vec2 uv)\n{\n    float offsetX = 1./iResolution.x;\n    float offsetY = 1./iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (metaNoise(uv - ovX.yx) - metaNoise(uv + ovX.yx));\n    float Y = (metaNoise(uv - ovY.xy) - metaNoise(uv + ovY.xy));\n    float Z = sqrt(1.0 - clamp01(dot(vec2(X,Y), vec2(X,Y))));\n    \n\treturn normalize(vec3(X,Y,Z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 nl = calculateNormals(uv) + texture(iChannel0,uv).rgb * 0.9;\n\tfragColor = vec4(nl, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This buffer generates larger sized drops\n\nfloat density = 4.5;\nfloat metasze = 1e2;\nvec4  noffset = vec4( 10.0, 2500.0, -90.0, 0.7 );\n\n#define clamp01(a) clamp(a, 0., 1.)\n#define sstep01(a) smoothstep(0., 1., a)\n\nvec4 getPerlinMap(int index)\n{\n    float x = float(mod(float(index), iResolution.y)) / iResolution.x;\n    float y = float(mod(float(index), iResolution.y)) / iResolution.y;\n    return texture(iChannel1, vec2(x,y));\n}\n\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n   \treturn mat2(+c, -s, +s, +c) * (uv - center) + center;\n}\n\nfloat metaBall(vec2 uv)\n{\n\treturn length(fract(uv) - vec2(0.5));\n}\n\nfloat metaNoise(vec2 uv)\n{\n\tfloat metaball = metasze;\n    \n    for(int i = 0; i < 20; i++)\n    {\n        vec4 n = getPerlinMap(i) * noffset;\n    \tvec2 c = vec2(n.y, n.z) - n.a;\n    \tvec2 uvr = rotuv(uv*n.x, n.x + n.a, c);\n    \t\n        metaball *= clamp01(metaBall(uvr) * density);\n    }\n    \n    return sstep01(metaball);\n}\n\nvec3 calculateNormals(vec2 uv)\n{\n    float offsetX = 1./iResolution.x;\n    float offsetY = 1./iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (metaNoise(uv - ovX.yx) - metaNoise(uv + ovX.yx));\n    float Y = (metaNoise(uv - ovY.xy) - metaNoise(uv + ovY.xy));\n    float Z = sqrt(1.0 - clamp01(dot(vec2(X,Y), vec2(X,Y))));\n    \n\treturn normalize(vec3(X,Y,Z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 nl = calculateNormals(uv) + texture(iChannel0,uv).rgb * 0.9;\n\tfragColor = vec4(nl, 1.0);\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// This buffer generates high frequency small drops\n\nfloat density = 4.5;\nfloat metasze = 1e3;\nvec4  noffset = vec4( -100.0, 6500.0, -90.0, 0.7 );\n\n#define clamp01(a) clamp(a, 0., 1.)\n#define sstep01(a) smoothstep(0., 1., a)\n\nvec4 getPerlinMap(int index)\n{\n    float x = float(mod(float(index), iResolution.y)) / iResolution.x;\n    float y = float(mod(float(index), iResolution.y)) / iResolution.y;\n    return texture(iChannel1, vec2(x,y));\n}\n\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n   \treturn mat2(+c, -s, +s, +c) * (uv - center) + center;\n}\n\nfloat metaBall(vec2 uv)\n{\n\treturn length(fract(uv) - vec2(0.5));\n}\n\nfloat metaNoise(vec2 uv)\n{\n\tfloat metaball = metasze;\n    \n    for(int i = 0; i < 20; i++)\n    {\n        vec4 n = getPerlinMap(i) * noffset;\n    \tvec2 c = vec2(n.y, n.z) + n.a;\n    \tvec2 uvr = rotuv(uv*n.x, n.x + n.a, c);\n    \t\n        metaball *= clamp01(metaBall(uvr) * density);\n    }\n    \n    return sstep01(metaball);\n}\n\nvec3 calculateNormals(vec2 uv)\n{\n    float offsetX = 1./iResolution.x;\n    float offsetY = 1./iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (metaNoise(uv - ovX.yx) - metaNoise(uv + ovX.yx));\n    float Y = (metaNoise(uv - ovY.xy) - metaNoise(uv + ovY.xy));\n    float Z = sqrt(1.0 - clamp01(dot(vec2(X,Y), vec2(X,Y))));\n    \n\treturn normalize(vec3(X,Y,Z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 nl = calculateNormals(uv) + texture(iChannel0,uv).rgb * 0.9;\n\tfragColor = vec4(nl, 1.0);\n}\n","name":"Buf D","description":"","type":"buffer"}]}