{"ver":"0.1","info":{"id":"mllcz8","date":"1690424813","viewed":32,"name":"eyepaper","username":"vvinrg","description":"remaking my animated wallpaper with a shader. curveLevel is very fun to play with","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["eyes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// config constants\nconst float height = 0.6;      // controls the vertical distortion of the eyes. 1.0 - 1.5\nconst float gridScale = 5.0;   // controls the overall zoom on the eyes.        0.0 - Inf\nconst float maxDist = 3.9;     // caps the furthest eyes to get rendered.       0.0 - Inf\n\nconst float stroke = 0.05;     // controls the thickness on the lines.          0.0 - Inf\n\nconst float curveLevel = 1.25; // controls the eyelid shape.                    0.0 - Inf\n\nconst float animSpeed = 5.0;   // seconds between each eye's blink.             0.0 - Inf\nconst float animPeriod = 1.5;  // distance between open and closed eyes.\n\nconst bool useRealDistForCutoff = false;\nconst bool useRealDistForAnim = true;\n\nconst bool debug = false;\n\n// internal constants\nconst float PI = 3.1415926535;\n// computed\nconst float heightInv = 1.0 / height;\nconst float vStroke = stroke / height;\n\n// utils\nfloat rad( in vec2 pos ) { return abs(pos.x) + abs(pos.y); } // right-angle distance\n\nvec4 tiling( in vec2 uv )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uvc = vec2(\n        uv.x - aspect/2.0,\n        (uv.y - 0.5) * heightInv\n    ) * gridScale;\n    vec2 uvc2 = vec2(\n        uv.x - aspect/2.0,\n        uv.y - 0.5\n    ) * gridScale;\n    \n    vec2 tiling1 = mod(uvc, 1.0) * 2.0 - vec2(1.0, 1.0);\n    vec2 tiling2 = mod(uvc + vec2(0.5, 0.5), 1.0) * 2.0 - vec2(1.0, 1.0);\n    \n    vec2 tiling = rad(tiling1) < rad(tiling2) ? tiling1 : tiling2;\n    float realDist = length(uvc2 - tiling * 0.5);\n    float squishDist = length(uvc - tiling * 0.5);\n    \n    return vec4(realDist, squishDist, tiling);\n}\nvec3 eye( in vec2 uv )\n{\n    vec4 tiler = tiling(uv);\n    float animDist = useRealDistForAnim ? tiler.x : tiler.y;\n    float cutoffDist = useRealDistForCutoff ? tiler.x : tiler.y;\n    vec2 uvc = tiler.zw;\n    \n    if (cutoffDist > maxDist) return vec3(0.0,0.0,0.0);\n    \n    float t = sin((iTime / animSpeed * 2.0 - animDist / animPeriod) * PI) * 0.5 + 0.5;\n    \n    float eyelidHeight = (cos(abs(uvc.x) * PI * curveLevel) + 1.0) * 0.3 * t;\n    bool eyelid = abs(abs(uvc.y) - eyelidHeight) < vStroke && rad(uvc * vec2(1.0, height)) < 0.9;\n    \n    bool pupil = abs(uvc.x) < stroke && abs(uvc.y) < min(0.5, eyelidHeight);\n    \n    float col = pupil || eyelid ? t : 0.0;\n    \n    return debug ? vec3(pupil ? t : 0.0, eyelid ? t : 0.0, 0.0) : vec3(col,col,col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 final = vec3(0.0, 0.0, 0.0);\n    for (float x = -1.0; x < 2.0; x++)\n        for (float y = -1.0; y < 2.0; y++)\n            final += eye((fragCoord + vec2(x / 3.0, y / 3.0))/iResolution.y);\n    \n    final /= 9.0;\n    fragColor = vec4(final, 1.0);\n}","name":"Image","description":"","type":"image"}]}