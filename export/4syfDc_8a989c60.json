{"ver":"0.1","info":{"id":"4syfDc","date":"1530746382","viewed":158,"name":"RK Raymarch 1","username":"rkibria","description":"Got around to trying raymarching finally!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThanks to\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://iquilezles.org/articles/distfunctions\n\n*/\n\n#define MAX_MARCHING_STEPS 50\n#define EPSILON 0.05\n#define MAX_DIST 100.0\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdf( vec3 p )\n{\n\tfloat d = udBox( p, vec3(4, 0.15, 4) ) ;\n    for( int j = 0; j < 5; j++ )\n    {\n        for( int i = 0; i < 5; i++ )\n        {\n            vec3 sp = vec3(\n                -3.5 + float(i) * 1.75 + sin(2. * iTime),\n                0.5 * -(sin(2. * iTime + float(i) + float(j) )),\n                -3.5 + float(j) * 1.75 + 0.25 * sin(2. * iTime)\n            );\n            float sv = sdSphere( p + sp, 0.75 + 0.125 * sin(iTime));\n            if((i+j) % 2 == 0)\n\t            d = opU( d, sv );\n            else\n\t            d = opS( sv, d );\n        }\n    }\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(in vec3 pos, in vec3 n)\n{\n    vec3 c = (n + 1.) / 2.;\n    vec3 a = vec3( 0.05 + max(0., dot(n, vec3(1., 0.5, 0.5)) ) );\n    a = a / ( 5. + pos.z );\n    return mix(a, c, 0.1);\n}\n\nvec3 march(in vec3 eye, in vec3 ray)\n{\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * ray;\n        float dist = sdf( pos );\n        if( dist < EPSILON ) {\n            return lighting( pos, estimateNormal( pos ) );\n        }\n\n        depth += dist;\n\n        if ( depth >= MAX_DIST ) {\n            return vec3( 0. );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    vec3 col = vec3( 0 );\n    \n    vec3 eye = vec3(0., 1.0, -10.);\n    vec3 ray = normalize( vec3( uv, 1. ) );\n\n    col = march( eye, ray );\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}