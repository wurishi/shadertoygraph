{"ver":"0.1","info":{"id":"dldyWl","date":"1699838967","viewed":60,"name":"Rotating Cube!","username":"userman","description":"A cube, rotating!\nRendered with a pinhole camera ray trace.\nShaded with surface normals, and directional lighting.\nI have never used triangle meshes so I used this to learn.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","rotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray {\n    vec3 o;\n    vec3 d;\n};\n\n\nvec3[8] verts = vec3[8](     // described as it would be seen looking at the face the vertex belongs to\n    vec3(-0.5, -0.5, -0.5),  // 0 - front bottom left\n    vec3(-0.5, 0.5, -0.5),   // 1 - front top left\n    vec3(0.5, 0.5, -0.5),    // 2 - front top right\n    vec3(0.5, -0.5, -0.5),   // 3 - front bottom right\n    vec3(0.5, -0.5, 0.5),    // 4 - back bottom left\n    vec3(0.5, 0.5, 0.5),     // 5 - back top left\n    vec3(-0.5, 0.5, 0.5),    // 6 - back top right\n    vec3(-0.5, -0.5, 0.5)    // 7 - back bottom right\n);\n\n\nint[36] ind = int[36](\n    // front face\n    0, 1, 2, 2, 3, 0,\n    // back face\n    4, 5, 6, 6, 7, 4,\n    // top face\n    1, 6, 5, 5, 2, 1,\n    // bottom face\n    7, 0, 3, 3, 4, 7,\n    // right face\n    3, 2, 5, 5, 4, 3,\n    // left face\n    7, 6, 1, 1, 0, 7\n    \n);\n\n\nvec4 noInt = vec4(0.0,0.0,0.0,-1.0);\nvec4 checkTriIntersect(vec3 V1, vec3 V2, vec3 V3, ray r)\n{\n    vec3 e1 = V2 - V1;\n    vec3 e2 = V3 - V1;\n\n    vec3 P = cross(e2, r.d);  // Reversed cross product\n    float det = dot(e1, P);\n\n    // Ray is parallel to the triangle plane, no intersection\n    if (abs(det) < 0.001) {\n        return noInt;\n    }\n\n    float invDet = 1.0 / det;\n    vec3 T = r.o - V1;\n    float u = dot(T, P) * invDet;\n\n    // Check if the intersection lies outside of the triangle\n    if (u < 0.0 || u > 1.0) {\n        return noInt;\n    }\n\n    vec3 Q = cross(e1, T);  // Reversed cross product\n    float v = dot(r.d, Q) * invDet;\n\n    // Check if the intersection lies outside of the triangle\n    if (v < 0.0 || u + v > 1.0) {\n        return noInt;\n    }\n\n    float x = dot(e2, Q) * invDet;\n\n    // Intersection is behind the ray's origin\n    if (x <= 0.0) {\n        return noInt;\n    }\n\n    // Intersection point\n    // return vec4(r.o + x * r.d, x);\n    vec3 n = normalize(cross(e1, e2));\n    return vec4(n, x);\n}\n\nconst vec3 origin = vec3(0.0, 0.0, 0.0);\nconst float dof = 3.0; // depth of field\n\nray makeRay(vec2 fragCoord) {\n    vec2 halfIRes = iResolution.xy * 0.5;\n    vec2 uv = (fragCoord - halfIRes) / halfIRes;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 dir = vec3(uv.x, uv.y, dof);\n    dir = normalize(dir);\n\n    return ray(origin, dir);\n}\n\n\nvoid transformCube(mat4 matrix) {\n    for (int i=0; i<8; i++) {\n        verts[i] = (matrix * vec4(verts[i], 1.0)).xyz;\n    }\n}\n\nmat4 rotMatY(float y) {\n    return mat4(cos(y), 0.0, sin(y), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -sin(y), 0.0, cos(y), 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotMatX(float x) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(x), -sin(x), 0.0,\n                0.0, sin(x), cos(x), 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotMatZ(float z) {\n    return mat4(cos(z), -sin(z), 0.0, 0.0,\n                sin(z), cos(z), 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scalarMat(float scalar) {\n    return mat4(scalar, 0.0, 0.0, 0.0,\n                0.0, scalar, 0.0, 0.0,\n                0.0, 0.0, scalar, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 moveByMat(vec3 translation) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                translation.x, translation.y, translation.z, 1.0);\n}\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.8, 0.8, 0.8);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(.2);\n    vec3 d = vec3(0.,0.3,0.5);\n\n    return min(a + b*cos(6.28318*(c*t+d)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    ray r = makeRay(fragCoord);\n    \n    mat4 rotx = rotMatX(0.6);\n    mat4 roty = rotMatY(0.0);\n    mat4 rotz = rotMatZ(0.0);\n    mat4 scale = scalarMat(2.0);\n    mat4 move = moveByMat(vec3(0.0, 0.0, 6.0));\n    mat4 transforms = move * scale;\n\n    transformCube(transforms);\n    //transformCub(move);\n    \n    \n    float maxDis = 10000.0;\n    vec4 closest;\n    bool madeHit = false;\n    \n    for (int i = 0; i <= 36; i+=3) {\n        vec3 v1 = verts[ind[i-1]];\n        vec3 v2 = verts[ind[i-2]];\n        vec3 v3 = verts[ind[i-3]];\n        \n        vec4 res = checkTriIntersect(v1, v2, v3, r);\n        \n        if (0.0 < res.w && res.w < maxDis) {\n            maxDis = res.w;\n            closest = res;\n            madeHit = true;\n        }\n    }\n    \n    if (madeHit) {\n         \n        float dotted = dot(r.d, closest.xyz);\n        float shadeScalar = min((max(dotted, 0.0)), 1.0);\n        fragColor = vec4(\n        palette(iTime), 1.0) * shadeScalar;\n        return;\n    }\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}