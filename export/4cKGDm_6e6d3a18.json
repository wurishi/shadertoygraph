{"ver":"0.1","info":{"id":"4cKGDm","date":"1712866641","viewed":91,"name":"Experiment with heightmap SDF 2","username":"jaszunio15","description":"Here I'm trying some idea to convert heightmap SDF to be more correct in positive values.\nIt is using some heuristic to march around and search for closest surface position.\n\nDo you have any other idea how to fix SDF for heightmap?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["heightmapsdftest"],"hasliked":0,"parentid":"XfKGWD","parentname":"Experiment with heightmap SDF"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\n/*\nHere I'm trying some idea to convert heightmap SDF to be more correct in positive values.\nIt is using some heuristic to march around and search for closest surface position.\n\nYellow circle is a fixed sdf value. Red is an original value.\n\nThis idea should be quite performant also in 3D. Maybe not in raymarching, but for physics.\n*/\n\n// Original heightmap value\nfloat Heightmap(float x)\n{\n    return (pow(textureLod(iChannel0, vec2((x) * 0.04, iTime * 0.001), 0.0).x, 1.0) - 0.5) * -8.0 - 1.0;\n}\n\nbool fixHeightmap = false;\n\n// SDF to original heightmap, just outputting height difference.\nfloat SDFRawFunction(vec2 coord)\n{\n    float heightmapSDF = coord.y - Heightmap(coord.x);\n    \n    float sdf = heightmapSDF;\n    \n    return sdf;\n}\n\n// Calculates normal vector of SDF field (basically heightmap normal in this case)\nvec2 SDFRawFunctionNormalizedGradient(vec2 position)\n{\n    float epsilon = 0.3; // Epsillon here matters a lot for the final SDF\n    float dYmin = SDFRawFunction(position + vec2(0.0, -epsilon));\n    float dYmax = SDFRawFunction(position + vec2(0.0, epsilon));\n    float dXmin = SDFRawFunction(position + vec2(-epsilon, 0.0));\n    float dXmax = SDFRawFunction(position + vec2(epsilon, 0.0));\n    \n    return normalize(vec2(dXmax - dXmin, dYmax - dYmin));\n}\n\n// Heuristic that searches local area for the nearest point. Basically follows the terrain antinormal and also checks \n// for perpendicular samples.\nvec2 ClosestSDFTerrainSurfaceSearch(vec2 position)\n{\n    float absSDFValue = 999999.0;\n    vec2 searchPosition = position;\n    for (int i = 0; i < 3; i++)\n    {\n        vec2 sdfNormal = SDFRawFunctionNormalizedGradient(searchPosition);\n        vec2 sdfTangent = sdfNormal.yx * vec2(-1, 1);\n\n        float localSearchDistance = (SDFRawFunction(searchPosition)) * abs(sdfNormal.y) * 0.6;\n        \n        float tangentMultiplier = 1.0;\n        float normalMultiplier = 1.0;\n\n        vec2 rightPosition = searchPosition + sdfTangent * localSearchDistance * tangentMultiplier;\n        vec2 leftPosition = searchPosition - sdfTangent * localSearchDistance * tangentMultiplier;\n        vec2 upPosition = searchPosition + sdfNormal * localSearchDistance * normalMultiplier; \n        vec2 downPosition = searchPosition - sdfNormal * localSearchDistance * normalMultiplier; \n        \n        float rightSDF = abs(SDFRawFunction(rightPosition));\n        float leftSDF = abs(SDFRawFunction(leftPosition));\n        float upSDF = abs(SDFRawFunction(upPosition));\n        float downSDF = abs(SDFRawFunction(downPosition));\n\n        if (rightSDF < absSDFValue)\n        {\n            absSDFValue = rightSDF;\n            searchPosition = rightPosition;\n        }\n        \n        if (leftSDF < absSDFValue)\n        {\n            absSDFValue = leftSDF;\n            searchPosition = leftPosition;\n        }\n        \n        if (upSDF < absSDFValue)\n        {\n            absSDFValue = upSDF;\n            searchPosition = upPosition;\n        }\n        \n        if (downSDF < absSDFValue)\n        {\n            absSDFValue = downSDF;\n            searchPosition = downPosition;\n        }\n    }\n    \n    return searchPosition - vec2(0.0, SDFRawFunction(searchPosition)); //snap last position to terrain.\n}\n\nfloat SDFFunction(vec2 coord)\n{\n    float sdf = SDFRawFunction(coord);\n    \n    // Apply fix for heightmap sdf\n    if (fixHeightmap)\n    {\n        float sdfSign = sign(sdf); // Cache SDF sign\n        vec2 closestSurfacePoint = ClosestSDFTerrainSurfaceSearch(coord); // heuristic that search for closest surface point;\n        \n        if (sdfSign < 0.0)\n            sdf = 9999999999.0;\n        sdf = min(sdf, distance(coord, closestSurfacePoint) * sdfSign); // output signed distance to found point;\n    }\n    \n    return sdf;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat DrawSegment(vec2 uv, vec2 a, vec2 b, float size)\n{\n    float pixelSize = fwidth(uv.x);\n    return smoothstep(size * pixelSize + pixelSize * 0.5, size * pixelSize - pixelSize * 0.5, sdSegment(uv, a, b));\n}\n\nvec2 PixelCoordToUv(vec2 coord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = coord/iResolution.y - 0.5;\n    uv.x += iTime * 0.1;\n    uv *= 10.0;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = PixelCoordToUv(fragCoord);\n    vec2 mouse = iMouse.xy;\n    vec2 mouseUV = PixelCoordToUv(mouse);\n   \n    // default mouse position\n    if (abs(iMouse.x) < 1.0)\n    {\n        mouse.xy = vec2(0.5, 0.6) * iResolution.xy;\n        mouseUV = PixelCoordToUv(mouse);\n        float rawSDF = SDFRawFunction(mouseUV);\n        mouseUV.y -= rawSDF - 0.6 + sin(iTime) * 0.5;\n    }\n    \n    if (fragCoord.x < abs(mouse.x))\n        fixHeightmap = true;\n\n    float sdf = SDFFunction(uv);\n        fixHeightmap = true;\n    \n    //vec2 normal = SDFRawFunctionNormalizedGradient(mouseUV);\n   // float segment = DrawSegment(uv, mouseUV, mouseUV + normal * mouseSDF, 2.0);\n    \n    float sdfVisuals = -cos(sdf * 40.0) * 0.5 + 0.5;\n    float sdfSign = sign(sdf) * 0.5 + 0.5;\n    vec3 color = mix(vec3(0.7, 0.8, 0.9) * 0.8, vec3(0.4, 1.0, 0.4) * 0.8, sdfSign) * sdfVisuals;\n    color *= (1.0 - 1.0 / exp(abs(sdf) * 2.0)) + 0.1;\n    color *= 0.9;\n    \n    float pixelSize = fwidth(sdf);\n    color += smoothstep(min(pixelSize, 0.1) * 2.0, 0.0, abs(sdf)) * vec3(1.0, 0.8, 0.4);\n    \n    float mouseSDF = SDFFunction(mouseUV);\n    float mouseRawSDF = SDFRawFunction(mouseUV);\n    pixelSize = fwidth(uv.x);\n    float circle = smoothstep(min(pixelSize, 0.1) * 2.0, min(pixelSize, 0.1) * 0.5, abs(distance(uv, mouseUV) - mouseSDF));\n    float circleRaw = smoothstep(min(pixelSize, 0.1) * 2.0, min(pixelSize, 0.1) * 0.5, abs(distance(uv, mouseUV) - mouseRawSDF));\n    \n    float verticalLine = smoothstep(2.0, 1.0, abs(fragCoord.x - abs(mouse.x)));\n    color = mix(color, vec3(1.0, 1.0, 1.0), verticalLine);// * vec3(1.0, 1.0, 1.0);\n    color = mix(color, vec3(1.0, 1.4, 0.4), circle);\n    color = mix(color, vec3(1.0, 0.3, 0.4), circleRaw * 0.75);\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(2.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}