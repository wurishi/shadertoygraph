{"ver":"0.1","info":{"id":"X3XfDs","date":"1729049818","viewed":44,"name":"rgb trig kaleidoscope ","username":"akr51","description":"kaleidoscopic effect using fracturing and polar coordinates, working on RGB channels ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","polarcoordinates"],"hasliked":0,"parentid":"M3XfWf","parentname":"kaleidoscopic eye-orb"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n\nvec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, vec3 t) {\n\n    return a + b * cos(PI * 2.0 * (c + d * t));\n\n}\n\nmat2 rt(float t)\n{\n\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n}\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 _d = iResolution.xy;\n    vec2 uv = (u + u - _d) / _d.y;\n    float g = length(uv);\n    uv *= rt(iTime * 0.36);\n    uv.y = abs(uv.y);\n    vec2 uvc = vec2(length(uv), atan(uv.y + sin(uv.x), uv.x));\n    \n    \n    uvc *= vec2(cos(iTime * 0.25), sin(iTime));\n    uvc.y = abs(uv.y);\n    uvc *= 0.7;\n    \n    vec3 a = vec3(0.4, 0.55, 0.25);\n    vec3 b = vec3(0.7, 0.3, 1.0);\n    vec3 c = vec3(0.1, 0.3, 0.24);\n    vec3 d = vec3(0.7, 0.2, 1.3);\n    \n    float w = tan(uvc.x * 4.0 + uvc.y * 3.0);\n    w = exp(cos(w + iTime) * 0.1);\n    vec3 clr = vec3(0.0);\n    \n    for (float i = 0.0; i < 5.0; i++) {\n        \n        uvc = vec2(length(uvc), atan(uvc.y, uvc.x));\n        uv = fract(uv * (1.2 / g) + iTime * 0.01) - 0.5;\n        \n        float fr = sin(uv.x * w + iTime * 0.01+ i * 2.5);\n        float fg = cos(uvc.y * w + iTime * 0.01 + i * 3.0);\n        float fb = tan(uvc.x * w + uv.y + iTime * 0.01 + i * 7.0);\n        \n\n        vec2 ofsr = vec2(cos(iTime + i), sin(iTime + i)) * 0.25 + vec2(fr);\n        vec2 ofsg = vec2(cos(iTime + PI + 3.0 * i), sin(iTime + PI)) * 0.25 + vec2(fg);\n        vec2 ofsb = vec2(cos(iTime + PI * 1.5 + 1.5 * i), sin(iTime + PI * 1.5)) * 0.25 + vec2(fb);\n\n        float r = smoothstep(0.0, length(uv + ofsr), 0.2);\n        float g = smoothstep(0.0, length(uv + ofsg), 0.1);\n        float b = smoothstep(0.0, length(uvc + ofsb), 0.14);\n        \n        clr += vec3(r, g, b) * w;\n    \n    \n    }\n    \n\n    clr *= pal(a, b, c, d, vec3(clr.r + iTime * 0.25));\n    clr = pow(clr, vec3(2.0));\n    c_out = vec4(clr, 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}