{"ver":"0.1","info":{"id":"Nty3D3","date":"1638403112","viewed":129,"name":"Stateful Particle System","username":"jgardner8","description":"A particle system with basic physics, and mouse interaction. Try holding the left mouse button down!\n\nBased on https://www.shadertoy.com/view/lsy3R1","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["particles","physics","stateful"],"hasliked":0,"parentid":"lsy3R1","parentname":"Stateful particle system"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Square root of the number of particles (i.e. NUM_PARTICLES_SQRT of 30 = 900 particles)\n#define NUM_PARTICLES_SQRT 30\n\n// Opacity of the particles. Because of the way rendering glow works this also affects the size\n#define OPACITY 0.7\n\n// Distance from particle to stop rendering glow. An optimisation.\n#define GLOW_CUTOFF 20.0\n\n// Amount particles glow, very sensitive\n#define GLOW 0.000015\n\n// How much velocity affects the coloring, very sensitive\n#define VELOCITY_COLORING 0.0000012\n\nvec3 particleColor(in vec4 particle) {\n    float val = lengthSquared(particle.zw) * VELOCITY_COLORING;\n    return vec3(-0.25 + val, 0.1, 0.25-val) * OPACITY;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec3 colorAcc = vec3(0.0);\n    for (int x = 0; x < NUM_PARTICLES_SQRT; x++) {\n        for (int y = 0; y < NUM_PARTICLES_SQRT; y++) {\n            vec4 particle = texelFetch(iChannel0, ivec2(x,y), 0);\n            float particleDistanceFromPixel = distanceSquared(particle.xy, uv);\n            \n            if (particleDistanceFromPixel < pixelSize.x * GLOW_CUTOFF) {\n                colorAcc += particleColor(particle) * (1.0/particleDistanceFromPixel * GLOW);\n            } \n        }\n    }\n    \n\tfragColor = vec4(colorAcc, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BOUNCE -0.5\n#define MAX_SPEED 800.0\n#define GRAVITY vec2(0.0, -5.0)\n#define ATTRACTION 60.0\n#define SIMULATION_SPEED 0.001\n\n// Stores particle position in xy, velocity in zw\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    // Init\n    if (iFrame == 1) {\n\t\tfragColor = vec4(nrand(uv.xy), nrand(uv.yx), 0.0 , 0.0);\n        return;\n    }\n\n    vec2 pos = texture(iChannel0, uv).xy;\n    vec2 vel = texture(iChannel0, uv).zw;\n \n    // Gravity\n    vel += GRAVITY;\n    \n    // Mouse attraction\n    if (mouseButtonDown(iMouse)) {\n    \tvec2 attractionVector = (iMouse.xy/iResolution.xy) - pos;\n    \tvel += normalize(attractionVector) * ATTRACTION;\n    }\n    \n    // Collisions with screen edges\n    // random number helps break apart clusters\n    float rand = nrand(uv.xy * iTime);\n    if ((pos.x < 0.0 && vel.x < 0.0) || (pos.x > 1.0 && vel.x > 0.0)) {\t\n        pos.x = clamp(pos.x, 0.0, 1.0);\n        vel.x = vel.x * BOUNCE * rand;\n    }\n\n    if ((pos.y < 0.0 && vel.y < 0.0) || (pos.y > 1.0 && vel.y > 0.0)) {\n        pos.y = clamp(pos.y, 0.0, 1.0);\n        vel.y = vel.y * BOUNCE * rand;\n    }\n    \n    // Max velocity\n    if (length(vel) > MAX_SPEED) {\n        vel = normalize(vel) * MAX_SPEED;\n    }\n    \n    // Integrate velocity into position\n    pos.xy += vel * iTimeDelta * SIMULATION_SPEED;\n    \n    fragColor = vec4(pos.xy, vel.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Random function from https://www.shadertoy.com/view/4ssXRX\n// note: uniformly distributed, normalized rand\nfloat nrand(vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// More efficient than length because it avoids sqrt\nfloat lengthSquared(in vec2 a) {\n    return a.x * a.x + a.y * a.y;\n}\n\n// More efficient than distance because it avoids sqrt\nfloat distanceSquared(in vec2 a, in vec2 b) {\n    return lengthSquared(a - b);\n}\n\n// Docs: https://www.shadertoy.com/view/Mss3zH\nbool mouseButtonDown(in vec4 mouse) {\n    return mouse.z > 0.0;\n}","name":"Common","description":"","type":"common"}]}