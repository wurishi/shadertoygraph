{"ver":"0.1","info":{"id":"4syXWG","date":"1466172175","viewed":155,"name":"golden pie","username":"dello32","description":"a simple test of how get normal from sinus function and use true reflection raytrace.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["goldraytracesinusnormal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYCASTSTEPS 0.1\n#define MAXDISTANCE 20.0\n\n#define MAXDREFL 10.0\n#define STEPREFL 0.2\n\n#define SPEED 1.0\n#define FOCAL 1.5\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43.5453);\n}\n\nvec4 map2(vec3 p, vec3 ro, vec3 lPos ){\n    // light map\n    if(distance(p,lPos)<0.1){\n    \treturn vec4(1.,1.,1.,1.);\n    }\n    \n    // wall map\n    float dens = sin(p.x)+sin(p.y)+sin(p.z);\n    if( dens>= 0.9 ){\n    \tvec3 n = normalize( vec3(-cos(p.x),-cos(p.y),-cos(p.z) ));\n        vec3 lDir = normalize(lPos-p);\n        float d = max(dot(lDir,n),0.0)*( (10.0-min(distance(lPos,p),10.0))/10.0);\n        vec3 camDir = normalize(ro-p);\n        vec3 r = cross(camDir, cross(n,camDir));\n        float s = pow(max(dot(lDir, r),0.0),1.0);\n        return vec4(vec3(d*1.,d*1.,d*.6) + vec3(s,s*s,s*s*s),1.);\n        \n    }\n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec4 trace2(vec3 ro, vec3 rd){\n    float time = iTime*SPEED;\n    vec3 p;\n    vec4 col;\n\tfor( float i=1.0; i<MAXDREFL; i+=STEPREFL )\t{\n\t\tp = ro + rd*float(i) + rd;\n        vec3 lPos =ro + vec3(sin(time*2.),0.0,2.0+cos(time*2.));\n        col = map2(p, ro, lPos);\n        if( col.w>=0.5) break;\n    }\n    return col;\n}\n\nvec4 map(vec3 p, vec3 ro, vec3 lPos ){\n    // light map\n    if(distance(p,lPos)<0.1){\n    \treturn vec4(1.,1.,1.,1.);\n    }\n    \n    // Erratic world\n    p += vec3(cos(p.x*7.475),sin(p.y*10.457),cos(p.z*8.14))*0.1;\n    \n    // wall map\n    float dens = sin(p.x)+sin(p.y)+sin(p.z);\n    if( dens>= 0.9 ){\n    \tvec3 n = normalize( vec3(-cos(p.x),-cos(p.y),-cos(p.z) ));\n        vec3 lDir = normalize(lPos-p);\n        float d = max(dot(lDir,n),0.0)*( (10.0-min(distance(lPos,p),10.0))/10.0);\n        vec3 camDir = normalize(ro-p);\n        vec3 r = cross(camDir, cross(n,camDir));\n        float s = pow(max(dot(lDir, r),0.0),1.0);\n        vec4 ref = trace2(p, n);\n        vec4 col = vec4(vec3(d*1.,d*1.,d*.6) + vec3(s,s*s,s*s*s),1.);\n        return(col+ref);\n        \n    }\n    \n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec4 trace(vec3 ro, vec3 rd){\n    float time = iTime*SPEED;\n    vec3 p;\n    vec4 col;\n\tfor( float i=1.0; i<MAXDISTANCE; i+=RAYCASTSTEPS )\t{\n        float spread = hash(rd.x+rd.y);\n\t\tp = ro + rd*float(i-1.0)+rd*spread;\n        vec3 lPos =ro + vec3(sin(time*2.),0.0,2.0+cos(time*2.));\n        col = map(p, ro, lPos);\n        if( col.w>=0.5) break;\n    }\n\n    float z =  1.-(20.0-min(distance(p,ro),20.0))/20.0;\n    vec4 fog = vec4(vec3(0.2,0.15,0.1)*z,1.0);\n    return mix(col,fog,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime*SPEED;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n    vec3 ro =  vec3(sin(time)-1.5,-2.0,time );\n\tvec3 ta =  ro + vec3(cos(time*0.2),0.0,2.0 );\n\tfloat roll = -0.15*sin(0.5*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 rd = normalize( p.x*cu + p.y*cp + cw*FOCAL );\n\t\n    fragColor = trace(ro, rd);\n}\n  ","name":"Image","description":"","type":"image"}]}