{"ver":"0.1","info":{"id":"NdSfDR","date":"1645949533","viewed":139,"name":"evangelion intro drop","username":"nexor","description":".","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float exposure = 1.8;\n    vec3 color = vec3(.1,.3,1.)*.2;\n    \n    vec4 col =\n    // additive blending\n    + texelFetch(iChannel0,ivec2(fragCoord.xy),0)\n    + texelFetch(iChannel1,ivec2(fragCoord.xy),0)\n    + texelFetch(iChannel2,ivec2(fragCoord.xy),0);\n    \n    col *= vec4(color,1);\n    \n    \n    // exposure\n    col.rgb = vec3(1) - exp(-col.rgb * exposure);\n\n    // gamma correction\n    col.rgb = pow(col.rgb,vec3(1./2.2));\n\n    // Output to screen\n    fragColor =col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 4; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // make it repeat\n    float f = float(iFrame)/60.*.4;\n    float t = mod(f,1.);\n    float w = fwidth(p.y);\n    float d = 0.;\n    \n    \n    float k = smoothstep(.0,.2,t-.2);\n    float y = mix(1.5*k,.0,smoothstep(.0,.1,t-.2));\n    float x = mix(k,k+t*.3,k)*1.;\n    \n    d = length(p)-x;\n    \n    d = abs(d)-y;\n    d = min(d,length(p)-.005);\n    d = smoothstep(w*1.35,0.,d);\n    \n    \n    float a = atan(p.y,p.x);\n    vec2 r = vec2(cos(a),sin(a));\n    // using fbm to cut out parts of the expanding ring\n    float n = fbm(r*25.+floor(f));\n    n = pow(n,2.2);\n    n = step(.2,n);\n    \n    \n    col+=d*mix(1.,n,smoothstep(.3,.35,t))*1.5;\n    t*=3.;\n    // fade over time\n    col *= exp(-t*t);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float[] kernel = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\n    vec4 col = vec4(0);\n\n    col += texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n    for(int i=0;i<5;++i)\n    {\n        // horizontal\n        col += texelFetch(iChannel0,ivec2(fragCoord.xy)+ivec2(i,0),0)*kernel[i];\n        col += texelFetch(iChannel0,ivec2(fragCoord.xy)-ivec2(i,0),0)*kernel[i];\n    }\n\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float[] kernel = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\n    vec4 col = vec4(0);\n\n    col += texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n    for(int i=0;i<5;++i)\n    {\n        // vertical\n        col += texelFetch(iChannel0,ivec2(fragCoord.xy)+ivec2(0,i),0)*kernel[i];\n        col += texelFetch(iChannel0,ivec2(fragCoord.xy)-ivec2(0,i),0)*kernel[i];\n    }\n\n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"}]}