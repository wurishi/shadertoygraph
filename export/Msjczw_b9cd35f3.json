{"ver":"0.1","info":{"id":"Msjczw","date":"1492201645","viewed":333,"name":"Rotating Kernels","username":"balkhan","description":"toying with volumetric light from sebH. ","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t100\n#define E\t\t0.001\n\n#define LPOS\tvec3(0., 0., 0.)\n#define L2\t\t1.0*vec3(st*4.,0.,ct*4.)\n\n//#define CAM_SHAKE\n\nvoid\trotate(inout vec2 v, float angle);\nfloat\tsdTorus( vec3 p, vec2 t );\nfloat\tsdCappedCylinder( vec3 p, vec2 h );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\n// --globals-- //\nvec3\th;\nfloat\tg; //coloring id\nfloat\tt; // time\nfloat\ta; // angle\nvec3\tss;// tmp var recording old ray position\nvec3\tsss;\nfloat\tmind;\nfloat\tmine;\nfloat\tminf;\nvec3\tsuper_uv;\nfloat\tst;\nfloat\tct;\n// --globals-- //\n\nconst vec3\tlightCol = vec3(1.,.7,.51);\nmat2\t\trot_t;\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(LPOS-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n        \tlightCol * 1.0/(distanceToL*distanceToL)\n           +lightCol * 1.0/(distanceToL2*distanceToL2)\n        \t)*.5;\n}\n\n// ------------volumetric light----------- //\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    mine = 1e5;\n    t = iTime*.5;\n    st = sin(t);\n    ct = cos(t);\n    rot_t = mat2(ct, st, -st, ct );\n\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h = vec3(0.);\n    \n    vec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 7.50);\n    #ifdef CAM_SHAKE\n    rotate(dir.xz, sin(t*40.)*.06125);\n    #endif\n    vec2\tinter = (march(pos, dir));\n\n    o.xyz = blackbody(((h.x+h.y+h.z) )*100.);\n    o.xyz += vec3(abs(sin(t+1.04+g)), abs(sin(t+2.09+g)), abs(sin(t+3.14+g)))*(1.-inter.y*.067515);\n    o.xyz += h*.125;\n    o.xyz *= (1.25-length(uv)*1.); // vignette\n}\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tde_0(vec3 p) // Spaghettis\n{\n\tfloat\tming = 1e5;\n\tfloat\ta = ( (t+p.z *.5)  ) * 4.;\n\tvec3\tpr = p;\n\n    pr.z *= 2.;\n\trotate(pr.xy, a);\n    ming = max(length( abs(pr.xy)-.51*(p.z+2.1)) -.5, .0051 );\n    ming = min(ming, max(length( abs(pr.xy)+.51*(p.z-2.1) ) -.5, .00051 ) );\n    ming = max(ming, sdCappedCylinder(p-vec3(0.,0.,0.), vec2(1.5, 2.4) ) );\n\treturn (ming);\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n\n\tmine = p.z+8.;\n    mine = min(mine, -(p.z)+8.);\n    mine = min(mine, (p.x)+8.);\n    mine = min(mine, -(p.x)+8.);\n    mine = min(mine, (p.y)+4.);\n    mine = min(mine, -(p.y)+4.);\n    mine = min(mine, length(p)-.1);\n\tvec3\tpole = vec3(p.x,p.z,p.y);\n    pole.xy *= mix(1., .8, abs(sin(t*8.)) );\n\tmine = min(mine, de_0(pole) );\n\n    minf = sdTorus(vec3(p.z,p.y,p.x), vec2(.58,.55) )\n        \t\t\t-sdCy(vec3(p.x,p.y,p.z), vec2(1.6,.85) \n                  );\n    mind = max(minf,-sdCy(vec3(p.z,p.y,p.x)*.65, vec2(.75,1.5) ) );\n    sss = p;\n    p-= L2;\n    vec3 tata = p;\n    rotate(tata.xy, +t*6.28+6.28 );\n    rotate(p.xy, +t*6.28 );\n    vec3 tracker;\n    tracker.x =\tmax(sdTorus(vec3(tata.z,tata.y,tata.x), vec2(.521,.521) ), -sdCy(vec3(tata.z,tata.y,tata.x), vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5)*abs(tata.x*.5)\n        \t\t\t;\n    if (tracker.x <= E)\n\t    ss = tata;\n    tata = p;\n    rotate(tata.zx, +t*6.28+4.16 );\n    rotate(p.zx, +t*6.28 );\n    tracker.y =\tmax(sdTorus(vec3(tata.x,tata.y,tata.z)*.75, vec2(.521,.521) ), -sdCy(vec3(tata.x,tata.y,tata.z)*.75, vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5*.75)*abs(tata.x*.5*.75)\n        \t\t\t;\n\tif (tracker.y <= E)\n\t    ss = tata;\n    tata = p;\n    rotate(tata.yz, +t*6.28+2.09 );\n    rotate(p.yz, +t*6.28 );\n    tracker.z =\tmax(sdTorus(vec3(tata.z,tata.x,tata.y)*.5, vec2(.521,.521) ), -sdCy(vec3(tata.z,tata.x,tata.y)*.5, vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5*.5)*abs(tata.x*.5*.5)\n        \t\t\t;\n    mind = min(mind, tracker.x);\n    mind = min(mind, tracker.y);\n    mind = min(mind, tracker.z);\n    mind = min(mind, length(p)-.1);\n    if (tracker.z <= E)\n\t    ss = p;\n    mind = min(mine, mind);\n\n    return mind;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\n    for (int i = 1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        p.xy *= rot_t;\n        p.zx *= rot_t;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.251125;\n        if (dist.x < E || dist.y > 20.)\n        {\n            if(dist.x == minf)\n\t            p=super_uv=sss;\n            if(dist.x != minf && dist.x != mine)\n                p=ss;\n\t        g +=  (step(sin(20.*abs(p.y) ), .5) \n                  + step(sin(20.*abs(p.x) ), .5)\n                  + step(sin(20.*abs(p.z) ), .5)\n                 );\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}","name":"Image","description":"","type":"image"}]}