{"ver":"0.1","info":{"id":"mtGfz1","date":"1701931252","viewed":65,"name":"Peking Opera Mask","username":"wangqiuyan","description":"Peking Opera Mask","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"Dt3BzB","parentname":"lianpu"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S smoothstep\nfloat Feature(vec2 p)\n{\n    float d=length(p-vec2(0.0,clamp(p.y,-0.3,.3)));\n    float r=mix(0.1,0.01,S(-.3,0.3,p.y));\n    d=S(.001,0.0,d-r);\n    \n    float x=.8*abs(p.x*1.05)/r;\n    x=pow(x,4.)+pow(x,3.)-3.*pow(x,2.)+2.*x;\n    x*=0.22;\n    float y=(p.y-x)*40.;\n    \n    float id=floor(y);\n  \n    float rand=fract(sin(id*653.11)*876.9);\n    float strand=S(0.0,0.1,abs(fract(y)-.5)-.1);\n    //show id\n   if(strand==0.)\n       strand+=(id+20.)/40.;\n    d*=strand;\n   \n   // strand=2.*p.x+p.y;\n    return d;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n// beizer distance copy from https://www.shadertoy.com/view/MtS3Dy\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat SDFLine(vec2 p, vec2 a, vec2 b,float width,float blur)\n{\n    vec2 ap=p-a,ab=b-a;\n    float t=clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    float d=length(p-(a+ab*t));\n  \n    return S(0.,blur,abs(d-width/2.));\n}\n\nfloat SDFLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ap=p-a,ab=b-a;\n    float t=clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    //t=dot(ap,ab)/dot(ab,ab)\n    float d=length(p-(a+ab*t));\n    \n   \n    if(det(ap,ab)<0.) return -d;\n    return d; \n}\n\n\n\n\nfloat Lagrange(float x, vec2[5] pts, int len)\n{\n    float result=0.;\n    \n    for(int i=0;i<len;i++)\n    {\n        float s=pts[i].y;\n        \n        for(int j=0;j<len;j++)\n        {\n            if(j==i)\n            {\n                for(int jj=0;jj<len;jj++)\n                {\n                    if(jj!=i)\n                    {\n                         s/=pts[i].x-pts[jj].x;\n                    }                   \n                }\n            }\n            else\n            {\n                s*=x-pts[j].x;\n            }\n        }\n        result+=s;\n    }\n    return result;\n}\nint mulj(int s)\n{\n    int re=s;\n    for(int i=1;i<=s;i++)\n        re*=i;\n    return re;\n}\n\n\n//this is always wrong i dont know why\nvec2 BezierPt(vec2[7] pts,int len,float t)\n{\n    vec2 result=vec2(0.0);\n    for(int i=0;i<=len;i++)\n    {\n        float c=1.;\n        \n        if(i>0&&i<len)\n        {\n            for(int j=len;j>len-i;j--)\n            {\n                c*=float(j);               \n            }\n           \n            c/=float(mulj(i));\n        }\n        c*=pow(t,float(i))*pow(1.-t,float(len-i));\n       \n       \n        result+=pts[i]*c;\n    }\n    //result=pts[2];\n    \n    //result=pts[0]*pow(1.-t,6.)+6.*pts[1]*pow(1.-t,5.)*t+15.*pts[2]*pow(1.-t,4.)*t*t+20.*pts[3]*pow(1.-t,3.)*pow(t,3.)+15.*pow(t,4.)*pts[4]*pow(1.-t,2.)+6.*pow(t,5.)*pts[5]*(1.-t)+pts[6]*pow(t,6.);\n    return result;\n}\n\n\nvec2 BezierPt6(vec2[7] pts,float t)\n{\n    vec2 result=vec2(0.0);\n   \n    result=pts[0]*pow(1.-t,6.)+6.*pts[1]*pow(1.-t,5.)*t+15.*pts[2]*pow(1.-t,4.)*t*t+20.*pts[3]*pow(1.-t,3.)*pow(t,3.)+15.*pow(t,4.)*pts[4]*pow(1.-t,2.)+6.*pow(t,5.)*pts[5]*(1.-t)+pts[6]*pow(t,6.);\n    return result;\n}\nvec2 BezierPt5(vec2[6] pts,float t)\n{\n    vec2 result=vec2(0.0);   \n    result= pts[0]*pow(1.-t,5.)+\n            5.*pts[1]*pow(1.-t,4.)*t+\n            10.*pts[2]*pow(1.-t,3.)*t*t+\n            10.*pts[3]*pow(1.-t,2.)*pow(t,3.)+\n            5.*pow(t,4.)*pts[4]*(1.-t)+\n            pts[5]*pow(t,5.);\n            \n    return result;\n}\n\nvec3 Feature2(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float d=0.;\n    \n    vec2 p=uv;\n    p.x=abs(p.x);\n    float t=0.;\n    float r=length(p-vec2(0.0,0.08));\n    t=S(0.4,0.42,r);\n    t*=S(0.3,0.42,length(p-vec2(0.0,-0.08)));\n    \n    d=t;\n    \n    t=length(p-vec2(0.,0.3))+length(p-vec2(0.,-0.3));\n    t=S(0.95,0.94,t);\n   // t*=p.y>0.0?0.:1.;\n    d+=t;\n    d=clamp(d,0.,1.);\n    \n    col+=vec3(1.)*d;\n    \n    float x=clamp(p.x,0.,0.5);\n    x*=2.;\n    float a=pow((x-0.3)*1.4,2.);\n    float b=1.1-pow((x-0.7)*1.4,2.);\n    float quxian=a*(1.-x)+b*x;\n    quxian=Lagrange(p.x*1.,vec2[5](vec2(0,0.133),vec2(0.04,0.04),vec2(0.108,0.214),vec2(0.214,0.316),vec2(0.245,0.413)),5);\n    d=p.y*1.-quxian;\n    d=S(0.025,0.034,abs(d));\n    \n    col*=vec3(1.,d,d);\n    \n    \n    //col=colorfusion(col,d,vec3(1.),0.\n    //col+=d;\n    //col=vec3(d);\n    //col=vec3(d);\n    \n   // vec2 pp=p;\n   // //p*=Rot(3.14/6.);\n   // quxian=sin(p.x*4.*3.1415-1.57)/4.;\n   // d=p.y*1.-quxian;\n   // d=S(0.025,0.034,abs(d));\n   // col*=vec3(d,d,d);\n   //    \n   \n   \n   \n    vec2 mouse = iMouse.xy/iResolution.xy-0.5;\n    vec2 click=iMouse.zw/iResolution.xy-0.5;\n  \n  \n    vec2[7] pts=vec2[7](\n          vec2(0.158,0.136),\n          vec2(0.08,0.131),\n          vec2(0.0133,-0.0667),\n          vec2(.212,-.034),\n          vec2(.3725,.078),\n          vec2(0.126,.296),\n          vec2(.355,.33));\n     \n    vec2 A = vec2(0.13,0.12);\n    vec2 B = mouse;\n    vec2 C = vec2(.33,0.33);\n    vec2 percent=p;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.25,0.));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        //color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, pts[1]);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        //color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, pts[6]);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        //color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n\n   //dist = approx_distance(percent, A, B, C);\n   //if (dist < EDGE + SMOOTH)\n   //{\n   //    dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n   //    color *= vec3(dist);\n   //}\n   \n    int bezierSegN=120;\n    float segn=1./float(bezierSegN);\n    \n    \n   \n    vec2 orip=pts[0];\n    for(int i=1;i<=bezierSegN;i++)\n    {      \n        float t=segn*float(i);\n        //vec2 bp=BezierPt(pts,6,t);\n        vec2 bp=BezierPt6(pts,t);       \n        color*=SDFLine(p,orip,bp,0.065*t*t,0.01);       \n        orip=bp;\n    }\n    col*=color;\n    \n    \n    \n    pts=vec2[7](\n          vec2(0.158,0.136),\n          vec2(0.043,0.108),\n          vec2(0.023,-0.035),\n          vec2(.087,-.243),\n          vec2(.448,-.15),\n          vec2(0.236,.167),\n          vec2(.455,.191));\n          \n    bezierSegN=280;\n    segn=1./float(bezierSegN);\n    orip=pts[0];\n   \n    for(int i=1;i<=bezierSegN;i++)\n    {      \n        float t=segn*float(i);       \n        vec2 bp=BezierPt6(pts,t);\n        //float disline=SDFLine(p,orip,bp);  \n        float xx=float(i/bezierSegN);\n        xx=(.5-clamp(abs(t-0.55),0.,0.5))*1.8;\n        xx*=xx;\n        //xx=(1.-abs(xx-0.25))*(float(i)-1.);\n        //xx/=30.;\n        //color*=S(0.0,xx,disline);\n        //color*=SDFLine(p,orip,bp,0.065*t*t*pow(abs(p.x-0.25),2.)*3.);\n        color*=SDFLine(p,orip,bp,0.15*xx,0.01);\n        //color2*=S(0.0,-0.2,disline);\n        //color*=S(0.5,0.05,disline);\n        //color*=S(0.2,0.1,disline);\n        orip=bp;\n    }\n    r=length(p-vec2(0.15,-0.08))+length(p-vec2(0.27,-0.05));\n    t=S(0.145,0.135,r);\n    color+=t;\n    \n    col*=color;\n    \n    if(p.y>0.)  return col; \n    \n    if(p.y<-0.0){\n    \n        float w=1.22*(p.y/(abs(p.y+1.))+0.9);\n        d=sin(3.1415926*(w*p.y-0.5))+1.02;\n        d=p.x-d;\n        d=S(-0.01,0.,d);\n        if(p.y<-0.48) d=1.;\n        color=vec3(d);\n        \n        \n       // d=length(vec2(p.x,p.y*1.2+sqrt(p.x)*0.4+0.15*0.15));\n        //d=length(vec2(p.x,p.y*1.2+sqrt(p.x)*0.35+0.158));\n        d=length(vec2(p.x+0.06,p.y*1.9+sqrt(p.x)*1.+0.04));\n        d*=d;        \n        d=S(0.019,0.0184,d);\n        if(-0.16<=p.y&&p.y<=-0.05&&p.x<=0.02)\n        {\n            d+=S(0.,0.001,p.y-x*0.18+0.15);\n            d=clamp(d,0.,1.);\n        }\n        //if(p.x<0.0143) d=1.;\n        color+=d;\n        \n        d=length(vec2(p.x,p.y*1.1-p.x*0.46+0.36));\n        d*=d;        \n        d=S(0.011,0.010,d);\n        color+=d;\n        color=clamp(color,vec3(0.),vec3(1.));\n    \n        d=length(uv-vec2(0.07,-0.24))+length(uv-vec2(-0.07,-0.24));\n        //d*=d;\n        \n        d=S(0.16,0.162,d);\n        color*=vec3(1.,d,d);\n       // color*=vec3(1.-d,0.8-d*0.8,0.);\n        \n    }\n   //col*=1.-S(0.,0.1,p.x-sin(p.y*3.14));\n    \n   //vec2[6] pts6=vec2[6](\n   //      vec2(0.046,-0.129),\n   //      vec2(0.112,-0.15),\n   //      vec2(0.174,-0.237),\n   //      vec2(.06,-.247),\n   //      vec2(.049,-.172),\n   //      vec2(0.0,-.237));\n     vec2[6] pts6=vec2[6](\n          vec2(0.024,-0.092),\n          vec2(0.048,-0.117),\n          vec2(0.079,-0.136),\n          vec2(.0555,-.168),\n          vec2(.016,-.129),\n          vec2(-0.012,-.1595));\n          \n    bezierSegN=40;\n    segn=1./float(bezierSegN);\n    orip=pts6[0];\n   \n    for(int i=1;i<=bezierSegN;i++)\n    {      \n        float t=segn*float(i);       \n        vec2 bp=BezierPt5(pts6,t);\n       \n       \n        color*=SDFLine(p,orip,bp,0.001,0.005);\n      \n        orip=bp;\n    }\n    \n   \n    //color*=vec3(d,d*0.5,0.);\n    col*=color;\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col =vec3(0.);\n    \n    col+=Feature2(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}