{"ver":"0.1","info":{"id":"lXtSRf","date":"1720420653","viewed":104,"name":"Flowing clouds","username":"dmc203","description":"Ignore it, this is useless.","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","cloud","volumtric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = textureLod(iChannel0,uv,0.0);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CLOUDSPEED 12.0\n#define FBMDEEP 3.0\n#define CLOUDSDENSITY 0.90\n//光照方向\n//sunlightDir\nconst float theta = -0.8;\nconst float alpha = -2.0;\nvec3 lightDir = vec3(sin(theta)*sin(alpha),cos(theta),sin(theta)*cos(alpha));\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}                       \n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//三维维纹理噪波\n//textureVolum\nfloat noise_t( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;  \n  \n}\nfloat fbmcloud_t( in vec3 x ,int depth)\n{\n    float f = 5.0;\n    float s = 0.25;\n    float a = 0.1;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<depth; i++ )\n    {\n        float depthf = float(depth);\n        float n = noise_t(x);\n        a += b*n;          \t\t\n        b *= s;\n        x = f*m3*x+depthf*vec3(iTime*CLOUDSPEED*0.01,0.0,-0.03*CLOUDSPEED*iTime);\n    }\n\treturn a;\n}\nfloat cloudsMap( in vec3 pos , int depth)\n{\n    return abs(fbmcloud_t(pos*0.0006,depth))-(1.0-CLOUDSDENSITY);\n}\n\n\n//射线相交检测\n//ray intersection detection\nfloat intersectRaySphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {\n    vec3 L = rayOrigin - sphereCenter;\n    \n\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - sphereRadius * sphereRadius;\n    \n    float discriminant = b * b - 4.0 * c;\n    \n    if (discriminant < 0.0) {\n        return 0.0;  \n    }\n    float sqrtDiscriminant = sqrt(discriminant);\n    float t1 = (-b - sqrtDiscriminant) / 2.0;\n    float t2 = (-b + sqrtDiscriminant) / 2.0;\n    float t = t1 > 0.0 ? t1 : t2;\n    \n    if (t < 0.0) {\n        return 0.0;  \n    }\n    return t;\n}\nvec3 conesampler(vec3 rd, float angle, float seed)\n{\n    \n    angle = radians(angle);\n    \n    float theta = acos(rd.y);\n    float alpha = atan(rd.x, rd.z);\n    \n    \n    //angle with y axis\n    theta += angle * (hash(seed + 0.1371) - 0.5);\n    //angle with z axis\n    alpha += angle * (hash(seed + 0.3137) - 0.5);\n    return vec3(sin(alpha) * sin(theta),\n                cos(theta),\n                cos(alpha) * sin(theta));\n}\nvec4 raymarchVolumeCloud(in vec3 ro , in vec3 rd)\n{\n    //视线和地平线相交的视线的y值\n    //The Y value of the line of sight intersecting the horizon\n    float max_y = -(1.0-(6371000.0)/(6371000.0+ro.y)*(6371000.0)/(6371000.0+ro.y));\n    if(rd.y >max_y)\n        {\n        vec4 sum = vec4(0.0);\n        vec3 rayOrigin = ro;\n        vec3 origin = vec3(ro.x,-6371000.0,ro.z);\n        float atm_in = 6372000.0;\n        float atm_out = 6378000.0;\n        float atm_thickness = atm_out-atm_in;\n        float atm_norheight = (atm_in+atm_out)*0.5;\n        float tmin = intersectRaySphere(rayOrigin,rd,origin,atm_in);\n        float tmax = intersectRaySphere(rayOrigin,rd,origin,atm_out);\n        float sample_count =64.0;\n        float t = tmin;\n        float dt = (tmax-tmin)/float(sample_count);\n        vec3 pos;\n        float den;\n        float sample_count_zero=0.0;\n        float thinkness = 0.0;\n        float total_thinkness=0.0;\n        vec3 sunsamplerpos=vec3(0.0);\n        for(float i = 0.01; i < sample_count; i++)\n        {\n            \n            vec3 pos = ro + t * (rd);\n            int depth = int(FBMDEEP * exp(-0.00002*t));\n            den = cloudsMap(pos , depth);\n            if(den>0.01)\n            {\n                float distance_pos_origin = length(pos-origin);\n                //0~1的线性值\n                float alpha_attenuation =  (distance_pos_origin - atm_in)/atm_thickness;\n                //非线性值\n                //alpha_attenuation\n                //https://graphtoy.com/?f1(x,t)=0.3&v1=false&f2(x,t)=log10(x)*f1(x)+1&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.28417159519495544,0.2705297647734529,1.621566851172481\n                //alpha\n                float a = 0.83;\n                alpha_attenuation = (log(alpha_attenuation) * a + 1.0);\n                vec3 nor = vec3(0.0,sign(distance_pos_origin - atm_norheight+950.0*den),0.0);\n                vec3 dif = vec3(1.6,1.3,1.0)*clamp(dot(nor,lightDir),0.0,1.0);\n                vec3 col = vec3(1.0,1.0,1.0);\n                float cos_angle = dot(lightDir, rd);\n                float inG = 0.13;\n                vec3 HenyeyGreenstein =  vec3(1.0,1.0,1.0)*((1.0 - inG * inG) / pow((1.0 + inG * inG - 2.0 * inG * cos_angle), 3.0/2.0))\n                / 4.0 * 3.1415;\n                sunsamplerpos = pos + lightDir*30.0;\n                //thinkness = den*0.9;\n                //float powder_sugar_effect = 1.0 - exp(-thinkness*2.0);\n                //float beers_law = exp(-thinkness);\n                //float light_energy =2.0 * beers_law * powder_sugar_effect;\n                for(int i =0;i<3;i++)\n                {\n                    vec3 rd = conesampler(lightDir, 180.0 , float(i));\n                    float lightden = cloudsMap(pos+lightDir,depth);\n                    thinkness += lightden*0.167;\n                }\n                float powder_sugar_effect = 1.0 - exp(-thinkness*2.0);\n                float beers_law = exp(-thinkness);\n                float light_energy =2.0 * beers_law * powder_sugar_effect;\n                vec3 lin = vec3(0.0);\n                lin += dif;\n                lin += vec3(1.0,1.0,1.0) * HenyeyGreenstein;\n                col *= lin;\n                col *= light_energy;\n                float alp = clamp(den * 0.80 * alpha_attenuation + dt * 0.0002 , 0.0 , 1.0);\n                col.rgb *= alp;\n                sum = sum + vec4(col,alp) * (1.0-sum.a);\n            }\n            \n            //t+=dt*hash(dot(rd, vec3(12.256, 2.646, 6.356)) + iTime);\n            t+=dt*(hash(dot(rd, vec3(12.256, 2.646, 6.356)) + iTime)+0.5);\n            if(t > tmax||sum.a>0.99) break;\n        }\n        //https://graphtoy.com/?f1(x,t)=1.0-exp(-x*2.0)&v1=false&f2(x,t)=exp(-x)&v2=false&f3(x,t)=2.0*f1(2*x)*f2(2*x)&v3=true&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=1.0158823884643056,0.33871932647508934,1.783723536289822\n        sum.xyz = mix(sum.xyz,vec3(0.0,0.6,1.8),0.22);\n        return sum;\n        }\n    else return vec4(0.0);\n}\nconst vec3 skycolor = vec3(0.21,0.586,1.1);\nvec4 cameraRender(in vec2 uv)\n{\n    vec2 o = vec2(-0.5,-0.5);\n    vec2 dirpos = (2.0*(uv)-iResolution.xy)/ iResolution.y+hash(dot(uv,vec2(1.23,5.323))+iTime)*0.03;\n    \n    float time = iTime;\n    float height = 899.0;\n    vec3 ro = vec3(0.0, height , 0.0);\n    vec2 m = iMouse.xy /iResolution.xy;\n    vec3 ta = vec3(m.x*3.0, height+m.y*3.0+1.0, 1.0); \n    //相机位置\n    //cameraset\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    vec3 raydir = ca * normalize(vec3(dirpos,1.0));\n    \n    vec3 col;\n    vec3 lightDir = vec3(sin(theta)*sin(alpha),cos(theta),sin(theta)*cos(alpha));\n    vec3 sun =vec3(1.8,1.0,0.9) * pow(clamp(dot(lightDir,raydir),0.0,1.0),128.0);\n    col = skycolor;\n    col+=sun;\n    \n    //CloudMarching\n    vec4 res = raymarchVolumeCloud(ro,raydir);\n    col = mix(res.rgb,col,1.0-res.a);\n    col = col + pow(max(dot(lightDir,raydir),0.0)*0.5,256.0);\n\n    //色调映射和gamma矫正\n    col=(col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n    col*=1.0;\n    col = pow(col,vec3(1.0/2.2));\n    //对比度调整\n    col = smoothstep(0.05,1.0,col);\n    vec3 glowdir =lightDir;\n    vec3 glow = vec3(1.0,0.64,0)*0.06*pow(max(dot(raydir,glowdir),0.0),2.0);\n    col += glow;\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = cameraRender(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}