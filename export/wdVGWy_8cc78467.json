{"ver":"0.1","info":{"id":"wdVGWy","date":"1570893432","viewed":206,"name":"noise_experiment","username":"skaplun","description":"Insireb by this image https://twitter.com/bencesamu/status/1182391240203132929","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define BG .15\n#define OUTLINE_CLR vec3(1.)\n#define OUTLINE_W .02\n#define SLICE .075\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec4 hitInside(Ray ray, float enterPointY){\n\tvec4 outClr = vec4(0.);\n    Plane plane = Plane(vec3(0., enterPointY - mod(enterPointY, SLICE) + SLICE * step(0., ray.dir.y), 0.), vec3(0., -1., 0.));\n    HitRecord rec;\n    for(int i=0; i<25; i++, plane.origin.y += SLICE * sign(ray.dir.y)){\n\t\tfloat noiseVal, noiseThreshold = 0.;\n        float len = 0.;\n        float y = 0.;\n        if(plane_hit(ray, plane, rec, 0., MAX_FLOAT)\n           && (len = length(rec.ptnt[0].xz)) < 1.\n           && rec.ptnt[0].y >= -1.\n           && (noiseVal = simplex3D(vec3(rec.ptnt[0].xz * 1.25, iTime * .1)) * .5 + .5)\n            > (noiseThreshold = (y = pow(smoothstep(-.75, 2.5, rec.ptnt[0].y), .25)) + pow(len, 8.)) - OUTLINE_W){\n\t\t\tfloat edge = smoothstep(.02, .01, abs(noiseVal - noiseThreshold));\n            vec3 curClr = pal(smoothstep(-1., 1., rec.ptnt[0].y), vec3(.5),vec3(.5),vec3(1.),vec3(.3, .2, .2));\n            curClr = mix(OUTLINE_CLR, curClr, smoothstep(noiseThreshold, noiseThreshold + OUTLINE_W, noiseVal));\n            float alpha = smoothstep(noiseThreshold - OUTLINE_W, noiseThreshold, noiseVal);\n            outClr.rgb = mix(curClr, outClr.rgb, outClr.a);\n            outClr.a += alpha;\n            if(outClr.a >= 1.)\n                return outClr;\n        }\n    }\n    return outClr;\n}\n\nvec4 image(vec2 fragCoord){\n\tvec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01;\n    vec3 origin = vec3(3.5 * sin(ang), 3., 3.5 * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    vec3 outClr = vec3(BG);\n    Cylinder cyl = Cylinder(vec3(0., -2., 0.), vec3(0., 2., 0.), 1.);\n    HitRecord rec;\n    if(cyl_hit(camRay, cyl, rec)){\n        vec4 curClr = hitInside(camRay, rec.ptnt[0].y);\n        outClr = mix(outClr, curClr.rgb, curClr.a);\n    }\n    \n    return vec4(outClr, 1.);\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(image(fragCoord + vec2(x, y) / float(AA)).rgb, 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Ray{ vec3 origin, dir;};\nstruct Plane{ vec3 origin; vec3 normal;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];};\nstruct Cylinder{vec3 A, B; float r;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out HitRecord rec, in float t_min, in float t_max) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= t_min && t < t_max){\n\t\t\trec.dist.x = t;\n            rec.ptnt[0] = inray.origin + inray.dir * rec.dist.x;\n            return true;\n        }\n    }\n    return false;\n}\n    \nbool cyl_hit(in Ray ray, in Cylinder cyl, inout HitRecord rec){\n  // Solution : http://www.gamedev.net/community/forums/topic.asp?topic_id=467789\n  float cxmin, cymin, czmin, cxmax, cymax, czmax;\n  if (cyl.A.z < cyl.B.z) {\n      czmin = cyl.A.z - cyl.r;\n      czmax = cyl.B.z + cyl.r;\n  } else {\n      czmin = cyl.B.z - cyl.r;\n      czmax = cyl.A.z + cyl.r;\n  }\n  if (cyl.A.y < cyl.B.y) {\n      cymin = cyl.A.y - cyl.r;\n      cymax = cyl.B.y + cyl.r;\n  } else {\n      cymin = cyl.B.y - cyl.r;\n      cymax = cyl.A.y + cyl.r;\n  }\n  if (cyl.A.x < cyl.B.x) {\n      cxmin = cyl.A.x - cyl.r;\n      cxmax = cyl.B.x + cyl.r;\n  } else {\n      cxmin = cyl.B.x - cyl.r;\n      cxmax = cyl.A.x + cyl.r;\n  }\n\n  vec3 AB = cyl.B - cyl.A;\n  vec3 AO = ray.origin - cyl.A;\n  vec3 AOxAB = cross(AO, AB);\n  vec3 VxAB  = cross(ray.dir, AB);\n  float ab2 = dot(AB, AB);\n  float a = dot(VxAB, VxAB);\n  float b = 2. * dot(VxAB, AOxAB);\n  float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);\n  float d = b * b - 4. * a * c;\n  if (d < 0.)\n      return false;\n  float[2] coef = float[2](1., -1.); \n  for(int i=0; i<2; i++){\n\t  float t = (-b - coef[i] * sqrt(d)) / (2. * a);\n      rec.dist[i] = t;\n      rec.ptnt[i] = ray.origin + ray.dir * t;\n  }\n  return true;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}","name":"Common","description":"","type":"common"}]}