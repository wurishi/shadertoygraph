{"ver":"0.1","info":{"id":"wlcXWn","date":"1580724305","viewed":232,"name":"locking sponges","username":"julianlumia","description":"\n:octopusballoon:","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["sponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//radial blur code from jeyko: https://www.shadertoy.com/view/WlKXRR :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.3;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.2);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.,1.));\n\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dMengerSponge(vec3 p) \n{\n float d = sdBox(p, vec3(0.6));\n float itt = 5.;\n float one_third = 2. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\nfloat dMengerSponge2(vec3 p) \n{\n float d = sdBox(p, vec3(0.4));\n float itt = 4.;\n float one_third = 1. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\nvec2 GetDist(vec3 p) {\t\n    \n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n vec2 d;\n d=vec2(1.0);  \n vec3 p5 = p;\n p5.xz *= Rot(sin(0.09*.4*6.28));\n vec2 dm1= vec2(dMengerSponge(p5),2);\n p = abs(p-.4);   \n vec3 p1 = p-vec3(-.0,1.,1.0);\n vec3 p2 = p-vec3(1.,0.0,1.0);\n vec3 p4 = p-vec3(1.,1.0,.0);   \n vec2  dm2=vec2(dMengerSponge2(p1),1);\n vec2  dm3=vec2(dMengerSponge2(p2),1);\n vec2  dm4=vec2(dMengerSponge2(p4),1);\n dm2.x *=0.6;\n dm3.x *=0.6;  \n dm4.x *=0.6;\n d = condmin( d,dm1);\n d = condmin( d,dm2);\n d = condmin( d,dm3);\n d = condmin( d,dm4);\n g1 +=1./(.02+pow(abs(dm1.x),10.));\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<64; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<0.001||t.x>100. ) break;\n  t.x+=h.x;t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nvec3 cameraPath(float t) {\n t *= PI *.5 ;\n float t2 =  cos(t)+0.;\n float c = cos(t*2.);\n float x = 0.;\n float y = 0.;\n float z = 0.;\n if (t2<0.){\n  x = 1. /1. + 2. +c;\n };       \n if (t2>0.){\n  y = 1. /1. + 2. +c;\n };\n vec3 xyz =vec3(x,y,z);\n return xyz;\n}\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = cameraPath(t);\n vec3 lightPos1 = vec3(-cameraPos-vec3(4,4.,2.0));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);    \n float dif1 = clamp(dot(n1, l1), 0., 1.);\n vec2 d1 = RayMarch(p+n1*0.001*1., l1);\n if(d1.x<length(lightPos1-p)) dif1 *= 1.;    \n return (dif1)/1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);  \n vec3 cameraPos = cameraPath(t);\n vec3 ro = vec3(-cameraPos);\n vec3 rd = normalize(vec3(uv.x, uv.y, 0.4));\n float the = iTime *0.3;\n rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 baseColor = vec3(0.,0.6,0.);\n  if(d.y==1.) baseColor=vec3((sin(iTime*1.5)*0.5+0.5),0.,0);\n  if(d.y==2.) baseColor=vec3((cos(iTime*1.5)*0.5+0.5),0.,0);\n;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  col+=baseColor;\n }  \n col*=g1*vec3(.0007);  \n float fog = 1. / (2. + d.x * d.x * 1.);\n col *= vec3(fog);  \n vec3 sky = vec3(1., 1., 1.);\n col = mix(sky, col, 1.1/(d.x*d.x/1./1.*.1+.8)); \n fragColor = vec4(col,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}