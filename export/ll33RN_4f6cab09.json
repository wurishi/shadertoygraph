{"ver":"0.1","info":{"id":"ll33RN","date":"1468153353","viewed":234,"name":"Necromurlok - Noise","username":"Necromurlok","description":"Noise","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n//    return fract((sin(h)*43758.5453123)  + iTime);\n    return fract((sin(h)*43758.5453123));\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*0.5 + 0.5; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    float r = max(d.y/1.2 - d.x*1., 0.)/1.2;\n    return r;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.xx;\n//    uv *= pow(1.0 - dot(uv, uv), 2.0);\n    float n = pow(1.0 - dot(uv, uv), 2.0); //noise(uv * 200.0);\n//    float i = 1.0;\n\n    fragColor -= fragColor;\n    \n    for (float i = 1.0; i < 5.0; i+=1.0) {\n        float s = sin(iTime * (0.13 * i));\n        float c = cos(iTime * (0.13 * i));\n        mat2 m = mat2(s, c, c, -s);\n        vec2 uv2 = uv * m;\n/*        fragColor += vec4(vec3(step(0.15, noise(uv2 * 140.0)),\n                               step(0.15, noise(uv2 * 141.0)),\n                               step(0.15, noise(uv2 * 142.0))),\n                               1.0);*/\n/*        fragColor += vec4(vec3(step(0.015, Voronoi(uv2 * 20.0)),\n                               step(0.015, Voronoi(uv2 * 21.0)),\n                               step(0.015, Voronoi(uv2 * 22.0))),\n                          1.0);*/\n        vec3 v = vec3(Voronoi(uv2 * 20. * (i * 0.25)), Voronoi(uv2 * 21. * (i * 0.25)), Voronoi(uv2 * 22. * (i * 0.25))) - .0015;\n        fragColor += vec4(smoothstep(vec3(0.01), fwidth(v), v), 1.);        \n    }\n    fragColor /= 5.0;\n    fragColor *= n;\n}","name":"Image","description":"","type":"image"}]}