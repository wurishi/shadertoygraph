{"ver":"0.1","info":{"id":"lcfcWr","date":"1721017211","viewed":39,"name":"Retro Terrain","username":"thebeardphantom","description":"A playground for testing making a raymarched 80s terrain shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float INF = 99999.0;\n\nconst vec3 BACKGROUND_COLOR_TOP = vec3(0.07, 0.0, 0.2);\nconst vec3 BACKGROUND_COLOR_BOTTOM = vec3(0.04, 0.02, 0.0);\nconst vec3 SUN_COLOR_TOP = vec3(0.96, 0.67, 0.08);\nconst vec3 SUN_COLOR_BOTTOM = vec3(0.93, 0.13, 0.25);\nconst vec3 GRID_COLOR = vec3(0.53, 0.0, 0.42);\nconst vec3 GRID_PULSE_COLOR = vec3(0.83, 0, 0.65);\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n    return pow(radius/dist, intensity);\t\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nvec3 repeat(in vec3 p, in vec3 s)\n{\n    vec3 q = p - s * round(p / s);\n    return q;\n}\n\n\nvec3 opCheapBend(in vec3 p, float k)\n{\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nfloat unlerp01(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nvec4 incorp(vec4 target, vec4 factor)\n{\n    if(factor.w > target.w)\n    {\n        return target;\n    }\n    \n    vec4 result = target;\n    float dist = abs(factor.w);\n    float contribution = unlerp01(MAX_DIST, 0.0, dist);\n    result.xyz += factor.xyz * contribution;\n    result.w = min(result.w, factor.w);\n    return result;\n}\n\n\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nvec4 sunSDF(vec3 samplePoint, vec3 position, float radius)\n{\n    float dist = length(samplePoint - position) - radius;\n    dist = mix(MAX_DIST, dist, step(0.5, samplePoint.y));\n    float fade = unlerp01(position.y, position.y + radius, samplePoint.y);\n    fade = pow(fade + 0.5, 6.5);\n    vec3 color = mix(SUN_COLOR_BOTTOM, SUN_COLOR_TOP, fade);\n    \n    // This does the vaporwave sun thing\n    const float GRID_THICKNESS = 2.0;\n    const float GRID_SEPARATION = 5.0;\n    samplePoint.y -= iTime * 3.0;\n    float thickness = GRID_THICKNESS * (fade + 0.5);\n    vec3 samplePointGridY = repeat(samplePoint, vec3(0.0, GRID_SEPARATION, 0.0));\n    float subDist = sdCapsule(samplePointGridY, vec3(-INF, 0.0, -450.0), vec3(INF, 0.0, -450.0), thickness);\n    dist = opIntersection(dist, subDist);\n    return vec4(color, dist);\n}\n\nvec4 gridSDF(vec3 samplePoint)\n{\n    const float GRID_THICKNESS = 0.1;\n    const float GRID_SEPARATION = 10.0;\n    \n    samplePoint.x += iTime * 10.0;\n    \n    vec3 samplePointGridX = repeat(samplePoint, vec3(GRID_SEPARATION, 0.0, 0.0));\n    float dist = sdCapsule(samplePointGridX, vec3(0.0, 0.0, -INF), vec3(0.0, 0.0, INF), GRID_THICKNESS);\n    \n    vec3 samplePointGridZ = repeat(samplePoint, vec3(0.0, 0.0, GRID_SEPARATION));\n    dist = min(dist, sdCapsule(samplePointGridZ, vec3(-INF, 0.0, 0.0), vec3(INF, 0.0, 0.0), GRID_THICKNESS));\n    \n    vec3 color = mix(GRID_COLOR, GRID_PULSE_COLOR, pow((sin(iTime * 12.0) + 1.0) / 2.0, 5.0));\n    return vec4(color, dist);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec4 sceneSDF(vec3 samplePoint)\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, MAX_DIST);\n    \n    \n    vec4 sun = sunSDF(samplePoint, vec3(0.0, -0.0, -500.0), 100.0);\n    result = incorp(result, sun);\n    \n    \n    vec4 grid = gridSDF(samplePoint);\n    result = incorp(result, grid);\n    \n    return result;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec4 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection)\n{\n    float depth = MIN_DIST;\n    const vec4 MISS = vec4(0.0, 0.0, 0.0, MAX_DIST);\n    vec4 accumulatedResult = vec4(0.0, 0.0, 0.0, MAX_DIST);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 samplePoint = eye + depth * marchingDirection;\n        samplePoint = opCheapBend(samplePoint, -0.0002);\n        vec4 result = sceneSDF(samplePoint);\n        accumulatedResult.xyz += result.xyz;\n        accumulatedResult.w = min(accumulatedResult.w, result.w);\n        \n        if (result.w <= EPSILON)\n        {\n\t\t\treturn result;\n        }\n        \n        depth += result.w;\n        if (depth >= MAX_DIST)\n        {\n            return MISS;\n        }\n    }\n    \n    return MISS;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 dir = rayDirection(60.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 5.0, 0.0);\n    vec4 result = shortestDistanceToSurface(eye, dir);\n    \n    if (result.w > MAX_DIST - EPSILON)\n    {\n        // background color\n\t\tfragColor = vec4(mix(BACKGROUND_COLOR_BOTTOM, BACKGROUND_COLOR_TOP, uv.y), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(result.xyz, 1.0);\n    }\n   \n    \n    float noise = texture(iChannel1, (uv * 0.75) + (iTime * 4.0)).r * 0.2;\n    fragColor += noise;\n    \n    noise = texture(iChannel3, (uv * 10.0) + (iTime * 100.0)).r;\n    noise = pow(noise, 100.0);\n    noise *= 0.5;\n    fragColor += noise;\n    \n    noise = texture(iChannel2, vec3(uv, iTime * 0.2)).r;\n    noise = pow(noise, 500.0) * 1000.0;\n    fragColor += noise;\n    \n    fragColor.xyz += vec3(0.02, 0.02, 0.02);\n}","name":"Image","description":"","type":"image"}]}