{"ver":"0.1","info":{"id":"DdBfWm","date":"1689759337","viewed":315,"name":"Gesture Mouse with Webcam","username":"kirickiri","description":"Forked from https://www.shadertoy.com/view/WsVcRt from Khrebtov_M \nForked from https://www.shadertoy.com/view/Xsf3zX from Dave_Hoskins\nchanged a bit on the interaction\nmotion left, motion right to twist the camera","likes":4,"published":1,"flags":34,"usePreview":0,"tags":["tracing","webcam","motion","movement"],"hasliked":0,"parentid":"cdBBDw","parentname":"Fork Follow You kirickiri 515"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEREO\n#define THRESHOLD .003\n#define MOD2 vec2(3.07965, 7.4235)\nconst float PI = 3.14159265;\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 cameraPos;\nvec3 sunColour = vec3(1.0, .75, .6);\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\nfloat gTime = 0.0;\n\n//--------------------------------------------------------------------------\n// Noise functions...\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//--------------------------------------------------------------------------\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0;\n    vec2 id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = b - f  + hash22( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid.x  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id.x);\n}\n\n\n\n\n//--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.003;\n\tfloat w = 50.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn vec2(f, type);\n}\n\n//--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n//--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\n// Merge grass into the sky background for correct fog colouring...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\n\treturn mix( rgb, GetSky(dir), fogAmount );\n}\n\n//--------------------------------------------------------------------------\nvec3 DE(vec3 p)\n{\n\tfloat base = Terrain(p.xz).x - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\n\t//p.y += height;\n\tfloat y = p.y - base-height;\n\ty = y*y;\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*2.0+p.zx*12.3)*.12+vec2(sin(iTime*1.3+1.5*p.z),sin(iTime*2.6+1.5*p.x))*y*.5));\n\tfloat f = ret.x * .65 + y * .5;\n\treturn vec3( y - f*1.4, clamp(f * 1.1, 0.0, 1.0), ret.y);\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\n//--------------------------------------------------------------------------\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .1);\n\t}\n\tif(col.w < .2)\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\n\treturn col.xyz;\n}\n\n//--------------------------------------------------------------------------\n// Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\n}\n\n//--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\n{\n\tvec3 mat;\n\tif (type == 0.0)\n\t{\n\t\t// Random colour...\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\n\t\t// Random shadows...\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\n\t\t// Do grass blade tracing...\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\n\t\tDoLighting(mat, pos, normal,dir, dis);\n\t}\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\n// Home in on the surface by dividing by two and split...\n// Note, this does a much better job than using 'abs' on the distance march.\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n        float h = Map(rO + halfwayT*rD).x;\n        (h < THRESHOLD) ? t = halfwayT:oldT = halfwayT;\n  }\n\treturn t;\n}\n\n//--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\n{\n    float t = 5.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.;\n\tfloat h = 0.0;\n\tbool hit = false;\n\tfor( int j=0; j < 60; j++ )\n\t{\n\t    vec3 p = rO + t*rD;\n\t\th = Map(p).x; // ...Get this position's height mapping.\n\n\t\t// Are we inside, and close enough to fudge a hit?...\n\t\tif( h < THRESHOLD)\n\t\t{\n\t\t\thit = true;\n            break;\n\t\t}\n        oldT = t;\n\t\tt +=  h + (t*0.04);\n\t}\n    type = 0.0;\n    resT = BinarySubdivision(rO, rD, t, oldT);\n\treturn hit;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\t//t = time + t;\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\n} \n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t// Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Vignette...\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    vec2 pxxx = fragCoord.xy / iResolution.xy;\n    pxxx.x = 1.0-pxxx.x;//uv.x=1.-uv.x;//(invert)\n\tvec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n\tfragColor=(textureLod(iChannel0,pxxx,0.0).xxxw+texture(iChannel2,pxxx))*0.01;\n    float pdist= distance(pxxx.x,pos.x);\n    \n    \n    \n\n\tfloat m = ((pos.x))*200.0;\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\tvec3 camTar;\n\t\n\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\tcameraPos = CameraPath(gTime + 0.0);\n    cameraPos.x -= 3.0;\n\tcamTar\t = CameraPath(gTime + .009);//CameraPath(gTime + .009);\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\n\tcamTar.y = cameraPos.y;\n\t\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tfloat type;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t{\n\t\t// Missed scene, now just get the sky...\n\t\tcol = GetSky(dir);\n\t}\n\telse\n\t{\n\t\t// Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t// Get normal from sampling the high definition height map\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\n\t\tvec2 p = vec2(0.1, 0.0);\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t// Get the colour using all available data...\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\n\t}\n\t\n\t// bri is the brightness of sun at the centre of the camera direction.\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t// glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t// glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\t//fragColor=vec4(col,1.);\n\n\tif(pdist<0.15 ||pdist<0.075 )   fragColor +=vec4(col*1.2, 1.0);\n    else \n    fragColor +=vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Buffer b stores camera image from the previous frame, and this buffer outputs \ndifference between previous frame and current frame, so,for pixels that moved\nthe output pixel is bright*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n\nfragColor = textureLod( iChannel0, uv,1.0 )-textureLod( iChannel1, uv,1.0);    \n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Thit is the buffer that stores current image from the camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\n    fragColor = texture( iChannel1, uv);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/*this buffer is used to calculate the center of pixels from \nbuffer A  that are  bright enough  (those are the pixels that moved)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //we want pixel(0;0) to output position of the center of bright pixels\n    \n    if( fragCoord.x>0.5) return;\n    if( fragCoord.y>0.5) return;\n    \n  /*we will calculate the sum of bright pixels'coordinates \n  and then divide it by the number of these pixels*/\n    \n    vec2 sum=vec2(0.0);\n    float g=0.0;\n    float threshold = 0.15;\n    for(float i=0.0;i<1.0;i+=0.01) for(float j=0.0;j<1.0;j+=0.01)\n \t    {\n            vec3 diff = textureLod(iChannel0,vec2(i,j)  ,3.0).xyz;\n            if(diff.r >= threshold || diff.g >= threshold || diff.b >= threshold)\n            {\n\t\t\t\tsum+=vec2(i,j);\n \t  \t        g++;\n \t        }\n  \t     \n\t   }\n    float  td= iTimeDelta;\n    \n    /*camera is not  a precise tool for tracking movement, so, if we just output\n     calculated center, it will be jittery. Instead, we can move cursor towards\n    the calculated center buy calculating the difference between this position\n   and previous position, and multiply this difference by some constant value*/\n\n\tvec4 te =texture(iChannel1,vec2(0.0,0.0));//xy-current coordinates;zw-desired coordinates;\n    vec2 delta = te.zw-te.xy;\n\tif(g<15.0) fragColor = te+vec4(3.0*delta*td,0.0,0.0);\n    else\n    {\n        te.zw =sum/g;\n    \tdelta = te.zw-te.xy;\n     \tfragColor =  te+vec4(3.0*delta*td,0.0,0.0);\n    }\n   \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//this buffer if for the line that cursor traces \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor=.97*texture(iChannel0,uv);\n   \n    vec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n    if(distance(uv,pos)<0.2)   fragColor =vec4(1.);\n    \n    \n\n}","name":"Buffer C","description":"","type":"buffer"}]}