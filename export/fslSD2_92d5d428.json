{"ver":"0.1","info":{"id":"fslSD2","date":"1619269256","viewed":251,"name":"Interactive black hole","username":"sperche","description":"My first ray marching project to experiment with this algorithm. \nThe effect is produced by rotating the ray according to the distance and the mass of the black hole.\nThere are obviously better ways to achieve that, but I am quite happy with the result.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Interactive black hole using ray marching algorithm.\n    You can move (in TEXTURE mode) or rotate (in CUBEMAP or SCENE mode) around the black hole to see the effect.\n    \n    It moves automatically if the mouse has not been used. You can get back this behavior by moving your mouse in the \n    left-down corner.\n    \n    You can change the scene between CubeMap, texture and ray marching object at line 24-25.\n*/\n\n// ----------\n// Shader parameters \n// ----------\n\n#define BH_MASS 10.\n#define BH_RADIUS 1.5\n\n// ----------\n// CHANGE SCENE\n// ----------\n\n// If TEXTURE and CUBEMAP are false, display a simple scene with few objects.\n// Texture must be in iChannel0 and cube map in iChannel1\n#define TEXTURE false\n#define CUBEMAP true\n\n// ----------\n\n/*\n    How to load your custom texture (https://www.shadertoy.com/view/lsGGDd) :\n     - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n\n    Copy this line of code in the console. You can replace the link by any image.\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/6/60/ESO_-_Milky_Way.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n    The default link is the Milky Way under Creative Commons Licence.\n\n*/\n\n#define MAX_STEP 100\n#define MIN_DIST .001\n#define MAX_DIST 100.\n\nvec3 POS_BH = vec3(0., 2., 10.);\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 pos;\n    vec3 size;\n};\n\nstruct BlackHole\n{\n    vec3 pos;\n    float radius;\n    float mass;\n};\n\nfloat dist(vec3 p, Sphere s)\n{\n    return length(p-s.pos)-s.radius;\n}\n\nfloat dist(vec3 p, Box b)\n{\n    float dX = length(p.x-b.pos.x)-b.size.x;\n    float dY = length(p.y-b.pos.y)-b.size.y;\n    float dZ = length(p.z-b.pos.z)-b.size.z;\n    return max(dX, max(dY, dZ));\n}\n\nfloat getDist(vec3 pos)\n{\n    float dFloor = pos.y;\n    \n    Sphere sphere = Sphere(vec3(-1., 1., 15.), 1.);\n    float dS = dist(pos, sphere);\n\n    Sphere sphere1 = Sphere(vec3(2., 0.5, 15.), 0.5);\n    float dS1 = dist(pos, sphere1);\n\n    Sphere blackHole = Sphere(POS_BH, 0.);\n    float dBH = dist(pos, blackHole);\n\n    Box box1 = Box(vec3(2., 2., 15.), vec3(0.5));\n    float dB1 = dist(pos, box1);\n\n    if(TEXTURE || CUBEMAP)\n        return dBH;\n    else\n        return min(min(dFloor, dB1), min(dBH, min(dS, dS1)));\n    \n}\n\n// https://community.khronos.org/t/quaternion-functions-for-glsl/50140\nvec3 rotateVector( vec4 q, vec3 v )\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n} \n\n\n// ----------\n// https://math.stackexchange.com/questions/939229/unit-quaternion-to-a-scalar-power\n// Exponentiation of quaternion\n// ----------\nvec4 scale(vec4 q, float scale)\n{\n    q.w*=scale;\n    q.x*=scale;\n    q.y*=scale;\n    q.z*=scale;\n    return q;\n}\n\nvec4 ln(vec4 q) \n{\n    float r  = sqrt(q.x*q.x + q.y*q.y + q.z*q.z);\n    float t  = r>0.00001 ? atan(r,q.w)/r : 0.;\n    q.w = 0.5 * log(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);\n    q.x *= t;\n    q.y *= t;\n    q.z *= t;\n    return q;\n}\n\nvec4 exp_q(vec4 q) \n{\n    float r  = sqrt(q.x*q.x + q.y*q.y + q.z*q.z);\n    float et = exp(q.w);\n    float s  = r>=0.00001 ? et*sin(r)/r : 0.;\n\n    q.w = et * cos(r);\n    q.x *= s;\n    q.y *= s;\n    q.z *= s;\n    return q;\n}\n\nvec4 pow_q(vec4 q, float n)\n{\n    q = ln(q);\n    q = scale(q, n);\n    q = exp_q(q);\n    return q;\n}\n// ----------\n\n// Return the ray affected by gravitation\nvec3 gravitationForce(vec3 p, vec3 ray)\n{\n    BlackHole bh = BlackHole(POS_BH, BH_RADIUS, BH_MASS);\n    vec3 v2 = normalize(bh.pos-p);\n\n    float d = length(bh.pos-p);\n    if(d-bh.radius < MIN_DIST)\n        return vec3(.0);\n\n    // https://stackoverflow.com/questions/1171849/finding-quaternion-representing-the-rotation-from-one-vector-to-another\n    vec3 a = cross(ray, v2);\n    vec4 rot;\n    rot.xyz = a;\n    rot.w = sqrt(pow(length(ray), 2.) * pow(length(v2), 2.)) + dot(ray, v2);\n    rot = normalize(rot);\n\n    // Gravitation force decrease inversely proportional to the square of the distance\n    float square_inv_d = (1./pow(d,2.));\n    square_inv_d = square_inv_d > 1. ? 1. : square_inv_d;\n\n    // Take only a fraction of the rotation (i.e. fraction of the quaternion)\n    float n = square_inv_d*0.1*bh.mass;\n    rot = pow_q(rot, -n);\n    rot = normalize(rot);\n\n    return normalize(rotateVector(rot, ray));\n}\n\nfloat rayMarch(vec3 pos, vec3 ray, out vec3 endingPos)\n{\n    float total_dist = 0.;\n    float d;\n    \n    for(int i = 0 ; i < MAX_STEP ; ++i)\n    {\n        d = getDist(pos);\n        total_dist += d;\n        pos += ray * d;\n        vec3 newRay = gravitationForce(pos, ray);\n        if(newRay == vec3(0.))\n        {\n            total_dist = -1.;\n            break;\n        }\n        ray = normalize(newRay);\n        if(d < MIN_DIST || d > MAX_DIST) break;\n    }\n\n    endingPos = pos + ray * d;\n\n    return total_dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float d = getDist(pos);\n    vec2 e = vec2(0.01, 0.);\n\n    vec3 n = d - vec3(\n        getDist(pos - e.xyy),\n        getDist(pos - e.yxy),\n        getDist(pos - e.yyx)\n    );\n\n    return normalize(n);\n}\n\nfloat getLight(vec3 pos)\n{\n    vec3 lightPos = vec3(0., 10., 10.);\n\n    vec3 lightRay = normalize(lightPos-pos);\n    vec3 n = getNormal(pos);\n    float col = smoothstep(0.,.9,dot(lightRay, n));\n\n    vec3 endingPos;\n    float d = rayMarch(pos+n*MIN_DIST*2., lightRay, endingPos);\n\n    if(d < length(lightPos-pos) && d != -1.)\n    {\n        col *= .1;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates \n    vec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.y)*2.;\n    vec2 mouse = (iMouse.xy/iResolution.xy);\n    bool mouseNotUsed = mouse.x < 0.1 && mouse.y < 0.1;\n    mouse.x = (mouse.x-0.5)*2.;\n\n    vec3 col = vec3(0.);\n   \n    vec3 camera = vec3(0., 2., 0.);\n    vec3 imagePlane = vec3(uv.x, uv.y+2., 1.);\n\n    if(TEXTURE) // -> move along x and y\n    {\n        if(mouseNotUsed)\n        {\n            mouse.x = sin(iTime*0.25)*10.;\n            mouse.y = 0.;\n        }\n        else\n        {\n            mouse.x *= -10.;\n            mouse.y *= -15.;\n            mouse.y += 7.5;\n        }\n        \n        camera = vec3(mouse.x, mouse.y+2., 0.);\n        imagePlane = vec3(uv.x+mouse.x, uv.y+mouse.y+2., 1.);;\n    }\n    else // CubeMap ou sample scene -> rotation\n    {\n        if(mouseNotUsed)\n        {\n            mouse.x = (iTime-8.)/5.;\n            mouse.y = 0.;\n        }\n        else\n        {\n            mouse.x *= 2.;\n            mouse.y *=2.;\n            mouse.y -= 0.35;\n        }\n        //Rotation\n        mat3 rot_x = mat3(1, 0, 0,\n                    0, cos(mouse.y), -sin(mouse.y),\n                    0, sin(mouse.y), cos(mouse.y));\n        mat3 rot_y = mat3(cos(mouse.x), 0, sin(mouse.x),\n                    0, 1, 0,\n                    -sin(mouse.x), 0, cos(mouse.x));\n        camera -= POS_BH;\n        camera *= rot_x;\n        camera *= rot_y;\n        camera += POS_BH;\n\n        imagePlane -= POS_BH;\n        imagePlane *= rot_x;\n        imagePlane *= rot_y;\n        imagePlane += POS_BH;\n    }\n\n    vec3 ray = normalize(imagePlane-camera);\n\n    vec3 endingPos;\n    float d = rayMarch(camera, ray, endingPos);\n    vec3 rd = endingPos-camera;\n\n    // If inside the black hole\n    if(d == -1.)\n    {\n        col = vec3(0.);\n    }\n    else if(TEXTURE)\n    {   \n        rd /= rd.z;\n        // Move the texture\n        rd.xy = (rd.xy+1.)/2.;\n        \n        col = texture(iChannel0, rd.xy).xyz;\n    }\n    else if (CUBEMAP)\n    {\n        rd = normalize(rd);\n        col = texture(iChannel1, rd).xyz;\n    }\n    else\n    {\n        col += getLight(endingPos);\n    }\n    \n    fragColor = vec4(col, 1.);    \n}","name":"Image","description":"","type":"image"}]}