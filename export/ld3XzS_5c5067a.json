{"ver":"0.1","info":{"id":"ld3XzS","date":"1459915681","viewed":714,"name":"18756.2048d","username":"Branch","description":"18756.2048d","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["187562048d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float T2 = 0.1;\n\nfloat frc (float x) {\n    float q = (0.01 + 1.0)*x*x;    \n\treturn q / (q + x + 0.01);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).xyz;\n    float w = frc(11.2);\n    c = vec3(\n        frc(c.r),\n        frc(c.g),\n        frc(c.b)) / w;\n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 512.\n#define epsilon 0.001\n#define infinite 1e7\n#define lightSize 5.\n#define powLight 11.\n#define lightColor vec3(1.0,0.92,0.8)\nvec3 lightSource;\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float co){\n    return rand(vec2(co));\n}\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    q=q.zxy;\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat length2( vec2 p ) {\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p ) {\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p ) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nmat3 rotY(in float a)\n{\n\treturn mat3( cos(a), 0.0, sin(a),\n\t\t\t\t 0.0,    1.0, 0.0,\n\t\t\t\t-sin(a), 0.0, cos(a)\n\t\t\t    );\n}\n\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat n( in vec2 p )\n{\n    #define K1  0.366025404\n    #define K2  0.211324865\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\nfloat getColorReflection( vec3 position, out vec3 color, out float reflectiveValue) {\n\n    vec3 _position2 = position;\n    vec3 _position = position;\n    _position = _position * rotationMatrix(vec3(0.0,0.0,1.0),_position.z/20.);\n    _position.y = -abs(_position.y);\n    _position.y+=4.0;\n    vec3 _position3 = _position;\n    vec3 _position4 = _position;\n    float dist = 1e8;\n    float dist2 = 1e8;\n    float time = iTime;\n    float t2 = iTime*.1111;\n    \n    float heightmap = n( _position.xz/5.);\n    float nh = n( _position.xz*9.);\n    heightmap += nh/44.;\n    heightmap -= heightmap*nh/77.;\n    heightmap += n( _position.xz*2.)/7.;\n    dist = min(\n        dist,\n        sdBox(\n            _position - vec3(0.,-2.1,0.),\n            vec3(256.,2.+heightmap,256.)));\n    \n    \n    \n    \n    \n    float a=heightmap;\n    \tcolor = vec3(.7) - 2.*vec3(.4,.6,.8)*n( _position.xz/4.)*n( _position.xz*11.);\n        color = min(max(color,vec3(0.)),vec3(1.));\n    color += n( _position.xz*55.);\n    reflectiveValue = 0.1;\n    \n    return dist;\n}\nfloat getDistance( in vec3 position) {\n    vec3 _position = position;\n    vec3 c;\n    float r;\n    return getColorReflection(_position, c, r);\n}\n\nvec3 getSurfaceNormal(vec3 position) {\n    float e=epsilon;\n    vec3 normalVector = vec3(\n        \t\t\t\t\tgetDistance(position+vec3( e,  0., 0.)) - getDistance(position+vec3(  -e,   0.,  0.)) ,\n        \t\t\t\t\tgetDistance(position+vec3( 0., e,  0.)) - getDistance(position+vec3(   0., -e,   0.)) ,\n        \t\t\t\t\tgetDistance(position+vec3( 0., 0., e)) - getDistance(position+vec3(    0.,  0., -e)) );\n    normalVector = normalize(normalVector);\n    return normalVector;\n}\nfloat traceToLight(vec3 rayPosition, vec3 normalVector, vec3 lightSource, float raylightdist){\n\n    vec3 ro = rayPosition;\n    vec3 rd = normalize(lightSource - rayPosition);\n    float t = 0.11;\n    float k = distance(lightSource, rayPosition)/4.;\n    float res = 1.0;\n    for( int i=0; i<44; i++ )\n    {\n        float h = getDistance(ro + rd*t);\n        h = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.9 );\n        if( h<0.01) break;\n    }\n    return clamp(res,0.07,8.0);\n}\nfloat fastTraceToLight(vec3 rayPosition, vec3 normalVector, vec3 lightSource, float raylightdist){\n\n    vec3 ro = rayPosition;\n    vec3 rd = normalize(lightSource - rayPosition);\n    float t = 0.2;\n    float k = distance(lightSource, rayPosition)/4.;\n    float res = 1.0;\n    for( int i=0; i<11; i++ )\n    {\n        float h = getDistance(ro + rd*t);\n        h = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.9 );\n        if( h<0.01) break;\n    }\n    return clamp(res,0.07,9.0);\n}\nfloat getSurfaceColor( vec3 curPosition, vec3 normalVector, vec3 lightSource, vec3 lightDirection) {\n    float intensity = lightSize * pow( 0.001 + max(0.0, dot( lightDirection, normalVector)),  powLight);\n    intensity = lightSize * pow( intensity / distance( curPosition, lightSource),  powLight);\n    intensity += pow (max( dot( normalize( lightSource - curPosition), normalVector), 0.0), powLight);\n    return intensity;\n}\nvec3 giTrace(vec3 rayOrigin, vec3 rayDirection) {\n    vec3 endColorResult = vec3(0.0);\n    vec3 prevPosition = rayOrigin;\n\tvec3 curPosition = rayOrigin;\n    vec3 normalVector;\n    vec4 result=vec4( 0., 0., 0., 0.);\n    vec3 finalLight = vec3(0.0);\n\tfloat dist = 0.0;\n    int hit = 0;\n    vec3 rna=vec3(rand(rayOrigin.xy)-.5,rand(rayOrigin.xz)-.5,rand(rayOrigin.zy)-.5);\n    #define maxSamples 2.\n        for(float i = 0.; i < maxSamples; i++) {\n            \trna +=rna.zxy;\n            \tvec3 curPosition = \n                    rayOrigin + normalize(rayDirection + 0.2*rna );\n                vec3 color = vec3( 0.0);\n                float reflection = 0.0;\n                getColorReflection( curPosition, color, reflection);\n                normalVector = getSurfaceNormal( curPosition);\n            \t\n                float raylightdist = distance( curPosition, lightSource);\n                float light = traceToLight( curPosition, normalVector, lightSource, raylightdist);\n                vec3 lightDirection = normalize( lightSource - curPosition);\n                lightDirection = normalize(lightDirection);\n                float directLight = dot(normalVector, lightDirection);\n                finalLight += light*max(lightSize*directLight,0.01);\n                endColorResult +=  color * finalLight;\n        }\n    \n    return endColorResult / maxSamples;\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return length(max(abs(coord-pos)-b,0.0));\n}\nvec3 AO(vec3 rayOrigin, vec3 rayDirection) {\n    float AO = 0.0;\n    for(float i=1.0; i<6.0; i++) {\n        vec3 position =  rayOrigin + i * 0.05 * rayDirection;\n        AO += getDistance( position);\n    }\n    return vec3(AO);\n}\nvec4 march(vec3 rayOrigin, vec3 rayDirection) {\n    vec2 p = gl_FragCoord.xy / iResolution.xy;\n    vec3 origRayDirection=rayDirection;\n    vec3 endColorResult = vec3(0.0);\n    vec3 prevPosition = rayOrigin;\n    float skip = 32. * texture(iChannel0,p).w ;\n\tvec3 curPosition = rayOrigin;\n    vec3 normalVector;\n    vec4 result=vec4( 0., 0., 0., 0.);\n    vec3 finalLight = vec3(0.0);\n\tfloat dist = 0.0;\n    float storeColorStrength = 1.0;\n    int hit = 0;\n    float collisions = 0.;\n    float distanceOfCollision = 1111110.;\n    \n    \n    float distanceOfFirstHit = 0.;\n    \n    \n        for(float i = 0.; i < MAX_STEPS; i++) {\n            float R = 0.0;\n                \n            vec3 color = vec3( 0.0);\n            float stepable = getColorReflection( curPosition, color, R);\n            dist += stepable;\n            curPosition = prevPosition + dist * rayDirection;\n            if(distance(rayOrigin*vec3(1.,1.,.1),curPosition*vec3(1.,1.,.1))>32.0) break;\n           \t/*too far from begining point, call it an end*/\n            if( abs( stepable) < epsilon + i*i/6400.) {\n                //if( reflection == 0.) {\n                //    distanceOfCollision = distance(rayOrigin, curPosition);\n                //}\n                normalVector = getSurfaceNormal( curPosition);\n                \n                float raylightdist = distance( curPosition, lightSource);\n                float light = max(traceToLight( curPosition, normalVector, lightSource, raylightdist),0.3);\n                vec3 lightDirection = normalize( lightSource - curPosition);\n                lightDirection = normalize(lightDirection);\n                float directLight = dot(normalVector, lightDirection);\n                finalLight += light * max( lightSize * directLight,0.002);\n                float surfaceBrightness = length(finalLight);\n                vec3 lightColorInside = color + finalLight * lightColor;\n               \n                vec3 surfaceFinalColor = color * lightColor * storeColorStrength * finalLight;\n                \n                float surfLight = getSurfaceColor(curPosition, normalVector, lightSource, lightDirection);\n                            \n\n                endColorResult += 0.1 * finalLight * storeColorStrength * surfaceFinalColor * pow(max(dot(normalize(lightSource-curPosition),normalVector),0.0),powLight);\n                endColorResult += finalLight * storeColorStrength * surfaceFinalColor / (1.0+surfLight);\n                endColorResult += finalLight * storeColorStrength * surfaceFinalColor * pow(lightColor,vec3(powLight))/ (1.0+surfLight )  ;\n                endColorResult += finalLight * storeColorStrength * surfaceFinalColor * surfLight * R * surfaceFinalColor ;\n               \n                //endColorResult += 0.32*storeColorStrength * ( surfaceFinalColor) * giTrace(curPosition, normalVector) ;\n               \n                vec3 AOresult = min(max(log(AO(curPosition, normalVector) ),0.),1.);\n                endColorResult += storeColorStrength * AOresult /(1.0+surfLight);\n                endColorResult = max(endColorResult,vec3(0.));\n                if(collisions==0.) {\n                    distanceOfFirstHit = dist/32.;\n                }\n                storeColorStrength *= R;\n                hit = 1;\n                dist = 0.0;\n                \n                if(R>0.3){\n                    prevPosition = curPosition + normalVector*0.1;\n                    curPosition = prevPosition;\n                    rayDirection = normalize(reflect(rayDirection, -normalVector));\n                    hit = 0;\n                \tcollisions++;\n                }else {\n                    break;\n                }\n            }\n    }\n    \n    \n    if(hit==0) distanceOfFirstHit = 0.1;\n    \n    vec3 lightDir = (lightSource-rayOrigin);\n    lightDir = normalize(lightDir);\n    float directLight = dot(rayDirection, lightDir);\n    vec3 backdrop=min(max( pow(directLight,40.0) * vec3(1.8,1.1,.9) * 0.6, 0.01),1.);\n    backdrop+=min(max( pow(directLight,1.5) * vec3(0.8,0.9,1.0) * 1.6, 0.01),1.);\n    backdrop+=(min(max( pow(directLight,80.0) * 1.6, 0.01),1.)*1.1);\n    \n    vec3 farShoot=rayOrigin+origRayDirection*10.;\n    backdrop+=vec3(0.,0.,.1);\n  \t//if(hit==0 ) endColorResult += backdrop ;\n    endColorResult = max(endColorResult,vec3(0.0));\n    if(collisions>0.) distanceOfFirstHit = -distanceOfFirstHit;\n    endColorResult = max(endColorResult,vec3(0.));\n    return vec4( endColorResult, distanceOfFirstHit);\n}\nfloat resolveRaySphereIntersection(vec3 b, vec3 c, vec3 dir){\n\tvec3 OC=b-c;\n\tfloat P=dot(OC,dir);\n\tif(P<0.) return 1111.0;\n\tfloat d=sqrt(pow(length(OC),2.0)-pow(P,2.0));\n\treturn d;\n}\nfloat trace(vec3 rayOrigin, vec3 rayDirection) {\n    return resolveRaySphereIntersection(vec3(0.0,3.0,2.0), rayOrigin, rayDirection)*3.0;\n}\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n\nvec4 render( vec2 uv ) {  \n     float aspect = iResolution.x / iResolution.y;\n    \tfloat T=iTime*0.1;\n    \tfloat vieteri = cos(T)/(1.+T*T*T);\n        vec3 cameraPosition = vec3( 2.*vieteri,-2.*vieteri,-0.2-iTime*0.3);\n        vec3 direction = normalize( vec3(.5 * uv * vec2( aspect, 1.0), 0.6) );\n        direction *= rotationMatrix(vec3(1.0,0.0,0.0),.2-iTime/100.);\n        direction *= rotationMatrix(vec3(0.0,1.0,0.0), 0.2-iTime/100.);\n        direction *= rotationMatrix(vec3(0.0,0.0,1.0), 0.06);\n        direction.z *= -1.0;\n    \n        vec4 color = march( cameraPosition, direction);\n\n        return color;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n lightSource = vec3(0.0,0.,-99.0-iTime*2.);\n     vec2 p = gl_FragCoord.xy / iResolution.xy;\n     vec2 uv = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n     float aspect = iResolution.x / iResolution.y;\n    \tfloat skip = texture(iChannel0,p).w ;\n    if(length(uv.y)*2.>aspect ) {\n\t\tfragColor =  vec4(0.,0.,0.,1.);\n    } else {\n        vec4 C=render( uv );\n\t\tfragColor =  vec4(C.rgb,C.w/4.);\n    }\n}\n\t","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float co){\n    return rand(vec2(co));\n}\nvec3 blur(sampler2D t, vec2 pos, float blur){\n    vec3 c = vec3(0);\n   \n        for(float i=0.; i<20.; i++) {\n            c.rgb += \n                texture(\n                    t,\n                    pos+\n                    vec2(\n                        sin(3.141591*2.*i/20.),\n                        cos(3.141591*2.*i/20.)) * blur).rgb ;\n        }\n    \tc.rgb /= 20.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;     \n    float aspect = iResolution.x / iResolution.y;\n\n     vec2 p = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n    \n\tvec2 j = vec2(1.,0.)/ iResolution.xy;\n\tvec2 k = vec2(0.,1.)/ iResolution.xy;\n    \n    if(length(p.y)*2.>aspect ) {\n        fragColor =  vec4(0.,0.,0.,0.);\n    }else if(texture(iChannel0,uv).w<0.) {\n        \n        vec4 d = vec4(0.,0.,0.,-texture(iChannel0,uv).w)*4.;\n        for(float i=1.;i<8.;i++) {\n            d.rgb+=blur(iChannel0, uv, .001*i);\n        }\n        d/=7.;\n        d.a = d.a*0.9 + texture(iChannel1,uv).a*0.2;\n        d.rgb = d.rgb*0.3 + texture(iChannel0,uv).rgb*0.3 + texture(iChannel1,uv).rgb*0.4;\n        fragColor = vec4(d)+vec4(vec3(0.8,0.9,0.99) * 6.2 *(d.a * d.a),0.0);\n    }else{\n        vec4 d = texture(iChannel0,uv);\n        d.a = d.a*0.9 + texture(iChannel1,uv).a*0.2;\n        d.rgb = d.rgb*0.4 + texture(iChannel1,uv).rgb*0.6;\n    \td.rgb = max(d.rgb,vec3(0.));\n        if(length(p.y)*2.>aspect ) {\n            fragColor =  vec4(0.,0.,0.,0.);\n        }else if(texture(iChannel0,uv).w==0.)\n            fragColor=vec4(0.,0.,0.,1.);\n        else\n            fragColor = vec4(d)+vec4(vec3(0.8,0.9,0.99) * 6.2 *(d.a * d.a),0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float co){\n    return rand(vec2(co));\n}\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\nvec2 c(vec2 uv){\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\nvec3 boxblur(sampler2D t, vec2 pos, float blur){\n    vec3 c = vec3(0);\n    float it = 0.0;\n    for(float i = 0.0; i < 40.0; i++){\n        vec2 rval;\n        rval.x = blur * rand(vec2(0.002345*iTime+pos.x, float(i)+pos.y)) - blur / 2.0;\n        rval.y = blur * rand(vec2(pos.x + float(i), pos.y+0.007615*iTime)) - blur / 2.0;\n        c += texture(t, pos + 0.25*rval*vec2(1.0/iResolution.x, 1.0/iResolution.y)).rgb;\n        it += 1.0;\n    }\n    return c/it;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n     vec2 p = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    \tfloat T=iTime*0.2;\n\tvec2 j = vec2(3.,0.)/ iResolution.xy;\n\tvec2 k = vec2(0.,3.)/ iResolution.xy;\n    uv=c(uv);\n    vec4 C = vec4( 0., 0., 0., 1.);\n    if(uv.x<0. || uv.x>1.) {\n    \tC = vec4(.0,.0,.0,1.0);\n    } else {\n        float dist = \n            texture(iChannel0,uv).w +\n            texture(iChannel0,uv+j).w +\n            texture(iChannel0,uv+k).w +\n            texture(iChannel0,uv-j).w +\n            texture(iChannel0,uv-k).w;\n        dist /= 5.;\n        dist = 0.04*dist*dist*dist*dist + 1./(1.+dist*64000.);\n        for(float i=0.; i<80.; i++) {\n            C.rgb += \n                texture(\n                    iChannel0,\n                    uv+\n                    vec2(\n                        sin(3.141591*2.*i/80.),\n                        cos(3.141591*2.*i/80.)) *dist / (1.+T*.6)).rgb ;\n        }\n    \tC.rgb /= 80.;\n        C.rgb = 2.*C.rgb/3. + boxblur(iChannel0, uv, dist*4000.)/3.;\n    }\n    \tC.rgb += vec3(floor(max( mod(uv.x*320.,32.)-30.,0.)))*length(p.y)*length(p.y)*length(p.y)/12.;\n        //C.rgb = tone(C.rgb,2.1);\n    \t//C.rgb-=vec3(.1);\n    \tC.rgb *= 1.-pow(length(p.x),8.);\n    \tC.rgb *= 1.-pow(length(p.y),8.);\n        //C.rgb=max(C.rgb,vec3(.08,.105,.09));\n    \tC.w=1.;\n    \tfragColor = C;\n}","name":"Buffer C","description":"","type":"buffer"}]}