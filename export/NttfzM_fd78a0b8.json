{"ver":"0.1","info":{"id":"NttfzM","date":"1662949237","viewed":51,"name":"something is wrong with the mous","username":"jdubjwub","description":"hw1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(c, 0.0, -s,0.0, 1.0, 0.0,s, 0.0, c\n    );\n}\n    \nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 boxPos = vec3(0,9,1);\nvec3 spherePos[3] = vec3[3](vec3(8,8,100),vec3(-8,8,100), vec3(0,1,10));\n\nbool testScenePos(vec3 eye, vec3 dir, out vec3 outPos){\n    float t = 0.0;\n    for( int i = 0; i < 350; i++){\n        //calc positions from view rays\n        vec3 pos = eye + dir * t;\n        \n        //get distance from positions to spheres\n        //float dist = min(sdSphere(pos, 5.0f), sdSphere(pos-vec3(4,0,0), 3.0f));\n        float dist = min(\n                        sdRoundBox(pos + boxPos, vec3(0.001, 3.0, 0.0), 4.0f),\n                        min(\n                            sdSphere(pos-vec3(-8,8,100), 5.0f),\n                            min(\n                               sdSphere(pos-vec3(8,8,100), 5.0f), \n                               sdSphere(pos-vec3(0,1,10), 5.0f)\n                            )\n                         )\n                      );\n        //check if ray HIT\n        if(dist < 0.001){\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n}\n\nbool testSceneRotater(vec3 eye, vec3 dir, out vec3 outPos){\n    float t = 0.0;\n    for( int i = 0; i < 60; i++){\n        //calc positions from view rays\n        vec3 pos = eye + dir * t;\n        \n        //get distance from positions to spheres\n        //float dist = min(sdSphere(pos, 5.0f), sdSphere(pos-vec3(4,0,0), 3.0f));\n        float dist = min(sdBoxFrame(rotateY(iTime)*(pos-vec3(5.0,8.0,0.0)), vec3(3.0,1.0,3.0), 0.3),\n                         sdBoxFrame(rotateY(iTime)*(pos-vec3(-5.0,8.0,0.0)), vec3(3.0,1.0,3.0), 0.3));\n      \n          //check if ray HIT\n        if(dist < 0.001){\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //set background color by combining tan, sin, & cos waves\n    vec3 col;\n    float lineWidth = 0.05;\n    float amplitude = sin(iTime)*0.3;\n    float y = tan(uv.x*35.0+iTime*1.5)*amplitude+0.3;\n    if(uv.y > y-lineWidth && uv.y < y+lineWidth) {\n        col = vec3(0.5, 0.5, 0.5) + cos(vec3(sin(0.5) + iTime, cos(0.5) * iTime, tan(0.5) * iTime));\n    }\n    y = cos(uv.x*35.0+iTime*1.5)*amplitude+0.5;\n    if(uv.y > y-lineWidth && uv.y < y+lineWidth) {\n        col = vec3(0.5, 0.5, 0.5) + cos(vec3(sin(0.5) - iTime, cos(0.5) * iTime, tan(0.5) * iTime));\n    }\n    y = sin(uv.x*35.0+iTime*1.5)*amplitude+0.5;\n    if(uv.y > y-lineWidth && uv.y < y+lineWidth) {\n        col = vec3(0.5, 0.5, 0.5) + cos(vec3(sin(0.5) * iTime, cos(0.5) * iTime, tan(0.5) * iTime));\n    }\n    \n    // uncompress shape\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 normal =vec3(0,0,1);\n    \n    vec3 pos, posdy, posdx;\n    \n    // for circles\n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, 5));\n    vec3 eye = vec3(0, 3.0, -100);\n        \n    if(testScenePos(eye, dir, pos) &&\n        testScenePos(eye, dirdx, posdx) &&\n        testScenePos(eye, dirdy, posdy)\n        ){\n\n            //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n\n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n\n            normal = cross(CA, BA);\n\n            //a fixed light from the direction of the camera\n            vec3 lightDir = vec3(0,0.4,1);\n\n            col = vec3(0.3)*dot(-lightDir,normal);\n\n            // color shape;\n            col += vec3(1.0, 0.0, 0.0);\n\n            // fractal pattern inspired from https://www.shadertoy.com/view/NlVcWh\n            float angle = 0.2 *iTime * 0.3;\n            vec2 normals = fragCoord / iResolution.xy*2.0-1.0;\n\n            for(float i = 0.0; i < 64.0; i += 1.0) {\n                normals = abs(normals);\n                normals -= 0.5;\n                normals *= 1.1;\n                normals *= mat2(\n                    cos(angle), -sin(angle),\n                    sin(angle), cos(angle)\n                );\n            }\n            col *= vec3(\n                length(normals),\n                length(normals +vec2(-0.2,0.4)),\n                length(normals +vec2(-0.1,-0.5)));\n      }\n      \n      if(testSceneRotater(eye, dir, pos) &&\n        testSceneRotater(eye, dirdx, posdx) &&\n        testSceneRotater(eye, dirdy, posdy)) {\n            //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n\n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n\n            normal = cross(CA, BA);\n\n            //a fixed light from the direction of the camera\n            vec3 lightDir = vec3(0,0.4,1);\n\n            col = vec3(0.3)*dot(-lightDir,normal);\n\n            // color shape\n            vec3 color = vec3(0.0);\n            float pct = abs(sin(iTime));\n            col += mix(vec3(2.0,0.6,0.9), vec3(-2.0,0.7,0.34), pct);\n\n            // add patterns to ears\n            float r = (step(0.1, sin(uv.x * 89.0 + iTime * 5.0)) + step(0.3, sin(uv.x * 21.0)));\n\n            col *= vec3(sin(r),cos(r),tan(r));\n            \n      }\n    \n    // generated noise pattern \n    col *= tan(vec3(cos(texture(iChannel0, fract(uv+tan(iTime)))).rrr));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}