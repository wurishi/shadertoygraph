{"ver":"0.1","info":{"id":"NtKfzm","date":"1664270325","viewed":266,"name":"Triangle & Rect at Tile Base","username":"volkovino","description":"Self Teaching Material 01 - UV Tiling, Triangle, Rectangle, Shape, Scale, Rotation, Noise\nGodot Shader on a full black sprite. \nThen converted into Shadertoy with small changes. Deformed Structure (from 75x75 to 800 x 450) intentionally left for 3D fake.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","triangle","antialiasing","rectangle","rotation","scale","shape","godot","uvtiling","colorchanges"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based of 2 Shaders below + SCALING + WOBBLING + DIFF. Rotational SPEEDS + NOISE\n// Many Spinning Mono Star-Flowers\n// https://www.shadertoy.com/view/3dsSWN\n// Spinning Rubber Gold Star\n// https://www.shadertoy.com/view/wdlSW4\n//\n\nconst float TWO_PI = 6.28318530718;\n\n// Helper Functions for Perlin Noise\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n// Helper Functions for Simplex Noise\nvec3 mod289S(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289_A(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permuteS(vec3 x) { return mod289S(((x*34.0)+1.0)*x); }\n// Classic Perlin noise\nfloat classicPerlin(vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n    }\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\nfloat simplex(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289_A(i);\n    vec3 p = permuteS(\n            permuteS( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n    m = m*m ;\n    m = m*m ;\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n    }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n    }\nfloat smoothedge(float v, float res) {\n\treturn smoothstep(0.0, res, v);\n    }\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s), vec2(s, c));\n\treturn m * v;\n    }\nfloat rect(vec2 p, vec2 size, vec2 uvMain, float coef) {\n\tp -= 0.5;\n\tuvMain = uvMain * coef + 1.0;\n\tfloat uvMainF = sqrt(floor(uvMain.x) + floor(uvMain.y));\n\tp = rotate(p, uvMainF * (cos(TWO_PI * abs(fract(iTime / 10. - 0.5))) - 2.0)) ;\n\tvec2 d = abs(p) - size * 0.25 * (sin(iTime) + 2.0) * uvMainF;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n    }\nfloat triangle(vec2 p, float size, vec2 uvMain, float coef) {\n\tp -= 0.5;\n\tuvMain = uvMain * coef + 1.0;\n\tfloat uvMainF = sqrt(floor(uvMain.x) + floor(uvMain.y));\n\tp = rotate(p, uvMainF * (cos(TWO_PI * abs(fract(iTime / 20. - 0.5))) - 1.0)) ;\n    vec2 q = abs(p) - size * 0.25 * (sin(iTime) + 2.0) * uvMainF;\n    return max(q.x * 0.866025 + p.y * 0.5, -p.y * 0.5) - size * 0.5;\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uvMain = fragCoord/iResolution.xy;\n    uvMain.x *= iResolution.x/iResolution.y;\n    float fraction = 5.0;\n    uvMain.x -= 1. / fraction;\n\tvec2 uvFraction = fract(uvMain * fraction) + 0.5;\n\tfloat d = 0.09;\n\td = min(d, rect(uvFraction - vec2(0.5, 0.5), vec2(0.15, .10), uvMain, fraction));\n//\td = min(d, triangle(uvFraction - vec2(0.5, 0.5), 0.09, uvMain, fraction));\n\tfloat colorF = smoothedge(d, 1.0 / iResolution.x);\n\tfloat hsbRG = hsb2rgb(vec3(ceil((1.0 - uvMain.x) * fraction)) / fraction).r;\n\tvec2 hsbB = hsb2rgb(vec3(ceil((1.0 - uvMain.y) * fraction)) / fraction).gb;\n\tvec3 color = vec3(1.0 - colorF) \n\t\t\t\t\t\t* vec3(hsbRG, hsbB) * (classicPerlin(uvMain * cos(iTime*1.)) + .5);\n\t\n\td = triangle(uvFraction - vec2(0.5, 0.5), 0.09, (1. - uvMain), fraction);\n\tcolorF = smoothedge(d, 1.0 / iResolution.x);\n\thsbRG = hsb2rgb(vec3(ceil((uvMain.x) * fraction)) / fraction).r;\n\thsbB = hsb2rgb(vec3(ceil((uvMain.y) * fraction)) / fraction).gb;\n\tcolor += vec3(1.0 - colorF)\n\t\t\t\t\t\t* vec3(hsbRG, hsbB) * (simplex(uvMain * sin(iTime*1.)) + .5);\n\t\t\t\t\t\t\n\tfragColor = vec4(color * 1.5, 1.0);\t\n}\n","name":"Image","description":"","type":"image"}]}