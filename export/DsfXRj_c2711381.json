{"ver":"0.1","info":{"id":"DsfXRj","date":"1669169131","viewed":85,"name":"Cosine, Sine, Exp Mandelbrots","username":"PhDFractal","description":"Absolute vs. Julia Set comparison for the Cosine, Sine, and Exponential Mandelbrots. Maps: zâ†¦cÃ—cos(z), zâ†¦cÃ—sin(z), zâ†¦c+exp(z). Press 'o' for original fractal and 'm' for mode. This is probably my last Shader for now. ðŸ‘‹","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot","juliaset","special","comparison"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Cosine, Sine, and Exponential Mandelbrots Comparison\n//\n// Comparison of Absolute vs. Julia Set of the Cosine, Sine, and Exp Mandelbrots.\n//\n// Created by PhdFractal, 8/11/2022\n//\n// Drag mouse on the screen to change the Julia seed.\n//\n// Press 'o' to see the original fractal. Observe that the location and seed are\n// already synchronized.\n//\n// Press 'm' to switch mode: Cosine, Sine, and Exponential Mandelbrots.\n//\n// Location in the Exponential Mandelbrot: (-0.986,0.0005) with 1000Ã— magnification.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nvec2 times(vec2 z1,vec2 z2){ return vec2(z1.x*z2.x-z1.y*z2.y,z1.x*z2.y+z1.y*z2.x); } //times\nvec2 cosine(vec2 z){ return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y)); }          //complex cosine\nvec2 sine(vec2 z){ return vec2(sinh(z.y)*cos(z.x),-cosh(z.y)*sin(z.x)); }            //complex sine\nvec2 expon(vec2 z){ return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y)); }              //complex exp\nfloat pi=3.14159265359;                                                              //Ï€\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }    //for switching modes\nvec4 store(int i,int j) { return texelFetch(iChannel1,ivec2(i,j),0); }               //for counting presses\nint keycount(int key) { return int(store(0,key).x); }\n//from Wythoffian Tiling Generator: https://www.shadertoy.com/view/wlGSWc\nvec4 rainbow(int i,float density){                       //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    int r=int(float(i)*density+5.)%100;\n    if(r<16){ float R=float(r)/16.; return mix(black,red,R); }\n    else if(r>=16 && r<31){ float R=float(r-16)/15.; return mix(red,yellow,R); }\n    else if(r>=31 && r<45){ float R=float(r-31)/14.; return mix(yellow,green,R); }\n    else if(r>=45 && r<62){ float R=float(r-45)/17.; return mix(green,cyan,R); }\n    else if(r>=62 && r<78){ float R=float(r-62)/16.; return mix(cyan,blue,R); }\n    else{ float R=float(r-78)/22.; return mix(blue,black,R); }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 c=vec2(0.,0.);                //Seed initialized to (0,0).\n    bool isOriginal=keypress(79);      //Press key 'o' for original\n    int mode = keycount(77)%3;         //Press key 'm' to switch modes\n    vec4 color=vec4(0.,0.,0.,1.);\n    \n    if(mode==0){                       //COSINE mode\n        vec2 z0=vec2(0.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n        if(isOriginal){                //original cosine mandelbrot\n            for(int i=0; i<250; i++){\n                vec2 z=times(cosine(z0),vec2(2.5,0.)+pix*10.);\n                if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                else{ z0=z; } } }\n        else{                          //cosine comparison\n            c=vec2(2.5,0.)+10.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x;\n            if(pix.x<=0.){             //absolute cosine\n                for(int i=0; i<250; i++){\n                    vec2 z=times(times(cosine(z0),cosine((pix+vec2(0.25,0.))*4.*pi)),c);\n                    if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                    else{ z0=z; } } }\n            else{                      //julia cosine\n                z0=(pix-vec2(0.25,0))*4.*pi;\n                for(int i=0; i<250; i++){\n                    vec2 z=times(cosine(z0),c);\n                    if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                    else{ z0=z; } } } } }\n    else if(mode==1){                  //SINE mode\n        vec2 z0=vec2(pi/2.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n        if(isOriginal){                //original sine mandelbrot\n            for(int i=0; i<250; i++){\n                vec2 z=times(sine(z0),times(vec2(2.5,0.)+pix*10.,vec2(0,1)));\n                if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                else{ z0=z; } } }\n        else{                          //sine comparison\n            c=vec2(2.5,0.)+10.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x;\n            if(pix.x<=0.){             //absolute sine\n                for(int i=0; i<250; i++){\n                    vec2 z=times(times(sine(z0),sine((pix+vec2(0.25,0.))*4.*pi)),c);\n                    if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                    else{ z0=z; } } }\n            else{                      //julia sine\n                z0=(pix-vec2(0.25,0))*4.*pi;\n                for(int i=0; i<250; i++){\n                    vec2 z=times(times(sine(z0),c),vec2(0,1));\n                    if(dot(z,z)>7e3){ color=rainbow(i,2.); break; }\n                    else{ z0=z; } } } } }\n    else{                              //EXP mode\n        vec2 z0=vec2(-1e7,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n        if(isOriginal){                //original exp mandelbrot\n            for(int i=0; i<1000; i++){\n                vec2 z=expon(z0)+vec2(-0.986,0.0005)+0.0013*pix;\n                if(dot(z,z)>1e10){ color=rainbow(i,2.7); break; }\n                else{ z0=z; } } }\n        else{                          //exp comparison\n            c=vec2(-0.986,0.0005)+0.0013*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x;\n            if(pix.x<=0.){             //absolute exp\n                for(int i=0; i<1000; i++){\n                    vec2 z=expon(z0)+expon(5.3333333*pi*(pix-vec2(0.3,0.)))+c; //SHIFTED for Abs Julia\n                    if(dot(z,z)>1e10){ color=rainbow(i,2.7); break; }\n                    else{ z0=z; } } }\n            else{                      //julia exp\n                z0=5.3333333*pi*(pix-0.35);\n                for(int i=0; i<1000; i++){\n                    vec2 z=expon(z0)+c;\n                    if(dot(z,z)>1e10){ color=rainbow(i,2.7); break; }\n                    else{ z0=z; } } } } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keystate(k,n) (texelFetch(iChannel0,ivec2(k,n),0))\nvoid mainImage(out vec4 t,vec2 uv){\n#if __VERSION__ < 300\n    t = vec4(0);\n#else    \n    int i=int(uv.x); int j=int(uv.y);\n    if(iFrame==0) { t=vec4(0); }\n    else{ t=texelFetch(iChannel1,ivec2(i,j),0); } //Get current state\n    if(i==0){ float w1 = keystate(j,2).x;\n        if (w1!=t.w) { t.w=w1; t.x++; } }\n#endif           \n}","name":"Buffer A","description":"","type":"buffer"}]}