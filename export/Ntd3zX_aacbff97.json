{"ver":"0.1","info":{"id":"Ntd3zX","date":"1642609284","viewed":163,"name":"Voxel Raymarching(partly broken)","username":"dan_fishlicka","description":"Tried to make a simple voxel raymarcher but it creates some weird background artifacts.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXDIST 10.\n#define MAXSTEP 200\n#define SURF 0.01\n#define SCALE 2.\n#define pi 3.141592\n#define SINSCALE 12.\n\n//Try to get some voxels working\\\n//simplex noise\nmat2 Rot(float b)\n{\n    float s = sin(b);\n    float c = cos(b);\n    return mat2(c,-s,s,c);\n}\nvec2 RotPoint(float a, vec2 p, vec2 ce) {\n    float s = sin(a); // angle is in radians\n    float c = cos(a); // angle is in radians\n    \n    p-=ce;\n\n    float xnew = p.x * c + p.y * s;\n    float ynew = -p.x * s + p.y * c;\n    \n    p = vec2(xnew,ynew) + ce;\n    return p;\n}\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 toData(vec3 p,float scale) { // blockify\n    return vec3(floor(p.x*scale)/scale,floor(p.y*scale)/scale,floor(p.z*scale)/scale);\n}\nfloat cube(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat torus( vec3 p, vec2 s )\n{\n  vec2 e = vec2(length(p.xz)-s.x,p.y);\n  return length(e)-s.y;\n}\nfloat GetVOXEL(vec3 r) { //GetDist but voxelizes everything\n    vec3 p = toData(r,floor(abs(sin(iTime/5.))*SINSCALE+2.));\n    //vec3 cu = p-vec3(0.,1.,3.);\n    vec3 sp = vec3(0.,1.,5.);\n\n    vec3 torP = p-sp;\n    torP.yz*=Rot(iTime); // S P I N\n    float sphereDist = sphere(p-sp,1.);\n    float torDist = torus(torP,vec2(2.,0.3));\n    \n    float holeDisZ = sphere(p-sp-vec3(0.,0.,abs(sin(iTime*1.5))), .5);\n    float holeDisZ2 = sphere(p-sp-vec3(0.,0.,-1.*abs(sin(iTime*1.5))), .5);\n    float holeDisX = sphere(p-sp-vec3(abs(sin(iTime*1.5)),0.,0.), .5);\n    float holeDisX2 = sphere(p-sp-vec3(-1.*abs(sin(iTime*1.5)),0.,0.), .5);\n    \n    //float cubeDist = cube(cu,vec3(.5,.5,.5));\n    \n    float flor = (p.y+2.)+noise(p.xz*0.1);\n    \n    float d = max(sphereDist,-holeDisZ);\n    d=max(d,-holeDisZ2);\n    d=max(d,-holeDisX);\n    d=max(d,-holeDisX2);\n    d= min(d,torDist);\n    return d/length(r);\n}\nfloat GetDist(vec3 p) {\n    vec3 sp = vec3(0.,1.,5.);\n\n    vec3 torP = p-sp;\n    torP.yz*=Rot(iTime); // S P I N\n    float sphereDist = sphere(p-sp,1.);\n    float torDist = torus(torP,vec2(2.,0.3));\n    \n    float holeDisZ = sphere(p-sp-vec3(0.,0.,abs(sin(iTime*1.5))), .5);\n    float holeDisZ2 = sphere(p-sp-vec3(0.,0.,-1.*abs(sin(iTime*1.5))), .5);\n    float holeDisX = sphere(p-sp-vec3(abs(sin(iTime*1.5)),0.,0.), .5);\n    float holeDisX2 = sphere(p-sp-vec3(-1.*abs(sin(iTime*1.5)),0.,0.), .5);\n    \n    //float cubeDist = cube(cu,vec3(.5,.5,.5));\n    \n    float flor = (p.y+2.)+noise(p.xz*0.1);\n    \n    float d = max(sphereDist,-holeDisZ);\n    d=max(d,-holeDisZ2);\n    d=max(d,-holeDisX);\n    d=max(d,-holeDisX2);\n    d= min(d,torDist);\n    return d;\n}\n\nfloat _GetDist(vec3 p) {\n    float d = noise(p.xz);\n    return p.y-1.;\n}\nvec3 GetNormal(vec3 p) {\n    p=toData(p,floor(abs(sin(iTime/5.))*5.+2.));\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat Raymarch(vec3 ro, vec3 rd) {\n    float dO = 0.; //Distance from origin\n    float dO2 = 0.;\n    int i = 0;\n    float iit =float(MAXSTEP-1);\n    float t;\n    float dirDiff = length(rd.xz*Rot(-iTime)-rd.xz);\n    if(dirDiff < 0.) dirDiff+=pi*2.;\n    if(dirDiff >2.*pi) dirDiff-=pi*2.;\n    do\n    {\n        vec3 p = ro+rd*dO;\n        //p = toData(p,SCALE);\n        t = GetVOXEL(p); //Get distance from origin to p\n        dO+=t; //dO adds that\n        if(dO>MAXDIST) { iit = float(i);break; }\n        i++;\n    }while(i<MAXSTEP);\n    return dO;//iit/float(MAXSTEP);  \n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, -5);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = Raymarch(p+n*SURF*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0,1.,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    ro.xz = RotPoint(iTime,ro.xz,vec2(0.,5.));\n    rd.xz*=Rot(-iTime);\n    \n    float d = Raymarch(ro,rd);\n    vec3 n = GetNormal(ro+rd*d);\n    float l = GetLight(ro+rd*d);\n    \n    float dif = dot(n, normalize(vec3(-2,2,-1)))*.5+.5;\n    // Output to screen\n    //fragColor = vec4(vec3(n.x,n.y,n.z),1.0)\n    vec3 color = abs(n)*dif;\n    if(d> MAXDIST) color = vec3(0.);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}