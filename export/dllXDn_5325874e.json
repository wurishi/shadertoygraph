{"ver":"0.1","info":{"id":"dllXDn","date":"1674605464","viewed":87,"name":"Simple Shape and Graph","username":"bagidea","description":"Tutorial 2D Shape and Graph","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","basic","graph","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    ///////// Gradient Background /////////\n    \n    uv += 0.5;\n    vec3 col = mix(vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), uv.y) * 0.5;\n    uv -= 0.5;\n    \n    ///////////////////////////////////////\n    \n    // SDF =  signed distance functions\n    \n    /////////////// Circle ////////////////\n    \n    // Shape = x^2 + y^2 - r^2 = 0\n    // Position = (x - offsetX)^2 + (y - offsetY)^2 - r^2 = 0\n    \n                               // position-offsetX               position-offsetY\n    float d1 = length(vec2(uv.x - sin(iTime * 5.0) * 0.5, uv.y - cos(iTime) * 0.2)) - 0.2; // <- radian\n    vec3 o1 = d1 > 0.0 ? vec3(1.0) : 0.5 + 0.5 * cos(iTime + uv.xyx + (vec3(uv, 0) * 5.0));\n    \n    ///////////////////////////////////////\n    \n    // Start symmetrical\n    uv.x = abs(uv.x); // symmetrical X\n    uv.y = abs(uv.y); // symmetrical Y\n    \n    vec2 c = vec2(0.2, 0.2);\n    uv = mod(uv + 0.5 * c, c);\n    \n    uv.x -= 0.1;\n    uv.y -= 0.1;\n    \n    /////////////// Square ////////////////\n    \n    // Shape = max(abs(x), abs(y)) - r^ = 0\n    // Position = max(abs(x - offsetX), abs(y - offsetY)) - r^ = 0\n    // Rotation = max(abs(mat2(cos(t) - sin(t)) * uv), abs(mat2(sin(t) + cos(t)) * uv)) - r^ = 0\n    \n    \n    vec2 rotation = mat2(cos(-iTime * 2.0), sin(-iTime * 2.0), -sin(-iTime * 2.0), cos(-iTime * 2.0)) * uv;\n    \n    float d2 = max(                   // position offset\n                   abs(rotation.x + sin(iTime * 3.0) * 0.05),\n                   abs(rotation.y + cos(iTime * 3.0) * 0.01)\n               ) - 0.05; // <- size         speed ^      ^ move-range\n               \n    vec3 o2 = d2 > 0.0 ? vec3(1.0) : 0.5 + 0.5 * cos(iTime + uv.xyx + (vec3(uv, 0) * 5.0));\n    \n    ///////////////////////////////////////\n\n    \n    // Mix SDF al\n    col = mix(o2, col, step(1.0, o2));\n    col = mix(o1, col, step(1.0, o1));\n    \n    //Render out\n    fragColor = vec4(col, 1.0);\n}\n\n/*\n    Combination 2D SDF Operations\n    \n    // d1 = sdf1\n    // d2 = sdf2\n    \n    float res; // result\n    \n    res = min(d1, d2); // union  \n    res = max(d1, d2); // intersection\n    res = max(-d1, d2); // subtraction - subtract d1 from d2\n    res = max(d1, -d2); // subtraction - subtract d2 from d1\n    res = max(min(d1, d2), -max(d1, d2)); // xor\n    \n    // smooth min (k = smooth value)\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    res = mix(d2, d1, h) - k * h * (1.0 - h); // union smoothly blend\n    \n    // smooth max (k = smooth value)\n    res = -smin(-d1, -d2, k); // smooth intersection\n    \n    res = step(0., res); // Same as res > 0. ? 1. : 0.;\n*/","name":"Image","description":"","type":"image"}]}