{"ver":"0.1","info":{"id":"WtlBR4","date":"1596163838","viewed":81,"name":"dodeca (wip)","username":"CoolerZ","description":"Trying to construct the distance function to a dodecahedron.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .01\n#define MAX_ITERS 100\n\nconst float PI = radians(180.);\nconst float PI2 = 2.*PI;\n\nvec2 rot2d(vec2 p, float angle)\n{\n    mat2 r = mat2(\n        cos(angle), sin(angle), // first column\n        -sin(angle), cos(angle) // second column\n    );\n    return r*p;\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    vec3 o = dot(p, axis)*axis;\n    vec3 x = normalize(p-o);\n    vec3 y = normalize(cross(-axis, x));\n    float r = length(p-o);\n    return o + r*cos(angle)*x + r*sin(angle)*y;\n}\n\nfloat line_d(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat line_d(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat thick_line_d(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba)-r;\n}\n\nfloat point_d(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat ngon_d(vec2 p, int n, float r)\n{\n    float delta = PI2/float(n);\n    float d = 10000.0;\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        d = min(d, line_d(p, v1, v2));\n\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)sig = 1.;\n    }\n    return sig*d;\n}\n\nfloat ngon_d(vec3 pos, int n, float r)\n{\n    vec2 p = pos.xy;\n    float delta = PI2/float(n);\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)\n        {\n            sig = 1.;\n            break;\n        }\n    }\n    if(sig<0.)return abs(pos.z);\n    float d = 10000.0;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec3 v1 = vec3(r*cos(a1), r*sin(a1), 0.);\n        vec3 v2 = vec3(r*cos(a2), r*sin(a2), 0.);\n        d = min(d, line_d(pos, v1, v2));\n    }\n    return d;\n}\n\nfloat vertex_d(vec3 p, vec3 pos)\n{\n    const float vertex_size = .1;\n    return length(p-pos)-vertex_size;\n}\n\nfloat dodeca_old(vec3 p, float radius)\n{\n    // https://en.wikipedia.org/wiki/Pentagon\n    // https://en.wikipedia.org/wiki/Regular_dodecahedron\n    const float C1 = 4./(sqrt(3.)*(1.+sqrt(5.)));\n    const float C2 = .5*sqrt(2.5+1.1*sqrt(5.));\n    const float C3 = sqrt(2./(5.-sqrt(5.)));\n    const float C4 = .5*sqrt(5.+2.*sqrt(5.));\n    const float dihedral_angle = radians(116.57);\n    float edge_len = radius*C1;\n    float ri = edge_len*C2; // radius of the inscribed sphere.\n    float d = 10000.0;\n    vec3 bot_center = ri*vec3(0,-1,0);\n    float pent_rad = edge_len*C3;\n    float delta_angle = PI2/5.;\n    const float line_thickness = .05;\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        float a2 = float(i+1)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    float pent_height = edge_len*C4;\n    float small_height = pent_height*sin(dihedral_angle);\n    float dodeca_height = 2.*ri;\n    float smaller_height = dodeca_height - small_height;\n    float low_height = (ri-smaller_height);\n    vec3 low_center = low_height*vec3(0,-1,0);\n    float low_rad = radius*cos(asin(low_height/radius));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n\n    // top half\n    //const float offset_angle = 0.;\n    const float offset_angle = PI2/10.;\n    //float offset_angle = mix(0., PI2/10.,.5+.5*sin(iTime));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        float a2 = offset_angle+float(i+1)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n\n        // join both halves with edges\n        float a3 = float(i)*delta_angle;\n        vec3 v3 = low_center + low_rad*cos(a3)*vec3(1,0,0) + low_rad*sin(a3)*vec3(0,0,1);\n        d = min(d, line_d(p, v2, v3)-line_thickness);\n        float a4 = offset_angle+float(i-1)*delta_angle;\n        vec3 v4 = -low_center + low_rad*cos(a4)*vec3(1,0,0) + low_rad*sin(a4)*vec3(0,0,1);\n        d = min(d, line_d(p, v3, v4)-line_thickness);\n    }\n\n\n    return d;\n}\n\nfloat plane_d(vec3 p, vec3 norm)\n{\n    return dot(p, norm);\n}\n\nfloat dodeca(vec3 p, float radius)\n{\n    vec3[] verts = vec3[](\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.)\n    );\n    // https://en.wikipedia.org/wiki/Pentagon\n    // https://en.wikipedia.org/wiki/Regular_dodecahedron\n    const float C1 = 4./(sqrt(3.)*(1.+sqrt(5.)));\n    const float C2 = .5*sqrt(2.5+1.1*sqrt(5.));\n    const float C3 = sqrt(2./(5.-sqrt(5.)));\n    const float C4 = .5*sqrt(5.+2.*sqrt(5.));\n    const float dihedral_angle = radians(116.57);\n    float edge_len = radius*C1;\n    float ri = edge_len*C2; // radius of the inscribed sphere.\n    float d = 10000.0;\n    vec3 bot_center = ri*vec3(0,-1,0);\n    float pent_rad = edge_len*C3;\n    float delta_angle = PI2/5.;\n    const float line_thickness = .05;\n    int index = 0;\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        float a2 = float(i+1)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    float pent_height = edge_len*C4;\n    float small_height = pent_height*sin(dihedral_angle);\n    float dodeca_height = 2.*ri;\n    float smaller_height = dodeca_height - small_height;\n    float low_height = (ri-smaller_height);\n    vec3 low_center = low_height*vec3(0,-1,0);\n    float low_rad = radius*cos(asin(low_height/radius));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n\n    // top half\n    //const float offset_angle = 0.;\n    const float offset_angle = PI2/10.;\n    //float offset_angle = mix(0., PI2/10.,.5+.5*sin(iTime));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        float a2 = offset_angle+float(i+1)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n\n        // join both halves with edges\n        float a3 = float(i)*delta_angle;\n        vec3 v3 = low_center + low_rad*cos(a3)*vec3(1,0,0) + low_rad*sin(a3)*vec3(0,0,1);\n        d = min(d, line_d(p, v2, v3)-line_thickness);\n        float a4 = offset_angle+float(i-1)*delta_angle;\n        vec3 v4 = -low_center + low_rad*cos(a4)*vec3(1,0,0) + low_rad*sin(a4)*vec3(0,0,1);\n        d = min(d, line_d(p, v3, v4)-line_thickness);\n    }\n\n    vec3 mid1 = .2*(verts[0]+verts[1]+verts[2]+verts[3]+verts[4]);\n    vec3 mid2 = .2*(verts[10]+verts[11]+verts[12]+verts[13]+verts[14]);\n\n    vec3 mid3 = .2*(verts[0]+verts[1]+verts[5]+verts[15]+verts[6]);\n    vec3 mid4 = .2*(verts[1]+verts[2]+verts[6]+verts[16]+verts[7]);\n    vec3 mid5 = .2*(verts[2]+verts[3]+verts[7]+verts[17]+verts[8]);\n    vec3 mid6 = .2*(verts[3]+verts[4]+verts[8]+verts[18]+verts[9]);\n    vec3 mid7 = .2*(verts[4]+verts[0]+verts[9]+verts[19]+verts[5]);\n\n    vec3 mid8  = .2*(verts[10]+verts[11]+verts[15]+verts[6]+verts[16]);\n    vec3 mid9  = .2*(verts[11]+verts[12]+verts[16]+verts[7]+verts[17]);\n    vec3 mid10 = .2*(verts[12]+verts[13]+verts[17]+verts[8]+verts[18]);\n    vec3 mid11 = .2*(verts[13]+verts[14]+verts[18]+verts[9]+verts[19]);\n    vec3 mid12 = .2*(verts[14]+verts[10]+verts[19]+verts[5]+verts[15]);\n\n    d = min(d, vertex_d(p, mid1));\n    d = min(d, vertex_d(p, mid2));\n    d = min(d, vertex_d(p, mid3));\n    d = min(d, vertex_d(p, mid4));\n    d = min(d, vertex_d(p, mid5));\n    d = min(d, vertex_d(p, mid6));\n    d = min(d, vertex_d(p, mid7));\n    d = min(d, vertex_d(p, mid8));\n    d = min(d, vertex_d(p, mid9));\n    d = min(d, vertex_d(p, mid10));\n    d = min(d, vertex_d(p, mid11));\n    d = min(d, vertex_d(p, mid12));\n\n    //d = min(d, plane_d(p, normalize(mid1))); // doesn't quite work, needs to be clamped to interior of the pentagon.\n    vec3 axis1 = normalize(mid1 - mid2);\n    vec3 axis2 = normalize(mid3 - mid10);\n    vec3 axis3 = normalize(mid4 - mid11);\n    vec3 axis4 = normalize(mid5 - mid12);\n    vec3 axis5 = normalize(mid6 - mid8);\n    vec3 axis6 = normalize(mid7 - mid9);\n\n    float d1 = 0.0;\n    d1 = max(d1, abs(dot(p, axis1)));\n    d1 = max(d1, abs(dot(p, axis2)));\n    d1 = max(d1, abs(dot(p, axis3)));\n    d1 = max(d1, abs(dot(p, axis4)));\n    d1 = max(d1, abs(dot(p, axis5)));\n    d1 = max(d1, abs(dot(p, axis6)));\n    d1 -= radius*.8;\n    d = min(d, d1);\n    return d;\n}\n\n\n\nfloat scene_d(vec3 p)\n{\n    //float d = length(p)-1.;\n    //float d = ngon_d(rot2d(p.xy-vec2(0,-1), radians(90.+10.*iTime)), 5, .5);\n    //vec3 axis = vec3(0,0,1);\n    //float d = ngon_d(rot3d(p, axis, radians(90.+10.*iTime)), 5, .5);\n    //float d = ngon_d(rot3d(p-vec3(1,-1,1), axis, radians(90.+10.*iTime)), 5, .5);\n    vec3 pp = rot3d(p,vec3(0,1,0), iTime);\n    float d = dodeca(pp, 1.);\n    d = min(d, p.y+4.); // ground plane\n    //d = min(d, length(p.yz)-0.05); // x axis\n    d = min(d, length(p.xz)-0.05); // y axis\n    //d = min(d, length(p.xy)-0.05); // z axis\n    return d;\n}\n\nvec3 get_normals(vec3 p)\n{\n    float x1 = scene_d(p-vec3(EPSILON,0,0));\n    float x2 = scene_d(p+vec3(EPSILON,0,0));\n    float y1 = scene_d(p-vec3(0,EPSILON,0));\n    float y2 = scene_d(p+vec3(0,EPSILON,0));\n    float z1 = scene_d(p-vec3(0,0,EPSILON));\n    float z2 = scene_d(p+vec3(0,0,EPSILON));\n\n    return normalize(vec3(x2-x1,y2-y1,z2-z1)/(2.*EPSILON));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam_pos = vec3(1,2,4);\n    vec3 lookat = vec3(0.);\n    vec3 cam_dir = normalize(lookat-cam_pos);\n    vec3 world_up = vec3(0,1,0);\n    vec3 cam_right = normalize(cross(cam_dir, world_up));\n    vec3 cam_up = normalize(cross(cam_right, cam_dir));\n    float focal_dist = 2.;\n    vec3 ro = cam_pos + cam_dir*focal_dist + cam_right*uv.x + cam_up*uv.y;\n    vec3 rd = normalize(ro - cam_pos);\n    float ray_dist = 0.;\n    vec3 col = vec3(0.);\n    bool hit = false;\n    for(int i = 0; i < MAX_ITERS; i++)\n    {\n        float d = scene_d(ro+rd*ray_dist);\n        if(d<EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        ray_dist += d;\n    }\n    if(hit)\n    {\n        vec3 hit_pos = ro+rd*ray_dist;\n\t\tcol = get_normals(hit_pos);\n    }\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}