{"ver":"0.1","info":{"id":"wsyGzV","date":"1570553301","viewed":169,"name":"Candy land ","username":"julianlumia","description":"I really have no idea how I got to this point to be honest... but its really awesome!:)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blob","candy","colorfull","gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 n;\nvec3 lightPos;\n\nfloat smin(float a, float b, float k)\n{\n float h = clamp (0.5+0.5*(b-a)/k,0.,1.);\n return mix(b, a, h) - k*h*(1.0-h);       \n}\n\nfloat gyroid ( vec3 p, float s )\n{\n return sin(p.x*s)*cos(p.y*s) + sin(p.y*s)*cos(p.z*s) + sin(p.z*s)*cos(p.x*s);\n}\n\nfloat GetDist (vec3 p) \n{\n float ogGyroid= gyroid(p-vec3(-2.,4.,4.),0.65);\n float d;\n float one = ogGyroid;\n float s = .5;\n p.xz +=sin(iTime)*cos(iTime*0.2);\n p.y += iTime*2.;\n float two = ((dot(cos(p.zxy), cos(p.zzy*s))));\n s =4.;\n float three = (abs(dot(sin(p), cos(p.zzz*s)))*.2);\n two = mix(two, three, sin(.0)*.5+.5);\n one = smin(one, two,-1.5);\n d = one;\n return  one ;\n}\n\nfloat marchCount;\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n float dO = 0.;\n marchCount = 0.0;\n for (int i=0; i<94; i++) \n {\n  vec3 p = ro + dO * rd;\n  float dS = GetDist (p);\n  dO += dS*1.;\n  marchCount+= 5.*dS*.001;\n  if (dS<.01 || dO>80.) break;\n  }\n return dO;\n}\n\nfloat traceRef(vec3 o, vec3 r)\n{\n float t = 0.0;\n for (int i = 0; i < 48; i++)\n  {\n   vec3 p = o + r * t;\n   float d = GetDist (p);\n   if(d<.002 || t>80.) break;\n   t += d * 1.;            \n  }\n return t;\n}\n\nvec3 GetNormal(vec3 p){\n vec2 e = vec2(.0035, -.0035); \n return normalize(\n  e.xyy * GetDist(p + e.xyy) + \n  e.yyx * GetDist(p + e.yyx) + \n  e.yxy * GetDist(p + e.yxy) + \n  e.xxx * GetDist(p + e.xxx));\n}\n\nfloat GetLight(vec3 p)\n{\n vec3 LightPos = vec3(1, 2, iTime*1.+10.);\n LightPos.xz += vec2(sin(iTime),cos (iTime)*3.);\n vec3 L = normalize(LightPos -p);\n n = GetNormal (p);   \n float dif = clamp(dot(n, L), 0. , 1.);\n float d = RayMarch(p+n*.01*10.,L);\n if (d<length(LightPos-p)) dif *= 1.;\n return dif;       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n vec3 ro; \n ro =vec3(1,5,iTime*1.);\n vec3 rd = normalize(vec3(uv.x,uv.y,.4));\n float the = iTime *0.25;\n //camera movement  \n // rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n // rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));      \n float d = RayMarch (ro,rd);\n vec3 p = ro + rd *d;\n vec3 sn = GetNormal(p);\n vec3 x = sn;\n rd = reflect(rd, sn);\n d = traceRef(ro +  rd*1.5, rd);\n ro += rd*d;\n sn = GetNormal(ro);\n x += sn;\n vec3 col =x;\n float dif = GetLight (p); \n col = vec3(dif);\n col *= 0.25;\n col += marchCount * vec3(0.2,.2,0.01) * 10.;\n col +=vec3(0.7,abs(sin(iTime*p.y*0.0002)),0.4);\n col +=vec3((smoothstep(-.5,1.,sin(-iTime*0.1+p.xzz*.2)))-1.);\n float fog = 1. / (1. + d * d * 2.);\n col += vec3(fog);\n col *= 1.15;\n fog = 1. / (2. + d * d * 0.01);\n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}