{"ver":"0.1","info":{"id":"lXG3Rt","date":"1718052113","viewed":17,"name":"Growing And Shrinking SDF","username":"Coolpuppykid","description":"My first little shader toy project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MDTD 100.0\n#define SURFACE_THRES 0.001\n\nfloat sphere(vec3 pos, float rad) {\n    return length(pos) - rad;\n}\n\nfloat raymarch(vec3 rayO, vec3 rayD, vec3 pos) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayO + rayD * t;\n        float d = sphere(p - pos, max(cos(iTime), 0.2));\n        if (d < SURFACE_THRES) {\n            return t;\n        }\n        t += d;\n        if (t >= MDTD) {\n            break;\n        }\n    }\n    return MDTD;\n}\n\nvec3 computeSNormal(vec3 pos) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sphere(pos + vec3(e.x, e.y, e.y), 1.0) - sphere(pos - vec3(e.x, e.y, e.y), 1.0),\n        sphere(pos + vec3(e.y, e.x, e.y), 1.0) - sphere(pos - vec3(e.y, e.x, e.y), 1.0),\n        sphere(pos + vec3(e.y, e.y, e.x), 1.0) - sphere(pos - vec3(e.y, e.y, e.x), 1.0)\n    ));\n}\n\nfloat starField(vec3 dir) {\n    float starDensity = 500.0;\n    vec3 starPos = floor(dir * starDensity) / starDensity;\n    float star = fract(sin(dot(starPos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    return step(0.999, star);\n}\n\nfloat clouds(vec3 dir) {\n    float cloudDensity = 1.5;\n    float noise = fract(sin(dot(dir.xy * cloudDensity, vec2(12.9898, 78.233))) * 43758.5453);\n    return smoothstep(0.4, 0.6, noise);\n}\n\nvec3 computeSky(vec3 dir)\n{\n    vec3 skyColor = mix(vec3(0.2, 0.3, 0.7), vec3(0.8, 0.9, 1.0), smoothstep(-0.2, 0.8, dir.y));\n    \n    float stars = starField(dir) * (1.0 - smoothstep(-0.1, 0.1, dir.y));\n    skyColor += stars * vec3(1.0, 1.0, 0.9);\n    \n    float cloudLayer = clouds(dir) * smoothstep(0.0, 1.0, dir.y);\n    skyColor = mix(skyColor, vec3(1.0, 1.0, 1.0), cloudLayer * 0.5);\n    return skyColor;\n}\n\nvec3 computeSLighting(vec3 p, vec3 rd, vec3 color, float ambientIntens) {\n    vec3 lightPos = vec3(2.0, 2.0, 2.0);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = computeSNormal(p);\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 diffuseCol = color * max(diffuse, ambientIntens);\n    return max(diffuseCol, 0.1);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv + iMouse.xy / iResolution.xy * 0.5, -1.5));\n\n    float t = raymarch(ro, rd, vec3(0.245, 0, 1));\n    float t2 = raymarch(ro, rd, vec3(1,0,0));\n\n    vec3 color = vec3(0.0);\n    \n    if (t2 < MDTD) {\n        vec3 p = ro + rd * t2;\n        color = computeSLighting(p, rd, vec3(1,0,0), 0.1f);\n    }\n     else\n    {\n        color = computeSky(normalize(vec3(uv + iMouse.xy / iResolution.xy * 0.5, -1.5 + max(cos(iTime), 0.0))));\n    }\n    \n    if (t < MDTD) {\n        vec3 p = ro + rd * t;\n        color = computeSLighting(p, rd, vec3(1,1,1), 0.2f);\n    }\n    \n    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}