{"ver":"0.1","info":{"id":"msBSW3","date":"1670975997","viewed":265,"name":"Planet atmosphere","username":"sub7","description":"A more portable atmosphere shader","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sun","normals","light","scattering","atmosphere","ssao"],"hasliked":0,"parentid":"NlXXWN","parentname":"Atmospherical Scattering"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define time (iTime*1.0)\n#define SHOW_SUN 0.0\n#define PLANET_SIZE 1.1\n#define ATMOSPHERE_THICKNESS 0.8\n\nstruct ray{\n\tvec3 ro;\n    vec3 rd;\n};\n\nstruct sph{\n    vec3 c;\n\tfloat r;\n};\n\nconst vec3 center=vec3(0);\n\nconst int VIEW_SAMPLES=64;\nconst int DEPTH_SAMPLES=8;\n\nconst sph atm=sph(center,1.0 * PLANET_SIZE * ATMOSPHERE_THICKNESS);\nconst vec3 sunInt=vec3(1.);\nconst sph earth=sph(center,0.5 * PLANET_SIZE);\nconst vec3 waves=700./vec3(700,510,440);\nconst vec3 RGBScatter=waves*waves*waves*waves;\nconst float scatterStrength=50.;\nconst float densFall=7.;\n\nconst float pi=4.*atan(1.);\n\nfloat phase(float cosTheta) {\n\treturn (1. + cosTheta * cosTheta) / (16.0 * pi);\n}\n\nfloat sphere(ray r, sph s, float n){\n\tvec3 rc = r.ro-s.c;\n\tfloat c = dot(rc, rc) - (s.r*s.r);\n\tfloat b = dot(r.rd, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn max(0.,mix(-1., t, st));\n}\n\nfloat suc(ray r,vec3 center,float radius){\n    vec3 o=r.ro-center;\n    float a=dot(o,o);\n    float b=dot(r.rd,o);\n    float c=dot(r.rd,r.rd);\n    float k=sqrt(a*c-b*b);\n    float integ=radius*(pi/2.-atan(b,k))/k/3.;\n    integ*=integ;\n    return integ;\n}\n\nfloat density(vec3 p){\n    float l=distance(p,center)-earth.r;\n    l/=atm.r-earth.r;\n    return exp(-l*densFall)*(1.-l);\n}\n\nfloat depth(vec3 s,vec3 e){\n    float d=0.;\n    for(int i=0;i<DEPTH_SAMPLES;i++){\n        vec3 p=s+(e-s)*float(i)/float(DEPTH_SAMPLES);\n        d+=density(p);\n    }\n    return d/float(DEPTH_SAMPLES)*distance(s,e);\n}\n\nvec3 light(ray r,vec3 sunPos,vec3 orig){\n    if(distance(r.ro,center)<atm.r){\n    }else{\n        float d1=sphere(r,atm,1.);\n        if(d1==0.)return orig;\n        r.ro+=r.rd*d1;\n    }\n    float d2=sphere(r,earth,1.);\n    if(d2==0.)d2=sphere(r,atm,-1.);\n    float viewDepth=0.;\n    vec3 l=vec3(0.);\n    for(int i=0;i<VIEW_SAMPLES;i++){\n        vec3 p=r.ro+r.rd*(float(i)+0.5)/float(VIEW_SAMPLES+1)*d2;\n        ray k=ray(p,normalize(sunPos-p));\n        if(sphere(k,earth,1.)==0.){\n            float sunDepth=depth(k.ro,k.ro+k.rd*sphere(k,atm,-1.));\n            viewDepth=depth(r.ro,p);\n            vec3 transmitance=exp(-(sunDepth+viewDepth)*RGBScatter);\n        \n        \n            l+=transmitance*density(p)*phase(dot(r.rd,normalize(sunPos-p)));\n        }\n    }\n    vec3 origTransmitance=exp(-viewDepth*RGBScatter);\n    return orig*origTransmitance+l/float(VIEW_SAMPLES)*d2*sunInt*RGBScatter*scatterStrength;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    float uvz=-1.;\n    float roz=-3.;\n    vec3 pos=vec3(0,0,0);\n\n    vec3 uv = vec3((U*2.-R.xy)/R.y,uvz);\n    vec3 ro=vec3(0,0,roz);\n    \n    O=vec4(0);\n    ray r=ray(ro+pos,normalize(uv-ro));\n    \n    // Set sun position\n    sph sun=sph(vec3(0, 10.*vec2(cos(time),sin(time))),SHOW_SUN);\n    \n    O.rgb+=clamp(0.,1000.,suc(r,sun.c,sun.r))*sunInt;\n     \n    O=vec4(light(r,sun.c,O.rgb),1.);\n}","name":"Image","description":"","type":"image"}]}