{"ver":"0.1","info":{"id":"Dd23Rh","date":"1667219747","viewed":94,"name":"RainDropPlane","username":"peremptor","description":"A simple shader, that makes raindrop like animations. As the method just drop produces a float between 0 and 1 it can easily be incorporated\ninto other shaders. Feel free to do so. But consider leaving  alink to the source :D.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","rain","basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_time iTime\n#define PI 3.1415926\n\nconst float a = 12.9898;\nconst float b = 78.233;\nconst float c = 43758.5453;\nfloat rand(float co) \n{\n    return fract(sin(dot(vec2(co,co+123333.), vec2(a, b))) * c);\n}\n\nfloat inRing(vec2 uv, float radius, vec2 pos)\n{\n    float radius2 = radius - 0.0012;\n    float polarCoordinateAngle = atan(uv.y,uv.x) + PI;\n    float polarCoordinateRadius = distance(pos,uv);\n\n    const float borderSmothness = 0.002;\n    float inBigCircle = smoothstep(radius, radius- borderSmothness, polarCoordinateRadius);\n    float insmallCircle = smoothstep(radius2,radius2 - borderSmothness, polarCoordinateRadius);\n    float inRing = inBigCircle - insmallCircle;\n    return inRing;\n}\n\nfloat drop(vec2 uv, float time)\n{\n    float scaledTime = time / 2.;\n    float timeSlot = floor(scaledTime);\n    float progressInTimeSlot = fract(scaledTime);\n    vec2 dropCoordinate = vec2(rand(timeSlot) *2., rand((rand(timeSlot))));\n    float inRingValue = inRing(uv,progressInTimeSlot, dropCoordinate); \n    inRingValue *= 0.02/progressInTimeSlot;\n    return inRingValue;\n}\n\nvec3 frag(vec2 uv)\n{\n    float dropValue = drop(uv, u_time);\n    //the loop variable controls how many simultaneous drops can occur\n    // try changing it to 0 to see what i mean.\n    for(float i = 0.; i < 50.; i += 1.)\n    {\n        float loopDropValue = drop(uv, (u_time / (rand(i) * 25.)) + 1000. * i);\n        dropValue = max(dropValue, loopDropValue);\n    }    \n    \n    return  dropValue * vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord /iResolution.xy;\n    uv.x = uv.x * ( iResolution.x / iResolution.y);\n    fragColor = vec4(frag(uv), 1);\n}","name":"Image","description":"","type":"image"}]}