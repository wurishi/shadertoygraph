{"ver":"0.1","info":{"id":"7l3fWn","date":"1662912261","viewed":130,"name":"Number to RGB Color scale","username":"ppelikan","description":"Click on the render to adjust.\n\nUtility to convert single number into RGB color scale.\nI've used this to calibrate my Mandelbrot pretty coloring.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","beginner","color","rgb","plot","tool","scale","heatmap","bargraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cc = vec3(0.25, 0.5, 0.75);         // color peak center\nvec3 cw = vec3(0.33, 0.33, 0.33);        // color peak width\n#define getColor(v) (smoothstep(cw, vec3(0.0), abs(v - cc)))\n#define getColorSRGB(v) (pow(getColor(v), vec3(1.0 / 2.2)))\n\n#define pw(x) ((x)*(x))\nconst float w = 0.0075;                  // plot line width\ntxt_def(iChannel0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 z = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float off = 0.0;\n    \n    if (m.y > 0.001)                     // when clicked\n    {\n        cw = cw * m.y * 2.0;          \n        cc.r = cc.g - m.x+0.5;\n        cc.b = cc.g + m.x-0.5;\n    }\n\n    vec3 color;\n    if (z.y > 0.5)\n    {\n        color = getColor(z.x);\n        off = 0.5;\n    }\n    else\n        color = getColorSRGB(z.x);\n        \n    float brightness = (color.r + color.g + color.b) / 3.0;\n    if ( abs((z.y-off)*2.0 - brightness ) <  w)\n        color = vec3(1.0);               // draw line for brightness\n        \n    vec3 k =  abs((z.y-off)*2.0 - color);\n    if ( min(k.r, min(k.g, k.b)) < w )\n           color = 1.0 - color;          // draw line for each RGB channel\n \n    if (pw(z.x-m.x)+pw(z.y-m.y)<1e-4)\n        color = 1.0 - color;             // draw cursor \"knob\"\n        \n    fragColor = vec4(color, 1.0);\n    \n    txt_pos(vec2(0.0,off),5.0);\n    if (off>0.1)\n    {\n        _R _G _B\n    }\n    else\n    {\n        _S _R _G _B\n    }\n    txt_pos(vec2(0.15,0.95),3.0);\n    _C _C _\n    txt_float(cc.r); _\n    txt_float(cc.g); _\n    txt_float(cc.b); _ _ _ _\n    _C _W _\n    txt_float(cw.r); _\n    txt_float(cw.g); _\n    txt_float(cw.b); _\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nSimple text by ppelikan\nhttps://www.shadertoy.com/view/fldBWn\n\nThanks to FabriceNeyret, PrzemyslawZaworski, otaviogood.\nBased on https://www.shadertoy.com/view/llySRh and on https://www.shadertoy.com/view/4sBfRd\n\n== Usage: =========================\n1. copy contents of the \"Common\" file to your project.\n2. add iChannel3 -> Textures -> Font1 in your project.\n3. use the \"txt_def(iChannel3)\" once, before \"mainImage\" function\n4. print all your text after \"fragColor\" has been assigned with some value.\n5. (optional: to get rid of artifacts set the texture \"Filter\" to \"linear\" (gear icon)).\n\ntxt_def(x)    <- defines input channel as the source of font texture,\n                 this needs to be placed above the \"mainImage\" function, (use it only once)\ntxt_pos(p, s) <- set starting position \"p\" and font size \"s\" for following text renders\n_A _B _C ...  <- print given letter\n_             <- print space\ntxt_int(i)    <- cast given \"i\" value to int and print it\ntxt_float(f)  <- cast given \"f\" value to float and print it\ntxt_red ...   <- given color definition,\n                 available colors: txt_red, txt_green, txt_blue, txt_white, txt_black, txt_negative\ntxt_col(c)    <- set custom vec4 font color for following text renders\n\n== Limitations: ===================\nThis solution is intended for debugging purposes, don't expect it to be pretty or 100% bug-free.\nText positioning isn't very precise.\nInteger printing is restricted to values between -1000000..1000000\nFloat printing has the same limitations, plus only 4 decimal places are being displayed.\nFloat printing doesn't have detection of NaN, INF, etc., so it's better to avoid such strange numbers.\n\n== Goals: =========================\n1. Lazy Plug&Play approach. One should be able to quickly add and remove this code to/from their's project.\n2. Reasonably low performance impact.\n3. Code might be obscure but has to be short.\n\n*/\n\n// internal\n#define txt_drop if(txt_U.y>0.&&txt_U.y<1.){\n#define txt_digit(d) {txt_C(48+(d)%10);}\n// public\n#define txt_def(X) vec4 txt_Col=vec4(1.0);vec2 txt_U=vec2(0); vec4 txt_char(int c){if(txt_U.x<.1||txt_U.x>1.)return vec4(0);return textureGrad(X,txt_U/16.+fract(vec2(c,15-c/16)/16.),dFdx(txt_U/16.),dFdy(txt_U/16.));}\n#define txt_C(c) {txt_drop fragColor+=txt_char(c).xxxx*txt_Col;txt_U.x-=.5;}}\n#define txt_pos(pos, size) {txt_U=(fragCoord/iResolution.xy-pos)*64.0/size;txt_U.x*= 2.0;}\n#define txt_col(c) {txt_Col=c;}\n#define txt_int(i) {txt_drop bool s=false;if(int(i)<0)txt_C(45);for(int n=1000000;n!=0;n/=10){int v=abs(int(i))/n;if(v!=0)s=true;if(s)txt_digit(v);}if(!s)txt_C(48);}}\n#define txt_float(f) {if(float(f)<0.0)txt_C(45);float integ,fr=modf(float(f),integ);txt_int(abs(integ));txt_C(46);for(int n=1000;n!=0;n/=10)txt_digit(int(abs(fr*10000.))/n);}\n// letters\n#define _A    txt_C(65);\n#define _B    txt_C(66);\n#define _C    txt_C(67);\n#define _D    txt_C(68);\n#define _E    txt_C(69);\n#define _F    txt_C(70);\n#define _G    txt_C(71);\n#define _H    txt_C(72);\n#define _I    txt_C(73);\n#define _J    txt_C(74);\n#define _K    txt_C(75);\n#define _L    txt_C(76);\n#define _M    txt_C(77);\n#define _N    txt_C(78);\n#define _O    txt_C(79);\n#define _P    txt_C(80);\n#define _Q    txt_C(81);\n#define _R    txt_C(82);\n#define _S    txt_C(83);\n#define _T    txt_C(84);\n#define _U    txt_C(85);\n#define _V    txt_C(86);\n#define _W    txt_C(87);\n#define _X    txt_C(88);\n#define _Y    txt_C(89);\n#define _Z    txt_C(90);\n#define _     txt_C(32);\n// colors\n#define txt_red   vec4(1.,.0,.0,1.)\n#define txt_green vec4(.0,1.,.0,1.)\n#define txt_blue  vec4(.0,.0,1.,1.)\n#define txt_white vec4(1.)\n#define txt_black vec4(vec3(-1.),1.)\n#define txt_negative vec4(vec3(1.-2.*fragColor.rgb),1.)\n","name":"Common","description":"","type":"common"}]}