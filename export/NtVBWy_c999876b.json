{"ver":"0.1","info":{"id":"NtVBWy","date":"1665286003","viewed":81,"name":"Sin arclength reparametrization","username":"Envy24","description":"I tried to reparametrize sin and get this blue curve.\nLine 53 can recover original sin(x).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sin","cos","arclength","reparametrization"],"hasliked":0,"parentid":"ftdBzS","parentname":"Quadratic Bezier Reparametrizati"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )   \n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define SCENE_SCALE                 2.5\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* Approximation by Gauss-Legendre quadrature.\n   https://www.shadertoy.com/view/st3yzs\n   https://keisan.casio.com/exec/system/1329114617 */\nfloat arclength(float t)\n{\n    const float xs[5] = float[5](\n        -0.9061798459386639927976,\n        -0.5384693101056830910363,\n        0.,\n        0.5384693101056830910363,\n        0.9061798459386639927976  );\n    const float ws[5] = float[5](\n        0.2369268850561890875143,\n        0.4786286704993664680413,\n        0.5688888888888888888889,\n        0.4786286704993664680413,\n        0.2369268850561890875143 );\n    \n    float a = 0., b = t;\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              //I += sqrt(0.53+sin(x)*sin(x))*ws[i];\n              I += sqrt(0.53+cos(x)*cos(x))*ws[i];\n              \n              //I += sqrt(1.+cos(x)*cos(x))*ws[i]; // correct formula for sin arclength\n              //I += sqrt(1.+sin(x)*sin(x))*ws[i]; // correct formula for cos arclength\n              \n              // this line gives original sin(x) function.\n              //I += (sqrt(0.53+cos(x)*cos(x))*ws[i] + sqrt(0.53+sin(x)*sin(x))*ws[i]) * 0.5;\n    }\n\n    return I * mean;\n}\n/* Bisection method for finding t relative to s */\nfloat reparametrize(float s)\n{\n    /* If in arclength used 1. *\n    s = mod(s, 3.82*2.);\n    s = s > 3.82 ? s - 3.82*2. : s;\n    s = s < -3.82 ? s + 3.82*2. : s;\n    /* If in arclength used 0.53. */\n    s = mod(s, TAU);\n    s = s > PI ? s - TAU : s;\n    s = s < -PI ? s + TAU : s;\n    /**/\n\n    const float tolerance = 1e-7; /* Desired precision */\n    float T[2] = float[2](-SCENE_SCALE*AR, SCENE_SCALE*AR);\n    float F[2] = float[2](\n        arclength(T[0]),\n        arclength(T[1]));\n    \n    float l = 0.5;\n    \n    for (int i = 0; (i < 16) && (abs(l-s) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float t = (T[0] + T[1]) * 0.5;\n              l = arclength(t);\n\n        int w_idx = int(l>s);\n        \n        F[w_idx] = l; T[w_idx] = t;\n    }\n\n    return sin((T[0] + T[1]) * 0.5);\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * SCENE_SCALE;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n#define func(x) ( sin(x) )\n#define dfdx(x) ( cos(x) )\n         color.gb -= draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x));\n#define func2(x) ( arclength(x) )\n#define dfdx2(x) ( (arclength(x) - arclength((x)+0.01)) / 0.01 )\n         color.rb -= draw_explicit_func(NDC, func2(NDC.x), dfdx2(NDC.x));\n#define func3(x) ( reparametrize(x) )\n#define dfdx3(x) ( (reparametrize(x) - reparametrize((x)+0.01)) / 0.01 )\n         color.rg -= draw_explicit_func(NDC, func3(NDC.x), dfdx3(NDC.x));\n\n    float t, l, len = arclength(SCENE_SCALE*AR); vec2 P;\n\n#define SCALE 0.25\n/* Static */\n         int count = 16;        \n         float dl = (2.*len) / float(count-1),\n               dt = 1. / float(count-1);\n         \n         for (int i = 0; i < count; ++i)\n         {\n                 P.x = -len+float(i)*dl;\n                 P.y = reparametrize(P.x);\n             color = mix(color, vec3(0, 1, 1), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) ));\n\n                 P.y = sin(P.x);\n             color = mix(color, vec3(1, 0, 0), SMAA( diskSDF_L2(NDC, P, UNIT) ));\n         }\n/* Motion (doesn't work on dynamic curves, because of length changes every frame) */\n    float speed = 1.0;\n             P.x = -len+mod(iTime*speed, 2.*len);\n             P.y = reparametrize(P.x); // moves with constant length.\n         color = mix(color, vec3(0.3, 0.5, 0.8), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) )); // light blue\n         \n             P.y = sin(P.x);\n         color = mix(color, vec3(0.8, 0.5, 0.3), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) )); // brown\n/**/\n\n    color -= vertical_line(NDC, -3.82)*0.2;  color -= vertical_line(NDC, 3.82)*0.2;\n    color -= vertical_line(NDC, -PI)*0.4;  color -= vertical_line(NDC, PI)*0.4;\n    \n    float T = iTime;\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(reparametrize(T+PI*0.5), reparametrize(T)), UNIT)) );\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, vec2(cos(T), sin(T)), UNIT)) );\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"}]}