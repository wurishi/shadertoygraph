{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 result = vec3(0);\n\t\n\tfloat F = iTime * 1.;\n\tfloat windowHeight = iResolution.y * 2.;\n\t\n\t// When seed is constant, time in this case, you get massive artifacts, using screen space\n\t// coordinates multiplied gives smooth noise, varying between these two gives the funky effect\n\tfloat distance, radius, seed = .7 < sin(F*.2) ? F : fragCoord.x*fragCoord.y;\n\t\n\t// We shoot 100 rays per pixel to smoothen out noise\n\tfor (int j=0; j<100; j++) {\n\t\tvec3 spherePos;\n\t\tvec3 mat;\n\t\tvec3 tint = vec3(1);\n\t\tvec3 rayO = vec3(0,.7,.1);\n\n\t\t// Calculate ray direction based on screen space coordinates\n\t\tvec3 rayD = normalize(vec3(fragCoord.x,0.0,fragCoord.y)/windowHeight - vec3(.44,-.2,.25) - rayO);\n\t\t\n\t\t// WebGL doesn't support recursion in shaders, so we use for loop to calcualte multiple\n\t\t// light bounces in the scene\n\t\tfor (int a=0; a<4; a++) {\n\t\t\t// Wall positions, we swap axis to get different sphere positions\n\t\t\tvec3 walls = vec3(0, 10.25,0);\n\t\t\tdistance=100.;\n\t\t\tfor (int k=0; k<8; k++) { // Go through all spheres\n\t\t\t\t// Setup sphere and materials \n\t\t\t\tvec3 sphere = vec3(.2 * cos(F), .2 * sin(F), sin(iTime)*.3); // Default to light\n\t\t\t\t// Just use some random vector to detect lights, m=x, if (m==x) light\n\t\t\t\tvec3 m = walls; \n\t\t\t\tradius=.005;\n\t\t\t\tif (k<7) // Diffuse sphere\n\t\t\t\t\tm = vec3(0,.7,.1).yyz,\n\t\t\t\t\tsphere=vec3(.12 * cos(F*.7+3.), .12 * sin(F*.7+3.),sin(F*.12)*.12);\n\t\t\t\tif (k<6) // Mirror sphere\n\t\t\t\t\tm = vec3(1),\n\t\t\t\t\tsphere=vec3(.12 * cos(F*.7), .12 * sin(F*.7),-sin(F*.12)*.12),\n\t\t\t\t\tradius = .012;\n\t\t\t\tif (k<5) // Walls\n\t\t\t\t\tm = vec3(0,.7,.1).yyy,\n\t\t\t\t\t// Here we do walls=-walls.zxy which basically over 5 iterations gives us all\n\t\t\t\t\t// 5 walls you see, left, right, top, bottom and back wall\n\t\t\t\t\tsphere=walls=-walls.zxy, \n\t\t\t\t\tradius = 100.;\n\t\t\t\tif (k==1)\n\t\t\t\t\tm = vec3(0,.7,.1).zyy;\n\t\t\t\tif (k==4)\n\t\t\t\t\tm = vec3(0,.7,.1).yzy;\n\t\t\t\t// Intersect sphere\n\t\t\t\tfloat d, b=dot(rayD, sphere - rayO),\n\t\t\t\t\tdet=b*b-dot(sphere - rayO, sphere - rayO)+radius;\n\t\t\t\t// Check if we hit something\n\t\t\t\tif (.0 < det)\n\t\t\t\t\tif (.0001 < (d=b-sqrt(det)))\n\t\t\t\t\t\tif (d < distance) { \n\t\t\t\t\t\t\t// If we did, set the materials, sphere position and hit distance\n\t\t\t\t\t\t\tdistance = d;\n\t\t\t\t\t\t\tmat = m;\n\t\t\t\t\t\t\tspherePos = sphere;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (distance == 100.) // Ray missed scene, it bounces no more\n\t\t\t\tbreak;\n\t\t\tif (mat == walls) { // We hit light, add tinted color to result\n\t\t\t\tresult += 12. * tint;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trayO += rayD * distance; // Calculate intersection point\n\t\t\ttint *= mat; // Apply color\n\t\t\t\n\t\t\t// Store normal of the intersection into spherePos\n\t\t\tspherePos = normalize(rayO - spherePos); \n\t\t\t\n\t\t\t// Decide if material is white which means its mirror or something else then its diffuse\n\t\t\trayD = mat == vec3(1) ? \n\t\t\t\t// Reflection\n\t\t\t\treflect(rayD, spherePos) :\n\t\t\t\t// Diffuse\n\t\t\t\t// fract(sin(seed += .7)*seed) is our random function\n\t\t\t\t// We create random vector then check if it is facing same way as normal,\n\t\t\t\t// if not then we flip it\n\t\t\t\tsign(dot(walls=normalize(vec3(fract(sin(seed += .7)*seed)-.5, \n\t\t\t\t\t\t\t\t\t\t\t\tfract(sin(seed += .7)*seed)-.5, \n\t\t\t\t\t\t\t\t\t\t\t\tfract(sin(seed += .7)*seed)-.5)),\n\t\t\t\t\t\t\t\t\tspherePos))*walls; \n\t\t}\n\t}\n\t// Set color, if time is over 166. then set color to black, otherwise some artifacts keep\n\t// appearing from inaccurate sphere interscetions that show even after the light has moved\n\t// outside of the box, sign(166. - F) returns 1 when F is below 166. and -1 when its above, so\n\t// multiplying color with that gives us the effect we want\n\tfragColor = vec4(.02 * result, 1); //vec4(.02 * result * sign(166. - F), 1);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msf3Rs","date":"1376824199","viewed":2394,"name":"Kornell Box","username":"Bercon","description":"Brute force path tracer which calculates 4 light bounces and features diffuse and reflective materials. I took part of Assembly 2013 1k intro competition with this and placed 3rd ( http://pouet.net/prod.php?which=61667 ).","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracer","intro","cornellbox","1k","pathtracing"],"hasliked":0,"parentid":"","parentname":""}}