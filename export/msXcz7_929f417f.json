{"ver":"0.1","info":{"id":"msXcz7","date":"1686666212","viewed":59,"name":"CRT Oscilloscope","username":"stduhpf","description":"simple simulation of a old school CRT oscilloscope","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simulation","phosphors","exponentialdecay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define persistence .02  //time for phosphor brightness to decay to 10% peak brightness (in seconds)\n// based on P1 phosphor\n// http://www.labguysworld.com/crt_phosphor_research.pdf\nconst vec3 phosphor_color = vec3(.01,.8,.02);\n\n#define speed 1. // lower values for slow-motion\n\nconst float scan_speed = 25000.; // pixel/s\nconst float signal_amplitude = 100.; //pixels\n\nfloat cursorBirghtess(float t){\n    // dimm the beam when returning to start\n    float a = t*scan_speed;\n    float k = mod(a,iResolution.x);\n    return step(0.,k-5.)*step(k+5.,iResolution.x)*.99+.01;\n}\n\nfloat horizScan(float t){\n    return mod(t*scan_speed,iResolution.x)-iResolution.x*.5;\n}\n\nfloat signal(float t){\n    float a = t*800.;\n    return sin(a)*cos(acos(-1.)*a);\n}\n\nvec2 cursorPos(float t){\n    return vec2(horizScan(t),signal_amplitude*signal(t));\n}\n\n\nfloat drawLine(vec2 start, vec2 end, vec2 p, float t0, float dt){\n    vec2 startOffset = p - start, dir = end - start;  \n    float h = clamp( dot(startOffset,dir)/dot(dir,dir), 0.0, 1.0 );\n    return pow(10.,-dt*h/persistence)*cursorBirghtess(t0-h*dt)*smoothstep(sqrt(2.),1.,length(startOffset-dir*h));\n}\n\n\n#define SUBFRAMES 64  // sampling of the cursor position per frame\n// higher values looks better, but with a big performance penalty\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    col=pow(col,vec3(2.2));\n    \n\n    float t1 = (iTime-iTimeDelta) * speed;\n    float dt = iTimeDelta * speed/float(SUBFRAMES);\n\n    for(int i=0;i<SUBFRAMES;i++){\n        float t0 = t1+dt;\n\n\n        vec2 p0 = cursorPos(t0), p1 = cursorPos(t1);\n        vec2 p = fragCoord-.5*iResolution.xy;\n \n    \n\n        // Time varying pixel color\n        col = max(col* pow(10.,-dt/persistence), phosphor_color*drawLine(p0,p1,p,t0,dt));\n        t1 = t0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}