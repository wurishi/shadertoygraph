{"ver":"0.1","info":{"id":"ctlGR2","date":"1672060855","viewed":97,"name":"Simple mug cup Modeling","username":"Trospy_Study","description":"Mug cup sdf Modeling","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","modeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 3\n#endif\n\n#define RADIUS 0.975f\n#define OFFSET 0.1\n#define R 0.05f\n#define K 2.5f\n#define INNERCIRCLE vec2(1.0f,0.05f)\n\nfloat SDFsphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat SDFTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SDFRotateTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k*a) + exp(k*b))/k;\n}\n\nfloat smoothMin(float a, float b , float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nfloat map(vec3 point)\n{\n    float d = 0.0;\n    point += vec3(0.0,-0.5,0.0);\n    float sphere = SDFsphere(point+vec3(0.0,0.75,0.0), RADIUS );\n    float torus = SDFTorus(point, INNERCIRCLE- vec2(0.0,0.05));\n    float torusMouth = SDFTorus(point+vec3(0.0,0.15,0.0), INNERCIRCLE*1.05);\n    float sphereBool = SDFsphere(point+vec3(0.0,0.35,0.0), RADIUS*1.00);\n    float rotateTorus = SDFRotateTorus(point + vec3(1.15,0.85,0.0), 0.35*(INNERCIRCLE + vec2(0.0,0.2) ));\n    d = smoothMin(sphere, torus, 3.5f);\n    d = smoothMin(rotateTorus,d,9.5f);\n    d = max(d,-sphereBool);\n    d = min(d, torusMouth);\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.001;\n    vec2 e = vec2(1.0f,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,3.0,6.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.0),-2.0));\n\n      // ray marching\n      // t : step size\n        float t = 5.0;\n        \n        for( int i=0; i<64; i++ )\n        {\n            // move ro(origin) + rd(ray direction) * t(step size)\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            // check h is inside of outside of surface\n            if( abs(h)<0.0001f || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<10.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 L_dir = vec3(0.5333-0.5333*(-2.0f + 5.0f*iMouse.x/iResolution.x), 0.5333, 0.5333);\n            \n            // dot(nor, L_dir) = Apply normal direction to surface\n            // this equation render 2D circle to 3D Sphere\n            float dif = clamp(dot(nor,L_dir),0.0,1.0);\n            \n            col = vec3(0.025,0.05,0.08) + dif*vec3(1.0,0.9,0.8);\n        }\n\n        col = sqrt( clamp(col,0.0,1.0) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}