{"ver":"0.1","info":{"id":"wsscDf","date":"1585783527","viewed":136,"name":"Sphere Tunnel","username":"Emiel","description":"Just a little ray marcher I made (is supposed to react to music but can't be bothered to do a multi stage shader for integrated fft).\nHookup sa (sample amplitude fft) and si (sample integrated fft) for sound reactivity.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","sdf","spheres","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define nrm normalize\n#define len length\n#define inv inverse\n#define tim iTime\n\nfloat vol = 80.;\n\nfloat sa(float x) { return 0.; }\nfloat si(float x) { return 0.; }\nmat2 r2(float x) { return mat2(cos(x), -sin(x), sin(x), cos(x)); }\nmat3 r3x(float x) { return mat3(1,0,0,0,cos(x),-sin(x),0,sin(x),cos(x)); }\nmat3 r3y(float x) { return mat3(cos(x),0,sin(x),0,1,0,-sin(x),0,cos(x)); }\nmat3 r3z(float x) { return mat3(cos(x),-sin(x),0,sin(x),cos(x),0,0,0,1); }\n\nfloat sdt(vec3 p, vec2 t) { vec2 q = vec2(length(p.xz)-t.x,p.y); return len(q) - t.y; }\nvec4 ope(vec3 p, vec3 h) { vec3 q = abs(p)-h; return vec4(max(q,0.),min(max(q.x,max(q.y,q.z)),0.)); }\nvec3 rpz(vec3 p, float c) { return vec3(p.xy, mod(p.z+.5*c,c)-.5*c); }\nfloat sds(vec3 p, float s){ return len(p)-s; }\n\nfloat map(vec3 p) {\n  \n  p*=r3z(tim+si(.2)*.5);\n  p.y += cos(p.z*.1)*.1;\n  p.x += sin(p.z*.1+2.5)*.1;\n  \n  vec3 pp=p;\n  \n  \n  p = rpz(p, 12.);\n  vec4 w = ope(p, vec3(.2, 0, 4.2));\n  float d = w.w+sdt(w.xzy, vec2(.8, .05));\n  \n  \n  for (float i=0.; i<12.;i++) {\n    float ic = .4;\n    float as = sa(.1+i*.02);\n    float is = si(.1+i*.02);\n    as = pow(as,.8);\n    as*= .2;\n    d = min(d, sds(p+vec3(\n      vec2(cos(i*ic),sin(i*ic))*.95 * (.9+(cos(i+tim)*.5+.5)*.2),\n      \n      sin(i*10.+tim*2.+is*.1)*3.)\n    \n    *.8, // scale\n    \n    .2+as));\n  }\n  \n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n\n  vec3 ro = vec3(0,sin(tim*2.)*.1,tim*5.+si(.1));\n  vec3 rd = normalize(vec3(uv, 1));\n  \n  float sc = 64.;\n  vec3 p = ro;\n  float i, d;\n  float e = 1e-3;\n  bool hit=false;\n  for (;i<sc;i++) { d=map(p); if(d<e){hit=true;break;} p+=d*rd;}\n  \n  vec2 h = vec2(e,0);\n  vec3 n = nrm(vec3(\n    map(p+h.xyy)-map(p-h.xyy),\n    map(p+h.yxy)-map(p-h.yxy),\n    map(p+h.yyx)-map(p-h.yyx)\n  ));\n  \n  vec3 c = vec3(i/sc*1.2) * vec3(.44,.1,.14)*3.;\n  if (hit) {\n    c += .2*max(vec3(0), dot(n,nrm(vec3(1,2,-2))));\n  } else {\n    c.r = mix(c.r, c.b, len(uv));\n    c.g = mix(c.g, c.b, len(uv));\n  }\n  c = pow(c, vec3(1.2));\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}