{"ver":"0.1","info":{"id":"sl3yz4","date":"1663103067","viewed":190,"name":"Mirror Room 220914","username":"tk87","description":"testing multiple reflection","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PATTERN \n// 0: fix \n// 1: rotate a mirror box\n#define PATTERN 1\n\n\n#define BOX_ID 1.\n#define BOX_ID2 2.\n#define OBJ_ID 3.\n\n#define OBJ_R .8\n#define EPS 1e-4\n\nconst float box_size = 2.;\nconst vec3 box3 = vec3(box_size, box_size*1.5, box_size);\nconst vec3 box32 = vec3(box_size, box_size*1.5, box_size)*.95;\n\n\nmat2 rotate2D(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nfloat box(vec3 p, vec3 w){\n    vec3 q = abs(p) - w;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nvec2 upU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1: d2;\n}\n\n\nvec3 calcNormal(vec3 p, float id){\n    vec2 h = vec2(EPS, 0.0);\n    vec3 sz = id==OBJ_ID ? vec3(OBJ_R) : id==BOX_ID ? box3 : box32;\n    return normalize(vec3(box(p + h.xyy, sz) - box(p - h.xyy, sz),\n                        box(p + h.yxy, sz) - box(p - h.yxy, sz),\n                        box(p + h.yyx, sz) - box(p - h.yyx, sz)\n        )); \n}\n\nmat3 setCamera(vec3 ro, vec3 tg, float cr){\n\tvec3 cw = normalize(tg-ro);\n\tvec3 cu = normalize(cross(cw,vec3(sin(cr), cos(cr), 0.0)));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    float td = EPS, td1;\n    vec2 d = vec2(100., -1.);\n    vec3 p;\n\n    vec3 col = vec3(0);\n    \n    float col_freq = .1 + sin(iTime*.3)*.2;\n    mat2 rot = rotate2D(iTime);\n    mat2 rot2 = rotate2D(3.1416*sin(iTime*.2)*.5);\n    float offset = sin(iTime)*1.5;\n\n    for(int j=0;j<10;++j){\n        d.y = -1.;\n        for(int i=0;i<120;++i){\n            p = ro + td * rd;\n\n            vec3 q = p;\n            q.xy *= rot;\n            d = vec2(box(q+offset, vec3(OBJ_R)), OBJ_ID);\n\n            d = upU(d, vec2(-box(p, box3), BOX_ID));\n            \n            #if PATTERN >= 1\n            q=p;\n            q.xy *= rot2;\n            d = upU(d, vec2(-box(q, box32), BOX_ID2));\n            #endif\n\n            if(d.x < EPS){\n                break;\n            }\n            td += d.x;\n        }\n\n        p = ro + td * rd;\n        if(d.x > EPS) break;\n        if(d.y >= OBJ_ID){\n            p.xy *= rot;\n            p += offset;\n        }\n        else if(d.y == BOX_ID){\n            if(abs(abs(p.y) - box3.y) > EPS){\n                col += hsv(p.y*col_freq+iTime*float(j+1)*.1,\n                1.,\n                1./(abs(abs(p.x) - box3.x) + abs(abs(p.z) - box3.z)+.15) * .08/exp(d.x) * step(-box3.y, -abs(p.y)));\n            }\n            else{\n                p = mod(p*2., 1.) - .5;\n                col += smoothstep(.5, 1., .05/length(p.xz));\n                break;\n            }\n        }\n        else if(d.y == BOX_ID2){\n            p.xy *= rot2;\n            if(abs(abs(p.y) - box32.y) > EPS){\n                col += hsv(p.y*col_freq+iTime*float(j+1)*.1,\n                1.,\n                1./(abs(abs(p.x) - box32.x) + abs(abs(p.z) - box32.z)+.15) * .08/exp(d.x));\n            }\n            else{\n                p = mod(p*2., 1.) - .5;\n                col += smoothstep(.5, 1., .05/length(p.xz));\n                break;\n            }\n            \n        }\n        \n        vec3 nor = calcNormal(p, d.y);\n        vec3 ref = reflect(rd, nor);\n\n        ro = p - nor * EPS;\n        rd = ref;\n        td = EPS;\n    }\n    \n \n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    float t = iTime;\n    \n    vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 col = vec3(0), col2 = vec3(0);\n    //---------------------------------------------------------------//\n\n    vec3 ro, tg;\n    \n    t*=.3;\n    ro = vec3(cos(t)*1.8, 0., sin(t)*1.8);\n    tg = vec3(0,0,0);\n\n    mat3 ca = setCamera(ro, tg, 0.);\n    vec3 rd = ca * normalize(vec3(uv, 1.));\n\n    vec3 p;\n    vec2 d;\n    float td;\n        \n    col = raymarch(ro, rd);\n    \n    \n \n    //---------------------------------------------------------------//\n    //col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1);\n    \n}","name":"Image","description":"","type":"image"}]}