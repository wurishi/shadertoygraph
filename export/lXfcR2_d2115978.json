{"ver":"0.1","info":{"id":"lXfcR2","date":"1726421903","viewed":46,"name":"Golden Sphere","username":"Escher","description":"Inspired by https://blog.wolfram.com/2011/07/28/how-i-made-wine-glasses-from-sunflowers/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere","golden","phionacci"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy Shader: Rendering Small Spheres at Distributed Points\n\n\n// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n\n    // Camera setup\n    vec3 cameraPos = vec3(0.0, 0.0, 2.0);\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDir = normalize(vec3(uv, -1.5));\n\n    vec3 color = vec3(0.0);\n\n    // Oscillating number of points between 5 and 255\n    float oscillation = abs(sin(iTime * 0.5));\n    int N = int(5.0 + oscillation * 250.0); // N ranges from 5 to 255\n    N = clamp(N, 5, 255); // Ensure N stays within bounds\n\n    float tMin = 10000.0;\n    vec3 finalColor = vec3(0.0);\n    bool hit = false;\n\n    // Loop over points (max 256 iterations due to ShaderToy limitations)\n    for (int i = 0; i < 256; i++)\n    {\n        if (i >= N) break; // Stop loop if we've reached the current N\n\n        float i_float = float(i);\n\n        // Compute z-coordinate\n        float z = 1.0 - 2.0 * (i_float + 0.5) / float(N);\n        float radius = sqrt(1.0 - z * z);\n\n        // Golden angle in radians\n        float goldenAngle = 3.14159265359 * (3.0 - sqrt(5.0));\n\n        // Compute azimuthal angle with optional rotation over time\n        float theta = goldenAngle * i_float + iTime * 0.1;\n\n        // Compute Cartesian coordinates\n        float x = radius * cos(theta);\n        float y = radius * sin(theta);\n\n        vec3 spherePos = vec3(x, z, y); // Adjusted coordinate system\n\n        // Small sphere radius\n        float sphereRadius = 0.01; // Adjust as needed\n\n        // Ray-sphere intersection\n        vec3 oc = rayOrigin - spherePos;\n        float b = dot(oc, rayDir);\n        float c = dot(oc, oc) - sphereRadius * sphereRadius;\n        float discriminant = b * b - c;\n\n        if (discriminant > 0.0)\n        {\n            float t = -b - sqrt(discriminant);\n            if (t > 0.0 && t < tMin)\n            {\n                tMin = t;\n                hit = true;\n\n                // Assign color based on point index or position\n                float hue = fract(i_float / float(N));\n                vec3 pointColor = hsv2rgb(vec3(hue, 1.0, 1.0));\n\n                finalColor = pointColor;\n            }\n        }\n    }\n\n    if (hit)\n    {\n        // Shading for the small sphere\n        vec3 hitPoint = rayOrigin + tMin * rayDir;\n        vec3 normal = normalize(hitPoint - (hitPoint - rayOrigin));\n\n        // Simple lighting (ambient + diffuse)\n        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n\n        color = finalColor * (0.3 + 0.7 * diffuse); // Mix ambient and diffuse\n    }\n    else\n    {\n        // Background color\n        color = vec3(0.1, 0.1, 0.1); // Dark gray background\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}