{"ver":"0.1","info":{"id":"MsV3Dh","date":"1454369440","viewed":334,"name":"Wrist Slitter","username":"jessec","description":"Kill me now!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Jesse Connell - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst vec2 DEST = vec2(-0.2334000, 0.82724);\nconst float ESCAPE_RADIUS = exp(4.0);\nconst float ESCAPE_RADIUS2 = exp(4.0)*exp(4.0);\nconst int ITER_MAX = 75;\nconst float SPEED = 0.8;\nconst int AA_STEPS = 3;\n\n\nvec2 zoomto(in vec2 xy, in vec2 target, in float t)\n{\n    float p = pow(SPEED, t);\n    float p2 = 1.0 - p;\n    return target * p2 + xy*p;\n}\n\nvec2 map(in vec2 xy) { \n    float mdim = min(iResolution.x, iResolution.y);\n    \n    xy = (xy - 0.5*iResolution.xy) / mdim * 4.0; \n    return zoomto(xy, DEST, iTime);\n}\nfloat usin(in float x)\n{\n    return sin(x)*0.5 + 0.5;\n}\n\nvoid frac(in vec2 xy, out float iter, out vec2 Z, out float dist)\n{\n    vec2 C = xy;\n    iter = 1.0;\n    Z = C;\n    vec2 C2 = vec2(-0.4, 0.6);\n    float dist2 = Z.x*Z.x + Z.y*Z.y;\n    for(int i = 0; i < ITER_MAX; ++i)\n    {\n        if (dist2 > ESCAPE_RADIUS2)\n        {\n            break;\n        }\n        Z = vec2(Z.x*Z.x - Z.y*Z.y, 2.0*Z.x*Z.y) + C;\n        dist2 = Z.x*Z.x + Z.y*Z.y;\n        iter += 1.0;\n    }\n    if (iter < float(ITER_MAX))\n    {\n        dist = sqrt(dist2);\n        //Z = vec2(Z.x*Z.x - Z.y*Z.y, 2.0*Z.x*Z.y) + C;\n        //Z = vec2(Z.x*Z.x - Z.y*Z.y, 2.0*Z.x*Z.y) + C;\n\t    dist = 3.0*log(log(dist))/log(8.0) - 2.0;\n    }\n    else\n    {\n        dist = length(Z);\n    }\n}\n\nvec4 getColor( in vec2 xy )\n{\n    vec2 Z;\n    float dist;\n    float iter;\n    vec2 zxy = map(xy);\n    frac(zxy, iter, Z, dist);\n    \n    if (int(iter) >= ITER_MAX)\n    {\n        return texture(iChannel0, zxy*0.25 + 0.5);\n    }\n    \n    float PI = 3.14159265358;\n    float twoPI = PI*2.0;\n    float a = (atan(Z.y, Z.x) + PI)/twoPI;\n    dist = max(min(dist, 1.0), 0.0);\n    float sz = 0.1;\n\t//fragColor = vec4(dist, a, dist, 1.0) * sz;\n    float sgn = (iter - float(int(iter)/2*2))*2.0-1.0;\n    float picx = mod(a + iTime*sgn, 1.0);\n    vec4 color = texture(iChannel0, vec2(picx, dist));\n    if (color.y/(color.x + color.y + color.z)\n        >= 0.5 && color.y > .4)\n    {\n        float id = iter - dist;\n        color = vec4(\n        \tusin(id*0.2 + iTime),\n            usin(id*0.23456 + iTime*1.12345),\n            usin(id*0.44444 - iTime*0.33333),\n            1.0);\n    }  \n    return color;\n}\n\nvoid mainImage(out vec4 color, in vec2 xy)\n{\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    int inc = AA_STEPS;\n    float stepInc = 1.0/float(AA_STEPS);\n    \n    for(int ii = 0; ii < AA_STEPS; ++ii)\n    {\n\t    for(int jj = 0; jj < AA_STEPS; ++jj)\n    \t{\n        \tcolor3 += getColor(xy + vec2(float(ii)*stepInc, float(jj)*stepInc)).xyz;\n        }\n    }\n    color3 *= stepInc*stepInc;\n    color = vec4(color3, 1.0);\n}","name":"Image","description":"","type":"image"}]}