{"ver":"0.1","info":{"id":"XlVBRd","date":"1543624925","viewed":129,"name":"Particles exercise","username":"Vermifuge","description":"particles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 one = vec2(1., 0.);\nconst float cells = 5.;\n\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(17.2512372,259.12379)))*7326.26723);\n}\n\nfloat noise(vec2 uv) {\n    vec2 ix = floor(uv);\n    vec2 fx = fract(uv);\n    fx = fx*fx*(3.-2.*fx);\n    \n    float bl = hash(ix);\n    float br = hash(ix + one.xy);\n    float tl = hash(ix + one.yx);\n    float tr = hash(ix + one.xx);\n   \n    return mix(\n        mix(bl, br, fx.x),\n        mix(tl, tr, fx.x),\n        fx.y);\n}\n\nfloat fbm(vec2 uv) {\n    float c = .5;\n    float po = 1.;\n    float res = 0.;\n    for (int i = 0; i < 4; ++i) {\n        res += c * noise(uv*po);\n        c /= 2.;\n        po *= 2. + .03 * hash(vec2(po));\n    }\n    return res;\n}\n\nfloat snow(vec2 uv, float cells) {\n    vec2 ruv = uv;\n    uv = uv * cells;\n    float px = noise(floor(uv) + 3.*one.yx * iTime) - .0;\n    float py = noise(floor(uv) + 3.*one.xy * iTime + 23.246*one);\n    float r = .02 + .06*noise(floor(uv) + one.xy * iTime + 235.246);\n    \n    vec2 pt = vec2(px, py);\n    return 1.-smoothstep(0.001, 2.*r, length(fract(uv) - pt));\n}\n\nvec2 wind(float cells) {\n    return 1./cells*iTime * one.yx - 4./cells*iTime * one.xy;\n}\n\nfloat ground(vec3 p) {\n    vec2 hills = p.xz / 5. + iTime;\n    return p.y - 3.*(fbm(hills)-.5) - noise(hills);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001, 0.);\n    return normalize(vec3(\n        ground(p + e.xyy) - ground(p - e.xyy),\n        ground(p + e.yxy) - ground(p - e.yxy),\n        ground(p + e.yyx) - ground(p - e.yyx)));\n}\n\nvec4 raymarch(vec2 uv) {\n    vec3 camera = vec3(0., 2. + iMouse.y / iResolution.y * 10., -1.);\n    vec3 dir = normalize(vec3(uv - .2 * one.yx, 1.));\n    \n    float t = 0.;\n    vec3 p = camera;\n    for (int i = 0; i < 70; ++i) {\n        vec3 r = camera + t * dir;\n        float d = ground(r);\n        if (d < .001) {\n            p = r;\n        }\n        t += d;\n    }\n    if (t > 100.) {\n        return vec4(p, 0.);\n    }\n    return vec4(vec3(dot(normal(p), one.yxy)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 screenpos = uv;\n    \n    \n    vec3 col = mix(vec3(.1, .1, .2), vec3(.3, .3, .7), 1.-screenpos.y);\n    vec4 obj = raymarch(uv);\n    col = mix(col, obj.xyz, obj.w);\n    \n    float snowflake = snow(uv + wind(10.), 12.) + snow(uv + wind(15.), 12.)\n        + snow(uv + wind(20.), 20.)\n        + snow(uv + wind(3.), 3.)\n        + snow(uv + wind(6.), 6.);\n    \n    col = mix(col, vec3(1.), snowflake);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}