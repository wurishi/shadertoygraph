{"ver":"0.1","info":{"id":"NtXcRf","date":"1648392943","viewed":110,"name":"Ray traced spherical refraction","username":"ivan100sic","description":"Refraction and internal/external reflection of light on moving glass ball is simulated. Code is somewhat decently documented and can be used for learning. \nHold the left mouse button to look around (though there's not really much to look at)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","refraction","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct camera_t {\n    vec3 center;\n    vec3 direction; // normalized\n    vec3 dir_up;    // normalized\n};\n\nstruct ray_t {\n    vec3 origin;\n    vec3 direction; // normalized\n};\n\nconst float pi = 3.1415926535;\n\nvec3 direction_from_mouse() {\n    float thx = (iMouse.x / iResolution.x - 0.5) * 2.0 * pi;\n    float thy = (iMouse.y / iResolution.y - 0.5) * pi;\n    return vec3(-sin(thx) * cos(thy), sin(thy), cos(thx) * cos(thy));\n}\n\n// Return a vector rotated 90 degrees towards y+\nvec3 look_up(vec3 direction) {\n    return normalize(\n        cross(\n            cross(direction, vec3(0.0, 1.0, 0.0)),\n            direction\n        )\n    );\n}\n\ncamera_t default_camera() {\n    camera_t result;\n    result.center = vec3(0.0, 1.0, -3.0);\n    result.direction = direction_from_mouse();\n    // 90 degrees towards y+\n    result.dir_up = look_up(result.direction);\n    return result;\n}\n\ncamera_t camera_look_at(camera_t camera, vec3 target) {\n    camera.direction = normalize(target - camera.center);\n    camera.dir_up = look_up(camera.direction);\n    return camera;\n}\n\nray_t ray_from_camera_pixel_perspective(camera_t cam, vec2 uv, vec2 fov) {\n    ray_t result;\n    result.origin = cam.center;\n    result.direction = cam.direction;\n    result.direction += cam.dir_up * uv.y * fov.y;\n    result.direction += cross(cam.direction, cam.dir_up) * uv.x * fov.x;\n    result.direction = normalize(result.direction);\n    return result;\n}\n\nvec3 sky_color(float direction_y) {\n    float t = 0.8 - direction_y / 2.0;\n    return vec3(t * 0.7, t, 1.0);\n}\n\nconst vec3 tile_color_1 = vec3(0.43);\nconst vec3 tile_color_2 = vec3(0.27);\n\nvec3 tiled_floor_color(ray_t ray) {\n    float t = -ray.origin.y/ray.direction.y;\n    vec2 hit = (ray.origin + ray.direction * t).xz;\n    return (mod(hit.x, 1.0) <= 0.5) != (mod(hit.y, 1.0) <= 0.5) ?\n        tile_color_1 :\n        tile_color_2;\n}\n\nvec3 floor_colored_ring_color(ray_t ray) {\n    float t = -ray.origin.y/ray.direction.y;\n    vec2 hit = (ray.origin + ray.direction * t).xz;\n    vec3 color = (mod(hit.x, 1.0) <= 0.5) != (mod(hit.y, 1.0) <= 0.5) ?\n        tile_color_1 :\n        tile_color_2;\n    float distance = dot(hit, hit);\n    if (16.0 <= distance && distance <= 36.0) {\n        float ang = atan(hit.y, hit.x);\n        color += 0.2 * (1.0 + sin(vec3(0.0, pi/3.0, 2.0*pi/3.0) + ang));\n    }\n    return color;\n}\n\nvec3 scene_ray_background(ray_t ray) {\n    if (ray.direction.y >= 0.0) {\n        return sky_color(ray.direction.y);\n    } else {\n        return floor_colored_ring_color(ray);\n    }\n}\n\nfloat ray_unit_sphere_distance(ray_t ray) {\n    float ray_dot = dot(ray.direction, ray.origin);\n    float origin_dist_squared = dot(ray.origin, ray.origin);\n    float under_sqrt = 1.0 - origin_dist_squared + ray_dot*ray_dot;\n    if (under_sqrt <= 0.0) {\n        // No intersection\n        return -1.0;\n    } else if (origin_dist_squared <= 1.0) {\n        // Inside sphere, return positive solution\n        return -ray_dot+sqrt(under_sqrt);\n    } else {\n        // Outside, return negative solution\n        return -ray_dot-sqrt(under_sqrt);\n    }\n\n    return -1.0;\n}\n\nfloat ray_sphere_distance(ray_t ray, vec4 sphere) {\n    ray.origin -= sphere.xyz;\n    ray.origin /= sphere.w;\n    float f = ray_unit_sphere_distance(ray);\n    return f * sphere.w;\n}\n\n// Generic reflection from surfaces, returns new direction\n// @param l Direction of incoming light\n// @param n Surface normal\nvec3 ray_reflect(vec3 l, vec3 n) {\n    return normalize(l - 2.0*n*dot(l, n));\n}\n\nfloat schlick_approximation(float r, float c) {\n    float r0 = (r-1.0)/(r+1.0);\n    r0 *= r0;\n    c = 1.0-c;\n    return r0+(1.0-r0)*c*c*c*c*c;\n}\n\n// @param l Direction of incoming light\n// @param n Surface normal\n// @param r Refraction index\n// The fourth component of the result is the power transmitted in the\n// direction returned. The rest of the power is reflected.\n// In case of total internal reflection, the reflected ray is returned with power 100%\nvec4 ray_refract(vec3 l, vec3 n, float r) {\n    float c = -dot(n, l);\n    float under_root = 1.0 - r*r*(1.0 - c*c);\n    if (under_root <= 0.0) {\n        return vec4(ray_reflect(l, n), 1.00);\n    } else {\n        float reflected = schlick_approximation(r, c);\n        return vec4(normalize(r*l + (r*c - sqrt(under_root)) * n), 1.0 - reflected);\n    }\n}\n\nvec3 sphere_surface_normal(vec3 point, vec4 sphere) {\n    return (point - sphere.xyz) / sphere.w;\n}\n\nvec4 scene_moving_sphere() {\n    // Make the sphere move around a little\n    return vec4(\n        sin(iTime * 0.161),\n        0.8 + 0.3 * sin(iTime * 0.37),\n        2.0 * sin(iTime),\n    0.5);\n}\n\nvec3 scene_ray_sphere_mirror(ray_t ray) {\n    vec4 sphere = scene_moving_sphere();\n    float f = ray_sphere_distance(ray, sphere);\n    if (f > 0.0) {\n        // Point where the collision occurs\n        vec3 hit = ray.direction * f + ray.origin;\n\n        ray.direction = ray_reflect(ray.direction, sphere_surface_normal(hit, sphere));\n        ray.origin = hit;\n    }\n\n    return scene_ray_background(ray);\n}\n\nvec3 scene_ray_glass_ball(ray_t source_ray) {\n    const float glass = 1.0 / 1.5;\n    const int steps = 5;\n    \n    vec4 sphere = scene_moving_sphere();\n    vec3 result = vec3(0);\n\n    for (int mask = 0; mask < (1 << steps); mask++) {\n        float ray_power = 1.0;\n        ray_t ray = source_ray;\n        for (int i = 0; i < steps; i++) {\n            float f = ray_sphere_distance(ray, sphere);\n            if (f >= 0.0) {\n                // Point where the collision occurs\n                vec3 hit = ray.direction * f + ray.origin;\n\n                float index = glass;\n                vec3 normal = sphere_surface_normal(hit, sphere);\n                if (length(ray.origin - sphere.xyz) <= sphere.w) {\n                    index = 1.0 / index;\n                    normal = -normal;\n                }\n\n                vec4 refract_result = ray_refract(ray.direction, normal, index);\n                // Do we take the refraction or reflection?\n                if ((mask & (1 << i)) != 0) {\n                    ray.direction = refract_result.xyz;\n                    ray_power *= refract_result.w;\n                } else {\n                    ray.direction = ray_reflect(ray.direction, normal);\n                    ray_power *= 1.0 - refract_result.w;\n                }\n                ray.origin = hit + ray.direction * 0.001;\n            } else {\n                ray_power *= 0.5;\n            }\n        }\n        result += ray_power * scene_ray_background(ray);\n    }\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    vec2 fov;\n    fov.x = 1.0;\n    fov.y = fov.x * iResolution.y / iResolution.x;\n\n    camera_t camera = default_camera();\n    bool mouse_down = iMouse.z > 0.0;\n    if (!mouse_down) {\n        camera = camera_look_at(camera, scene_moving_sphere().xyz);\n    }\n\n    ray_t ray = ray_from_camera_pixel_perspective(camera, uv, fov / 2.0);\n    vec3 col = scene_ray_glass_ball(ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}