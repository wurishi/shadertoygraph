{"ver":"0.1","info":{"id":"WtBcRD","date":"1593790939","viewed":318,"name":"Moebius Lizard - study","username":"FabriceNeyret2","description":"studying \"Moebius Lizard\" by iapafoto. [url]https://shadertoy.com/view/wtjyz1[/url]\nT encodes shape, turned 4x by Pi/2, + copied trough tiles.\nVoronoi coloring identify lines.\nTrying to #FILL the shape, but uneasy since we never draw a close contour !","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["2d","lizard","moebus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// === Studying \"Moebius Lizard\" by iapafoto. https://shadertoy.com/view/wtjyz1\n\n//#define FILL 2           // 1 : try shape filling   2: better: with close contour\n#define FILL ( fract(iTime/3.)<.5 ? 0 : 2 )\n//#define mod(a,b) a     // uncomment to see only 1 tile \n\n// --- L() get the distance d of p=U-a to segment(a-a,b-a) \n// AND get whether pixel in/out shape by counting the number of intersection with [U,U+(0,inf)]\n//     for close contours, n is odd inside and even outside.\n// l get the label of the closest line\nvec2 q; float s,c,v,d=1e3; int k,n=0;\n#define L(p,l) v = length( q = p-b*( c = clamp( s = dot(p,b)/dot(b,b),0.,1.))); \\\n               if (v<d) d=v, k=l;                                               \\\n               c = clamp ( s = p.y/b.y, 0.,1.);                                 \\\n               if ( c == s && s * b.x > (p).x ) n++\n            \n// --- T encodes shape, turned 4x by Pi/2, + copied trough tiles.\n// note that a Lizard is contoured by 3 of these.        Vsame Yv                         Vsame xV\nint[] T = int[](6,0,9,2,12,5,6,10,0,20,  6,26,  12,20,11,17,14,17,17,18,15,22,11,26,16,26,22,18,22,27,25,28,28,30,30,26\n          // left hand  - left of head (10)head right of head                   -                right foot\n    ,     // completed contour. Used only with FILL=2\n    26,24,28,21,29,18,38,18,30,12,30,7,34,11,38,13,39,10,39,7,36,8,  30,2,    24,8,14,2,9,-4,6,-1,4,2, 6,0 );\n          //       ^same y^                        ^same x^\n\nvoid drawTile(vec2 m, int i, int r) {\n    vec2 a = vec2(T[i],T[i+1]),\n         b = vec2(T[i+2],T[i+3])-a,\n         p = m-a;\n    L(p, 4*r);                                      // ok alone with m = mod(U+g+12.,48.)-12.\n/*\n#if 1\n    L(p-vec2(48,0), 4*r+1);                         //  with m = mod(U+g, 48.)\n#else\n    L(p-h,4*r+0); L(p-h.yx,4*r+0); L(p-h.yy,4*r+0); // with m = U + g \n#endif \n*/\n}\n    \nvoid mainImage(out vec4 O, vec2 u ) {\n    \n    vec2 R = iResolution.xy,\n         m = 2.*iMouse.xy/R,\n         U = (u - .5*R) / R.y , _U,_m, h = vec2(0,48), g = vec2(30,26), I;     \n    U *= 1.3;\n    I = floor(U+.5);\n  //U =(fract(U+.5)-.5); // no longer needed with m = mod(U+g...\n    U *= 48.;\n\n    int nn=-1;\n    for (int r=0; r < (true?4:1); r++)\n    {   \n      //m = U + g; \n      //m = mod(U+g, 48.);\n        m = mod(U+g+8.,48.)-8.;\n        U = vec2(-U.y,U.x); \n        for (int i=0; i < ( FILL==2 ? T.length()-2 : 34 ); i+=2) {\n            drawTile(m,i,r);\n            if (FILL==1){      // 1: manually close contour per lizard  \n                _U = U; _m=m;  // 2: T already complete\n                if (i<10) U =  U - vec2(48,0);\n                else      U = -U;\n                m = mod(U+g+12.,48.)-12.;\n                drawTile(m,i,r);\n                U = _U; m = _m;\n            }\n        }\n        if (n%2>0) nn=r, n=0; // for checkered filling color\n    }\n    if(nn>=0) n=nn;\n    \n    // --- returned values: d = distance to contour, n = fill parity, I = tileId\n\n    float ch = mod(I.x+I.y,2.);\n    O = vec4( ( clamp(d,0.,1.)+.5*sin(10.*d) )   // contour + isovals\n             * ( .7+.3*ch ) );                   // checkered tiles\n    O = .5*O + .5* (.6 + .6 * cos( float(k) + vec4(0,23,21,0)  )); // Voronoi contour coloring\n    if (FILL>0) O = mix( O , vec4(n%2), .6 );    // shape filling\n}\n\n","name":"Image","description":"","type":"image"}]}