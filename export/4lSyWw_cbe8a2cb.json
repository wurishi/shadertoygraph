{"ver":"0.1","info":{"id":"4lSyWw","date":"1579833003","viewed":132,"name":"noodle1","username":"kvick","description":"noodes","likes":4,"published":1,"flags":40,"usePreview":0,"tags":["noodle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy);\n    \n    //Chroma shift?\n    vec4 colOrig = texture(iChannel0, uv);\n    vec4 colShift1 = texture(iChannel0, vec2(uv.x + 0.009, uv.y));\n  \n    fragColor = colOrig;\n    fragColor = vec4(vec3(colOrig.xy, colShift1), 1.0);\n    fragColor = mix(colOrig, vec4(vec3(colOrig.xy, colShift1), 1.0), uv.y);\n    \n    //Gaussian blur, why not\n    //https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n\n\n    //filter by dist to center\n    vec2 centerPoint = vec2(0.5, 0.5);\n    vec2 vToCenter = centerPoint - uv;\n    vec3 final_color = final_colour/(Z*Z);\n    float dist = length(vToCenter) * 1.2;\n    fragColor = mix(fragColor, vec4(final_color, 1.0), dist);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.14159265359;\n\n//https://www.shadertoy.com/view/Xljczw\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\n//https://www.shadertoy.com/view/MslGR8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat addNoise( vec2 seed )\n{\n \treturn (hash12( seed ) + hash12(seed + 0.59374) - 0.5 );   \n}\n\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = vec2(uv.x * (iResolution.x / iResolution.y), uv.y);\n    vec2 pos = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 invUV = vec2(-uv.x + 1.0, -uv.y + 1.0);\n    \n    //(pi * 2.0) correlates to 1 full rotation per second\n    const float pi2 = (pi * 2.0);\n    float speed = pi2 * 0.125;\n    float phasor1 = sin(iTime * speed + (uv.x * pi2 * 4.0));\n    float phasor2 = sin(iTime * speed * 1.2 + (uv.x + 0.5) * (pi2));\n    float phasor3 = sin(iTime * speed * 4.2 + (uv.x * pi2));\n    float phasorResult = (phasor1 + phasor2 + phasor3) * 0.01625 + 0.25;\n    \n    //Color\n    const float col1_amb = 0.5;\n    vec3 col1 = vec3(0.0, 0.0, uv.y) + vec3(col1_amb);\n    \n    float col2_amb = (0.25 * invUV.y) * 0.3;\n    vec3 col2 = vec3(0.2, 0.4, 0.5) + vec3(col2_amb);\n    \n    //Draw sun\n    const float sunPosHz = 10.0;\n    const float circleRadius = 0.5;\n    const float sunSpeed = 0.01;\n    vec2 sunPos = vec2(sin(iTime * sunSpeed) * 1.2, cos(iTime * sunSpeed) * 0.5) * circleRadius + vec2(1.00, 0.4);//vec2(sin(iTime * pi2 / sunPosHz) * 0.5 + 0.5, sin(iTime * pi2 / sunPosHz * 0.5) * 0.5 + 0.5);\n    vec2 sunSize = vec2(0.2, 0.3);\n    float sunRadius = 0.2;\n    vec2 vToSun = sunPos - st;\n    float distToSun = sqrt(pow(vToSun.x, 2.0) + pow(vToSun.y, 2.0));\n    \n    float spinSpeed = 0.001;\n    float angle = mod(atan(vToSun.y, vToSun.x) + iTime * spinSpeed, pi2);// + (sin(iTime) * 0.5 + 0.5) * 55.0;\n    float sunEdgePhasor1 = (sin(angle * 10.0) * (sin(iTime) * 0.5 + 0.5 + 0.25) * 0.01);\n    float sunEdgePhasor2 = (sin((angle + 0.2) * 10.0) * (sin(iTime) * 0.5 + 0.5 + 0.25) * 0.01);\n    float sunEdgePhasor3 = (sin((angle + 0.1) * 5.0) * (sin(iTime) * 0.5 + 0.5 + 0.25) * 0.005);\n    float moddedDist = distToSun + sunEdgePhasor1 + sunEdgePhasor2 + sunEdgePhasor3;\n    //sunColor.r = sin(angle) * 0.5 + 0.5;\n    \n    float i = 1.0;\n    const float iterations = 8.0;\n    for (i = 1.0; i <= iterations; ++i)\n    {\n        const float outlineThickness = 0.01;\n        float currentThickness = outlineThickness + i * 0.005;\n        vec3 outlineColor = vec3(0.9, 1.0 - i * 0.1, 0.5 + i * 0.1);\n        float distFromSun = i * 0.125;\n        const float crawlSpeed = 0.025;\n        if (\n            moddedDist > sunRadius + distFromSun + currentThickness * 0.5 \n            && moddedDist < sunRadius + distFromSun + currentThickness \n            && mod(angle + i + iTime * crawlSpeed, pi * 0.25) > pi * 0.125//Add the crawly bits to the outline\n        )\n            col1 = outlineColor;//Draw sun outline\n    }\n    \n    const vec3 sunColor = vec3(0.95, 0.89, 0.95);\n    if (moddedDist < sunRadius)\n        col1 = sunColor;//Draw sun filling\n    \n    //Drawing dots\n    float dotSize = (1.0 - uv.y) * 0.03 + 0.01;\n    float dotSpeed = (1.0 - uv.y) * 5.0 + 0.2;\n    if (fract(st.x + iTime) < dotSize &&\n        fract(st.y + iTime) < dotSize)\n        col1 = sunColor;\n    \n    if (uv.y > phasorResult)\n        fragColor = vec4(col1, 1.0);\n    else\n        fragColor = vec4(col2, 1.0);\n    \n    //Vignette, center of the screen is 0, 0\n    float vignetteSize = 0.5;\n    vec2 modUV = (uv * vignetteSize) + (vignetteSize * 0.5);\n    float vignetteCol = pow(10.0 * modUV.x * (1.0 - modUV.x) * modUV.y * (1.0 - modUV.y), 1.0);\n        vignetteCol *= 1.0 + hash1( modUV * iTime ) * 0.1;\n    fragColor *= vignetteCol;\n    \n    //Adding noise on top\n    fragColor *= 1.0 + (addNoise(uv + iTime) * 0.05);\n    \n    \n    //Apply weird IQ hexagon thing I dont understand on top\n    //fragColor *= vec4(hexagon((uv * iTime) * 25.0).z, 0.0, 0.0, 1.0);\n    \n    //fragColor = vec4(uv.x * (iResolution.x / iResolution.y), uv.y, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159265359;\nconst float pi2 = 6.28318530718;\n\nvec2 mainSound( in int samp, float time )\n{\n    \n    float modTime = time * 2.0;\n    \n    if (mod(floor(modTime * 0.25), 2.0) == 0.0)\n    {\n     \tmodTime *= 2.0;   \n    }\n    \n    if (mod(floor(modTime * 0.5), 2.0) == 0.0)\n    {\n     \tmodTime *= 4.0;   \n    }\n    \n    float baseHz1 = 110.0;\n    \n    if (mod(floor(time * 0.0625), 2.0) == 0.0)\n    {\n        baseHz1 = 100.0;\n    }\n    \n    if (mod(floor(time * 0.0625), 2.0) == 0.0)\n    {\n     \tbaseHz1 *= 1.5;\n    }\n    if (mod(floor(time * 0.125), 2.0) == 0.0)\n    {\n     \tbaseHz1 *= 1.75;\n    }\n    if (mod(floor(time * 0.25), 2.0) == 0.0)\n    {\n     \tbaseHz1 *= 1.5;\n    }\n    \n    \n    float baseHz2 = baseHz1 * 1.5;\n    float baseHz3 = baseHz2 * 1.5;\n    \n    float r = \tsin(baseHz1 * 2.0 * time) * 4.0+ \n        \t\tsin(baseHz1 * 4.0 * time) + \n        \t\tsin(baseHz1 * 8.0 * time);\n    \n    if (mod(floor(modTime), 4.0) == 0.0)\n    {\n     \tr *= 0.0;   \n    }\n    \n    r += sin(baseHz2 * 4.0 * time);\n    \n    r += sin(baseHz3 * 4.0 * time);\n    \n    \n    float l = \tsin(baseHz1 * 16.0 * time) + \n        \t\tsin(baseHz1 * 4.0 * time) + \n        \t\tsin(baseHz1 * 8.0 * time);\n    \n    if (mod(floor(modTime), 2.0) == 1.0)\n    {\n     \tl *= 0.0;\n    }\n    \n    l += sin(baseHz2 * 8.0 * time);\n    \n    if (mod(floor(time), 2.0) == 0.0)\n    {\n     \tfloat temp = l;\n        l = r;\n        r = temp;\n    }\n    \n    //Apply square wave pattern\n    if (mod(floor(time * 0.25), 2.0) == 0.0)\n    {\n        time *= 2.0;\n        float timeFract = 1.0 - fract(time * 0.25);\n     \tl = mix(floor(r), round(r), timeFract) * 0.8;\n        r = mix(floor(r), round(r), timeFract) * 0.8;\n    }\n    \n    return vec2(0.);//Mute, driving me nuts O.o\n    return vec2(r, l)*exp(-3.0*fract(time * 0.5));\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"Sound","description":"","type":"sound"}]}