{"ver":"0.1","info":{"id":"4sfyzM","date":"1487369492","viewed":753,"name":"Dodgson's Quadratic Filter","username":"won3d","description":"A pair of implementations of Dodgson's Quadratic filter, which has a 3x3 tap footprint (cubic filters typically have a 4x4 footprint). Using bilinear taps and ignoring the distant, small-weight corner, it is possible to implement using 3 samples.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["filter","quadratic","dodgson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on hornet's bicubic filter example (https://www.shadertoy.com/view/MtVGWz)\n\nvec4 sampleLevel0( vec2 uv )\n{\n    return texture( iChannel0, uv, -10.0 );\n}\n\n// Dodgson's parameterization.\n// 0.5: approximating (blurry)\n// 1.0: interpolating (sharp)\n// 0.8: Dodgson's compromise\n// Crazy value below is to minimize absolute value of side lobe.\nconst float R = 0.5*(1.0+sqrt(0.5));  // ~0.85355\n\n//const float R = 1.0;\n\n// Dodgson's quadratic filter weights are defined by two parabolas.\n// The center one is straightforward.\nvec2 DQCenter(vec2 x) {\n    return 0.5*(R+1.0) - 2.0*R*x*x;\n}\n\nvec2 DQLobe(vec2 x) {\n    return R*x*x - (2.0*R+0.5)*abs(x) + 0.75*(R+1.0);\n}\n\n// Seems to work best with linear gamma?\nconst float kGamma = 1.0;\n\nvec4 unSRGB(vec4 x) {\n    return pow(x, vec4(1.0/kGamma));\n}\n\nvec4 sRGB(vec4 x) {\n    return pow(x, vec4(kGamma));\n}\n\nconst ivec2  N = ivec2( 0,  1);\nconst ivec2  S = ivec2( 0, -1);\nconst ivec2  E = ivec2( 1,  0);\nconst ivec2  W = ivec2(-1,  0);\nconst ivec2 NW = ivec2(-1,  1);\nconst ivec2 NE = ivec2( 1,  1);\nconst ivec2 SE = ivec2( 1, -1);\nconst ivec2 SW = ivec2(-1, -1);\n\n// A reference implementation that uses texelFetch[Offset] with individual\n// weights and color correction. Written for clarity.\nvec4 DodgsonQuadraticRef(vec2 uv, vec2 texSize) {\n    // Compute integer and fractional texel coordinates.\n    vec2 texUV = uv * texSize;\n    ivec2 itexel = ivec2(texUV);\n    vec2 ftexel = vec2(itexel) + 0.5;\n    ftexel = texUV - ftexel;\n    \n    // Fetch a 3x3 patch of texels. 2-D arrays would have been nice.\n    vec4  fetchC =       texelFetch(iChannel0, itexel, 0);\n    vec4  fetchN = texelFetchOffset(iChannel0, itexel, 0, N);\n    vec4  fetchS = texelFetchOffset(iChannel0, itexel, 0, S);\n    vec4  fetchE = texelFetchOffset(iChannel0, itexel, 0, E);\n    vec4  fetchW = texelFetchOffset(iChannel0, itexel, 0, W);\n    vec4 fetchNW = texelFetchOffset(iChannel0, itexel, 0, NW);\n    vec4 fetchNE = texelFetchOffset(iChannel0, itexel, 0, NE);\n    vec4 fetchSE = texelFetchOffset(iChannel0, itexel, 0, SE);\n    vec4 fetchSW = texelFetchOffset(iChannel0, itexel, 0, SW);\n   \n    // Compute weights based on fractional texel coordinates.\n    vec2 texelSign = sign(ftexel);\n    vec2 w0 = DQLobe(ftexel - texelSign);\n    vec2 w1 = DQCenter(ftexel);\n    vec2 w2 = DQLobe(ftexel + texelSign);\n\n    // Transpose weights based on fractional texel coordinates.\n    vec3 wH = vec3(0.0, w1.x, 0.0);\n    vec3 wV = vec3(0.0, w1.y, 0.0);\n\n    // A bit tricky! assign weights based on which side of the\n    // center tap UV is located.\n    if (texelSign.x < 0.) {\n      // sample is West of texel.\n      wH.x = w0.x;\n      wH.z = w2.x;\n    } else if (texelSign.x > 0.) {\n      // sample is East of texel.\n\t  wH.x = w2.x;\n      wH.z = w0.x;\n    }\n    if (texelSign.y > 0.) {\n      // sample is North of texel.\n      wV.x = w0.y;\n      wV.z = w2.y;\n    } else if (texelSign.y < 0.){\n      // sample is South of texel.\n\t  wV.x = w2.y;\n      wV.z = w0.y;\n    }\n        \n    // Combine weights.\n    mat3 w = outerProduct(wH, wV);\n    vec4 ret =\n    \tw[0][0] * unSRGB(fetchNW) +\n        w[0][1] * unSRGB(fetchN)  +\n    \tw[0][2] * unSRGB(fetchNE) +\n        w[1][0] * unSRGB(fetchW)  +\n    \tw[1][1] * unSRGB(fetchC)  +\n        w[1][2] * unSRGB(fetchE)  +\n    \tw[2][0] * unSRGB(fetchSW) +\n        w[2][1] * unSRGB(fetchS)  +\n        w[2][2] * unSRGB(fetchSE);\n    \n    return sRGB(ret);\n}\n\n// An approximate implementation using bilinear samples and using\n// the 8 (out of 9) most significant samples.\nvec4 DodgsonQuadraticFast(vec2 uv, vec2 texSize) {\n    // Compute integer and fractional texel coordinates.\n    vec2 texUV = uv * texSize;    \n    ivec2 itexel = ivec2(texUV);\n    vec2 texelCenter = vec2(itexel) + 0.5;\n    vec2 ftexel = texUV - texelCenter;\n    \t   \n    // Compute weights based on fractional texel coordinates.\n    vec2 texelSign;\n    texelSign.x = ftexel.x < 0.0 ? -1.0 : 1.0;\n    texelSign.y = ftexel.y < 0.0 ? -1.0 : 1.0;\n        \n    vec2 w0 = DQLobe(ftexel - texelSign);\n    vec2 w1 = DQCenter(ftexel);\n    vec2 w2 = vec2(1.0) - w0 - w1;\n    \n    // Rescale texel coordinates back to [0, 1].\n    vec2 texScale = vec2(1.0) / texSize;\n\ttexelCenter *= texScale;\n    texelSign *= texScale;\n    \n    // Encode all 4 positive weighted taps in one bilinear sample.\n    // Note that these are relative weights and will need to be\n    // reweighted later.\n    vec2 nudge = w0 / (w0 + w1);\n    vec2 texelNudge = texelCenter + texelSign * nudge;\n    \n    // Compute location of negative-weighted taps. We skip the low\n    // magnitude tap in the far corner because it will never change\n    // the output noticably.\n    vec2 texelFar = texelCenter - texelSign;\n    \n    // Use the negative weights directly, but renormalize the\n    // positive weight which compensates for the missing tap while\n    // avoiding a bit of extra computation.\n    vec4 ret =\n        w2.x * unSRGB(sampleLevel0(vec2(texelFar.x, texelNudge.y))) +\n    \tw2.y * unSRGB(sampleLevel0(vec2(texelNudge.x, texelFar.y))) +\n        (1.0 - w2.x - w2.y) * unSRGB(sampleLevel0(texelNudge));\n    \n    return sRGB(ret);\n}\n\nconst bool showFilter = false;\n\nvec4 drawFilter(vec2 fragCoord) {\n    fragCoord = abs(3.0*fragCoord);\n    if (fragCoord.x > 1.5 || fragCoord.y > 1.5) {\n        return vec4(0.0);\n    }\n    \n    vec2 c = DQCenter(fragCoord);\n    vec2 l = DQLobe(fragCoord);\n    vec2 f = mix(c, l, greaterThan(fragCoord, vec2(0.5)));\n    float o = f.x * f.y;\n    return vec4(-20.0*o, o, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / max(iResolution.x, iResolution.y);\n \n    if (showFilter) {\n        fragColor = drawFilter(fragCoord.xy / min(iResolution.x, iResolution.y) - 0.5);\n        return;\n    }\n\n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.5 );\n   \tsample_uv += 0.03 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= (iMouse.z>0.0)? (iMouse.x + iMouse.y) * 0.001 : 0.06125;\n    \n                                        \n    vec4 color;\n    if ( uv.x < 0.5 ) {\n    \tcolor = DodgsonQuadraticFast( sample_uv, iChannelResolution[0].xy );\n        bool diff_hack = false;\n        if (diff_hack) {\n        \tcolor -= DodgsonQuadraticRef( sample_uv, iChannelResolution[0].xy );\n        \tcolor *= color;\n        \tcolor *= vec4(500.0);\n        }\n    } else\n        color = sampleLevel0( sample_uv );\n\n    fragColor = color - step(abs(uv.x-0.5), 0.001);\n\n}\n","name":"Image","description":"","type":"image"}]}