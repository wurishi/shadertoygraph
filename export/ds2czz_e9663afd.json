{"ver":"0.1","info":{"id":"ds2czz","date":"1687380349","viewed":33,"name":"Toiledd","username":"hermes777","description":"dddd\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ddd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Définition d'une fonction pour générer une couleur basée sur le temps t\nvec3 palette( float t ) {\n    // Création de vecteurs de couleur (en RGB) à partir de composants spécifiques\n    vec3 a = vec3(0.3, 0.7, 0.5); \n    vec3 b = vec3(0.2, 0.5, 0.5); \n    vec3 c = vec3(1.0, 1.0, 1.0); // couleur blanche\n    vec3 d = vec3(0.263,0.416,0.557); // couleur bleue\n\n    // Utilisation de ces vecteurs pour générer une couleur finale basée sur une fonction de cosinus\n    return a + b*cos(324.28317*(c*t+d) );\n}\n\n// Fonction principale qui génère la couleur finale pour chaque pixel de l'écran\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalisation des coordonnées du pixel à un intervalle de 0 à 1\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Conversion des coordonnées de pixel normalisées à un intervalle de -0.3 à 0.7\n    uv = uv * 0.9 - 0.3;\n    \n    // Correction du ratio d'aspect pour s'assurer que l'image n'est pas déformée\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Retournement de l'axe y pour l'effet de retournement de l'écran\n    uv.y = -uv.y;\n    uv.x = -uv.x;\n\n    // Stockage des coordonnées uv originales\n    vec2 uv0 = uv;\n    \n    // Initialisation de la couleur finale\n    vec3 finalColor = vec3(0.0);\n\n    // Boucle sur plusieurs \"couches\" de l'image pour ajouter de la complexité à la texture\n    for (float i = 0.0; i < 1.9; i++) {\n        // Calcul de l'angle de rotation basé sur le temps\n        float angle = -iTime * 1.07;\n        \n        // Création d'une matrice de rotation à partir de cet angle\n        mat2 rot = mat2(cos(angle), -sin(angle), -sin(angle), cos(angle));\n        \n        // Application de la rotation et de l'échelle aux coordonnées uv\n        uv = fract(rot * uv * 3.5) - 0.07;\n\n        // Calcul de la distance depuis le centre de l'image et application d'une décroissance exponentielle\n        float d = length(uv) * exp(-length(uv0));\n\n        // Conversion des coordonnées uv en coordonnées polaires\n        float r = length(uv);\n        float theta = atan(uv.y, uv.x);\n\n        // Application d'une spirale de Fibonacci à la couleur\n        vec3 col = palette(length(uv0) + i*.7 + iTime*.8 - 0.4*sqrt(theta));\n\n        // Modification de la distance pour ajouter une animation basée sur une fonction sinus\n        d = sin(d*33. + iTime)/0.7;\n        d = abs(d);\n\n                // Réduction de la distance pour augmenter l'effet de \"brillance\"\n        d = pow(0.05 / d, 1.88);\n\n        // Combinaison de la couleur et de la distance pour produire la couleur finale pour cette \"couche\"\n        finalColor += col * d;\n    }\n\n    // Affectation de la couleur finale au pixel de l'écran, avec une opacité de 2.1\n    fragColor = vec4(finalColor, 2.1);\n}\n\n\n/*\nDans la dernière partie du code, on finalise le calcul de la couleur de chaque pixel. \nLa distance modifiée d est utilisée pour donner un effet de \"brillance\" aux couleurs produites par la fonction palette.\nEnsuite, la couleur est affectée au pixel de l'écran.\nL'opacité est fixée à 2.1, ce qui est techniquement au-delà du maximum de 1.0,\nmais cela peut être utilisé dans certains cas pour créer des effets de surbrillance ou de bloom lorsqu'ils sont combinés avec d'autres étapes de post-traitement.\n*/\n\n","name":"Image","description":"","type":"image"}]}