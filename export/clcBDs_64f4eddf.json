{"ver":"0.1","info":{"id":"clcBDs","date":"1701797823","viewed":39,"name":"Sunset Over Sea","username":"iuhf","description":"This is my first artistic-centered shader, I hope you enjoy","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bias = 20.;\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord + vec2(-1., -1.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(0., -1.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(1., -1.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(-1., 0.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(0., 0.)), 0)*bias + texelFetch(iChannel0, ivec2(fragCoord + vec2(1., 0.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(-1., 1.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(0., 1.)), 0) + texelFetch(iChannel0, ivec2(fragCoord + vec2(1., 1.)), 0); \n    col /= 8. + bias;\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define E 2.71828182846\n#define PI 3.14159265359\n\nconst float bars = 10.;\n\nstruct HitInfo {\n    bool hit;\n    vec3 p;\n};\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 fbm(in vec2 po, in float time, in float oct) {\n    \n    float ot = 0.;\n    vec3 n = vec3(po.x, -4., po.y);\n    \n    for (float o = 0.; o < oct; o++) {\n        ot += pow(E, sin((po.x*rand(vec2(o+33838.))+rand(vec2(o))) + (po.y*rand(vec2(o+5535.))+rand(vec2(o+4828.43))) + (time*rand(vec2(o+69964.4452))+rand(vec2(o+388392.221334)))))/E;\n        n += vec3((pow(E, -cos((po.x*rand(vec2(o+33838.))+rand(vec2(o))) + (po.y*rand(vec2(o+5535.))+rand(vec2(o+4828.43))) + (time*rand(vec2(o+69964.4452))+rand(vec2(o+388392.221334)))))/E), 1., (pow(E, -cos((po.x*rand(vec2(o+33838.))+rand(vec2(o))) + (po.y*rand(vec2(o+5535.))+rand(vec2(o+4828.43))) + (time*rand(vec2(o+69964.4452))+rand(vec2(o+388392.221334)))))/E));\n    }\n    \n    \n    return vec4(normalize(n), ot/oct);\n    \n}\n\nconst vec2 sun_pos = vec2(0., .5);\nconst vec3 sun_colour = vec3(1., 0.95, 0.95);\n\nvec3 sun(in vec2 p) {\n    vec3 base = vec3((asin(sin(length(sun_pos - p)*PI*0.4)-abs(sin(iTime)*0.01))/(PI/2.)), (asin(sin((length(sun_pos - p)-0.7-abs(cos(iTime)*0.01))*PI*0.9)))/(PI/2.), length(sun_pos - p) - 0.7);\n    if (length(sun_pos - p)+sin(10.*atan((p - sun_pos).y/(p - sun_pos).x)+iTime)*0.025 + cos(10.*atan((p - sun_pos).y/(p - sun_pos).x)-iTime)*0.015 < 0.25) {\n        base = sun_colour;\n    }\n    return base;\n}\n\nHitInfo intersect(in vec3 O, in vec3 D, in float py, in vec3 pn, in float time) {\n    if (dot(D, pn) >= 0.) {\n        return HitInfo(false, vec3(0.));\n    }\n    \n    float t = ((py+sin(D.x+time)*.5+sin(D.y+time)*.5) - O.y)/D.y;\n    return HitInfo(true, O + D * t);\n}\n\nconst float normal_nudge = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 O = vec3(0., 0., -1.);\n    vec3 R = vec3(uv, 0.);\n    vec3 D = normalize(R - O);\n    \n    HitInfo i = intersect(O, D, -4., vec3(0., 1., 0.), iTime*0.5);\n    \n    vec3 water_colour = vec3(0.05, 0.2, 1.);\n    \n    vec3 col;\n    \n    if (!i.hit) {\n        vec2 n = vec2(20.)/iResolution.xy;\n        \n        col = sun(uv + vec2(-1., -1.)*n) + sun(uv + vec2(0., -1.)*n) + sun(uv + vec2(1., -1.)*n) + sun(uv + vec2(-1., 0.)*n) + sun(uv + vec2(0., 0.)*n) + sun(uv + vec2(1., 0.)*n) + sun(uv + vec2(-1., 1.)*n) + sun(uv + vec2(0., 1.)*n) + sun(uv + vec2(1., 1.)*n);\n        col /= 9.;\n    } else {\n        \n        vec2 n = vec2(20.)/iResolution.xy;\n        \n        vec3 scol = sun(uv + vec2(-1., -1.)*n) + sun(uv + vec2(0., -1.)*n) + sun(uv + vec2(1., -1.)*n) + sun(uv + vec2(-1., 0.)*n) + sun(uv + vec2(0., 0.)*n) + sun(uv + vec2(1., 0.)*n) + sun(uv + vec2(-1., 1.)*n) + sun(uv + vec2(0., 1.)*n) + sun(uv + vec2(1., 1.)*n);\n        scol /= 9.;\n        \n        vec4 noise = fbm(i.p.xz, iTime, 10.);\n        col = water_colour*2.+(dot(noise.xyz, normalize(vec3(0., 0.5, 1.))) * vec3(1., 0.5, 0.))*2.-noise.w;\n        \n        col /= 2.;\n        \n        col += scol*(1. + uv.y)/1.5;\n        \n        col.z -= clamp(1. - length(uv), 0., 1.);\n    }\n    \n    \n    \n    fragColor = vec4(floor(col*bars)/bars, 1.);\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}