{"ver":"0.1","info":{"id":"styfz1","date":"1664037674","viewed":94,"name":"ImplicitSurfaceGearWheel2","username":"gPlatl","description":"Get black artifacts, if using function  pow(2.*pos.z,44.);    // activate BufferA line 18\n\nMany thanks to @fad, who described me the error with the pow-function and the solution.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["math","antialiasing","raytrace","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------------------------------------------\n//\n// Shader: ImplicitSurfaceGearWheel2_Image.glsl\n//\n// Fork of \"sin(x)+sin(y)+sin(z)=0 + TxAA\" by yvtjp. https://shadertoy.com/view/lt3SWj\n//\n//---------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//---------------------------------------------------------\n//\n// ImplicitSurfaceGearWheel2_BufA.glsl\n//\n//  v1.0  GearWheel\n//  v1.1  Rhombic_Triacontahedron\n//  v1.2  Platls_Egg\n//  v1.3  Meiers_Egg\n//\n//---------------------------------------------------------\n\nconst float FarDistance = 16.;\nconst float NearDistance = -2.;\nconst int NumSteps = 32;\t\t// number of samples per pixel (per frame)\nconst float DerivStep = 0.01;\t// for shading\nconst bool disableProgressiveRefinement = false;\nconst bool disableGuidedProgressiveRefinement = false; // use adjacent depth info for faster convergence\n\nint mainDemo = 0;\n\n//---------------------------------------------------------\n// Meiers Egg:  http://3d-meier.de/tut25/Seite116.html\n// 3d formula:  (z-a)*(z-b)*z*c^2 -x^2 -y^2 = 0\n//---------------------------------------------------------\nfloat Meiers_Egg(vec3 p, float a)\n{\n  float b = 2.8;\n  float c = 0.55;\n  float d = 1.2;\n  float z = p.z*0.7 + d; \n  return (z-a)*(z-b)*z*c*c -p.x*p.x -p.y*p.y;  \n}\n\n//---------------------------------------------------------\n// 2d curve:   https://www.desmos.com/calculator/wr0btg26hv\n// 3d formula: a-x^2-y^2-(abs(b*(1.0-z)))^3-z\n//---------------------------------------------------------\nfloat Platls_Egg(vec3 p, float a)\n{\n  float b = 0.5;\n  float c = 1.0;\n  float f = b*(c-p.z);\n  return a -p.x*p.x -p.y*p.y -abs(f*f*f) -p.z;\n}\n\n//---------------------------------------------------------\n#define sq(x) (x)*(x)\n#define R 3.\n#define gr 14.\nfloat GearWheel(vec3 pos)   \n{\n  float a = R + 0.8*sin(gr*atan(pos.x, pos.y));\n//return 0.5*a -0.3*(sq(pos.x) + sq(pos.y)) - 9.*sq(pos.z); \n//return 0.5*a -0.3*(sq(pos.x) + sq(pos.y)) - pow(2.*pos.z,44.);      // black dots\n//return 0.5*a -0.3*(sq(pos.x) + sq(pos.y)) - pow(abs(2.*pos.z),44.); // corrected\n  return 0.5*a -0.3*(sq(pos.x) + sq(pos.y)) - pow(abs(2.*pos.z),12.+11.*sin(iTime)); // correct\n}\n\n//---------------------------------------------------------\n// https://sylvain69780.github.io/2021/09/25/magic-of-fold-and-cut.html\n//---------------------------------------------------------\nfloat Rhombic_Triacontahedron (vec3 p) \n{\n  float c = clamp(4.5+sin(iTime),4.,5.);\n  c = cos(3.1415 / c);\n  float s = sqrt(0.75-c*c);\n  vec3 n = vec3(-0.5, -c, s);\n  p = abs(p);        p -= 2.*min(0., dot(p, n))*n;\n  p.xy = abs(p.xy);  p -= 2.*min(0., dot(p, n))*n;\n  p.xy = abs(p.xy);  p -= 2.*min(0., dot(p, n))*n;\n  return 1.0 - p.z;\n}\n\n//---------------------------------------------------------\nfloat implicitFunc(vec3 pos)\n{\n  if      (mainDemo == 2) return Rhombic_Triacontahedron(pos);\n  else if (mainDemo == 3) return Platls_Egg(pos, 2.0 +sin(iTime)*0.5);\n  else if (mainDemo == 4) return Meiers_Egg(pos, 5.0 +sin(iTime)*0.5);\n  return GearWheel(pos);\n}\n\n//---------------------------------------------------------\nfloat ditherPattern(vec2 coord)\n{\n  coord = fract(coord * 0.5);\n  return dot(coord, vec2(0.25, 0.5));\n}\n\nvec3 computeNormalAt(vec3 pos)\n{\n  vec3 v = vec3(\n    implicitFunc(pos - vec3(DerivStep, 0., 0.)),\n    implicitFunc(pos - vec3(0., DerivStep, 0.)),\n    implicitFunc(pos - vec3(0., 0., DerivStep)));\n  vec3 v2 = vec3(\n    implicitFunc(pos + vec3(DerivStep, 0., 0.)),\n    implicitFunc(pos + vec3(0., DerivStep, 0.)),\n    implicitFunc(pos + vec3(0., 0., DerivStep)));\n  return normalize(v - v2);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// from https://github.com/Hyper3D/hyper3d/blob/master/src/renderer/shaders/common/ShadingModel.glsl \nfloat evaluateGGXSpecularDistribution(float nhDot, highp float roughness)\n{\n  // Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"\n  // http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n  highp float a = roughness * roughness;\n  highp float aa = a * a;\n  highp float t = nhDot * nhDot * (aa - 1.) + 1.;\n  return aa / (t * t + 1.e-20);\n}\nfloat evaluateSchlickFresnel(float hlDot)\n{\n  float t = 1. - hlDot;\n  float tt = t * t;\n  return tt * tt * t;\n}\nfloat evaluateBeckmannGeometryShadowing(float nlDot, float nvDot, float roughness)\n{\n  // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n  float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n  float vct = .5 / (roughness * sqrt(1. - nvDot * nvDot) + 0.00001);\n  float lc = lct * nlDot, vc = vct * nvDot;\n  float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n  a *= 3.353 * vct + 2.181 * vct * vc;\n  float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n  b *= 1. + 2.276 * vc + 2.577 * vc * vc;\n  return a / b;\n}\nfloat evaluateBeckmannGeometryShadowingSingleSide(float nlDot, float roughness)\n{\n  // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n  float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n  float lc = lct * nlDot;\n  float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n  float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n  return a / b;\n}\n\nvec3 cameraPos;\n\nfloat evaluateAmbient(vec3 pos, vec3 normal)\n{\n  vec3 viewDir = normalize(cameraPos - pos);\n  float nvDot = dot(normal, viewDir);\n  float fresnel = evaluateSchlickFresnel(nvDot);\n  float refl = mix(0.03, 1., fresnel);\n  return 1. - refl;\n}\n\nvec3 evaluatePointLight(vec3 pos, vec3 normal, vec3 lightDir, vec3 albedo)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n \tvec3 halfVec = normalize(viewDir + lightDir);\n    float nlDot = dot(normal, lightDir);\n    if (nlDot <= 0.) return vec3(0.);\n    float hlDot = dot(halfVec, lightDir);\n    float nhDot = dot(normal, halfVec);\n    float nvDot = dot(normal, viewDir);\n    \n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    float roughness = 0.2;\n    float spec = evaluateGGXSpecularDistribution(nhDot, roughness)\n        * evaluateBeckmannGeometryShadowing(nlDot, nvDot, roughness);\n    return mix(albedo, vec3(spec), refl) * nlDot;\n}\n\nvec3 sampleBackground(vec3 v)\n{\n    v = vec3(v.x, -v.z, v.y);\n    vec3 rgb = texture(iChannel1, v).xyz;\n    return rgb * rgb * 4.; // linearize\n}\t\n\nvec3 evaluateReflection(vec3 pos, vec3 normal)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n    float nvDot = dot(normal, viewDir);\n    vec3 lightDir = reflect(-viewDir, normal);\n    \n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    float roughness = 0.2;\n    \n    refl *= evaluateBeckmannGeometryShadowingSingleSide(nvDot, roughness);\n    \n    return refl * sampleBackground(lightDir).xyz;\n}\n\nvoid shade(vec3 pos, out vec3 color)\n{\n    vec3 surfNormal = computeNormalAt(pos);\n    \n    float h = pos.x * 0.25;\n    vec3 albedo = hsv2rgb(vec3(h, 0.9, 0.8));\n    \n    // semisphere lighting\n    float dtSky = dot(surfNormal, vec3(0., 0., 1.));\n    vec3 diff = (dtSky * 0.5 + 0.5) * evaluateAmbient(pos, surfNormal)\n        * vec3(0.4, 0.7, 0.4);\n    color.xyz = albedo * diff;\n    \n    // directional lighting\n    color.xyz += evaluatePointLight(pos, surfNormal,\n        normalize(vec3(0.5, 1., 1.)), albedo);\n    \n    // environemntal mapping\n    color.xyz += evaluateReflection(pos, surfNormal);\n}\n\nbool trace(inout vec4 fragColor, vec3 cameraPos, vec3 rayDir\n                               , float farDist, float dither)\n{\n    fragColor.w = FarDistance; // reset upper bound\n    \n    // Start sampling\n    float interval = (farDist - NearDistance) / float(NumSteps + 1);\n    float d = interval * dither + NearDistance;\n    vec3 rayPos = vec3(0.);\n    float fval = implicitFunc(cameraPos + rayDir * d);\n    \n    for (int i = 0; i < NumSteps; ++i) {\n        float lastD = d;\n        // vec3 lastRayPos = rayPos;\n        float lastfval = fval;\n        \n       \td += interval;\n        if (i == NumSteps - 1) {\n         \td = farDist;   \n        }\n     \trayPos = cameraPos + rayDir * d;\n        fval = implicitFunc(rayPos);\n        \n        if (fval > 0.) {\n            // refine\n            for (int k = 0; k < 12; ++k) {\n                float midD = mix(lastD, d, 0.5);\n                vec3 midRayPos = cameraPos + rayDir * midD;\n                float midfval = implicitFunc(midRayPos);\n                if (midfval > 0.) {\n                 \td = midD;   \n                } else {\n                 \tlastD = midD;   \n                }\n                rayPos = midRayPos;\n            }\n         \tfragColor.w = lastD;\n            shade(rayPos, fragColor.xyz);\n            return true;\n        }\n        \n    }\n    \n    return false;\n}\n\n//------------------------------------------------\n// get javascript keycode:  http://keycode.info/\n//------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n//----------------------------------------------------------\n// javascript keycodes: http://keycode.info/\n// key testing:    https://www.shadertoy.com/view/llVSRm\n//----------------------------------------------------------\nconst int KEY_SPACE = 32;\nconst int KEY_0  = 48;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\nconst int KEY_4  = 52;\nconst int KEY_5  = 53;\nconst int KEY_6  = 54;\nconst int KEY_7  = 55;\nconst int KEY_8  = 56;\nconst int KEY_9  = 57;\n//----------------------------------------------------------\nvoid GetDemoIndex() \n{\n  if      (ReadKey(KEY_1, false)) mainDemo = 1;\n  else if (ReadKey(KEY_2, false)) mainDemo = 2;\n  else if (ReadKey(KEY_3, false)) mainDemo = 3;\n  else if (ReadKey(KEY_4, false)) mainDemo = 4;\n  else if (ReadKey(KEY_5, false)) mainDemo = 5;\n  else if (ReadKey(KEY_6, false)) mainDemo = 6;\n  else if (ReadKey(KEY_7, false)) mainDemo = 7;\n  else if (ReadKey(KEY_8, false)) mainDemo = 8;\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    GetDemoIndex();  // works but compile time too high ???\n  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 lastValue = iFrame == 0 ? vec4(0.) : texture(iChannel0, uv);\n    \n    // 12/14/2016: use adjacent depth info for faster convergence\n    vec2 ires = 1.0 / iResolution.xy;\n    float depth1 = texture(iChannel0, uv + vec2(+ires.x, 0.0)).w;\n    float depth2 = texture(iChannel0, uv + vec2(-ires.x, 0.0)).w;\n    float depth3 = texture(iChannel0, uv + vec2(0.0, +ires.y)).w;\n    float depth4 = texture(iChannel0, uv + vec2(0.0, -ires.y)).w;\n    float minAdjDepth = min(min(depth1, depth2), min(depth3, depth4));\n    float maxAdjDepth = max(max(depth1, depth2), max(depth3, depth4));\n    \n    float yaw = iTime * 0.06;\n    float pitch = 0.5;\n    if (iMouse.z > 0.) {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n     \tyaw = mousePos.x * 6.;\n        pitch = mousePos.y * -4.;\n    }\n    float cameraDist = 11.0;\n    \n    cameraPos = cameraDist * vec3(cos(yaw)*cos(pitch),sin(yaw)*cos(pitch),sin(pitch));\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 cameraUp = vec3(0., 0., 1.);\n    vec3 cameraU = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraV = cross(cameraDir, cameraU);\n    vec2 cameraUV = (uv - 0.5) * 0.5 * vec2(16./9.,1.);\n    vec3 rayDir = cameraDir + cameraU * cameraUV.x + cameraV * cameraUV.y;\n    \n    vec3 background = sampleBackground(rayDir);\n    fragColor = vec4(mix(lastValue.xyz, background, 0.8), 1.0);\n    \n    float farDist = clamp(lastValue.w * 1.003, 0.01, FarDistance);\n    \n    float dither = ditherPattern(fragCoord);\n    dither = fract(dither + 10. * cos(10. * cos(iTime + dot(fragCoord, vec2(11.4, 51.4)))));\n    \n    // 12/14/2016: use adjacent depth info for faster convergence\n    if (disableProgressiveRefinement || (\n        !trace(fragColor, cameraPos, rayDir, farDist, dither) &&\n        (disableGuidedProgressiveRefinement || (\n            !trace(fragColor, cameraPos, rayDir, minAdjDepth * 1.005, dither) &&\n        \t!trace(fragColor, cameraPos, rayDir, maxAdjDepth * 1.005, dither) // */\n       )))) \n    // Fail; reset the upper bound\n    trace(fragColor, cameraPos, rayDir, FarDistance, dither);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Undersampling for bloom effect\n\nconst float BloomUndersample = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= BloomUndersample;\n    if (uv.x > 1. || uv.y > 1.) {\n     \tfragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 offs = vec2(20.) / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    for (float x = -0.5; x <= 0.5; x += 0.1) {\n        for (float y = -0.5; y <= 0.5; y += 0.1) {\n\t\t\tfragColor.xyz += texture(iChannel0, uv +\n                  vec2(x, y) * offs).xyz;\n        }\n    }\t\n    \n    fragColor.w = 1.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//---------------------------------------------------------\n// Shader: ImplicitSurfaceGearWheel2_BufC.glsl  by gPlatl\n//   Final composition\n//---------------------------------------------------------\n\nconst float BloomUndersample = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel1, uv);\n    \n    vec2 offs = vec2(50. / BloomUndersample) / iResolution.xy;\n    \n    vec2 uv0 = uv / BloomUndersample;\n    for (float x = -0.5; x <= 0.5; x += 0.2) {\n        for (float y = -0.5; y <= 0.5; y += 0.2) {\n\t\t\tfragColor += texture(iChannel0, uv0 + vec2(x, y) * offs)\n                 * (max(0.7 - length(vec2(x, y)), 0.) * .0002);\n        }\n    }\n    \n    // vignette\n    vec2 vigPos = ((uv.xy - 0.5) * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float vig = 1. - dot(vigPos, vigPos);\n    fragColor.xyz *= vig * vig;\n    \n    fragColor.xyz = sqrt(fragColor.xyz); // gamma correction\n    fragColor.xyz *= 0.7; // exposure\n    fragColor.xyz = mix(fragColor.xyz, smoothstep(0., 1., fragColor.xyz), 0.9); // tone mapping\n    fragColor.w = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Temporal AA based on Epic Games' implementation:\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n// \n// Originally written by yvt for https://www.shadertoy.com/view/4tcXD2\n// Feel free to use this in your shader!\n//\n// iChannel0: input image\n// iChannel1: output image from the last frame\n//\n// Version history:\n//   12/13/2016: first version\n//   12/14/2016: removed unnecessary gamma correction inside\n//               encodePalYuv and decodePalYuv\n\n// YUV-RGB conversion routine from Hyper3D\nvec3 encodePalYuv(vec3 rgb)\n{\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001)));\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    return vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColor = texture(iChannel1, uv);\n    \n    vec3 antialiased = lastColor.xyz;\n    float mixRate = min(lastColor.w, 0.5);\n    \n    vec2 off = 1.0 / iResolution.xy;\n    vec3 in0 = texture(iChannel0, uv).xyz;\n    \n    antialiased = mix(antialiased * antialiased, in0 * in0, mixRate);\n    antialiased = sqrt(antialiased);\n    \n    vec3 in1 = texture(iChannel0, uv + vec2(+off.x, 0.0)).xyz;\n    vec3 in2 = texture(iChannel0, uv + vec2(-off.x, 0.0)).xyz;\n    vec3 in3 = texture(iChannel0, uv + vec2(0.0, +off.y)).xyz;\n    vec3 in4 = texture(iChannel0, uv + vec2(0.0, -off.y)).xyz;\n    vec3 in5 = texture(iChannel0, uv + vec2(+off.x, +off.y)).xyz;\n    vec3 in6 = texture(iChannel0, uv + vec2(-off.x, +off.y)).xyz;\n    vec3 in7 = texture(iChannel0, uv + vec2(+off.x, -off.y)).xyz;\n    vec3 in8 = texture(iChannel0, uv + vec2(-off.x, -off.y)).xyz;\n    \n    antialiased = encodePalYuv(antialiased);\n    in0 = encodePalYuv(in0);\n    in1 = encodePalYuv(in1);\n    in2 = encodePalYuv(in2);\n    in3 = encodePalYuv(in3);\n    in4 = encodePalYuv(in4);\n    in5 = encodePalYuv(in5);\n    in6 = encodePalYuv(in6);\n    in7 = encodePalYuv(in7);\n    in8 = encodePalYuv(in8);\n    \n    vec3 minColor = min(min(min(in0, in1), min(in2, in3)), in4);\n    vec3 maxColor = max(max(max(in0, in1), max(in2, in3)), in4);\n    minColor = mix(minColor,\n       min(min(min(in5, in6), min(in7, in8)), minColor), 0.5);\n    maxColor = mix(maxColor,\n       max(max(max(in5, in6), max(in7, in8)), maxColor), 0.5);\n    \n   \tvec3 preclamping = antialiased;\n    antialiased = clamp(antialiased, minColor, maxColor);\n    \n    mixRate = 1.0 / (1.0 / mixRate + 1.0);\n    \n    vec3 diff = antialiased - preclamping;\n    float clampAmount = dot(diff, diff);\n    \n    mixRate += clampAmount * 4.0;\n    mixRate = clamp(mixRate, 0.05, 0.5);\n    \n    antialiased = decodePalYuv(antialiased);\n        \n    fragColor = vec4(antialiased, mixRate);\n}","name":"Buffer D","description":"","type":"buffer"}]}