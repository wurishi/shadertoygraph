{"ver":"0.1","info":{"id":"lct3WB","date":"1712099477","viewed":126,"name":"Walk on sphere interpolation","username":"mrboggieman","description":"Interpolate between two boundaries of points in 2D. Generalized interpolation using walk on spheres to solve the laplacian equation with a monte carlo method. Version of https://www.shadertoy.com/view/ttByDw using functions for boundaries","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["diffuse","interpolation","laplace","wos"],"hasliked":0,"parentid":"ttByDw","parentname":"Demofox WoS Interpolation 1D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rgb;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 distanceToBoundaryAndColor(vec2 uv)\n{\n    if (uv.x <= 0.5)\n        return vec4(uv.x, vec3(from(uv.y)));\n    else\n        return vec4(1.0 - uv.x, vec3(to(uv.y)));\n}\n\nvec4 unitBoundaryRange(in vec2 uv) {\n    //only a subset of the inputs and outputs would cross our uv coord, we can compute the ranges\n    float from_start = clamp(uv.y - ((1.0 - uv.y) / (1.0 - uv.x)) * uv.x, 0.0, 1.0);\n    float from_end = clamp(uv.y - (-uv.y / (1.0 - uv.x)) * uv.x, 0.0, 1.0);\n\n    float to_start = clamp(uv.y/uv.x, 0.0, 1.0);\n    float to_end = clamp(((uv.y - 1.0)/uv.x) + 1.0, 0.0, 1.0);\n    \n    return vec4(from_start, from_end, to_start, to_end);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    // this is our starting point\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    \n    // Walk on spheres algorithm\n\tvec4 distanceAndColor;\n    for (int i = 0; i < c_numStepsMax; ++i)\n    {\n        // Get distance to closest boundary.\n        // If it's close enough, we are done. Use the color of the boundary we are next to.\n        distanceAndColor = distanceToBoundaryAndColor(pos);\n        if (distanceAndColor.x < c_epsilon)\n            break;\n        \n        // the boundary direction is a range we can calculate\n        vec4 boundary = unitBoundaryRange(pos);\n        \n        // Otherwise, walk the distance to the nearest boundary, in a random direction.\n        float randDir = randomFloat01(rngState);\n        \n        vec2 targetPos = (randDir < 0.5) ? vec2(0.0, mix(boundary.x, boundary.y, randDir * 2.0)) : vec2(1.0, mix(boundary.z, boundary.w, (randDir - 0.5) * 2.0));\n        vec2 direction = normalize(targetPos - pos);\n\n        pos += direction * distanceAndColor.x;\n    }\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);  \n\n    // incremental average this new color with the old.\n    vec4 lastFrameColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    float blend = (iFrame < 2 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    vec3 newColor = mix(lastFrameColor.rgb, distanceAndColor.yzw, blend);\n    fragColor = vec4(newColor, blend);    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// how close the random walk needs to get before it's considered a hit.\n// This is in a percentage of the screen\nconst float c_epsilon = 0.001;\n\n// how many steps to take on the random walk at maximum\nconst int c_numStepsMax = 32;\n\n// linear space colors we are interpolating between\nconst vec3 colorA = vec3(1.0, 0.0, 0.0);\nconst vec3 colorB = vec3(1.0, 1.0, 0.0);\n\nconst float SQRT_2PI = 2.50662827463;\nconst float TAU = 6.28318530718;\nconst float E = 2.718281828;\nconst float EPSILON = 0.00001;\n\nfloat normal_dist(in float x, in float m, in float s) {\n    return pow(E, -0.5*pow((x-m)/s, 2.0)) / (s*SQRT_2PI);\n}\n\n// define two functions that we will interpolate (in 0:1 range)\nfloat from(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return (normal_dist(x, -0.5, 0.1) + normal_dist(x, 0.5, 0.1)) / 4.0;\n    return (normal_dist(x, -0.9, 0.3) + normal_dist(x, 0.9, 0.3)) / 2.0;\n    //return (sin(t * TAU * 4.0) + 1.0) / 2.0;\n}\n\nfloat to(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return normal_dist(x, 0.0, 1.0);\n    return (normal_dist(x, -1.0, 0.1) + normal_dist(x, 0.0, 0.1) + normal_dist(x, 1.0, 0.1)) / 4.0;\n}\n\nconst float KEY_SPACE = 32.5/256.0;\n\n// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat randomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}","name":"Common","description":"","type":"common"}]}