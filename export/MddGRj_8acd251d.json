{"ver":"0.1","info":{"id":"MddGRj","date":"1451344509","viewed":1496,"name":"Rosetta","username":"sixstring982","description":"What secrets lie in the stone?","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["terrain","menger","euler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**  Rosetta\n  *  sixstring982 - 2015\n  *\n  *  First shot at doing some iterative structures.\n  *  Got some help from iq's page on that topic.\n  */\n\n#define INFTY 1e20\n#define EPS 0.001\n\n#define NIGHT_COLOR vec3(0.05, 0.05, 0.125)\n#define DAY_COLOR vec3(0.25, 0.5, 0.75)\n#define FOG_START 3.0\n#define FOG_END 20.0\n\n#define PI 3.1415926535\n#define PIOVERTWO 1.57079632679\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat box3(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat box2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat heightAt(vec2 xz) {\n    return texture(iChannel0, (xz + vec2(1.0)) * 0.005).r - 0.04;\n}\n\nfloat plane(in vec3 p, in vec4 n) {\n    return dot(p, n.xyz) + n.w + \n        2.0 * heightAt(p.xz);\n}\n\nfloat opI(in float a, in float b) {\n    return max(a, b);\n}\n\nfloat opS(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opU(in float a, in float b) {\n    return min(a, b);\n}\n\nvec3 vectorField(in vec3 p) {\n    return vec3(-p.y * sin(iTime / 3.0), \n                -p.z * sin(iTime / 5.0), \n                 p.x * cos(iTime / 7.0));\n}\n\n#define EULER_ITERS 2\n#define LAMBDA 0.05\nvec3 euler(in vec3 p){\n    float lambda = mix(0.0, 8.0 * LAMBDA, 0.5 + 0.5 * sin(iTime / 11.0));\n    for (int i = 0; i < EULER_ITERS; i++) {\n        p = p + lambda * vectorField(p);\n    }\n    return p;\n}\n\n#define MENGER_ITERS 3\nfloat mengerSponge(in vec3 p) {\n    float d = box3(p, vec3(1.0));\n    float scale = 1.0;\n    \n    for (int i = 0; i < MENGER_ITERS; i++) {\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        r = euler(r);\n        \n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        \n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        d = max(d, c);\n    }\n    \n    return d;\n}\n\nfloat map(in vec3 ro) {\n    // d = opU(d, sphere(ro, 2.0));\n    float d = mengerSponge(ro);\n    d = opU(d, plane(ro, normalize(vec4(0.0, -1.0, 0.0, 1.0))));\n    return d;\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(vec3(map(ro + e.xyy) - map(ro - e.xyy),\n                          map(ro + e.yxy) - map(ro - e.yxy),\n                          map(ro + e.yyx) - map(ro - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float maxDist) {\n    float d = EPS;\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        if (d < abs(EPS) ||\n            td > maxDist) {\n            break;\n        }\n        \n        d = map(ro);\n        ro += d * rd;\n        td += d;\n    }\n    \n    if (d < abs(EPS)) {\n        return td;\n    } else {\n        return INFTY;\n    }\n}\n\n#define LIGHT_COUNT 1\nbool light(in int idx, out vec3 lightPos) {\n    // Sun light\n    if (idx == 0) {\n        lightPos = vec3(1000.0,\n                        1000.0 * -sin(iTime * 0.01),\n                        1000.0 * cos(iTime * 0.01));\n        return true;\n        \n    // Rotating light        \n    } else if (idx == 1) {\n        lightPos = vec3(5.0 * sin(iTime),\n                        -1.0,\n                        5.0 * -cos(iTime));\n        return true;\n        \n    // Still light\n    } else if (idx == 0) {\n        lightPos = vec3(-3.0);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvec3 fogColor() {\n    vec3 lightPos;\n    if (light(0, lightPos) &&\n        lightPos.y < 0.0) {\n        lightPos = normalize(lightPos);\n        return mix(NIGHT_COLOR, DAY_COLOR, -lightPos.y);\n    }\n    return NIGHT_COLOR;\n}\n\nmat3 materialAt(in vec3 p, out float shininess) {\n    if (abs(p.x) <= 1.01 &&\n        abs(p.y) <= 0.999 &&\n        abs(p.z) <= 1.01) {\n        shininess = 1.0;\n        return mat3(vec3(0.3294 * p.x, 0.2235, 0.0274),\n                    vec3(0.7803, 0.5686 * p.y, 0.1137 * p.z),\n                    vec3(0.9921, 0.9411 * p.x, 0.8078 * p.y));\n    } else if (texture(iChannel1, p.xz * 0.01).r > 0.3) {\n        shininess = 1.0;\n        return mat3(0.5, 0.5, 0.5,\n                    1.0, 1.0, 1.0,\n                    1.0, 1.0, 1.0);\n    } else {\n        shininess = 1.0;\n        float amt = min(1.0, texture(iChannel1, p.xz * 0.01).g * 5.0);\n        return mat3(mix(vec3(0.5), texture(iChannel1, p.xz * 0.01).rgb * 0.2, amt),\n                    mix(vec3(1.0), texture(iChannel1, p.xz * 0.01).rgb * 0.7, amt),\n                    mix(vec3(1.0), texture(iChannel1, p.xz * 0.01).rgb * 0.8, amt));\n        \n    }\n}\n\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.0;\n    float delta = 0.5;\n    for (float i = 1.0; i <= 5.0; i++) {\n        float c = (1.0 / pow(2.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += c;//clamp(c, 0.0, 1.0);\n    }\n    \n    return 1.0 - k * s;\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float td) {\n    float shininess;\n    mat3 mat = materialAt(ro, shininess);\n    float fogAmt = 0.0;\n    vec3 N = normalAt(ro);\n    vec3 V = -rd;\n    float shadow = 0.25;\n\n    if (td > FOG_START) {\n        fogAmt = smoothstep(0.0, 1.0, (td - FOG_START) / (FOG_END - FOG_START));\n    }\n    \n    float diff = 0.0;\n    float spec = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n        vec3 lp;\n        if (light(i, lp)) {\n            vec3 L = normalize(lp - ro);\n            vec3 R = reflect(-L, N);\n            \n            float sd = march(lp, -L, 10000.0);\n            lp = lp - sd * L;\n            \n            if (length(lp - ro) < 0.01) {\n                shadow = max(shadow, 1.0);\n            }\n            \n            diff = clamp(diff + max(0.0, dot(L, N)), 0.0, 1.0);\n            spec = clamp(spec + max(0.0, pow(dot(R, V), shininess)), 0.0, 1.0);\n        }\n    }\n    \n    vec3 lit = vec3((diff + spec) * shadow);\n    vec3 color = mat[0] * occlusion(ro, N, 0.9) +\n                 mat[1] * diff +\n                 mat[2] * spec;\n    \n    return mix(color * shadow, fogColor(), fogAmt);\n}\n\n#if 1\n#define CAM_DIST 2.5\n#define CAM_SPEED 0.08\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float theta = iMouse.x * 0.02 + iTime * CAM_SPEED;\n    ro = vec3(CAM_DIST * sin(theta), \n              0.0, \n              CAM_DIST * -cos(theta));\n    ro = vec3(ro.x, heightAt(ro.xz) * 2.0, ro.z);\n    vec3 t = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    \n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#else\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = ballPos();\n    vec3 t = targetPos();\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    \n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    float td;\n    setupCamera(uv, ro, rd);\n    \n    td = march(ro, rd, FOG_END);\n    ro = ro + td * rd;\n    if (td < INFTY) {\n        fragColor = vec4(lighting(ro, rd, td), 1.0);\n    } else {\n        fragColor = vec4(fogColor(), 1.0);\n    }\n}","name":"","description":"","type":"image"}]}