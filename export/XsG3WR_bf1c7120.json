{"ver":"0.1","info":{"id":"XsG3WR","date":"1453929027","viewed":1008,"name":"Lunar Lander","username":"Hamneggs","description":"A playable clone of Lunar Lander! The colored areas are where you want to land. Want more info? Select &quot;How to play&quot; :)","likes":39,"published":1,"flags":112,"usePreview":0,"tags":["2d","game","space","multipass","playable","lunar","lander"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Lunar Lander! (Or rather an ambitious clone)\n    License: GPLv2\n\n\tVersion 1.0:\t Increased minimum zoom, and added frame time correction for \n\t\t\t     \t lackluster framerate playability.\n\tVersion 1.00001: Moved discard tests to as early as possible in the frame.\n\tVersion 1.00204: getBit() returned its negative power and multiplication for\n\t\t\t\t     its original positive power and divide for the sake of Mac\n\t\t\t\t\t users. Are the artifacts gone now? I can't test it. Also clamped\n\t\t\t\t\t fragColor.\n\tVersion 1.01000: Implemented IQ's fragColor fix. Hopefully Mac is good now.\n\tVersion 1.1:\t Increased starting point variation.\n\tVersion 1.11:    Landing notification text now flashes with a precise start point.\n    \n    Space Lander is a Lunar Lander clone, where you can land ANYWHERE! -ISH! FREEDOM!\n    EXPLORATION! SURFACE-NORMAL-ALIGNMENT BASED SCORING!\n    \n    The gameplay logic of the game is handled in buffer A, using the read-a-texel,\n    act upon that value, if-this-fragment-is-that-texel-write-the-new-value design pattern.\n    That buffer maintains program state (main menu, gameplay, gameover, etc.), ship\n    status, collision, menu interactivity...\n    \n    The other buffers draw stuff based on the values buffer A writes to itself.\n    Buffer B simply draws the how-to menu during the ST_HOWTO state, and discards otherwise.\n    Buffer C draws the splash screen and main menu and game over dialog, discarding during \n    other states.\n    Buffer D draws gameplay and (crash)landing screens.\n\n\tText rendering is my HaltCF'd version of P_Malin's numbers.\n\tnumbers: https://www.shadertoy.com/view/4sf3RN\n\twriteup: gerardgeer.com/bittext\n\n\tAll the rest is FBM and 2D distance fields.\n\n\tMusic is the opening theme to Lagrange Point (NES)\n*/\n\n// Draw debug text?\n//#define DEBUG_OUTPUT\n// Draw memory?\n//#define DRAW_MEMORY\n\n// Game data buffer definitions.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 txSTATE   = vec2(4,4); // Current game state. Splash, menu, gameplay etc...\n\n// iChannel definitions.\n#define DATA_BUFFER iChannel0\n#define HOWTO_SCREEN iChannel1\n#define MMENU_SCREEN iChannel2\n#define GAMEP_SCREEN iChannel3\n\n// Game states.\n#define ST_SPLSH 0.0\n#define ST_MMENU 1.0\n#define ST_HOWTO 2.0\n#define ST_INITG 3.0\n#define ST_GAMEP 4.0\n#define ST_CRASH 5.0\n#define ST_SCCES 7.0\n#define ST_GMOVR 8.0\n// Menu selections.\n#define MS_START 0.0\n#define MS_HOWTO 1.0\n\n// Character encodings.\n#ifdef DEBUG_OUTPUT\n#define _f(n,v) n = float(v)\nconst highp float _f(CH_A,   0x69f99), _f(CH_E,   0xf171f), _f(CH_S,   0xe1687),\n    \t\t\t _f(CH_T,   0xf4444), _f(CH_0,   0x6bd96), _f(CH_1,   0x46444), \n                 _f(CH_2,   0x6942f), _f(CH_3,   0x69496), _f(CH_4,   0x99f88), \n                 _f(CH_5,   0xf1687), _f(CH_6,   0x61796), _f(CH_7,   0xf8421), \n    \t         _f(CH_8,   0x69696), _f(CH_9,   0x69e84), _f(CH_CLON,0x00202);\n#undef _f\nconst lowp vec2 MAP_SIZE = vec2(4,5);\nconst lowp float KERN = 6.0;\n#endif\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n#ifdef DEBUG_OUTPUT\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n/*\n\tTrades a float for a character bitmap. Here's to eliminating\n\tbranches with step()!\n*/\nfloat floatToChar( in float x )\n{\n    float res = CH_BLNK;\n    res += (step(-.5,x)-step(0.5,x))*CH_0;\n    res += (step(0.5,x)-step(1.5,x))*CH_1;\n    res += (step(1.5,x)-step(2.5,x))*CH_2;\n    res += (step(2.5,x)-step(3.5,x))*CH_3;\n    res += (step(3.5,x)-step(4.5,x))*CH_4;\n    res += (step(4.5,x)-step(5.5,x))*CH_5;\n    res += (step(5.5,x)-step(6.5,x))*CH_6;\n    res += (step(6.5,x)-step(7.5,x))*CH_7;\n    res += (step(7.5,x)-step(8.5,x))*CH_8;\n    res += (step(8.5,x)-step(9.5,x))*CH_9;\n    return res;\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent uv coordinate. The key difference with this implementation\n    and my reference one is that this one has a (very useful) side\n    effect of moving the carriage.\n*/\nfloat drawChar( in float char, inout vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv -= pos;\n    uv /= size;    \n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    pos.x += KERN;\n    return clamp(res,0.0,1.0);\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nfloat drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    float res = 0.0,digit = 0.0;\n    for( int i = 0; i < 10; ++i )\n    {\n        if(val == 0 && i >= places) break;\n        digit = float( val-(val/10)*10 );\n        res += drawChar(floatToChar(digit),pos,size,uv);\n        pos.x -= size.x*2.8;\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nfloat drawInt( in float val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(val);\n    val *= s;\n    \n    float c = drawIntCarriage(int(val),p,size,uv,1);\n    return c + drawChar(CH_HYPH,p,size,uv)*max(0.0, -s);\n}\n\n/*\n    Draws debug output.\n*/\nfloat drawDebugText( in vec2 uv, in float state )\n{\n    vec2 scr = uv*vec2(640,360); // small text\n    vec2 pos = vec2(30,20);\n    // \"STATE: {state}\"\n    float char = drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_COLN,pos,MAP_SIZE,scr); \n    pos.x += KERN*5.0;\n    char += drawInt(state*1000000.0,pos,MAP_SIZE,scr);\n    \n    return char;\n}\n#endif\n\n/*\n    Shadertoy's entry point, MAIN IMAGE EDITION!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get a normalized screen coordinate.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // This is the point that would be best to draw the\n    // memory if wanted.\n    #ifdef DRAW_MEMORY\n    fragColor = texture(DATA_BUFFER, uv*.025); return;\n    #endif\n    \n    // Initialize fragColor so we don't get bonkers stuff on Mac. Thanks IQ!\n    fragColor = vec4(0);\n    \n    // Get texels from each buffer for viewing.\n    vec4 data = texture(DATA_BUFFER, uv);     // RAM, sorta.\n    vec4 howto = texture(HOWTO_SCREEN, uv);   // The howto screen.\n    vec4 mmenu = texture(MMENU_SCREEN, uv);   // The main menu screen.\n    vec4 gamep = texture(GAMEP_SCREEN, uv);   // The gameplay screen.\n\n    // Get the current state of the game.\n    float state = readTexel(DATA_BUFFER, txSTATE).r;\n    \n    fragColor += (step(ST_SPLSH-.5,state)-step(ST_SPLSH+.5,state))*mmenu;\n    fragColor += (step(ST_MMENU-.5,state)-step(ST_MMENU+.5,state))*mmenu;\n    fragColor += (step(ST_HOWTO-.5,state)-step(ST_HOWTO+.5,state))*howto;\n    fragColor += (step(ST_INITG-.5,state)-step(ST_INITG+.5,state))*vec4(0,0,0,1);\n    fragColor += (step(ST_GAMEP-.5,state)-step(ST_GAMEP+.5,state))*gamep;\n    fragColor += (step(ST_CRASH-.5,state)-step(ST_CRASH+.5,state))*gamep;\n    fragColor += (step(ST_SCCES-.5,state)-step(ST_SCCES+.5,state))*gamep;\n    fragColor += (step(ST_GMOVR-.5,state)-step(ST_GMOVR+.5,state))*mmenu;\n    \n    // Draw debug text maybe?\n    #ifdef DEBUG_OUTPUT\n    fragColor = mix(fragColor,vec4(1),drawDebugText(uv,state));\n    // Iunno maybe this will help with some artifacty stuff?\n    fragColor = clamp(fragColor);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsXGWH","filepath":"https://soundcloud.com/user-891621526/lagrange-point-theme-of-isis-opening-1","previewfilepath":"https://soundcloud.com/user-891621526/lagrange-point-theme-of-isis-opening-1","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Space Lander\n    License: GPLv2\n    This buffer handles persistent game state, meaning things like the\n    current menu, ship properties, and score are all stored and modified\n    in this buffer.\n*/\n\n// Locations of the texels that store game state.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 txPSVL    = vec2(2,2); // xy = pos, zw = vel.\nconst vec2 txFSRT    = vec2(2,4); // x = fuel, y = throttle position, z = radians, w = score\nconst vec2 txDIRS    = vec2(2,6); // Current keys. x = left, y = up, z = right, w = down\nconst vec2 txKEYS    = vec2(4,2); // Current keys. x = enter, y = space\nconst vec2 txSTATE   = vec2(4,4); // Current game state. Splash, menu, gameplay etc...\nconst vec2 txMSEL    = vec2(4,6); // Current menu selection.\nconst vec2 txPCHANGE = vec2(6,2); // Time of last state change.\nconst vec2 txCAM     = vec2(6,4); // Camera position. x = x, y = y, z = zoom.\n\n// Gameplay constants.\nconst vec2 GRAV = vec2(0.0, -0.000002);\t// Gravity.\nconst vec2 UP = vec2(0.0,1.0);\t\t\t// An up vector for orientation concerns.\nconst float BSTACCL = 0.000007;\t\t\t// How strong the boost is.\nconst float BSTCOST = .05;\t\t\t\t// How much fuel each frame of boost costs.\nconst float ROTSPD = .08;\t\t\t\t// Ship rotation speed per frame.\nconst float SPDTHRSH = .003;            // Max speed of a successful landing.\nconst float DSTTHRSH = .0065;           // Minimum distance to the surface before contact.\nconst float DOTTHRSH = .975;            // Cosine of the max safe camber for safe landings.\nconst float LANDTIME = 4.0;             // Length of the landing dialog.\nconst float STRTFUEL = 800.0;           // How much fuel to start with. You get a lot.\nconst float INCTHRSH = .925;            // The maximum cosine away from up a surface can be to land.\nconst float ORG = 8.0;                  // Pad multiplier values.\nconst float GRN = 4.0;                  // Pad multiplier values.\nconst float BLU = 1.0;                  // Pad multiplier values.\nconst float YEL = 2.0;                  // Pad multiplier values.\nconst float PRP = 6.0;                  // Pad multiplier values.\n\n// iChannel definitions.\n#define DATA_BUFFER iChannel0\n#define KEYBOARD iChannel1\n#define NOISE_TEX iChannel2\n\n// Normal sampling differential distance.\n#define EPSILON .005\n\n// Key codes.\nconst float KEY_LEFT = 37.0/256.0;\nconst float KEY_UP = 38.0/256.0;\nconst float KEY_RGHT = 39.0/256.0;\nconst float KEY_DOWN = 40.0/256.0;\nconst float KEY_ENT = 13.0/256.0;\nconst float KEY_SPC = 32.0/256.0;\nconst float KEY_ESC = 27.0/256.0;\n\n// locations of key events per key in the keyboard iChannel buffer.\n#define KD_POS 0.0\n#define KP_POS 0.5\n\n// Game states.\n#define ST_SPLSH 0.0\n#define ST_MMENU 1.0\n#define ST_HOWTO 2.0\n#define ST_INITG 3.0\n#define ST_GAMEP 4.0\n#define ST_CRASH 5.0\n#define ST_SCCES 7.0\n#define ST_GMOVR 8.0\n\n// Menu selections. Starting at zero allows us to floor(mod()).\n#define MS_START 0.0\n#define MS_HOWTO 1.0\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    Writes a single to the buffer. How does this work, you ask?\n    That inout float buff at the start of each frame is read from\n    the framebuffer that we are storing stuff in. Then every time \n    we want to save something to that buffer, we call one of the\n    write functions, passing in that texel we read.\n    If the current fragment position is that of the storage location,\n    we modify the inout var.\n    Finally, at the end of the frame, the texel we loaded and passed\n    around is what gets written out to the framebuffer.\n */\nvoid write1( inout float buff, in float v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.01,max(off.x,off.y)) );\n}\n\n/*\n    Uses the same technique to write two components.\n*/\nvoid write2( inout vec2 buff, in vec2 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.01,max(off.x,off.y)) );\n}\n\n/* \n    Again, but with three!\n */\nvoid write3( inout vec3 buff, in vec3 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.01,max(off.x,off.y)) );\n}\n\n/* \n    Do the whole gabbernazzle all at once.\n*/\nvoid write4( inout vec4 buff, in vec4 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.01,max(off.x,off.y)) );\n}\n\n/* \n    The seminal RNGF.\n */\nfloat rand( in float t ){\n    return fract(sin(t*1230.114) * 43758.5453);\n}\n\n/* \n    A simpler FBM for non-crucial samples, such as for\n    the camera zoom.\n */\nfloat partialFBM( in vec2 uv )\n{\n    \n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    return result * .5714; // * (1.0/1.75);\n}\n\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n/* \n    The distance to the lunar surface, or rather \n    to a transformed FBM.\n */\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n/*\n    Returns the distance to the surface with less high frequency\n    noise. Used to make the camera less scizophrenic.\n*/\nfloat distSoftLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = partialFBM(q);\n    return uv.y - f*f*1.;\n}\n\n/*\n    The surface normal of the lunar surface. Uses the local differential \n    technique, but in 2D.\n*/\nvec2 lunarSurfaceNormal( in vec2 uv )\n{\treturn normalize( vec2(distLunarSurface(vec2(uv.x+EPSILON,uv.y)),\n\t\t\t\t\t\t   distLunarSurface(vec2(uv.x,uv.y+EPSILON)))-\n                      vec2(distLunarSurface(vec2(uv.x-EPSILON,uv.y)),\n\t\t\t\t\t\t   distLunarSurface(vec2(uv.x,uv.y-EPSILON))));\n}\n\n/*\n    Returns the value of a pad, which is dependent on its color,\n    which is dependent on it's height, the latter of which we care about.\n*/\nfloat padValue( in vec2 uv )\n{\n    uv.y *= 12.0;\n    uv.y = mod(uv.y,4.0);\n    float res = 0.0;\n    res += (step(-.5,uv.y)-step(0.5,uv.y))*PRP;\n    res += (step(0.5,uv.y)-step(1.5,uv.y))*YEL;\n    res += (step(1.5,uv.y)-step(2.5,uv.y))*BLU;\n    res += (step(2.5,uv.y)-step(3.5,uv.y))*GRN;\n    res += (step(3.5,uv.y)-step(4.5,uv.y))*ORG;\n    return res;\n}\n\n/* \n    When the state is that of the splash screen, this funciton\n    is called. It checks key state and changes the state to\n    the main menu when Enter is pressed.\n */\nvoid handleSplash( inout vec4 buff, in vec2 fc, in vec2 keys )\n{\n    // If enter is pressed, we change the state to ST_MMENU.\n    float curState = readTexel(DATA_BUFFER,txSTATE).r;\n    write1(buff.r, mix(curState, ST_MMENU, step(.5,keys.x)), txSTATE, fc);\n    // Eh we don't want to trigger the fade in again when\n    // we go from splash to main menu, so we don't set txPCHANGE.\n}\n\n/* \n    The main menu functionality handler. Checks keys, updates stuff,\n    possibly changes the program state.\n */\nvoid handleMMenu( inout vec4 buff, in vec2 fc, in vec2 keys, in vec4 dirs )\n{\n    // Load current menu selection.\n    float curMenu = readTexel(DATA_BUFFER,txMSEL).r;\n    float curState = readTexel(DATA_BUFFER,txSTATE).r;\n    \n    // If the UP or DOWN keys are pressed, we cycle the menu\n    // in that direction.\n    curMenu -= step(.5,dirs.z);\n    curMenu += step(.5,dirs.w);\n    curMenu = floor(mod(curMenu,2.0));\n    \n    // Save the current menu selection in case we have to go another\n    // frame here.\n    write1(buff.r, curMenu, txMSEL, fc);\n    \n    // Now we do selection testing.\n    float newState = curState;\n    \n    // curMenu is 0 or 1, so this is works for binary selection.\n    newState = mix(ST_INITG,ST_HOWTO,curMenu);\n    \n    // Write either the existing value or current value.\n    // Notice how I assume the buffer holds the previous value? This can be\n    // done because the only time writeX() writes to the buffer passed in\n    // is when the current fragment coordinate aligns with the position\n    // that we want to write to. Also note that the buffer value that is passed\n    // in is the texel from the data buffer at the current fragCoord.\n    // So in the only actionable situation, buff does hold the prior value.\n    write1(buff.r, mix( buff.r,iTime, step(.5,keys.x) ), txPCHANGE, fc);\n    \n    // Write either our new state or the current state.\n    write1(buff.r, mix(curState, newState, step(.5,keys.x) ), txSTATE,fc);\n}\n\n/*\n    The handler for the how-to menu. Simply changes the state\n    upon enter being pressed.\n*/\nvoid handleHowto( inout vec4 buff, in vec2 fc, in vec2 keys )\n{\n    // If enter is pressed, we change the state to ST_MMENU.\n    // Otherwise, we just write was there.\n    float curState = readTexel(DATA_BUFFER,txSTATE).r;\n    write1(buff.r, mix(curState, ST_MMENU, step(.5,keys.x)), txSTATE, fc);\n    write1(buff.r, mix(buff.r,iTime, step(.5,keys.x)), txPCHANGE, fc);\n}\n\n/*\n    Initializes/resets the player/ship before each round, then\n    sets the state to that of actual gameplay. This keeps load times\n    down to 1/60 second!\n*/\nvoid handleInitialization( inout vec4 buff, in vec2 fc, inout vec4 psvl, inout vec4 fsrt )\n{\n    // Get a random value\n    float r = rand(iTime)*2.0 - 1.0;\n    \n    // Initialize ship position and velocity, with horizontal\n    // position and velocity being random-ish.\n    psvl = vec4(20.0*r,.8, .003*r, 0.0);\n    \n   \t// Initialize fuel amount, rotation and score.\n    // If fsrt is already set up, don't reset the score or fuel.\n    fsrt = mix( vec4(STRTFUEL, 0.0, 0.0, 0.0), \n                vec4(fsrt.x, fsrt.y, 0.0, 0.0), \n                step(.001, length(fsrt) ) );\n    \n    // Initialize the camera.\n    vec3 cam = vec3(psvl.xy, 1.0);\n    \n    // Store these new values.\n    write4(buff, psvl, txPSVL, fc);\n    write4(buff, fsrt, txFSRT, fc);\n    write3(buff.xyz, cam, txCAM, fc);\n    \n    // Change game state.\n    write1(buff.r, ST_GAMEP, txSTATE, fc);\n    \n    // Store the time of the state change.\n    write1(buff.r,iTime,txPCHANGE,fc);\n}\n\n/*\n    The ship per-frame update handler. Updates velocity based on gravity\n    and potentially boost, as well as manages fuel. This was fun to de-branch.\n*/\nvoid handleShip( inout vec4 buff, in vec2 fc, in vec2 keys, in vec4 dirs, inout vec4 psvl, inout vec4 fsrt )\n{   \n    // Since some people I know want to play this on machines where 15fps is\n    // the norm, here's framerate compensation.\n    float frameTimeSkew = iTimeDelta*60.0;\n    \n    // Gravity comes first. (or after that calculation above.)\n    psvl.zw += GRAV*frameTimeSkew;\n    \n    // Handle heading update.\n    fsrt.z += ROTSPD*dirs.x*frameTimeSkew;\n    fsrt.z -= ROTSPD*dirs.y*frameTimeSkew;\n    \n    // Handle fuel consumption and volontary acceleration.\n    // fuel.\n    fsrt.x -= BSTCOST*keys.y*step(BSTCOST,fsrt.x)*frameTimeSkew;\n    // Set throttle position to on if necessary.\n    fsrt.w = keys.y*step(BSTCOST,fsrt.x);\n    // Get the acceleration vector from the current acceleration,\n    // and boost!\n    psvl.zw += vec2(-sin(fsrt.z),cos(fsrt.z))*BSTACCL*keys.y*step(BSTCOST,fsrt.x)*frameTimeSkew;\n    \n    // Now that all changes to velocity are accounted for, let's move.\n    psvl.xy += psvl.zw;\n}\n\n/*\n    Handles camera positioning. Right now it's just centered on ship,\n    and the zoom is based on the distance the ship is above a smoother\n    terrain.\n*/\nvoid handleCamera( inout vec4 buff, in vec2 fc, inout vec4 psvl )\n{\n    \n    // Get the current camera position.\n    vec3 cam = readTexel(DATA_BUFFER, txCAM).rgb;   \n    \n    // Awesome camera, but doesn't like the dynamic zoom.\n    // vec2 diff = cam.xy-psvl.xy;\n    // cam.x += psvl.z*abs(diff.x)*cam.z;\n    // cam.y += psvl.w*abs(diff.y)*cam.z;\n    // Locked camera. Oh well.\n    cam.xy = psvl.xy;\n    \n    // This bases zoom off of the actual distance to the noise.\n    vec2 diff = vec2(EPSILON,0);\n    float smoothDist = distSoftLunarSurface(psvl.xy+diff)-\n        \t\t\t   distSoftLunarSurface(psvl.xy-diff) / 2.0*EPSILON;\n    cam.z = clamp(.5/smoothDist, 1.25, 4.0);\n    \n    // Move the camera if the ship is too far in a certain direction.\n    // Store our wibberknacked camera.\n    write3(buff.xyz,cam,txCAM,fc);\n}\n\n/*\n    Handles collision.\n    First, the distance to the ground is checked. If it is within\n    a certain threshold, then the ship is considered to be hitting\n    the terrain.\n    If so, we see if the landing is safe or catastrophic. For it to\n    safe is simple, the ship must not be going too fast, and its\n    orientation must roughly align with the surface normal of the\n    ground below the ship, and the surface must be ~level.\n    Otherwise, it's boom-boom.\n    \n    Also, I'm not sure about un-branching this.\n*/\nvoid handleCollision( inout vec4 buff, in vec2 fc, inout vec4 psvl, inout vec4 fsrt )\n{\n    // Distance check.\n    float dist = distLunarSurface(psvl.xy);\n    if( dist <= DSTTHRSH )\n    {\n        // Let's get the surface normal of the moon here.\n        vec2 n = lunarSurfaceNormal(psvl.xy);\n        // Now let's get the ship's orientation.\n        vec2 o = vec2(-sin(fsrt.z),cos(fsrt.z));\n        \n        // Now if the dot product is high, then we're ~aligned.\n        float dN = dot(n,o);\n        float dU = dot(UP,o);\n        // Get the pad value at the point of collision, not the position of the ship.\n        float pv = padValue(vec2(psvl.x,psvl.y-dist));\n        \n        // With all of this we can do some validity testing on\n        // the landing.\n        if( length(psvl.zw) < SPDTHRSH ) // Speed check.\n        {\n            if( dN > DOTTHRSH && dU > INCTHRSH ) // orientation checking.\n            {\n                // YAY! Success!\n                //Add to the score.\n                // ALRIGHTY GUYS I HAVE A QUESTION.\n                // If I increment the score by 5000 instead of 5,\n                // velocity breaks. I don't know why.\n                // fsrt.y seems to have a max value <= 100. Why?\n                fsrt.y += dN*dN*pv;\n                write1(buff.r, ST_SCCES, txSTATE, fc);\n    \t\t\twrite1(buff.r, iTime, txPCHANGE, fc);\n                return;\n            }\n        }\n        // If the player crashed we update the fuel, then change the state.\n        fsrt.x -= 100.0;\n        write1(buff.r, ST_CRASH, txSTATE, fc);\n    \twrite1(buff.r, iTime, txPCHANGE, fc);\n    }\n}\n\n/*\n    Handles the whole of gameplay, tying camera updates, collision,\n    and ship updates together. Note that the psvl and fsrt are inout--\n    this is so that each method manipulates (the same instance) of these\n    vectors.\n*/\nvoid handleGameplay( inout vec4 buff, in vec2 fc, in vec2 keys, in vec4 dirs, inout vec4 psvl, inout vec4 fsrt )\n{\n    // Okay this is a work.\n    float escape = texture(KEYBOARD,vec2(KEY_ESC,KD_POS)).r;\n    write1(buff.r,mix(buff.r,ST_GMOVR,step(.5,escape)), txSTATE, fc);\n    handleCamera(buff,fc,psvl);\n    handleCollision(buff,fc,psvl,fsrt);\n    handleShip(buff,fc,keys,dirs,psvl,fsrt);\n}\n\n/*\n    Handles what happens when the player lands. We only need one of these since\n    the success and crash landing behavior at this point of execution are\n    the same.\n*/\nvoid handleLanding( inout vec4 buff, in vec2 fc, in vec2 keys, inout vec4 fsrt )\n{\n    float pchange = readTexel(DATA_BUFFER, txPCHANGE).r;\n    float dochange = max( step(.5,keys.x), step(LANDTIME, iTime-pchange) );\n    float newState = mix( ST_GMOVR, ST_INITG, step(BSTCOST,fsrt.x) );\n    write1(buff.r, mix(buff.r, newState, dochange), txSTATE, fc);\n    write1(buff.r, mix(buff.r, iTime, dochange), txPCHANGE, fc);\n}\n\n/*\n    What happens when the player tries to start a new round but is already\n    out of fuel? Well the game is over silly!\n*/\nvoid handleGameOver( inout vec4 buff, in vec2 fc, in vec2 keys, inout vec4 fsrt )\n{\n    float pchange = readTexel(DATA_BUFFER, txPCHANGE).r;\n    float dochange = step(.5,keys.x);\n    write1(buff.r, mix(buff.r,ST_SPLSH,dochange), txSTATE, fc);\n    write1(buff.r, mix(buff.r,iTime,dochange), txPCHANGE, fc);\n    // Now that we're done displaying the score, we can clear out the\n    // last play's ship, since the initializer can't tell the difference\n    // between the last round's ship and the last game's ship.\n    fsrt = mix(fsrt,vec4(0),dochange);\n}\n\n/*\n    Takes a state, and does stuff based on that state.\n*/\nvoid handleGame( inout vec4 buff, in vec2 fc, in vec2 keys, in vec4 dirs, inout vec4 psvl, inout vec4 fsrt )\n{\n    // Okay a whole lot of stuff happens in these branches. So for the sake of\n    // the user maybe having MIMD functionality, or proper branching, let's leave this.\n    // Doing all of these branches certainly must outweigh conditionality's overhead.\n    float curState = readTexel(DATA_BUFFER, txSTATE).r;\n    if(curState == ST_SPLSH) handleSplash(buff,fc,keys);\n    else if( curState > ST_MMENU-.5 && curState < ST_MMENU+.5 ) handleMMenu(buff,fc,keys,dirs);\n    else if( curState > ST_HOWTO-.5 && curState < ST_HOWTO+.5 ) handleHowto(buff,fc,keys);\n    else if( curState > ST_INITG-.5 && curState < ST_INITG+.5 ) handleInitialization(buff,fc,psvl,fsrt);\n    else if( curState > ST_GAMEP-.5 && curState < ST_GAMEP+.5 ) handleGameplay(buff, fc,keys,dirs,psvl,fsrt);\n    else if( curState > ST_CRASH-.5 && curState < ST_CRASH+.5 ) handleLanding(buff,fc,keys,fsrt);\n    else if( curState > ST_SCCES-.5 && curState < ST_SCCES+.5 ) handleLanding(buff,fc,keys,fsrt);\n    else if( curState > ST_GMOVR-.5 && curState < ST_GMOVR+.5 ) handleGameOver(buff,fc,keys,fsrt);\n\telse return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We don't need to run logic for fragments that are not within the region\n    // we're storing stuff in.\n    if( max(fragCoord.x,fragCoord.y) > 7.0 ) discard; // That cuts a vast majority of the pixelz.\n    // Load the buffer at this fragment's position.\n    vec4 buff = texture(DATA_BUFFER,fragCoord/BUFF_RES);\n    // Scan the keyboard.\n    vec2 keys; vec4 dirs; \n    // Get current directional key state.\n    dirs.x = texture(KEYBOARD,vec2(KEY_LEFT, KD_POS)).r;\n    dirs.y = texture(KEYBOARD,vec2(KEY_RGHT, KD_POS)).r;\n    dirs.z = texture(KEYBOARD,vec2(KEY_UP, KP_POS)).r;\n    dirs.w = texture(KEYBOARD,vec2(KEY_DOWN, KP_POS)).r;\n    // Get current operational key state.\n    keys.x = texture(KEYBOARD,vec2(KEY_ENT, KP_POS)).r;\n    keys.y = texture(KEYBOARD,vec2(KEY_SPC, KD_POS)).r;\n    \n    // Since everything uses it...\n    // Get current ship state and game state.\n    vec4 psvl = readTexel(DATA_BUFFER, txPSVL);\n    vec4 fsrt = readTexel(DATA_BUFFER, txFSRT);\n    \n    // Call the key handler.\n    handleGame(buff,fragCoord, keys, dirs,psvl,fsrt);\n    \n    // Save all that shizzam.\n    write4(buff,psvl,txPSVL,fragCoord);\n    write4(buff,fsrt,txFSRT,fragCoord);    \n    \n    // Write out this fragment position's result.\n    fragColor = buff;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Space Lander\n    License: GPLv2\n\tThis buffer just renders the \"How To Play\" help screen. It's\n    definitely the least worked of all the buffers, I'd say.\n*/\n\n// Locations of the texels in the data buffer that store game state.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 txSTATE   = vec2(4,4); // Current game state. Splash, menu, gameplay etc...\nconst vec2 txPCHANGE = vec2(6,2); // Time of last state change.\n\n// Rendering constants.\nconst vec3 STAR_COLOR_A = vec3(1,1,1);   // Plane A star color.\nconst vec3 STAR_COLOR_B = vec3(1,.8,.5); // Plane B star color.\nconst vec3 STAR_COLOR_C = vec3(.5,1,1);  // Plane C star color.\nconst vec4 ORG = vec4(1,.33,.125,1);    // Pad colors.\nconst vec4 GRN = vec4(.125,1,.125,1);\nconst vec4 BLU = vec4(.125,.125,1,1);\nconst vec4 YEL = vec4(1,1,0,1);\nconst vec4 PRP = vec4(1,0,1,1);\n\n\n// iChannel definitions.\n#define NOISE_TEX iChannel1\n#define DATA_BUFFER iChannel0\n// Character encodings.\n#define _f(n,v) n = float(v)\nconst highp float _f(CH_A,   0x69f99), _f(CH_B,   0x79797), _f(CH_C,   0xe111e),\n       \t  \t     _f(CH_D,   0x79997), _f(CH_E,   0xf171f), _f(CH_F,   0xf1711),\n\t\t  \t     _f(CH_G,   0xe1d96), _f(CH_H,   0x99f99), _f(CH_I,   0xf444f),\n\t\t  \t     _f(CH_L,   0x1111f), _f(CH_M,   0x9f999), _f(CH_N,   0x9bd99), \n                 _f(CH_O,   0x69996), _f(CH_P,   0x79971), _f(CH_Q,   0x69b5a), \n                 _f(CH_R,   0x79759), _f(CH_S,   0xe1687), _f(CH_T,   0xf4444), \n                 _f(CH_U,   0x99996), _f(CH_V,   0x999a4), _f(CH_W,   0x999f9), \n                 _f(CH_X,   0x99699), _f(CH_Y,   0x99e8e), _f(CH_1,   0x46444), \n                 _f(CH_2,   0x6942f), _f(CH_4,   0x99f88), _f(CH_6,   0x61796), \n                 _f(CH_8,   0x69696), _f(CH_HYPH,0x00600), _f(CH_EQUL,0x0f0f0),\n                 _f(CH_FSTP,0x00002), _f(CH_LEFT,0x8CEC8), _f(CH_RGHT,0x13731),\n                 _f(CH_FULL,0xfffff), _f(CH_ENTA,0x46f64), _f(CH_COLN,0x00202),\n    \t\t\t _f(CH_ENTB,0x88f00);\n#undef _f\nconst lowp vec2 MAP_SIZE = vec2(4,5);\nconst lowp float KERN = 6.0;\n\n// The \"how-to\" game state.\n#define ST_HOWTO 2.0\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    A simpler FBM for non-crucial samples, such as for\n    the camera zoom.\n */\nfloat partialFBM( in vec2 uv )\n{\n    \n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    return result * .5714; // * (1.0/1.75);\n}\n\n/*\n    Draws three layers of parallax fbm^H^H^Hstars.\n*/\nvec4 drawStars( in vec2 uv, in vec2 cam )\n{\n    // All these step thresholds are magic.\n    \n    vec2 q = uv - cam*.75; // Temporary uv.\n    float d = smoothstep(.7,.8,pow(partialFBM(q),2.0)); // Are we on a star here?\n    float r = d; // Were we ever on a star?\n    vec3 c = mix(vec3(0.0), STAR_COLOR_A, d); // The color of the star that we're on.\n    \n    // Parallax star plane 2.\n    q = uv*2.0 - cam*1.7;\n    d = smoothstep(.55,.7,pow(partialFBM(q),3.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_B, d);\n    \n    // Parallax star plane 3.\n    q = uv*4.0 - cam*3.7;\n    d = smoothstep(.4,.7,pow(partialFBM(q),4.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_C, d);\n    \n    return vec4(c,r);\n}\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map/exp2(index) ), 2.0 );\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent uv coordinate. The key difference with this implementation\n    and my reference one is that this one has a (very useful) side\n    effect of moving the carriage.\n*/\nfloat drawChar( in float char, inout vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv-=pos;\n    uv /= size;    \n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    pos.x += KERN;\n    return clamp(res,0.0,1.0);\n}\n\n/*\n    Draws the text of the How-To screen.\n*/\nvec4 drawHowtoText( in vec2 uv, in float pchange )\n{\n    // Scale UV up a bit so that the pixels in our characters\n    // can be one-to-one.\n    vec2 scr = uv*vec2(320,180);\n    // Character position, initialized to that of the first character.\n    vec2 pos = vec2(125,152);\n    // Accumulators for each character's contribution. One for the\n    // titles and another for content so we can tell them apart.\n    float charT = 0.0, char = 0.0;\n    // Oh, and another one for the color swatches.\n    vec4 color = vec4(0);\n    \n    // \"-Controls-\"\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_C,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_N,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_T,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_R,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_L,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_S,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    pos.y -= 10.0;\n    pos.x = 108.0;\n    \n    // \"Rotate Ship: < >\"\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_A,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    pos.x += KERN; \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_H,pos,MAP_SIZE,scr);\n    char += drawChar(CH_I,pos,MAP_SIZE,scr);\n    char += drawChar(CH_P,pos,MAP_SIZE,scr);\n    char += drawChar(CH_COLN,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    char += drawChar(CH_LEFT,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    char += drawChar(CH_RGHT,pos,MAP_SIZE,scr);\n    \n    // \"Boosters: space\"\n    pos.y -= 10.0;\n    pos.x = 110.0;\n    char += drawChar(CH_B,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_COLN,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_P,pos,MAP_SIZE,scr);\n    char += drawChar(CH_A,pos,MAP_SIZE,scr);\n    char += drawChar(CH_C,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    \n    // \"-How To Play-\"\n    pos.y -= 20.0;\n    pos.x = 115.0;\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_H,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_W,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    charT += drawChar(CH_T,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_O,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    charT += drawChar(CH_P,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_L,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_A,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_Y,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    \n    // \"Rotate ship and boost to move.\"\n    pos.y -= 10.0;\n    pos.x = 68.0;\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_A,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    pos.x += KERN; \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_H,pos,MAP_SIZE,scr);\n    char += drawChar(CH_I,pos,MAP_SIZE,scr);\n    char += drawChar(CH_P,pos,MAP_SIZE,scr);\n    pos.x += KERN; \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_D,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_B,pos,MAP_SIZE,scr); \n    char += drawChar(CH_O,pos,MAP_SIZE,scr); \n    char += drawChar(CH_O,pos,MAP_SIZE,scr); \n    char += drawChar(CH_S,pos,MAP_SIZE,scr); \n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    pos.x += KERN;  \n    char += drawChar(CH_M,pos,MAP_SIZE,scr); \n    char += drawChar(CH_O,pos,MAP_SIZE,scr); \n    char += drawChar(CH_V,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_FSTP,pos,MAP_SIZE,scr);\n    \n    // \"Land squarely on colored pads.\"\n    pos.y -= 10.0;\n    pos.x = 68.0;\n    char += drawChar(CH_L,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_D,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    char += drawChar(CH_S,pos,MAP_SIZE,scr); \n    char += drawChar(CH_Q,pos,MAP_SIZE,scr); \n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_L,pos,MAP_SIZE,scr); \n    char += drawChar(CH_Y,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_N,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_C,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_L,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_D,pos,MAP_SIZE,scr);  \n    pos.x += KERN;    \n    char += drawChar(CH_P,pos,MAP_SIZE,scr);  \n    char += drawChar(CH_A,pos,MAP_SIZE,scr);  \n    char += drawChar(CH_D,pos,MAP_SIZE,scr);  \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);  \n    char += drawChar(CH_FSTP,pos,MAP_SIZE,scr);\n    \n    // \"How square determines score.\"\n    pos.y -= 10.0;\n    pos.x = 73.0;\n    char += drawChar(CH_H,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_W,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_Q,pos,MAP_SIZE,scr);\n    char += drawChar(CH_U,pos,MAP_SIZE,scr);\n    char += drawChar(CH_A,pos,MAP_SIZE,scr);\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_D,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_T,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_M,pos,MAP_SIZE,scr);\n    char += drawChar(CH_I,pos,MAP_SIZE,scr);\n    char += drawChar(CH_N,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    char += drawChar(CH_C,pos,MAP_SIZE,scr);\n    char += drawChar(CH_O,pos,MAP_SIZE,scr);\n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    char += drawChar(CH_FSTP,pos,MAP_SIZE,scr);\n    \n    // \"Game ends when fuel runs out.\" \n    pos.y -= 10.0;\n    pos.x = 70.0;\n    char += drawChar(CH_G,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_M,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr);\n    pos.x += KERN;  \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_D,pos,MAP_SIZE,scr); \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_W,pos,MAP_SIZE,scr); \n    char += drawChar(CH_H,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr);\n    pos.x += KERN;  \n    char += drawChar(CH_F,pos,MAP_SIZE,scr); \n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_L,pos,MAP_SIZE,scr);\n    pos.x += KERN;   \n    char += drawChar(CH_R,pos,MAP_SIZE,scr); \n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;  \n    char += drawChar(CH_O,pos,MAP_SIZE,scr); \n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    char += drawChar(CH_FSTP,pos,MAP_SIZE,scr);\n    \n    // \"-Pad Values-\"\n    pos.y -= 20.0;\n    pos.x = 117.0;\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_P,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_A,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_D,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    charT += drawChar(CH_V,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_A,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_L,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_U,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_E,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_S,pos,MAP_SIZE,scr);\n    charT += drawChar(CH_HYPH,pos,MAP_SIZE,scr);\n    \n    // \"{pad values}\"\n    pos.y -= 10.0;\n    pos.x = 80.0;\n    color += drawChar(CH_FULL,pos,MAP_SIZE,scr)*BLU;\n    char += drawChar(CH_EQUL,pos,MAP_SIZE,scr);\n    char += drawChar(CH_1,pos,MAP_SIZE,scr);\n    char += drawChar(CH_X,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    color += drawChar(CH_FULL,pos,MAP_SIZE,scr)*YEL;\n    char += drawChar(CH_EQUL,pos,MAP_SIZE,scr);\n    char += drawChar(CH_2,pos,MAP_SIZE,scr);\n    char += drawChar(CH_X,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    color += drawChar(CH_FULL,pos,MAP_SIZE,scr)*GRN;\n    char += drawChar(CH_EQUL,pos,MAP_SIZE,scr);\n    char += drawChar(CH_4,pos,MAP_SIZE,scr);\n    char += drawChar(CH_X,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    color += drawChar(CH_FULL,pos,MAP_SIZE,scr)*PRP;\n    char += drawChar(CH_EQUL,pos,MAP_SIZE,scr);\n    char += drawChar(CH_6,pos,MAP_SIZE,scr);\n    char += drawChar(CH_X,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    color += drawChar(CH_FULL,pos,MAP_SIZE,scr)*ORG;\n    char += drawChar(CH_EQUL,pos,MAP_SIZE,scr);\n    char += drawChar(CH_8,pos,MAP_SIZE,scr);\n    char += drawChar(CH_X,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    \n    // -Press {enter} to return-\n    pos.y -= 20.0;\n    pos.x = 100.0;\n    charT += drawChar(CH_P,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_R,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_E,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_S,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    // The two halves of the Enter symbol need to be drawn flush.\n    charT += drawChar(CH_ENTA,pos,MAP_SIZE,scr); pos.x -= KERN-MAP_SIZE.x;\n    charT += drawChar(CH_ENTB,pos,MAP_SIZE,scr); \n    pos.x += KERN;  \n    charT += drawChar(CH_T,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_O,pos,MAP_SIZE,scr); \n    pos.x += KERN;  \n    charT += drawChar(CH_R,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_E,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_T,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_U,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_R,pos,MAP_SIZE,scr); \n    charT += drawChar(CH_N,pos,MAP_SIZE,scr); \n    \n    // Have text scroll in from the top. That .2333 is the top of the\n    // text normalized. The .05555 is the screen fraction occupied (.66666)\n    // divided by the number of lines(11).\n    float scrollTime = floor((iTime-pchange)*1.0);\n    float scrollPos = .100000+uv.y+scrollTime*.05555;\n    float fade = floor(clamp(scrollPos, 0.0,1.0));\n    \n    \n    // All this nonsense with floor() is to make sure that\n    // the sheen is pixel perfect relative to the letters,\n    // and has a snazzy retro stairstep gradient.\n    float sheenTime = iTime - floor(scr.x)*.003125;\n    float sheen = .5 + .5*smoothstep( .995, 1.00, sin(sheenTime));\n    sheen = floor(sheen*4.0)*.25;\n    \n    float res = charT + sheen*char;\n    \n    return vec4(res+color.rgb,charT+char+color.a)*fade;\n}\n\n/*\n    Draws the content of the How-To screen.\n*/\nvec4 drawHowtoScreen( in vec2 uv, in float pchange )\n{\n    // How long has it been since the previous state change?\n    float time = iTime-pchange;\n    \n    // A -1..1 version of screen space.\n    vec2 q = uv*2.0 - 1.0;\n    \n    // A coefficient to cull out star pixels near q.y = 0.\n    float cull = smoothstep(.0,.333,abs(q.y));\n    \n    // Warp the domain so that we get the two plane tunnel.\n    q.x = q.x/abs(q.y);\n\tq.y = 1.0/abs(q.y);\n    // Render the stars.\n    vec4 s = drawStars(q,vec2(q.x, q.y+time*-.05))*cull;\n    // Render the \"how-to\" text.\n    vec4 t = drawHowtoText(uv,pchange);\n    // Alpha mix the two things together.\n    return mix(s,t,t.a)*min(time,1.0);\n}\n\n/*\n    Shadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the current state of the game.\n    float state = readTexel(DATA_BUFFER, txSTATE).r;\n    \n    // If we aren't on this screen, screw it.\n    if( state != ST_HOWTO ) discard;\n    \n    // If we are though, we get the time of the last state change.\n    float pchange = readTexel(DATA_BUFFER, txPCHANGE).r;\n    \n    // 0..1 screen coords.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = drawHowtoScreen(uv, pchange);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Space Lander\n    License: GPLv2\n\tThis buffer renders the splash screen, main menu, and game over screens.\n    Which one (if any) is decided by the state, stored in the data buffer \n    at txSTATE.\n*/\n\n// Game data buffer definitions.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 txFSRT    = vec2(2,4); // x = fuel, y = throttle position, z = radians, w = score\nconst vec2 txSTATE   = vec2(4,4); // Current game state. Splash, menu, gameplay etc...\nconst vec2 txMSEL    = vec2(4,6); // Current menu selection.\nconst vec2 txPCHANGE = vec2(6,2); // Time of last state change.\n\n// Rendering constants.\nconst vec3 STAR_COLOR_A = vec3(1,1,1);   // Color of the plane A stars.\nconst vec3 STAR_COLOR_B = vec3(1,.8,.5); // Color of the plane B stars.\nconst vec3 STAR_COLOR_C = vec3(.5,1,1);  // Color of the plane C stars.\nconst float TERR_WGT = 4.0 ; // Weight of the line that makes up the terrain.\n\n// Channel definitions.\n#define DATA_BUFFER iChannel0\n#define NOISE_TEX iChannel1\n\n// FBM distance estimation sample differential.\n#define EPSILON .05\n\n// Game states.\n#define ST_SPLSH 0.0\n#define ST_MMENU 1.0\n#define ST_HOWTO 2.0\n#define ST_INITG 3.0\n#define ST_GAMEP 4.0\n#define ST_CRASH 5.0\n#define ST_SCCES 7.0\n#define ST_GMOVR 8.0\n\n// Menu selections.\n#define MS_START 0.0\n#define MS_HOWTO 1.0\n\n// Line width for the ship.\n#define L_WGHT_A .0020\n#define L_WGHT_B .0035\n\n// Character encodings.\n#define _f(n,v) n = float(v)\nconst highp float _f(CH_A,   0x69f99), _f(CH_C,   0xe111e), _f(CH_D,   0x79997), \n    \t\t\t _f(CH_E,   0xf171f), _f(CH_G,   0xe1d96), _f(CH_H,   0x99f99),\n\t\t  \t     _f(CH_L,   0x1111f), _f(CH_M,   0x9f999), _f(CH_N,   0x9bd99), \n    \t\t\t _f(CH_O,   0x69996), _f(CH_P,   0x79971), _f(CH_R,   0x79759),\n\t\t  \t     _f(CH_S,   0xe1687), _f(CH_T,   0xf4444), _f(CH_U,   0x99996),\n\t\t  \t     _f(CH_V,   0x999a4), _f(CH_W,   0x999f9), _f(CH_Y,   0x99e8e), \n    \t \t \t _f(CH_0,   0x6bd96), _f(CH_1,   0x46444), _f(CH_2,   0x6942f), \n                 _f(CH_3,   0x69496), _f(CH_4,   0x99f88), _f(CH_5,   0xf1687), \n                 _f(CH_6,   0x61796), _f(CH_7,   0xf8421), _f(CH_8,   0x69696), \n                 _f(CH_9,   0x69e84), _f(CH_HYPH,0x00600), _f(CH_EXCL,0x33303), \n                 _f(CH_COLN,0x00202), _f(CH_LEFT,0x8CEC8), _f(CH_RGHT,0x13731), \n                 _f(CH_ENTA,0x46f64), _f(CH_ENTB,0x88f00);\n#undef _f\nconst lowp vec2 MAP_SIZE = vec2(4,5);\nconst lowp float KERN = 6.0;\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    A simpler FBM for non-crucial samples, such as for\n    the camera zoom.\n */\nfloat partialFBM( in vec2 uv )\n{\n    \n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    return result * .5714; // * (1.0/1.75);\n}\n\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n/* \n    The distance to the lunar surface, or rather \n    to a transformed FBM.\n */\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n/*\n    Draws the lunar surface.\n*/\nvec4 drawLunarSurface( in vec2 uv )\n{\n    return vec4(1.0 - step(TERR_WGT/iResolution.x, abs(distLunarSurface(uv))));\n}\n\n/*\n    Draws three layers of parallax fbm^H^H^Hstars.\n*/\nvec4 drawStars( in vec2 uv, in vec2 cam )\n{\n    uv*=.5;\n    cam*=.5;\n    // All these step thresholds are magic.\n    \n    vec2 q = uv - cam*.75; // Temporary uv.\n    float d = smoothstep(.7,.8,pow(partialFBM(q),2.0)); // Are we on a star here?\n    float r = d; // Were we ever on a star?\n    vec3 c = mix(vec3(0.0), STAR_COLOR_A, d); // The color of the star that we're on.\n    \n    // Parallax star plane 2.\n    q = uv*2.0 - cam*1.7;\n    d = smoothstep(.55,.7,pow(partialFBM(q),3.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_B, d);\n    \n    // Parallax star plane 3.\n    q = uv*4.0 - cam*3.7;\n    d = smoothstep(.4,.7,pow(partialFBM(q),4.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_C, d);\n    \n    return vec4(c,r);\n}\n\n/*\n    Draws the playfield--the stars and the terrain.\n*/\nvec4 drawPlayfield( in vec2 uv, in vec3 cam )\n{\n    uv /= cam.z;\n    uv += cam.xy;\n    vec4 result = vec4(0.0);\n    vec4 elements = mix(drawLunarSurface(uv),drawStars(uv,cam.xy),step(0.0,distLunarSurface(uv)));\n    return mix(result, elements, elements.a);\n}\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map/exp2(index) ), 2.0 );\n}\n\n/*\n\tTrades a float for a character bitmap. Here's to eliminating\n\tbranches with step()!\n*/\nfloat floatToChar( in float x )\n{\n    float res = 0.0;\n    res += (step(-.5,x)-step(0.5,x))*CH_0;\n    res += (step(0.5,x)-step(1.5,x))*CH_1;\n    res += (step(1.5,x)-step(2.5,x))*CH_2;\n    res += (step(2.5,x)-step(3.5,x))*CH_3;\n    res += (step(3.5,x)-step(4.5,x))*CH_4;\n    res += (step(4.5,x)-step(5.5,x))*CH_5;\n    res += (step(5.5,x)-step(6.5,x))*CH_6;\n    res += (step(6.5,x)-step(7.5,x))*CH_7;\n    res += (step(7.5,x)-step(8.5,x))*CH_8;\n    res += (step(8.5,x)-step(9.5,x))*CH_9;\n    return res;\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent uv coordinate. The key difference with this implementation\n    and my reference one is that this one has a (very useful) side\n    effect of moving the carriage.\n*/\nfloat drawChar( in float char, inout vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv-=pos;\n    uv /= size;    \n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    pos.x += KERN;\n    return clamp(res,0.0,1.0);\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nfloat drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    float res = 0.0,digit = 0.0;\n    for( int i = 0; i < 10; ++i )\n    {\n        if(val == 0 && i >= places) break;\n        digit = float( val-(val/10)*10 );\n        res += drawChar(floatToChar(digit),pos,size,uv);\n        pos.x -= size.x*2.8;\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nfloat drawInt( in float val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(val);\n    val *= s;\n    \n    float c = drawIntCarriage(int(val),p,size,uv,1);\n    return c + drawChar(CH_HYPH,p,size,uv)*max(0.0, -s);\n}\n\n/* \n    The seminal RNGF.\n */\nfloat rand(float t){\n    return fract(sin(t*1230.114) * 43758.5453);\n}\n\n/*\n    Draws the text for the splash screen.\n*/\nfloat drawSplashText( in vec2 uv )\n{\n    uv.x *= iResolution.y/iResolution.x; // Unfix aspect ratio\n    uv = uv *.5 + .5;\n    vec2 scr = uv*vec2(320,180);\n    vec2 pos = vec2(30,20);\n    \n    // \"LUNAR LANDER\"\n    float char = drawChar(CH_L,pos,MAP_SIZE,scr);\n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_L,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_D,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    \n    // \"PRESS {enter} TO PLAY\"\n    pos.x = 197.0;\n    char += drawChar(CH_P,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_S,pos,MAP_SIZE,scr); \n    char += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    // The two halves of the Enter symbol need to be drawn flush.\n    char += drawChar(CH_ENTA,pos,MAP_SIZE,scr); pos.x -= KERN-MAP_SIZE.x;\n    char += drawChar(CH_ENTB,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_T,pos,MAP_SIZE,scr); \n    char += drawChar(CH_O,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_P,pos,MAP_SIZE,scr); \n    char += drawChar(CH_L,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_Y,pos,MAP_SIZE,scr); \n    \n    // All this nonsense with floor() is to make sure that\n    // the sheen is pixel perfect relative to the letters,\n    // and has a snazzy retro stairstep gradient.\n   \tfloat time = iTime - floor(uv.x*320.0)*.003125;\n    float sheen = .5 + .5*smoothstep( .995, 1.00, sin(time));\n    sheen = floor(sheen*4.0)*.25;\n    \n    return char*sheen;\n}\n\n/*\n    Draws the main menu text.\n*/\nfloat drawMenuText( in vec2 uv, in float msel )\n{\n    uv.x *= iResolution.y/iResolution.x; // Unfix aspect ratio\n    uv = uv *.5 + .5;\n    vec2 scr = uv*vec2(320,180);\n    vec2 pos = vec2(30,20);\n    \n    // \"LUNAR LANDER\"\n    float char = drawChar(CH_L,pos,MAP_SIZE,scr);\n    char += drawChar(CH_U,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    char += drawChar(CH_L,pos,MAP_SIZE,scr); \n    char += drawChar(CH_A,pos,MAP_SIZE,scr); \n    char += drawChar(CH_N,pos,MAP_SIZE,scr); \n    char += drawChar(CH_D,pos,MAP_SIZE,scr); \n    char += drawChar(CH_E,pos,MAP_SIZE,scr); \n    char += drawChar(CH_R,pos,MAP_SIZE,scr);\n    \n    // \"Start Game\"\n    pos = vec2(210,25);\n    float charSA = drawChar(CH_RGHT,pos,MAP_SIZE,scr);\n    float charA = drawChar(CH_S,pos,MAP_SIZE,scr);\n    charA += drawChar(CH_T,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_A,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_R,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_T,pos,MAP_SIZE,scr); \n    pos.x += KERN;\n    charA += drawChar(CH_G,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_A,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_M,pos,MAP_SIZE,scr); \n    charA += drawChar(CH_E,pos,MAP_SIZE,scr);\n    charSA += drawChar(CH_LEFT,pos,MAP_SIZE,scr);\n    \n    // \"How to play\"\n    pos.x = 207.0;\n    pos.y -= 10.0;\n    float charSB = drawChar(CH_RGHT,pos,MAP_SIZE,scr);\n    float charB = drawChar(CH_H,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_O,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_W,pos,MAP_SIZE,scr); \n    pos.x += KERN; \n    charB += drawChar(CH_T,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_O,pos,MAP_SIZE,scr);\n    pos.x += KERN; \n    charB += drawChar(CH_P,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_L,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_A,pos,MAP_SIZE,scr); \n    charB += drawChar(CH_Y,pos,MAP_SIZE,scr); \n    charSB += drawChar(CH_LEFT,pos,MAP_SIZE,scr);\n    \n    float time = iTime - floor(uv.x*320.0)*.003125;\n    float sheen = .5 + .5*smoothstep( .995, 1.00, sin(time));\n    sheen = floor(sheen*4.0)*.25;\n    \n    // This relies heavily on MS_START being 0.0 and MS_HOWTO being 1.0\n    // to display the correct text.\n    return (char*sheen + charA + charSA*sheen + charB*sheen)*(1.0-msel) +\n           (char*sheen + charB + charSB*sheen + charA*sheen)*(msel);\n}\n\n/*\n    Draws the text of the game over screen.\n*/\nfloat drawGameOverText( in vec2 uv, in float time, in vec4 fsrt )\n{\n    uv.x *= iResolution.y/iResolution.x; // Unfix aspect ratio\n    uv = uv *.5 + .5;\n    vec2 scr = uv*vec2(320,180);\n    vec2 pos = vec2(30,150);\n    float charG = 0.0, charS = 0.0, charV = 0.0, charE = 0.0;\n    // Current value of the counting-up score.\n    float curVal = fsrt.y * clamp( (time-3.0)*.1667, 0.0, 1.0 );\n    // Current size of the gets-bigger-when-done counting score.\n    vec2 curSize = MAP_SIZE*(1.0+step(fsrt.y*.999,curVal)*.25);\n    \n    // \"Game over\"\n    charG += drawChar(CH_G,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_A,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_M,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_E,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    charG += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_V,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_E,pos,MAP_SIZE,scr);\n    charG += drawChar(CH_R,pos,MAP_SIZE,scr);\n    \n    // \"Your score: {score}\"\n    pos.x = 30.0;\n    pos.y -= 20.0;\n    charS += drawChar(CH_Y,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_U,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_R,pos,MAP_SIZE,scr);\n    pos.x += KERN;\n    charS += drawChar(CH_S,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_C,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_O,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_R,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_E,pos,MAP_SIZE,scr);\n    charS += drawChar(CH_COLN,pos,MAP_SIZE,scr);\n    pos.x += 7.0*KERN;\n    charV += drawInt(curVal*5000.0,pos,curSize,scr);\n    \n    // -Press {enter} to exit-\n    pos.x = 180.0;\n    pos.y = 20.0;\n    charE += drawChar(CH_P,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_R,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_E,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_S,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_S,pos,MAP_SIZE,scr);\n    pos.x += KERN;    \n    charE += drawChar(CH_ENTA,pos,MAP_SIZE,scr); pos.x -= KERN-MAP_SIZE.x;\n    charE += drawChar(CH_ENTB,pos,MAP_SIZE,scr);  \n    pos.x += KERN;  \n    charE += drawChar(CH_T,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_O,pos,MAP_SIZE,scr);  \n    pos.x += KERN;  \n    charE += drawChar(CH_R,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_E,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_T,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_U,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_R,pos,MAP_SIZE,scr);  \n    charE += drawChar(CH_N,pos,MAP_SIZE,scr);  \n    \n    // All this nonsense with floor() is to make sure that\n    // the sheen is pixel perfect relative to the letters,\n    // and has a snazzy retro stairstep gradient.\n    float sheenTime = iTime - floor(scr.x)*.003125;\n    float sheen = .5 + .5*smoothstep( .995, 1.00, sin(sheenTime));\n    sheen = floor(sheen*4.0)*.25;\n    \n    return charG * sheen * step(1.0,time) + \n           charS * sheen * step(2.0,time) + \n           charV *         step(3.0,time) + \n           charE * sheen * step(10.0,time);\n}\n/*\n    Draws the background and text that makes up the title screen,\n    be it the splash or the main menu.\n*/\nvec4 drawTitleScreen( in vec2 uv, in float state, in float msel, in float pchange, in vec4 fsrt )\n{\n    // Normalize the time to start at the time that the screen starts.\n    float time = iTime-pchange;\n    // Shutter fade.\n    float fade = 1.0-smoothstep(.9, 1.00, abs(cos(time*.35)));\n    // Constant reflecting which camera to use. (0 or 1).\n    float camSelect = step(0.0,sin(time*.35));\n    // The results of the two cameras.\n    vec4 camA = drawPlayfield(uv,vec3(time*-.1,0.5, 2.0));\n    vec4 camB = drawPlayfield(uv,vec3(time*.1, 0.5, 2.0));\n    \n    // Selects and fades between camera feeds.\n    vec4 p =mix(camA,camB,camSelect)*fade;\n    \n    // This branch potentially cuts out a LOT of work. So it stays.\n    float t;\n    if(state == ST_SPLSH)\n    \tt = drawSplashText(uv);\n    else\n        t = drawMenuText(uv, msel);\n    return mix(p, vec4(t,t,t,1), step(.5,t));\n}\n\n/*\n    Draws the background and text of the game over screen.\n*/\nvec4 drawGameOverScreen( in vec2 uv, in float state, in float msel, in float pchange, in vec4 fsrt )\n{\n    // Align the time with the start of the screen.\n    float time = iTime-pchange;\n    \n    // The Y position of the camera.\n    float py = 8.5 - smoothstep(0.0,8.0,time)*8.0;\n    \n    vec3 cam = vec3(8.9,py,3.0);\n    \n    vec4 bg = drawPlayfield(uv,cam);\n   \tfloat t = drawGameOverText(uv,time,fsrt);\n    \n    return mix(bg, vec4(t,t,t,1), step(.1,t)) * min(1.0, time);\n}\n\n/*\n    Shadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Load game and menu and ship state.\n    float state = readTexel(DATA_BUFFER, txSTATE).r;\n    if( state > ST_MMENU && state < ST_GMOVR ) discard; // Do a quick check.\n    float msel = readTexel(DATA_BUFFER, txMSEL).r;\n    float pchange = readTexel(DATA_BUFFER, txPCHANGE).r;\n    vec4 fsrt = readTexel(DATA_BUFFER, txFSRT);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    float color = distLunarSurface(uv);\n    \n    if( state <= ST_MMENU )\n\t\tfragColor = drawTitleScreen(uv,state,msel,pchange,fsrt);\n    else\n\t\tfragColor = drawGameOverScreen(uv,state,msel,pchange,fsrt);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n    Space Lander\n    License: GPLv2\n\tThis is the gameplay buffer. It renders what you see during gameplay:\n\tThe ship, the ground and sky, the hud, passive aggressive crash notices...\n*/\n\n// Game data buffer definitions.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 txPSVL    = vec2(2,2); // xy = pos, zw = vel.\nconst vec2 txFSRT    = vec2(2,4); // x = fuel, z = radians, w = score\nconst vec2 txSTATE   = vec2(4,4); // Current game state. Splash, menu, gameplay etc...\nconst vec2 txPCHANGE = vec2(6,2); // Time of last state change.\nconst vec2 txCAM     = vec2(6,4); // Camera position. x = x, y = y, z = zoom.\n\n// Rendering constants.\nconst vec3 STAR_COLOR_A = vec3(1,1,1);   // Plane A star color.\nconst vec3 STAR_COLOR_B = vec3(1,.8,.5); // Plane B star color.\nconst vec3 STAR_COLOR_C = vec3(.5,1,1);  // Plane C star color.\nconst vec2 UP = vec2(0,1); // An UP vector for orientation considerations.\nconst float TERR_WGT = 4.0 ; // Weight of the line that makes up the terrain.\nconst float L_WGHT_A = .0020; // Line width for the ship.\nconst float L_WGHT_B = .0035; // Line width for the ship.\nconst vec4 ORG_COL = vec4(1,.33,.125,1);    // Pad colors.\nconst vec4 GRN_COL = vec4(.125,1,.125,1);\nconst vec4 BLU_COL = vec4(.125,.125,1,1);\nconst vec4 YEL_COL = vec4(1,1,0,1);\nconst vec4 PRP_COL = vec4(1,0,1,1);\nconst float ORG_VAL = 8.0;      // Pad multiplier values.\nconst float GRN_VAL = 4.0;      // Pad multiplier values.\nconst float BLU_VAL = 1.0;      // Pad multiplier values.\nconst float YEL_VAL = 2.0;      // Pad multiplier values.\nconst float PRP_VAL = 6.0;      // Pad multiplier values.\nconst float INCTHRSH = .925;    // The maximum cosine away from up a surface can be to land.\n\n// Channel definitions.\n#define DATA_BUFFER iChannel0\n#define NOISE_TEX iChannel1\n\n// FBM distance estimation sample differential.\n#define EPSILON .005\n\n// Game states.\n#define ST_SPLSH 0.0\n#define ST_MMENU 1.0\n#define ST_HOWTO 2.0\n#define ST_INITG 3.0\n#define ST_GAMEP 4.0\n#define ST_CRASH 5.0\n#define ST_NFUEL 6.0\n#define ST_SCCES 7.0\n#define ST_GMOVR 8.0\n// Menu selections.\n#define MS_START 0.0\n#define MS_HOWTO 1.0\n\n// Character encodings.\n#define _f(n,v) n = float(v)\nconst highp float _f(CH_A,   0x69f99), _f(CH_C,   0xe111e), _f(CH_D,   0x79997), \n    \t\t\t _f(CH_E,   0xf171f), _f(CH_F,   0xf1711), _f(CH_G,   0xe1d96),\n    \t\t\t _f(CH_H,   0x99f99), _f(CH_I,   0xf444f), _f(CH_L,   0x1111f),\n\t\t  \t     _f(CH_N,   0x9bd99), _f(CH_O,   0x69996), _f(CH_P,   0x79971), \n    \t\t\t _f(CH_R,   0x79759), _f(CH_S,   0xe1687), _f(CH_T,   0xf4444),\n    \t\t\t _f(CH_U,   0x99996), _f(CH_V,   0x999a4), _f(CH_W,   0x999f9), \n    \t\t     _f(CH_X,   0x99699), _f(CH_Y,   0x99e8e), _f(CH_0,   0x6bd96),\n\t\t  \t     _f(CH_1,   0x46444), _f(CH_2,   0x6942f), _f(CH_3,   0x69496),\n\t\t  \t     _f(CH_4,   0x99f88), _f(CH_5,   0xf1687), _f(CH_6,   0x61796),\n\t\t  \t     _f(CH_7,   0xf8421), _f(CH_8,   0x69696), _f(CH_9,   0x69e84),\n\t\t  \t     _f(CH_HYPH,0x00600), _f(CH_EXCL,0x33303), _f(CH_FSTP,0x00002),\n    \t  \t     _f(CH_COLN,0x00202), _f(CH_CLON,0x00202);\n#undef _f\nconst lowp vec2 MAP_SIZE = vec2(4,5);\nconst lowp float KERN = 6.0;\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    The seminal RNGF.\n */\nfloat rand( in float t ){\n    return fract(sin(t*1230.114) * 43758.5453);\n}\n\n/* \n    A simpler FBM for non-crucial samples, such as for\n    the camera zoom.\n */\nfloat partialFBM( in vec2 uv )\n{\n    \n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    return result * .5714; // * (1.0/1.75);\n}\n\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n/* \n    The distance to the lunar surface, or rather \n    to a transformed FBM.\n */\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n/*\n    Returns the distance to the surface with less high frequency\n    noise. Used to make the camera less scizophrenic.\n*/\nfloat distSoftLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = partialFBM(q);\n    return uv.y - f*f*1.;\n}\n\n/*\n    Draws the lunar surface.\n*/\nfloat drawLunarSurface( in vec2 uv )\n{\n    return 1.0 - step( TERR_WGT/iResolution.x, abs(distLunarSurface(uv)) );\n}\n\n/*\n    Returns the color of a pad, which is dependent on it's height.\n*/\nvec4 padColor( in vec2 uv )\n{\n    uv.y *= 12.0;\n    uv.y = mod(uv.y,4.0);\n    vec4 res = vec4(0);\n    res += (step(-.5,uv.y)-step(0.5,uv.y))*PRP_COL;\n    res += (step(0.5,uv.y)-step(1.5,uv.y))*YEL_COL;\n    res += (step(1.5,uv.y)-step(2.5,uv.y))*BLU_COL;\n    res += (step(2.5,uv.y)-step(3.5,uv.y))*GRN_COL;\n    res += (step(3.5,uv.y)-step(4.5,uv.y))*ORG_COL;\n    return res;\n}\n\n/*\n    Returns the value of a pad, which is dependent on its color,\n    which is dependent on it's height, the latter of which we care about.\n*/\nfloat padValue( in vec2 uv )\n{\n    uv.y *= 12.0;\n    uv.y = mod(uv.y,4.0);\n    float res = 0.0;\n    res += (step(-.5,uv.y)-step(0.5,uv.y))*PRP_VAL;\n    res += (step(0.5,uv.y)-step(1.5,uv.y))*YEL_VAL;\n    res += (step(1.5,uv.y)-step(2.5,uv.y))*BLU_VAL;\n    res += (step(2.5,uv.y)-step(3.5,uv.y))*GRN_VAL;\n    res += (step(3.5,uv.y)-step(4.5,uv.y))*ORG_VAL;\n    return res;\n}\n\n/*\n    Returns the surface normal of the lunar surface.\n*/\nvec2 lunarSurfaceNormal( in vec2 uv )\n{\treturn normalize( vec2(distLunarSurface(vec2(uv.x+EPSILON,uv.y)),\n\t\t\t\t\t\t   distLunarSurface(vec2(uv.x,uv.y+EPSILON)))-\n                      vec2(distLunarSurface(vec2(uv.x-EPSILON,uv.y)),\n\t\t\t\t\t\t   distLunarSurface(vec2(uv.x,uv.y-EPSILON))) );\n}\n\n/*\n    Draws three layers of parallax fbm^H^H^Hstars.\n*/\nvec4 drawStars( in vec2 uv, in vec2 cam )\n{\n    // Make 'em bigger.\n    uv*=.5;\n    cam*=.5;\n    \n    // All these step thresholds are magic.\n    \n    vec2 q = uv - cam*.75; // Temporary uv.\n    float d = smoothstep(.7,.8,pow(partialFBM(q),2.0)); // Are we on a star here?\n    float r = d; // Were we ever on a star?\n    vec3 c = mix(vec3(0.0), STAR_COLOR_A, d); // The color of the star that we're on.\n    \n    // Parallax star plane 2.\n    q = uv*2.0 - cam*1.7;\n    d = smoothstep(.55,.7,pow(partialFBM(q),3.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_B, d);\n    \n    // Parallax star plane 3.\n    q = uv*4.0 - cam*3.7;\n    d = smoothstep(.4,.7,pow(partialFBM(q),4.0));\n    r = max(r,d);\n    c = mix(c, STAR_COLOR_C, d);\n    \n    return vec4(c,r);\n}\n\n/*\n    Draws a circle of r radius at point c given UV p.\n*/\nfloat drawCircle( in vec2 p, in vec2 c, in float r )\n{\n    return 1.0 - smoothstep(L_WGHT_A,L_WGHT_B, abs(length(p-c)-r) );\n}\n\n/*\n    IQ's capsule function, smushed down to two dimensions. It's\n    a great way to draw lines.\n*/\nfloat drawLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - smoothstep(L_WGHT_A,L_WGHT_B, length( pa - ba*h ));\n}\n\n/*\n    IQ's square function, also wringed of a third dimension.\n*/\nfloat drawSquare( in vec2 p, in vec2 b, in vec2 d )\n{\n  \tvec2 q = abs(p-b) - d;\n    return 1.0-smoothstep(L_WGHT_A, L_WGHT_B, abs(min(max(q.x,q.y),0.0) +\n           length(max(q,0.0))));\n}\n\n/*\n    By the power of those shapes combined, we shall draw the Luner Landar!\n    This also handles the explosion animation itself, with expl being whether\n    or not we've exploded, and pchange being when we exploded.\n*/\nfloat drawShip( in vec2 uv, in vec2 p, in float s, in float r, in float throttle, in float expl, in float pchange )\n{\n    // Do transformation.\n    float cr = cos(r), sr = sin(r);\n    mat2 rot = mat2(cr,sr,-sr,cr);\n    uv *= rot;\n    p *= rot;\n    uv -= p;\n    \n    // Set up stuff for the explosion animation just in case.\n    float time = iTime - pchange;\n    \n    // An independent vec2 for handling the explosion.\n    vec2 q;\n    // Draw ship.\n    p = uv + vec2(0.0,-.2)*time*expl;\n    float c = drawCircle(p*vec2(1.0,1.4), vec2(0.0,.475)*s, .45*s);\n    p = uv + vec2(0.0,-.1)*time*expl;\n    c = max(c, drawSquare(p, vec2(0,-.125)*s, vec2(.45, .125)*s));\n    \n    // Draw booster and burn.\n    p = uv + vec2(0.0,.5)*time*expl;\n    c = max(c, drawSquare(p, vec2(0.0, -.325)*s, vec2(.225, .07)*s));\n    c = max(c, drawLine(p, vec2(-.25,-.330)*s, vec2(.25,-.330)*s));\n    float rnd = rand(iTime);\n    c = max(c, drawLine(p, vec2(-.2,-.330)*s, vec2(0.0, -.330-throttle*rnd)*s));\n    c = max(c, drawLine(p, vec2(.2,-.330)*s, vec2(0.0, -.330-throttle*rnd)*s));\n    \n    // Draw left leg.\n    p = uv + vec2(.5,.2)*time*expl;\n    c = max(c, drawLine(p, vec2(-.35,-.25)*s, vec2(-.54,-.575)*s));\n    c = max(c, drawLine(p, vec2(-.45,-.131)*s, vec2(-.56,-.575)*s));\n    c = max(c, drawLine(p, vec2(-.65,-.575)*s, vec2(-.45,-.575)*s));\n    \n    // Draw right leg.\n    p = uv + vec2(-.5,.2)*time*expl;\n    c = max(c, drawLine(p, vec2(.35,-.25)*s, vec2(.54,-.575)*s));\n    c = max(c, drawLine(p, vec2(.45,-.131)*s, vec2(.56,-.575)*s));\n    c = max(c, drawLine(p, vec2(.65,-.575)*s, vec2(.45,-.575)*s));\n    return c;\n}\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map/exp2(index) ), 2.0 );\n}\n\n/*\n\tTrades a float for a character bitmap. Here's to eliminating\n\tbranches with step()!\n*/\nfloat floatToChar( in float x )\n{\n    float res = 0.0;\n    res += (step(-.5,x)-step(0.5,x))*CH_0;\n    res += (step(0.5,x)-step(1.5,x))*CH_1;\n    res += (step(1.5,x)-step(2.5,x))*CH_2;\n    res += (step(2.5,x)-step(3.5,x))*CH_3;\n    res += (step(3.5,x)-step(4.5,x))*CH_4;\n    res += (step(4.5,x)-step(5.5,x))*CH_5;\n    res += (step(5.5,x)-step(6.5,x))*CH_6;\n    res += (step(6.5,x)-step(7.5,x))*CH_7;\n    res += (step(7.5,x)-step(8.5,x))*CH_8;\n    res += (step(8.5,x)-step(9.5,x))*CH_9;\n    return res;\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent uv coordinate. The key difference with this implementation\n    and my reference one is that this one has a (very useful) side\n    effect of moving the carriage.\n*/\nfloat drawChar( in float char, inout vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv -= pos;\n    uv /= size;    \n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    pos.x += KERN;\n    return clamp(res,0.0,1.0);\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nfloat drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    // Create a place to store the current values.\n    float res = 0.0,digit = 0.0;\n    // Surely it won't be more than 10 chars long, will it?\n    // (MAX_INT is 10 characters)\n    for( int i = 0; i < 10; ++i )\n    {\n        // If we've run out of film, cut!\n        if(val == 0 && i >= places) break;\n        // The current lsd is the difference between the current\n        // value and the value rounded down one place.\n        digit = float( val-(val/10)*10 );\n        // Draw the character. Since there are no overlaps, we don't\n        // need max().\n        res += drawChar(floatToChar(digit),pos,size,uv);\n        // Move the carriage.\n        pos.x -= size.x*2.8;\n        // Truncate away this most recent digit.\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nfloat drawInt( in float val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(val);\n    val *= s;\n    \n    float c = drawIntCarriage(int(val),p,size,uv,1);\n    return c + drawChar(CH_HYPH,p,size,uv)*max(0.0, -s);\n}\n\n/*\n    Draws the text that appears on screen during gameplay.\n    This can be the standard HUD, congratulations on success,\n    or mockery on failure.\n*/\nfloat drawHUD( in vec2 uv, in vec4 fsrt, in vec4 psvl, in float state, in float pchange )\n{\n    vec2 scr = uv*vec2(320,180); // Let's make pixels from normalized screenspace.\n    vec2 pos; // To store the current text position.\n    // Character presence values for labels and warnings.\n    float charL = 0.0, charV = 0.0, charW = 0.0;\n    // Several things need to blink.\n    float blink = floor(mod((iTime-pchange+.5)*2.0,2.0));\n    // What to write when in gameplay.\n    if( state > ST_GAMEP-.5 && state < ST_GAMEP+.5 )\n    {\n        // Score: {score}\n        pos = vec2(10,165);\n        charL += drawChar(CH_S,pos,MAP_SIZE,scr);\n        charL += drawChar(CH_C,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_O,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_R,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_E,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_COLN,pos,MAP_SIZE,scr);\n        pos.x += 4.*KERN; \n        charV += drawInt( fsrt.y*5000.0, pos, MAP_SIZE, scr);\n\n        // Fuel: {fuel}\n        pos.x =  10.0;\n        pos.y -= 10.0;\n        charL += drawChar(CH_F,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_U,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_E,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_L,pos,MAP_SIZE,scr);\n        charL += drawChar(CH_COLN,pos,MAP_SIZE,scr); \n        pos.x += 5.0*KERN; \n        charV += drawInt( fsrt.x, pos, MAP_SIZE, scr);\n\n        // Alt.: {alt}\n        pos.x = 245.0;\n        pos.y = 165.0;\n        charL += drawChar(CH_A,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_L,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_T,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_FSTP,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_COLN,pos,MAP_SIZE,scr); \n        pos.x += 5.*KERN;\n        charV += drawInt(distLunarSurface(psvl.xy)*400.0, pos, MAP_SIZE, scr);\n\n        // H-Vel.: {hvel}\n        pos.x = 245.0;\n        pos.y -= 10.0;\n        charL += drawChar(CH_H,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_HYPH,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_V,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_E,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_L,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_FSTP,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_COLN,pos,MAP_SIZE,scr); \n        pos.x += 3.*KERN; \n        charV += drawInt( psvl.z*20000.0, pos, MAP_SIZE, scr);\n\n        // V-Vel.: {vvel}\n        pos.x = 245.0;\n        pos.y -= 10.0;\n        charL += drawChar(CH_V,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_HYPH,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_V,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_E,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_L,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_FSTP,pos,MAP_SIZE,scr); \n        charL += drawChar(CH_COLN,pos,MAP_SIZE,scr); \n        pos.x += 3.*KERN; \n        charV += drawInt( psvl.w*20000.0, pos, MAP_SIZE, scr);\n        \n        if( fsrt.x < .1 )\n        {\n            // \"OUT OF FUEL\"\n            pos.x = 127.0;\n            pos.y = 165.0;\n            charW += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_U,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_T,pos,MAP_SIZE,scr);\n            pos.x += KERN; \n            charW += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_F,pos,MAP_SIZE,scr);\n            pos.x += KERN; \n            charW += drawChar(CH_F,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_U,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_L,pos,MAP_SIZE,scr);\n        }\n        \n        else if( fsrt.x < 100.0 )\n        {\n            // \"LOW FUEL\"\n            pos.x = 137.0;\n            pos.y = 165.0;\n            charW += drawChar(CH_L,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_W,pos,MAP_SIZE,scr);\n            pos.x += KERN; \n            charW += drawChar(CH_F,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_U,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charW += drawChar(CH_L,pos,MAP_SIZE,scr);\n    \t}\n    }\n    // What to write if the player has crashed.\n    else if( state > ST_CRASH-.5 && state < ST_CRASH+.5 )\n    {\n        float sel = floor(mod(pchange,3.0));\n        if(sel < 1.0)\n        {\n            // \"DESTROYED!\"\n            pos = vec2(132,45);\n            charL += drawChar(CH_D,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_S,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_T,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_R,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_Y,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_D,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_EXCL,pos,MAP_SIZE,scr);\n        }\n        else if(sel < 2.0)\n        {\n            // \"DEAD!\"\n            pos = vec2(150,45);\n            charL += drawChar(CH_D,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_A,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_D,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_EXCL,pos,MAP_SIZE,scr);\n        }\n        else\n        {\n            // \"WHOOPSIE!\"\n            pos = vec2(135,45);\n            charL += drawChar(CH_W,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_H,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_O,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_P,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_S,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_I,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_E,pos,MAP_SIZE,scr);\n            charL += drawChar(CH_EXCL,pos,MAP_SIZE,scr);\n        }\n        // \"100 FUEL LOST\" This value is hard coded.\n        pos.y -= 10.0;\n        pos.x = 120.0;\n     \tcharL += drawChar(CH_1,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_0,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_0,pos,MAP_SIZE,scr);\n        pos.x += KERN;\n     \tcharL += drawChar(CH_F,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_U,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_E,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_L,pos,MAP_SIZE,scr); \n        pos.x += KERN;  \n     \tcharL += drawChar(CH_L,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_O,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_S,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_T,pos,MAP_SIZE,scr);   \n        charL *= blink;            \n    }\n    // What to do in the event of a successful landing.\n    else if( state > ST_SCCES-.5 && state < ST_SCCES+.5 )\n    {        \n        // \"SUCCESS!\"\n        pos = vec2(135,45);\n    \tcharL += drawChar(CH_S,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_U,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_C,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_C,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_E,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_S,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_S,pos,MAP_SIZE,scr);\n    \tcharL += drawChar(CH_EXCL,pos,MAP_SIZE,scr);\n        charL *= blink;  \n        vec2 padLoc = vec2(psvl.x, psvl.y-distLunarSurface(psvl.xy));\n        float padVal = padValue(padLoc);\n        // \"{pad value}x landing{! if greater than 4}\"\n        pos.y -= 10.0;\n        pos.x = 125.0;\n     \tcharL += drawChar(floatToChar(padVal),pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_X,pos,MAP_SIZE,scr);   \n        pos.x += KERN;\n     \tcharL += drawChar(CH_L,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_A,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_N,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_D,pos,MAP_SIZE,scr); \n     \tcharL += drawChar(CH_I,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_N,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_G,pos,MAP_SIZE,scr);   \n     \tcharL += drawChar(CH_EXCL,pos,MAP_SIZE,scr)*step(3.5,padVal);\n        charL *= blink;         \n    }\n        \n    charW *= blink;\n    return charL*.5 + charV + charW*.75;\n    \n}\n\n/*\n    Draws the playfield: The ground and sky.\n*/\nvec4 drawPlayfield( in vec2 uv, in vec3 cam, in vec4 psvl )\n{\n    float pad = smoothstep( INCTHRSH, INCTHRSH+.01, dot(lunarSurfaceNormal(uv),UP) );\n    vec4 color = mix(vec4(1),padColor(uv),pad);\n    vec4 result = vec4(0.0);\n    float lunar = drawLunarSurface(uv);//-vec4(1,0,1,0)*pad;\n    vec4 stars = drawStars(uv,cam.xy);\n    vec4 elements = mix( lunar*color, stars, step(0.0,distLunarSurface(uv)) );\n    \n    return mix(result, elements, elements.a);\n}\n\n/*\n    Shadertoy's entry function.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Load ship position and stuff.\n    float state = readTexel(DATA_BUFFER, txSTATE).r;\n    if( state < ST_GAMEP || state > ST_SCCES ) discard; // quick check.\n    vec4 fsrt = readTexel(DATA_BUFFER, txFSRT);\n    vec4 psvl = readTexel(DATA_BUFFER, txPSVL);\n    vec3 cam = readTexel(DATA_BUFFER, txCAM).rgb;\n    float pchange = readTexel(DATA_BUFFER, txPCHANGE).r;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p, s, h = uv; // For the playfield, ship, and hud since they all need different transforms.\n    uv = uv*2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    p = uv; s = uv;\n    \n    // Perform camera operations.\n    p /= cam.z;\n    p += cam.xy;\n    \n    // The ship, since the line weight is dependent on the scale\n    // of the input coordinate system, we have to have an independent\n    // system.\n    s += cam.xy;\n    \n    // Draw the ship\n    float ship = drawShip(s, psvl.xy, .0125*cam.z, fsrt.z, fsrt.w, float(state==ST_CRASH), pchange);\n    \n    // Draw the other stuff. Since the HUD doesn't use aspect-ratio-modified\n    // coords, it's somewhat reactive.\n    float hud = drawHUD(h, fsrt, psvl, state, pchange);\n    vec4 pfld = drawPlayfield(p,cam,psvl);\n    \n    // Alpha everything together and ship it.\n\tfragColor = pfld;\n    fragColor = mix(fragColor, vec4(hud), hud);\n    fragColor = mix(fragColor, vec4(ship), ship);\n}","name":"Buf D","description":"","type":"buffer"}]}