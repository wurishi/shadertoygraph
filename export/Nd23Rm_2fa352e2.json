{"ver":"0.1","info":{"id":"Nd23Rm","date":"1617156632","viewed":209,"name":"sdf octree","username":"ch3coohlink","description":"fork from https://www.shadertoy.com/view/4sVfWw","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// octree subdivision level, higher for greater detail\n#define detail 7\n// sample count n*n, higher for better quality\n#define samples 1\n// max traversal step, the bigger the more accurate\n#define steps 300\n// if a traversal failed, the fragColor will be red\n#define maxdistance 1.\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define sqr(a) (a*a)\n#define pi 3.1415926535\n#define opacity 1.\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n    float d = min(max(-sdSphere(p, .218), sdBox(p, vec3(.15))), -sdSphere(p, .5));\n    //float d = -sdSphere(p, 1.);\n    return int(d < size*1.73205080757);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size) {\n    size *= 0.5; return -(sign(rd)*(ro-size)-size)*ird;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int i, j; vec3 sp; int spc = samples;\n\n    for (j = 0; j < spc*spc; j++) {\n    float d = 1./float(spc);\n    vec2 spv = vec2(float(j%spc)*d-0.5, float(j/spc)*d-0.5);\n    vec2 uv = ((fragCoord.xy+spv) * 2.0 - iResolution.xy) /iResolution.y;\n    float size=1.;\n    vec3 ro = vec3(0.4*sin(iTime), 0, 0.4*cos(iTime)), rd = normalize(vec3(uv,1.0));\n    //rd.yz *= rot(0.304085*pi-pi*0.5); rd.xz *= rot(0.375*pi*2.0-pi);\n    float x = mod(iMouse.x/iResolution.x+0.5,1.), y = mod(iMouse.y/iResolution.y+0.5,1.);\n    rd.yz *= rot(y*pi-pi*0.5); rd.xz *= rot(iTime-pi); rd.xz *= rot(x*pi*2.0-pi);\n    \n    vec3 lro = mod(ro,size), fro = ro-lro;\n    vec3 ird = 1.0/max(abs(rd),0.001), mask;\n    bool exit = false; int recursions = 0;\n    float dist = 0.0, fdist = 0.0; vec3 lastmask;\n    \n    for (i = 0; i < steps; i++) {\n        if (dist > maxdistance) { break; }\n        if (exit) {\n            vec3 newfro = floor(fro/(size*2.0))*(size*2.0);\n            lro += fro-newfro;\n            fro = newfro;\n            recursions--;\n            size *= 2.0;\n            exit = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            continue;\n        } int v = getvoxel(fro, size);\n        if (v == 1 && recursions >= detail) { v = 2; }\n        if (v == 1) {\n            recursions++;\n            size *= 0.5;\n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n        } else if (v==2) { break; } else { //move forward\n            //raycast and find distance to nearest voxel surface in ray direction\n            //i don't need to use voxel() every time, but i do anyway\n            vec3 hit = voxel(lro, rd, ird, size);\n\n            if (hit.x < min(hit.y,hit.z)) { mask = vec3(1,0,0); }\n            else if (hit.y < hit.z) { mask = vec3(0,1,0); }\n            else { mask = vec3(0,0,1); }\n\n            //moving forward in ray direction, and checking if i need to go up a level\n            float len = dot(hit,mask);\n            dist += len;\n            fdist += len;\n            lro += rd*len-mask*sign(rd)*size;\n            vec3 newfro = fro+mask*sign(rd)*size;\n            exit = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n            fro = newfro; lastmask = mask;\n        }\n    }\n    if (dist > maxdistance) { sp += vec3(0,opacity,0); }\n    else if(i < steps) {\n        vec3 color = vec3(1);//sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n        vec3 normal = -lastmask*sign(rd);\n        //vec3 light = normalize(vec3(-1,0.1,0.1));\n        sp += sqrt(color*0.3 + normal*0.7)*opacity;\n        //sp += sqrt(color*0.3 + max(color*0.7*(dot(normal, light)), 0.0))*opacity;\n    } else { sp += vec3(1,0,0); }\n    } fragColor = vec4(sp/float(spc*spc),1);\n}","name":"Image","description":"","type":"image"}]}