{"ver":"0.1","info":{"id":"XsBcWt","date":"1494256108","viewed":413,"name":"Albedo to normals","username":"Liuban","description":"Generate normals from a given albedo texture.\n1 - Calculate a greyscale value from the RGB colour.\n2 - Apply Sobel operator to detect edges\n3 - calculate the normal using a gradient betwen the height values of the neighbors.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["normalsfromheightssobelfilter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat RGBToLuminance(vec3 rgb)\n{\n\treturn 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;\n}\n\n\nvec4 ColourAt(vec2 coord, vec2 resolution)\n{\n\tvec2 uv = coord / resolution.xy;\n    return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = fragCoord;\n    vec2 resolution = iResolution.xy;    \n    \n    float heightScale = 5.0;\n    float hN = ColourAt(center + vec2(0.0, 1.0), resolution).a * heightScale; // North\n    vec3 hC = ColourAt(center, resolution).rgb; // center\n    float hS = ColourAt(center + vec2(0.0, -1.0), resolution).a * heightScale; // South\n    float hE = ColourAt(center + vec2(1.0, 0.0), resolution).a * heightScale; // East\n    float hW = ColourAt(center + vec2(-1.0, 0.0), resolution).a * heightScale; // West\n\n    vec3 average = normalize(vec3((hW - hE), (hN - hS), 2.0));\n    vec3 normal = average;\n    average = average * 0.5 + 0.5;\n    \n    vec3 kLightDir = normalize(vec3(cos(iTime), sin(iTime), 1.0));\n    \n    vec3 diffuse = hC;\n    float NdotL = dot(normal, kLightDir);\n    \n    fragColor = vec4(vec3(1.0, 0.7, 0.5) * NdotL, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat RGBToLuminance(vec3 rgb)\n{\n\treturn 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;\n}\n\nvec3 ColourAt(vec2 coord, vec2 resolution)\n{\n\tvec2 uv = coord / resolution.xy;\n    return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = fragCoord;\n    vec2 resolution = iResolution.xy;\n    \n\tfloat p1 = RGBToLuminance(ColourAt(fragCoord + vec2(-1.0, 1.0), resolution));\n    float p2 = RGBToLuminance(ColourAt(fragCoord + vec2(0.0, 1.0), resolution));\n    float p3 = RGBToLuminance(ColourAt(fragCoord + vec2(1.0, 1.0), resolution));\n    float p4 = RGBToLuminance(ColourAt(fragCoord + vec2(-1.0, 0.0), resolution));\n    float p5 = RGBToLuminance(ColourAt(fragCoord, resolution));\n    float p6 = RGBToLuminance(ColourAt(fragCoord + vec2(1.0, 0.0), resolution));\n    float p7 = RGBToLuminance(ColourAt(fragCoord + vec2(-1.0, -1.0), resolution));\n    float p8 = RGBToLuminance(ColourAt(fragCoord + vec2(0.0, -1.0), resolution));\n    float p9 = RGBToLuminance(ColourAt(fragCoord + vec2(1.0, -1.0), resolution));\n    \n    float GX = (p1 + 2.0 * p2 + p3) - (p7 + 2.0 * p8 + p9);\n    float GY = (p3 + 2.0 * p6 + p9) - (p1 + 2.0 * p4 + p7);\n    \n    float G = sqrt(GX * GX + GY * GY);\n    \n    fragColor = vec4(ColourAt(fragCoord, resolution), G);\n}","name":"Buf A","description":"","type":"buffer"}]}