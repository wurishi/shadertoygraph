{"ver":"0.1","info":{"id":"4fBXRG","date":"1706448246","viewed":204,"name":"Vogel's Method","username":"chronos","description":"Simple demonstration of Vogel's method with brightness scaled by a normal distribution, like a blur kernel, and disc areas scaled to fit area.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["spiral","bokeh","angle","gaussian","discs","kernel","fibonacci","sunflower","vogel","phyllotaxis","spread","golden","layout","ratio","method"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\n    based on\n    http://blog.marmakoide.org/?p=1\n    found via\n    https://www.shadertoy.com/view/4d2Xzw by Dave_Hoskins\n    \n*/\n\nconst float PI     = 3.14159265;\nconst float TWO_PI = 6.283185307; // aka Tau\nconst float PHI = (1. + sqrt(5.))/2.; // Golden ratio\n\nconst float golden_angle = TWO_PI * (1. - 1./PHI);\n//const float golden_angle = PI * (3. - sqrt(5.));\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n//float sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\n//vec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\nfloat normal_distribution(float r)\n{\n    r *= PI;\n    return exp(-(r*r)/2.)/sqrt(2. * PI);\n}\n\nfloat normal_distribution2(float t) // t = r * r\n{\n    t *= PI * PI;\n    return exp(-t/2.)/sqrt(2. * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if (length(iMouse.xy) < 10.) mouse.xy = vec2(cos(iTime), sin(iTime)) + 0.1;\n\n    float ps = 2./ iResolution.y;\n\n    vec3 color = vec3(0);\n\n    \n    float num_samples = 150. * (mouse.y + 1.);\n    float rcp_num_samples = 1./num_samples;\n    \n    \n    // Find disc area. Regardless of derivation,\n    // The area should scale with the reciprocal sqare root of the number of samples.\n    \n    #if 1\n    // A quadrant has area 1\n    //float disc_area = 2. * PI * disc_radius * disc_radius;\n    // num_samples * disc_area = quadrant_area * num_quadrants\n    // (num_samples / 4.) * 2. * PI * disc_radius * disc_radius = 1.\n    // disc_radius = sqrt(1. / ((num_samples / 4.) * 2. * PI));\n    // disc_radius = sqrt(1. / ((num_samples / 2.)  * PI));\n    // disc_radius = sqrt(2. / (num_samples  * PI) );\n    float disc_radius = sqrt(2. / (num_samples * PI));\n    \n    \n    #elif 0\n    // Alternatively: full sample region has area 2 PI (1 + disc_radius)^2\n    // float disc_area = 2. * PI * disc_radius * disc_radius;\n    // num_samples * disc_area = full sample region area\n    // num_samples * 2. * PI * disc_radius^2 = 2 PI (1 + disc_radius)^2\n    // num_samples * disc_radius^2 = (1 + disc_radius)^2\n    // (num_samples-1.) * disc_radius^2 = 1 + 2. * disc_radius\n    // (num_samples-1.) * disc_radius^2  - 2. * disc_radius - 1. = 0.\n    // solve quadratic by wolfram alpha to get:\n    // x = 1/(sqrt(num_samples) - 1) \n    float disc_radius = 1. / (sqrt(num_samples) - 1.);\n    \n    #else\n    // Alternatively 2: full sample region has area 2 PI\n    // float disc_area = 2. * PI * disc_radius^2;\n    // num_samples * disc_area = full sample region area\n    // num_samples * 2. * PI * disc_radius^2 = 2 PI\n    // num_samples * disc_radius^2 = 1\n    // disc_radius = sqrt(1/num_samples)\n    \n    float disc_radius = sqrt(1. / num_samples);\n    #endif\n    \n    for(float i = .5; i < num_samples; i++) // Samples half-integers between 0 and num_samples\n    {\n        float t = i * rcp_num_samples;\n        \n        float r = sqrt(t);\n        float th = golden_angle * i;\n        \n        vec2 pos = r * vec2(cos(th), sin(th));\n        \n        float d = length(pos - uv) - disc_radius;\n        float alpha = smoothstep(ps, -ps, d);\n        color = mix(color, vec3(normal_distribution2(t)), alpha);\n    }\n\n    color = sRGBencode(color); //color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}