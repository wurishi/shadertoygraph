{"ver":"0.1","info":{"id":"4f3fDN","date":"1733096895","viewed":92,"name":"Fermi–Pasta–Ulam problem","username":"prasound","description":"Fermi, Pasta, Ulam, and Tsingou simulated the vibrating string by solving a discrete system of coupled oscillators:\nmx''[s] = (x[s+1] + x[s-1] - 2x[s]) * (1 + alpha*(x[s+1] - x[s-1]))\nIn the limit, it approximates the KdV equation.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["oscillator","fput"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Fermi–Pasta–Ulam–Tsingou problem\n//  Feel free to use in your experiments.\n//\n// Renders the mesh defined by iChannel0 coords.\n\nfloat lineSDF(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nmat2 basis(vec2 c) {\n    return mat2(c.x, c.y, -c.y, c.x);\n}\n\nvec2 i2xy(int i) {\n    float phi = float(i)/float(N)*2.*PI;\n    return vec2(sin(phi), cos(phi));\n}\n\nvec2 pos(int i) {\n    vec2 c = i2xy(i)*R1;\n    return c + basis(c)*texFetch(iChannel0, i).xy;\n}\n\nfloat sdf(vec2 q) {\n    float dist = INF;\n    vec2 b = pos(-1);\n    \n    for (int i = 0; i < N; i++) {\n        vec2 c = pos(i);\n        float d = lineSDF(q, b, c);\n        dist = min(dist, d);\n        b = c;\n    }\n    \n    return dist;\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    vec2 q = p/iResolution.xy*2. - 1.;\n    q *= iResolution.xy/iResolution.yy;\n    \n    float d = sdf(q);\n    o.rgb = pow(R0/d, GLOW) * RGB;\n    o.rgb = pow(o.rgb, vec3(0.4545));\n    o.a = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\nconst float SQ3 = sqrt(3.);\nconst float INF = 1e10;\n\n// Simulation consts\nconst int N = 64;\nconst float DT = 0.5;\nconst float ALPHA = 0.3;\nconst float MASS = 1.0;\n\n// Rendering consts\nconst vec3 RGB = vec3(1.0, 0.05, 0.3);\nconst float GLOW = 1.5;\nconst float R0 = 0.015;\nconst float R1 = 0.75;\nconst float DMAX = 5.0;\n\nvec4 texFetch(sampler2D ch0, int i) {\n    i = int(mod(float(i), float(N)));\n    return texelFetch(ch0, ivec2(i,0), 0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// CC0: Fermi–Pasta–Ulam–Tsingou problem.\n//  Feel free to use in your experiments.\n//\n// Simulates the motion of masses in iChannel0.\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    ivec2 pp = ivec2(p - 0.5);\n\n    if (pp.x > N-1 || pp.y > 1)\n        return;\n     \n    // initial state\n    if (iFrame == 0) {\n        float x = 2.*PI*float(pp.x)/float(N);\n        o = 0.25*cos(x*2.)*vec4(1,-1,0,0);\n        return;\n    }\n     \n    // copy state: string[t-1] <- string[t]\n    if (pp.y > 0) {\n        o = texelFetch(iChannel0, pp-ivec2(0,1), 0);\n        return;\n    }\n    \n    vec4 cc_prev = texelFetch(iChannel0, pp + ivec2(0,1), 0);\n    vec4 cc = texelFetch(iChannel0, pp, 0);\n    vec4 rr = texFetch(iChannel0, pp.x + 1);\n    vec4 ll = texFetch(iChannel0, pp.x - 1);\n    \n    vec4 T = rr + ll - 2.*cc; // Hooke's law\n    T = T + T*ALPHA*(rr - ll); // the non-linear term\n    \n    o = 2.*cc - cc_prev;\n    o += T/MASS * (DT*DT);\n    o = clamp(o,vec4(-DMAX),vec4(DMAX));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}