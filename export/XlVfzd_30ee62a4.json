{"ver":"0.1","info":{"id":"XlVfzd","date":"1543652596","viewed":366,"name":"Cloud Fog of War","username":"esrever2357","description":"Quick n dirty procedurally generated cloud texture, layered to use as  fog of war for a 2D game. Click and drag to \"reveal\" area. The number of layers is variable based on time, to demonstrate how from a single cloud per cell we can create a dense layer.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILE_RES_POT 6\n#define TILE_RES (1 << TILE_RES_POT)\n#define NUM_CLOUD_CIRCLES 16\n#define VISIBLE_RADIUS 1.0\n\nfloat randomf(float p)\n{\n    return fract(52.043*sin(p*205.429));\n}\n\nfloat random(int p)\n{\n    return randomf(float(p));\n}\n\nfloat circle(vec2 uv, vec2 c, float r)\n{\n    vec2 d = uv-c;\n    //d.y *= 1.0 + 0.5*abs(c.x-0.5); // pancake them the further from c.x==0.5 they are\n    float val = 1.0 - step(r*r, dot(d,d));\n    float rimdistance = 1.0 - 0.5*smoothstep(r*r*0.01, r*r, dot(d,d));\n    val = val * rimdistance;\n    //vec2 dir = vec2(random(int(uv.x*100.0)), random(int(uv.y*100.0)))*vec2(2.0) - vec2(1.0);\n    vec2 dir = vec2(0.0,1.0);\n    //return max( val * smoothstep( -1.0, 0.0, dot(normalize(vec2(c.x,uv.y)-c), dir)), 0.0);\n    return val * (r*0.85 + uv.y-c.y)/r;\n}\n\n// return cloud intensity in [0,1]^2 space\nfloat cloud( vec2 uv, int seed )\n{\n    float vmax = 0.0;\n    for(int i=0; i < NUM_CLOUD_CIRCLES; ++i)\n    {\n        vec2 coff = 0.25 + 0.5*vec2( random(seed*123 + i), random(seed*234 + i));\n        coff.y = (coff.y-0.5)*(1.0 - coff.x) + 0.5; // allow greater y expansion at the center\n        coff.y += 0.025*sin(0.975*iTime + 10.0*random(seed + 1));\n        float radius = 0.1 + 0.05*random(seed*345 + i);\n        float val = circle(uv, coff,radius) * ( 0.9 + 0.1*random(seed*113+i));\n        vmax= max(vmax,val);\n    }\n    return vmax;\n}\n\nfloat cloud_layer(vec2 uv, ivec2 tileId, int layer_index)\n{\n    return cloud(uv, tileId.x + 1 + tileId.y * 1024 + layer_index);\n}\n\nfloat tile_cloud_opacity( vec2 c0, vec2 c1)\n{\n    float nd = length(c1-c0)/(float(TILE_RES)*sqrt(2.0));\n    nd /= VISIBLE_RADIUS;\n    \n    nd = smoothstep(0.5,1.0,nd);\n    return min(nd,1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cloudsum = 0.0;\n    \n    ivec2 mouseTile = ivec2(iMouse.xy) >> TILE_RES_POT;\n    ivec2 tileIdBase = ivec2(gl_FragCoord.xy) >> TILE_RES_POT;\n    \n    int NUM_CLOUD_LAYERS = 1 + int(iTime)%12;\n    \n    for(int layer_index=0;layer_index<NUM_CLOUD_LAYERS;++layer_index)\n    {\n        vec2 coord = gl_FragCoord.xy + vec2(TILE_RES)*vec2( random(layer_index*123+1), random(layer_index*234+1));\n        ivec2 tileId = ivec2(coord.xy) >> TILE_RES_POT;\n\t\tvec2 uv = fract(coord.xy / vec2(TILE_RES));\n        \n        float intensity = cloud_layer(uv, tileId, layer_index);\n        intensity *= tile_cloud_opacity(gl_FragCoord.xy, iMouse.xy);\n        \n        // blend\n        cloudsum = mix( cloudsum, intensity, intensity);\n    }\n    \n    vec2 borderDiff = abs((gl_FragCoord.xy / float(TILE_RES)) - vec2(tileIdBase));\n    vec2 onBorder2 = vec2(1.0) - smoothstep(vec2(0.0),vec2(0.1), borderDiff);\n    float onBorder = max(onBorder2.x,onBorder2.y);\n    \n    \n    fragColor = vec4(onBorder,0.3,1.0,0.0);\n    fragColor.xyz = mix(fragColor.xyz, vec3(cloudsum), cloudsum );\n}","name":"Image","description":"","type":"image"}]}