{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI = 3.1415926;\n\nvec2 rotate( vec2 v, float theta )\n{\n\treturn vec2(v.x*cos(theta) - v.y*sin(theta), v.x*sin(theta) + v.y*cos(theta));\n}\n\n// Compute magnetic dipole field value (a vector) at field location samplePt\n// for a dipole located at dipolePt, with moment dipoleMoment.\n// this is a 2d implementation but it would be the same for 3d with vec3s.\n// http://en.wikipedia.org/wiki/Magnetic_field\n// http://en.wikipedia.org/wiki/Dipole#Field_of_a_static_magnetic_dipole\n\nvec2 evalDipoleField( vec2 samplePt, vec2 dipolePt, vec2 dipoleMoment )\n{\n\tconst float mu_0 = 0.0000012566371; // permeability of free space: http://en.wikipedia.org/wiki/Magnetic_constant\n\tvec2 mm = dipoleMoment; // vector dipole moment\n\t\n\t// rr: vector from position of dipole to position of interest\n\tvec2 rr = samplePt - dipolePt;\n  \n  \t// r: is the absolute value of rr: the distance from the dipole\n\tfloat r = length(rr);\n  \n\t// r_hat: rr/r the unit vector parallel to rr\n\tvec2 r_hat = rr / r;\n  \n  \t// B: computed field value\n  \tvec2 B = (mu_0/(4.0*PI*r*r*r)) * ( (3.0*dot(mm,r_hat)*r_hat) - mm );\n\n\treturn B; \n}\n\nvec2 evalField(vec2 samplePt)\n{\n\tvec2 dipolePt = iResolution.xy / 2.0;\n\tvec2 dipoleMoment = vec2(0.0, 1.0);\n\t\n\tvec2 fieldValue = evalDipoleField( samplePt, dipolePt, dipoleMoment );\n\t\n\tvec2 secondDipolePt = dipolePt + rotate(vec2(200,0),iTime);\n\t// click and drag to move the second dipole\n\tif( iMouse.x != 0.0 ){\n\t\tsecondDipolePt.xy = iMouse.xy;\n\t}\n\t\n\t// add a second dipole (offset and rotated by 90 degrees)\n\tfieldValue += evalDipoleField( samplePt, secondDipolePt, rotate(dipoleMoment,PI*0.5) );\n\t\n\treturn fieldValue;\n}\n\nfloat computeIsoWarpedStrength( vec2 v )\n{\n\t//return pow(length(v), 1.0/3.0) * 5.0;\n\t\n\treturn length(v) * 2.0;\n}\n\nfloat isolineIntensity( vec2 samplePt )\n{\n\t// (apply * 1000...0.0 scaling factor for rendering)\n\tvec2 v = evalField(samplePt) * 10000000000000.0;\n\tvec2 v_xl = evalField(samplePt+vec2(-1.0,0.0)) * 10000000000000.0;\n\tvec2 v_ya = evalField(samplePt+vec2(0.0,-1.0)) * 10000000000000.0;\n\tvec2 v_xr = evalField(samplePt+vec2(1.0,0.0)) * 10000000000000.0;\n\tvec2 v_yb = evalField(samplePt+vec2(0.0,1.0)) * 10000000000000.0;\n\t\n\tfloat warpedStrength = computeIsoWarpedStrength(v);\n\tfloat warpedStrength_xl = computeIsoWarpedStrength(v_xl);\n\tfloat warpedStrength_ya = computeIsoWarpedStrength(v_ya);\n\tfloat warpedStrength_xr = computeIsoWarpedStrength(v_xr);\n\tfloat warpedStrength_yb = computeIsoWarpedStrength(v_yb);\n\t\n\t// distance of current pos value from 0.5 isoline crossing\n\t// mod 1 so that we can generate isolines for each crossing of 0.5\t\n\tfloat d = abs(mod(warpedStrength,1.0)-0.5);\n\t\n\t// factors for normalization to local gradient. this gives us a 1px wide line\n\tfloat rx = abs(warpedStrength_xr - warpedStrength_xl) * 0.5;\n\tfloat ry = abs(warpedStrength_yb - warpedStrength_ya) * 0.5;\n\t\n\t// the min(..) term is our isolines \n\t// the +max(..) term fades out the lines if they are too close together\n\treturn clamp( min( d / rx, d / ry ) + max(rx, ry), 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat t = iTime * .5;\n\t\n\tfloat spacing = 10.0;\n\t\n\t// samplePt is the point of interest.\n\tvec2 samplePt = fragCoord.xy;\n\t\n\tfloat isolines = isolineIntensity(samplePt);\n\t\n\tfragColor = vec4(1.0,1.0,1.0,1.0) * isolines;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls23WR","date":"1386436378","viewed":862,"name":"Antialiased isolines","username":"RossBencina","description":"1px isolines for field strength of two dipoles.\nClick and drag to move the second dipole.\n","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["isolines","dipole"],"hasliked":0,"parentid":"","parentname":""}}