{"ver":"0.1","info":{"id":"wlByz1","date":"1593705887","viewed":867,"name":"Diffuse Product Warp Example","username":"dahart","description":"Play with SAMPLING_STRATEGY and \"lrad\"\nMost basic example from \"Practical Product Sampling by Fitting and Composing Warps\" ESGR 2020\nOnly demonstrates diffuse BRDF cos weighted approximation.\nCompile errors? https://get.webgl.org/webgl2/enable.html","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["warp","sampling","diffuse","cosine","product","composing","egsr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n// This code demonstrates one example from the EGSR 2020 paper\n// \"Practical Product Sampling by Fitting and Composing Warps\"\n// Included are several other sampling techniques for comparison and validation.\n// The WARP_ANGLE sampling strategy corresponds to section 4.1 of the paper.\n//\n// For any users experiencing compiler errors or not able to use WebGL2,\n// an alternative WebGL1 compatible version of this shader is posted here:\n// https://www.shadertoy.com/view/wljyDz\n//\n// Additional resources:\n// https://diglib.eg.org/bitstream/handle/10.1111/cgf14060/v39i4pp149-158.pdf\n// https://youtu.be/ZvgpbP0DyHs?t=3183\n// https://casual-effects.com/research/Hart2020Sampling/index.html\n// https://tom94.net/data/publications/hart20practical\n// https://github.com/mmp/pbrt-v3/tree/warp-product-sampling\n// \n\n//----------------------------------------------------------------------\n// CONTROLS\n\nconst int NS = 1; // number of samples per pixel\n\nconst float lrad = .3; // size of the light\n\n// sampling strategies, in order of decreasing noise\n#define HEMI_UNIFORM            0  // uniform hemisphere samples (just for validation)\n#define HEMI_COS                1  // cosine pdf hemisphere samples (just for validation)\n#define AREA                    2  // uniform area samples on quad light (common practice)\n#define MIS_HEMICOS_AREA        3  // multiple importance sampling: cosine + area\n#define WARP_AREA               4  // One bilinear warp of lighting + uniform area sampling (1st try, slightly better than area, but not great)\n#define MIS_HEMICOS_ANGLE       5  // multiple importance sampling: cosine + area\n#define ANGLE                   6  // uniform solid angle sampling (state of the art)\n#define WARP_ANGLE              7  // Two warps: bilinear cosine composed with uniform solid angle (2nd try, better than solid angle)\n#define ANALYTIC                8  // analytic irradiance (just for fun; the shadows are incorrect)\n\n// which sampler to use\n#define SAMPLING_STRATEGY 7 // use name or number\n\n#define NONLINEAR_PROJECTION 0 // 0==linear perspective 1=spherical camera 2=pannini projection\n\nconst float hfov = 70.;\nconst float dist = .7;\n\nconst float brightFactor = 1.;\nconst float gamma = 1.8;\n\nconst float pixelation = 3.; // render in NxN pixel blocks where N=pixelation. easier to see noise.\n\nconst float mouseFactor = .8;\n\n//----------------------------------------------------------------------\n\nconst float pi = 3.1415927;\nconst float maxfloat = 9e9;\nconst float default_tmin = 1e-5;\nconst float default_tmax = maxfloat;\n\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\nfloat sqr(float x) { return x * x; }\n\nvec3 random_in_unit_sphere(vec3 uvw) {\n    uvw = uvw * vec3(2., 2.*pi, 1.) - vec3(1., 0., 0.);\n\treturn pow(uvw.z, 1./3.) * vec3(sqrt(1. - uvw.x*uvw.x)*vec2(cos(uvw.y),sin(uvw.y)),uvw.x);\n}\n\n//----------------------------------------------------------------------\n\n// NB my scene & camera coordinate system is left handed\n\n\nstruct Ray { vec3 o; vec3 d; };\nvec3 Ray_at_t(Ray r, float t) { return r.o + t * r.d; }\n\nstruct Hitrec { float t; vec3 p; vec3 n; vec2 uv; int objId; };\n\n#if 0 // cornell box scene\nconst vec3 lc = vec3(.5, 1., .5); // light center\nconst vec3 lpn = vec3(0.0, -1., 0.); // light normal\nconst vec3 lpu = cross(lpn, -Z);\nconst vec3 lpv = cross(lpn, lpu);\nconst vec3 lp00 = lc - lpu*lrad - lpv*lrad;\nconst vec3 lp20 = lc + lpu*lrad - lpv*lrad;\nconst vec3 lp02 = lc - lpu*lrad + lpv*lrad;\nconst vec3 lp22 = lc + lpu*lrad + lpv*lrad;\n\n// occluder\nconst vec3 occa = vec3(.4, .1, .4);\nconst vec3 occbdir = vec3(.3, .1, .3);\nconst vec3 occcdir = vec3(-.4, .3, .2);\nconst vec3 occn = normalize(cross(occbdir, occcdir));\n\nconst int nQuads = 6;\nstruct Quad { vec3 p; vec3 n; vec3 u; vec3 v; };\nconst Quad[nQuads] quads = Quad[nQuads](\n     Quad(lp00                      , /* n */              lpn, lp20-lp00, lp02-lp00) // ceiling\n    ,Quad(vec3( /* p */  0,  0, 0), /* n */ vec3( 0,  1,  0), 1.*X, 1.*Z) // floor\n    ,Quad(vec3( /* p */  0,  0, 1), /* n */ vec3( 0,  0, -1), 1.*X, 1.*Y) // back wall\n    ,Quad(vec3( /* p */  0,  0, 0), /* n */ vec3(-1,  0,  0), 1.*Y, 1.*Z) // left wall\n    ,Quad(vec3( /* p */  1,  0, 0), /* n */ vec3( 1,  0,  0), 1.*Y, 1.*Z) // right wall\n    ,Quad(occa, occn, occbdir, occcdir) // occluder\n);\n\nconst int nSpheres = 1;\nstruct Sphere { vec3 p; float r; };\nconst Sphere[nSpheres] spheres = Sphere[nSpheres](\n    Sphere(vec3(.5, 1., .5), .1)\n);\n\nconst int GEOM_QUAD   = 0;\nconst int GEOM_SPHERE = 1;\n\nconst int MAT_LAMBERT = 0;\nconst int MAT_LIGHT   = 1;\n\n// world\nconst int nObj = 6;\nstruct Obj { int geomType; int geomId; int matType; int matId; };\nconst Obj[nObj] world = Obj[nObj](\n    //Obj(GEOM_SPHERE, 0, MAT_LIGHT  , 0) // ceiling light sphere\n    Obj(GEOM_QUAD, 0, MAT_LIGHT  , 0)     // ceiling light quad\n    ,Obj(GEOM_QUAD, 1, MAT_LAMBERT, 0)    // floor\n    ,Obj(GEOM_QUAD, 2, MAT_LAMBERT, 0)    // back wall\n    ,Obj(GEOM_QUAD, 3, MAT_LAMBERT, 2)    // left wall\n    ,Obj(GEOM_QUAD, 4, MAT_LAMBERT, 1)    // right wall\n    ,Obj(GEOM_QUAD, 5, MAT_LAMBERT, 3)    // occluder\n);\n\n#else // b&w light & floor scene\n\nconst vec3 lc = vec3(0., /*.4+*/ .2+lrad, .5); // light center -- used .4+lrad for y w/ lrad==0.05\nconst vec3 lpn = normalize(vec3(1., 0, 0.));   // light normal\nconst vec3 lpu = cross(lpn, -Z);\nconst vec3 lpv = cross(lpn, lpu);\nconst vec3 lp00 = lc - lpu*lrad - lpv*lrad;\nconst vec3 lp20 = lc + lpu*lrad - lpv*lrad;\nconst vec3 lp02 = lc - lpu*lrad + lpv*lrad;\nconst vec3 lp22 = lc + lpu*lrad + lpv*lrad;\n\n// occluder\nconst vec3 occa = vec3(.4, .1, .4);\nconst vec3 occbdir = vec3(.3, .1, .3);\nconst vec3 occcdir = vec3(-.4, .3, .2);\nconst vec3 occn = normalize(cross(occbdir, occcdir));\n\nconst int nQuads = 6;\nstruct Quad { vec3 p; vec3 n; vec3 u; vec3 v; };\nconst Quad[nQuads] quads = Quad[nQuads](\n     Quad(lp00                      , /* n */              lpn, lp20-lp00, lp02-lp00) // ceiling\n    ,Quad(vec3( /* p */  0,  0, 0), /* n */ vec3( 0,  1,  0), 1.*X, 1.*Z) // floor\n    ,Quad(vec3( /* p */  0,  0, 1), /* n */ vec3( 0,  0, -1), 1.*X, 1.*Y) // back wall\n    ,Quad(vec3( /* p */  0,  0, 0), /* n */ vec3(-1,  0,  0), 1.*Y, 1.*Z) // left wall\n    ,Quad(vec3( /* p */  1,  0, 0), /* n */ vec3( 1,  0,  0), 1.*Y, 1.*Z) // right wall\n    ,Quad(occa, occn, occbdir, occcdir) // occluder\n);\n\nconst int nSpheres = 1;\nstruct Sphere { vec3 p; float r; };\nconst Sphere[nSpheres] spheres = Sphere[nSpheres](\n    Sphere(vec3(.5, 1., .5), .1)\n);\n\nconst int GEOM_QUAD   = 0;\nconst int GEOM_SPHERE = 1;\n\nconst int MAT_LAMBERT = 0;\nconst int MAT_LIGHT   = 1;\n\n// world (commented Cornell Box w/ occluder)\nconst int nObj = 2;\nstruct Obj { int geomType; int geomId; int matType; int matId; };\nconst Obj[nObj] world = Obj[nObj](\n    //Obj(GEOM_SPHERE, 0, MAT_LIGHT  , 0) // ceiling light sphere\n    Obj(GEOM_QUAD, 0, MAT_LIGHT  , 0) // ceiling light quad\n    ,Obj(GEOM_QUAD, 1, MAT_LAMBERT, 0) // floor\n    //,Obj(GEOM_QUAD, 2, MAT_LAMBERT, 0) // back wall\n    //,Obj(GEOM_QUAD, 3, MAT_LAMBERT, 2) // left wall\n    //,Obj(GEOM_QUAD, 4, MAT_LAMBERT, 1) // right wall\n    //,Obj(GEOM_QUAD, 5, MAT_LAMBERT, 3) // occluder\n);\n#endif\n\nstruct Lambert { vec3 albedo; };\nconst int nLambert = 4;\nconst Lambert[nLambert] lambertMats = Lambert[nLambert](\n     Lambert(vec3(.8))\n    ,Lambert(vec3(.2, .7, .2))\n    ,Lambert(vec3(.7, .2, .2))\n    ,Lambert(vec3(.2, .2, .8))\n);\n\n\nconst float lightbright = .25 * brightFactor;\n\nconst int nLightMats = 1;\nstruct LightMat { vec3 color; };\nconst LightMat[nLightMats] lightMats = LightMat[nLightMats](\n     LightMat(vec3(lightbright/lrad/lrad))\n);\n\n\n#if SAMPLING_STRATEGY == ANGLE || SAMPLING_STRATEGY == WARP_ANGLE || SAMPLING_STRATEGY == MIS_HEMICOS_ANGLE\n\n// code is from 'An area preserving parameterization of spherical rectangles'\n// Urena et. al, EGSR 2013\n\nstruct SphQuad {\n    vec3 o, x, y, z;       // local reference system 'R'\n    float z0, z0sq;        //\n    float x0, y0, y0sq;    // rectangle coords in 'R'\n    float x1, y1, y1sq;    //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S;               // solid angle of 'Q'\n};\n\nvoid SphQuadInit(inout SphQuad squad, vec3 s, vec3 ex, vec3 ey, vec3 o) {\n    squad.o = o;\n    float exl = length(ex);\n    float eyl = length(ey);\n\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n        squad.z *= -1.;\n        squad.z0 *= -1.;\n    }\n\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0,n1));\n    float g1 = acos(-dot(n1,n2));\n    float g2 = acos(-dot(n2,n3));\n    float g3 = acos(-dot(n3,n0));\n\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.*pi - g2 - g3;\n\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nconst float eps = 1e-4;\nvec3 SphQuadSample(SphQuad squad, float u, float v) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n\n    float cu = 1./sqrt(fu*fu + squad.b0sq) * sign(fu);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n\n    // 3. compute ’yv’\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0);\n    float hv2 = hv*hv;\n    float yv = (hv2 < 1.-eps) ? (hv*d)/sqrt(1.-hv2) : squad.y1;\n\n    // 4. transform (xu,yv,z0) to world coords\n    return (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n}\n\n#endif // SAMPLING_STRATEGY == ANGLE || SAMPLING_STRATEGY == WARP_ANGLE\n\n\n#if SAMPLING_STRATEGY == WARP_AREA || SAMPLING_STRATEGY == WARP_ANGLE\n\n//# return a real root between 0 and 1\nfloat solve_quadratic(float A, float B, float C) { //: #Bx + C = 0 so x = -C/B\n    if (abs(A) < 0.0001) return -C/B;\n    float rad = B*B - 4.*A*C;\n    if (rad < 0.) return 0.;\n    rad = sqrt(rad);\n    float tmp =  (-B - rad) / (2.*A);\n    if (tmp < 0. || tmp > 1.) tmp = (-B + rad) / (2.*A); //# use the other root\n    return tmp;\n}\n\n// These functions correspond to the bilinear row of table 3 in the paper\n// https://diglib.eg.org/bitstream/handle/10.1111/cgf14060/v39i4pp149-158.pdf\nfloat fu(float r, float W00, float W01, float W10, float W11) {\n    float A = W10 + W11 - W01 - W00;\n    float B = 2.*(W01+W00);\n    float C = -(W00 + W01 + W10 + W11)*r;\n    return solve_quadratic(A,B,C);\n}\n\nfloat v(float r, float u, float W00, float W01, float W10, float W11) {\n    float A = (1.-u)*W01 + u*W11 - (1.-u)*W00 - u*W10;\n    float B = 2.*(1.-u)*W00+2.*u*W10;\n    float C = -((1.-u)*W01 + u*W11 + (1.-u)*W00 + u*W10)*r;\n    return solve_quadratic(A,B,C);\n}\n\n//*\n// returns warped uv, plus the pdf in the 3rd component\nvec3 sampleQuad(vec2 uv, float W00, float W01, float W10, float W11) {\n    float uu = fu(uv.x, W00, W01, W10, W11);\n    float vv = v(uv.y, uu,  W00, W01, W10, W11);\n    float u = uu;//uv.x;\n    float v = vv;//uv.y;\n    float pdf = 4. * (\n        (1.-u)*(1.-v)*W00\n        + u*(1.-v)*W10\n        + u*v*W11\n        + (1.-u)*v*W01) / (W00 + W01 + W10 + W11);\n    return vec3(uu, vv, pdf);\n}\n//*/\n\nfloat sampleLinear(float u, float a, float b) {\n    return (sqrt(mix(a*a, b*b, u)) - a) / (b - a);\n}\n\n/*\n// returns warped uv, plus the pdf in the 3rd component\nvec3 sampleQuad(vec2 uv, float W00, float W01, float W10, float W11) {\n    float a = mix(W00, W01, .5);\n    float b = mix(W10, W11, .5);\n    float u = sampleLinear(uv.x, a, b);\n    float c = mix(W00, W10, u);\n    float d = mix(W01, W11, u);\n    float v = sampleLinear(uv.y, c, d);\n    float area = mix(a, b, .5);\n    float pdf = mix(c, d, v) / area;\n    return vec3(u, v, pdf);\n}\n//*/\n\n#endif // SAMPLING_STRATEGY == WARP_AREA || SAMPLING_STRATEGY == WARP_ANGLE\n\n\n\nstruct Camera {\n    vec3 origin;\n    vec3 u, v, w;\n    float hfov;\n    float aspect;\n};\n\nCamera Camera_make(vec3 lookfrom, vec3 lookat,\n                   vec3 vup, float hfovDeg,\n                   float aspect)\n{\n    Camera cam;\n    cam.aspect = aspect;\n    cam.hfov = radians(hfovDeg);\n    float half_width  = tan(cam.hfov / 2.);\n    float half_height = half_width / aspect;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookat - lookfrom);\n#if NONLINEAR_PROJECTION == 0\n    cam.u = half_width  * normalize(cross(vup  , cam.w));\n    cam.v = half_height * normalize(cross(cam.w, cam.u));\n#endif\n#if NONLINEAR_PROJECTION == 1 || NONLINEAR_PROJECTION == 2\n    cam.u = normalize(cross(vup  , cam.w));\n    cam.v = normalize(cross(cam.w, cam.u));\n#endif\n    return cam;\n}\n\nvec3 slerp(vec3 p0, vec3 p1, float t) {\n    float a = acos(dot(p0, p1));\n    return (sin((1. - t)*a) * p0 + sin(t*a) * p1) / sin(a);\n}\n\nRay Camera_getRay(Camera cam, vec2 uv) {\n#if NONLINEAR_PROJECTION == 0\n    // perspective projection\n    uv = 2. * uv - 1.;\n    return Ray(cam.origin, normalize(cam.w + uv.x * cam.u + uv.y * cam.v));\n#endif // NONLINEAR_PROJECTION\n\n#if NONLINEAR_PROJECTION == 1\n    // non-linear cam\n    uv = (uv - .5) * cam.hfov * vec2(1., 1./cam.aspect);\n    vec2 xy = tan(uv) / cos(uv.yx);\n    //xy.y /= cos(uv.x); xy.x /= cos(uv.y);\n    return Ray(cam.origin, xy.x * cam.u + xy.y * cam.v + cam.w);\n#endif // NONLINEAR_PROJECTION\n\n#if NONLINEAR_PROJECTION == 2\n    uv = (uv - .5) * cam.hfov * vec2(1., 1./cam.aspect);\n    vec2 xy = vec2(tan(uv.x), uv.y);\n    xy.y /= cos(uv.x);\n    return Ray(cam.origin, xy.x * cam.u + xy.y * cam.v + cam.w);\n#endif\n\n}\n\n\nbool hit_sphere(int objId, Ray ray, float tmin, float tmax, bool padHit, out Hitrec rec) {\n    Sphere s = spheres[world[objId].geomId];\n    vec3 pos = s.p;\n    float rad = padHit ? s.r * 1.01 : s.r;\n    vec3 oc = ray.o - pos;\n    float a = dot(ray.d, ray.d);\n    float b = /* 2. * */ dot(oc, ray.d);\n    float c = dot(oc, oc) - sqr(rad);\n    float discrim = sqr(b) - /* 4.* */ a*c;\n    if (discrim > 0.) {\n        float sd = sqrt(discrim);\n        float temp = (-b - sd) / a;\n        if (temp < tmax && temp > tmin) {\n            vec3 p = Ray_at_t(ray, temp);\n            rec = Hitrec(temp, p, (p - pos) / rad, vec2(0.), -1);\n            return true;\n        }\n        temp = (-b + sd) / a;\n        if (temp < tmax && temp > tmin) {\n            vec3 p = Ray_at_t(ray, temp);\n            rec = Hitrec(temp, p, (p - pos) / rad, vec2(0.), -1);\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nbool hit_plane(int objId, Ray ray, float tmin, float tmax, bool padHit, out Hitrec rec) {\n    Quad plane = quads[world[objId].geomId];\n    vec3 pro = ray.o - plane.p;\n\n    float nrd = -dot(ray.d, plane.n);\n    float t = dot(pro, plane.n) / nrd;\n\n    if (t < tmin || t > tmax) return false;\n    \n    vec3 hitpoint = ray.o + t * ray.d;\n    vec3 hpdir = hitpoint - plane.p;\n\n    float minU = padHit ? -.1 : 0.;\n    float maxU = padHit ? 1.1 : 1.;\n\n    float u = dot(plane.u, hpdir) / dot(plane.u, plane.u);\n    if (u < minU || u > maxU) return false;\n    float v = dot(plane.v, hpdir) / dot(plane.v, plane.v);\n    if (v < minU || v > maxU) return false;\n\n    vec3 p = Ray_at_t(ray, t);\n    //vec3 p = plane.p + u * plane.u + v * plane.v;\n    rec = Hitrec(t, p,\n                 (nrd < 0.) ? -plane.n : plane.n, /* normal always faces the ray (two sided planes) */\n                 vec2(u, v),\n                 objId);\n    return true;\n}\n\n\nbool trace(Ray ray, float tmin, float tmax, bool padLights, out Hitrec rec) {\n    bool hit_anything = false;\n    Hitrec temp_rec;\n\n    for (int i = 0; i < nObj; i++) {\n        Obj o = world[i];\n        bool isHit;\n        switch (o.geomType) {\n            case GEOM_SPHERE: isHit = hit_sphere(i, ray, tmin, tmax, padLights && i == 0, temp_rec); break;\n            case GEOM_QUAD  : isHit = hit_plane(i, ray, tmin, tmax, padLights && i == 0, temp_rec); break;\n        }\n        \n        if (isHit) {\n            hit_anything = true;\n            rec = temp_rec;\n            tmax = rec.t;\n            Obj obj = world[rec.objId];\n        }\n    }\n\n    return hit_anything;\n}\n\n\nvec3 Lambert_direct(int lightId, Lambert mat, Ray r_in, Hitrec rec, vec3 rand3) \n{\n    Obj light = world[lightId];\n    LightMat lmat = lightMats[light.matId];\n    Hitrec shadowRec;\n\n    \n#if SAMPLING_STRATEGY == HEMI_UNIFORM\n\n    vec3 dir = normalize(random_in_unit_sphere(rand3));\n    vec3 dirnorm = dir;\n    float ndotdir = dot(dirnorm, rec.n);\n    if (ndotdir < 0.) {\n        dir = -dir;\n        dirnorm = -dirnorm;\n    }\n    float pdf = 1. / (2. * pi);\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, false, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n\n#elif SAMPLING_STRATEGY == HEMI_COS\n\n    vec3 dir = normalize(rec.n + normalize(random_in_unit_sphere(rand3)));\n    vec3 dirnorm = dir;\n    float pdf = dot(rec.n, dirnorm) / pi;\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, false, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n\n#elif SAMPLING_STRATEGY == AREA\n\n    Quad o = quads[light.geomId];\n    vec2 uv = rand3.xy;\n\n    vec3 target = o.p + o.u * uv.x + o.v * uv.y ;\n\n    vec3 dir = target - rec.p;\n    vec3 dirnorm = normalize(dir);\n    float pdf = dot(dir, dir) / (   // falloff 1/r^2\n        dot(o.n, -dirnorm) *        // cosine of light soure\n        length(cross(o.u, o.v))     // area of light source\n    );\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, false, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n    \n#elif SAMPLING_STRATEGY == MIS_HEMICOS_AREA\n    \n    Quad o = quads[light.geomId];\n    vec2 uv = rand3.xy;\n\n    // Light area estimator\n    vec3 target = o.p + o.u * uv.x + o.v * uv.y ;\n    vec3 dir1 = target - rec.p;\n    vec3 dirnorm1 = normalize(dir1);\n    float pdf1 = dot(dir1, dir1) / (    // falloff 1/r^2\n        dot(o.n, -dirnorm1) *           // cosine of light soure\n        length(cross(o.u, o.v))         // area of light source\n    );\n    // trace shadow ray\n    bool hit1 = trace(Ray(rec.p, dirnorm1), default_tmin, default_tmax, false, shadowRec);\n    bool lit1 = hit1 && shadowRec.objId == lightId;\n    float X1 = dot(rec.n, dirnorm1) / pdf1;\n\n    \n    // diffuse BRDF estimator\n    vec3 dir2 = normalize(rec.n + normalize(random_in_unit_sphere(rand3)));\n    vec3 dirnorm2 = dir2;\n    float pdf2 = dot(rec.n, dirnorm2) / pi;\n    // trace shadow ray\n    bool hit2 = trace(Ray(rec.p, dirnorm2), default_tmin, default_tmax, false, shadowRec);\n    bool lit2 = hit2 && shadowRec.objId == lightId;\n    float X2 = dot(rec.n, dirnorm2) / pdf2;\n\n    \n    float pdf2d1 = dot(rec.n, dirnorm1) / pi;\n    \n    if (lit2) dir2 = shadowRec.p - rec.p;\n    float pdf1d2 = dot(dir2, dir2) / (       // falloff 1/r^2\n        dot(o.n, -dirnorm2) *                // cosine of light soure\n        length(cross(o.u, o.v))              // area of light source\n    );\n\n    float w1 = float(lit1) * pdf1 / (pdf1 + pdf2d1);\n    float w2 = float(lit2) * pdf2 / (pdf1d2 + pdf2);\n    \n    float X = w1*X1 + w2*X2;\n    \n    return lmat.color * mat.albedo * X; // divide by pi for correct units\n\n    \n#elif SAMPLING_STRATEGY == WARP_AREA\n\n    const int N = 4;\n\n    vec3 wpd[N], wpn[N];\n    float prob[N];\n    Quad o = quads[light.geomId];\n    vec3 wp[4] = vec3[4](o.p, o.p + o.u, o.p + o.v, o.p + o.u + o.v);\n\n    for (int i = 0; i < N; i++) {\n        wpd[i] = wp[i] - rec.p;\n        wpn[i] = normalize(wpd[i]);\n        // 3 lighting terms: both cosines + falloff\n        prob[i] = max(0., dot(wpn[i], rec.n) * dot(wpn[i], -o.n) / dot(wpd[i], wpd[i]));\n    }\n\n    vec3 newuv = sampleQuad(rand3.xy, prob[0], prob[2], prob[1], prob[3]); // note B,C order swap\n\n    vec3 target = o.p\n        + newuv.x * o.u\n        + newuv.y * o.v;\n\n    vec3 dir = target - rec.p;\n    vec3 dirnorm = normalize(dir);\n\n    float pdf = newuv.z                    // importance pdf\n        * dot(dir, dir)                    // falloff 1/r^2\n        / ( dot(o.n, -dirnorm)             // cosine of light soure\n            * length(cross(o.u, o.v))      // area of light source\n    );\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, false, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n\n#elif SAMPLING_STRATEGY == ANGLE\n\n    Quad o = quads[light.geomId];\n    vec3 wp[4] = vec3[4](o.p, o.p + o.u, o.p + o.v, o.p + o.u + o.v);\n\n    // sample from the quad\n    SphQuad squad;\n    SphQuadInit(squad, wp[0]-rec.p, wp[1]-wp[0], wp[2]-wp[0], vec3(0.));//rec.p);\n    vec3 dir = SphQuadSample(squad, rand3.x, rand3.y);\n    vec3 dirnorm = normalize(dir);\n\n    float pdf = 1. / squad.S;  // solid angle area of light source\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, true, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n\n#elif SAMPLING_STRATEGY == MIS_HEMICOS_ANGLE\n    \n    vec2 uv = rand3.xy;\n    Quad o = quads[light.geomId];\n    vec3 wp[4] = vec3[4](o.p, o.p + o.u, o.p + o.v, o.p + o.u + o.v);\n\n    // Light solid angle estimator\n    SphQuad squad;\n    SphQuadInit(squad, wp[0]-rec.p, wp[1]-wp[0], wp[2]-wp[0], vec3(0.));//rec.p);\n    vec3 dir1 = SphQuadSample(squad, rand3.x, rand3.y);\n    vec3 dirnorm1 = normalize(dir1);\n    float pdf1 = 1. / squad.S;  // solid angle area of light source\n    // trace shadow ray\n    bool hit1 = dot(dirnorm1, rec.n) < 0. ? false : trace(Ray(rec.p, dirnorm1), default_tmin, default_tmax, true, shadowRec);\n    bool lit1 = hit1 && shadowRec.objId == lightId;\n    float X1 = dot(rec.n, dirnorm1) / pdf1;\n\n    \n    // diffuse BRDF estimator\n    vec3 dir2 = normalize(rec.n + normalize(random_in_unit_sphere(rand3)));\n    vec3 dirnorm2 = dir2;\n    float pdf2 = dot(rec.n, dirnorm2) / pi;\n    // trace shadow ray\n    Hitrec shadowRec2;\n    bool hit2 = trace(Ray(rec.p, dirnorm2), default_tmin, default_tmax, false, shadowRec2);\n    bool lit2 = hit2 && shadowRec2.objId == lightId;\n    float X2 = dot(rec.n, dirnorm2) / pdf2;\n\n    \n    float pdf2d1 = dot(rec.n, dirnorm1) / pi;\n    float pdf1d2 = pdf1;\n\n    float w1 = float(lit1) * pdf1 / (pdf1 + pdf2d1);\n    float w2 = float(lit2) * pdf2 / (pdf1d2 + pdf2);\n    \n    float X = w1*X1 + w2*X2;\n    \n    return lmat.color * mat.albedo * X; // divide by pi for correct units\n\n    \n#elif SAMPLING_STRATEGY == WARP_ANGLE\n\n    const int N = 4;\n    vec3 wpd[N], wpn[N];\n    float prob[N];\n    Quad o = quads[light.geomId];\n    vec3 wp[4] = vec3[4](o.p, o.p + o.u, o.p + o.v, o.p + o.u + o.v);\n    for (int i = 0; i < N; i++) {\n        wpd[i] = wp[i] - rec.p;\n        wpn[i] = normalize(wpd[i]);\n        // cosine term of ray with illuminated surface\n        prob[i] = max(0., dot(wpn[i], rec.n));\n    }\n\n    vec3 cosWeightedUV = sampleQuad(rand3.xy, prob[0], prob[2], prob[1], prob[3]);\n    // Now push the cosine weighted samples into our solid angle mapping.\n    // sample from the quad\n    SphQuad squad;\n    SphQuadInit(squad, wp[0]-rec.p, wp[1]-wp[0], wp[2]-wp[0], vec3(0.));//rec.p);\n    vec3 dir = SphQuadSample(squad, cosWeightedUV.x, cosWeightedUV.y);\n    float totalarea = squad.S;\n\n    if (dot(dir, rec.n) < 0.) return vec3(0.);\n    \n    vec3 dirnorm = normalize(dir);\n    float pdf = cosWeightedUV.z   // importance pdf\n        / totalarea;              // solid angle area of light source\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dirnorm), default_tmin, default_tmax, true, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = lit ? dot(rec.n, dirnorm) / pdf : 0.;\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n\n#elif SAMPLING_STRATEGY == ANALYTIC\n\n    // Just for fun, compute analytic lighting.\n    // Note the shadows are wrong.\n\n    Quad o = quads[light.geomId];\n    vec3 wp[4] = vec3[4](o.p, o.p + o.u, o.p + o.v, o.p + o.u + o.v);\n    vec2 uv = rand3.xy;\n\n    const int N = 4;\n    vec3[4] lgt = vec3[4](\n        o.p,\n        o.p + o.u,\n        o.p + o.u + o.v,\n        o.p + o.v );\n\n    for (int i = 0; i < N; i++) lgt[i] = normalize(lgt[i] - rec.p);\n\n    vec3 target = o.p + o.u * uv.x + o.v * uv.y ;\n    vec3 dir = target - rec.p;\n\n    float pdf = 0.;\n    for (int i = 0; i < N; i++) {\n        int j = i - 1;\n        if (j == -1) j = N-1;\n        vec3 c = cross(lgt[i], lgt[j]);\n        float cDotn = dot( normalize(c), rec.n );\n        float acosAng = acos( dot( lgt[i], lgt[j] ) );\n        pdf += cDotn * acosAng;\n    }\n    pdf = 2. / pdf;\n    // trace shadow ray\n    bool hit = trace(Ray(rec.p, dir), default_tmin, default_tmax, true, shadowRec);\n    bool lit = hit && shadowRec.objId == lightId;\n    float cosSurfOverPdf = 1. / pdf; // cos surf already accounted for\n    return lmat.color * mat.albedo * cosSurfOverPdf; // divide by pi for correct units\n\n#endif // SAMPLING_STRATEGY\n\n\n}\n\n\nvec3 color(Ray ray, vec2 uv, float time, vec3 rand3) {\n    Hitrec rec;\n\n    if (trace(ray, default_tmin, default_tmax, false, rec)) {\n        Obj o = world[rec.objId];\n        if (o.matType == MAT_LAMBERT) {\n            Lambert mat;\n            mat = lambertMats[o.matId];\n            vec3 result = vec3(0.);\n            for (int i = 0; i < nObj; i++) {\n                if (world[i].matType != MAT_LIGHT) continue;\n                result += Lambert_direct(i, mat, ray, rec, rand3);\n            }\n            return result;\n        } else if (o.matType == MAT_LIGHT) {\n            LightMat mat = lightMats[o.matId];\n            return vec3(1.);\n            return mat.color;\n        }\n    }\n\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    fragCoord = floor(fragCoord / pixelation) * pixelation;\n\n    vec3 m = mouseFactor * vec3(iMouse.xy / iResolution.xy - .5, 0);\n    //m = vec3(-.3, -.3, 0.); // lock camera for generating figures - cornell box\n    m = vec3(0, -.4, -.2); // lock camera for generating figures - light & floor\n    float time = iTime + dot(m, vec3(1.));// / 100.;\n\n    vec3 col = vec3(0.);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 lookfrom = vec3(.5, .5, -dist) - m;\n    vec3 lookat   = vec3(.5, .0, .5);\n    vec3 up       = vec3(0., 1., 0.);\n    float aspect  = iResolution.x / iResolution.y;\n\n    Camera cam = Camera_make(lookfrom, lookat, up, hfov, aspect);\n\n    vec2 randcoord = 2.*uv;\n    int NOUNROLL = min(0,iFrame); // prevent loop unrolling\n    for (int i = 0; i < NS + NOUNROLL; ++i) {\n        randcoord = fract(randcoord + vec2(37.,101.) / 256. - float(iTime)*vec2(32.,17.));\n        vec4 rand4 = texture(iChannel0, randcoord);\n        vec2 suv = (fragCoord + rand4.xy) / iResolution.xy;\n        col += color(Camera_getRay(cam, suv), suv, time, rand4.zyw);\n    }\n    col /= float(NS);\n\n    fragColor = vec4(col, 1.);\n    fragColor = vec4(pow(fragColor.xyz, vec3(1./gamma)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}