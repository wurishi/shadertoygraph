{"ver":"0.1","info":{"id":"sl3cR8","date":"1659215977","viewed":68,"name":"Realt Time RayCast","username":"AlexRusu","description":"Simple Shader to learn about raycasting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat2 rot(float teta) {\n    if(teta <= 0.0){\n        return mat2(1,0,1,0);\n    }\n    \n\tfloat s = sin(teta);\n\tfloat c = cos(teta);\n    \n\treturn mat2(c, -s, s, c);\n}\n\n\n\n\n\n\n\nvec3 castRay(vec3 ro,vec3 rd){\n    vec3 HitCol = vec3(0.6);\n    vec3 lightPos = vec3(0.0,0.0,1.0);\n    vec3 lightColor = vec3(1.0);\n    vec3 objColor = vec3(0.2,1.0,1.0);\n    vec2 it;\n\n\n    vec3 sPos = vec3(0.0,0.0,0.0);\n    \n\n    it = sphIntersect(ro ,rd,sPos,1.0);\n    if(it.x > 0.0){ \n        vec3 norm = NormalOnSfere(ro,rd,sPos,it);\n        HitCol = Light(norm,lightPos,lightColor,rd)* objColor;\n    }\n    \n    \n    \n    return HitCol;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rayOrigin =  vec3(0.0, 0.0, 0.0);\n    vec3 rayDirection =  normalize(vec3((fragCoord * 2.0 - iResolution.xy)/ iResolution.yy , -1.75));\n    \n    \n    //move circle\n    const float radius = 5.0f;\n    float camX = sin(iTime) * radius;\n    float camZ = cos(iTime) * radius;\n   \n   rayOrigin.x += camX;\n   rayOrigin.z += camZ;\n\n\n   \n   \n   \n  \n   \n   \n   \n   \n   \n   \n   vec4 lastpos;\n   \n   vec4 mpos = iMouse;\n   \n   \n   vec2 delta = iMouse.xy - lastpos.xy;\n   \n   lastpos.xy = iMouse.xy;\n  \n\n   mat3 matY = rotationY(toRad(delta.x));\n   mat3 matX = rotationX(toRad(delta.x));\n   rayDirection = rayDirection * matY;\n   \n   vec3 col = castRay(-rayOrigin,rayDirection);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 sphIntersect(vec3 ro, vec3 rd,vec3 ce, float ra )\n{\n    vec3 v = ro - ce;\n    float a = dot(rd,rd);\n    float b = 2.0 * dot(v , rd);\n    float c = dot(v,v) - ra*ra;\n\n    float delta = (b*b) - 4.0*a*c;\n    if(delta<0.0){ \n        return vec2(-1.0);\n    }\n    else{\n        return vec2((-b + sqrt(delta))/(2.0*a)   ,   (-b - sqrt(delta))/(2.0*a));\n    }\n}\nvec3 NormalOnSfere(vec3 ro,vec3 rd, vec3 centre,vec2 hitPos){\n    vec3 sfHitPosition = ro - rd * hitPos.x;\n    vec3 n = sfHitPosition - centre;\n    \n    return normalize(n);\n}\n\nvec3 Light(vec3 norm,vec3 lightPos ,vec3 lightColor ,vec3 rd ){\n\n     float ambientStrength = 0.01;\n    vec3 ambient = ambientStrength * lightColor;\n\n    //difuse\n    float diff = max(dot(norm,lightPos),0.0);\n    vec3 diffuse = diff * lightColor;\n\n    //specular\n    vec3 reflected = reflect(norm,rd);\n    float spec = max(dot(rd,reflected),0.0);\n    vec3 specular = spec * lightColor;\n\n\n    vec3 result = ( ambient+ diffuse);\n    return result;\n\n}\n\n\nmat3 rotationZ(float r )\n{\n    mat3 mat;\n    mat[0].x = cos(r);  mat[0].y = sin(r);  mat[0].z = 0.0;\n    mat[1].x = -sin(r); mat[1].y = cos(r);  mat[1].z = 0.0;\n    mat[2].x = 0.0;      mat[2].y = 0.0;      mat[2].z = 1.0;\n    \n    return mat;\n}\n\nmat3 rotationY(float r)\n{\n    mat3 mat;\n    mat[0].x = cos(r);  mat[0].y = 0.0;      mat[0].z = -sin(r);\n    mat[1].x = 0.0;      mat[1].y = 1.0;      mat[1].z = 0.0;\n    mat[2].x = sin(r);  mat[2].y = 0.0;      mat[2].z = cos(r);\n    return mat;\n}\n\nmat3 rotationX(float r)\n{\n    mat3 mat;\n    mat[0].x = 1.0;      mat[0].y = 0.0;      mat[0].z = 0.0;\n    mat[1].x = 0.0;      mat[1].y = cos(r);  mat[1].z = sin(r);\n    mat[2].x = 0.0;      mat[2].y = -sin(r); mat[2].z = cos(r);\n    return mat;\n}\n\n\n\n\nfloat toRad(float angle){\n    return angle * 0.017453;\n}\n\n\n\n\nfloat GetAngle(vec3 v1,vec3 v2){\n       vec3 nv1 = normalize(v1);\n        vec3 nv2 = normalize (v2);\n    \n        float angle = acos(dot(nv1,nv2)/(length(nv1)* length(nv2)));\n     return angle;\n   }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}