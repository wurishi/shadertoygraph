{"ver":"0.1","info":{"id":"WdcfRH","date":"1604313853","viewed":55,"name":"RIOW - 10 - Dielectrics","username":"TheMunro","description":"https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //divide by the number of samples (w component = sum of samples = 2 in this case)\n    //take square root to gamma correct\n    fragColor = vec4(sqrt(data.rgb/data.w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 1\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n    \n//constants\nvec3 zero = vec3(0., 0., 0.);\nvec3 one = vec3(1., 1., 1.);\nvec2 seed;\n\nfloat pi =  3.141592653;\nfloat tau = 6.283185307;\n\nfloat near = 0.0001;\nfloat far = 1e20;\n//wherever you are...\n\nconst int MAX_OBJECTS = 5;\nconst int MAX_ITERATIONS = 100;\n\n//functions\nvec3 random_in_unit_sphere()\n{\n    //https://stackoverflow.com/questions/5408276/sampling-uniformly-distributed-random-points-inside-a-spherical-volume\n    //can probably simplify this with trig identities\n    vec3 rnd = hash_3d(seed) * vec3(tau, 2., 1.) - vec3(0., 1., 0.);\n        \n    float phi = rnd.x;\n    float theta = acos(rnd.y);\n    float r = pow(rnd.z, 1./3.);   \n        \n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n                            \n    return vec3(x, y, z);\n}\n\n//vec3 reflect(in vec3 v, in vec3 n)\n//{\n//    return v - 2.*dot(v,n)*n;\n//}\n\n//vec3 refract(in vec3 i, in vec3 n, in float refraction_ratio) \n//{\n//    float c_theta = min(dot(-i, n), 1.);\n//    vec3 perpendicular = refraction_ratio * (i + c_theta * n);\n//    vec3 parallel = -sqrt(abs(1. - dot(perpendicular, perpendicular))) * n;\n//    return perpendicular + parallel;\n//}\n\n////lambertian distribution\n//vec3 random_in_unit_sphere()\n//{\n//    vec2 r.direction = hash_2d(seed) * vec2(tau, 2.) - vec2(0., 1.);\n//        \n//    float a = r.direction.x;\n//    float z = r.direction.y;\n//    float r = sqrt(1. - z*z);   \n//                          \n//    return vec3(r*cos(a), r*sin(a), z);\n//}\n\nfloat schlick_approximation(in float cosine, in float ratio)\n{\n    float r0 = (1.-ratio) / (1.+ratio);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow(1.-cosine, 5.);\n}\n\nbool lambertian_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n    vec3 scatter_direction = normalize(rec.normal + random_in_unit_sphere());\n    if (length(scatter_direction) < 1e-8)\n        scatter_direction = rec.normal;\n    \n    scattered = Ray(rec.p, scatter_direction);\n    attenuation = rec.mat.albedo;    \n    return true;\n}\n\nbool metal_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n    vec3 reflected = reflect(normalize(r.direction), rec.normal);\n    float shininess = 1. - clamp(rec.mat.value, 0., 1.);\n    vec3 direction = normalize(reflected + shininess * random_in_unit_sphere());\n    scattered = Ray(rec.p, direction);\n    attenuation = rec.mat.albedo;   \n\n    return dot(scattered.direction, rec.normal) > 0.;\n}\n\nbool dielectric_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n   attenuation = one;\n   float refraction_ratio = rec.front_face ? (1. / rec.mat.value) : rec.mat.value;\n   \n   vec3 d_n = normalize(r.direction);\n   float cos_theta = min(dot(-d_n, (rec.normal)), 1.0);\n   float sin_theta = sqrt(1. - cos_theta*cos_theta);\n   \n   vec3 dir;\n   bool cannot_refract = sin_theta * refraction_ratio >= 1.;\n   \n  \n   //dir = refract(d_n, rec.normal, refraction_ratio);\n       \n    if(cannot_refract || schlick_approximation(cos_theta, refraction_ratio) > hash_1d(seed))\n    {\n        dir = reflect(d_n, rec.normal);\n        \n        //https://github.com/RayTracing/raytracing.github.io/issues/713\n        //this doesn't work, leaves a black outline\n        //scattered = Ray(rec.p, dir);\n            \n        //this does work, thanks L3tum!\n    \tscattered = Ray(r.origin, dir); \n    }\n    else\n    {\n        dir = refract(d_n, rec.normal, refraction_ratio);\n    \tscattered = Ray(rec.p, dir); \n    }\n    \n    return true;\n}\n\nbool scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scatter)\n{\n    if(rec.mat.type == LAMBERTIAN)\n    {\n        return lambertian_scatter(r, rec, attenuation, scatter);\n    }\n    \n    if(rec.mat.type == METAL)\n    {\n        return metal_scatter(r, rec, attenuation, scatter);\n    }\n    \n    if(rec.mat.type == DIELECTRIC)\n    {\n        return dielectric_scatter(r, rec, attenuation, scatter);\n    }\n    \n    return false;\n}\n\nbool compute_hit(in Sphere s, in Ray r, in float t, in float t_min, in float t_max, out HitRecord rec)\n{\n    if(t < t_max && t > t_min) \n    {\n        rec.t = t;\n        rec.p = r.direction * t + r.origin;\n        rec.normal = (rec.p - s.centre) / s.radius;\n        rec.front_face = dot(rec.normal, r.direction) < 0.;\n        rec.normal = rec.front_face ? rec.normal : -rec.normal;\n        rec.mat = s.mat;\n        return true;\n    }\n    \n    return false;\n}\n\nbool hit_sphere(in Sphere s, in Ray r, in float t_min, in float t_max, out HitRecord rec)\n{\n    //quadratic solution to sphere-line intersection\n    //N.B. 0/1/2 solutions all possible solutions\n    //0 in complex case\n    //1 in tangent case\n    //2 in full sphere intersection case\n    \n    //vector from ray origin to sphere centre\n    vec3 oc = r.origin - s.centre;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    \n    float discriminant = half_b*half_b - a*c;\n        \n    if(discriminant < 0.)\n        return false;\n    \n    float t;\n    //closest intersection point calculation\n    t = (-half_b - sqrt(discriminant)) / a;\n    if(compute_hit(s, r, t, t_min, t_max, rec)) \n        return true;\n    \n    //farthest intersection point calculation\n    t = (-half_b + sqrt(discriminant)) / a;\n    if(compute_hit(s, r, t, t_min, t_max, rec)) \n        return true;\n\n    return false;\n}  \n\nbool world_hit(in Ray r, in float t_min, in float t_max, out HitRecord rec) \n{\n    //fix spheres\n    HitRecord temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    const Sphere sphere0 = Sphere(vec3(0.0, -100.5, -1.0), 100.0,               \n                                  Material(LAMBERTIAN, vec3(0.8, 0.8, 0.0), 1.));\n    \n    const Sphere sphere1 = Sphere(vec3(0.0, 0.025, -1.0), 0.5,             \n                                  Material(DIELECTRIC, vec3(0.1, 0.2, 0.5), 1.5));\n    \n    const Sphere sphere2 = Sphere(vec3(0.0, 0.025, -1.0), -0.4,            \n                                  Material(DIELECTRIC, vec3(0.1, 0.2, 0.5), 1.5));\n    \n    const Sphere sphere3 = Sphere(vec3(-1.1, 0.0, -1.0), 0.5,    \n                                  Material(LAMBERTIAN, vec3(0.8, 0.8, 0.8), 0.7));\n    \n    const Sphere sphere4 = Sphere(vec3(1.1, 0.0, -1.0), 0.5,     \n                                  Material(METAL, vec3(0.8, 0.6, 0.2), 0.975));\n    \n    Sphere[MAX_OBJECTS] s = Sphere[](sphere0, sphere1, sphere2, sphere3, sphere4);\n\n    //checks each intersectable object for hit, updates rec if closer\n    for(int i = 0; i < MAX_OBJECTS; i++) \n    {\n        if(hit_sphere(s[i], r, t_min, t_max, temp_rec)) \n        {\n            if(temp_rec.t < closest_so_far) \n            {\n                hit_anything = true;\n                closest_so_far = temp_rec.t;\n                rec = temp_rec;\n            }\n        }\n    }\n    \n    return hit_anything;\n}\n\n\nvec3 trace_ray(in Ray r)\n{\n    HitRecord rec;\n    vec3 col = one;\n    bool hit;\n    \n    for(int i = 0; i <= MAX_ITERATIONS; i++)\n    {\n        if(i == MAX_ITERATIONS)\n            return vec3(0.);\n        \n        if(world_hit(r, near, far, rec)) \n        {\n            Ray scattered;\n            vec3 attenuation;\n            if(scatter(r, rec, attenuation, scattered))\n            {\n                col *= attenuation;\n                r = scattered; \n                hit = true;\n            }\n        }\n        else \n        {\n            float t = 0.5 * (r.direction.y + 1.);\n            return col *= mix(one, vec3(0.5, 0.7, 1.), t);\n        }\n    } \n    \n    return col;\n}\n\n//output\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{    \n    //stores resolution in (0,0) pixel\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = iResolution.xyxy;\n        return;\n    } \n    \n    vec3 col;\n    seed = hash_2d(fragCoord + iTime);\n    \n#if AA>1\n    for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++)\n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + vec2(float(m),float(n))/float(AA) + hash_2d(seed))/iResolution.y;\n#else      \n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + hash_2d(seed))/iResolution.y;\n#endif\n        \n        //position \n        Ray r = Ray(zero, vec3(uv, -1.));\n        \n        //this is affecting output colour somehow...\n        col += trace_ray(r);\n        \n#if AA>1\n    }\n    col /= float(AA * AA);\n#endif\n        \n    //checks resolution in (0,0) pixel and if matched, sums current with last\n    if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n        fragColor = vec4(col,1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    } else {        \n        fragColor = vec4(0,0,0,1);\n    }\n}","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//data types\nstruct Ray\n{ \n    vec3 origin; \n    vec3 direction;\n};\n       \nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float value; //smoothness when metal, refractive index when dielectric\n};\n    \nstruct Sphere\n{ \n    vec3 centre; \n    float radius;\n    Material mat;\n};\n\nstruct HitRecord\n{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front_face;\n    Material mat;\n};\n\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash_1d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash_2d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash_3d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash_4d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}  \n\nfloat hrand(in vec2 coord) \n{\n    uint hashed_coord = base_hash(floatBitsToUint(coord));\n    return float(hashed_coord)/float(0xFFFFFFFFU);  \n}\n\nfloat length_squared(vec3 v)\n{\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\n// other\nfloat nrand(in vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}","name":"Common","description":"","type":"common"}]}