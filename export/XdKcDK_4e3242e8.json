{"ver":"0.1","info":{"id":"XdKcDK","date":"1523431648","viewed":142,"name":"Somewhere in space","username":"Pr0fed","description":"Was playing with adding heightmap to a raytraced sphere.\nAlso my first touch on fractals, i like it and will study more on that.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Main buffer with raytracing and coloring.\n\n#define time iTime * 0.425\n#define maxD 35.0\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\nconst vec3 darkOrange = vec3(0.95, 0.425, 0.0);\n\n///-- Scene Objects -------------------------------------------------------\n\nstruct Sphere\n{\n\tvec3 c;\n    float r;\n};\n\n// Just for the sake of simplicity.\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nSphere scene[2];\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\n\nfloat randomCol() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233 + seed++))) * 43758.5453);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x * 8.3e-3 + co.y ) * vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x * 0.3e-3 + co.y ) * vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n// Fractal used in nebula. taken from: https://www.shadertoy.com/view/lslGWr\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p) \n{\n\tfloat strength = 8. + .03 * (sin(time) * 43.11);\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 32; ++i) \n    {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n    \n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// This one remaps spherical coords to UV of a texture.\n// So we feed a normal in the intersect point of a sphere\n// and it works like a charm.\nvec2 GetSphereUV(vec3 p)\n{\n    // Swapping axis to hide the texture seam.\n    // There are others solutions to this i'm sure.\n    float phi = atan(p.x, p.z);\n    float theta = asin(p.y);\n    float u = 1. - (phi + PI) / PI2;\n    float v = (theta + PI / 2.) / PI;\n    \n    return vec2(u, v);\n}\n\nfloat ToGrayScale(vec3 color)\n{\n    return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\n///-- INTERSECT FUNCTIONS -----------------------------------------------------\n\n// The point where we intersected something.\nvec3 getHitPoint(Ray ray, float t) \n{\n \treturn ray.origin + t * ray.direction;   \n}\n\nvec3 getNormal(in vec2 p) \n{\n    float offset = 0.02;\n\n    // Horizontal offset.\n    vec2 o1 = vec2( offset, 0. );\n\n    // Vertical offset.\n    vec2 o2 = vec2( 0., offset );\n\n    // Getting offsets.\n    float s01 = ToGrayScale(texture(iChannel1, p - o1).rgb);\n    float s21 = ToGrayScale(texture(iChannel1, p + o1).rgb);\n    float s10 = ToGrayScale(texture(iChannel1, p - o2).rgb);\n    float s12 = ToGrayScale(texture(iChannel1, p + o2).rgb);\n\n    vec3 va = normalize(vec3(p.x,  0., s21 - s01));\n    vec3 vb = normalize(vec3(0., p.y, s12 - s10));\n\n    // This is our normal from HeightMap.\n    return vec3(cross(va, vb) * 0.5);\n}\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\n// Ray tracing function.\nbool hitScene1(Ray ray, Sphere sphere, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out float t)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n\n    // Sphere intersection formula.\n    vec3 oc = ray.origin - sphere.c;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.r * sphere.r;\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0001) \n    {\n        // We only need the closer side of a sphere.\n        t = (-b - sqrt(discriminant)) / a;\n\n        if (t < tMin) \n        {\n            t = (-b + sqrt(discriminant)) / a;\n        }\n\n        if (t > tMin && t < closestSoFar) \n        {\n            closestSoFar = t;\n            isHit = true;\n\n            vec3 p = getHitPoint(ray, t);\n            normal = (p - sphere.c) / sphere.r;\n            float heightAtPos = 0.5 * ToGrayScale(texture(iChannel1, GetSphereUV(normal)).rgb);\n            position = p + (normal * heightAtPos);\n        }\n    }\n\n    return isHit;\n}\n\n// Ray tracing function.\nbool hitScene2(Ray ray, Sphere sphere, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out float t)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n\n    // Sphere intersection formula.\n    vec3 oc = ray.origin - sphere.c;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.r * sphere.r;\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0001) \n    {\n        // We only need the closer side of a sphere.\n        t = (-b - sqrt(discriminant)) / a;\n\n        if (t < tMin) \n        {\n            t = (-b + sqrt(discriminant)) / a;\n        }\n\n        if (t > tMin && t < closestSoFar) \n        {\n            closestSoFar = t;\n            isHit = true;\n\n            vec3 p = getHitPoint(ray, t);\n            normal = (p - sphere.c) / sphere.r;\n        }\n    }\n\n    return isHit;\n}\n\n\n// Color mixing of planet.\nvec3 GetSurfaceColor(vec3 normal)\n{\n    vec3 col = vec3(0.0);\n    \n    vec3 heightAtPos = texture(iChannel1, GetSphereUV(normal)).rgb;\n    \n    // Since we get noisy-ish texture, we manually add colors.\n    // Here is a cyan.\n    col = mix(vec3(0., 0.29, 0.75), vec3(1.0), heightAtPos * 2.0);\n    // And a bit of purple.\n    col = mix(col, vec3(0.47, 0.0, 0.85), heightAtPos);\n \n    return col * col;\n}\n\n// Color mixing of sun.\nvec3 GetSunColor(vec3 normal)\n{\n    // Actually it is already done inside buffer, just a little tweak on brightness.\n    return texture(iChannel2, GetSphereUV(normal)).rgb * 1.5;\n}\n\nvec3 GetNebulaColor(vec2 uv)\n{\n    // A subtle movement of the nebula.\n    vec3 p = vec3(uv / 3., 0) + vec3(1.0, -1.3, 0.0005 * sin(time));\n    float t = field(p);\n\treturn mix(.4, 1., 1.) * vec3(0.8 * t * t * t, 1.4 * t * t, t);\n}\n\n\n// Main tracing function.\nvec3 trace(Ray ray, vec2 uv) \n{\n    vec3 normal, position;\n\n    vec3 position1; \n    float t = maxD;\n    float planetD;\n    vec2 p;\n    \n    vec3 sunColor;\n    vec3 orange;\n    \n    // Star field.\n    vec2 seed = uv.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y, 30.0));\n    \n    vec3 color = GetNebulaColor(uv) + starcolor.rgb;\n    \n    // First we try to hit the 'planet'.\n    if (hitScene1(ray, scene[1], 0.001, maxD, position, normal, t))\n    {\n        // Light settings.\n        vec3 light = vec3(0.0, 1.0, -8.0) - scene[1].c;\n        float diff = max(dot(normal, light), 0.15);\n  \n        color = GetSurfaceColor(normal) * diff;\n        planetD = t;\n    }\n    \n    // Then we hit 'sun' sphere. Note that we overwrite ray.origin.\n    if (hitScene1(ray, scene[0], 0.001, t, ray.origin, normal, t))\n    {\n        if (hitScene2(ray, scene[0], 0.001, t, position, normal, t)) \n        {\n            color = GetSunColor(normal);\n        }\n    }\n    \n    // Somewhere here must go the glow or other effects.\n    \n    return color;\n}\n\nvoid SceneFill() \n{\n    // Main sphere.\n\tscene[0] = Sphere(vec3(0.0, 1.0, -8.0), 2.5);\n    scene[1] = Sphere(vec3(0.0, 1.0, -8.0), 1.25);\n}\n\n#define STEPS 100\n\nvec2 hash(vec2 p) {\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization.\n    SceneFill();\n    seed = time;\n    \n    // Circular planet movement.\n    scene[1].c.x = cos(time) * 5.;\n    scene[1].c.z += sin(time) * 5.;\n    \n    \n    // Basic normalization.\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n\n    vec3 origin = vec3(0.0, 1.0, 0.0);\n\n    vec3 lookAt = vec3(0.0, 1.0, -1.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    vec2 st = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    \n    vec3 direction = lowerLeft - origin;\n    direction += horizontal * (pixelSize.x * random() + uv.x);\n    direction += vertical * (pixelSize.y * random() + uv.y);\n    color += trace(Ray(origin, direction), st);\n\n    fragColor = vec4(vec3(color), 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Simple perlin - worley texture with a bit of movement.\n\n#define time iTime * 0.05\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0 * fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\n#define NUM_OCTAVES 5\n\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat fbmW ( in vec2 _st) \n{\n    float v = 0.11;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(1.25 + time), sin(0.85 + time),\n                    -sin(0.85 + time), cos(1.25+ time));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * worley2D(_st);\n        _st = rot * _st * 2.0;\n        a *= 0.5;\n    }\n    \n    \n    return v;\n}\n\n\nfloat fbmP ( in vec2 _st) \n{\n    float v = 0.5;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(1.4), sin(1.2),\n                    -sin(1.2), cos(1.4));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * noise2D(_st);\n        _st = rot * _st * 2.0;\n        \n        a *= 0.5;\n    }\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q ;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.;\n    \n    float w = fbmP(uv) * (1.0 - fbmW(uv + fbmP(-uv * 3.)));\n    \n    vec3 color = vec3( w );\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Texture for the sun from my other shader: https://www.shadertoy.com/view/lsVyzV\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.20,  0.80, -0.80,  1.20 );\n\n// Time simplification and easier overall speed control.\n#define time iTime * 0.23\n\n// Just a simple checker-like pattern.\n// Not even sure if we can call it noise.\nfloat squareNoise( in vec2 x )\n{\n\treturn cos(x.x) * sin(x.y);\n}\n\n// Six octave FBM square noise (3 seems enough).\nfloat fbm3( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.02;\n    f += 0.250000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.03;\n    f += 0.125000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.01;\n    return f / 0.96875;\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat voronoi2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid.\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n// Four octave voronoi FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.2500 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.1250 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.0625 * voronoi2D( p );\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Base motion.\n    float ql = length( q * m );\n\n    // First layer.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    // Note that we pass q length inside outer fbm4 to get a circle pattern.\n    o = vec2(fbm4(vec2(0.5 * ql - time) + fbm3( vec2(2.0 * q + vec2(q)))));\n\n    // Second layer. Note that we use previous result as input.\n    vec2 n;\n    n = vec2(fbm4(q + fbm3( vec2(2.0 * o + vec2(o)))));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n;\n    float f = 0.5 + 0.5 * fbm3(p);\n\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.5 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    // You can play with this. Nothing really complex.\n    col = mix( vec3(0.78, 0.45, 0.06), vec3(0.35, 0.0, 0.4), f );\n    col = mix( col, vec3( 0.81, 0.55, 0.0), dot(on.xy, on.zw));\n\n    return col * col * 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p *= 6.;\n\n    // Time varying pixel color.\n    vec3 col = GetColor(p);\n\n    // Output to screen.\n    fragColor = vec4(col, 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}