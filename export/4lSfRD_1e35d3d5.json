{"ver":"0.1","info":{"id":"4lSfRD","date":"1516642398","viewed":281,"name":"theRollingStones","username":"skaplun","description":"the code could be a bit more elegant...","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","logo","rolling","stones"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define RED vec3(1., 0., 0.)\n#define PI 3.14\n#define TAU 6.28\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2, float thickness) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n  \n  float d = sqrt(pow(c, 2.) + pow(thickness, 2.));\n\n  if ( a >= d || b >= d )\n  {\n  \tif (distance(p1, uv) <= thickness ||\n        distance(p2, uv) <= thickness)\n        return 1.0;\n    else\n        return 0.0;\n  }\n\n  float p = (a + b + c) * 0.5;\n  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n    \n  if (h <= thickness)\n  {\n      return 1.0;\n  }\n  else\n  {\n      return 0.0;\n  }\n}\n\nvec2 rotate2D (vec2 _st, vec2 center, float _angle) {\n    _st -= center;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += center;\n    return _st;\n}\n\nfloat bl(vec2 p){\n\tfloat outer;\n\t{\n\t\tvec2 uv = p;\n\t\tuv *= 2.; uv -= 1.;\n\t\tuv.x -= uv.y * .1;\n\t\tfloat curve = sin(uv.x * PI * 2. - 1.6) * .11;\n\t\tfloat s = sign(curve);\n\t\touter = step(pow(abs(curve), .6) * s - .25, uv.y) * (1. - step(0., uv.y)) * (1. - step(.5, abs(uv.x)));\t\n\t}\n\n\tvec2 uv = p;\n\tuv *= 2.; uv -= 1.;\n\tuv.x -= uv.y * .1;\n\tuv *= 1.5;\n\tuv.x += .045;\n\tfloat curve = sin(uv.x * PI * 2. - 1.6) * .11;\n\tfloat s = sign(curve);\n\treturn (1. - step(pow(abs(curve), .6) * s - .25, uv.y) * (1. - step(0., uv.y)) * (1. - step(.5, abs(uv.x)))) * outer;\n}\n\nfloat tl(vec2 p){\n\tfloat inner;\n\t{\n\t\tvec2 uv = p;\n\t\tuv *= 2.; uv -= 1.;\n\t\tfloat curve = cos(uv.x * PI * 8. + PI) * .05 - .5;\n\t\tcurve -= pow(abs(uv.x), 1.7) * step(0., uv.x);\n\t\tfloat l = 1. - step(1.05 * p.x + .14, p.y);\n\t\tinner = 1. - step(pow(abs(curve), 4.), -uv.y + .18) * (1. - step(.27, uv.x)) * step(-.32, uv.x) * l;\n\t}\n    \n    vec2 uv = p;\n\tuv *= 2.; uv -= 1.;\n\tuv.x -= uv.y * .15;\n\tuv.x *= 1. - pow(p.y, 4.);\n\tfloat multiplier = .235 - step(0., uv.x) * 0.005;\n\tfloat curve = sin(abs(uv.x) * PI * 2.9 + .75) * multiplier + (multiplier + .1);\n\treturn (1. - step(pow(curve, 2.), uv.y)) * step(0., uv.y) * (1. - step(.4, abs(uv.x))) * inner;\n}\n\nfloat t(vec2 p){\n\tvec2 uv = p;\n\tuv.y *= 2.; uv.y -= 1.;\n\tuv.x -= pow(abs(uv.y + .5), 2.) * step(-.5, uv.y) * (.4 + smoothstep(-.2, .2, uv.y) * .25);\n\tfloat curve = sin(uv.x * TAU * 1.9 - .1) * .15;\n\tfloat s = sign(curve);\n\tfloat t = step(pow(abs(curve), .25) * s, uv.y);\n\tt *= (1. - step(sin(p.x * (TAU * .75) - .7) * .1, p.y - .425)) * (1. - step(.75, p.x)) * step(.25, p.x);\n\t\n\treturn clamp(t, 0., 1.);\n}\n\nfloat c(vec2 p, float t){\n\t{\n\t\tvec2 c = p * 2. - 1.;\n\t\tc.x /= 1.25;\n\t\tt *= clamp(step(.1, length(c - vec2(.0175, .07))) + step(.075, c.y), 0., 1.);\n\t}\n\t\n\t{\n\t\tvec2 c = p * 2. - 1.;\n\t\tc.x += .22; c.y += .405;\n\t\tfloat curve = sin(c.x * TAU) * .15;\n\t\tfloat s = sign(curve);\n\t\tfloat r = step(pow(abs(curve), .5) * s, c.y);\n\n\t\tc = p * 2. - 1.;\n\t\tc.x += .225; c.y += .38;\n\t\tcurve = sin(c.x * TAU) * .15;\n\t\ts = sign(curve);\n\t\tr *= 1. - step(pow(abs(curve), .5) * s, c.y);\n\t\tr *= step(.3, p.y);\n\t\tr *= 1. - step(.5, p.x);\n\n\t\tt -= r;\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tuv.y *= 2.; uv.y -= 1.;\n\t\tuv.x -= pow(abs(uv.y + .5), 2.) * step(-.5, uv.y) * (.4 + smoothstep(-.2, .2, uv.y) * .25);\n\t\tfloat curve = sin(uv.x * TAU * 1.9 - .1) * .15;\n\t\tfloat s = sign(curve);\n\t\tfloat x = step(pow(abs(curve), .25) * s, uv.y);\n\t\t\n\t\tcurve = sin(uv.x * TAU * 1.9 - .2) * .15;\n\t\ts = sign(curve);\n\t\tx += 1. - step(pow(abs(curve), .25) * s, uv.y);\n\t\tx += 1. - step(.25, uv.x);\n\t\tx += step(-.02, uv.y);\n\t\t\n\t\tt *= clamp(x, 0., 1.);\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tuv.y *= 2.; uv.y -= 1.;\n\t\tt -= clamp((1. - step(1. - uv.x * .875 - .4375, uv.y)) * step(1. - uv.x * .875 - .45, uv.y) - (1. - step(-.02, uv.y)) - step(.05, uv.y), 0., 1.);\n\t}\n\n\treturn t;\n}\n\nfloat ff(vec2 p){\n\tfloat outer = 0.;\n\t{\n\t\tvec2 uv = p;\n\t\tuv *= 2.; uv -= 1.;\n\t\tfloat curve = cos(uv.x * PI * 8. + PI) * .05 - .5;\n\t\tcurve -= pow(abs(uv.x), 1.7) * step(0., uv.x);\n\t\touter = step(pow(abs(curve), 4.), -uv.y + .18) * (1. - step(.27, uv.x)) * step(-.32, uv.x);\n\t\n\t\tuv = p;\n\t\tuv.y *= 2.; uv.y -= 1.;\n\t\tcurve = cos(uv.x * 15. * PI) * .5;\n\t\tfloat s = sign(curve);\n\t\touter *= step(-pow(abs(curve), .75), (uv.y * 15. - .75) - pow(abs((.5 - uv.x) * (1. - step(.5, p.x)) * 10.), 2.5));\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tuv.x -= pow(abs((uv.y - .32)/.14 * .25), 2.);\n\t\touter += drawLine(uv, vec2(.345, .32), vec2(.345, .46), .007 + .007 * (1. - (uv.y - .32)/.14));\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tuv.x -= sign(uv.y - .365) * pow(abs((uv.y - .265)/.2 - .4), 3.) * .15 + (uv.y - .265)/.2  * .1;\n\t\touter += drawLine(uv, vec2(.45, .265), vec2(.435, .455), .01 + .01 * (1. - (uv.y - .265)/.2));\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tfloat xNorm = (uv.x - .45)/.03;\n\t\tuv = rotate2D(uv, vec2(.455, .61), (-xNorm + 1.5)/2.);\n\t\touter += drawLine(uv, vec2(.455, .625), vec2(.475, .62), .0125 + .005 * xNorm);\n\t}\n\n\t{\n\t\tvec2 uv = p;\n\t\tfloat xNorm = (uv.x - .56)/.03;\n\t\tuv = rotate2D(uv, vec2(.56, .61), (-xNorm + 1.5)/2.);\n\t\touter += drawLine(uv, vec2(.56, .625), vec2(.58, .62), .01 + .01 * xNorm);\n\t}\n\n\treturn outer;\n}\n\nvec3 m(vec2 p){\n\tfloat teath = ff(p);\n\tfloat mouth = c(p, clamp(tl(p) + bl(p) + t(p), 0., 1.));\n\treturn mix(teath * vec3(1.), mouth * vec3(.925, .109, .141), 1. - teath);\n}\n\n//TODO: clean up the code. it's extremely messy now\n//TODO: add antialiasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv *= .6;\n    uv.x *= iResolution.x/iResolution.y; uv.y += .15; uv.x -= .05;\n\tfragColor = vec4(vec3(m(uv)), 1.);\n}","name":"Image","description":"","type":"image"}]}