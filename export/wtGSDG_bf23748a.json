{"ver":"0.1","info":{"id":"wtGSDG","date":"1583664148","viewed":490,"name":"Learning about RayMarching","username":"firegump","description":"just learing, left click to drag the screen.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\nfloat hd = 1.;//height information\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel0, p*1.00 ).x;//+ \n           //0.2500*texture( iChannel0, p*2.02 ).x+\n           //0.250*texture( iChannel0, p*4.05 ).x;\n           \n}\nfloat bgm( vec2 p )\n{\n    return 0.5000*texture( iChannel1, p*1.00 ).x+ \n           0.2500*texture( iChannel1, p*2.02 ).x+\n           0.250*texture( iChannel1, p*4.05 ).x;\n           \n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p,inout float hd) {\n    float bgm = bgm(vec2(0.1,1));//bgm anima\n    bgm = clamp(0.5,1.,bgm);\n        \n    float w1 = noise(p.xz+iTime);\n    float w2 = noise(p.xz-iTime*1.);\n    w1 = w1+ w2;\n    //w1 = pow(w1,2.);\n    \n    float w3 = fbm(p.xz*.01 + iTime*.01)*0.3;\n    float w4 = fbm(p.xz*.02 - iTime*.04)*0.2;\n    \n    \n    float w = w1*.6+ w3+w4;//wave\n    //w = w1*.6;\n    //w = w3 + w4;\n    \n    float sinOffset =  sin(p.x*1.+ iTime)*.05 + sin(p.z*4. + iTime*2.)*.05;\n    sinOffset = sinOffset * .3;\n    float hd1 = sinOffset + w*0.2;//wave height\n    hd = hd1 + bgm*.1;\n    \n    vec3 pn = vec3(0,1,0);\n    pn.x = p.x*0.01 + sin(iTime)*.01;//wobble\n    pn.z = p.z*0.01 + cos(iTime)*.01;\n    \n    pn.xz = pn.xz*(sin(iTime*1.)*.26 + .89);//convex\n    //pn.xz = pn.xz*(sin(iTime*1.)*.5+.7);//wave concave ,convex \n    float plane = dot(p,normalize(pn)) +2. + hd1;//plane distance\n    \n    vec3 bp = p-vec3(0,sin(iTime)*.5+ .5,0);\n    \n    bp = abs(bp);\n    bp.xz -= 1.;\n     \n   \n    float scale = mix(1.,5.,smoothstep(-1.,1.,bp.y));\n    \n    bp.xz *= scale;\n    bp.xz *= Rot(bp.y+iTime);\n    \n    \n    \n    bp.xz = abs(bp.xz);\n    bp.xz -= 1.5;\n    \n    \n    \n    float box = sdBox(bp, vec3(1,1,1));\n    \n    //box = sdBox(p-vec3(0,1,0)-sin(p.x* 6.5+iTime*4.)*.02, vec3(1,.02,1));//wave\n    //box = abs(box)-.1;   //making  shell\n    vec4 s1 = vec4(0,1.5+ bgm,0,1.);\n    float sd1 = length(p-s1.xyz) - s1.w-bgm;\n    float sd = sd1;\n    float d = smin(plane, box*.1,0.9);\n    d= smin(sd, d,0.7);\n    \n    //sky\n    float sdsky = length(p)- 52.;\n    sdsky = abs(sdsky) - 1.5;\n    \n    d = min(d,sdsky);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float h = 1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p,hd);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    \n\tfloat d = GetDist(p, hd);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, hd),\n        GetDist(p-e.yxy, hd),\n        GetDist(p-e.yyx, hd));\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p,vec3 rd, vec3 lightPos, vec3 lightCol) {\n    vec3 v = -rd;\n    \n    \n    //attenuation\n    float atten = 1. - length(lightPos - p)/20.;//float is light Area\n    atten = smoothstep(1.,.5,clamp(0.,1.,atten));\n    \n    float MoveRadius = 0.;\n    float MoveSpeed = 0.;\n    \n    //float t = iTime * MoveSpeed;\n    //lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    vec3 ref = reflect(n,rd);\n    //ambient\n    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n    //diffuse\n    float NdotL = dot(n, l);\n    NdotL = NdotL*.5 + .5;\n    float dif = clamp(NdotL, 0. , 1.);\n    //specular\n    vec3 h = normalize(l + v);\n    float spe = pow(max(dot(n,h),0.), 128.);\n    //fresnel\n    //float fs = .4; //fresnel scale\n    \n    \n    \n    \n    \n    float fre =  clamp(  1.+ dot(rd,n)       ,0.,1.);\n    fre = pow(fre, 4.);\n    //dom\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    \n    \n    //ficker\n    vec4 fcol = texture(iChannel3,p.xz);\n    \n    \n    vec3 finCol = vec3(0.); \n    finCol += amb * vec3(1,1,0) * .5;\n    finCol += dif * vec3(1,1,1) * .5;\n    finCol += spe * vec3(1,1,1) * 1.;\n    finCol *= fre * vec3(1,1,0)* .1;\n   \tfinCol += dom * vec3(0,1,1) * 0.1;\n    vec3 refT = texture(iChannel2,ref).xyz;\n    finCol += refT*.5*( dot(rd,n)*.5+.5);\n    \n    \n    finCol *= atten*lightCol*1.4;\n    finCol *= 2.;\n    //finCol = vec3(dom);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    //if(p.y<.01 && d<length(lightPos-p)) dif *= 0.3;//shadow\n    \n    //color adjust\n    finCol.rg *= 0.5;\n    finCol.g *= .7;\n    //finCol = i\n    return finCol ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,4.2, -12);//camera point\n    ro.yz *= Rot(-m.y*3.14*.6 + sin(iTime*.6)*0.52 -.4);//camera rotate animation\n    ro.xz *= Rot(-m.x*6.2831 + sin(iTime*.3));\n    \n    vec3 rd = R(uv, ro, vec3(0,3,0), 1.);//look point\n    \n    //vec3 Bgcol = texture(iChannel2,rd).xyz;\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 lightPos = vec3(-2. , 9. , -4. );\n    vec3 lightCol = vec3(1, 1 ,1);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tvec3 dif = GetLight(p,rd,lightPos, lightCol);\n        //dif.x = clamp(0.,1.,dif.x);\n        //vec3 BGcolor = mix(vec3(.1,0.1,0.1), vec3(0.1,0.1,1),smoothstep(1., 100.,d));\n        //col = Bgcol;\n    \t//if(col.r > 0.)  col = dif;\n        col = dif;\n        //col = vec3(uv,1.);\n        col = dif *3.5;//color adjust\n        \n        //float hda = smoothstep(0.,1.,hd);\n        //col += vec3(hd)*1.1*(sin(iTime*2.)*.2+.8)*vec3(1,0.7,.5)*sin(p.z + p.x + p.y );\n        \n        vec3 hdcol = vec3(hd)*1.1*(sin(iTime*2.)*.1+.9)*vec3(0,.3,.7);\n        col += hdcol;\n        \n        \n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}