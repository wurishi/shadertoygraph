{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nRay marching a endless, randomly generated track.\nTo make this demo less boring, the waveform of the background music is being visualized :-P\n\nThis shader is still under optimization.\n\n*/\nvec4 GRID_SIZE = vec4( 1.0, 0.5, 0.0, 2.0 ); // grid size, grid size / 2, 0, grid height\nvec4 BG_COLOR = vec4( 0.0, 0.0, 0.0, 1.0 );\nvec4 FG_COLOR0 = vec4( 0.25, 0.25, 1.0, 1.0 );\nvec4 FG_COLOR1 = vec4( 1.0, 0.701, 0.0, 1.0 );\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\t\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 rotatex( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\n\tvec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n\treturn vResult;\n}\n\nvec3 rotatey( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n      \nvec3 rotatez( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\n\treturn vResult;\n}\n\nvec3 translate( vec3 v, vec3 t )\n{\n\treturn v - t;\n}\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\n// Grid related\nvec3 gridId( in vec3 p )\n{\n\tvec3 gid;\n\tgid = floor( p / GRID_SIZE.xxx );\n\tgid.y = 0.0;\n\treturn gid;\n}\n\nvoid gridData( out vec4 gdim, out vec3 gpos, in vec3 gid, in Ray eyeRay )\n{\n\tfloat h = hash( gid.z * 5.0 ) * 0.875 + 0.125;\n\th = h * h * GRID_SIZE.w;\n\t\n\tgpos.xz = ( gid.xz * GRID_SIZE.xx );\n\tgpos.y = 0.0;\n\t\n\tgdim.xz = GRID_SIZE.xx;\n\tgdim.y = h;\n\tgdim.w = 0.0625;\n}\n\nfloat gridUD( in vec4 gdim, in vec3 gpos, in vec3 p )\n{\n\t//return udBox( translate( p, gpos ), gdim.xyz );\n\treturn udRoundBox( translate( p, gpos ), gdim.xyz - gdim.www, gdim.w );\n}\n\nvec4 scene( in Ray eyeRay, in vec3 target )\n{\n\tvec3 gid;\n\tvec4 gdim;\n\tvec3 gpos;\n\tvec4 ret;\n\t\n\tvec3 q = floor( eyeRay.org / GRID_SIZE.xxx ) * GRID_SIZE.xxx;\n\t\n\tq.y = 0.0;\n\tfloat side = 1.0;\n\tfloat sideL = udBox( translate( target, q - GRID_SIZE.xzz * 2.0 ), GRID_SIZE.xwx * vec3( 1.0, side, 5.0 ) );\n\tfloat sideR = udBox( translate( target, q + GRID_SIZE.xzz * 2.0 ), GRID_SIZE.xwx * vec3( 1.0, side, 5.0 ) );\n\tret.w = min( sideL, sideR );\n\t\n\t\n\tvec3 p = q + GRID_SIZE.zzx;\n\t\t\n\tfor ( int col = 0; col < 7; ++col )\n\t{\n\t\tgid = gridId( p );\n\t\tgridData( gdim, gpos, gid, eyeRay );\n\t\t\n\t\tfloat d = gridUD( gdim, gpos, target );\n\t\t\n\t\tif ( d < ret.w )\n\t\t{\n\t\t\tret.xyz = gid;\n\t\t\tret.w = d;\n\t\t}\n\t\t\n\t\tp -= GRID_SIZE.zzx;\n\t}\n\t\n\treturn ret;\n}\n\nbool raymarch3( out vec3 hitPos, out vec3 hitNrm, Ray ray )\n{\n\t// assume ray.dir is normalized\n\tconst float hitThreshold = 0.001;\n\t\n\t// ray march against found\n\tbool hit = false;\n\tfloat t = 0.0;\n\t\n\tRay r2;\n\tr2.org = ray.org;\n\tr2.dir = ray.dir * GRID_SIZE.y;\n\t\n\tfor ( int i = 0; i < 64; ++i )\n\t{\n\t\tvec3 p = ray.org + t * ray.dir;\n\t\t\n\t\tvec4 found = scene( r2, p );\n\t\tif ( found.w < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = p;\n\t\t\t\n\t\t\tvec3 eps = vec3( hitThreshold * 0.5,0.0,0.0 );\n\t\t\tvec3 nor;\n\t\t\tnor.x = scene( r2, p + eps.xyy ).w - scene( r2, p - eps.xyy ).w;\n\t\t\tnor.y = scene( r2, p + eps.yxy ).w - scene( r2, p - eps.yxy ).w;\n\t\t\tnor.z = scene( r2, p + eps.yyx ).w - scene( r2, p - eps.yyx ).w;\n\t\t\thitNrm = normalize( nor );\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tt += found.w;\n\t}\n\t\n\treturn hit;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in Ray eyeRay )\n{\n\tfloat AREA = 0.045;\n\tfloat SOFTNESS = 0.25;\n\tfloat sca = 15.0;\n\t\n    float ao = 1.0;\n    float totao = 0.0;\n    \n    for ( int aoi = 0; aoi < 5; aoi++ )\n    {\n        float hr = 0.01 + AREA * float( aoi * aoi );\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( eyeRay, aopos ).w;\n        totao += -( dd - hr ) * sca;\n        sca *= SOFTNESS;\n    }\n    return 1.0 - clamp( totao, 0.0, 1.0 );\n}\n\nvec4 fgcolor( in float brightness )\n{\n\tfloat t = clamp( brightness * brightness * 2.0, 0.0, 1.0 ) ;\n\tif ( t < 0.5 )\n\t\treturn mix( BG_COLOR, FG_COLOR0, t * 2.0 ) * t;\n\telse\n\t\treturn mix( FG_COLOR0, FG_COLOR1, ( t - 0.5 ) * 2.0 ) * t;\n}\n\n\nvec4 shade( in vec3 scenePos, in vec3 sceneNrm, in Ray eyeRay, in vec4 bg_color )\n{\n\tfloat brightness = texture( iChannel0, vec2( 0.125, 0.75 ) ).x;\n\t\n\tfloat ao = calcAO( scenePos, sceneNrm, eyeRay );\n\t\n\tvec4 diff = mix( fgcolor( brightness ), BG_COLOR, ao );\n\t\n\tfloat fog = min( 1.0, length( scenePos.z - eyeRay.org.z ) / 5.0 );\n\t\n\treturn mix( diff, bg_color, fog );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//fragColor = texture( iChannel0, vec2( 0.5, 0.75 ) );\n\t\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\tvec2 scaledXY = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\tvec3 camWsXYZ = vec3( 0.0, GRID_SIZE.w * 1.25, 0.0 );\n\tcamWsXYZ.z = -iTime * 1.5;\n\t\n\tfloat rotX = 0.2618;\n\tfloat rotZ = sin( iTime ) * 0.25;\n\t//float rotZ = mix( -0.7854, 0.7854, texture( iChannel0, vec2( 0.25, 0.25 ) ).x );\n\t\n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir = rotatex( normalize( vec3( scaledXY, -1.0 ) ), rotX ); // OpenGL is right handed\n\tray.dir = rotatez( ray.dir, rotZ );\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\t// sync the bg_color with the music\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\t//vec2 uv = rotatez( vec3( fragCoord.xy / iResolution.xy, 0 ), rotZ * 0.75 ).xy;\n\t\n\tfloat h = texture( iChannel0, vec2( uv.x, 0.75 ) ).x;\n\tfloat t = clamp( pow( abs((1.0 - uv.y) - ((1.0 - h) - 0.125)), 0.25 ), 0.0, 1.0 );\n\tvec4 bg_color = mix( fgcolor( h ), BG_COLOR, t ) * 2.0;\n\t\n\t\n\t// ray march the scene\n\tif ( raymarch3( sceneWsPos, sceneWsNrm, ray ) )\n\t{\n\t\t// hit\n\t\tfragColor = shade( sceneWsPos, sceneWsNrm, ray, bg_color );\n\t}\n\telse\n\t{\n\t\t// not hit\n\t\tfragColor = bg_color;\n\t}/**/\n\t\n\t//fragColor = bg_color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sl3z8","date":"1364616776","viewed":299,"name":"The Endless Track","username":"ming","description":"Ray marching a endless, randomly generated track.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","music","audio","endless"],"hasliked":0,"parentid":"","parentname":""}}