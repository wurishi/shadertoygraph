{"ver":"0.1","info":{"id":"dtXGRN","date":"1707598443","viewed":100,"name":"Crystalline Morphing 2","username":"dominionxvii","description":"Snowflakes morphing between them, generated with Raymarching","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarchingcrystal"],"hasliked":0,"parentid":"fdtXDS","parentname":"Crystalline Morphing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n\nbool IsInFrame(vec2 uv)\n{\n   return (uv.x > 0. && uv.y > 0. && uv.x < 1. && uv.y < 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = col;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n//[-1, 1] -> [0, 1]\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nvec3 project(vec3 a, vec3 b)\n{\n    return (dot(a, b)/dot(b,b))*b;\n}\n\nvec3 reject(vec3 a, vec3 b)\n{\n    return a - project(a, b);\n}\n\nvec3 RotateAroundAxis(vec3 p, vec3 axis, float a)\n{\n    vec3 parallel = project(p, axis);\n    vec3 orthogonal = reject(p, axis);\n    vec3 vcross = cross(p, axis);\n    return parallel + orthogonal * cos(a) + vcross * sin(a);\n}\n\nfloat Repeat(float t, float len)\n{\n    return clamp(t - floor(t / len) * len, 0., len);\n}\nvec2 Repeat(vec2 t, vec2 size)\n{\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, vec3 size)\n{\n    return vec3(\n        Repeat(t.x, size.x),\n        Repeat(t.y, size.y),\n        Repeat(t.z, size.z)\n    );\n}\n\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\nfloat ReduceResolution(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\nvec2 Remap(vec2 fromMin, vec2 fromMax, vec2 toMin, vec2 toMax, vec2 v)\n{\n    return vec2(Remap(fromMin.x, fromMax.x, toMin.x,toMax.x, v.x), Remap(fromMin.y, fromMax.y, toMin.y, toMax.y, v.y));\n}\n\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.y * s + p.z * c\n      );\n}\n\n\nvec3 RotateZ45(vec3 pos)\n{\n    return RotateZ(pos, radians(45.));\n}\nvec3 RotateY45(vec3 pos)\n{\n    return RotateY(pos, radians(45.));\n}\nvec3 RotateX45(vec3 pos)\n{\n    return RotateX(pos, radians(45.));\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 HueShift(vec4 col, float shift)\n{  \n    vec3 hsv = rgb2hsv(col.rgb);\n    hsv.r += shift;\n    col.rgb = hsv2rgb(hsv);\n    return col;\n}\n\nvec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 1.) / 255.;\n}\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x * 3.151) +\n        0.333 * sin(v.y * 8.357) + \n        0.333 * cos((v.x + v.y) * 3.723);\n\n}\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad(float x) {\n    return x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\nfloat easeInOutQuint(float x)\n{\n    return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\n\nvec2 PolarToCartesian(vec2 polar)\n{\n    float r = polar.x;\n    float a = polar.y;\n    return vec2(r * cos(a), r * sin(a));\n}\nvec2 CartesianToPolar(vec2 cartesian)\n{\n    float r = length(cartesian);\n    float a = atan(cartesian.y, cartesian.x);\n    return vec2(r, a);\n}\n\n\nvec3 AddStar(vec3 pos, float angle)\n{\n    float radPentaAngle = radians(360.0 / 5.0);\n    vec2 polarCoord = CartesianToPolar(pos.xy);\n    polarCoord.y = mod(polarCoord.y, radPentaAngle) + radPentaAngle + angle;\n    pos.xy = PolarToCartesian(polarCoord);\n \n    float angle2 = CartesianToPolar(pos.xy).y;\n    return pos;\n}\n\nvec3 AddSymmetryToPos(vec3 pos, bool mirrorX, out float quadrant, out float xSign)\n{\n    float radHexAngle = radians(60.);\n   \n    \n    vec2 polarCoord = CartesianToPolar(pos.xy);\n    quadrant = floor(polarCoord.y / radHexAngle);\n\n    polarCoord.y = Repeat(polarCoord.y, radHexAngle) + radHexAngle;\n    \n    pos.xy = PolarToCartesian(polarCoord);\n    \n    if(mirrorX)\n    {    \n        xSign = sign(pos.x);\n        pos.x = abs(pos.x);\n    }   \n    return pos;\n}\n\nvec3 AddSymmetryToPosMirrorX(vec3 pos, float yAngle, out float quadrant, out float xSign)\n{\n    pos = RotateY(pos, -yAngle);\n    pos = AddSymmetryToPos(pos, true, quadrant, xSign);\n    return pos;\n}\n\n\nvec3 AddSymmetryToPos(vec3 pos, float yAngle, out float quadrant)\n{\n    float unused;\n    pos = RotateY(pos, -yAngle);\n    pos = AddSymmetryToPos(pos, false, quadrant, unused);\n    return pos;\n}\n\n\n///https://iquilezles.org/articles/distfunctions\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n\nvec3 opTwist(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPrism(vec3 position, float halfWidth, float halfHeight, float halfDepth) \n{\n    position.x = abs(position.x);\n    position.xy -= vec2(halfWidth, -halfHeight);\n    vec2 e = vec2(-halfWidth, 2.0 * halfHeight);\n    vec2 q = position.xy - e * clamp(dot(position.xy, e) / dot(e, e), 0.0, 1.0);\n    float d1 = length(q);\n    if (max(q.x, q.y) < 0.0) {\n        d1 = -min(d1, position.y);\n    }\n    float d2 = abs(position.z) - halfDepth;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCrystal4(vec3 pos, float size, vec2 heights, float topCut, vec3 boxCut)\n{\n    vec3 pos1 = pos;\n    float minD = sdPyramid(pos1, heights.x);\n    minD = max(minD, sdBox(pos1 + vecY(topCut), vec3(size)));\n    \n    vec3 pos2 = vec3(pos.x, -pos.y, pos.z);\n    minD = min(minD, sdPyramid(pos2, heights.y));\n    \n    minD = max(minD, sdBox(pos, boxCut));\n    return minD;\n}\n\nfloat sdCrystal8(vec3 pos)\n{\n/*\n    float topCut = 0.7;\n    float size = 1.;\n    vec2 height = vec2(0.5, 1.0);\n    vec3 boxCut = vec3(0.47, 5.0, 0.47);\n    float d1 = sdCrystal4(pos, size, height, topCut, boxCut);\n    \n    pos = RotateY(pos, radians(45.0));\n    float d2 = sdCrystal4(pos, size, height, topCut, boxCut);\n    */\n    float topCut = 0.3;\n    float size = 0.5;\n    vec2 height = vec2(0.25, 0.5);\n    vec3 boxCut = vec3(0.25, 2.5, 0.15);\n    float d1 = sdCrystal4(pos, size, height, topCut, boxCut);\n    \n    pos = RotateY(pos, radians(45.0));\n    float d2 = sdCrystal4(pos, size, height, topCut, boxCut);\n    return max(d1, d2);\n}\n\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n    }\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n     \n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\nfloat fbm4r_3x( in vec3 x, mat3 rot)\n{\n    vec3 fbm1 = vec3(fbm_4r(x, rot));\n    vec3 fbm2 = x + fbm_4r(fbm1, rot);\n    return fbm_4r(x + fbm2, rot);\n}\n\nfloat fbm4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nvec2 NextVec2(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\n\n//quaternions\n\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\n//other\n\n\nfloat Convert2DTo1D(vec2 p, vec2 s) \n{\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size)\n{\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size)\n{\n    //p = Repeat(p, size);\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size)\n{\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\nfloat PeriodicalCellularNoise(vec2 p, float scale, vec2 size, float sideOffset, out vec2 mainCell)\n{\n    p *= scale;\n    mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 cellIndex = mainCell + vec2(x, y);\n        \n        vec2 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17.);\n        uint state = WangHash(seed);\n        \n        vec2 rngVec2 = NextVec2(state);\n        vec2 cellPoint = cellIndex + Remap(vec2(0.), vec2(1.), vec2(sideOffset), vec2(1. - sideOffset), rngVec2);\n        float dist = distance(p, cellPoint);\n        minDist = min(minDist, dist);\n    }\n\n    return minDist;\n}\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size)\n{\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        float dist = distance(p, cellPoint);\n        minDist = min(minDist, dist);\n    }\n\n    return minDist;\n}\n\n\n//Music utils\n#define BPM 120.\nconst float beatDuration = 60. / BPM;\nconst int beatPerMesure = 4;\n\nconst float loopDuration = float(beatPerMesure) * beatDuration;\n\nconst int beatLoopPerFlake = 4;\n\nconst int hitHatMesure[8] = int[8](1, 0, 1, 0, 1, 0, 1, 0); \nconst int kickMesure[4] = int[4](1, 0, 1, 0); \nconst int tomMesure[2] = int[2](0, 1); \nconst int snareMesure[8]  = int[8](0, 0, 0, 1, 0, 0, 1, 0);\n\n\nfloat GetEnv(float t)\n{\n    t = DASRCurve(t, 0.0, 0.2, 0.8, 1.0);//smooth\n    //t = DASRCurve(t, 0.0, 0.00, 1.0, 1.0);//step\n    return easeInOutCubic(t);\n}\n/*\nvoid TimeToBeatIndex(float ratio, int mesuresPerLoop, out int i, out float t)\n{  \n    t = Repeat(t, 1.0);\n    //[0, 1] -> [0, mesuresPerLoop]\n    t = ratio * float(beatPerMesure * mesuresPerLoop) / mesureScale;\n    i = int(t) % beatPerMesure;\n    t = fract(t);\n    return; \n}\n*/\nvoid TimeToBeatIndex(float ratio, int notePerLoop, out int i, out float t)\n{  \n    t = ratio * float(notePerLoop * beatLoopPerFlake);\n    i = int(t) % notePerLoop;\n    t = fract(t);\n    return; \n}\nfloat GetHitHat(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, 8, i ,t);\n    return GetEnv(t) * float(hitHatMesure[i]);\n}\n\n\nfloat GetSnare(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, 8, i ,t);\n    float env = t = DASRCurve(t, 0.0, 0.05, 0.8, 1.0);\n    return easeInOutCubic(env) * float(snareMesure[i]);\n}\n\nfloat GetKick(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, 4, i ,t);\n    \n    float env = t = DASRCurve(t, 0.0, 0.05, 0.5, 1.0);\n    return easeInOutCubic(env) * float(kickMesure[i]);\n}\n\nfloat GetTom(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, 2, i ,t);\n    float env = t = DASRCurve(t, 0.0, 0.2, 0.4, 1.0);\n    return easeInOutCubic(env) * float(tomMesure[i]);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This shader is made to be morphing between flakes\n//But the compile time is nasty so ill let it commented out\n//#define MORPHING\n\n//Alternatively you can change this from 0 to 3\n#define DEBUG_CRYSTAL 0\n\n//#define HD\n#define FAST\n//#define VOLUMETRIC_LIGHT\n\n#ifdef FAST\n    #define RAYMARCH_STEPS 100\n    #define VOLLIGHT_STEPS 20\n    #define VOLLIGHT_STEPSIZE 0.5\n    #define FRACTIONAL_STEP 0.25\n#else\n    #define RAYMARCH_STEPS 1000\n    #define VOLLIGHT_STEPS 50\n    #define VOLLIGHT_STEPSIZE 0.1\n    #define FRACTIONAL_STEP 0.1\n#endif\n\n#define VOLLIGHT_DENSITY 0.003\n\n\n\n#define BASECRYSTAL 100\n#define PI 3.1416\n#define TAU 6.2831\n\n\n#define MATERIAL_FLAKE 0\n#define MATERIAL_CLOTH 1\n\nconst float HEXAGONALANGLE = 60.;\n\nconst int numberCrystal = 4;\n\nconst int flakesOrder[numberCrystal] = int[numberCrystal](0, 1, 2, 3);\n\nfloat flakeTime;\nfloat rotationAngle;\nfloat rotationAngleDx;\n\nvec3 rotationAxis;\n\nstruct RayPrimHit\n{\n    //flake based\n    float dist;\n    float hueShift;\n    float normalBlend;\n    int materialID;\n    \n    //general\n    int crystalID0;\n    int crystalID1;\n\n    float crystalMix;\n};\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    vec3 reflPos;\n    vec3 reflDir;\n    vec2 uv;\n    int steps;\n    RayPrimHit primHit;\n};\n\n\nRayPrimHit MixPrimHit(RayPrimHit hit1, RayPrimHit hit2, float t)\n{\n    RayPrimHit hit = hit1;\n    hit.dist = mix(hit1.dist, hit2.dist, t);\n    hit.hueShift = mix(hit1.hueShift, hit2.hueShift, t);\n    hit.normalBlend = mix(hit1.normalBlend, hit2.normalBlend, t);\n    hit.materialID = t < 0.5 ? hit1.materialID : hit2.materialID;\n\n    return hit;\n}\n\n\nfloat AddTexture(vec3 pos, vec3 size, float spread)\n{\n    pos = opRepLim(pos, spread, vec3(10., 10., 4.6));\n    pos = RotateZ45(pos);\n    pos = RotateX45(pos);\n    return sdBox(pos, size);\n}\n\nfloat BevelCube(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    vec3 sizebevel = vec3(size.x * bevelRatio.x, size.y * bevelRatio.x, size.z * bevelRatio.y);\n    float d1 = sdBox(pos - offset, size);\n    float d2 = sdBox(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat BevelCubeDiamond(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    return BevelCube(RotateZ45(pos), RotateZ45(offset), size, bevelRatio);\n}\n\nfloat BevelHex(vec3 pos, vec3 offset, vec2 size, vec2 bevelRatio)\n{\n    vec2 sizebevel = vec2(size.x * bevelRatio.x, size.y * bevelRatio.y);\n    float d1 = sdHexPrism(pos - offset, size);\n    float d2 = sdHexPrism(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat BevelPrism(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    vec3 sizebevel = vec3(size.x * bevelRatio.x, size.y * bevelRatio.y, size.z);\n    float d1 = sdPrism(pos - offset, size.x, size.y, size.z);\n    float d2 = sdPrism(pos - offset, sizebevel.x, sizebevel.y, sizebevel.z);\n    return mix(d1, d2, 0.5);\n}\n\nfloat BevelHexRotZ(vec3 pos, vec3 offset, float rotationZ, vec2 size, vec2 bevelRatio)\n{\n    pos = RotateZ(pos, rotationZ);\n    offset = RotateZ(offset, rotationZ);\n    return BevelHex(pos, offset, size, bevelRatio);\n}\n\nfloat BevelTriPrism(vec3 pos, vec3 offset, vec2 size, vec2 bevel)\n{\n    vec2 sizebevel = vec2(size.x * bevel.x, size.y * bevel.y);\n    float d1 = sdTriPrism(pos - offset, size);\n    float d2 = sdTriPrism(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat ClockAngle(float duration, float angleStep, float animSpeed)\n{\n    float speed = 1. / duration;\n    float time = iTime * speed;\n    float t = fract(time);\n    float count = floor(time);\n    \n    t = saturate(t * animSpeed);   \n    t = easeOutCirc(t);\n    return (t + count) * angleStep;\n}\n\n\nRayPrimHit CrystalBase(vec3 pos)\n{\n    float quadrant;\n    pos = AddSymmetryToPos(pos, rotationAngle, quadrant);\n    vec2 bevel = vec2(0.5, 0.7);    \n\n    RayPrimHit hit;\n    hit.materialID = MATERIAL_FLAKE;\n    hit.dist = 999999.;\n\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.7, .05), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.6, .075), bevel));\n    \n    hit.dist = max(hit.dist, -BevelHex(pos, vecY(0.4), vec2(.1, .15), bevel));\n    hit.dist = max(hit.dist, -BevelHex(pos, vecY(0.3), vec2(.1, .15), bevel));\n    hit.dist = max(hit.dist, -BevelHex(pos, vec3(0.), vec2(.25, .15), bevel));\n\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.), vec2(.15, .075), bevel));\n    hit.dist = max(hit.dist, -BevelHex(pos, vecY(0.2), vec2(.05, .15), bevel));\n    \n    hit.dist = min(hit.dist, BevelHex(pos, vecY(.5), vec2(.09, .075), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vecY(.6), vec2(.07, .075), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vecY(.7), vec2(.05, .075), bevel));\n\n    return hit;\n}\n\nRayPrimHit Crystal0(vec3 pos)\n{\n    float quadrant;\n    float xSign;\n    pos = AddSymmetryToPosMirrorX(pos, rotationAngle, quadrant, xSign);\n    vec3 spinPos = RotateY(pos, iTime);\n    \n    RayPrimHit hit;\n    hit.materialID = MATERIAL_FLAKE;\n    hit.dist = 999999.;\n    vec2 bevel = vec2(0.5, 0.3);\n    \n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.7, .05), bevel));\n    \n    int spikeCount = 6;\n    for(int i = 0; i < spikeCount; i++)\n    {\n        float x = float(i);\n        float xOffset = x * 2. * PI / float(spikeCount);\n        \n        float sinOffset = 0.05 * sin(PI * flakeTime * 6. + xOffset);\n        vec3 p = -RotateY(pos, iTime + xOffset);\n        hit.dist = smin(hit.dist, BevelTriPrism(p, vec3(0.0, -0.5 - x * 0.2 + sinOffset, 0.0), vec2(0.6 - x * 0.1, .05), bevel), 0.1);\n    }\n    hit.dist = max(hit.dist, -BevelHex(spinPos, vecY(0.5), vec2(0.15, 0.12), bevel));\n    hit.dist = max(hit.dist, -BevelHex(pos, vecY(0.0), vec2(0.2, 0.2), bevel));\n\n    return hit;\n}\n\nfloat GetArp(float time, float arpNotes, float quadrant, float xSign)\n{\n    //const float arpNotes = 12.;\n    float arpId = Repeat(quadrant * 2. + (1.0 - max(xSign, 0.)), arpNotes); \n    float arpSpeed = 3.;\n    float arp = 1. - abs(floor(mod(time * arpNotes, arpNotes)) - arpId) < 0.01 ? 1. : 0.;\n    return arp;\n}\n\n\nRayPrimHit Crystal1(vec3 pos)\n{\n    float quadrant;\n    float xSign;\n    vec3 simPos = AddSymmetryToPosMirrorX(pos, rotationAngle, quadrant, xSign);\n    pos = AddSymmetryToPos(pos, rotationAngle, quadrant);\n\n    RayPrimHit hit;\n    hit.materialID = MATERIAL_FLAKE;\n    hit.dist = 999999.;\n    float smooss = 0.1;\n    float thicc = 0.1;\n    vec2 bevel = vec2(0.5, 0.3);\n  \n    float kick =  GetKick(flakeTime);\n    float snare = GetSnare(flakeTime);\n    float hitHat = GetHitHat(flakeTime);\n    float tom = GetTom(flakeTime);\n\n    float noise1 = snoise(vec2(pos.y * 2., quadrant));\n    float noise2 = snoise(vec2(pos.y * 2., 100.));\n\n    pos.x += 0.1 * mix(noise1, noise2, snare);\n    \n    vec2 modPos = Repeat(vec2(abs(pos.x), pos.y) * 15., vec2(1.0));\n    vec3 thornPos = pos + 0.02 * distance(fract(modPos.x - modPos.y), 0.5);\n        \n    vec3 wavePos = simPos + 0.02 * (\n        1.00 * vecZ(1.) * sin(10. * simPos.y - flakeTime * TAU * 2.5) +\n        1.50 * vecX(1.) * cos(20. * simPos.y - flakeTime * TAU * 5.) +\n        0.25 * vecZ(1.) * sin(30. * simPos.y - flakeTime * TAU * 10.)\n    );\n   \n    //low ring - kick\n    hit.dist = smin(hit.dist, BevelCubeDiamond(wavePos, vecY(mix(0.2, 0.4, kick)), vec3(0.07, 1.0, thicc), bevel), smooss);\n    \n    float waveTime = fract(flakeTime * 4.0);\n    float waveOffset = pos.y * 0.05 * snare;//mix(0., pos.y * 0.075 * snare, waveTime);\n    thornPos.y += waveOffset;\n    wavePos.y += waveOffset;\n    \n    float shockWave = 0.2 * tom * sin(pos.y * 16. + flakeTime * 64.0);\n    thornPos.y += shockWave;\n    wavePos.y += shockWave;\n\n    //branch\n    hit.dist = smin(hit.dist, BevelCube(thornPos, vecY(0.7), vec3(0.07, 0.95, thicc), bevel), smooss);\n    \n    float tulipCurve = 0.1 + smoothstep(simPos.y, 1.0, 1.2) * 0.3;\n    //float distTree1 = BevelCube(wavePos, vecY(1.5), vec3(tulipCurve, 0.4, thicc * 1.1), bevel);\n    float distTree2 = BevelCube(wavePos, vecY(1.4), vec3(tulipCurve, 0.3  + simPos.x * 0.1, thicc * 1.1), bevel);\n    float distMainFlower = mix(distTree2, distTree2, snare);\n    hit.dist = smin(hit.dist, distMainFlower, smooss * 0.5);\n    hit.dist = max(hit.dist, -BevelCubeDiamond(wavePos, vecY(1.7), vec3(0.2, 0.2, thicc * 1.2), bevel));\n    hit.dist = max(hit.dist, -BevelCubeDiamond(wavePos, vecY(1.7) + vecX(0.15), vec3(0.2, 0.2, thicc * 1.2), bevel));\n    hit.dist = max(hit.dist, -BevelCubeDiamond(wavePos, vecY(1.7) - vecX(0.15), vec3(0.2, 0.2, thicc * 1.2), bevel));\n\n    //ligne\n    hit.dist = smin(hit.dist, BevelCube(thornPos, vecY(0.9 + pow(simPos.x, 1.5) * 0.5), vec3(.7, 0.05, thicc), bevel), smooss);\n\n    //tite leaf\n    float distTiteLeaf = BevelHex(wavePos, vec3(0.45, 1.08, 0.0), vec2(.1, thicc), bevel);\n    hit.dist = min(hit.dist, distTiteLeaf);\n\n    //flower, snare\n    float distBranch1 = BevelCube(mix(simPos, wavePos, hitHat), vecY(0.2) + vecX(0.2), vec3(0.07, 0.6, thicc), bevel);\n    hit.dist = min(hit.dist, distBranch1);\n    \n    float distBranch2 = BevelCube(mix(simPos, wavePos, hitHat), vecY(0.5) + vecX(0.3), vec3(0.07, 0.5, thicc), bevel);\n    hit.dist = min(hit.dist, distBranch2);\n    \n    \n    if(hit.dist == distBranch1 || hit.dist == distTiteLeaf)\n    {\n        hit.hueShift = -0.3;\n    }\n    else if(hit.dist == distBranch2)\n    {\n        hit.hueShift = 0.15;\n    }\n    else if( hit.dist == distMainFlower)\n    {\n        hit.hueShift = mix(0.15, 0.4, snare);\n    }\n   \n    return hit;\n}\n\nRayPrimHit Crystal2(vec3 pos)\n{\n    vec3 originalPos = pos; \n    float quadrant;\n    pos = AddSymmetryToPos(pos, rotationAngle, quadrant);\n\n    vec2 bevel = vec2(0.5, 0.7);    \n\n\n    RayPrimHit hit;\n    hit.dist = 1000.;\n    \n    //spike\n    hit.dist = smin(hit.dist, BevelPrism(pos, vec3(0.15, 0.4, 0), vec3(0.05, 0.1, 0.04), bevel), 0.05);\n    hit.dist = smin(hit.dist, BevelPrism(pos, vec3(-0.15, 0.4, 0), vec3(0.05, 0.1, 0.04), bevel), 0.05);\n    \n    //crystal\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.7, .05), bevel));\n    hit.dist = max(hit.dist, -BevelHex(pos, vec3(0.0), vec2(.45, .15), bevel));\n\n    //alchemy\n    float alchemyTime = Remap(-1., 1., 1.0, 3.0, sin(flakeTime * TAU * 2.));\n    hit.dist = smin(hit.dist, BevelPrism(pos, RotateZ(vecY(0.2), -alchemyTime), vec3(0.1, 0.12, 0.04), bevel), 0.1);\n    hit.dist = smin(hit.dist, BevelPrism(pos, RotateZ(vecX(0.2), -alchemyTime ), vec3(0.1, 0.12, 0.04), bevel), 0.1);\n    hit.dist = smin(hit.dist, BevelPrism(pos, RotateZ(vecY(-0.1), alchemyTime), vec3(0.1, 0.10, 0.04), bevel), 0.1);\n    hit.dist = smin(hit.dist, BevelPrism(pos, RotateZ(vecX(-0.1), alchemyTime), vec3(0.1, 0.10, 0.04), bevel), 0.1);\n    hit.dist = smin(hit.dist, BevelPrism(RotateY(pos, alchemyTime), vecY(0.5), vec3(0.1, 0.2, 0.04), bevel), 0.1);\n\n    float crystalDist = hit.dist;\n    \n    //use rotation dx\n    vec3 rotAxis = RotateZ(vecY(1.0), -radians(60. * (quadrant - 1.)));\n    vec3 rotatedPos = RotateAroundAxis(pos, rotAxis, radians(rotationAngleDx * pos.y * 5.5));\n     \n    vec3 flagOffset = vecY(0.4);\n    vec3 windPos = pos - flagOffset;\n    \n    vec3 straightPos = windPos;\n    \n    float angleY = 0.;\n    //fbm y rotation\n    angleY += 1./8.  * TAU * sin(windPos.y * 5.0 + flakeTime * 2. * TAU);\n    angleY += 1./16.  * TAU * sin(windPos.y * 10.0 + flakeTime * 4. * TAU);\n    angleY += 1./32.  * TAU * sin(windPos.y * 20.0 + flakeTime * 8. * TAU);\n    angleY *= 0.5; \n    \n     //add twirl\n    windPos = RotateY(windPos, angleY);\n        \n   \n    //add wind\n    windPos.x += 0.025 * sin(quadrant + windPos.y * 2. + flakeTime * 5. * TAU);\n    windPos.x += 0.012 * sin(quadrant + windPos.y * 4. + flakeTime * 10. * TAU);\n    windPos.x += 0.006 * sin(quadrant + windPos.y * 8. + flakeTime * 20. * TAU);\n\n    windPos.z += 0.025 * sin(quadrant + windPos.y * 2. + flakeTime * 5. * TAU);\n    windPos.z += 0.012 * sin(quadrant + windPos.y * 4. + flakeTime * 5. * TAU);\n    windPos.z += 0.006 * sin(quadrant + windPos.y * 8. + flakeTime * 10. * TAU);\n\n\n    //add texture\n    windPos.z += 0.002 * pow(abs(sin(windPos.y * 100.)), 2.5); \n    windPos.z += 0.002 * pow(abs(sin(windPos.x * 50.)), 2.5);  \n\n    windPos = mix(straightPos, windPos, smoothstep(0.5, 1.3, pos.y));\n\n             \n    float width = 0.1;\n    float len = 1.5;\n    hit.dist = min(hit.dist, sdBox(windPos - vecY(len / 2.), vec3(0.1, len / 2.1, 0.01))); \n    \n    //flag snowflakes\n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2.      ),  radians(45.)) - vecY(0.3), vec3(0.05, 0.4, 0.01))); \n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2.      ), -radians(45.)) - vecY(0.3), vec3(0.05, 0.4, 0.01))); \n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2. - 0.25),  radians(45.)) - vecY(0.3), vec3(0.05, 0.25, 0.01))); \n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2. - 0.25), -radians(45.)) - vecY(0.3), vec3(0.05, 0.25, 0.01))); \n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2. - 0.5),  radians(45.)) - vecY(0.2), vec3(0.025, 0.12, 0.01))); \n    hit.dist = min(hit.dist, sdBox(RotateZ(windPos - vecY(len / 2. - 0.5), -radians(45.)) - vecY(0.2), vec3(0.025, 0.12, 0.01))); \n\n     \n    //end of flag\n    hit.dist = min(hit.dist, sdPrism(windPos - vecY(len + 0.015) + vecX(0.05), 0.05, 0.05, 0.01)); \n    hit.dist = min(hit.dist, sdPrism(windPos - vecY(len + 0.015) - vecX(0.05), 0.05, 0.05, 0.01)); \n \n    bool hitCrystal =  hit.dist == crystalDist;\n    hit.hueShift = 0.45;// + ((abs(quadrant + .0) < 0.001) ? 0.1 : 0.0);\n    hit.materialID = hitCrystal ? MATERIAL_FLAKE : MATERIAL_CLOTH;\n\n    return hit;\n}\n\nRayPrimHit Crystal3(vec3 pos)\n{\n    float quadrant, xSign;\n    pos = AddSymmetryToPosMirrorX(pos, rotationAngle, quadrant, xSign);\n\n    RayPrimHit hit;\n    hit.materialID = MATERIAL_FLAKE;\n    hit.dist = 999999.;\n    vec2 bevel = vec2(0.7, 0.1);\n    \n    int recursionCount = 4;\n    float recursionPos = .45f;\n    float recursionSize = .5;\n    for(int i = 0; i < recursionCount; i++)\n    {\n        float x = float(i);\n        \n        vec3 p = pos - vecY(recursionPos);\n\n        p = AddSymmetryToPosMirrorX(p, 0.0, quadrant, xSign);\n        \n        //recursion offset\n        p = RotateZ(p, -0.5 + TAU * flakeTime * 0.5);\n\n        float smouss = 0.25;\n        \n        float prevDist = hit.dist;\n        \n        for(float j = -1.; j <= 1.; j++)\n        {\n            hit.dist = smin(hit.dist, BevelTriPrism(p, vec3(0.3 * j, 0.3 * j, 0.0), vec2(recursionSize, .07), bevel), smouss * recursionSize);\n            hit.dist = smin(hit.dist, BevelTriPrism(p, recursionSize * vec3( 0.3 + j, 0.3, 0.), vec2(0.5 * recursionSize, .05), bevel), smouss * recursionSize);\n            hit.dist = smin(hit.dist, BevelTriPrism(p, recursionSize * vec3(-0.3 + j, 0.3, 0.), vec2(0.5 * recursionSize, .05), bevel), smouss * recursionSize);\n\n\n            hit.dist = max(hit.dist, -BevelTriPrism(p, recursionSize * vec3(-0.3 + j, 0.4, 0.), vec2(0.5 * recursionSize, .15), bevel));\n            hit.dist = max(hit.dist, -BevelTriPrism(p, recursionSize * vec3( 0.3 + j, 0.4, 0.), vec2(0.5 * recursionSize, .15), bevel));            \n        }\n        \n        if(hit.dist < prevDist)\n        {\n            hit.hueShift = x * 0.13;\n        }\n    \n        recursionPos += recursionSize;\n        recursionSize *= 0.5;\n    }\n    \n    return hit;\n}\n\n\nRayPrimHit GetCrystal(vec3 pos, int id)\n{\n    switch(id)\n    {\n        case BASECRYSTAL: return CrystalBase(pos);\n        case 0: return Crystal0(pos);\n        case 1: return Crystal1(pos);\n        case 2: return Crystal2(pos);\n        case 3: return Crystal3(pos);\n\n    }\n    RayPrimHit hit;  \n    return hit;\n}\n\nfloat ApplyRotationAngleCurve(float t, float index)\n{ \n    return (easeInOutCubic(easeInOutCubic(t)) + index) * PI;\n}\n\nRayPrimHit DistanceFunction(vec3 pos)\n{\n    RayPrimHit hit; \n    \n    float duration = loopDuration * float(beatLoopPerFlake);\n    float speed = 1.0 / duration;\n    \n    rotationAxis = vecY(1.0);\n    float timeSpeed = iTime * speed;\n    \n    float fracRot = fract(timeSpeed);\n    flakeTime = fract(timeSpeed);\n    \n    \n    float floorIndex = floor(timeSpeed) - 1.;\n    \n    rotationAngle = ApplyRotationAngleCurve(flakeTime, floorIndex);\n    \n    //nice init angle\n    rotationAngle -= radians(22.5);\n    \n    //wave panning\n    float rotWavePanningAngle = sin(2. * flakeTime * TAU);\n    rotationAngle += radians(15.) * rotWavePanningAngle; \n\n    float dt = 0.01; \n    rotationAngleDx = (rotationAngle - ApplyRotationAngleCurve(flakeTime - dt, floorIndex)) / dt;\n  \n    float morphTime = iTime * speed - 0.5;\n    int crystalIDprev = int(mod(floor(morphTime), float(numberCrystal)));\n    int crystalIDnext = int(mod(floor(morphTime + 1.0), float(numberCrystal)));\n    float morphOffset = 0.4;\n\n    crystalIDprev = flakesOrder[crystalIDprev];\n    crystalIDnext = flakesOrder[crystalIDnext];\n    \n#ifdef MORPHING\n    RayPrimHit baseHit = GetCrystal(pos, BASECRYSTAL);\n    RayPrimHit crystalPrev = GetCrystal(pos, crystalIDprev);\n    RayPrimHit crystalNext = GetCrystal(pos, crystalIDnext);\n    RayPrimHit mixHit;\n    \n    float remapMorph = Remap(morphOffset, 1.0 - morphOffset, 0., 1., fract(morphTime)); \n    float crystalMix = remapMorph;\n\n    if(crystalMix < 0.5)\n    {\n        crystalMix = crystalMix * 2.0;\n        crystalMix = easeInCubic(crystalMix);\n        mixHit = MixPrimHit(crystalPrev, baseHit, crystalMix);  \n        \n        mixHit.crystalID0 = crystalIDprev;\n        mixHit.crystalID1 = BASECRYSTAL;\n    }\n    else\n    {\n        crystalMix = (crystalMix - 0.5) * 2.0;\n        crystalMix = easeOutCubic(crystalMix);\n        mixHit = MixPrimHit(baseHit, crystalNext, crystalMix);\n        \n        mixHit.crystalID0 = BASECRYSTAL;\n        mixHit.crystalID1 = crystalIDnext;\n    }\n       \n    mixHit.crystalMix = crystalMix;   \n#else\n    //testing individual flakes\n    RayPrimHit mixHit = GetCrystal(pos, DEBUG_CRYSTAL);\n    mixHit.crystalMix = 0.;\n    mixHit.crystalID0 = DEBUG_CRYSTAL;\n    mixHit.crystalID1 = DEBUG_CRYSTAL;\n#endif\n    \n    return mixHit;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    \n    float distX1 = DistanceFunction(p+h.xyy).dist;\n    float distX2 = DistanceFunction(p-h.xyy).dist;\n    \n    float distY1 = DistanceFunction(p+h.yxy).dist;\n    float distY2 = DistanceFunction(p-h.yxy).dist;\n    \n    float distZ1 = DistanceFunction(p+h.yyx).dist;\n    float distZ2 = DistanceFunction(p-h.yyx).dist;\n\n    return normalize( vec3(distX1 - distX2,\n                           distY1 - distX2,\n                           distZ1 - distZ2));\n}\n\n\nRayHit SetupRayHit(vec3 ro, vec3 rd, bool hasHit, float dist, vec3 normal, vec2 uv, int steps, RayPrimHit primHit)\n{\n    RayHit rayHit;\n    rayHit.hasHit = hasHit;\n    rayHit.hitPos = ro + rd * dist;\n    rayHit.dist = dist;\n    rayHit.normal = normal; \n    rayHit.reflDir = reflect(rd, rayHit.normal);\n    rayHit.reflPos = rayHit.hitPos + rayHit.reflDir * 0.01;\n    rayHit.uv = uv;\n    rayHit.steps = steps;\n    rayHit.primHit = primHit;\n\n    return rayHit;\n}\n\nRayHit Raymarch(vec3 ro, vec3 rd)\n{\n    float currentDist = 0.;\n    bool hasHit = false;\n    RayPrimHit primHit;\n    int i;\n    for(i = 0; i < 10000; i++)\n    {\n        vec3 pos = ro + rd * currentDist;\n        primHit = DistanceFunction(pos);\n        float dist = primHit.dist * FRACTIONAL_STEP;\n        currentDist += dist;\n      \n        if(dist < 0.0001)\n        {    \n            hasHit = true;\n            break;\n        }\n        else if(currentDist > 1000.0)\n        {\n            break;\n        }\n    }\n\n    vec3 normal = calcNormal(ro + rd * currentDist);\n    vec2 uv = vec2(0.0);\n    return SetupRayHit(ro, rd, hasHit, currentDist, normal, uv, i, primHit); \n}\n\nvec4 NormalColorWheel(float a, float frequency, float phase)\n{\n    float s = sin(a * frequency * TAU + phase);\n    float c = cos(a * frequency * TAU + phase);\n    vec2 col = vec2(s, c);\n    return vec4((col + 1.0) * 0.5, 1.0, 1.0);\n}\n\nvec4 StarShine(vec3 pos, float scale, float size, float rollAngle, float yawAngle)\n{\n    pos = RotateY(pos, -yawAngle * length(pos));\n    pos = RotateZ(pos, radians(rollAngle));\n    float cell = cellular(pos.xy * scale).x;\n    float shine = 0.8;\n    \n    float starSize = size;\n    float fadeDist = size * 35.;\n\n    if(cell < starSize)\n    {\n        return vec4(1.) * shine;\n    }\n    else if(cell < fadeDist)\n    {\n        float intensity = 1. - unlerp(cell, starSize, fadeDist);\n        intensity = pow(intensity, 5.);\n        return vec4(intensity) * shine * 0.15;\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 GetFlakeColor(in RayHit hit, vec3 viewDir, vec2 uv)\n{\n    vec3 localHitPos = RotateAroundAxis(hit.hitPos, rotationAxis, rotationAngle);\n    \n    vec3 lightDir = normalize(vec3(.6, -.3, .5));\n    \n    vec3 normal = hit.normal;\n    normal = normalize(mix(normal, RotateY(vecZ(1.), rotationAngle), hit.primHit.normalBlend));\n    \n    float l = saturate(dot(-normal, lightDir));\n    float h = saturate(dot(-normal, viewDir));\n\n\n    vec4 normalCol = vec4((-normal + 1.0) / 2.0, 1.0);\n    vec4 iridescent1 = NormalColorWheel(h, 1.0, 5.5);\n    vec4 iridescent2 = NormalColorWheel(l, 1.0, 4.5);\n    vec4 iridescent = mix(iridescent1, iridescent2, 0.5);\n    \n    vec3 shineDir1 = cheapNoise(localHitPos * 30., 1.0);\n    vec3 shineDir2 = cheapNoise(localHitPos * 15., 5.0);\n    vec3 shineDir = normalize(mix(shineDir1, shineDir2, 0.25));\n    float shine = saturate(dot(normalize(viewDir - lightDir), shineDir));\n    shine = Remap(0.98, 1.0, 0.0, 0.7, shine) * saturate(snoise(localHitPos * 10.));\n    \n#ifdef HD    \n    vec3 cloudDir = normalize(vec3(fbm4r_3x(localHitPos * 2.5, m3), fbm_4(localHitPos * 2.), 1.0));\n#else\n    vec3 cloudDir = normalize(vec3(cheapNoise(localHitPos * 2.5, 0.0).x, cheapNoise(localHitPos * 2., 25.).y, 1.0));\n#endif\n    \n    vec4 cloud = NormalColorWheel(dot(lightDir, cloudDir), 1.0, 2.0) * 0.2;\n\n    vec4 starShine = \n        StarShine(hit.hitPos, 5.1, 0.02, iTime * 1.0, 0.5) +  \n        StarShine(hit.hitPos, 7.1, 0.01, iTime * 1.5, 1.0);\n    \n\n    vec4 col = mix(normalCol, iridescent, 1.0) * 1.2;\n    vec4 finalCol = col + starShine + cloud + shine;\n    \n    finalCol = HueShift(finalCol, hit.primHit.hueShift);\n    \n    return finalCol;\n}\n\nvec4 GetClothColor(RayHit hit)\n{\n    vec3 lightDir = normalize(vec3(.6, -.3, .5));  \n    vec3 normal = hit.normal;\n    float l = Remap(0., 1.0, 0.3, 1.0, saturate(dot(-normal, lightDir)));\n\n    return vec4(1., 0., 0.0, 1.0) * l;\n}\n\nvec4 GetColor(in RayHit hit, vec3 viewDir, vec2 uv)\n{    \n    int materialID = hit.primHit.materialID;\n    switch(materialID)\n    {\n        case MATERIAL_FLAKE: return GetFlakeColor(hit, viewDir, uv);\n        case MATERIAL_CLOTH: return GetClothColor(hit);\n    }\n    return vec4(1.0);\n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\n\nvec4 FlowerPallet(float value)\n{\n    if(value > 0.66)\n        return GetCol(255, 172, 255);\n    else if(value > 0.33)\n        return GetCol(175, 255, 94);\n    return GetCol(102, 174, 255);\n}\n\nvec4 YellowRedGradient(float value)\n{\n    return mix(GetCol(245, 197, 66), GetCol(240, 53, 53), value);\n}\nvec4 DustColor(float value)\n{\n    vec3 v = RotateZ(vecX(1.0), value * 2. * PI);\n    v = normalize(vec3(v.x, v.y, 1.));\n    return vec4(v, 1.0);\n}\n\nvec4 GetCrystalBackgroundColor(int id, float value)\n{\n    switch(id)\n    {\n        case 0:\n           return DustColor(value);\n        case 1:\n            return FlowerPallet(value);\n        case 2:\n            return YellowRedGradient(value);\n        case 3:\n            return DustColor(value);\n        \n    }\n    return DustColor(value);\n}\n\nvec4 GetDustBackgroundColor(RayHit hit, float value)\n{\n    vec4 col1 = GetCrystalBackgroundColor(hit.primHit.crystalID0, value);\n    vec4 col2 = GetCrystalBackgroundColor(hit.primHit.crystalID1, value);\n    return mix(col1, col2, hit.primHit.crystalMix);\n}\n\nvec2 GetUVBackground(int id, vec2 uv)\n{\n    switch(id)\n    {\n        case 0:\n        case 1:\n        case 2:\n            return uv;\n            \n        case 3:\n            float unsued1, unsued2;\n            return AddSymmetryToPosMirrorX(vec3(uv.x, uv.y, 0.0), 0., unsued1, unsued2).xy;\n    }\n    return uv;\n}\n\nvec2 GetUVBackGround(RayHit hit, vec2 uv)\n{\n    vec2 uv1 = GetUVBackground(hit.primHit.crystalID0, uv);\n    vec2 uv2 = GetUVBackground(hit.primHit.crystalID1, uv);\n    return mix(uv1, uv2, hit.primHit.crystalMix);\n}\n\nvec4 Background(RayHit hit, vec2 uv)\n{    \n    uv = GetUVBackGround(hit, uv);\n    \n    vec4 sum = vec4(0.);\n    \n    int loopCount = 5;\n    \n    uv += 0.1 * vec2(\n        snoise(vec2(iTime * 0.2, 0.)),\n        snoise(vec2(25. + iTime * 0.2, 0.))\n    );\n\n    for(int i = 0; i < loopCount; i++)\n    {\n        vec2 mainCell;\n        float x = float(i);\n        float bokehSize = 10. - (x * 1.3);\n        \n        vec2 uv2 = uv - vec2(iTime * 0.33, iTime) * (0.12 - x * 0.01);\n        \n        //just super cool\n        uv2 += 0.05 * vec2(snoise(vec2(iTime * 0.2, x * 5.)), snoise(vec2(25. + iTime * 0.2, x * 5.)));\n        \n        float noiseValue = PeriodicalCellularNoise(uv2 * bokehSize + vec2(i * 25), 0.5, vec2(20.), 0.15, mainCell);\n        \n        float bokehBlur = 0.2 - (x * 0.04);\n        float bokehIntensity = 1. - smoothstep(0.0, bokehBlur, noiseValue);\n    \n        // bokehIntensity = pow(bokehIntensity, 1.5);\n        uint state = WangHash(uint(137. + abs(mainCell.x) * 133. + abs(mainCell.y) * 171.));     \n        \n        vec4 rgbBokeh = GetDustBackgroundColor(hit, NextFloat(state));\n        float intensityValue = NextFloat(state) * (float(loopCount) - x);\n        \n        float flashSin = sin(mainCell.x * 11. + mainCell.y * 13. + iTime * 5.);\n        flashSin = Remap(-1., 1., 0.2, 0.6, flashSin);\n        sum += flashSin * intensityValue * pow(bokehIntensity, 1.5) * mix(rgbBokeh, vec4(1.0), pow(bokehIntensity, 5.5));    \n    }\n    return sum;\n}\n\n\nvec4 SampleVolumetricBuffer(vec3 pos)\n{\n    vec3 bufferSize = vec3(64.); //must match Buffer A size's value\n\n    float x = Convert3DTo1D(pos,  bufferSize);\n    vec2 channelResolution = iChannelResolution[0].xy;\n    vec2 uv3D = Convert1DTo2D(x, channelResolution.xy) / channelResolution.xy; //must match buffer A resolution\n    vec4 sampleColor = vec4(texture(iChannel0, uv3D));\n    return sampleColor;\n}\n\nfloat VolumetricLight(vec3 ro, vec3 rd, float maxDist)\n{\n#ifndef VOLUMETRIC_LIGHT\n    return 0.;\n#endif\n\n    float sum = 0.;\n    vec3 lightPos = vec3(5.0, 5.0, 0.0);\n    for(int i = 0; i < VOLLIGHT_STEPS; i++)\n    {\n        vec3 pos = ro + rd * float(i) * VOLLIGHT_STEPSIZE;\n        vec3 lightDiff = lightPos - pos;\n        float lightDist = length(lightDiff);\n        vec3 lightDir = lightDiff / lightDist;\n        \n        RayHit shadowHit = Raymarch(pos, lightDir);    \n        bool hitIsValid = !shadowHit.hasHit;\n        \n        float lightBoost = 0.;\n\n        float volumetricnoise = Remap(0., 1.0, 0.5, 1.0, SampleVolumetricBuffer(32. + pos * 5.0).x);\n        \n        //todo animate?\n        float onBeat = 1.;\n        float onBeatGlow = (onBeat * 0.05);\n        sum += (hitIsValid ? 1. : 0.) * VOLLIGHT_STEPSIZE * (VOLLIGHT_DENSITY + lightBoost + onBeatGlow) * volumetricnoise;\n        \n    }\n    return sum;\n}\n\nvec4 RenderAtUv(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    vec3 ro, rd;\n    PerspectiveCam(camPos, camRot, uv, ro, rd);\n    \n    RayHit hit = Raymarch(ro, rd);\n    float volumetricLight = VolumetricLight(ro, rd, hit.dist);\n    if(hit.hasHit)\n    {\n        vec4 col = GetColor(hit, rd, uv) + volumetricLight;\n        return col;\n    }\n    else\n    {\n        vec4 col = Background(hit, uv) + volumetricLight;\n        col.a = 0.0;\n        return col;\n    }\n}\n\n#ifdef HD  \nvec4 RenderAtUvAntiAliasing(vec3 camPos, vec4 camRot, vec2 uv, vec2 fragCoord)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += RenderAtUv(camPos, camRot, uv);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 camPos = vec3(0., 0.0, -4.0);\n    vec4 camRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n#ifdef HD  \n    fragColor = RenderAtUvAntiAliasing(camPos, camRot, uv, fragCoord);  \n#else\n    fragColor = RenderAtUv(camPos, camRot, uv); \n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size = vec3(64.);\n    float zoom = 1.0 / 16.;\n    \n    float i = Convert2DTo1D(fragCoord, iResolution.xy);\n    vec3 pos = Convert1DTo3D(i, size.xyz);\n    \n    float noise = PeriodicalCellularNoise(pos, zoom, size);\n    fragColor = vec4(1. - noise, 0, 0 ,0);\n}","name":"Buffer B","description":"","type":"buffer"}]}