{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// height map\nfloat voxel( vec3 pos ) {\n\tpos = floor( pos );\n\tfloat density = textureLod( iChannel0, pos.xz / 2048.0, 0.0 ).x;\n\treturn step( pos.y, floor( density * 32.0 ) );\n}\n\n// improvement based on fb39ca4's implementation to remove most of branches :\n// https://www.shadertoy.com/view/4dX3zl\n// min | x < y | y < z | z < x\n//  x  |   1   |   -   |   0  \n//  y  |   0   |   1   |   -  \n//  z  |   -   |   0   |   1  \nfloat ray_vs_world( vec3 pos, vec3 dir, out vec3 mask, out vec3 center ) {\n\t// grid space\n\tvec3 grid = floor( pos );\n\tvec3 grid_step = sign( dir );\n\tvec3 corner = max( grid_step, vec3( 0.0 ) );\n\t\n\t// ray space\n\tvec3 inv = vec3( 1.0 ) / dir;\n\tvec3 ratio = ( grid + corner - pos ) * inv;\n\tvec3 ratio_step = grid_step * inv;\n\t\n\t// dda\n\tfloat hit = -1.0;\n\tfor ( int i = 0; i < 512; i++ ) {\n\t\tif ( voxel( grid ) > 0.5 ) {\n\t\t\thit = 1.0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvec3 cp = step( ratio, ratio.yzx );\n\n\t\tmask = cp * ( vec3( 1.0 ) - cp.zxy );\n\t\t\n\t\tgrid  += grid_step  * mask;\t\t\n\t\tratio += ratio_step * mask;\n\t}\n\t\n\tcenter = grid + vec3( 0.5 );\n\treturn dot( ratio - ratio_step, mask ) * hit;\n}\n\n// improvement based on iq's implementation to remove lots of redundant texture accesses :\n// https://www.shadertoy.com/view/4dfGzs\nvoid occlusion( vec3 v, vec3 n, out vec4 side, out vec4 corner ) {\n\tvec3 s = n.yzx;\n\tvec3 t = n.zxy;\n\n\tside = vec4 (\n\t\tvoxel( v - s ),\n\t\tvoxel( v + s ),\n\t\tvoxel( v - t ),\n\t\tvoxel( v + t )\n\t);\n\t\n\tcorner = vec4 (\n\t\tvoxel( v - s - t ),\n\t\tvoxel( v + s - t ),\n\t\tvoxel( v - s + t ),\n\t\tvoxel( v + s + t )\n\t);\n}\n\nfloat filterf( vec4 side, vec4 corner, vec2 tc ) {\n\tvec4 v = side.xyxy + side.zzww + corner;\n\n\treturn mix( mix( v.x, v.y, tc.y ), mix( v.z, v.w, tc.y ), tc.x ) * 0.25;\n}\n\nfloat ao( vec3 v, vec3 n, vec2 tc ) {\n\tvec4 side, corner;\n\t\n\tocclusion( v + n, abs( n ), side, corner );\n\t\n\treturn 1.0 - filterf( side, corner, tc );\n}\n\nfloat edge( vec3 v, vec3 n, vec2 tc ) {\n\tfloat scale = 1.0 / 12.0;\n\ttc = fract( tc / scale );\n\tn *= scale;\n\n\tv += abs( n.yzx ) * ( -tc.y + 0.5 );\n\tv += abs( n.zxy ) * ( -tc.x + 0.5 );\n\n\tvec4 side_l, side_h, corner_l, corner_h;\n\t\t\n\tocclusion( v - n, abs( n ), side_l, corner_l );\n\tocclusion( v + n, abs( n ), side_h, corner_h );\n\n\treturn 1.0 - filterf(\n\t\tvec4( 1.0 ) -   side_l * ( vec4( 1.0 ) -   side_h ),\n\t\tvec4( 1.0 ) - corner_l * ( vec4( 1.0 ) - corner_h ),\n\t\ttc\n\t);\n}\n\nfloat grid( vec2 tc ) {\n\ttc = abs( tc - vec2( 0.5 ) );\n\n\treturn 1.0 - pow( max( tc.x, tc.y ) * 1.6, 10.0 );\n}\n\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 ray_dir_spherical( float fov, vec2 size, vec2 pos ) {\n\tvec2 angle = ( pos - vec2( 0.5 ) * size ) * ( fov / size.y * DEG_TO_RAD );\n\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn normalize( vec3( c.y * s.x, s.y, -c.y * c.x ) );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tvec3 final = vec3( 0.0 );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos = vec3( 100.0, 110.0, 150.0 );\n\t\tvec3 light_color = vec3( 1.0 );\n\t\tvec3 vl = normalize( light_pos - v );\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfinal += light_color * diffuse;\n\t}\n\n\treturn final;\n}\n\nfloat fog_uniform( vec3 o, vec3 dir, float d ) {\n    float density = 0.01;\n    return 1.0 - exp( -d * density );\n}\n\nfloat b = 0.04;\nfloat fog_density( vec3 p ) {\n    return exp( -p.y * b );\n}\n\nfloat fog_exp( vec3 o, vec3 dir, float d ) {\n   float optic = ( fog_density( o ) - fog_density( o + dir * d ) ) / ( dir.y * b );\n   return optic;1.0 - exp( -optic * 0.08 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 60.0, iResolution.xy, fragCoord.xy );//_spherical\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 180.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( -DEG_TO_RAD * 34.0, iTime * 0.1 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\tdir = normalize( dir );\n\t\n\tvec3 fog_color = vec3( 0.4, 0.6, 0.8 );\n\n    // grid traversal\n\tvec3 mask;\n\tvec3 center;\n\tfloat depth = ray_vs_world( eye, dir, mask, center );\n    if ( depth < 0.0 ) {\n        fragColor = vec4( fog_color, 1.0 );\n        return;\n    }\n    \n\tvec3 p = eye + dir * depth;\n\tvec3 n = -mask * sign( dir );\n\n\tvec2 tc =\n\t\t( fract( p.yz ) * mask.x ) +\n\t\t( fract( p.zx ) * mask.y ) +\n\t\t( fract( p.xy ) * mask.z );\n\t\n\t// ambient occlusion\n\tfloat k_ao = ao( center, n, tc );\n\t\n\t// grid\n\tfloat k_grid = grid( tc );\n\t\n\t// edge\n\tfloat k_edge = edge( p, n, tc );\n\t\n\t// color\n\tvec3 color = shading( p, n, eye ) * (\n\t\tk_ao\n\t\t//k_grid *\n\t\t//k_edge * k_edge\n\t\t);\n    \n    float att = fog_exp( eye, dir, depth );\n\t\n    \n\tfragColor = vec4( mix( color, fog_color, att ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdBGRm","date":"1385208244","viewed":6128,"name":"MagicaVoxel","username":"gltracy","description":"Try to guess the methods used in iq's 'Voxel Edge' demo. Use 3D grid traversal algorithm to do ray tracing, bilinear interpolation within grids to smooth AO and edges, and 'pow' function to squeeze line width.","likes":88,"published":1,"flags":0,"usePreview":1,"tags":["shadow","voxel","edge","ao"],"hasliked":0,"parentid":"","parentname":""}}