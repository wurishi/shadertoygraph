{"ver":"0.1","info":{"id":"wdVcRW","date":"1602613652","viewed":77,"name":"accela","username":"adr","description":"mouse to move camera","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","anime","lain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 glow = texture(iChannel1, uv);\n    \n    const vec3 glowColor = vec3(0.4, 0.38, 0.7);\n    fragColor = vec4(texture(iChannel0, uv).xyz + glow.xyz * glowColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CLIP_NEAR 0.1\n#define CLIP_FAR 40.0\n#define STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n#define PI 3.14159\n#define BACKGROUND 0.0\n#define BLACK 1.0\n#define ACCENT 2.0\n#define INNER 3.0\n#define GLOW 4.0\n#define LIGHT 5.0\n#define BLACKPHONG 6.0\n#define SPEED 0.3\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 bend(vec3 p, float k) {\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(p.x, m*p.yz);\n    return q;\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nmat4 rotateX(float theta) {\n    float c = cos(-theta);\n    float s = sin(-theta);\n\n    return mat4(\n        vec4( 1, 0, 0, 0),\n        vec4( 0, c, s, 0),\n        vec4( 0,-s, c, 0),\n        vec4( 0, 0, 0, 1)\n    );\n}\nmat4 rotateY(float theta) {\n    float c = cos(-theta);\n    float s = sin(-theta);\n\n    return mat4(\n        vec4( c, 0, s, 0),\n        vec4( 0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4( 0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(-theta);\n    float s = sin(-theta);\n\n    return mat4(\n        vec4( c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4( 0, 0, 1, 0),\n        vec4( 0, 0, 0, 1)\n    );\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat accelaFrontPhong(vec3 p) {\n    float d = sdCapsule(p, vec3(0.0,0.0,-0.2), vec3(0.0,0.0,-0.15), 0.27);\n    d = differenceSDF(d, sdBox(p + vec3(0.0, 0.0, -0.3), vec3(0.5,0.5, 0.37)));\n    d = differenceSDF(d, sdBox(p + vec3(0.0, 0.0, 0.14), vec3(0.5,0.5, 0.008)));\n    \n    float theta = 0.0;\n    for (int i = 0; i < 3; ++i) {\n    \tvec3 transform = (rotateZ(theta) * vec4(p, 1.0)).xyz;\n    \td = differenceSDF(d,\n        \tsdBox(transform, vec3(0.008,0.5,1.0)));\n        theta += PI / 3.0;\n    }\n    \n    theta = PI / 6.0;\n    for (int i = 0; i < 6; ++i) {\n    \tvec3 translate = vec3(sin(theta), - cos(theta), 2.2) * 0.182;\n    \td = differenceSDF(d,\n        \tsdSphere(vec3(1.0, 1.0, 0.6) * (p + translate), 0.012));\n        theta += PI / 3.0;\n    }\n    return d;\n}\n\nfloat accelaFrontStandard(vec3 p) {\n    float d = sdCappedCylinder(vec3(p.x, p.y, p.z - 0.02), 0.03, 0.22);\n    \n    float theta = 0.0;\n    for (int i = 0; i < 3; ++i) {\n    \tvec3 transform = (rotateZ(theta) * vec4(p, 1.0)).xyz;\n    \td = differenceSDF(d,\n        \tsdBox(transform, vec3(0.008,0.5,1.0)));\n        theta += PI / 3.0;\n    }\n    d = unionSDF(d, sdCappedCylinder(p, 0.2, 0.1));\n    return d;\n}\n\n\nfloat accelaProp(vec3 p, float theta) {\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * 0.21;\n    vec3 conePoint = (rotateZ(theta) * vec4(p + translate, 1.0)).xyz;\n    \n    float spike = 1.495;\n    return sdCone(conePoint, vec2(sin(spike), cos(spike)), 0.25);\n}\n\nfloat accelaRudder(vec3 p, float theta) {\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * 0.07;\n    vec3 transform = (rotateZ(theta) * vec4(p + translate, 1.0)).xyz;\n    \n    float spike = 1.495;\n    return sdBox(transform, vec3(0.001,0.02,0.023));\n}\n\nfloat accelaRear(vec3 p) {\n    float rear_body = unionSDF(\n        sdCappedCylinder(vec3(p.x, p.y, p.z - 0.15), 0.08, 0.25),\n        sdCappedCylinder(vec3(p.x, p.y, p.z - 0.32), 0.07, 0.22));\n    \n    float prop_blades = CLIP_FAR;\n\tvec3 prop_pos = vec3(p.x, p.y, p.z - 0.42);\n    float theta = 0.0;\n    for (int i = 0; i < 6; ++i) {\n    \tprop_blades = unionSDF(prop_blades, accelaProp(prop_pos, theta));\n        theta += PI / 3.0;\n    }\n    \n    float prop = unionSDF(\n        prop_blades,\n        sdCappedCylinder(prop_pos, 0.03, 0.07));\n    \n\tvec3 tail_pos = vec3(p.x, p.y, p.z - 0.47);\n    float tail_cover = differenceSDF(\n        sdCappedCylinder(tail_pos, 0.028, 0.09),\n        sdCappedCylinder(tail_pos, 0.04, 0.08));\n    const float spike = 1.495;\n    float tail = differenceSDF(\n        sdCone((rotateX(PI / 2.0) * vec4(tail_pos + vec3(0.0,0.0,-0.67), 1.0)).xyz, vec2(sin(spike), cos(spike)), 0.72),\n        sdCappedCylinder(tail_pos, 0.08, 0.035));\n    tail = intersectSDF(\n        tail,\n        sdCappedCylinder(tail_pos, 0.06, 0.1));\n    theta = PI / 6.0;\n    for (int i = 0; i < 6; ++i) {\n    \ttail = unionSDF(tail, accelaRudder(tail_pos, theta));\n        theta += PI / 3.0;\n    }\n        \n    \n    float d = unionSDF(rear_body, prop);\n    d = unionSDF(d, tail_cover);\n    d = unionSDF(d, tail);\n    return d;\n}\n\nfloat accelaRib(vec3 p, float theta) {\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * 0.43;\n    vec3 transform = (rotateZ(theta) * vec4(p + translate, 1.0)).xyz;\n    return sdCappedCylinder(bend(transform, 1.25), 0.45, 0.04);\n}\n\nfloat accelaCage(vec3 p) {\n    float d = CLIP_FAR;\n    float theta = PI / 6.0;\n    for (int i = 0; i < 6; ++i) {\n    \td = unionSDF(d, accelaRib(p + vec3(0.0, 0.0, 0.22), theta));\n        theta += PI / 3.0;\n    }\n    return d;\n}\n\nfloat accelaInner(vec3 p) {\n    return unionSDF(\n        sdCappedCylinder(p + vec3(0.0, 0.0, 0.25), 0.32, 0.24),\n        sdCappedCylinder(p + vec3(0.0, 0.0, -0.22), 0.1, 0.21));\n}\n\nfloat accelaLight(vec3 p, vec3 offset, float theta, float scale) {\n    theta = 2.0 * PI * texture(iChannel0, vec2(offset.z + theta, offset.z + theta)).x;\n    theta += sin(iTime * (offset.z + theta) / PI);\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * scale;\n    return sdSphere(p + translate + offset, 0.02);\n}\n\nfloat accelaGlow(vec3 p, vec3 offset, float theta, float scale) {\n    theta = 2.0 * PI * texture(iChannel0, vec2(offset.z + theta, offset.z + theta)).x;\n    theta += sin(iTime * (offset.z + theta) / PI);\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * scale;\n    return sdSphere(p + translate + offset, 0.035);\n}\n\nfloat accelaBody(vec3 p) {\n    return sdCappedCylinder(p, 0.05, 0.25);\n}\n\nfloat accelaCone(vec3 p, float theta) {\n    vec3 translate = vec3(sin(theta), - cos(theta), 0.0) * 0.54;\n    vec3 conePoint = (rotateZ(theta) * vec4(p + translate, 1.0)).xyz;\n    \n    const float spike = 1.495;\n    return sdCone(conePoint, vec2(sin(spike), cos(spike)), 0.4);\n}\n\nvec3 accela(vec3 p) {\n    float dBlack = accelaRear(p);\n    vec3 offset = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 5; ++i) {    \n    \tfloat theta = 0.0;\n    \tdBlack = unionSDF(dBlack, accelaBody(p + offset));\n    \tfor (int i = 0; i < 6; ++i) {\n        \tdBlack = unionSDF(dBlack, accelaCone(p + offset, theta));\n        \ttheta += PI / 3.0;\n        }\n        \n        offset.z += 0.118;\n    }\n    dBlack = unionSDF(dBlack, accelaBody(p + offset));\n    offset.z += 0.118;\n    dBlack = unionSDF(dBlack, accelaFrontStandard(p + offset));\n    float dBlackPhong = unionSDF(dBlack, accelaFrontPhong(p + offset));\n    \n    float dCage = accelaCage(p);\n    \n    float dInner = accelaInner(p);\n    \n    float dLight = CLIP_FAR;\n    float dGlow = CLIP_FAR;\n\n\toffset = vec3(0.0, 0.0, -0.059);\n    for (int i = 0; i < 6; ++i) {       \n    \tfloat theta = 0.0;\n    \tfor (int i = 0; i < 6; ++i) {\n        \tdGlow = unionSDF(dGlow, accelaGlow(p, offset, theta, 0.25));\n        \tdLight = unionSDF(dLight, accelaLight(p, offset, theta, 0.23));\n        \ttheta += PI / 3.0;\n        }\n        offset.z += 0.118;\n    }\n\toffset = vec3(0.0, 0.0, -0.24);   \n    float theta = 0.0;\n    for (int i = 0; i < 6; ++i) {\n        dGlow = unionSDF(dGlow, accelaGlow(p, offset, theta, 0.22));\n        dLight = unionSDF(dLight, accelaLight(p, offset, theta, 0.2));\n        theta += PI / 3.0;\n    }\n    float d = CLIP_FAR;\n    float material = BACKGROUND;\n    float glow = 0.0;\n    if (dBlack < d) {\n        d = dBlack;\n        material = BLACK;\n    }\n    if (dBlackPhong < d) {\n        d = dBlackPhong;\n        material = BLACKPHONG;\n    }\n    if (dCage < d) {\n        d = dCage;\n        material = ACCENT;\n    }\n    if (dInner < d) {\n        d = dInner;\n        material = INNER;\n    }\n    if (dLight < d) {\n        material = LIGHT;\n    }\n    if (dGlow < d) {\n        glow = dGlow;\n    }\n    return vec3(d, material, glow);\n}\n        \nvec3 scene(vec3 p) {\n    return accela((rotateZ(iTime * SPEED) * vec4(p, 1.0)).xyz);\n}\n\n// followed great tutorial https://www.shadertoy.com/view/XlBGDW\nvec4 raymarch(vec3 p, vec3 direction) {\n\tfloat dist = 0.0;\n\tfloat lastResult = 1e10;\n    vec3 result;\n    float edge = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        result = scene(p + direction * dist);\n        \n        // from https://www.shadertoy.com/view/MsB3W1\n\t\tif (lastResult < 0.005 && result.x > lastResult + 0.001) {\n\t\t\tedge = 1.0;\n\t\t\t// Also should put a break here, but it's not working with GL ES...\n\t\t}\n        \n        if (result.x < EPSILON) { break; }\n        dist += result.x * DISTANCE_BIAS;\n        if (dist > CLIP_FAR) { break; }\n\t\tif (result.x < lastResult) lastResult = result.x;\n    }\n    return vec4(dist, result.y, edge, result.z);\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\t//vec3 f = normalize(center - eye);\n    vec3 f = normalize(eye - center);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 offset = vec3(0.0, 0.0,  iTime);\n    vec3 offset = vec3( 0.0, 0.0, -0.4);\n    vec3 eyeOffset = vec3( 0.0, 0.0, -1.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 2.5));    \n    \n    vec3 eye = vec3(\n        1.5 - 3.0 * sin(PI * iMouse.x / iResolution.x) + offset.x,\n        1.0 - 2.0 * iMouse.y / iResolution.y + offset.y,\n        1.5 - 3.0 * cos(PI * iMouse.x / iResolution.x) + eyeOffset.z);\n    \n    mat4 viewToWorld = viewMatrix(eye, offset, vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    direction = worldDir;\n    vec4 result = raymarch(eye, direction);\n    \n    vec3 intersection = eye + direction * result.x;\n    vec3 norm = normal(intersection, 0.0001);\n    \n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(lightDir, norm);\n    vec3 lightColor = vec3(1.4, 1.2, 0.9) * 1.6;\n    vec3 ambientColor = vec3(0.2, 0.45, 0.6);\n    \n    //https://www.shadertoy.com/view/XlXGDj\n    vec3 h = normalize(eye + lightDir);\n    \n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == BLACK)\n    {\n        diffuse = diffuse * 0.5 + 0.5;\n        diffuse *= 0.7;\n        diffuse -= 0.5;\n        materialColor = vec3(0.1, 0.1, 0.1);\n    }\n    if(result.y == BLACKPHONG)\n    {\n        diffuse = diffuse * 0.5 + 0.5;\n        diffuse *= 0.7;\n    \tfloat spec = pow(clamp(dot(h, norm), 0.0, 1.0), 128.0);\n        diffuse += floor(spec + 0.5) - 0.5;\n        materialColor = vec3(0.1, 0.1, 0.1);\n    }\n    if(result.y == ACCENT)\n    {\n        diffuse = diffuse * 0.5 + 0.5;\n        diffuse *= 0.7;\n    \tfloat spec = pow(clamp(dot(h, norm), 0.0, 1.0), 2.0);\n        diffuse += floor(spec + 0.5) - 0.5;\n    \tambientColor = vec3(0.2, 0.45, 0.6);\n        materialColor = vec3(0.1, 0.1, 0.1);\n    }\n    if(result.y == INNER)\n    {\n        diffuse = 1.0;\n       \tmaterialColor = mix(vec3(0.43, 0.1, 0.1), vec3(0.55, 0.1, 0.1), sin(iTime));\n    }\n        \n    if(result.y == LIGHT)\n    {\n        diffuse = 1.0;\n       \tmaterialColor = vec3(0.2, 0.3, 0.5);\n    }\n    \n    \n    if (result.w != 0.0 && result.z != 0.0) {\n        materialColor = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    vec3 diffuseLit = materialColor * (diffuse * lightColor);\n    vec3 color = diffuseLit;\n    if (result.x > (CLIP_FAR - 1.0)) { color = vec3(0.8,0.8,0.8); }\n    color = mix(color, vec3(0.0, 0.0, 0.0), result.z);\n    float addGlow = 0.0;\n    if(result.w != 0.0)\n    {\n\t\tcolor = mix(color, vec3(0.4, 0.38, 0.7), 0.15);\n        addGlow = 0.5;\n        if (result.y == INNER && result.z == 0.0) {\n\t\t\tcolor = mix(color, vec3(0.4, 0.38, 0.7), 0.6);\n        \taddGlow = 1.0;\n        }\n    }\n    fragColor = vec4(color, addGlow);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 sampleDist = vec2(3.0,3.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 dist = sampleDist/iResolution.xy;\n   \tfloat glow;\n    for(int x = -1; x <= 1; x++)\n    {\n    \tfor(int y = -1; y <= 1; y++)\n        {\n\t\t\tglow += texture(iChannel0, uv + vec2(x,y)*dist).w;\n        }\n    }\n        \n    glow /= 5.0;\n\tfragColor = vec4(0.0, 0.0, 0.0, glow);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 sampleDist = vec2(6.0,6.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 dist = sampleDist/iResolution.xy;\n   \n    float glow;\n    \n    for(int x = -1; x <= 1; x++)\n    {\n    \tfor(int y = -1; y <= 1; y++)\n        {\n\t\t\tglow += texture(iChannel0, uv + vec2(x,y)*dist).w;\n        }\n    }\n        \n    glow /= 10.0;\n    \n\tfragColor = vec4(glow, glow, glow, glow);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Bloom Blur Pass1\nvec2 sampleDist = vec2(3.0,3.0);\n// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl/\n// from http://www.java-gaming.org/index.php?topic=35123.0\nvec4 cubic(float v){\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\nvec4 textureBicubic(vec2 texCoords){\n\n   vec2 texSize = vec2(iResolution);\n   vec2 invTexSize = 1.0 / texSize;\n\n   texCoords = texCoords * texSize - 0.5;\n\n\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture(iChannel0, offset.xz);\n    vec4 sample1 = texture(iChannel0, offset.yz);\n    vec4 sample2 = texture(iChannel0, offset.xw);\n    vec4 sample3 = texture(iChannel0, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 dist = sampleDist/iResolution.xy;\n    vec4 glow = textureBicubic(uv);\n\tfragColor = glow;\n}","name":"Buffer D","description":"","type":"buffer"}]}