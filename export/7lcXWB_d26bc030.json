{"ver":"0.1","info":{"id":"7lcXWB","date":"1645276589","viewed":361,"name":"[Storm in a glass]","username":"Langwedocjusz","description":"It's a storm in a glass. \nI feel like physical IOR deforms the shape of the lightning too much, but on the other hand using a smaller value makes the cloud look like it's in the foreground. Still not sure what to do about it >_<","likes":18,"published":1,"flags":32,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemap(vec3 x) {\n    float a = 2.51 + 0.5;\n    float b = 0.03 - 0.0;\n    float c = 2.43 + 0.0;\n    float d = 0.59 + 0.0;\n    float e = 0.14 + 0.5;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Bloom code from this great shader by Maurogik: https://www.shadertoy.com/view/Wtc3W2 \nvec3 doBloom(vec2 uv) {\n    const float kGoldenRatio = 1.618;\n    const float kGoldenRatioConjugate = 0.618;\n    const vec2 oz = vec2(1.0, 0.0);\n    const float we = 0.6;\n    \n    float totalWeight = 0.0;\n    vec3 bloom = vec3(0.0);\n\n    vec2 subPixelJitter = fract(hash22(uv*iResolution.xy)\n                        + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n    float range = 2.0;\n    //Super sample low mips to get less blocky bloom\n    for(float xo = -range; xo < range + 0.1; xo += 0.5)\n    {\n        for(float yo = -range; yo < range + 0.1; yo += 0.5)\n        {\n            vec2 vo = vec2(xo, yo);\n            float weight = (range*range*2.0) - dot(vo, vo);\n            vo += 0.5 * (subPixelJitter);\n            vec2 off = vo*(0.5/range)/iResolution.xy;\n            \n            if(weight > 0.0)\n            {\n                bloom += we  * weight * textureLod(iChannel0, uv + off*exp2(4.0), 4.0).rgb;\n                bloom += we  * weight * textureLod(iChannel0, uv + off*exp2(5.0), 5.0).rgb;\n                bloom += we  * weight * textureLod(iChannel0, uv + off*exp2(6.0), 6.0).rgb;\n            }\n            totalWeight += weight;\n        }\n    }\n\n    bloom.rgb /= totalWeight;\n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n      \n\tvec3 color = textureLod(iChannel0, uv, 0.0).rgb;\n    \n    vec3 bloom = doBloom(uv);\n    color += 0.025 * pow(bloom, vec3(2.0));\n        \n    color = tonemap(color);\n    color.b *= 1.05;\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MARCH_STEPS 64\n#define MARCH_MAX_DIST 4.0\n#define MARCH_MIN_DIST 1e-6\n\n#define VOLUME_MARCH_STEPS 20\n#define VOLUME_SHADOWING_STEPS 10\n\n#define IOR 1.45\n#define PI 3.14159265\n\nfloat sdfSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdfCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat MapGlass(vec3 point) {\n    vec3 t = vec3(0.0, -1.0, 0.0);\n    float sd = sdfCylinder(point, 1.0, 1.0);\n    sd = max(sd, -sdfCylinder(point+0.05*t, 0.96, 1.0));\n    \n    float arg = atan(point.x/point.z);\n    sd += 0.001 * sin(60.0*arg);\n    \n    return sd;\n}\n\nfloat GlassMarch(vec3 org, vec3 dir, bool inside) {\n    float total_dist = 0.0;\n    vec3 point = org;\n    float orientation = 2.0*float(!inside)-1.0;\n    \n    for (int i=0; i<MARCH_STEPS; i++) {\n        float sd = orientation*MapGlass(point);\n        if (sd < MARCH_MIN_DIST || total_dist >= MARCH_MAX_DIST)\n            break;\n        point += sd * dir;\n        total_dist += sd;\n    }\n    \n    return total_dist;\n}\n\nvec3 GlassGradient(vec3 point) {\n    vec2 h = vec2(0.0, 0.001);\n    return normalize(vec3(\n        MapGlass(point + h.yxx) - MapGlass(point - h.yxx),\n        MapGlass(point + h.xyx) - MapGlass(point - h.xyx),\n        MapGlass(point + h.xxy) - MapGlass(point - h.xxy)\n    ));\n}\n\nstruct Ray{\n    vec3 org, dir;\n};\n\nvoid RefractThroughVolume(vec3 point, vec3 dir, inout Ray ray, inout bool reflected) {\n    const float offset_factor = 5.0;\n    vec3 dir_out = dir, point_out = point;\n    \n    vec3 norm = GlassGradient(point);\n        \n    dir = refract(dir, norm, 1.0/IOR);\n    point = point - offset_factor*MARCH_MIN_DIST*norm;\n        \n    float dist = GlassMarch(point, dir, true);\n    dir_out = dir;\n        \n    if (dist < MARCH_MAX_DIST) {\n        point_out = point + dist * dir;\n        norm = GlassGradient(point_out);\n        dir_out = refract(dir, -norm, IOR);\n        \n        if (dot(dir_out, dir_out) < 1e-7) {\n            dir_out = reflect(dir, -norm);\n            reflected = true;\n        }\n        \n        point_out = point_out\n                  + offset_factor*MARCH_MIN_DIST*norm;\n    }\n    \n    ray.org = point_out;\n    ray.dir = dir_out;\n}\n\n//From method 1 in https://www.shadertoy.com/view/XslGRr\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\n//https://iquilezles.org/articles/fbm\nfloat fbm(in vec3 x) {\n    const float H = 1.0;\n    const int num_octaves = 5;\n    \n    float G = exp2(-H);\n    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    \n    vec3 flow = 0.05*iTime*vec3(-1.0, 0.4, 1.0);\n    \n    for(int i=0; i<num_octaves; i++) {\n        t += (i>2) ? a*noise(f*(x-flow)): a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    \n    return t;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat DensityMap(vec3 point) {\n    vec3 t = vec3(0.0, 1.0, 0.0);\n    vec3 q = point * vec3(1.0, 3.0, 1.0);\n    vec3 p = point * vec3(1.0, 1.5, 1.0);\n    \n    float sd = sdfSphere(q-2.3*t, 0.85);\n    sd = smin(sd, sdfSphere(p-0.75*t-0.1*t.yxx, 0.7), 0.1);\n    \n    sd += 0.4*fbm(1.0*point);\n    return sd;\n}\n\nfloat NormalizedDensity(vec3 point) {   \n    float sd = DensityMap(point);\n    bool inside = sd < 0.0;\n    return inside ? min(-sd, 1.0) : 0.0;\n}\n\nfloat DensityMarch(vec3 org, vec3 dir) {\n    float total_dist = 0.0;\n    vec3 point = org;\n    \n    for (int i=0; i<MARCH_STEPS/2; i++) {\n        float sd = DensityMap(point);\n        if (sd < MARCH_MIN_DIST || total_dist >= MARCH_MAX_DIST)\n            break;\n        point += sd * dir;\n        total_dist += sd;\n    }\n    \n    return total_dist;\n}\n\nfloat BeerLambert(float dist, float absorbance) {\n    return exp(-absorbance*dist);\n}\n\nvec3 VolumetricMarch(vec3 org, vec3 dir, float opaque_depth, inout float visibility) {\n    const float albedo = 0.95, absorbance = 20.0;\n    const vec3 ambient = vec3(0.25);\n    \n    vec3 color = vec3(0.0);\n    visibility = 1.0;\n    \n    float volume_depth = DensityMarch(org, dir);\n    if (volume_depth >= MARCH_MAX_DIST) return color;\n    volume_depth -= 0.2;\n    float max_depth = 3.0;\n    float step_size = (max_depth - volume_depth)/float(VOLUME_MARCH_STEPS);\n    \n    for(int i = 0; i < VOLUME_MARCH_STEPS; i++) {\n        volume_depth += step_size;\n        \n        if(volume_depth > opaque_depth) break;\n\t\n        vec3 pos = org + volume_depth*dir;\n        bool inVolume = DensityMap(pos) < 0.0f;\n        \n        if(inVolume) {\n            float prev_visiblity = visibility;\n            visibility *= BeerLambert(step_size, NormalizedDensity(pos)*absorbance);\n            \n            float absorption = prev_visiblity - visibility;\n            \n            //Lighting:\n            vec3 light_dir = normalize(vec3(1.0, 1.0, -1.0));\n            vec3 light_col = vec3(1.0);\n                \n            float light_vis = 1.0;\n            float ldist = 0.0, light_dist = 1.0;\n            float lstep_size = light_dist/float(VOLUME_SHADOWING_STEPS);\n            \n            //Self shadowing:\n            for (int k=0; k<VOLUME_SHADOWING_STEPS; k++) {\n                ldist += lstep_size;\n                if (ldist > MARCH_MAX_DIST) break;\n                \n                vec3 lpos = pos + ldist * light_dir;\n                if (DensityMap(lpos) < 0.0 )\n                    light_vis *= BeerLambert(step_size, NormalizedDensity(lpos)*absorbance);\n            }\n                \n            color += absorption * albedo * light_vis * light_col;\n            color += absorption * albedo * ambient;\n        }\n    }\n    \n    return color;\n}\n\nfloat LightningMap(vec3 point) {\n    const float r = 0.01, top = 0.2;\n    float h = 0.5;\n    vec3 offset = h*vec3(0.0, -1.0, 0.0);\n    offset += 0.5*noise(vec3(floor(iTime/PI))) * vec3(1.0, 0.0, 0.0);\n    vec3 displacement = 0.3 * vec3(1.0, 0.0, 0.0) * sin(3.5*point.y);\n    displacement += 0.05 * vec3(1.0, 0.0, 0.0) * fbm(10.0*point);\n    \n    bool show = sin(2.0*iTime) > 0.9;\n    \n    if (show)\n        return sdfCylinder(point-offset-displacement, r, h);\n    else\n        return MARCH_MAX_DIST;\n}\n\nfloat LightningMarch(vec3 org, vec3 dir) {\n    float total_dist = 0.0;\n    vec3 point = org;\n    \n    for (int i=0; i<MARCH_STEPS/2; i++) {\n        float sd = LightningMap(point);\n        if (sd < MARCH_MIN_DIST || total_dist >= MARCH_MAX_DIST)\n            break;\n        point += sd * dir;\n        total_dist += sd;\n    }\n    \n    return total_dist;\n}\n\nvec3 Render(vec3 org, vec3 dir) {\n    Ray ray = Ray(org,dir);\n    float dist = GlassMarch(org, dir, false);\n    bool reflected = false, lightning = false;\n    vec3 volume_color = vec3(0.0);\n    float vis = 1.0;\n    \n    if (dist < MARCH_MAX_DIST) {\n        vec3 point = org + dist * dir;\n        RefractThroughVolume(point, dir, ray, reflected);\n        \n        dist = GlassMarch(ray.org, ray.dir, false);\n        \n        volume_color = VolumetricMarch(ray.org, ray.dir, dist, vis);\n        \n        float lightning_dist = LightningMarch(ray.org, ray.dir);\n        if (lightning_dist < MARCH_MAX_DIST) {\n            lightning = true;\n        }\n        \n        if (dist < MARCH_MAX_DIST) {\n            vec3 end = ray.org + dist * ray.dir;\n            if (!reflected)\n                RefractThroughVolume(end, ray.dir, ray, reflected);\n        }\n        \n    }\n    \n    vec3 solid_col = lightning\n                   ? vec3(5.0, 5.0, 10.0)\n                   : texture(iChannel0, ray.dir).rgb;\n    return min(volume_color, 1.0f) + vis * solid_col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 org = vec3(0.0, 0.0, -2.5);\n    vec3 dir = normalize(vec3(uv, 1.3));\n    \n    vec3 color = Render(org, dir);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}