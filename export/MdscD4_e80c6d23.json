{"ver":"0.1","info":{"id":"MdscD4","date":"1488405736","viewed":523,"name":"Sky Party","username":"grumdrig","description":"Sky dome based on atmospheric scattering from an older GamaSutra article (see comments) which is slowly rotting away. Earth-like parameters are baked in. Not a cloud in the sky today!\n\nThe star field is based on https://www.shadertoy.com/view/MtB3zW\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sky","stars","scattering","rayleigh","mie","cloudparty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sky from http://www.gamasutra.com/blogs/ConorDickinson/20130925/200990/\n// However, earth-like parameters are baked in rather than calculated.\n// You can look left & right using the mouse.\n//\n// Starfield is based on https://www.shadertoy.com/view/MtB3zW\n\nconst float DAY = 30.; // seconds per day\n\nvec3 calcExtinction(float dist) {\n\treturn exp(dist * vec3(-4.522079564139858e-7, -9.250694574802765e-7, -0.0000018804023511620471));\n}\n\nvec3 calcScattering(float cos_theta) {\n\tfloat r_phase = (cos_theta * cos_theta + 1.) * 0.1790493130683899;\n\tfloat m_phase = 0.000232047910685651 * pow(-1.8919999599456787 * cos_theta + 1.89491605758667, -1.5);\n\treturn vec3(0.6477129459381104, 0.7398291826248169, 0.8121863603591919) * r_phase +\n\t       vec3(0.3522870540618896, 0.2601708173751831, 0.1878136247396469) * m_phase;\n}\n\nfloat baseOpticalDepth(in vec3 ray) {\n\tfloat a1 = 6371000.0 * ray.y;\n\treturn sqrt(a1 * a1 + 1284199940096.0) - a1;\n}\n\nfloat opticalDepth(in vec3 pos, in vec3 ray) {\n\tpos.y += 6371000.0;\n\tfloat a0 = 41873842372608.0 - dot(pos, pos);\n\tfloat a1 = dot(pos, ray);\n\treturn sqrt(a1 * a1 + a0) - a1;\n}\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 p) {\n    p = vec2(dot(p, vec2(12.9898,78.233)),\n    \t     dot(p, vec2(26.65125, 83.054543)));\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat stars(in vec2 x, float numCells, float size, float br) {\n    vec2 n = x * numCells;\n    vec2 f = floor(n);\n\n\tfloat d = 1.0e10;\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            vec2 g = f + vec2(float(i), float(j));\n\t\t\tg = n - g - rand2(mod(g, numCells)) + rand(g);\n            // Control size\n            g *= 1. / (numCells * size);\n\t\t\td = min(d, dot(g, g));\n        }\n    }\n\n    return br * (smoothstep(.95, 1., (1. - sqrt(d))));\n}\n\nvec3 skyColor(in vec3 rd) {\n    float sunAngle = 6.28 * iTime / DAY;\n\tfloat cs = cos(sunAngle), ss = sin(sunAngle);\n    vec3 sunDirection = normalize(vec3(cs, ss, 0.5));\n\n    // Coordinates to use are the two smallest of the three. There's some distortion at various points\n\tvec3 starvec = vec3(rd.x * cs + rd.y * ss,\n                        rd.x * ss - rd.y * cs,\n                        rd.z);\n\tvec2 starcoord = starvec.xy;\n\tif (abs(starvec.z) < abs(starvec.x)) {\n\t\tstarcoord.x = starvec.z + .388;\n\t\tif (abs(starvec.x) < abs(starvec.y)) {\n\t\t\tstarcoord.y = starvec.x + .24;\n\t\t}\n\t} else if (abs(starvec.z) < abs(starvec.y)) {\n\t\tstarcoord.y = starvec.z + 0.17;\n\t}\n\tstarcoord = asin(starcoord);\n\tvec3 starlight = vec3(0);\n\tstarlight += stars(starcoord,  4., 0.1,   2.0) * vec3(.74, .74, .74);\n\tstarlight += stars(starcoord,  8., 0.05,  1.0) * vec3(.97, .74, .74);\n\tstarlight += stars(starcoord, 16., 0.025, 0.5) * vec3(.90, .90, .95);\n\n\tfloat cos_theta = dot(rd, sunDirection);\n\n\t// optical depth along view ray\n\tfloat ray_dist = baseOpticalDepth(rd);\n\n\t// extinction of light along view ray\n\tvec3 extinction = calcExtinction(ray_dist);\n\n\t// optical depth for incoming light hitting the view ray\n\tvec3 light_ray_pos = rd * (ray_dist * (0.15 + 0.75 * sunDirection.y));\n\tfloat light_ray_dist = opticalDepth(light_ray_pos, sunDirection);\n\n\t// optical depth for edge of atmosphere:\n\t// this handles the case where the sun is low in the sky and\n\t// the view is facing away from the sun; in this case the distance\n\t// the light needs to travel is much greater\n\tfloat light_ray_dist_full = opticalDepth(rd * ray_dist, sunDirection);\n\n\tlight_ray_dist = max(light_ray_dist, light_ray_dist_full);\n\n\t// cast a ray towards the sun and calculate the incoming extincted light\n\tvec3 incoming_light = calcExtinction(light_ray_dist);\n\n\t// calculate the in-scattering\n\tvec3 scattering = calcScattering(cos_theta);\n\tscattering *= 1.0 - extinction;\n\n\t// combine\n\tvec3 in_scatter = incoming_light * scattering;\n\n\t// sun disk\n\tfloat sun_strength = clamp(cos_theta * 666.6619873046875 - 665.6619873046875, 0.0, 1.0);\n\tsun_strength *= sun_strength;\n\tvec3 sun_disk = extinction * sun_strength;\n\n\tvec3 result = vec3(5.839504241943359) * (0.5 * sun_disk + in_scatter);\n\n\tfloat daylight = smoothstep(-0.3, 0.2, sunDirection.y);\n\tresult += (1. - daylight) * starlight;\n\n\treturn result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    p.y += 0.9;  // Show just a bit of the horizon\n    \n\tvec3 rd = normalize(vec3(p, 1.));\n\n    // Adjust view with mouse\n    float mouse = 0.;\n    // Mouse look commented out because the default mouse value can be somewhere weird\n    // mouse = (2.*iMouse.x  - iResolution.x) / iResolution.y;\n\tmouse -= .3;  // Angle towards the sunrise\n\tfloat cm = cos(mouse), sm = sin(mouse);\n    rd = vec3(cm * rd.x - sm * rd.z, rd.y, sm * rd.x + cm * rd.z);\n\n    if (rd.y > 0.) {\n        fragColor.rgb = skyColor(rd);\n    } else { \n        float sunAngle = 6.28 * iTime / DAY;\n        float sunheight = sin(sunAngle);\n\t\tfloat daylight = smoothstep(-0.3, 0.05, sunheight);\n        daylight = max(0., sunheight);\n\t\t//vec3 pos = ro + h * rd;\n        fragColor.rgb = mix(vec3(0, .15, .15), vec3(.1, .4, .1), daylight);\n    }\n\tfragColor.a = 1.;    \n}","name":"Image","description":"","type":"image"}]}