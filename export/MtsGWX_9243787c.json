{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nbool cflag = false;\nint id;\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1.0), clamp((abs(fract(\n    h + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - 3.0) - 1.0), 0.0, 1.0), s) * v;\n}\n\nfloat map0(in vec3 p) // body\n{   \n    // postion\n    p.y -= -0.3;\n   \tp.z -= 1.2;\n    //de\n    p.x *= 0.8;\n    float a =  atan(-p.y, p.z);\n    p.yz *= (abs(cos(0.5 * a)) + 0.08);\n    return length(p) - 0.25;\n}\n\nfloat map1(in vec3 p) // engine\n{   \n    // postion\n    p.y -= 0.82;\n    p.z -= 0.05;\n    // de\n    return length(max(abs(p) - vec3(0.15, 0.15, 0.25), 0.0)) - 0.1;\n}\n\nfloat map2(in vec3 p) //propeller\n{   \n    // position\n    p.y -= 0.8;\n    p.z -= 0.5;\n    // de\n    p.xy *= rotate(iTime);\n    vec3 q = p;\n    p.x *= 0.2;\n    p.x = abs(p.x)-0.05;\n    p.yz *= rotate(sign(q.x) * 0.8 - q.x *  1.5);\n    q.z -= -0.02;\n    q.z *= 0.6;\n    return min(\n        max(abs(p.z) - 0.01,length(p.xy) - 0.05),\n        max(-q.z,length(q) - 0.08));\n}\n\nfloat map3(in vec3 p) // main wing\n{   \n    // postion\n    p.y -= 0.3;\n    // de\n    p.y *= 2.0;\n    p.z += 0.2 * abs(p.x);\n    p.z *= 0.4;\n    float r = 0.15;\n    p.x = abs(p.x) -2.0;\n    return min(length(p) - r, max(p.x, length(p.zy) - r));\n}\n\nfloat map4(in vec3 p) // folat\n{   \n    // postion\n    p.y -= -0.4;\n    p.z -= -0.1;\n    p.x = abs(p.x) - 1.5;\n    // de\n    p.x *= 0.8;\n    float a =  atan(-p.y, p.z);\n    p.yz *= (abs(cos(0.5 * a)) + 0.3);\n\treturn length(p) - 0.2;\n}\n\nfloat map5(in vec3 p) // vertical tail\n{   \n    // postion\n    p.y -= -0.3;\n    p.z -= -1.8;\n    // de\n    p *= 2.0;\n    p.z += 0.2 * p.y;\n    p.y *= 0.1;\n    p.z *= 0.3;\n    return max(abs(p.y - 0.06) - 0.06, length(p) - 0.1);\n}\n\n\nfloat map6(in vec3 p) // horizontal tail\n{   \n    // postin\n    p.y -=- 0.2;\n    p.z -= -1.8;\n    // de\n    p.z += 0.2 * abs(p.x);\n    p.z *= 0.6;\n    float r = 0.1;\n    p.x = abs(p.x) - 0.3;\n    return min(length(p) - r, max(p.x, length(p.zy) - r));\n}\n\nfloat map7(in vec3 p) // engine stay\n{   \n    // position\n    p.y -= 0.3;\n    p.x = abs(p.x) - 0.4;\n    // de\n    p.x += 0.6 * abs(p.y);\n    vec3 q = p;\n    p.z += -0.2 * p.y;\n\tp.z = abs(p.z) - 0.2;\n    q.z -= -0.2;\n    q.z += -1.0 * abs(q.y);\n\treturn min(\n        max(abs(p.y) - 0.5,length(p.zx) - 0.05),\n        max(abs(q.y) - 0.5,length(q.zx) - 0.03));\n}\n\nfloat map8(in vec3 p) // float stay\n{   \n    // postion\n    p.y -= -0.4;\n    p.z -= -0.3;\n    p.x = abs(p.x) - 1.5;\n    // de\n\tp.z += -0.1 * p.y;\n\tp.z = abs(p.z) - 0.2;\n    p.z += -0.1 * p.y;\n    vec3 q = p;\n    q.x +=  0.6 * q.y;\n\treturn min(\n        max(abs(p.y - 0.3) - 0.3,length(p.zx) - 0.05),\n        max(abs(q.y - 0.3) - 0.3,length(q.zx) - 0.03));\n}\n\nfloat map(in vec3 p)\n{       \n    p *= 0.7;  // weight\n    // bounding box\n    vec3 bb = vec3(2.3, 1.3, 2.2);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    const int n = 9;\n    float res = 100.0;\n    float de[n];\n    de[0] = map0(p);\n    de[1] = map1(p);\n    de[2] = map2(p);\n    de[3] = map3(p);\n    de[4] = map4(p);\n    de[5] = map5(p);\n    de[6] = map6(p);\n    de[7] = map7(p);\n    de[8] = map8(p);\n    for(int i = 0; i < n; i++) res = min(res, de[i]);\n    if (cflag)\n    {\n\t\tid = n - 1;        \n   \t\tfor(int i = 0; i < n - 1; i++)\n    \t{\n            bool f = true;\n            for(int j = 1; j < n; j++)\n            {\n                if (de[i] > de[j])  f = false;\n            }\n            if (f) \n            {\n                id = i;\n                break;\n            }\n        }\t     \n    }    \n    return res;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for(int i = 0; i < 64; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 coloring(in vec3 p)\n{\n    cflag = true;\n    map(p);\n    vec3 col0 = hsv(0.0, 0.9, 0.8);\n    if (id == 0) \n    {\n        return col0;\n    }\n    if (id == 1)\n    {\n        return col0;\n    }\n    if (id == 2) \n    {\n        return hsv(0.2, 0.8, 0.6);\n    }\n    if (id == 3) \n    {\n        return col0;\n    }\n    if (id == 4) \n    {\n        return col0;\n    }\n    if (id == 5) \n    {\n        return col0;\n    }\n    if (id == 6) \n    {\n        return col0;\n    }\n    if (id == 7) \n    {\n        return col0;\n    }\n    if (id == 8) \n    {\n        return col0;\n    }\n    return vec3(0.0);\n}\n\nmat3 lookat(in vec3 fw, in vec3 up)\n{\n\tfw = normalize(fw);\n    vec3 rt = normalize(cross(fw, up));\n    return mat3(rt, cross(rt, fw), fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2d = (2.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    float time = 0.3 * iTime;\n    /*\n    float a = 0.0;\n    float h = -0.3;\n    float d = 6.0;\n    a = (a + 0.5)*PI;\n    vec3 ro = vec3(cos(a), h, sin(a))* d;\n\t*/\n\tvec3 ro = vec3(cos(time), 0.6, sin(time))* 6.0;\n    vec3 rd = normalize(vec3(p2d, 2.0));\n\trd = lookat(-ro, vec3(0.0, 1.0, 0.0)) * rd;\n    vec3 lig = normalize(ro + vec3(0.5, 0.8, 3.0)); \n    vec3 col = hsv(0.4, 0.8, 0.2);\n    col = mix(col, hsv(0.6, 0.3, 0.15), smoothstep(0.0, 2.0, length(p2d)));\n    float t = march(ro, rd);\n    if(t > -0.01)\n    {\n        vec3 p3d = ro + t * rd;\n        vec3 n = calcNormal(p3d);\n\t\tfloat dif = clamp((dot(n, lig) + 0.5) * 0.7, 0.2, 1.0);\n        dif *= clamp(softshadow(p3d, lig), 0.2, 1.0);\n        col = coloring(p3d) * dif;\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGWX","date":"1425829746","viewed":210,"name":"Flying boat","username":"gaz","description":"3d","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","de"],"hasliked":0,"parentid":"","parentname":""}}