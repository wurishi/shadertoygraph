{"ver":"0.1","info":{"id":"XccyWN","date":"1730626552","viewed":51,"name":"Dynamic Geometric Trio II","username":"Secretstar","description":"A dynamic 3D shader showcasing rotating shapes—cube, sphere, and octahedron—blended with smooth transitions to create a visually engaging and fluid animation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["smoothblending","proceduralanimation","3dgeometry","cubesphereoctahedron","dynamicshapes","rotatingforms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Funzioni di distanza per le forme 3D\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\n// Funzione per ruotare un punto nello spazio 3D\nvec3 rotate(vec3 p, vec3 angles) {\n    float cx = cos(angles.x); float sx = sin(angles.x);\n    float cy = cos(angles.y); float sy = sin(angles.y);\n    float cz = cos(angles.z); float sz = sin(angles.z);\n    \n    vec3 p2 = p;\n    p2.yz = vec2(cx*p.y - sx*p.z, sx*p.y + cx*p.z);\n    p = p2;\n    p2 = p;\n    p2.xz = vec2(cy*p.x - sy*p.z, sy*p.x + cy*p.z);\n    p = p2;\n    p2 = p;\n    p2.xy = vec2(cz*p.x - sz*p.y, sz*p.x + cz*p.y);\n    return p2;\n}\n\n// Funzione per unire le forme con smooth blend\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\n// Funzione principale di distanza che combina tutte le forme\nfloat map(vec3 p) {\n    float t = iTime;\n    \n    // Sfera rotante\n    vec3 spherePos = p - vec3(2.0 * sin(t), 0.0, 0.0);\n    spherePos = rotate(spherePos, vec3(t * 0.5, t * 0.3, 0.0));\n    float sphere = sdSphere(spherePos, 1.0);\n    \n    // Cubo rotante\n    vec3 boxPos = p - vec3(-2.0 * sin(t), 0.0, 0.0);\n    boxPos = rotate(boxPos, vec3(t * 0.4, t * 0.6, t * 0.2));\n    float box = sdBox(boxPos, vec3(0.8));\n    \n    // Ottaedro al centro\n    vec3 octPos = p - vec3(0.0, 2.0 * sin(t * 0.5), 0.0);\n    octPos = rotate(octPos, vec3(t * 0.3, t * 0.4, t * 0.5));\n    float octahedron = sdOctahedron(octPos, 1.2);\n    \n    // Combina le forme con smooth blend\n    float d = smin(sphere, box, 0.5);\n    d = smin(d, octahedron, 0.5);\n    \n    return d;\n}\n\n// Calcola la normale alla superficie\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        map(p + h.xyy) - map(p - h.xyy),\n        map(p + h.yxy) - map(p - h.yxy),\n        map(p + h.yyx) - map(p - h.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Setup della camera\n    vec3 ro = vec3(0.0, 0.0, -6.0); // Posizione camera\n    vec3 rd = normalize(vec3(uv, 1.5)); // Direzione ray\n    \n    // Ray marching\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p;\n    \n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        if(d < 0.001 || t > 20.0) break;\n        t += d;\n    }\n    \n    // Coloring\n    vec3 color = vec3(0.1, 0.1, 0.2); // Background color\n    \n    if(d < 0.001) {\n        // Calcola normale e lighting\n        vec3 normal = calcNormal(p);\n        \n        // Lighting base\n        vec3 lightPos = vec3(2.0 * sin(iTime), 4.0, -3.0);\n        vec3 lightDir = normalize(lightPos - p);\n        \n        // Diffuse lighting\n        float diff = max(dot(normal, lightDir), 0.0);\n        \n        // Specular lighting\n        vec3 viewDir = normalize(ro - p);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        \n        // Colore base basato sulla posizione\n        vec3 baseColor = 0.5 + 0.5 * cos(iTime + p.xyz + vec3(0,2,4));\n        \n        // Combine all lighting\n        color = baseColor * (diff * vec3(0.8) + spec * vec3(0.5));\n        \n        // Aggiunge ambient occlusion\n        float ao = 1.0 - float(t) / 20.0;\n        color *= ao;\n    }\n    \n    // Gamma correction\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}