{"ver":"0.1","info":{"id":"ds3cWj","date":"1695481696","viewed":264,"name":"Volumetric Rendering - Cloud","username":"MaximeHeckel","description":"One of my first attempts at volumetric rendering using raymarching and other techniques (blue noise dithering, HG phase function, noise derivatives)\n\nPosted here to get feedback on how I can improve it :)\n\n","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","cloud","volumetric","beerslaw","phase","bluenoisedithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 25\n#define MAX_STEPS_LIGHTS 6\n#define PI 3.14159265359\n#define ABSORPTION_COEFFICIENT 0.5\n#define SCATTERING_ANISO 0.3\n\n// Originally posted on https://r3f.maximeheckel.com/sdf10\n// Posting here to get feedback and see if I'm doing anything wrong\n\n// Sources:\n// https://www.ea.com/frostbite/news/physically-based-sky-atmosphere-and-cloud-rendering\n// https://www.shadertoy.com/view/WsfBDf\n// https://www.shadertoy.com/view/3sffzj\n// https://www.youtube.com/watch?v=Qj_tK_mdRcA&t=181s\n\n// Next improvements I'd like to make:\n// - properly apply the PowderApprox function\n// - upscaling the result (when rendering in three.js I'm rendering at half the resolution)\n// - applying a light blur to hide some artifacts (especially from dithering)\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\nvec3 rotateAlongAxis(vec3 v,vec3 axis,float angle){\n    mat4 m = rotation3d(axis,angle);\n    return (m * vec4(v,1.)).xyz;\n}\n\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// HG Phase function\nfloat HenyeyGreenstein(float g, float mu) {\n    float gg = g * g;\n    return (1.0 / (4.0 * PI))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));\n}\n\n// BeersLaw\nfloat BeersLaw (float dist, float absorption) {\n    return exp(-dist * absorption);\n}\n\nfloat PowderApprox(float dist) {\n    return  1.0 - exp(-dist * 2.0);\n}\n\n// Value noise derivative from Inigo Quilez\nfloat hash(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    // TODO: Switch to a noise texture instead of hash function\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// Dirty modification of the FBM: allow for a low res (3 octaves) and high res (5 octaves) noise\n// based on the second arg\n// Useful in this case because, we don't need the noise applied to our \"lightmarch\" function to be\n// as detailed as the one applied to our \"raymarch\" function.\n// [??] Is there a more elegant way to do this? \nfloat fbm(vec3 p, bool lowRes) {\n    float frequency = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 1.0;\n    \n\n    if (lowRes) {\n       for( int i=0; i<3; i++ ) {\n            float n = noise(p);\n            a += b*n;\n            b *= s;\n            p = frequency*m*p;\n        }\n    } else {\n        for( int i=0; i<5; i++ ) {\n            float n = noise(p);\n            a += b*n;\n            b *= s;\n            p = frequency*m*p;\n        }\n    }\n\n\treturn a;\n}\n\n\nvec3 background(vec3 rd, vec3 lightPosition, vec3 sunColor){\n    vec3 lightDirection = normalize(lightPosition);\n    vec3 sky = vec3(0.06, 0.08, 0.115) * 7.0;\n    \n    // Sun\n    float d = clamp(dot(rd, lightDirection), 0., 1.);\n    \n    // Add the sun to the sky with a slight red ring around it\n    sky += sunColor * smoothstep(0.998, 1., d) * vec3(1., 0.6, 0.4);\n    sky = mix(sky, sunColor, 0.18);\n    \n    return sky;\n}\n\n// The overall cloud shape is based on the SDF of 2 spheres, combined with smoothmin\n// with FBM applied to it\nfloat scene(vec3 p, bool lowRes) {\n    float s1 = sdSphere(p + vec3(1.0, 0.0, 0.0), 0.5);\n    float s2 = sdSphere(p + vec3(-1.0, 0.0, 0.0), 0.3);\n\n    float d = smin(s1, s2, 2.2);\n\n    // For volumetric rendering we want the opposite of what's usually returned by SDFs in raynmarching\n    // - In Raymarching -> we don't want to march inside the object, hence we want the distance from the surface\n    // - In this case -> we want to actually march into the object, hence the distance here represents more the \"density\"\n    // of the volume, and the bigger, the more \"dense\" the object is\n    return -d + fbm(p + 2.0 * vec3(iTime * 1.9, iTime * 0.2, iTime * 0.8)  / 12.0, lowRes);\n}\n\nfloat lightmarch(vec3 position, vec3 rayDirection, vec3 lightPosition) {\n    vec3 lightDirection = normalize(lightPosition);\n    float totalDensity = 0.0;\n    float marchSize = 0.20;   \n   \n    for (int step = 0; step < MAX_STEPS_LIGHTS; step++) {\n        position += lightDirection * marchSize * float(step);\n              \n        float lightSample = scene(position, true);\n        totalDensity += lightSample;\n    }\n    \n    // [??] Apply powder approx here?\n    //float transmittance = mix(BeersLaw(totalDensity, ABSORPTION_COEFFICIENT) * 2.0 * PowderApprox(totalDensity * 0.01), BeersLaw(totalDensity, ABSORPTION_COEFFICIENT), 0.8);\n    float transmittance = BeersLaw(totalDensity, ABSORPTION_COEFFICIENT);\n\n    return transmittance;\n}\n\nconst float OG_MARCH_SIZE = 0.7;\n\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection, vec3 lightPosition, float offset) {    \n    // Striking the right balance for march size =>\n    // - if too high we march too fast and leave out some details\n    // - if too low we don't march fast enough and may not \"reach\" the cloud before\n    // MAX_STEPS is reached through this loop\n    float marchSize = OG_MARCH_SIZE;\n    \n    float depth = 0.0;\n    depth += marchSize * offset;\n\n    vec3 lightDirection = normalize(lightPosition);\n  \n    float totalTransmittance = 1.0;\n    float lightEnergy = 0.0;\n\n\n    // https://www.shadertoy.com/view/3sffzj : Combine backward and forward scattering to have details in all directions.\n    float phase = mix(HenyeyGreenstein(-1.0 * SCATTERING_ANISO, dot(rayDirection, lightDirection)), HenyeyGreenstein(SCATTERING_ANISO, dot(rayDirection, lightDirection)), 0.75);\n    vec3 p = rayOrigin + depth * rayDirection;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n\n        float density = scene(p, false);\n    \n        // When the \"density\" (or distance of the SDF) is positive, it means we're \"inside\" the volume\n        // We then start sampling light at any given point inside the volume\n        if (density > 0.0) {\n            float transmittance = BeersLaw(density * marchSize, ABSORPTION_COEFFICIENT);\n            float lightTransmittance = lightmarch(p, rayDirection, lightPosition);\n            float luminance = density * lightTransmittance * phase;\n            \n            totalTransmittance *= transmittance;\n\n            // [??] Frostbite code sample for lightEnergy (benefits?)\n            //lightEnergy += totalTransmittance * (luminance - luminance * transmittance) / 0.07;\n            lightEnergy += totalTransmittance * luminance;\n             \n            if (totalTransmittance < 0.001) {\n                break;\n            }\n        }\n        \n        depth += marchSize;\n        p = rayOrigin + depth * rayDirection;\n    }\n\n    return clamp(lightEnergy, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec3 lightPosition = vec3(0.0 , 0.8, 0.8);\n    \n    vec3 sunRotationAxis = normalize(vec3(1., 1., 0.));\n    \n    // sun colors -> mid day and sunset/sunrise\n    vec3 brightSunColor = vec3(1.,0.97,0.95);\n    vec3 darkSunColor = vec3(1., 0.5, 0.3);\n    \n    float sunAngle = mod(iTime * 0.4, 2.0 * PI);\n    vec3 movingSun = rotateAlongAxis(lightPosition, sunRotationAxis, sunAngle);\n    // adjust the sun color based on its angle (lower sun -> darker, higher sun -> brighter)\n    vec3 sunColor = mix(brightSunColor, darkSunColor, clamp(1.0 - sin(sunAngle), 0.0, 1.0));\n    \n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    \n    // Blue noise dithering\n    // This allows for a less resource hungry cloud (i.e. we need less octaves in our noise, less steps\n    // in our raymarching and light marching) to obtain a decent quality result\n    float blueNoise = texture(iChannel0, gl_FragCoord.xy / 1024.0).r;\n    float offset = fract(blueNoise + float(iFrame%32) / sqrt(0.5));\n    \n    float res = raymarch(ro, rd, lightPosition, offset);\n    \n    color = background(rd, movingSun, sunColor);\n    color += sunColor * res;\n\n    // A dash of tone mapping \n    color = smoothstep(0.1,1.05,color);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}