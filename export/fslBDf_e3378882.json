{"ver":"0.1","info":{"id":"fslBDf","date":"1645488816","viewed":152,"name":"Gentle signal glitch","username":"Dubswitcher","description":"A successful attempt at creating a glitch postprocess that uses a smooth noise function to operate. Adjustable.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","postprocess","glitch","static"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// settings\nfloat bscale = 0.7;\nfloat layers = 28.;\nfloat speed = 0.6;\nfloat seed = 500.;\nfloat sat = 0.5;\nfloat dist = 0.01;\n//----------\n\nfloat hash (in vec2 uv) {\n    vec3 p = vec3(\n    dot(uv.xy,vec2(123.,456.)),\n    dot(uv.xy,vec2(789.,112.)),\n    dot(uv.xy,vec2(345.,678.))\n    );\n    p = fract(sin(p*10.)*5000.);\n    return fract(dot(p,vec3(987.,654.,321.)));\n}\n\nfloat ppong (in float x) { // ping pong\n    if (fract(x/2.)<0.5) {\n        return fract(x);\n    } else {\n        return 1.-fract(x);\n    }\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 nb;\n    float b, t, x, y, count; // bottom, top, point, per-layer Y, layer counter\n    vec3 build;\n    \n    for (int i = 0; i < int(layers); i++) {\n    \n        // create 'noise base' randoms for each layer\n        nb.w = hash(vec2(count-100.+seed)); // speed\n        nb.x = hash(vec2(count+100.+seed)); // R\n        nb.y = hash(vec2(count-200.+seed)); // G\n        nb.z = hash(vec2(count+200.+seed)); // B\n        \n        y = ppong(uv.y + iTime*(nb.w*1.2-0.6)*speed); // Slide each layer vertically over time\n        \n        b = floor(y*10.)/10.; // bottom and top of each vertical cell\n        t = ceil(y*10.)/10.;           \n        vec2 np = vec2(hash(vec2(b+count)),hash(vec2(t+count))); // create noise for each cell\n        \n        // Interpolate between each cell\n        x = mix(np.x,np.y,fract(y*10.));\n        // Scale cell values to sharper peaks (tension could have done this better)\n        x = clamp(x-bscale,0.,1.)*(1./(1.-bscale));\n        \n        // Add the color from this layer to the builder\n        build += vec3(x*nb.x,x*nb.y,x*nb.z)*(3.+bscale*3.);\n        count += 1.;\n    }\n    \n    build /= count;\n    \n    // Colorizing elements\n    build = rgb2hsv(build);\n    build.x += iTime/12.;\n    build.y *= sat;\n    build = hsv2rgb(build);\n    \n    vec2 coldist = mix(vec2(0.),vec2(build.x,build.y)*2.-1.,dist);\n    \n    vec3 col = texture(iChannel0,uv+coldist).rgb;    \n    col = mix(col, col*build, build);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}