{"ver":"0.1","info":{"id":"mdc3WN","date":"1677263744","viewed":219,"name":"xray radiation","username":"Carandiru","description":"radiation as if it were visible by xray emission of an accelerating particle environment.\n\nhttp://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["goldenratio","xray"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  radiation as if it were visible by xray emission of an accelerating particle environment.\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/    [100s]\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, uv, 0.0).rgb;\n    \n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define NUM_PLOT 1024.0\n\nfloat circle(in vec2 uv, in vec3 p, in float rad)\n{\n    vec3 puv = vec3(uv, sqrt(1.0f - p.x*p.x - p.y*p.y)) - p;\n    float rsquare = rad*rad;\n    return smoothstep(rsquare + 0.000000625, rsquare - 0.000000625, dot(puv, puv));\n}\n\n/*\nconst float pi = PI;\nconst float golden = GOLDEN_RATIO;\n\nvec3 golden_sphere_coord(float iteration, float max_iterations)\n{\n    float phi = acos(1.0f - 2.0f * (iteration + 0.5f) / max_iterations);\n\n    float theta = golden * iteration;\n\n    float cphi = cos(phi), sphi = sin(phi);\n\n    float c = cos(theta), s = sin(theta);\n\n    // this is the most natural function ever\n    return(vec3(sphi * c, sphi * s, mix(s * s * cphi, cphi, smoothstep(0.0f, 20.0f, iTime))));\n}\n*/\n\n/*\n\ng = 1.22074408460575947536\na1 = 1.0/g\na2 = 1.0/(g*g)\na3 = 1.0/(g*g*g)\nx[n] = (0.5+a1*n) %1\ny[n] = (0.5+a2*n) %1\nz[n] = (0.5+a3*n) %1\n\n*/\n#define g (1.22074408460575947536)\n\nvec3 golden_sphere_coord(in float iteration)\n{\n    vec3 a = 1.0f / vec3(g,g*g,g*g*g);\n    \n    return mod(0.5f + a * iteration, 1.0f);\n}\n#undef g\n\nmat3 rotateAroundY(float a)\n{\n    float cs = cos(a);\n    float sn = sin(a);\n    return\n        mat3( cs, 0.0, -sn,\n              sn, 0.0,  cs,\n             0.0, 1.0, 0.0);\n}\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = radians(180.0);\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 color = vec3(0.0);\n    mat3 rot = rotateAroundY(iTime*iTime);\n    \n    float i = 0.0f;\n    for(i = 0.0f; i < (NUM_PLOT); ++i) {\n\n        vec3 p = (golden_sphere_coord(i * NUM_PLOT + (0.9f*iTime*iTime)) * 2.0f - 1.0f);\n        \n        float plot = circle(uv, rot * p.xyz, pow(0.5f * length(p), 5.0f));\n        \n        p = p * 0.5f + 0.5f;\n\n        color += p * p * plot;\n\n    }\n\n    float h = dot(color * color * color * color * color, LUMA);\n    \n    color = vec3(dot(color, LUMA));\n    \n    fragColor = vec4( h + h * (color) + dot(textureLod(iChannel0, fragCoord/iResolution.xy, 2.0f).rgb, LUMA) * 0.9925f, float(iTime));\n}","name":"Buffer A","description":"","type":"buffer"}]}