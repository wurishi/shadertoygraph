{"ver":"0.1","info":{"id":"MsSfzz","date":"1499107394","viewed":174,"name":"Eco Icon","username":"VB","description":"2D ao & antialiasing, mouse X controls number of arrows.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////\nvec3 hsv(vec3 c) \n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdRing(vec2 p, float r, float thick)\n{\n\tfloat d = length(p);\n\treturn abs(d-r)-thick;\n}\n\nfloat sdPlane(vec2 p, vec2 n)\n{\n\treturn dot(p, n);\n}\n\nfloat sdPlaneAB(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 n = normalize(b-a);\n\treturn -dot(p - a, vec2(n.y, -n.x)); \n}\n\nfloat sdArrowHead(vec2 p, vec2 dir, float l, float w)\n{\n\tvec2 a = dir * vec2(l);\n\tvec2 t = vec2(-dir.y, dir.x);\n\tvec2 b = t * vec2(-w * 0.5);\n\tvec2 c = -b;\n\n\tfloat d = max(sdPlaneAB(p, b, c), sdPlaneAB(p, a, b));\n\td = max(d, sdPlaneAB(p, c, a));\n\n\treturn d;\n}\n\nvec2 a2v(float a)\n{\n\treturn vec2(cos(a), sin(a));\n}\n\n////////////////////////////////////////////////////////////////////////////\nconst float PI = 3.14159265358;\nconst float PI2 = 2.0 * PI;\nconst float D_MAX = 99.0;\n\nvec4 mapEco(vec2 p, float angleOff)\n{\n\tfloat N_SECTIONS = floor(3.0 + (iMouse.x / iResolution.x) * 6.0);\n\tfloat SECTION_W = PI2 / N_SECTIONS;\n\tfloat SPACING = SECTION_W * 0.5;\n\tfloat R = 0.25;\n\tfloat ARROW_L = SPACING * 0.2;\n\tfloat THICK = R * mix(0.25, 0.05, (N_SECTIONS-3.0)/13.0);\n\tfloat ARROW_W = THICK * 4.0;\n\n\t// base thick circle\n\tfloat d = sdRing(p, R, THICK);\n\n\t// find in which section we are\n\tvec2 n = normalize(p);\n\tfloat a = atan(n.y, n.x);\n\ta = mod(a - angleOff, PI2);\n\tfloat section = floor(a / SECTION_W);\n\n\t// color\n\tfloat localA = mod(a, SECTION_W);\n\tfloat w = (SECTION_W - ARROW_L);\n\tfloat k = 0.0;\n\tif (localA < w)\n\t\tk = localA / w;\n\n\tvec3 C1 = vec3(0.3, 0.9, 0.8);\n\tvec3 C2 = vec3(0.3, 0.6, 1.0);\n\tvec3 ECO_GREEN = hsv(mix(C1, C2, k));\n\n\t// substract triangles / add arrow for the section\n\tfloat a2 = mod(PI/2.0 + angleOff + SECTION_W*(section+1.0), PI2);\n\tfloat a1 = a2 - SPACING;\n\tfloat d1 = -sdPlane(p, a2v(a1));\n\tfloat d2 = +sdPlane(p, a2v(a2));\n\td = max(d, -max(d1, d2));\n\n\tvec2 dir = a2v(a1 - PI/2.0 - 0.005);\n\tfloat arrow = sdArrowHead(p - dir * R, vec2(-dir.y, dir.x), ARROW_L, ARROW_W);\n\td = min(d, arrow);\n\n\treturn vec4(ECO_GREEN, d);\n}\n\nvec4 map(vec2 p)\n{\n\tvec2 screenCenter = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n\n\tfloat scale = 1.0;\n\tfloat angle = 0.0;\n\n#define ANIMATE\n#ifdef ANIMATE\n\tfloat a1 = iTime*4.0;\n\tscale = (1.0 + (cos(a1)*0.2));\n\tfloat a2 = iTime*2.0;\n\tangle = a2;\n#endif\n\n\tp = (p - screenCenter) / scale;\n\treturn mapEco(p, angle);\n}\n\n////////////////////////////////////////////////////////////////////////////\nfloat ao2D_simple(float d, float pixSize, float width, float coef)\n{\n\tfloat max_dist = pixSize * width * 3.0;\n\tfloat dRef = max_dist * coef;\n\tif (d <= max_dist)\n\t\treturn clamp(d, 0.0, dRef) / dRef;\n\treturn 1.0;\n}\n\n// 25 taps / gaussian blur / uses sdf distance to ponderate (which is not exact as soon as you use CSG operations)\nfloat ao2D_5x5(vec2 p, float d, float pixSize, float width, float coef)\n{\n\tfloat weights[25] = float[](\n\t\t0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765,\n\t\t0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n\t\t0.023792,\t0.094907,\t0.150342,\t0.094907,\t0.023792,\n\t\t0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n\t\t0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765\n\t);\n\t\n\tfloat max_dist = pixSize * width * 3.0;\n\tif (d >= -pixSize && d <= max_dist)\n\t{\n\t\tfloat dRef = max_dist * coef;\n\t\tfloat coverage = 0.0; \n\t\tint off = 0;\n\t\tfor (float i=0.0; i < 5.0; i++)\n\t\t{\n\t\t\tfor (float j=0.0; j < 5.0; j++)\n\t\t\t{\n\t\t\t\tvec2 delta = (vec2(i, j) + vec2(-2.0)) * vec2(pixSize * width);\n\t\t\t\tvec4 r = map(p - delta);\n\t\t\t\tfloat cov = clamp(r.w, 0.0, dRef) / dRef;\n\t\t\t\tcoverage += cov * weights[off++];\n\t\t\t}\n\t\t}\n\t\treturn coverage;\n\t}\n\treturn 1.0;\n}\n\n////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tfloat pixSize = 1.0 / max(iResolution.x, iResolution.y);\n\n\tvec3 BG_COLOR = hsv(vec3(0.2, 0.3, 1.0));\n\tvec3 c = BG_COLOR;\n\n#if 0\n\tvec4 res = map(uv);\n\tif (res.w > 0.0  && res.w <= pixSize)\n\t{\n\t\tc = vec3(0.0, 1.0, 0.0);\n\t}\n\telse if (res.w > 0.0)\n\t{\n\t\tc = vec3(res.w);\n\t}\n\telse\n\t\tc = vec3(-res.w, 0.0, 0.0);\n#else\n\t// map the shape\n\tvec4 res = map(uv);\n\n\t// then draw ao/shadow\n\tfloat ao = ao2D_5x5(uv, res.w, pixSize, 4.0, 0.35);\n\t//float ao = ao2D_simple(res.w, pixSize, 7.0, 0.3);\n\tc = c * vec3(ao);\n\t\n\t// render shape\t\n\tif (abs(res.w) <= pixSize)\n\t{\n\t\t//msaa4x on edges\n\t\tfloat aaw = 0.35 * pixSize;\n\t\tfloat coverage = 0.0; \n\t\tfloat min_d = 0.0;\n\n\t\tcoverage += 1.0-step(min_d, map(uv - vec2(+aaw, +0.0)).w);\n\t\tcoverage += 1.0-step(min_d, map(uv - vec2(-aaw, +0.0)).w);\n\t\tcoverage += 1.0-step(min_d, map(uv - vec2(+0.0, +aaw)).w);\n\t\tcoverage += 1.0-step(min_d, map(uv - vec2(+0.0, -aaw)).w);\n\t\tcoverage += 1.0-step(min_d, res.w);\n\t\tcoverage = coverage / 5.0;\n\n\t\tc = mix(c, res.xyz, coverage);\n\t}\n\telse if (res.w < 0.0)\n\t{\n\t\t// no msaa inside\n\t\tc = res.xyz;\n\t}\n#endif\n\n\tc.xyz = pow(c.xyz, vec3(1.0 / 2.2));\n\tfragColor = vec4(c.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}