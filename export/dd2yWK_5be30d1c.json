{"ver":"0.1","info":{"id":"dd2yWK","date":"1688213448","viewed":153,"name":"dFdx, dFdy, fwidth","username":"Envy24","description":"Read header in Image tab.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["dfdx","dfdy","fwidth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    For those who want to understand what fwidth is and how it can be used... like me)\n    Looks like fwidth is just a fancy name for L1-norm of gradient vector of some d=f(x, y) (or vice versa).\n\n    I know that bufA is uneccesary, but i think this variant is simpler.\n    \n    Usefull link:\n    https://computergraphics.stackexchange.com/questions/61/what-is-fwidth-and-how-does-it-work\n    \n    Native     - glsl built-in variant.\n    Soft       - recreation of native variant.\n    Analytical - more precise variant.\n*/\n\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), true);\n\n    // Read stored function values for native and soft variants.\n    float f =  TEXF0( SC ).x,\n          fr = TEXF0((SC+vec2(1, 0))).x,\n          fu = TEXF0((SC+vec2(0, 1))).x;\n\n    /*\n        Choose derivative calculation method below.\n    */\n\n    /* Native derivatives (direct finite differences) */\n    float dfdx = dFdx(f), dfdy = dFdy(f); \n    /* Soft derivatives (direct finite differences) *\n    float dfdx = fr-f, dfdy = fu-f;\n    /* Analitycal derivatives. *\n    float dfdx = aDFDX(NDC), dfdy = aDFDY(NDC);\n    \n    /*\n        Choose function width calculation method below.\n    */\n    \n    /* Function width. https://registry.khronos.org/OpenGL-Refpages/gl4/html/fwidth.xhtml */\n    float fw = abs(dfdx) + abs(dfdy);       // L1-norm ( native variant for glsl and hlsl, same as call fwidth(f), fwidth(F(NDC)) )\n          //fw = sqrt(dfdx*dfdx + dfdy*dfdy); // L2-norm\n          //fw = max(abs(dfdx), abs(dfdy));   // Linf-norm\n          //fw = fwidth(f);\n          //fw = fwidth(F(NDC));\n    \n    /*\n        Choose what you want to see).\n        If image is plain black/white, try to increase/decrease multiplier respectively.\n    */\n    \n    /* Function. *\n    O = vec4(f)*1.;\n    /* Function derivative with respect to x. *\n    O = vec4(dfdx, 0., -dfdx, 1.)*256.;\n    /* Function derivative with respect to y. *\n    O = vec4(dfdy, 0., -dfdy, 1.)*256.;\n    /* Function width ( L1, L2, Linf-norm of gradient vector vec2(dfdx, dfdy) ). *\n    O = vec4(fw)*0.01;    \n    /* AA with fwidth (native and soft) */\n    //O = mix(vec4(1), vec4(0), smoothstep(0., fw, f));      // solid\n    O = mix(vec4(1), vec4(0), smoothstep(0., fw, abs(f))); // outline\n    /* AA with fwidth (analitycal) *\n    //O = mix(vec4(1), vec4(0), smoothstep(0., fw*0.01, f)); // solid\n    O = mix(vec4(1), vec4(0), smoothstep(0., fw*0.005, abs(f))); // outline\n    /**/\n    \n    // sRGB conversion (FabriceNeyret2 advice)\n    O = pow(O, vec4(1./2.2));\n    //O = sqrt(O);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), true);\n\n    // Function to anti-alias.\n    O = vec4(F(NDC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Define/choose function (sdf or implicit function) above\n//#define F(P) ( segmentSDF_L2( (P) ) )\n#define F(P) ( electric_motor_curve( (P) ) )\n\n#define UNIT ( 1./450. )                           // ( 1./iResolution.y )\n#define DX ( vec2(UNIT, 0.))\n#define DY ( vec2(0., UNIT) )\n// If you don't know exact analytical expression for d=f(x,y) use this approximation\n#define aDFDX(p) ( (F(p+DX) - F(p-DX)) / (2.*UNIT) )\n#define aDFDY(p) ( (F(p+DY) - F(p-DY)) / (2.*UNIT) )\n\n/*\n    SDFs\n*/\nfloat diskSDF_L2(in vec2 NDC) { return length(vec2(0) - NDC) - 1.; }\nfloat verticalSDF(vec2 NDC) { return abs(NDC.x-0.); }\nfloat horizontalSDF(vec2 NDC) { return abs(NDC.y-0.); }\nfloat segmentSDF_L2(in vec2 NDC)\n{\n    vec2 B = vec2(0.75), E = vec2(-0.75); float r = 0.1;\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n/*\n    Implicit functions.\n*/\nfloat electric_motor_curve(vec2 NDC)\n{\n    NDC *= 12.;\n    float x = NDC.x, y = NDC.y;\n    return y * y * (y * y - 100.0) - x * x * (x * x - 96.0);\n}\nfloat random_curve_0000(vec2 NDC)\n{\n    float x = NDC.x, y = NDC.y;\n    return sin(x*x + y*y)-y*y;\n}","name":"Common","description":"","type":"common"}]}