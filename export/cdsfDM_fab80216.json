{"ver":"0.1","info":{"id":"cdsfDM","date":"1688824091","viewed":63,"name":"cog sdf","username":"dokso","description":"an sdf recreation of a cog","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereSDF(vec2 pos, float radius) {\n    return length(pos) - radius;\n}\nfloat boxSDF(vec2 pos, vec2 size) {\n    vec2 d = abs(pos) - size * 0.5;\n\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rot(vec2 vec, float angle) {\n    // i know i can use matrices\n    // but i'm doing this to test my knowledge\n    //  c s\n    // -s c\n    //  x y\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(vec.x *  c + vec.y * s,\n                vec.x * -s + vec.y * c);\n}\n\nconst float sectors = 8.0;\nconst float sectorSize = (3.14159 * 2.0) / sectors;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec2 q = uv;\n    \n    // spin\n    float ang = iTime;\n    q = rot(q, ang);\n    \n    // repeat sectors amount of times\n    float sector = round(atan(q.y, q.x) / sectorSize);\n    ang = sector * sectorSize;\n    vec2 rq = rot(q, ang);\n    rq -= vec2(0.2, 0.0);\n    \n    float d = boxSDF(rq, vec2(0.04, 0.06)) - 0.025;\n    d = min(d, abs(length(q) - 0.15) - 0.04);\n    \n    vec3 col = mix(vec3(uv, 0.0), vec3(1.0), smoothstep(2.0/iResolution.y, 0.0, d));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}