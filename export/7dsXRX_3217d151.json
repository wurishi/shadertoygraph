{"ver":"0.1","info":{"id":"7dsXRX","date":"1620471733","viewed":121,"name":"Triangle pattern","username":"Eyemm","description":"Testing an idea I've had on paper. Funny how the empty spaces become hexagons during the transition.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["trianglepattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float s32 = sqrt(3.)/2.;\n\nfloat lineDistance(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nbool rightSide(in vec2 p, in vec2 a, in vec2 b)\n{\n    return (p.x-a.x)*(b.y-a.y)-(p.y-a.y)*(b.x-a.x) > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = ( (1.-cos(2.*iTime)) )/2.;\n    \n    // 4. factor so we see more triangles in the viewport.\n    // 0.2*iTime for the diagonal drift\n    vec2 uv = 4.*(fragCoord-iResolution.xy/2.)/iResolution.y + 0.2*iTime;\n    \n    // Tile vertically~diagonally along a triangle edge:\n    // uv.y/s32 is the V coordinate in a UV frame shaped like /_\n    uv -= floor(uv.y/s32)*vec2(0.5, s32);\n    // And tile by 1 horizontally\n    uv.x = uv.x - floor(uv.x);\n    \n    // Look at the three triangle edges individually.\n    // Here's the horizontal _ one that becomes / when t==1\n    vec2 orig = vec2(0., 0.);\n    vec2 end = t*vec2(0.5, s32) + vec2(1.-t, 0.);\n    \n    // Distance to the line, and are we on its right side\n    float dist1 = lineDistance(uv, orig, end);\n    bool right1 = rightSide(uv, orig, end);\n \n    // Transform uv into the second edge's local frame\n    vec2 uv2 = uv - vec2(1.0, 0.0);\n    uv2 = vec2(-0.5*uv2.x + s32*uv2.y, -s32*uv2.x - 0.5*uv2.y);\n    // Then same computation\n    float dist2 = lineDistance(uv2, orig, end);\n    bool right2 = rightSide(uv2, orig, end);\n\n    // Transform into the third edge's frame\n    vec2 uv3 = uv - vec2(0.5, s32);\n    uv3 = vec2(-0.5*uv3.x - s32*uv3.y, s32*uv3.x - 0.5*uv3.y);\n    // And again\n    float dist3 = lineDistance(uv3, orig, end);\n    bool right3 = rightSide(uv3, orig, end);\n \n    // Background\n    fragColor = vec4(1.0);\n\n    // Inside triangles\n    if (right1 && right2 && right3)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    if (!right1 && !right2 && !right3)\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n  \n    // Triangle edges\n    // Truncated\n    dist1 = (!right3 && right2) ? 10.0 : dist1;\n    dist2 = (!right1 && right3) ? 10.0 : dist2;\n    dist3 = (!right2 && right1) ? 10.0 : dist3;\n\n    float distToTriangle = min(min(dist1, dist2), dist3);\n    // Anti-aliasing\n    fragColor = mix( fragColor, vec4(0.), smoothstep(6./iResolution.y, 0., distToTriangle) );\n}","name":"Image","description":"","type":"image"}]}