{"ver":"0.1","info":{"id":"Mfj3zz","date":"1703774659","viewed":73,"name":"Game of Life: Multiverse","username":"sampathsris","description":"A very simple game of life implementation. But here's the kicker: It plays three simultaneous games in the same canvas. Each color channel is used to play a different game. Colors are shifted such that the result isn't boring red/green/blue.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["conway","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Get the colors from Buffer A, and shift them.\n    // This will make sure that pixel colors aren't boring red/green/blue.\n    vec3 tex = texture(iChannel0,uv).rgb;\n    vec3 col = vec3(0.0);\n    col.r += (tex.r + tex.g) / 2.0;\n    col.g += (tex.g + tex.b) / 2.0;\n    col.b += (tex.b + tex.r) / 2.0;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// We'll do a bit of floating-point boolean logic. In this logic,\n// assuming values are either 0.0/1.0,\n//\n// a > b  => step(b, a)           (approximation)\n// a < b  => step(0.0, b - a)     (approximation)\n// a || b => max(a, b)\n// a && b => min(a, b)\n// !a     => 1.0 - a\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy;\n    vec3 color = vec3(0.0);\n    \n    // Previous color of the pixel, retrieved from Buffer A\n    vec3 prevColor = texture(iChannel1, uv0).rgb;\n    \n    if (iFrame == 0)\n    {\n        // On the zeroth frame, we will copy the texture in iChannel0\n        // as the initial set of values.\n        // But since we want 1.0/0.0 for values, we'll transform the\n        // pixels using step.\n        color = step(0.2, texture(iChannel0, uv0).rgb);\n    }\n    else\n    {\n        // From frame 1 onwards, Game of Life starts. Each color channel in\n        // RGB will play a separate game, depending on color value.\n        \n        // First, get the population density by adding up the nine neighboring pixels.\n        vec3 popDensity =\n            texture(iChannel1, (uv - vec2(-1.0, -1.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2( 0.0, -1.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2( 1.0, -1.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2(-1.0,  0.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2( 1.0,  0.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2(-1.0,  1.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2( 0.0,  1.0)) / iResolution.xy).rgb +\n            texture(iChannel1, (uv - vec2( 1.0,  1.0)) / iResolution.xy).rgb;\n        \n        vec3 underpopulated = step(0.0, 1.99 - popDensity);          // (aprox) popDensity < 2.0\n        vec3 overpopulated = step(3.01, popDensity);                 // (aprox) popDensity > 3.0\n        \n        // If the cell is either underpopulated or overpopulated, it will die\n        vec3 badNeighborhood = max(underpopulated, overpopulated);   // underpopulated || overpopulated\n        \n        // If the cell has 2 or 3 neighbors, it's a good neighborhood. It will keep the previous state.\n        vec3 goodNeighborhood = 1.0 - badNeighborhood;               // !badNeighborhood\n        \n        // But if a cell has exactly 3 neighbors, conditions are just right. It will reproduce if\n        // it was a dead cell\n        vec3 mightBeJustRight = step(3.0, popDensity);               // popDensity >= 3\n        vec3 exactlyRight = min(mightBeJustRight, goodNeighborhood); // mightBeJustRight && goodNeighborhood\n        \n        // Probably keep the previous color if it's a good neighborhood.\n        vec3 keepPrevious = min(prevColor, goodNeighborhood); // prevColor && goodNeighborhood\n        \n        // Figure out if the mouse was clicked on this cell, without if-then-else.\n        // length(iMouse.zw) would be 1.0 if clicked.\n        // uv - iMouse.xy will be (0.0, 0.0), if the mouse coordinates mach with\n        // this pixel's coordinates. In that case, length(uv - iMouse.xy) shall be 0.0\n        //\n        // So the following statement is equivalent to:\n        // mouseClicked || mouseCoordinate == thisPixelCoordinate\n        float mouseClicked = min(step(0.0, length(iMouse.zw)), 1.0 - length(uv - iMouse.xy));\n    \n        // Final cell status. It will be live if eigher keepPrevious or exactlyRight is true.\n        // It will also spawn a new cell if mouse was clicked.\n        // keepPrevious || exactlyRight || mouseClicked\n        color = vec3(max(max(keepPrevious, exactlyRight), step(0.0, mouseClicked)));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}