{"ver":"0.1","info":{"id":"DdsyD8","date":"1687294118","viewed":83,"name":"Squeezing a 3D squircle","username":"Peregrine","description":"Playing with ray marching and diffuse illumination.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I am a newbie, exploring ray marching and diffuse lightning with help from\n// Jamie Wong (https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/) and\n// Michael Walczyk (https://michaelwalczyk.com/blog-ray-marching.html)\n// Helpful comments welcome.\n\n\nconst float EPSILON = 0.0001;\n\n\n// Rigid body transforms\n\nmat4 rotate_y(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c,  0., s,  0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-s, 0., c,  0.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\n\n// Constructive solid geometry\n\nfloat sdf_intersection(float sdf_A, float sdf_B) {\n    return max(sdf_A, sdf_B);\n}\n\nfloat sdf_union(float sdf_A, float sdf_B) {\n    return min(sdf_A, sdf_B);\n}\n\nfloat sdf_difference(float sdf_A, float sdf_B) {\n    return max(sdf_A, -sdf_B);\n}\n\n\n// Signed distance functions\n\nfloat sdf_cube(vec3 position, float side) {\n    vec3 d = abs(position) - vec3(side);\n    float inside_dist = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outside_dist = length(max(d, 0.0));\n    \n    return inside_dist + outside_dist;\n}\n\nfloat sdf_sphere(vec3 position, float radius) {\n    return length(position) - radius;\n}\n\nfloat sdf_scene(vec3 position) {\n    float displacement = sin(sin(3. * iTime) * 5. * position.x) * \n                         sin(sin(2. * iTime) * 3. * position.y) * \n                         sin(sin(5. * iTime) * 2. * position.z) * 0.25;\n    float sphere = sdf_sphere(position, 1.3);\n    float cube = sdf_cube(position, 1.);\n    \n    return sdf_intersection(cube + displacement, sphere);\n}\n\n\n// Lighting\n\nvec3 estimate_normal(vec3 p) {\n    const vec3 small_step = vec3(EPSILON, 0., 0.);\n    \n    float gradient_x = sdf_scene(p + small_step.xyy) - sdf_scene(p - small_step.xyy);\n    float gradient_y = sdf_scene(p + small_step.yxy) - sdf_scene(p - small_step.yxy);\n    float gradient_z = sdf_scene(p + small_step.yyx) - sdf_scene(p - small_step.yyx);\n    \n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 light_position = vec3(2., -5., 0.);\n\nfloat diffuse_lighting(vec3 position) {\n    vec3 light_direction = normalize(light_position - position);\n    vec3 normal = estimate_normal(position);\n    float lambertian = max(dot(normal, light_direction), 0.);\n    return lambertian;\n}\n\nfloat blinn_phong_lighting(vec3 position) {\n    float shininess = 16.;\n    float specular_intensity = 0.;\n\n    vec3 light_direction = normalize(light_position - position);\n    light_direction = normalize(light_direction);\n    vec3 normal = estimate_normal(position);\n    float lambertian = max(dot(light_direction, normal), 0.);\n\n    if (lambertian > 0.) {\n        vec3 view_direction = normalize(- position);\n        vec3 half_direction = normalize(view_direction + light_direction);\n        float specular_angle = max(dot(half_direction, normal), 0.);\n        specular_intensity = pow(specular_angle, shininess); \n    }\n\n    return specular_intensity;\n}\n\n// Gamma correction, suggested by Spalmer\nvec3 gamma_correction(vec3 color) {\n    float gamma = 2.2; // TO DO: what about sqrt() instead of pow()?\n                       // 2 is almost 2.2 ;-) --- but is it worth it?\n    return pow(color, vec3(1. / gamma));\n}\n\n\n\n// Camera and views\n\nvec3 ray_direction(float field_of_view, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(field_of_view) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s,        0.),\n\t\tvec4(u,        0.),\n\t\tvec4(-f,       0.),\n\t\tvec4(vec3(0.), 1.));\n}\n\n\n// Ray marching\n\nvec3 ray_march(vec3 origin, vec3 direction) {\n    const int STEPS_MAX = 255;\n    const float HIT_DIST_MIN = EPSILON;\n    const float TRACE_DIST_MAX = 100.;\n    float total_distance_traveled = 0.;\n    float distance_to_closest;\n    vec3 current_position;\n\n    for (int i = 0; i < STEPS_MAX; i++) {\n        current_position = direction * total_distance_traveled + origin;\n        distance_to_closest = sdf_scene(current_position);\n        if ((distance_to_closest < HIT_DIST_MIN) || (total_distance_traveled > TRACE_DIST_MAX))\n            break;\n        total_distance_traveled += distance_to_closest;\n    }\n    \n    if (distance_to_closest < HIT_DIST_MIN)\n        return current_position;\n    else\n        return vec3(0.);\n}\n\n\n// Main image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.xx;\n    \n    vec3 view_direction = ray_direction(45., iResolution.xy, fragCoord);\n    vec3 eye = (rotate_y(-iTime) * vec4(8., 5., 7., 1.)).xyz;  \n    mat4 view_to_world = view_matrix(eye, vec3(0.), vec3(0., 1., 0.));\n    vec3 world_direction = (view_to_world * vec4(view_direction, 0.)).xyz;\n    \n    vec3 position = ray_march(eye, world_direction);\n    vec3 color_linear = vec3(0.) + // ambient color\n                        diffuse_lighting(position) * vec3(1., 0., 0.) +\n                        blinn_phong_lighting(position) * vec3(1.);\n    vec3 color_corrected = gamma_correction(color_linear);\n    \n    fragColor = vec4(color_corrected, 1.);\n}","name":"Image","description":"","type":"image"}]}