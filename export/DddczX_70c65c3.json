{"ver":"0.1","info":{"id":"DddczX","date":"1695306939","viewed":43,"name":"simple ground","username":"tomcat7479","description":"use surface of z = sin(x) * sin(y) to  generating ground","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ground"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 3\n#define max_distance 200.0\n#define min_distance 0.1\n#define iter_count 15\n#define iter_precision 1e-4\n#define PI 3.1415926\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 y_dir = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, y_dir));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat ground(vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nvec3 calNormal(vec3 p) {\n    const vec2 diff = vec2(1e-5, 0.0);\n    float px = ground(p.xz + diff.xy) - ground(p.xz - diff.xy);\n    float py = 2.0 * diff.x;\n    float pz = ground(p.xz + diff.yx) - ground(p.xz - diff.yx);\n    return normalize(vec3(px, py, pz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = min_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        float d = ground(p.xz);\n        float h_diff = p.y - d;\n        if (h_diff < iter_precision || t > max_distance) {\n            break;\n        }\n        t += h_diff;\n    }\n    return t;\n}\n\nvec3 render(in vec2 uv) {\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 5.0, 3.0);\n\n    float focus_distance = 1.0;\n    vec3 ro = vec3(4.0 * sin(0.2 * iTime), 5.0, 4.0 * cos(0.2 * iTime));\n    vec3 lookAt = vec3(0.0, -1.5, 0.0);\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n    float rm = rayMarch(ro, rd);\n    vec3 color = vec3(0.38, 0.93, 0.93);\n    vec3 ground_color = vec3(0.92, 0.64, 0.2);\n    if (rm < max_distance) {\n        vec3 p = ro + rm * rd;\n        vec3 n = normalize(calNormal(p));\n        vec3 l = normalize(light_pos - p);\n        \n        vec3 ambient = ground_color * light_color * 0.41;\n\n        float dif_cos = clamp(dot(n, l), 0.0, 1.0);\n        vec3 diffuse = ground_color * light_color * dif_cos * 0.91;\n\n        color = ambient + diffuse;\n    }\n    return color;\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}