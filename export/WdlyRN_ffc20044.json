{"ver":"0.1","info":{"id":"WdlyRN","date":"1584283145","viewed":119,"name":"Ray Sphere/Ellipsoid intersect","username":"AngryBaguette","description":"Ray Sphere/Ellipsoid intersection","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray","sphere","ellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_MAX 1e9\nconst float PI_4 = 0.78539816339744;\n\n// Sphere / Ray intersection\n// ro  : ray origin\n// rd  : ray direction\n// r   : radius\n// t0  : distance to intersection 1\n// t1  : distance to intersection 2\n// return true if intersect, false otherwise\nbool iSphere(vec3 ro, vec3 rd, float r, inout float t0, inout float t1)\n{   \n    float A = dot(rd,rd);\n    float B = 2.0 * dot(rd,ro);\n    float C = dot(ro,ro) - r*r;\n    float D =  B*B - (4.0 * A * C);\n\tif (D<0.0)\n\t{\n\t\tt0 = -M_MAX;\n\t\tt1 = -M_MAX;\n\t\treturn false;\n\t}\n    \n    float D_SQR = sqrt(D);\n    A += A; // 2A\n    t0 = (-B - D_SQR) / A;\n    t1 = (-B + D_SQR) / A;\n\n    return true;  \n}\n\n// Axis aligned Ellipsoid / Ray intersection\n// ro : ray origin\n// rd : ray direction\n// r  : radius\n// t0 : distance to intersection 1\n// t1 : distance to intersection 2\n// return true if intersect, false otherwise\nbool iEllipsoid(in vec3 ro, in vec3 rd, in vec3 r, inout float t0, inout float t1)\n{\n    vec3 ir2 = vec3(1.0) / (r*r);    \n    float A = dot(rd*rd,ir2);\n    float B = 2.0 * dot(rd*ro,ir2);\n    float C = dot(ir2,ro*ro) - 1.0;\n    float D =  B*B - (4.0 * A * C);\n\tif (D<0.0)\n\t{\n\t\tt0 = -M_MAX;\n\t\tt1 = -M_MAX;\n\t\treturn false;\n\t}\n    \n    float D_SQR = sqrt(D);\n    A += A; // 2A\n    t0 = (-B - D_SQR) / A;\n    t1 = (-B + D_SQR) / A;\n\n    return true;    \n}\n\n    \n// Rotation matrix from euler angle (radian)\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Compute ray\nRay sdRay(vec3 origin, vec2 frag, vec2 res, float fov)\n{\n    Ray ray;\n    ray.origin = origin;\n    vec2 xy = frag - res / 2.0;\n    float z = res.y / tan(fov / 2.0);\n    ray.direction = normalize(vec3(xy, -z));\n    \n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n            \n    vec3 EyePos = vec3(0.0, 0.0, 15.0);\n    Ray ray = sdRay(EyePos, fragCoord.xy, iResolution.xy, PI_4);\n    //mat3 rot = fromEuler( vec3(0.7, 0.7, 0.0) );\n    mat3 rot = fromEuler( vec3(iTime,0.5, 0.1) );\n    vec3 ro = rot * ray.origin;\n    vec3 rd = rot * ray.direction;\n        \n    vec3 radius = vec3(2.0,0.5,3.0);\n\tfloat t0,t1;\n    bool intersect = iEllipsoid(ro, rd, radius, t0, t1);    \n    //bool intersect = iSphere(ro, rd, radius.x, t0, t1);\n    \n    vec3 isect = ro + rd * t0;\n    float color = length(isect) / length(radius);\n    fragColor = vec4(color,color,color,1.0);\n}","name":"Image","description":"","type":"image"}]}