{"ver":"0.1","info":{"id":"tlXfz4","date":"1596127036","viewed":146,"name":"cloudy stones","username":"pixlpa","description":"combined noisy volume rendering and noisy sdf ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","volume","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//global variables\n\n#define fractal_iterations 7\n#define fractal_elongate 0.21\n#define volume_iterations 7\n#define volume_step 0.004\n#define density 0.75\n#define max_distance 5.\n#define grad_step 0.0001\n#define stop_threshold 0.002\n#define maxiterations 100\n\n#define scale 2.75\n#define offset 0.22\n\nconst vec3 nn1 = normalize(vec3(-0.2,.5,1.));\n\nmat3 objRot = mat3(1.);\nmat3 frcRot = mat3(1.);\n\n//iq distance functions\n\nfloat sdfSphere(vec3 z, vec3 pos, float s){\n\tvec3 p = z-pos;\n\treturn length(p)-s;\n}\n\nfloat sdfOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdfNoise( vec3 p, float s)\n{\n  float v = triNoise3d(p*0.35)*0.5+snoise(p*1.3)*0.8;\n  return v*s;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}           \n\n\nvec2 map(vec3 z){\n\tfloat upscale = 1.;\n\tvec3 rotated = (z*objRot)/upscale;\n\tfloat d0a = sdfOctahedron(rotated-vec3(0.,0.,0.),1.25);\n\tfloat d0b = sdfSphere(rotated,vec3(0.2,-0.4,0.),0.5);\n\tfloat d1 = sdfNoise(rotated+vec3(iTime*0.1,0.,0.),0.7);\n\td1 = opSmoothUnion(d1,d0b,0.5);\n\td1 = opSmoothIntersection(d1,d0a, 0.0001);\n\treturn vec2(d1/upscale,1.);\n}\n\nvec3 calcNormal(vec3 pos ){   \n\tvec3 eps = vec3( grad_step, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){    \n\tfloat result = -1.0;\n    float id = -1.;\n    float dist = stop_threshold*2.0;\n\n    for (int i = 0; i < maxiterations; i++) {\n        vec3 p = ro+rd*dist;\n        vec2 res = map(p);\n        if (res.x <= stop_threshold) break;\n        dist += res.x;\n        id = res.y; \n        if (dist >= max_distance) break;\n    }\n\n    result = dist;\n\tid = mix(id,-1.0,float(dist>max_distance));\n    \n    return vec2(result,id);   \n}\n\n//diffuse lighting calc\nvec3 calcLight(vec3 p, vec3 eye2, vec3 N, \n\t\t\t\t\t\t\tvec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos);\n    vec3 V = normalize(eye2 - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (dotLN);\n    }\n    return lightIntensity * (dotLN);\n}\n\n// procedural volume\n// maps position to color\n// based on https://www.shadertoy.com/view/ttSczc\nvec4 volumeFunc(vec3 p)\n{\n\treturn colornoise(p*objRot*2.+vec3(iTime*0.3,0.,0.),1.5, 0.8);\n}\n\nvec4 volumeMarch(vec3 rayOrigin, vec3 rayDir, vec3 lightDir)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tvec3 pos = rayOrigin;\n\tvec3 ref = rayDir;\n\tfloat dist = 0.005;\n\tfor(int i=0; i<volume_iterations; i++) {\n\t\tvec3 p = pos + ref * dist;\n\t\tdist += volume_step;\n\t\tvec4 vol = volumeFunc(p);\n        //using volume sample diff to get lighting\n        //based on https://www.shadertoy.com/view/XslGRr\n        float dif = clamp((vol.a + volumeFunc(p-0.01*lightDir).a)/.7, 0.0, 1.0 );\n\t\tsum.rgb += vol.rgb*vol.a*density*(dif*0.85);\n\t\tsum.a += vol.a*density;\n\t\tref = refract(rayDir, vol.xyz, 1./1.2);\n\t}\n\treturn abs(sum);\n}\n\n#define light_dir vec3(1.,-1.,0.95)\nvec3 render(vec2 res, vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.65,0.85,0.95)*0.25;\n\tif( res.y > -0.5 ) {\n\t\tvec3 p = ro +rd * res.x;\n\t\tvec3 norm = calcNormal(p);\n        \n        color += calcLight(p, ro, norm, \n\t\t\t\t\t\t\tlight_dir, vec3(0.8,.2,0.2)*1.95); \n\t\t\n\t\tvec4 vol = volumeMarch(p, refract(rd,norm,1./1.95), light_dir);\n        vol.rgb = mix(vec3(dot(vol.rgb,vec3(0.333))),vol.rgb,0.15);\n\t\tvol.a = pow(vol.a,1.1);\n\t\tvol = clamp(vol,0.,1.);\n\t\tcolor = mix(color,vol.rgb,vol.a);\n\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\tvec3 ro = vec3(0.,0.,2.);\n\tvec3 ta = vec3(0.);\n\t\n\t//initialize globals\n\tobjRot = rot3Dmat(vec3(0.25,0.25,0.));\n\t//frcRot = rot3Dmat(vec3(sin(iTime*0.23)*2.5,0.,iTime*0.3));\n\n\tmat3 camMat = calcLookAtMatrix(ro, ta, 0.);\n\tvec3 rd = normalize(camMat * vec3(p.xy,2.0) );\n    vec2 res = calcIntersection(ro, rd);\n\tvec3 color = render(res,ro,rd);\n\n    // Output to screen\n    fragColor = mix(vec4(0.25,0.5,0.45,1.),vec4(color, 1.0),float(res.y>-0.5));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec4 colornoise(vec3 p, float rgboff, float simple){\n\tvec4 color = vec4(0.);\n\tvec3 pos = p+vec3(0.,0.,rgboff);\n\tcolor.r = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,0.,-rgboff);\n\tcolor.g = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,rgboff,0.);\n\tcolor.b = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(2.,0.,-rgboff);\n\tcolor.a = triNoise3d(pos*0.25)*simple+snoise(pos);\n\treturn color;\n}\n\n//Rotation matrix from euler (X/Y/Z) angles. http://glslsandbox.com/e#48064.5\nmat3 rot3Dmat(vec3 angles)\n{\n\tvec3 c = cos(angles);\n\tvec3 s = sin(angles);\n\t\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n\tmat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n\tmat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t\n\treturn rotX * rotY * rotZ;\n}\n\n//-----------------------------------------------------------------------------\n//Vectors\n//-----------------------------------------------------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}","name":"Common","description":"","type":"common"}]}