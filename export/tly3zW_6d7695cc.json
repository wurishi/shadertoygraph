{"ver":"0.1","info":{"id":"tly3zW","date":"1578380400","viewed":77,"name":"3d ray-openscad logo intersect","username":"16807","description":"Distance field to an OpenSCAD logo formed by the negation of three cylinders from a sphere. The code provides functions to calculate distance to any shape formed from constructive solid geometry, and works in both 2d and 3d. Click the screen to rotate.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","csg","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define PI 3.1415926\n#define CRATER_RADIUS 0.4\n\nFUNC(bool) try_distances_along_line_intersecting_negation(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    if (!is_intersection1)\n    {\n      return false;\n    }\n    entrance = is_intersection2 || entrance1 < entrance2 ? entrance1 : max(exit2,     entrance1);\n    exit     = is_intersection2 || exit1     < exit2     ? exit1     : max(entrance2, exit1    );\n    return !is_intersection2 || entrance1 < entrance2 || exit2 < exit1;\n}\n\nFUNC(bool) try_distances_along_line_intersecting_union(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    exit     = !is_intersection1 ? exit2     : !is_intersection2 ? exit1     : max(exit1,     exit2    );\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) try_distances_along_line_intersecting_intersection(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = is_intersection1 && is_intersection2 ? max(entrance1, entrance2) : 0.f;\n    exit     = is_intersection1 && is_intersection2 ? min(exit1,     exit2    ) : 0.f;\n    return is_intersection1 && is_intersection2 && entrance < exit;\n}\n\nFUNC(float) get_distance_along_3d_line_intersecting_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\n// 3D FUNCTIONS RETURNING MULTIPLE INTERSECTIONS / CLOSEST APPROACHES\nFUNC(bool) try_distances_along_3d_line_intersecting_sphere(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    float xz = dot(B0-A0, A);\n    float z  = length(A0+A*xz - B0);\n    float y2  = r*r-z*z;\n    float dxr = sqrt(max(y2, 1e-10));\n    entrance = xz - dxr;\n    exit     = xz + dxr;\n    return y2 > 0.;\n}\n\nFUNC(bool) try_distances_along_3d_line_intersecting_infinite_cylinder(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    // simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    vec3  O = A0 - B0;\n    float BA = dot(B,A);\n    float BO = dot(B,O);\n    float a = 1.0 - BA*BA;\n    float b = dot( O, A ) - BO*BA;\n    float c = dot( O, O ) - BO*BO - r*r;\n    float h = sqrt(max(b*b - a*c,0.f));\n    entrance =(-b+h)/a;\n    exit     =(-b-h)/a;\n    return h>0.0;\n}\nFUNC(bool) try_distances_along_3d_line_intersecting_cylinder(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B1, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    vec3 B = normalize(B1-B0);\n    float a1 = get_distance_along_3d_line_intersecting_plane(A0,A,B0,B);\n    float a2 = get_distance_along_3d_line_intersecting_plane(A0,A,B1,B);\n    float a_in  =  min(a1,a2);\n    float a_out =  max(a1,a2);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_intersecting_infinite_cylinder(A0,A, B0,B, r, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_line_intersecting_intersection(b_hits, b_in, b_out, true, a_in, a_out, c_in, c_out);\n    entrance = max(b_out, min(a1,a2));\n    exit     = min(b_in,  max(a1, a2));\n    return b_hits && entrance < exit;\n}\n\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.6+ iMouse.x * -0.01 + iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_intersecting_sphere(view_origin, view_direction, vec3(0,0,0), 0.5f, a_in, a_out);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_intersecting_cylinder(view_origin, view_direction, vec3(-1,0,0), vec3(1,0,0), 0.3f, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_3d_line_intersecting_cylinder(view_origin, view_direction, vec3(0,-1,0), vec3(0,1,0), 0.3f, c_in, c_out);\n    float d_in, d_out; bool d_hits = try_distances_along_3d_line_intersecting_cylinder(view_origin, view_direction, vec3(0,0,-1), vec3(0,0,1), 0.3f, d_in, d_out);\n    float e_in, e_out; bool e_hits = try_distances_along_line_intersecting_negation(a_hits,a_in,a_out, b_hits,b_in,b_out, e_in, e_out);\n    float f_in, f_out; bool f_hits = try_distances_along_line_intersecting_negation(e_hits,e_in,e_out, c_hits,c_in,c_out, f_in, f_out);\n    float g_in, g_out; bool g_hits = try_distances_along_line_intersecting_negation(f_hits,f_in,f_out, d_hits,d_in,d_out, g_in, g_out);\n    vec3  color = vec3(0);\n    \n    if (g_hits)\n    {\n        color = vec3(g_in/3.f);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}