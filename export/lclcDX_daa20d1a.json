{"ver":"0.1","info":{"id":"lclcDX","date":"1721714962","viewed":63,"name":"Lucid dream","username":"moloxe","description":"random things","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","creative"],"hasliked":0,"parentid":"lcXyzs","parentname":"Periodic terrain with normals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdScene(vec3 p) {\n    float t = (iTime - iTimeDelta) * .3;\n    p = rotation(vec3(\n        -PI/2.,\n        -t,\n        -t - 1.\n    )) * p;\n    const float r = 15.;\n    p.x += cos(t) * r;\n    p.y += sin(t) * r;\n    p.z += 2.;\n    float d = sdTerrain(p);\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    const float eps = 1e-4;\n    vec3 h = vec3(eps, 0.0, 0.0);\n    return normalize(vec3(\n        sdScene(p + h.xyy) - sdScene(p - h.xyy),\n        sdScene(p + h.yxy) - sdScene(p - h.yxy),\n        sdScene(p + h.yyx) - sdScene(p - h.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 ro = vec3(0., 0., 1.);\n    vec3 rd = normalize(vec3(uv, -.8));\n    \n    vec4 c = vec4(0);\n    float z = 0.;\n    float limit = 512.;\n    float maxD = 1e4;\n    for(float i = 0.; i < limit; i++) {\n        vec3 p = ro + z * rd;\n        float d = sdScene(p) / 1.4;\n        if(d < 1e-4) {\n            vec3 normal = calcNormal(p);\n            float bri = exp((sin(p.z) + 1.) / 2.) - 1.;\n            c.rgb = normal * bri;\n            break;\n        }\n        z += d;\n        if(z > maxD) break;\n    }\n    \n  \n    fragColor = c;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nfloat sdTerrain(vec3 p) {\n  float height = cos(p.x) + cos(p.y) + cos(p.z);\n  return sin(p.z) - height;\n}\n\nmat3 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n     c, 0.,  s,\n    0., 1., 0.,\n    -s, 0.,  c\n  );\n}\n\nmat3 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    1., 0., .0,\n    0.,  c, -s,\n    0.,  s,  c\n  );\n}\n\nmat3 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n     c, -s, 0.,\n     s,  c, 0.,\n    0., 0., 1.\n  );\n}\n\nmat3 rotation(vec3 angles) {\n  float cx = cos(angles.x);\n  float sx = sin(angles.x);\n  float cy = cos(angles.y);\n  float sy = sin(angles.y);\n  float cz = cos(angles.z);\n  float sz = sin(angles.z);\n\n  mat3 rotX = mat3(\n    1., 0., 0.,\n    0., cx, -sx,\n    0., sx, cx\n  );\n\n  mat3 rotY = mat3(\n    cy, 0., sy,\n    0., 1., 0.,\n    -sy, 0., cy\n  );\n\n  mat3 rotZ = mat3(\n    cz, -sz, 0.,\n    sz, cz, 0.,\n    0., 0., 1.\n  );\n\n  return rotZ * rotY * rotX;\n}\n","name":"Common","description":"","type":"common"}]}