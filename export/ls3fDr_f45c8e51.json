{"ver":"0.1","info":{"id":"ls3fDr","date":"1528319600","viewed":126,"name":"raymarch sdf","username":"minism","description":"raymarch sdf","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///// SDF LIB\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend(float d1, float d2, float k) {\n    return smin(d1, d2, k);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n    return mod(p, c) - 0.5 * c;\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 opTx(vec3 p, vec3 o) {\n    return o + p;\n}\n\n//////\n\n\nvec3 ambientColor = vec3(0, 0.5, 0.9);\nvec3 diffuseColor = vec3(0.1);\nvec3 specularColor = vec3(1);\nfloat specularity = 100.0;\nvec3 lightDir = normalize(vec3(-1, 0, 0.2));\n\nfloat sdf(vec3 p) {\n    p = opRep(p, vec3(1));\n    float d = sdBox(p, vec3(0.1));\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001, 0);\n    vec3 norm = vec3(\n       sdf(p + eps.xyy) - sdf(p - eps.xyy),\n       sdf(p + eps.yxy) - sdf(p - eps.yxy),\n       sdf(p + eps.yyx) - sdf(p - eps.yyx));\n   return normalize(norm);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, vec2 duv) {\n    vec4 ret = vec4(0, 0, 0, 0);\n    int maxsteps = 128;\n    float t = 0.0;\n    for (int i = 0; i < maxsteps; ++i) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if (d < 0.03) {\n          vec3 n = calcNormal(p);\n            \n          // Blinn-phong\n          float occ = 1.0;\n          float amb = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n          float dif = clamp(dot(lightDir, n), 0.0, 1.0);\n          vec3 h = normalize(-rd + lightDir);\n          float spec = pow(clamp(dot(h, n), 0.0, 1.0), specularity);\n          float reflectivity = 0.5;\n            \n          // Reflections\n          vec3 ref = reflect(-rd, n);\n          vec3 refColor = texture(iChannel0, ref).rgb;\n            \n          vec3 color = amb * ambientColor * occ;\n          color += dif * diffuseColor * occ;\n          color += dif * spec * specularColor * occ;\n          color += dif * refColor * reflectivity * occ;\n          color += amb * refColor * reflectivity * occ;\n      \n          // Return color.\n          ret = vec4(color, 1);\n          break;\n        }\n        t += d;\n    }\n    return ret;       \n}\n\nvec4 alphaBlend(vec4 bg, vec4 fg) {\n    return vec4(bg.rgb * (1.0 - fg.a) + fg.rgb * fg.a, 1);\n}\n\nfloat dither(vec2 duv) {\n\tfloat noise =- texture(iChannel1, duv).r;\n    float amt = 5.;\n    return mix(-amt/255.0, amt/255.0, noise);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    float cd = 9.0;\n    float cs = 0.2;\n    float cx = cos(iTime * cs) * cd - sin(iTime * cs) * cd;\n    float cz = cos(iTime * cs) * cd + sin(iTime * cs) * cd;\n    vec3 camera_pos = vec3(cx, 0, cz);\n    vec3 look_at = vec3(0, 0, 0);\n    vec3 ray_origin = camera_pos;\n    \n    \n    // camera matrix -- TODO learn this\n    vec3 ww = normalize( look_at - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray -- TODO learn ghits\n\tvec3 ray_direction = normalize( uv.x*uu + uv.y*vv + 1.9*ww );\n    \n    // vec3 bg = pow(texture( iChannel2, traceData.rayDir ).xyz,vec3(2.2));\n    vec4 bg = vec4(texture(iChannel0, ray_direction).rgb, 1);\n    vec2 duv = fragCoord.xy / iChannelResolution[1].xy;\n    vec4 sdfcol = raymarch(ray_origin, ray_direction, duv);\n    vec4 col = alphaBlend(bg, sdfcol);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}