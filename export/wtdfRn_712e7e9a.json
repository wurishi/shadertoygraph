{"ver":"0.1","info":{"id":"wtdfRn","date":"1612131423","viewed":139,"name":"Chess game - Carlsen vs Giri","username":"DanielGomez","description":"Carlsen vs Giri. Gashimov Memorial 2019.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["chess","chessboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat Circle(float radius, vec2 pos, vec2 uv)\n{\n    float distance = length(uv - pos);\n    float p = smoothstep(radius, radius - 12.0/iResolution.y, distance);\n    \n    return p;\n}\n\nfloat Ellipse (float a, float b, vec2 pos, vec2 uv)\n{\n    float c = 0.0;\n    \n    vec2 distance = uv - pos;\n    distance.x /= b;\n    distance.y /= a;\n    \n    float dist = length(vec2(distance.x, 0.0) - vec2(0.0,distance.y));\n    c = smoothstep(1.0, 1.0-12.0/iResolution.y, dist);\n    \n    return c;\n}\n\nfloat Rectangle(float h, float w, vec2 pos, vec2 uv)\n{\n    vec2 p = uv-pos;\n    p = abs(p);\n    \n    h /= 2.0;\n    w /= 2.0;\n    \n    float a = smoothstep(h, h-12.0/iResolution.y, p.y);\n    float b = smoothstep(w, w-12.0/iResolution.y, p.x);\n    \n    return a * b;\n}\n\nfloat Base(float a, float b, vec2 pos, vec2 uv)\n{\n    float c = 0.0;\n    c += Rectangle(a, b*2.0, vec2(pos.x, pos.y - a/2.0), uv);\n    if (uv.y > pos.y - 12.0/iResolution.y)\n        c += Ellipse(a, b, pos, uv);\n    \n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nfloat Neck(float h, float w1, float w2, vec2 pos, vec2 uv) //w2 = 0 -> triangle\n{\n    float c = .0;\n    \n    if (w1 > w2)\n    {\n        float angle = atan(h,(w1-w2)/2.0);\n        c += Rectangle(h,w1,pos,uv);\n        vec2 initpos = vec2(pos.x - w1/2.0 , pos.y - h/2.0);\n        vec2 line = uv - initpos;\n        float angle2 = atan(line.y,line.x);\n        if (angle2 > angle) c=0.0;\n\n        initpos = vec2(pos.x + w1/2.0 , pos.y - h/2.0);\n        line = uv - initpos;\n        angle2 = atan(line.y,abs(line.x));\n        if (angle2 > angle) c=0.0;\n    }\n    else\n    { \n        float angle = atan(h, (w2-w1)/2.0);\n        c += Rectangle(h,w2,pos,uv);\n        vec2 initpos = vec2(pos.x + w1/2.0, pos.y - h/2.0);\n        vec2 line = uv - initpos;\n        float angle2 = atan(line.y, line.x);\n        if (angle2 < angle) c = 0.0;\n        \n        initpos = vec2(pos.x - w1/2.0, pos.y - h/2.0);\n        line = uv - initpos;\n        angle2 = atan(line.y, abs(line.x));\n        if (line.x < 0.0 && angle2 < angle) c = 0.0;\n    }\n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nfloat Pawn(float size, vec2 pos, vec2 uv)\n{\n\n    float c = 0.0;\n    c += Circle(size*1.2, vec2(pos.x, pos.y + 2.0*size), uv);\n\n    float h1 = 0.5 * size;\n    float h2 = 0.7 * size;\n    float b1 = 2.5 * size;\n    float b2 = 3.0 * size;\n    float b3 = 1.0 * size;\n    c += Neck(h1 + 12.0/iResolution.y, b1, b2, vec2(pos.x, pos.y + h1/2.0), uv);\n    c += Neck(h2 + 12.0/iResolution.y, b2, b3, vec2(pos.x, pos.y + h1 + h2/2.0), uv);\n\n    float r = 2.5 *size;\n    c += Base(size*0.7, 3.0*size, vec2(pos.x, pos.y - 2.5 * size), uv);\n    c += Neck(r + 12.0/iResolution.y, r*2.0, b1, vec2(pos.x, pos.y-r/2.0), uv);\n\n    if (uv.y < pos.y)\n    {\n        c -= 2.0*Circle(size*2.2, vec2(pos.x+3.0*size, pos.y), uv);\n        c -= 2.0*Circle(size*2.2, vec2(pos.x-3.0*size, pos.y), uv);\n    }\n\n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nfloat Rook(float size, vec2 pos, vec2 uv)\n{\n    float c = 0.0;\n    c += Base(size*0.7, 3.0*size, vec2(pos.x, pos.y - 2.5 * size), uv);\n    c += Neck(4.0*size, 5.0*size, 3.5*size, vec2(pos.x, pos.y - size), uv);\n    float h1 = pos.y + 1.5*size;\n    if (uv.y < h1)\n        c += Ellipse(size * 0.8,2.5*size,vec2(pos.x, h1), uv);\n    \n    c += Neck(size/2.0 + 12.0/iResolution.y, 5.05*size, 5.25*size, vec2(pos.x, h1+size/4.0), uv);\n    c += Neck(size/2.0 + 12.0/iResolution.y, 5.2*size, 5.4*size, vec2(pos.x, h1+size/1.5), uv);\n    c += Ellipse(size * 0.8, size*2.7, vec2(pos.x, h1 + size/1.1),uv);\n    c -= 2.0*Neck(size*1.2, 0.70*size, 1.3*size, vec2(pos.x-size, h1+size*1.3), uv);\n    c -= 2.0*Neck(size*1.2, 0.70*size, 1.3*size, vec2(pos.x+size, h1+size*1.3), uv);\n    c = clamp(c, 0.0,1.0);\n    return c;\n}\n\nfloat Bishop(float size, vec2 pos, vec2 uv)\n{\n    float c = 0.0;\n    \n    c+= Base(size*0.7, 3.0*size, vec2(pos.x, pos.y - 2.5 * size), uv);\n    if (uv.y > pos.y-size*2.5)\n    if (uv.y > pos.y)\n    c += Ellipse(size*3.0, size*2.3, pos, uv);\n    c += Circle(size*2.3, pos, uv); \n    c += Circle(size*.8, vec2(pos.x,pos.y+3.25*size), uv);\n    c = clamp(c,0.0,1.0);\n    if (uv.y > pos.y && uv.x < pos.x+size*0.8)\n    {\n    c -= Ellipse(size*3.5, size,vec2(pos.x+size*0.6, pos.y),uv);\n    if (uv.x < pos.x+size*1.2)\n    c += Ellipse(size*3.5, size,vec2(pos.x+size*1.3, pos.y),uv);\n    }\n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nfloat King(float size, vec2 pos, vec2 uv)\n{\n    float c = .0;\n    c+= Base(size*0.7, 3.0*size, vec2(pos.x, pos.y - 2.5 * size), uv);\n    c+= Circle(size*1.7, vec2(pos.x+2.0*size, pos.y+size*.5), uv);\n    c+= Circle(size*1.7, vec2(pos.x-2.0*size, pos.y+size*.5), uv);\n    c+= Neck(size*2.3, 3.0*size, 7.0*size, vec2(pos.x, pos.y-size*1.5), uv);\n    c+= Rectangle(size*2.5,size*2.0,pos,uv);\n    c+= Neck(size*3.0, size*3.0, size*0.7, vec2(pos.x,pos.y + size), uv);\n    c+= Rectangle(size*1.75,size*.75,vec2(pos.x,pos.y+size*3.0),uv);\n    c+= Rectangle(size*0.75,size*1.75,vec2(pos.x,pos.y+size*3.0),uv);\n\n    c = clamp(c,0.0,1.0);\n    \n    c -= Circle(size*0.7, vec2(pos.x+size*1.5,pos.y+size*0.25), uv);\n    if (uv.x > pos.x+size*0.805 && length(uv-pos) < 2.0 * size)\n        c -= Neck(size,size,size*3.5, vec2(pos.x+size*0.805, pos.y-size*0.3), uv);\n\n    c -= Circle(size*0.7, vec2(pos.x-size*1.5,pos.y+size*0.25), uv);\n    if (uv.x < pos.x-size*0.805 && length(uv-pos) < 2.0 * size)\n        c -= Neck(size,size,size*3.5, vec2(pos.x-size*0.805, pos.y-size*0.3), uv);\n    \n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nfloat Queen(float size, vec2 pos, vec2 uv)\n{\n    float c = 0.0;\n    c+= Base(size*0.7, 3.0*size, vec2(pos.x, pos.y - 2.5 * size), uv);\n    c+= Neck(size*3.0,size*4.0, size*7.0, vec2(pos.x,pos.y-size*1.0), uv);\n    c-= Neck(size,size*2.0,size*5.0,vec2(pos.x,pos.y), uv);\n    c+= Rectangle(size*5.0,size*3.0,pos,uv);\n    c-= Neck(size*3.0,0.0,size*2.0,vec2(pos.x,pos.y+1.5*size), uv);\n    c=clamp(c,0.0,1.0);\n    c+= Circle(size*0.8, vec2(pos.x+size*1.2,pos.y+2.4*size), uv);\n    c+= Circle(size*0.8, vec2(pos.x-size*1.2,pos.y+2.4*size), uv);\n    c+= Circle(size*0.8, vec2(pos.x-size*3.1,pos.y+.9*size), uv);\n    c+= Circle(size*0.8, vec2(pos.x+size*3.1,pos.y+.9*size), uv);\n    c = clamp(c,0.0,1.0);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv-=0.5; // 0..1 --> -0.5..0.5\n    //uv.x *= iResolution.x / iResolution.y; //normalize //x from -1.7777 .. 1.7777\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    uv *= 8.0;\n    \n    vec3 whitecheckcolor = vec3(208.0, 182.0,142.0)/255.0;\n    vec3 blackcheckcolor = vec3(122.0,91.0,54.0)/255.0;\n    //chessboard\n    vec3 col = blackcheckcolor;\n    vec2 d = sin(uv*PI);\n        if ((d.x < 0.0 || d.y < 0.0) && !(d.x < 0.0 && d.y < 0.0)) col = whitecheckcolor;\n    \n   //grey background\n   if (abs(uv.x) > 4.0)\n       col = vec3(0.3);\n      \n   \n   col += Pawn(.09, vec2(3.5,-2.5), uv);\n   col += Pawn(.09, vec2(2.5,-1.5), uv); \n   col += Pawn(.09, vec2(1.5,-2.5), uv); \n   col += Pawn(.09, vec2(0.5,-1.5), uv); \n   col += Pawn(.09, vec2(-0.5,-1.5), uv); \n   col += Pawn(.09, vec2(-3.5,-1.5), uv);\n   col += Pawn(.09, vec2(-2.5,-2.5), uv);\n   col += Bishop(.09, vec2(-1.5,-1.5), uv); \n   col += Bishop(.09, vec2(2.5,-2.5), uv); \n   col += Rook(.09, vec2(1.5,-3.5), uv); \n   col += Rook(.09, vec2(-1.5,-3.5), uv); \n   col += Queen(.09, vec2(1.5,-1.5), uv); \n   col += King(.09, vec2(2.5,-3.5), uv);\n   \n   col -= Pawn(.09, vec2(-2.5,2.5), uv);\n   col -= Pawn(.09, vec2(-1.5,2.5), uv);\n   col -= Pawn(.09, vec2(-3.5,0.5), uv);\n   col -= Pawn(.09, vec2(0.5,0.5), uv);\n   col -= Pawn(.09, vec2(1.5,2.5), uv);\n   col -= Pawn(.09, vec2(2.5,2.5), uv);\n   col -= Pawn(.09, vec2(3.5,1.5), uv);\n   col -= Bishop(.09, vec2(-1.5,0.5), uv);\n   col -= Bishop(.09, vec2(-1.5,3.5), uv);\n   col -= Rook(.09, vec2(-3.5,3.5), uv); \n   col -= Rook(.09, vec2(1.5,3.5), uv); \n   col -= Queen(.09, vec2(0.5,2.5), uv); \n   col -= King(.09, vec2(2.5,3.5), uv);\n   \n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}