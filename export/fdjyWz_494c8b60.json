{"ver":"0.1","info":{"id":"fdjyWz","date":"1643507987","viewed":165,"name":"ito","username":"namanonamako","description":"raymarch","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float speed;\n\nconst vec3 lightDir = normalize(vec3(.4, .5, -.4));\n\nfloat rand(vec2 p){\n    return fract(sin(dot(p, vec2(24.6442, 71.0532))) * 5938.4291);\n}\n\nvec3 hsv(float h, float s, float v){\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nfloat rand(float p){\n    return fract(sin(p) * 5938.4291);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 cam(float t){\n    return vec3(sin(t * .2) * 2.6, cos(t * .3) * 1.8, t);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(max(d.x, d.y), d.z), 0.);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdTube(vec3 p, float r){\n    p.xy = abs(p.xy);\n    return max(p.x, p.y) - r;\n}\n\nvec2 map(vec3 p){\n    p -= vec3(cam(p.z).xy, 0.) - vec3(sin(iTime * .8 + 2.1 + p.z * .4) * 1.3, cos(iTime * .6 + 1.+ p.z* .4) * 1.6, 0.);\n    p.xy *= rot(p.z * .3);\n    \n    float bounds = sdTube(p, 2.);\n\n    p.z -= speed * 8.;\n    \n    float div = .7;\n    vec2 id = floor(p.xy * div);\n    p.xy = mod(p.xy, div) - div / 2.;\n    p.z += rand(id) * 350.;\n    \n    float div2 = 55.;\n    p.z = mod(p.z, div2) - div2 / 2.;\n\n    float d1 = sdBox(p, vec3(.04, .04, 11.));\n    \n    return vec2(max(d1, bounds), rand(id + 2.));\n}\n\nvec3 genNormal(vec3 p){\n    vec2 d = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + d.xyy).x - map(p -d.xyy).x,\n        map(p + d.yxy).x - map(p -d.yxy).x,\n        map(p + d.yyx).x - map(p -d.yyx).x\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    //col.xy = uv;\n    \n    speed = iTime*2.;\n\n    vec3 cPos = vec3(0., 0., -3. + speed);\n    cPos = cam(speed);\n    cPos += vec3(sin(iTime * .2) * 2.3, cos(iTime * .2 + 2.) * 1.5, 0.) + vec3(0., .6, 0.);\n    vec3 t = vec3(0., 0., + speed);\n    t = cam(speed + 15.5) ;\n    t += vec3(sin(iTime * .5 + 2.1) * 2.3, cos(iTime * .8 + 1.) * 2.6, 0.);\n    vec3 fwd = normalize(t - cPos);\n    vec3 side = normalize(cross(vec3(0., 1., 0.), fwd));\n    vec3 up = normalize(cross(fwd, side));\n    vec3 rd = normalize(uv.x * side + uv.y * up + fwd);\n    //cPos += 1. * rd;\n    \n    float d = .001;\n    vec2 dd;\n    int k;\n    float max_dist = 30.;\n    \n    for(int i = 0; i < 350; i++){\n        dd = map(cPos + d * rd);\n        if(abs(dd.x) < 0.001 || d > max_dist){\n            //col += 1.;\n            break;\n        }\n        k = i;\n        d += min(.1,dd.x);\n    }\n    \n    vec3 ip = cPos + d * rd;\n    vec3 bg = vec3(.8);\n\n\n    if(abs(dd.x) < 0.001){\n        vec3 normal = genNormal(ip);\n        \n        float diff = clamp(dot(normal, lightDir), 0., 1.);\n        float amb = 0.7;\n        \n        \n        col += diff + amb;\n        \n        col *= mix(vec3(1.), vec3(1., 0.1, 0.1), step(rand(dd.y * 5.), .25));\n        \n    }else{\n        col = bg;\n    }\n    float ao = (float(k) + dd.x / 0.001) / 250.;\n    //col *= ao;\n    \n    col = mix(col, bg, d / max_dist);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}