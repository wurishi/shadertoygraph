{"ver":"0.1","info":{"id":"3sKXWh","date":"1573909352","viewed":1465,"name":"Tileable textures collection","username":"alint","description":"Collection of tileable procedural textures such as: cellular noise, fbm, voronoi, perlin and other.\nGithub link: https://github.com/tuxalin/procedural-tileable-shaders\n\nNOTE. You can use left click and slide to browse through the collection.","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["procedural","voronoi","noise","fbm","textures","cellular","tileable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2019 Alin Loghin\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define SCALE   8.0 \n#define TILES   2.0     \n\n#define SHOW_TILING 1      \n#define ANIMATE 1      \n\n// hashes\n\nuint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nvec3 hash3D(vec2 x) \n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x.xyx * 65536.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) * (1.0 / float(0xffffffffu));\n}\n\nvec4 hash4D(vec2 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x.xyyx * 65536.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y * v.w;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n\nvec4 hash4D(vec4 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x * 65536.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n\n\nvec2 betterHash2D(vec2 x)\n{\n    uvec2 q = uvec2(x);\n    uint h0 = ihash1D(ihash1D(q.x) + q.y);\n    uint h1 = h0 * 1933247u + ~h0 ^ 230123u;\n    return vec2(h0, h1)  * (1.0 / float(0xffffffffu));\n}\n\n// generates a random number for each of the 4 cell corners\nvec4 betterHash2D(vec4 cell)    \n{\n    uvec4 i = uvec4(cell) + 101323u;\n    uvec4 hash = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    return vec4(hash) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the 4 cell corners\nvoid betterHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 i = uvec4(cell) + 101323u;\n    uvec4 hash0 = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    uvec4 hash1 = ihash1D(hash0 ^ 1933247u);\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the four 2D coordinates\nvoid betterHash2D(vec4 coords0, vec4 coords1, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 hash0 = ihash1D(ihash1D(uvec4(coords0.xz, coords1.xz)) + uvec4(coords0.yw, coords1.yw));\n    uvec4 hash1 = hash0 * 1933247u + ~hash0 ^ 230123u;\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n} \n\n// generates a random number for each of the 8 cell corners\nvoid betterHash3D(vec3 cell, vec3 cellPlusOne, out vec4 lowHash, out vec4 highHash)\n{\n    uvec4 cells = uvec4(cell.xy, cellPlusOne.xy);  \n    uvec4 hash = ihash1D(ihash1D(cells.xzxz) + cells.yyww);\n    \n    lowHash = vec4(ihash1D(hash + uint(cell.z))) * (1.0 / float(0xffffffffu));\n    highHash = vec4(ihash1D(hash + uint(cellPlusOne.z))) * (1.0 / float(0xffffffffu));\n}\n\n#define multiHash2D betterHash2D\n#define multiHash3D betterHash3D\n\nvoid smultiHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    multiHash2D(cell, hashX, hashY);\n    hashX = hashX * 2.0 - 1.0; \n    hashY = hashY * 2.0 - 1.0;\n}\n\n// common\n\nvec2 noiseInterpolate(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolate(const in vec4 x) \n{ \n    vec4 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolateDu(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    vec2 u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    vec2 du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n    return vec4(u, du);\n}\nvoid noiseInterpolateDu(const in vec3 x, out vec3 u, out vec3 du) \n{ \n    vec3 x2 = x * x;\n    u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n}\n\nfloat distanceMetric(vec2 pos, uint metric)\n{\n    switch (metric)\n    {\n        case 0u:\n            // squared euclidean\n            return dot(pos, pos);\n        case 1u:\n            // manhattam   \n            return dot(abs(pos), vec2(1.0));\n        case 2u:\n            // chebyshev\n            return max(abs(pos.x), abs(pos.y));\n        default:\n            // triangular\n            return  max(abs(pos.x) * 0.866025 + pos.y * 0.5, -pos.y);\n    }\n}\n\nvec4 distanceMetric(vec4 px, vec4 py, uint metric)\n{\n    switch (metric)\n    {\n        case 0u:\n            // squared euclidean\n            return px * px + py * py;\n        case 1u:\n            // manhattam   \n            return abs(px) + abs(py);\n        case 2u:\n            // chebyshev\n            return max(abs(px), abs(py));\n        default:\n            // triangular\n            return max(abs(px) * 0.866025 + py * 0.5, -py);\n    }\n}\n\n// noises\n\nfloat noise(vec2 pos, vec2 scale, float phase, float seed) \n{\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy) + seed;\n\n    vec4 hash = multiHash2D(i);\n    hash = 0.5 * sin(phase + kPI2 * hash) + 0.5;\n    float a = hash.x;\n    float b = hash.y;\n    float c = hash.z;\n    float d = hash.w;\n\n    vec2 u = noiseInterpolate(f);\n    float value = mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    return value * 2.0 - 1.0;\n}\n\nvec3 noised(vec2 pos, vec2 scale, float phase, float seed) \n{\n    const float kPI2 = 6.2831853071;\n    // value noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy) + seed;\n\n    vec4 hash = multiHash2D(i);\n    hash = 0.5 * sin(phase + kPI2 * hash) + 0.5;\n    float a = hash.x;\n    float b = hash.y;\n    float c = hash.z;\n    float d = hash.w;\n    \n    vec4 udu = noiseInterpolateDu(f);    \n    float abcd = a - b - c + d;\n    float value = a + (b - a) * udu.x + (c - a) * udu.y + abcd * udu.x * udu.y;\n    vec2 derivative = udu.zw * (udu.yx * abcd + vec2(b, c) - a);\n    return vec3(value * 2.0 - 1.0, derivative);\n}\n\nvec2 multiNoise(vec4 pos, vec4 scale, float phase, vec2 seed) \n{\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec4 i = floor(pos);\n    vec4 f = pos - i;\n    vec4 i0 = mod(i.xyxy + vec2(0.0, 1.0).xxyy, scale.xyxy) + seed.x;\n    vec4 i1 = mod(i.zwzw + vec2(0.0, 1.0).xxyy, scale.xyxy) + seed.y;\n\n    vec4 hash0 = multiHash2D(i0);\n    hash0 = 0.5 * sin(phase + kPI2 * hash0) + 0.5;\n    vec4 hash1 = multiHash2D(i1);\n    hash1 = 0.5 * sin(phase + kPI2 * hash1) + 0.5;\n    vec2 a = vec2(hash0.x, hash1.x);\n    vec2 b = vec2(hash0.y, hash1.y);\n    vec2 c = vec2(hash0.z, hash1.z);\n    vec2 d = vec2(hash0.w, hash1.w);\n\n    vec4 u = noiseInterpolate(f);\n    vec2 value = mix(a, b, u.xz) + (c - a) * u.yw * (1.0 - u.xz) + (d - b) * u.xz * u.yw;\n    return value * 2.0 - 1.0;\n}\n\nvec3 gradientNoised(vec2 pos, vec2 scale, float seed) \n{\n    // gradient noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n    \n    vec4 hashX, hashY;\n    smultiHash2D(i, hashX, hashY);\n    vec2 a = vec2(hashX.x, hashY.x);\n    vec2 b = vec2(hashX.y, hashY.y);\n    vec2 c = vec2(hashX.z, hashY.z);\n    vec2 d = vec2(hashX.w, hashY.w);\n    \n    vec4 gradients = hashX * f.xzxz + hashY * f.yyww;\n\n    vec4 udu = noiseInterpolateDu(f.xy);\n    vec2 u = udu.xy;\n    vec2 g = mix(gradients.xz, gradients.yw, u.x);\n    \n    vec2 dxdy = a + u.x * (b - a) + u.y * (c - a) + u.x * u.y * (a - b - c + d);\n    dxdy += udu.zw * (u.yx * (gradients.x - gradients.y - gradients.z + gradients.w) + gradients.yz - gradients.x);\n    return vec3(mix(g.x, g.y, u.y) * 1.4142135623730950, dxdy);\n}\nvec3 gradientNoised(vec2 pos, vec2 scale, mat2 transform, float seed) \n{\n    // gradient noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n    \n    vec4 hashX, hashY;\n    smultiHash2D(i, hashX, hashY);\n\n    // transform gradients\n    vec4 m = vec4(transform);\n    vec4 rh = vec4(hashX.x, hashY.x, hashX.y, hashY.y);\n    rh = rh.xxzz * m.xyxy + rh.yyww * m.zwzw;\n    hashX.xy = rh.xz;\n    hashY.xy = rh.yw;\n\n    rh = vec4(hashX.z, hashY.z, hashX.w, hashY.w);\n    rh = rh.xxzz * m.xyxy + rh.yyww * m.zwzw;\n    hashX.zw = rh.xz;\n    hashY.zw = rh.yw;\n    \n    vec2 a = vec2(hashX.x, hashY.x);\n    vec2 b = vec2(hashX.y, hashY.y);\n    vec2 c = vec2(hashX.z, hashY.z);\n    vec2 d = vec2(hashX.w, hashY.w);\n    \n    vec4 gradients = hashX * f.xzxz + hashY * f.yyww;\n\n    vec4 udu = noiseInterpolateDu(f.xy);\n    vec2 u = udu.xy;\n    vec2 g = mix(gradients.xz, gradients.yw, u.x);\n    \n    vec2 dxdy = a + u.x * (b - a) + u.y * (c - a) + u.x * u.y * (a - b - c + d);\n    dxdy += udu.zw * (u.yx * (gradients.x - gradients.y - gradients.z + gradients.w) + gradients.yz - gradients.x);\n    return vec3(mix(g.x, g.y, u.y) * 1.4142135623730950, dxdy);\n}\n\nvec3 gradientNoised(vec2 pos, vec2 scale, float rotation, float seed) \n{\n    vec2 sinCos = vec2(sin(rotation), cos(rotation));\n    return gradientNoised(pos, scale, mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y), seed);\n}\n\nfloat perlinNoise(vec2 pos, vec2 scale, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    // normalize: 1.0 / 0.75^3\n    gradients *= 2.3703703703703703703703703703704;\n    vec4 lengthSq = f * f;\n    lengthSq = lengthSq.xzxz + lengthSq.yyww;\n    vec4 xSq = 1.0 - min(vec4(1.0), lengthSq); \n    xSq = xSq * xSq * xSq;\n    return dot(xSq, gradients);\n}\nfloat perlinNoise(vec2 pos, vec2 scale, mat2 transform, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // transform gradients\n    vec4 m = vec4(transform);\n    vec4 rg = vec4(gradientX.x, gradientY.x, gradientX.y, gradientY.y);\n    rg = rg.xxzz * m.xyxy + rg.yyww * m.zwzw;\n    gradientX.xy = rg.xz;\n    gradientY.xy = rg.yw;\n\n    rg = vec4(gradientX.z, gradientY.z, gradientX.w, gradientY.w);\n    rg = rg.xxzz * m.xyxy + rg.yyww * m.zwzw;\n    gradientX.zw = rg.xz;\n    gradientY.zw = rg.yw;\n\n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    // normalize: 1.0 / 0.75^3\n    gradients *= 2.3703703703703703703703703703704;\n    f = f * f;\n    f = f.xzxz + f.yyww;\n    vec4 xSq = 1.0 - min(vec4(1.0), f); \n    return dot(xSq * xSq * xSq, gradients);\n}\nfloat perlinNoise(vec2 pos, vec2 scale, float rotation, float seed) \n{\n    vec2 sinCos = vec2(sin(rotation), cos(rotation));\n    return perlinNoise(pos, scale, mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y), seed);\n}\n\nvec3 perlinNoised(vec2 pos, vec2 scale, mat2 transform, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // transform gradients\n    vec4 mt = vec4(transform);\n    vec4 rg = vec4(gradientX.x, gradientY.x, gradientX.y, gradientY.y);\n    rg = rg.xxzz * mt.xyxy + rg.yyww * mt.zwzw;\n    gradientX.xy = rg.xz;\n    gradientY.xy = rg.yw;\n\n    rg = vec4(gradientX.z, gradientY.z, gradientX.w, gradientY.w);\n    rg = rg.xxzz * mt.xyxy + rg.yyww * mt.zwzw;\n    gradientX.zw = rg.xz;\n    gradientY.zw = rg.yw;\n    \n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    vec4 m = f * f;\n    m = m.xzxz + m.yyww;\n    m = max(1.0 - m, 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m * m2;\n    // compute the derivatives\n    vec4 m2Gradients = -6.0 * m2 * gradients;\n    vec2 grad = vec2(dot(m2Gradients, f.xzxz), dot(m2Gradients, f.yyww)) + vec2(dot(m3, gradientX), dot(m3, gradientY));\n    // sum the surflets and normalize: 1.0 / 0.75^3\n    return vec3(dot(m3, gradients), grad) * 2.3703703703703703703703703703704;\n}\n\nfloat organicNoise(vec2 pos, vec2 scale, float density, vec2 phase, float contrast, float highlights, float shift, float seed)\n{\n    vec2 s = mix(vec2(1.0), scale - 1.0, density);\n    float nx = perlinNoise(pos + phase, scale, seed);\n    float ny = perlinNoise(pos, s, seed);\n\n    float n = length(vec2(nx, ny) * mix(vec2(2.0, 0.0), vec2(0.0, 2.0), shift));\n    n = pow(n, 1.0 + 8.0 * contrast) + (0.15 * highlights) / n;\n    return n * 0.5;\n}\n\nvec2 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float seed)\n{\n    float strength = jitter * 1.25;\n\n    // compute gradient\n    // TODO: compute the gradient analytically\n    vec2 grad;\n    vec3 offsets = vec3(1.0, 0.0, -1.0) / 1024.0;\n    vec4 p = pos.xyxy + offsets.xyzy;\n    vec2 nv = count * (strength * multiNoise(p, scale.xyxy, phase, vec2(seed)) + p.yw);\n    grad.x = nv.x - nv.y;\n    p = pos.xyxy + offsets.yxyz;\n    nv = count * (strength * multiNoise(p, scale.xyxy, phase, vec2(seed)) + p.yw);\n    grad.y = nv.x - nv.y;\n    \n    float v =  count * (strength * noise(pos, scale, phase, seed) + pos.y);\n    float w = fract(v) / length(grad / (2.0 * offsets.x));\n    width *= 0.1;\n    smoothness *= width;\n    smoothness += max(abs(grad.x), abs(grad.y)) * 0.02;\n    \n    float d = smoothstep(0.0, smoothness.x, w) - smoothstep(max(width - smoothness.y, 0.0), width, w);\n    return vec2(d, mod(floor(v), count));\n}\nvec4 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float colorVariation, float seed)\n{\n    vec2 l = randomLines(pos, scale, count, width, jitter, smoothness, phase, seed);\n    vec3 r = hash3D(l.yy + seed);\n    return vec4(l.x * (r.x < colorVariation ? r : r.xxx), l.x);\n}\n\nvec4 fbmMulti(vec2 pos, vec2 scale, float lacunarity, int octaves, float phase, float seed) \n{    \n    vec4 seeds = vec4(0.0, 1031.0, 537.0, 23.0) + seed;\n    float f = 2.0 / lacunarity;\n    \n    vec4 value = vec4(0.0);\n    float w = 1.0;\n    float acc = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        vec2 ns = vec2(scale / w);\n        vec4 n;\n        n.xy = multiNoise(pos.xyxy, ns.xyxy, phase, seeds.xy);\n        n.zw = multiNoise(pos.xyxy, ns.xyxy, phase, seeds.zw);\n        value += (n * 0.5 + 0.5) * w;\n        acc += w;\n        w *= 0.5 * f;\n    }\n    return value / acc;\n}\n\nvec3 dotsNoise(vec2 pos, vec2 scale, float density, float size, float sizeVariation, float roundness, float seed) \n{\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy);\n    \n    vec4 hash = hash4D(i.xy + seed);\n    if (hash.w > density)\n        return vec3(0.0);\n\n    float radius = clamp(size + (hash.z * 2.0 - 1.0) * sizeVariation * 0.5, 0.0, 1.0);\n    float value = radius / size;  \n    radius = 2.0 / radius;\n    f = f * radius - (radius - 1.0);\n    f += hash.xy * (radius - 2.0);\n    f = pow(abs(f), vec2((mix(20.0, 1.0, sqrt(roundness)))));\n\n    float u = 1.0 - min(dot(f, f), 1.0);\n    return vec3(clamp(u * u * u * value, 0.0, 1.0), hash.w, hash.z);\n}\n\n\n// worley noises\n\nvec2 cellularNoise(vec2 pos, vec2 scale, float jitter, float phase, uint metric, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = distanceMetric(dx0, dy0, metric);\n    vec4 d1 = distanceMetric(dx1, dy1, metric);\n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 *  multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    vec4 F = min(d0, d1);\n    // shuffle into F the 4 lowest values\n    F = min(F, max(d0, d1).wzyx);\n    // shuffle into F the 2 lowest values \n    F.xy = min(min(F.xy, F.zw), max(F.xy, F.zw).yx);\n    // add the last value\n    F.zw = vec2(distanceMetric(centerPos, metric), 1e+5);\n    // shuffle into F the final 2 lowest values \n    F.xy = min(min(F.xy, F.zw), max(F.xy, F.zw).yx);\n    \n    vec2 f12 = vec2(min(F.x, F.y), max(F.x, F.y));\n    // normalize: 0.75^2 * 2.0  == 1.125\n    return (metric == 0u ? sqrt(f12) : f12) * (1.0 / 1.125);\n}\nvec3 cellularNoised(vec2 pos, vec2 scale, float jitter, float phase, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = dx0 * dx0 + dy0 * dy0; \n    vec4 d1 = dx1 * dx1 + dy1 * dy1; \n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 *  multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    float dCenter = dot(centerPos, centerPos);\n    vec4 d = min(d0, d1);\n    vec4 less = step(d1, d0);\n    vec4 dx = mix(dx0, dx1, less);\n    vec4 dy = mix(dy0, dy1, less);\n\n    vec3 t1 = d.x < d.y ? vec3(d.x, dx.x, dy.x) : vec3(d.y, dx.y, dy.y);\n    vec3 t2 = d.z < d.w ? vec3(d.z, dx.z, dy.z) : vec3(d.w, dx.w, dy.w);\n    t2 = t2.x < dCenter ? t2 : vec3(dCenter, centerPos);\n    vec3 t = t1.x < t2.x ? t1 : t2;\n    t.x = sqrt(t.x);\n    // normalize: 0.75^2 * 2.0  == 1.125\n    return  t * vec3(1.0, -2.0, -2.0) * (1.0 / 1.125);\n}\n\nvec3 voronoi(vec2 pos, vec2 scale, float jitter, float phase, float seed)\n{\n     // voronoi based on Inigo Quilez: https://archive.is/Ta7dm\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n\n    // first pass\n    vec2 minPos, tilePos;\n    float minDistance = 1e+5;\n    for (int y=-1; y<=1; y++)\n    {\n        for (int x=-1; x<=1; x++)\n        {\n            vec2 n = vec2(float(x), float(y));\n            vec2 cPos = hash2D(mod(i + n, scale) + seed) * jitter;\n            cPos = 0.5 * sin(phase + kPI2 * cPos) + 0.5;\n            vec2 rPos = n + cPos - f;\n\n            float d = dot(rPos, rPos);\n            if(d < minDistance)\n            {\n                minDistance = d;\n                minPos = rPos;\n                tilePos = cPos;\n            }\n        }\n    }\n\n    // second pass, distance to edges\n    minDistance = 1e+5;\n    for (int y=-2; y<=2; y++)\n    {\n        for (int x=-2; x<=2; x++)\n        { \n            vec2 n = vec2(float(x), float(y));\n            vec2 cPos = hash2D(mod(i + n, scale) + seed) * jitter;\n            cPos = 0.5 * sin(phase + kPI2 * cPos) + 0.5;\n            vec2 rPos = n + cPos - f;\n            \n            vec2 v = minPos - rPos;\n            if(dot(v, v) > 1e-5)\n                minDistance = min(minDistance, dot( 0.5 * (minPos + rPos), normalize(rPos - minPos)));\n        }\n    }\n\n    return vec3(minDistance, tilePos);\n}\nvec3 cracks(vec2 pos, vec2 scale, float jitter, float width, float smoothness, float warp, float warpScale, bool warpSmudge, float smudgePhase, float seed)\n{\n    vec3 g = gradientNoised(pos, scale * warpScale, smudgePhase, seed);\n    pos += (warpSmudge ? g.yz : g.xx) * 0.1 * warp;\n    vec3 v = voronoi(pos, scale, jitter, 0.0, seed);\n    return vec3(smoothstep(max(width - smoothness, 0.0), width + fwidth(v.x), v.x), v.yz);\n}\n\nfloat metaballs(vec2 pos, vec2 scale, float jitter, float phase, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = dx0 * dx0 + dy0 * dy0; \n    vec4 d1 = dx1 * dx1 + dy1 * dy1; \n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 * multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    \n    float d = min(1.0, dot(centerPos, centerPos));\n    d = min(d, d * d0.x);\n    d = min(d, d * d0.y);\n    d = min(d, d * d0.z);\n    d = min(d, d * d0.w);\n    d = min(d, d * d1.x);\n    d = min(d, d * d1.y);\n    d = min(d, d * d1.z);\n    d = min(d, d * d1.w);\n    \n    return sqrt(d);\n}\n\nfloat metaballs(vec2 pos, vec2 scale, float jitter, float phase, float width, float smoothness, float seed) \n{       \n    float d = metaballs(pos, scale, jitter, phase, seed);\n    return smoothstep(width, width + smoothness, d);\n}\n\n// fbms\n\nfloat fbm(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float n = noise(p / frequency, frequency, time, seed);\n        value += amplitude * n;\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    return value * 0.5 + 0.5;\n}\n\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, vec2 shift, float timeShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    // fbm implementation based on Inigo Quilez\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift.x), cos(shift.y));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n\n    vec3 value = vec3(0.0);\n    vec2 derivative = vec2(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 n =  noised(p / frequency, frequency, time, seed).xyz;\n        derivative += n.yz;\n\n        n *= amplitude;\n        n.x /= (1.0 + mix(0.0, dot(derivative, derivative), slopeness));\n        value += n; \n        \n        p = (p + shift) * lacunarity;\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        shift = shift * rotate;\n        time += timeShift;\n    }\n    \n    value.x = value.x * 0.5 + 0.5;\n    return value;\n}\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    return fbmd(pos, scale, octaves, vec2(shift), timeShift, gain, vec2(lacunarity), slopeness, octaveFactor, seed);\n}\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, vec2 shift, float timeShift, float gain, float lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    return fbmd(pos, scale, octaves, shift, timeShift, gain, vec2(lacunarity), slopeness, octaveFactor, seed);\n}\n\nfloat fbmMetaballs(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float jitter, float interpolate, vec2 width, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n    \n    float n = 1.0;\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float cn = metaballs(p / frequency, frequency, jitter, timeShift, width.x, width.y, seed) * 2.0 - 1.0;\n        n *= cn;\n        value += amplitude * mix(n, abs(n), interpolate);\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    return value * 0.5 + 0.5;\n}\n\nfloat fbmPerlin(vec2 pos, vec2 scale, int octaves, float shift, float axialShift, float gain, float lacunarity, uint mode, float factor, float offset, float seed) \n{\n    float amplitude = gain;\n    vec2 frequency = floor(scale);\n    float angle = axialShift;\n    float n = 1.0;\n    vec2 p = fract(pos) * frequency;\n\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float pn = perlinNoise(p / frequency, frequency, angle, seed) + offset;\n        if (mode == 0u)\n        {\n            n *= abs(pn);\n        }\n        else if (mode == 1u)\n        {\n            n = abs(pn);\n        }\n        else if (mode == 2u)\n        {\n            n = pn;\n        }\n        else if (mode == 3u)\n        {\n            n *= pn;\n        }\n        else if (mode == 4u)\n        {\n            n = pn * 0.5 + 0.5;\n        }\n        else\n        {\n            n *= pn * 0.5 + 0.5;\n        }\n        \n        n = pow(n < 0.0 ? 0.0 : n, factor);\n        value += amplitude * n;\n        \n        p = p * lacunarity + shift;\n        frequency *= lacunarity;\n        amplitude *= gain;\n        angle += axialShift;\n    }\n    return value;\n}\n\nvec3 fbmdPerlin(vec2 pos, vec2 scale, int octaves, vec2 shift, mat2 transform, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed) \n{\n    // fbm implementation based on Inigo Quilez\n    float amplitude = gain;\n    vec2 frequency = floor(scale);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.3;\n\n    vec3 value = vec3(0.0);\n    vec2 derivative = vec2(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 n = perlinNoised(p / frequency, frequency, transform, seed);\n        derivative += n.yz;\n        n.x = negative ? n.x : n.x * 0.5 + 0.5;\n        n *= amplitude;\n        value.x += n.x / (1.0 + mix(0.0, dot(derivative, derivative), slopeness));\n        value.yz += n.yz; \n        \n        p = (p + shift) * lacunarity;\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        transform *= transform;\n    }\n\n    return clamp(value,-1.,1.);\n}\nvec3 fbmdPerlin(vec2 pos, vec2 scale, int octaves, vec2 shift, float axialShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed) \n{\n    vec2 cosSin = vec2(cos(axialShift), sin(axialShift));\n    mat2 transform = mat2(cosSin.x, cosSin.y, -cosSin.y, cosSin.x) * mat2(0.8, -0.6, 0.6, 0.8);\n    return fbmdPerlin(pos, scale, octaves, shift, transform, gain, lacunarity, slopeness, octaveFactor, negative, seed);\n}\n\nvec4 fbmVoronoi(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float jitter, float interpolate, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n    \n    float n = 1.0;\n    vec4 value = vec4(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 v = voronoi(p / frequency, frequency, jitter, timeShift, seed);\n        v.x = v.x * 2.0 - 1.0;\n        n *= v.x;\n        value += amplitude * vec4(mix(v.x, n, interpolate), hash3D(v.yz));\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    value.x = value.x * 0.5 + 0.5;\n    return value;\n}\n\n\n// warp\n\nfloat fbmWarp(vec2 pos, vec2 scale, vec2 factors, int octaves, vec4 shifts, float timeShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed,\n              out vec2 q, out vec2 r) \n{\n    // domain warping with factal sum value noise\n\n    float qfactor = factors.x;\n    float rfactor = factors.y;\n    q.x = fbmd(pos, scale, octaves, vec2(0.0), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    q.y = fbmd(pos, scale, octaves, vec2(shifts.x), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    q = negative ? q * 2.0 - 1.0 : q;\n    \n    vec2 np = pos + qfactor * q;\n    r.x = fbmd(np, scale, octaves, vec2(shifts.y), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    r.y = fbmd(np, scale, octaves, vec2(shifts.z), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    r = negative ? r * 2.0 - 1.0 : r;\n    \n    return fbmd(pos + r * rfactor, scale, octaves, vec2(shifts.w), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n}\n\nfloat perlinNoiseWarp(vec2 pos, vec2 scale, float strength, float phase, float factor, float spread, float seed)\n{\n    vec2 offset = vec2(spread, 0.0);\n    strength *= 32.0 / max(scale.x, scale.y);\n    \n    vec4 gp;\n    gp.x = perlinNoise(pos - offset.xy, scale, phase, seed);\n    gp.y = perlinNoise(pos + offset.xy, scale, phase, seed);\n    gp.z = perlinNoise(pos - offset.yx, scale, phase, seed);\n    gp.w = perlinNoise(pos + offset.yx, scale, phase, seed);\n    gp = pow(gp, vec4(factor));\n    vec2 warp = vec2(gp.y - gp.x, gp.w - gp.z);\n    return pow(perlinNoise(pos + warp * strength, scale, phase, seed), factor);\n}\n\nfloat curlWarp(vec2 pos, vec2 scale, vec2 factors, vec4 seeds, float curl, float seed,\n               out vec2 q, out vec2 r)\n{\n    float qfactor = factors.x;\n    float rfactor = factors.y;\n    vec2 curlFactor = vec2(1.0, -1.0) * vec2(curl, 1.0 - curl);\n    \n    vec2 n = gradientNoised(pos, scale, seed).zy * curlFactor;\n    q.x = n.x + n.y;\n    n = gradientNoised(pos + hash2D(seeds.xx), scale, seed).zy * curlFactor;\n    q.x = n.x + n.y;\n    \n    vec2 np = pos + qfactor * q;\n    n = gradientNoised(np + hash2D(seeds.yy), scale, seed).zy * curlFactor;\n    r.x = n.x + n.y;\n    n = gradientNoised(np + hash2D(seeds.zz), scale, seed).zy * curlFactor;\n    r.y = n.x + n.y;\n\n    return perlinNoise(pos + r * rfactor + hash2D(seeds.ww), scale, seed);\n}\n\n// other\n\nfloat sdfLens(vec2 p, float width, float height)\n{\n    float d = 1.0 / width - width / 4.0;\n    float r = width / 2.0 + d;\n    \n    p = abs(p);\n\n    float b = sqrt(r * r - d * d);\n    vec4 par = p.xyxy - vec4(0.0, b, -d, 0.0);\n    return (par.y * d > p.x * b) ? length(par.xy) : length(par.zw) - r;\n}\nvec3 tileWeave(vec2 pos, vec2 scale, float count, float width, float smoothness)\n{\n    vec2 i = floor(pos * scale);    \n    float c = mod(i.x + i.y, 2.0);\n    \n    vec2 p = fract(pos.st * scale);\n    p = mix(p.st, p.ts, c);\n    p = fract(p * vec2(count, 1.0));\n    \n    // Vesica SDF based on Inigo Quilez\n    width *= 2.0;\n    p = p * 2.0 - 1.0;\n    float d = sdfLens(p, width, 1.0);\n    vec2 grad = vec2(dFdx(d), dFdy(d));\n\n    float s = 1.0 - smoothstep(0.0, dot(abs(grad), vec2(1.0)) + smoothness, -d);\n    return vec3(s , normalize(grad) * smoothstep(1.0, 0.99, s) * smoothstep(0.0, 0.01, s)); \n}\n\nvec3 checkers45(const in vec2 pos, const in vec2 scale, const in vec2 smoothness)\n{\n    // based on filtering the checkerboard by Inigo Quilez \n    vec2 numTiles = floor(scale); \n    vec2 p = pos * numTiles * 2.0;\n    \n    const float angle = 3.14152 / 4.0;\n    const float cosAngle = cos(angle);\n    const float sinAngle = sin(angle);\n\n    p *= 1.0 / sqrt(2.0);\n    p = p * mat2(cosAngle, sinAngle, -sinAngle, cosAngle);\n    p += vec2(0.5, 0.0);\n    vec2 tile = mod(floor(p), numTiles);\n    \n    vec2 w = smoothness;\n    // box filter using triangular signal\n    vec2 s1 = abs(fract((p - 0.5 * w) / 2.0) - 0.5);\n    vec2 s2 = abs(fract((p + 0.5 * w) / 2.0) - 0.5);\n    vec2 i = 2.0 * (s1 - s2) / w;\n    float d = 0.5 - 0.5 * i.x * i.y; // xor pattern\n    return vec3(d, tile);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 p = fract(uv * TILES);\n    vec2 scale = vec2(SCALE);\n\t\n    const float totalCount = 19.0;\n    vec3 col;\n    float current;\n    if(iMouse.z > 0.0)\n    \tcurrent = (iMouse.x / iResolution.x) * totalCount;\n    else\n    {\n        current = mod(iTime * 0.5, totalCount);\n#if ANIMATE == 1\n    \tp += iTime * 0.03;\n#endif\n    }\n\n    current = clamp(floor(current), 0.0, totalCount - 1.0);\n\n    if(current < 1.0)\n    {\n        col = vec3(perlinNoise(p, scale, /*rotation:*/ iTime * 0.25, 0.0)) * 0.5 + 0.5;\n    }\n    else if(current < 2.0)\n    {\n        uint mode = uint(mod(iTime, 5.0));\n        if(mode == 4u)\n        {\n            col += cellularNoised(p, scale, /*jitter:*/ 1.0, /*phase*/ iTime * 0.5, 23.0).yzx * 0.5 + 0.5;\n        }\n        else\n        {\n        \tvec2 cells = cellularNoise(p, scale, /*jitter:*/ 1.0, /*phase:*/ iTime * 0.5, /*metric*/ mode, 0.0);\n        \tcol += 1.0 - cells.x;\n        }\n        \n    }\n    else if(current < 3.0)\n    {\n        col = vec3(perlinNoiseWarp(p, scale, /*strength:*/ 0.9, /*phase:*/ iTime * 0.5, mix(2.0, 6.0, abs(sin(iTime))), /*spread:*/ 0.001, 0.0));\n    }\n    else if(current < 4.0)\n    {\n        vec2 tilePos;\n        vec3 c = cracks(p, scale, /*jitter*/ 0.5 + sin(iTime) * 0.2, /*width:*/ 0.1, /*smoothness:*/ 0.5, /*warp:*/ 0.1, /*warpScale:*/ 4.0, /*warpSmudge:*/ true, /*smudgePhase:*/ iTime * 0.75, 23.0);\n        col += c.x;\n        col *= hash3D(c.yz*0.0001);\n    }\n    else if(current < 5.0)\n    {\n        float jitter = 0.2 + sin(iTime*0.5 + 23.0) * 0.1;\n        col+= randomLines(p + vec2(0.0, iTime * 0.35), scale, /*count*/ 14.0, /*width*/ 0.15, jitter, /*smoothness*/ vec2(0.1, 0.5), /*phase*/ iTime * 0.5, /*colorVariation*/ 0.5 + sin(iTime*0.5) * 0.5, 13.0).rgb;\n    }\n    else if(current < 6.0)\n    {\n       vec3 c = checkers45(p, scale, /*smoothness*/ vec2(0.5));\n       col += c.x;\n        \n       vec4 hash = hash4D(c.yz + mod(floor(iTime * 1.5), 128.0));\n       if(hash.w < (0.5 + sin(iTime * 0.5) * sin(iTime * 0.5) * 0.2))\n       \t\tcol += smoothstep(0.5, 0.0, c.x) * hash.rgb;\n    }\n    else if(current < 7.0)\n    {\n        vec3 d = dotsNoise(p, scale, /*density*/ 0.5 + sin(iTime * 0.5) * 0.25, /*size*/ 0.45, /*sizeVariation*/ 0.7 + sin(iTime + 0.25) * 0.3, /*roundness*/ 0.7 + sin(iTime * 2.0 + 23.0) *  0.3, 0.0);\n        col += hash3D(d.yy) * d.x * (d.z + 0.5);\n    }\n    else if(current < 8.0)\n    {\n        vec2 offset = vec2(iTime,cos(iTime*0.25)*2.)*0.015;\n\t\tcol += fbm(uv + offset, scale, 9, /*shift:*/ 23.0,  /*timeShift: */ iTime * 0.25, /*gain:*/ 0.49, /*lacunarity*/ 2.0, /*octaveFactor:*/ -0.5, 0.0);\n    }\n    else if(current < 9.0)\n    {\n        \n        col += fbmMetaballs(p, scale, 8, 0.0, /*timeShift:*/ iTime * 0.5, /*gain*/ 0.5, /*lacunarity*/ 2.0, /*octaveFactor*/ 0.0, /*jitter*/ 1.0, /*interpolate*/ 0.1, vec2(0.1, 0.03), 0.0); \n    }\n\n    else if(current < 10.0)\n    {\n        vec4 v = fbmVoronoi(p, scale, 16, /*shift*/ 0.5, /*timeShift:*/ iTime * 0.000005, /*gain*/ 0.5, /*lacunarity*/ 2.0, /*octaveFactor:*/ -0.3, /*jitter*/ 1.0, /*interpolate*/ 0.0, 0.00);\n        col = vec3(smoothstep(0.02, 0.10, v.x)) * v.yzw;\n    }\n    else if(current < 11.0)\n    {\n        vec3 tw = tileWeave(p, scale * 0.5, /*count*/ 3.0, /*width*/ 0.75, /*smoothness*/ 0.5 + sin(iTime) * 0.3);\n        col = vec3(fragCoord.x / iResolution.x < 0.5 ? tw.xxx : normalize(vec3(tw.yz, 1.0)) * 0.5 + 0.5);\n    }\n    else if(current < 12.0)\n    {\n        float axialShift = sin(iTime * 4.25) * sin(iTime * 4.25 + 0.53) * 0.64;\n        col = vec3(fbmPerlin(p, scale * 0.5, 16, /*shift*/ -iTime * 0.21, axialShift, /*gain*/ 0.3, /*lacunarity*/ 2.0, /*mode*/ 0u, /*factor*/ 0.75, /*offset*/ 0.0, 0.0)) * 2.0;\n    }\n    else if(current < 13.0)\n    {\n        vec2 phase = vec2(iTime *0.15, iTime *0.05 + 0.5);\n        col = vec3(organicNoise(p, scale, /*density*/ 1.0, phase, /*contrast*/ 0.0, /*highlights*/ 0.25, /*shift*/ 0.5 + 0.4 * sin(iTime),0.));\n    }\n    else if(current < 14.0)\n    {\n        col = fbmd(p, scale, 16, /*shift:*/ vec2(0.0), /*timeShift*/ iTime * 0.5, /*gain:*/ 0.5, /*lacunarity*/ vec2(2.0), /*slopeness:*/ 0.2 + sin(iTime) * 0.2, /*octaveFactor:*/ 0.5, 0.0).yzx * 0.5 + 0.5;\n        col = mix(col, col.zzz * 2.0 - 1.0, step(fragCoord.x / iResolution.x, 0.5));\n    }\n    else if(current < 15.0)\n    {\n        col = fbmdPerlin(p, scale, 8, /*shift:*/ vec2(iTime)*0.01, /*axialShift*/ iTime * 0.2, /*gain:*/ 0.45, vec2(2.0), /*slopeness:*/ 0.5, /* octaveFactor*/ sin(iTime) * 0.5, false, 0.0).yzx;\n        col = mix(normalize(col + vec3(0.,0.,1.)) * 0.5 + 0.5, col.zzz, step(fragCoord.x / iResolution.x, 0.5));\n    }\n    else if(current < 17.0)\n    {\n        // domain warping example\n        \n        int octaves = 16;\n        float gain = 0.5;\n        float lacunarity = 2.0;\n        float slopeness = 0.5;\n        vec2 factors = vec2(1.0);\n        vec4 shifts = vec4(123.0, 235.0, 53.0, 511.0);\n        \n        vec2 q;\n        vec2 r;\n    \tfloat f = current < 16.0 ? fbmWarp(p, scale, factors, octaves, shifts, iTime * 0.1, gain, vec2(lacunarity), slopeness, 0.0, false, 0.0, q, r) :\n        fbmWarp(p, scale, factors, octaves, shifts, iTime * 0.25, gain*0.93, vec2(lacunarity), slopeness, -0.5, true, 0.0, q, r);\n        \n        if (current < 16.0)\n        {\n            col = mix(vec3(0.1,0.5,0.8), vec3(0.6,0.6,0.3), clamp((f * f) * 8.0, 0.0, 1.0));\n            col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n            col = mix(col, vec3(0.8, 0.8, 0.8), r.x);\n            col = mix(col, col * vec3(0.8, 0.4, 0.2), 0.5 * pow(length(r), 4.0));\n        }\n        else\n        {\n            col = mix(vec3(0.1,0.4,0.7), vec3(0.6,0.5,0.3), clamp((f * f) * 1.0, 6.0, 3.0));\n            col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n            col = mix(col, vec3(0.1), r.x);\n            col = mix(col, col * vec3(1.8, 0.4, 0.2), 0.75 * pow(length(r), 10.0)) * 0.95;\n        }\n    }\n    else if(current < 18.0)\n    {\n        // domain warping with curl noise example\n\n        vec2 factors = vec2(1.25);\n        float curl = abs(sin(iTime * 0.5));\n        curl *= curl;\n        vec4 seeds = vec4(123.0, 235.0, 53.0, 511.0);\n        scale *= 0.25;\n        \n        vec2 q;\n        vec2 r;\n    \tfloat f = curlWarp(p, scale, factors, seeds, curl, 2.0, q, r);\n        col = vec3(1.0 - f);\n        col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n        col = mix(col, col * vec3(0.2, 0.4, 0.8), pow(length(r), 2.0));\n    }\n    else if(current < 19.0)\n    {\n        // multi value noise FBM\n        \n        int octaves = 16;\n        float lacunarity = 2.0;\n        \n        vec4 n = fbmMulti(uv, floor(scale * vec2(0.5, 1.)), lacunarity, octaves, iTime, 0.0);\n        n.xy = n.xz - n.yw;\n        vec2 v = 1.0 - pow(abs(n.xy) * 4.0, vec2(0.1));\n        col = vec3(pow(1.0 - v.x * v.y, 3.0));\n    }\n    \n#if SHOW_TILING == 1\n    vec2 pixel = vec2(TILES) / iResolution.xy;\n    uv *= TILES;\n\n    vec2 first = step(pixel, uv) * floor(mod(iTime * 0.75, 4.0)) * 0.25;        \n    uv  = step(fract(uv), pixel);               \n    col = mix(col, vec3(0.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}