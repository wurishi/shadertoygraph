{"ver":"0.1","info":{"id":"ct23Dz","date":"1673159401","viewed":131,"name":"lighted voxel shader","username":"wilowilo","description":"personal reference fork of https://www.shadertoy.com/view/4dX3zl , adds diffuse lighting while keeping the branchless traversal an option (creates the normals from the mask). useful as a reference if anyone else didn't see how to do it","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycast","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst bool USE_BRANCHLESS_DDA = false;\nconst int MAX_RAY_STEPS = 1000;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 rayPos = vec3(0.0, 0.0, -17.0);\n    vec3 rayDir = normalize(vec3(uv, 1.02));\n\t\t\n\t//rayPos.xz = rotate2d(rayPos.xz, iTime);\n\t//rayDir.xz = rotate2d(rayDir.xz, iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    \n\tbvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos)) contine;\n\t\tif (USE_BRANCHLESS_DDA) {\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t/*bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\t\tmask.x = b1.x && b2.x;\n\t\t\tmask.y = b1.y && b2.y;\n\t\t\tmask.z = b1.z && b2.z;*/\n\t\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\t\n\t\t\t//All components of mask are false except for the corresponding largest component\n\t\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t\t}\n\t\telse {\n\t\t\tif (sideDist.x < sideDist.y) {\n\t\t\t\tif (sideDist.x < sideDist.z) {\n\t\t\t\t\tsideDist.x += deltaDist.x;\n\t\t\t\t\tmapPos.x += rayStep.x;\n\t\t\t\t\tmask = bvec3(true, false, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sideDist.y < sideDist.z) {\n\t\t\t\t\tsideDist.y += deltaDist.y;\n\t\t\t\t\tmapPos.y += rayStep.y;\n\t\t\t\t\tmask = bvec3(false, true, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n    vec3 lightPosition = rayPos;\n    vec3 lightDirection = normalize(lightPosition-vec3(mapPos));\n    \n    vec3 normals = vec3(mask) * vec3(-rayStep);\n    \n    float diff = clamp(dot(normals, lightDirection), 0.3, 1.0);\n\t\n\tvec3 color = vec3(1.0);\n\t\n\tfragColor.rgb = color*diff;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n\t//fragColor.rgb = vec3(0.1 * noiseDeriv);\n}","name":"Image","description":"","type":"image"}]}