{"ver":"0.1","info":{"id":"fssyzs","date":"1642537936","viewed":111,"name":"Line segment distance on sphere","username":"arkanis","description":"Geodesic distance from a point on a sphere to a line segment on a sphere. I use it as a base to generate canyons on planets.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","distance","geodesic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 Stephan Soller\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// \n// My first try to get the geodesic distance to a line segment on a sphere.\n// \n// Primary inspirations:\n// - Projecting sphere points onto a plane by Eric Nitardy:\n//   https://math.stackexchange.com/questions/23054/how-to-find-the-distance-between-a-point-and-line-joining-two-points-on-a-sphere#answer-23612\n// - The way sdCapsule() works by Inigo Quilez\n//   https://iquilezles.org/articles/distfunctions\n// \n// Used https://www.shadertoy.com/view/ldl3Dl by Inigo Quilez for the visualization.\n// Mostly because I'm lazy.\n// \n// Didn't find anything related on shadertoy, so I posted it here. The algorithm is cobbled together\n// from various parts. There a probably way better and faster solutions to this, feel free to explore. :)\n// I use it as a base to generate canyons on planets. For that the progress_on_line_segment variable\n// was especially useful. That might have skewed my choice of algorithm a bit.\n// \n// BUGS:\n// The distance around the start point a is slightly squashed. Haven't looked into that yet. Just be aware. ;)\n// \n// OPTIMIZATION / SIMPLIFICATION IDEAS:\n// - Right now the angle between a and b is clamped to [0, 1]. On the way each fragment is projected\n//   onto the plane/circle that has a, b and the origin on it. Maybe it's simpler or faster to clamp\n//   that projected point to the circle slice created by a, b and the origin.\n// - Currently the angle between a and the projected fragment position is calculated, mapped to\n//   [0, 1] (where 1 is the angle between a and b), clamped and finally slerped back into a 3D point.\n//   It should be enough to just calculate the angle, clamp it to the range [0, angle between a and b]\n//   and then calculate a new 3D point based on that angle. Gets rid of the [0, 1] mapping. Might be\n//   simpler over all than using slerp().\n\n\n\n//===============================================================================================\n//===============================================================================================\n\n\n// Maps value between start and end to 0..1 depending on where between the two it is.\n// Like smoothstep() but not smooth. It just uses linear interpolation (a line instead of a curve).\nfloat linstep(float start, float end, float value) {\n\treturn clamp((value - start) / (end - start), 0.0, 1.0);\n}\n\n// Spherical interpolation between the two points a and b where t in [0, 1] specifies how far along we are.\n// Assumes a and b are normalized, otherwise the dot product will not have the proper value range.\n// Based on Slerp() by KeithM from https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\n// Removed the clamp() of the dot product because we assume normalized vectors.\nvec3 slerp(vec3 a, vec3 b, float t) {\n\t// Dot product - the cosine of the angle between 2 vectors.\n\tfloat d = dot(a, b);\n\t// acos(d) returns the angle between a and b, and multiplying that by t returns the angle between a and the final result.\n\tfloat theta = acos(d) * t;\n\tvec3 relative_vec = b - a*d;\n\trelative_vec = normalize(relative_vec);\n\t// Orthonormal basis. The final result.\n\treturn a * cos(theta) + relative_vec * sin(theta);\n}\n\n// The geodesic distance (great circle distance) between two points on a unit sphere. Assumes that a and b are normalized.\n// Based on https://en.wikipedia.org/wiki/Great-circle_distance#Vector_version.\nfloat geodesic_dist(vec3 a, vec3 b) {\n\treturn acos(dot(a, b));\n}\n\n// Geodesic distance from p to the plane that contains a, b and the origin.\n// Expects p, a and b to be normalized.\n// Based on the distance between point X to the geodesic line AB from: https://math.stackexchange.com/questions/23054/how-to-find-the-distance-between-a-point-and-line-joining-two-points-on-a-sphere#answer-23612\nfloat geodesic_dist_to_plane(vec3 p, vec3 a, vec3 b) {\n\tvec3 plane_normal = cross(a, b);\n\treturn asin(abs(dot(plane_normal, p)));\n}\n\n// Geodesic distance from p to the line segment between a and b.\n// Expects p, a and b to be normalized.\n// You can also return progress_on_line_segment if you want a value that is 0 at the start (a) and 1 at the end (b).\nfloat geodesic_dist_to_line_segment(vec3 p, vec3 a, vec3 b) {\n\t// Project the point p onto the plane with a, b and the origin on it. normalize() then moves that point back out onto \n    // the sphere surface. This gives us the closest point on the circle with a and b on it (or line on the sphere, but\n    // not a line segment). Basically geodesic distance to a plane defined by two points.\n\t// Projection onto the plane is based on https://math.stackexchange.com/questions/23054/how-to-find-the-distance-between-a-point-and-line-joining-two-points-on-a-sphere#answer-23612\n\tvec3 plane_normal = cross(a, b);                                 // n hat (n with a ^) in the linked answer\n\tvec3 p_proj_on_plane = p - dot(plane_normal, p) * plane_normal;  // X hat proj in the answer, p is X hat\n\tvec3 p_proj_on_circle = normalize(p_proj_on_plane);              // x hat in the answer\n\t\n\t// Now we want to limit the line to the line segment between a and b.\n\t// Basic approach inspired by distance to 3D line segment by Inigo Quilez, sdCapsule() at\n    // https://iquilezles.org/articles/distfunctions.\n\t// We map p_proj_on_circle onto the line segment and clamp that projected value to their min\n    // and max values (representing start and end of the line segment, a and b) and stretch it to\n    // [0, 1] (progress_on_line_segment below). We then reconstruct the point on the line segment\n    // corresponding to this clamped number, here done with slurp().\n\t// This will give us the closest point to p on the line segment, restricted to a and b. We use\n    // the angle between a and other points as that number. It's 0 at a (same vector, dot is 1,\n    // acos(1) is 0) and this will be our min value. Max will be the angle between a and b. This\n    // is where our line segment ends.\n\tfloat angle_ab = acos(dot(a, b));\n\tfloat angle_ap = acos(dot(a, p_proj_on_circle));\n\t// Linearly interpolate real angles in radiants. Works with slerp() to reconstruct points on the\n    // line segment again. Map [0, angle_ab] onto [0, 1], depending on where angle_ap is between\n    // them. Outside results are clamped.\n\tfloat progress_on_line_segment = linstep(0.0, angle_ab, angle_ap);\n\tvec3 point_on_line = slerp(a, b, progress_on_line_segment);\n\t\n\treturn geodesic_dist(point_on_line, p);\n}\n\n\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// Almost completely unmodified code from https://www.shadertoy.com/view/ldl3Dl\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5;  // 0.5*iTime;  // Disabled time to better see the distance\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\t\n        // geodesic_dist_to_line_segment() expects normalized coordinates where (0,0,0) is the center of\n        // the sphere. So we use (pos - sc) instead of just pos as in the original version.\n        float f;\n        vec3 a = normalize(vec3(1, -0.25, 0));\n        vec3 b = normalize(vec3(1, 1, 1));\n        f = geodesic_dist_to_line_segment(pos - sc, a, b);\n\t\t\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}