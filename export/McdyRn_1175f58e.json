{"ver":"0.1","info":{"id":"McdyRn","date":"1730790796","viewed":140,"name":"rainy ride home","username":"nagpsa","description":"Made entirely by following (not blindly) the 6-step tutorial by The Art of Code: https://www.youtube.com/watch?v=52TMliAWocY","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 camPos = vec3(0.3, 0, -1.);\nconst vec3 lookAt = vec3(0.2, 0., 1); // I am assuming I always look at the center of the screen\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat BokehCircle(Ray ray, vec3 center, float radius, float percentBlur, float minThickPct, float minBokeh)\n{\n    vec3 closestPt = ray.origin + max(0.0, (dot((center - ray.origin), ray.direction))) * ray.direction;    \n    float distFromCenter = distance(closestPt, center);\n    //radius *= distance(camPos, center);\n    float c = smoothstep(radius, radius * (1.0 - percentBlur), distFromCenter);\n    float thicknessThreshold = max(minBokeh, smoothstep(radius * minThickPct, radius, distFromCenter));\n    return thicknessThreshold * c;\n}\n\nfloat BokehCircle(Ray ray, vec3 center, float radius) {\n    return BokehCircle(ray, center, radius, 0.1, 0.8, 0.3);\n}\n\nfloat rng(float n)\n{\n    return fract(sin(n *42.243) * 3392.21);\n}\n\nvec3 StreetLights(Ray ray)\n{\n    vec3 col = vec3(0,0,0);\n    float streetLightDepthRange = 10.f;\n    float minDepth = 0.f;\n    float maxDepth = 1.f;\n    float spacing = (maxDepth - minDepth)/8.f;\n    float offsetOneSideOfStreetLights = step(ray.direction.x, 0.0); // we want them to appear alternately, so offset the side for which this term is non-zero\n    ray.direction.x = abs(ray.direction.x); // without this we only get one side of street lights. With this we get both for free\n    for(float i = minDepth; i < maxDepth; i += spacing)\n    {\n        float currDepth = fract(iTime *0.2 + i + offsetOneSideOfStreetLights * 0.1);        \n        col += BokehCircle(ray, vec3(0.8, 0.5, streetLightDepthRange * (1.f - currDepth)), 0.24, 1.3f - currDepth, 0.5, currDepth * 0.8) * ( currDepth + 0.4 ) ;\n    }\n    return col* vec3(0.9, 0.95, 0.35);\n}\n\nvec3 EnvLights(Ray ray)\n{\n    return (ray.direction.y + 0.1) * vec3(0.7, 0.1, 0.9); // the purplish sky\n}\n\nvec3 HeadLights(Ray ray)\n{\n    vec3 col = vec3(0,0,0);\n    float lightDepthRange = 10.f;\n    float minDepth = 0.f;\n    float maxDepth = 1.f;\n    float spacing = (maxDepth - minDepth)/10.f;\n    float width = 0.08;\n    float xOffset = -0.4;\n    for(float i = minDepth; i < maxDepth; i += spacing)\n    {\n        if(rng(i) > 0.4) continue;\n        float currDepth = fract(iTime *0.6 + i);\n        float z = lightDepthRange * (1.f - currDepth);\n        float focus = smoothstep(0.4, 0.8, currDepth); // we want lights at a certain distance to be out of focus, and then\n        float radius = mix(0.2, 0.05, focus); //shrink a little bith when they come in focus\n        col += BokehCircle(ray, vec3(xOffset + width, -0.05, z), radius, 1.f - currDepth, 0.7, 0.9);\n        col += BokehCircle(ray, vec3(xOffset- width, -0.05, z), radius, 1.f - currDepth, 0.7, 0.9);\n        \n        float reflection = 0.0;\n        reflection += BokehCircle(ray, vec3(xOffset + width, -0.2, z), radius * 4.f, 0.99, 0.7, 0.7);\n        reflection += BokehCircle(ray, vec3(xOffset - width, -0.2, z), radius * 4.f, 0.99, 0.7, 0.7);\n        \n        col += reflection * focus * 0.4;\n    }\n    return col * vec3(0.95, 0.95, 1.0);\n}\n\nvec3 TailLights(Ray ray)\n{\n    vec3 col = vec3(0,0,0);\n    vec3 flash = vec3(0,0,0);\n    float lightDepthRange = 10.f;\n    float minDepth = 0.5f;\n    float maxDepth = 1.5f;\n    float spacing = (maxDepth - minDepth)/10.f;\n    float width = 0.08;\n    float threshold = 0.3;\n    for(float i = minDepth; i < maxDepth; i += spacing)\n    {\n        float rng = rng(i * 14.5);\n        if(rng > threshold ) continue;\n        float lane = step(threshold/2.f, rng);\n        float xOffset = 0.4 * (1. + lane);\n        float currDepth = fract(iTime *0.07 + i);\n        float z = lightDepthRange * (1.f - currDepth);\n        float focus = smoothstep(0.6, 0.8, currDepth); // we want lights at a certain distance to be out of focus, and then\n        float radius = mix(0.2, 0.06, focus); //shrink a little bith when they come in focus\n        \n        //logic for cars in front of me to give the indicator and switch to the slower lane\n        if(lane < 1.)\n        {\n            float initZThreshold = 1.5;\n            float minZThreshold = 0.4;            \n            if(z < initZThreshold) xOffset = mix(xOffset, 2. * xOffset, smoothstep(initZThreshold, minZThreshold, z)); // slowly drive to the adjacent lane\n            if(z < 2. * initZThreshold) // give the indicator a little before the car actually starts drifting off to the nearby lane          \n            {\n            flash += BokehCircle(ray, vec3(xOffset + width * 1.6, -0.05, z), radius * 1.5, 1.f - currDepth * 0.6, 0.7, 0.6) * step(fract(iTime * 1.5f), 0.5);\n            }\n        }\n        \n        col += BokehCircle(ray, vec3(xOffset + width, -0.05, z), radius, 1.f - currDepth * 0.9, 0.7, 0.8);\n        col += BokehCircle(ray, vec3(xOffset- width, -0.05, z), radius, 1.f - currDepth * 0.9, 0.7, 0.8);\n        \n        float reflection = 0.0;\n        reflection += BokehCircle(ray, vec3(xOffset + width, -0.2, z), radius * 4.f, 0.99, 0.7, 0.7);\n        reflection += BokehCircle(ray, vec3(xOffset - width, -0.2, z), radius * 4.f, 0.99, 0.7, 0.7);\n        \n        \n        col += reflection * focus * 0.4;\n    }\n    return col * vec3(1.0, 0.1, 0.1) + flash * vec3(0.9, 0.75, 0.35);\n}\n\nvec2 RainDistortionForUV(vec2 uv, float gridificationFactor)\n{\n    vec2 tempUV = uv;// + 0.5;\n    tempUV *= gridificationFactor;\n    vec2 aspectRatio = vec2(3.,1.);//always be x:1, if you have any other value other than 1 for y then you would need to counter for distortion by a factor of aspectRatio.y/aspectRatio.x\n    tempUV *= aspectRatio;    \n    tempUV.y += fract(sin(floor(tempUV.x) * 841.23) * 51.19); // apply some offset to each column so that we don't have a uniform tiled patttern\n    tempUV.y += 1.4 * iTime; //move the entire grid down. If not, then the rain drops go back up, but we want a trickling effect where the drop goes down a bit, the pauses, then continues to go down    \n    vec2 gridId = floor(tempUV);\n    tempUV = fract(tempUV) - 0.5; //-0.5 to again remap our UVs to -0.5 to 0.5, the same space we were working with in mainImage()\n    float y = -iTime * 3.5f; //this y i used to move the drop down, then make it go back up slowly    \n    y += fract(sin(floor(gridId.y) * 41.23 + floor(gridId.x) * 223.4) * 51.19) * 6.28;\n    vec2 movingUV = vec2(0., sin(y + sin(y + sin(y))) * 0.41);\n    \n    //for the main, big drop\n    vec2 mainUVOffset = (tempUV - movingUV)/aspectRatio;\n    float radius = length(mainUVOffset); //center of each grid is the origin, so the radius for the current pixel is simply its distance from the origin. Divide by aspectRatio to counter for distortion causing elliptical discs instead of round\n    float discArea = smoothstep(gridificationFactor/120., 0.02, radius);\n    \n    //for the trail of droplets (or as I call my cute weetle woplets) left behind by the bigger drop\n    vec2 wopletsUV = uv * gridificationFactor;\n    vec2 wopletsAspectRatio = vec2(1.f, 5.f);\n    wopletsUV *= wopletsAspectRatio;\n    wopletsUV.x *= aspectRatio.x;\n    wopletsUV = fract(wopletsUV) - 0.5;\n    vec2 wopletsUVOffset = (wopletsUV/wopletsAspectRatio)/aspectRatio;\n    float weetleWoplets = length(wopletsUVOffset); //center of each grid is the origin, so the radius for the current pixel is simply its distance from the origin. Divide by aspectRatio to counter for distortion causing elliptical discs instead of round\n    float wopletsArea = smoothstep(0.03 * (1. - tempUV.y), 0.0, weetleWoplets) * smoothstep(-.1,.1,(tempUV.y - movingUV.y));\n    \n    //if(tempUV.x > 0.46 || tempUV.y > 0.49) discArea = 1.; //hack to draw edges of the box\n    //return vec2(discArea + wopletsArea);\n    return(mainUVOffset * discArea * 20. + wopletsUVOffset * wopletsArea * 25.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;      \n    \n    uv -= 0.5; // make 0,0 the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // get rid of stretching\n    uv -= RainDistortionForUV(uv, 4.f) * 0.7;\n    uv -= RainDistortionForUV(uv, 7.f) * 0.5;\n    uv.x += sin(uv.y * 56.) * 0.002;\n    uv.y += sin(uv.x * 7.) * 0.003;\n    \n    vec3 f = normalize(lookAt - camPos); // assuming left-handed coordinate system\n    vec3 r = normalize( cross( vec3(0, 1, 0), f ) );\n    vec3 u = normalize( cross(f, r) );\n    \n    vec3 pixelWorldCoords = lookAt + uv.x * r + uv.y * u;        \n    \n    Ray ray = Ray(camPos, normalize(pixelWorldCoords - camPos));\n        \n\n    vec3 col = StreetLights(ray);\n    col += HeadLights(ray);\n    col += TailLights(ray);\n    col += EnvLights(ray);\n    \n    //col = vec3(distortion, 0.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}