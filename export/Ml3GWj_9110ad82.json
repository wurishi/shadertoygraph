{"ver":"0.1","info":{"id":"Ml3GWj","date":"1471561602","viewed":184,"name":"Hover","username":"StrongJoshua","description":"Wanted to recreate the item hover effect with the shadow ellipse similar to how it works in games like Minecraft.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WHITE vec4(1., 1., 1., 1.)\n#define BLACK vec4(0., 0., 0., 1.)\n#define ORIG vec2(0., 0.)\n#define MAX_BLOCK_SIZE 50.\n#define OPTIMAL_BLOCK_AMT 10.\n\nbool colorful = true;\n\nvoid manipulateColor(out vec4 color, vec2 absPos, vec2 relativePos, float imgSize, bool colorful) {\n    if(colorful) {\n        color.r = relativePos.y / imgSize;\n        color.b = 1. - relativePos.y / imgSize;\n        color.g = sin(iTime);\n    } else {\n        color.rgb += absPos.y / iResolution.y * 2. - .5;\n    }\n}\n\nbool between(float f, float begin, float end) {\n    return f < max(begin, end) && f > min(begin, end);\n}\n\nvec4 drawLine(vec4 background, vec2 start, vec2 end, vec2 xy) {\n    if(distance(start, end) == distance(start, xy) + distance(xy, end)) return BLACK;\n    return background;\n}\n\nvec4 drawBlock(vec4 background, vec2 pos, float width, float height, vec2 xy) {\n    if(between(xy.x, pos.x, pos.x + width) && between(xy.y, pos.y, pos.y +  height)) return BLACK;\n    return background;\n}\n\nvec4 drawBlockLine(vec4 background, vec2 start, vec2 end, int blocks, vec2 xy) {\n    vec2 relative = xy - start;\n    end = end - start;\n    start = ORIG;\n    \n    if(between(relative.x, start.x, end.x) && between(relative.y, start.y, end.y)) {\n        float width = abs(start.x - end.x) / float(blocks);\n        float height = abs(start.y - end.y) / float(blocks);\n\n        float block = floor(abs(relative.x) / width);\n        float dir = end.y < start.y ? -1. : 1.;\n        if(between(relative.y, block * height * dir, (block + 1.) * height * dir)) return BLACK;\n    }\n    \n    return background;\n}\n\nvec2 blockPos(int x, int y, float blockSize) {\n    return vec2(float(x) * blockSize, float(y) * blockSize);\n}\n\nvec4 drawSword(vec4 background, vec2 position, float size, vec2 xy) {\n    vec2 relative = xy - position;\n    vec4 color = vec4(background);\n    \n    int blocks = 6;\n    float blockSize = size / float(blocks);\n    \n    color = drawBlockLine(color, ORIG, vec2(size, size), blocks, relative);\n    color = drawBlockLine(color, blockPos(0, 3, blockSize), blockPos(3, 0, blockSize), 3, relative);\n    \n    if(color == background) return background;\n    \n    manipulateColor(color, xy, relative, size, colorful);\n    \n    return color;\n}\n\nvec4 drawS(vec4 background, vec2 position, float size, vec2 xy) {\n    vec2 relative = xy - position;\n    vec4 color = vec4(background);\n    \n    int blocks = 8;\n    float blockSize = size / float(blocks);\n    \n    color = drawBlock(color, blockPos(0, 1, blockSize), blockSize, blockSize, relative);\n    color = drawBlock(color, blockPos(1, 0, blockSize), blockSize * 5., blockSize, relative);\n    color = drawBlock(color, blockPos(6, 1, blockSize), blockSize, blockSize * 2., relative);\n    color = drawBlock(color, blockPos(4, 3, blockSize), blockSize * 2., blockSize, relative);\n    color = drawBlock(color, blockPos(1, 4, blockSize), blockSize * 3., blockSize, relative);\n    color = drawBlock(color, blockPos(0, 5, blockSize), blockSize, blockSize * 2., relative);\n    color = drawBlock(color, blockPos(1, 7, blockSize), blockSize * 5., blockSize, relative);\n    color = drawBlock(color, blockPos(6, 6, blockSize), blockSize, blockSize, relative);\n    \n    if(color == background) return background;\n    \n    manipulateColor(color, xy, relative, size, !colorful);\n    \n    return color;\n}\n\nvec4 drawJ(vec4 background, vec2 position, float size, vec2 xy) {\n    vec2 relative = xy - position;\n    vec4 color = vec4(background);\n    \n    int blocks = 10;\n    float blockSize = size / float(blocks);\n    \n    color = drawBlock(color, blockPos(1, 1, blockSize), blockSize, blockSize * 2., relative);\n    color = drawBlock(color, blockPos(2, 0, blockSize), blockSize * 4., blockSize, relative);\n    color = drawBlock(color, blockPos(6, 1, blockSize), blockSize, blockSize * 8., relative);\n    color = drawBlock(color, blockPos(1, 9, blockSize), blockSize * 8., blockSize, relative);\n    \n    if(color == background) return background;\n    \n    manipulateColor(color, xy, relative, size, colorful);\n    \n    return color;\n}\n\nvec4 drawEllipse(vec4 background, vec2 pos, float width, vec2 xy) {\n    float a = width / 2.;\n    float b = 5.;\n    \n    vec2 center = pos + vec2(width / 2., width / 2. / b);\n    vec2 relative = xy - center;\n    \n    float xx = relative.x * relative.x;\n    float yy = relative.y * relative.y;\n    float dist = xx / (a * a) + yy / (b * b);\n    \n    if(dist < 1.) return WHITE * dist;\n    return background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n    vec4 color = WHITE;\n    float index = xy.x + xy.y * iResolution.x;\n    float screenSize = iResolution.x * iResolution.y * 1.5;\n    \n    float size = 100.;\n    float val = sin((iTime - index / screenSize)* 3.) * 15.;\n    \n\tcolor = drawS(color, iResolution.xy / 2. - size / 2. + vec2(-size, val), size, xy);\n    color = drawEllipse(color, iResolution.xy / 2. - vec2((size - val / 2.) / 2. + size, size), size - val / 2., xy);\n    \n    color = drawJ(color, iResolution.xy / 2. - size / 2. + vec2(size, val), size, xy);\n    color = drawEllipse(color, iResolution.xy / 2. - vec2((size - val / 2.) / 2. - size, size), size - val / 2., xy);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}