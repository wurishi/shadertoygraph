{"ver":"0.1","info":{"id":"NlKBDh","date":"1666012309","viewed":125,"name":"sobel算子进行边缘检测","username":"nathanau","description":"sobel算子进行边缘检测","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sobel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _EdgeOnly 0.5    \n#define _CONDITION 0.2\n\n#define X 0.299\n#define Y 0.587\n#define Z 0.114\n//RGB转亮度\nfloat luminance(vec4 color)\n{\n    return X * color.x + Y * color.y + Z * color.z;\n}\n\n\nfloat Sobel(vec2 uv)\n{\n    float texColor;\n    float edgeX = 0.;\n    float edgeY = 0.;\n    //在卷积运算中，依次对9个像素进行采样，计算他们的亮度值，再与卷积核Gx Gy中对应的权重相乘后，叠加到各自的梯度上\n    vec2 one = vec2(1,1);\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(-1, -1)));\n    edgeX += texColor * -1.;\n    edgeY += texColor * -1.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(0, -1)));\n    edgeX += texColor * 0.;\n    edgeY += texColor * -2.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(1, -1)));\n    edgeX += texColor * 1.;\n    edgeY += texColor * -1.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(-1, 0)));\n    edgeX += texColor * -2.;\n    edgeY += texColor * 0.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(0, 0)));\n    edgeX += texColor * 0.;\n    edgeY += texColor * 0.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(1, 0)));\n    edgeX += texColor * 2.;\n    edgeY += texColor * 0.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(-1, 1)));\n    edgeX += texColor * -1.;\n    edgeY += texColor * 1.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(0, 1)));\n    edgeX += texColor * 0.;\n    edgeY += texColor * 2.;\n\n    texColor = luminance(texture(iChannel0, uv + one/iResolution.xy * vec2(1, 1)));\n    edgeX += texColor * 1.;\n    edgeY += texColor * 1.;\n\n    //1减去水平方向和竖直方向的梯度值的绝对值，得到edge edge越小越可能是边缘\n    float edge = 1. - abs(edgeX) - abs(edgeY);\n\n    return edge;\n}\n\n\n//sobel算子进行边缘检测\nvoid TmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float edge = Sobel(uv);\n    vec4 EdgeColor = vec4(0, 0, 0, 1);\n    vec4 BackgroundColor = vec4(1, 1, 1, 1);\n    vec4 withEdgeColor = mix(EdgeColor, texture(iChannel0, uv + iResolution.xy * vec2(0, 0)), edge);\n    vec4 onlyEdgeColor = mix(EdgeColor, BackgroundColor, edge);\n\n    fragColor = mix(withEdgeColor, onlyEdgeColor, _EdgeOnly);\n    // Output to screen\n}\n\n//sobel算子进行边缘检测\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float edge = Sobel(uv);\n    vec4 col;\n    if (edge > _CONDITION)\n    {\n        col = texture(iChannel0, uv);\n    }\n    else\n    {\n        col = vec4(0,0,0,1);\n    }\n    fragColor = col;\n\n}","name":"Image","description":"","type":"image"}]}