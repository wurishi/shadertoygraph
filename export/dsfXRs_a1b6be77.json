{"ver":"0.1","info":{"id":"dsfXRs","date":"1669388097","viewed":87,"name":"Mini Noise (practice)","username":"MikaJoo","description":"https://www.getrevue.co/profile/xordev/issues/gm-shaders-mini-noise-1437243\nhttps://www.getrevue.co/profile/xordev/issues/gm-shaders-mini-noise-2-1454708\n\nhttps://www.shadertoy.com/view/DdBGDh?utm_campaign=Shader%20Tutorials&utm_medium=email&utm_source=Re","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","perlin","worley","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// classic fraction part of the sinus of a big number\nfloat hashNoise(float _input)\n{\n    return fract(sin(_input * 0.12345f)*98765.3456f);\n}\nfloat hashNoise(vec2 _input)\n{\n    return fract(sin(_input.x * 0.12345f + _input.y * 0.6547893f)*98765.3456f);\n}\n\n// use hash noise with bilinear interpolation to generate a continuous noise\nfloat valueNoise(vec2 _input)\n{\n    const float gridSize = 12.0f;\n    vec2 p = _input * gridSize;\n    vec2 cell = floor(p);\n    \n    float hashNoise0 = hashNoise(cell + vec2(0,0));\n    float hashNoise1 = hashNoise(cell + vec2(1,0));\n    float hashNoise2 = hashNoise(cell + vec2(0,1));\n    float hashNoise3 = hashNoise(cell + vec2(1,1));\n    \n    vec2 cellPos = p - cell;\n    vec2 cubic = cellPos*cellPos*(3.0-2.0*cellPos);\n    \n    float hashNoise01 = mix(hashNoise0, hashNoise1, cubic.x);\n    float hashNoise23 = mix(hashNoise2, hashNoise3, cubic.x);\n    float hashNoise0123 = mix(hashNoise01, hashNoise23, cubic.y);\n    \n    return hashNoise0123;\n}\n\n\n// hash noise returning vec2\nvec2 hashNoise2(vec2 _input)\n{\n    return fract(sin(_input * mat2(0.12345f, 0.56789f, 0.54321f, 0.98765f)) * 951753.8462f);\n}\n\n// hash noise returning a normalized vec2\nvec2 nHashNoise2(vec2 _input)\n{\n    return normalize(hashNoise2(_input) - 0.5);\n}\n\n// perlin noise (quitinc interpolation)\nfloat perlinNoise(vec2 _input)\n{\n    const float gridSize = 32.0f;\n    vec2 p = _input * gridSize;\n    vec2 cell = floor(p);\n    \n    vec2 dirHashNoise0 = nHashNoise2(cell + vec2(0,0));\n    vec2 dirHashNoise1 = nHashNoise2(cell + vec2(1,0));\n    vec2 dirHashNoise2 = nHashNoise2(cell + vec2(0,1));\n    vec2 dirHashNoise3 = nHashNoise2(cell + vec2(1,1));\n    \n    vec2 cellPos = p - cell;\n    \n    float gradDir0 = dot(dirHashNoise0, vec2(0,0) - cellPos);\n    float gradDir1 = dot(dirHashNoise1, vec2(1,0) - cellPos);\n    float gradDir2 = dot(dirHashNoise2, vec2(0,1) - cellPos);\n    float gradDir3 = dot(dirHashNoise3, vec2(1,1) - cellPos);\n    \n    vec2 quintinc = cellPos*cellPos*cellPos*(cellPos*(cellPos*6.0 - 15.0) + 10.0);\n    \n    float gradDir01 = mix(gradDir0, gradDir1, quintinc.x);\n    float gradDir23 = mix(gradDir2, gradDir3, quintinc.x);\n    float perlin = mix(gradDir01, gradDir23, quintinc.y);\n    \n    // from [-srqt(2);sqrt(2)] to [0;1]\n    return perlin * sqrt(2.0) * 0.5 + 0.5;\n}\n\n\n// worley noise\nfloat worleyNoise(vec2 _input)\n{\n    const float gridSize = 16.0f;\n    vec2 p = _input * gridSize;\n    vec2 cell = floor(p);\n    \n    // distance max from a random point\n    const float distMax = 9.0f;   \n    float minDist = distMax;\n    \n    for(int y=-1;y<2;++y)\n    {\n        for(int x=-1;x<2;++x)\n        {\n            vec2 neighborCell = cell + vec2(x,y);\n            vec2 neighborWorleyPoint = hashNoise2(neighborCell) + neighborCell - p;\n            minDist = min(minDist, length(neighborWorleyPoint));\n        }\n    }\n    \n    return minDist;\n}\n\n// voronoi noise\nfloat voronoiNoise(vec2 _input)\n{\n    const float gridSize = 16.0f;\n    vec2 p = _input * gridSize;\n    vec2 cell = floor(p);\n    \n    // distance max from a random point\n    const float distMax = 9.0f;   \n    float minDist = distMax;\n    vec2 closestCell = cell;\n    \n    for(int y=-1;y<2;++y)\n    {\n        for(int x=-1;x<2;++x)\n        {\n            vec2 neighborCell = cell + vec2(x,y);\n            vec2 neighborWorleyPoint = hashNoise2(neighborCell) + neighborCell - p;\n            float dist = length(neighborWorleyPoint);\n            \n            if(dist<minDist)\n            {\n                closestCell = neighborCell;\n                minDist = dist;\n            }\n        }\n    }\n    // return a random value based on the closestCell\n    return hashNoise(closestCell);\n}\n\n// fractal noise\nfloat fractalNoise(vec2 _input)\n{\n    vec2 point = _input;\n    \n    float noiseSum = 0.0f;\n    float noiseWeight = 0.0f;\n    float weight = 1.0f;\n    float weightSum = 0.0f;\n    \n    const int octaveCount = 5;\n    const float nextWeightMultiplier = 1.25f; // next octave will be more \"visible\"\n    \n    const float staticRandomScale = 0.75f;\n    const vec2 staticRandomOffset = vec2(0.23, -0.5896);\n    \n    for(int octave=0; octave<octaveCount; ++octave)\n    {\n        // perlin fractal\n        //noiseSum += perlinNoise(point) * weight;\n        \n        // worley fractal\n        //noiseSum += worleyNoise(point) * weight;\n        \n        // voronoi fractal\n        noiseSum += voronoiNoise(point) * weight;\n        \n        weightSum += weight;\n        weight *= nextWeightMultiplier;\n        point = point * staticRandomScale + staticRandomOffset; // scale & offset\n    }\n    \n    float fractalNoise = noiseSum / weightSum;\n    return fractalNoise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates [0;1]\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // hash noise\n    //float hashNoise = hashNoise(uv);\n    //vec3 colorOutput = vec3(hashNoise, hashNoise, hashNoise);\n    \n    // value noise\n    //float valueNoise = valueNoise(uv);\n    //vec3 colorOutput = vec3(valueNoise, valueNoise, valueNoise);\n    \n    // perlin noise\n    //float perlinNoise = perlinNoise(uv);\n    //vec3 colorOutput = vec3(perlinNoise, perlinNoise, perlinNoise);\n    \n    // worley noise\n    //float worleyNoise = worleyNoise(uv);\n    //vec3 colorOutput = vec3(worleyNoise, worleyNoise, worleyNoise);\n    \n    // voronoi noise\n    //float voronoiNoise = voronoiNoise(uv);\n    //vec3 colorOutput = vec3(voronoiNoise, voronoiNoise, voronoiNoise);\n    \n    // fractal noise\n    float fractalNoise = fractalNoise(uv);\n    vec3 colorOutput = vec3(fractalNoise,fractalNoise,fractalNoise);\n    \n    //colorOutput = vec3(hashNoise2(uv), 0.0f);\n    \n    fragColor = vec4(colorOutput,1.0);\n}","name":"Image","description":"","type":"image"}]}