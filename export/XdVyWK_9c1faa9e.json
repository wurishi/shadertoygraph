{"ver":"0.1","info":{"id":"XdVyWK","date":"1523429914","viewed":280,"name":"Frustum/Sphere intersection test","username":"dpk","description":"Just playing around.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\n// Use IQ's optimized ray sphere instruction.\n// https://iquilezles.org/blog/?p=2411\nfloat IntersectSphereAtOrigin(in vec3 ro, in vec3 rd, float radius) {\n  vec3 sphereOrigin = vec3(0.0);\n  vec3 oc = ro - sphereOrigin;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - radius * radius;\n  float t = b * b - c;\n  if (t > 0.0) {\n    t = -b - sqrt(t);\n  }\n  return t;\n}\n\nvec2 ComputeUvForSpherePoint(in vec3 pos) {\n  vec3 n = normalize(pos);\n  float longitude = atan(n.z, n.x);\n  float latitude = -acos(n.y);\n  return vec2(longitude / (2.0 * PI), latitude / PI);\n}\n\nvoid ComputeCameraFromLatLon(in float cameraDistance, in float cameraLatitude,\n                             in float cameraLongitude, out vec3 cameraPosition,\n                             out mat3 rotationMatrix) {\n  cameraPosition = cameraDistance * (vec3(sin(cameraLatitude) * cos(cameraLongitude),\n                                   cos(cameraLatitude),\n                                   sin(cameraLatitude) * sin(cameraLongitude)));\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n  float cr = 0.0;\n  vec3 cw = normalize(ta - cameraPosition);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = -normalize(cross(cw, cp));\n  vec3 cv = -normalize(cross(cu, cw));\n  rotationMatrix = mat3(cu, cv, cw);\n}\n\nvoid ComputeCameraLatLonFromMouse(out float cameraLatitude,\n                                  out float cameraLongitude) {\n  // Mouse control\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  (iMouse.z == 0.0) ? mouse = vec2(0.0, .85) : mouse = mouse;\n  float mouseXspeed = 10.0;\n  float mouseYspeed = 2.0;\n  cameraLongitude = -mouseXspeed * mouse.x;\n  cameraLatitude = -mouseYspeed * (mouse.y * 1.5);\n}\n\nmat4 ComputeInverseProjectionMatrix(float l, float r, float t, float b, float n,\n                                    float f) {\n  float A = 2.0 * n / (r - l);\n  float B = 2.0 * n / (t - b);\n  float C = -(f + n) / (f - n);\n  float D = -(2.0 * f * n) / (f - n);\n  float E = -1.0;\n  return mat4(1.0 / A, 0, 0, 0, 0, 1.0 / B, 0, 0, 0, 0, 0, 1.0 / E, 0, 0,\n              1.0 / D, -C / (D * E));\n}\n\nvec3 ComputeGlobePixelColor(vec3 spherePoint, float polyCameraDistance,\n                            float polyCameraLatitude,\n                            float polyCameraLongitude) {\n  // Compute base color.\n  vec2 uv = ComputeUvForSpherePoint(spherePoint);\n  vec3 col = texture(iChannel0, uv).xyz * 0.3;\n\n  // Compute inverse model-view-projection matrix of the polyline camera.\n  vec3 polyCameraPosition;\n  mat3 polyCameraRotationMatrix;\n  ComputeCameraFromLatLon(polyCameraDistance, polyCameraLatitude,\n                          polyCameraLongitude, polyCameraPosition,\n                          polyCameraRotationMatrix);\n  polyCameraPosition = spherePoint * polyCameraDistance;\n\n  mat4 inverseModelViewProjection =\n      ComputeInverseProjectionMatrix(-1.0, 1.0, 0.5, -1.0, 0.5, 1.f) *\n      mat4(polyCameraRotationMatrix);\n\n  // Transform the sphere point from world space to polyline camera image space.\n  vec4 spherePointInImageSpaceH =\n      (inverseModelViewProjection * vec4(polyCameraPosition, 1.0));\n  vec3 spherePointInImageSpace =\n      spherePointInImageSpaceH.xyz / spherePointInImageSpaceH.w;\n\n  // Compute signed distance function for rectangle border.\n  // Negative is inside the rectangle.\n  // 0 is on the border.\n  // Positive is outside the rectangle.\n  float borderSdf = max((abs(spherePointInImageSpace.y) - 0.5),\n                        (abs(spherePointInImageSpace.x) - 0.5));\n\n  // Compute rectangle color.\n  float borderSmoothness = 0.001;\n  float borderWidth = 0.015;\n  float intensity = 0.0;\n\n  // Add rectangle fill.\n  intensity += smoothstep(0.0, -borderWidth, borderSdf) * 0.08;\n\n  // Add rectangle border.\n  intensity +=\n      smoothstep(borderWidth, borderWidth - borderSmoothness, borderSdf) *\n      (1.0 -\n       smoothstep(-borderWidth + borderSmoothness, -borderWidth, borderSdf)) *\n      0.9;\n\n  col += intensity * vec3(1.0, 0.0, 0.0);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 imageUv = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y *\n                 tan(radians(22.5));\n\n  // Compute camera lat/lon.\n  float cameraDistance = 5.0;\n  float cameraLatitude;\n  float cameraLongitude;\n  ComputeCameraLatLonFromMouse(cameraLatitude, cameraLongitude);\n\n  // Compute camera position/matrix.\n  vec3 cameraPosition;\n  mat3 rotationMatrix;\n  ComputeCameraFromLatLon(cameraDistance, cameraLatitude, cameraLongitude,\n                          cameraPosition, rotationMatrix);\n\n  // Perform ray-sphere intersection.\n  vec3 rayDirection = rotationMatrix * normalize(vec3(imageUv.xy, 1.5));\n  float t = IntersectSphereAtOrigin(cameraPosition, rayDirection, 1.0);\n\n  // Compute pixel color based on intersection t value.\n  vec3 col = vec3(0);\n  if (t > 0.0) {\n    // Animate the position of the \"polyline camera\" that drives the red\n    // frustum/sphere intersection polygon.\n    float polyCameraDistance = (sin(iTime * 5.0) + 2.0) * 3.0;\n    float polyCameraLatitude = iTime * 1.2;\n    float polyCameraLongitude = iTime * 1.5;\n\n    vec3 spherePoint = cameraPosition + t * rayDirection;\n    col = ComputeGlobePixelColor(spherePoint, polyCameraDistance,\n                                 polyCameraLatitude, polyCameraLongitude);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}