{"ver":"0.1","info":{"id":"flXfWM","date":"1650944055","viewed":52,"name":"9-neighbor cellular automat","username":"Envy24","description":"9-neighbor cellular automat (Moore neighbourhood).\n\nMore cellular automats: https://www.shadertoy.com/playlist/fXVSRy","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","wolfram","4neighbor"],"hasliked":0,"parentid":"ftXfWM","parentname":"8-neighbor cellular automat"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) \n{ \n    O = TEXF0(SC);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n#define READ_CELL(P) (TEX0(TEX_COORDS(P)).r)\n\nint read_neighbors_states(vec2 SC)\n{\n    /* Kernel:\n                tl t tr\n                 l m r\n                bl b br\n    */\n\n    float t  = READ_CELL(SC + vec2( 0,  1));\n    float tr = READ_CELL(SC + vec2( 1,  1));\n    float r  = READ_CELL(SC + vec2( 1,  0));\n    float br = READ_CELL(SC + vec2( 1, -1));\n    float b  = READ_CELL(SC + vec2( 0, -1));\n    float bl = READ_CELL(SC + vec2(-1, -1));\n    float l  = READ_CELL(SC + vec2(-1,  0));\n    float tl = READ_CELL(SC + vec2(-1,  1)); \n    float m  = READ_CELL(SC);\n\n    return // max sum == 512\n        (int(tl == 0.0) << 8) +\n        (int(l == 0.0)  << 7) +\n        (int(bl == 0.0) << 6) +\n        (int(b == 0.0)  << 5) +\n        (int(br == 0.0) << 4) +\n        (int(r == 0.0)  << 3) +\n        (int(tr == 0.0) << 2) +\n        (int(t == 0.0)  << 1) +\n         int(m == 0.0);\n\n}\n\nvoid decompose_rule(\n    in int rule,\n    inout int[512] allowed_sums,\n    inout int num_of_allowed_sums)\n{\n    const int num_of_neighbors = 9;\n    const int num_of_combinations = 1 << num_of_neighbors;\n    const int weights[9] = int[9]( 1,  2,  4,  8, 16, 32, 64, 128, 256 );\n    int wIdx = 0;\n\n    for (int combination = 0; combination < num_of_combinations; ++combination)\n    {\n        int sum = 0;\n\n        if (((rule >> combination) & 1) == 0) { continue; }\n\n        for (int b = 0; b < num_of_neighbors; ++b)\n        {\n            sum += weights[b] * ((combination >> b) & 1);\n        }\n\n        allowed_sums[wIdx] = sum;\n        ++wIdx;\n    }\n\n    num_of_allowed_sums = wIdx;\n}\n\nbool check_rule(\n    in vec2 TC,\n    in int[512] allowed_sums,\n    in int num_of_allowed_sums)\n{\n    int sum_of_neighbors_weights = read_neighbors_states(TC);\n\n    bool result = false;\n    \n    for (int s = 0; s < num_of_allowed_sums; ++s)\n    {\n        if (sum_of_neighbors_weights == allowed_sums[s])\n        {\n            result = true;\n            break;\n        }\n    }\n    \n    return result;\n}\n\nfloat init_one_pixel_in_center(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 M = vec2(floor(R.x * 0.5), floor(R.y * 0.5));\n    return \n        SC.y == M.y && SC.x == M.x ?\n            0.0 :\n            1.0;\n}\n\n\nfloat randomize_part_of_frame(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float hash = step(fract(sin(dot(SC, vec2(127.1,311.7))) * 43758.5453123), 0.5);\n\n    return \n       (SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y)) == true ?\n            hash :\n            1.0;\n}\n\nfloat mainScene(in vec2 SC)\n{\n    float transition_number = 0.0; \n    bool s = transition(iFrame, 100, transition_number);\n    \n    /* rules range = \n        [0; 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095] or\n        [0; 2^512 - 1] */\n    int rule = 8120000 + int(transition_number * 100.0);\n\n    int allowed_sums[512];\n    int num_of_allowed_sums = 0;\n    \n    decompose_rule(rule, allowed_sums, num_of_allowed_sums);\n    float state = \n        check_rule(SC, allowed_sums, num_of_allowed_sums) == ALIVE ?\n        0.0 :\n        1.0;\n        \n    return \n        s == true ?\n            randomize_part_of_frame(SC, 0.4) :\n            //init_one_pixel_in_center(SC) :\n            state;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(mainScene(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                        iResolution\n#define TEX0(TC)               ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n/* Every num_of_frame returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int numOfFrames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame);\n    float inv = 1.0 / float(numOfFrames);\n    \n    // Calculate previous and current quotents.\n    float qc = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < qc;\n}\n\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}","name":"Common","description":"","type":"common"}]}