{"ver":"0.1","info":{"id":"7s3SRH","date":"1632595431","viewed":485,"name":"Volumetric fog ride","username":"sergei_am","description":"Simple exponential density height fog + 3D noise.\nBrute-force integration with a fixed number of regularly distributed samples along each ray.\nBeer transmittance, Henyey-Greenstein phase function used for the Sun light scattering.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOG_HEIGHT_FALLOFF = 0.02;\nconst float FOG_GLOBAL_DENSITY = 0.01;\n\nconst int FOG_TRACE_STEPS = 32;\n\nconst float FOG_NOISE_SCALE = 0.004;\nconst float FOG_NOISE_SPEED = 0.07;\n\nconst float CLOUDS_DENSITY = 0.08;\nconst float CLOUDS_MAX_DENSITY_HEIGHT  = -10.0;\nconst float CLOUDS_ZERO_DENSITY_HEIGHT = 10.0;\n\nconst vec3  SUN_COLOR = vec3(20.0, 19.0, 13.0);\nconst vec3  SKY_COLOR = vec3(1.2, 1.5, 2.0);\nconst float SUN_SCATTERING_ANISO = 0.7;\n\nconst float CAMERA_PITCH = 0.4;\nconst float PI = 3.14159265359;\n\n\n\n\n\nvec2 rotate( in vec2 v, in float angle )\n{\n    float c = cos(angle), s = sin(angle);\n    return vec2( v.x*c - v.y*s, v.x*s + v.y*c );\n}\n\nfloat get_terrain_height( in vec3 pos )\n{\n    const float xw[12] = float[](40.0, 25.0, 112.0, 23.0,12.0,37.0, 13.0,6.0,41.0, 7.0,5.0,27.0);\n    \n    float h = 0.0;\n    for(int i=0; i<12; i += 3)\n    {\n        h += sin(pos.x / xw[i])*xw[i+1]*cos(pos.z / xw[i+2])*2.0;\n        h += cos(pos.z / xw[i] + 0.6)*xw[i+1]*cos(pos.x / xw[i+2])*2.0;\n    }\n    return h;\n}\n\nvec3 get_terrain_albedo( in vec3 pos )\n{\n    vec3 color = texture(iChannel0, pos.xz * 0.015).xyz;\n    color = vec3(0.2,0.2,0.2) + color * 0.8;\n    color *= vec3(1.0,0.6,0.3);\n    \n    color.xyz *= texture(iChannel2, pos.xz/20.0).x*0.5 + 0.5;\n    \n    return color;\n}\n\nvec3 terrain_intersect_precise( in vec3 p_below, in vec3 p_above, int num_steps )\n{\n    for( int i=0; i<num_steps; ++i )\n    {\n        vec3 mid = (p_below + p_above)*0.5;\n        float h = get_terrain_height( mid );\n        if( h < mid.y )\n            p_above = mid;\n        else\n            p_below = mid;\n    }\n    \n    return p_below;\n}\n\nbool terrain_intersect(in vec3 eye, in vec3 ray, in float step_size, in int num_steps, in int num_precise_steps, out vec3 I)\n{\n    vec3 ray_step = normalize(ray);\n    ray_step *= step_size;\n    \n    for( int i=0; i<num_steps; ++i )\n    {\n        float h = get_terrain_height( eye );\n        if( h > eye.y )\n        {\n            I = terrain_intersect_precise( eye, eye - ray_step, num_precise_steps );\n            return true;\n        }\n        eye += ray_step;\n    }\n    return false;\n}\n\nvec3 terrain_normal( in vec3 pos )\n{\n    float h00 = get_terrain_height(pos);\n    float h10 = get_terrain_height(pos + vec3(0.5, 0.0, 0.0) );\n    float h01 = get_terrain_height(pos + vec3(0.0, 0.0, 0.5));\n    vec3 N = normalize(vec3(h00-h10, 0.5, h00-h01));\n    return N;\n}\n\nfloat get_sky_visibility(in vec3 N)\n{\n    return pow(N.y*0.5 + 0.5, 0.5);\n}\n\nvec3 get_sun_direction()\n{\n    //return SUN_DIRECTION;\n\n    float angle = iTime/16.0;\n    \n    //angle = 1.9;\n    \n    vec3 dir = vec3(cos(angle), 0.2, sin(angle));\n    dir = normalize(dir);\n    \n    //dir = vec3(0.0, 1.0, 0.0);\n    \n    return dir;\n}\n\nfloat get_shadow(in vec3 wpos)\n{\n    vec3 dummy;\n\treturn terrain_intersect(wpos + vec3(0.0, 0.1, 0.0), get_sun_direction(), 4.0, 40, 0, dummy) ? 0.0 : 1.0;\n}\n\nfloat get_soft_shadow(in vec3 wpos)\n{\n    vec3 dummy;\n    float shadow = 0.0;\n    float a = 0.0, b = 0.0;\n    \n    a = sin(wpos.x*1430.0);\n    b = sin(wpos.z*6312.0);\n    \n    vec3 to_sun = get_sun_direction();\n    \n    for(int i=0; i<8; ++i)\n    {\n        vec3 dir = to_sun;\n        \n        vec3 jitter = vec3(cos(a)*cos(b), sin(b), sin(a)*cos(b));\n        dir += jitter*0.03;\n        \n        a += 0.96;\n        b += 0.76;\n        \n        shadow += terrain_intersect(wpos + vec3(0.0, 0.1, 0.0), dir, 4.0, 40, 0, dummy) ? 0.0 : 1.0;\n    }\n    return shadow * (1.0/16.0);\n}\n\nfloat get_fog_density(in vec3 pos)\n{\n    vec3 coord = pos*FOG_NOISE_SCALE;\n    coord.x += iTime * FOG_NOISE_SPEED;\n    \n    float noise = texture(iChannel1, coord).x;\n    float exp_fog = exp(-pos.y*FOG_HEIGHT_FALLOFF)*FOG_GLOBAL_DENSITY*noise;\n    \n    float cloud_fog = CLOUDS_DENSITY;\n    float k = clamp((pos.y - CLOUDS_MAX_DENSITY_HEIGHT) / (CLOUDS_ZERO_DENSITY_HEIGHT - CLOUDS_MAX_DENSITY_HEIGHT), 0.0, 1.0);\n    cloud_fog *= 1.0 - k;\n\n    cloud_fog *= noise;\n    \n    return exp_fog + cloud_fog;\n}\n\n// Henyey-Greenstein phase function\nfloat HG_phase(in vec3 L, in vec3 V, in float aniso)\n{\n    float cosT = dot(L,-V);\n    float g = aniso;\n    return (1.0-g*g) / (4.0*PI*pow(1.0 + g*g - 2.0*g*cosT, 3.0/2.0));\n}\n\nvec3 apply_volumetric_fog(in vec3 eye, in vec3 pos, in vec3 scene_color, in float noise)\n{\n    vec3 dir = eye - pos;\n    vec3 V = normalize(dir);\n    vec3 L = get_sun_direction();\n    \n    vec3 accum = scene_color;\n    \n    float sun_phase = HG_phase(L, V, SUN_SCATTERING_ANISO)*3.0;\n    \n    float step = length(dir) / float(FOG_TRACE_STEPS) / 1.0;\n    \n    float jitter = noise*2.5;\n    \n    for(int i=0; i<FOG_TRACE_STEPS; ++i)\n    {\n        float k = float(i)/float(FOG_TRACE_STEPS-1);\n        k += jitter;\n        \n        vec3  pi = pos + dir*k;\n        float s = get_shadow(pi);\n        float f = get_fog_density(pi);\n        \n        float T = exp(-f*step);\n        \n        vec3 sky = SKY_COLOR * step;\n        vec3 sun = SUN_COLOR * sun_phase * s * step;\n        \n        accum = accum*T;\n        accum += sky * f;\n        accum += sun * f;\n    }\n    return accum;\n}\n\nvec3 tonemap(in vec3 hdr)\n{\n    return hdr / (hdr + vec3(1.0, 1.0, 1.0));\n}\n\nfloat compute_ao(in vec3 pos, in vec3 N)\n{\n    return 1.0;\n\n    float ao = 0.0, a=0.0, b=0.0;\n    vec3 dummy;\n    float vis_sum = 0.0;\n    \n    //a = abs(sin(pos.x/3.3))*6.0;\n    //b = abs(sin(pos.z/3.3))*4.0;\n    \n    b = max(b,0.2);\n    \n    #define AO_SAMPLES 16\n    \n    for(int i=0; i<AO_SAMPLES; ++i)\n    {\n        vec3 dir = vec3(cos(a)*cos(b), sin(b), sin(a)*cos(b));\n        \n        float sample_vis = max(0.0, dot(N, dir));\n\n        ao += terrain_intersect(pos + N, dir, 3.0, 40, 0, dummy) ? 0.0 : sample_vis;\n        vis_sum += sample_vis;\n        \n        a += 0.33;\n        b += 0.71456;\n        if(b > 3.14) b -= 3.14;\n        b = max(b,0.1);\n    }\n    \n    ao /= (vis_sum + 0.00001);\n    ao = pow(ao, 2.0);\n    \n    return ao;\n}\n\nvec3 light_terrain( in vec3 pos, in vec3 eye, in vec3 ray, in float noise )\n{\n    vec3 N = terrain_normal( pos );\n    vec3 L = get_sun_direction();\n    vec3 V = normalize(-ray);\n    float S = get_shadow(pos + N);\n    \n    vec3 ambient;\n    \n    ambient = SKY_COLOR;\n    ambient *= get_sky_visibility(N);\n    ambient *= compute_ao(pos, N);\n    \n    vec3 diffuse = max(dot(N, L), 0.0)*SUN_COLOR;\n    //diffuse *= get_soft_shadow(pos + N);\n    diffuse *= S;\n    \n    vec3 H = (L+V)*0.5;\n    \n    vec3 specular = SUN_COLOR * pow(max(0.0, dot(N,H)), 32.0) * S * 65.0;\n    \n    vec3 albedo = get_terrain_albedo(pos);\n    \n    vec3 color;\n    \n    color += ambient; \n    color += diffuse;\n    \n    color *= albedo;\n    \n    color += specular * pow(albedo.x,8.0);\n    \n    return color;\n}\n\nbool intersect_sphere( in vec3 ray, in vec3 center, in float R )\n{\n    float B = dot(center, ray);\n    float det = B*B - dot(center,center) + R * R;\n    if( det < 0.0 ) return false;\n    \n    float T = dot(ray, center) - sqrt(det);\n    return T > 0.0;\n}\n\nvec3 compute_sky( vec3 ray )\n{\n    vec3 color = mix( SKY_COLOR, SKY_COLOR*0.5, ray.y );\n    if( intersect_sphere( ray, get_sun_direction(), 0.05 ))\n    {\n        color += vec3(13.0,13.0,13.0);\n    }\n    return color;\n}\n\n\nvec3 shade_ray( vec3 eye, vec3 ray, float noise )\n{\n    vec3 pos, color;\n    \n    if( terrain_intersect( eye, ray, 3.0, 400, 5, pos ))\n    {\n        color = light_terrain( pos, eye, ray, noise );\n    }\n    else\n    {\n         color = compute_sky(ray);\n         pos = eye + ray*1000.0;\n    }\n    color = apply_volumetric_fog(eye, pos, color, 0.0);\n    color = tonemap(color);\n\treturn color;\n}\n\nfloat compute_average_terrain_height(in vec3 pos, in float radius)\n{\n    vec3 offset = vec3(1.0,0.0,0.0);\n    \n    float angle_step = 6.28/8.0;\n    float h0 = get_terrain_height(pos);\n    float h = h0;\n    float sum = 1.0;\n    \n    for(int j=1; j<=3; ++j)\n    {\n        float R = radius * float(j) * (1.0/3.0);\n        float weight = mix(1.0, 0.25, float(j)/8.0);\n        for(int i=0; i<8; ++i)\n        {\n            h += get_terrain_height(pos + offset*R)*weight;\n            sum += weight;\n            offset.xz = rotate(offset.xz, angle_step);\n        }\n    }\n    h /= sum;\n   \n    return max( h, h0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.xy = (fragCoord.xy - iResolution.xy*0.5)/iResolution.yy + vec2(0.5,0.5);\n\n    vec3 ray = normalize( vec3( fragCoord*2.0 - 1.0, 1.0 ));\n    ray.yz = rotate( ray.yz, CAMERA_PITCH );\n    \n    vec3 eye = vec3(iTime*2.0, 0.0, iTime*24.0);\n    eye.y = max( eye.y, compute_average_terrain_height(eye, 60.0) + 85.0);\n    \n    float fragment_noise = abs(sin(fragCoord.x*453.0 + iTime*40.0)*sin(fragCoord.y*3489.124));\n\n    vec3 color  = shade_ray(eye, ray, fragment_noise);\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}