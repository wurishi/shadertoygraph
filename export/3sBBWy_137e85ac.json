{"ver":"0.1","info":{"id":"3sBBWy","date":"1590675167","viewed":388,"name":"Floating things","username":"gaz","description":"Referenced volumelight  https://www.shadertoy.com/view/XsKGRz","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["volumelight","shadowmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getData (int id)\n{\n\tint row = int(iResolution.y);\n\treturn texelFetch(iChannel0,ivec2(id%row,id/row),0);\n}\n\nmat4 getMatrix(int id)\n{\n \tid = id*4;\n\treturn mat4(getData(id++),getData(id++),getData(id++),getData(id));\n}\n\nfloat map(vec3 p, int id)\n{\n\tp = (getMatrix(id)*vec4(p,1)).xyz;\n    int num = 0;\n  \tDE\n    \treturn sdRoundBox(p,vec3(10,0.1,10),0.1 );\n  \tEND\n  \tDE\n    \treturn sdRoundBox(p,vec3(1.7,1,0.3),0.1 );\n  \tEND   \n    return (id%2==0)?sdRoundBox(p,vec3(0.3),0.1):sdTorus(p,vec2(0.5,0.2));\n}\n\nfloat march(vec3 ro, vec3 rd, float maxd, inout int id)\n{\n    float depth = maxd;\n\tfor(int j=0;j<NUM;j++){\n        float t = 0.0, d;\n        for(int i = 0; i <64; i++)\n        {\n\t\t\tt += d = map(ro + rd * t, j);\n\t\t\tif(d < 0.001 || t>depth) break;\n\t\t}\n\t\tif(d < 0.001)\n        {\n\t\t\tdepth = t;\n            id=j;\n    \t}\n\t}\n    return depth;                  \n}\n                  \n//+++++++++++++++++++++++++                  \n                  \nvec3 calcNormal(vec3 p, int id)\n{\n  vec3 n = vec3(0.0);\n  for(int i = 0; i < 4; i++){\n    vec3 e = 0.001*(vec3(9>>i&1, i>>1&1, i&1)*2.0-1.0);\n    n += e * map(p + e, id);\n  }\n  return normalize(n);\n}\n\nvec3 doColor(int id)\n{\n  return mix(vec3(1), cos((vec3(3,37,25)+float(id+1000)*9.))*0.5+0.5, 0.7);\n}\n    \nfloat hash(vec3 n)\n{\n\treturn fract(sin(dot(n*0.123,vec3(12.9898,78.233,112.166))) * 43758.5453);\n}               \n    \n// https://www.shadertoy.com/view/XsKGRz\nfloat volumeLight(vec3 ro, vec3 rd, vec3 light, float depth, float maxd)\n{\n    int itr = 50;\n    float pitch=maxd/float(itr);\n\tfloat t=pitch*hash(rd);\n\tfloat ret=0.0;\n\tfor(int i=0; i<itr; i++)\n\t{\n\t\tvec3 p=ro+t*rd;\n\t\tvec3 lv=(p-light);\n\t\tfloat d=length(lv);\n\t\tlv/=d;\n\t\tfloat phi=asin(lv.y);\n\t\tvec2 uv=vec2(asin(lv.z/cos(phi)),phi);\n        if(lv.x<0.0)uv.x=(lv.z<0.0?-1.0:1.0)*PI-uv.x;\n        uv/=vec2(PI*2.0,PI);\n\t\tuv+=0.5;         \n\t\tif(d<textureLod(iChannel1,uv,0.0).x)\n        {\n\t\t\tret+=1.0/(1.0+5.0*d*d);\n\t\t}\n\t\tt+=pitch;\n\t\tif(t>depth)break;\n\t}\n\treturn ret;\n}\n                  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,7);\n    vec3 ta = vec3(1,0,0);\n    vec3 w = normalize(ta-ro);\n\tvec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));   \n\tint id;\n    vec3 col;\n\tfloat depth = march(ro, rd, MAXD, id);\n   \tif(depth<MAXD)\n\t{\n\t\tvec3 p = ro + rd * depth;\n    \tvec3 nor = calcNormal(p, id);   \n       \tcol = doColor(id);\n       \tvec3 lv=(lightPos-p);\n       \tfloat d=length(lv);\n\t\tif(d-march(lightPos, -lv/d, d, id)>0.01) col *= 0.3;\n       \tvec3 li = normalize(lv);\n       \tfloat dif = clamp(dot(nor, li), 0.3, 1.0);\n       \tfloat amb = max(0.5 + 0.5 * nor.y, 0.0);\n       \tfloat spc = pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 50.0);\n       \tcol *= dif * amb ;\n       \tfloat rimd = pow(clamp(1.0 - dot(reflect(-li, nor), -rd), 0.0, 1.0), 2.5);\n       \tfloat frn = rimd + 2.2 * (1.0 - rimd);\n       \tcol *= frn*0.8;\n       \tcol += vec3(0.9,0.7,0.3)*spc;\n   \t}\n    col = mix(vec3(0.05,0.15,0.3)*.3,col,exp(-depth*depth*0.008));    \n    col += vec3(0.9,0.7,0.3)*volumeLight(ro,rd,lightPos,depth,MAXD);\n    col = clamp(col,0.0,1.0);\n    col = pow(col,vec3(0.8));\n\tfragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.0)\n#define TAU PI*2.0\n\n#define NUM 30\n#define MAXD 25.0\n\n#define DE\tif(id == num){\n#define END }num++;\n\nvec3 lightPos=vec3(2,6,2);     \n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat4 move(vec3 p) {\n  return mat4(1,0,0,0,0,1,0,0,0,0,1,0,-p,1);\n}\n\nmat4 rotX(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1);\n}\nmat4 rotY(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);\n}\n\nmat4 rotZ(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(c,s,0,0,-s,c,0,0,0,0,1,0,0,0,0,1);\n}\n\nmat4 rot(vec3 axis, float t) {\n    vec3 a = normalize(axis);\n    float s=sin(t),c=cos(t),r=1.0-c;\n    return mat4(\n      a.x*a.x*r+c,a.y*a.x*r+a.z*s,a.z*a.x*r-a.y*s,0,\n      a.x*a.y*r-a.z*s,a.y*a.y*r+c,a.z*a.y*r+a.x*s,0,\n      a.x*a.z*r+a.y*s,a.y*a.z*r-a.x*s,a.z*a.z*r+c,0,\n      0,0,0,1);\n}\n\nfloat hash(float n)\n{\n\treturn fract(sin(n)*7777.0);\n}\n\nvec3 randVec(float n)\n{\n    float a=(hash(n)*2.-1.)*TAU,b=asin(hash(n+215.3)*2.-1.);\n    return vec3(cos(a),sin(a)*cos(b),sin(a)*sin(b));\n}\n\nvec3 randCurve(float t,float n)\n{\n\tvec3 p = vec3(0);\n\tfor (int i=0; i<6; i++)\n\t{\n\t\tp += randVec(n+=165.0)*sin((t*=0.8)+sin(t*1.6*hash(n))*0.5);\n\t}\n\treturn p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int id = int(fragCoord.x) + int(iResolution.y) * int(fragCoord.y);\n    if(id>=NUM*4)\n    {\n        discard;\n    }\n\tfloat mid = float(id/4);\n    mat4 m=mat4(1);\n    switch (id/4)\n    {\n        case 0:\n        \tm *= move(vec3(0,-5,0));\n        \tbreak;\n        case 1:\n        \tm *= rot(normalize(vec3(1)),iTime);\n        \tbreak;     \n    \tdefault:\n\t\t\tm *= rot(randVec(mid*53.44+563.21),iTime*1.5+hash(mid*896.23+45678.2)*10.0);\n\t\t\tm *= move(randCurve(iTime*1.5,mid*89.23+123.7)*2.0);\n\t\t\tm *= move((vec3(\n\t\t\t\thash(mid*2.236+455.0),\n\t\t\t\thash(mid*5.236+42255.0),\n\t\t\t\thash(mid*55.236+42255.0)\n\t\t\t)*2.0-1.0)*(1.0/hash(mid*77.23+852.2))*1.5);\n\t\t\tm *= rotZ(iTime*0.2);\n\t\t\tm *= rotX(iTime*0.3);\n    }\n    fragColor = m[id%4];\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getData (int id)\n{\n\tint row = int(iResolution.y);\n\treturn texelFetch(iChannel0,ivec2(id%row,id/row),0);\n}\n\nmat4 getMatrix(int id)\n{\n \tid = id*4;\n\treturn mat4(getData(id++),getData(id++),getData(id++),getData(id));\n}\n\nfloat map(vec3 p, int id)\n{\n\tp = (getMatrix(id)*vec4(p,1)).xyz;\n    int num = 0;\n  \tDE\n    \treturn sdRoundBox(p,vec3(10,0.1,10),0.1 );\n  \tEND\n  \tDE\n    \treturn sdRoundBox(p,vec3(1.7,1,0.3),0.1 );\n  \tEND   \n    return (id%2==0)?sdRoundBox(p,vec3(0.3),0.1):sdTorus(p,vec2(0.5,0.2));\n}\n\nfloat march(vec3 ro, vec3 rd, float maxd)\n{\n    float depth = maxd;\n\tfor(int j=0;j<NUM;j++){\n        float t = 0.0, d;\n        for(int i = 0; i <64; i++)\n        {\n\t\t\tt += d = map(ro + rd * t, j);\n\t\t\tif(d < 0.001 || t>depth) break;\n\t\t}\n\t\tif(d < 0.001)\n        {\n\t\t\tdepth = t;\n     \t}\n\t}\n    return depth;                  \n}         \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv *= vec2(PI*2.0,PI);\n\tvec3 ro = lightPos;\n\tvec3 rd = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n\tfragColor = vec4(march(ro, rd, 10.));\n}","name":"Buffer B","description":"","type":"buffer"}]}