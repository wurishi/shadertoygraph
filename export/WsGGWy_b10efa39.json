{"ver":"0.1","info":{"id":"WsGGWy","date":"1570811436","viewed":246,"name":"Move in circle ( tutorial )","username":"Kiltun","description":"A simple shader of a circle moving on a ring.\nI really tried to be understandable but if you need precision or just if you have ideas of optimization, you can write it in the comment section ^^.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","circle","ring","move","moveincircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nby Kilian Allaire (SLEEPN'T STUDIO). 11/10/2019\n\nHello, this is the first shader I made for shadertoy and \nI will try to explain you how I did. I am clearly not an expert\nand maybe this script is not optimal but I just want to have \nthe possibility to help other devs ^^.\n\nThis script is heavily based on this tutorial made by Uğur Güney : https://www.shadertoy.com/view/Md23DV\n(Go check his work, seriously)\n*/\n\n\n// choose one of the two options and compile the shader again\n// PART 1 = with aliasing\n// PART 2 = with anti-aliasing\n#define PART 1\n\n\n#if PART == 1\n\n// Function for making a disk :\n// \tr = screen resolution\n// \tcenter = position of the disk in the screen\n// \tradius = size of the disk\n// \tcolor = color of the disk\n// \tpixel = color output (what will be returned by the function)\n// \tWe will assign all this parameters when calling the function\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n    \n    // \"length(r-center)\" give us the distance between \"r\" and \"center\"\n    //  It will only change the color when it's inferior to the radius which will create a disk\n\tif( length(r-center) < radius) {\n\t\tpixel = color; \n\t}\n}\n\nvoid ring(vec2 r, vec2 center, float radius, vec3 lineColor, float lineThickness, inout vec3 pixel){\n    \n    // For making a ring, we will need to create two disk\n    // and then adding color between them\n    // 1st disk = \"length(r-center) < radius\"\n    // 2nd disk = \"length(r-center) > (radius - lineThickness)\"\n    if(length(r-center) < radius && length(r-center) > (radius - lineThickness)){        \n\t\tpixel = lineColor;        \n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; // Screen resolution in [-1.0, 1.0] scale\n    \n    vec3 pixel = vec3(0.1); // Base color\n    vec3 col1 = vec3(0.85,0.2,0.25); // red\n    vec3 col2 = vec3(0.95,0.92,0.95); // white\n    \n    float ringRadius = 0.7; \n    \n    // The math function to have a object moving in circle : \n    // X = originX + cos(angle)*radius;\n\t// Y = originY + sin(angle)*radius;\n    \n    // In this example the origin of the ring is the center \n    // of the screen ([0.0, 0.0]) so it's not important. \n    // I also wanted to have a moving object so I replace\n    // \"angle\" \n    // (the object has a specific position on the ring depending on the angle)\n    // by \"iTime\". \n    // (the object position depend on the time value which is always increasing)\n    vec2 mouvCircle = vec2((cos(iTime)*ringRadius),(sin(iTime)*ringRadius));\n\n    \n\t// calling functions\n    ring(r, vec2(0.0), ringRadius, col2, 0.05, pixel);\n    disk(r, mouvCircle, 0.2, col1, pixel);\n\n\n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}\n\n\n#elif PART == 2\n\n\t// In PART 1, we were able to see the pixel around \n\t// the disk and the ring, this is aliasing.\n\t// Here, we will reduce this effect by making the edges\n\t// fade which will give a nicer look to our objects.\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n        \n        // We will use the \"smoothstep\" function.\n        // This function act like a \"lerp\" function but \n        // will start slow and end slow (giving a better look) \n        \n        // exemple : ValueA = smoothstep( 0, 1, ValueB)\n        // \"ValueB\" will interpolate the \"ValueA\" between 0 and 1.\n        \n        // Thank to that, we can fade the edges of the disk by \n        // adjusting the brightness of it. \n        vec3 brightness = vec3(smoothstep(radius, radius - 0.06, length(r-center)));\n\t\tpixel = vec3(brightness * color); // adding color\n        \n\t}\n}\n\nvoid ring(vec2 r, vec2 center, float radius, vec3 lineColor, float lineThickness, inout vec3 pixel){\n    if(length(r-center) < radius && length(r-center) > (radius - lineThickness)){ \n        \n        // For the ring, we need to put the \"smoothstep\" function on the two edges.\n        // We start by taking the middle of the ring :\n        // ((radius - lineThickness) + (radius - (radius - lineThickness))*0.5)\n        // and then we use \"smoothstep\" from the middle of the ring to the two edges.\n        \n        // (edge1 to middle) * (middle to edge2) * Intensity\n        \n        lineColor = vec3(smoothstep(radius, (radius - lineThickness) + (radius - (radius - lineThickness))*0.5, length(r-center)))\n            \t* vec3(smoothstep( (radius - lineThickness) + (radius - (radius - lineThickness))*0.5, radius, length(r-center))) * 4.0;\n        \n\t\tpixel = vec3(lineColor);        \n        \n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 pixel = vec3(0.0);\n    vec3 col1 = vec3(0.15, 0.2, 0.95);\n    vec3 col2 = vec3(0.95, 0.92, 0.95);\n    \n    float ringRadius = 0.7;\n    \n    vec2 mouvCircle = vec2((cos(iTime)*ringRadius),(sin(iTime)*ringRadius));\n    \n\n    ring(r, vec2(0.0), ringRadius, col2, 0.09, pixel);\n    disk(r, mouvCircle, 0.2, col1, pixel);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(pixel), 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}