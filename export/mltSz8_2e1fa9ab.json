{"ver":"0.1","info":{"id":"mltSz8","date":"1685036121","viewed":70,"name":"capsule matheus freitas","username":"matheusfs2","description":"using ray tracing to make a cup of wine","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 origin, direction;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nSphere world[] = Sphere[2](\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5),\n    Sphere(vec3(0.0, -100.5, -1.0), 100.0)\n);\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n};\n\nfloat hit_sphere(vec3 center, float radius, Ray r){\n    vec3 oc = r.origin - center;\n    float a = dot(r.direction,r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminat = b*b - 4.0*a*c;\n    if (discriminat < 0.0)\n    return(-1.0);\n    else\n    return( (-b - sqrt(discriminat) ) / (2.0*a));\n}\n\n// -----------------------------------------------------\n// https://www.shadertoy.com/view/NlKBzm\n#define HASH_LUT_SIZE 256\n#define inc(x) (x+1)%HASH_LUT_SIZE\n\nconst float kMagic  = 3571.0;\n\n// Hash lookup table as defined by Ken Perlin.\n// This is a randomly arranged array of all numbers from 0-255 inclusive.\nconst int kHashLUT[] = int[HASH_LUT_SIZE](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180); \nconst int p[2*HASH_LUT_SIZE] = int[2*HASH_LUT_SIZE](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180); \n\nfloat RandFast(vec2 PixelPos)\n{\n\tvec2 Random2 = ( 1.0 / 4320.0 ) * PixelPos + vec2( 0.25, 0.0 );\n    float ran = dot( Random2, Random2 );\n\tfloat Random = fract( ran * kMagic );\n\tRandom = fract( Random * Random * (2.0 * kMagic) );\n\treturn Random;\n}\n\nfloat Mapping(float x) {\n    x = clamp(x, 0.0, 1.0);\n    float res = 0.0;\n    if(x<=0.2)\n        res = 0.1;\n    else if(x<=0.4)\n        res = 0.3;\n    else if(x<=0.6)\n        res = 0.5;\n    else if(x<=0.8)\n        res = 0.7;\n    else\n        res = 0.9;\n    return res;\n}\n\nfloat FadeSmooth(float x) {\n    float t = clamp(x, 0.0, 1.0);\n    float t_2 = t * t;\n    float res = t_2 * t * (6.0*t_2 - 15.0*t + 10.0);\n    return res;\n}\n\nvec2 RandomVector2D() {\n    return vec2(0.0, 0.0);\n}\n\n// pick a random vector\nfloat Grad(int hash, float x, float y, float z) {\n    int h = hash & 15;                                    \n    float u = h < 8 /* 0b1000 */ ? x : y;                \n    \n    float v;                                             \n    \n    if(h < 4 /* 0b0100 */)                               \n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/) \n        v = x;\n    else                                                 \n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); \n}\n\nfloat PerliNoise3D(float x, float y, float z) {\n    float repeat = 0.0;\n    if(repeat > 0.0) {\n        x = mod(x, repeat);\n        y = mod(y, repeat);\n        z = mod(z, repeat);\n    }\n    \n    int xi = int(x) & 255;                           \n    int yi = int(y) & 255;                              \n    int zi = int(z) & 255;                           \n    float xf = fract(x);\n    float yf = fract(y);\n    float zf = fract(z);\n    \n    float u = FadeSmooth(xf);\n    float v = FadeSmooth(yf);\n    float w = FadeSmooth(zf);\n    \n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n   \n    float x1, x2, y1, y2;\n    x1 = mix(Grad(aaa, xf, yf, zf), Grad(baa, xf-1.0, yf, zf), u);                                     \n    x2 = mix(Grad(aba, xf, yf-1.0, zf), Grad(bba, xf-1.0, yf-1.0, zf), u);\n    y1 = mix(x1, x2, v);\n\n    x1 = mix(Grad(aab, xf, yf, zf-1.0), Grad(bab, xf-1.0, yf, zf-1.0), u);\n    x2 = mix(Grad(abb, xf, yf-1.0, zf-1.0), Grad(bbb, xf-1.0, yf-1.0, zf-1.0), u);\n    y2 = mix (x1, x2, v);\n    \n    return (mix(y1, y2, w)+1.0)/2.0; \n}\n// -----------------------------------------------------\n\n// Função para calcular a interseção entre um raio e uma cápsula\nfloat intersectCapsule(vec3 rayOrigin, vec3 rayDirection, vec3 capsuleStart, vec3 capsuleEnd, float capsuleRadius)\n{\n    vec3 oc = rayOrigin - capsuleStart;\n    vec3 d = normalize(rayDirection);\n    float tmin = -1.0;\n    \n    // Interseção com as semiesferas nas extremidades\n    float t1 = dot(-oc, d);\n    vec3 p1 = rayOrigin + t1 * d;\n    if (t1 >= 0.0 && length(p1 - capsuleStart) <= capsuleRadius) {\n        tmin = t1;\n    }\n    \n    float t2 = dot(capsuleEnd - capsuleStart, d);\n    vec3 p2 = rayOrigin + t2 * d;\n    if (t2 >= 0.0 && t2 <= tmin && length(p2 - capsuleEnd) <= capsuleRadius) {\n        tmin = t2;\n    }\n    \n    // Interseção com o cilindro central\n    vec3 p3 = rayOrigin + tmin * d;\n    vec3 v = normalize(capsuleEnd - capsuleStart);\n    float t3 = dot(p3 - capsuleStart, v);\n    \n    if (t3 >= 0.0 && t3 <= length(capsuleEnd - capsuleStart) && tmin >= 0.0) {\n        return tmin;\n    }\n    \n    return -1.0; // Nenhuma interseção\n}\n\nvec3 calculateCapsuleNormal(vec3 point, vec3 capsuleStart, vec3 capsuleEnd, float capsuleRadius)\n{\n    vec3 v = normalize(capsuleEnd - capsuleStart);\n    vec3 n1 = normalize(point - capsuleStart);\n    vec3 n2 = normalize(point - capsuleEnd);\n    \n    float t = dot(point - capsuleStart, v);\n    float t1 = dot(n1, v);\n    float t2 = dot(n2, -v);\n    \n    // Verifica se o ponto está nas semiesferas\n    if (t <= 0.0) {\n        return n1;\n    }\n    else if (t >= length(capsuleEnd - capsuleStart)) {\n        return n2;\n    }\n    else {\n        // O ponto está no cilindro central\n        vec3 n3 = normalize(point - (capsuleStart + t * v));\n        vec3 normal = mix(n1, n2, t / length(capsuleEnd - capsuleStart));\n        return normalize(normal + n3);\n    }\n}\n\n\n\nvec3 point_at_parameter(Ray r, float t) {\n    return(r.origin + t*r.direction);\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 color(Ray r, vec2 uv){\n    // float t = hit_sphere(vec3(0.,0.,-1.), 0.5, r);\n    \n    // float t = intersectCapsule(r.origin, r.direction, vec3(mod(iTime, 1.5),mod(iTime, 1.5),-1.25), vec3(2.5e-4,2.5e-4,2.5e-4), 0.2);\n    float t = intersectCapsule(r.origin, r.direction, vec3(.65,.65,-1.25)*rotateY(mod(iTime, 1.)), vec3(2.5e-4,2.5e-4,2.5e-4)*rotateY(iTime), 0.2);\n    if(t > 0.0) {\n        // circle \n        // vec3 N = normalize(point_at_parameter(r,t) - vec3(0.0, 0.0, -1.0));\n        // return 0.5*(N+vec3(1.0));\n        \n        // capsule calculate normal\n        // vec3 N = calculateCapsuleNormal(point_at_parameter(r,t), vec3(mod(iTime, 5.),.5,-1.25), vec3(2.5e-4,2.5e-4,2.5e-4), 0.2);\n        // return 0.5*(N+vec3(1.0));\n        \n        // calculate perlin noise\n        vec2 noise_uv = uv + vec2(iTime) * 0.1;\n        float res = PerliNoise3D(10.0*noise_uv.x, 10.0*noise_uv.y, 0.0); \n        \n        // turbulence\n        res += PerliNoise3D(10.0*noise_uv.x + .05, 10.0*noise_uv.y + .05, 0.0); \n        \n        if(uv.x * iResolution.y < (0.5-0.002)*iResolution.x) {\n            res = Mapping(res);\n        }\n        else if(uv.x * iResolution.y > (0.5+0.002)*iResolution.x) {\n        // do nothing\n            ;\n        }\n        else{\n            res = 0.0;\n        }\n        \n        return vec3(res);\n    }\n    vec3 unit_direction = normalize(r.direction);\n    t = 0.5 * (unit_direction.y + 1.0);\n    return mix(vec3(1.0), vec3(0.5,0.7,1.0), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 lower_left_corner = vec3(-1.0*aspect,-1.0, -1.0);\n    vec3 horizontal = vec3(2.0*aspect, 0.0, 0.0);\n    vec3 vertical = vec3(0.0,2.0, 0.0);\n    Ray r = Ray(vec3(0,0,0), lower_left_corner+uv.x*horizontal+uv.y*vertical);\n    fragColor = vec4(color(r, uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}