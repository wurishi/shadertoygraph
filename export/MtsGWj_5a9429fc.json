{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n// For the love of relative scale.\n//\n// This shader drills down into floating point precision loss in a sdf raymarcher\n//\n// Credits to IQ and whoever wrote some of these single double functions\n// I've added a few to the list.\n//\n// -Floseph\n//\n\n#define USE_DOUBLESINGLE 1\n#define ANIMATE 1\n\n// some double single code found on the web all over the place\nvec2 ds_set(float a) \n{\n    vec2 z;\n    z.x = a;\n    z.y = 0.0;\n    return z;\n}\n\nvec2 ds_add (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float t1, t2, e;\n\n    t1 = dsa.x + dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\nvec2 ds_sub (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\nvec2 ds_mul (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x) {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n        else return 1.;\n    }\n    else return 1.;\n}\n\nstruct dsvec3\n{\n    vec2 x;\n    vec2 y;\n    vec2 z;\n};\n\ndsvec3 set(vec3 v)\n{\n    return dsvec3(vec2(v.x, 0.0), vec2(v.y, 0.0), vec2(v.z, 0.0));\n}\n\ndsvec3 calcRayPos(vec3 ro, vec3 rd, vec2 t)\n{\n    dsvec3 dsrd = set(rd);\n    dsvec3 dsrp = set(ro);\n    dsrd.x = ds_mul(dsrd.x, t);\n    dsrd.y = ds_mul(dsrd.y, t);\n    dsrd.z = ds_mul(dsrd.z, t);\n    dsrp.x = ds_add(dsrp.x, dsrd.x);\n    dsrp.y = ds_add(dsrp.y, dsrd.y);\n    dsrp.z = ds_add(dsrp.z, dsrd.z);\n    return dsrp;\n}\n\nvec2 ds_sqrt(vec2 d)\n{\n    //\n\t// sqrt(d) = (d * x) + 0.5 * [d - (d * x)^2] * x (approx.)\n    //\n    vec2 x = vec2(inversesqrt(d.x), 0.0);\n    vec2 dtx = ds_mul(d, x);\n    return ds_add(dtx, ds_mul(vec2(0.5, 0.0), ds_mul(ds_sub(d, ds_mul(dtx, dtx)), x)));\n}\n\nvec2 ds_length(dsvec3 p)\n{\n    return ds_sqrt(ds_add(ds_add(ds_mul(p.x, p.x), ds_mul(p.y, p.y)), ds_mul(p.z, p.z)));\n}\n\nvec2 ds_min(vec2 a, vec2 b)\n{\n    return (ds_compare(a, b) < 0.0) ? a : b;\n}\n\ndsvec3 ds_mul(dsvec3 p, float a)\n{\n    return dsvec3(ds_mul(p.x, vec2(a, 0.0)), ds_mul(p.y, vec2(a, 0.0)), ds_mul(p.z, vec2(a, 0.0)));\n}\n\n// IQ's noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n\n#ifdef USE_DOUBLESINGLE\n\nvec2 rmf(dsvec3 p, float f, float l)\n{\n    p = ds_mul(p, f);\n    float s = 0.0;\n    vec2 v  = vec2(0.0);\n    float w = 1.0;\n    float h = 1.0;\n    float fs = 1.0;\n\n    for (int i=0; i < 8; i++) \n    {\n        s = noise(vec3(p.x.x+p.x.y, p.y.x+p.y.y, p.z.x+p.z.y));\n        s = pow(1.0 - abs(s), 2.0) * w;\n        w = clamp(0.0, 1.0, s * 16.0);\n        v = ds_add(v, vec2(s * pow(fs, -1.0), 0.0));\n        fs *= l;\n        p = ds_mul(p, l);\n    }\n    \n    return v;\n}\n\nvec2 sdf(dsvec3 p)\n{\n    vec2 s0 = ds_sub(ds_length(p), vec2(1.0, 0.0));\n    dsvec3 q = dsvec3(ds_sub(p.x, vec2(0.141, 0.0)), ds_sub(p.y, vec2(0.1, 0.0)), ds_sub(p.z, vec2(0.9, 0.0)));\n    vec2 s1 = ds_sub(ds_length(q), vec2(0.2, 0.0));\n\n    vec2 sd = ds_min(s0, s1);\n    vec2 n = ds_mul(rmf(p, 512.0, 2.0), vec2(0.00025, 0.0));\n    n = ds_sub(sd, n);\n    return n;\n    \n}\ndsvec3 grad(dsvec3 p, vec2 coneR)\n{\n    vec2 f = sdf(p);\n    dsvec3 q = p;\n    q.x = ds_add(q.x, coneR);\n    vec2 g0 = sdf(q);\n    q.x = p.x;\n    q.y = ds_add(q.y, coneR);\n    vec2 g1 = sdf(q);\n    q.y = p.y;\n    q.z = ds_add(q.z, coneR);\n    vec2 g2 = sdf(q);\n    q.x = ds_sub(g0, f);\n    q.y = ds_sub(g1, f);\n    q.z = ds_sub(g2, f);\n    return q;//(g-f) / coneR;\n}\n\n#else\nfloat rmf(vec3 p, float f, float l)\n{\n    p *= f;\n    float s = 0.0;\n    float v  = 0.0;\n    float w = 1.0;\n    float h = 1.0;\n    float fs = 1.0;\n\n    for (int i=0; i < 8; i++) \n    {\n        s = noise(p);\n        s = pow(1.0 - abs(s), 2.0) * w;\n        w = clamp(0.0, 1.0, s * 16.0);\n        v += (s * pow(fs, -1.0));\n        fs *= l;\n        p *= l;\n    }\n    \n    return v;\n}\nfloat sdf(vec3 p)\n{\n    return min(length(p)-1.0, length(p-vec3(0.141, 0.1, 0.9))-0.2) - rmf(p, 512.0, 2.0)*0.00025;\n}\nvec3 grad(vec3 p, float coneR)\n{\n    vec3 f = vec3(sdf(p));\n    vec3 g = vec3(sdf(p+vec3(coneR, 0.0, 0.0)),\n                  sdf(p+vec3(0.0, coneR, 0.0)),\n                  sdf(p+vec3(0.0, 0.0, coneR)));\n    return (g-f) / coneR;\n}\n\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    //vec2 m = 2.0*(mouse * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    #ifdef ANIMATE\n\tvec3 ro = vec3(0.0, 0.0, 1.1-sin(iTime*0.5)*0.0989);\n    #else\n    vec3 ro = vec3(0.0, 0.0, 1.1-0.0989);\n    #endif\n    \n    vec2 coord = vec2(fragCoord.xy);\n    vec2 v = vec2(coord / iResolution.xy) * 2.0 - 1.0;\n    float camAspect = iResolution.x/iResolution.y;\n    float fov_y_scale = tan(radians(30.0));\n    vec3 rd = normalize(vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0));\n    \n    #ifdef USE_DOUBLESINGLE\n    vec2 t = vec2(0.0);    \n    vec2 coneR;\n    vec2 sd;\n    #else\n    float t = 0.0;\n    float coneR = 0.0;\n    float sd;\n    #endif\n    \n    float coneScale = tan(radians(30.0)/iResolution.y);\n    \n    for (int i=0; i<256; i++)\n    {\n\n        #ifdef USE_DOUBLESINGLE\n        coneR = ds_mul(vec2(coneScale, 0.0), t);\n        dsvec3 rp = calcRayPos(ro, rd, t);\n        #else\n        vec3 rp;\n        coneR = coneScale * t;\n        rp = ro+rd*t;\n        #endif\n        \n        sd = sdf(rp);\n        \n        #ifdef USE_DOUBLESINGLE        \n        if (ds_compare(abs(sd), coneR) < 0.0)\n        {\n            dsvec3 g = grad(rp, coneR);\n            vec3 N = normalize(vec3(g.x.x, g.y.x, g.z.x));\n            fragColor = vec4(N*0.5+0.5, 1.0);\n            return;\n        }\n        else if (t.x > 3.0)\n        {\n            break;\n        }\n        t = ds_add(t, sd);\n        #else\n        if (abs(sd) < coneR)\n        {\n            vec3 N = normalize(grad(rp, coneR));\n            fragColor = vec4(N*0.5+0.5, 1.0);\n            return;\n        }\n        else if (t > 3.0)\n        {\n            break;\n        }\n        t += sd;\n        #endif\n        \n    }\n    \n    fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGWj","date":"1425343593","viewed":277,"name":"The Hassle of Relative Scale","username":"florian","description":"A classic ray marcher of sphere plus noise of sorts, using emulated somewhat double precision. I've tracked down the floating point precision loss all the way except for IQ's noise, which still is single float and lossy. Uncomment the #defines to see diff","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["singledouble","relativescale","detail","flopsgalore"],"hasliked":0,"parentid":"","parentname":""}}