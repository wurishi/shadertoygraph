{"ver":"0.1","info":{"id":"wsXyW4","date":"1584786557","viewed":388,"name":"Day 93","username":"jeyko","description":"potato","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Pallete from Inigo Quilez\n// pModPolar from hg-sdf library\n// Antialiasing thx to Fabrice Neyret\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define PI acos(-1.)\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    \n    \n    n += valueNoise(uv*500.,0.1);\n    //n += valueNoise(uv*1000., 0.1)*0.5;\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    \n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    \n    \n    n = max(n, 0.);\n    return n;\n}\n\nvec3 get(vec2 fragCoord){\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y ;\n\n    vec3 col = vec3(0);\n    \n    vec2 uvn = uv;\n    \n    float mm = 4.;\n    uvn *= rot(-PI*mm*0.5);\n    \n    // random IFS stuff\n    for(int i = 0; i < 26; i++){\n    \tuvn = abs(uvn);\n        uvn -= 0.25;\n    \tuvn.y += 0.299991;\n        if(uvn.x < 0.){\n        \tuvn.x -= 1.*uvn.y;\n        }\n        if(uvn.y < 0.){\n        \t//uvn.y -= 1.*uvn.y;\n        }\n        uvn *= rot(0.5 *PI);\n    }\n    \n    float j = pModPolar(uvn, mm);\n    float modD = 0.05;\n    vec2 id = vec2(j,floor(uvn.x/modD));\n    uvn.x = pmod(uvn.x, modD);\n    \n    vec3 c = pal(0.5,0.5,vec3(1.,0.7,0.5), 0.6 + id.x, id.y + iTime*0.5);\n    \n    c = max(c, 0.);\n    \n    col += c;\n    col -= fbm(uv).x*0.1;\n    col += fbm(uv + 4.).x*0.1;\n    \n    \n    \n    // vignette\n    col = pow(col, vec3(1. + dot(uv,uv)*0.1));\n    col *=1. -  dot(uv,uv)*0.7;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // float(min(iFrame,0)) hack for faster compilation (stops loop unrolling)\n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.1);\n    }\n    col /= 9.;\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}