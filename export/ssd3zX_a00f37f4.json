{"ver":"0.1","info":{"id":"ssd3zX","date":"1630446375","viewed":268,"name":"Movable Hyperbolic Tessellation","username":"diabolix17","description":"Click to move the origin to any point. See source code for different options.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["tessellation","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Color schemes:\n// 0 is \"wireframe\",\n// 1 is alternating colors,\n// 2 is a texture generated by the function \"tex\" (generates the flowers you see),\n// 3 is the texture in iChannel0.\n// There is an add-on for Firefox and Chrome that allows you to use custom textures.\n// You can make some really nice faux Escher tilings with that.\n#define COLOR_SCHEME 2\n\n// Any whole numbers whose reciprocals sum to less than 1 can be chosen\n#define P 2.0\n#define Q 3.0\n#define R 7.0\n\n// Uncomment to see the Beltrami or upper half plane models instead\n//#define BELTRAMI\n//#define UPPER_HALF_PLANE\n\n// Multisampling with SAMPLES^2 samples\n#define SAMPLES 2\n\n// Uncomment to show the edges of the triangles\n#define EDGE_OVERLAY\n#define EDGE_THICKNESS 0.002\n\n// -------------------------------------------------------------------------------------\n\n#define PI 3.141592653\n#define MAX_ITER 100\n\n// Complex number functions\nvec2 conj(vec2 a){\n    return vec2(a.x,-a.y);\n}\n\nvec2 comp_mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 comp_inv(vec2 a){\n    return vec2(a.x, -a.y) / dot(a,a);\n}\n\nvec2 comp_div(vec2 a, vec2 b){\n    return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y));\n}\n\n\n// There is a unique hyperbolic translation that takes m to the origin.\n// This function applies that translation to p.\nvec2 map_to_origin(vec2 m, vec2 p){\n    \n    return comp_div(p-m, comp_mul(-conj(m), p) + vec2(1.0,0.0));\n}\n\nvec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){\n    \n    float det = d2.x*d1.y - d1.x*d2.y;\n    if(det == 0.0){\n        return vec2(0.0);\n    }\n    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;\n    float l1 = det1 / det;\n    return P1 + l1*d1;\n}\n\n// compute the circle (center and radius) corresponding to the hyperbolic line through a and b\nvec3 hyp_line_circle(vec2 a, vec2 b){\n    vec2 a1 = comp_inv(conj(a));\n    vec2 b1 = comp_inv(conj(b));\n    \n    vec2 p1 = 0.5*(a+a1);\n    vec2 p2 = 0.5*(b+b1);\n    \n    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));\n    float r = length(a - c);\n    return vec3(c,r);\n}\n\n\nbool euclidean_line_side(vec2 p, vec2 a, vec2 b){\n    vec2 n = vec2(-(b-a).y, (b-a).x);\n    return dot(n,p-a) < 0.0;\n}\n\nbool hyperbolic_line_side(vec2 p, vec2 a, vec2 b){\n    if(a == vec2(0.0)){\n        return euclidean_line_side(p,b,vec2(0.0,0.0));\n    }\n    vec3 circle = hyp_line_circle(a,b);\n    return length(p - circle.xy) < circle.z;\n}\n\nfloat line_dist(vec2 p, vec2 a, vec2 b){\n    \n    vec2 d = p - a;\n    vec2 l = normalize(b-a);\n    return length(d - dot(d,l)*l);\n}\n\nfloat circle_dist(vec2 p, vec3 circle){\n    vec2 d = p - circle.xy;\n    return length(d) - circle.z; \n}\n\n\nvec2 circle_inversion(vec2 p, vec2 c, float r){\n    return r*r*comp_inv(conj(p-c)) + c;\n}\n\nvec2 euclidean_reflection(vec2 p, vec2 a, vec2 b){\n    vec2 n = vec2(-(b-a).y, (b-a).x);\n    n = normalize(n);\n    return p - 2.0*dot(p-a,n)*n;\n}\n\nvec2 beltrami_to_poincare(vec2 p){\n    float z = sqrt(1.0 - dot(p,p));\n    float alpha = 1.0/(z+1.0);\n    return alpha * p;\n}\n\nvec2 upper_half_plane_to_poincare(vec2 p){\n    p += vec2(0.0,1.0);\n    return comp_div(p - vec2(0.0,1.0), p + vec2(0.0,1.0));\n}\n\nvec4 tex( vec2 uv )\n{\n    uv.y /= 2.0;\n    \n    vec4 color;\n    \n    color = vec4(0.5,1.0,0.5,1.0);\n    \n    if(length(uv - vec2(0.5, -0.3)) <= 0.58){\n        color = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    if(length(uv - vec2(0.5, -0.3)) <= 0.5){\n        color = vec4(1.0,0.0,0.0,1.0);\n    }\n    if(length(uv) <= 0.15){\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    return color;\n}\n\nvec4 shader(vec2 uv){\n\n    vec2 coords = 2.0*uv-vec2(1.0);\n    coords.x *= iResolution.x / iResolution.y;\n\n#ifndef UPPER_HALF_PLANE\n    if(length(coords) >= 1.0){\n        return vec4(0.2, 0.0, 0.2, 1.0);\n    }\n#endif\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = 2.0*mouse - vec2(1.0);\n    mouse.x *= iResolution.x / iResolution.y;\n    \n#ifdef BELTRAMI\n    coords = beltrami_to_poincare(coords);\n    mouse = beltrami_to_poincare(mouse);\n#endif\n\n#ifdef UPPER_HALF_PLANE\n    coords = upper_half_plane_to_poincare(coords);\n    mouse = upper_half_plane_to_poincare(mouse);\n#endif\n\n    if(length(mouse) < 1.0){\n        coords = map_to_origin(mouse,coords);\n    }\n    \n    // compute two side lengths of the fundamental triangle using the hyperbolic law of cosines\n    float s1 = tanh(0.5*acosh((cos(PI/P) + cos(PI/Q)*cos(PI/R)) / (sin(PI/Q)*sin(PI/R))));\n    float s2 = tanh(0.5*acosh((cos(PI/Q) + cos(PI/P)*cos(PI/R)) / (sin(PI/P)*sin(PI/R))));\n    \n    // one vertex of the triangle is always set to be the origin, so that two of the sides are straight lines\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(s1, 0.0);\n    mat2 rot = mat2(vec2(cos(PI/R), sin(PI/R)), vec2(-sin(PI/R), cos(PI/R)));\n    vec2 c = rot*vec2(s2, 0.0);\n    \n    bool inside;\n    int iter = 0;\n    \n    vec3 circle = hyp_line_circle(b, c);\n    \n    while(true){\n    \n        inside = true;\n\n        if(hyperbolic_line_side(coords, c,b)){\n            coords = circle_inversion(coords, circle.xy, circle.z);\n            inside = false;\n            iter++;\n        }\n        \n        if(euclidean_line_side(coords, c,a)){\n            coords = euclidean_reflection(coords, c,a);\n            inside = false;\n            iter++;\n        }\n        \n        if(euclidean_line_side(coords, a,b)){\n            coords = euclidean_reflection(coords, a,b);\n            inside = false;\n            iter++;\n        }\n      \n        if(inside || iter > MAX_ITER){\n            break;\n        }\n    }\n    \n    if(COLOR_SCHEME == 0){\n        if(    line_dist(coords, c,a) <= EDGE_THICKNESS\n            || line_dist(coords, b,a) <= EDGE_THICKNESS\n            || circle_dist(coords, circle) <= EDGE_THICKNESS){\n                   return vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    \n        return vec4(1.0);\n    }\n    \n    vec4 color;\n    \n    if(COLOR_SCHEME == 1){\n        if((iter % 2) == 1){\n            color = vec4(1.0, 0.0, 0.0, 1.0);\n        } else {\n            color = vec4(1.0);\n        }\n    }\n    \n    vec2 tex_coords;\n    \n    // scale texture coordinates so that maximum x and y coordinates are 1\n    tex_coords.x = coords.x / s1;\n    \n    // do some trig to figure out the height of the fundamental triangle\n    float s3 = sqrt(s1*s1 + s2*s2 - 2.0*s1*s2*cos(PI/R));\n    float s4 = (s1+s2+s3)/2.0;\n    float area = sqrt(s4*(s4-s1)*(s4-s2)*(s4-s3));\n    float height = 2.0 * area / s1;\n    \n    tex_coords.y = coords.y / height;\n    \n    if(COLOR_SCHEME == 2){\n        color = tex(tex_coords);\n    }\n    \n    if(COLOR_SCHEME == 3){\n        color = texture(iChannel0,tex_coords);\n    }\n    \n#ifdef EDGE_OVERLAY\n    if(   line_dist(coords, c,a) <= EDGE_THICKNESS\n       || line_dist(coords, b,a) <= EDGE_THICKNESS\n       || circle_dist(coords, circle) <= EDGE_THICKNESS){\n                   color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n#endif    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixel_size = vec2(1.0/iResolution.x,1.0/iResolution.y);\n    uv -= pixel_size / 2.0;\n    vec2 pixel_inc = pixel_size / float(SAMPLES+1);\n    vec4 color = vec4(0.0);\n    for(int i = 1; i <= SAMPLES; i++){\n        for(int j = 1; j <= SAMPLES; j++){\n            color += shader(uv + float(i)*pixel_inc.x + float(j)*pixel_inc.y);\n        }\n    }\n    \n    fragColor = color/float(SAMPLES * SAMPLES);\n    \n}","name":"Image","description":"","type":"image"}]}