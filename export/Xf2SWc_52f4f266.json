{"ver":"0.1","info":{"id":"Xf2SWc","date":"1706899399","viewed":57,"name":" Cubic bezier - Nearest Point","username":"doles","description":"Based on https://www.shadertoy.com/view/4sKyzW\nSimply split cubic_bezier_nearest() out of cubic_bezier_dis().","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","beziercurve","distance","polynomial","cubicbezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\nInspired by https://www.shadertoy.com/view/4sXyDr and https://www.shadertoy.com/view/ldXXWH\nSee also my approximate version:\nhttps://www.shadertoy.com/view/lsByRG\n*/\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size = .005;\nconst vec3 point_col = vec3(1, 1, 0);\nconst int halley_iterations = 8;\n\n// lagrange positive real root upper bound\n// see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4)\n{\n\n  vec4 coeffs1 = vec4(a0, a1, a2, a3);\n\n  vec4 neg1 = max(-coeffs1, vec4(0));\n  float neg2 = max(-a4, 0.);\n\n  const vec4 indizes1 = vec4(0, 1, 2, 3);\n  const float indizes2 = 4.;\n\n  vec4 bounds1 = pow(neg1, 1. / (5. - indizes1));\n  float bounds2 = pow(neg2, 1. / (5. - indizes2));\n\n  vec2 min1_2 = min(bounds1.xz, bounds1.yw);\n  vec2 max1_2 = max(bounds1.xz, bounds1.yw);\n\n  float maxmin = max(min1_2.x, min1_2.y);\n  float minmax = min(max1_2.x, max1_2.y);\n\n  float max3 = max(max1_2.x, max1_2.y);\n\n  float max_max = max(max3, bounds2);\n  float max_max2 = max(min(max3, bounds2), max(minmax, maxmin));\n\n  return max_max + max_max2;\n}\n\n// lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4)\n{\n\n  vec4 coeffs1 = vec4(-a0, a1, -a2, a3);\n\n  vec4 neg1 = max(-coeffs1, vec4(0));\n  float neg2 = max(-a4, 0.);\n\n  const vec4 indizes1 = vec4(0, 1, 2, 3);\n  const float indizes2 = 4.;\n\n  vec4 bounds1 = pow(neg1, 1. / (5. - indizes1));\n  float bounds2 = pow(neg2, 1. / (5. - indizes2));\n\n  vec2 min1_2 = min(bounds1.xz, bounds1.yw);\n  vec2 max1_2 = max(bounds1.xz, bounds1.yw);\n\n  float maxmin = max(min1_2.x, min1_2.y);\n  float minmax = min(max1_2.x, max1_2.y);\n\n  float max3 = max(max1_2.x, max1_2.y);\n\n  float max_max = max(max3, bounds2);\n  float max_max2 = max(min(max3, bounds2), max(minmax, maxmin));\n\n  return -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  vec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n  vec2 a1 = (3. * p0 - 6. * p1 + 3. * p2);\n  vec2 a2 = (-3. * p0 + 3. * p1);\n  vec2 a3 = p0;\n\n  return (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots)\n{\n  vec3 tmp;\n\n  tmp[0] = min(roots[0], min(roots[1], roots[2]));\n  tmp[1] = max(roots[0], min(roots[1], roots[2]));\n  tmp[2] = max(roots[0], max(roots[1], roots[2]));\n\n  roots = tmp;\n}\n\nvoid sort_roots4(inout vec4 roots)\n{\n  vec4 tmp;\n\n  vec2 min1_2 = min(roots.xz, roots.yw);\n  vec2 max1_2 = max(roots.xz, roots.yw);\n\n  float maxmin = max(min1_2.x, min1_2.y);\n  float minmax = min(max1_2.x, max1_2.y);\n\n  tmp[0] = min(min1_2.x, min1_2.y);\n  tmp[1] = min(maxmin, minmax);\n  tmp[2] = max(minmax, maxmin);\n  tmp[3] = max(max1_2.x, max1_2.y);\n\n  roots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x)\n{\n\n  float f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n  return f;\n}\n\n// halley's method\n// basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n// see http://mathworld.wolfram.com/HalleysMethod.html\n// or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x)\n{\n\n  float f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n  float f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n  float f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n  return x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x)\n{\n\n  float f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n  float f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n  float f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n  return x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots)\n{\n\n  // normal form: x^2 + px + q = 0\n  float p = coeffs[1] / 2.;\n  float q = coeffs[0];\n\n  float D = p * p - q;\n\n  if (D < 0.)\n  {\n    return 0;\n  }\n  else if (D > 0.)\n  {\n    roots[0] = -sqrt(D) - p;\n    roots[1] = sqrt(D) - p;\n\n    return 2;\n  }\n}\n\n// From Trisomie21\n// But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r)\n{\n\n  float a = coeffs[2];\n  float b = coeffs[1];\n  float c = coeffs[0];\n\n  float p = b - a * a / 3.0;\n  float q = a * (2.0 * a * a - 9.0 * b) / 27.0 + c;\n  float p3 = p * p * p;\n  float d = q * q + 4.0 * p3 / 27.0;\n  float offset = -a / 3.0;\n  if (d >= 0.0)\n  { // Single solution\n    float z = sqrt(d);\n    float u = (-q + z) / 2.0;\n    float v = (-q - z) / 2.0;\n    u = sign(u) * pow(abs(u), 1.0 / 3.0);\n    v = sign(v) * pow(abs(v), 1.0 / 3.0);\n    r[0] = offset + u + v;\n\n    // Single newton iteration to account for cancellation\n    float f = ((r[0] + a) * r[0] + b) * r[0] + c;\n    float f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n    r[0] -= f / f1;\n\n    return 1;\n  }\n  float u = sqrt(-p / 3.0);\n  float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n  float m = cos(v), n = sin(v) * 1.732050808;\n\n  // Single newton iteration to account for cancellation\n  //(once for every root)\n  r[0] = offset + u * (m + m);\n  r[1] = offset - u * (n + m);\n  r[2] = offset + u * (n - m);\n\n  vec3 f = ((r + a) * r + b) * r + c;\n  vec3 f1 = (3. * r + 2. * a) * r + b;\n\n  r -= f / f1;\n\n  return 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s)\n{\n\n  float a = coeffs[3];\n  float b = coeffs[2];\n  float c = coeffs[1];\n  float d = coeffs[0];\n\n  /*  substitute x = y - A/4 to eliminate cubic term:\nx^4 + px^2 + qx + r = 0 */\n\n  float sq_a = a * a;\n  float p = -3. / 8. * sq_a + b;\n  float q = 1. / 8. * sq_a * a - 1. / 2. * a * b + c;\n  float r = -3. / 256. * sq_a * sq_a + 1. / 16. * sq_a * b - 1. / 4. * a * c + d;\n\n  int num;\n\n  /* doesn't seem to happen for me */\n  // if(abs(r)<eps){\n  //\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n  //\tvec3 cubic_coeffs;\n\n  //\tcubic_coeffs[0] = q;\n  //\tcubic_coeffs[1] = p;\n  //\tcubic_coeffs[2] = 0.;\n\n  //\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n  //\ts[num] = 0.;\n  //\tnum++;\n  //}\n  {\n    /* solve the resolvent cubic ... */\n\n    vec3 cubic_coeffs;\n\n    cubic_coeffs[0] = 1.0 / 2. * r * p - 1.0 / 8. * q * q;\n    cubic_coeffs[1] = -r;\n    cubic_coeffs[2] = -1.0 / 2. * p;\n\n    solve_cubic(cubic_coeffs, s.xyz);\n\n    /* ... and take the one real solution ... */\n\n    float z = s[0];\n\n    /* ... to build two quadric equations */\n\n    float u = z * z - r;\n    float v = 2. * z - p;\n\n    if (u > -eps)\n    {\n      u = sqrt(abs(u));\n    }\n    else\n    {\n      return 0;\n    }\n\n    if (v > -eps)\n    {\n      v = sqrt(abs(v));\n    }\n    else\n    {\n      return 0;\n    }\n\n    vec2 quad_coeffs;\n\n    quad_coeffs[0] = z - u;\n    quad_coeffs[1] = q < 0. ? -v : v;\n\n    num = solve_quadric(quad_coeffs, s.xy);\n\n    quad_coeffs[0] = z + u;\n    quad_coeffs[1] = q < 0. ? v : -v;\n\n    vec2 tmp = vec2(1e38);\n    int old_num = num;\n\n    num += solve_quadric(quad_coeffs, tmp);\n    if (old_num != num)\n    {\n      if (old_num == 0)\n      {\n        s[0] = tmp[0];\n        s[1] = tmp[1];\n      }\n      else\n      { // old_num == 2\n        s[2] = tmp[0];\n        s[3] = tmp[1];\n      }\n    }\n  }\n\n  /* resubstitute */\n\n  float sub = 1. / 4. * a;\n\n  /* single halley iteration to fix cancellation */\n  for (int i = 0; i < 4; i += 2)\n  {\n    if (i < num)\n    {\n      s[i] -= sub;\n      s[i] = halley_iteration4(coeffs, s[i]);\n\n      s[i + 1] -= sub;\n      s[i + 1] = halley_iteration4(coeffs, s[i + 1]);\n    }\n  }\n\n  return num;\n}\n\n// Sign computation is pretty straightforward:\n// I'm solving a cubic equation to get the intersection count\n// of a ray from the current point to infinity and parallel to the x axis\n// Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n\n  float cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n  float qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n  float li = (-3. * p0.y + 3. * p1.y);\n  float co = p0.y - uv.y;\n\n  vec3 roots = vec3(1e38);\n  int n_roots = solve_cubic(vec3(co / cu, li / cu, qu / cu), roots);\n\n  int n_ints = 0;\n\n  for (int i = 0; i < 3; i++)\n  {\n    if (i < n_roots)\n    {\n      if (roots[i] >= 0. && roots[i] <= 1.)\n      {\n        float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n        x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n        x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n        x_pos = x_pos * roots[i] + p0.x;\n\n        if (x_pos < uv.x)\n        {\n          n_ints++;\n        }\n      }\n    }\n  }\n\n  vec2 tang1 = p0.xy - p1.xy;\n  vec2 tang2 = p2.xy - p3.xy;\n\n  vec2 nor1 = vec2(tang1.y, -tang1.x);\n  vec2 nor2 = vec2(tang2.y, -tang2.x);\n\n  if (p0.y < p1.y)\n  {\n    if ((uv.y <= p0.y) && (dot(uv - p0.xy, nor1) < 0.))\n    {\n      n_ints++;\n    }\n  }\n  else\n  {\n    if (!(uv.y <= p0.y) && !(dot(uv - p0.xy, nor1) < 0.))\n    {\n      n_ints++;\n    }\n  }\n\n  if (p2.y < p3.y)\n  {\n    if (!(uv.y <= p3.y) && dot(uv - p3.xy, nor2) < 0.)\n    {\n      n_ints++;\n    }\n  }\n  else\n  {\n    if ((uv.y <= p3.y) && !(dot(uv - p3.xy, nor2) < 0.))\n    {\n      n_ints++;\n    }\n  }\n\n  if (n_ints == 0 || n_ints == 2 || n_ints == 4)\n  {\n    return 1.;\n  }\n  else\n  {\n    return -1.;\n  }\n}\n\nvec2 cubic_bezier_nearest(vec2 pt, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  vec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n  vec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n  vec2 a1 = (-3. * p0 + 3. * p1);\n  vec2 a0 = p0 - pt;\n\n  // compute polynomial describing distance to current pixel dependent on a parameter t\n  float bc6 = dot(a3, a3);\n  float bc5 = 2. * dot(a3, a2);\n  float bc4 = dot(a2, a2) + 2. * dot(a1, a3);\n  float bc3 = 2. * (dot(a1, a2) + dot(a0, a3));\n  float bc2 = dot(a1, a1) + 2. * dot(a0, a2);\n  float bc1 = 2. * dot(a0, a1);\n  float bc0 = dot(a0, a0);\n\n  bc5 /= bc6;\n  bc4 /= bc6;\n  bc3 /= bc6;\n  bc2 /= bc6;\n  bc1 /= bc6;\n  bc0 /= bc6;\n\n  // compute derivatives of this polynomial\n\n  float b0 = bc1 / 6.;\n  float b1 = 2. * bc2 / 6.;\n  float b2 = 3. * bc3 / 6.;\n  float b3 = 4. * bc4 / 6.;\n  float b4 = 5. * bc5 / 6.;\n\n  vec4 c1 = vec4(b1, 2. * b2, 3. * b3, 4. * b4) / 5.;\n  vec3 c2 = vec3(c1[1], 2. * c1[2], 3. * c1[3]) / 4.;\n  vec2 c3 = vec2(c2[1], 2. * c2[2]) / 3.;\n  float c4 = c3[1] / 2.;\n\n  vec4 roots_drv = vec4(1e38);\n\n  int num_roots_drv = solve_quartic(c1, roots_drv);\n  sort_roots4(roots_drv);\n\n  float ub = upper_bound_lagrange5(b0, b1, b2, b3, b4);\n  float lb = lower_bound_lagrange5(b0, b1, b2, b3, b4);\n\n  vec3 a = vec3(1e38);\n  vec3 b = vec3(1e38);\n\n  int num_roots = 0;\n\n  // compute root isolating intervals by roots of derivative and outer root bounds\n  // only roots going form - to + considered, because only those result in a minimum\n  if (num_roots_drv == 4)\n  {\n    if (eval_poly5(b0, b1, b2, b3, b4, roots_drv[0]) > 0.)\n    {\n      a[0] = lb;\n      b[0] = roots_drv[0];\n      num_roots = 1;\n    }\n\n    if (sign(eval_poly5(b0, b1, b2, b3, b4, roots_drv[1])) != sign(eval_poly5(b0, b1, b2, b3, b4, roots_drv[2])))\n    {\n      if (num_roots == 0)\n      {\n        a[0] = roots_drv[1];\n        b[0] = roots_drv[2];\n        num_roots = 1;\n      }\n      else\n      {\n        a[1] = roots_drv[1];\n        b[1] = roots_drv[2];\n        num_roots = 2;\n      }\n    }\n\n    if (eval_poly5(b0, b1, b2, b3, b4, roots_drv[3]) < 0.)\n    {\n      if (num_roots == 0)\n      {\n        a[0] = roots_drv[3];\n        b[0] = ub;\n        num_roots = 1;\n      }\n      else if (num_roots == 1)\n      {\n        a[1] = roots_drv[3];\n        b[1] = ub;\n        num_roots = 2;\n      }\n      else\n      {\n        a[2] = roots_drv[3];\n        b[2] = ub;\n        num_roots = 3;\n      }\n    }\n  }\n  else\n  {\n    if (num_roots_drv == 2)\n    {\n      if (eval_poly5(b0, b1, b2, b3, b4, roots_drv[0]) < 0.)\n      {\n        num_roots = 1;\n        a[0] = roots_drv[1];\n        b[0] = ub;\n      }\n      else if (eval_poly5(b0, b1, b2, b3, b4, roots_drv[1]) > 0.)\n      {\n        num_roots = 1;\n        a[0] = lb;\n        b[0] = roots_drv[0];\n      }\n      else\n      {\n        num_roots = 2;\n\n        a[0] = lb;\n        b[0] = roots_drv[0];\n\n        a[1] = roots_drv[1];\n        b[1] = ub;\n      }\n    }\n    else\n    { // num_roots_drv==0\n      vec3 roots_snd_drv = vec3(1e38);\n      int num_roots_snd_drv = solve_cubic(c2, roots_snd_drv);\n\n      vec2 roots_trd_drv = vec2(1e38);\n      int num_roots_trd_drv = solve_quadric(c3, roots_trd_drv);\n      num_roots = 1;\n\n      a[0] = lb;\n      b[0] = ub;\n    }\n\n    // further subdivide intervals to guarantee convergence of halley's method\n    // by using roots of further derivatives\n    vec3 roots_snd_drv = vec3(1e38);\n    int num_roots_snd_drv = solve_cubic(c2, roots_snd_drv);\n    sort_roots3(roots_snd_drv);\n\n    int num_roots_trd_drv = 0;\n    vec2 roots_trd_drv = vec2(1e38);\n\n    if (num_roots_snd_drv != 3)\n    {\n      num_roots_trd_drv = solve_quadric(c3, roots_trd_drv);\n    }\n\n    for (int i = 0; i < 3; i++)\n    {\n      if (i < num_roots)\n      {\n        for (int j = 0; j < 3; j += 2)\n        {\n          if (j < num_roots_snd_drv)\n          {\n            if (a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j])\n            {\n              if (eval_poly5(b0, b1, b2, b3, b4, roots_snd_drv[j]) > 0.)\n              {\n                b[i] = roots_snd_drv[j];\n              }\n              else\n              {\n                a[i] = roots_snd_drv[j];\n              }\n            }\n          }\n        }\n        for (int j = 0; j < 2; j++)\n        {\n          if (j < num_roots_trd_drv)\n          {\n            if (a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j])\n            {\n              if (eval_poly5(b0, b1, b2, b3, b4, roots_trd_drv[j]) > 0.)\n              {\n                b[i] = roots_trd_drv[j];\n              }\n              else\n              {\n                a[i] = roots_trd_drv[j];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  float nearestDistSq = 1e38;\n  vec2 nearestPt = vec2(0.0);\n\n  // compute roots with halley's method\n\n  for (int i = 0; i < 3; i++)\n  {\n    if (i < num_roots)\n    {\n      float rootsi = .5 * (a[i] + b[i]);\n\n      for (int j = 0; j < halley_iterations; j++)\n      {\n        rootsi = halley_iteration5(b0, b1, b2, b3, b4, rootsi);\n      }\n\n      // compute squared distance to nearest point on curve\n      rootsi = clamp(rootsi, 0., 1.);\n      vec2 n = parametric_cub_bezier(rootsi, p0, p1, p2, p3);\n      vec2 to_curve = pt - n;\n      float distSq = dot(to_curve, to_curve);\n      if (distSq < nearestDistSq)\n      {\n        nearestDistSq = distSq;\n        nearestPt = n;\n      }\n    }\n  }\n\n  return nearestPt;\n} // cubic_bezier_nearest\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  vec2 n = uv - cubic_bezier_nearest(uv, p0, p1, p2, p3);\n  return sqrt(dot(n, n));\n}\n\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float border = 2. / iResolution.x;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv -= .5;\n  uv.y *= iResolution.y / iResolution.x;\n\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  mouse -= .5;\n  mouse.y *= iResolution.y / iResolution.x;\n\n  border *= zoom;\n  uv *= zoom;\n  mouse *= zoom;\n\n  float t0 = mod(iTime * 2. + 1.5, 24. * 3.1416);\n\n  vec2 p0 = vec2(-cos(t0 * 1. / 2.) * .2, sin(t0 * 1. / 3.) * .25);\n  vec2 p1 = vec2(-cos(t0 * 2. / 3.) * .2, sin(t0 * 1. / 4.) * .1);\n  vec2 p2 = vec2(cos(t0 * 1. / 4.) * .1, -sin(t0 * 2. / 3.) * .2);\n  vec2 p3 = vec2(cos(t0 * 1. / 3.) * .25, -sin(t0 * 1. / 2.) * .1);\n\n  float d0 = 1e38;\n\n  d0 = min(d0, cubic_bezier_dis(uv, p0, p1, p2, p3));\n\n  float sgn = cubic_bezier_sign(uv, p0, p1, p2, p3);\n\n  // iq's sd color scheme\n  vec3 col = vec3(1.0) - sgn * vec3(0.1, 0.4, 0.7);\n  col *= 1.0 - exp(-8.0 * d0);\n  col *= 0.8 + 0.2 * cos(480.0 * d0);\n  col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d0)));\n\n  d0 = 1e38;\n\n  d0 = min(d0, distance(p0, uv) - dot_size);\n  d0 = min(d0, distance(p1, uv) - dot_size);\n  d0 = min(d0, distance(p2, uv) - dot_size);\n  d0 = min(d0, distance(p3, uv) - dot_size);\n  col = mix(point_col, col, smoothstep(0., border, d0));\n\n  vec2 nearest = cubic_bezier_nearest(mouse, p0, p1, p2, p3);\n  col = mix(\n      vec3(0, 0.6, 1.0),\n      col,\n      smoothstep(0.0, border, udSegment(uv, mouse, nearest) - dot_size * 0.2));\n  col = mix(\n      vec3(0, 0.6, 1.0),\n      col,\n      smoothstep(\n          0.0,\n          border,\n          distance(nearest, uv) - dot_size));\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}