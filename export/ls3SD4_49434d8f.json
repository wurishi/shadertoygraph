{"ver":"0.1","info":{"id":"ls3SD4","date":"1459295152","viewed":156,"name":"Tunnel tryout 001","username":"andro","description":"PAARDEN","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//mercury functions \n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n//mercury definitions\nfloat d;\nfloat r = 0.5;//default 0.3\nfloat n = 4.0;//default 0.4\n\n//for modulo\nfloat size = 4.0;\n\tfloat c = 0.0;\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n\n/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  SÃ©bastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] https://iquilezles.org/articles/distfunctions\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  https://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\n\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n    \n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n\n\n\nvoid pR(inout vec2 p, float a) \n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\t// The sphere is positioned at the origin (0,0,0) and has a radius of `s`.\n\t// the distance between the point `p` and the envelope of the shpere is\n\t// then the distance between the point and the origin, minus the radius\n\t// of the sphere.\n\treturn length(p)-s;\n}\n\n//creates an unsigned Box\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n        \n}\n\n//Displacement\nfloat displacement(vec3 p)\n{\n   return  sin(3.0*sin(p.x+(iTime)))*sin(p.y+(iTime))\n       *sin(p.z+(iTime));\n}\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0.0 ? abs(p.y) : length(vec2(p.y, l));\n}\n\n//mod functions\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.0))* 2.0 - vec2(1.0);\n\treturn c;\n}\n\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\n////////////// /////////////////////// /////////////////// //////////////////////\nfloat map( vec3 p )//where the magic happens\n{\n    //pR(p.zx,cos(iTime)*PHI);//This rotates around the p.xz axis passes through\n    //pR(p.xz,sin(iTime*0.5));//This rotates around the p.xz axis passes through\n  \n   // pR(p.yx,1.5);//This rotates around the p.xz axis passes through\n   // pR(p.yx,sin(iTime*0.33));//This rotates around the p.xz axis passes through\n    \n    \n     pR(p.xy,PI*0.01*(PI*sin(iTime)));//This rotates around the p.xz axis passes through\n    //pR(p.yz,0.1*(PI*cos(iTime)));\n    pMod3(p, vec3 (2.0));\n    float box1 = fBox(p,vec3(1.0,0.1,0.1));\n    float box2 = fBox(p,vec3(0.1,1.0,0.2));//make diagonal crosses\n     pR(p.xz,PI*0.5);//This rotates around the p.xz axis passes through\n    vec3 movebox3 = vec3(0.0,sin(iTime),0.0);\n    float box3 = fBox(p+movebox3,vec3(1.0,0.1,0.1));//make diagonal crosses\n    \n\tfloat sphere = sdSphere(p,1.0)*0.5;\n    //pR(p.yz,1.5);//This rotates around the p.xz axis passes through\n\tfloat torus1 = fTorus(p,0.1,1.0)+displacement(p)*0.01;\n   // pR(p.yz,1.5);//This rotates around the p.xz axis passes through\n    float torus2 = fTorus(p,0.2+(sin(iTime))*0.35,0.75)+displacement(p)*0.5;\n    //float torus = fTorus(p,0.25,0.75);\n     pR(p.zy,PI*0.5*sin(iTime));//This rotates around the p.xz axis passes through\n    float disc1 =fDisc(p,1.0);//pModMirror2( p.xz, vec2(2.0));\n    \n    \n    \n    //return udRoundBox(p,vec3(1.0, 1.0, 1.0),0.05);\n    //return udRoundBox(p,vec3(abs(sin(iTime)),abs(sin(iTime))*2.0,1.0),0.05);\n      \n\t//return fOpPipe(box,torus,r*0.6);//backup\n    //return torus;\n   float unionX = fOpUnionRound(torus2, torus1, 0.5);\n    float engrave = fOpEngrave(sphere, unionX, 0.5);\n    //return engrave;\n    float union1 = fOpUnionRound(box1,box2, 0.05);\n     float union2 = fOpUnionRound(union1,box3, 0.001);\n    float union3 = fOpUnionRound(union2,disc1, 0.1);\n    float union4 = fOpEngrave( engrave , union3, 0.5);\n    float union5 = fOpUnionRound( union3 , union4, 0.5);\n    float result = union5;\n    return result;\n    //return engrave;\n}\n\n\nvec3 fNormal(vec3 intersection, float lastDistance)//generates normals\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize((vec3(map(intersection + epsilon.xyy),\n    map(intersection + epsilon.yxy),\n    map(intersection + epsilon.yyx)) - lastDistance) / epsilon.x);\n}\n\n\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 20.0;\n\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 normal )\n{\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<100; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n\t    h = map( ro+rd*t );\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\t\n    normal = fNormal(ro + rd * t, h);\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel, meaning it\n    // is between [0,0] and [1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    \n    // If you do `p=q`, you will see that the origin is to the bottom left \n    // of the screen. With this simple expression, we adjust the viewpoint\n    // in the space and center the origin in the preview screen.\n    //\n    // vec2 p = q;              // [1] Origin is at the bottom-left of the screen\n    // vec2 p = 2.0 * q;        // [2] We scale by 1/2 by multiplying q\n    vec2 p = 2.0 * q - 1.0;     // [3] We scale by 1/2 and then center the origin on screen\n    // vec2 p = -0.5 + q;       // [4] Alternatively, we can center without scaling\n    \n    // NOTE: I'm not very familiar with the shader API, but from the above we can deduce\n    // that 1.0 means [1.0, 1.0] for a vect2, 2.0 means [2.0, 2.0], etc.\n    \n    // `iResolution.x/isResolution.y` is the aspect ratio, by default it is 512/288~=1.7777.\n    // If you uncomment the following line the image will appear as squashed.\n    p.x *= iResolution.x/iResolution.y;  \n    \n    // The `ro` value specifies the origin of the camera's center in the virtual space.\n    // You can tweak the X and Y values to shift the origin, or the Z value to\n    // adjust the distance to the sphere (here it is 2.0 to the sphere's center).\n\t//vec3 ro = vec3(0.0,0.0, 6.0 );\n    \n    // The `rd` value specifies the  direction of the current pixel (on the projection\n    // plane) in the 3D space The notation vec3(p,-1.0) is equivalent to vec3(p.x,p.y,-1.0) as\n    // `p` is a vec2. -1.0 for z means it is pointing forward, and the normalization ensures\n    // that `rd` can be used as a step for raymarching.\n    //vec3 rd = normalize( vec3(p,-2.0) );\n\tfloat xmove = iTime;//mod(iTime,2.0*PI);\n    //camera lookat\n    vec3 ro = vec3(cos(xmove)*0.05+1.0,sin(xmove+(PI/2.0)), xmove*2.5);//has to be even number for smooth movement\n    \n    vec3 ta = vec3(sin(xmove)*0.05+1.0, sin(xmove),xmove*2.6);\n    \n    //camera tx\n    vec3 cw = normalize (ta - ro);\n    vec3 cp = vec3 (0.0, 1.0, 0.0);\n    vec3 cu = normalize ( cross(cw,cp) );\n    vec3 cv = normalize ( cross (cu,cw) );\n    vec3 rd = normalize ( p.x*cu + p.y*cv + 2.5 *cw);\n    \n    \n    // The `col` vector holds the color that will be rendered on the screen, ie. the main\n    // output of the shader. As the alpha channel will be set to 1.0, we only need the\n    // three components RGB, hence the use of a vec3.\n\tvec3 col = vec3(0.);\n\n    // We call the `interect` function with `ro` as the ray origin and `rd` as the \n    // point from which the raymarching step/delta will be calculated. Intersect is the\n    // main raymatching function.\n    vec3 normal;\n    float t = intersect(ro,rd,normal);\n    \n        // Here we do the simplest possible shading, which is based on the distance between\n        // the ray and the sphere. if `t == 0`, it means the sphere's envelope is intersecting\n        // with the current pixel, otherwise t will be the distance between the current pixel\n        // and the sphere's envelope. \n        //\n  \t\t// NOTE: I'm not sure exactly why we need to substract t from 2.0 and not 1.0. I would\n        // assume that because the projection plane is at -1.0 (as set by `rd.z`) and that the\n        // sphere is at the origin with a 1.0 radius that there t would be osciallating between\n        // 0 (closest) and 1.0 (farthest). If you try changing rd to the following expression:\n        //\n        // vec3 rd = normalize( vec3(p,-2.0) );\n        //\n        // You will only make the sphere closer, but the values for `t` will remain the same\n        // (the shading will remain). However, if you change the value of `ro` to the following:\n        //\n        // vec3 ro = vec3(0.0, 0.0, 2.5 );\n        //\n        // not only will the sphere shrink on the projection, but `t` will also increase. It is\n        // not clear to me yet why that is.\n        float d = clamp(t / maxd, 0.0, 1.0);\n    \tvec3 fog_color = vec3(0.0, 0.0, 0.0);\n    \tvec3 obj_color = vec3(1.0, 1.0, 1.0);\n    vec3 light_direction = normalize(vec3(sin(iTime), 1.0, 0.0));\n    float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);\n        \n    \tcol = mix(obj_color * diffuse, fog_color, d);\n    \t\n\t// We assign the color we've just computed.\n    fragColor = vec4(col, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}