{"ver":"0.1","info":{"id":"ds2GRh","date":"1667235974","viewed":151,"name":"Sphere inversion cubes","username":"OstrichDog","description":"Infinite cubes projected inside a sphere. Render quality is very bad, but this is the best I could make while maintaining a decent frame rate.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camPos = vec3(0., 0., -4.);\nfloat screenDist = 1.;\nfloat minDist = 0.01;\nfloat maxDist = 4.;\n\nvec3 lightPos = vec3(-1., 1.5, -3.);\n\nint maxSteps = 3000;\nfloat distanceHit = 0.0001;\n\nvec4 obj = vec4(0., -1., -1., 1.);\nvec4 sphere = vec4(0., 0., 0., 2.);\nvec4 cube = vec4(.5, .5, .5, 2.5);\nfloat planeX = 4.;\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    float dist = length(p) - r;\n\n    return (dist);\n}\n\nfloat sdSphere(vec3 p) {\n    float dist = length(p) - sphere.w;\n\n    return (dist);\n}\n\nfloat sdCube(vec3 p) {\n    vec3 d = abs(p)-cube.xyz;\n    vec3 dist3 = max(d, 0.);\n    float dist = length(dist3); \n\n    return (dist);\n}\n\nfloat sdCyl(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdObject(vec3 p) {\n    p -= vec3(1.25+sin(iTime*3.)*0.15,-iTime/5.,0.);\n    float c= cube.w;\n    float distA = sdCube(mod(p+0.5*c,c)-0.5*c);\n    //float distP=length(p-sphere.xyz);\n    return distA/15.;\n   // return distA*sphere.w*sphere.w/(distP*distP-distA*distA)/5.;\n\n}\n\nfloat sdPlane(vec3 p, vec3 n, vec3 shift) {\n    n = normalize(n);\n    return dot(p - shift, n);\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n\treturn min(a, b) - h*h*k*(1.0 / 4.0);\n}\n\nvec3 invertP(vec3 p, out float scale) {\n    scale=1.0;\n    float distSphere = length(p-sphere.xyz);\n    vec3 dir = p-sphere.xyz*cos(iTime);\n    scale/=length(dir);\n    dir/=length(dir);\n    float k = sphere.w*sphere.w/distSphere;\n    scale*=k;\n    return dir*k;\n}\n\nfloat getDist(vec3 p) {\n    float scale;\n    float distObj = sdObject(invertP(p, scale));\n    \n    float d = distObj;\n    return d/scale;\n}\n\nfloat march(vec3 ro, vec3 rd, float startDist) {\n    float dist = startDist;\n    for (int i=0; i<maxSteps; i++){\n        float newDist = getDist(ro + rd*dist);\n        dist += 0.7*newDist;\n        if (abs(newDist) <= distanceHit || dist >= maxDist) break;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.001, 0.);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    //return n/e.x;\n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n    float scale;\n    //lightPos=invertP(lightPos, scale);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    float dif = max(dot(n, l),0.3);\n    \n    float dist = march(p+n*distanceHit*1.5, l, 0.);///scale;\n    float shadow = clamp(dist / length(lightPos - p), 0., 1.);\n    \n    return dif * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere.w = 4.2+sin(iTime/5.)*3.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv.x, uv.y, screenDist));\n\n    float dist = march(ro, rd, minDist);\n    \n    vec3 p = ro + rd * dist;\n\n    float dif = light(p);\n    col = vec3(0.6) * dif;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}