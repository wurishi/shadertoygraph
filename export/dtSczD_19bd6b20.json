{"ver":"0.1","info":{"id":"dtSczD","date":"1695379385","viewed":67,"name":"Comparing Implicit Algorithms","username":"Seebone","description":"Comparing 4 different algorithms for implicit rasterization. View distance fields produced by some here:https://www.shadertoy.com/view/Dlffzs","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["implicit","graphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Keep in mind that I know next to nothing about shader programming (or math for that\n// matter).\n\n// Algorithm Layout (quadrant)\n#define FIRSTQ exact\n#define SECONDQ divideByGrad\n#define THIRDQ extendedNewton\n#define FOURTHQ supersampleSign\n\n#define MIRROR\n\n/* Implemented algorithms (the names were made up by me):\n *\n * ***sampleSign***\n * author: me\n * (not a very good algorithm and definetly discovered by someone else first)\n *\n * Samples the sign of f at points on the line (with same length as curve width)\n * defined by the gradient of f at the current point. The though is that the when \n * close to the curve, the gradient will be normal to the curve. Proximity to the\n * curve is determined by how many sampled points have the same sign as the original\n * point.\n *\n * Cannot handle roots where the function doesn't change sign, for example x*x or\n * abs(x*y). Additionally require a well behaved gradient to use as normal.\n *\n *\n * ***divideByGrad***\n * Author: Inigo Quilez has an article on it from 2011: https://iquilezles.org/articles/distance/\n *         I first saw Flyguy's version here: https://www.shadertoy.com/view/4tB3WV\n * This method works really well in most cases and is very cheap so there is almost\n * never any reason to use another algorithm. Cannot handle functions that are zero for large areas.\n *\n * ***extendedNewton***\n * Author: I came up with it independently, but it is described on wikipedia:\n * https://en.wikipedia.org/wiki/Implicit_curve#Raster_algorithm\n * Works quite well. Can be modified to handle functions that are zero for large areas,\n * but that would make the precision worse.\n *\n * ***supersampleSign***\n * Author: First saw Envy24's version here: https://www.shadertoy.com/view/DtlcDs\n *\n * ***exact***\n * Author: me.\n * A naive way to do it. Gives very precise distance but complexity scales a lot with distance.\n * Cannot handle functions that are zero for large areas. Doesn't work on some devices for some reason.\n */\n\n/* Viewport parameters */\n// The distance from the left to the right of the viewport\n//#define WIDTH 4.\n// Animated width:\n#define WIDTH (smp(iTime, .1, 5., 8., .1))\n// Don't change, dependent on height\n#define HEIGHT (WIDTH * iResolution.y/iResolution.x)\n// Coordinates at center of viewport\n#define CENTER (vec2(0.))\n\n/* curve parameters */\n// Target curve width in pixels\n#define CURVE_COL (vec3(1.000,0.502,0.000))\n// Target curve width in pixels\n#define CWP 3.\n\n/* zero plane */\n// Manual\n#define Z_LEVEL 0.\n// Animated 0-level\n//#define Z_LEVEL (adjustedSine(iTime, 0., 1., 8.))\n\n/* constants */\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 6.2831853071795864769252867665590\n#define M_SQRT2 1.4142135623730950488016887242096\n#define FLT_MAX 3.402823466e+38\n\n// Not adjusted to begin at 0\nfloat adjustedSine(float x, float yMin, float yMax, float period) {\n    return .5*((yMax - yMin) * sin(M_TAU*x/period) + yMax + yMin);\n}\n\n// https://www.desmos.com/calculator/udnerpr09b\nfloat smp(float x, float yMin, float yMax, float period, float L) {\n    period = abs(period)*.5;\n    L = clamp(L, 0., 1.)*period;\n    // Function\n    x += .5*L;\n    bool a = mod(x,2.*period) >= period;\n    x = (a ? 1. : -1.)*smoothstep(L, period, mod(x, period)) + (a ? 0. : 1.);\n    \n    //shifting\n    return yMin + (yMax - yMin)*x;\n}\n\n// https://iquilezles.org/articles/functions/\nfloat smoothPlatform(float x, float a, float b, float l) {\n    float c = a;\n    a = min(a,b);\n    b = max(c,b);\n    l = clamp(l, 0., .5*(b-a));\n    \n    return smoothstep(a, a+l, x) + smoothstep(b, b-l,x) - 1.;\n    \n}\n\n// Change to any function\nfloat implicit(float x, float y) {\n      //return x * y * (abs(x) + abs(y) - 1.);\n      //return abs(x+y) + abs(x-y)-1.;\n      return pow(abs(3.*x*x - y*y), 2.)*y*y - pow(x*x + y*y, 4.);\n      //return smp(x, -1., 1., 2., .5) - y;\n      //return smoothPlatform(x, -1., 1., .5) - y;\n      //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n      //return tan(x*y*sin(y*x)*cos(x*x)) ;\n      //return cos(x*x) + sin(y*x);\n      //return cos(x * y) + y * sin(x) -1.;\n      //return x*x*y + y*y*x;\n      //return sin(y)+cos(x);\n      //return sin(x+y)-cos(x*y) - 1.;\n      //return x*x + y*y; // set equal to 0 to test if single points are detected\n      //return x*x; // set equal to 0, this does not work with supersampleSign() since the sign does not change at the root\n      //return sin(x*x) - y;\n      //return abs(x*y)-x; // This function should be 0 for large areas. \n      //return x-abs(x); \n      //return pow(abs(sin(2.*x)),4.)+4.*sin(y)*sin(y)*sin(y)-3.*sin(2.*x)*sin(y);\n      \n      // Challenging function:\n      //const float R = 1.;\n      //2R\\sqrt{x^{2}+y^{2}}-\\left(x^{2}+y^{2}+R^{2}\\right)\n      //return 2.*R*sqrt(x*x+y*y)-(x*x+y*y+R*R);\n}\n\n// z-shifted since all algorithms are made to detects roots\nfloat f(vec2 p) {\n    return implicit(p.x, p.y) - Z_LEVEL;\n}\n\n/* Can be used to demonstrate the problem */\nfloat naive(vec2 uv, float cw) {\n    return smoothstep(0., cw, abs(f(uv)));\n}\n\n/* Mostly good for distance fields */\nfloat exact(vec2 uv, float cw) {\n    const vec2 h = vec2(1e-4, 0.);\n    // Increase iterations to avoid artifacts. f is sampled 3 times every iteration.\n    const int NEWTON_ITERATIONS = 8; // The convergence is often very fast\n    // The precision will be bettter than this, this value is only used to determine if a root was found.\n    const float rootErr = 1e-4;\n    const float nAngle = 2.; // number of starting points when finding angle root\n    const float rSPP = 3.; // number of radius steps per pixel traversed\n    \n    float radiusStep = WIDTH/(iResolution.x*rSPP); // 'resolution' in distance field (scaled with viewport)\n    float radius0 = 0.;\n    float angle0 = 0.;\n    float radiusMax = .5*cw;\n    \n    for(radius0 = 0.; radius0 <= radiusMax; radius0 += radiusStep) {\n        for(angle0 = 0.; angle0 <= M_TAU; angle0 += M_TAU/nAngle) {\n            // Do extended newton's method:\n            // Vector containing current radius and angle\n            float radius = radius0;\n            float angle = angle0;\n\n            float fVal;\n            vec2 fGrad;\n\n            for(int i = 0; i < NEWTON_ITERATIONS; i++) {\n                vec2 dir = vec2(cos(angle), sin(angle));\n                vec2 p = uv+radius*dir;\n                fVal = f(p);\n                                \n                // Gradient with respect to x and y at p\n                fGrad = vec2(f(p+h)-fVal, f(p+h.yx)-fVal) / h.x;\n                // partial derivative with respect to angle using multivariable chain rule\n                float dfdAngle = dot(fGrad, radius*vec2(-dir.y, dir.x));\n                // Other way of doing it\n                // float dfdAngle = (f(uv + radius*vec2(cos(angle+h.x), sin(angle+h.x))) - fVal)/h.x;\n                \n                // Updating using newton's method\n                angle -= fVal/dfdAngle;\n            }\n            // Check is placed after loop since we always want to find the best approximataion before\n            // returning. \n            // This check is here to determine if a root was found. To avoid precision errors,\n            // especially in the case where the function approaches the root very slowly leading to\n            // incorrect detection of roots, we divide by the gradient length to enhance flat areas and\n            // squash infinities. Only problem is if gradient is 0.\n            if(abs(fVal)*inversesqrt(dot(fGrad, fGrad)) <= rootErr) {\n            // Theretically correct:\n            //if(abs(fVal) <= rootErr) {\n                return smoothstep(0., radiusMax, radius);\n            }\n        }\n    }\n    // If no root was found withing specified radius\n    return 1.;\n}\n\n\nfloat sampleSign(vec2 uv, float cw) {\n    \n    const vec2 h = vec2(.0001, 0.);\n    const float n = 23.; // number of samples values (number of possible roots)\n    // f is evaluated n + 2 times (with cheap gradient)\n    \n    \n    float fVal = f(uv);\n    //vec2 grad = vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/(2.*h.x);\n    vec2 grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    // This check can cause issues sometimes\n    grad = abs(grad.x) <= 1e-10 && abs(grad.y) <= 1e-10 ? .5*vec2(M_SQRT2) : normalize(grad);\n    \n    // Without detecting double roots (cheaper version of supersampleSign):\n    float count = 0.;\n    int fSign0 = fVal >= 0. ? 1 : -1; \n    for(float t = -cw*.5; t < cw*.5; t += cw/n) {\n        int fSign = f(uv + t*grad) >= 0. ? 1 : -1;\n        count += fSign0 == fSign ? 1. : 0.;\n    }\n    return smoothstep(.5*n, n, count);\n}\n\n/* Works by 'normalizing' the gradient of f to create a function that increases linearly (like a true distance function) in close proximity to a root of f. */ \nfloat divideByGrad(vec2 uv, float cw) {\n    const vec2 h = vec2(.0001, 0.);\n    // f is evaluated 3 times for cheap version and 5 times for expensive version\n    \n    // Expensive version (central differences):\n    vec2 grad = vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/(2.*h.x);\n    return smoothstep(0., .5*cw, abs(f(uv))*inversesqrt(dot(grad,grad)));\n    \n    \n    /*\n    // Cheap version (forward differences):\n    float fVal = f(uv);\n    vec2 grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    return abs(fVal)*inversesqrt(dot(grad,grad));\n    */\n}\n\n/* Works by sampling the sign of f at nearby points */\nfloat supersampleSign(vec2 uv, float cw) {\n    // The side length of the sampled square,\n    // essentially double the width of the resulting curve (in pixels)\n    float s = cw;\n    \n    // Number of columns or rows in half a side length (-1), higher for finer grid\n    // total number of cells (points checked) = (2*ccHalf + 1)^2\n    float ccHalf = 2.; // fractional part is irrelevant\n    // This method is expensive, for a value of 2, f is evaluated 25 times\n    \n    // Normalizing square by dividing by number of rows or columns\n    s /= 2.*ccHalf + 1.;\n    \n    // the number of cells with a different sign\n    float count = 0.;\n    \n    int uvSign0 = f(uv) >= 0. ? 1 : -1;\n    \n    for(float x = -ccHalf; x <= ccHalf; x++) {\n        for(float y = -ccHalf; y <= ccHalf; y++) {\n            if(uvSign0 == ( f(uv + s*vec2(x,y)) >= 0. ? 1 : -1 )) {\n                count++;\n            }\n        }\n    }\n    \n    // expected count is .5*(2.*ccHalf + 1.)^2 for a point exactly on the curve\n    // return count/((2.*ccHalf + 1.)*(2.*ccHalf + 1.));\n    // count is higher farther away\n    // in the optimal case, the lowest possible is 1/2 total count and highest is the total count:\n    float cellTotal = (2.*ccHalf + 1.)*(2.*ccHalf + 1.);\n    return smoothstep(.5*cellTotal, cellTotal, count);\n    \n}\n\n/* Works by extending newton's method to 2 variables and treating the found root as the closest point on the curve */ \nfloat extendedNewton(vec2 uv, float cw) {\n    const vec2 h = vec2(1e-3, 0.);\n    // Increase iterations to avoid artifacts. f is sampled 3 times every iteration.\n    const int NEWTON_ITERATIONS = 10; // The convergence is often very fast\n    /* In almost all cases, the precision will be much bettter than this,\n     * this value is only used to determine if a root was found.\n     */ \n    const float rootErr = 1e-2; \n    \n    vec2 uv0 = uv;\n    float fVal;\n    vec2 grad;\n    \n    for(int i = 0; i < NEWTON_ITERATIONS; i++) {\n        fVal = f(uv);\n        // placing the check here would create more problems than it solved\n\n        // Expensive:\n        // vec2 grad = .5*vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/h.x;\n        // Cheap:\n        grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n\n        uv -= fVal/dot(grad, grad) * grad;\n    }\n    // Update to use latest uv\n    fVal = f(uv);\n    grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    \n    // Check is placed after loop since we always want to find the best approximataion before returning\n    // Divide by gradient length to smooth out asymptotes and enhance \n    if(abs(fVal)*inversesqrt(dot(grad, grad)) <= rootErr) {\n        return smoothstep(0., .5*cw, distance(uv0, uv));\n    } else {\n        return 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n    \n    // Drawing background \n    vec3 col = vec3(1.);\n    // Drawing borders\n\n    col = mix(col, vec3(0.),smoothstep(2./iResolution.x, 0., min(abs(uv.x), abs(uv.y))));\n\n    bool right = uv.x >= 0.;\n    bool up = uv.y >= 0.;\n   \n    // transforming to correct size and position\n    uv *= WIDTH;\n    uv += CENTER;\n    \n    float value;\n    // Curve width as fraction of viewport width\n    float CW = WIDTH*CWP/iResolution.x;\n    \n    #ifndef MIRROR\n    // Edit curve width and dropoff for every algorithm here\n    if (right && up) {\n        // 1st quadrant\n        //value = sampleSign(uv, CW);\n        value = FIRSTQ(uv, CW);\n        /*\n        // Max value where curve is still visible\n        float maxValue = 2.*WIDTH/iResolution.x;\n        value = smoothstep(.5*maxValue, maxValue, naive(uv));\n        */\n    } else if (!right && up) {\n        // 2nd quadrant\n        value = SECONDQ(uv, CW);\n    } else if (!right && !up) {\n        // 3rd quadrant\n        value = THIRDQ(uv, CW);\n        \n    } else {\n        // 4th quadrant\n        value = FOURTHQ(uv, CW);\n    }\n    #endif\n    #ifdef MIRROR\n    uv = 2.*uv - CENTER;\n    CW *= 2.;\n    // Edit curve width and dropoff for every algorithm here\n    if (right && up) {\n        // 1st quadrant\n        uv -= .5*vec2(WIDTH, HEIGHT);\n        \n        //value = sampleSign(uv, CW);\n        value = FIRSTQ(uv,CW);\n        /*\n        float maxValue = 2.*WIDTH/iResolution.x;\n        value = smoothstep(0.*maxValue, maxValue, naive(uv));\n        */\n    } else if (!right && up) {\n        // 2nd quadrant\n        uv -= .5*vec2(-WIDTH, HEIGHT);\n        value = SECONDQ(uv, CW);\n    } else if (!right && !up) {\n        // 3rd quadrant\n        uv -= .5*vec2(-WIDTH, -HEIGHT);\n        value = THIRDQ(uv, CW);\n        \n    } else {\n        // 4th quadrant\n        uv -= .5*vec2(WIDTH, -HEIGHT);\n        value = FOURTHQ(uv, CW);\n    }\n    #endif\n    \n    col = mix(CURVE_COL, col, value);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}