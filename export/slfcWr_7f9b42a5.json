{"ver":"0.1","info":{"id":"slfcWr","date":"1647806296","viewed":129,"name":"Simple Ray Marching Sphere","username":"yvettemuki","description":"ray marching the sphere sdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** learn from https://michaelwalczyk.com/blog-ray-marching.html */\nconst int MAX_STEP = 32;\nconst float MAX_DISTANCE = 1000.f;\nfloat current_ray_length = 0.f;\nvec3 c = vec3(0, 0, 0);\nconst float r = 1.0;\nconst float MIN_DISTANCE = 0.01;\n\n\nfloat distance_from_sphere(vec3 p, vec3 c, float r)\n{\n    return distance(p, c) - r;\n}\n\nfloat map_to_world(vec3 p)\n{\n    float sphere_0 = distance_from_sphere(p, c, r);\n    \n    // set displacement\n    float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25 * sin(2.f * iTime);\n    \n    return sphere_0 + displacement;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_to_world(p + small_step.xyy) - map_to_world(p - small_step.xyy);\n    float gradient_y = map_to_world(p + small_step.yxy) - map_to_world(p - small_step.yxy);\n    float gradient_z = map_to_world(p + small_step.yyx) - map_to_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_marching(vec3 ro, vec3 rd)\n{\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        vec3 curr_pos = ro + current_ray_length * rd;\n        \n        float dist = map_to_world(curr_pos);\n        \n        if (dist < MIN_DISTANCE)\n        {\n            //calcualte shading\n            vec3 normal = calculate_normal(curr_pos);\n            vec3 light_pos = vec3(2.0, -5.0, 3.0);\n            vec3 light_dir = normalize(curr_pos - light_pos);\n            // diffuse\n            vec3 diffuse = max(0.f, dot(normal, light_dir)) * vec3(0.55, 0.55, 0.55);\n            \n            return vec3(0.627, 0.266, 1) + diffuse;\n        }\n        \n        if (dist > MAX_DISTANCE)\n        {\n            return vec3(0.f, 0.f, 0.f);\n        }\n        \n        current_ray_length += dist;\n    }\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Transform the uv to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    \n    // adjust the aspect ratio\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 camera_pos = vec3(0.f, 0.f, -5.f);\n    vec3 ro = camera_pos; \n    vec3 rd = vec3(uv, 1.f);\n    \n    // ray marching\n    vec3 col = ray_marching(ro, rd);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}