{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tDerivative based edge detection. \n\tdFdx() and dFdy() are applied to the surface normal. \n\tIt will detect discontinuities in the normal.\n\n  modified by vish\n\n*/\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat t;\n\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\nmat3 rot;\n//mat3 rot = rotate_z(t);// * rotate_x(0.50);\n//vec3 trans = vec3(sin(t),cos(t),sin(t))*.1;\nvec3 trans = vec3(0.0, 0.0, 0.0);\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n#define sphere(center) s0 = min(s0, length(p+center) - 0.2);\n\nfloat line(float s0, vec3 p, vec3 a, vec3 b)\n{\n    for (float t = 0.0; t <= 1.0; t += 0.1)\n    {\n    \tsphere(a*t + b * (1.0 - t));\n    }\n        \n    return s0;\n}\n\nfloat df_obj(vec3 p)\n{\n\tp += trans;\n\tp *= rot;\n\t\n\tfloat s0 = 1.0; //dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n    //sphere(vec3(1.2, 0.0, 0.0));\n    \n    s0 = line(s0, p, vec3(2.0, 0.5, 0.0), vec3(2.5, -0.5, 0.0));\n    s0 = line(s0, p, vec3(2.0, 0.5, 0.0), vec3(1.5, -0.5, 0.0));\n\n    s0 = line(s0, p, vec3(1.0, 0.5, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    sphere(vec3(1.0, -0.5, 0.0));\n    \n    s0 = line(s0, p, vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.0));\n    s0 = line(s0, p, vec3(0.5, 0.0, 0.0), vec3(0.0, 0.5, 0.0));\n    s0 = line(s0, p, vec3(0.0, 0.5, 0.0), vec3(0.5, 0.5, 0.0));\n    \n    s0 = line(s0, p, vec3(-0.5, 0.5, 0.0), vec3(-0.5, -0.5, 0.0));\n    s0 = line(s0, p, vec3(-0.5, 0.0, 0.0), vec3(-1.0, 0.0, 0.0));\n    s0 = line(s0, p, vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.5, 0.0));\n\n    s0 = line(s0, p, vec3(-1.5, 0.0, 0.0), vec3(-1.5, -0.5, 0.0));\n    sphere(vec3(-1.5, 0.5, 0.0));\n    \n    //s0 = line(s0, p, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0));\n    //s0 = line(s0, p, vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0));\n    \n    /*\n\tp*=rot;\n\t\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n\tp*=rot;\n\t\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t*/\n\n\treturn s0;\n}\n\n\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nt = iTime - 4.0;\nrot = rotate_x(t*.5)*rotate_y(t*.5)*rotate_z(t*.5);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n\tvec3 pos = vec3(.0,.0,-3.0) ;\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25));\n\t\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\n\tvec3 n = nf(pos);\n\t\n\tvec3 color1 = n*.4+.4;\n\t\n    //color1 = vec3(pos.z, 0.0, 0.0);\n    \n\tfragColor = vec4(pow(color1,vec3(.5)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lj3RW","date":"1427350267","viewed":123,"name":"vish shader","username":"vsingh","description":"learning","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}