{"ver":"0.1","info":{"id":"mdByRG","date":"1687821121","viewed":81,"name":"projection from vanishing points","username":"jt","description":"A simple demo how to calculate projection transform given vanishing points.\nThe vanishing points are the column-vectors of the (inverse) transform matrix, projected (i.e. v.xy / v.z).\nReverse [url=https://www.shadertoy.com/view/csjyDw]here[/url].","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["projection","geometry","matrix","perspective","points","point","projective","vanishing"],"hasliked":0,"parentid":"csjyDw","parentname":"vanishing points from projection"},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/mdByRG\n// projection from vanishing points - 2023 by Jakob Thomsen\n// A simple demo how to calculate projection transform given vanishing points.\n\n// tags: projection, geometry, matrix, perspective, points, point, projective, vanishing\n\nfloat DrawLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nfloat DrawX(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(DrawLine(A, C, p), DrawLine(B, D, p));\n}\n\nfloat SpotX(float Size, vec2 A, vec2 p)\n{\n    vec2 a = vec2( Size, Size);\n    vec2 b = vec2(-Size, Size);\n    return DrawX(A-a, A-b, A+a, A+b, p);\n}\n\n#define pi 3.1415926\n\nvec2 project(vec3 v)\n{\n    return vec2(v) / v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.xy - 1.0;\n    \n    float t = pi * iTime * 0.1;\n\n    // Vanishing points...\n    vec3 x = vec3(vec2( cos(t),sin(t)),1);\n    vec3 y = vec3(vec2(-sin(2.*t),cos(2.*t)),1);\n    // ...and center...\n    vec3 z = vec3(.2*vec2( cos(.5*t),sin(.5*t)),1);\n    // ...combined to (inverse) transform\n    mat3 m = mat3(x, y, z);\n\n    float o = 1.0;\n    o = min(o, SpotX(0.02, project(m[0]), p)); // vanishing point\n    o = min(o, SpotX(0.02, project(m[1]), p)); // vanishing point\n    o = min(o, SpotX(0.02, project(m[2]), p)); // center\n\n    if(false)\n    {\n        // linear combinations of vanishing points lie on vanishing line\n        for(float h = 0.0; h <= 1.0; h += 0.2)\n            o = min(o, SpotX(0.02, project(mix(m[0],m[1],h)), p));\n    }\n\n    p = project(inverse(m) * vec3(p,1));\n\n    //fragColor = vec4(vec3(fract(p), 0.0), 1.0);\n    fragColor = texture(iChannel0, p); // NOTE: set texture to mipmap, repeat\n    \n    vec3 col = vec3(0.0);\n    col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 0.01, o)));\n    fragColor = mix(fragColor, vec4(0,0,1,1), vec4(col, 1));\n    \n    \n    if(false)\n    {\n        if(abs(p.x) < 0.05) fragColor.z = 1.0; // x axis\n        if(abs(p.y) < 0.05) fragColor.z = 1.0; // y axis\n        if(abs(p.x+p.y) > 20.) fragColor.z = 1.0; // vanishing line\n    }\n}\n","name":"Image","description":"","type":"image"}]}