{"ver":"0.1","info":{"id":"tlX3Ws","date":"1558114656","viewed":304,"name":"Subspace","username":"shau","description":"Yet more Beeple/Mike Winklemann :) Takes about 30 seconds for particle system to stabalise","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["3d","beeple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*   \n    Some nice examples (code used and abused):\n\n    Reflecting balls by dr2\n    https://www.shadertoy.com/view/Xsy3WR\n\n    Ben-Hur balls. One of my favourites again from dr2\n    https://www.shadertoy.com/view/MsVfRW\n\n    A fun mashup by iapafoto\n    https://www.shadertoy.com/view/XdGGWz\n*/\n\n#define R iResolution.xy\n#define T iTime\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) {\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec3 pc = vec3(0);\n\tvec2 uv = U/R;\n    \n    float cy = 1. - abs(uv.y - .5) * 2.;\n    pc = palette(T*.01) * pow(cy,3.) + vec3(1.) * pow(cy,18.);\n    float n = noise(uv, 64., 16., float(iFrame), float(iFrame), .96);\n    pc *= n;\n    pc *= sin((uv.y + T * 0.05) * 1200.0) * 0.1 + 0.9;\n\n    float uvx = abs(uv.x-.5) * 2.;\n    uvx*=uvx;\n    float scale = max(0., uvx-.6)*2.;\n    float uvy = .5 + (uv.y-.5) * (1. + scale*scale*4.);\n    vec4 scene = texture(iChannel0, vec2(uv.x, uvy));\n    vec4 glow = texture(iChannel1, vec2(uv.x, U/R));\n\n    if (scene.w!=FAR){\n        pc = scene.xyz;    \n    }\n    \n    pc += texture(iChannel1, uv).xyz;\n    \n    C = vec4(pc, 0.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS .005\n#define FAR 100.\n#define PI 3.14159\n\n#define NBALLS 100\n#define NLIGHTS 10\n#define BW 4.0\n\n#define BUF(C, P, R) texture(C, P/R)\n#define POS 10.5\n#define VEL 20.5\n#define LIG 30.5\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//compact rotation - Fabrice\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1.) * t + vec3(0., .33, .67)));}\n\nvec4 load(sampler2D channel, vec2 R, float type, int idx) {\n    return BUF(channel, vec2(float(idx)+.5, type), R);\n}\n\nvec3 camera(vec2 U, vec2 R, vec3 ro, vec3 la, float fl) {\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution.xy\n#define T iTime\n\n//Physics from dr2 and iapafoto\n//https://www.shadertoy.com/view/Xsy3WR\nvoid animate(int idx, //current ball index  \n             inout vec4 bp,  //current ball position\n             inout vec4 bv) { //current ball velocity\n\n    vec3 rn, vn, dr, f;\n    float fOvlap, fDamp, rSep, dt, rtot;\n    fOvlap = 1000.;\n    fDamp = .1;\n    f = vec3(0.);\n\n    float grav = .1;\n    \n    for (int n=0; n<NBALLS; n++) {\n        vec4 oBP = load(iChannel0,R,POS,n);\n        dr = bp.xyz - oBP.xyz;\n        rSep = length(dr);\n        rtot = bp.w + oBP.w;\n        if (n!=idx && rSep < rtot) f += fOvlap * (rtot / rSep - 1.) * dr;\n    }\n\n    dr = vec3(0., BW - bp.w - abs(bp.yz));\n    \n    f -= step(dr, vec3(1.)) * fOvlap * sign(bp.xyz) * (1. / abs(dr) - 1.) * dr +\n    //           grav + fDamp * bv.xyz;\n                      + fDamp * bv.xyz;\n    \n    dt = .001;\n    bv.xyz += dt * f;\n    bv.x+=grav; //accelerate\n    bp.xyz += dt * bv.xyz;    \n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    int idx = int(U.x-.5); //ball index\n    float fidx = float(idx), //float version of ball index\n          type = U.y; //data type\n    vec3 hash = (hash33(vec3(U,float(iFrame)))-.5)*2.; //hash -1 to 1\n    \n    vec4 bp = load(iChannel0,R,POS,idx), //this ball position\n         bv = load(iChannel0,R,VEL,idx), //this ball velocity\n         li = load(iChannel0,R,LIG,idx); //light\n    \n    if (iFrame<2 || bp.x>20.) {\n        \n        //initialise/re-generate\n        //position\n        vec2 yz = hash.yz * .125; \n        if (iFrame<2) bp.xyz =  vec3(-20. + (hash.x+1.) * 20., yz);\n        else bp.xyz =  vec3(-20. - (hash.x+1.) * 20., yz);\n        //box size\n        bp.w = clamp(hash.x+hash.z ,1., 2.);\n        //velocity\n        bv.xyz = hash * .08;\n        \n    } else {\n        \n        //do something\n        if (type==POS || type==VEL) {\n            animate(idx, bp, bv);\n        }\n    }\n\n    //lights\n    if (li==vec4(0) || li.x>20.) {\n        vec2 yz = (4.*sign(hash.yz)) + hash.yz * 2.; \n        li = vec4(-40. - (hash.x+1.) * 20., yz, max(.4, (1.2 + hash.x) * .4));    \n    }\n    \n    vec3 r = vec3(0., li.y, li.z);\n    r.yz *= rot(.05*li.w);\n    li.yz = r.yz;\n    li.x += li.w * .3;\n    \n    //save\n    if (type==POS) {\n        C = bp; //ball position    \n    } else if (type==VEL) {\n        C = bv; //ball velocity\n    } else if (type==LIG) {\n        C = li; //light\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution.xy\n#define T iTime\n#define LP1 vec3(5., 3., -6.)\n\nstruct Cube {\n    float tN; //near face distance\n    float tF; //far face distance\n    vec3 nN; //near face normal\n    vec3 nF; //far face normal\n    float tx; //texture\n};\n\n//wireframe edges\nfloat tex(vec3 p) {\n    float tx = clamp(step(.9, abs(p.x)) + step(.9, abs(p.y)), 0., 1.);\n    //tx *= step(.3, abs(p.x)) * step(.3, abs(p.y));\n    return tx;\n}        \n\n// Cube mapping routine from Fizzer\nfloat cmap(vec3 p) {\n    vec3 f = abs(p);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x>.5 ? p.yz/p.x : f.y>.5 ? p.xz/p.y : p.xy/p.z; \n    return tex(f);\n}\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nCube boxIntersect(vec3 ro, vec3 rd, vec3 bs, float r1, float r2) {\n    \n    ro.xz *= rot(r1);\n    rd.xz *= rot(r1);\n    ro.xy *= rot(r2);\n    rd.xy *= rot(r2);\n    \n    vec3 m = 1./rd,\n         n = m*ro,\n         k = abs(m)*bs,\n         t1 = -n - k,\n         t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z),\n          tF = min(min(t2.x, t2.y), t2.z);\n    if (tN>tF || tF<0.) return Cube(-.1, 0., vec3(0), vec3(0), 0.);\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz),\n         nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n    \n    float tx = cmap(ro + rd*tN);\n    \n    nN.xy *= rot(-r2);\n    nF.xy *= rot(-r2);\n    nN.xz *= rot(-r1);\n    nF.xz *= rot(-r1);\n    \n    return Cube(tN, tF, nN, nF, tx);\n} \n\nstruct Scene{\n    float t;\n    vec3 n;\n    float tx;\n};\n    \nScene trace(vec3 ro, vec3 rd) {\n    \n    Scene s = Scene(-.1, vec3(0), 0.);\n    \n    float mint = FAR;\n    for (int i=0; i<NBALLS; i++) {\n        vec4 bp = load(iChannel0,R,POS,i);        \n        vec2 hash = hash22(vec2(float(i), bp.w)) * 2.;\n        float bx = sqrt(bp.w*bp.w*.5);\n        Cube cube = boxIntersect(ro-bp.xyz, rd, vec3(bx), hash.x*T, hash.y*T);\n        if (cube.tN>0. && cube.tN<mint) {\n            s = Scene(cube.tN, cube.nN, cube.tx);\n            mint = cube.tN;\n        }\n    }  \n    \n    return s;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n  \n    vec3 pc = vec3(0),\n         la = vec3(-20., 0., 0.), //look at\n         ro = vec3(-20., 0., -20.), //ray origin\n         rd = camera(U, R, ro, la, 1.3); //camera\n    \n    float mint = FAR;\n    \n    //trace scene\n    Scene s = trace(ro, rd);\n    if (s.t>0. && s.t<FAR) {\n        \n        mint = s.t;\n        \n        vec3 p = ro + rd*s.t;\n        vec3 ld = normalize(LP1-p);\n        float spec = pow(max(dot(reflect(-ld, s.n), -rd), 0.0), 64.0);\n        float fres = pow(clamp(dot(s.n, rd) + 1.0, 0.0, 1.0), 16.0);\n\n        pc = palette(T*.01) * s.tx; \n        pc *= max(.05, dot(ld, s.n));\n        pc += vec3(.8,.8,1.2) * (spec+fres);\n    }\n    \n    C = vec4(pc*3., mint);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution.xy\n#define T iTime\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\n\nvec4 trace(vec3 ro, vec3 rd) {\n    \n    vec4 s = vec4(0.);\n    \n    float mint = FAR;\n    for (int i=0; i<NLIGHTS; i++) {\n        vec4 bp = load(iChannel1,R,LIG,i);        \n        float si = sphIntersect(ro, rd, vec4(bp.xyz,.5));\n        if (si>0. && si<mint) {\n            mint = si;\n            s = vec4(si, bp.xyz);\n        }\n    }  \n    \n    return s;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec3 pc = vec3(0),\n         la = vec3(-20., 0., 0.), //look at\n         ro = vec3(-20., 0., -20.), //ray origin\n         rd = camera(U, R, ro, la, 1.3); //camera\n    \n    vec2 uv = U/R;\n    float uvx = abs(uv.x-.5) * 2.;\n    uvx*=uvx;\n    float scale = max(0., uvx-.6)*2.;\n    float uvy = .5 + (uv.y-.5) * (1. + scale*scale*4.);\n    vec4 scene = texture(iChannel2, vec2(uv.x, uvy));\n\n    vec3 ppc = texture(iChannel0, U/R).xyz;\n    //vec4 scene = texture(iChannel2, U/R);\n    \n    vec4 s = trace(ro, rd);\n\n    if (s.x>0. && s.x<scene.w) {\n        float w = sphDensity(ro, rd, vec4(s.yzw,.5), FAR); \n        if (w>0.) {\n            pc = palette(T*.01) * w*w*w*1.;    \n            pc += vec3(1.) * pow(w, 8.);    \n        }\n        \n    }\n    \n    C = vec4(pc+ppc*.844, 1.);\n}","name":"Buffer C","description":"","type":"buffer"}]}