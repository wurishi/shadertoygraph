{"ver":"0.1","info":{"id":"lslfDX","date":"1498628071","viewed":328,"name":"The Boring Company","username":"pi","description":"A tunnel shader. (Oh come on. How don't you make one of these after looking at [url=http://shadertoy.com/user/Shane]Shane's Profile[/url].\nWell the name is a pun. (an Elon Musk company name)","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["3d","noise","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsXSzX","filepath":"https://soundcloud.com/ma77/rocky-road-exp-arp-v0-15","previewfilepath":"https://soundcloud.com/ma77/rocky-road-exp-arp-v0-15","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A value between 0.1 and 1.0\n//(The less it is, the more your camera turns with the track\n#define CAMERA_BUMP .7\n#define TEXTURES true\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n               );\n}\nmat3 lookat(vec3 eye, vec3 target) {\n\tvec3 dir = normalize(target-eye);\n    float yAxis = atan(dir.x,dir.z);\n    float xAxis = -asin(dir.y);\n    return rotate(vec3(1,0,0),xAxis)*rotate(vec3(0,1,0),yAxis);\n}\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k ){\n\treturn mix(b,a,(smin(a,b,k)-a)/(b-a));    \n}\nfloat fractal(vec3 x) {\n\tfloat v=0.;for (float i=1.;i<7.;i++) {\n        v+=noise(x*exp2(i))/exp2(i);\n    }return v;\n}\nvec3 path(float x) {\n\treturn vec3(noise(vec3(x))*3.,noise(vec3(x,0.,x))*3.,6.*x);    \n}\n\nvec3 path2(float x) {\n\treturn vec3(noise(vec3(x,x,3.))*3.,cos(x)*3.,6.*x).yxz;     \n}float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat cart(vec3 o) {\n    o.y+=.3;\n    o.y/=3.;\n    float f = sdBox(o,vec3(o.y+1.5,.3,o.y+1.5)/3.);\n    return f;\n}\nfloat dis(vec3 i) {\n\tvec3 a = abs(i);\n    return a.x+a.y+a.z;\n}\nvec2 map(vec3 pos) {\n    float n = 1.-length(pos-path(pos.z/6.));\n    n=smax(n,.7-length(pos-path2(pos.z/6.)),1.5);\n    n+=fractal(pos)/2.;\n    \n    n=min(n,\n        smin(dis(pos-path2(pos.z/6.)+vec3(0,.8,0))-.05,dis(pos-path(pos.z/6.)+vec3(0,1.1,0))-.05, .1)\n          );\n    vec3 c = vec3(0);\n    vec3 v = pos-path2(iTime+1.);\n    v*=inverse(lookat(path2(iTime+1.),path2(iTime+1.1)));\n    v+=path2(iTime+1.);\n    float q = cart(v-path2(iTime+1.));\n    n=min(n,q);\n    return vec2(n,n==q?1.:0.);\n}\nfloat FAR=30.;\nfloat trace(vec3 o, vec3 d) {\n\tfloat t=0.,q=0.;\n    for (int i=0;i<100&&t<FAR;i++){\n   \t\tif((q=map(o+d*t).x)<.02)break;t+=q*.7;\n    }\n    return t;\n}\nvec3 normal( in vec3 x )\n{\n    vec2 e = vec2( .02, 0.0 );\n    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,\n                            map(x+e.yxy).x - map(x-e.yxy).x,\n                            map(x+e.yyx).x - map(x-e.yyx).x ) );\n}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn TEXTURES?(texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz:vec3(1);\n}\n\nvoid render(vec2 u, out vec3 color) {\n    vec2 R =iResolution.xy;\n    vec3 d = vec3(u*2.-1.,2), o = path(iTime);\n    d.x*=R.x/R.y;\n    d=normalize(d);\n    \n\n    \td*=lookat(o,path(iTime+CAMERA_BUMP));\n    color=texture(iChannel0,d.xy*FAR).rgb/5.;\n    \n    {\n        float dist = trace(o,d);\n        vec3 hit = o+d*dist;\n        vec2 hitMap = map(hit);\n        vec3 n = normal(hit);\n        if(hitMap.x<.02)\n        {\n            float diff = dot(n,o-hit)/(dist*dist)+.2;\n            \n            \n            vec3 o2 = path2(iTime+1.)-hit;\n            float dist2 = length(o2);\n            float diff2 = dot(n,o2)/(dist2*dist2);\n            \n            vec3 core = tex3D(iChannel0,hit,n);\n            \n            if(hitMap.y==1.)\n                core=tex3D(iChannel1,(hit-path2(iTime+1.))*inverse(lookat(path2(iTime+1.),path2(iTime+1.1))),n);\n            color=core*(max(diff,0.)+max(diff2,0.));\n            \n            \n            float ao = length(n/7.)-map(hit+n/7.).x;\n            color-=max(0.,ao);\n        }\n    }\n    color/=max(length(u*2.-1.)*2.,1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 color = vec3(0);\n    \n    render(uv,color);\n    \n\tfragColor = vec4(color*min(1.,iTime), 1);\n}","name":"Image","description":"","type":"image"}]}