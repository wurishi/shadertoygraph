{"ver":"0.1","info":{"id":"DdXGDM","date":"1666200211","viewed":80,"name":"Automata Erosion Lab","username":"essaar","description":"Cellular automata erosion demo for CIS 5660","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["automata","erosion"],"hasliked":0,"parentid":"cdl3W4","parentname":"Erosion Lab"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord / iResolution.x;\n    if(iTime == 0.) {\n        float f = fbm(uv);\n        vec2 warp1 = NoiseVectorFBM(uv) * 0.6;\n        float w = WorleyNoise(uv * vec2(1., 6.) + warp1);\n        float h = gain(mix(w, f, 0.33), 0.4);\n        vec3 color = mix(vec3(0.0, 1.0, 0.), vec3(0., 0., 1.), h);\n        fragColor = vec4(color, 1.);\n    }\n    else {\n        // Here's how to read a pixel from the input buffer. This gets us the cell stored in a single pixel\n        vec3 curr = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        \n        // 1. Get the values from the neighboring cells\n        vec3 neighbors[9];\n        for(int i = -1; i < 2; i++)\n        {\n            for(int j = -1; j < 2; j++)\n            {\n                int idx = ((i + 1) * 3) + (j + 1);    //row * arrlength + col\n                neighbors[idx] = texture(iChannel0, (fragCoord + vec2(float(i), float(j))) / iResolution.xy).rgb;\n            }\n        }\n        \n        // 2. Get change in slope b/t each of 8 neighbors\n        vec3 diffs[9];\n        for(int i = 0; i < 9; i++)\n        {\n            diffs[i] = neighbors[i] - curr;\n        }\n        \n        // 3. For each negative slope, subtract height from\n        // curr proportional to diff. For each positive slope,\n        // add height to curr (represents neighbor losing\n        // height to us)\n        // To mimic erosion due to gravity, only do this when between\n        // certain thresholds. Here are some recommendations!\n        \n        #define THR_LOWER 0.0035\n        #define THR_UPPER 0.0085\n        \n        vec3 erosion = vec3(0.);\n        for(int i = 0; i < 9; i++)\n        {\n            if(abs(diffs[i].b) > THR_LOWER && abs(diffs[i].b) < THR_UPPER)\n            {\n                erosion += (diffs[i] * EROSION_SCALAR);\n            }\n        }\n        \n        curr += erosion;\n       \n        fragColor = vec4(curr, 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EROSION_SCALAR 0.25\n#define FBM_OCTAVES 8\n\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat gain(float time, float gain)\n{\n  if(time < 0.5)\n    return bias(time * 2.0,gain)/2.0;\n  else\n    return bias(time * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float rad = deg * 3.14159 / 180.0;\n    return vec2(cos(rad) * p.x - sin(rad) * p.y,\n                sin(rad) * p.x + cos(rad) * p.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\n\nfloat bilerpNoise(vec2 uv) {\n    ivec2 uvFloor = ivec2(floor(uv));\n    vec2 uvFract = fract(uv);\n    float ll = random1(vec2(uvFloor));\n    float lr = random1(vec2(uvFloor + ivec2(1, 0)));\n    float ul = random1(vec2(uvFloor + ivec2(0, 1)));\n    float ur = random1(vec2(uvFloor + ivec2(1, 1)));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec2 NoiseVectorFBM(vec2 uv) {\n    float x = fbm(uv) * 2.0 - 1.0;\n    float y = fbm(rotate(uv, 60.0)) * 2.0 - 1.0;\n    return vec2(x, y);\n}","name":"Common","description":"","type":"common"}]}