{"ver":"0.1","info":{"id":"DtSSRh","date":"1675621205","viewed":100,"name":"Another noise without sin/cos","username":"ianertson","description":"Some other noise functions without sin/cos/tan etc.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define MAP(v) (0.5+(0.5*v))\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint linc(uint s) { return ((1103515245u * s) + 12345u) % 7883u; } \nfloat linc(float s) { return float(linc(uint(ceil(abs(s*10.0))))) / float(7883u); }\n\n// parkmiller\nuint pm_u(uint s) {return (s+16u) * 48271u % 0x7fffffffu;}\n\n// float parkmiller\nfloat pm(float s) { return exp(fract((float(pm_u(uint(ceil(abs(s))))) / float(0x7fffffffu / 48271u)) * (0.5 + s))); }\n\n// combination of linc and pm\nfloat rand11(float v) { return linc(v+pm(v)); }\n\n// combination of linc and pm but with vec2 as input\nfloat rand21(vec2 p) {\n    float x = rand11(rand11(rand11(p.x)));\n    float y = rand11(rand11(rand11(p.y)));\n    float z = fract(dot(p, vec2(x, y))) * 10.2315;\n    return fract(rand11((z*z)/(10.0315+exp(x*y))) * exp(z));\n}\n\n// smooth noise\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    return mix(mix(rand21(id), rand21(id+vec2(1.0, 0.0)), lv.x),\n        mix(rand21(id+vec2(0.0, 1.0)),\n        rand21(id+vec2(1.0, 1.0)), lv.x), lv.y);\n}\n\n// layered smooth noise\nfloat noise(vec2 p, float freq, int depth) {\n    float n = 0.0;\n    for (int i = 0; i < depth; i++) { n += noise(p*freq); freq *= 2.0; }\n    return n / float(depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    O = vec4(vec3(noise((fc/R.xy) + vec2(cos(T*0.2), sin(T*0.2)), 16.5 + (MAP(cos(T*0.5)) * 32.0), 5)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}