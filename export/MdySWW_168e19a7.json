{"ver":"0.1","info":{"id":"MdySWW","date":"1464328346","viewed":296,"name":"Flooded Canyon","username":"zackpudil","description":"A very simple ray marched terrain with volumetric water. This seems to render very weird on my Windows 7 ThinkPad work laptop, so apologizes if you see that. Please let me know if you see something weird.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tmax = 20.0;\n\n// ----- random -----\nfloat hash2(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.988, 71.233)))*43758.5453);\n}\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec3 hash(vec3 x) {\n\tvec3 n = vec3(\n\t\tdot(x, vec3(171.0, 311.0, 57.0)),\n\t\tdot(x, vec3(269.0, 382.0, 113.0)),\n\t\tdot(x, vec3(129.0, 234.0, 170.0))\n\t);\n\n\treturn fract(sin(n)*43758.5453);\n}\n\n// ---- perlen noise, most basic implemntation ----\nfloat noise(vec3 g) { // 3d\n\tvec3 p = floor(g);\n\tvec3 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\n\tfloat x = mix(hash(n + 0.), hash(n + 1.), f.x);\n\tfloat y = mix(hash(n + 57.), hash(n + 58.), f.x);\n\tfloat z = mix(hash(n + 113.), hash(n + 114.), f.x);\n\tfloat w = mix(hash(n + 170. /* this number is the addition of y coeff and z coeff*/), hash(n + 171.), f.x);\n\n\treturn mix(mix(x, y, f.y), mix(z, w, f.y), f.z);\n}\n\nfloat noise(vec2 g) { //2d\n\tvec2 p = floor(g);\n\tvec2 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat x = mix(hash(n + 0.0), hash(n + 1.0), f.x);\n\tfloat y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n\n\treturn mix(x, y, f.y);\n}\n\nconst mat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n// 2d fractional browning motion.\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m2*2.01;\n\tf += 0.2500*noise(p); p *= m2*2.04;\n\tf += 0.1250*noise(p); p *= m2*2.07;\n\tf += 0.0625*noise(p);\n\n\treturn f;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n// 3d fractional browning motion.\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m3*2.01;\n\tf += 0.2500*noise(p); p *= m3*2.04;\n\tf += 0.1250*noise(p); p *= m3*2.07;\n\tf += 0.0625*noise(p);\n\n\treturn f;\n}\n\n// vornoi pattern.\nfloat voronoi(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tfloat d = 8.0;\n\tfor(int i = -1; i <= 1; i++)\n\tfor(int j = -1; j <= 1; j++) \n\tfor(int k = -1; k <= 1; k++) {\n\t\tvec3 g = vec3(float(i), float(j), float(k));\n\t\tvec3 r = g + hash(p + g) - f;\n\n\t\td = min(d, dot(r, r));\n\t}\n\n\treturn sqrt(d);\n}\n\nfloat map(vec3 p) {\n    // a simple plan modified with fbm and some noise for hills.\n\treturn p.y + 1.0  \n\t\t- 0.8*noise(p) // hills\n\t\t- smoothstep(0.4, 0.7, fbm(2.0*p.xz)); // mountains\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < 300; i++) {\n\t\tfloat d = map(ro + rd*t);\n\t\tif(abs(d) < 0.001 || t >= tmax) return t;\n        // only stepping a small amount to get more details.\n        // con is we have to march we more or the ray get's stopped to soon.\n\t\tt += d*0.1;\n\t}\n\n\treturn t;\n}\n\nfloat volume(vec3 p) {\n    // a simple cosine plan with fbm modification.\n\tfloat d = -(p.y + 0.5);\n\td += 0.5*fbm(4.0*p + iTime);\n\td += 0.4*cos(2.0*p.x + iTime)*sin(2.0*p.z + iTime);\n\treturn clamp(d, 0.0, 1.0);\n}\n\nvec4 volumetric(vec3 ro, vec3 rd, float mt, vec2 p) {\n\tfloat s = 0.05, t = 0.0;\n\tvec4 sum = vec4(0);\n\n\tt += 0.05*hash2(p); // dithering for psuedo aa.\n\tfor(int i = 0; i < 200; i++) {\n\t\tif(sum.a > 1.00) continue; // break the loop if we got 100% opacity.\n\t\tif(t > mt) continue; // break if the volume ray intersected with solid geometry. Don't render any fog  behind it.\n\n\t\tfloat d = volume(ro + rd*t);\n        // mixing between a light blue and white.\n\t\tvec4 c = vec4(mix(vec3(1), vec3(0.0, 0.4, 1.0), 1.0 - d), d);\n        // fog for the water.\n        c.rgb = mix(c.rgb, vec3(1), 1.0 - exp(-0.02*t));\n\n        // increase the opacity 10 fold so it looks less like fog and more like water.\n\t\tc.a *= 10.0;\n\t\tc.rgb *= c.a;\n        // back to front blending.\n\t\tsum += c*(1.0 - sum.a);\n\n\t\tt += s;\n\t}\n\n    // adding this step outside the loop...\n    // a white vornoi pattern on the total distance traveled for the ray.\n\tsum.rgb = mix(sum.rgb, vec3(1), 0.4*voronoi(2.0*(ro + rd*t)));\n\n\treturn clamp(sum, 0.0, 1.0);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\n    // bump mapping on the canyons.\n\tfloat f = 20.0; \n\tvec3 b = 0.3*vec3(\n\t\tfbm(f*(p + h.xyy)) - fbm(f*(p - h.xyy)),\n\t\tfbm(f*(p + h.yxy)) - fbm(f*(p - h.yxy)),\n\t\tfbm(f*(p + h.yyx)) - fbm(f*(p - h.yyx))\n\t);\n\n\treturn normalize(n + b);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    // the simplest ambient occlusion.\n\tfloat s = 0.005, t = s;\n\tfloat o = 0.0, w = 1.0;\n\n\tfor(int i = 0; i < 25; i++) {\n\t\tfloat d = map(p + n*t);\n\t\to += (t - d)*w;\n        // this adds a scattering effect.\n        //Dampins the occlusion as the distance travele\n\t\tw *= 0.85;\n        \n        // a simple constant step.\n\t\tt += s;\n\t}\n\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\n// a basic camera matrix. Right hand rule.\nmat3 camera(vec3 eye, vec3 lat) {\n    // the vector pointing from the eye to the look at position.\n\tvec3 ww = normalize(lat - eye);\n    // vector pointing to the left\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    // vector pointing up (relative to the foward vector).\n\tvec3 vv = normalize(cross(ww, uu));\n\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy); // [0, 1] -> [-1, 1]\n\tuv.x *= iResolution.x/iResolution.y; // aspect ratio.\n\n    // camera position, just move along the z direction linearly.\n\tvec3 ro = vec3(0, 1.0 - 0.25*cos(iTime*0.5), iTime*0.6);\n    // construct the ray direction, using the 3x3 camera matrix, and the current uv coord.\n\tvec3 rd = normalize(camera(ro, ro + vec3(0.0, -1.2, 3))*vec3(uv, 1.97));\n\n    // background color a blue sky. mixed in with some clouds. fbm based on xy coords of ray direction\n\tvec3 col = mix(vec3(0.2, 0.6, 1.0), vec3(1), smoothstep(0.4, 1.0, fbm(20.0*rd.xy)));\n\n    // ray march.\n\tfloat i = march(ro, rd);\n\n    // if the ray is less then the max we hit something.\n\tif(i < tmax) {\n        // get the geometry of what we hit.\n        //  Position, surface normal, and the reflected vector of the norm and the veiw dir.\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n        /* very simple lighting, only ambient and diffuse */\n        \n        // two lights, both direction. \n\t\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6)); // sun light.\n\t\tvec3 gli = normalize(vec3(0, -1.0, 0.0)); // ground light.\n\n\n\t\tcol  = 0.2*vec3(1); // ambient light.\n\t\tcol += 0.7*clamp(dot(lig, nor), 0.0, 1.0); // diffuse light for sun.\n\t\tcol += 0.1*clamp(dot(gli, nor), 0.0, 1.0); // diffuse light for ground.\n\n        // material, nothing fancy just a mixing of a brown and a darker brown.\n\t\tcol *= mix(vec3(0.72, 0.45, 0.3), vec3(0.33, 0.2, 0.0), fbm(30.0*pos));\n\n        // ambient occlusion.\n\t\tcol *= vec3(ao(pos, nor));\n\n        // fog, only affected when we intersect so we don't loose are background color.\n\t\tcol = mix(col, vec3(0.5), 1.0 - exp(-1.0*smoothstep(4.0, 10.0, i)));\n\t}\n\n    // render the render with volumetric rendering.\n\tvec4 v = volumetric(ro, rd, i, uv);\n\tcol = mix(col, v.rgb, v.a); // mix that with the overall color of the scene.\n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}