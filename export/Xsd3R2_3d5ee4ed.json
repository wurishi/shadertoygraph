{"ver":"0.1","info":{"id":"Xsd3R2","date":"1450966562","viewed":16172,"name":"try volumetric","username":"candycat","description":"very simple volumetric rendering. based on https://www.shadertoy.com/view/Xss3DS.","likes":137,"published":1,"flags":0,"usePreview":1,"tags":["noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0);\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n     \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    p = p - vec3(1.0, 1.0, 0.0) * iTime * 0.1;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat density(vec3 pos, float dist)\n{    \n    float den = -0.2 - dist * 1.5 + 3.0 * fractal_noise(pos);\n    den = clamp(den, 0.0, 1.0);\n    float size = clamp(texture(iChannel1, vec2(0.5, 0.0)).x * 2.0 + 0.1, 0.4, 0.8);\n    float edge = 1.0 - smoothstep(size*sphere.w, sphere.w, dist);\n    edge *= edge;\n    den *= edge;\n    return den;\n}\n\nvec3 color(float den, float dist)\n{\n    // add animation\n    vec3 result = mix(vec3(1.0, 0.9, 0.8 + sin(iTime) * 0.1), \n                      vec3(0.5, 0.15, 0.1 + sin(iTime) * 0.1), den * den);\n    \n    vec3 colBot = 3.0 * vec3(1.0, 0.9, 0.5);\n\tvec3 colTop = 2.0 * vec3(0.5, 0.55, 0.55);\n    result *= mix(colBot, colTop, min((dist+0.5)/sphere.w, 1.0));\n    return result;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{\n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 30; i++) {\n        float dist = length(pos - sphere.xyz);\n        if (dist > sphere.w + 0.01 || sum.a > 0.99) break;\n        \n        float den = density(pos, dist);\n        vec4 col = vec4(color(den, dist), den);\n        col.rgb *= col.a;\n        sum = sum + col*(1.0 - sum.a); \n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    return mix(backCol, sum.xyz, sum.a);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec2 mo = vec2(iTime * 0.5);\n    if (iMouse.z > 0.0) \n    {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    // Rotate the camera\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec2 cossin = vec2(cos(mo.x), sin(mo.x));\n    mat3 rot = mat3(cossin.x, 0.0, -cossin.y,\n                   \t0.0, 1.0, 0.0,\n                   \tcossin.y, 0.0, cossin.x);\n    ro = rot * ro;\n    cossin = vec2(cos(mo.y), sin(mo.y));\n    rot = mat3(1.0, 0.0, 0.0,\n               0.0, cossin.x, -cossin.y,\n               0.0, cossin.y, cossin.x);\n    ro = rot * ro;\n    \n    // Compute the ray\n    vec3 rd = setCamera(ro, vec3(0.0), 0.0) * normalize(vec3(p.xy, 1.5));\n    \n    float dist = sphIntersect(ro, rd, sphere);\n    vec3 col = vec3(0.45, 0.4, 0.4) * (1.0- 0.3 * length(p));\n    \n    if (dist > 0.0) {\n        col = raymarching(ro, rd, dist, col);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}