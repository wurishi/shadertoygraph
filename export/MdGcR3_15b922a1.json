{"ver":"0.1","info":{"id":"MdGcR3","date":"1522751366","viewed":116,"name":"WaterMelon - Noise Texture","username":"nawafuji","description":"Tested noise on texture map","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n\nfloat fbm(vec4 x) {\n\tfloat v = 0.0;\n    float a = 0.5;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tv += x[i] * a;\n        a *= 0.5;\n\t}\n\treturn v;\n}\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\n//rolled brass\n/*\nconst vec2 P = vec2(0.100, 0.330);\nconst vec2 A = vec2(0.050, 0.160);\nconst vec3 Scale = vec3(1.0, 1.0, 1.0);\nvec3 surfaceColor = vec3(1.0,0.62,0.31);\n*/\n\n// plastic laminate\n/*\nconst vec2 P = vec2(0.670, 0.070);\nconst vec2 A = vec2(0.092, 0.092);\nconst vec3 Scale = vec3(1.0, 50.0, 2.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n*/\n\n// semi-gloss paint, rolled\n\nconst vec2 P = vec2(0.450, 0.048);\nconst vec2 A = vec2(0.045, 0.068);\nconst vec3 Scale = vec3(1.0, 20.0, 10.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n\n\n// lightly brushed aluminum\n/*\nconst vec2 P = vec2(0.150, 0.190);\nconst vec2 A = vec2(0.088, 0.130);\nconst vec3 Scale = vec3(2.0, 2.0, 2.0);\nvec3 surfaceColor = vec3(1.0,0.99,1.0);\n*/\n\n// white ceramic tile\n/*\nconst vec2 P = vec2(0.700, 0.050);\nconst vec2 A = vec2(0.071, 0.071);\nconst vec3 Scale = vec3(1.0, 10.0, 10.0);\nvec3 surfaceColor = vec3(1.0,1.0,1.0);\n*/\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 2.0;\n}\n\nfloat plane(vec3 p){\n    float s = -1.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   //\tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    //return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n    return sphere(p);\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec2 computeSphereTexCoord(vec3 p){\n    float longitude = acos(dot(vec2(0,-1), normalize(p.xz)));\n    if(p.x > 0.0)\n        longitude = 2.0*PI - longitude;\n    longitude /= 2.0*PI;\n    \n    float latitude = acos(dot(vec2(1,0), normalize(p.yz)));\n    latitude /= PI;\n    \n    return vec2(longitude, latitude);\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        \n        vec2 texcoord = computeSphereTexCoord(hit);\n        \n        vec3 N = computeSurfaceNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(p-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n       \n\n    \t// Time varying pixel color\n    \tvec4 tex = texture(iChannel0, texcoord);\n\n\t\tfloat noise = fbm(tex);\n        \n        float v = texcoord.x;\n        float sawtooth = fract((v+noise*0.02) * 20.0);\n        float triangle = abs(2.0*sawtooth-1.0);\n       // triangle = 1.0- triangle*triangle;\n        float val = smoothstep(0.45,0.55, triangle);\n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P,A,Scale, mix(vec3(0.0,0.0,0.0), vec3(0.5,1.0,0.0),val));\n        \n\n\n        return pixelColor;\n    } \n    dist += nearest;\n  }\n  return vec3(1.0,0.0,0.0);\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n    vec2 mouseUV = vec2(0.5);\n    \n    if(iMouse.z>0.0)\n\t    mouseUV = 2.0*iMouse.xy/iResolution.xy-1.0;\n    \n    float d = 10.0;\n    float z = d*cos(mouseUV.y*PI/2.0);\n    vec3 cameraPosition = vec3(sin(mouseUV.x*PI/2.0) * z, d*sin(mouseUV.y*PI/2.0), cos(mouseUV.x*PI/2.0)*z);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n    cameraUp = normalize(cross(nright, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n\n    if(pixelColour == vec3(1.0,0.0,0.0))\n    {\n            \n\t\tpixelColour = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), uv.y);\n    }\n    \n\tpixelColour *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .16); // Vigneting\n\n    fragColor = vec4(pixelColour, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n\n\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n#define BASE_FREQUENCY 8\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat turbulence(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += abs(a * (noise(x) - 0.5));\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v*4.0,0.0,1.0);\n}\n\n\nfloat marble(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += abs(a * (noise(x) - 0.5));\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn  sin(v*12.0) * 0.5 + 0.5;\n}\n\nfloat granite(vec2 x) {\n\tfloat v = min(1.0, 4.0*noise(x*16.0));\n\treturn  v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color;\n    float f = 1.0 * float(BASE_FREQUENCY);\n    for (int i = 0; i < 4; ++i) {\n        color[i] = noise(uv*f);\n        f *= 2.0;\n    }\n    fragColor = color;\n    //fragColor = vec4(fbm(uv*float(BASE_FREQUENCY)));\n    //fragColor = vec4(turbulence(uv*float(BASE_FREQUENCY)));\n    //fragColor = vec4(marble(uv*float(BASE_FREQUENCY)));\n    //fragColor = vec4(granite(uv*float(BASE_FREQUENCY)));\n}","name":"Buf A","description":"","type":"buffer"}]}