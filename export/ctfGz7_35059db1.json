{"ver":"0.1","info":{"id":"ctfGz7","date":"1671488236","viewed":111,"name":"System Response Plotter","username":"Envy24","description":"n = f(t) - discrete function of time,\nBlue - input signal x(n),\nRed - system response y(n) to signal x(n).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["template","linear","plotter","system","response","graphs","dsp"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0, 0) )\n#define SCENE_SCALE               ( 15.0 )\n#define UNIT                      ( 2.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat step_(float n) { return n < 0. ? 0. : 1.; } // step signal\nfloat unit(float n) { return n == 0. ? 1. : 0.; } // unit impulse\n\nfloat x(float n) // input signal\n{\n    //n -= 1.; // delay signal\n    //n += 1.; // advance signal\n    \n#define MIN (-21.)\n#define MAX (20.)\n#define T (iTime * 0.1)\n\n// Time quantization.\n//#define LOOP(T) ( loop_continuous(MIN, MAX, T) )\n#define LOOP(T) ( loop_discrete(MIN, MAX, T) )\n    n -= LOOP(T);\n    \n// Value quantization example.\n    //float X = sin(0.15*n) * 5.; // continuous input\n    float X = round(sin(0.15*n) * 5.); // discrete input\n\n    //float X = unit(n);\n    //float X = step_(n);\n    //float X = (6. - n)*(step_(n) - step_(n - 6.));\n    //float X = clamp(round(n*n*n), -6., 6.);\n    \n    return X; //clamp(X, -6., 6.);\n}\nfloat y(float n) // system response to signal\n{\n    //float Y = x(n); // bypass\n    //float Y = x(4. - n);\n    //float Y = x(2.*n - 3.);\n    //float Y = x(8. - 3.*n);\n    float Y = x(n*n - 2.*n + 1.);\n    \n    return Y; //clamp(Y, -6., 6.);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    float vert_offset = 7.,  // offset relative to y = 0 line\n          vert_shift = -0.,  // shifts plot up or down\n          x_offs = vert_offset + vert_shift,\n          y_offs = vert_shift - vert_offset;\n\n    vec3 X_col = vec3(0,0,1), Y_col = vec3(1,0,0), color = vec3(1.);\n    /* Common stuff */\n         color -= x_axis(vec2(NDC.x, NDC.y - x_offs)); \n         color -= x_axis(vec2(NDC.x, NDC.y - y_offs));\n         color -= y_axis(NDC);\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MIN));\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX));\n         color = mix(color, vec3(0,0,.5), vertical_line(NDC, LOOP(T)));\n\n    /* Variant 1. *\n    float n = round(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs;\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n    /* Variant 2. *\n    float n = floor(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs;\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(NDC.x, X), UNIT)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(NDC.x, Y), UNIT)));\n    /* Variant 3. */\n    float n = round(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs;  \n         color = mix(color, X_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, X), UNIT*0.25)));\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         \n         color = mix(color, Y_col, SMAA(segmentSDF_L2(NDC, vec2(n, y_offs), vec2(n, Y), UNIT*0.25)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float loop_continuous(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return (min + fract(T) * range);\n}\nfloat loop_discrete(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return round(min + fract(T) * range);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}