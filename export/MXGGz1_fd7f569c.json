{"ver":"0.1","info":{"id":"MXGGz1","date":"1718405272","viewed":62,"name":"7 Segments Numbers","username":"LucasLelievre","description":"drawing number in the style of 7 segments displays","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["numbers","digits","7segments"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// digit to segments truth table\nconst int truth_table[10] = int[10](0x7E, 0x30, 0x6D, 0x79, 0x33, 0x5B, 0x5F, 0x70, 0x7F, 0x7B);\n\nfloat range(float i, float a, float b){\n    return step(a, i)*step(i, b);\n}\nfloat saturate(float a) {\n    return clamp(a, 0., 1.);\n}\n\n/**\nuv    : position of the current fragment\ncenter: position of the segment\nl     : length of the segment\nw     : width of the segment\nisVertical: orientation of the segment\n*/\nfloat drawSegment(vec2 uv, vec2 center, float l, float w, float isVertical) {\n    uv = abs(uv-center);\n    uv = isVertical * vec2(uv.y, uv.x) + (1.-isVertical) * uv;\n    return step(uv.y, min(-uv.x+l, 1./3.));\n}\n\n/**\ndigit :   digit to draw\nuv    :   position of the current fragment\npos   :   position in normalized coordinates\nhalves:   width and height of the drawing\n*/\nfloat drawDigit(int digit, vec2 pos, vec2 halves, vec2 uv) {\n    // pos of fragment relative to the center of the digit\n    vec2 frag = (uv-pos)/halves.x;\n    // the digit that is currently drawn\n    int cur_digit = truth_table[digit];\n    // compute which segment is going to be drawn\n    float s0 = saturate(step(abs(frag.x)+abs(frag.y), 1.));\n    float s1 = saturate(step(1., (-frag.x) - abs(frag.y-1.) + 1.) * sign(frag.y));\n    float s2 = saturate(step(1., (-frag.x) - abs(frag.y+1.) + 1.) * -sign(frag.y));\n    float s3 = saturate(step(1., -frag.y - abs(frag.x)));\n    float s4 = saturate(step(1., frag.x - abs(frag.y+1.) + 1.) * -sign(frag.y));\n    float s5 = saturate(step(1., frag.x - abs(frag.y-1.) + 1.) * sign(frag.y));\n    float s6 = saturate(step(1., frag.y - abs(frag.x)));\n    int i = int(s0*0. + s1*1. + s2*2. + s3*3. + s4*4. + s5*5. + s6*6.);\n    // compute whether the segment is lit up or not\n    float isSegmentLit = float((cur_digit>>i)&0x1);\n    // compute if the segment is vertical or not\n    float isVertical = min(mod(float(i), 3.), 1.);\n    // compute the center position of the segment\n    float x_delta = sign(float(i)-3.); // lateral translation\n    float x = x_delta * isVertical; // only applied if the segment is vertical\n    float y_delta_v = (1. - range(float(i), 1.5, 4.5)) * 2. - 1.; // vertical translation for vertical segments\n    float y_delta_h = max(-float(i)*2./3., (float(i)*4./3.)-6.); // vertical translation for horizontal segments\n    float y = y_delta_v * isVertical + y_delta_h * (1.-isVertical);\n    \n    return isSegmentLit * drawSegment(frag, vec2(x, y), 0.9, halves.y*0.45, isVertical);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/vec2(min(iResolution.x, iResolution.y));\n    vec2 res_norm = iResolution.xy/vec2(min(iResolution.x, iResolution.y));\n    uv -= res_norm/2.;\n    \n    vec2 size = vec2(.5, 1.)*.06;\n    vec3 col = vec3(0.0);\n    // current time digits\n    int dah = int(floor(mod(iTime/36000., 24.)));\n    int h = int(floor(mod(iTime/3600., 10.)));\n    int dam = int(floor(mod(iTime/600., 6.)));\n    int m = int(floor(mod(iTime/60., 10.)));\n    int das = int(floor(mod(iTime/10., 6.)));\n    int s = int(floor(mod(iTime, 10.)));\n    int ds = int(floor(mod(iTime*10., 10.)));\n    int cs = int(floor(mod(iTime*100., 10.)));\n    int ms = int(floor(mod(iTime*1000., 10.)));\n    int us = int(floor(mod(iTime*10000., 10.)));\n    \n    col += drawDigit(dah, vec2(-.55,.0), size, uv);\n    col += drawDigit(h, vec2(-.45,.0), size, uv);\n    col += drawDigit(dam, vec2(-.3,.0), size, uv);\n    col += drawDigit(m, vec2(-.2,.0), size, uv);\n    col += drawDigit(das, vec2(-.05,.0), size, uv);\n    col += drawDigit(s, vec2(.05,.0), size, uv);\n    col += drawDigit(ds, vec2(.2,.0), size, uv);\n    col += drawDigit(cs, vec2(.3,.0), size, uv);\n    col += drawDigit(ms, vec2(.4,.0), size, uv);\n    col += drawDigit(us, vec2(.5,.0), size, uv);\n\n    // colons\n    col += drawSegment((uv-vec2(-.375,  size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n    col += drawSegment((uv-vec2(-.375, -size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n    col += drawSegment((uv-vec2(-.125,  size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n    col += drawSegment((uv-vec2(-.125, -size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n    col += drawSegment((uv-vec2( .125,  size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n    col += drawSegment((uv-vec2( .125, -size.y/2.))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n\n    // framerate\n    float fps = iFrameRate;\n    int daf = int(floor(mod(fps/10., 10.)));\n    int f = int(floor(mod(fps, 10.)));\n    int df = int(floor(mod(fps, 10.)));\n    int cf = int(floor(mod(fps, 10.)));\n    int mf = int(floor(mod(fps, 10.)));\n    \n    col += drawDigit(daf, vec2(-.55,-.2), size, uv);\n    col += drawDigit(f, vec2(-.45,-.2), size, uv);\n    col += drawDigit(df, vec2(-.3,-.2), size, uv);\n    col += drawDigit(cf, vec2(-.2,-.2), size, uv);\n    col += drawDigit(mf, vec2(-.1,-.2), size, uv);\n    col += drawSegment((uv-vec2(-0.375,-size.y - .2))/size.x, vec2(0.0), 1./3., size.y*0.45, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}