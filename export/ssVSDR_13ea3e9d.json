{"ver":"0.1","info":{"id":"ssVSDR","date":"1634498411","viewed":104,"name":"jneen - 3d sprites","username":"jneen","description":"rendering 3d objects using sprites","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","sprites"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I (1.)\n#define O (0.)\n\n#define T (.2*(iTime))\n\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n\nfloat[16] T1 = float[16](\nI,I,O,O,\nI,I,I,O,\nO,I,I,I,\nO,O,I,I\n);\n                         \nfloat[16] T2 = float[16](\nO,O,I,I,\nO,I,I,I,\nI,I,I,O,\nI,I,O,O\n);\n\nfloat[16] T3 = float[16](\nI,I,I,I,\nI,O,O,I,\nO,O,O,O,\nI,I,I,I\n);\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q=abs(p)-abs(a);\n  return min(length(max(q,0.)),max(q.x,max(q.y,q.z)));\n}\n\nvec3 erot(vec3 p,vec3 ax,vec3 ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define MISS(D) (D>1000.)\n\n\nvec3 erot(vec3 p,vec3 ax,float o) {\n  return mix(dot(ax,p)*ax,p,cos(o))+sin(o)*cross(ax,p);\n}\n\n#define bump(X) (sqrt(abs(sin(X))))\n\n\nmat2 rot(float t) { float s=sin(t),c=cos(t);return mat2(c,s,-s,c); }\n#define nsin(X) (.5+.5*sin(X))          \nfloat warp(vec2 p) {\n  //p *= rot(bump(T));\n  //p *= rot(pow(2.,length(p)));\n  //p.x-=3.*sin(T);\n  p*=(2.+10.*nsin(T));\n  return tan(p.x)*tan(p.x)-tan(p.y)*tan(p.y);\n}\n\nfloat sph(vec3 p, float r) { return length(p)-r; }\n\nfloat boxle(vec3 p, float r) {\n  return max(box(p,vec3(r)), -sph(p,r*(4./3.)));\n}\n\nfloat S(vec3 p) {\n  p.x+=sin(T);\n  p = erot(p, normalize(vec3(1)), T*4.);\n  float D= boxle(p,1.5);\n  p = erot(p, normalize(vec3(11,-1,0)),-T*16.);\n  D=min(D,boxle(p,.5));\n  return D;\n}\n\n\nfloat ray(vec3 p, vec3 dir) {\n  float dist=0.;\n  for (int i=0; i<100;i++) {\n    float m=S(p+dist*dir);\n    dist+=m;\n    if (m<0.01) return dist;\n    if (MISS(dist)) return dist;\n  }\n  return 1001.;\n}\n\nvec3 norm(vec3 p) {\n  mat3 K=mat3(p,p,p)-mat3(.001);\n  return normalize(S(p)-vec3(S(K[0]),S(K[1]),S(K[2])));\n}\n\nfloat RES;\n\nvec3 stext(vec2 uv) {\n    vec2 xy = floor(uv*RES)/RES;\n    vec2 idx = (clamp((uv-xy)*RES*4.,0.,4.));\n    // Time varying pixel color\n    float w = nsin(T)-warp(xy);\n    int i=4*int(idx.y)+int(idx.x);\n    vec3 c1 = 1.-mix(vec3(1),vec3(0),T1[i]);\n    vec3 c2 = 1.-mix(vec3(1),vec3(0),T2[i]);\n    vec3 c3 = 1.-mix(vec3(1),vec3(0),T3[i]);//erot(mix(vec3(uv,.6),vec3(.3,.1,.9),T3[i]),vec3(1.,.5,.4),T)/2.+.1;\n    return vec3(mix(c1,mix(c2,c3,step(2.,w)),step(0.,w)));\n\n}\nvec3 text(vec2 uv) {\n    uv = uv+0.;\n    uv /= max(1.-1.*length(uv),.5);\n    uv *= rot(length(uv));\n    \n    uv.y = -uv.y;\n    return stext(uv);\n\n}\nvec3 light(vec3 cam, vec3 dir, float dist,vec3 bg) {\n  vec3 p = cam+dir*dist;\n  vec3 n = norm(p);\n  vec3 R = cross(dir,n);\n  float inc = dot(dir,-n);\n  float ring = n.y;\n  float angle = atan(n.x, n.z)/TAU;\n  \n  //vec3 R = mix(dir,n,.05*inc);\n  return mix(bg,stext(p.xx),step(.1,inc));//inc*text(n.xy);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    RES=floor(20.+20.*nsin(.25+T*3.523));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uu = fragCoord/iResolution.xy;\n    \n    vec2 uv=uu-.5;\n    \n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n//        uv += rot(T*5.)*vec2(bump(T*5.)-.5);\n\n    // Output to screen\n    vec3 C = text(uv);\n    vec3 cam=vec3(0,0,-5);\n    vec3 dir=normalize(vec3(floor(uv*RES*4.)/RES/4.,1));\n    float dist = ray(cam,dir);\n    if (!MISS(dist)) C=light(cam,dir,dist,C);\n    C -= vec3(.8,.5,sin(uv.x+T));\n    fragColor = vec4(C,1.0);\n}\n","name":"Image","description":"","type":"image"}]}