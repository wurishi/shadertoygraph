{"ver":"0.1","info":{"id":"Xd2yzG","date":"1492592817","viewed":94,"name":"GRAPROG - FINALS - SANTOS, KAD","username":"KennySans37","description":"as","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pattern 1\n\nfloat random2(in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise2 (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random2(i);\n    float b = random2(i + vec2(1.0, 0.0));\n    float c = random2(i + vec2(0.0, 1.0));\n    float d = random2(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise2(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\nfloat random(vec2 uv) {\n  return fract(sin(dot(uv, vec2(5.34, 7.13)))*5865.273458);   \n}\nfloat fade(float t) {\n  return t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n}\nfloat grad(float p) {\n\tconst float texture_width = 256.0;\n\tfloat v = texture(iChannel0, vec2(p / texture_width, p)).r;\n    return v > 0.5 ? 1.0 : -1.0;\n}\nfloat noise(float p) {\n  float p0 = floor(p);\n  float p1 = p0 + 1.0;\n    \n  float t = p - p0;\n  float fade_t = fade(t);\n\n  float g0 = grad(p0);\n  float g1 = grad(p1);\n\n  return (1.0-fade_t)*g0*(p - p0) + fade_t*g1*(p - p1);\n}\n\nfloat stars(float probability, vec2 uv) {\n    return smoothstep(probability, 1.0, random(uv));\n}\n\nfloat mountain1(float x) {\n\tfloat position =  x;\n    return 2. *\n        (noise(position * (1.0/300.0)) * 1.0 +\n       \tnoise(position * (1.0/150.0)) * 0.5 +\n  \t\tnoise(position * (1.0/75.0))  * 0.25 +\n    \tnoise(position * (1.0/37.5))  * 0.125);\n}\n\n#if pattern ==1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float star = stars(0.999, uv) * ((sin(iTime) +1.) / 2.);\n    star += stars(0.998, uv) * 0.5;\n    star += stars(0.995, uv) * 0.3;\n    \n\tfragColor = vec4(vec3(star),1.0);\n}\n#elif pattern ==5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    \n   \n    float amplitude = 0.01;\n    vec4 x = texture(iChannel0, uv);\n   \tfloat X = uv.y*25. + iTime;\n    float Y = uv.x*25. + iTime;        \n    uv.x += amplitude * cos(X - Y);\n    uv.y += amplitude * cos(Y + X);\n    \n   vec4 color = texture(iChannel0, uv);\n    \n    fragColor = color;\n}\n\n#elif pattern ==4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 blue = vec3(0.,0.,1.);\n    vec3 yellow = vec3(1.,1.,0.);\n    float n1 = mountain1(fragCoord.x + iTime*200.);\n    fragCoord.x +=500.;\n    float n2 = mountain1(fragCoord.x+ iTime*100.);\n    fragCoord.x -=5000.;\n    float n3= mountain1(fragCoord.x+ iTime*50.);\n    fragCoord.x +=50000.;\n    float n4= mountain1(fragCoord.x+ iTime*25.);\n    fragCoord.x +=500.;\n    float n5= mountain1(fragCoord.x+ iTime*12.5);\n    \n    float ypos = fragCoord.y/iResolution.y;\n    float y = 2.0 * (ypos) - 0.1; \n    float y2 = 2.0 * (ypos) - 0.4;\n    float y3= 2.0 * (ypos) - 0.6 ;\n    float y4= 2.0 * (ypos) - 0.8;\n    float y5= 2.0 * (ypos) - 1.;\n    vec3 color = mix(yellow, blue, ypos);\n    \n\n    if(n5 >  y5) color = vec3(0.,0.,0.41);\n    if(n4 >  y4) color = vec3(0.,0.,0.31);\n    if(n3 >  y3) color = vec3(0.,0.,0.21);\n    if(n2 >  y2) color = vec3(0.,0.,0.11);\n    if(n1 >  y) color = vec3(0.,0.,0.01);\n    \n\tfragColor = vec4(color, 1.0);\n}\n\n#elif pattern ==2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 colorA = vec3(73./255., 56./255., 41.0/255.);\n    vec3 colorB = vec3(133.0/255., 87.0/255., 35.0/255.);\n    vec3 colorC = vec3(169./255., 161./255., 140./255.);\n    \n    float mask = fbm(uv.xx* 18.);\n  \t\n    vec3 color = mix(colorA, colorB, mask);\n    color -= noise2(uv * vec2(500., 14.) + noise2(uv * vec2(1000., 64.))) * 0.13;\n \t\n\tfragColor = vec4(color,1.0);\n}\n\n#elif pattern ==3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy / iResolution.yy;\n    vec4 glass = texture(iChannel2, uv);\n    uv.x += glass.g ;\n    \n    uv*=50.;\n    vec2 p = vec2(fbm(uv)+1.);\n    float c = length(p);\n    vec3 col;\n    col=vec3(0.6,0.7,0.8+.05*p.y)*c/5.;\n\tfragColor = vec4(col,1.0);\n}\n\n#elif pattern ==6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 rnd = vec2(random(uv));\n    \n    uv += rnd * 0.02;\n    fragColor = texture(iChannel1, uv);\n}\n\n#elif pattern ==7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 glass = texture(iChannel2, uv) * 1.;\n    uv.y += glass.y;\n    \n    fragColor = texture(iChannel1, uv);\n}\n\n#elif pattern ==8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv +=  step(0.7, random(uv + iTime) );\n    \n    fragColor = texture(iChannel1, uv);\n    //fragColor = vec4(vec3(step(0.5, random(uv + iTime))), 1.);\n}\n\n#elif pattern == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 rain = texture(iChannel0,vec2(uv.x,uv.y+iTime)) * 0.05;\n\tuv -= rain.xy;\n\tvec4 rainy = texture(iChannel1,uv);\n\t\n\tfragColor = rainy;\n}\n\n#elif pattern == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 rainy = texture(iChannel1,uv);\n\t\n\tfragColor = rainy;\n}\n\n\n#endif","name":"Image","description":"","type":"image"}]}