{"ver":"0.1","info":{"id":"MclczB","date":"1721317618","viewed":299,"name":"[zznewclear13] Procedural Lizard","username":"zznewclear13","description":"A procedurally animated lizard based on [url]https://youtu.be/qlfh_rv6khY[/url].\nInteractable with iMouse.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Procedural Lizard\n// https://www.shadertoy.com/view/MclczB\n// \n// A procedurally animated lizard based on \n// argonaut's (A simple procedural animation technique)[https://youtu.be/qlfh_rv6khY].\n// Interactable with iMouse.\n\n// Uncomment thiss line to draw rings.\n// #define DRAW_RING\n\nconst float anchorSize[ANCHOR_COUNT] = float[ANCHOR_COUNT](\n    0.030f,\n    0.052f, 0.058f, 0.040f, 0.060f,\n    0.068f, 0.071f, 0.065f, 0.050f,\n    0.028f, 0.015f, 0.011f, 0.009f,\n    0.007f, 0.007f, 0.007f\n);\nconst float footSize[FOOT_COUNT] = float[FOOT_COUNT](\n    0.03f, 0.03f, 0.035f, 0.035f\n);\n\nconst float thickness = 0.004f;\nconst vec2 eyeSize = vec2(0.01f, 0.005f);\nconst vec3 backgroundColor = vec3(0.15f, 0.16f, 0.21f);\nconst vec3 lizardColor = vec3(0.2f, 0.4f, 0.35f);\nconst vec3 outlineColor = vec3(0.94f, 0.98f, 0.96f);\nconst vec3 footColor = vec3(0.64f, 0.12f, 0.11f);\n\nvec4 loadFromTexel(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nfloat drawRing(vec2 uv, float fw, vec2 center, float radius, float thickness)\n{\n    float sdRing = distance(uv, center) - radius;\n    float ringAlpha = smoothstep(thickness + fw, thickness, abs(sdRing));\n    return ringAlpha;\n}\n\nfloat drawCircle(vec2 uv, float fw, vec2 center, float radius)\n{\n    float sdCircle = distance(uv, center) - radius;\n    float circleAlpha = smoothstep(fw, 0.0f, sdCircle);\n    return circleAlpha;\n}\n\n// https://www.shadertoy.com/view/4lcBWn\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nconst mat4 characterMat = mat4(0.0f, -1.0f, 2.0f, -1.0f,\n                                2.0f, 0.0f, -5.0f, 3.0f,\n                                0.0f, 1.0f, 4.0f, -3.0f,\n                                0.0f, 0.0f, -1.0f, 1.0f);\n\n// https://www.mvps.org/directx/articles/catmull/\nvec3 catmull_rom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    vec4 tVec = vec4(1.0f, t, t*t, t*t*t);\n    vec4 px = vec4(p0.x, p1.x, p2.x, p3.x);\n    vec4 py = vec4(p0.y, p1.y, p2.y, p3.y);\n    vec4 pz = vec4(p0.z, p1.z, p2.z, p3.z);\n    \n    float xPos = 0.5f * dot(tVec, characterMat * px);\n    float yPos = 0.5f * dot(tVec, characterMat * py);\n    float zPos = 0.5f * dot(tVec, characterMat * pz);\n    return vec3(xPos, yPos, zPos);    \n}\n\n// Stolen from fad on Shadertoy's discord server, modified for catmull_rom\nfloat sdBody(vec2 p, vec3 anchorPosRad[ANCHOR_COUNT], int samples)\n{\n    float dist = 1e30;\n\n    vec3 p0 = anchorPosRad[0];\n    \n    for (int i=0; i<ANCHOR_COUNT-3; ++i)\n    {\n        vec3 a = anchorPosRad[i+0];\n        vec3 b = anchorPosRad[i+1];\n        vec3 c = anchorPosRad[i+2];\n        vec3 d = anchorPosRad[i+3];\n        for (int j=0; j<samples; ++j)\n        {\n            float t = float(j) / float(samples);\n            vec3 p1 = catmull_rom(a, b, c, d, t);\n            dist = min(dist, sdUnevenCapsule(p, p0.xy, p1.xy, p0.z, p1.z));\n            p0 = p1;\n        }\n    }\n\n    return dist;\n}\n\nfloat sdFoot(vec2 p, vec3 anchorPosRad[ANCHOR_COUNT], int footIndex, int anchorIndex)\n{\n    vec3 f0 = loadFromTexel(footIndex, 1).xyz;\n    vec2 f1 = loadFromTexel(footIndex+FOOT_COUNT, 1).xy;\n    vec2 f = mix(f0.xy, f1, max(f0.z, 0.0f));\n    vec2 a = anchorPosRad[anchorIndex].xy;\n    float s = footSize[footIndex];\n    return sdUnevenCapsule(p, a, f, s * 1.2f, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5f) / iResolution.y;\n    float fw = 1.0f / iResolution.y;\n    \n    vec2 target = loadFromTexel(0, 2).xy;\n    if (iMouse.z > 0.0f) target = (iMouse.xy - iResolution.xy * 0.5f) / iResolution.y;\n    \n    float targetAlpha = drawCircle(uv, fw, target, 0.01f);\n    vec3 color = mix(backgroundColor, outlineColor, targetAlpha);\n\n#ifdef DRAW_RING\n    float bodyAlpha = 0.0f;\n    for (int i=0; i<ANCHOR_COUNT; ++i)\n    {\n        vec2 center = loadFromTexel(i, 0).xy;\n        float radius = anchorSize[i];\n        float ringAlpha = drawRing(uv, fw, center, radius, thickness);\n        bodyAlpha = max(ringAlpha, bodyAlpha);\n    }\n    color = mix(color, outlineColor, bodyAlpha);\n    \n    float footAlpha = 0.0f;\n    for (int i=0; i<FOOT_COUNT; ++i)\n    {\n        vec3 f0 = loadFromTexel(i, 1).xyz;\n        vec2 f1 = loadFromTexel(i+FOOT_COUNT, 1).xy;\n        vec2 center = mix(f0.xy, f1, max(f0.z, 0.0f));\n        float radius = 0.05f;\n        float ringAlpha = drawRing(uv, fw, center, radius, thickness);\n        footAlpha = max(ringAlpha, footAlpha);\n    }\n    color = mix(color, footColor, footAlpha);\n#else\n    vec3 anchorPosRad[ANCHOR_COUNT];\n    for (int i=0; i<ANCHOR_COUNT; ++i)\n    {\n        anchorPosRad[i] = vec3(loadFromTexel(i, 0).xy, anchorSize[i]);\n    }\n    \n    float sdLizardFoot = 1e5;\n    sdLizardFoot = min(sdFoot(uv, anchorPosRad, 0, FRONT_ANCHOR), sdLizardFoot);\n    sdLizardFoot = min(sdFoot(uv, anchorPosRad, 1, FRONT_ANCHOR), sdLizardFoot);\n    sdLizardFoot = min(sdFoot(uv, anchorPosRad, 2, BACK_ANCHOR), sdLizardFoot);\n    sdLizardFoot = min(sdFoot(uv, anchorPosRad, 3, BACK_ANCHOR), sdLizardFoot);\n    float footAlpha1 = smoothstep(fw, 0.0f, sdLizardFoot);\n    float footAlpha2 = smoothstep(fw, 0.0f, sdLizardFoot + thickness);\n    vec3 foot = mix(outlineColor, lizardColor, footAlpha2);\n    color = mix(color, foot, footAlpha1);\n\n    float sdLizard = 1e5;\n    float sdLizardBody = sdBody(uv, anchorPosRad, 5);   \n    float lizardAlpha1 = smoothstep(fw, 0.0f, sdLizardBody);\n    float lizardAlpha2 = smoothstep(fw, 0.0f, sdLizardBody + thickness);\n    vec3 lizard = mix(outlineColor, lizardColor, lizardAlpha2);\n    color = mix(color, lizard, lizardAlpha1);\n    \n    vec2 forward = normalize(anchorPosRad[0].xy - anchorPosRad[1].xy);\n    vec2 offset1 = getOrientedOffset(forward, vec2(0.02f, 0.03f));\n    vec2 offset2 = getOrientedOffset(forward, vec2(0.02f, -0.03f));\n    vec2 eyeCenter1 = anchorPosRad[1].xy + offset1;\n    vec2 eyeCenter2 = anchorPosRad[1].xy + offset2;\n    float eyeAlpha1 = drawCircle(uv, fw, eyeCenter1, eyeSize.x);\n    float eyeAlpha2 = drawCircle(uv, fw, eyeCenter2, eyeSize.x);\n    vec2 toTarget = normalize(target - anchorPosRad[0].xy);\n    float weight = max(dot(toTarget, forward), 0.0f);\n    toTarget = mix(forward, toTarget, vec2(weight));\n    float eyeAlpha3 = drawCircle(uv, fw, eyeCenter1 + toTarget * 0.5f * eyeSize.x, eyeSize.x);\n    float eyeAlpha4 = drawCircle(uv, fw, eyeCenter2 + toTarget * 0.5f * eyeSize.x, eyeSize.x);\n    vec3 eye = mix(outlineColor, backgroundColor, max(eyeAlpha3, eyeAlpha4));\n    color = mix(color, eye, max(eyeAlpha1, eyeAlpha2));\n#endif\n    \n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Updates anchors.\n\nconst vec2 speed = vec2(0.5f / 60.0f, 2.5f / 60.0f);\nconst float boneLength[BONE_COUNT] = float[BONE_COUNT](\n    0.05f,\n    0.05f, 0.05f, 0.05f, 0.05f,\n    0.05f, 0.05f, 0.05f, 0.05f,\n    0.05f, 0.05f, 0.05f, 0.05f,\n    0.05f, 0.05f\n);\n\nvoid saveToTexel(ivec2 iFragCoord, int x, int y, vec4 valueToSave, inout vec4 prevVal)\n{\n    if(iFragCoord.x == x && iFragCoord.y == y)\n    {\n        prevVal = valueToSave;\n    }\n}\n\nvec4 loadFromTexel(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid initAnchors(vec2 center, out vec2 anchorPos[ANCHOR_COUNT], out vec2 footPos[FOOT_COUNT])\n{\n    anchorPos[0] = center;\n    for (int i=0; i<BONE_COUNT; ++i)\n    {\n        anchorPos[i+1] = anchorPos[i] - vec2(boneLength[i], 0.0f);\n    }\n    \n    footPos[0] = anchorPos[FRONT_ANCHOR] + vec2(0.03f, 0.04f);\n    footPos[1] = anchorPos[FRONT_ANCHOR] + vec2(0.03f, -0.04f);\n    footPos[2] = anchorPos[BACK_ANCHOR] + vec2(0.03f, 0.05f);\n    footPos[3] = anchorPos[BACK_ANCHOR] + vec2(0.03f, -0.05f);\n}\n\nvec2 updatePos(vec2 p1, vec2 p2, float len)\n{\n    vec2 dir = p2 - p1;\n    float lenDir = length(dir);\n    dir /= lenDir;\n    return p2 - dir * len;\n}\n\nvec2 updatePosClamp(vec2 p1, vec2 p2, inout vec2 forward, float angleLimit, vec2 speed, bool keep)\n{\n    vec2 dir = p2 - p1;\n    float lenDir = length(dir);\n    if (lenDir == 0.0f || keep) return p1 + speed.x * forward;\n    \n    dir /= lenDir;\n    float DoF = dot(dir, forward);\n    float signVal = cro(dir, forward) >= 0.0f ? 1.0f : -1.0f;\n    float angularSpeed = speed.y;\n    if (DoF >= angleLimit)\n    {\n        float maxOffset = sqrt(1.0f - DoF * DoF) / DoF;\n        angularSpeed = min(2.0f * speed.y, maxOffset);\n    }\n\n    forward = normalize(forward + vec2(forward.y, -forward.x) * angularSpeed * signVal);\n    return p1 + speed.x * forward;\n}\n\nvoid updateAnchors(inout vec2 anchorPos[ANCHOR_COUNT], inout vec2 forward, vec2 mousePos, bool keep)\n{\n    anchorPos[0] = updatePosClamp(anchorPos[0], mousePos, forward, 0.8f, speed, keep);\n    for (int i=0; i<BONE_COUNT; ++i)\n    {\n        anchorPos[i+1] = updatePos(anchorPos[i+1], anchorPos[i], boneLength[i]);\n    }\n}\n\nbvec4 updateFeet(in vec2 anchorPos[ANCHOR_COUNT], in vec3 footPos[FOOT_COUNT], out vec3 newFootPos[FOOT_COUNT])\n{\n    bvec4 shouldUpdate = bvec4(false, false, false, false);\n    vec2 fForward1 = normalize(anchorPos[FRONT_ANCHOR-1] - anchorPos[FRONT_ANCHOR]);\n    vec2 fForward2 = normalize(anchorPos[FRONT_ANCHOR-2] - anchorPos[FRONT_ANCHOR-1]);\n    vec2 bForward1 = normalize(anchorPos[BACK_ANCHOR-1] - anchorPos[BACK_ANCHOR]);\n    vec2 bForward2 = normalize(anchorPos[BACK_ANCHOR-2] - anchorPos[BACK_ANCHOR-1]);\n    float fCurve = cro(fForward1, fForward2);\n    float bCurve = cro(fForward1, fForward2);\n    \n\n    float dFL = dot(footPos[0].xy - anchorPos[FRONT_ANCHOR], fForward1);\n    float dFR = dot(footPos[1].xy - anchorPos[FRONT_ANCHOR], fForward1);\n    float dBL = dot(footPos[2].xy - anchorPos[BACK_ANCHOR], bForward1);\n    float dBR = dot(footPos[3].xy - anchorPos[BACK_ANCHOR], bForward1);\n    shouldUpdate = lessThan(vec4(dFL, dFR, dBL, dBR), vec4(-0.03f, -0.03f, -0.045f, -0.045f));\n    \n    newFootPos[0] = vec3(anchorPos[FRONT_ANCHOR-1] + getOrientedOffset(fForward1, vec2(0.060f + fCurve * 0.1f, 0.05f - fCurve * 0.1f)), 1.0f);\n    newFootPos[1] = vec3(anchorPos[FRONT_ANCHOR-1] + getOrientedOffset(fForward1, vec2(0.060f - fCurve * 0.1f, -0.05f - fCurve * 0.1f)), 1.0f);\n    newFootPos[2] = vec3(anchorPos[BACK_ANCHOR-1] + getOrientedOffset(bForward1, vec2(0.070f + bCurve * 0.15f, 0.065f - bCurve * 0.15f)), 1.0f);\n    newFootPos[3] = vec3(anchorPos[BACK_ANCHOR-1] + getOrientedOffset(bForward1, vec2(0.070f - bCurve * 0.15f, -0.065f - bCurve * 0.15f)), 1.0f);     \n    return shouldUpdate;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFrame == 0)\n    {\n        vec4 initVal = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec2 anchorPos[ANCHOR_COUNT];\n        vec2 footPos[FOOT_COUNT];\n        initAnchors(vec2(0.0f, 0.0f), anchorPos, footPos);\n        if (iFragCoord.x < ANCHOR_COUNT)\n        {\n            vec4 valToSave = vec4(anchorPos[iFragCoord.x], 0.0f, 0.0f);\n            saveToTexel(iFragCoord, iFragCoord.x, 0, valToSave, initVal);\n        }\n        if (iFragCoord.x < 2*FOOT_COUNT)\n        {\n            vec4 valToSave = vec4(footPos[iFragCoord.x%FOOT_COUNT], 0.0f, 0.0f);\n            saveToTexel(iFragCoord, iFragCoord.x, 1, valToSave, initVal);\n        }\n             \n        vec2 target = hash21(iDate.w) - 0.5f;\n        // target\n        saveToTexel(iFragCoord, 0, 2, vec4(target, 0.0f, 0.0f), initVal);\n        // forward\n        saveToTexel(iFragCoord, 1, 2, vec4(1.0f, 0.0f, 0.0f, 0.0f), initVal);\n        // hungry\n        saveToTexel(iFragCoord, 2, 2, vec4(0.0f, 0.0f, 0.0f, 0.0f), initVal);\n        // full\n        saveToTexel(iFragCoord, 3, 2, vec4(0.0f, 0.0f, 0.0f, 0.0f), initVal);\n        fragColor = initVal;\n        return;\n    }\n\n    vec4 prevVal = loadFromTexel(iFragCoord.x, iFragCoord.y);\n    vec2 target = loadFromTexel(0, 2).xy; \n    if (iMouse.z > 0.0f) target = (iMouse.xy - iResolution.xy * 0.5f) / iResolution.y;\n    \n    vec2 anchorPos[ANCHOR_COUNT];\n    for (int i=0; i<ANCHOR_COUNT; ++i)\n    {\n        anchorPos[i] = loadFromTexel(i, 0).xy;\n    }\n    vec3 footPos[FOOT_COUNT];\n    for (int i=0; i<FOOT_COUNT; ++i)\n    {\n        footPos[i] = loadFromTexel(i, 1).xyz - vec3(0.0f, 0.0f, iTimeDelta * 10.0f);\n    }\n    \n    vec2 forward = loadFromTexel(1, 2).xy;\n    float hungry = loadFromTexel(2, 2).x + iTimeDelta;\n    float full = loadFromTexel(3, 2).x - iTimeDelta;\n    bool newTarget = false;\n    updateAnchors(anchorPos, forward, target, full>0.0f);\n    vec3 newFootPos[FOOT_COUNT];\n    bvec4 shouldUpdateFeet = updateFeet(anchorPos, footPos, newFootPos);\n    if (iFragCoord.x < 2 * FOOT_COUNT)\n    {\n        int footIndex = iFragCoord.x % FOOT_COUNT;\n        bool shouldUpdate = shouldUpdateFeet[footIndex];\n        vec3 f1 = footPos[footIndex];\n        if (shouldUpdate)\n        {\n            vec3 f0 = newFootPos[footIndex];     \n            saveToTexel(iFragCoord, footIndex, 1, vec4(f0, 0.0f), prevVal);\n            saveToTexel(iFragCoord, footIndex + FOOT_COUNT, 1, vec4(f1, 0.0f), prevVal);\n        }\n        else\n        {\n            saveToTexel(iFragCoord, footIndex, 1, vec4(f1, 0.0f), prevVal);\n        }\n    } \n    \n    if (iFragCoord.x < ANCHOR_COUNT)\n    {\n        vec4 valToSave = vec4(anchorPos[iFragCoord.x], 0.0f, 0.0f);\n        saveToTexel(iFragCoord, iFragCoord.x, 0, valToSave, prevVal);\n    }\n    \n    saveToTexel(iFragCoord, 1, 2, vec4(forward, 0.0f, 0.0f), prevVal);\n    if (distance(anchorPos[0], target) <= 0.01f)\n    {\n        full = 0.4f;\n        newTarget = true;\n    }\n    \n    if (iMouse.z <= 0.0f && (newTarget || hungry > 5.0f))\n    {\n        target = hash21(iDate.w) - 0.5f;\n        saveToTexel(iFragCoord, 0, 2, vec4(target, 0.0f, 0.0f), prevVal);\n        hungry = 0.0f;\n    }\n    saveToTexel(iFragCoord, 2, 2, vec4(hungry, 0.0f, 0.0f, 0.0f), prevVal);\n    saveToTexel(iFragCoord, 3, 2, vec4(full, 0.0f, 0.0f, 0.0f), prevVal);\n    \n    \n    fragColor = prevVal;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int ANCHOR_COUNT = 16;\nconst int BONE_COUNT = ANCHOR_COUNT - 1;\nconst int FOOT_COUNT = 4;\n\nconst int FRONT_ANCHOR = 4;\nconst int BACK_ANCHOR = 7;\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 getOrientedOffset(vec2 forward, vec2 offset)\n{\n    return forward * offset.x + vec2(forward.y, -forward.x) * offset.y;\n}\n","name":"Common","description":"","type":"common"}]}