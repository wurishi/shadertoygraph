{"ver":"0.1","info":{"id":"WsB3RV","date":"1549311110","viewed":127,"name":"Raymarching shading test","username":"darkeclipz","description":"raymarching and testing blinn-phong shading, and some other stuff.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MinDistance 0.01\n#define MaxRaySteps 300.\n\nstruct hit { float dist; vec3 p; vec3 normal; bool shadow; float occlusion; };\n\n// https://iquilezles.org/articles/distfunctions\nfloat SphereDE(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat SphereRotDE(vec3 p, float r) {\n    float a = 1.1 ;\n    float c = cos(a*p.x), s = sin(-a*p.y);\n    mat3 rotY = mat3(c*p.x, 0, s,  0, 1, 0,  s*p.x, 0, c);\n\treturn length(rotY*p) - r;\n}\n\nfloat YPlaneDE(vec3 p, float y) {\n    float z1 = cos(2.*p.x) + sin(2.*p.z);\n\treturn p.y - y - z1 * 0.075;\n}\n\nfloat scene(vec3 p) {\n    \n    float a1 = YPlaneDE(p, -0.9),\n          a2 = SphereRotDE(p, 0.3),\n          a3 = SphereDE(p - vec3(1.*cos(iTime), 0.,-1.*sin(iTime)), 0.1),\n          a4 = SphereDE(p - vec3(1.*cos(1.2*iTime+0.25), 0.05,-1.*sin(1.2*iTime+0.25)), 0.05),\n          a5 = SphereDE(p - vec3(1.*cos(1.2*iTime+4.8), -.4,-1.*sin(1.2*iTime+4.8)), 0.05),\n          a6 = SphereDE(p - vec3(1.*cos(-1.2*iTime+3.55), 0.5,-1.*sin(-1.2*iTime+3.55)), 0.05),\n          a7 = SphereDE(p - vec3(1.2*cos(-1.2*iTime+5.88), 0.2,-1.2*sin(-1.2*iTime+5.88)), 0.05);\n    \n\treturn min(a1, min(a2, min(a3, min(a4, min(a5, min(a6, a7))))));\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nhit trace(vec3 o, vec3 r) {\n\tfloat t = 0., steps, occlusion = 0.;\n    vec3 normal = vec3(0);\n    for(steps=0.; steps < MaxRaySteps; steps++) {\n    \tvec3 p = o + t*r;\n        float d = scene(p);\n        t += d;\n        if(d < MinDistance) {\n            p = o + (t-d)*r;\n            float h = 0.0001;\n            vec2 k = vec2(1,-1);\n            vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                           k.yyx*scene( p + k.yyx*h ) + \n                           k.yxy*scene( p + k.yxy*h ) + \n                           k.xxx*scene( p + k.xxx*h ) ); \n            return hit(t-d, p, n, false, 1. - steps / MaxRaySteps);\n        }\n    }\n    return hit(0., vec3(0), vec3(0), false, 0.);\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 8.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 light(vec3 p, vec3 viewDir, vec3 normal) {\n    vec3 c1 = shadeBlinnPhong(p, viewDir, normal, vec3(1.*cos(iTime), 0.,-1.*sin(iTime)), 0.25, cos(iTime + vec3(0,2,4)));\n    vec3 c2 = shadeBlinnPhong(p, viewDir, normal, vec3(1.*cos(iTime), 0.,-1.*sin(iTime)), 0.25, cos(iTime + vec3(0,2,4)) + 1.);\n    vec3 c3 = shadeBlinnPhong(p, viewDir, normal, vec3(1.*cos(1.2*iTime+0.25), 0.05,-1.*sin(1.2*iTime+0.25)), 0.25, cos(iTime + vec3(0,2,4) + 2.));\n    vec3 c4 = shadeBlinnPhong(p, viewDir, normal, vec3(1.*cos(-1.2*iTime+3.55), 0.5,-1.*sin(-1.2*iTime+3.55)), 0.25, cos(iTime + vec3(0,2,4) + 3.));\n    vec3 c5 = shadeBlinnPhong(p, viewDir, normal, vec3(1.*cos(-1.2*iTime+5.88), 0.2,-1.*sin(-1.2*iTime+5.88)), 0.25, cos(iTime + vec3(0,2,4) + 4.));\n    vec3 c6 = shadeBlinnPhong(p, viewDir, normal, vec3(15,15,-15), 200., vec3(1));\n    \n    vec3 ambientColor = vec3(0.1);\n    \n    return c1 + c2 + c3 + c4 + c5 + c6 + ambientColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-R)/iResolution.y;\n    vec3 o = vec3(0,0,-5);\n    vec3 r = normalize(vec3(uv, 0) - o);\n    hit h = trace(o, r);\n    \n    vec3 col = vec3(0); \n    if(h.dist > 0.) col = light(h.p, r, h.normal) * h.occlusion;\n    else col = mix( vec3(0,70./200.,128./200.), vec3(0,24./200.,45./200.),uv.y);\n    \n    //col = mix(col, vec3(1,0,0), 1.-h.occlusion); // iteration count map\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}