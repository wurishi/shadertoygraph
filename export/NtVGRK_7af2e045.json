{"ver":"0.1","info":{"id":"NtVGRK","date":"1638005601","viewed":133,"name":"mach ring","username":"ligaobo","description":"马赫环几何构建二维初步版本","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["machring","rockets","fighter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://thebookofshaders.com/13/\nfloat fbm(sampler2D sampler, vec2 p) {\n\t// Initial values\n\tfloat value = 0.;\n\tfloat amplitude = .5;\n\tfloat frequency = 1.;\n\t// Loop of octaves\n\tfor (int i = 0; i < 5; i++) {\n        value += amplitude * (texture(sampler, p*frequency).r);\n\t\tfrequency *= 2.;\n\t\tamplitude *= .5;\n\t}\n\treturn value;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n// outrs、inrs用于对空间进行缩放，以实现椭圆的绘制\nfloat machring(vec2 p, float R, float outrs, float inrs)\n{\n    vec2 c = vec2(0.0, R);\n    vec2 pc = p-c;\n    pc.y *= pc.y > 0.0? outrs: inrs;\n    float d = length(pc);\n    {\n        c = vec2(0.0, -R);\n        pc = p-c;\n        pc.y *= pc.y < 0.0? outrs: inrs;\n        d = opSmoothUnion(d, length(pc), 0.2);\n    }\n\n    return d;\n}\n\n//----------------------------------------------------------------\n\nconst float PI = float(3.14159265359);\n#define plot(v)     clamp( 1.- abs(v-y) / fwidth(v-y) , 0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelSize = 1.0 / min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) * pixelSize;\n    \n    p *= 2.0;\n    vec2 offset = iResolution.xy * pixelSize;\n\n    if(p.y > 0.0)\n    {\n        vec2 q = p - vec2(-2.0, 1.0) * offset;\n        q *= 8.0;\n        \n        //q.x += sin(fbm(iChannel0, vec2(iTime * 2.0, 0.0)));\n        float y = q.y;\n        //fragColor.rgb += vec3(0.0, 1.0, 1.0) * plot(1.0);\n        //fragColor.rgb += vec3(0.0, 1.0, 1.0) * plot(exp(q.x * 0.06));\n\n        // 在初始均匀压强场中，压力为1.0的等值线\n        y = abs(q.y) * exp(q.x * q.x * 0.002);\n        //fragColor.rgb += vec3(0.0, 1.0, 1.0) * plot(1.0);\n        \n        // 对空间的压缩（模拟压强场）\n        float R = 1.05;\n        float T = R * 2.0;\n        float x = mod(q.x*(0.5 + 0.1 * sin(fbm(iChannel0, vec2(iTime * 2.0, 0.0)))) + T * 0.5, T);\n\n        float outscale = 1.0 / 0.4; // \n        float inscale = 1.0 / 1.3; // 未压缩\n        float d = machring(vec2(x, y), R, outscale, inscale);\n        float d1 = machring(vec2(x - T, y), R, outscale, inscale);\n        d = opSmoothUnion(d, d1, 0.2);\n        \n        d -= R;\n        \n        if(abs(y) > R)\n        {\n            fragColor.rgb += vec3(0.6) * smoothstep(1.0, 0.0, d)\n                            * smoothstep(-0.3, 0.0, d);\n        }\n        else{\n            fragColor.rgb += vec3(0.6) * smoothstep(-0.3, 0.0, d)\n                        * smoothstep(0.1, 0.0, d)\n                        * smoothstep(-0.0, R, y);\n        }\n\n        fragColor.rgb *= smoothstep(16.0, 0.0, q.x * q.x * 0.005) \n                * smoothstep(T * 18.0, 0.0, q.x *y);\n\n        //vec2 lq = q * 0.005;\n        //lq.y *= exp(-lq.x * 20.0+1.0);\n        //lq.y *= exp(q.x);\n        //fragColor.rgb += fbm(iChannel0, lq - normalize(lq) * iTime * 0.01);\n    }\n    else\n    {\n        vec2 q = p - vec2(-2.0, -0.5) * offset;\n        q *= 8.0;\n        \n        q.x += sin(fbm(iChannel0, vec2(iTime * 2.0, 0.0)));\n        float y = q.y;\n        // 在初始均匀压强场中，压力为1.0的等值线\n        y = abs(q.y) * exp(q.x * q.x * 0.002);\n        \n        // 对空间的压缩（模拟压强场）\n        float R = 1.05;\n        float T = R * 2.0;\n        float x = mod(q.x*(0.5 + 0.1 * sin(fbm(iChannel0, vec2(iTime * 2.0, 0.0)))) + T * 0.5, T);\n        x-=0.3;\n\n        float outscale = 1.0 / 0.4; // \n        float inscale = 1.0 / 1.3; // 未压缩\n        float d = machring(vec2(x, y), R, outscale, inscale);\n        float d1 = machring(vec2(x - T, y), R, outscale, inscale);\n        d = opSmoothUnion(d, d1, 0.2);\n        \n        d -= R;\n        \n        if(abs(y) > R)\n        {\n            fragColor.rgb += vec3(0.6) * smoothstep(1.0, 0.0, d)\n                            * smoothstep(-0.3, 0.0, d);\n        }\n        else{\n            fragColor.rgb += vec3(0.6) * smoothstep(-0.3, 0.0, d)\n                        * smoothstep(0.1, 0.0, d)\n                        * smoothstep(-0.0, R, y);\n        }\n\n        fragColor.rgb *= smoothstep(16.0, 0.0, q.x * q.x * 0.005) \n                * smoothstep(T * 18.0, 0.0, q.x *y);\n        \n    }\n\n    fragColor.w = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}