{"ver":"0.1","info":{"id":"4XSSWG","date":"1711019117","viewed":90,"name":"Kaleidoscope Hexagons - shader","username":"DanielWooldridge","description":"This is my first shader, followed a tutorial but added and played around with it a lot","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://dev.thi.ng/gradients/ use this to create your own colour palettes\n\nvec3 palette (float t)\n{\n    vec3 a = vec3(0.500, 0.000, 0.500);\n    vec3 b = vec3(0.500, 0.000, 0.500);\n    vec3 c = vec3(0.500, 0.000, 0.500);\n    vec3 d = vec3(0.000, 0.000, 0.500);\n    \n    return a + b*cos(6.28318*(c*t+d));\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Making the resolution -1 to 1 on both the x and y axis \n    // AND Making the Center of the screen at 0,0 \n    // In this it also fixxes the aspect ratio so it doesnt distort\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y; // -> .xy means just x and y in a vec2 \n    \n    vec2 uv0 = uv; // this to save the originial distance before spacial repetition\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++)\n    {\n        // FRACT is very good for Spacial Repetition\n        uv = fract(uv * 1.2) - 0.5;\n        \n\n        //SDF -> term used to describe a function that takes a position in space as input and returns the distance from that position to a \n        //given shape, it is called sined because the distance is positive outisde the shape, negative inside the shape and exactly 0 at the \n        //boundary of the shape - > https://iquilezles.org/articles/distfunctions2d/\n        //float d = length(uv) * exp(-length(uv0)); // distance\n        \n        //float d = sdEquilateralTriangle(uv, 0.1) * exp(-length(uv0));\n        float d = sdHexagon(uv, 1.0) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i*.3 + iTime*.4);\n        d = sin(d*15. + iTime)/4.; // creates rings on screen, iTime makes it move\n        d = abs(d);\n        d = pow(0.01 / d, 1.0); // Inverse of d\n\n        finalColor += col * d;\n    }\n    // Setting each pixel colour\n    fragColor = vec4(finalColor, 1.0);\n    \n    \n    \n}\n\n//6.28318\n// To get a neon effect, Inverse function 1/x if great!","name":"Image","description":"","type":"image"}]}