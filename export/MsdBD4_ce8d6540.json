{"ver":"0.1","info":{"id":"MsdBD4","date":"1525249445","viewed":831,"name":"Extreme Desert","username":"dr2","description":"Desert flyover with changing lighting (look around with mouse)","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["terrain","lighting","sand","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Extreme Desert\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Desert flyover with changing lighting (look around with mouse)\n\n  Based on earlier 'Terrain Explorer' with terrain option derived from 'Sirenian Dawn'\n  by nimitz; sand ripples use waveform from 'Rock Garden'.\n\n  Motivation from Shane's 'Desert Sand'\n*/\n\n#define FAST_SUN  1    // (0/1) fast lighting changes\n#define AA        0    // (0/1) optional antialiasing\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2s (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar, gFac, hFac, fWav, aWav, smFac, stepFac;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec3 v;\n  vec2 q, t;\n  float wAmp, wp, tp, f;\n  q = gFac * p;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * fWav;\n  wAmp = 1.;\n  t = vec2 (0.);\n  wp = aWav;\n  tp = 5.;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (tp)) - v.yz;\n    tp -= 1.;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - wp;\n    wp *= smFac;\n    q *= qRot;\n  }\n  return hFac * (1. + 6. * f / (1. + smoothstep (-0.5, 1.5, f)));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstFar) break;\n    sLo = s;\n    s += stepFac * (max (0.3, 0.6 * h) + 0.008 * s);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2s (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2s (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.5, 0.5, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (0.9), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec2 e = vec2 (1., 0.);\n  return (sd.z > 0.) ? 0.1 * pow (abs (sd.z), 4.) *\n     (2. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n     e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n     e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n     e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy))) : vec3 (0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dstGrnd, f, spec, sh, dFac;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro, dstGrnd);\n    f = 0.2 + 0.6 * smoothstep (0.7, 1.1, 2. * Fbm2s (16. * ro.xz));\n    col = mix (mix (vec3 (0.75, 0.5, 0.1), vec3 (0.65, 0.4, 0.1), f),\n       mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.4), f), smoothstep (1., 3., ro.y));\n    col = mix (vec3 (0.7, 0.6, 0.4), col, smoothstep (0.2, 0.5, vn.y));\n    spec = mix (0.05, 0.1, smoothstep (2., 3., ro.y));\n    dFac = 1. - smoothstep (0.3, 0.4, dstGrnd / dstFar);\n    if (dFac > 0. && vn.y > 0.85) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.85, 0.9, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 6. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    if (dFac > 0.) vn = VaryNf (8. * ro, vn, dFac);\n    sh = 0.3 + 0.7 * smoothstep (0.3, 0.7, Fbm2 (0.1 * ro.xz + 1.3 * tCur));\n    col *= 0.2 + sh * (0.1 * vn.y + 0.7 * max (0., dot (vn, sunDir)) +\n       0.1 * max (0., dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy))) +\n       spec * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    col *= 0.8 + 0.2 * dFac;\n    col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 g, w;\n  float f, c, s;\n  v = normalize (v);\n  g = cross (v, vec3 (0., 1., 0.));\n  if (g.y != 0.) {\n    g.y = 0.;\n    w = normalize (cross (g, v));\n  } else w = vec3 (0., 1., 0.);\n  f = v.z * a.x - v.x * a.z;\n  f = - clamp (2. * f, -0.2 * pi, 0.2 * pi);\n  c = cos (f);\n  s = sin (f);\n  w = normalize (cross (w, v));\n  return mat3 (w, cross (v, w), v) * mat3 (c, s, 0., - s, c, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv, uvv, ori, ca, sa;\n  float el, az, sunEl, sunAz, dt, tCur, flyVel, mvTot, h, hSum, nhSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 3600.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  gFac = 0.07;\n  hFac = 1.5;\n  fWav = 1.9;\n  aWav = 0.45;\n  smFac = 0.65;\n  flyVel = 3.;\n  dstFar = 120.;\n  stepFac = 0.35;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  mvTot = flyVel * tCur;\n  ro = TrackPath (mvTot);\n  dt = 1.;\n  fpF = TrackPath (mvTot + dt);\n  fpB = TrackPath (mvTot - dt);\n  flMat = EvalOri ((fpF - fpB) / (2. * dt), (fpF - 2. * ro + fpB) / (dt * dt));\n  hSum = 0.;\n  nhSum = 0.;\n  for (float fk = -1.; fk <= 5.; fk ++) {\n    hSum += GrndHt (TrackPath (mvTot + 0.5 * fk).xz);\n    ++ nhSum;\n  }\n  ro.y = 6. * hFac + hSum / nhSum;\n#if FAST_SUN\n  sunAz = 0.03 * 2. * pi * tCur;\n#else\n  sunAz = 0.01 * 2. * pi * tCur;\n#endif\n  sunEl = pi * (0.2 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunAz) * cos (sunEl), sin (sunEl), sin (sunAz) * cos (sunEl));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.), 0.5 * pi * (a + 0.5));\n    rd = normalize (vec3 (uvv, 2.5));\n    rd = vuMat * rd;\n    rd = flMat * rd;\n    col += (1. / naa) * (ShowScene (ro, rd) + GlareCol (rd, sunDir * vuMat, uvv));\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n","name":"Image","description":"","type":"image"}]}