{"ver":"0.1","info":{"id":"XtyGzh","date":"1472935029","viewed":4795,"name":"Lindenmayer Systems","username":"sillsm","description":"Trees with breeze","likes":144,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","ifs","lsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n//\n// Real time lindenmayer systems.\n// Reference: http://algorithmicbotany.org/papers/abop/abop-ch1.pdf\n// Figures d, e, f from pg. 25. \"Bracketed OL systems\".\n// \n// Inspired by Knighty's using base n encodings to explore\n// n-ary IFS. Bounding volumes are trash.\n//\n// Enormous thanks to iq for numerous bugfixes and optimizations!\n#define PI 3.14159\n#define MAXDEPTH 7\n\nmat3 Rot (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n); \n}\n\nmat3 Disp (vec2 displacement)\n{\nreturn  mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(displacement, 1)\n); \n}\n\nfloat sdCappedCylinder( vec2 p, vec2 h )\n{\n  p -= vec2(0.,h.y);\n  vec2 d = abs(vec2(length(p.x),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat left(vec2 pt)\n{\n    mat3 posR = Rot(-(20./360.)*2.*PI);\n    mat3 negR = Rot(20./360.*2.*PI);\n    \n    const int depth = 6;\n    const int branches = 3; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.7;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = sdCappedCylinder(pt-vec2(0.,0.), vec2(wid,len));\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    \n    for (int count = 0; count <= 100; ++count){\n      int off = int(pow(float(branches), float(depth)));\n        \n      vec2 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n         \n        //\n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx=posR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(0.5*sin(iTime + 2.));\n          mx = wind*posR * Disp(vec2(0,-4.*l));\n\t    }\n\t    else if(path == 2){\n          mat3 wind = Rot(0.2*sin(iTime));\n          mx = wind*negR * Disp(vec2(0,-4.*l));\n\t    }\n        pt_n = (mx * vec3(pt_n,1)).xy;\n        float y = sdCappedCylinder(pt_n, vec2(wid,l));\n        \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-2.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk);\n}\n\nfloat center(vec2 pt)\n{\n    \n    mat3 posR = Rot(-(25.7/360.)*2.*PI);\n    mat3 negR = Rot(25.7/360.*2.*PI);\n    \n    const int depth = 7;\n    const int branches = 3; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.7;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = sdCappedCylinder(pt-vec2(0.,0.), vec2(wid,len));\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    for (int count = 0; count <= 100; ++count){\n      int off = int(pow(float(branches), float(depth)));\n      vec2 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n          \n        \n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx = posR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(0.2*sin(iTime+6.2));\n          mx = wind*negR*Disp(vec2(0,-2.*l));\n\t    }\n\t    else if(path == 2){\n          mat3 wind = Rot(0.2*sin(iTime+1.));\n          mx = wind*Disp(vec2(0,-4.*l)) ;\n\t    }\n        \n        pt_n = (mx * vec3(pt_n,1)).xy;\n        float y = sdCappedCylinder(pt_n, vec2(wid,l));   \n          \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-2.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk); \n}\n\n// Primitive shape for the right l-system.\nfloat right_p(vec2 pt, float wid, float len)\n{\n    mat3 posR = Rot(-(22.5/360.)*2.*PI);\n    \n    float t1 = sdCappedCylinder(pt, vec2(wid,len));\n    vec2 pt_t2 = (posR*Disp(vec2(0,-2.*len))* vec3(pt,1)).xy;\n    float t2= sdCappedCylinder(pt_t2, vec2(wid,len/2.));\n    return min(t1, t2);\n}\n\nfloat right(vec2 pt)\n{\n    mat3 posR = Rot(-(22.5/360.)*2.*PI);\n    mat3 negR = Rot(22.5/360.*2.*PI);\n    \n    const int depth = 4;\n    const int branches = 4; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.3;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = right_p(pt, wid, len);\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    for (int count = 0; count <= 110; ++count){\n    \n    int off = int(pow(float(branches), float(depth)));\n    vec2 pt_n = pt;\n                \n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n        \n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx = negR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(.6*sin(iTime/2.));\n\t\t  mx = wind*negR*Disp(vec2(0,-4.*l));\n\t    }\n        else if(path == 2){\n          // This branch overlaps the first, so you don't\n          // immediately see its effects.\n          mx = Disp(vec2(0,-2.*l));\n\t    }  \n\t    else if(path == 3){\n          mx = Disp(vec2(0,-2.*l))*posR*Disp(vec2(0,-4.*l));\n\t    }\n\n         pt_n = (mx* vec3(pt_n,1)).xy; \n         float y = right_p(pt_n, wid, l); \n          \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-3.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.;\n    \n    fragColor = vec4(0);\n    float l = left(uv - vec2(-5.,0.));\n    float c = center(uv);\n    float r = right(uv - vec2(5.,0.));\n    float d = min(r,min(l, c));\n    \n    float t = clamp(d, 0.0, .04) * 2.*12.5;\n    vec4 bg = vec4(0);\n    vec4 fg = vec4(.8);\n    fragColor = mix(bg, fg, 1.-t);  \n}","name":"Image","description":"","type":"image"}]}