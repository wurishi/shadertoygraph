{"ver":"0.1","info":{"id":"McVXWR","date":"1715059473","viewed":160,"name":"Anisotropic filter","username":"GeForceLegend","description":"A fork of [url]https://www.shadertoy.com/view/4lXfzn[/url], changed from coord space to texel space.\nLeft: original, right: improved\nSet to full screen at 1080P and you can see the farest pixels are slightly better.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["aliasing","filtering","anisotropic","gpmipmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 R; // see more about aniso x16 here: https://www.shadertoy.com/view/ltXfRr\n\nvec4 textureAniso(sampler2D T, vec2 p) {\n    mat2 J = inverse(mat2(dFdx(p),dFdy(p)));       // dFdxy: pixel footprint in texture space\n    J = transpose(J)*J;                            // quadratic form\n    float d = determinant(J), t = J[0][0]+J[1][1], // find ellipse: eigenvalues, max eigenvector\n          D = sqrt(abs(t*t-4.*d)),                 // abs() fix a bug: in weird view angles 0 can be slightly negative\n          V = (t-D)/2., v = (t+D)/2.,                     // eigenvalues. ( ATTENTION: not sorted )\n          M = 1./sqrt(V), m = 1./sqrt(v), l =log2(m*R.y); // = 1./radii^2\n  //if (M/m>16.) l = log2(M/16.*R.y);                     // optional\n    vec2 A = M * normalize(vec2( -J[0][1] , J[0][0]-V )); // max eigenvector = main axis\n    vec4 O = vec4(0);\n    for (float i = -7.5; i<8.; i++)                       // sample x16 along main axis at LOD min-radius\n        O += textureLod(iChannel0, p+(i/16.)*A, l);\n    return O/16.;\n}\n\nvec4 textureAniso2(sampler2D T, vec2 p) {\n    vec2 pR = p * R;\n    mat2 J = inverse(mat2(dFdx(pR),dFdy(pR))); // Changed from coord space to texel space\n    J = transpose(J)*J;\n    float d = determinant(J),\n          t = (J[0][0]+J[1][1]) * 0.5,         // No need for 3 extra multiply\n          D = sqrt(abs(t * t - d)),\n          V = t - D, v = t + D,\n          l = log2(inversesqrt(v));            // As switched to texel space, resolution is already multiplied\n    vec2 A = vec2(-J[0][1], J[0][0] - V );     // Merged `M` with the inversesqrt() in normalize()\n    A *= inversesqrt(V * dot(A, A)) / R;       // Convert back to coord space\n    vec4 O = vec4(0);\n    for (float i = -7.5; i<8.; i++)\n        O += textureLod(iChannel0, p+(i/16.)*A, l);\n    return O/16.;\n}\n\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    vec3 r = vec3( 2.* U / R - 1. , 1 );                         // ray\n    vec2 p = - r.xz / r.y + .1 * iTime;                          // intersection on floor\n\n    p /= 4.;  // because texture contains big tiles\n    O =   r.y > (0.1 / R.y) ? vec4(.5, .7, .9, 1)                        // background\n        : r.x < (0.1 / R.x) ? textureAniso(iChannel0, p) \n        : r.x < (3.5 / R.x) ? vec4(1.0, 0.0, 0.0, 0.0)\n                            : textureAniso2(iChannel0, p);\n    O = pow(O,vec4(1./2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, vec2 u )\n{   ivec2 U = ivec2( u / iResolution.xy * 8. ) % 2;\n    O = vec4( U.x == U.y );\n}","name":"Buffer A","description":"","type":"buffer"}]}