{"ver":"0.1","info":{"id":"ldGfzd","date":"1619816831","viewed":62,"name":"Little Blobby","username":"rift","description":"Diff of box and sphere, with smaller sphere melting through the box.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_STEPS = 128;\nconst float STEP_SCALE = 0.5;\nconst float eps = 0.005; \n\n\n// Rotates a point t radians around the y-axis\nvec3 rotateY(vec3 v, float t)\n{\n  float cost = cos(t); float sint = sin(t);\n  return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\n// Rotates a point t radians around the x-axis\nvec3 rotateX(vec3 v, float t)\n{\n  float cost = cos(t); float sint = sin(t);\n  return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sphere(vec3 p, vec3 center, float radius) \n{\n  return length(p - center) - radius;\n}\n\nfloat sinusoid(vec3 p)\n{\n  return cos(p.x*3.+sin(iTime)*0.7)* sin(p.y*3.+sin(iTime)*0.4) * cos(p.z*-3.0+sin(iTime)*0.4) \n          + 0.8*cos(p.x*18.+sin(iTime)*1.4) * sin(p.y*18.+sin(iTime)*0.4) * cos(p.z*-18.+sin(iTime)*0.8);\n}\n\nfloat scene(vec3 p)\n{\n\t/*\n    float boxBlob = min(\n              \t\tmax(sdBox(p, vec3(.5,0.8,0.5)), \n                  -sphere(p, vec3(cos(iTime)*0.1+0.0, cos(iTime/4.)*-2.0, cos(iTime)*0.1+0.0), .75) + 0.04*sinusoid(p)), \n              \t\tsphere(p, vec3(cos(iTime)*0.1+0.0, cos(iTime/4.)*-2.0, cos(iTime)*0.1+0.0), .3) + 0.1*sinusoid(p)\n            \t\t);\n    float plane = sdPlane(p, vec4(0.0,0.01,0.0,0.1));\n    \n    return min(boxBlob, plane);*/\n    \n  return min(\n              max(sdBox(p, vec3(.5,0.8,0.5)), \n                  -sphere(p, vec3(cos(iTime), cos(iTime/5.)*-1.3, cos(iTime/2.)*0.5), .7) + 0.06*sinusoid(p)), \n              sphere(p, vec3(cos(iTime), cos(iTime/5.)*-1.3, cos(iTime/2.)*0.5), .3) + 0.1*sinusoid(p)\n            );\n}\n\nfloat march(vec3 origin, vec3 direction, float start, float end)\n{\n  float sceneDist = 0.0;\n  float rayDepth = start;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    sceneDist = scene( origin + direction * rayDepth);\n\n    if(rayDepth >= end) {\n      break;\n    }\n\n    rayDepth += sceneDist * STEP_SCALE;\n\n  }\n\n  return rayDepth;\n}\n\nvec3 getNormal(in vec3 p) \n{\n  \n  return normalize(vec3(\n    scene(vec3(p.x+eps,p.y,p.z))-scene(vec3(p.x-eps,p.y,p.z)),\n    scene(vec3(p.x,p.y+eps,p.z))-scene(vec3(p.x,p.y-eps,p.z)),\n    scene(vec3(p.x,p.y,p.z+eps))-scene(vec3(p.x,p.y,p.z-eps))\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 cameraPos = vec3(sin(iTime/4.)*-2.2, 0.0, cos(iTime/4.)*-2.2);\n  vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n  vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n  vec2 screenCoords = vec2(2. * fragCoord.xy/iResolution.xy - 1.0) * aspectRatio;\n  float FOV = 0.5;\n\n  vec3 rayOrigin = cameraPos;\n  vec3 forward = normalize(cameraLookAt - cameraPos);\n  vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\n  vec3 up = normalize(cross(forward,right));\n  vec3 rayDir = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);\n\n  float clipNear = 0.0;\n  float clipFar = 10.0;\n\n  vec3 bgColor = vec3(0.0, 0.0, 0.0);\n\n  float dist = march(rayOrigin, rayDir, clipNear, clipFar);\n\n  if (dist >= clipFar) {\n    fragColor = vec4(bgColor, 1.0);\n    return;\n  }\n\n  vec3 surfacePos = rayOrigin + rayDir*dist;\n  vec3 surfaceNormal = getNormal(surfacePos);\n  \n  vec3 lightPos = vec3(sin(iTime/4.)*-2.0,1.5, cos(iTime/4.)*-2.);\n\n  vec3 lightDir = lightPos-surfacePos;\n\n  vec3 lightColor = vec3(1.,0.97,0.92);\n\n  vec3 ref = reflect(-lightDir, surfaceNormal);\n  float diffuse = max( 0.0, dot(surfaceNormal, lightDir) );\n  float specular = max( 0.0, dot( ref, normalize(cameraPos-surfacePos)) ); \n\n  vec3 spherecolor = vec3(abs(sin(iTime/2.))*0.5, abs(cos(iTime/2.))*0.5,abs(sin(iTime/4.))*0.5) * (diffuse*.8) + specular*0.01;\n  fragColor = vec4(spherecolor,1.0);\n}","name":"Image","description":"","type":"image"}]}