{"ver":"0.1","info":{"id":"NljfDG","date":"1652705811","viewed":181,"name":"Metallic Wave 4","username":"denosya","description":"Cube/Symmetry training","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["personnaltoolbox"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CELL_SIZE = 2.;\n\nvec3 cellTransform(vec3 p) {\n\n   float cellSize = CELL_SIZE + 0.05 + sin(iTime*0.25);\n\n   vec3 cell = clamp(round(p / cellSize), -3., +3.);\n   return p - cell * cellSize;\n}\n\nvec3 angularRepeat(vec3 m, float n) {\n    \n  float angle = atan(m.y, m.x) + 6.28 - 1.57;\n\n  angle = mod(angle, 2.*3.1415/n);\n  angle = 3.1415/n - abs(3.1415/n - angle);\n  angle += 1.57;\n  \n  return vec3(length(m.xy)*vec2(cos(angle), sin(angle)), m.z);\n}\n\nvec3 zRepeat(vec3 m, float spacing, float nBefore, float nAfter) {\n   float cellSize = spacing;\n\n   float cell = clamp(round(m.z / cellSize), -nBefore, +nAfter);\n   return vec3(m.xy, m.z - cell * cellSize);\n}\n\nvec3 zRepeat(vec3 m, float spacing) {\n   float cellSize = spacing;\n\n   float cell = round(m.z / cellSize);\n   return vec3(m.xy, m.z - cell * cellSize);\n}\n\nconst float ZREPEAT = 2.;\n\nfloat discretize(float val, float period) {\n    return val - mod(val, period);\n}\n\nvec3 zTork(vec3 m, float intensity) {\n  float angle = atan(m.y, m.x) + discretize(m.z + CELL_SIZE*0.5, ZREPEAT) * intensity;\n  return vec3(length(m.xy)*vec2(cos(angle), sin(angle)), m.z);\n}\n\nfloat map(in vec3 m, in vec3 ro) {\n\n    float zparam = m.z - ro.z;\n\n    m = zTork(m, 0.09);\n    m = angularRepeat(m, 50.);\n    m = zRepeat(m, ZREPEAT);\n\n    vec3 cubePos = vec3(0, 10. + 0.*cos(iTime),0.5);\n    vec3 relative;\n\n    relative = cellTransform(m - cubePos);\n    relative = m - cubePos;\n\n    float a = 0.33;\n    float corner = a * 0.05;\n    \n    return length(max(abs(relative) - a, 0.)) - corner;\n}\n\nbool rayMarching(in vec3 ro, in vec3 rd, out vec3 m) {\n    \n    float md = 1.0;\n   \n    while(md < 200.) {       \n    \n        m = ro + rd * md;    \n        \n    \tfloat dist = map(m, ro);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n\n        md += dist;\n    }\n    \n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos, in vec3 ro)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy, ro) - map(pos-eps.xyy, ro),\n\t     map(pos+eps.yxy, ro) - map(pos-eps.yxy, ro),\n\t     map(pos+eps.yyx, ro) - map(pos-eps.yyx, ro));\n\treturn normalize(nor);\n}\n\nfloat fade(float z) {\n    return 1. - smoothstep(0.25, 0.5, 1. - pow(1. / z, 0.125));\n}\n\nvec4 background(vec2 uv, vec3 rd) {\n    return length(uv) < 0.2 ? vec4(0) : texture(iChannel0, -rd) * 0.75;  \n}\n\nvec4 run(in vec2 fragCoord) {\n\n    vec3 m;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float anim = iTime * 0.5;\n    float cosa = cos(anim);\n    float sina = sin(anim);    \n\n    mat3 rot = mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));\n\n    vec3 camera = vec3(cos(iTime*0.2)*7.,sin(iTime*0.5)*5.,-10. + iTime*10.);\n    \n    vec3 ro = camera;\n    vec3 rd\t= normalize(vec3(uv.xy, 1.));\n\n    if(rayMarching(ro, rd, m)) {\n        vec3 normal = computeNormal(m, ro);\n        vec3 refl = reflect(rd, normal);\n        \n        return texture(iChannel0, refl) * fade(m.z - ro.z);  \n    }\n    else {\n       return background(uv, rd);  \n    }\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = run(fragCoord);\n}\n    \n","name":"Image","description":"","type":"image"}]}