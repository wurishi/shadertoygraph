{"ver":"0.1","info":{"id":"mlVBzd","date":"1702408024","viewed":37,"name":"ellipsoid with pimples","username":"Efim","description":"simple ellipsoid with pimples","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","domain","repetition","ellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//M - sdf function for simple ellipsoid with pimple\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\n#define N        normalize\n#define r(f)     mat2( cos(f + vec4(0,33,11,0)) )   // rotation \n\nfloat t;\n\nfloat M(vec3 p)                                    \n{\n    p.yz *= r( t);\n    p.xy *= r(-t);\n    float n = 20., \n          m = 20.,\n          h = .1, //height pimple\n          r = 0.02; // radius pimple  \n\n    vec3 ell = vec3(.6, 1., 1.2); //ellipsoid\n    //vec3 ell = vec3(1., 1., 1.); //sphere\n    float k0 = length(p/ell),\n          k1 = length(p/(ell*ell)),\n          dlon = TAU/n, dlat = PI/m, l = length(p.xy), \n          //https://iquilezles.org/articles/distfunctions/ \n          dz = k0*(k0-1.0)/k1, //distance to ellipsoid\n          lon = mod(atan(p.y,p.x), TAU),\n          lat = atan(l, p.z), //longitude and latitude\n          lon1 = floor(lon/dlon)*dlon + 0.5*dlon,\n          lat1 = clamp(floor(lat/dlat), 1., m-2.)*dlat + 0.5*dlat, //longitude and latitude nearest pimple\n          x1 = ell.x * sin(lat1)*cos(lon1), \n          y1 = ell.y*sin(lat1)*sin(lon1), \n          z1 = ell.z * cos(lat1), //x1,y1,z1 - coordinate nearest pimple\n          x = ell.x * sin(lat)*cos(lon), \n          y = ell.y *sin(lat)*sin(lon), \n          z = ell.z * cos(lat), //x,y,z - coordinate point on ellipsoid\n          dxy = length(vec3(x, y, z) - vec3(x1, y1, z1));\n          \n   //float dp = (length(vec2(dxy, dz - clamp(dz, 0., h)))*0.5 - r); //distance to pimple \n   //idea of @jt))\n   float dp = (length(vec2(dxy - (h - clamp(dz, 0., h))/h*r, dz - clamp(dz, 0., h)))*0.5); //distance to the cone for cactus, idea of jt)))\n   //float dp = (length(vec2(dxy - (h - clamp(dz, 0., h))/h*r, dz - clamp(dz, 0., h)))*0.5 - 0.001); //distance to the cone for non-sharp spikes\n   \n    return min(dz, dp) ;    \n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    //template of FabriceNeyret2\n    vec2 m, R = iResolution.xy, e = vec2(1,-1)/1e4;\n    t = iMouse.z > 0. ? m = ( 2.*iMouse.xy - R ) / R.y, 0. // mouse or auto-demo\n                      : iTime/2.;\n  \n    vec3 p; p.z = 2.5;                               // camera\n    p.yz *= r(m.y*PI);                            // camera rotation\n    p.xz *= r(m.x*TAU);\n   \n    int k;     // antialiasing AxA\n    \n    #if HW_PERFORMANCE==0\n    #define A 1\n    #else\n    #define A 2\n    #endif\n    \n    for( O *= 0.; k < A*A; k++ )\n    {   vec3 p = p, \n             n = N(-p),\n             r = N(vec3(n.z,0,-n)),                 // ray direction\n             d = N(   mat3( r, cross(n,r), n )\n                    * vec3( ( 2.*( U +vec2(k%A,k/A)/float(A)-.5 ) - R ) / R.y, 1.5 ) \n                  );\n   \n        float t, E = .001, h = E;                   // --- ray-march\n        for (int i; i++ < 128 && h >= E && t < 5. ; )\n            t += h = M( p += d*h );    \n        \n        t < 5. ?                                    // if hit:\n            n = N( e.xyy* M(p + e.xyy ) +           // normal\n                   e.yyx* M(p + e.yyx ) + \n                   e.yxy* M(p + e.yxy ) + \n                   e.xxx* M(p + e.x   ) ),  \n            O +=  vec4(.2  ,.3,.4 ,0) * (.5 + .5*dot( n, vec3(0, .7,-.7)) )     // ambiant\n                + vec4(.85,.75,.65,0) * max(     dot( n, vec3(0, .7, .7)), .2 ) // diffuse\n          : O ;\n    }\n\n    O = sqrt( O ) / float(A);                       // sRGB\n}","name":"Image","description":"","type":"image"}]}