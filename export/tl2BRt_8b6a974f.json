{"ver":"0.1","info":{"id":"tl2BRt","date":"1599671817","viewed":107,"name":"Voronoid Coverband","username":"sylistine","description":"Experimentation with voronoi-based effects. Style inspired by Voronoid game by Zach Aikman\n\nManhattan-style voronoi is incomplete. It's hard to locate those edges...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define manhattan 0\n#define neat 0\n#define PI 3.1415926535\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat VoroLen(vec2 a, vec2 b) {\n#if manhattan\n    vec2 c = abs(a - b);\n    return c.x + c.y;\n#else\n    return length(a-b);\n#endif\n}\n\nfloat EdgeDistance(vec2 a, vec2 b, vec2 c) {\n#if manhattan\n    float halfLen = VoroLen(a, b) * 0.5;\n    float a2c = VoroLen(a, c);\n    float b2c = VoroLen(b, c);\n    return max(halfLen - a2c, b2c - halfLen);\n#else\n    vec2 halfJoin = (a - b) * 0.5;\n    vec2 edgeOrigin = b + halfJoin;\n    vec2 edgeNormal = normalize(halfJoin);\n    return dot(edgeNormal, c - edgeOrigin);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 10.;\n    vec2 suv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    suv *= scale;\n    vec2 mousePos = (iMouse.xy -0.5 * iResolution.xy)/iResolution.y;\n    mousePos *= scale;\n    \n    float t = iTime * 0.25;\n    float r = 4.5;\n    float rsqrt = r * 0.707;\n    vec2[9] point;\n    point[0] = mousePos;\n    point[1] = vec2(sin(t)*rsqrt, sin(t)*rsqrt);\n    point[2] = vec2(-sin(t+PI*0.5)*rsqrt, sin(t+PI*0.5)*rsqrt);\n    point[3] = vec2(0., sin(t*2.-0.5)*r);\n    point[4] = vec2(sin(t*2.+0.7)*r, 0.);\n    point[5] = vec2(r, r);\n    point[6] = vec2(-r, r);\n    point[7] = vec2(r, -r);\n    point[8] = vec2(-r, -r);\n    \n    // Determine some cool colors.\n    vec3[point.length()] color;\n    float pi2 = PI * 2.;\n    float theta = 0.;\n    float increment = pi2 / float(point.length());\n    for(int i = 0; i < color.length(); i++) {\n        color[i] = hsv2rgb(vec3(theta/pi2, 1., 1.));\n        theta += increment;\n    }\n    \n    // Get nearest voronoi point.\n    int nearest = 0;\n    float dnearest = VoroLen(suv, point[0]);\n    for (int i = 1; i < point.length(); i++) {\n        float dcurrent = VoroLen(suv, point[i]);\n        if (dcurrent < dnearest) {\n            dnearest = dcurrent;\n            nearest = i;\n        }\n    }\n        \n    \n    // Get the nearest edge.\n    // Note: nearest edge can't be inferred from the second-nearest voronoi point.\n    // i.e.: For a point in Red, the second nearest point may be Blue, but the nearest edge could be Red-Green.\n    float edgeDistance = 1000.;\n    for (int i = 0; i < point.length(); i++) {\n        if (i == nearest) continue;\n        float edgeDistCurrent = EdgeDistance(point[nearest], point[i], suv);\n        if (edgeDistCurrent < edgeDistance) {\n            edgeDistance = edgeDistCurrent;\n        }\n    }\n    \n    float pointcolor = clamp(0., 1., 1. - smoothstep(0.04, 0.08, dnearest));\n    \n#if neat\n    vec3 edgeColor = vec3(smoothstep(0.01, 0.02, 0.04-edgeDistance));\n    vec3 backgroundColor = color[nearest] * (1. - pow(edgeDistance / scale, 0.125));\n    fragColor = vec4(max(max(edgeColor, backgroundColor), vec3(pointcolor)), 1.0);\n#else\n    fragColor = vec4(max(color[nearest], pointcolor), 1.0);\n#endif\n}\n","name":"Image","description":"","type":"image"}]}