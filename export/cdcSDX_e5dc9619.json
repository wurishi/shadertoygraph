{"ver":"0.1","info":{"id":"cdcSDX","date":"1680649703","viewed":654,"name":"A WEDDING OF WISPS","username":"alro","description":"Individually wisps do not display higher sentience. However, around midsummer, large congregations called \"wisp weddings\" can occur. While this phenomenon is not fully understood, observers report hearing faint voices and laughter.","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["3d","noise","simulation","curl","particles","glow","flicker","magic","wisp","spark","embers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Particles with 3D curl noise. Use mouse to move camera.\n    \n    Positions are updated in Buffer B based on the curl of a gradient noise field.\n    Buffer C renders camera facing dics at a fraction of the canvas resolution.\n    \n    See Common tab for resolution scaling.\n\n*/\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, RENDER_SCALE*uv).rgb;\n    \n    col = ACESFilm(col);\n    col = gamma(col);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n// Size of canvas that renders particles and is then stretched across the whole view.\n// Reduce further at full screen\n// Between 0 and 1\n#define RENDER_SCALE (iResolution.x < 2048.0 ? 0.5 : 0.25)\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Track mouse movement and resolution change between frames and set camera position.\n*/\n\n#define CAMERA_DIST 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Store and update particle positions using curl noise\n    \n    Based on:\n        https://atyuwen.github.io/posts/bitangent-noise/\n        https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph2007-curlnoise.pdf\n*/\n\nconst float speed = 3.0;\nconst float scale = 0.15;\n\n// How many positions are computed regardless of how many are displayed in Buffer C\nconst float particleCount = 2048.0;\n\n// Particles beyond this distance are reset to the centre\nconst float boundingRadius = 10.0;\n\n// Radius where reset particles are placed\nconst float spawnRadius = 4.0;\n\n//---------------------------- Noise ----------------------------\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat noise(vec3 p){\n\n    // Offset to vary look slowly over time\n    p += 1e-4 * iTime;\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n    \n    /*\n    * For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u \n    * is an integer and g is in [-1, 1]. This is the equation for a line with slope g which \n    * intersects the x-axis at u.\n    * For N dimensional noise, use dot product instead of multiplication, and do \n    * component-wise interpolation (for 3D, trilinear)\n    */\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\n//---------------------------- Curl ----------------------------\n\n// https://atyuwen.github.io/posts/bitangent-noise/\nvec3 computeCurl(vec3 p){\n\n    const float eps = 1e-4;\n\n    float dx = noise(p + vec3(eps, 0, 0)) - noise(p - vec3(eps, 0, 0));\n    float dy = noise(p + vec3(0, eps, 0)) - noise(p - vec3(0, eps, 0));\n    float dz = noise(p + vec3(0, 0, eps)) - noise(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad0 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    // Offset position for second noise read\n    p += 1000.5;\n\n    dx = noise(p + vec3(eps, 0, 0)) - noise(p - vec3(eps, 0, 0));\n    dy = noise(p + vec3(0, eps, 0)) - noise(p - vec3(0, eps, 0));\n    dz = noise(p + vec3(0, 0, eps)) - noise(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad1 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    noiseGrad1 = normalize(noiseGrad1);\n    noiseGrad1 = normalize(noiseGrad1);\n    vec3 curl = cross(noiseGrad0, noiseGrad1);\n\n    return normalize(curl);\n}\n\n\n//---------------------------- Position ----------------------------\n\nvec4 getInitialPosition(vec2 fragCoord){\n    return vec4(spawnRadius * (2.0 * hash32(fragCoord) - 1.0), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    if((floor(fragCoord.y) * iResolution.x + floor(fragCoord.x)) < particleCount){\n        if(iFrame == 0){\n            fragColor = getInitialPosition(fragCoord);\n        }else{\n            // Determine how much time has passed since last frame\n            // iTimeDelta is not 0 when interacting with a paused shader\n            float iTimeLastFrame = texelFetch(iChannel0, ivec2(0.5, 0.5), 0).x;\n            float dT = iTime - iTimeLastFrame;\n            \n            vec4 oldData = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            vec3 oldPos = oldData.rgb;\n\n            oldPos += speed * dT * computeCurl(scale * oldPos);\n\n            // Store how long a particle has existed since a reset in the fourth channel\n            vec4 newPos = vec4(oldPos, oldData.w + dT);\n            \n            if(length(newPos) > boundingRadius){\n                newPos = getInitialPosition(fragCoord + iTime);\n            }\n\n            fragColor = newPos;\n        }\n    }else{\n        fragColor = vec4(vec3(0), 1.0);\n    }\n\n    // Store iTime in the first pixel of Buffer B\n    if(fragCoord == vec2(0.5, 0.5)){\n        fragColor = vec4(iTime);  \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Render camera facing particles\n    \n    Based on:\n        https://www.shadertoy.com/view/lsfGDB\n*/\n\n// Buffer B has a separate limit to how many particles positions are provided\n// Above 1k things start to slow down significantly\nconst int particleCount = 300;\n\nconst float boundingRadius = 10.0;\n\n// Mix colour with previous frame results\nconst bool trails = false;\n\n//---------------------------- Camera ----------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//---------------------------- Intersection functions ----------------------------\n\n// https://www.shadertoy.com/view/lsfGDB\nvec3 intersectCoordSys(in vec3 ro, in vec3 rd, vec3 dc, vec3 du, vec3 dv){\n\tvec3 oc = ro - dc;\n\treturn vec3(\n        dot(cross(du, dv), oc),\n\t\tdot(cross(oc, du), rd),\n\t\tdot(cross(dv, oc), rd)) / \n        dot(cross(dv, du), rd);\n}\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 minCorner, vec3 maxCorner){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\n//---------------------------- Colour ----------------------------\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 getColour(float t){\n    \n    // Blue\n    //return vec3(0.1, 0.45, 1.0);\n    \n    // Orange\n    //return vec3(1.0, 0.2, 0.01);\n\n    t += 0.15 * iTime;\n\n    vec3 a = vec3(0.65);\n    vec3 b = 1.0 - a;\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.15,0.5,0.75);\n    \n    return a + b * cos(TWO_PI * (c * t + d));\n}\n\n//---------------------------- Geometry ----------------------------\n\nvec3 traceParticles(vec3 org, vec3 rayDir){\n\n    // Create a coordinate system from the ray direction\n    vec3 n = -rayDir;\n    vec3 tangent;\n    vec3 bitangent;\n    pixarONB(n, tangent, bitangent);\n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 col = vec3(0);\n\n    // Cutoff size for particles\n    float size = 16.0;\n    \n    vec3 intersection;\n    // Distance of intersection in disc uv space\n    float d;\n    vec3 glow;\n    ivec2 uv;\n    vec4 data;\n    vec3 pos;\n    // Distance of particle from the centre\n    float len;\n    // 1 - 0 from the centre of the scene to the bounding sphere\n    float s;\n        \n    for(int i = 1; i < particleCount; i++){\n\n        // Fetch particle data from Buffer B\n        uv = ivec2(int(mod(float(i), iChannelResolution[1].x)), \n                         i / int(iChannelResolution[1].x));\n\n        data = texelFetch(iChannel1, uv, 0);\n\n        pos = data.xyz;\n        len = length(pos);\n\n        // 1 - 0 from the centre of the scene to the bounding sphere\n        s = smoothstep(boundingRadius, 0.0, len);\n\n        if(s < 1e-5){\n            continue;\n        }\n        \n        intersection = intersectCoordSys(org, rayDir, pos, tangent, bitangent);\n        \n        // Distance of intersection in disc uv space\n        d = dot(intersection.yz, intersection.yz);\n\n        if(d < size){\n            // Get an animated glow based on particle index and position\n            // Create a brighter core, vary diameter with time\n            float glowSize = mix(1.0, 4.0, smoothstep(4.0, 0.0, len)) * \n                             mix(0.001, 0.01, 0.5 + 0.5 * sin(13.0 * iTime + float(i)/6.0));\n\n            vec3 tone = getColour(float(i) / (3.4 * float(particleCount)));\n\n            // Reduce glow radius at the edges of the bounding sphere\n            glow = tone * getGlow(d, glowSize, mix(1.0, 0.9, s));\n            \n            // Smoothly fade in reset particles\n            float lifeTime = smoothstep(0.0, 0.5, data.w);\n            // Fade particles at the edges of the bounding sphere and fade glow\n            // locally based on particle size\n            col += lifeTime * s * glow * smoothstep(size, 0.0, d);\n        }\n    }\n    \n    return col;\n}\n\n\n//---------------------------- Render ----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    if(fragCoord.x > iResolution.x * RENDER_SCALE || \n       fragCoord.y > iResolution.y * RENDER_SCALE){\n    \n        fragColor = vec4(0);\n        \n    }else{\n    \n        //Get the default direction of the ray (along the negative Z direction)\n        vec3 rayDir = rayDirection(60.0, fragCoord, iResolution.xy * RENDER_SCALE);\n\n        //----------------- Define a camera -----------------\n\n        vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n        vec3 targetDir = -cameraPos;\n\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        // Get the view matrix from the camera orientation\n        mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n        \n        //---------------------------------------------------\n\n        // Transform the ray to point in the correct direction\n        rayDir = normalize(viewMatrix * rayDir);\n\n        vec3 col = vec3(0.0, 0.01, 0.02);\n\n        vec2 intersections = intersectAABB(cameraPos, rayDir, \n                                           vec3(-boundingRadius), vec3(boundingRadius));\n\n        if(intersections.x > 0.0 && (intersections.x < intersections.y) || \n           insideAABB(cameraPos, vec3(-boundingRadius), vec3(boundingRadius))){\n            col += traceParticles(cameraPos, rayDir);\n        }\n        \n        if(trails){\n            if(iMouse.z < 0.0){\n                vec3 oldCol = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n                oldCol = clamp(oldCol, 0.0, 2.0);\n                col = mix(oldCol, col, 0.45);\n            }\n        }\n        \n        // Output to screen\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}