{"ver":"0.1","info":{"id":"lf2yzy","date":"1722546584","viewed":79,"name":"Multisample AA  experiments","username":"Yap","description":"Use Mouse in X to select a pattern, Mouse Y to tweak patterns\n\nI played with two slightly different approches of multisample with interesting results","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spiral","antialiasing","multisample","4x4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    I played a little with two approaches of MultiSample, one where the sample\n    start from the angles or border of the pixel and the orther where the samples\n    are inside the pixel.\n   \n    With the first one the are overlap of the sample on the angles or border with\n    neighboring pixels, the other method always keep a margin with the border so\n    the grid across the entire image should be more regular.\n    \n    I noticed that with the first method the result look smoother for AA = 4 for example\n    but when AA = 2 the result if way better with the second approch.\n    \n    \n    \n    -------------------------------    \n    \n    X represent the samples positions in a pixel\n    \n    With the first version the samples start from the border or the angle of the pixel\n    \n\n        1/3       1/3       1/3    \n         \n    X - - - - X - - - - X - - - - X\n    |                             |\n    |                             |\n    |                             |\n    |                             |\n    X         X         X         X\n    |                             |\n    |                             |\n    |                             |\n    |                             |\n    X         X         X         X\n    |                             |\n    |                             |\n    |                             |\n    |                             |\n    X - - - - X - - - - X - - - - X\n\n\n    -------------------------------\n    \n    With the second version, the sample positions keep a margin with the border\n    of the pixel\n    \n    \n    1/8   1/4     1/4     1/4  1/8 \n     \n    + - - - - - - - - - - - - - - +\n    |  X       X       X       X  |\n    |                             |\n    |                             |\n    |                             |\n    |  X       X       X       X  |\n    |                             |\n    |                             |\n    |                             |\n    |                             |\n    |  X       X       X       X  |\n    |                             |\n    |                             |\n    |                             |\n    |  X       X       X       X  |\n    + - - - - - - - - - - - - - - +\n*/\n\n\n// AA samples, set to 1 to see without AA\n#define AA      4\n\n// Set to  0 or 1\n#define METHOD  0\n\n#define time iTime * 1.0\n\n#define epsilon 0.00001\n#define mouseY iMouse.y/iResolution.y\n\n\nvec3 draw(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    float x; int i;\n   \n    \n    if( iMouse.x > 12.) // I keep some pixels on the left to be able to see all the patterns together\n    {    \n        i = int(floor(iMouse.x/iResolution.x*4.));\n    }\n    else\n    {\n        i = int(floor(fragCoord.x/iResolution.x*4.));\n        uv.x -= (float(i)-1.5)*.45;\n    }  \n    \n    \n    switch(i){   \n        case 0:\n            x = spiral(uv, time, mouseY);        break;\n        case 1:\n            x = lines(uv, time, mouseY);         break;\n        case 2:\n            x = floorTile(uv, time, mouseY);     break;\n        case 3:\n            x = maze(uv, time, mouseY);       break;\n    }\n    \n    return vec3(x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    vec2 uv = fragCoord;\n    \n    \n    // MultipleSample Version 1 ---> \n    \n    #if METHOD == 0\n    float dist = 1. / float(AA - 1);\n\n    for (float xOf=0.; xOf < 1. + epsilon ; xOf += dist) \n    {\n        for (float yOf=0.; yOf < 1. + epsilon; yOf += dist)\n        {                   \n            vec2 offset = vec2(xOf, yOf) - .5;       //center the offset vector\n            //offset *= 1./ iResolution.xy;          //multiply by pixel size for normalized uvs version\n            color += draw(uv + offset);\n        }\n    }\n    color /= float(AA * AA);\n    #endif\n    \n    \n        \n    // MultipleSample Version 2 ---> \n    \n    #if METHOD == 1\n    float rcpAA = 1. / float(AA);\n\n    for (int i=0; i<AA; i++) \n    {\n        float xOf = float(i) * rcpAA;  \n        for (int j=0; j<AA; j++)\n        {\n            float yOf = float(j) * rcpAA;                    \n            vec2 offset = vec2(xOf, yOf) - ((1.-rcpAA) * .5);     //center the offset vector\n            //offset *= 1./ iResolution.xy;                       //multiply by pixel size for normalized uvs version\n            color += draw(uv + offset);\n        }\n    }\n    color /= float(AA * AA);\n    #endif\n\n    /*\n    // Remove AA, depends on mouse input\n    if (iMouse.y > iResolution.y *.55)\n    {\n        color = draw(uv);\n    }\n    */\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common functions\nvec2 rotate2d(vec2 pos, float angle)\n{\n    angle *= 6.283185;\n    float s = sin(angle);\n    float c = cos(angle);\n     \n                               \t\n    return  mat2(c, s, -s, c) * pos;\n}\n\n\n\n// Some drawings to see AA results\n\n#define animSpeed 0.004\n#define shapeNumb 13.\n\nfloat spiral(vec2 uv, float iTime, float mouseY )\n{\n    float lenUv = length(uv);\n    float spir = pow(lenUv,sin(lenUv*mix(20.,10.,lenUv)+iTime * .5)*.1);\n    uv = rotate2d(uv, iTime * animSpeed + mix(spir,0.,mouseY * 2.)); // Rotation + spiral effect\n\n    float x = sin(atan(uv.x, uv.y) * shapeNumb);\n    \n    return step(0.,x);\n}\n\n\nfloat floorTile(vec2 uv, float iTime, float mouseY)\n{\n    float v = abs(uv.y*2.);\n    uv.x /= mix(0.1, 20., v);\n    uv.y /= v + .1;\n    uv.x -= uv.y > 0.? iTime/32. : 0.;\n    uv = floor(uv * mix(20., 50., mouseY));\n    return mod(uv.x+uv.y, 2.);\n    \n}\n\n\n#define linesScale 400.\n\nfloat lines(vec2 uv, float iTime, float mouseY)\n{\n    float dir = (mouseY + .5) * 1.570796;\n    uv *= linesScale;\n    return step(0.,sin(dot(uv,vec2(cos(dir),sin(dir)))));\n}\n\n\n#define chkMaxScale 20.\n\nfloat maze(vec2 uv, float iTime, float mouseY)\n{\n    uv -= 1.;\n    uv = rotate2d(uv * abs(mouseY - .2), iTime / 120.);\n    uv*= chkMaxScale;\n    vec2 chUv = floor(uv);\n    float checker = mod(chUv.x+chUv.y, 2.);\n    uv = abs(fract(uv * 2.));\n    float pyr = min (uv.x, uv.y);\n    pyr = mod(floor(pyr * 5.) + checker , 2.);\n    \n    return pyr;   \n}","name":"Common","description":"","type":"common"}]}