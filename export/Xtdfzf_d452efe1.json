{"ver":"0.1","info":{"id":"Xtdfzf","date":"1540493910","viewed":141,"name":"Fractals(Julia/Sierpinski)","username":"liahimz","description":"WASD/Arrow keys - movement\nQ - zoom in\nE - zoom out\nR - restore default position and size\nZ - change frac (Julia set / Sierpinski_set / gcd_set)\nF - AA (No AA/4x/8x)\nSpace  - pause\n1,2,3,4 - colors (from 1 to 3 static colors / 4 - dynamic color)","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["fractal","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int i_max = 2048;\nfloat er = 15.0;\n\nfloat AA_CONS = 0.001;\n\n\n\nfloat red[4];\n    //red[0] = 1.0; red[1] = 1.0; red[2] = 1.0; red[3] = sin(cons_time * 0.2);\nfloat green[4];\n    //green[0] = 1.0; green[1] = 0.1; green[2] = 1.5; green[3] = sin(cons_time * 0.5);\nfloat blue[4];\n    //blue[0] = 1.0; blue[1] = 0.1; blue[2] = 8.5; blue[3] = sin(cons_time * 0.1);\nfloat off_t[4];\n    //off_t[0] = 15.0; off_t[1] = 3.0; off_t[2] = 8.5; off_t[3] = 1.0;\n\n\nvec2 complex_square(vec2 v) {\n    return vec2(\n        v.x * v.x - v.y * v.y,\n        v.x * v.y * 2.0\n    );\n}\n\nbool read_key(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.0;\n}\n\nfloat length2(vec2 p) \n{ \n    return dot(p,p); \n}\n\n\nbool isprime(int n){\n    if (n < 0) {\n        n *= -1;\n    }\n\tfor(int i=2 ;i <= int(sqrt(float(n))); i++)\n\t\tif(n%i==0)\n\t\t\treturn false;\n\treturn true;\n}\n\n\nvec3 Gcd_set(vec2 fragCoord, int i, float cons_time) {\n    vec3 col;\n    float cons = cons_time;\n    float temp = float(int(fragCoord.x*70.) ^ int(fragCoord.y*70.));\n    if (cons_time <= 0.2) {\n        cons = 75.;\n    }\n    if(isprime(int(temp*cons/75.)) == true) { \n    \tcol = (vec3(red[i],green[i],blue[i]));\n        if (col.x < 0.01 || col.y < 0.01 || col.z < 0.01) {\n            col.x += 0.5; col.y += 0.5; col.z += 0.5;\n        }\n    } else {\n    \t//col = vec3(cos(cons_time * 0.2),cos(cons_time * 0.5),cos(cons_time * 0.1));\n        col = vec3(0.,0.,0.);\n    }\n    return col;\n}\n\n\nvec2 Sierpinski_set(vec2 p,vec2 va,vec2 vb,vec2 vc, float cons_time)\n{\n\tfloat a = 0.0;\n\tvec2 c;\n\tfloat dist, d, t;\n\tfor( int i = 0; i < 7; i++ ) {\n\t\td = length2(p-va);                 \n        c = va; dist=d; t=0.0;\n        d = length2(p-vb); \n        if (d <= dist) { \n            c = vb; dist=d; t=1.0; \n        }\n        d = length2(p-vc); \n        if (d <= dist) { \n            c = vc; dist=d; t=2.0; \n        }\n\t\tp = c + 2.0*(p - c);\n\t\ta = t + a*3.0;\n\t}\n\t\n\treturn vec2( length(p)/pow(2.0, 7.0), a/pow(6.0 + sin(cons_time) ,4.0) );\n}\n\nfloat Julia_set(vec4 sum, vec2 z, float cons_time) \n{\n    float l = 0.0;\n    int count = 0;\n    vec2 c;\n    \n    c = vec2(0.80 * sin(cons_time*0.5), 0.80 * cos(cons_time*0.5));\n    \n    for (int i = 0 ; i < i_max; i++) {\n        z = c + complex_square(z);\n        count = i;\n        if ( dot(z,z) > er ) {  \n            break;\n        }\n        l += 1.0;\n    }\n    \n    float sl = (l - (log2(log2(length2(z))))); \n    float al = smoothstep( -0.2, 0.0,0.5*6.2831*cons_time );\n    l = mix( l, sl, al ); \n    return l;\n}\n\n\n\nvec3 antialiasing_x4(vec2 fragCoord,vec4 sum, float cons_time, int j, int k)\n{\n    vec3  result_color = vec3(0.0);\n    float iterations   = 5.0;\n    \n    vec2 biases[5];\n    biases[0] = vec2(0, 0);\n    biases[1] = vec2(-AA_CONS, 0);\n    biases[2] = vec2( AA_CONS, 0);\n    biases[3] = vec2(0, -AA_CONS);\n    biases[4] = vec2(0,  AA_CONS);\n\n    for (int i = 0; i < 5; ++i) {\n        if (k == 0) {\n            //float success = 0.0;\n            float l = Julia_set(sum, fragCoord + vec2(biases[i]), cons_time);\n            vec3 col = 0.5 + 0.5*cos( off_t[j] + l*0.15 + vec3(red[j],green[j],blue[j]));\n            result_color += mix(result_color,col,0.8);;\n            iterations += 1.0/5.0;\n        } else if (k == 2) {\n            vec3 col = Gcd_set(fragCoord + biases[i],j, cons_time);\n            //float l = Julia_set(sum, fragCoord + vec2(biases[i]), cons_time);\n            //vec3 col = 0.5 + 0.5*cos( off_t[j] + l*0.15 + vec3(red[j],green[j],blue[j]));\n            result_color += mix(result_color,col,1.);\n        }\n            \n    }\n\n    result_color /= iterations;\n    return result_color;\n}\n\n\nvec3 antialiasing_x8(vec2 fragCoord,vec4 sum, float cons_time, int z, int k)\n{\n    vec3  result_color = vec3(0.0);\n    float iterations   = 0.0;\n\n    for (float i = -AA_CONS; i <= AA_CONS ; i += AA_CONS) {\n        for (float j = -AA_CONS; j <= AA_CONS; j += AA_CONS) {\n            if (k == 0) {\n                //float success = 0.0;\n                float l = Julia_set(sum, fragCoord + vec2(i,j), cons_time);\n                vec3 col = 0.5 + 0.5*cos( off_t[z] + l*0.15 + vec3(red[z],green[z],blue[z]));\n                result_color = mix(result_color,col,0.5);\n                //iterations += 1.;\n                //iterations += 1.0/5.0;\n            } else if (k == 2) {\n                AA_CONS = 0.0010;\n                vec3 col = Gcd_set(fragCoord + vec2(i,j),z, cons_time);\n                //float l = Julia_set(sum, fragCoord + vec2(biases[i]), cons_time);\n                //vec3 col = 0.5 + 0.5*cos( off_t[j] + l*0.15 + vec3(red[j],green[j],blue[j]));\n                result_color += mix(result_color,col,0.8);\n            }\n            //float success = 0.0; \n            \n        }\n    }\n\n    //result_color /= iterations;\n    return result_color;\n    //return vec4(0.0);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sum = texture(iChannel0, uv);\n    float size = sum.r;\n    vec2 z = sum.gb + (vec2(0.5, 0.5) - uv) / size;\n    \n    float cons_time = sum.a;\n    \n    //float red[4];\n    red[0] = 1.0; red[1] = 1.0; red[2] = 0.0; red[3] = sin(log2(cons_time) * 0.2 / 256.);\n\t//float green[4];\n    green[0] = 1.0; green[1] = 0.1; green[2] = 0.0; green[3] = cos((cons_time) * 0.2);\n    //float blue[4];\n    blue[0] = 1.0; blue[1] = 0.1; blue[2] = 1.0; blue[3] = sin(cons_time * 0.1);\n    //float off_t[4];\n    off_t[0] = 15.0; off_t[1] = 3.0; off_t[2] = 3.0; off_t[3] = mix(sin(cons_time),cos(cons_time),1.);\n    \n    vec4 pic_config = texture(iChannel2, uv);\n    int i = int(pic_config.a);\n    int j = int(pic_config.b);\n    int k = int(pic_config.r);\n    vec3 col;\n    \n    if (k == 0) {\n        if (j % 3 == 1) {\n            col = antialiasing_x4(z, sum, cons_time, i, k);\n        } else if (j % 3 == 2) {\n            col = antialiasing_x8(z, sum, cons_time, i, k);\n        } else {\t\n        \tfloat l = Julia_set(sum, z, cons_time);\n    \t\tcol = 0.5 + 0.5*cos( off_t[i] + l*0.15 + vec3(red[i],green[i],blue[i]));\n        }   \n    } else if (k == 1) {\n        vec2 va = vec2(  0, 1 );\n        vec2 vb = vec2(  cos(cons_time) * 0.75, -0.75 );\n        vec2 vc = vec2( -cos(cons_time) * 0.75, -0.75 );\n\n        vec2 r = Sierpinski_set(z,va,vb,vc, cons_time);\n\t\tcol = 0.5 + 0.5*sin( cos(3.1416*r.y) + vec3(red[i],green[i],blue[i]));\n\t\tcol *= 1.0 - smoothstep( 0.001, 0.01, (r.x) );\n\t\t\n    } else if (k == 2) {\n        col = Gcd_set(z,i, cons_time);\n        if (j % 3 == 1) {\n            col = antialiasing_x4(z,sum, cons_time, i, k);\n        } else if (j % 3 == 2) {\n            col = antialiasing_x8(z, sum, cons_time, i, k);\n        } else {\t\n        \tcol = Gcd_set(z,i, cons_time);\n        }\n    }\n   \n    fragColor = vec4(col, 1.0); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_SPACE = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER = 190;\n\nbool read_key(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.0;\n}\n\nbool read_key_1(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.0;\n}\n\nbool read_key_2(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sum = texture(iChannel0, uv);\n    vec4 con = texture(iChannel2, uv);\n    float size = sum.r;\n    vec2 z = sum.gb;\n    \n    if (size == 0.0)\n    \tsize = 0.30;\n\n    if (read_key(KEY_Q)) {\n        size += (0.015 * size);\n    }\n    if (read_key(KEY_E)) {\n        size -= (0.015 * size);\n        if (con.r != 2.) { \n            if (size < 0.30)\n                size = 0.30;\n        }\n    }\n    if (read_key(KEY_R)) {\n        size = 0.30;\n        z = vec2(0.0, 0.0) ;\n    }\n\n    if (read_key(KEY_W) || read_key(KEY_UP)) {      \n        z += vec2(0.0, -0.1) / size;\n        if (con.r != 2.){\n            if (z.y < -0.7 * size)\n                z.y = -0.7 * size;\n        }\n    }\n    if (read_key(KEY_S) || read_key(KEY_DOWN)) {\n        z += vec2(0.0, 0.1) / size;\n        if (con.r != 2.) {\n        \tif (z.y > 0.7 * size)\n            \tz.y = 0.7 * size;\n        }\n    }\n    if (read_key(KEY_A) || read_key(KEY_LEFT)) {\n        z += vec2(0.1, 0.0) / size;\n        if (con.r != 2.) {\n            if (z.x > 0.5 * size) \n                z.x = 0.5 * size;\n        }\n    }\n    if (read_key(KEY_D) || read_key(KEY_RIGHT)) {\n        z += vec2(-0.1, 0.0) / size;\n        if (con.r != 2.) {\n            if (z.x < -0.7 * size) \n                z.x = -0.7 * size;\n        }\n    }\n    \n    \n    float cons_time = sum.a;\n    if (read_key_2(KEY_SPACE)) {\n        cons_time = iTime;\n    }  \n\n    \n    fragColor = vec4(size, z, cons_time);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_0 = 48;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_5 = 53;\nconst int KEY_6 = 54;\nconst int KEY_7 = 55;\nconst int KEY_8 = 56;\nconst int KEY_9 = 57;\n\nconst int KEY_F = 70;\nconst int KEY_Z = 90;\n\n\nbool read_key(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 pic_config = texture(iChannel0, uv);\n    int i = int(pic_config.a);\n    int j = int(pic_config.b);\n    int k = int(pic_config.r);\n    \n    if (read_key(KEY_1)) {\n        i = 0;\n    }\n    if (read_key(KEY_2)) {\n        i = 1;\n    }\n    if (read_key(KEY_3)) {\n        i = 2;\n    }\n    if (read_key(KEY_4)) {\n        i = 3;\n    }\n    \n    if (read_key(KEY_F)) {\n    \tj ++;\n    }\n    \n    if (read_key(KEY_Z)) {\n    \tk ++;\n        k %= 3;\n    } \n    \n    fragColor = vec4(k, 0.0, j, i);\n}","name":"Buffer B","description":"","type":"buffer"}]}