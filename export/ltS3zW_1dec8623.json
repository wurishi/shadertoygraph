{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float u_fHalfBorderThickness = 30.0 / 2.0;\nconst vec4 u_v4BorderColor = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 u_v4FillColor = vec4(1.0, 0.0, 0.0, 1.0);\n//const vec2 u_v2HalfShapeSizePx;\nconst float u_fRadiusPx = 50.0;\n\nfloat RectSDF(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b + vec2(r);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u_v2HalfShapeSizePx = iResolution.xy / 2.0 - clamp(iMouse.xy, vec2(0.0, 0.0), iResolution.xy / 2.5) - vec2(u_fHalfBorderThickness);\n    //u_v2HalfShapeSizePx = vec2(100.0, 50.0) - vec2(u_fHalfBorderThickness);\n    \n\tvec2 v_v2CenteredPos = (fragCoord - iResolution.xy / 2.0);\n\n    float fDist = RectSDF(v_v2CenteredPos, u_v2HalfShapeSizePx, u_fRadiusPx - u_fHalfBorderThickness);\n    \n    vec4 v4FromColor = u_v4BorderColor; //Always the border color. If no border, this still should be set\n    vec4 v4ToColor = vec4(0.0, 0.0, 1.0, 1.0); //Outside color\n    \n    if (u_fHalfBorderThickness > 0.0)\n    {\n        if (fDist < 0.0)\n        {\n            v4ToColor = u_v4FillColor;   \n        } \n        \n        fDist = abs(fDist) - u_fHalfBorderThickness;\n    }\n    \n    float fBlendAmount = smoothstep(-1.0, 1.0, fDist);\n    \n    // final color\n    fragColor = mix(v4FromColor, v4ToColor, fBlendAmount);\n    //fragColor = vec4(vec3(fBlendAmount), 1.0);\n    //fragColor = vec4(vec3(abs(dist) / (2.0 * corner)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltS3zW","date":"1427213162","viewed":1161,"name":"Rounded Rect","username":"mdemoret","description":"2D Rounded Rect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}