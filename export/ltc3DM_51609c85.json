{"ver":"0.1","info":{"id":"ltc3DM","date":"1469571922","viewed":117,"name":"Colorful mandelbrot","username":"Flai","description":"It's a new mandelbrot-shader, derived from https://www.shadertoy.com/view/lsX3W4. \n\nI made sure you can see which points are actually part of the mandelbrot-set, and also reworked the coloring to not only be black / white. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader computes the distance to the Mandelbrot Set for everypixel, and colorizes\n// it accoringly.\n// \n// Z -> ZÂ²+c, Z0 = 0. \n// therefore Z' -> 2Â·ZÂ·Z' + 1\n//\n// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n// G'(c) = Z'/Z/2^n\n//\n// So the distance is |G(c)|/|G'(c)| = |Z|Â·log|Z|/|Z'|\n//\n// More info here: https://iquilezles.org/articles/distancefractals\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = .7 - .5 * cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i < 1024; i++ )\n    {\n        if( m2>8192.0 ) {\n            break;\n        }\n\n        \n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n    \n    \n    if( m2 < 8192.0 ) {\n        fragColor = vec4 ( 0 );\n        return;\n    }\n\n\tfloat d = 0.5 * sqrt(dot(z,z)/dot(dz,dz)) * log(dot(z,z));\n\n\t\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    vec3 col = vec3( 0 );\n    \n    fragColor = hsv_to_rgb( d * d , .95 - .3 * d, .25 + .75 * d, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}