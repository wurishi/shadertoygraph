{"ver":"0.1","info":{"id":"flXyzH","date":"1647510849","viewed":89,"name":"Materialistic Jar","username":"Mohido","description":"A simple scene to demonstrate material interaction with light using raytracing with implicit defined object. The Jar material is changing between roughness and smoothness with time. ","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","reflection","lighting","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//------- Configurations\n#define CULLING   // NOTE: Culling a triangle causes the triangle to be ignored when viewed \n                        // From the back. Even reflection rays will ignore the triangle if they hit it from the back\n\n\n\n//------- Macros Area\n/// Used for defining the type of objects in the Object struct.\n#define TRIANGLE_IMPL_TYPE 0u\n#define SPHERE_IMPL_TYPE 1u\n#define PLANE_IMPL_TYPE 2u\n#define POINT_LIGHT_TYPE 3u\n#define DIR_LIGHT_TYPE 4u\n#define DISC_IMPL_TYPE 5u\n\n\n#define UNDEF_TYPE (DISC_IMPL_TYPE+1u)\n\n\n//------- Constants Area\nconst float pi = 3.1415926535897932384626433832795;\n\nconst uint maxSphereNo = 3u; // Maximum number of Spheres can be stacked \nconst uint maxPlaneNo = 1u;  // Maximum number of planes can be stacked\nconst uint maxTriNo = 32u;    // Maximum number of Triangles can be stacked\nconst uint maxDiscNo = 1u;   // Maximum number of Triangles can be stacked\nconst uint maxObjNo = maxSphereNo + maxPlaneNo + maxTriNo + maxDiscNo;\n\nconst uint maxDirLightNo = 1u;       // Maximum number of Directional lights\nconst uint maxPointLightNo = 1u;     // Maximum number of point lights\nconst uint maxLightNo = maxDirLightNo + maxPointLightNo;  // Maximum number of lights\n\nconst uint maxMatNo = 5u;            // Maximum number of materials\n\n\n//------- Structs area\n\n// Utilities\nstruct TriangleVertex {\n    vec3 position;  // Position of the vertex\n    // vec3 color;     // Color of the vertex.. It is implemented in the material.\n    // vec3 normal;    // Normal of the vertex.. This might be added in the future for complicated lighting blending of Triangular meshes.\n    vec2 texcord;   // Texture coordinates of the vertex\n};\n\nstruct Material { \n    vec3 color;           // [0,1/pi] \n    float roughness;      // [0,~7] \n    vec3 emission;        // [0, inf] \n    float metalness;      // 0.02-0.05 for non-metals, 0.6-0.9 for metals \n};\n\n// Lights\nstruct PointLight {\n    float r;    // Light strength: Light col will be exactly the given value at r\n    vec3 pos;   // Light position\n    vec3 col;   // Light color\n};\n\nstruct DirectionalLight {\n    vec3 dir;   // Light direction\n    vec3 pos;   // Light position\n    vec3 col;   // Light color\n};\n\n\n// Premitives\nstruct Sphere {\n    vec3 c;     // center\n    float r;    // radius\n};\n \nstruct Plane {\n    vec3 q0;      // any point on the plane\n    vec3 n;       // normal\n};\n\nstruct Triangle{\n    bool useTexture;      // Using the texture as a surface color during the rendering process. By default it uses the Material color\n    TriangleVertex vertices[3];\n};\n\nstruct Disc{\n    vec3 q0;      // any point on the plane\n    vec3 n;       // normal\n    float r;      // radius\n};\n\nstruct Object {\n    uint ind_m;   // The material index that this current object uses.\n    uint type;    // The type of the object (To know in which array is it stored in)\n    uint index;   // The index where the object is in the array.\n};\n\nstruct Light {\n    uint type;   // The Type of light (To know in which array it is stored in).\n    uint index;  // The index where the light is residing in the array.\n};\n\n// Stacks.\n// NOTE: Once an object has been added to the stack, it can't be deleted (Iter can't go down).\nstruct SphereStack{\n    uint iter;                       // The index of the last object inserted to the container\n    Sphere spheres[maxSphereNo];     // The container of the spheres.\n};\n\nstruct PlaneStack{\n    uint iter;                       // The last empty index\n    Plane planes[maxPlaneNo];        // The stack (container)\n};\n\nstruct DiscStack{\n    uint iter;                       // The last empty index\n    Disc discs[maxDiscNo];        // The stack (container)\n};\n\nstruct TriangleStack {\n    uint iter;\n    Triangle triangles[maxTriNo];\n};\n\nstruct ObjectStack {\n    uint iter;\n    Object objects[maxObjNo];\n};\n\nstruct DirLightStack {\n    uint iter;\n    DirectionalLight lights[maxDirLightNo];\n};\n\nstruct PointLightStack {\n    uint iter;\n    PointLight lights[maxPointLightNo];\n};\n\nstruct LightStack {\n    uint iter;\n    Light lights[maxLightNo];\n};\n\nstruct MaterialStack {\n    uint iter;\n    Material materials[maxMatNo];\n};\n\n// Rays relative structs\nstruct Ray\n{\n    vec3 p0;    // ray origin if tmin=0\n    float tmin; // omit solutions t<tmin\n    vec3 v;     // direction\n    float tmax; // omit solutions t>tmax\n};\n \nstruct TraceResultLegacy\n{\n    vec3 n;     // Normal vector on surface\n    float t;    // Distance taken on ray\n};\n\nstruct TraceResult{\n    Object obj; // The intersected object.\n    vec3 extra; // Extra vector. It is used mainly to store the barcyntric values (u,v) of the Triangle intersection.\n    float dist; // Distance tile the intersection.\n};\n\n// Scene Struct\nstruct Scene{\n    SphereStack sceneSpheres;\n    PlaneStack scenePlanes;\n    TriangleStack sceneTris;\n    DiscStack sceneDiscs;\n    ObjectStack sceneObj;\n\n    DirLightStack sceneDirs;\n    PointLightStack scenePoints;\n    LightStack sceneLights;\n    \n    MaterialStack sceneMaterials; // All the available materials in the scene.\n};\n\n//------- Global Variables (Scene variables)\nScene scene;\n\n\n\n\n//------- Methods Area\n// Adding Materials\nbool addMaterial(Material mt){\n    if(scene.sceneMaterials.iter >= maxMatNo)\n        return false;\n    scene.sceneMaterials.materials[scene.sceneMaterials.iter] = mt;\n    scene.sceneMaterials.iter++;\n    return true;\n}\n\n\n// Adding Objects\n/**\n* Add a sphere to the scene. It is used as a static method in C to edit the global variables\n*  that we defined above. Call this function to add a sphere to the scene.\n* Returns true if the sphere has been added. \n*/\nbool addSphere(Sphere sph, in uint ind_m){\n    if(scene.sceneSpheres.iter >= maxSphereNo || scene.sceneObj.iter >= maxObjNo)\n        return false;\n    // Adding the sphere to the spheres stack\n    scene.sceneSpheres.spheres[scene.sceneSpheres.iter] = sph;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneObj.objects[scene.sceneObj.iter].type = SPHERE_IMPL_TYPE;\n    scene.sceneObj.objects[scene.sceneObj.iter].ind_m = ind_m;\n    scene.sceneObj.objects[scene.sceneObj.iter].index = scene.sceneSpheres.iter;\n    \n    // Incrementing the stack.\n    scene.sceneSpheres.iter += 1u;\n    scene.sceneObj.iter += 1u;\n    return true;\n}\n\n\n/**\n* Add a triangle to the scene. Same as the addSphere() method written above. It is used\n*  to statically add a triangle to the scene. \n*/\nbool addTriangle(Triangle tri, uint ind_m){\n    if(scene.sceneTris.iter >= maxTriNo || scene.sceneObj.iter >= maxObjNo)\n        return false;\n    \n    // Adding the triangle to the triangles stack\n    scene.sceneTris.triangles[scene.sceneTris.iter] = tri;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneObj.objects[scene.sceneObj.iter].type = TRIANGLE_IMPL_TYPE;\n    scene.sceneObj.objects[scene.sceneObj.iter].ind_m = ind_m;\n    scene.sceneObj.objects[scene.sceneObj.iter].index = scene.sceneTris.iter;\n    \n    // Incrementing the stack.\n    scene.sceneTris.iter += 1u;\n    scene.sceneObj.iter += 1u;\n    return true;   \n}\n\n\n/**\n* Add a triangle to the scene. Same as the addSphere() method written above. It is used\n*  to statically add a triangle to the scene. \n*/\nbool addPlane(Plane pl, uint ind_m){\n    if(scene.scenePlanes.iter >= maxPlaneNo || scene.sceneObj.iter >= maxObjNo)\n        return false;\n    \n    // Adding the plane\n    scene.scenePlanes.planes[scene.scenePlanes.iter] = pl;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneObj.objects[scene.sceneObj.iter].type = PLANE_IMPL_TYPE;\n    scene.sceneObj.objects[scene.sceneObj.iter].ind_m = ind_m;\n    scene.sceneObj.objects[scene.sceneObj.iter].index = scene.scenePlanes.iter;\n    \n    // Incrementing the stack.\n    scene.scenePlanes.iter += 1u;\n    scene.sceneObj.iter += 1u;\n    return true;   \n}\n\n/**\n* Add a triangle to the scene. Same as the addSphere() method written above. It is used\n*  to statically add a triangle to the scene. \n*/\nbool addDisc(Disc pl, uint ind_m){\n    if(scene.sceneDiscs.iter >= maxDiscNo || scene.sceneObj.iter >= maxObjNo)\n        return false;\n    \n    // Adding the plane\n    scene.sceneDiscs.discs[scene.sceneDiscs.iter] = pl;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneObj.objects[scene.sceneObj.iter].type = DISC_IMPL_TYPE;\n    scene.sceneObj.objects[scene.sceneObj.iter].ind_m = ind_m;\n    scene.sceneObj.objects[scene.sceneObj.iter].index = scene.sceneDiscs.iter;\n    \n    // Incrementing the stack.\n    scene.sceneDiscs.iter += 1u;\n    scene.sceneObj.iter += 1u;\n    return true;   \n}\n\n\n/**\n* Add a point light to the scene.\n*/\nbool addPointLight(PointLight pl){\n    if(scene.scenePoints.iter >= maxPointLightNo || scene.sceneLights.iter >= maxLightNo)\n        return false;\n    \n    // Adding the plane\n    scene.scenePoints.lights[scene.scenePoints.iter] = pl;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneLights.lights[scene.sceneLights.iter].type = POINT_LIGHT_TYPE;\n    scene.sceneLights.lights[scene.sceneLights.iter].index = scene.scenePoints.iter;\n    \n    // Incrementing the stack.\n    scene.scenePoints.iter += 1u;\n    scene.sceneLights.iter += 1u;\n    return true;   \n}\n\n\n/**\n* Add a directional light\n*/\nbool addDirLight(DirectionalLight pl){\n    if(scene.sceneDirs.iter >= maxDirLightNo || scene.sceneLights.iter >= maxLightNo)\n        return false;\n    \n    // Adding the plane\n    scene.sceneDirs.lights[scene.sceneDirs.iter] = pl;\n    \n    // Adding it as well to the objects stack.\n    scene.sceneLights.lights[scene.sceneLights.iter].type = DIR_LIGHT_TYPE;\n    scene.sceneLights.lights[scene.sceneLights.iter].index = scene.sceneDirs.iter;\n    \n    // Incrementing the stack.\n    scene.sceneDirs.iter += 1u;\n    scene.sceneLights.iter += 1u;\n    return true;   \n}\n\n\n// Intersection Functions. \n/**\n* Check if the given ray intersects the given sphere using the \n*  geometric intersection algorithm.\n* Precondition:\n    * Sphere must be implicit defined.\n    * Ray direction must be normalized!\n* Returns \n    * the distance from ray origin to sphere surface.\n    * If no intersection, returns ray.tmax.\n*/\nfloat intersectSphere(Ray ray, Sphere sphere){\n    float scaler = dot(sphere.c - ray.p0, ray.v);\n    vec3 p = (ray.p0 + ray.v * scaler);\n    float cc_len = length(p - sphere.c); // intersecting the circle at all?\n    if(cc_len > sphere.r) return ray.tmax; // Not passing by the circle\n    float bias = sqrt(sphere.r*sphere.r - cc_len*cc_len); // pythogerian\n    vec2 biasLengths = vec2(scaler - bias, scaler + bias); // if the point is behind the camera or not\n    if(max(biasLengths.x, biasLengths.y) < 0.) return ray.tmax;\n    if(min(biasLengths.x, biasLengths.y) < 0.) return max(biasLengths.x, biasLengths.y); //minimum is behind the camera, so we return the other point\n    return min(biasLengths.x, biasLengths.y); // if minimum is positive, then that is the desired point\n}\n\n\n/**\n* Check if the given ray intersects the given Plane.\n* Precondition:\n    * Plane must be implicit defined.\n    * Ray direction must be normalized!\n* Returns \n    * the distance from ray origin to sphere surface.\n    * If no intersection, returns ray.tmax.\n*/\nfloat intersectPlane(Ray ray, Plane plane){\n    float dist = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    if(dist <= ray.tmin) return ray.tmax;\n    return min(dist, ray.tmax);\n}\n\n\n/**\n* Check if the given ray intersects the given Triangle using Moller Tomber algorithm.\n* Precondition:\n    * Triangle 3 vertices must exist (Implicitly defined).\n    * Ray direction must be normalized!\n* Returns \n    * the distance from ray origin to sphere surface.\n    * If no intersection, returns ray.tmax.\n* Note:\n    * This function does not consider back face culling.\n    * Code is taken from Scratch a pixel website and edited a bit to suit the implementation.\n        https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n*\n*/\nvec3 intersectTriangle(Ray ray, Triangle triangle){\n    vec3 ret;\n    vec3 v0 = triangle.vertices[0].position;\n    vec3 v1 = triangle.vertices[1].position;\n    vec3 v2 = triangle.vertices[2].position;\n\n    vec3 e1 = v1 - v0; \n    vec3 e2 = v2 - v0; \n    vec3 pvec = cross(ray.v , e2);  // DxE2 <-- For the determinant\n    float det = dot(e1, pvec);      // Determinant of the Linear system of equations coeffs [-D, E1, E2]\n    float bias = 0.0001;            // If project of the ray is close to the bias, then the ray is parallel\n#ifdef CULLING \n    // if the determinant is negative the triangle is backfacing\n    // if the determinant is close to 0, the ray misses the triangle\n    if (det < bias) return vec3(ray.tmax); \n#else \n    // ray and triangle are parallel if det is close to 0\n    if (abs(det) < bias) return vec3(ray.tmax); \n#endif \n    float invDet = 1. / det;\n    vec3 tvec = ray.p0 - v0;     // Ray origin in v0 space \n    \n    ret.y = dot(tvec,pvec) * invDet; // First parameter of the unit triangle (u) \n    if (ret.y < 0. || ret.y > 1.) return vec3(ray.tmax); \n \n    vec3 qvec = cross(tvec, e1); \n    ret.z = dot(ray.v, qvec) * invDet; // Second parameter of the unit triangle (v)\n    if (ret.z < 0. || ret.z + ret.y > 1.) return vec3(ray.tmax); \n \n    ret.x = dot(e2, qvec) * invDet; \n    if(ret.x <= ray.tmin) return vec3(ray.tmax); \n    return ret; \n}\n\n\n/**\n* Calculates if a ray intersect any of the scene objects and return that object details,\n*  and its distance from the ray origin. If the distance is ray.tmax. \n*  it means the ray didn't intersect with any of the scene objects.\n*  \n*/\nTraceResult getClosestObject(Ray ray){\n    TraceResult ret;\n    ret.dist = ray.tmax;\n    ret.obj.type = UNDEF_TYPE;\n    ret.obj.index = maxObjNo;\n    \n    // Through all the scene objects.\n    for(uint i = 0u ; i < scene.sceneObj.iter; i++){\n        uint objectInd = scene.sceneObj.objects[i].index;\n        \n        /*Check triangle intersection using Moller Tromber*/\n        if(scene.sceneObj.objects[i].type == TRIANGLE_IMPL_TYPE){ // Triangle intersection check\n            vec3 res = intersectTriangle(ray, scene.sceneTris.triangles[objectInd]);\n            if(res.x < ret.dist){\n                ret.dist = res.x;\n                ret.extra.x = res.y;   // u\n                ret.extra.y = res.z;   // v\n                ret.obj.type = scene.sceneObj.objects[i].type;\n                ret.obj.index = scene.sceneObj.objects[i].index;\n                ret.obj.ind_m = scene.sceneObj.objects[i].ind_m;\n            }\n        } // Triangle intersection check\n        \n        /*Check Sphere intersection using Geometric intersection calculation*/\n        if(scene.sceneObj.objects[i].type == SPHERE_IMPL_TYPE){// Sphere intersection check\n            float res = intersectSphere(ray, scene.sceneSpheres.spheres[objectInd]);\n            if(res < ret.dist){\n                ret.dist = res;\n                ret.obj.type = scene.sceneObj.objects[i].type;\n                ret.obj.index = scene.sceneObj.objects[i].index;\n                ret.obj.ind_m = scene.sceneObj.objects[i].ind_m;\n            }\n        } // Sphere intersection check\n        \n        /*Check for Plane intersections */\n        if(scene.sceneObj.objects[i].type == PLANE_IMPL_TYPE){ // Plane intersection check\n            float res = intersectPlane(ray, scene.scenePlanes.planes[objectInd]);\n            if(res < ret.dist){\n                ret.dist = res;\n                ret.obj.type = scene.sceneObj.objects[i].type;\n                ret.obj.index = scene.sceneObj.objects[i].index;\n                ret.obj.ind_m = scene.sceneObj.objects[i].ind_m;\n            }\n        }// Plane intersection check\n        \n        /*Check for Disc intersections */\n        if(scene.sceneObj.objects[i].type == DISC_IMPL_TYPE){ // Plane intersection check\n            Disc dtemp =  scene.sceneDiscs.discs[objectInd];\n            Plane ptemp;\n            ptemp.n = dtemp.n;\n            ptemp.q0 = dtemp.q0;\n            float res = intersectPlane(ray, ptemp);\n            if(res < ret.dist && length((ray.v*res + ray.p0) - dtemp.q0) <= dtemp.r){\n                ret.dist = res;\n                ret.obj.type = scene.sceneObj.objects[i].type;\n                ret.obj.index = scene.sceneObj.objects[i].index;\n                ret.obj.ind_m = scene.sceneObj.objects[i].ind_m;\n            }\n        }// Disc intersection check\n        \n    }\n    \n    return ret;\n}\n\n\n\n// BRDF implementation:\n/**\n    Schlik Geometric attantuation function:\n\n          N.V\n    --------------\n    (N.V)(1-k) + k\n\n    Note that K is different for Image Based Lightening (IBL)\n    and different from direct lightening (Direct)\n    (https://learnopengl.com/PBR/Theory)\n*/\nfloat schlick_geometry_GGX(vec3 N, vec3 V, float k){\n    float NdotV = max(dot(N, V), 0.0);\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \n\n/*\n* Combines hte masking and shadowing microfacent attenuations.\n*/\nfloat smith_schlick_geometry(vec3 N, vec3 V, vec3 L, float k){\n    return schlick_geometry_GGX(N,V,k) *  schlick_geometry_GGX(N,L,k);\n}\n\n\n\n/**\n    Trowbridge-Reitz GGX Equation:\n                a*a\n    ---------------------------\n    Pi((N.H)^2 (a*a - 1) + 1)^2\n*/\nfloat reitz_distribution_GGX(vec3 N, vec3 H, float a){\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = pi * denom * denom;\n    return nom / denom;\n}\n\n\n\nvec3 schlick_frasnel(vec3 N, vec3 V, vec3 F0){   \n    // Base reflection + rest reflection * simple pdf\n    // Where F0 kind of work as a surface base color.\n    return F0 + (1.0 - F0) * pow(1.0 - dot(N,V), 5.0);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n* EMAIL: zyqsyj@inf.elte.hu\n* PLEASE MAKE SURE TO USE OTHER BROWSERS THAN CHROME TO RUN THE SCENE SMOOTHLY. \n*    CHROME TEND TO MAKE THE FPS HIT THE GROUND!!!\n* \n* What is this?\n*  A simple scene that contains a Jar with a changing material from smoothness to roughness.\n* \n* Why the code is created?\n*  This simple project and code was written to satisfy the first assignment in the Course of\n*  Computer Graphics that is being taught at the University of Eotvos Lorand. \n* \n* What are the requirements of the assignment?\n*  The requirements of the course mainly based on implementing a Raytracer with a good material\n*  system, and good interaction between the material and light.\n*\n* Modules explanation?\n*  I have created 2 main modules (Common, and Buffer A) to host the code in. The \"Common\" is an \n*  API giving us the ability to create flixible scenes, while the \"Buffer A\" host our scene\n*  and the code that defines it. The \"Buffer A\" contains the main function that produces the\n*  image that you see on the left. It creates the logic and relies on many functions defined \n*  in the \"Common\" module.\n*\n* How the scene code is structured?\n*  First of all, the scene is initialized and all objects are added to the scene stack. The \n*  Scene stack and objects are defined within the \"Common\" interface, and by calling certain \n*  functions, we can add \"Entities\" to the \"Scene\". \n*  After the scene is initialized, the rendering begins. In each pixel, we trace a ray and \n*  calculate the closest objects to the ray. After that, we get the object's data such as \n*  its material and Normal, then we calculate the Irradiance Coeff and stack them. \n*  Finally, we repeat the process until max RAY_DEPTH is reached (Ray bounces) and calculate \n*  the irradiance color based on the gathered Coeffs.\n*\n* What features does this scene have?\n*  { Reflection, Multiple Ray-Bounces, Texture Coordinates for Triangular Surfaces, Spheres,\n*    Planes, Quads, Micro-Facet based BRDF}\n*\n* How to create a new scene?\n*  To create a new scene, simply you need to write your own initScene() function which adds\n*  the entities and their materials to the scene. Note that nothing else should be changed \n*  in this module, except the initScene(). \n*\n* What is not there?\n*  Sampling Emmissive objects: Emmissive entities are not treated as light sources, therefore,\n*   they are ignored from the shadow rays caclulation\n*  Refraction: Refraction requires to artificially mimic the behavior of recursion. Fragment \n*   shaders are not fancy enough to have recursion since an object might or might not shoot\n*   a ray toward the refraction. Therefore, I ignored adding refraction method to the scene.\n*\n* How to configure the existing scene?\n*  Not many choices is given to configure the existing scene since the initScene() is straight\n*  forward. However, you can change the Jar position and the ground position.\n*  For editing the lights, and materials, you will need to edit them from the initScene(). Again,\n*  the initScene is straight forward to edit and configure.\n*\n* Some reminders?\n*  Note that there are maximum boundaries for the number of entities that you can have in the\n*  scene that correspons under a category (TYPE). Types are defined in the \"Common\" module.\n*  In case you want to have many objects or found that some objects are not appearing,\n*  make sure to change the settings of the \"Common\" module to make it able to hold larger \n*  stacks. Simply, the stacks are not flixible in size, so make sure to pre-calculate how \n*  many entities you want to have in the scene and change the \"Common\" configuration accordingly.\n*/\n#define RAY_DEPTH 3\n#define TMAX 500.\n#define TMIN .1\nconst vec3 JAR_POSITION =  vec3(0., 3., 0.);\nconst vec3 GROUND_POSITION = vec3(0., 0., 0.);\nconst vec3 EyeStartPosition = vec3(-40., 10., -5.);\n\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n// ------------------------ MAIN\n\nstruct HitResult{\n    vec3 dirCol;  // Surface color at hitpoint direct illuminating.\n    vec3 refCont; // Surface reflection Contribution\n};\n\nstruct BRDFResult{\n    vec3 diffuse;  // Diffuse coeff\n    vec3 specular; // Specular coeff\n};\n\n// ------------ Function decleration Area\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2);   \nvoid initScene();\nvoid render(vec3 eye, Ray ray, out vec4 fragColor, in vec2 fragCoord);\nBRDFResult brdf(in vec3 L, in vec3 N, in vec3 V,in vec3 F,in vec3 SC, in uint ind_m);\nvoid postProcess( out vec4 fragColor, in vec2 fragCoord, in float dist);\nvec3 getSurfCol(in vec3 R, in vec3  N, in vec3 V, in vec3 F, in uint ind_m, in vec3 SC);\nvec3 getDirectCol(in vec3 P, in vec3  N, in vec3 V, in vec3 F, in uint ind_m, in vec3 SC);\nvoid generatQuad(in vec3 C, in vec3 P, in vec3 N, in float size, in bool textureless);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initScene();                            // Add objects to the scene.\n    \n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    //render(eye, ray, fragColor, fragCoord); // Renders the scene\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}\n\n\n\n\n// ---------- Function Definitions Area\n\n/**\n* Used to initialize the scene with the objects.\n*/\nvoid initScene(){\n\n    /*Materials Generation*/\n    Material m;\n    // 0 material index (A bit of a metalic jar)\n    m.color = vec3(0.5, 0.2, 0.2);\n    m.roughness = clamp(abs(sin(iTime)/2. + 0.5), 0.01 , 1.);\n    m.metalness = 0.;   //clamp(abs(sin(iTime)/2. + 0.5), 0.01 , 1.);\n    addMaterial(m);\n\n    // 1 material index. ALmost rough (Used on the asphalt to give a realistic asphalt texture)\n    m.color = vec3(0., 1., 0.);\n    m.roughness = 0.85;\n    m.metalness = 0.;\n    addMaterial(m);\n   \n    // 2 material index  (Used in the rotating mirror)\n    m.color = vec3(1., 1., 1.);\n    m.roughness = 0.01;\n    m.metalness = 0.;\n    //m.emission = vec3(1.);\n    addMaterial(m);\n\n    // 3 material index (Used for the hat)\n    m.color = vec3(1., 1., 1.);\n    m.roughness = 0.95;\n    m.metalness = 0.;\n    addMaterial(m);\n\n    // 4 material index (Used in the emissive object near)\n    m.color = vec3(0.);\n    m.roughness = 1.;\n    m.metalness = 1.;\n    m.emission = vec3(.9);\n    addMaterial(m);\n        \n        \n    /*Jar Generation */\n    // Jar body\n    Sphere s;\n    s.c = JAR_POSITION + vec3(0., 2., 0.);\n    s.r = 1.;\n    addSphere(s, 0u);    \n    s.c = JAR_POSITION;//vec3(0., 7.3, 0.);\n    s.r = 2.;\n    addSphere(s, 0u);\n    \n    // Jar cover\n    Disc dsc;\n    dsc.q0 = JAR_POSITION + vec3(0., 3.001,0.);\n    dsc.n = vec3(0.,1.,0.);\n    dsc.r = 1.;\n    addDisc(dsc, 3u);\n    Triangle t;\n    float hatStrawsCount = 14.;\n    float strawSize = 2. * pi / hatStrawsCount; // full circle / stras count\n    for(int i = 0 ; i < int(hatStrawsCount); i++){\n        float iff = float(i);\n        mat3 rotY = mat3(\n            cos(strawSize*iff), 0. , sin(strawSize*iff),\n             0   , 1. , 0.   ,\n           -sin(strawSize*iff), 0. , cos(strawSize*iff)\n        );\n         \n        t.vertices[0].position = rotY* (JAR_POSITION + vec3(strawSize/2., 3.,  0.99)) ;  // vec3(strawSize/2., 11.,  0.99)\n        t.vertices[2].position = rotY* (JAR_POSITION + vec3(0., 2.,  1.4)) ;             // vec3(0., 10.,  1.4)\n        t.vertices[1].position = rotY* (JAR_POSITION + vec3(-strawSize/2., 3.,  0.99));\n        addTriangle(t, 3u);\n        \n        t.vertices[0].position = rotY* (JAR_POSITION + vec3( strawSize/2., 2., 1.4)) ;\n        t.vertices[2].position = rotY* (JAR_POSITION + vec3( -strawSize/2., 2.,  1.4));\n        t.vertices[1].position = rotY* (JAR_POSITION + vec3(0., 3., 0.99));\n        addTriangle(t, 3u);\n    }\n    \n    /*Generation of Quads (The ground) */\n    generatQuad(GROUND_POSITION, vec3(1.,0.,0.), vec3(0., 1., 0.), 30., false );\n    \n    /*Rotating Mirror*/\n    mat3 rotY = mat3(\n        cos(iTime), 0. , sin(iTime),\n         0   , 1. , 0.   ,\n       -sin(iTime), 0. , cos(iTime)\n    );\n    t.vertices[0].position = rotY*vec3(15., 0. ,  5.);\n    t.vertices[1].position = rotY*vec3(15., 14. , 5.);\n    t.vertices[2].position = rotY*vec3(15., 0. , -5.);\n    t.useTexture = false;\n    addTriangle(t, 2u);\n    t.vertices[0].position = rotY*vec3(15., 14. ,  5.);\n    t.vertices[1].position = rotY*vec3(15., 14. , -5.);\n    t.vertices[2].position = rotY*vec3(15., 0. ,  -5.);\n    t.useTexture = false;\n    addTriangle(t, 2u);\n    \n    /* Adding light */\n    DirectionalLight light;\n    light.dir = normalize(vec3(0., -1., 0.));\n    light.pos = vec3(0., 10., 0.);\n    light.col = vec3(.8, .8, .8);\n    addDirLight(light);\n   \n    PointLight plight;\n    plight.pos = vec3(sin(iTime) * 8., 20., cos(iTime) * 8.);\n    plight.col = vec3(.9, .9, .9);\n    plight.r = 12.;\n    addPointLight(plight);\n    \n    /* Adding Emessive objects*/\n    s.c = rotY * vec3(20., 10, 0.);\n    s.r = 2.;\n    addSphere(s, 4u);\n}\n\n\n/*\n* Used to generate the scene Quads since teh \"Common\" API does not contain that due to the\n* ability and ease of creating one using 2 triangles.\n*/\nvoid generatQuad(in vec3 C, in vec3 P, in vec3 N, in float size, in bool textureless){\n    float hfsize = size * .5;\n    vec3 D1 = normalize(cross(abs(C - P), N));\n    vec3 V1 = C + D1*hfsize;\n    vec3 V2 = C - D1*hfsize;\n    \n    vec3 D2 = cross(normalize(V2 - V1), N);\n    vec3 V3 = C + D2*hfsize;\n    vec3 V4 = C - D2*hfsize;\n    \n   /*Quad Generaton (Ground)*/\n    Triangle t;\n    t.useTexture = !textureless;\n    t.vertices[0].position = V3;      //vec3(-1., 0., -1.) * size;\n    t.vertices[2].position = V1;      //vec3(1., 0., -1.) * size;\n    t.vertices[1].position = V2;      //vec3(-1., 0., 1.) * size;\n    t.vertices[0].texcord = vec2(1., 1.);\n    t.vertices[2].texcord = vec2(1., 0.);\n    t.vertices[1].texcord = vec2(0., -1.);\n    addTriangle(t, 1u);\n    \n    t.vertices[0].position = V4;     //vec3(1., 0., 1.) * size;\n    t.vertices[1].position = V1;     //vec3(1., 0., -1.) * size;\n    t.vertices[2].position = V2;     //vec3(-1., 0., 1.) * size;\n    t.vertices[0].texcord = vec2(-1., -1.);\n    t.vertices[1].texcord = vec2(-1., 0.);\n    t.vertices[2].texcord = vec2(0., -1.);\n    addTriangle(t, 1u);\n}\n\n\n/**\n* Renders the scene with the following consideration:\n*  Shooting reflection rays. Its contribution to the irradiance is determined by the BRDF\n*  Multiple light bounces. The setting can be changed from the RAY_DEPTH. \n* Note that we are not using multi-sampling method, the depth only considers shooting rays\n*  in the direction of reflection. Therefore, the results may not be realistic for complicated\n*  scenes.\n*/\nvoid render(vec3 eye, Ray ray, out vec4 fragColor, in vec2 fragCoord){\n    vec3 pixelColor = texture(iChannel2, ray.v).xyz;\n    HitResult hitRes[RAY_DEPTH];       // Hit result of the surface (our stack of hits coeffs)\n    \n    TraceResult result = getClosestObject(ray);      // Raycast\n    float dist = result.dist;\n    \n    if(ray.tmax <= result.dist){\n            //pixelColor *= surfCols[0];\n        fragColor = vec4(pixelColor,1.);\n        return;\n    }\n    \n    /* Forward Tracing From camera to last Reflection bounce direction.*/\n    int refCnt = 0 ;\n    while(ray.tmax > result.dist && refCnt < RAY_DEPTH){\n        \n        vec3 P = ray.v*result.dist + ray.p0;  // Point on surface\n        vec3 V = -ray.v;                      // View direction\n        vec3 N = vec3(0.);\n        uint ind_m = result.obj.ind_m;\n        vec2 texCord;\n        vec3 surfaceCol = scene.sceneMaterials.materials[ind_m].color; // texture(iChannel3, texCord).xyz;\n        \n        /*Computing the normals*/\n        if(result.obj.type == SPHERE_IMPL_TYPE){\n            Sphere sphere = scene.sceneSpheres.spheres[result.obj.index];    \n            N = normalize( P - sphere.c);     // Sphere normal\n        }\n        else if(result.obj.type == TRIANGLE_IMPL_TYPE){\n            Triangle tri = scene.sceneTris.triangles[result.obj.index];\n            vec3 e1 = tri.vertices[1].position - tri.vertices[0].position;\n            vec3 e2 = tri.vertices[2].position - tri.vertices[0].position;\n            N = normalize(cross(e1,e2));     // Sphere normal\n            if(tri.useTexture){\n                result.extra.xy = result.extra.xy * 2. - vec2(1.);  // uv between -1 -> 1 instead of 0 -> 1.\n                texCord = tri.vertices[0].texcord * result.extra.xy; // Map the coordinate to the texture coordinate\n                texCord = (texCord + vec2(1.)) * .5 ;  // texture coordinate from -1 -> 1 to 0 -> 1\n                surfaceCol = texture(iChannel3, texCord).xyz;\n            }\n        }\n        else if(result.obj.type == PLANE_IMPL_TYPE){\n            Plane pl = scene.scenePlanes.planes[result.obj.index];\n            N = pl.n;\n        }\n        else if(result.obj.type == DISC_IMPL_TYPE){\n            Disc pl = scene.sceneDiscs.discs[result.obj.index];\n            N = pl.n;\n        }\n        \n        P = P + N*0.001;\n        vec3 R = reflect(-V,N);\n        pixelColor =  texture(iChannel2, R).xyz;\n        \n        /*Computing the Frasnel effect.*/\n        vec3 F0 = vec3(0.04);   // Base reflectivity of dialectrics (Non-Metalic surfaces)\n        F0      = mix( F0, \n                       scene.sceneMaterials.materials[ind_m].color.rgb, \n                       scene.sceneMaterials.materials[ind_m].metalness);  // we move from base dialectric to metalic\n        vec3 F = schlick_frasnel(N, V, F0);\n        \n        /*Computing color of the surface at the point    */\n        hitRes[refCnt].dirCol = getDirectCol(P, N, V, F, ind_m, surfaceCol) + scene.sceneMaterials.materials[ind_m].emission ; // Calculates the direct illumination\n        hitRes[refCnt].refCont = getSurfCol(R, N, V, F, ind_m, surfaceCol);  // Calculates the reflection contribution\n        \n        ray.v = R;\n        ray.p0 = P;\n        result = getClosestObject(ray);\n        refCnt++;\n    }\n    \n    /* backward tracing from last reflection value (sky) to the first hitpoint*/\n    for(int i = refCnt - 1; i >= 0 ; i--){\n       pixelColor = pixelColor * hitRes[i].refCont +  hitRes[i].dirCol;\n    }\n    \n    fragColor = vec4( pixelColor, 1.);\n    postProcess(fragColor, fragCoord, dist);\n}\n\n\n\n/**\n* For post processing the pixel.\n*/\nvoid postProcess( out vec4 fragColor, in vec2 fragCoord, in float dist){\n    /*Motion blur*/\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = dist;\n}\n\n\n/*\n* Calculate the shaded point color under direct illumination.\n*/\nvec3 getDirectCol(in vec3 P, in vec3  N, in vec3 V, in vec3 F, in uint ind_m, in vec3 SC){\n    vec3 col = vec3(0.);\n    \n    /*Calculate the Directional illumination.*/\n    for(int i = 0; i < int(scene.sceneLights.iter); i++){\n        Ray shray;\n        shray.tmax = TMAX;\n        shray.tmin = TMIN;\n        shray.p0 = P;    \n        vec3 L, li;\n        \n        if(scene.sceneLights.lights[i].type == POINT_LIGHT_TYPE){\n           PointLight light = scene.scenePoints.lights[scene.sceneLights.lights[i].index];\n           float di = length(light.pos - P);\n           li = (light.r * light.r * light.col) / (di*di) ;\n           L = normalize(light.pos - P);\n        } // Point light shading\n        else if(scene.sceneLights.lights[i].type == DIR_LIGHT_TYPE){\n           DirectionalLight light = scene.sceneDirs.lights[scene.sceneLights.lights[i].index];\n           L = -light.dir;\n           li = light.col;\n        } // Direction light shading\n        \n        \n        shray.v = L;\n        TraceResult intRes = getClosestObject(shray);\n        if(intRes.dist < shray.tmax){ // Calculating shadow rays\n            continue;\n        }\n        BRDFResult res = brdf(L, N, V, F, SC, ind_m);\n        vec3 difspec = res.diffuse + res.specular;\n        col += clamp(difspec, vec3(0.), vec3(1.)) * max(0. , dot(N, L)) * li ;\n    }\n    return col;\n}\n\n\n\n/*\n* Calculates the color of the surface coeff under indirect illumination \n* (Only reflection rays are support and not any other sampling method).\n*/\nvec3 getSurfCol(in vec3 R, in vec3  N, in vec3 V,in vec3 F, in uint ind_m, in vec3 SC){\n    /* HACK:: clamping is to preserve energy conservation.\n        We exceeds the boundary when the roughness is close to 0, because the distribution \n        approaches infinity. Thus, we get extremely huge BRDF that is accurate in stating the\n        reflection ratio, but gives additional energy to it.\n    */\n    BRDFResult res = brdf(R,N,V,F, SC, ind_m);\n    return  clamp(res.specular, vec3(0.), vec3(1.)) * dot(N, R);\n}\n\n\n/*\n* Computes the BRDF of an object by using the Cook-Torrance BRDF Model.\n* Parameters:\n    * L: Light direction (Incedent ray)\n    * V: View direction (Camera/Eye ray)\n    * N: Surface Normal (Surface normal at the hitpoint)\n* Return:\n    * The compute ratio of incomming light contribution\n*/\nBRDFResult brdf(in vec3 L, in vec3 N, in vec3 V, in vec3 F, in vec3 SC, in uint ind_m){\n    float r = scene.sceneMaterials.materials[ind_m].roughness;\n\n    float k = (r*r)/2.; // Used in Geometric_Attenuation function.\n    vec3 H = normalize(L+V);\n    float D = reitz_distribution_GGX(N, H, r);\n    float G = smith_schlick_geometry(N, V, L, k);\n    vec3 specular = F*D*G/(4.*dot(L,N)*dot(V,N) + 0.001);\n    \n    vec3 kd = vec3(1.) - F;\n    vec3 diffuse = kd*SC/pi; \n\n    return BRDFResult(diffuse, specular);\n}\n\n\n\n\n// Legally stolen from: https://www.shadertoy.com/view/sdSBWm :p\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2){\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               TMIN,\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               TMAX);\t\t\t\t\t\t//maxT\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}