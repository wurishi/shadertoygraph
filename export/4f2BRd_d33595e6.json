{"ver":"0.1","info":{"id":"4f2BRd","date":"1725378805","viewed":103,"name":" piramid and light","username":"nayk","description":"originals https://www.shadertoy.com/view/ftB3DG","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq sdf's\nfloat box(vec3 p, vec3 b, float r) {\n\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat octa( vec3 p, float s) {\np.xz*=rot(iTime*0.1);\np.xy*=rot(45.);\n  p = abs(p);\n  \n  return (p.x+p.y+p.z-s)*.5773;\n}\n\n// fold formulas\nvoid bet(inout vec4 p, float s, float f, float m) {\n\tp.xy = abs(p.xy + f) - abs(p.xy - f) - p.xy;\n    p.xz*=rot(iTime*0.1);\np.xy*=rot(45.);\n\tfloat rr = dot(p.xyz, p.xyz);\n\tif (rr < m) {\n\t\tif(m==0.) m=1e-5;\n\t\tp /= m;\n\t}else{\n\t\tif (rr<1.)p /= rr;\n\t}\n\tp *= s;\n}\n\nvoid tet(inout vec4 p, float k1, float k2, float k3, float k4) {\n\tp = abs(p);\n\tfloat k = (k1 - .5)*2.;\n\tp.xyz /= vec3(k2, k3, k4);\n\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n\n\tp.xyz = p.xyz*k1 - k + 1.;\n\tp.xyz *= vec3(k2, k3, k4);\n\tp.w *= abs(k);\n}\n\nvec2 sdform(in vec3 pos, float hs) {\n    vec4 P = vec4(pos.xzy, 1.);\n    float orbits = .0;\n    for(int i = 0; i < 3; i++) {\n        orbits = max(length(P.xz)*.075,orbits);\n        bet(P, 4.25-hs, 3.-hs, .55);\n        \n        if(hs>.5) {\n            tet(P, 1.5+hs, 1.5, 1.5, 1.5);\n        }else{\n            tet(P, 1.5-hs, 1.+hs, 1.5, 1.5);\n        }\n    }\n  \n    float ln = .9*(abs(P.z)-15.)/P.w;\n    \n    return vec2(ln,orbits);\n}\n\nmat2 rx,ry,turn;\nfloat time,ga1,ga2,ga3,ga4,tmod;\n    \nconst float s = 13.;\nconst float hf= s/2.;\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n    \n    vec3 dp = p;\n    \n    p.y+= .2;\n    p.z+= M.z>0.?.75:1.75;\n   \n    // movin domain 1 rep but using px to move the ID's\n    // as if the domain is continious helps make the refraction\n    // stay pretty as things get messy with larger time variables \n    // used for distance\n    float px = p.x-(ga2*s);\n    p.x-=ga1*s;\n    float id = floor((px+hf)/s);\n\n    p.x=mod(p.x+hf,s)-hf;\n    p.yz*=rx;\n    p.xz*=ry;\n\n    float hs = hash21(vec2(id,1.));\n    vec2 f = sdform(p,hs);\n    float c = octa(p,3.);\n    \n    f.x= hs>.85?max(f.x,c):max(-f.x,c);\n    if(f.x<res.x) {\n        res = f;\n    }\n\n    float d = box(dp,vec3(9),.00);\n    d=max(d,-box(dp,vec3(5.5,4.,5.5),.001));\n    d=max(d,-box(dp,vec3(9.5,3.,4.5),.25));\n    d=max(d,-box(dp,vec3(4.5,3.,9.5),.25));\n    if(d<res.x) {\n        res = vec2(d,14.);\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 clr = .5 + .4 *sin(m + vec3(2.5,1.5,.5));\n    vec3 h = mix(vec3(0),clr,.45);\n    if(m==14.) h=vec3(.416,.420,.506)*clamp((p.y*.1+.5),0.,1.);\n    return h*diff;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    time = T;\n    float timer = T*.08;\n    \n  \n   \n\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,4.),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? 0. :  (M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n \n    rx = rot(x+.28),ry = rot(timer+y);\n\n    vec3  p = ro + rd * .1;\n    float atten = .95,k = 1.;\n    \n    \n    for(int i=0;i<172;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float d = ray.x*.95;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==4.)break;\n\n            p += rd*.01;\n            k = sign(map(p).x);\n\n           \n        }  \n        if(distance(p,rd)>18.) { break; }\n    }\n    uv.y+=0.05;\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n  \n    O = vec4(sqrt(smoothstep(0.,1.,C)*happy_star(uv, anim) * vec3(0.35,0.2,1.15)*0.5),1.);\n     \n   \n}\n","name":"Image","description":"","type":"image"}]}