{"ver":"0.1","info":{"id":"XlyXWK","date":"1492610252","viewed":552,"name":"Amiga Demos 1","username":"gPlatl","description":"An Amiga like demo collection with 3d sinus scroller using shadertoy font texture ;-)\nHold key 1 .. 4 to watch only selected demo....\nGreetings to all contributors and to https://www.shadertoy.com/view/ld2yDz0     \n","likes":12,"published":1,"flags":80,"usePreview":0,"tags":["text","plasma","amiga","sinus","starfield","scroller","copper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dSXDD","filepath":"https://soundcloud.com/carpenter_brut/sets/ep-iii","previewfilepath":"https://soundcloud.com/carpenter_brut/sets/ep-iii","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//----------------------------------------------------------\n// Amiga_Demos_1.glsl\n// Collection of Amiga based demos...\n//   v0.1  2016-01-31  initial version\n//   v1.0  2016-04-19  first release\n//      used codes...\n// ReadKey:    https://www.shadertoy.com/view/llVSRm\n// Scroller:   https://www.shadertoy.com/view/MtySzd\n// RGB_Bars:   https://www.shadertoy.com/view/4lVGzc\n// Copper:     https://www.shadertoy.com/view/Md3GRl\n// RubberCube: https://www.shadertoy.com/view/4lt3R7\n// Amigaball:  https://www.shadertoy.com/view/Xd3XWX\n// Greetings:  https://www.shadertoy.com/view/ld2yDz\n//----------------------------------------------------------\n\n//--- common data ---\nfloat time = 0.0;\nbool mousePressed = false;\nvec2 pos = vec2(0);      //  0 .. 1\nvec2 uv  = vec2(0);      // -1 .. 1\nvec2 aspect = vec2(1.0); // R.xy / R.y\n\nvec2 tp  = vec2(0);      // text position\nvec3 aColor = vec3(0);\n\n//== font handling =========================================\n\n//--- font data ---\n#define FONT_SIZE1 0.40\n#define FONT_SIZE2 0.25\n#define FONT_SPACE 0.45\n\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);\n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _add   S(43);   // +\n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n//----------------------------------------------------------\n// return font image intensity of character ch at text position tp\n//----------------------------------------------------------\nfloat char(int ch)\n{\n  //vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp)))\n               ? vec4(0)\n               : texture(iChannel0,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));\n  if (mousePressed)\n    return f.x;   // 2d\n  else\n    return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n\n//== display values ========================================\n\n//--- display number fraction with leading zeros ---\nfloat drawFract(int digits, float fn)\n{\n  float c = 0.0;\n  fn = fract(fn) * 10.0;\n  for (int i = 1; i < 60; i++)\n  {\n    c += char(48 + int(fn)); // add 0..9\n    tp.x -= FONT_SPACE;\n    digits -= 1;\n    fn = fract(fn) * 10.0;\n    if (digits <= 0 || fn == 0.0) break;\n  }\n  tp.x -= FONT_SPACE*float(digits);\n  return c;\n}\n\n//--- display integer value ---\nfloat drawInt(int val, int minDigits)\n{\n  float c = 0.;\n  if (val < 0)\n  { val = -val;\n    if (minDigits < 1) minDigits = 1;\n    else minDigits--;\n    _sub                   // add minus char\n  }\n  int fn = val, digits = 1; // get number of digits\n  for (int n=0; n<10; n++)\n  {\n    fn /= 10;\n    if (fn == 0) break;\n    digits++;\n  }\n  digits = max(minDigits, digits);\n  tp.x -= FONT_SPACE * float(digits);\n  for (int n=1; n < 11; n++)\n  {\n    tp.x += FONT_SPACE; // space\n    c += char(48 + (val-((val/=10)*10))); // add 0..9\n    if (n >= digits) break;\n  }\n  tp.x -= FONT_SPACE * float(digits);\n  return c;\n}\n\n//--- display float value ---\nfloat drawFloat(float fn, int prec, int maxDigits)\n{\n  float tpx = tp.x-FONT_SPACE*float(maxDigits);\n  float c = 0.;\n  if (fn < 0.0)\n  {\n    c = char(45); // write minus sign\n    fn = -fn;\n  }\n  tp.x -= FONT_SPACE;\n  c += drawInt(int(fn),1);\n  c += char(46); SPACE; // add dot\n  c += drawFract(prec, fract(fn));\n  tp.x = min(tp.x, tpx);\n  return c;\n}\n\nfloat drawFloat(float value)           {return drawFloat(value,2,5);}\n\nfloat drawFloat(float value, int prec) {return drawFloat(value,prec,2);}\n\nfloat drawInt(int value)               {return drawInt(value,1);}\n\n//----------------------------------------------------------\n// javascript keycodes: http://keycode.info/\n// key testing:    https://www.shadertoy.com/view/llVSRm\n//----------------------------------------------------------\nconst int KEY_SPACE = 32;\n\nconst int KEY_0  = 48;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\nconst int KEY_4  = 52;\nconst int KEY_5  = 53;\nconst int KEY_6  = 54;\nconst int KEY_7  = 55;\nconst int KEY_8  = 56;\nconst int KEY_9  = 57;\n\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\n\n//----------------------------------------------------------\n// get javascript keycode: http://keycode.info/\n//----------------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n\n//----------------------------------------------------------\n// render scroll text, mouse.y = sinus height\n//----------------------------------------------------------\n\n#define SCROLL_SPEED 2.0\n#define SCROLL_LEN 40.\n#define SIN_FREQ 0.75\n#define SIN_SPEED 3.0\n\n//----------------------------------------------------------\nvec3 ScrollText1()\n{\n  tp = uv / FONT_SIZE1;  // set font size\n  tp.x = 2.0*(tp.x -4.0 +mod(time*SCROLL_SPEED, SCROLL_LEN));\n  float SIN_AMP = 1.5 * iMouse.y  / iResolution.y - 0.5;\n  tp.y += 1.0 +SIN_AMP*sin(tp.x*SIN_FREQ +time*SIN_SPEED);\n\n  float c = 0.0;\n\n  _A _n _ _A _m _i _g _a _ _l _i _k _e _ _d _e _m _o _ _c _o _l _l _e _c _t _i _o _n \n      \n  _ _w _i _t _h _ _3 _d _ _a _n _t _i _a _l _i _a _s _e _d _  _s _i _n _u _s \n      \n  _ _s _c _r _o _l _l _e _r _ _u _s _i _n _g\n     \n  _ _s _h _a _d _e _r _t _o _y _ _f _o _n _t _ _t _e _x _t _u _r _e \n    \n  _ _smily _\n\n  _ _H _o _l _d _ _k _e _y _ _1 _dot _dot _4 _ _t _o \n\n  _ _w _a _t _c _h _ _o _n _l _y _ _s _e _l _e _c _t _e _d _ _d _e _m _o _ _dot _dot _dot _dot\n\n  vec3 fcol = c * vec3(pos, 0.5+0.5*sin(2.0*time));    \n  if (c >= 0.5) return fcol; \n  return mix (aColor, fcol, c);\n}\n//----------------------------------------------------------\nvec3 ScrollText2()\n{\n  tp = uv / FONT_SIZE2;  // set font size\n  tp.x = 1.8*(tp.x -4.0 +mod(time*SCROLL_SPEED, SCROLL_LEN));\n  tp.y = (uv.y + 0.88) / 0.2;  // set position & font size\n\n  float c = 0.0;\n  _ _star _ _star _ _star _ _star _ _note _note _note _note _\n  _p _l _a _y _i _n _g _  _s _o _u _n _d _c _l _o _u _d _\n  _m _u _s _i _c _  _note _D _i _v _i _s _i _o _n  _ _R _u _i _n _e _note _\n  _f _r _o _m _  _C _a _r _p _e _n _t _e _r _  _B _r _u _t _\n  _note _note _note _note _ _star _ _star _ _star _ _star\n  // _1 _2 _3 _4 _5 _6 _7 _8 _9 _0\n      \n  vec3 fcol = c * vec3(pos, 0.5+0.5*sin(time));    \n  if (c >= 0.5) return fcol; \n  return mix (aColor, fcol, c);\n}\n//----------------------------------------------------------\n// render Amiga Copper Bars\n//----------------------------------------------------------\nfloat barsize = 0.04;\nfloat r=0., g=0.0, b=0.0;\nvec3 barColor = vec3(0.0);\n\nvec3 Copper()\n{\n  float df = time * 0.8;\n  r = 0.5 + 0.5 * sin(df + 3.1415);\n  g = 0.5 + 0.5 * cos(df);\n  b = 0.5 + 0.5 * sin(df);\n  for(float i=0.0; i<0.9; i+=0.08)\n  {\n    float p = 0.7 + 0.2 * cos(1.8*time+160.*i);\n    if ((pos.y <= p + barsize) && (pos.y >= p - barsize))\n    {\n      barColor = (1.0 - abs(p - pos.y) / barsize) * vec3(r+i,g+i,b+i);\n    }\n  }\n  return barColor;\n}\n//----------------------------------------------------------\n// render red green blue sinus bars\n//----------------------------------------------------------\nvec3 calcSine(float frequency, float amplitude, float shift, float yOffset\n             ,vec3 color, float height)\n{\n  float y = sin(time * frequency + shift + uv.x) * amplitude + yOffset;\n  return color * smoothstep(height, 0.0, distance(y, uv.y));;\n}\n\nvec3 RGB_Bars()\n{\n  return calcSine(2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.10)\n       + calcSine(2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.10)\n       + calcSine(0.9, 0.35, 0.5, 0.5, vec3(1.0, 0.0, 0.0), 0.10);\n}\n//------------------------------------------- \n// render transparent rubber cube\n//------------------------------------------- \n// Hold LMB to disable transparency\n\nvec3 cubevec;\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n  float f = sin(time/3.)*1.45;\n  float c = cos(f*p.y);\n  float s = sin(f/2.*p.y);\n  mat2  m = mat2(c,-s,s,c);\n  return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n  p = Twist(p);\n  cubevec.x = sin(time);\n  cubevec.y = cos(time);\n  mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n  p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n  cubevec = p;\n  return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones, return color index 0 or 1\nfloat Face( vec2 uv )\n{\n  uv.y = mod(uv.y, 1.0);\n  return ((uv.y < uv.x) != (1.0 - uv.y < uv.x)) ? 1.0 : 0.0;\n}\n\n// Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n  vec2 e = vec2(0.005, -0.005);\n  return normalize(\n    e.xyy * Cube(p + e.xyy) +\n    e.yyx * Cube(p + e.yyx) +\n    e.yxy * Cube(p + e.yxy) +\n    e.xxx * Cube(p + e.xxx));\n}\n\nvec3 RubberCube()\n{\n  const vec3 lightPos = vec3(1.5, 0, 0);\n  vec3 cubeColor = aColor;\n  float rDist = 0.0,   near = -1.0;\n  float rStep = 1.0,   far = -1.0;\n  float hd = -1.;\n  vec3 ro = vec3 (0.0, 0.0, 2.1);\n  vec3 rd = normalize (vec3(uv * aspect, -2.0));\n  for(int i = 0; i < 256; i++)\n  {\n    rStep = Cube (ro +rd*rDist);\n    rDist += rStep*0.5;\n    if (rDist > 4.0) break;\n    if (rStep < 0.001)\n    {\n      far = Face( cubevec.yx) +Face(-cubevec.yx) +Face( cubevec.xz) \n          + Face(-cubevec.xz) +Face( cubevec.zy) +Face(-cubevec.zy);\n    \tif(hd < 0.0) hd = rDist;\n      if (near < 0.0) near = far;\n    \tif (!mousePressed) rDist += 0.05;  // 0.05 is a magic number \n      else break; \n    }\n  }\n  if (near > 0.0)\n  {\n    vec3 sp = ro + rd*hd;\n    vec3 ld = lightPos - sp;\n    float lDist = max(length(ld), 0.001);\n    ld /= lDist;\n    float atten = 1. / (1. + lDist*0.2 + lDist*0.1); \n    float ambience = 0.7;\n    vec3 sn = getNormal( sp);\n    float diff = min(0.3,max( dot(sn, ld), 0.0));\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n    float mv = near*0.45 +far*far*0.04;  \n    const vec3 color1  = vec3(0.2, 0.0, 1.0);\n    const vec3 color2  = vec3(1.0, 1.0, 1.0);\n    const vec3 specCol = vec3(0.8, 0.5, 1.0);  \n    cubeColor = mix(color1, color2, mv);\n    if(!mousePressed) \n         cubeColor += aColor / 3.0;   // add some back color\n    cubeColor *= diff +ambience +specCol*spec/1.5;\n  }\n  return cubeColor;\n}\n//------------------------------------------- \n// render famous amiga ball\n//------------------------------------------- \nvec3 AmigaBall()\n{\n  vec3 backColor = vec3(0.03);\n  vec3 ballColor1 = vec3(1);      // white\n  vec3 ballColor2 = vec3(1,0,0);  // red\n\n  float a = 0.3,   c = cos(a),   s = sin(a);\n  vec2 p, \n    off = vec2(1./4.0, 1./3.24),\n    R = iResolution.xy,  \n    U = pos * aspect;\n    p.x = mod(time+1.25, 5.)/2.5, \n    p.y = mod(time,     5.2)/2.6;\n    p = min(p,2.0 - p); \n    p.y *= p.y;\n    p = off + p*(aspect -2.0*off);\n  vec2 \n    gh = 4.0*(p - vec2(U.x,1.-U.y)),\n    xy = mat2(c,-s,s,c) * gh;\n  float \n    f = xy.y, \n    rad = length(gh),\n    r = min(U, aspect-U).x,\n    val = floor( 2.*(9.+5.*p.x/aspect.x + xy.x/sqrt(1.-f*f)) )\n        + floor( 9.*(2.+f*.2) );\n    if (rad < 1.0)\n      return (1.4-rad) * (mod(val,2.0)<0.5 ? ballColor1: ballColor2);\n    return aColor;\n}\n//----------------------------------------------------------\n// render 2d starfield\n//----------------------------------------------------------\nfloat rand (in vec2 uv)\n{\n  return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241);\n}\n\nfloat noise (in vec2 uv)\n{\n  vec2 b = floor(uv);\n  return mix(mix(rand(b),rand(b+1.),.5),mix(rand(b+0.1),rand(b+1.),.5),.5);\n}\n\nvec3 Starfield2d()\n{\n  float stars = 0.;\n  for (float layer = 0.; layer < 4.; layer++)\n  {\n    float s = 320. +20.*layer;\n    float n = noise(mod(vec2(uv.x*s +18. * time - layer*444., uv.y*s),iResolution.x));\n    stars += step(0.1, pow(n,18.)) * (layer / float(6.));\n  }\n  return vec3(stars);\n}\n//----------------------------------------------------------\n// render plasma background\n//----------------------------------------------------------\nvec3 Plasma()\n{\n  float fScale = 2.1;\n  float t1 = time * 0.01;\n  float t2 = time * 0.8;\n  vec2 p = pos*5.0;  \n  for(int i=1; i<33; i++) \n  {\n    vec2 newp = p;\n    newp.x += 0.25/float(i)*cos(float(i)*p.y+t1*cos(t2)*0.3/40.0+0.03*float(i))*fScale-t1;\t\t\n    newp.y += 0.50/float(i)*cos(float(i)*p.x+t1*t2*0.3/50.0+0.03*float(i+10))*fScale+12.34;\n    p = newp;\n  }\n  vec3 col = 0.2 * vec3(0.5*sin(3.0*p.x)+0.5, 0.5*sin(3.0*p.y)+0.5, sin(p.x+p.y)) + 0.2;\n  return col;\n}\n\n//----------------------------------------------------------\n#define BACK_DEMOS 4.\n#define MAIN_DEMOS 5.\n\nint backDemo = 0;   \nint mainDemo = 0;  \n\nvec3 frameDrawing()   // frame and background drawing\n{\n  float rep = 128.;   // try 8 16 32 64 128 256 ...\n  float df = gl_FragCoord.x / rep + time * 5.0;\n  if (pos.y < 0.5) df *= -1.0;\n  vec3 color = vec3(0.5 + 0.5 * sin(df + 3.1415)\n                   ,0.5 + 0.5 * cos(df)\n                   ,0.5 + 0.5 * sin(df));\n  if (pos.y > 0.945 && pos.y<0.95)  return color;\n  if (pos.y > 0.05  && pos.y<0.055) return color;\n  if (pos.y < 0.05  || pos.y>0.95)  return vec3 (0.0, 0.15, 0.25);\n \n  if      (backDemo == 1) return vec3(0);\n  else if (backDemo == 2) return Starfield2d();\n  else if (backDemo == 3) return Plasma();\n  return vec3(0);\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  mousePressed = (iMouse.z > 0.5);\n  pos = fragCoord.xy / iResolution.xy; //  0 .. 1\n  uv = pos * 2.0 - 1.0;                // -1 .. 1\n  aspect = iResolution.xy / iResolution.y;\n\n  mainDemo = 0;\n  if      (ReadKey(KEY_1, false)) mainDemo = 1;\n  else if (ReadKey(KEY_2, false)) mainDemo = 2;\n  else if (ReadKey(KEY_3, false)) mainDemo = 3;\n  else if (ReadKey(KEY_4, false)) mainDemo = 4;\n\n  backDemo = 0;\n  if      (ReadKey(KEY_F1, false)) backDemo = 1;\n  else if (ReadKey(KEY_F2, false)) backDemo = 2;\n  else if (ReadKey(KEY_F3, false)) backDemo = 3;\n  else if (ReadKey(KEY_F4, false)) backDemo = 4;\n\n  if (mainDemo == 0)      \n    mainDemo = int(mod(time*0.08, MAIN_DEMOS));\n\n  if (backDemo == 0)      \n    backDemo = int(mod(time*0.1, BACK_DEMOS));\n      \n  aColor = frameDrawing();\n    \n  if      (mainDemo == 1) aColor += RGB_Bars();\n  else if (mainDemo == 2) aColor += Copper();\n  else if (mainDemo == 3) aColor = RubberCube();\n  else if (mainDemo == 4) aColor = AmigaBall();\n\n  aColor = ScrollText1();\n  aColor = ScrollText2();\n\n  fragColor = vec4(aColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}