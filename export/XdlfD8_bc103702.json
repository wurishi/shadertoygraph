{"ver":"0.1","info":{"id":"XdlfD8","date":"1496126291","viewed":348,"name":"Subset Sum Automata","username":"pixartist","description":"Subset Sum Automata\nSpace -> noise\nR -> reset, C -> clear\nq/a, w/s, e/d, t/g -> change offset, reward, penalty, seed range (hold shift to quick change)\nLMB -> paint\nSome rules can be found here: https://thquinn.github.io/projects/automaton.html","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["automata","sum","subset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define FRAMESPERSTEP 1\n\n#define R(i) (texture(iChannel1, (vec2(i,0)+vec2(.5))/iResolution.xy))\n\n#define RESET 0\n#define ORP 1\n#define CLEAR 2\n#define SR 3\n\nfloat seed;\nvec2 uv;\nvec2 fc;\nivec3 orp;\nfloat rand() \n{ \n    vec2 s = uv;\n    float n = fract(sin(seed+=1.0)*43758.5453123);\n    return fract(n + fract(sin(dot(vec2(n * s.y, s.x)*0.123,vec2(12.9898,78.233))) * 43758.5453));\n}\nint get(int x, int y)\n{\n    vec2 coord = (fc.xy + vec2(x,y)) / iResolution.xy;\n    return int(texture(iChannel0, mod(coord, vec2(1.0))).x);\n}\nint getSum(int[8] n, int self)\n{\n    int target = self + orp.x;\n    int c = 0;\n    for (int i = 1; i < 256; i++) {\n        int sum = 0;\n        for (int j = 0; j < 8; j++) {\n            if ((i >> j) % 2 == 1) {\n                sum += n[j];\n            }\n        }\n        if(sum == target)\n            c++;\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fc = fragCoord;\n    uv = fragCoord.xy / iResolution.xy;\n    seed = (uv.y * 9.1234 + (iTime +4324.123) * 0.523413187) * sqrt(uv.x * 0.77777777 * (iTime + 923.132));\n    orp = ivec3(R(ORP).xyz);\n    float seedrange = R(SR).x;\n    int nbs[8];\n    int i = 0;\n    for(int x = -1; x <= 1 ; x++)\n    {\n        for(int y = -1; y <= 1 ; y++)\n    \t{\n            if(x != 0 || y != 0)\n            {\n                nbs[i] = get(x,y);\n                i++;\n            }\n        }\n    }\n    int self = get(0,0);\n    if(iFrame % FRAMESPERSTEP == 0)\n    {\n        int res = getSum(nbs, self);\n        if(res > 0)\n            self = max(0, self + orp.y);\n        else\n            self = max(0, self - orp.z);\n    }\n    fragColor = vec4(self, 0.0, 0.0, 1.0);\n    if(R(RESET).x > 0.0)\n    {\n        fragColor.x = floor(rand() * seedrange+1.0);\n    }\n    if(R(CLEAR).x > 0.0)\n    {\n        fragColor = vec4(0.0);\n    }\n    if(iMouse.z > 0.0 && distance(iMouse.xy, fragCoord.xy) < 10.0)\n    {\n        fragColor.x = floor(rand() * seedrange+1.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40,kCtrl=17, kShift=16;\n#define PI 3.14159265359\n\n#define K(key) (texture( iChannel0, vec2( (float(key)+.5)/256.0, .25 ) ).x > 0.0)\n#define R(i) (texture(iChannel1, (vec2(i,0)+vec2(.5))/iResolution.xy))\n#define S(i, code) if(int(fragCoord.y) == 0 && int(fragCoord.x) == i) {code}\n\n#define RESET 0\n#define ORP 1\n#define CLEAR 2\n#define SR 3\n\nbool kOnce(int k, vec4 self, inout float newA)\n{\n    bool res = false;\n    if(K(k))\n    {\n        if(self.a <= 0.0)\n            res = true;\n        newA = 1.0;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool reset = iFrame < 5 || K(kR);\n    vec4 self = R(int(fragCoord.x)); \n    if(reset)\n    {\n        S(RESET,\n          self = vec4(1);\n          );\n        S(ORP,\n          self = vec4(123, 53, 12, 0);\n          );\n        S(SR,\n          self = vec4(200,0,0,0);\n          );\n         S(CLEAR,\n          self = vec4(0);\n          );\n    }\n    else\n    {\n        S(RESET,\n          self = vec4(0);\n          if(K(kSpace))\n          \tself = vec4(1);\n          );\n        S(ORP,\n          bool shift = K(kShift);\n          float am = shift ? 10.0 : 1.0;\n        self.a -= 0.1;\n        float newA = 0.0;\n        if(kOnce(kQ, self, newA))\n            self.x += am;\n          if(kOnce(kA, self, newA))\n          \tself.x = self.x - am;\n          if(kOnce(kW, self, newA))\n          \tself.y += am;\n          if(kOnce(kS, self, newA))\n          \tself.y = max(0.0, self.y - am);\n          if(kOnce(kE, self, newA))\n          \tself.z += am;\n          if(kOnce(kD, self, newA))\n          \tself.z = max(0.0, self.z - am);\n          if(self.a <= 0.0)\n          \tself.a = newA;\n          );\n         S(CLEAR,\n           if(K(kC))\n          \tself = vec4(1);\n           else\n           \tself = vec4(0.0);\n          );\n        S(SR,\n           bool shift = K(kShift);\n          float am = shift ? 10.0 : 1.0;\n          self.a -= 0.1;\n        float newA = 0.0;\n        if(kOnce(kT, self, newA))\n            self.x += am;\n        if(kOnce(kG, self, newA))\n            self.x = max(0.0, self.x - am);\n          if(self.a <= 0.0)\n          \tself.a = newA;\n          );\n    }\n    fragColor = self; \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define R(i) (texture(iChannel2, (vec2(i,0)+vec2(.5))/iResolution.xy))\n\n#define RESET 0\n#define ORP 1\n#define SR 3\n//== font handling ================================================\nvec2 uv = vec2(0.0);  // -1 .. 1\n#define FONT_SPACE 0.5\n\nvec2 tp = vec2(1.0);  // text position\n\nconst vec2 vFontSize = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n#define _     tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);  tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);   // :-)        \n#define _exc   S(33);   // !\n#define _add   S(43);   // +\n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n//---------------------------------------------------------\n// return font image intensity of character ch at text position tp\n//---------------------------------------------------------\n\n//float char(float ch)    // old versions\n//{ vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n//  vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,16.-(1e-6)-floor(ch)/16.))/16.));  \n    \nfloat char(int ch)\n{\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp))) \n               ? vec4(0) \n               : texture(iChannel1,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));  \n  //if (iMouse.z > 0.0) \n    return f.x;   // 2d \n  //else\n  //  return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n//----------------------------------------------------------------\n// set text starting position to x=line, y=column (left/top = 1,1) \n//----------------------------------------------------------------\nvoid SetTextPosition(float x, float y)  //\n{\n  tp = 10.0*uv;\n  tp.x = tp.x +17. - x;\n  tp.y = tp.y -9.4 + y;\n}\n//--- display number fraction with leading zeros --- \nfloat drawFract(float value, int digits)\n{ \n  float c = 0.0;\n  value = fract(value) * 10.0;\n  for (int ni = 1; ni < 60; ni++) \n  {\n    c += char(48 + int(value)); // add 0..9\n    tp.x -= FONT_SPACE;\n    digits -= 1;\n    value = fract(value) * 10.0;\n    if (digits <= 0 || value == 0.0) break;\n  } \n  tp.x -= FONT_SPACE*float(digits);\n  return c;\n}\n//--- display integer value --- \nfloat drawInt(int value, int minDigits)\n{\n  float c = 0.;\n  if (value < 0) \n  { value = -value;\n    if (minDigits < 1) minDigits = 1;\n    else minDigits--;\n    _sub                   // add minus char\n  } \n  int fn = value, digits = 1; // get number of digits \n  for (int ni=0; ni<10; ni++)\n  {\n    fn /= 10;\n    if (fn == 0) break;\n    digits++;\n  } \n  digits = max(minDigits, digits);\n  tp.x -= FONT_SPACE * float(digits);\n  for (int ni=1; ni < 11; ni++) \n  { \n    tp.x += FONT_SPACE; // space\n    c += char(48 + (value-((value/=10)*10))); // add 0..9 \n    if (ni >= digits) break;\n  } \n  tp.x -= FONT_SPACE * float(digits);\n  return c;\n}\n\n//--- display float value ---\nfloat drawFloat(float value, int prec, int maxDigits)\n{ \n  float tpx = tp.x-FONT_SPACE*float(maxDigits);\n  float c = 0.;\n  if (value < 0.0) \n  { \n    c = char(45); // write minus sign\n    value = -value;\n  }\n  tp.x -= FONT_SPACE;\n  c += drawInt(int(value),1);\n  c += char(46); SPACE; // add dot \n  c += drawFract(fract(value), prec);\n  tp.x = min(tp.x, tpx);\n  return c;\n}\n\nfloat drawFloat(float value)           {return drawFloat(value,2,5);} \n\nfloat drawFloat(float value, int prec) {return drawFloat(value,prec,2);} \n\nfloat drawInt(int value)               {return drawInt(value,1);}\n// define center coodinates\n#define CC(c) (2.0 * c / iResolution.xy - 1.0) * ratio;\nfloat renderText()\n{\n    vec3 orp = R(ORP).xyz;\n    float sr = R(SR).x;\n    SetTextPosition(0.0,-3.5);\n    float c = 0.0;\n    _O _f _f _s _e _t _ddot SPACE\n        c += drawInt(int(orp.x), 5);\n\t SPACE SPACE SPACE SPACE SPACE\n    _R _e _w _a _r _d _ddot SPACE\n        c += drawInt(int(orp.y), 5);\n     SPACE SPACE SPACE SPACE SPACE\n    _P _e _n _a _l _t _y _ddot SPACE\n        c += drawInt(int(orp.z), 5);\n     SPACE SPACE SPACE SPACE SPACE\n    _S _e _e _d _r _a _n _g _e _ddot SPACE\n        c += drawInt(int(sr), 5);\n\treturn c;\n}\nfloat delta(float v, float t, float d)\n{\n    return 1.0 - min(1.0, abs(t-v) / d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n    uv = CC(fragCoord.xy * 1.2);        // -1 .. 1\n    vec3 textColor = vec3(clamp(renderText(), 0.0, 1.0));\n    float x = texture(iChannel0, fragCoord.xy/iResolution.xy).x;\n    vec3 board = vec3(delta(x, 40.0, 40.0), delta(x, 100.0, 60.0), smoothstep(100.0, 300.0, x));\n    fragColor = vec4(mix(board, textColor, textColor), 1.0);\n\n   // fragColor += vec4(drawInt(int(orp.x), 5) * 20.0);\n   // fragColor += vec4(drawInt(int(orp.y), 5) * 20.0);\n   // fragColor += vec4(drawInt(int(orp.z), 5) * 20.0);\n}","name":"Buf C","description":"","type":"buffer"}]}