{"ver":"0.1","info":{"id":"mscXDn","date":"1679628619","viewed":148,"name":"My Hexagon Grid","username":"isaacchurchill","description":"I wanted to write a shader that draws a grid of hexagons without me looking up a distance function.\nIt was a lot harder than I thought.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["2d","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float HEX_DIST_TO_CORNER = sqrt(3.0) / 3.0;\nconst float DOWNWARD_HEX_SLOPE = -HEX_DIST_TO_CORNER;\n\nfloat randomFloat(float seed)\n{\n    // I wrote this from my vague memory of how others do this, I don't recommend copying this\n    return abs(fract(sin(seed * 2349.7) * 33324.3832));\n}\n\nvec3 randomColor(float seed)\n{\n    return vec3(randomFloat(seed), randomFloat(seed * 1.332), randomFloat(seed * 1.4));\n}\n\nbool isInOddRow(vec2 p)\n{\n    p.y = mod(p.y + HEX_DIST_TO_CORNER * 1.5, HEX_DIST_TO_CORNER * 3.0) - HEX_DIST_TO_CORNER * 1.5;\n    p.y = abs(p.y);\n    p.x = mod(p.x + 0.5, 1.0) - 0.5;\n    p.x = abs(p.x);\n    \n    bool isUnderLine = p.y < p.x * DOWNWARD_HEX_SLOPE + HEX_DIST_TO_CORNER;\n    return !isUnderLine;\n}\n\nvec3 hexagons(vec2 p)\n{\n    p *= 10.0 * (sin(iTime) + 1.1);\n    if (isInOddRow(p)) {\n        p.x += 0.5;\n        p.y -= HEX_DIST_TO_CORNER * 1.5;\n        float colNum = trunc(p.x + sign(p.x) * 0.5);\n        float rowNum = trunc(p.y / (HEX_DIST_TO_CORNER * 3.0) + sign(p.y) * 0.5);\n\n        float colorSeed = colNum + randomFloat(rowNum) + 234.0;\n        return randomColor(colorSeed);\n        //float colorFactor = colNum + rowNum * 3.342 + 10.0;\n        //return vec3(sin(colorFactor), sin(colorFactor + 1.0), sin(colorFactor + 2.0));\n    } else {\n        float colNum = trunc(p.x + sign(p.x) * 0.5);\n        float rowNum = trunc(p.y / (HEX_DIST_TO_CORNER * 3.0) + sign(p.y) * 0.5);\n\n        float colorSeed = colNum + randomFloat(rowNum);\n        return randomColor(colorSeed);\n        //float colorFactor = colNum + rowNum * 4.322;\n        //return vec3(sin(colorFactor), sin(colorFactor + 1.0), sin(colorFactor + 2.0));\n    }\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = hexagons(uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}