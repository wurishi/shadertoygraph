{"ver":"0.1","info":{"id":"DsGyRG","date":"1699627130","viewed":36,"name":"Projet Ray tracing Mif02 ","username":"Dor2Plat","description":"Source code for ray-tracing assignment","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"fl2yz3","parentname":"M1 - Ray tracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Source :\n- Cylinder : https://hugi.scene.org/online/hugi24/coding%20graphics%20chris%20dragan%20raytracing%20shapes.htm\n- Box : https://web.cse.ohio-state.edu/~shen.94/681/Site/Slides_files/basic_algo.pdf\n- Eclairement/atténuation : https://opengl.developpez.com/tutoriels/apprendre-opengl-2/?page=sources-de-lumieres\n- Surface color : https://learnwebgl.brown37.net/10_surface_properties/surface_properties_color.html\n- Ma petit bible du ray-tracing : https://www.scratchapixel.com/\n*/\n\n\nconst int MAX_LIGHTS = 64;\nconst int MAX_COLORS = 12; \n\n/////////////////////////////////////////////////////////////\n// \t                        UTILS                          // \n/////////////////////////////////////////////////////////////\n\nvec3 Hemisphere(int seed,vec3 n) {\n\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n) < 0.){d=-d;}// Hemishpere\n\n    return d;\n}\n\nvec3 RayWithAngle(int seed, vec3 n, float angle) {\n    // Convertir l'angle en radians\n    float radians = radians(angle);\n\n    float a = fract(sin(176.19 * float(seed))); // Uniform randoms\n    float b = fract(sin(164.19 * float(seed)));\n\n    float u = 2.0 * 3.1415 * a;\n    float v = acos(2.0 * b - 1.0);\n\n    vec3 tangentVec = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));\n\n    vec3 orthoVec = cross(n, tangentVec);\n\n    vec3 d = normalize(n * cos(radians) + tangentVec * sin(radians));\n\n    return d;\n}\n\n/////////////////////////////////////////////////////////////\n// \t                        SHAPES                         // \n/////////////////////////////////////////////////////////////\n\nstruct Sphere {\n    vec3 center; // Center\n    float radius; // Radius\n    int id; // Texture Id\n    int objetId;\n};\n\nstruct Cylinder {\n    vec3 extremityA, extremityB; // Extremety\n    float radius;// Radius of the cylinder\n    int id;// Texture Id\n    int objetId;\n};\n\nstruct Plane{\n    vec3 normal; // Normal\n    vec3 point; // Point\n    int id; // Texture Id\n    int objetId;\n};\n\nstruct Box{\n    vec3 mini, maxi; // Minimum and maximum coordonates\n    int id; // Texture Id\n    int objetId;\n};\n\n/////////////////////////////////////////////////////////////\n// \t                RAY TRACING STRUCTURE                  // \n/////////////////////////////////////////////////////////////\n\nstruct Hit{\n    float t; // Intersection depth\n    vec3 normal;// Normal\n    int id;// Texture Id\n    int objetId; // The id of the hitting objet\n};\n\nstruct Ray{\n    // Ray = origin + direction * t\n    vec3 origin;// Origin\n    vec3 direction;// Direction\n};\n\nstruct PunctualLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n    // Paramètre d'atténuation (distance 65)\n    float constant;\n    float linear;\n    float quadratic;\n} plights[1]; // only one for the moment\n\n// Compute point on ray (hitting point)\nvec3 Point(Ray ray, float t)\n{\n    return ray.origin + t * ray.direction;\n}\n\n/////////////////////////////////////////////////////////////\n// \t                 PLACEMENT OPERATOR                    // \n/////////////////////////////////////////////////////////////\n\n// Translation\n// Moove the box in terms of coefficient\nRay translation(vec3 translation, Ray originRay) {\n    originRay.origin = originRay.origin - translation;\n    return originRay;\n}\n\n// Homothétie\nRay homothetie(float scale, Ray originRay) {\n    float scaleInvers = 1. / scale;\n    mat3 scaler = mat3(\n        vec3(scaleInvers, 0., 0.),\n        vec3(0., scaleInvers, 0.),\n        vec3(0., 0., scaleInvers)\n     );\n        \n    originRay.origin = scaler * originRay.origin;\n    return originRay;\n}\n\n\n// Rotation\nRay rotateX(float angle, Ray originRay) {\n    mat3 rotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angle), -sin(angle),\n        0.0, sin(angle), cos(angle)\n    );\n\n    Ray rotatedRay;\n\n    // Apply the rotation matrix to the origin\n    rotatedRay.origin = rotationMatrix * originRay.origin;\n\n    // Apply the same rotation to the direction\n    rotatedRay.direction = rotationMatrix * originRay.direction;\n\n    return rotatedRay;\n}\n\nRay rotateY(float angle, Ray originRay) {\n    mat3 rotationMatrix = mat3(\n        cos(angle), 0.0, sin(angle),\n        0.0, 1.0, 0.0,\n        -sin(angle), 0.0, cos(angle)\n    );\n\n    Ray rotatedRay;\n\n    // Apply the rotation matrix to the origin\n    rotatedRay.origin = rotationMatrix * originRay.origin;\n\n    // Apply the same rotation to the direction\n    rotatedRay.direction = rotationMatrix * originRay.direction;\n\n    return rotatedRay;\n}\n\nRay rotateZ(float angle, Ray originRay) {\n    mat3 rotationMatrix = mat3(\n        cos(angle), -sin(angle), 0.0,\n        sin(angle), cos(angle), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    Ray rotatedRay;\n\n    // Apply the rotation matrix to the origin\n    rotatedRay.origin = rotationMatrix * originRay.origin;\n\n    // Apply the same rotation to the direction\n    rotatedRay.direction = rotationMatrix * originRay.direction;\n\n    return rotatedRay;\n}\n\n/////////////////////////////////////////////////////////////\n// \t                MATERIALS & TEXTURES                   // \n/////////////////////////////////////////////////////////////\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w = fwidth(p) + .001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p-.5*w)*.5)-.5) - abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return .5 - .5 * i.x * i.y;\n}\n\nvec3 getDamier(vec3 p) {\n    float f = Checkers(.5 * p.xy);\n    vec3 res = vec3(.4,.4,.7) + f* vec3(1.);\n    return res;\n}\n\n\n\nfloat simpleRand(vec3 p) {\n    return 0.1 * (sin(p.x) + cos(p.x + 2.) + sin(p.y + 4.));\n}\n\nstruct Material {\n    /* Different phong material \n        - -1 = No phong color\n        - 0 = Gold\n        - 1 = Polished Silver\n        - 2 = Emerald\n        - 3 = Jafe\n        - 4 = Obsisian\n        - 5 = Ruby\n        - 6 = Turquoise\n        - 7 = Black Plastic\n    */\n    //Phong colors and coefficient between [.0, 1.]\n    vec3 ambiant; // lumière ambiant (diffusion de la lumière dans toutes les directions)\n    float aCoef;\n    vec3 diffuse; // lumière rélféchie depuis la surface de l'objet \n    float dCoef;\n    vec3 specular; // lumière réfléchie de manière brillante et concentrée à partir de la surface de l'objet\n    float sCoef; \n    // Shininess [.0, 100.]\n    float shin;   \n    bool isReflected;\n    bool isRefracted;\n} materials[MAX_COLORS];\n\n/////////////////////////////////////////////////////////////\n// \t                    LIGTHING CODE                      // \n/////////////////////////////////////////////////////////////\n\nvoid initPhongMaterials() {\n    // 0 = Gold\n    materials[0] = Material(vec3(0.24725,0.1995,0.0745), 1., vec3(0.75164,0.60648,0.22648), 1., \n        vec3(0.628281,0.555802,0.366065), 1., 51.2, false, false);\n    // 1 = Polished Silver\n    materials[1] = Material(vec3(0.23125,0.23125,0.23125), 1., vec3(0.2775,0.2775,0.2775), 1., \n        vec3(0.773911,0.773911,0.773911), 1., 89.6, true, false);\n    // 1' = Silver\n    //materials[1] = Material(vec3(0.19225,0.19225,0.19225), 1., vec3(0.50754,0.50754,0.50754), 1., \n        //vec3(0.508273,0.508273,0.508273), 1., 51.2, true, false);\n    // 2 = Emerald\n    materials[2] = Material(vec3(0.0215,0.1745,0.0215), .55, vec3(0.07568,0.61424,0.07568), .55, \n        vec3(0.633,0.727811,0.633), .55, 76.8, true, false);\n    materials[3] = Material(vec3(0.135,0.2225,0.1575), .95, vec3(0.54,0.89,0.63), .95, \n        vec3(0.316228,0.316228,0.316228), .95, 12.8, false, false);\n    materials[4] = Material(vec3(0.1745,0.01175,0.01175), .55, vec3(0.61424,0.04136,0.04136), .55, \n        vec3(0.727811,0.626956,0.626956), .55, 76.8, true, false);\n    materials[5] = Material(vec3(0.1745,0.01175,0.01175), .55, vec3(0.61424,0.04136,0.04136), .55, \n        vec3(0.727811,0.626956,0.626956), .55, 76.8, false, true);\n}\n\n\n//n = objet normal, i = incendent ray, substanceIndex index of refraction\nvec3 getRefractedRay(vec3 n, vec3 i, float substanceIndex1, float substanceIndex2) {\n    float eta1 = substanceIndex1; // Air\n    float eta2 = substanceIndex2; // 1.3 = Glace\n    float eta = eta1/ eta2;\n    float c1 = dot(n, i);\n    if (c1 < 0.) {\n        c1 = -c1;\n    } else {\n        n = -n;\n        eta = 1. / eta;\n    }\n    float theta = acos(c1);\n    float c2 = sqrt(1. - eta * eta * sin(theta) * sin (theta));\n    vec3 t = eta * i + n * (eta * c1 - c2);\n    return t;\n}\n\n\n/////////////////////////////////////////////////////////////\n// \t                       TEXTURES                       // \n/////////////////////////////////////////////////////////////\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    switch(i) {\n        case 0 :\n            return materials[0]; // Gold\n        case 1 :\n            return materials[1]; // Silver\n        case 2 :\n            return materials[2]; // Emerald\n        case 3 :\n            return materials[3]; // Jade\n        case 4 :\n            return materials[4]; // Ruby\n        case 5 :\n            return materials[5];\n        case 8 : // Concentrique + ruby\n            float dc1 = 9.;\n            float intervalle1 = 8.;\n            vec3 col1 = vec3(dc1 * sin(2. * 11. / intervalle1 * sqrt(dot(p, p)))); \n            materials[8] = materials[4];\n            materials[8].ambiant  = materials[4].ambiant * col1;\n            return materials[8];\n        case 9 : // Concentrique + noice + jade\n            float dc2 = 5.;\n            float intervalle2 = 3. + simpleRand(p);\n            vec3 col2 = vec3(dc2 * sin(2. * 11. / intervalle2 * sqrt(dot(p, p)))); \n            materials[9] = materials[3];\n            materials[9].ambiant  = materials[3].ambiant * col2;\n            materials[9].isReflected = true;\n            return materials[9];\n        case 10 : // Weird but nice\n            float dc3 = 5.;\n            float intervalle3 = 1.5;\n            vec3 col3 = vec3(dc3 * sin(simpleRand(p) * 11. / intervalle3 * sqrt(dot(p, p)))); \n            materials[10] = Material(col3, 1., vec3(1.), 1., vec3(1.), 1., 0., true, false);\n            return materials[10];\n        case 11 : // Damier\n            float f=Checkers(.9*p.xy);\n            vec3 col4 = vec3(.4,.5,.7)+f*vec3(.1);\n            materials[11] = Material(col4, 1., vec3(1.), 1., vec3(1.), 1., 0., true, false); // TODO Changer les couleurs du damier\n            return materials[11];\n        default:\n            return materials[0];;\n    }\n}\n\n/////////////////////////////////////////////////////////////\n// \t                    INTERSECTION                       // \n/////////////////////////////////////////////////////////////\n\n// Sphere intersection\n// ray : The ray (origin and direction)\n//   x : Returned intersection information (depth t and n the normal)\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x)\n{\n    vec3 dist_orign_centre = ray.origin - sph.center;\n    // no a because a = 1\n    float b = dot(ray.direction, dist_orign_centre);\n    float c = dot(dist_orign_centre, dist_orign_centre) - sph.radius * sph.radius;\n    \n    float d = b * b - c;\n    \n    if (d > 0.)\n    {\n        float t = -b - sqrt(d);\n        if (t > 0.)\n        {\n            vec3 p = Point(ray, t);\n            x = Hit(t,normalize(p - sph.center), sph.id, sph.objetId);\n            \n            return true;\n        }\n    }\n    return false;  \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    //P = O + D*t\n    //t = -X|V / D|V\n\n    float t = -dot(ray.origin - pl.point, pl.normal) / dot(ray.direction, pl.normal);\n    if (t > 0.)\n    {\n        x = Hit(t, vec3(0,0,1.),pl.id, pl.objetId);\n        return true;\n    }\n    return false;\n}\n\n// Cylinder \n// ray : The ray\n//   x : Returned intersection information\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3 cylinder_axis = normalize(cyl.extremityB - cyl.extremityA);\n    vec3 center = cylinder_axis / 2.;\n    vec3 dist_orign_centre = ray.origin - cyl.extremityA;\n    \n    float maxh = length(cyl.extremityB - cyl.extremityA);\n\n    float a = 1. - pow(dot(ray.direction, cylinder_axis), 2.0);\n    float b_half = dot(ray.direction, dist_orign_centre) - dot(ray.direction, cylinder_axis) * dot(dist_orign_centre, cylinder_axis);\n    float c = dot(dist_orign_centre, dist_orign_centre) - pow(dot(dist_orign_centre, cylinder_axis), 2.0) - cyl.radius * cyl.radius;\n\n    float discriminant = b_half * b_half - a * c;\n    \n    if (discriminant < 0.0) return false;\n   \n   \n    float t1 = (-b_half - sqrt(discriminant)) / a;\n    float t2 = (-b_half + sqrt(discriminant)) / a;\n\n    if (t1 < 0.0 || t2 < 0.0) return false;\n   \n\n    float height1 = dot(ray.direction, cylinder_axis) * t1 + dot(dist_orign_centre, cylinder_axis);\n    float height2 = dot(ray.direction, cylinder_axis) * t2 + dot(dist_orign_centre, cylinder_axis);\n   \n\n    bool hit1 = (t1 > 0.0 && height1 >= 0.0 && height1 <= maxh);\n    bool hit2 = (t2 >= 0.0 && height2 >= 0.0 && height2 <= maxh);\n\n    vec3 hit_point = ray.origin + (ray.direction * t1);\n\n\n    if (hit1) {\n        x = Hit(t1, normalize(hit_point - cyl.extremityA - cylinder_axis * height1), cyl.id, cyl.objetId);\n        return true;\n    }\n    \n    /*} else { // Ends caps (doesn't works)\n        Plane endCap1 = Plane(cyl.extremityA, -cylinder_axis, cyl.id, 69);\n        Plane endCap2 = Plane(cyl.extremityB, cylinder_axis, cyl.id, 70);\n        Hit current;\n        if (IntersectPlane(ray,endCap1,current)&&current.t<x.t) {\n            x=current;\n            return true;\n        } else if (IntersectPlane(ray,endCap2,current)&&current.t<x.t) {\n            x=current;\n            return true;\n        }\n        return false\n        */\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n    vec3 invDir = 1.0 / ray.direction;\n    vec3 t1 = (box.mini - ray.origin) * invDir;\n    vec3 t2 = (box.maxi - ray.origin) * invDir;\n\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (tNear <= tFar && tFar > 0.0)\n    {\n        vec3 hitPoint = ray.origin + ray.direction * tNear;\n\n        // Determine the normal of the hit point based on which face of the box was hit\n        vec3 normal;\n\n        if (tNear == t1.x) normal = vec3(-1.0, 0.0, 0.0);\n        else if (tNear == t1.y) normal = vec3(0.0, -1.0, 0.0);\n        else if (tNear == t1.z) normal = vec3(0.0, 0.0, -1.0);\n        else if (tNear == t2.x) normal = vec3(1.0, 0.0, 0.0);\n        else if (tNear == t2.y) normal = vec3(0.0, 1.0, 0.0);\n        else if (tNear == t2.z) normal = vec3(0.0, 0.0, 1.0);\n\n        x = Hit(tNear, normalize(normal), box.id, box.objetId);\n        return true;\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////\n// \t                    SCENE METHODS                      // \n/////////////////////////////////////////////////////////////\n\nvoid setupScene() {\n    PunctualLight plight1 = PunctualLight(\n        vec3(0., -1., 8.), \n        vec3(1., 1., 1.), \n        1.8,    // Intensity\n        1.,    // Constant\n        0.045,   // Linear\n        0.0075); // Quadratique\n    plights[0] = plight1;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n    // Spheres\n    Sphere sph1 = Sphere(vec3(0.,0.,.1), 1., 5, 1);\n    \n    Sphere sph2 = Sphere(vec3(3.,0.,4.5), 1.5, 2, 2);\n    \n    Box box1 = Box(vec3(-2.,-1.,-1.), vec3(-4., 1., 1.1), 2, 3);\n    \n    Box box2 = Box(vec3(4.,-3.,-1.), vec3(-5., -3.1, 5.), 1, 4);\n    \n    Cylinder cyl1 = Cylinder(vec3(3.,0.,-1.), vec3(3., 0., 3.5), 1., 4, 5);\n    \n    //Sphere sph2 = Sphere(vec3(0.,2.,3.), 1., 0, 2);\n        \n    Plane pl = Plane(vec3(0.,0.,-1.),vec3(0.,0.,-1.), 9, 6);\n    \n    //Plane p2 = Plane(vec3(0.,1.,0.),vec3(0.,20.,0.), 4, 4);\n      \n    x = Hit(1000.,vec3(0),-1,0); // infinie\n    Hit current;\n    bool ret = false;\n    \n \n    if(IntersectSphere(ray, sph1,current)&&current.t<x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray, sph2,current)&&current.t<x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectBox(ray, box1,current)&&current.t<x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectBox(ray, box2,current)&&current.t<x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCylinder(ray, cyl1,current)&&current.t<x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    \n    if(IntersectPlane(ray ,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    /*\n    if(IntersectPlane(ray ,p2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n  \n   return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta) {\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Ambient occlusion\n////////////////////\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    if(N==0){return 1.;}\n    float ao=0.;\n    Hit osef;\n    \n    for (int i = 0; i < N; i++) {\n        bool isHit = false;\n        vec3 d = Hemisphere(i, n);\n        Ray current = Ray(p, d);\n        float rayLength = .15;\n        vec3 rayEndpoint = (p + d) * rayLength;\n\n        if (all(lessThanEqual(p, rayEndpoint))) {\n            bool isHit = Intersect(current, osef);\n        }\n        \n        ao += isHit ? .0 : 1.; // .0 if hiting \n    }\n    ao /= float(N);\n\n    return ao;\n}\n\n\nvec3 ambiantColor(int lightId, int materialId) {\n    return materials[materialId].ambiant * plights[lightId].color * materials[materialId].aCoef;\n}\n\nvec3 diffuseColor(int lightId, vec3 surfaceNormal, vec3 ligthDirection, int materialId) {\n    float diff=clamp(-dot(ligthDirection, surfaceNormal),0., 1.);\n    return materials[materialId].diffuse *  plights[lightId].color * diff * materials[materialId].dCoef;\n}\n\nvec3 specularColor(int lightId, vec3 surfaceNormal, vec3 lightDirection, vec3 viewDirection, int materialId) {\n    vec3 halfWayDir = normalize(lightDirection + viewDirection);\n    float spec = pow(clamp(-dot(surfaceNormal, halfWayDir), 0., 1.), materials[materialId].shin);\n    vec3 specular = (materials[materialId].specular * plights[lightId].color * spec) * materials[materialId].sCoef ;\n    return specular;\n}\n\nvec3 getColor(vec3 viewDirection, vec3 hitPoint, vec3 surfaceNormal, int lightId, int materialId, int objectId) {\n    vec3 lightVector = hitPoint - plights[lightId].position;\n    vec3 lightDirection = normalize(lightVector);   \n    \n    // For punctual lighting\n    float distance = length(plights[lightId].position - hitPoint);\n    float attenuation = 1.0 / (plights[lightId].constant + plights[lightId].linear * distance + plights[lightId].quadratic * (distance * distance));\n    \n    vec3 ambient = ambiantColor(lightId, materialId) * attenuation;\n    vec3 diffuse = diffuseColor(lightId, surfaceNormal, lightDirection, materialId) * attenuation;\n    vec3 specular = specularColor(lightId, surfaceNormal, lightDirection, viewDirection, materialId) * attenuation;\n  \n    vec3 color = ambient + diffuse + specular;\n    color *= plights[lightId].intensity;\n    \n    // --- OMBRES ---\n    \n    Hit osef;\n    if (Intersect(Ray(hitPoint + surfaceNormal * 0.1, -lightDirection), osef) && osef.objetId != objectId) {\n        color *= (.3 * ambient);\n    }\n    return color;   \n}\n\n\n// Rendering\n////////////\nvec3 Shade(Ray ray)\n{\n    int bounces = 2;\n    // Intersect contains all the geo detection\n    vec3 finalColor = vec3(0.);\n    vec3 hitPoint = ray.origin;\n    vec3 orginDirection = ray.direction;\n    vec3 previusHitPoint;\n    // Not intersect your self for the ray trace loop\n    int previusType = -1;\n    int previusIndex = -1;\n    bool isRefract = false;\n    bool isReflect = false;\n    \n    // Main refract and reflect loop\n    for (int i = 0; i < bounces; i++) {\n        Hit x;\n        int actualType = -1;\n        int actualIndex = -1;\n        vec3 pastColor = vec3(0.);\n        bool idx=Intersect(ray,x);\n        \n        if (previusType == x.objetId && previusIndex == i) { // Prevents intersection with yourself\n                continue;\n        }\n        \n        if(idx)\n        {\n            hitPoint = Point(ray, x.t);\n            Material mat = Texture(hitPoint, x.id);\n            float occlusion = AmbientOcclusion(hitPoint, x.normal, 20);\n            pastColor = getColor(ray.direction, hitPoint, x.normal, 0, x.id, x.objetId) * occlusion; // For now only one light\n            actualType = x.objetId;\n            actualIndex = i;\n            previusHitPoint = hitPoint;\n            isReflect = mat.isReflected;\n            isRefract = mat.isRefracted;\n        }\n        \n        if (bounces == 0) // first bounce\n        {\n            finalColor += pastColor;\n        }\n        else\n        {\n        \tfinalColor += Texture(hitPoint, x.id).specular * pastColor;\n        }\n        \n        if (actualType < 0) break;\n        \n        if (isReflect) { // Reflection\n            ray.origin = previusHitPoint + 0.01;\n            ray.direction = reflect(ray.direction, x.normal); // TODO avec le refracted ray\n            finalColor += pastColor;\n        }  \n        \n        if (isRefract) {\n            // TODO Refraction\n            //ray.origin = previusHitPoint * 0.001;\n            ray.direction = normalize(getRefractedRay(x.normal, ray.direction, 1., 1.33));\n            if (previusType != x.objetId && previusIndex != i) {\n                continue;\n            } \n            finalColor += pastColor;\n        }\n        \n       \n        \n        /*if (isRefract) { FEATURE\n            // TODO Refraction\n            vec3 refractedRay = getRefractedRay(x.normal, ray.direction, 1.3);\n\n            // Offset the hit point to avoid self-intersection\n            vec3 refractOffset = 9. * x.normal; // You may need to adjust the offset value\n\n            // Construct the new refracted ray with the offset hit point\n            Ray refractedRayObjectSpace = Ray(hitPoint + refractOffset, refractedRay);\n\n            // Update the original ray with the refracted ray\n            ray = refractedRayObjectSpace;\n            \n            // Update the final color with the refracted color\n            finalColor += pastColor;\n        }*/\n        \n        previusType = actualType;\n        previusIndex = actualIndex;\n    }\n    return finalColor / float(bounces);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // Position de la caméra (origine)\n    vec3 ro = 15.0 * normalize(vec3(sin(2.0 * 3.14 * mouse.x), cos(2.0 * 3.14 * mouse.x), 1.4 * (mouse.y - 0.1)));\n    vec3 ta = vec3(0.0, 0.0, 1.5); // Point visé par le caméra\n\n    // Init Phong color materials\n    initPhongMaterials();\n    setupScene();\n\n    mat3 ca = setCamera(ro, ta);\n\n    // Antialiasing\n    int sampleSize = 2;\n    vec3 finalColor = vec3(0.0);\n    for (int i = -sampleSize; i < sampleSize; i++)\n    {\n        for (int j = -sampleSize; j < sampleSize; j++)\n        {\n            vec2 subUV = uv + vec2(float(i) / iResolution.x, float(j) / iResolution.y);\n\n            vec3 rd = ca * normalize(vec3(subUV.xy * tan(radians(22.0)), 1.0));\n\n            finalColor += Shade(Ray(ro, normalize(rd)));\n        }\n    }\n\n    finalColor /= pow(float(sampleSize) * 2.0, 2.0);\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}