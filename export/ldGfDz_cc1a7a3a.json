{"ver":"0.1","info":{"id":"ldGfDz","date":"1528302506","viewed":88,"name":"Raymarch (Glim)","username":"Glim888","description":"Raymarch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 25\n#define MAX_INTERSECTION_DIST 0.001\n#define MAX_DIST 5000.0\n#define SUN_RAD 2.0\n\nvec3 sun_pos;\n// Ray\nstruct ray_t {\n \tvec3 o;\n \tvec3 d;    \n};\n\n// Sphere Object\nstruct sphere_t{\n\tvec3 pos;\n    vec3 col;\n    float rad;\n};\n\nmat3 rot3D (float rad) {\n  return mat3 (cos(rad), 0.0, sin(rad),\n               0.0\t   , 1.0, 0.0     ,\n               -sin(rad),0.0, cos(rad)); \n}\n\nfloat distance_from_sphere(vec3 pos, sphere_t sphere) {\n \treturn length(pos - sphere.pos) - sphere.rad;  \n}\n\nvec3 raymarch (ray_t ray, sphere_t sphere) {\n    \n    vec3 current_pos;\n    float way_done = 0.0;\n    float dist_to_sphere;\n    \n    for (int i=0; i<ITERATIONS; ++i) {\n        \n       current_pos = ray.o + ray.d*way_done;\n        \n       dist_to_sphere = distance_from_sphere(current_pos, sphere); \n        \n        if (dist_to_sphere < MAX_INTERSECTION_DIST) {\n            \n            float shading = 0.0;\n            \n            if (sun_pos != sphere.pos) {\n               shading = dot (normalize(sun_pos), normalize(current_pos-sphere.pos));\n            }else{\n               shading = 1.0;\n            }\n            \n        \treturn vec3(sphere.col.r * shading+0.1,\n                        sphere.col.g * shading+0.1,\n                        sphere.col.b * shading+0.1);  \n        }\n        \n        if (way_done > MAX_DIST) break;\n        \n        way_done += dist_to_sphere;\n        \n    }\n    \n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera Position\n    vec3 camera \t= vec3(0.0,0.0,-4.0);            \n       \n    ray_t ray \t\t= ray_t(camera,vec3(uv, 1.));\n    \n    sphere_t sphere[2];\n    \n    sphere[0] = sphere_t(vec3(0.0,-1.0, 1.0),vec3(0.5, 0.5, .5), 2.0);\n    sphere[1] = sphere_t(vec3(sin(iTime)*SUN_RAD, 2.5, 1.+cos(iTime)*SUN_RAD),vec3(1.0, 1.0, .0), 1.0);\n    \n    sun_pos = sphere[1].pos;\n    \n    vec3 col = vec3 (0.0);\n    \n    for (int i=0; i<sphere.length(); i++) \n    \tcol += raymarch(ray, sphere[i]);\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}