{"ver":"0.1","info":{"id":"wdSfWR","date":"1589815773","viewed":125,"name":"Sparse Sphere Field","username":"spalmer","description":"an example of a simple voxel march acceleration algorithm\nbased on [url]https://shadertoy.com/view/tdsfR4[/url]\nexample of CCC or FCC tiling with possibly sparse cells","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","voxel","camera","kerning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see https://shadertoy.com/view/tdsfR4\n// was originally that toy, but that toy wasn't\n// supposed to be about the spheres, but the camera,\n// so I redid that one and moved the packed spheres here.\n// I'm not a fan of this camera look method,\n// which is why I redid Fly Camera recently;\n// TODO I may back-port those changes here.\n\nconst float\n  fogdensity = .005\n;\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n    vec3 mr = March(ro, rd, 1.04, 128 + IZERO);\n    float t = mr.x // trace depth to first hit\n        , hd; // distance at hit point\n    int m = int(mr.y);\n    vec3 hp = ro + rd * t\n    , n = SceneNormal(hp, .004, hd)\n    , albedo = Material(m)\n    , light = Light(m, hp, n, -rd)\n    , c = vec3(1);\n    c *= albedo;\n    c *= light;\n    vec3 csky = vec3(.81,.91,.99);\n    c = mix(csky, c, exp2(-fogdensity * t)); // simple fog Beer's law\n    return c;\n}\n\nvec3 Render(vec3 ro, vec3 rd, float focus)\n{\n    return Render(ro, rd);\n}\n\nvec3 Render(vec2 p)\n{\n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n    // FIXME fovy hardcoded at 60\n    vec3 rv = vec3(q, 2.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n    return Render(ro, rd, 1.);\n}\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p); //\n    c = pow(c, vec3(.4545));\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// see https://shadertoy.com/view/tdsfR4\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 10.\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n  //  bool sprint; // speed boost\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n// key bindings to local directions\n#if 0 // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nbool option(int vk)\n{\n    return .5 <= texelFetch(Kbd, ivec2(vk,2), 0).x;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0))  // icon?\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move = vec3(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_UW) - key(KEY_DW)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.dt = iTimeDelta;\n}\n\nvec3 CollideSphere(vec3 pos, float radius)\n{\n    float d;\n    vec3 n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n    return pos;\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed;\n    if (key(KEY_SHIFT) > .5) spd *= 4.;\n    vec3 op = state.eyepos\n    , move = inp.move * inp.dt * spd \n    , p = op\n    ;\n   \tp += view * move;\n    p = CollideSphere(p, eyeradius);\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, iTimeDelta);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 1e4 ? .5 : 1.;\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = inp.mouse / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // wrap angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // reset\n        state.eyepos = vec3(.5,4,-3);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// see https://shadertoy.com/view/tdsfR4\n\n// can disable rhombic dodecahedron voronoi cell tiling (diamonds in 2D)\n// set to 0 for cell-centered cubic, 1 for face-centered cubic lattice\n#define FCC 1\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.) //6.28318531 //\n, voxtile = 4.\n, scale = voxtile * .5 - .001 //voxtile * .7 - .001 //1.6*.5*tile //sqrt(2.)*.5*tile //.5 // object radius\n; // FCC balls can be larger\n\nconst vec3 voxorg = vec3(0,2,0);\n\nconst int\n  mSky  = 0\n, mGray = 1\n, mRed  = 2\n;\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec3 eyevel; // or old pos? either way involves iTimeDelta\n    vec2 eyeaim;\n};\n\nconst int\n  slotResolution = 0 // still not using zw channels - could put mouse state here, or..\n, slotEyePosAz   = 1\n, slotEyeVelEl   = 2\n, slotCount      = 3\n;\n// stuffed azimuth and elevation of aim into w components\n// of position and velocity, respectively\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePosAz].xyz;\n    state.eyevel = data[slotEyeVelEl].xyz;\n    state.eyeaim = vec2(data[slotEyePosAz].w\n                       ,data[slotEyeVelEl].w);\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePosAz:\n        c = vec4(state.eyepos, state.eyeaim.x);\n        break;\n      case slotEyeVelEl:\n        c = vec4(state.eyevel, state.eyeaim.y);\n        break;\n      default:\n        break;\n    }\n}\n     \nvec3 voxpos(ivec3 i)\n{\n    return vec3(i) * voxtile + voxorg;\n}\n//    i.x += (i.x^i.y^i.z)&1; // ensure using a valid id\n\n// given world space position, return closest voxel id\nivec3 voxid(vec3 p)\n{\n    p -= voxorg;\n    p /= voxtile;\n    ivec3 i = ivec3(round(p)); //floor(p + .5)); //\n  #if FCC\n    if (((i.x^i.y^i.z)&1) != 0) {\n        vec3 d = p - vec3(i); // - .5;\n        vec3 a = abs(d);\n        if (a.x > max(a.y, a.z)) i.x += int(sign(d.x));\n        else if (a.y > a.z)      i.y += int(sign(d.y));\n        else                     i.z += int(sign(d.z));\n    }\n  #endif\n    return i;\n}\n\nbool isVoxel(ivec3 i)\n{\n    if ((((i.x^i.y^i.z)>>3)&3)==0) return false;\n    return i.y >= 0 && i.y <= 1;\n}\n\nivec3 voxstorage(ivec3 i)\n{\n  #if FCC\n    i.x >>= 1;\n  #endif\n    return i;\n}\n\n// originally I had this in Fly Camera when I\n// was tiling the spheres with simple cubic lattice,\n// but after I discovered the FCC tiling method, and\n// I copied it into Rhombic Dodecahedron Voxels,\n// which wound up being published way earlier than this,\n// the code there disappeared around when I upgraded the lattice to\n// FCC, and somehow this clever bit of code almost got lost.\n// FCC tiled spheres *got lost again*\n// when I redid Fly Camera scene \n// assuming I had copied the working stuff\n// into this toy for safekeeping.\n// After working out all the kinks in March 2D,\n// I discovered that the dEmptyCell for FCC\n// wasn't quite perfect yet anyway.  Now it is!\n// But now I recreated it and actually \n// fixed a few bad bugs in the process,\n// so I guess it's all right after all.\n// I just don't want to lose it again!\n\nfloat dOccupCell(vec3 q)\n{\n\treturn length(q) - scale; // ball at lattice points\n}\n\n// attempting to estimate the distance\n// to the next cell, plus the distance from there\n// to that cell's object, which also depends on the\n// cell size.\nfloat dEmptyCell(vec3 q)\n{\n    vec3 a = abs(q)\n    , d = step(0., q) * 2. - 1.; //sign(q); // sign is buggy\n   #if FCC\n    if (a.x <= a.y && a.x <= a.z) d.x = 0.; // x min\n    else if (a.y <= a.z) d.y = 0.; // y min\n    else d.z = 0.; // z smallest - only smallest component gets zeroed\n   #else\n    if (a.x > a.y && a.x > a.z) d.yz = vec2(0.); // x max\n    else if (a.y > a.z) d.xz = vec2(0.); // y max\n    else d.xy = vec2(0.); // z largest component - both smaller components get zeroed\n   #endif\n    q -= d * voxtile; // snap to closest neighbor cell\n    return dOccupCell(q) - 1e-3;\n}\n\n// returns (distance, material)\n// FIXME converting material back&forth between float&int unnecessarily\n// but would require a custom struct or out args\nvec2 Scene(vec3 p)\n{\n    ivec3 i = voxid(p);\n    vec3 q = p - voxpos(i);\n    float dp = p.y // ground plane +Y\n    , db = isVoxel(i) // object in this cell?\n        ? dOccupCell(q)\n        : dEmptyCell(q);\n    db = max(db, p.y-voxtile*2.-scale+voxorg.y); // intersect tiled balls with a slab - hacky way - bounding plane optimization\n    return db < dp\n    \t? vec2(db, mRed)\n        : vec2(dp, mGray);\n}\n\nvec3 SceneNormal(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          Scene(p + vec3(h,0,0)).x\n        , Scene(p + vec3(0,h,0)).x\n        , Scene(p + vec3(0,0,h)).x\n      ) - (d = Scene(p).x);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\n// returns (distance, material, nearestmissdistance)\nvec3 March(vec3 ro, vec3 rd, float rate, int iters)\n{\n    vec3 c = vec3(3.4e38, mSky, 3.4e38);\n    int i = iters;\n    float t = 0.;\n    const float thresh = 1e-3;\n    while (i-- > 0) {\n        vec2 h = Scene(ro + rd * t);\n        float d = h.x;\n        t += d * rate;\n        //if (abs(d) < abs(c.z)) {\n            //c.yz = h.yx;\n        \tif (abs(d) < t*thresh) {\n        \t    c.yz = h.yx;\n        \t    break;\n        \t}\n        //}\n    }\n    int m = int(c.y);\n    if (abs(c.z) > t * thresh * 2.) m = mSky;\n    const float dmax = 1e4; //8.5e4; //9e3; //\n    if (m == mSky) // HACK different rescue\n        if (rd.y >= 0. && ro.y > 0.)\n            t = dmax;\n        else \n            m = mGray;\n    c.y = float(m);\n    c.x = clamp(t, 0., dmax);\n    return c;\n}\n\n// compute material (albedo for now) from id\nvec3 Material(int i)\n{\n    vec3 a;\n    switch (i) {\n      default:\n      case mSky:  a = vec3(0); break;\n      case mGray: a = vec3(.5); break;\n      case mRed:  a = vec3(1,0,0); break;\n    }\n    return a;\n}\n\n\nvec3 Light(int m, vec3 p, vec3 n, vec3 v)\n{\n    // hemisphere ambient and hack ambient occlusion only\n    float aod = .2, ao = sqrt(clamp((Scene(p + aod * n).x - Scene(p).x)/aod, 0., 1.));\n    return mix(n.y, 1., .5) * ao * vec3(1);\n}\n\n","name":"Common","description":"","type":"common"}]}