{"ver":"0.1","info":{"id":"mlXyWj","date":"1691169611","viewed":56,"name":"The Sims Plumbob","username":"xor_swap","description":"The Sims plumbob object, rendered with maths","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Cristian A. aka @swap_xor on twitter\n// I make cool stuff, leave a like if you enjoy it ;)\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DIST  = 100.0;\nconst float SURF_DIST = 0.001;\nconst float PI = 3.1415;\n\n// ==== PRIMITIVES ================================================================\n\nfloat dot2(in vec3 v) { return dot(v, v); }\n\nfloat face(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n    return sqrt((\n        sign(dot(cross(ba, nor), pa)) +\n        sign(dot(cross(cb, nor), pb)) +\n        sign(dot(cross(ac, nor), pc)) < 2.0)\n        ?\n        min(min(\n        dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n        dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n        dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))\n        :\n        dot(nor, pa) * dot(nor, pa) / dot2(nor)\n    );\n}\n\n// ==== SCENE =====================================================================\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotateY(vec3 center, vec3 p, float r) {\n    vec3 cp = p - center;\n    return vec3(\n        cp.x * cos(r) - cp.z * sin(r),\n        cp.y * 1.0,\n        cp.x * sin(r) + cp.z * cos(r)\n    ) + center;\n}\n\nfloat scene(vec3 p) {\n    //return cylinder(p, vec3(0), vec3(0, 1, 0), 0.5);\n    float d = MAX_DIST;\n    float r = iTime * 0.2; // rotation\n    float s = 0.25;         // scale\n    vec3  t = vec3(0, 0.5, 0); // translate\n    vec3 A = vec3(1, 0, 0)       * s + t;\n    vec3 B = vec3(0, -1.85, 0)   * s + t; // bottom\n    vec3 C = vec3(0,  1.85, 0)   * s + t; // top\n    vec3 D = vec3(0.5, 0, 0.866) * s + t;\n    for (float i = r; i <= 2.0 * PI + r; i += PI / 3.0){\n        float ADC = face(p, rotateY(t, A, i), rotateY(t, D, i), C);\n        float ADB = face(p, rotateY(t, A, i), rotateY(t, D, i), B);\n        d = min(d, ADC);\n        d = min(d, ADB);\n    }\n    return d;\n}\n\nconst float INSIDE = -1.0, OUTSIDE = 1.0;\nfloat march(in vec3 ro, in vec3 rd, float side) {\n\tfloat d0 = 0.0, ds = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * d0;\n\t\tds = scene(p) * side; // outside or inside (1, -1)\n\t\td0 += ds;\n\t\tif (d0 >= MAX_DIST || abs(ds) <= SURF_DIST) break;\n\t}\n\treturn d0;\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = scene(p);\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(\n\t\tscene(p - e.xyy),\n\t\tscene(p - e.yxy),\n\t\tscene(p - e.yyx)\n\t); // n is a point close to p;\n\treturn normalize(n);\n}\n\nvec3 direction(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color) {\n    vec3 r = reflect(rd, n);\n    vec3 t = texture(iChannel0, r).rgb;\n    return vec3(d) * t * color;\n}\n\n// reflection with chromatic aberration:\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color, float ca) {\n    vec3 t;\n    t.r = texture(iChannel0, reflect(rd - ca, n)).r;\n    t.g = texture(iChannel0, reflect(rd, n)).g;\n    t.b = texture(iChannel0, reflect(rd + ca, n)).b;\n    return vec3(d) * t * color;\n}\n\nvec3 refraction(vec3 p, vec3 rd, vec3 n, float ior) {\n    vec3 reflo = texture(iChannel0, reflect(rd, n)).rgb; // reflection outside\n    vec3 ri = refract(rd, n, 1.0 / ior); // refraction inside\n    vec3 e = p - n * SURF_DIST * 3.0; // enter point\n    vec3 ro, t = vec3(0);\n    ro = refract(ri, normal(e), ior);\n    t = texture(iChannel0,\n        dot(ro, ro) == 0.0 ? reflect(ri, e) : ro\n    ).rgb;\n    float fresnel = 0.7 * dot(rd, n);\n    t = mix(t, texture(iChannel0, rd).rgb, 0.5);\n    return mix(t, reflo, fresnel);\n}\n\n// ==== CAMERA =====================================================================\n\nvec3 fragment(in vec2 uv) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 5, - 4);\n    ro.yz *= rotation(- m.y * 3.14);\n    ro.xz *= rotation(- m.x * 6.2831);// + (sin(iTime / 9.5) * 3.0);\n    vec3 rd = direction(uv, ro, vec3(0, 0.5, 0), 3.0);\n    float d = march(ro, rd, OUTSIDE);\n    vec3 color = texture(iChannel0, rd).rgb;\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        const float ior = 5.1; // index of refraction\n        color = vec3(0.01, 0.6 + (sin(p.y) + 0.5) * 0.5, 0.05);\n        color *= refraction(p, rd, normal(p), ior);\n    }\n    color = pow(color, vec3(0.4545)); // gamma correction\n\treturn color;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\tvec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\tcolor = vec4(fragment(uv), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}