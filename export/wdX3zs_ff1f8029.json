{"ver":"0.1","info":{"id":"wdX3zs","date":"1547184414","viewed":227,"name":"Solifugae","username":"efairbanks","description":"Desert spider or dessert spider? Depends on how determined you are.\n\n(mouse controls camera)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","globalillumination","montecarlo","temporalantialiasing","rayscattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec3 col=texture(iChannel0, uv).xyz;\n    fragColor=vec4(vec3(col),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MARCH_MAX_DIST 20.\n#define MARCH_MIN_DIST .01\n#define MARCH_STEPS 250\n#define MARCH_EPSILON .0001\n#define MARCH_COEF 0.7\n#define REFL_STEPS 7\n#define FOG_COLOR vec3(1.,1.,1.)\n#define FOG_STEP .1\n#define NORM_EPSILON .0005\n\n#define FOG false\n#define REFLECTIONS false\n#define REFRACTIONS false\n\n#define LIGHT_DECAY_EXP 2.\n\n#define MONTE_FRAMES 6\n#define MONTE_COEF 1./6.\n#define SSAA 2\n\nfloat rand31a(vec3 n){return fract(sin(sin(dot(n,vec3(70.19,44.57,32.99)))*10465.27)*1676.9023);}\nfloat rand31b(vec3 n){return fract(sin(sin(dot(n,vec3(21.53,37.97,55.07)))*3991.6801)*21474.83647);}\nfloat randa(float n){return fract(sin(sin(n*21474.83647)*108.301)*115.249);}\nfloat randb(float n){return fract(sin(sin(n*3991.6801)*993.319)*4790.01599);}\nvec2 c2p(vec2 p){return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(vec2 p){return vec2(cos(p.x),sin(p.x))*p.y;}\n\n#define M_SKYBOX\t1.\n#define M_SKYBOXB\t1.5\n#define M_FLOOR\t\t2.\n#define M_OBJ1\t\t3.\n\nvec3 getlum(float mat)\n{\n    if(mat==M_SKYBOX) return vec3(1.,1.2,1.4)*28.;\n    if(mat==M_SKYBOXB) return vec3(1.4,1.,.8)*25.;\n    return vec3(0.);\n}\nvec3 getrefl(float mat)\n{\n\tif(mat==M_FLOOR) return vec3(1.,0.8,0.6)*0.4;\n    if(mat==M_OBJ1) return vec3(0.4,0.33,0.22)*2.;\n    return vec3(0.);\n}\nfloat getdiff(float mat)\n{\n\tif(mat==M_FLOOR) return 4.;\n    if(mat==M_OBJ1) return .1;\n    return 0.0;\n}\nvec3 getrefr(float mat)\n{\n    return vec3(0.);\n}\nvec3 pantilt(vec2 xy, vec3 origin, vec3 target)\n{\n\tvec3 up=normalize(vec3(0.,1.,0.));\n    vec3 fwd=normalize(target-origin);\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*xy.x+up*xy.y);\n}\nvec2 U(vec2 a, vec2 b){return a.x<b.x?a:b;}\nvec2 map(vec3 p){\n    // --- skybox --- //\n    vec2 d;\n    d=vec2(-(length(p)-4.),M_SKYBOX);\n    d=U(d,vec2(p.y+3.,M_SKYBOXB));\n\t// -------------- //\n    \n    // --- floor --- //\n    d = U(d,vec2(max(-p.y,length(p.xz)-1.),M_FLOOR));\n    // ------------- //\n    \n    // --- scene --- //\n    vec3 q=p;\n    q.y+=0.4;\n    for(int i=0;i<9;i++)\n    {\n        q = abs(q);\n\t\tq -= 0.03;\n        q.xy = p2c(c2p(q.xy)+vec2(0.3,0.));\n        q.zy = p2c(c2p(q.zy)+vec2(0.3,0.));\n    }\n    float size = 0.01;\n    vec2 e = vec2(max(abs(q.x)-size,abs(q.z)-size),M_OBJ1);\n    e.x = max(e.x,length(p)-.5);\n\t// ------------- //\n\n    d = U(d,e);\t\n    \n    return d;\n}\nvec3 normal(vec3 p, float epsilon){vec2 e=vec2(epsilon,0.);return normalize(vec3(map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x));}\nvec2 march(vec3 origin, vec3 dir)\n{\n    float t=MARCH_MIN_DIST;\n    vec2 result=vec2(MARCH_MAX_DIST,0.);\n    for(int i=0;i<MARCH_STEPS; i++)\n    {\n        result=map(origin+dir*t);\n        float dist=abs(result.x);\n        if(dist<MARCH_EPSILON) return vec2(t+dist,result.y);\n        if(dist>MARCH_MAX_DIST) break;\n        t+=result.x>0.?dist*MARCH_COEF:max(dist*MARCH_COEF,0.05);\n    }\n    return vec2(MARCH_MAX_DIST,0.);\n}\nvec3 look(vec3 origin, vec3 dir)\n{\n    vec3 o=origin;\n    vec3 d=dir;\n   \tfloat tdist=0.;\n    vec3 tlum=vec3(0.);\n    vec3 trefl=vec3(1.);\n    vec3 trefr=vec3(0.);\n    for(int i=0; i<REFL_STEPS; i++)\n    {\n    \tvec2 result=march(o,d);\n        float dist=result.x;\n        vec3 lum=getlum(result.y);\n        vec3 refl=getrefl(result.y);\n        float diff=getdiff(result.y);\n        vec3 refr=getrefr(result.y);\n        if(dist>MARCH_MAX_DIST) break;\n        tdist+=dist;\n        tlum+=trefl*lum/pow(LIGHT_DECAY_EXP,tdist);\n        if(length(refr)>0.) // refract\n        {\n\t\t\to+=d*(dist+MARCH_EPSILON*0.6);\n            float ref=1.1;\n            vec3 n = normal(o,NORM_EPSILON);\n            if (dot(n,dir) > 0.) {\n                n = -n;\n                ref = 1./ref;\n            }\n            o -= MARCH_EPSILON * n;\n            dir=normalize(refract(dir,n,1./ref));\n        }else if(length(refl)>0.){ // reflect\n            trefl=trefl*refl;\n            o+=d*(dist-MARCH_EPSILON*2.);\n            d=reflect(normalize(d),normal(o,NORM_EPSILON));\n            if(diff>0.) d=pantilt(vec2(rand31a(o+randa(iTime))-0.5,rand31b(o+randb(iTime))-0.5)*diff,vec3(0.),d);\n        } else break;\n    }\n\treturn tlum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lastVal = texture(iChannel0,fragCoord.xy/iResolution.xy).xyz;\n    if(int(fragCoord.x*345.67+fragCoord.y*567.89)%MONTE_FRAMES!=iFrame%MONTE_FRAMES) {\n        fragColor=vec4(lastVal,1.);return;\n    }\n    vec3 csum = vec3(0.);\n    for(int i=0;i<SSAA;i++){\n        // --- //\n        vec2 uv=fragCoord+vec2(randa(iTime+float(i)),randb(iTime+float(i)))-.5;\n        uv+=vec2(rand31a(vec3(uv.x,uv.y,uv.y*23.)+float(iFrame)*.234),rand31b(vec3(uv.x,uv.x*13.,uv.y)+float(iFrame)*.345))-.5;\n        uv=(uv/iResolution.xy-.5)*1.;\n        uv.x=uv.x*iResolution.x/iResolution.y;\n        vec3 camera = vec3(0.,-10.*iMouse.y/iResolution.y-0.2,-4.25)*0.2;\n        camera.xz = p2c(c2p(camera.xz)+vec2(iMouse.x/40.,0.));\n        vec3 color=look(camera,pantilt(uv,camera,vec3(0.,-.25,0.)));\n        color=atan(color);\n        csum+=color;\n    }\n    fragColor = vec4(csum*MONTE_COEF/float(SSAA)+lastVal*(1.-MONTE_COEF),1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}