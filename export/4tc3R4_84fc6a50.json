{"ver":"0.1","info":{"id":"4tc3R4","date":"1470598461","viewed":216,"name":"Multipass Raytracer","username":"rory618","description":"When the camera moves, the previous buffer is sampled to find points that have already been calculated. Uncomment line 8 to see what pixels are calculated during that frame. Might be useful for faster realtime renders with a moving camera.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = texture( iChannel2 , uv );\n    fragColor = sin(20.0*log(1.0+fragColor*fragColor));\n    if (fragColor.w < 0.1 ) {\n      //  fragColor *= .1;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926535\n#define m 10000.0\n#define up vec3(0,0,1)\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\n\nconst float KEY_R  = 82.5/256.0;\n\nconst vec2 cPosLoc = vec2(1.5,1.5);\nconst vec2 cDirLoc = vec2(2.5,1.5);\nconst vec2 mouseLoc = vec2(3.5,1.5);\n\nconst float speed = .005;\nconst float sens = .001;\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 cPos = load(cPosLoc).xyz;\n    vec3 cDir = normalize(load(cDirLoc).xyz);\n    vec2 mouse = load(mouseLoc).xy;\n    \n    vec2 dM = iMouse.xy-mouse;\n    \n    vec3 R = normalize(cross(cDir, up));\n    vec3 U = normalize(cross(R, cDir));\n    \n    if (keyIsDown(KEY_D)||keyIsDown(KEY_RIGHT)) cPos += speed*R;\n    if (keyIsDown(KEY_A)||keyIsDown(KEY_LEFT))  cPos -= speed*R;\n    if (keyIsDown(KEY_W)||keyIsDown(KEY_UP))    cPos += speed*cDir;\n    if (keyIsDown(KEY_S)||keyIsDown(KEY_DOWN))  cPos -= speed*cDir;\n\n    \n    if (keyIsDown(KEY_R)||iTime < 1.){\n        cPos = vec3(0.0, -1.0, .5);\n        cDir = normalize(vec3(0.0,0.6,-.4));\n    }\n    \n    if (iMouse.z > 0.0) {\n        if(mouse.x>0.0){\n        \tcDir += sens * (R * dM.x + U * dM.y);\n        }\n        mouse = iMouse.xy;\n    } else {\n        mouse = vec2(0);\n    }\n    \n    fragColor = vec4(0);\n    fragColor += save(vec4(cPos,0),cPosLoc,fragCoord);\n    fragColor += save(vec4(cDir,0),cDirLoc,fragCoord);\n    fragColor += save(vec4(mouse,0,0),mouseLoc,fragCoord);\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define samples 100.\n\n\n#define PI 3.1415926535\n#define m 1000.0\n#define up vec3(0,0,1)\n\n\nconst vec2 cPosLoc = vec2(1.5,1.5);\nconst vec2 cDirLoc = vec2(2.5,1.5);\nconst int n = (int(sqrt(samples)))/2;\n\nfloat angle(vec2 p) {\n    if (p.x < 0.0) {\n        return atan(p.y/p.x)+PI;\n    } else {\n        return atan(p.y/p.x);\n    }\n}\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\n\nfloat rd;\nint rmat;\nvec2 ruv;\nvec3 rnorm;\n\nvoid s(vec3 o, vec3 d, vec3 s, float r) {\n    \n\tfloat A = dot(d, s-o);\n    if(A < 0.0) {rd = m; return; }\n    float B = length(o-s+d*A);\n    if(B>r) {rd = m; return; }\n    if(length(o-s)<r) {\n    \trd = A+sqrt(r*r-B*B);\n    } else {\n    \trd = A-sqrt(r*r-B*B);\n    }\n    \n    rmat = 1;\n    rnorm = normalize(o-s+rd*d);\n    \n    ruv = vec2(\n        (PI/2.+angle(vec2(length(rnorm.xy),rnorm.z) ))/(PI), \n        (PI/2.+angle(rnorm.xy))/(2.0*PI)      );\n    \n}\n\n\nvoid c(vec3 o, vec3 d, vec3 s, float r) {\n    \n\tfloat A = dot(d, s-o);\n    if(A < 0.0) {rd = m; return; }\n    float B = length(o-s+d*A);\n    if(B>r) {rd = m; return; }\n    rd = A-sqrt(r*r-B*B);\n    \n    rmat = 1;\n    rnorm = normalize(o-s+rd*d);\n    \n    ruv = vec2(\n        (PI/2.+angle(vec2(length(rnorm.xy),rnorm.z) ))/(PI), \n        (PI/2.+angle(rnorm.xy))/(2.0*PI)      );\n    \n}\n\n\nfloat Rd;\nfloat Rmat;\nvec2 Ruv;\nvec3 Rnorm;\n\nvoid ray(vec3 o, vec3 d) {\n    \n    Rd = m;\n    \n    s(o, d, vec3(-11,  0,  0),10.0);  if (rd < Rd) {Rd = rd;Rmat = .1;Ruv = ruv;Rnorm = rnorm;}\n    s(o, d, vec3(  0, 11,  0),10.0);  if (rd < Rd) {Rd = rd;Rmat = .2;Ruv = ruv;Rnorm = rnorm;}\n    s(o, d, vec3( 11,  0,  0),10.0);  if (rd < Rd) {Rd = rd;Rmat = .3;Ruv = ruv;Rnorm = rnorm;}\n    s(o, d, vec3(  0,  0,-11),10.0);  if (rd < Rd) {Rd = rd;Rmat = .4;Ruv = ruv;Rnorm = rnorm;}\n}\n\nvec4 castPixel( vec2 uv )\n{\n    vec3 o = load(cPosLoc).xyz;\n    vec3 d = normalize(load(cDirLoc).xyz);\n       \n    vec3 R = normalize(cross(d, up))*.3;\n    vec3 U = normalize(cross(R, d))*.3;\n    \n    d = normalize(d + R*uv.x + U*uv.y);\n    \n    ray(o,d);\n    \n\treturn vec4(o+d*Rd,Rmat);\n}\n\nbool isInRay( vec2 uv , vec3 p)\n{\n    vec3 o = load(cPosLoc).xyz;\n    vec3 d = normalize(load(cDirLoc).xyz);\n       \n    vec3 R = normalize(cross(d, up))*.3;\n    vec3 U = normalize(cross(R, d))*.3;\n    \n    d = normalize(d + R*uv.x + U*uv.y);\n    \n    return dot(normalize(p-o),d) > .999999;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(.5);\n    uv *= 2.;\n    uv.x*=iResolution.x/iResolution.y;\n        \n    bool found = false;\n    \n    float dist = 2.0*m;\n    \n    vec3 o = load(cPosLoc).xyz;\n    \n    \n    \n    for (int dx = -n; dx <=n; dx++) {\n    \tfor (int dy = -n; dy <=n; dy++) {\n    \t    vec4 p = texture(iChannel1, (fragCoord.xy + vec2(dx,dy)) / iResolution.xy );\n            if (isInRay (uv, p.xyz) ) {\n                if (length(p.xyz-o) < dist) {\n                    dist = length(p.xyz-o);\n                \tfragColor=p;\n        \t\t\tfragColor.w = 1.0;\n                }\n                found = true;\n            }\n    \t}\n    }\n    if (!found) {\n\t\tfragColor = castPixel( uv );\n        fragColor.w = 0.0;\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf D","description":"","type":"buffer"}]}