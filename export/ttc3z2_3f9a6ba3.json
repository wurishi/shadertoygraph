{"ver":"0.1","info":{"id":"ttc3z2","date":"1576860764","viewed":250,"name":"Hexagon Tunnel","username":"MikeXenix","description":"First 3D shape, using a previous procedural texture I made. Tunnel computation by iq","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Michael Yllo - MikeXenix/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\nUsing some code from https://www.shadertoy.com/view/Ms2SWW   inigo quilez - iq/2013\nMore info: https://iquilezles.org/articles/tunnel\n\n*/\n\n// A bit of a hacked together procedural texture computing the closest distance to a hexagon grid using planes and voronoi regions\nfloat hexTex(vec2 Tex)\n{\n    float degAlpha = 57.0;\n    \n    float alpha = (degAlpha) / 360.0 * 2.0 * 3.14159, cal = cos(alpha), sal = sin(alpha);\n\tfloat beta = ((90.0 - degAlpha) / 360.0 * 2.0 * 3.14159), cbe = cos(beta), sbe = sin(beta);\n\tfloat r = 0.5 / cbe;\n\tvec2 P1 = vec2(r*sbe, r*cbe);\n\tvec2 P2 = vec2(2.0 * r*cal, 0.0);\n\tvec2 N = normalize(P2 - P1);\n\tfloat D = dot(vec2(-N.y, N.x), P1);\n    \n\tfloat v = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.y), 1.0));\n\tfloat v2 = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.x), 1.0));\n\tfloat d = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D);\n\tfloat d2 = (dot(vec2(-N.y, -N.x), vec2(v2, v)));\n\n\tif (v2 <= r * cal)\n\t{\n\t\tif (d2 > 0.0)\n\t\t\td = abs(d) / D;\n\t\telse if (v < 0.5)\n\t\t\td = abs(0.5 - v) * 2.0;\n\t\telse if (d > 0.0)\n\t\t\td = abs(d2) / D;\n\t\telse\n\t\t\td = abs(0.5 - v) * 2.0;\n\t}\n\telse if (d <= 0.0)\n\t{\n\t\td = abs(d) / D;\n\t}\n\telse\n\t{\n\t\tif (v2 >= 2.0 * r*cal)\n\t\t{\n\t\t\tif (v < 0.5)\n\t\t\t{\n\t\t\t\tvec2 P3 = vec2(0.25, 0.5);\n\t\t\t\tvec2 N2 = normalize(P3 - P2);\n\t\t\t\tfloat D2 = dot(vec2(-N2.y, N2.x), P2);\n\t\t\t\tfloat d3 = (dot(vec2(-N2.y, -N2.x), vec2(v2, v)) - D2);\n\t\t\t\tif (d3 < 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d) / D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat d4 = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D * 2.0);\n\t\t\t\tif (d4 > 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d2) / D;\n\t\t\t}\n\t\t}\n\t\telse if (v > 0.5)\n\t\t\td = abs(dot(vec2(-N.y, -N.x), vec2(v2, v))) / D;\n\t\telse\n\t\t\td = abs(d) / D;\n\t}\n\n    return min(0.999, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // rotate\n    float rotateSpeed = 0.4;\n\tp=vec2(p.x*cos(iTime*rotateSpeed)+p.y*sin(iTime*rotateSpeed),p.y*cos(iTime*rotateSpeed)-p.x*sin(iTime*rotateSpeed));\n    \n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n\n    // squareish tunnel\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/16.0 );\n    \n    // index texture by (animated inverse) radious and angle\n    uv = vec2( 0.3/r, a/3.1415927 );\n\n    // Texture computation\n    float c = pow(1.0-hexTex(vec2(iTime,0)+uv.xy*vec2(6.0,3.0)),4.1+2.0*sin(iTime)); // eval texture and bend with pow\n\n    // fade by time\n    c = 0.1+0.9*c*abs(sin(iTime*2.0));\n\n    // spiral\n    c *= 0.2+0.8*pow(abs(sin(uv.x*10.0-iTime*10.0+uv.y*3.14159)),4.0);\n\n    // fade by distance\n    c *= min(max(1.0-uv.x,0.0),1.0);\n\n    // Output to screen\n    fragColor = vec4(0,c,c,1.0);\n}","name":"Image","description":"","type":"image"}]}