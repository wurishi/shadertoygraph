{"ver":"0.1","info":{"id":"NdsXW2","date":"1619268294","viewed":245,"name":"Elementary Cellular Automaton","username":"kaihagseth","description":"Implementation of 1d cellular automaton. Try changing the rule! Pan/zoom with arrow keys.\nhttps://mathworld.wolfram.com/ElementaryCellularAutomaton.html","likes":5,"published":3,"flags":48,"usePreview":0,"tags":["cellularautomata","wolfram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by Stephen Wolfram :) \n// https://www.youtube.com/watch?v=VguG_y05Xe8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(vec3(1. - texelFetch( iChannel0, ivec2(fragCoord), 0 ).x), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RULE 30\n// Update: Stores states of automaton in buffers b and c channels... Can still be optimized\n//         a lot to store even more states without rolling over, but now it should be \n//         possible to calculate w * h iterations without overflowing.\n// Update: Added camera panning and zooming. Note that since only the \n//         1 dimensional state of the system is stored, things get a bit weird while panning.\n\n\nconst ivec2 ZOOMIX   = ivec2(0,0);\nconst ivec2 OFFSETIX = ivec2(1,0);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nfloat getParam(ivec2 ix) {\n   return texelFetch(iChannel0, ix, 0).w;\n}\n\nfloat getOffset() {\n   return getParam(OFFSETIX);\n}\n\nfloat getZoom() {\n   return max(getParam(ZOOMIX), 1.);\n}\n\nbool keyPressed(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > .5;\n}\n\nfloat getData(ivec2 coord) {\n    if (coord == ivec2(0, 0)) {\n        if      (keyPressed(KEY_UP))   return getZoom() * 1.01;\n        else if (keyPressed(KEY_DOWN)) return getZoom() / 1.02;\n        return getZoom();\n    } else if(coord == ivec2(1, 0))\n    {\n        if      (keyPressed(KEY_LEFT))  return getOffset() - 2.;\n        else if (keyPressed(KEY_RIGHT)) return getOffset() + 2.;\n        return   getOffset();\n    }\n    return 0.0;\n}\n\n\nivec2 ixToCoord(int i) {\n    return ivec2(i % int(iResolution.x),  i / int(iResolution.x));\n}\n\n// Returns value from previous iteration\nint px(int i) {\n    if (i < 0){\n        ivec2 c = ixToCoord(-1 - i);\n        return int(texelFetch(iChannel0, c, 0).z);\n    }\n    ivec2 c = ixToCoord(i);\n    return int(texelFetch(iChannel0, c, 0).y);\n}\n\nfloat dispPx(ivec2 coord) {\n    if (coord.y == 0) {\n        float i = ( float(coord.x) - (iResolution.x / 2.) ) / getZoom();\n        i += getOffset();\n        return float(px(int(floor(i))));\n    }\n    else if (coord.y < (int(getZoom())) ) {\n        return texelFetch(iChannel0, ivec2(coord.x, 0), 0).x;\n    }\n    return texelFetch(iChannel0, ivec2(coord.x, coord.y - int( getZoom())), 0).x; // scroll\n}\n\n// a: int to access as a bitset\n// n: bit index\nint getNthBit(int a, int n) {\n    return (a & ( 1 << n )) >> n;\n}\n\n//Generates current iteration\nvec2 cellStep(ivec2 coord) {  \n    int xb = (int(iResolution.x) * coord.y) + coord.x;\n    int xc =  -1- xb;\n    int  b = (px(xb+1) << 2) | (px(xb) << 1) | px(xb-1);\n    int  c = (px(xc+1) << 2) | (px(xc) << 1) | px(xc-1);\n    return vec2(getNthBit(RULE, b), getNthBit(RULE, c));\n}\n\n// Clear buffers and add seed.\nvec2 init(ivec2 coord) {\n    return vec2(float(coord == ivec2(1, 0)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    ivec2 coord = ivec2(fragCoord);\n    vec2 cellularPx = cellStep(coord);\n    if (iFrame == 0) cellularPx = init(coord);\n    float data = getData(coord);\n    fragColor = vec4(dispPx(coord), cellularPx, data);\n}","name":"Buffer A","description":"","type":"buffer"}]}