{"ver":"0.1","info":{"id":"l3fGDl","date":"1708033168","viewed":99,"name":"CS Hexagons","username":"NivBehar","description":"Inspired by a hexagon pattern wall painting I saw in my university class.\nmake sure music is on in Buffer A :)","likes":7,"published":1,"flags":96,"usePreview":0,"tags":["sound","music","pattern","tiling","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define time iTime\n# define PI 3.141592654\n\n// if the music is off - color the scene anyway\n# define INIT_SOUND(x, y) is_music_on == 1. ? x : y;\n# define INIT_SOUND_CONT(x) is_music_on == 1. ? x : time*0.125;\n\nfloat is_music_on;\nfloat bass;\nfloat mid;\nfloat treb;\nfloat sound;\nfloat bass_cont;\nfloat mid_cont;\nfloat treb_cont;\nfloat sound_cont;\n\nfloat getLines(vec2 uv, float l_a, float l_b, bool h, float h_a, float h_b)\n{\n    vec2 outer_hex = vec2(HexDist(uv), 0.);\n    outer_hex.y = smoothstep(h_b,h_a, outer_hex.x);\n    \n    float ret = outer_hex.y;\n    \n    if(h)\n    {\n        vec2 line1_pos = vec2(0., -1.);\n        vec2 line2_pos = Rot(line1_pos, -2.*PI/3.);\n        vec2 line3_pos = Rot(line2_pos, -2.*PI/3.);\n    \n        float inner_lines = smoothstep(l_b,l_a,sdSegment(uv, vec2(0.,0.), line1_pos));\n        inner_lines *= smoothstep(l_b,l_a,sdSegment(uv, vec2(0.,0.), line2_pos));\n        inner_lines *= smoothstep(l_b,l_a,sdSegment(uv, vec2(0.,0.), line3_pos));\n        ret *= inner_lines;\n    }\n    \n    return ret;\n}\n\nvec3 light_col = vec3(1.)* 0.85;\nvec3 yellow_col = vec3(1.,1.,0.)* 0.8;\nvec3 shadow_col = vec3(0.8,0.8,0.8) *0.6;\nvec3 upper_col = vec3(0.,1.,1.)*0.7;\n\nvec3 light_1_col = vec3(1.,1.,0.) * 1.;\nfloat light_1_beat;\nvec3 light_2_col = vec3(153.,55.,255.)/255. * 2.;\nfloat light_2_beat;\nvec3 light_3_col = vec3(102.,255.,102.)/255. * 2.;\nfloat light_3_beat;\n\nbool isEmptyCell(vec2 hash)\n{\n    return (hash.x + hash.y)*0.5 > 0.65;\n}\n\nbool isTopCell(vec2 id)\n{\n    return floor(id.x) != id.x;\n}\n\nvec3 getHex1Col(float ang, vec2 UV, bool l, float h_a, float h_b, vec2 hash, bool rotated)\n{\n    vec3 hex1_col = vec3(1.,0.,0.);\n    if(ang <= 2.*PI/3.)\n        hex1_col = light_col;\n    else if( ang <= 2.*2.*PI/3.)\n        hex1_col = upper_col;\n    else\n        hex1_col = shadow_col;\n        \n    float a = 0.015;\n    float lines = getLines(UV, a, 0.1*a, l, h_a, h_b);\n    \n    float dif = (1.-ang/(2.*PI));\n    dif *= 2.;\n    /*if(rotated)\n        dif = ang < PI ? dif * (1.-ang/(2.*PI)) : 1.;\n    else\n        dif = ang >= PI ? dif * (1.-ang/(2.*PI)) : 1.;*/\n    \n    vec3 tex = texture(iChannel0, (UV + hash * 12. )*.5).xyz;\n    \n    return tex * hex1_col * lines * dif;\n}\n\nvec3 getHex2Col(float ang, vec2 UV, bool l, float h_a, float h_b, vec2 hash)\n{\n    vec3 hex2_col = vec3(1.,0.,0.);\n    \n    float off = 0.005;\n    float b_1 = 1. - off;\n    float b_2 = 1. + off;\n    \n    float shadow_col_a = smoothstep(b_1 * 2.*PI/6., b_2 * 2.*PI/6., ang);\n    shadow_col_a *= 1.-smoothstep(b_1 * PI, b_2 * PI, ang);\n    \n    float light_col_a = 1. - shadow_col_a;\n\n    hex2_col =  shadow_col * shadow_col_a\n              + light_col * light_col_a;\n        \n    float a = 0.15;\n    float lines = getLines(UV, a, 0.1*a, l, h_a, h_b);\n    \n    float dif = 0.8;\n    /*if(rotated)\n        dif = ang > PI ? dif : 1.;\n    else\n        dif = ang <= PI ? dif : 1.;*/\n        \n    dif = ang <= PI || ang >= 5.*2.*PI/6. ? 1. : dif;\n    \n    vec3 tex = texture(iChannel1, (UV + hash * 12. )*1.).xyz;\n    \n    return tex * hex2_col * lines * dif;\n}\n\nvec3 getHex5Col(float ang, vec2 UV, bool l, float h_a, float h_b, vec2 hash)\n{\n    vec3 hex5_col = vec3(1.,0.,0.);\n    if(ang <= 2.*PI/3.)\n        hex5_col = 0.2 + light_3_col * light_3_beat * 2.;\n    else if( ang <= 4.*PI/3.)\n        hex5_col = 0.2 + light_1_col * light_1_beat * 1.3;\n    else\n        hex5_col = 0.2 + light_2_col * light_2_beat * 2.;\n\n    float a = 0.035;\n    float lines = getLines(UV, a, 0.01*a, l, h_a, h_b);\n    \n    vec3 tex = texture(iChannel1, (UV + hash * 12.)*1.).xyz;\n    \n    return tex * hex5_col * lines;\n}\n\nvec3 getLight(vec2 UV, float rot_ang, vec3 light_col, float mask, float light_beat)\n{\n    vec2 light_pos = Rot(UV, rot_ang) - vec2(0., 1.7);\n    light_pos = Rot(light_pos, PI);\n    float light = sdEquilateralTriangle(light_pos, 0.5);\n    light = smoothstep(1., 0., light);\n    return light * light_col * light_beat * mask;\n}\n\nvec3 csHex(vec2 UV, vec2 scale, vec2 hash, bool rotated)\n{\n    vec3 ret = vec3(0);\n    \n    vec2 hex1 = vec2(HexDist(UV), 0.);\n    hex1.y = smoothstep(0.5,0.49, hex1.x);\n    vec2 hex1_uv = UV;\n    float hex1_ang = atan(hex1_uv.x, hex1_uv.y) + PI;\n    \n    UV.xy *= 1.25;// - bass*0.1;\n    vec2 hex2 = vec2(HexDist(UV), 0.);\n    hex2.y = smoothstep(0.5,0.49, hex2.x);\n    vec2 hex2_uv = UV;\n    float hex2_ang = atan(hex2_uv.x, hex2_uv.y) + PI;\n\n    UV.xy *= 1.25;\n    UV.y += -0.12 - 0.1*sin(time * 0.5 + hash.x*21232.);\n    vec2 hex3 = vec2(HexDist(UV), 0.);\n    hex3.y = smoothstep(0.5,0.49, hex3.x);\n    vec2 hex3_uv = UV;\n    float hex3_ang = atan(hex3_uv.x, hex3_uv.y) + PI;\n\n    UV.xy *= 1.25;\n    vec2 hex4 = vec2(HexDist(UV), 0.);\n    hex4.y = smoothstep(0.5,0.49, hex4.x);\n    vec2 hex4_uv = UV;\n    float hex4_ang = atan(hex4_uv.x, hex4_uv.y) + PI;\n    \n    UV.xy *= 1.75- mid*mid*mid*1.3;\n    float rot_dir = hash.y < 0.5 ? 1. : -1.;\n    UV.xy = Rot(UV, rot_dir*(treb_cont*4. + hash.x*2312.));\n    UV.y += 0.06;\n    vec2 hex5 = vec2(HexDist(UV), 0.);\n    hex5.y = smoothstep(0.5,0.49, hex5.x);\n    vec2 hex5_uv = UV;\n    float hex5_ang = atan(hex5_uv.x, hex5_uv.y) + PI;\n    \n    vec3 hex1_col = getHex1Col(hex1_ang, hex1_uv, true, 0.82, 0.85, hash, rotated);\n    \n    vec3 hex2_col = getHex2Col(hex2_ang, hex2_uv, false, 0.47, 0.49, hash);\n        \n    vec3 hex3_col = getHex1Col(hex3_ang, hex3_uv, true, 0.47, 0.49,hash, rotated);    \n\n    vec3 hex4_col = getHex2Col(hex4_ang, hex4_uv, false, 0.47, 0.49, hash);\n    \n    vec3 hex5_col = getHex5Col(hex5_ang, hex5_uv, true, 0.46, 0.48, hash);\n    \n    float hex1_a = max(0., hex1.y - hex2.y - hex3.y - hex4.y - hex5.y);\n    float hex2_a = max(0., hex2.y - hex3.y - hex4.y - hex5.y);\n    float hex3_a = max(0., hex3.y - hex4.y - hex5.y);\n    float hex4_a = max(0., hex4.y - hex5.y);\n    float hex5_a = max(0., hex5.y);\n    \n    ret += hex1_a * hex1_col;\n    ret += hex2_a * hex2_col;\n    ret += hex3_a * hex3_col;\n    ret += hex4_a * hex4_col;\n    ret += hex5_a * hex5_col;\n    \n    // lights coming from the inside box - only on the walls\n    // yellow light\n    vec3 light_1 = getLight(hex5_uv, 0., light_1_col, hex2_a + hex4_a, light_1_beat);\n    ret += light_1;\n    \n    // pink light\n    vec3 light_2 = getLight(hex5_uv, 2.*PI/3., light_2_col, hex2_a + hex4_a, light_2_beat);\n    ret += light_2;\n    \n    // green light\n    vec3 light_3 = getLight(hex5_uv, 4.*PI/3., light_3_col, hex2_a + hex4_a, light_3_beat);\n    ret += light_3;\n    \n    return ret;\n}\n\nvec3 background(vec2 uv, hex hc)\n{\n    vec3 ret;\n    vec2 uv_orig = uv;\n\n    uv = uv * 3. + vec2(time*0.85, time*0.55)*0.05;\n\n    // background color\n    vec2 tex_uv = uv;\n    ret = texture(iChannel3, tex_uv).xyz;\n\n    ret *= ret;\n\n    uv = Rot(uv*8., PI/4.);\n    vec2 box_uv = fract(uv);\n    vec2 box_id = floor(uv);\n\n    float box_off = 0.1;\n\n    // box black borders\n    float box = smoothstep(1.-box_off, 1., abs(box_uv.x));\n    box += smoothstep(box_off, 0., box_uv.x);\n    box += smoothstep(1.-box_off, 1., box_uv.y);\n    box += smoothstep(box_off, 0., box_uv.y);\n\n    vec2 box_hash2 = N22(box_id);\n    float box_hash = (box_hash2.x + box_hash2.y)/2.;\n\n    // box color based on id\n    vec3 box_inner_col; \n\n    if(box_hash < 0.33)\n        box_inner_col = light_1_col * (0.3 + 0.7*pow(bass*0.9, 6.) * 4.);\n    else if(box_hash < 0.66)\n        box_inner_col = light_2_col * (0.3 + 0.7*pow(mid, 3.) * 4.) ;\n    else\n        box_inner_col = light_3_col * (0.3 + 0.7*pow(treb, 2.) * 7.);\n\n    // apply box color\n    ret *= box_inner_col * (1.-box);\n\n    // \"shadows\" of nearby hexagons:\n\n    // neighbors hexagons: left, top-left, top-right, right, bottom-right, bottom-left\n    hex l_hex, tl_hex, tr_hex, r_hex, br_hex, bl_hex;\n\n    // calc neighbors id's:\n    l_hex.id = vec2(hc.id.x - 1., hc.id.y);\n    r_hex.id = vec2(hc.id.x + 1., hc.id.y);\n\n    if(isTopCell(hc.id))\n    {\n        tl_hex.id = vec2(hc.id.x - 0.5, hc.id.y + 1.);\n        tr_hex.id = vec2(hc.id.x + 0.5, hc.id.y + 1.);\n\n        bl_hex.id = vec2(hc.id.x - 0.5, hc.id.y);\n        br_hex.id = vec2(hc.id.x + 0.5, hc.id.y);\n    }\n    else\n    {\n        tl_hex.id = vec2(hc.id.x - 0.5, hc.id.y);\n        tr_hex.id = vec2(hc.id.x + 0.5, hc.id.y);\n\n        bl_hex.id = vec2(hc.id.x - 0.5, hc.id.y - 1.);\n        br_hex.id = vec2(hc.id.x + 0.5, hc.id.y - 1.);\n    }\n\n    // calc neighbors uv's:\n    l_hex.uv = hc.uv + vec2(-1.73, 0.);\n    r_hex.uv = hc.uv + vec2(1.73, 0.);\n\n    tl_hex.uv = hc.uv + vec2(-1.73*0.5, 1.5);\n    tr_hex.uv = hc.uv + vec2(1.73*0.5, 1.5);\n\n    bl_hex.uv = hc.uv + vec2(-1.73*0.5, -1.5);\n    br_hex.uv = hc.uv + vec2(1.73*0.5, -1.5);\n\n    // calc neighbors hash:\n    l_hex.hash = N22(l_hex.id);\n    r_hex.hash = N22(r_hex.id);\n\n    tl_hex.hash = N22(tl_hex.id);\n    tr_hex.hash = N22(tr_hex.id);\n\n    bl_hex.hash = N22(bl_hex.id);\n    br_hex.hash = N22(br_hex.id);\n\n    // calc neighbors dists:\n    l_hex.dist = isEmptyCell(l_hex.hash) ? 0. : HexDist(l_hex.uv);\n    r_hex.dist = isEmptyCell(r_hex.hash) ? 0. :  HexDist(r_hex.uv);\n\n    tl_hex.dist = isEmptyCell(tl_hex.hash) ? 0. :  HexDist(tl_hex.uv);\n    tr_hex.dist = isEmptyCell(tr_hex.hash) ? 0. :  HexDist(tr_hex.uv);\n\n    bl_hex.dist = isEmptyCell(bl_hex.hash) ? 0. :  HexDist(bl_hex.uv);\n    br_hex.dist = isEmptyCell(br_hex.hash) ? 0. :  HexDist(br_hex.uv);\n\n\n    float t_dist, s_dist, b_dist; // top, sides, bottom\n    t_dist = max(tr_hex.dist, tl_hex.dist);\n    s_dist = max(r_hex.dist, l_hex.dist);\n    b_dist = max(br_hex.dist, bl_hex.dist);\n\n    float dist = max(max(t_dist, s_dist), b_dist);\n\n    float a = 2.21;\n    float b = 0.19;\n\n    // shadows mask\n    float shadow_a = 1. - smoothstep(a, a-b, dist);\n\n    // apply neighbors shadows\n    ret *= 1. - shadow_a;\n\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    //uv = fragCoord / R.y;                     // [0,1] vertically\n    //uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    //uv = ( fragCoord - .5*R ) / R.y;          // [-1/2,1/2] vertically\n    //uv = ( 2.*fragCoord - R ) / min(R.x,R.y); // [-1,1] along the shortest side\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    is_music_on = GET_IS_MUSIC_ON;\n    bass = INIT_SOUND(GET_BASS, 1.);\n    mid = INIT_SOUND(GET_MID, 0.5);\n    treb = INIT_SOUND(GET_TREB, 0.5);\n    sound = INIT_SOUND(GET_SOUND, 1.);\n    bass_cont = GET_BASS_CONT;\n    mid_cont = INIT_SOUND_CONT(GET_MID_CONT);\n    treb_cont = INIT_SOUND_CONT(GET_TREB_CONT);\n    sound_cont = INIT_SOUND_CONT(GET_SOUND_CONT);\n\n    light_1_beat = pow(bass*0.75, 2.);\n    light_2_beat = mid*mid;\n    light_3_beat = treb*treb;\n\n    vec3 ret = vec3(0);\n    \n    vec2 scale = vec2(4.);\n    \n    hex hc = HexCoords(uv*scale + time*0.15 + 1.);\n    hc.hash = N22(hc.id);\n    \n    /*bool rotated = false;\n    if(hash.x > 0.5)\n    {\n        rotated = true;\n        hc_uv = vec2(-hc_uv.x, hc_uv.y);;\n    }*/\n    \n    if(!isEmptyCell(hc.hash))\n    {\n        // hexagons\n        ret = csHex(hc.uv, scale, hc.hash, false);\n    }\n    else\n    {\n        // background\n        ret = background(uv, hc);\n    }\n    \n    vec3 gamma = vec3(2.2);\n    ret = pow(ret, 1./gamma);\n\n    // Output to screen\n    fragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdtGWS","filepath":"https://soundcloud.com/kutiman/fresh-haze","previewfilepath":"https://soundcloud.com/kutiman/fresh-haze","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**********************************************\n* sound: https://www.shadertoy.com/view/mtl3Rj\n***********************************************/\n\n# define time iTime\n\n// bass bands\n# define BASS_START 0\n# define BASS_END 14\n// middle bands\n# define MID_START 15\n# define MID_END 143\n// treble bands\n# define TREBLE_START 144\n# define TREBLE_END 511\n\n/*------------ Tuning ------------*/\n\n/*---- Smooth Sound values ----*/\n// lower value - more time for the smooth sound stay on top of the pure sound\n#define DECREASE_MIN 0.001\n// lower value - lower decrease time. should be above 1.\n#define DECREASE_MUL 5.\n/* lower value - slower increase of smooth sound. \n   higher value - faster increase.\n   should be below 1. */\n#define INCREASE_MUL 0.3\n\n/*---- Smooth Sound Continues values ----*/\n/* play with this to get smaller\\bigger \"acceleration\" for the circles\n   lower value - more deceleration\n   should be below 1 */\n#define DELTA_INCREASE 0.1\n\n/* should be a value between 0 and 1\n   play with this to get smaller\\bigger \"deceleration\" for the circles\n   lower value - less acceleration */\n#define DELTA_MUL 0.9\n\n/* bigger DELTA_COUNT_MAX value will take into account more of the \"acceleration\"\n   lower value will restrain the acceleration\n   in other words - saturate it */\n#define DELTA_COUNT_MAX 8.\n\nfloat getSound(int start, int end)\n{\n    float ret = 0.;\n    for(int i = start; i <= end; i++)\n    {\n        float samp = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n        \n        samp = samp*samp + 0.5*samp;\n        if(samp > 0.8)\n            samp *= 0.8; // just to reduce the magnitude of the low frequencies\n        ret += samp;\n    }\n    \n    ret /= float(end - start + 1);\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float fpsInv = 60./iFrameRate;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 operation = fragCoord - 0.5;\n\n    int start, end;\n    \n    float sound; // pure sound samples average\n    float prev_sound; // previous sound\n    float smooth_sound; // smooth sound\n    float prev_smooth_sound; // previous smooth sound\n    float decrease;\n    float smooth_sound_cont; // smooth sound continues\n    float prev_smooth_sound_cont; // previous smooth sound continues\n    float delta;\n    float delta_count;\n    float is_music_on;\n\n    // Initialize values\n    if(iFrame == 0)\n    {\n        sound = 0.;\n        prev_sound = 0.;\n        smooth_sound = 0.;\n        prev_smooth_sound = 0.;\n        decrease = 0.;\n        smooth_sound_cont = 0.;\n        prev_smooth_sound_cont = 0.;\n        delta = 0.;\n        delta_count = 0.;\n        is_music_on = 0.;\n    }\n    \n    // fragCoord.x determines to calculate bass\\mid\\treble\n    if(operation.x == 0.) { start = BASS_START; end = BASS_END;}\n    if(operation.x == 1.) { start = MID_START; end = MID_END;}\n    if(operation.x == 2.) { start = TREBLE_START; end = TREBLE_END;}\n    \n    // determine if music started\n    is_music_on = BufA(0., 7.).x;\n    \n    // prev sound\n    sound = getSound(start, end);\n    prev_sound = BufA(operation.x, 0.).x;\n    \n    // sound type 2\n    prev_smooth_sound_cont = BufA(operation.x, 2.).x;\n    prev_smooth_sound = BufA(operation.x, 3.).x;;\n    decrease = BufA(operation.x, 4.).x;\n    if(sound > prev_smooth_sound)\n    {\n        smooth_sound = prev_smooth_sound + (sound-prev_smooth_sound)*INCREASE_MUL;\n        decrease = DECREASE_MIN;\n    }\n    else\n    {\n        smooth_sound = prev_smooth_sound - decrease;\n        decrease *= 1. + iTimeDelta * DECREASE_MUL;\n    }\n    \n    // smooth_sound_cont - circles motion\n    delta = BufA(operation.x, 5.).x;\n    delta_count = BufA(operation.x, 6.).x;\n    if(sound > prev_sound)\n    {\n        is_music_on = 1.;\n        \n        // this statement is to prevent exreme acceleration, when bass\\middle\\treble goes higher very quickly.\n        // in other words - saturate it.\n        // bigger value - accept a bigger acceleration.\n        // to notice the difference, just comment the if statement and reset the shader,\n        // then look at the blue circle which represent the treble\n        if(delta_count < DELTA_COUNT_MAX)\n        {\n            //delta += DELTA_INCREASE;\n            delta += iTimeDelta * DELTA_INCREASE;\n            delta_count += 1.; // for each delta increase\n        }\n    }\n    else\n    {\n        delta_count = 0.; // reset the counting\n        delta *= DELTA_MUL;\n    }\n    smooth_sound_cont = smooth_sound*iTimeDelta + delta + prev_smooth_sound_cont; \n    \n    // to prevent the value to go extremely high, can be useful in some cases when we only care about the fraction value\n    //if(smooth_sound_cont > 50.)\n    //    smooth_sound_cont -= floor(smooth_sound_cont);\n    \n    // fragCoord.y determines to calculate sound\\smoth_sound\\etc..\n    if(operation.y == 0.)\n        fragColor = vec4(sound, 0.,0.,1.0);\n    if(operation.y == 2.)\n        fragColor = vec4(smooth_sound_cont, 0.,0.,1.0);\n    if(operation.y == 3.)\n        fragColor = vec4(smooth_sound, 0.,0.,1.0);\n    if(operation.y == 4.)\n        fragColor = vec4(decrease, 0.,0.,1.0);\n    if(operation.y == 5.)\n        fragColor = vec4(delta, 0.,0.,1.0);\n    if(operation.y == 6.)\n        fragColor = vec4(delta_count, 0.,0.,1.0);\n    if(operation.y == 7.)\n        fragColor = vec4(is_music_on, 0.,0.,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BufA(x, y) texture(iChannel2, (vec2(x, y) + 0.5) / iResolution.xy)\n#define GET_BASS_PURE BufA(0.,0.).x\n#define GET_BASS BufA(0.,3.).x\n#define GET_BASS_CONT BufA(0.,2.).x\n#define GET_MID_PURE BufA(1.,0.).x\n#define GET_MID BufA(1.,3.).x\n#define GET_MID_CONT BufA(1.,2.).x\n#define GET_TREB_PURE BufA(2.,0.).x\n#define GET_TREB BufA(2.,3.).x\n#define GET_TREB_CONT BufA(2.,2.).x\n#define GET_SOUND_PURE (GET_BASS_PURE + GET_MID_PURE + GET_TREB_PURE)/3.\n#define GET_SOUND (GET_BASS + GET_MID + GET_TREB)/3.\n#define GET_SOUND_CONT (GET_BASS_CONT + GET_MID_CONT + GET_TREB_CONT)/1.5\n#define GET_IS_MUSIC_ON BufA(0.,7.).x\n\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.732050808)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nstruct hex\n{\n    //float x;\n    //float y;\n    vec2 uv;\n    float ang;\n    float dist;\n    vec2 id;\n    vec2 hash;\n};\n\n// Hexagon Coords by BigWings\n// ID's by Shane\nhex HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1., sqrt(3.));\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    \n    vec4 hC = floor(vec4(UV, UV - vec2(.5, 1))/r.xyxy) + vec4(.5, .5, 1, 1.5);\n    vec2 final_hC = dot(a, a) < dot(b,b) ? hC.xy : hC.zw;\n    //angle, dist from center, id_x, id_y\n    hex ret = hex(gv.xy, x, y, final_hC, vec2(0.));\n    return ret;\n}\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\n\nvec2 Rot(vec2 p, float ang)\n{\n    return vec2(p.x * cos(ang) - p.y * sin(ang), p.x * sin(ang) + p.y * cos(ang));\n}\n\n// Hash function by BigWings\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}","name":"Common","description":"","type":"common"}]}