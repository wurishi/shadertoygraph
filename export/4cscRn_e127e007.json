{"ver":"0.1","info":{"id":"4cscRn","date":"1720705429","viewed":42,"name":"The sunrise reflection on ocean","username":"mike2367","description":"made through applying noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code ref: https://www.shadertoy.com/view/4dlGDN\n// code ref: https://www.shadertoy.com/view/Xt3yDS\nvec3 hash33(vec3 p) { \n   return -fract(sin(p)*58.5453);\n}\nvec2 hash( vec2 p )\n{\n    return fract(sin(p)*43758.5453);\n}\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); \n}\n\nfloat sTri(vec2 p, float radius) {\n    return length(p) - radius < 0.?0.:.5;\n}\n\n#define PI 3.14159265359\n\nvec2 smoothRepeatStart(float x, float size) {\n  return vec2(\n      mod(x - size / 2., size),\n      mod(x, size)\n  );\n}\n\nfloat smoothRepeatEnd(float a, float b, float x, float size) {\n  return mix(a, b,\n      smoothstep(\n          0., 1.,\n          sin((x / size) * PI * 2. - PI * .5) * .5 + .5\n      )\n  );\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 45.0), hash(n+ 45.0),f.x),f.y);\n}\nvec2 map( vec2 p, in float offset )\n{\n\tp.x += 0.1*sin( iTime + 2.0*p.y ) ;\n\tp.y += 0.1*sin( iTime + 2.0*p.x ) ;\n\t\n\tfloat a = noise(p*1.5 + sin(0.1*iTime))*6.2831;\n\ta -= offset;\n\treturn vec2( cos(a), sin(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Square uv centered and sclead to the screen height\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    // Zoom in a bit\n    uv /= 2.;\n    float repeatSize = 4.;\n    float x = uv.x - mod(sin(iTime), repeatSize / 2.);\n    float y = uv.y;\n\n    vec2 ab; // two sample points on one axis\n\n    float noise;\n    float noiseA, noiseB;\n    float offset = iTime + fragCoord.x/iResolution.x;\n    \n    // Blend noise at different frequencies, moving in\n    // different directions\n    \n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(16.+vec3(vec2(ab.x, uv.y) * 1.2, 0)) * .5;\n    noiseB = tetraNoise(16.+vec3(vec2(ab.y, uv.y) * 1.2, 0)) * .5;\n    noise = smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n\n    ab = smoothRepeatStart(y, repeatSize / 2.);\n    noiseA = tetraNoise(vec3(vec2(uv.x, ab.x) * .5, 0)) * 2.;\n    noiseB = tetraNoise(vec3(vec2(uv.x, ab.y) * .5, 0)) * 2.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, y, repeatSize / 2.);\n\n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(9.+vec3(vec2(ab.x, uv.y) * .05, 0)) * 5.;\n    noiseB = tetraNoise(9.+vec3(vec2(ab.y, uv.y) * .05, 0)) * 5.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n    \n\n\n    noise *= .35;\n\n\n    // Blend with a linear gradient, this gives the isolines a\n    // common orientation (try changing .6 to 1.)\n    noise = mix(noise, dot(uv, vec2(-.66,1.)*.4), .6);\n    \n    // Create anti-aliased even weight isolines from the noise...\n\n    // Break the continuous noise into steps\n    float spacing = 1./50.;\n    float lines = mod(noise, spacing) / spacing;\n\n\n    lines = min(lines * 2., 1.) + max(lines * 2. - 1., 0.);\n    \n    // Scale it by the amount the noise varies over a pixel,\n    // factoring in the spacing scaling that was applied.\n    // noise is used because it's continuous, if we use lines we'd\n    // see stepping artefacts.\n    lines /= fwidth(noise / spacing);\n\t\n    // Double to occupy two pixels and appear smoother\n    lines /= 2.;\n    \n    // Triangle distance\n    float d = sTri(uv + vec2(0,.1), .3);\n    \n    // Create a fuzzy border from 0 - 1 around the triangle, this\n    // controls the pointy shape where lines transition from thick\n    // to thin\n    float weight = smoothstep(.05, .1, d);\n\n    // Adjust to the desired inner and outer weight\n    weight = mix(7.2, 4.7, weight);\n\n    \n    // Scale the weight when fullscreen\n    weight *= iResolution.y / 287.;\n\n    // Offset the line by the weight\n    lines -= weight - 1.;\n    vec3 Lines = vec3(d*.4, lines + d * 4., lines+ d * 2.);\n    float acc = 0.0;\n    for( int i=0; i<32; i++ )\n\t{\n\t\tvec2 dir = map( uv, offset );\n\t\t\n\t\tfloat h = float(i)/32.0;\n\t\tfloat w = 4.0*h*(1.0-h);\n\t\t\n\t\tvec3 ttt = w*texture( iChannel0, uv ).xyz;\n\t\tttt *= mix( vec3(0.6,0.7,0.7), vec3(1.0,0.95,0.9), 0.5 - 0.5*dot( reflect(vec3(dir,0.0), vec3(1.0,0.0,0.0)).xy, vec2(0.707) ) );\n\t\tLines += w*ttt;\n\t\tacc += w;\n\t\t\n\t\tuv += 0.05*dir;\n\t}\n    vec3 col = vec3(Lines.x, Lines.y * 0.5, Lines.z*0.4);\n\tfragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}