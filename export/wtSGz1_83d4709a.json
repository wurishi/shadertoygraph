{"ver":"0.1","info":{"id":"wtSGz1","date":"1558541019","viewed":408,"name":"Peter Shirley RTFW","username":"shau","description":".... well almost. I ended up using a lot of Reinders implementation where I couldn't get it right. I tried to fudge in a few things of my own (right or wrong): Direct lighting, ray tinting and fuzzy shadows. Scene resets every 20 seconds. F = a few.","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["3d","pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n \n/*\n     Trying to learn a little about path tracing/ray tracing\n     using Peter Shirley books and Reinders example as a crutch.\n     https://github.com/petershirley/raytracinginoneweekend\n\n     Also tried to implement a bit of direct lighting as per IQs examples\n\n     and add/fudge coloured tints to light where rays pass through \n     transparent coloured medium. Not sure what the real term for this is\n\n     Fuzz soft shadows a bit by changing size of light source on shadow rays\n\n     Increasing number of render iteration for each pass to speed up resolution\n\n     For some reason little green ball looks like a tennis ball???\n     I think I've broken ISOTROPIC in my implementation as they don't look\n     too good when stacked in front of each other\n\n     Some nice examples:\n\n     Reinder\n     https://www.shadertoy.com/view/MtycDD\n     https://www.shadertoy.com/view/XlycWh\n\n     IQ\n     https://www.shadertoy.com/view/MsdGzl\n     https://www.shadertoy.com/view/Xtt3Wn\n     \n*/\n\nvoid mainImage(out vec4 fragColour, vec2 fragCoord) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 buf = texture(iChannel0, uv);\n    vec3 colour = buf.xyz/buf.w;\n        \n    fragColour = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592\n#define MAXFLOAT 1e5\n#define SAMPLES 20.0\n#define MAXRECURSIONS 6\n#define EPSILON 0.01\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n#define DIFFUSE_LIGHT 3\n#define ISOTROPIC 4\n\nstruct Box {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Camera {\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    float lensRadius;\n    Ray ray;\n};\n    \nstruct Material {\n    int type;\n    vec3 albedo;\n    vec3 emit;\n    float v;\n};\n    \nstruct HitRecord {\n    float t;\n    vec3 p;\n    vec3 normal;\n    Material material;\n    vec4 sphere;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nvec2 sphIntersect(\n        vec3 ro, \n        vec3 rd, \n        vec4 sphere) {\n    \n\tvec3 oc = ro - sphere.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sphere.w*sphere.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    // physically plausible shadow\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt( max(h,0.0) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t);\n}   \n\nBox boxIntersect(\n        vec3 ro, \n        vec3 rd, \n        vec3 bs) {\n    \n    vec3 m = 1./rd,\n         n = m*ro,\n         k = abs(m)*bs,\n         t1 = -n - k,\n         t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z),\n          tF = min(min(t2.x, t2.y), t2.z);\n    if (tN>tF || tF<0.) return Box(-1.0, -1.0, vec3(0), vec3(0));\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz),\n         nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n    \n    return Box(tN, tF, nN, nF);\n} \n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(\n        uvec2 p) {\n    \n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(\n        inout float seed) {\n    \n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(\n        inout float seed) {\n    \n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(\n        inout float seed) {\n    \n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//reinder    \nvec2 randomInUnitDisk(\n        inout float seed) {\n    \n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\n//reinder    \nvec3 randomInUnitSphere(\n        inout float seed) {\n    \n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n//reinder    \nvec3 randomCosWeightedHemisphereDirection(\n        vec3 n, \n        inout float seed) {\n    \n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 randomPointOnBox(\n        vec3 box, \n        vec3 boxCenter,\n        inout float seed) {\n    \n\tvec3 rius = normalize(randomInUnitSphere(seed));\n    Box bi = boxIntersect(vec3(0.0), rius, box);\n    return boxCenter + rius * bi.tF;\n}\n\nfloat schlick(\n        float cosine, \n        float refIdx) {\n    \n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0*r0;\n    return r0 + (1.0 - r0)*pow(1.0 - cosine, 5.0);\n}\n\nbool refraction(\n        vec3 v, \n        vec3 n, \n        float niOverNt, \n        inout vec3 refracted) {\n    \n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - niOverNt*niOverNt*(1.0 - dt*dt);\n    if (discriminant > 0.0) {\n        refracted = niOverNt*(uv -n*dt) - n*sqrt(discriminant);\n        return true;\n        \n    } else return true;\n}\n\nvec3 materialEmission(HitRecord rec) {\n    if (rec.material.type == DIFFUSE_LIGHT) {\n        return rec.material.emit;\n    } else {\n        return vec3(0.0);\n    }\n}\n\n//wrapper functions\nbool isLight(HitRecord rec) {\n    return (rec.material.type == DIFFUSE_LIGHT);\n}\n\nbool hitSphere(\n        vec4 sphere, \n        Ray ray, \n        float tMin, \n        inout HitRecord rec) {\n    \n    vec2 si = sphIntersect(\n                    ray.origin, \n                    ray.direction, \n                    sphere);\n    \n    float t = si.x < tMin ? si.y : si.x;\n    if (t>tMin && t<rec.t) {\n        rec.t = t;\n        rec.p = ray.origin + t*ray.direction;\n        rec.normal = (rec.p - sphere.xyz) / sphere.w;\n\t    return true;  \n    }\n    return false;\n}\n\nbool hitSphereVolume(vec4 sphere, \n        Ray ray, \n        float tMin, \n        inout HitRecord rec,\n        inout vec3 tint,\n        vec3 tintColour,             \n        float dens,\n        float seed) {\n    \n    vec2 si = sphIntersect(\n                    ray.origin,\n                    ray.direction,\n                    sphere);\n    \n    float t = si.x < tMin ? si.y : si.x;\n    if (t>tMin) {\n        float distanceInsideBoundary = si.y - max(0.0, si.x);\n        float hitDistance = -(1./dens)*log(hash1(seed)); \n        if (hitDistance<distanceInsideBoundary) {\n            rec.t = t + hitDistance;\n            rec.p = ray.origin + ray.direction * rec.t;\n            rec.normal = vec3(1.0, 0.0, 0.0);  // arbitrary\n            return true;\n        } else {\n            //colour escaping light\n            tint += tintColour * distanceInsideBoundary * 1.0;    \n        }\n    }\n    return false;\n}\n\nbool hitBox(\n        vec3 box,\n        vec3 boxCenter,\n        Ray ray,\n        float tMin,\n        inout HitRecord rec) {\n    \n    Box bi = boxIntersect(\n                    ray.origin - boxCenter,\n                    ray.direction,\n                    box);\n\n    if (bi.tN>tMin && bi.tN<rec.t) {\n        rec.t = bi.tN;\n        rec.p = ray.origin +bi.tN*ray.direction;\n        rec.normal = bi.nN;\n        return true;\n    }\n    return false;\n}\n\nCamera setupCamera(\n        vec2 uv,\n        float seed,\n        vec3 lookFrom,\n        vec3 lookAt,\n        vec3 up,\n        float fieldOfView,\n        float aspect,\n        float aperature,\n        float focalLength) {\n    \n    Camera camera;\n    \n    camera.lensRadius = aperature/2.;\n    \n    float theta = fieldOfView * PI/180.;\n    float halfHeight = tan(theta/2.);\n    float halfWidth = aspect * halfHeight;\n    \n    camera.origin = lookFrom;\n    camera.w = normalize(lookFrom - lookAt);\n    camera.u = normalize(cross(up, camera.w));\n    camera.v = cross(camera.w, camera.u); \n    camera.lowerLeftCorner = camera.origin - \n                             halfWidth*focalLength*camera.u -\n                             halfHeight*focalLength*camera.v -\n                             focalLength*camera.w;\n    camera.horizontal = 2.0*halfWidth*focalLength*camera.u;;\n    camera.vertical = 2.0*halfHeight*focalLength*camera.v;;\n        \n    vec2 rd = camera.lensRadius*randomInUnitDisk(seed);\n    vec3 offset = camera.u*rd.x + camera.v*rd.y;\n    camera.ray = Ray(camera.origin + offset, \n                     normalize(camera.lowerLeftCorner + \n                               uv.x*camera.horizontal + \n                               uv.y*camera.vertical - \n                               camera.origin - offset));\n        \n    return camera;\n}\n\nbool materialScatter(\n        float seed,\n        Ray rayIn, \n        HitRecord rec, \n        inout vec3 attenuation, \n        inout Ray scattered) {\n\n    if (rec.material.type==LAMBERTIAN) {\n        scattered = Ray(rec.p, randomCosWeightedHemisphereDirection(rec.normal, seed));\n        attenuation = rec.material.albedo;\n        return true;          \n    } else if (rec.material.type==METAL) {\n        vec3 rd = reflect(rayIn.direction, rec.normal);\n        scattered = Ray(rec.p, normalize(rd + rec.material.v*randomInUnitSphere(seed)));\n        attenuation = rec.material.albedo;\n        return true;        \n    } else if (rec.material.type==DIELECTRIC) {\n        vec3 outwardNormal;\n        vec3 reflected = reflect(rayIn.direction, rec.normal);\n        float niOverNt;\n        attenuation = vec3(1.0, 1.0, 1.0);\n        vec3 refracted;\n        float reflectProb;\n        float cosine;\n        if (dot(rayIn.direction, rec.normal) > 0.) {\n            outwardNormal = -rec.normal;\n            niOverNt = rec.material.v;\n            cosine = dot(rayIn.direction, rec.normal);\n            cosine = sqrt(1. - rec.material.v*rec.material.v*(1.-cosine*cosine));\n        } else {\n            outwardNormal = rec.normal;\n            niOverNt = 1. / rec.material.v;\n            cosine = -dot(rayIn.direction, rec.normal);\n        }\n        \n        if (refraction(\n                rayIn.direction, \n                outwardNormal, \n                niOverNt, \n                refracted)) {\n            \n\t        reflectProb = schlick(cosine, rec.material.v);\n        } else {\n            reflectProb = 1.;\n        }\n        \n        if (hash1(seed) < reflectProb) {\n            scattered = Ray(rec.p, reflected);\n        } else {\n            scattered = Ray(rec.p, refracted);\n        }\n        return true;\n    \n    } else if(rec.material.type == ISOTROPIC) {\n        scattered = Ray(rec.p, randomInUnitSphere(seed));\n        attenuation = rec.material.albedo;\n    \treturn true;    \n    }\n    \n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution.xy\n#define T iTime\n#define BOX vec3(4.0, 0.01, 2.0)\n#define BOX_CENTER vec3(-4.0, 4.6, 2.0)\n\nfloat g_seed = 0.0;\n\nbool hitScene(\n        Ray ray, \n        float tMin, \n        float tMax, \n        inout HitRecord rec,\n        inout vec3 tint,\n        float lightScale) {\n \n    bool hitAnything = false;\n\tfloat closestSoFar = tMax;\n    rec.t = tMax;\n\n    //rectangular light\n    //fuzz light box size for shadow rays\n    if (hitBox(BOX*lightScale, BOX_CENTER, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(DIFFUSE_LIGHT, vec3(0.0), vec3(7.0), 0.0);\n    }\n\n    //floor\n    if (hitSphere(vec4(0.0, -1000.0, -1.0, 1000.), ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(LAMBERTIAN, vec3(0.5), vec3(0.0), 0.0);\n        rec.sphere = vec4(0.0, -1000.0, -1.0, 1000.);\n    }\n\n    //small green center sphere                             \n    if (hitSphere(vec4(0.0, 0.3, 0.0, 0.3), ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(LAMBERTIAN, vec3(0.0, 1.0, 0.0), vec3(0.0), 0.0);\n        rec.sphere = vec4(0.0, 0.2, 0.0, 0.2);\n    }\n        \n    //orange glass sphere\n    vec4 sphereCenter = vec4(-4.0, 1.0, 0.0, 1.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(DIELECTRIC, vec3(1.0, 0.0, 0.0), vec3(0.0), 1.5);\n        rec.sphere = sphereCenter;\n    }\n    if (hitSphereVolume(sphereCenter, \n                        ray, \n                        tMin, \n                        rec,\n                        tint,\n                        vec3(1.0, 0.5, 0.0),\n                        0.9, \n                        g_seed)) {\n        \n        hitAnything = true;\n        rec.material = Material(ISOTROPIC, vec3(1.0, 0.5, 0.0), vec3(0.0), 0.0);\n    }\n\n    //purple metal sphere\n    sphereCenter.xz *= rot(PI/3.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(METAL, vec3(1.0, 0.0, 0.8), vec3(0.0), 0.0);\n        rec.sphere = sphereCenter;\n    }\n\n    //clear glass sphere                            \n    sphereCenter.xz *= rot(PI/3.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(DIELECTRIC, vec3(1.0, 0.0, 0.8), vec3(0.0), 1.5);\n        rec.sphere = sphereCenter;\n    }\n\n    //red metal sphere                            \n    sphereCenter.xz *= rot(PI/3.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(METAL, vec3(1.0, 0.0, 0.0), vec3(0.0), 0.0);\n        rec.sphere = sphereCenter;\n    }\n\n    //blue glass sphere\n    sphereCenter.xz *= rot(PI/3.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(DIELECTRIC, vec3(1.0, 0.0, 0.0), vec3(0.0), 1.5);\n        rec.sphere = sphereCenter;\n    }\n    if (hitSphereVolume(sphereCenter, \n                        ray, \n                        tMin, \n                        rec,\n                        tint,\n                        vec3(0.0, 0.0, 1.0),\n                        0.3, \n                        g_seed)) {\n        \n        hitAnything = true;\n        rec.material = Material(ISOTROPIC, vec3(0.0, 0.0, 1.0), vec3(0.0), 0.0);\n    }\n\n    //yellow metal sphere\n    sphereCenter.xz *= rot(PI/3.0);\n    if (hitSphere(sphereCenter, ray, tMin, rec)) {\n        hitAnything = true;\n        rec.material = Material(METAL, vec3(1.0, 1.0, 0.0), vec3(0.0), 0.0);\n        rec.sphere = sphereCenter;\n    }\n\n\n    return hitAnything;\n}\n\nvec3 directLight(HitRecord rec) {\n    \n    vec3 colour = vec3(0.0);\n    vec3 tint = vec3(0.0);\n    \n    vec3 lightPosition = randomPointOnBox(BOX, BOX_CENTER, g_seed);\n    vec3 lightDirection = normalize(lightPosition - rec.p);\n    \n    float tMax = length(lightPosition - rec.p);\n    \n    HitRecord shadowRec;\n    Ray shadowRay = Ray(rec.p, lightDirection);\n    \n    //fuzz shadows\n    float h1 = 0.6*(float(base_hash(floatBitsToUint(rec.p.xz)))/float(0xffffffffU)+T);\n    if (hitScene(shadowRay, 0.001, tMax, shadowRec, tint, max(0.0, 1.0 - h1*0.6))) {\n        float st = length(shadowRec.p - rec.p);\n        float attn = 1.0 / (1.0 + shadowRec.t*shadowRec.t*0.5);\n        colour = materialEmission(shadowRec) * attn;    \n        if (!isLight(shadowRec)) {\n            colour *= sphSoftShadow(rec.p, lightDirection, shadowRec.sphere, 16.0);\n        }\n        colour += tint*attn*0.5; //tint\n    }\n    return colour;\n}\n\nvec3 colour(\n        float seed,\n        Ray ray) {\n    \n    HitRecord rec;\n    vec3 colourMask = vec3(1.0), \n         tint = vec3(0.0),\n         sceneColour = vec3(0.0);\n    float tdis = 0.0;\n    \n    for (int i=0; i<MAXRECURSIONS; i++) {\n        if (hitScene(ray, 0.001, MAXFLOAT, rec, tint, 1.0)) {\n            Ray scattered;\n            vec3 attenuation;\n            \n            tdis += rec.t;\n            \n            if (materialScatter(\n                    seed,\n                    ray, \n                    rec, \n                    attenuation, \n                    scattered)) {\n                \n                colourMask = i==0 ? attenuation : colourMask * attenuation;\n                ray = scattered;\n                sceneColour = colourMask * directLight(rec);\n                \n            } else {\n                //hit light\n                sceneColour = (i == 0) ? materialEmission(rec) : colourMask * (materialEmission(rec) + tint);\n                break;\n            }\n            \n        } else {\n            //missed scene\n            break;\n        }\n        if (dot(colourMask, colourMask) < 0.0001) break;\n    } \n    \n    float ff = exp(-0.02*tdis);\n    sceneColour *= ff;\n    \n    return sceneColour;   \n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec4 buf = texelFetch(iChannel0, ivec2(1,0), 0);\n    if (buf==vec4(0)) buf = vec4(15.0, 5.0, 3.0, 1.0);\n    \n    float at = mod(T,20.);\n\n    vec3 lookFrom = buf.xyz,\n         lookAt = vec3(0.0, 0.0, 0.0),\n         pixelColour = vec3(0.0),\n         up = vec3(0.0, 1.0, 0.0);\n    \n    vec2 uv = (U + hash2(g_seed))/R;\n    \n    float aspect = R.x/R.y,\n          fieldOfView = 20.0,\n          aperature = 0.1,\n          focalLength = 15.0;\n     \n    //force render reset and camera move every 20 seconds\n    if (ivec2(U) == ivec2(0)) {\n        //I like this technique to re-render when screen size changes\n        //again from Reinder\n        C = R.xyxy * step(at, 19.9); \n    } else if (ivec2(U) == ivec2(1,0)) {\n        //camera lookFrom state\n        buf.xz *= rot(0.4 * step(19.9, at));\n        C = buf;\n    } else {\n        \n        vec3 acCol = vec3(0.0);\n        for (float i=0.0; i<SAMPLES; i++) {\n            g_seed = i + float(base_hash(floatBitsToUint(U)))/float(0xffffffffU)+T;\n            Camera cam = setupCamera(\n                uv,\n                g_seed,\n                lookFrom, \n                lookAt, \n                up, \n                fieldOfView, \n                aspect, \n                aperature, \n                focalLength);\n            acCol += colour(g_seed, cam.ray);\n        }\n            \n        pixelColour = acCol/SAMPLES;\n        \n        if (texelFetch(iChannel0, ivec2(0),0).xy == R) {        \n\t        C = vec4(pixelColour, 1.0) + texelFetch(iChannel0, ivec2(U), 0);\n        } else {        \n\t        C = vec4(pixelColour, 1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}