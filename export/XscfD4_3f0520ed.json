{"ver":"0.1","info":{"id":"XscfD4","date":"1525074598","viewed":481,"name":"Neural Network Digit printer","username":"akhgary","description":"digits are converted to 5-bit binary (extra bit for bias) and passed into the network. \nnetwork outputs 3 numbers, these numbers are 5-bit bit-masks, \ntherefor numbers are mapped to 3 columns and 5 rows indicating which box should be on or off.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["number","map","digit","plot","show","print","neural","network","neuralnetwork","bitmask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a multi-layer perceptron trained to map digits into 3x5 grid.\n//\n// I know its overkill but i did it for fun.\n//\n// the network has 4 inputs (+1 bias) and 3 outputs.\n//\n// the hidden layer has 8 neurons, \n// i maybe able to reduce nuerons to 7 or 6 but training becomes much harder.\n//\n// activation function for hidden layer is \"leaky relu\"\n// with parameter e, i.e euler number (just for fun)\n//\n// output layer activation function is identity with no bias.\n//\n// if feedforward propagaition process (i.e matrix operations) \n// was done on parallel as well, this would perform much faster.\n//\n// leraning rate was set to 0.0025 and \n// it took about 20 thousand iterations to complete training process\n// using stochastic gradient descent and momentum optimizer.\n\nconst float e = 2.718;\n\nfloat[] M5x8 = float[](\n-3.848,-1.199,-6.866, 4.184,-1.614,-0.535,-1.750, 0.712,\n-2.836,-3.297,-3.862, 2.182, 0.960, 3.122,-0.744,-2.085,\n-3.851, 1.785,-6.241, 5.170,-2.690, 0.205,-2.613,-1.910,\n 2.810,-2.801, 5.849,-5.508, 1.408,-3.599, 2.308, 0.222,\n 5.560,-0.384,-2.017,-1.906,-2.263, 0.000,-3.095,-3.417);\n\nfloat[] M8x3 = float[](\n 6.724, 3.157, 2.590,\n-2.459,-3.694, 1.484,\n-6.943, 2.090,-9.163,\n 3.347, 6.206,-5.418,\n 2.717, 0.953,-2.970,\n 0.718,-4.600, 0.477,\n 2.817,-2.431,-3.094,\n 3.236,-2.270,-0.168);\n\n// gets binary from a 5bit number\nfloat[5] toBinary(int x) {\n    float[] bin = float[](1.,1.,1.,1.,1.);\n    int p = 16;\n    for(int i=0;i<5;i++,p>>=1) {\n        if(x<p) bin[i]=0.;\n        else x-=p;\n    }\n    return bin;\n}\n\nfloat[8] feedforward1(float[5] A){\n    float[8] B;\n    for(int col=0;col<8;col++)\n        for(int row=0;row<5;row++)\n            B[col]+=A[row]*M5x8[row*8+col];\n    return B;\n}\n\n// perform activation function\nfloat[8] leakyRelu(float[8] B){\n    for(int i=0;i<8;i++)\n        if(B[i]<0.0)B[i]*=1./e;\n    return B;\n}\n\nfloat[3] feedforward2(float[8] B){\n    float[3] C;\n    for(int col=0;col<3;col++)\n        for(int row=0;row<8;row++)\n            C[col]+=B[row]*M8x3[row*3+col];\n    return C;\n}\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\nfloat digit(vec2 uv, vec2 c, float w, float h, int d){\n    \n    vec2 wh = vec2(w/3.,h/5.);\n    vec2 o = vec2(w/2.,h/2.);\n    float v = 0.0;\n    \n    float[5] bin = toBinary((d<<1)|1);\n    float[3] map = feedforward2(leakyRelu(feedforward1(bin)));\n    \n    for(int col=0;col<3;col++)\n    {\n        float[5] mapBin = toBinary(int(round(map[col])));\n        \n        for(int row=0;row<5;row++){\n            \n            vec2 p0 = c-o+wh*vec2(col,row), p1 = p0+wh;\n            vec2 lb = step(p0,uv);\n            vec2 ub = 1.-step(p1,uv);\n            \n            if(mapBin[5-row-1]>0.5) v += lb.x*lb.y*ub.x*ub.y;\n        }\n    }\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy);\n    vec3 col = vec3(0);\n    \n    int d = int(floor(mod(iTime,10.0)));\n        \n    col += digit(uv, vec2(0),iResolution.y/iResolution.x,1.0,d);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}