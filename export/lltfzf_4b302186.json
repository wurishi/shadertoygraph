{"ver":"0.1","info":{"id":"lltfzf","date":"1540543748","viewed":146,"name":"We're doing better","username":"wazoowazoo","description":"This is a huge progress into direction \"water shader\", next step is probably using perlin noise for waves generation instead of a z = f(x, y) function. Any idea why it seems so laggy ?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["water","distorsion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P 0.001 //derivative precision\n#define SIZE vec2(10, 7.5) //function size/precision\n#define WATER vec4(1, 1, 1, 1) //water color, do you have any suggestions ? write in comments !\n\nfloat func(vec2 coords, float offset) {\n  \treturn (sin(coords.x - offset) * sin(coords.y + offset) + 1.0) / 2.0;\n  \t//return (sin(coords.x - offset) + 1.0) / 2.0;\n  \t//return cos(sqrt(pow(coords.x + offset, 2.0) + pow(coords.y + offset, 2.0))); //this one is ugly\n  \t//uncomment line to see reslut\n    //you can add you own functions ;)\n}\n\nfloat xDerivative(vec2 coords, float offset) {\n  \treturn (func(coords + vec2(P, 0), offset) - func(coords - vec2(P, 0), offset))/((coords.x + P) - (coords.x - P));\n}\n\nfloat yDerivative(vec2 coords, float offset) {\n  \treturn (func(coords + vec2(0, P), offset) - func(coords - vec2(0, P), offset))/((coords.y + P) - (coords.y - P));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 texCoords = fragCoord / iResolution.xy;\n    float waveHeight = func(texCoords * SIZE, iTime);\n\n    float xDerivative = xDerivative(texCoords * SIZE, iTime);\n    float yDerivative = yDerivative(texCoords * SIZE, iTime);\n\n    vec2 off;\n    off.x = xDerivative * waveHeight / SIZE.x;\n\toff.y = yDerivative * waveHeight / SIZE.y;\n\n    //return vec4(abs(off.x), abs(off.y), 0, 1);\n    //return vec4(waveHeight, 0, 0, 1);\n    fragColor = texture(iChannel0, texCoords + off) * WATER;\n}\n","name":"Image","description":"","type":"image"}]}