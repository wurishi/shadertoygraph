{"ver":"0.1","info":{"id":"WsfcRs","date":"1670592310","viewed":194,"name":"Ocean Of Sin() V0.8 Test","username":"Delvar","description":"A test bench for a bunch of things I wanted to play with. Compilation times grew too big and i never optimised it down, still someone might like it.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["test","reflection","cloud","wip","ocean","lod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Ocean Of Sin() V0.7 Test'\n//  https://www.shadertoy.com/view/WdfyzH\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tA test bench for a bunch of things I wanted to pay with,\n//\t1. Ocean/Clouds generation using sin waves.\n//\t2. Using vec4 to processes 4 octaves in one go.\n//\t3. Multiple levels of reflection.\n//\t4. Distance from camera LOD on everything!\n//\t5. Super sampling.\n//\t    \n//\tCredits: \n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://iquilezles.org/articles/distfunctions\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 100.0\n\n#define MIN_SURFACE_DISTANCE_BASE 0.002\n#define MIN_SURFACE_DISTANCE_MOD 0.02\n\n#define REFLECTION_OFFSET_BASE 0.004\n#define REFLECTION_OFFSET_MOD 0.04\n\n#define SHADOW_MIN_SURFACE_DISTANCE_BASE 0.004\n#define SHADOW_MIN_SURFACE_DISTANCE_MOD 0.04\n\n#define SHADOW_OFFSET_BASE 0.008\n#define SHADOW_OFFSET_MOD 0.08\n\n#define PI  3.1415926535897932384626433832795\n\n//enable to melt you system\n//#define DEBUG_MULTISAMPLE\n\n//#define DEBUG_RAY_DITHER\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_OCCLUSION\n#define DEBUG_SHADOW\n#define DEBUG_SHADOW_IGNORE_OCEAN\n#define DEBUG_MAX_REFLECTIONS 2\n#define DEBUG_REFLECTION_FRESNEL\n#define DEBUG_VIGNETTE\n#define DEBUG_SUN_RAYS_RENDER\n#define DEBUG_CLOUDS\n\n#define OCCLUSION_LOD_DISTANCE1 0.05\n#define OCCLUSION_LOD_DISTANCE2 0.1\n\n#define SHADOW_LOD_DISTANCE1 0.05\n#define SHADOW_LOD_DISTANCE2 0.1\n\n#define OCEAN_LOD_REFLECTION_DISTANCE1 0.05\n#define OCEAN_LOD_REFLECTION_DISTANCE2 0.1\n\n#define OCEAN_LOD_OCTAVES_DISTANCE1 0.05\n#define OCEAN_LOD_OCTAVES_DISTANCE2 0.5\n\n#define CLOUD_LOD_MIN_OCTAVES 4.0\n#define CLOUD_LOD_MAX_OCTAVES 64.0\n\n//Define the number of octaves for the Ocean based on the distance from the camera\n#define OCEAN_LOD_MIN_NORM_OCTAVES 1.0\n#define OCEAN_LOD_MAX_NORM_OCTAVES 60.0\n#define OCEAN_LOD_MIN_SDF_OCTAVES 1.0\n#define OCEAN_LOD_MAX_SDF_OCTAVES 4.0\n//Adds a little more motion to the surface\n#define OCEAN_TRANSLATION\n\n#define CLOUD_OCCLUSION_STEPS 10.0\n#define CLOUD_OCCLUSION_DISTANCE 2.5\n#define CLOUD_OCCLUSION_SCALE 10.0/CLOUD_OCCLUSION_STEPS\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_OCEAN\t1\n#define MAT_YELLOW\t2\n#define MAT_CHROME\t3\n#define MAT_BLACK\t4\n#define MAT_WHITE\t5\n\n// -- Colours\n#define SUN_COLOUR vec3(1.6,1.2,0.8)\n\n#define OCEAN_BASE vec3(0.04,0.06,0.4)\n#define OCEAN_REFLECTION_BASE vec3(0.06,0.24,0.36)\n#define OCEAN_TINT vec3(0.3,0.8,0.9)\n#define AMBIENT_COLOUR vec3(0.3, 0.49, 0.54)\n\n#define HAZE_BASE_COLOUR vec3(2.85,2.5,2.2)\n#define SKY_BASE_COLOUR vec3(0.29,0.76,1.71)\n#define SKY_UPPER_COLOUR vec3(0.24,0.28,0.72)\n\n// -- Debug Colours, https://en.wikipedia.org/wiki/Web_colors\n#define White vec3(1.0)\n#define Silver vec3(0.75)\n#define Gray vec3(0.5)\n#define Black vec3(0.0)\n#define Red vec3(1.0,0.0,0.0)\n#define Maroon vec3(0.5,0.0,0.0)\n#define Yellow vec3(1.0,1.0,0.0)\n#define Olive vec3(0.5,0.5,0.0)\n#define Lime vec3(0.0,1.0,0.0)\n#define Green vec3(0.0,0.5,0.0)\n#define Aqua vec3(0.0,1.0,1.0)\n#define Teal vec3(0.0,0.5,0.5)\n#define Blue vec3(0.0,0.0,1.0)\n#define Navy vec3(0.0,0.0,0.5)\n#define Fuchsia vec3(1.0,0.0,1.0)\n#define Purple vec3(0.5,0.0,0.5)\n#define Orange vec3(1.0,0.65,0.0)\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance of eye from screen\n};\n\nstruct rayMarch {\n    vec3 origin, direction;\n};\n\nstruct rayQuery {\n    vec3 origin;\n    float surfaceDistance;\n    int materialId;\n};\n\nstruct rayHit {\n    vec3 rayOrigin, origin, incidence, normal, albedo, diffuse, specular;\n    float surfaceDistance, rayDistance, rayDistanceRatio, cameraDistance, cameraDistanceRatio;\n    float reflectivity, occlusion, shadow, shininess;\n    int materialId, iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst vec3 sunDir = normalize(vec3(5.0, 4.0, 5.0));\n//const vec3 sunColour=Red;\n//vec3(0.8,0.6,0.4);\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nrayMarch getRay(vec2 uv, camera camera) {\n    rayMarch ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\nrayMarch getRefRay(rayHit hit) {\n    rayMarch ray;\n    ray.direction = reflect(hit.incidence, hit.normal);\n    ray.origin = hit.origin + hit.normal * (REFLECTION_OFFSET_MOD * hit.cameraDistanceRatio + REFLECTION_OFFSET_BASE );\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n#define HI 95.501775192\n#define HJ 45.043107817\n#define HK 22.671833926\n#define HL 25.490516071\n\nfloat hash11(float st) {\n    return fract(sin(st*HE)*HD); \n}\n\nvec4 hash44(vec4 st) {\n    return fract(sin((st+vec4(HE,HF,HG,HH))*vec4(HI,HJ,HK,HL))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n}\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 3D ==\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ==  ==\n// From https://www.shadertoy.com/view/Mly3R3\n// I dont understand it :)\n\nconst float PHI = (1.+sqrt(5.))/2.;\nconst float A = PHI / sqrt( 1. + PHI*PHI );\nconst float B = 1. / sqrt( 1. + PHI*PHI );\nconst float J = 0.309016994375;\nconst float K = J+.5;\n\nconst mat3 R0 = mat3(0.5,-K,J        ,K,J,-0.5                       ,J,0.5,K                          );\nconst mat3 R1 = mat3(K,J,-0.5        ,J,0.5,K                        ,0.5,-K,J                         );\nconst mat3 R2 = mat3(-J,-0.5,K       ,0.5,-K,-J                      ,K,J,0.5                          );      \nconst mat3 R3 = mat3(-0.5,sqrt(.75),0,K,0.467086179481,0.356822089773,-J,-0.178411044887,0.934172358963);\nconst mat3 R4 = mat3(0.587785252292,-K,0.,-0.425325404176,-J,0.850650808352,0.688190960236,0.5,0.525731112119);\nconst vec3 O3 = vec3(B,B/sqrt(3.),sqrt(1.-4./3.*B*B));\nconst vec3 O4 = vec3(A/3./tan(PI/5.),A/3.,0.63147573033330584);\n\nvec3 opIcosahedron( vec3 p )\n{    \n    p = R0 * abs( p );\n    p = R1 * abs( p );\n    p = R2 * abs( p );\n    return abs( p );  \n}    \n\nvec3 opAlignedDodecahedron( vec3 p, float radius )\n{         \n    return R4 * opIcosahedron( p ) - O4 * radius;\n}  \n\nfloat sdRoundedDodecahedron( vec3 p, float radius, float cornerRadius )\n{\n    float bound = sdSphere( p, radius );\n    if( bound > radius ) return bound;\n        \n    p = opAlignedDodecahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\nvec3 opAlignedIcosahedron( vec3 p, float radius )\n{         \n    return R3 * opIcosahedron( p ) - O3 * radius;\n}  \n\nfloat sdRoundedIcosahedron( vec3 p, float radius, float cornerRadius )\n{   \n    float bound = sdSphere( p, radius );\n    if( bound > radius ) return bound;\n        \n    p = opAlignedIcosahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\ncamera getTableCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n    camera.origin.y = max(camera.origin.y,1.0);\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec2 mouse, in float time) {\n    return getTableCamera(vec3(0.0,2.0,0.0), 2.5, 0.0, -mouse.y*PI, -mouse.x*2.0*PI,  0.5);\n}\n\n// ========== ==========\n\n// ========== Screen Space Effects ==========\n\nvec3 getLensFlare(vec2 uv, vec2 sunUv)\n{\n \t// Render the 'godray'?\n    vec2 delta = uv-sunUv;\n    float distance = clamp(dot(delta,delta),0.0,1.0);\n    float angle = atan(delta.x,delta.y);\n    //FIXME: remove thsi and use sin instead.\n    float ray =sin(valueNoise1du(sin(angle*3.0+sunUv.x*2.0)*7.0-cos(angle*5.0+sunUv.y*2.0)))*0.2;\n    ray*=1.0-distance;\n    ray+=pow(1.0-distance,10.0);\n    ray*=0.1;\n    //Render the 'circles'\n    //further away from the center the bigger they gets\n    vec2 uvSpread =  uv * length(uv) ;\n    //Offset the RGB to fake Chromatic Aberration\n    vec3 circles = vec3(0.0);\n    if (sunUv.x > -1.5 && sunUv.y > -1.0 && sunUv.x < 1.5 && sunUv.y < 1.0) {\n        for (float i=0.0;i<5.0;i++) {\n            vec2 circlePosition = sunUv * (0.5 - 0.4*i);\n            float size = 40.0/(i+1.0);\n            float blur = 2.0*(5.0-i);\n            circles += vec3(\tmax(\t0.0,\t1.0-pow(length(\t\t\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.05*\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.1*\t\tcirclePosition-delta)*size,blur)));    \n        }\n    }\n    // Odd edge glows ...\n    circles += vec3(\n        max(0.0, 5.0/(1.0+25.0*pow(length(uvSpread-0.7*-sunUv),1.5))),\n        max(0.0, 5.0/(1.0+30.0*pow(length(uvSpread-0.8*-sunUv),1.4))),\n        max(0.0, 5.0/(1.0+35.0*pow(length(uvSpread-0.9*-sunUv),1.3)))\n    );\n\n    circles += vec3(\n        max(0.0, 1.0-(1.0*pow(length(uvSpread-0.7*-sunUv)*5.5,2.5))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.8*-sunUv)*5.5,2.4))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.9*-sunUv)*5.5,2.3)))\n    );\n\n    return circles*0.01*distance + ray;\n}\n\n// ========== ==========\n\n\n// ========== Ray Marcher ==========\n\n// ========== Ocean ==========\n\n//New faster way to geneerate the height using vec math to reduce required instructions.\nfloat getOceanHeight(vec2 position, float totalOctaves, float time) {\n    vec2 p = position + vec2(1000.0);// move off center as we get artifacts around 0,0\n\n    float maxHeight = 0.0;\n    float height = 0.0;\n\n    for(float quadOctave = 0.0; quadOctave<totalOctaves; quadOctave+=4.0) {\n        vec4 octaves = vec4(0.0,1.0,2.0,3.0)+quadOctave;\n        //frequencies, PI2*0.03\n        vec4 fs = pow(vec4(1.095),octaves)*0.25;\n        //amplitudes\n        vec4 as = pow(vec4(0.9),octaves);\n        //For runs where we dont want exactly multiple of 4 octaves.. to match the old output.\n        float octaivesRemaining = totalOctaves-quadOctave;\n\n        //Rotations\n        vec4 angles = (octaves*0.1)+hash44(octaves)*0.2;\n        \n        vec4 cAngles = cos(angles), sAngles = sin(angles);\n        vec4 xs, ys;\n\n        #if defined(OCEAN_TRANSLATION)\n        vec4 ts = time*0.1*as; \n        #endif\n\n        for(int i;i<4;i++) {\n            #if defined(OCEAN_TRANSLATION)\n            p-= ts[i];\n            #endif\n\n            p=p*mat2(cAngles[i],-sAngles[i], sAngles[i], cAngles[i]);\n            xs[i] = p.x;\n            ys[i] = p.y;\n        }\n\n        vec4 values = 1.0-abs(sin(fs*xs+time)+sin(fs*ys));\n        values=1.0-values*values;\n        values=(0.5-values*values)*2.0;\n        \n        if(octaivesRemaining<1.0) {\n            as*=vec4(fract(totalOctaves),0.0,0.0,0.0);\n        } else if(octaivesRemaining<2.0) {\n            as*=vec4(1.0,fract(totalOctaves),0.0,0.0);\n        } else if(octaivesRemaining<3.0) {\n            as*=vec4(1.0,1.0,fract(totalOctaves),0.0);\n        } else if(octaivesRemaining<4.0) {\n            as*=vec4(1.0,1.0,1.0,fract(totalOctaves));\n        }\n        \n        values *= as;\n\n        height+=dot(values,vec4(1));\n        maxHeight+=dot(as,vec4(1));\n    }\n    return (height/maxHeight)*0.5;\n}\n\nfloat getOceanLod(float cameraDistanceRatio, bool isSdf){\n    cameraDistanceRatio=clamp(cameraDistanceRatio,0.0,1.0);\n    if(isSdf) {\n        return mix(OCEAN_LOD_MAX_SDF_OCTAVES, OCEAN_LOD_MIN_SDF_OCTAVES, cameraDistanceRatio);\n    } else {\n        return mix(OCEAN_LOD_MAX_NORM_OCTAVES, OCEAN_LOD_MIN_NORM_OCTAVES, cameraDistanceRatio);\n    }\n}\n\nvec3 getOceanNormal(vec2 point, float cameraDistanceRatio, in float time) {\n    float oceanLod = getOceanLod(cameraDistanceRatio, false);\n\n    float hc = getOceanHeight(point, oceanLod, time)*0.5+0.5;\n    float hl = getOceanHeight(point + vec2(-0.005773,0.0), oceanLod, time)*0.5+0.5;\n    float hf = getOceanHeight(point + vec2(0.0,-0.005773), oceanLod, time)*0.5+0.5;\n\n    return normalize(vec3(\n        hl - hc,\n        0.0028865,\n        hf - hc\n    ));\n}\n\nvoid sdfShapes(inout rayQuery query, float cameraDistanceRatio, float oceanLod, in float time) {\n\tfloat newDistance = query.surfaceDistance;\n    vec3 objectPos;\n\n    objectPos=vec3(2.0,0.0,-2.0);\n    objectPos.y=getOceanHeight(objectPos.xz, OCEAN_LOD_MAX_SDF_OCTAVES, time)-0.125;\n    newDistance = min(newDistance, sdRoundedIcosahedron(query.origin-objectPos, 1.0, 0.02));\n\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;\n        query.materialId = MAT_BLACK;\n    }\n\n    objectPos=vec3(-2.0,0.0,0.0);\n    objectPos.y=getOceanHeight(objectPos.xz, OCEAN_LOD_MAX_SDF_OCTAVES, time)-0.125;\n    newDistance = min(newDistance, sdBox(query.origin - objectPos, vec3(1.0,1.0,1.0))-0.02);\n\n    objectPos=vec3(0.0,2.0+sin(time),0.0);\n    newDistance = min(newDistance, sdSphere(query.origin-objectPos, 0.5));\n\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;\n        query.materialId = MAT_CHROME;\n    }\n\n    objectPos=vec3(2.0,0.0,2.0);\n    objectPos.y=getOceanHeight(objectPos.xz, OCEAN_LOD_MAX_SDF_OCTAVES, time)-0.125;\n    \n    newDistance = min(newDistance, sdRoundedDodecahedron(query.origin-objectPos, 1.0, 0.02));\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;\n        query.materialId = MAT_YELLOW;\n    }\n\n    objectPos=vec3(-1.0,2.0,2.0);\n    newDistance = min(newDistance, sdSphere(query.origin-objectPos, 0.5));\n\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;\n        query.materialId = MAT_WHITE;\n    }\n}\n\nvoid sdfOceon(inout rayQuery query, float cameraDistanceRatio, float oceanLod, in float time) {\n    float newDistance = query.surfaceDistance;\n    float heightCenter = getOceanHeight(query.origin.xz, oceanLod, time);\n    newDistance = (query.origin.y - heightCenter);\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;        \n        query.materialId = MAT_OCEAN;\n    }\n}\n\nvoid QuerySdf(inout rayQuery query, float cameraDistanceRatio, in float time) {\n    query.materialId = MAT_SKY;\n    query.surfaceDistance = RAY_MAX_DISTANCE;\n\n    float oceanLod = getOceanLod(cameraDistanceRatio,true);        \n\n    sdfShapes(query, cameraDistanceRatio, oceanLod, time);\n        \n    //only do the expensive water lookup if it could be closer than the other shapes.\n    if (query.surfaceDistance > query.origin.y-1.0 ) {\n\t\tsdfOceon(query, cameraDistanceRatio, oceanLod, time);\n\t}\n}\n\nrayHit RayMarch(inout rayMarch ray, float cameraDistance, int cameraSteps, in float time)\n{\n\trayQuery query;\n    float accumilatedRayDistance = 0.0;\n    int i = cameraSteps;\n    for(; i<RAY_MAX_STEPS; i++) {\n        float cameraDistanceRatio = (accumilatedRayDistance+cameraDistance)/RAY_MAX_DISTANCE;\n        //the more iterations the less precise we are, improve perfomance a bit with only mild artifacts\n        float modulatedMinSurfaceDistance=MIN_SURFACE_DISTANCE_MOD * cameraDistanceRatio + MIN_SURFACE_DISTANCE_BASE;\n        query.origin = ray.direction * accumilatedRayDistance + ray.origin;\n\n        //Boundig box to save some steps\n        if((query.origin.y<-1.0 && ray.direction.y < 0.0) ||  (query.origin.y> 4.0 && ray.direction.y > 0.0)){\n            accumilatedRayDistance = RAY_MAX_DISTANCE - cameraDistance;\n            query.materialId=MAT_SKY;\n            break;\n        }\n\n        QuerySdf(query, cameraDistanceRatio,time);\n        \n        #if defined (DEBUG_RAY_DITHER)\n        if(query.surfaceDistance > modulatedMinSurfaceDistance*2.0) {\n            //we take smaller steps closer to the camera, gives a better result.           \n            query.surfaceDistance *= 0.5+mix(cameraDistanceRatio,1.0, hash31(fract(query.origin+time)))*0.5;\n        }\n        #endif\n\n        accumilatedRayDistance += query.surfaceDistance;\n\n        if(accumilatedRayDistance+cameraDistance >= RAY_MAX_DISTANCE) {\n            accumilatedRayDistance = RAY_MAX_DISTANCE - cameraDistance;\n            query.materialId=MAT_SKY;\n            break;\n        }\n        else if(query.surfaceDistance >= 0.0 && query.surfaceDistance < modulatedMinSurfaceDistance) {\n            //else if(query.surfaceDistance < modulatedMinSurfaceDistance) { //forget bouncing back, if we end up inside just terminate\n            break;\n        }\n\n    }\n    \n    rayHit hit;\n    hit.origin = query.origin;\n    hit.surfaceDistance = query.surfaceDistance;\n\thit.materialId = query.materialId;\n    hit.rayOrigin = ray.origin;\n    hit.incidence = ray.direction;\n    hit.iteration = i;\n    hit.rayDistance = accumilatedRayDistance;\n    hit.rayDistanceRatio = clamp((hit.rayDistance/RAY_MAX_DISTANCE),0.0,1.0);\n    hit.cameraDistance = accumilatedRayDistance+cameraDistance;\n    hit.cameraDistanceRatio = clamp((hit.cameraDistance/RAY_MAX_DISTANCE),0.0,1.0);\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\nfloat getOcclusion(in vec3 origin, in vec3 normal, float cameraDistanceRatio, in float time) {\n    float occlusion = 0.0;\n    float scale = 0.1;\n    rayQuery query;\n    origin = origin + normal * (SHADOW_OFFSET_MOD  * cameraDistanceRatio + SHADOW_OFFSET_BASE);\n\t\n    for( float i=0.0; i<10.0; i++ )\n    {\n        float distance = 0.1*i;\n        query.origin = distance * normal + origin;\n        QuerySdf(query, cameraDistanceRatio,time);\n        occlusion += (distance-query.surfaceDistance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - occlusion, 0.0, 1.0 );\n}\n\nfloat getShadow(inout rayHit hit, in vec3 destination, float sharpness, in float time) {\n    float factor = 1.0;\n    rayQuery query;\n    \n    //Offset the origin slightly\n    vec3 origin = hit.normal * (hit.cameraDistanceRatio*SHADOW_OFFSET_MOD+SHADOW_OFFSET_BASE) + hit.origin;\n    vec3 direction = destination-origin;\n    float maxDistance = length(direction);\n    direction = direction/maxDistance; //Normalize it\n    \n    float accumilatedRayDistance = 0.0;\n    \n    for(int i=hit.iteration; i<RAY_MAX_STEPS; i++) {\n        \n        float cameraDistanceRatio = (accumilatedRayDistance+hit.cameraDistance)/RAY_MAX_DISTANCE;\n        //the more iterations the less precise we are, improve perfomance a bit with only mild artifacts\n        float modulatedMinSurfaceDistance=SHADOW_MIN_SURFACE_DISTANCE_MOD * cameraDistanceRatio + SHADOW_MIN_SURFACE_DISTANCE_BASE;\n        query.origin = direction * accumilatedRayDistance + origin;\n\n        //Boundig box to save some steps\n        if(query.origin.y<-1.0 || query.origin.y > 5.0 || abs(query.origin.z) > 5.0 || abs(query.origin.x) > 5.0){\n            break;\n        }\n\n        #if defined(DEBUG_SHADOW_IGNORE_OCEAN)\n            //Skip Ocean for shadow rays, doenst add much anyway.\n            query.materialId = MAT_SKY;\n            query.surfaceDistance = RAY_MAX_DISTANCE;\n            float oceanLod = getOceanLod(cameraDistanceRatio,true);        \n            sdfShapes(query, cameraDistanceRatio, oceanLod, time);\n        #else\n        \tQuerySdf(query, cameraDistanceRatio,time);\n        #endif\n        \n\t\taccumilatedRayDistance += query.surfaceDistance;\n\n        if(accumilatedRayDistance >= maxDistance) {\n            break;\n        } else if(query.surfaceDistance < modulatedMinSurfaceDistance) {\n            factor = 0.0;\n            break;\n        }\n        \n        //Soft Shadows!\n        factor = min(factor, sharpness * (query.surfaceDistance/accumilatedRayDistance));\n    }\n    return factor;\n}\n\nvoid getDirectionalLight(vec3 position, vec3 normal, vec3 incidence, vec3 lightDirection, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    diffuseBrightness = clamp(dotProd,0.0,1.0);\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, incidence);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    specularBrightness = dotProd;\n}\n\nvoid getLight(inout rayHit hit,in float time) {\n    float diffuseBrightness;\n    float specularBrightness;\n    vec3 specular,diffuse;\n\n    getDirectionalLight(hit.origin, hit.normal, hit.incidence, sunDir, hit.shininess, diffuseBrightness, specularBrightness);\n    specular = SUN_COLOUR * specularBrightness;\n    diffuse = SUN_COLOUR * diffuseBrightness;\n\n    #if defined(DEBUG_SHADOW)\n        if(hit.cameraDistanceRatio < SHADOW_LOD_DISTANCE2) {\n            hit.shadow = getShadow(hit, (sunDir * 10.0) + hit.origin, 10.0, time);\n            if(hit.cameraDistanceRatio > SHADOW_LOD_DISTANCE1) {\n                hit.shadow = map(hit.cameraDistanceRatio, SHADOW_LOD_DISTANCE1, SHADOW_LOD_DISTANCE2, hit.shadow, 1.0);\n            }        \n        } else {\n            hit.shadow=1.0;\n        }\n\n        hit.specular = specular*hit.shadow;\n        hit.diffuse = diffuse*hit.shadow;\n    #else\n        hit.specular = specular;\n        hit.diffuse = diffuse;\n        hit.shadow=1.0;\n    #endif\n\n    #if defined(AMBIENT_COLOUR)\n    hit.diffuse += AMBIENT_COLOUR;\t\n    #endif\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\nvoid calcNormal(inout rayHit hit, in float time )\n{\n    if(hit.materialId == MAT_SKY) {\n        return;        \n    }\n    if( hit.materialId == MAT_OCEAN) {\n        hit.normal = getOceanNormal(hit.origin.xz, hit.cameraDistanceRatio, time);\n        return;\n    } else {\n        rayQuery query;\n        // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n        vec3 n = vec3(0.0);\n        for( int i=ZERO; i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            query.origin=hit.origin+0.001*e;\n            QuerySdf(query, hit.cameraDistanceRatio,time);\n            n += e*query.surfaceDistance;\n        }\n        hit.normal = normalize(n);\n    }\n}\n\n// ==========  ==========\n\n// ========== Get colour for a ray hit ==========\n\n//New faster way to geneerate the height using vec math to reduce required instructions.\n// Clouds\nfloat getCloudNoise(vec2 position, float totalOctaves, float time) {\n    position+=vec2(1000,2000) + vec2(time)*vec2(0.05,0.1);\n\ttime=time*0.08;\n    \n    float maxHeight = 0.0;\n    float height = 0.0;\n    \n    for(float quadOctave = 0.0; quadOctave<totalOctaves; quadOctave+=4.0) {\n        vec4 octaves = vec4(0.0,1.0,2.0,3.0)+quadOctave;\n        //frequencies, PI2*0.03\n        vec4 fs = pow(vec4(1.095),octaves)*0.25;\n        //amplitudes\n        vec4 as = pow(vec4(0.9),octaves);\n \n        //Rotations\n        vec4 angles = (octaves*0.1)+hash44(octaves)*0.2;\n        vec4 cAngles = cos(angles), sAngles = sin(angles);\n        vec4 xs, ys;\n\n        for(int i;i<4;i++) {\n            position=position*mat2(cAngles[i],-sAngles[i], sAngles[i], cAngles[i]);\n            xs[i] = position.x;\n            ys[i] = position.y;\n        }\n\n        vec4 values = (sin(fs*xs+time)+sin(fs*ys));\n\n        //For runs where we dont want exactly multiple of 4 octaves.. to match the old output.\n        float octaivesRemaining = totalOctaves-quadOctave;\n        \n        if(octaivesRemaining<1.0) {\n            as*=vec4(fract(totalOctaves),0.0,0.0,0.0);\n        } else if(octaivesRemaining<2.0) {\n            as*=vec4(1.0,fract(totalOctaves),0.0,0.0);\n        } else if(octaivesRemaining<3.0) {\n            as*=vec4(1.0,1.0,fract(totalOctaves),0.0);\n        } else if(octaivesRemaining<4.0) {\n            as*=vec4(1.0,1.0,1.0,fract(totalOctaves));\n        }\n        \n        values *= as;\n        \n        height+=dot(values,vec4(1));\n        maxHeight+=dot(as,vec4(1));\n    }\n    return height/maxHeight;\n}\n\nvec4 getCloudsColour(vec3 direction, float sunDotProduct, float time) {\n    //Dont draw clouds very low on the horizon or ground.\n    if (direction.y<=0.04) {\n        return vec4(0.0);\n    }\n    vec2 samplePoint = direction.xz;\n    samplePoint *= (4000.0)/direction.y;\n    samplePoint *= 0.001;\n    \n    float occlusion = 0.0;\n    vec2 offsetDelta = (sunDir.xz * CLOUD_OCCLUSION_DISTANCE)/CLOUD_OCCLUSION_STEPS;\n    vec2 offset = vec2(0.0);\n    \n    //Simple LOD based on y direction. // limited to 0.04 above, 1.0/0.04 = 25.0 so dont need to clamp it\n    float t = 1.0/1.0-direction.y;\n    \n    //NOTE: the map values are backwards (1.0 to 0.0) to normal (0.0 to 1.0) because we flipped t to start with.\n\tfloat totalOctaves = map(t, 25.0, 0.0, CLOUD_LOD_MIN_OCTAVES , CLOUD_LOD_MAX_OCTAVES );\n     \n    float c1 = getCloudNoise(samplePoint, totalOctaves, time)*0.5+0.5;\n    \n    //return(vec4(vec3(sunDotProduct),1.0));\n    \n    if(c1 <= 0.5) {\n\t\treturn vec4(0.0);\n    }\n    \n    for( float i=CLOUD_OCCLUSION_SCALE; i>0.0; i-=(CLOUD_OCCLUSION_SCALE/CLOUD_OCCLUSION_STEPS) )\n    {\n        offset += offsetDelta;\n        offsetDelta *= 1.25;\n        float c2 = getCloudNoise(samplePoint+offset, totalOctaves, time)*0.5+0.5;\n        float d = (c1-c2) * c2;\n        occlusion += d*i;\n    }\n    //The inner map here, pushes the shadow down for clouds furhter away from the sun\n    occlusion = clamp(map(occlusion,0.0,1.0,clamp(map(sunDotProduct,0.0,1.0,0.7,-0.7),0.0,0.7),1.5),0.0,1.0);\n    float alpha = clamp(map(c1,0.5,1.0,0.0,2.0),0.0,1.0);\n\t//We fake back lighting based off the sub dot product, make the fringes brighter\n    occlusion = mix(occlusion,map(alpha,1.0,0.0,0.0,3.0),pow(sunDotProduct,5.0));\n    vec3 col=SUN_COLOUR*2.0*occlusion;\n    #if defined(AMBIENT_COLOUR)\n\t\tcol += AMBIENT_COLOUR;\n    #endif\n    return vec4(col,alpha);\n}\n    \nvec3 getSkybox(vec3 direction, float cameraDistanceRatio, float observerHeight, bool lowerWhite, bool upperSun, float time) {\n    vec3 skybox;\n    if (lowerWhite && upperSun) {\n        direction.y = abs(direction.y);\n    }\n    \n    float sunDotProduct=dot(direction,sunDir)*0.5+0.5;\n        \n    //ensure the skybox lower portion matches the OCEAN base colour with lighting etc.\n    if(direction.y<0.0) {\n        //Fog always has white on the lower side, just think it looks better\n        if (lowerWhite) {\n            #if defined(DEBUG_DISTANCE_FOG)\n            return HAZE_BASE_COLOUR;\n            #else \n            return OCEAN_REFLECTION_BASE;\n            #endif\n        } else {\n            direction.y = abs(direction.y);\n            skybox = OCEAN_REFLECTION_BASE;\n\n            #if defined(DEBUG_LIGHTING)\n            vec3 defuse = SUN_COLOUR * dot(sunDir,vec3(0.0,1.0,0.0));\n                #if defined(AMBIENT_COLOUR)\n                defuse += AMBIENT_COLOUR;\n                #endif\n            skybox*=defuse;\n            #endif\n\n            #if defined(DEBUG_DISTANCE_FOG)\n\t\t\tfloat haze = clamp(observerHeight/direction.y,0.0, RAY_MAX_DISTANCE)/RAY_MAX_DISTANCE;\n            skybox = mix(skybox,HAZE_BASE_COLOUR,haze);\n            \n            //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,4.0)));\n            #endif\n            return skybox;\n        }\n    } else {\n\t\tskybox=SKY_BASE_COLOUR;\n        skybox=mix(skybox,SKY_UPPER_COLOUR,smoothstep(0.0,1.0,direction.y));\n        \n        //Fog layer doesnt have the sun spot, jsut looks weird\n        if(upperSun) {\n            //Add Sun and Halo\n            skybox += SUN_COLOUR*((pow(sunDotProduct,1000.0)*20.0)+pow(sunDotProduct,10.0));\n            #if defined(DEBUG_CLOUDS)\n                vec4 clouds = getCloudsColour(direction, sunDotProduct, time);\n                skybox = mix(skybox, clouds.xyz, clamp(clouds.w,0.0,1.0));\n            #endif\n\t\t}\n        //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,20.0)));\n        skybox=mix(skybox,HAZE_BASE_COLOUR,pow(1.0-direction.y,20.0));\n        return skybox;\n    }\n}    \n\nvoid applyDistanceFog(inout vec3 colour, inout rayHit hit) {\n    if(hit.materialId==MAT_SKY) {\n        return;\n    }\n    colour = mix(colour, getSkybox(hit.incidence, hit.cameraDistanceRatio, hit.rayOrigin.y, true, false, 0.0), pow(hit.rayDistanceRatio,3.0));\n}\n\nvec3 getReflectedSkyBox(inout rayHit hit, float time) {\n    vec3 reflectDirection = reflect(hit.incidence, hit.normal);\n    return getSkybox(reflectDirection, hit.cameraDistanceRatio, hit.origin.y, hit.materialId == MAT_OCEAN, true, time);\n}\n\nvec3 fakeReflection(inout rayHit hit, float time) {\n    if (hit.reflectivity <= 0.0) {\n        return hit.albedo*hit.diffuse*hit.occlusion;\n    } else {\n        vec3 reflectDirection = reflect(hit.incidence, hit.normal);\n        vec3 r = getSkybox(reflectDirection, hit.cameraDistanceRatio, hit.origin.y, hit.materialId == MAT_OCEAN, true, time);\n        //r=mix(r,HAZE_BASE_COLOUR,hit.cameraDistanceRatio);\n        //r=mix(r,SKY_BASE_COLOUR,hit.cameraDistanceRatio);\n        //r=mix(r,Black,hit.cameraDistanceRatio);\n        //hit.reflectivity *= 1.0-hit.cameraDistanceRatio;\n        if(hit.reflectivity >= 1.0) {\n            return r;\n        } else {\n            return mix(hit.albedo*hit.diffuse*hit.occlusion, r, hit.reflectivity );\n        }\n        \n    }\n}\n\nvoid renderRay(inout rayHit hit, in float time) {\n\n    if(hit.materialId == MAT_SKY) {\n        //hit.albedo = getSkybox(hit.incidence, hit.rayOrigin.y);\n        hit.albedo = getSkybox(hit.incidence, hit.cameraDistanceRatio, hit.rayOrigin.y, false, true, time);\n        hit.diffuse = White;\n        hit.occlusion=1.0;\n        hit.reflectivity = 0.0;\n        return;\n    }\n    \n    calcNormal( hit, time );\n\n    switch (hit.materialId) {\n\t\tcase MAT_OCEAN:\n        hit.reflectivity = 1.0;\n        hit.albedo=mix(OCEAN_BASE,OCEAN_TINT,hit.origin.y*0.5+0.5)*0.5;\n        hit.shininess = 50.0;\n        break;\n\t\tcase MAT_CHROME:\n        hit.reflectivity = 1.0;\n        hit.albedo=White;\n        hit.shininess = 0.0;\n        hit.diffuse = White;\n        hit.specular = Black;\n        hit.shadow = 1.0;\n        break;\n        case MAT_YELLOW:\n        hit.reflectivity = 0.5;\n        hit.albedo=Yellow;\n        hit.shininess = 2.0;\n        break;\n        case MAT_BLACK:\n        hit.reflectivity = 0.0;\n        hit.albedo=Black;\n        hit.shininess = 10.0;\n        break;\n\t\tcase MAT_WHITE:\n        hit.reflectivity = 0.5;\n        hit.albedo=White;\n        hit.shininess = 20.0;\n        break;\n    }\n\n    #if defined(DEBUG_REFLECTION_FRESNEL)\n        if (hit.materialId != MAT_CHROME) {\n            hit.reflectivity = pow(clamp(1.0 - dot(hit.normal,-hit.incidence), 0.0, 1.0),3.0) * hit.reflectivity;\n        }\n    #else\n    \thit.reflectivity *= 0.2;\n    #endif\n    \n    #if defined(DEBUG_OCCLUSION)\n        if(hit.cameraDistanceRatio < OCCLUSION_LOD_DISTANCE2) {\n            hit.occlusion=getOcclusion(hit.origin, hit.normal, hit.cameraDistanceRatio, time);\n            if(hit.cameraDistanceRatio > OCCLUSION_LOD_DISTANCE1) {\n                hit.occlusion = map(hit.cameraDistanceRatio, OCCLUSION_LOD_DISTANCE1, OCCLUSION_LOD_DISTANCE2, hit.occlusion, 1.0);\n            }\n        } else {\n            hit.occlusion=1.0;\n        }\n    #else\n    \thit.occlusion=1.0;\n    #endif\n\n    #if defined(DEBUG_LIGHTING)\n\tif (hit.materialId != MAT_CHROME) {\n\t\tgetLight(hit, time);\n\t}\n    #else\n    \thit.diffuse = White;\n    \thit.specular = Black;\n    #endif\n}\n\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvec3 applySkyboxLodFade(vec3 fromColour, inout rayHit hit, float time) {\n    if(hit.cameraDistanceRatio <= OCEAN_LOD_REFLECTION_DISTANCE1) {\n        return fromColour;\n    } else {\n        vec3 toColour = getReflectedSkyBox(hit, time);\n        if(hit.cameraDistanceRatio >= OCEAN_LOD_REFLECTION_DISTANCE2) {\n            return toColour;\n        } else {\n            return mix(fromColour,toColour,map(hit.cameraDistanceRatio, OCEAN_LOD_REFLECTION_DISTANCE1, OCEAN_LOD_REFLECTION_DISTANCE2, 0.0, 1.0));\n        }    \n    }\n}\n\nvec3 realRenderRay(inout rayMarch ray, float time) {\n    vec3 colour;\n    \n    rayHit mainHit = RayMarch(ray, 0.0, 0, time);\n    renderRay(mainHit, time);\n\n    // ---- Render\n\n    #if defined(DEBUG_MAX_REFLECTIONS) && DEBUG_MAX_REFLECTIONS > 0\n    if(mainHit.cameraDistanceRatio >= OCEAN_LOD_REFLECTION_DISTANCE2 ) {\n        colour = fakeReflection(mainHit, time);\n    } else {\n        //requires a real reflection!\n        rayHit[DEBUG_MAX_REFLECTIONS] reflectionHits;\n        int reflectionCount;\n\n        float accumaltedReflection = mainHit.reflectivity;\n\n        rayHit previusHit = mainHit;\n        reflectionCount=0;\n        while(reflectionCount<DEBUG_MAX_REFLECTIONS) {\n            //break out when we dont need a real reflection or there is no reflection\n            if(accumaltedReflection <= 0.00) {\n                break;\n            }\n            rayMarch ray = getRefRay(previusHit);\n            rayHit hit = RayMarch(ray, previusHit.cameraDistance, previusHit.iteration, time);\n            renderRay(hit, time);\n            accumaltedReflection*=hit.reflectivity;\n            previusHit = hit;\n            reflectionHits[reflectionCount] = hit;\n            reflectionCount++;\n            if(hit.cameraDistanceRatio > OCEAN_LOD_REFLECTION_DISTANCE2) {\n                break;\n            }\n        }\n\n        reflectionCount--;\n\n        vec3 tColour;\n        vec3 hColour;\n\n        if (reflectionCount < -1) {\n            colour=Green;\n        } else if (reflectionCount == -1) {\n            colour = fakeReflection(mainHit, time);\n        } else {\n            previusHit = reflectionHits[reflectionCount];\n            hColour = fakeReflection(previusHit, time);\n            hColour += previusHit.specular;\n\n            #if defined(DEBUG_DISTANCE_FOG)\n            applyDistanceFog(hColour, previusHit);\n            #endif\n\n            reflectionCount--;\n            for(;reflectionCount>=0;reflectionCount--) {\n                previusHit = reflectionHits[reflectionCount];\n                hColour = applySkyboxLodFade(hColour, previusHit, time);\n\n                hColour = mix(previusHit.albedo*previusHit.diffuse, hColour, previusHit.reflectivity);\n                hColour+=previusHit.specular;\n                #if defined(DEBUG_DISTANCE_FOG)\n                applyDistanceFog(hColour, previusHit);\n                #endif\n            }\n            hColour = applySkyboxLodFade(hColour, mainHit, time);\n            colour = mix(mainHit.albedo*mainHit.diffuse*mainHit.occlusion, hColour, mainHit.reflectivity);\n        }\n    }\n    #else\n    colour = fakeReflection(mainHit, time);\n    #endif\n\n    colour+=mainHit.specular;\n\n    #if defined(DEBUG_DISTANCE_FOG)\n    applyDistanceFog(colour, mainHit);\n    #endif\n    \n    return colour;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n/*    \n    #if defined(DEBUG_MULTISAMPLE)\n    \tvec2 uv;\n    \tvec3 colour;\n    \trayMarch mainRay;\n    \n    \t// Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    \tuv = ((fragCoord-0.5*iResolution.xy)-0.25)/iResolution.y;\n    \tmainRay = getRay(uv, camera);\n    \tcolour += realRenderRay(mainRay, time);\n    \n        uv = ((fragCoord-0.5*iResolution.xy)+0.25)/iResolution.y;\n    \tmainRay = getRay(uv, camera);\n    \tcolour += realRenderRay(mainRay, time);\n    \n\t\tuv = ((fragCoord-0.5*iResolution.xy)-vec2(-0.25,0.25))/iResolution.y;\n    \tmainRay = getRay(uv, camera);\n    \tcolour += realRenderRay(mainRay, time);\n    \n    \tuv = ((fragCoord-0.5*iResolution.xy)-vec2(0.25,-0.25))/iResolution.y;\n    \tmainRay = getRay(uv, camera);\n    \tcolour += realRenderRay(mainRay, time);\n    \n    \tcolour*=0.25;\n    #else\n        // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    \tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \trayMarch mainRay = getRay(uv, camera);\n    \tvec3 colour = realRenderRay(mainRay, time);\n    #endif\n*/\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    rayMarch mainRay = getRay(uv, camera);\n    vec3 colour = realRenderRay(mainRay, time);\n    \n    \n    // ---- Lense Flare\n    #if defined(DEBUG_SUN_RAYS_RENDER)\n    float sunDot = dot(camera.forward, sunDir);\n    if (sunDot > 0.0) {\n        //Project the sun to the screen to get its UV position\n        mat3 invMat = rotateY(-camera.yaw) * rotateX(-camera.pitch) * rotateZ(-camera.roll);\n        vec3 sunProjection = (sunDir*invMat);\n        vec2 sunUv = sunProjection.xy/sunProjection.z*camera.zoom;\n        colour += getLensFlare(uv, sunUv)*5.0;\n    }\n    #endif\n\n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n    colour = clamp(colour,0.0,1.0); \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    #if defined(DEBUG_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*10.0,0.2)+0.4,0.0,1.0);\n    colour=1.0-((1.0-colour)/vignette);\n    #endif\n\n    fragColour = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}