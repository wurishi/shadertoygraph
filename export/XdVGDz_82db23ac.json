{"ver":"0.1","info":{"id":"XdVGDz","date":"1454038730","viewed":1413,"name":"Gradient Dial","username":"TheGrego","description":"Growing gradient circle. Perfect for progress bars and countdown timers.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["circle","gradient","progress","dial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// static values\nconst float PI=3.14159265358979323846;\nconst float TAU = 6.28318530717958647692;\nconst float STEP_LENGTH = 0.01;\nconst float ANGLE_OFFSET = PI*0.5;\t\t\t\t// angle of dial\nconst vec4 color1 = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 color2 = vec4(1.0, 1.0, 0.0, 1.0);\nconst float duration = 3.0;\t\t\t\t\t\t// duration of dial\n\n\n// Get the color value based on where in the circle the uv is\nvec4 getGradientValue(in vec2 uv)\n{\n    vec2 dist =\tvec2(1.0, 0.0) - vec2(-1.0, 0.0);\n\tfloat val = dot( uv - vec2(-1,0), dist ) / dot( dist, dist );\n\tclamp( val, 0.0, 1.0 );\n    \n\tvec4 color = mix( color1, color2, val );\n\t// clamp depending on higher alpha value\n\tif( color1.a >= color2.a )\n\t\tcolor.a = clamp( color.a, color2.a, color1.a );\n\telse\n\t\tcolor.a = clamp( color.a, color1.a, color2.a );\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, duration) / duration;\n    float innerRadius = 0.5;\n    float outerRadius = 0.65;\n    float startAngle = 0.0;\n    float endAngle = progress* TAU;\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    float d = length( uv );\n    vec4 ioColor = getGradientValue(uv);    \n\n    // Perform adaptive anti-aliasing.\n    float w = fwidth( d ) * 1.0;\n    float c = smoothstep( outerRadius + w, outerRadius - w, d );\n    c -= smoothstep( innerRadius + w, innerRadius - w, d );\n    \n    // set color for the area within inner and outer radius\n    fragColor = vec4(ioColor.rgb * vec3(c), 1.0);\n\t\n    // limit to active progress\n    float angle = (atan(uv.y,uv.x)) + ANGLE_OFFSET;\n\tif( angle < 0.0 ) angle += PI * 2.0;\n    if( angle > endAngle){\n        float a = smoothstep( 0.75, -w*2.0,  abs(endAngle - angle) );        \n        //float a = smoothstep( 0.0, -w*2.0,  abs(endAngle - angle) );        \n        fragColor *= a;\n    }\n    if(angle - w*2.0 < startAngle ){\n        float a = smoothstep(  -w*2.0, w*2.0, (abs(startAngle - angle)) );\n        fragColor *= a;    \n    }\n    \n    /*\n    // round butt stuff\n\tfloat lineWidth = (outerRadius - innerRadius) * 0.5;\n    float midRadius = innerRadius + lineWidth;\n    \n   \t// distance from pt at end angle\n    vec2 endAnglePos = vec2( cos(endAngle-ANGLE_OFFSET), sin(endAngle-ANGLE_OFFSET)) * vec2(midRadius);\n    float dist = length( uv - endAnglePos );\n    float buttAlpha = smoothstep( lineWidth + w, lineWidth - w, dist );\n    fragColor = mix(fragColor, ioColor, buttAlpha );\n\n    // distance from pt at start angle\n    vec2 startAnglePos = vec2( cos(startAngle-ANGLE_OFFSET), sin(startAngle-ANGLE_OFFSET)) * vec2(midRadius);\n    dist = length( uv - startAnglePos );\n    buttAlpha = smoothstep( lineWidth + w, lineWidth - w, dist );\n    fragColor = mix(fragColor, ioColor, buttAlpha );\n\t*/\n}","name":"Image","description":"","type":"image"}]}