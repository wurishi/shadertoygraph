{"ver":"0.1","info":{"id":"ssccRs","date":"1653921177","viewed":141,"name":"DMT","username":"bblob289","description":"DMT","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CELL_SIZE 0.3\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec2 getCenter(vec2 idx, vec2 offset, float time) {\n    idx -= offset;\n    float ampl = CELL_SIZE/2. - 0.05;\n    vec2 timeCoeffs = vec2(noise(idx),noise(noise(idx)));\n    timeCoeffs = timeCoeffs / 2. + 0.25;\n    timeCoeffs *= 5.;\n    \n    vec2 center = vec2(sin(time*timeCoeffs.y + timeCoeffs.x)*ampl,\n                       sin(time*timeCoeffs.x + timeCoeffs.y)*ampl);\n    return center - offset * CELL_SIZE;\n}\n\nvec2 getCenter(vec2 idx, float time) { return getCenter(idx, vec2(0), time); }\n\nfloat lineDist(vec2 a, vec2 b, vec2 p) {\n    vec2 g = b - a;\n    vec2 h = p - a;\n    return length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n}\n\nvec3 frame(vec2 uv, float time) {\n    vec3 col = vec3(0.);\n    \n    vec2 cellUv = mod(uv, CELL_SIZE) - CELL_SIZE/2.;\n    vec2 idx = floor(uv / CELL_SIZE);\n    \n    vec2 a = getCenter(idx, time);\n    float d = CELL_SIZE;\n    float lineLen = -1.;\n    \n    vec2[] directions = vec2[](vec2(-1,0),vec2(0,1),vec2(1,0),vec2(0,-1));\n    \n    for (int i = 0; i < directions.length(); i++) {\n        vec2 b = getCenter(idx, directions[i], time);\n        float dd = lineDist(a, b, cellUv);\n        if (dd < d) {\n            lineLen = length(a-b);\n            d = dd;\n        }\n    }\n    \n    vec3 line = clamp(vec3(smoothstep(0.01,0.005,d)) * (vec3(1)-(lineLen / CELL_SIZE *.7)),0.,1.);\n    line *= vec3(1,1,0);\n    vec3 point = vec3(smoothstep(0.02,0.01,length(a-cellUv)));\n    \n    return point + line;\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float m = 4.;\n    \n    for (float i = 0.; i < 4.; i++) {\n        float scale = mod(i - iTime, m);\n        vec3 f = frame(uv * rot(i + iTime / 5.) * scale, iTime + i);\n        col += f * smoothstep(m, m-2., scale);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}