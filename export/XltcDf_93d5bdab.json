{"ver":"0.1","info":{"id":"XltcDf","date":"1534471100","viewed":191,"name":"RayMarching&SDFs","username":"ycheng14799","description":"Short demo-scene created following Jamie Wong's \"Ray Marching and Signed Distance Functions\" tutorial. \n\nSources: \n\"Ray Marching and Signed Distance Functions\" tutorial by Jamie Wong\n\"Modeling with Distance Functions\" page by Inigo Quilez","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdfs","jamiewongtutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define maximum marching steps \nconst int maxMarchSteps = 255;\n// Define minimum distance \nconst float minDist = 0.0;\n// Define maximum distance \nconst float maxDist = 100.0;\nconst float epsilon = 0.0001; \n\n// Sphere SDF \nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n// Cube SDF \nfloat ubox(vec3 samplePoint) {\n    return length(max(abs(samplePoint) - vec3(1.0, 1.0, 1.0), 0.0));\n}\n\n// Constructuve solid geometry functions \n// For intersections \nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n// For unions \nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// Rotation transformation \n// About y-axis\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n// About x-axis  \nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n// About z-axis \nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, s, 1, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    // Rotate entire scene \n    samplePoint = (rotateY(iTime / 2.0) * vec4(samplePoint, 1.0)).xyz;\n    // Box distortions \n    float boxX = 0.2;\n    float boxY = 1.5;\n    float boxZ = 1.5; \n    vec3 wallPoint = (rotateX(iTime) * vec4(samplePoint, 1.0)).xyz;\n    float sphereShapeChange = 0.5 * sin(2.0 * iTime) + 0.5;\n    float sphere = sphereSDF(samplePoint / sphereShapeChange) * sphereShapeChange;\n    float wall = ubox(wallPoint / vec3(boxX, boxY, boxZ)) * min(boxX, min(boxY, boxZ));\n\tfloat hole = differenceSDF(wall, sphere);\n    float ball = sphereSDF((samplePoint + vec3(2.0 * sin(iTime - 3.14 / 4.0), 0.0, 0.0))/ 0.5) * 0.5;\n    return unionSDF(hole, ball);\n\t//return hole;\n}\n\n// Ray marching function to find\n// shortest distance from eyepoint to scene surface \n// follow marching direction \n// eye: Origin of ray, eye point \n// marchDirection: normalized direction to march in \n// start: Starting distance away from eye\n// End: Max distance from eye to march \nfloat rayMarch(vec3 eye, vec3 marchingDirection, \n               float start, float end) {\n\t// Define starting depth \n    float depth = start;\n    // March until maxMarchSteps is reached\n    for (int i = 0; i < maxMarchSteps; i++) {\n        // Obtain distance from closest surface \n        float dist = sceneSDF(eye + depth *\n                              marchingDirection);\n        // Determine if marched inside surface\n        if (dist < epsilon) {\n            // Inside scene surface\n            return depth; \n        }\n        // Update depth \n        depth += dist;\n        // Determine if marched too far \n        if (depth >= end) {\n            // Return farthest allowable\n            return end;\n        }\n    }\n    // Return distance if marched more than max steps\n    return end;\n}\n\n// Return normalized direction to march in from eye\n// fov: vertical field of view in degrees \n// size: resolution of output image\n// fragCoord: x, y coordinates of pixel in output \nvec3 rayDirection(float fov, vec2 size, vec2 fragCoords) {\n    // Center coordinate system \n    // Define x and y coordinates \n    vec2 xy = fragCoords - size / 2.0;\n    // Find z\n    float z = size.y / tan(radians(fov) / 2.0);\n    // Return normalized direction to march \n    return normalize(vec3(xy, -z));\n}\n\n// Esimate normal on surface \nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + epsilon, p.y, p.z)) - sceneSDF(vec3(p.x - epsilon, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + epsilon, p.z)) - sceneSDF(vec3(p.x, p.y - epsilon, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + epsilon)) - sceneSDF(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\n// Calculate lighting contribution of single point light source\n// Return: RGB color of light's contribution \n// k_a: Ambient color \n// k_d: Diffuse color \n// k_s: Specular color \n// alpha: Shininess coefficient \n// p: Position of point being lit \n// eye: Position of camera \n// lightPos: Position of light \n// lightIntensity: color / intensity of light \nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha,\n                          vec3 p, vec3 eye, vec3 lightPos,\n                          vec3 lightIntensity) {\n    // Get normal vector at position p \n    vec3 N = estimateNormal(p);\n    // Get direction of light to position p\n    vec3 L = normalize(lightPos - p);\n    // Get direction of camera to position p\n    vec3 V = normalize(eye - p);\n    // Get direction of reflection \n    vec3 R = normalize(reflect(-L, N));\n    \n    // Obtain dot product between light and normal \n    float dotLN = dot(L, N);\n    // Obtain dot product between reflection and view ray \n    float dotRV = dot(R, V);\n    \n    // Light not visible from this point on surface\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    // Determine if light reflection is viewable \n    // from viewer\n    if (dotRV < 0.0) {\n        // If light reflection is opposite direction of viewer\n        // Apply only diffuse lighting \n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    // Return phong lighting contribution \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// Phong illumination \n// Return RGB color of point after lighting contribution \n// k_a: Ambient color \n// k_d: Diffuse color \n// k_s: Specular color\n// alpha: Shininess coefficient \n// p: Position of point being lit \n// eye: Position of camera \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n\t// Define ambient light intensity \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    // Calculate color from ambient light \n    vec3 color = ambientLight * k_a;\n    \n    // Define light 1 \n    vec3 light1Pos = vec3(4.0 * sin(iTime), \n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, \n                                  eye, light1Pos,\n                                  light1Intensity);\n    \n    // Define light 2 \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime), \n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    float light2IntensityComp = 0.5*sin(iTime)+0.5; \n    vec3 light2Intensity = vec3(light2IntensityComp,\n                                light2IntensityComp,\n                               \tlight2IntensityComp);\n    color += phongContribForLight(k_d, k_s, alpha, p,\n                                  eye, light2Pos,\n                                  light2Intensity);\n    return color;\n}\n\n// Return transformation matrix that will transform a \n// ray from view space to world coordinates \n// given a eye point, a camera target, and a up vector\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Define direction from camera to target \n    vec3 f = normalize(center - eye);\n    // Define right vector \n    vec3 s = normalize(cross(f, up));\n    // Define new up for camera \n    vec3 u = cross(s, f);\n    // Return transformation matrix \n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n    \n\n// Main \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Obtain view direction\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    // Define camera position \n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    // Obtain transformation matrix \n    // Point camera at target \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    // Apply transformation \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    // Obtain SDF with eye \n    float dist = rayMarch(eye, worldDir, minDist, maxDist);\n    \n    // Set background as black\n    // if ray did not intersect a surface \n    if (dist > maxDist - epsilon) {\n        \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        \treturn;\n    }\n    \n    // Apply lighting \n    // Find closest point on surface to eyepoint\n    // along view ray \n    vec3 p = eye + dist * worldDir; \n    // Define ambient light color \n    // Defined based on normal estimates \n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    // Define diffuse light color \n    vec3 K_d = K_a;\n    // Defien specular light color \n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    // Set object shininess \n    float shininess = 10.0;\n    // Obtain color \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    // Set fragment color \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}