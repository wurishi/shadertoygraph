{"ver":"0.1","info":{"id":"3lj3zc","date":"1560627631","viewed":158,"name":"Nibbler","username":"procra","description":"Ouais.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["snake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat index = 6.;\n\nvec4 color(int r, int g, int b, int a)\n{\n\treturn (vec4(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0, float(a) / 255.0));\n}\n\n\nvec4 bg(vec2 fragCoord)\n{\n\tvec4 firstCol = color(0x16, 0x18, 0x1e, 0xff);\n\tvec4 secondCol = color(0x22, 0x28, 0x3a, 0xff);\n\tvec4 thirdCol = color(0x08, 0x09, 0x0B, 0xff);\n\n\tvec2 pos = (fragCoord.xy) / iResolution.xy;\n\tvec2 tex;\n\n\tvec2 fromCenter = vec2(abs(pos.x - 0.5), abs(pos.y - 0.5));\n\tfloat stripe;\n\tfloat fromBorder = max(fromCenter.x, fromCenter.y);\n\n\tif (fromCenter.x > fromCenter.y)\n\t{\n\t\tstripe = mod(fromCenter.x + (1. - iTime * 4.) * .05, .05);\n\t}\n\telse\n\t{\n\t\tstripe = mod(fromCenter.y + (1. - iTime * 4.) * .05, .05);\n\t}\n\n\tvec4 fcolor;\n\n\tif (stripe > .025)\n\t\tfcolor = firstCol;\n\telse\n\t\tfcolor = secondCol;\n\n\treturn mix(fcolor, thirdCol, min(1., 1. - fromBorder * 2. + 0.1));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 scolor(float c)\n{\n\treturn (vec4(pal(c, vec3(0.6,0.6,0.8),vec3(0.6,0.6,0.8),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67)), 1.0));\n}\n\nvec2 resolution = vec2(50., 50.);\n\nvec4 star(vec2 fragCoord, vec2 coord)\n{\n    float branches = mod((-iTime), 7.);\n\n\tfloat\tPI = 3.14159265358979323846264;\n\tfloat\tradius = 0.42;\n\tfloat\ta = cos(iTime * PI * 2.f) * 0.5;\t\t\t// Rotation angle\n\tvec2\tpos = (fragCoord.xy - coord) / resolution.xy;\t// Point from center\n\tpos *= mat2(cos(a), -sin(a), sin(a), cos(a));\t// Rotation\n\tfloat\ttruc = atan(pos.x / pos.y) * branches;\t// Position on circle\n\tif (pos.y < 0.)\n\t\ttruc += mod(branches, 2.0) * PI;\t\t\t// Symmetry\n\tfloat\tdst = length(pos);\n\tif (branches > 1.f)\n\t\tdst *=  (cos(truc) + 3. ) / 2.;\t// Curved distance\n\telse\n\t{\n\t\tdst *= 1.3;\n\t\tdst += (cos(iTime * PI * 20.) - 1.) * 0.1;\n\t}\n\tfloat\tcol = 1. - pow(abs(dst - radius) * 10., 2.);\t// Glow factor\n\tfloat\tbright;\n\tif (branches > 1.f)\n\t\tbright = sin(fract(branches) * PI);\n\telse\n\t\tbright = (cos(iTime * PI * 20.) + 1.) * 0.5;\n\n\tvec4 color = color(0xff, 0xa8, 0xf7, 0xff) +\n\t\tcolor(0x5f, 0x5f, 0x5f, 0xff) * bright;\n\tcolor = color * (col + pow(bright, 3.) * 0.5);\n    color = vec4(max(0., color.r), max(0., color.g), max(0., color.b), max(0., color.a));\n    return color;\n}\n\nvec4 egg(vec2 fragCoord, vec2 coord)\n{\n    float\tradius = 0.8;\t// circle radius\n\tfloat\tminiRadius = 0.40;\t// mini circles radius\n\tvec4\ttheColor = color(0xff, 0xed, 0x81, 0xff);\n\tfloat\tPI = 3.14159265358979323846264;\n\tvec2\trealPos = (fragCoord.xy - coord) / resolution * 2.;\t// normalized position from center\n\tfloat\trealL = length(realPos);\n\tfloat\ta = 2.0;\t// rotation angle\n\tvec2\tuv = vec2(0.5 + asin(realPos.x / radius) / PI,\t// sphere texture coords\n\t\t\t\t\t  0.5 + asin(realPos.y / radius) / PI);\n\tvec2\tpos = uv;\n\tpos *= mat2(cos(a), -sin(a), sin(a), cos(a));\t// rotation\n\tpos += vec2(sin(iTime * PI * 2.), cos(iTime * PI * 2.)) * 0.1;\t\t// movement\n\tpos *= 4.;\t// scale\n\tfloat t = floor(mod(pos.x, 2.)) * 2. + floor(mod(pos.y, 2.)) * 2.; // mini circle position factor\n\tpos.x = mod(pos.x, 1.);\t// lil' circles\n\tpos.y = mod(pos.y, 1.);\t// bis\n\tvec2 fromCenter = pos - vec2(0.5, 0.5);\t// normalized position from center\n\tfloat\ttst = length(fromCenter);\t\t// distance from center\n\tfloat\tcol = pow(abs(tst - miniRadius) * 7., 2.);\t// glow\n\tcol *= cos(iTime * 4. * PI + t) * 0.3 + 0.5;\t// time glow factor\n\tcol = 1. - col;\n\tfloat\tcircle = pow(abs(realL - radius) * 7., 2.);\t// glow\n\tcircle *= cos(iTime * 4. * PI) * 0.4 + 0.7;\t// time factor\n\tcircle = 1. - circle;\n\tcircle = min(1., max(0., circle));\n\n    vec4 ret;\n    \n\tif (realL < radius)\t// circle interior\n\t\tret = theColor * min(1., col + 0.04 / (radius - realL) * circle);\n\telse\t\t\t\t// circle exterior\n\t\tret = theColor * circle;\n    ret = vec4(max(0., ret.r), max(0., ret.g), max(0., ret.b), max(0., ret.a));\n    return ret;\n}\n\nvec4 orange(vec2 fragCoord, vec2 coord)\n{\n\tfloat\tradius = 0.42;\n\tfloat\tPI = 3.14159265358979323846264;\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\n\tfloat\tcol = 0.;\n\tfloat\tcolCoef = 0.;\n\n\tvec4 col1 = color(0xff, 0xed, 0x81, 0xff);\n\tvec4 col2 = color(0xff, 0x20, 0x10, 0xff);\n\tvec4 ret = color(0, 0, 0, 0);\n\n\tint circles = 6;\n\tfor (int i = 0; i < circles; i++)\n\t{\n\t\tvec2 pos2 = pos;\n\t\tfloat circle_time = pow(1. - mod(iTime + float(i) * (1. / float(circles)), 1.), 1.5) * 1.5 * PI;\n\t\tpos2.x += sign(pos.x) * sqrt(radius * radius - pos.y * pos.y) * ((cos(circle_time) + 1.) / 2.);\n\t\tfloat tst = length(pos2);\n\t\tcol = max((1. - pow(abs(tst - radius) * 15., 2.) * (cos(iTime * 4. * PI) + 2.)) / 1., 0.);\n\t\tcolCoef = (1. - mod(iTime + float(i) * (1. / float(circles)), 1.)) * col;\n\t\tret += (1. - ret.a) * mix(col2, col1, colCoef) * col;\n\t}\n    return ret;\n}\n\n\nvec4 cut(vec2 fragCoord, vec2 coord)\n{\n\tfloat debug = iTime;\n\n\tfloat\tPI = 3.14159265358979323846264;\n\tfloat\tseg = 4.;\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\t// Point from center\n    \n    if (abs(pos.x) > 0.5 || abs(pos.y) > 0.5)\n\t\treturn vec4(0);\n\n    pos = vec2(0.5, 0.5) + pos;\n\tpos = mod(pos, vec2(0.5, 0.5));\n\tpos -= vec2(0.25, 0.25);\n\n\tfloat\td = 0.;\n\n\tfor (float i = 1.; i <= seg; i++)\t// Computes distance from each segment\n\t{\n\t\tvec2\tgridPos = (fragCoord.xy - coord) / resolution;\n\t\tgridPos = floor(gridPos * 2.);\n\t\tfloat\tradius = 0.22;\n\t\tfloat\ttimeMod;\n\t\tif (gridPos.x == -1.)\n\t\t\ttimeMod = mod(iTime + 0.25 * (gridPos.x * 2. - gridPos.y - 1.), 1.);\n\t\telse if (gridPos.x == 0.)\n\t\t\ttimeMod = mod(iTime + 0.25 * (gridPos.x * 2. + gridPos.y), 1.);\n\t\tfloat\ta0 = 0.; // Square rotation angle\n\t\tif (timeMod < 0.5)\n\t\t{\n\t\t\tradius *= 1. - timeMod * 4.;\n\t\t\ta0 = cos (timeMod * 4. * 4.);\n\t\t}\n\t\tfloat\tsize = radius * sin(PI / seg);\t// segment size / 2\n\t\tfloat\tapot = radius * cos(PI / seg);\t// segment distance from center\n\t\tvec2\tp = pos * mat2(cos(a0), -sin(a0), sin(a0), cos(a0)); // Rotation\n\t\tfloat\ta = i / seg * (2. * PI);\n\t\tp *= mat2(cos(a), -sin(a), sin(a), cos(a));\t// Put segment horizontaly\n\t\tfloat\tdst = 0.;\n\n\t\tif (p.x > -size && p.x < size)\n\t\t{\n\t\t\tdst = abs(apot - p.y);\n\t\t}\n\t\telse if (p.x <= -size)\n\t\t{\n\t\t\tdst = length(vec2(-size, apot) - p);\n\t\t}\n\t\telse if (p.x >= size)\n\t\t{\n\t\t\tdst = length(vec2(size, apot) - p);\n\t\t}\n\t\tif (d == 0. && dst != 0.)\n\t\t\td = dst;\n\t\telse if (dst != 0.)\n\t\t\td = min(d, dst);\n\t}\n\n\tvec4 snakeCol = scolor( mod(0.3 + index * 0.3, 1.0) );\n\n\tfloat\tcol = 1. - pow(abs(d) * 15., 2.);\t// Glow factor\n\n\treturn snakeCol * col;\n}\n\n\nvec4 triangle(vec2 fragCoord, vec2 coord)\n{\n    float ssize = 0.5;\n    float rot = mod(iTime, 2.);\n\tfloat\ttest = iTime;\n\tfloat\tPI = 3.14159265358979323846264;\n\tfloat\tradius = ssize;\n\tfloat\tseg = 3.;\n\tfloat\tsize = radius * sin(PI / seg);\t// segment size / 2\n\tfloat\tapot = radius * cos(PI / seg);\t// segment distance from center\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\t// Point from center\n\n\tfloat\td = 0.;\n\n\tfloat\ta = pow(1. - rot, 3.) * PI * 2. / seg * 7.;\n\tpos *= mat2(cos(a), -sin(a), sin(a), cos(a));\t// Rotation\n\n\tfor (float i = 1.; i <= seg; i++)\t// Computes distance from each segment\n\t{\n\t\tfloat\ta = i / seg * (2. * PI);\n\t\tvec2\tp = pos * mat2(cos(a), -sin(a), sin(a), cos(a));\t// Put segment horizontaly\n\t\tfloat\tdst = 0.;\n\n\t\tif (p.x > -size && p.x < size)\n\t\t{\n\t\t\tdst = abs(apot - p.y);\n\t\t}\n\t\telse if (p.x <= -size)\n\t\t{\n\t\t\tdst = length(vec2(-size, apot) - p);\n\t\t}\n\t\telse if (p.x >= size)\n\t\t{\n\t\t\tdst = length(vec2(size, apot) - p);\n\t\t}\n\t\tif (d == 0. && dst != 0.)\n\t\t\td = dst;\n\t\telse if (dst != 0.)\n\t\t\td = min(d, dst);\n\t}\n\n\tfloat\tcol = 1. - pow(abs(d) * 30., 2.);\t// Glow factor\n\n    col = clamp(col, 0., 1.);\n\tvec4 ret = color(0x75, 0xee, 0xff, 0xff) * col;\n    return ret;\n}\n\nvec4 ring(vec2 fragCoord, vec2 coord)\n{\n\tfloat\tradius = 0.42;\n\tfloat\tPI = 3.14159265358979323846264;\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\n\tfloat\ttst = length(pos);\n\tfloat\tcol;\n\n\tcol = 1. - pow(abs(tst - radius) * 10., 2.) * (cos(iTime * 4. * PI) + 2.);\n    col = clamp(col, 0., 1.0);\n\treturn color(0xff, 0xed, 0x81, 0xff) * col;\n}\n\nvec4 head(vec2 fragCoord, vec2 coord, bool eye)\n{\n\tfloat\tPI = 3.14159265358979323846264;\n\tfloat\tradius = 0.42;\n\tfloat\tseg = 4.;\n\tfloat\tsize = radius * sin(PI / seg);\t// segment size / 2\n\tfloat\tapot = radius * cos(PI / seg);\t// segment distance from center\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\t// Point from center\n\n\tfloat\td = 0.;\n\n\tfloat\ta = PI / 4.;\n\tpos *= mat2(cos(a), -sin(a), sin(a), cos(a));\t// Rotation\n\n\tfor (float i = 1.; i <= seg; i++)\t// Computes distance from each segment\n\t{\n\t\tfloat\ta = i / seg * (2. * PI);\n\t\tvec2\tp = pos * mat2(cos(a), -sin(a), sin(a), cos(a));\t// Put segment horizontaly\n\t\tfloat\tdst = 0.;\n\n\t\tif (p.x > -size && p.x < size)\n\t\t{\n\t\t\tdst = abs(apot - p.y);\n\t\t}\n\t\telse if (p.x <= -size)\n\t\t{\n\t\t\tdst = length(vec2(-size, apot) - p);\n\t\t}\n\t\telse if (p.x >= size)\n\t\t{\n\t\t\tdst = length(vec2(size, apot) - p);\n\t\t}\n\t\tif (d == 0. && dst != 0.)\n\t\t\td = dst;\n\t\telse if (dst != 0.)\n\t\t\td = min(d, dst);\n\t}\n\n\tfloat\tcol = 1. - pow(abs(d) * 15., 2.);\t// Glow factor\n\tcol = max(0., min(1., col));\n    float colEye = 0.;\n    if (eye)\n\t\tcolEye = 1. - pow(length(pos) * 6., 2.) * (cos(iTime * 4. * PI) * 0.5 + 0.9);\t// Time factor\n\tcolEye = max(0., min(1., colEye));\n    \n    col = clamp(col, 0., 1.);\n    colEye = clamp(colEye, 0., 1.);\n\n\tvec4 eyeCol = scolor( mod(0.7 + index * 0.3, 1.0) );\n\teyeCol *= 1.2;\n\tvec4 snakeCol = scolor( mod(0.3 + index * 0.3, 1.0) );\n\treturn eyeCol * colEye + col * snakeCol;\n}\n\nvec4 block(vec2 fragCoord, vec2 coord)\n{\n\tvec4\tsnakeCol = color(0xff, 0x6a, 0x32, 0xff);\n\tfloat\tdebug = iTime;\n\n\tfloat\tPI = 3.14159265358979323846264;\n\tfloat\tradius = 0.6;\n\tfloat\tseg = 4.;\n\tfloat\tsize = radius * sin(PI / seg);\t// segment size / 2\n\tfloat\tapot = radius * cos(PI / seg);\t// segment distance from center\n\tvec2\tpos = (fragCoord.xy - coord) / resolution;\t// Point from center\n\n\tfloat\td = 0.;\n\n\tfor (float i = 1.; i <= seg; i++)\t// Computes distance from each segment\n\t{\n\t\tfloat\ta = i / seg * (2. * PI);\n\t\tvec2\tp = pos * mat2(cos(a), -sin(a), sin(a), cos(a));\t// Put segment horizontaly\n\t\tfloat\tdst = 0.;\n\n\t\tif (p.x > -size && p.x < size)\n\t\t{\n\t\t\tdst = abs(apot - p.y);\n\t\t}\n\t\telse if (p.x <= -size)\n\t\t{\n\t\t\tdst = length(vec2(-size, apot) - p);\n\t\t}\n\t\telse if (p.x >= size)\n\t\t{\n\t\t\tdst = length(vec2(size, apot) - p);\n\t\t}\n\t\tif (d == 0. && dst != 0.)\n\t\t\td = dst;\n\t\telse if (dst != 0.)\n\t\t\td = min(d, dst);\n\t}\n\td = mod(d + 0.05, 0.3) - 0.05;\n\tfloat\tcol = 1. - pow(abs(d) * 10., 1.);\t// Glow factor\n    col = clamp(col, 0., 1.);\n\n\treturn snakeCol * col;\n}\n\nvec4 walls(vec2 fragCoord)\n{\n\tvec2 c = mod(fragCoord, resolution);\n    if (fragCoord.x < resolution.x || fragCoord.y < resolution.y\n        || iResolution.x - fragCoord.x < resolution.x\n        || iResolution.y - fragCoord.y < resolution.y)\n\t\treturn block(c, resolution / 2.);\n    return vec4(0);\n}\n\nvec2 wave_offset(vec2 fragCoord, vec2 tpos, float tsize)\n{\n\tfloat\tPI = 3.14159265358979323846264;\n    \n    vec2 texPos = fragCoord / iResolution.xy - tpos;\n\n\tfloat dst = (length(texPos) - tsize) * 16.;\n\tfloat coef = 0.0f;\n\n\tif (dst < 1. && dst > -1.) // If in the wave\n\t{\n\t\tcoef = -1. + cos(dst * PI + PI); // Wave slope\n\t\ttexPos += normalize(texPos) * coef / 100.; // Texture offset with slope\n\t}\n    texPos += tpos;\n\n\treturn texPos * iResolution.xy\n        ;\n}\n\nfloat wave_coef(vec2 fragCoord, vec2 tpos, float tsize)\n{\n\tfloat\tPI = 3.14159265358979323846264;\n    \n    vec2 texPos = fragCoord - tpos;\n\n\tfloat dst = (length(texPos) - tsize) * 16.;\n\tfloat coef = 0.0f;\n\n\tif (dst < 1. && dst > -1.) // If in the wave\n\t{\n\t\tcoef = -1. + cos(dst * PI + PI); // Wave slope\n\t}\n\n\treturn coef;\n}\n\nvec2 start = vec2(100., 100.) + vec2(50., 50.) / 2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wave_size = mod(iTime / 2., 1.);\n    fragCoord = wave_offset(fragCoord, vec2(0.5, 0.5), wave_size);\n    \n    vec4 bgc = bg(fragCoord);\n\tvec4 c = star(fragCoord, start);\n    c += egg(fragCoord, start + vec2(resolution.x, 0.));\n    c += orange(fragCoord, start + vec2(resolution.x * 2., 0.));\n    c += cut(fragCoord, start + vec2(resolution.x * 3., 0.));\n    c += triangle(fragCoord, start + vec2(resolution.x * 4., 0.));\n    c += ring(fragCoord, start + vec2(0., resolution.y));\n    \n    float dec = mod(iTime, 1.) * resolution.x;\n    vec2 sstart = start + vec2(resolution.x * 3., resolution.y * 4.);\n    c += head(fragCoord, sstart + vec2(dec, 0.), floor(mod(iTime, 4.)) == 3.);\n    c += head(fragCoord, sstart + vec2(0., -dec + resolution.y), floor(mod(iTime, 4.)) == 2.);\n\tc += head(fragCoord, sstart + vec2(-dec + resolution.x, resolution.y), floor(mod(iTime, 4.)) == 1.);\n    c += head(fragCoord, sstart + vec2(resolution.x, dec), floor(mod(iTime, 4.)) == 0.);\n    \n    c += walls(fragCoord);\n\n    fragColor = mix(bgc, c, clamp(c.a, 0., 1.));\n    fragColor = vec4(fragColor.rgb * (1. - (wave_coef(fragCoord / iResolution.xy, vec2(0.5, 0.5), wave_size) / 2.)), 1.); // Lightens texture according to slope\n\n}","name":"Image","description":"","type":"image"}]}