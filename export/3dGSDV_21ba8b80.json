{"ver":"0.1","info":{"id":"3dGSDV","date":"1575382861","viewed":1554,"name":"exp_deconstruction","username":"skaplun","description":"The code could be more elegant. I kept this version for sake of understanding\nVersion wo animation - https://www.shadertoy.com/view/tdySzt","likes":49,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    for(int i=0; i<6; i++){\n    \tvec4 light = texture(iChannel0, fragCoord/iResolution.xy, float(i));\n        color += light.rgb * light.a;\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    // Íñigo Quílez\n    // https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec3 Rotate(in vec3 norm, in float yaw, in float pitch){\n    float cosp = cos(pitch);\n    float sinp = sin(pitch);\n    \n    mat3 rotp;\n    rotp[0][0] = 1.0;\n    rotp[0][1] = 0.0;\n    rotp[0][2] = 0.0;\n    rotp[1][0] = 0.0;\n    rotp[1][1] = cosp;\n    rotp[1][2] = -sinp;\n    rotp[2][0] = 0.0;\n    rotp[2][1] = sinp;\n    rotp[2][2] = cosp;\n    \n    float cosy = cos(yaw);\n    float siny = sin(yaw);\n    \n    mat3 roty;\n    roty[0][0] = cosy;\n    roty[0][1] = 0.0;\n    roty[0][2] = siny;\n    roty[1][0] = 0.0;\n    roty[1][1] = 1.0;\n    roty[1][2] = 0.0;\n    roty[2][0] = -siny;\n    roty[2][1] = 0.0;\n    roty[2][2] = cosy;\n    \n    norm = (rotp * norm);\n    norm = (roty * norm);\n    \n    return norm;\n}\n\nmat3 rotX(float a){\n\treturn mat3(1., 0., 0., 0., cos(a), -sin(a), -sin(a), 0., cos(a)); \n}\n\n\nmat3 rotY(float a){\n\treturn mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a)); \n}\n\nmat3 rotZ(float a){\n\treturn mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.); \n}\n\nstruct BreakdownAnimationState{\n\tfloat id;\n    float phase; \n};\n\n#define AP_GROW 0.\n#define AP_SHRINK_TOP 1.\n#define AP_SHRINK_INNER 2.\n#define AP_RING_2_EXPAND 3.\n#define AP_RING_3_EXPAND 4.\n#define AP_RING_4_EXPAND 5.\n#define AP_RING_5_EXPAND 6.\n#define AP_OUTER_RING_EXPAND 7.\n#define AP_DESATURATE 8.\n#define AP_RING_1_LIGHT_INCREASE 9.\n#define AP_RING_2_LIGHT_INCREASE 10.\n#define AP_RING_3_LIGHT_INCREASE 11.\n#define AP_RING_4_LIGHT_INCREASE 12.\n#define AP_RINGS_SPIN 13.\n#define AP_PATTERN_SHOW 14.\n#define AP_RINGS_COLLAPSE 15.\n#define AP_END 16.\n    \nconst int PHASES_COUNT = 17;\nconst float PHASES_DURATIONS[PHASES_COUNT] = float[PHASES_COUNT]\n    (.5, 1., 1.5, 2., 2.5, 3.0, 3.5, 4.5, 5., 5.5, 6., 6.5, 7., 9., 9.5, 10., 11.);\n\nBreakdownAnimationState getBreakdownAnimationState(float time){\n\ttime = mod(time, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    \n    int id = 0;\n    for(int i=1; i<=PHASES_COUNT; i++){\n        if(time < PHASES_DURATIONS[i-1]){\n        \tid = i-1;\n            break;\n        }\n    }\n    float phase = (time - (id == 0 ? 0. : PHASES_DURATIONS[id-1]))\n        \t\t/ (PHASES_DURATIONS[id] - (id == 0 ? 0. : PHASES_DURATIONS[id-1]));\n    \n    return BreakdownAnimationState(float(id), phase);\n}\n\nfloat getNormalizedBAS(BreakdownAnimationState bas, float id){\n\tif(id == bas.id)\n        return bas.phase;\n    else\n        return step(id, bas.id);\n    //return max(bas.phase, step(bas.id, id-1.));\n}\n\nfloat getInvNormalizedBAS(BreakdownAnimationState bas, float id){\n\tif(id == bas.id)\n        return 1.-bas.phase;\n    else\n        return step(bas.id, id);\n    //return max(1.-bas.phase, step(bas.id, id-1.));\n}\n\nfloat block(in vec2 uv, vec2 size){\n\treturn max(abs(uv).x-size.x, abs(uv).y-size.y);\n}\n\nfloat greek1(vec2 uv){\n\tuv = (fract(uv)-.5) * 2.;\n    \n    float res = MAX_FLOAT;\n    res = min(res, block(uv, vec2(.3, .1)));\n    res = min(res, block(vec2(abs(uv.x), uv.y) - vec2(.2, .2*sign(uv.x)), vec2(.1, .3)));\n    res = min(res, block(vec2(uv.x, abs(uv.y)) - vec2(-.2 * sign(uv.y), .4), vec2(.5, .1)));\n    res = min(res, block(vec2(abs(uv.x), uv.y) - vec2(.6, .2*sign(uv.x)), vec2(.1, .6)));\n    res = min(res, block(vec2(uv.x, abs(uv.y)) - vec2(-.1 * sign(uv.y), .8), vec2(.8, .1)));\n    res = min(res, block(vec2(abs(uv.x), uv.y) - vec2(1., 0.*sign(uv.x)), vec2(.1, .9)));\n    return res;\n}\n\nfloat greek2(vec2 uv){\n\tuv = (fract(uv)-.5) * 2.;\n    \n    float res = MAX_FLOAT;\n    res = min(res, block(uv - vec2(0., .3), vec2(.6, .15)));\n    res = min(res, block(vec2(abs(uv.x), uv.y) - vec2(.7, -.2), vec2(.4, .15)));\n    res = min(res, block(vec2(abs(uv.x), uv.y) - vec2(.5, .05), vec2(.2, .4)));\n    return res;\n}\n\nfloat greek3(vec2 uv){\n\tuv = (fract(uv)-.5) * 2.;\n    \n    float border = smoothstep(.99, .98, abs(uv.x))\n        \t\t * smoothstep(.99, .98, abs(uv.y));\n    \n    float res = MAX_FLOAT;\n    res = min(res, block(abs(uv) - vec2(step(uv.y, 0.), .4), vec2(.9, .1)));\n    res = min(res, block(abs(uv) - vec2(.5, 0.), vec2(.4, .1)));\n    res = min(res, block(abs(uv) - vec2(.2 + .6*step(0., uv.y), .2), vec2(.1, .1)));\n    \n    return res;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAT_ID_COAL 0.\n#define MAT_ID_GOLD 1.\n#define UP vec3(0., 1., 0.)\n#define MAX_MARCHING_STEPS 64\n#define EPSILON .0001\n//#define SHADOWS\nBreakdownAnimationState bas;\n\nconst vec4 RING_1_COLOR = vec4(48., 111., 197., 255.)/255.;\nconst vec4 RING_2_COLOR = RING_1_COLOR * .85;\nconst vec4 RING_3_COLOR = RING_1_COLOR * .65;\nconst vec4 RING_4_COLOR = RING_1_COLOR * .55;\n\nfloat getRingAngle(int id){\n    switch(id){\n        case 1:\n        {\n        \tfloat rotAng = 30. * getNormalizedBAS(bas, AP_RING_2_EXPAND);\n            rotAng += 20. * getNormalizedBAS(bas, AP_RING_3_EXPAND);\n            rotAng += 460. * pow(getNormalizedBAS(bas, AP_RINGS_SPIN), 2.);\n            rotAng += 30. * pow(getNormalizedBAS(bas, AP_RINGS_COLLAPSE), .5);\n        \treturn rotAng;\n        }\n        case 2:\n        {\n        \tfloat rotAng = 25. * getNormalizedBAS(bas, AP_RING_3_EXPAND);\n            rotAng += 15. * getNormalizedBAS(bas, AP_RING_4_EXPAND);\n            rotAng += 450. * pow(getNormalizedBAS(bas, AP_RINGS_SPIN), 1.5);\n            rotAng += 50. * pow(getNormalizedBAS(bas, AP_RINGS_COLLAPSE), 1.);\n        \treturn rotAng;\n        }\n        case 3:\n        {\n        \tfloat rotAng = 20. * getNormalizedBAS(bas, AP_RING_4_EXPAND);\n            rotAng += 10. * getNormalizedBAS(bas, AP_RING_5_EXPAND);\n            rotAng += 440. * getNormalizedBAS(bas, AP_RINGS_SPIN);\n            rotAng += 70. * pow(getNormalizedBAS(bas, AP_RINGS_COLLAPSE), 1.5);\n            return rotAng;\n        }\n        case 4:\n        {\n            float rotAng = 15. * getNormalizedBAS(bas, AP_RING_5_EXPAND);\n            rotAng += 430. * pow(getNormalizedBAS(bas, AP_RINGS_SPIN), .5);\n            rotAng += 93. * pow(getNormalizedBAS(bas, AP_RINGS_COLLAPSE), 2.);\n            return rotAng;\n        }\n    \tdefault:\n        \treturn 0.;\n    }\t\n}\n\nfloat opSubtraction(float d1, float d2){return max(-d1,d2);}\nfloat getRadialShrinkAnimation(vec3 p, float animationId){\n\tfloat a = 1.001 * getNormalizedBAS(bas, animationId) * PI * 2.;\n    if(a > 2. * PI)\n        return -MAX_FLOAT;\n    else if(a < PI)\n    \treturn max(p.x, -(p * rotY(a)).x);\n    else\n    \treturn min(p.x, -(p * rotY(a)).x);\n}\n\nfloat getRadialExpandAnimation(vec3 p, float animationId){\n\tfloat a = getNormalizedBAS(bas, animationId) * PI * 2. - .00001;\n    if(a < 0.)\n    \treturn MAX_FLOAT;\n    else if(a < PI)\n    \treturn max(-p.x, (p * rotY(a)).x);\n    else\n    \treturn min(-p.x, (p * rotY(a)).x);\n}\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h){\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat world(vec3 pos){\n  \tfloat res = length(pos) - 2.5 * getNormalizedBAS(bas, AP_GROW);\n    \n    {\n        vec3 p = Rotate(pos, 0., -radians(getRingAngle(1)));\n        res = max(res, p.y - .05 - 2.5 * getInvNormalizedBAS(bas, AP_SHRINK_TOP));\n        res = opSubtraction(max(length(p) - 2., getRadialShrinkAnimation(p, AP_SHRINK_INNER)), res);\n        res = max(res, -p.y - .05 - 2.5 * getInvNormalizedBAS(bas, AP_SHRINK_INNER));\n    }\n    {\n        vec3 p = Rotate(pos, 0., -radians(getRingAngle(2)));\n        res = min(res, max(opSubtraction(length(p) - 1.5,\n                                         max(p.y-.05, -p.y-.05)),\n                           max(length(p) - 2.,\n                               getRadialExpandAnimation(p, AP_RING_2_EXPAND))));\n    }\n    {\n        vec3 p = Rotate(pos, 0., -radians(getRingAngle(3)));\n        res = min(res, max(opSubtraction(length(p) - 1.,\n                                         max(p.y-.05, -p.y-.05)),\n                           max(length(p) - 1.5,\n                               getRadialExpandAnimation(p, AP_RING_3_EXPAND))));\n    }\n    {\n        vec3 p = Rotate(pos, 0., -radians(getRingAngle(4)));\n        res = min(res, max(opSubtraction(length(p) - .5,\n                                         max(p.y-.05, -p.y-.05)),\n                           max(length(p) - 1.,\n                               getRadialExpandAnimation(p, AP_RING_4_EXPAND))));\n    }\n    \n    vec3 p = pos;\n    res = min(res, max(max(p.y-.05, -p.y-.05),\n                       max(length(p) - .5,\n                           getRadialExpandAnimation(p, AP_RING_5_EXPAND))));\n    res = min(res, max(opSubtraction(length(pos) - 2.5,\n                                     max(p.y-.05, -p.y-.05)),\n                           length(pos) - 2.49 - 100. * getNormalizedBAS(bas, AP_OUTER_RING_EXPAND)));\n    float l = length(pos.xz) + .5;\n    float pattern = greek1(vec2((atan(pos.z, pos.x)/PI+PI) * (8. + l*.2*sign(mod(floor(l), 2.) - .5)), l));\n    pattern = opSubtraction(length(p) - 2.5,\n                            opExtrussion(pos - vec3(0., .05, 0.), pattern + .1 * getInvNormalizedBAS(bas, AP_PATTERN_SHOW), .025));\n    return opSubtraction(pattern, res);\n}\n\nfloat march(vec3 eye, vec3 marchingDirection){\n    const float precis = 0.001;\n    float t = 0.0;\n\tfor(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    float h = world(eye + marchingDirection * t);\n        if( h < precis ) return t;\n        t += h;\n    }\n    return -1.;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nstruct Light{vec3 normal; vec3 attenuation; vec3 position; float radius;};\n\nvec3 PointOnCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius){\n \tvec3 d = pos - circlePos;\n    vec3 qc = d - dot(circleNorm, d) * circleNorm;\n    \n    return (circlePos + circleRadius * normalize(qc));\n}\n\nfloat Attenuation(float d, float c, float l, float q){\n    return (1.0 / (c + (l * d) + (q * d * d)));\n}\n\n#ifdef SHADOWS\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.;\n    const float mint = .5;\n    const float maxt = 1.5;\n    const float k = 3.;\n    float t = mint;\n    \n    for (int i = 0; i < 4; i++) {\n        if (t > maxt) {\n            break;\n        }\n        float h = world(ro + rd * t);\n        res = min(res, k * h / t);\n        if (h < 0.01) {\n            return 0.0;\n        }\n        t += h;\n    }\n    return res;\n}\n#endif\n\nfloat Lighting_Ring(in vec3  toView, in vec3  pos, in vec3  norm, in Light light){\n    // Get the closest point on the circle circumference on the plane \n    // defined bythe light's position and normal. This point is then used\n    // for the standard lighting calculations.\n    \n    vec3 pointOnLight = PointOnCircle(pos, light.position, light.normal, light.radius);\n    vec3 toLight      = pointOnLight - pos;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, light.normal);\n          lightCos    = max(0., lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    float roughness= 1.;\n    float spcLight = pow(max(0.0, dot(reflVector, toLight)), roughness) * lightCos;\n    \n\tfloat color = lightCos * attenuation * max(dot(toLightN, norm), 0.);\n#ifdef SHADOWS\n    color *= shadow(pos, -toLightN);\n#endif\n    return color;\n\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec4 color = vec4(0.);\n    float a = PI*.75 - getNormalizedBAS(bas, AP_PATTERN_SHOW)*2.;\n    vec3 eye = vec3(4. * sin(a), 2., 4. * cos(a)) * 2.;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    float dist = march(eye, worldDir);\n    if (dist >= 0.) {\n        vec3 p = (eye + dist * worldDir);\n    \tvec3 norm = estimateNormal(p);\n        \n        vec4 lightedSurface = vec4(6., 16., 31., 0.)/255.;\n        \n        float rotAng = getRingAngle(1);\n        Light light = Light(Rotate(UP, 0., radians(rotAng)), vec3(.1, 1., .5), vec3(0., .05, 0.)*rotX(radians(rotAng)), 2.25);\n        vec4 ligthColor = vec4(RING_1_COLOR.rgb, 0.);\n        lightedSurface += ligthColor * 8. * getNormalizedBAS(bas, AP_RING_1_LIGHT_INCREASE) * Lighting_Ring(worldDir, p, norm, light);\n        \n        rotAng = getRingAngle(2);\n        light = Light(Rotate(UP, 0., radians(rotAng)), vec3(.1, 1., .5), vec3(0., .05, 0.)*rotX(radians(rotAng)), 1.75);\n        ligthColor = vec4(RING_2_COLOR.rgb, 0.);\n        lightedSurface += ligthColor * 8. * getNormalizedBAS(bas, AP_RING_2_LIGHT_INCREASE) * Lighting_Ring(worldDir, p, norm, light);\n        \n        rotAng = getRingAngle(3);\n        light = Light(Rotate(UP, 0., radians(rotAng)), vec3(.1, 1., .5), vec3(0., .05, 0.)*rotX(radians(rotAng)), 1.25);\n        ligthColor = vec4(RING_3_COLOR.rgb, 0.);\n        lightedSurface += ligthColor * 8. * getNormalizedBAS(bas, AP_RING_3_LIGHT_INCREASE) * Lighting_Ring(worldDir, p, norm, light);\n        \n        rotAng = getRingAngle(4);\n        light = Light(Rotate(UP, 0., radians(rotAng)), vec3(.1, 1., .5), vec3(0., .05, 0.)*rotX(radians(rotAng)), .75);\n        ligthColor = vec4(RING_4_COLOR.rgb, 0.);\n        lightedSurface += ligthColor * 8. * getNormalizedBAS(bas, AP_RING_4_LIGHT_INCREASE) * Lighting_Ring(worldDir, p, norm, light);\n    \t\n        lightedSurface /= 4.;\n\t\tfloat ang = getRingAngle(1);\n        vec3 mp = Rotate(p, 0., radians(-ang));\n        float l = length(mp);\n        lightedSurface += RING_1_COLOR\n               * smoothstep(.1, -.1, greek1(vec2((atan(mp.z, mp.x)/PI+PI) * 12., l * 2.)))\n               * smoothstep(.25, .245, distance(l, 2.25))\n               * step(.99, dot(UP, norm*rotX(radians(ang))))\n               * getNormalizedBAS(bas, AP_RING_1_LIGHT_INCREASE);\n        ang = getRingAngle(2);\n        mp = Rotate(p, 0., radians(-ang));\n        lightedSurface += RING_2_COLOR\n               * smoothstep(-.05, .1, greek1(vec2((atan(mp.z, mp.x)/PI+PI) * 8., l * 1.5 - .125)))\n               * smoothstep(.25, .245, distance(l, 1.75))\n        \t   * step(.99, dot(UP, norm*rotX(radians(ang))))\n        \t   * getNormalizedBAS(bas, AP_RING_2_LIGHT_INCREASE);\n        ang = getRingAngle(3);\n        mp = Rotate(p, 0., radians(-ang));\n        lightedSurface += RING_3_COLOR\n               * smoothstep(.1, -.1, greek3(vec2((atan(mp.z, mp.x)/PI+PI) * 6., l * 2.)))\n               * smoothstep(.25, .245, distance(l, 1.25))\n        \t   * step(.99, dot(UP, norm*rotX(radians(ang))))\n               * getNormalizedBAS(bas, AP_RING_3_LIGHT_INCREASE);\n        ang = getRingAngle(4);\n        mp = Rotate(p, 0., radians(-ang));\n        lightedSurface += RING_4_COLOR\n               * smoothstep(.0, -.1, greek2(vec2((atan(mp.z, mp.x)/PI+PI) * 6., l * 2.)))\n               * smoothstep(.25, .245, distance(l, .75))\n        \t   * step(.99, dot(UP, norm*rotX(radians(ang))))\n               * getNormalizedBAS(bas, AP_RING_4_LIGHT_INCREASE);\n        \n        color = mix(vec4(vec3(1.-pow(abs(dot(norm, worldDir)), .25)), 0.), lightedSurface, getNormalizedBAS(bas, AP_RING_1_LIGHT_INCREASE));\n        color.rgb = mix(norm, color.rgb, getNormalizedBAS(bas, AP_DESATURATE));\n    }\n    return color;\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    bas = getBreakdownAnimationState(iTime);\n    fragColor -= fragColor;\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n            fragColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n    fragColor /= float(AA * AA);\n}","name":"Buffer A","description":"","type":"buffer"}]}