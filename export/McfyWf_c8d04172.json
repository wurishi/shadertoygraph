{"ver":"0.1","info":{"id":"McfyWf","date":"1721675625","viewed":76,"name":"Blurlin","username":"Chroma_Crash","description":"Recreation of an old effect I designed in Python.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin","rgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PIXEL_SIZE 4.0f\n#define CELL_SIZE 64\n\n#define MOD 32\n\n#define SPEED 0.5f\n\nfloat interp(float a, float b, float t) {\n    return (b - a) * t + a;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 cellDir(ivec3 cell) {\n    float z = rand(vec2(cell.x, cell.y + cell.z));\n    float rxy = sqrt(1.0f - z * z);\n    float phi = rand(vec2(cell.z, cell.x + cell.y));\n    \n    float y = rxy * sin(phi);\n    float x = rxy * cos(phi);\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat perlin(vec3 position) {\n    position = position / float(CELL_SIZE);\n    ivec3 cellPos = ivec3(floor(position));\n    \n    int i = 0;\n    \n    float products[8];\n    \n    for (int z = 0; z <= 1; z++) {\n        for (int y = 0; y <= 1; y++) {\n            for (int x = 0; x <= 1; x++) {\n                ivec3 checkCell = cellPos + ivec3(x, y, z);\n                vec3 offset = position - vec3(checkCell) + vec3(0.01f);\n                checkCell = checkCell % MOD;\n                vec3 dir = cellDir(checkCell);\n                \n                float product = dot(dir, offset);\n                products[i] = product;\n                i += 1;\n            }\n        }\n    }\n\n    vec3 offset = position - vec3(cellPos);\n    \n    float xInterp[4] = float[4](\n    interp(products[0], products[1], offset.x), \n    interp(products[2], products[3], offset.x), \n    interp(products[4], products[5], offset.x), \n    interp(products[6], products[7], offset.x)\n    );\n    float yInterp[2] = float[2](\n    interp(xInterp[0], xInterp[1], offset.y), \n    interp(xInterp[2], xInterp[3], offset.y)\n    );\n    float zInterp = interp(yInterp[0], yInterp[1], offset.z);\n    \n    return zInterp > 0.0f ? zInterp * 2.0f + 0.5f : 0.0f;\n}\n\nfloat noise(vec3 position) {\n    return perlin(position);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    \n    float time = (iTime + 16.0f) * SPEED * float(CELL_SIZE);\n\n    float r = noise(vec3(uv * 1.4f, time));\n    float g = noise(vec3(uv, -time - 2.0f));\n    float b = noise(vec3(uv / 1.4f, time + 60.0f));\n    \n    vec3 col = vec3(r, g, b);\n    \n    //ivec3 cellPos = ivec3(vec3(uv, iTime * SPEED) / float(CELL_SIZE));\n    //col = cellDir(cellPos);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}