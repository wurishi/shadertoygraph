{"ver":"0.1","info":{"id":"fs33Dr","date":"1629546813","viewed":229,"name":"Double Pendula","username":"chronos","description":"Work in progress!\n\nAdjust properties in the  'Common' tab:\n- Line trace vs dot trace rendering\n- Color vs monochrome rendering\n- Number of pendula (1-256 for now)\n- Pendula properties","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["chaos","equation","double","pendulum","differential","multiple"],"hasliked":0,"parentid":"7sdGzr","parentname":"Vectors, Covectors, Duality"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center, zoom by factor 2, and correct aspect ratio\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float acc = 0.; // accumulate\n    \n    float spacing = 0.1;\n    \n    // Draw concentric circles\n    for(int i = 0; i < 21; i++)\n    {\n        float radius = spacing * float(i);\n        float circle = indicator(circle_sdf(uv, radius));\n        acc = max(acc, circle);\n    }\n    \n    // accentuate radius == 1\n    float circle = bump(circle_sdf(uv, 1.), 1.5, 400., 0.5);\n    acc = max(acc, circle);\n    \n    \n    // Draw axis cross\n    float weight = 0.25;\n    acc = max(acc, bump(uv.x, width, sharpness, weight));\n    acc = max(acc, bump(uv.y, width, sharpness, weight));\n\n    //vec2 mouse1 = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    //vec2 mouse2 = (2. * abs(iMouse.zw) - iResolution.xy) / iResolution.y;\n\n    vec2 p_theta = vec2(0);\n    vec2 theta = vec2(0);\n    vec4 buffer = vec4(0);\n    if(iFrame > WAIT_FRAMES)\n    {\n        for(int i = 0; i < NUM_PENDULA; i++) // Draw pendula\n        {\n            buffer = texelFetch(iChannel0, ivec2(i, 0), 0);\n            p_theta = buffer.rg;\n            theta = buffer.ba;\n    \n    \n            vec2 v1 = pendulum1(theta, l);\n            vec2 v2 = pendulum2(theta, l);\n    \n            float startweight = 1.;\n            float endweight = 0.1;\n            weight = (startweight - endweight) * smoothstep(100., 20., iTime) + endweight;\n            float draw_v1 = bump(line_segment_sdf(vec2(0), v1, uv), width, sharpness, weight );\n            float draw_v2 = bump(line_segment_sdf(v1, v2, uv), width, sharpness, weight );\n    \n            acc = max(acc, draw_v1);\n            acc = max(acc, draw_v2);\n        }\n    }\n    vec3 color = vec3(acc);\n    \n    \n    /*\n    if(uv.x > 1.6)\n    {\n        if(uv.x > 1.69)\n        {\n            color = vec3(0, 0, 1) * step(uv.y, 0.9 * theta.x / TAU);\n        }\n        else\n        {\n            color = vec3(1, 0, 0) * step(uv.y, 0.9 * theta.y / TAU);\n        }\n    }\n    \n    if(uv.x < -1.6)\n    {\n        if(uv.x < -1.69)\n        {\n            color = vec3(0, 0, 1) * step(uv.y, 0.1 * p_theta.x);\n        }\n        else\n        {\n            color = vec3(1, 0, 0) * step(uv.y, 0.1 * p_theta.y);\n        }\n    }\n    */\n    color += texture(iChannel1, fragCoord.xy / iResolution.xy).rgb * 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Simulate\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 noise = texelFetch(iChannel3, ivec2(fragCoord) % ivec2(256), 0).rg; // Initial position\n    vec2 theta = noise * TAU;\n    \n    vec2 omega = vec2(0.);\n    if(iFrame > WAIT_FRAMES)\n    {\n        vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        omega = buffer.rg;\n        theta = buffer.ba;\n\n        for(int it = 0; it < 40; it++)\n        {\n        \n            float dt = 0.0001;\n            \n            vec2 omega_prime = angular_acceleration(omega, theta, l, m, g);\n    \n            \n            theta += dt * omega;\n            omega += dt * omega_prime;\n            \n        }\n        \n    }\n\n    fragColor = vec4(omega, theta);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float m = 1.; // mass\nfloat l = 0.5; // length\nfloat g = 9.; // gravity\n\n#define PI 3.14159265359\n#define TAU (PI * 2.)\n\n#define NUM_PENDULA 100\n#define WAIT_FRAMES 60\n\n#define USE_LINE_TRACE 0\n\n#define USE_COLOR 0\n\nvec2 pendulum1(vec2 theta, float l)\n{\n    return l * vec2(sin(theta.x), -cos(theta.x));\n}\n\nvec2 pendulum2(vec2 theta, float l)\n{\n    return\n        pendulum1(theta, l)\n        + \n        pendulum1(theta.yx, l)\n        ;\n}\n\n// from https://www.myphysicslab.com/pendulum/double-pendulum-en.html\n// simplified such that l1 = l2 = l, and m1 = m2 = m\nvec2 angular_acceleration(vec2 omega, vec2 theta, float l, float m, float g)\n{\n    vec2 omega_squared = omega * omega;\n    float sinAngleDifference = sin(theta.x - theta.y);\n    float cosAngleDifference = cos(theta.x - theta.y);\n    return \n    vec2(\n        - g * (3. * sin(theta.x) + sin(theta.x - 2. * theta.y)) - 2. * sinAngleDifference * (omega_squared.y * l + omega_squared.x * l * cosAngleDifference),\n        2. * sinAngleDifference * (omega_squared.x * l * 2. * m + 2. * g * m * cos(theta.x) + omega_squared.y * l * m * cosAngleDifference)\n    ) / (l * (3. - cos(2. * theta.x - 2. * theta.y)));\n}\n\n/*\nomega1_dt =\n(−g * (3 * sin(theta1) + sin(theta1 − 2 * theta2)) − 2 * sin(theta1 − theta2) * (omega2 * omega2 * L + omega1 * omega1 * L * cos(theta1 − theta2)))\n/\nL * (3 − cos(2 * theta1 − 2 * theta2))\n\nomega2_dt = \n\n2 * sin(theta1 − theta2)) * (omega1 * omega1 * L * 2 * m + 2 * g * m * cos(theta1) + omega2 * omega2 * L * m *cos(theta1 - theta2))\n/\nL * (3 − cos(2 * theta1 − 2 * theta2))\n*/\n\n\n\n// SDF and drawing functions\n\nfloat sharpness = 400.;\nfloat width = 1.5;\nfloat weight = 1.;\n\nfloat circle_sdf(vec2 xy, float radius)\n{\n    return length(xy) - radius;\n}\n\n// Smooth bump-like function in the 'offset' variable parameterised by the other arguments\nfloat bump(float offset, float width, float sharpness, float weight)\n{\n    return weight * smoothstep(0., 1., width - sharpness * abs(offset));\n}\n\nfloat indicator(float offset)\n{\n    float sharpness = 400.;\n    float width = 1.5;\n    float weight = 0.125;\n\n    return bump( offset, width, sharpness, weight );\n}\n\nfloat line_segment_sdf(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float l = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    return distance(a + l * ab, p);\n}\n\n\n\n\n\n\n\n// from wikipedia, this did not work well....\n/*\nvec2 momenta(float m, float l, vec2 theta_dt, vec2 theta)\n{\n    return (1./6.) * m * l * l * \n    vec2( \n        8. * theta_dt.x + 3. * theta_dt.y * cos(theta.x - theta.y),\n        2. * theta_dt.y + 3. * theta_dt.x * cos(theta.x - theta.y)\n        );\n}\n\nvec2 theta_dt(float m, float l, vec2 p_theta, vec2 theta)\n{\n    float cosTheta1MinusTheta2 = cos(theta.x - theta.y);\n    return (6. / (m * l * l)) * \n    (vec2(2., 8.) * p_theta.xy - 3. * cosTheta1MinusTheta2 * p_theta.yx)\n    / \n    (16. - 9. * cosTheta1MinusTheta2 * cosTheta1MinusTheta2);\n}\n\nvec2 p_theta_dt(float m, float l, vec2 theta, vec2 theta_dt, float g)\n{\n    float sinTheta1MinusTheta2 = cos(theta.x - theta.y);\n    return - (.5 * (m * l * l)) * \n        vec2(\n            theta_dt.x * theta_dt.y * sinTheta1MinusTheta2 + 3. * g * sin(theta.x)/ l,\n            theta_dt.x * theta_dt.y * sinTheta1MinusTheta2 -      g * sin(theta.y)/ l\n        );\n}\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Draw and trace / accululate endpoint positions\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center, zoom by factor 2, and correct aspect ratio\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 acc = vec3(0.); // accumulate\n    \n    float spacing = 0.1;\n    \n    vec2 p_theta = vec2(0);\n    vec2 theta = vec2(0);\n    vec4 buffer = vec4(0);\n    if(iFrame > WAIT_FRAMES)\n    {\n        int num = NUM_PENDULA;\n        for(int i = 0; i < num; i++)\n        {        \n        \n           #if USE_LINE_TRACE\n        \n            // this probably does not correctly estimate something proportional to the PDF of the pendulum endpoint being in a certain position,\n            // but should be close to what would be drawn if you attached a pen to the end.\n           \n            buffer = texelFetch(iChannel2, ivec2(i, 0), 0);\n            theta = buffer.rg;\n            vec2 theta_prev = buffer.ba;\n            \n            vec2 v2 = pendulum2(theta, l);\n            vec2 v2_prev = pendulum2(theta_prev, l);\n    \n            // trying to normalize by line segment length, by integrating cross section of bump along segment and adding endcaps.\n            // probably wrong, but should be proportional to this i think...\n            weight = .1 * (1. / (1. + distance(v2, v2_prev))); \n            float draw_v2 = //bump(distance(uv, v2), width, sharpness, weight );\n            \n                bump(line_segment_sdf(v2, v2_prev, uv), width, sharpness, weight )\n            \n                // Adjust for endpoint overlap, also not entirely correct...\n                // Consider the case where a pendulum endpoint is standing still.\n                - bump(distance(uv, v2), width, sharpness, weight ) \n            ;  \n            \n        \n           #else\n            \n            // Draw dots \n             \n            buffer = texelFetch(iChannel0, ivec2(i, 0), 0);\n            theta = buffer.ba;\n            //vec2 v1 = pendulum1(theta, l);\n            vec2 v2 = pendulum2(theta, l);\n            \n            weight = .1 ; \n            float draw_v2 = bump(distance(uv, v2), width, sharpness, weight );         \n            \n           #endif\n           \n           vec3 trace_color = vec3(1);\n           #if USE_COLOR\n               float noise = texelFetch(iChannel3, ivec2(i, 0), 0).r; // Initial position\n               float color_theta = noise * TAU;\n               trace_color = \n               clamp(\n                   vec3(0.5) + \n                   normalize(vec3(1, -1, 0)) * cos(color_theta) + \n                   normalize(cross(vec3(1, -1, 0), vec3(1))) * sin(color_theta),\n                   vec3(0), vec3(1)\n                   );\n           #endif\n            acc = max(acc, draw_v2 * trace_color);\n        }\n    }\n    \n    vec3 color = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb + acc;\n    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Delay buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 theta = texelFetch(iChannel0, ivec2(fragCoord), 0).ba;\n    vec2 theta_prev = texelFetch(iChannel1, ivec2(fragCoord), 0).rg;\n    fragColor = vec4(theta, theta_prev);\n}","name":"Buffer C","description":"","type":"buffer"}]}