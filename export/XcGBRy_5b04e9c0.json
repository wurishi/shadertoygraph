{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/* I find it fun to watch\nhow fast a cluster of normals\ncan separate into recognizable\nplanes.\nSince all normals are the same\ndistance from the origin, this\nis always convex.\nToo few normals on a side result in\nlarge protrusions.\nLots of algorithms can distribute\nthe surface normals.\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\n#define ROT2(ANG) mat2(cos(ANG),sin(ANG),-sin(ANG),cos(ANG))\n\nfloat sdSphere(vec3 pt,float sz) {\n    return length(pt)-sz;\n}\n\n// I played to get this small\n#define PHI 1.6180339887\nfloat sdDodecahedron(vec3 p,float d) {\n    p = abs(p);\n    vec2 v = normalize(vec2(1,PHI));\n    float d1 = dot(p.yz,v.xy);  \n    float d2 = dot(p.xz,v.yx);\n    float d3 = dot(p.xy,v.xy);\n    return max(d1,max(d2,d3))-d;\n}\n\n// ********** sdWhateverhedron *************\n\n#define sin1(X) (.5+.5*sin(X))\n#define sinab(X,A,B) (sin1(X)*((B)-(A))+(A))\nint count;\nfloat sdWhateverhedron(vec3 p,float h) {\n  float d = -1e9;\n  float d2 = 1e9;\n  float tm = iTime/4.;\n  count=0;\n  float dc=TAU/sinab(tm*1.7+TAU/5.,2.3,4.98);\n  for ( float cc = 0.; cc < TAU; cc += dc )\n  for ( float bb = 0.; bb < TAU; bb += TAU/sinab(tm*1.3+TAU/6.,2.2,4.95) )\n  for ( float aa = 0.; aa < TAU; aa += TAU/sinab(tm*1.,2.4,4.9) )\n  {\n    vec3 n = vec3(1,0,0);\n    n.xy *= ROT2(aa);\n    n.yz *= ROT2(cc);\n    n.xz *= ROT2(bb);\n    float t;\n    t = dot(p,n);  if ( t > d ) d = t;\n    t = sdSphere(p-n*h,.3); if ( t < d2 ) d2 = t;\n    ++count;\n  }\n  d -= h;\n  return min(d,d2);\n}\n\nvec3 Spin(vec3 p) {\n   p.xz *= ROT2(iTime);\n   p.yz *= ROT2(iTime*1.4);\n   return p;\n}\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n#define TC(SDF,C) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,C);\n    T( sdSphere( pt-vec3(20,-10,0), 2. ) )\n    T( sdDodecahedron(Spin(pt-vec3(-20,10,0)),4.) )\n    T( sdWhateverhedron(pt,15.) )\n    T( sdSphere( pt-vec3(30,20,30), 2. ) )\n    T( sdSphere( pt-vec3(-30,-10,20), 2. ) )\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 150; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .001 || stps == 149 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}   \n\nfloat pow2n(float x,int n) {\n    while ( n-- > 0 ) x *= x;\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n\n    vec3 cam = vec3(0,0,-40);\n    vec3 camdir = normalize( vec3( uv, 2.) );\n    \n    vec2 M = iMouse.xy;\n    if ( M.x != .0 || M.y != 0. ) \n      M = (M+M-R) / min(R.x,R.y);  // -1 ... +1\n    mat3 rot = MAT3xz(M.x*2.) * MAT3zy(M.y*2.);\n    cam *= rot;\n    camdir *= rot;\n\n    vec4 hit = March( cam, camdir );\n    vec3 norm = Normal(hit.xyz);\n\n    vec3 Light = vec3(-40);\n    vec3 dir = normalize( Light - hit.xyz );\n    float difu = max(0.,dot( norm, dir ));\n\n    vec3 Light2 = vec3(40);\n    dir = normalize( Light2 - hit.xyz );\n    difu += max(0.,dot( norm, dir ));\n\n    difu += pow2n(difu,2);\n    \n    difu *= .6;\n   \n    difu = .30 + .70*difu;\n    \n#define CLR(C) pow(.5+.5*sin((C)+vec3(0.,TAU/3.,TAU*2./3.)),vec3(.5))\n         \n    if ( hit.w < 59. ) \n        O = difu * vec4(CLR(hit.w)*(1.+norm),1);\n    else\n        O = vec4(vec3(.2,.2,.8)*camdir,1.);\n    O = sqrt(O);\n    \n    if (U.x<10.&&U.y<float(count)/150.*R.y)\n        O=vec4(1);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcGBRy","date":"1734138165","viewed":81,"name":"Whateverhedron","username":"dray","description":"What polyhedron do you get with changing position and number (~8-125) of faces ?\nMouse view control. Normals indicated.\nThats also the smallest Dodecahedron code I could come up with.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["polyhedera"],"hasliked":0,"parentid":"","parentname":""}}