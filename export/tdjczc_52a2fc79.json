{"ver":"0.1","info":{"id":"tdjczc","date":"1587111684","viewed":113,"name":"Rounded Rectangle Demo","username":"hyouka","description":"demo to show the rounded rectangle and moving along the shape","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["newbie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define W 0.4\n#define H 0.4\n#define R 0.1\n#define T 0.02\n\n#define LH (H - R * 2.0)\n#define LR (PI * R / 2.0)\n#define LW (W - R * 2.0)\n\n\n\nfloat roundedRectangle (vec2 coord, vec2 size, float radius, float thickness)\n{\n    vec2 halfsize = size / 2.0;\n    halfsize = halfsize - vec2(radius + thickness / 2.0, radius + thickness / 2.0);\n\n    float d = length( max( abs(coord), halfsize ) - halfsize) - radius;\n    return smoothstep(thickness / 2.0, 0.0, abs( d - thickness / 2.0 ) );\n}\n\n\nfloat circle (vec2 coord, float radius)\n{\n    return smoothstep( 0.001, 0.0, length(coord) - radius );\n} \nvec2 trajectory(float l)\n{\n    while (l >= LH + LR + LW + LR + LH + LR + LW + LR) {\n        l = l - (LH + LR + LW + LR + LH + LR + LW + LR);\n    }\n\n    // may use `step` to optimize\n    // TODO: figure out a simpler way to represent the trajectory function\n    if (0.0 <= l && l < LH) {\n        return vec2( W / 2.0, - H / 2.0 + R )\n             + vec2( 0.0, l );\n    }\n\n    else if ( LH <= l && l < LH + LR ) {\n        l = l - LH;\n        return vec2( W / 2.0 - R, H / 2.0 - R)\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR <= l && l < LH + LR + LW) {\n        l = l - LH - LR;\n        return vec2( LW / 2.0 , H / 2.0 )\n             - vec2( l , 0.0 );\n    }\n\n    else if ( LH + LR + LW <= l && l < LH + LR + LW + LR ) {\n        l = l - LH - LW;\n        return vec2( - W / 2.0 + R, H / 2.0 - R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR + LW + LR <= l && l < LH + LR + LW + LR + LH ) {\n        l = l - LH - LW - LR - LR;\n        return vec2( - W / 2.0, H / 2.0 - R )\n             + vec2( 0, - l );\n    }\n\n    else if ( LH + LR + LW + LR + LH <= l && l < LH + LR + LW + LR + LH + LR ) {\n        l = l - (LH + LW + LH);\n        return vec2( - W / 2.0 + R, - H / 2.0 + R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR + LW + LR + LH + LR <= l && l < LH + LR + LW + LR + LH + LR + LW ) {\n        l = l - (LH + LR + LW + LR + LH + LR);\n        return vec2( - W / 2.0 + R, - H / 2.0 )\n             + vec2( l, 0.0 );\n    }\n\n    else if ( LH + LR + LW + LR + LH + LR + LW <= l && l < LH + LR + LW + LR + LH + LR + LW + LR ) {\n        l = l - (LH + LW + LH + LW);\n        return vec2( W / 2.0 - R, - H / 2.0 + R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    return vec2( W / 2.0, - H / 2.0 + R )\n         + vec2( 0.0, 0.0 );\n}\n\n\nvec2 differential(float l) {\n    return trajectory(l + 0.001) - trajectory(l);\n}\n\nfloat distanceFunction(vec2 pos) {\n    if ( W / 2.0 - T / 2.0 < pos.x\n      && pos.x < W / 2.0 + T / 2.0\n      && 0.0 < pos.y\n      && pos.y < LH / 2.0)\n    {\n        return pos.y;\n    }\n    else if ( pos.y > LH / 2.0 && pos.x > H / 2.0 - R )\n    {\n        pos = pos - vec2(LW / 2.0, LH / 2.0);\n        return acos(dot(pos, vec2(1., 0.)) / length(pos)) * R + LH / 2.0;\n    }\n    else if ( pos.y > 0.0 && 0. < pos.x && pos.x < LW / 2.0 )\n    {\n        return LW / 2.0 - pos.x + LH / 2.0 + LR;\n    }\n\n    return 0.0;\n}\n\n\n// 三角波\nfloat period(float phase, float p, float t)\n{\n    float a = LH + LR + LW + LR + LH + LR + LW + LR;\n\n    float scaleT = (t - phase) / p;\n\n    // x \\in [0, 1)\n    float x = fract(scaleT);\n\n    return a * x;\n}\n\n// 正弦波\n// float period()\n// {\n//     return ;\n// }\n\n\nfloat colors(float l)\n{\n    return l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = uv - vec2(0.5, 0.5);\n\n    // Time varying pixel color\n    float colRoundedRectangle = roundedRectangle(pos, vec2(0.4, 0.4), 0.1, 0.02);\n\n    float colStart = circle(pos - trajectory(period(0.0, 3.0, iTime)), 0.01);\n    float colEnd = circle( pos - trajectory(period(0.1, 3.0, iTime)), 0.01);\n\n    float colStart2 = circle(pos - trajectory(period(1.5, 3.0, iTime)), 0.01);\n    float colEnd2 = circle(pos - trajectory(period(1.6, 3.0, iTime)), 0.01);\n\n    // float col = colCircle;\n    float col = colRoundedRectangle * (colStart + colEnd + colStart2 + colEnd2 + distanceFunction(pos) * 2.0);\n\n    // Output to screen\n    fragColor = vec4(col, col / 2.0, 0.0, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}