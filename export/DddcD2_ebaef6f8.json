{"ver":"0.1","info":{"id":"DddcD2","date":"1695506634","viewed":52,"name":"Fork Conformal  radokirov 416","username":"RadoKirov","description":"math behind this conformal mapping - http://www.ams.org/notices/200304/fea-escher.pdf","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["droste","escher","conformalmapping"],"hasliked":0,"parentid":"3sjyWG","parentname":"Conformal Droste effect"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Parameters\nfloat winding = 8.0;\nfloat numSpirals = 12.0;\n\nfloat u_f = 2.0; // scaling\nfloat majorGrid = 2.0;\nfloat minorGrid = 2.0 /* majorGrid */ * 3.0;\n\nfloat speed = 3.0;\n\n// convert from cartisian to polar.\n// returns [r, theta] in x+iy = r e^i * theta\nvec2 polarz(in vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// convert from polar to cartisian.\nvec2 cart(in vec2 c) {\n  return vec2(c.x * cos(c.y), c.x * sin(c.y));\n}\n\nvec2 powz(in vec2 c1, in vec2 c2) {\n  vec2 polarC = polarz(c1);\n\n  // (r * e ^ i theta) ^ (x + i y) = r ^ x * r ^ i y * e ^ i x theta * e ^ - y theta\n  // r ^ x * e ^ - y theta * e ^ i (x theta + log (r) y)\n  // |--------- r -------| * e ^ i |------- theta -----|\n\n  float r = pow(polarC.x, c2.x) * exp(-polarC.y * c2.y);\n  float theta = c2.x * polarC.y + log(polarC.x) * c2.y;\n\n  return cart(vec2(r, theta));\n}\n\nvec3 getcolor(vec2 z) {\n    \n  vec3 col = int(floor(z.x * 1.0) + floor(z.y * 1.0)) % 2 == 0 ? vec3(1) : vec3(0);\n  return col;\n}\n\nvec4 grid(in vec2 uv) {\n  return vec4(getcolor(uv), 1.0);\n}\n\nvec2 conformal(in vec2 uv) {\n  float P = log(u_f) / M_PI / 2.0;\n  vec2 alpha = vec2(winding / 4.0, numSpirals * P);\n  return powz(uv, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 e = conformal(c);\n    \n    float t = iTime / speed;\n    e /= exp(log(u_f) * fract(t / log(u_f)));\n    while (abs(e.x) > 1.0 || abs(e.y) > 1.0) {\n      e /= u_f;\n    }\n    while (abs(e.x) < 1.0 / u_f && abs(e.y) < 1.0 / u_f) {\n      e *= u_f;\n    }\n    \n    fragColor = grid(e + 1.0 / 2.0);\n}","name":"Image","description":"","type":"image"}]}