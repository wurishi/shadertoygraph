{"ver":"0.1","info":{"id":"ld2fzh","date":"1499563623","viewed":440,"name":"Alphabet Soup","username":"KilledByAPixel","description":"Endless pixel fractal zoom using English alphabet. \nI also made a screensaver version that uses real words at http://pixelwords.3d2k.com","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","zoom","alphabet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Alphabet Soup - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.3;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 2.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 26;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet\n 0x01110, 0x11110, 0x01111, 0x11110, 0x11111, 0x11111, 0x01111, 0x11011, 0x11111, 0x01111, 0x11011, 0x11000, 0x01010, 0x11001, 0x01110, 0x11110, 0x01110, 0x11110, 0x01111, 0x11111, 0x11011, 0x11011, 0x10101, 0x10001, 0x10001, 0x11111,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11000, 0x11011, 0x01110, 0x00110, 0x11110, 0x11000, 0x11111, 0x11101, 0x11011, 0x11011, 0x11011, 0x11011, 0x11100, 0x01110, 0x11011, 0x11011, 0x10101, 0x11011, 0x11011, 0x00111,\n 0x11111, 0x11111, 0x11000, 0x11011, 0x11110, 0x11110, 0x11011, 0x11111, 0x01110, 0x10110, 0x11100, 0x11000, 0x11111, 0x11111, 0x11011, 0x11110, 0x11011, 0x11110, 0x11111, 0x01110, 0x11011, 0x11011, 0x11111, 0x01110, 0x01110, 0x01110,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11011, 0x11011, 0x01110, 0x11110, 0x11110, 0x11000, 0x10101, 0x10111, 0x11011, 0x11000, 0x11010, 0x11111, 0x00111, 0x01110, 0x11111, 0x01110, 0x11111, 0x11011, 0x01110, 0x11100,\n 0x11011, 0x11110, 0x01111, 0x11110, 0x11111, 0x11000, 0x01111, 0x11011, 0x11111, 0x01100, 0x11011, 0x11111, 0x10101, 0x10011, 0x01110, 0x11000, 0x01101, 0x11011, 0x11110, 0x01110, 0x01110, 0x00100, 0x01010, 0x10001, 0x01110, 0x11111\n);// A        B        C        D        E        F        G        H        I        J        K        L        M        N        O        P        Q        R        S        T        U        V        W        X        Y        Z\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(-0.02, 0.02, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n   \t\tmix(0.0, 1.0, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n      \t1.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color.x += myColor.x*f;;\n        color.y = max(color.y, myColor.y*f);\n    color.z = max(color.z, myColor.z*pow(f, 1.3));\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += (0.05*uv.y + 0.05*uv.x + 0.05*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.01*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.01*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\tuv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    \n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 0;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    // find a random valid pixel in glyph\n    c -= RandInt(iterations) % c;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x, glyphSize - 1 - y/glyphCount);\n        }\n    }\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}