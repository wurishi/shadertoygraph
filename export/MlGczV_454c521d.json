{"ver":"0.1","info":{"id":"MlGczV","date":"1676590565","viewed":93,"name":"displacement test da yo","username":"uynet","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["displacement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Trus{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n struct Sphere{\n     vec3 pos;\n     float r;\n };\n     struct Box{\n         vec3 pos; \n         \n     };\nstruct Ray{\n    vec3 orig;\n    vec3 dist;\n};\n struct Metaball{\n     vec3 pos;\n};\n\n vec3 L =normalize(vec3(1));\nconst float EPS = 0.001;\nTrus trus;\n\n//trus distancefield\nfloat dist(vec3 p,Trus trus){\n  \n  \n  float d;\n   p -= trus.pos;\n   vec3 p_proj = p-trus.dir*(dot(p,trus.dir));\n   p_proj = trus.r * normalize(p_proj);\n   d = length(p_proj - p)-trus.s;\n   return d;//\n}\n\nfloat dist_box(vec3 p , Box box){\n    //0.1...box size\n    p = abs(p);\n      float y = 0.35;\n    p.x = p.x-y*floor(p.x/y);\n     p.y = p.y-y*floor(p.y/y);\n          p.z = p.z-y*floor(p.z/y);\n    \n   return  length(max(abs(p)-vec3(0.1),0.0));\n}\n\nfloat disp(vec3 p){\n    float f = 50.0*sin(iTime);\n    float a = 0.05 * sin(iTime*1.7);\n    return a*(sin(f*p.x)*cos(f*p.y)*sin(f*p.z));\n}\n\nfloat dist_twist(vec3 p ,Trus trus){\n   \n    float pich = 100.0*sin(iTime);\n    float c = cos(p.y*pich);\n    float s = sin(p.y*pich);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xz,p.y);\n    return dist(q,trus);\n}\n\n\nfloat dist_disp(vec3 p , Trus trus){\n    float d1 = dist(p , trus);\n    float d2 = disp(p);\n    return d1 + d2;\n}\n\n\nfloat dist_s(vec3 p,Sphere sphere){\n   return length(p-sphere.pos)-sphere.r;\n}\n\n\n\nRay march(Ray ray, float dist){\n                        //distance / distination\n    Ray r = ray;\n    r.orig = ray.orig + dist*ray.dist;\n    return r;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\nvec3 rotY(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x* c - v.z * s,\n\t\tv.y ,\n\t\tv.z * c + v.x * s\n\t);\n}\n\n// 法線の計算\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n    dist(p + vec3(EPS, 0.0, 0.0),trus) - dist(p + vec3(0),trus),\n    dist(p + vec3(0.0, EPS, 0.0),trus) - dist(p + vec3( 0),trus),\n    dist(p + vec3(0.0, 0.0, EPS),trus) - dist(p + vec3(0),trus)\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    trus.dir = normalize(vec3(1));\n    trus.dir = rotX(trus.dir,iTime*100.0);\n    trus.pos = vec3(0,0,0);\n    trus.r = 0.1;\n    trus.s = trus.r/4.0 ;\n   \n    \n    Sphere sphere;\n    sphere.pos = vec3(0.0,0,0);\n    sphere.r = 0.11;\n    \n    Box box;\n    box.pos = vec3(0);\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y*=asp;\n    \n    Ray ray;\n    vec3 eye =  vec3(0,0,-1.0);\n   // eye.z -= iTime;\n    ray.orig =eye;\n    ray.dist = vec3(uv,1);\n    \n   // float a = 1.0 *( floor(sin(iTime*10.0)/2.0) + 0.5);\n   //ray.dist = rotX(ray.dist , 90.0);\n  //  ray.orig = rotX(ray.orig , 20.0);\n    //ray.dist = rotY(ray.dist , a);\n  //  ray.orig = rotY(ray.orig , a);\n    \n    \n    float d1;\n    float d2;\n    float d3;\n    \n    float d = 100.0;\n    int t = 0;\n    vec3 col = vec3(0);\n    \n    while(d > EPS){\n        \n        //d1 = dist_s(ray.orig,sphere);\n        //d2 = dist(ray.orig,trus);\n        //d3 =  dist_box(ray.orig,box);\n        float p = (sin( iTime)/2.0+0.5);\n        d = dist_disp(ray.orig,trus);\n        //d = d2;\n        ray = march(ray,d);\n        if(t++>20)break;\n        \n    }\n    if(d<=0.001){\n        vec3 norm =  getNormal(ray.orig);\n        float dif = max(dot(L,norm),0.0);\n        float spe = max(dot(L,reflect(ray.dist,norm)),0.0)*0.1;\n        float amb = 0.4;\n        //float fog = -max(0.4 , ray.orig.z * 10.0);\n       // col = vec3((dif+spe+amb)*(fog+1.0));\n      //   col = vec3((dif+amb));\n        col =0.5+norm/2.0;\n        //col -= length(eye - ray.orig)*length(eye - ray.orig)*0.1;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}