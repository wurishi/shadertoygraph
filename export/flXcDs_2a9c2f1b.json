{"ver":"0.1","info":{"id":"flXcDs","date":"1648890271","viewed":55,"name":"Shader 学习 004 - 条状进度条值离散","username":"Liuary","description":"现在进度条的值是离散的，也即进度不是连续的，按照每块的大小进行","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 得到 UV\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // 通过对时间使用正弦函数，得到一个变化的值，处理后这个值处于[0.f, 1.f]\n    float val = (sin(iTime / 3.f) + 1.f) / 2.f;\n\n    // 分成32段\n    float pieces = floor(32.f);\n\n    // 用 sin 函数来分段\n    // 不理解为什么显示的段数不对\n    float piecColor = ceil(sin(uv.x * pieces * 6.f));\n\n    // 离散值\n    float discreteVal = floor(pieces * val) / pieces;\n    \n    // 用离散值来计算要显示的区域\n    float ans = floor(1.f - uv.x + discreteVal);\n\n    // 输出值和分段的积\n    fragColor = vec4(vec3(ans * piecColor), 1.f);\n}","name":"Image","description":"","type":"image"}]}