{"ver":"0.1","info":{"id":"MfjBDh","date":"1724888590","viewed":24,"name":"4d sinapsis","username":"cyberhens","description":"4D Sinapsis es una pieza de arte digital creada a través de técnicas de raymarching, que explora la convergencia entre matemáticas, ruido fractal en cuatro dimensiones, y efectos holográficos.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","4d","cyberhens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265359\n\n// Global variables for randomization\nfloat seed;\nvec3 color1, color2, color3;\n\n// Hash function for pseudo-random numbers\nfloat hash(float n) { return fract(sin(n) * 43758.5453123); }\n\n// 4D noise function\nfloat noise4D(vec4 p) {\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = i.x + i.y*157.0 + 113.0*i.z + 137.0*i.w;\n    return mix(\n        mix(mix(mix(hash(n+0.0),hash(n+1.0),f.x),\n                mix(hash(n+157.0),hash(n+158.0),f.x),f.y),\n            mix(mix(hash(n+113.0),hash(n+114.0),f.x),\n                mix(hash(n+270.0),hash(n+271.0),f.x),f.y),f.z),\n        mix(mix(mix(hash(n+137.0),hash(n+138.0),f.x),\n                mix(hash(n+294.0),hash(n+295.0),f.x),f.y),\n            mix(mix(hash(n+250.0),hash(n+251.0),f.x),\n                mix(hash(n+407.0),hash(n+408.0),f.x),f.y),f.z),f.w);\n}\n\n// 4D fractal function\nfloat fractal4D(vec4 p) {\n    float scale = 1.0;\n    float sum = 0.0;\n    for (int i = 0; i < 8; i++) {\n        sum += abs(noise4D(p * scale)) / scale;\n        scale *= 2.0;\n        p = p * 2.0 + vec4(1.0, 0.5, -0.5, -1.0);\n    }\n    return sum;\n}\n\n// Distance function for the 4D fractal\nfloat getDist(vec3 p) {\n    vec4 p4 = vec4(p, iTime * 0.1);\n    float d = fractal4D(p4) - 0.5;\n    d *= 0.5;\n    return d;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    return normalize(n);\n}\n\n// Main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n    \n    // Lighting\n    vec3 lightPos = vec3(5.0 * sin(iTime), 5.0 * cos(iTime), -5.0);\n    vec3 l = normalize(lightPos - p);\n    float diff = max(dot(n, l), 0.0);\n    \n    // Holographic effect\n    float holographic = sin(dot(n, rd) * 10.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Color based on position and normal\n    vec3 col = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    col *= diff;\n    col += holographic * color3;\n    col += color1 * fractal4D(vec4(p * 0.1, iTime * 0.05));\n    col += color2 * fractal4D(vec4(n * 0.2, iTime * 0.1));\n    \n    // Fog\n    col = mix(col, vec3(0.1), 1.0 - exp(-0.01 * d * d));\n    \n    return col;\n}\n\n// Camera setup\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Screen coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Seed for randomization\n    seed = hash(iTime);\n    \n    // Random colors\n    color1 = vec3(hash(seed), hash(seed+1.0), hash(seed+2.0));\n    color2 = vec3(hash(seed+3.0), hash(seed+4.0), hash(seed+5.0));\n    color3 = vec3(hash(seed+6.0), hash(seed+7.0), hash(seed+8.0));\n    \n    // Camera setup\n    vec3 ro = vec3(3.0 * sin(iTime * 0.1), 2.0, 3.0 * cos(iTime * 0.1));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 cam = camera(ro, ta);\n    \n    // Ray direction\n    vec3 rd = cam * normalize(vec3(uv, 1.0));\n    \n    // Render\n    vec3 col = render(ro, rd);\n    \n    // Tonemapping and gamma correction\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n    \n    // Output\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}