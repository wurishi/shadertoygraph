{"ver":"0.1","info":{"id":"dlyczc","date":"1700489770","viewed":53,"name":"starFrame","username":"darkfox","description":"starFrame.\nThis is a transplant of a work I created in the past. The comments are in Japanese because translation is troublesome. sorry.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["glsl","iteration","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ユニフォーム\nuniform vec2 u_resolution;\nuniform float u_count;\n// 定数\nconst float pi = 3.14159;\nconst float TAU = atan(1.0) * 8.0;\nconst float eps = 0.00001;\nconst vec3 ex = vec3(1.0, 0.0, 0.0);\nconst vec3 ey = vec3(0.0, 1.0, 0.0);\nconst vec3 ez = vec3(0.0, 0.0, 1.0);\n// 色\nconst vec3 silver = vec3(0.5);\nconst vec3 gold = vec3(0.85, 0.67, 0.14);\n// ベクトル取得関数\nvec2 fromAngle(float t){ return vec2(cos(t), sin(t)); }\n// 回転\nvoid rotX(out vec3 p, float theta){\n  p.yz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\nvoid rotY(out vec3 p, float theta){\n  p.zx *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\nvoid rotZ(out vec3 p, float theta){\n  p.xy *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n// 最初のfold.\n// x=y,y=z,z=xでくるくるして6分割、z>|x|かつz>|y|に落とす処理。\nvec3 topFold(vec3 p){\n  if(p.z < p.x){ p.xz = p.zx; }\n  if(p.z < p.y){ p.yz = p.zy; }\n  if(p.z < -p.x){ p.xz = -p.zx; }\n  if(p.z < -p.y){ p.yz = -p.zy; }\n  return p;\n}\n\n// 基本領域のはじっこに0がくるやつ（0～pi/n）\nvec2 dihedral_bound(vec2 p, float n){\n  float k = pi / n;\n  vec2 e1 = vec2(0.0, 1.0);\n  vec2 e2 = vec2(sin(k), -cos(k));\n  for(float i = 0.0; i < 99.0; i += 1.0){\n    if(i == n){ break; }\n    p -= 2.0 * min(dot(p, e1), 0.0) * e1;\n    p -= 2.0 * min(dot(p, e2), 0.0) * e2;\n  }\n  return p;\n}\n\n// hsbで書かれた(0.0～1.0)の数値vec3をrgbに変換する魔法のコード\t\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvec3 getRGB(vec3 col){ return getRGB(col.x, col.y, col.z); }\n\n// 角柱\nfloat polyBar(vec3 p, vec3 e, float r, float n){\n  vec3 e1;\n  if(abs(e.x) > 0.0){ e1 = normalize(vec3(e.y, -e.x, 0.0)); }else{ e1 = normalize(vec3(0.0, e.z, -e.y)); }\n  vec3 e2 = cross(e, e1);\n  float t = dot(p, e1) - r;\n  vec3 q;\n  float k = pi * 2.0 / n;\n  for(float i = 1.0; i < 99.0; i += 1.0){\n    if(i == n){ break; }\n    q = cos(k * i) * e1 + sin(k * i) * e2;\n    t = max(t, dot(p, q) - r);\n  }\n  return t;\n}\n// 2D\n// 星型\nfloat star(vec2 p, float r){\n  p = dihedral_bound(p, 5.0);\n  vec2 e = fromAngle(0.4 * pi);\n  return dot(p - vec2(r, 0.0), e);\n}\n// 色変え\n// 0:min.つまり合併。重なっているときは近い方を採用するので。\n// 1ってなんだっけ・・あ、max？んー。共通部分じゃないの。平面でスライスするのとか。で、断面の色とか指定する。\n// 新しく追加された距離関数に対して、そっちの方が大きかったらそっちで置き換える。\n// これをたとえば平面で使うと平面の向こう側だけが描画されてスライスができる（はず）。\n// つまりこの1で指定された距離関数のオブジェクトに対してそれと共通であるような\n// それまでに描画されたオブジェクトが得られると。\n// だからベースはそれまでのオブジェクトで、それと新しいオブジェクトとの共通部分を切り取って描画するのね。\n// 最後はくりぬき。これは逆に、新しいオブジェクトのところだけカットする技術。\n// 何のことはない、新しいオブジェクトのdを反転させて補集合の距離関数を取得してそれと1をやるだけ。つまり\n// 1でマイナスにして放り込めばいいんだけどまあ別に用意しましょうって話。\nvoid updateDist(out vec3 col, out float t, vec3 newCol, float d, int id){\n  if(id == 0){\n    float newD = min(t, d);\n    if(newD < t){ col = newCol; t = newD; }\n  }\n  if(id == 1){\n    float newD = max(t, d);\n    if(newD > t){ col = newCol; t = newD; }\n  }\n  if(id == 2){\n    float newD = max(t, -d);\n    if(newD > t){ col = newCol; t = newD; }\n  }\n}\n// 距離の総合関数\nvec4 dist(vec3 p){\n  rotY(p, pi * iTime*60.0 * 0.001);\n  rotZ(p, pi * iTime*60.0 * 0.0005);\n  vec3 q1 = fract(p) - 0.5; // -0.5～0.5に正規化することで格子を実現する\n  q1 = topFold(q1);\n  float t = polyBar(q1, ez, 0.08, 4.0); // polyBar１本にできる\n  vec3 col = silver;\n  vec3 q2 = 0.2 * fract(p * 5.0) - 0.1; // -0.2～0.2にして格子を作り、やや小さめの格子だが、これでマイナスする。\n  q2 = topFold(q2);\n  rotZ(q2, -pi * 0.1);\n  float starPole = max(abs(q2.z) - 1.5, star(q2.xy, 0.06));\n  updateDist(col, t, gold, starPole, 2); // polyBar１本にできる\n  return vec4(col, t);\n}\n// レイマーチング\nvec4 march(vec3 eye, vec3 ray){\n  const float threshold = 0.001;\n  const float far = 20.0;  // 視認できる限界\n  const int limit = 64;\n  vec3 col = vec3(0.0);\n  float t = 0.0;\n  float d;\n  vec3 p = eye;\n  for(int i = 0; i < limit; i++){\n    col = dist(p).xyz;\n    d = dist(p).w;\n    if(d < threshold || d > far){ break; }\n    p += d * ray;\n    t += d;\n  }\n  if(d < threshold){ return vec4(col, t); }\n  return vec4(col, -1.0);\n}\n// 法線取得\nvec3 getNormal(vec3 pos){\n  float dx = dist(pos + eps * ex).w - dist(pos - eps * ex).w;\n  float dy = dist(pos + eps * ey).w - dist(pos - eps * ey).w;\n  float dz = dist(pos + eps * ez).w - dist(pos - eps * ez).w;\n  return normalize(vec3(dx, dy, dz));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // こうすると今横長なので上下±1.0みたいになる。\n  vec2 p = (fragCoord.xy*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  // 視点を用意する。z軸正方向5.0くらいで。\n  vec3 eye = vec3(0.0, 0.0, 5.0);\n  // スクリーンは目の前2.0くらいのところにあるイメージ。つまりz=3.0の平面の中にあるわけね。\n  // その中に点pがあって、eyeからpに向かう線がその先にある物体に突き刺さって色とか取得してスクリーンに落とす。\n  float d = 2.0;\n  // で、距離が2.0で、そこに向かうベクトルを・・する。\n  vec3 ray = normalize(vec3(p, d) - eye);\t\n  // それと別に光のベクトルを用意しておく感じ。これは刺さる方向と逆のベクトルにする。\n  vec3 light = normalize(vec3(1.0));\n  // レイマーチングする。\n  // 仕組み。まず視点eyeにおける距離関数の値を調べる。その分だけ進む。直進する。\n  // それで届かなかったらその位置からまた計算してその分だけ進む。それを定められた回数繰り返し、\n  // 閾値を下回ったら到達したとみなす。そこにおける法線ベクトルを距離関数から算出し、\n  // 光のベクトルと内積を取って明るさを調節しつつそこにおける色をスクリーンに映し出して処理終了。\n  // とりあえず色はいいや\n  // やっぱ色付けたいよなぁ\n  vec4 data = march(eye, ray);\n  float t = data.w;\n  vec3 col = vec3(0.0);\n  if(t > 0.0){\n    col = data.xyz; \n    vec3 pos = eye + t * ray;\n    // posにおける法線\n    vec3 n = getNormal(pos);\n    // colをnとlightで補正する\n    col *= clamp(dot(n, light), 0.2, 1.0);\n  }\n  float a = 1.0-t/20.0;\n  fragColor = vec4(col*a, a);\n}","name":"Image","description":"","type":"image"}]}