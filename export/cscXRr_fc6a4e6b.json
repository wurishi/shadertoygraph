{"ver":"0.1","info":{"id":"cscXRr","date":"1679278132","viewed":83,"name":"f(x,y) - 2D functions","username":"JasonD","description":"Testing f(x,y) 2D function rendering on the GPU, similar to my CPU-drive program:\nhttps://youtube.com/playlist?list=PLjnbT4UISq0YLgynFSpLzml4BMC6TDZL2\n\nINSTRUCTIONS:\nEdit float f_xy() to test your own functions.\nClick and move mouse to zoom out.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","testing","graph","fx","function","convenience","verification","fxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n// http://thefirstpixel.com/\n//\n// f(x,y)\n// March 19, 2023\n// \n// Follow up to: https://www.shadertoy.com/view/ldyXD1\n//               f(x) - 1D functions\n//\n// Based on my CPU-driven version:\n// https://youtube.com/playlist?list=PLjnbT4UISq0YLgynFSpLzml4BMC6TDZL2\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n//#define RENDER_METHOD_1  // show red & blue for various sides of the equation\n#define RENDER_METHOD_2  // show white lines for the equation solutions\n\n#define RENDER1_COLOR1 vec3(0.3, 0.3, 1.0)\n#define RENDER1_COLOR2 vec3(1.0, 0.3, 0.3)\n\n#define RENDER2_LINE  vec3(1.0, 1.0, 1.0)\n#define RENDER2_EMPTY vec3(0.0, 0.0, 0.7)\n#define RENDER2_LINE_THICKNESS 2.0  // 1.0 = exact pixel perfect render\n\n#define GRID_DIM_PERCENTAGE 0.85\n\n#define STANDARD_ZOOM 4.0     // 4 = show -2.0..+2.0 at least\n#define ZOOM_MOUSE_POWER 5.0\n\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.141592653589793238462643383\n\n\n// ---- METHODS ----------------------------------------------------------------\n\n// ================================================================\n// =    ENTER f(x,y) FUNCTION HERE                                =\n// ================================================================\nfloat f_xy(float x, float y)\n{\n    // 1. cirlce, radisu 3\n    //return (y * y + x * x - 9.);\n    \n    // 2. https://www.youtube.com/watch?v=XeFtcZXqu7w\n    float t = iTime;\n    float sinT = sin(t);\n    return\n        cos(sin(y * t + x) + cos(t - t * x)) +\n        sin(cos(t - y * x) - sin(y + x - t)) +\n        tan(cos(x * y - sinT + x) - sin(x * y - sinT * y));\n}\n\n// ================================================================\n// ================================================================\n// ================================================================\n\nvec3 f_uv(vec2 uv, float invRes)\n{\n\n#ifdef RENDER_METHOD_1\n    // color inside or out\n    return (f_xy(uv.x, uv.y) > 0. \n        ? RENDER1_COLOR1 \n        : RENDER1_COLOR2);\n#endif        \n\n#ifdef RENDER_METHOD_2\n    // 4x the work: determine if pixel is at boundaru\n    // it woudn't be 4x the work if I could reuse the data\n    // from adjacent pixels\n    float halfPix = invRes * 0.5;\n    return (\n        ((f_xy(uv.x - halfPix, uv.y) < 0.) != (f_xy(uv.x + halfPix, uv.y) < 0.)) || \n        ((f_xy(uv.x, uv.y - halfPix) < 0.) != (f_xy(uv.x, uv.y + halfPix) < 0.))\n        )\n        ? RENDER2_LINE\n        : RENDER2_EMPTY;\n#endif\n\n}\n\nvec3 addGrid(vec2 uv, vec3 color)\n{\n\treturn\n        ((mod(uv.x, 2.0) < 1.0 ? 1 : 0) +\n         (mod(uv.y, 2.0) < 1.0 ? 1 : 0) == 1\n    \t\t? color * GRID_DIM_PERCENTAGE\n            : color);\n}\n\n\n// ---- MAIN ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    float minRes = min(iResolution.x, iResolution.y);\n    float invRes = 1. / minRes;  // size of a single pixel\n    vec2 uv = fragCoord * invRes;\n    \n    // get mouse\n    vec2 m = iMouse.xy / minRes;\n    if (iMouse.z < 0.5) {\n    \tm = iResolution.xy / minRes / 2.;\n    }\n    \n    // center point on screen\n    vec2 center = (iResolution.xy / minRes) / 2.;\n    \n    // adjust for center\n    uv -= center;\n    m -= center;\n    \n    // adjust for mouse\n    uv -= m;\n    \n    // zoom\n    // normal zoom of 1.0 shows at least -0.5 .. +0.5 in one of the dimensions\n    float zoom = STANDARD_ZOOM * 2.;\n    float mouseZoom = 1.0 + sqrt(m.x*m.x + m.y*m.y) * ZOOM_MOUSE_POWER;\n    float totalZoom = zoom * mouseZoom;\n    uv.xy *= totalZoom;\n\n    // f(x)\n    vec3 color = f_uv(uv, invRes * totalZoom * RENDER2_LINE_THICKNESS);\n        \n    // show x-axis and y-axis\n    float a = 0.002 * totalZoom;\n    float b = a * 2.;    \n    color *= smoothstep( a, b, abs(uv.x) );\n    color *= smoothstep( a, b, abs(uv.y) );\n    \n    // add grid\n    color = addGrid(uv, color);\n   \n    // result\n\tfragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}