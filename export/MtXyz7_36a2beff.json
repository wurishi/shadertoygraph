{"ver":"0.1","info":{"id":"MtXyz7","date":"1504033034","viewed":1021,"name":"Steep Parallax Mapping","username":"Assossa","description":"Left click and drag horizontally to change occlusion amount.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","parallax","steepparallax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float floorHeight = -1.0;\nconst vec3 up = vec3(0, 1, 0);\nconst vec2 floorSize = vec2(3.0, 2.0);\nconst vec3 lightPosition = vec3(0.0, 3.0, 0.5);\n\nvec3 background(float t, vec3 rd) {\n    vec3 light = normalize(vec3(sin(t), 0.2, cos(t)));\n    float sun = max(0.0, dot(rd, light));\n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) +\n        pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +\n        pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nfloat floorHit(vec3 o, vec3 d, float height) {\n    float du = dot(d, up);\n    if(du == 0.0) return -1.0;\n    \n    float dist = dot(vec3(0, height, 0) - o, up) / du;\n    if(dist < 0.0) return -1.0;\n    \n    return dist;\n}\n\nfloat sphereHit(vec3 ray, vec3 dir, vec3 center, float radius) {\n    vec3 rc = ray - center;\n    float c = dot(rc, rc) - (radius * radius);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 spherePos = vec3(sin(iTime * 0.5), 0.0, 0.0);\n    \n    float floorDist = floorHit(ro, rd, floorHeight);\n    float sphereDist = sphereHit(ro, rd, spherePos, 0.8);\n    \n    if(floorDist > 0.0 && (floorDist < sphereDist || sphereDist < 0.0)) {\n        float dist = floorDist;\n        ro += rd * dist;\n\n        if(dist < 0.0 || abs(ro.x) > floorSize.x || abs(ro.z) > floorSize.y) {\n            fragColor = vec4(background(10.0, rd), 1.0);\n            return;\n        }\n\n        float parallaxScale = (iMouse.x + 0.6) * 0.015;\n\n        while(1.0 - (ro.y - floorHeight) * -parallaxScale > texture(iChannel1, ro.xz).r) {\n            ro += rd * 0.001;\n\n            if(abs(ro.x) > floorSize.x || abs(ro.z) > floorSize.y) {\n                fragColor = vec4(background(10.0, rd), 1.0);\n                return;\n            }\n        }\n        \n        vec3 col = texture(iChannel0, ro.xz).xyz;\n        float ao = min(texture(iChannel1, ro.xz).r * 2.0, 1.0);\n        float shadow = 1.0;\n        \n        {\n            vec3 rd = normalize(lightPosition - ro);\n            float sphereDist = sphereHit(ro, rd, spherePos, 0.8);\n            if(sphereDist > 0.0) {\n            \tshadow = 0.2;\n                ao = min(1.0, ao * 1.5);\n            }\n        }\n\n        fragColor = vec4(col * ao * shadow, 1.0);\n    } else if(sphereDist > 0.0) {\n        float dist = sphereDist;\n        ro += rd * dist;\n        vec3 nml = normalize(ro - spherePos);\n        vec3 col = vec3(1) / 3.14159 * 3.0 * max(0.0, dot(nml, normalize(lightPosition - rd)));\n        \n        //hitColor = hitObject->albedo / M_PI * light->intensity * light->color * std::max(0.f, hitNormal.dotProduct(L));\n        fragColor = vec4(col + 0.05, 1.0);\n    } else {\n        fragColor = vec4(background(10.0, rd), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}