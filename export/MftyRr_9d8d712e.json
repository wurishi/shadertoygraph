{"ver":"0.1","info":{"id":"MftyRr","date":"1730306627","viewed":31,"name":"GOL by JoostAB","username":"JoostAB","description":"My first public shader, just another GoL","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["conway","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* /==============================================================\\ */\n/* ||           ____                                             || */\n/* ||          / ___|___  _ ____      ____ _ _   _ ___           || */\n/* ||         | |   / _ \\| '_ \\ \\ /\\ / / _` | | | / __|          || */\n/* ||         | |__| (_) | | | \\ V  V / (_| | |_| \\__ \\          || */\n/* ||          \\____\\___/|_| |_|\\_/\\_/ \\__,_|\\__, |___/          || */\n/* ||                                        |___/               || */\n/* ||                                                            || */\n/* ||  ____                               __   _     _  __       || */\n/* || / ___| __ _ _ __ ___   ___    ___  / _| | |   (_)/ _| ___  || */\n/* ||| |  _ / _` | '_ ` _ \\ / _ \\  / _ \\| |_  | |   | | |_ / _ \\ || */\n/* ||| |_| | (_| | | | | | |  __/ | (_) |  _| | |___| |  _|  __/ || */\n/* || \\____|\\__,_|_| |_| |_|\\___|  \\___/|_|   |_____|_|_|  \\___| || */\n/* ||                                                            || */\n/* || By JoostAB                                                 || */\n/* ||                                                            || */\n/* || My first public shader, just another GoL                   || */\n/* ||                                                            || */\n/* || - All drawing and buffering is done in Buffer A            || */\n/* || - Settings can be manipulated in Common                    || */\n/* ||                                                            || */\n/* \\==============================================================/ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Just remove state from pixel before drawing\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Cell {\n    vec3 color;\n    float state;\n};\n\nvec3 lifeColor() {\n#if COLORMODE == CM_RAINBOW\n    return rainbow;\n#elif COLORMODE == CM_STEP\n    int m = int(mod(iTime/2.0,3.0));\n    switch(m) {\n        case 0:\n            return C_RED;\n        case 1:\n            return C_GREEN;\n        case 2:\n            return C_BLUE;\n        default:\n            return C_WHITE;\n    }\n#else\n    return C_WHITE;\n#endif\n}\n\nvec3 deadColor() {\n    return C_BLACK;\n}\n\nCell newCell() {\n    return Cell(lifeColor(), STATE_BORN);\n}\n\nCell deadCell() {\n    return Cell(deadColor(), STATE_DEAD);\n}\n\nfloat binaryNoise(in vec2 pos, in float seed) {\n    return (fract(tan(distance(pos*1.618034, pos)*seed)*pos.x) < 0.8) ? 0.0 : 1.0;\n}\n\nCell randCell(vec2 pos) {\n    float seed = fract(iTime);\n    if (binaryNoise(pos,seed) == 1.0) {\n        return newCell();\n    } else {\n        return deadCell();\n    }\n}\n\nCell getCell(vec2 pos) {\n    #ifdef CONTINUOUS\n    pos = mod(pos,RES.xy);\n    #endif\n    vec4 t = texelFetch(iChannel0, ivec2(pos),0);\n    return Cell(t.rgb,t.w);\n}\n\nbool isAlive(Cell cell) {\n    return cell.state >= STATE_BORN;\n}\n\nint countNeighbours(vec2 pos) {\n    int c = 0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 p = vec2(x,y);\n            if (p != vec2(0.0)) {\n                if (isAlive(getCell(pos + p))) c++;\n            }\n        }\n    }\n    return c;\n}\n\nvec4 drawCell(Cell cell) {\n    return vec4(cell.color,cell.state);\n}\n\nvoid aging(inout Cell cell, int neighbours) {\n    float orgState = cell.state;\n\n    float age = isAlive(cell)\n        ? cell.state - STATE_BORN\n        : 0.0;\n\n    cell.state = neighbours == 3\n        ? STATE_BORN\n        : neighbours == 2\n            ? STATE_BORN\n            : STATE_DEAD;\n\n    if (age > MAX_AGE) cell.state = STATE_DEAD;\n\n    if (isAlive(cell)) {\n        cell.state = STATE_BORN + age;\n    }\n\n    /*\n    cell.color = isAlive(cell) //cell.state == STATE_ALIVE \n        ? orgState >= STATE_BORN\n            ? cell.color\n            : lifeColor() \n        : deadColor();\n        */\n    cell.color = isAlive(cell)\n        ? cell.state == STATE_BORN\n            ? lifeColor()\n            : cell.color\n        : deadColor();\n\n\n}\nvoid b3s23(inout Cell cell, int neighbours) {\n    float orgState = cell.state;\n    \n    cell.state = neighbours == 3 \n        ? STATE_BORN \n        : neighbours == 2 \n            ? orgState \n            : STATE_DEAD;\n\n    cell.color = isAlive(cell) //cell.state == STATE_BORN \n        ? orgState == STATE_BORN\n            ? cell.color\n            : lifeColor() \n        : deadColor();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    #ifdef INITNOISE\n    if (iFrame == 0) {\n        fragColor = drawCell(randCell(fragCoord));\n        return;\n    } \n    #endif\n\n    Cell curr = getCell(fragCoord);\n    int neighBours = countNeighbours(fragCoord);\n    \n    // b3s23 is the standard Conway algorithm\n    b3s23(curr, neighBours);\n    // Try this one to have cells die after a certain amount of generations \n    // (Does not work yet)\n    //aging(curr, neighBours);\n    \n    #ifdef MOUSEDISTURB\n    vec4 m = iMouse / (RES.x * RESFACT);\n    vec2 p = fragCoord / RES.x;\n    if (m.z > 0.0) {\n        if (length(p-m.xy) < MOUSESIZE) {\n            curr = randCell(fragCoord);\n        }\n    }\n    #endif\n    \n    fragColor = drawCell(curr);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// If defined, frame 0 will fill the screen with random life cells. \n#define INITNOISE\n\n// If defined, cells will overflow from the edge of the screen to the other side\n#define CONTINUOUS\n\n// If defined, The mouse (when button down) will add disturbance\n#define MOUSEDISTURB\n#define MOUSESIZE 0.04\n// Different mmodes to generate life color\n#define CM_DEFAULT 0\n#define CM_STEP 1\n#define CM_RAINBOW 2\n#define COLORMODE CM_RAINBOW\n\n\n// Some values I was playing with to scale the world\n#define RESFACT (1.0)\n#define RES (iResolution*RESFACT)\n\n// Some colors\n#define C_BLACK vec3(0.0,0.0,0.0)\n#define C_RED vec3(1.0,0.0,0.0)\n#define C_GREEN vec3(0.0,1.0,0.0)\n#define C_BLUE vec3(0.0,0.0,1.0)\n#define C_WHITE vec3(1.0)\n\n// The states\n#define STATE_AGE 0.001\n#define STATE_BORN STATE_AGE\n#define STATE_DEAD 0.000\n#define MAX_GENERATIONS 360\n#define MAX_AGE (float(MAX_GENERATIONS) * STATE_AGE)\n\n// Macro to generate a rainbowcolor over time\n#define rainbow clamp( abs(mod(iTime+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 )\n\n","name":"Common","description":"","type":"common"}]}