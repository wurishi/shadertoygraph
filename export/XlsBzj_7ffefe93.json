{"ver":"0.1","info":{"id":"XlsBzj","date":"1513073466","viewed":312,"name":"target UI","username":"modelain","description":"http://www.randomghost.com/post/45955195639","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","target","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://www.randomghost.com/post/45955195639\n\n#define red vec3(.933,.255,.106)\n#define glow 2.0\n\nfloat circle(in vec2 uv, in vec2 p, in float r, in float width){\n    float dist = length(uv - p);\n    \n\treturn \n        (1. - smoothstep(r - glow, r + glow, dist)) -\n        (1. - smoothstep((r - width) - glow, (r - width) + glow, dist));\n}\n\nfloat sector(in vec2 uv, in vec2 p, in float r, in float width, in float start, in float end){\n    float dist = length(uv - p);\n    float angle = degrees(atan(uv.y - p.y, uv.x - p.x)) + 180.;\n    \n\treturn \n        ((1. - smoothstep(r - glow, r + glow, dist)) -\n        (1. - smoothstep((r - width) - glow, (r - width) + glow, dist))) * \n        smoothstep(start - glow, start + glow, angle) * \n        (1. - smoothstep(end - glow, end + glow, angle));\n}\n\nfloat rect(in vec2 uv, in vec4 p){\n    float t = p.y; // top\n    float r = p.x + p.z; // right\n    float b = p.y + p.w; // bottom\n    float l = p.x; // left\n        \n    return\n        smoothstep(l - glow, l, uv.x) *\n        (1. - smoothstep(r, r + glow, uv.x)) *\n        smoothstep(t - glow, t, uv.y) *\n        (1. - smoothstep(b, b + glow, uv.y));\n}\n\n// http://thebookofshaders.com/edit.php#06/easing.frag\nfloat expoOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat expoIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat expoInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n} \n\nvoid rotate(inout vec2 uv, in vec2 center, inout float rotation, in float angle){\n    float a = radians(angle - rotation);\n    \n    rotation = angle;\n    \n    uv -= center;\n    uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n    uv += center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy / 2.;\n    center.y -= 10.;\n    vec3 color = vec3(0.);\n    float rotation = 0.;\n    float t = fract(iTime * .3);\n    \n    color += circle(uv, center, 65., 3.) * red;\n    \n    float inRotation = 0.;\n    inRotation -= 120. * expoInOut(smoothstep(.6, 1., t)) * step(.6, t) * (1. - step(1., t));\n    \n    rotate(uv, center, rotation, 50. + inRotation);\n\n    float s1 = sector(uv, center, 64., 6., 0., 80.);\n    color = mix(color, red, s1);\n    \n    float s2 = sector(uv, center, 64., 6., 120., 200.);\n    color = mix(color, red, s2);\n    \n    float s3 = sector(uv, center, 64., 6., 240., 320.);\n    color = mix(color, red, s3);\n    \n    float outRotation = 0.; \n    outRotation -= (120. * 2.) * expoInOut(smoothstep(.7, .9, t)) * step(.7, t) * (1. - step(.9, t));\n    \n    rotate(uv, center, rotation, sin(iTime * 3.) * 60. + outRotation);\n\n    float outRadius = 80.;\n    outRadius -= 35. * expoInOut(smoothstep(.3, .5, t)) * step(.3, t) * (1. - step(.5, t));\n    outRadius -= 35. * step(.5, t);\n    outRadius += 35. * expoInOut(smoothstep(.7, 1., t)) * step(.7, t) * (1. - step(1., t));\n    \n    float s7 = sector(uv, center, outRadius, 5., 0., 60.);\n    color = mix(color, red * .4, s7);\n    \n    float s8 = sector(uv, center, outRadius, 5., 120., 180.);\n    color = mix(color, red * .4, s8);\n    \n    float s9 = sector(uv, center, outRadius, 5., 240., 300.);\n    color = mix(color, red * .4, s9);\n    \n    rotate(uv, center, rotation, 45. + outRotation);\n    \n    float s4 = sector(uv, center, outRadius, 5., 0., 90.);\n    color = mix(color, red, s4);\n    \n    float s5 = sector(uv, center, outRadius, 5., 120., 210.);\n    color = mix(color, red, s5);\n    \n    float s6 = sector(uv, center, outRadius, 5., 240., 330.);\n    color = mix(color, red, s6);rotate(uv, center, rotation, 0.);\n    \n    float rectY = center.y + 75.;\n    rectY += 180. * (1. - expoOut(min(t, .3) / .3));\n    rectY -= 65. * expoInOut(smoothstep(.4, .6, t)) * step(.4, t) * (1. - step(.6, t));\n    rectY -= 65. * step(.6, t); \n    rectY += (180. + 65.) * expoIn(smoothstep(.7, .9, t) * step(.7, t * (1. - step(.9, t))));\n    rectY += (180. + 65.) * step(.9, t);\n    \n    float rectColorAlpha = 1.;\n    rectColorAlpha -= (1. - step(.03, t));\n    rectColorAlpha -= step(.9, t);\n    rectColorAlpha -= (1. - step(center.y + 15., rectY)) * ceil(sin(iTime * 100.));\n    rectColorAlpha = clamp(rectColorAlpha, 0., 1.);\n    \n    vec3 rectColor = mix(vec3(0.), red, rectColorAlpha);\n    \n    float r1 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r1);\n    \n    rotate(uv, center, rotation, 120.);\n    \n    float r2 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r2);\n    \n    rotate(uv, center, rotation, -120.);\n    \n    float r3 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r3);\n    \n\tfragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}