{"ver":"0.1","info":{"id":"NslyzX","date":"1642453333","viewed":176,"name":"Modular Multiplication_","username":"Envy24","description":"Sources:\n https://www.youtube.com/watch?v=S0boNB8fxIY\n https://github.com/darkfrei/love2d-lua-tests/blob/main/modular-multiplication/main.lua","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["multiplication","modular"],"hasliked":0,"parentid":"NdlyzX","parentname":"Capsule / Line SDF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                        iResolution\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = TEXF0(SC);      \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Returns smooth signed distance to capsule.\n*/\nfloat capsuleSMSDF(\n    in vec2 P,   // Sample coordinates\n    in vec2 B,   // Capsule begin coordinates\n    in vec2 E,   // Capsule end coordinates\n    in float R,  // Thickness\n    in float SM) // Smoothness\n{\n    vec2 BP = P - B; // from B to P\n    vec2 BE = E - B; // from B to E\n    \n    // dot(SP, SE) - length of projection SP to SE.\n    // dot(SE, SE) - capsule squared length.\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Colsest point on line BE * t to point P.\n    vec2 K = BP - BE * t;\n\n    float sdf = sqrt(dot(K, K)) - R;\n\n    return smoothstep(-SM, SM, sdf);\n    //return smoothstep(-SM, SM, abs(sdf)); // outline\n}\n\n/*\n    Returns squared signed distance to capsule.\n*/\nfloat capsuleSQSDF(\n    in vec2 P,   // Sample coordinates\n    in vec2 B,   // Capsule begin coordinates\n    in vec2 E)   // Capsule end coordinates\n{\n    vec2 BP = P - B; // from B to P\n    vec2 BE = E - B; // from B to E\n    \n    // dot(SP, SE) - length of projection SP to SE.\n    // dot(SE, SE) - capsule squared length.\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Colsest point on line BE * t to point P.\n    vec2 K = BP - BE * t;\n    \n    return dot(K, K);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define R                        iResolution\n#define TO_RAD                   0.017453292519943295                 // Convert degrees to radians\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TAU                      6.2831853071795862\n#define CS(a)                    vec2(cos(a), sin(a))\n#define INITIALLY_FAR            9e30\n\nfloat calc_module(int frameIdx)\n{\n    float framesToTransition = (360.0 + log2(float(frameIdx) * 100.0));\n    return 2.0 + floor(float(frameIdx - 1) / framesToTransition);\n}\n\nvec4 sceneA(in vec2 SC)\n{   \n    // Data from previous frame.\n    vec4 prevColor = TEXF0(SC);\n    float prevModule = prevColor.a;  \n\n    float module = calc_module(iFrame); \n    float phaseStep = float(iFrame - 1) * 3.14;\n    float phase0 = phaseStep * TO_RAD;\n    float phase1 = phase0 * module;\n\n    vec2 C = R.xy * 0.5; // center of screen.\n    float radius = min(C.x, C.y);\n    vec2 B = C + radius * CS(phase0);\n    vec2 E = C + radius * CS(phase1);\n\n    vec4 color = \n        (iFrame == 0) ||        // Initial frame?\n        (module > prevModule) ? // Or transition frame?\n            vec4(1.0) :\n            vec4(min(prevColor.r, capsuleSMSDF(SC, B, E, 0.5, 0.8)));\n            \n    return vec4(color.rgb, module);\n}\n\nvec4 sceneB(in vec2 SC)\n{\n    float numOfPoints = 300.0;\n    \n    float module = 2.0 + iTime * 0.75;\n    float phaseStep = TAU / numOfPoints;\n\n\n    float minSqDist = INITIALLY_FAR;\n\n    for (float p = 0.0; p < numOfPoints; p += 1.0)\n    {\n        float phase0 = p * phaseStep;\n        float phase1 = phase0 * module;\n    \n        vec2 C = R.xy * 0.5; // center of screen.\n        float radius = min(C.x, C.y);\n        \n        vec2 B = C + radius * CS(phase0);\n        vec2 E = C + radius * CS(phase1);\n        \n        minSqDist = min(minSqDist, capsuleSQSDF(SC, B, E));\n    }\n\n    return vec4(smoothstep(-0.64, 0.64, minSqDist-0.25));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = sceneA(SC);\n    //O = sceneB(SC);  // recreation of this shader: https://www.shadertoy.com/view/4d2cWD\n}","name":"Buffer A","description":"","type":"buffer"}]}