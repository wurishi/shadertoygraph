{"ver":"0.1","info":{"id":"XscyRX","date":"1519641850","viewed":648,"name":"Smooth Voronoi (weights)","username":"jcg_","description":"the neighboring cells are weighted based on a function of their distance to a point. The weights of surrounding cells can be individually used. Not perfect but good enough. Useful for generating a random smooth biome map, for example in terrain generation","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","biomes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\nstruct vor{\n    vec2 p1;\n    vec2 p2;\n    vec2 cell1;\n    vec2 cell2;\n    float distToBorder;\n    \n    mat4 pointDistances;\n};\n    float rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat weightFunction(float i)\n{\n    return 1./(pow(i,3.));\n}\nfloat matSum(mat4 m)\n{\n    float res;\n    for (int i = 0; i < 4;i++)\n    {\n        for (int j = 0; j < 4;j++)\n        {\n            res += weightFunction(m[i][j]);\n        }\n    }\n    return res;\n}\n\n\nvec3 colors[5] =vec3[]( vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),vec3(1,1,0),vec3(1,0,1));\nvec2 hash2(vec2 p)\n{\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n   \n}\n\n\n\nfloat noise12(vec2 pi)\n{\n\tvec3 p = vec3(pi,0);\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nvor voronoi( in vec2 x )\n{\n    \n    \n\tvor res;\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            res.p1 = g+o+n;\n            res.cell1 = g+n;\n        }\n        res.pointDistances[i][j]=d;\n        \n        \n        \n        \n        \n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        {\n            float newD = dot( 0.5*(mr+r), normalize(r-mr) );\n            if (newD < md)\n            {\n                md = newD;\n                res.p2 = g+o+n;\n                res.cell2 = g+n;\n            }\n        }// skip the same cell\n    }\n    res.distToBorder = md;\n    \n    \n    \n    \n    \n   \n    return res;\n}\n\n\nvec3 plot( vec2 p, float ss )\n{\n    vec3 col;\n    \n    vor O = voronoi(p);\n    \n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    \n    float S = matSum(O.pointDistances);\n    for (int i = 0; i <= 3;i++)\n    {\n        for (int j = 0; j <= 3;j++)\n        {\n            float w = weightFunction(O.pointDistances[i][j]);\n                if (w/S > 0.01)\n                {\n                    \n                    vec3 thisCol = colors[int(5.0*noise12(n+vec2(i,j)))];\n            \t\tcol += thisCol*w/S;\n                }\n        }\n        \n    }\n    \n    \n   \n    \n    \n    \n    \n    //col=c1;\n    if (O.distToBorder < 0.01)\n    {\n        //col = vec3(1);\n    }\n    if (length(O.p1-p) < 0.03 )\n    {\n        //col = vec3(1);\n    }\n    \n    \n    if (iMouse.z > 0.) // show grid\n    {\n\t\tvec2 g = abs(fract(p)-.5);\n        col = mix(col,vec3(.8),smoothstep(.5-ss*1.5,.5,max(g.x,g.y)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}","name":"Image","description":"","type":"image"}]}