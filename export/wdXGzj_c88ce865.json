{"ver":"0.1","info":{"id":"wdXGzj","date":"1546873983","viewed":101,"name":"Raymarched Sphere.","username":"caseymacneil","description":"sphere","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 512\n#define MAXDIST 200.\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{\n\tn = normalize(n);\n\treturn dot(p, n.xyz)+1.;\n}\n\nvec3 opRep(vec3 p, vec3 r)\n{\n\treturn mod(abs(p),r)-.5*r;\n}\n\nfloat map(vec3 p)\n{\n\treturn min(sdSphere(opRep(vec3(0.0,0.,0.0)-p,vec3(10.,0.,10.)),1.0),sdPlane(vec3(0.,0.,0.)-p,vec3(0.,-1.,0.)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n// soft shadow function by iq\n//https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n//\n\n// taken from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.00 + 0.15*float(i)/4.0;\n        float d = map(p + h*n);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 1.5 * occ, 0.1, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up camera\n    vec2 sp =  (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(sin(iTime*.5)*2.,3.,4.);\n    vec3 rd = normalize(vec3(sp,-2.));\n    //\n\t\n    vec3 lightDir = normalize(vec3(sin(iTime),sin(iTime*2.)*.5 + .75,cos(iTime)));\n\n    vec3 col = vec3(0.3,0.5,0.8);\n   \t\n    // sun\n    col += vec3(pow(max(dot(rd,lightDir),0.),80.));\n    \n    float t = 0.;\n    \n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n    \tvec3 p = ro + rd * t;\n        float d = map(p);\n        \n        if(t > MAXDIST) break;\n        \n        // draw\n        if(d < 0.001)\n        {\n            vec3 n = calcNormal(p);\n            float NDotL = dot(n,lightDir);\n            float iNDotL = dot(n,-lightDir);\n            NDotL = max(NDotL,0.);\n           \tiNDotL = max(iNDotL,0.);\n            float shadow = softshadow(p,lightDir,.1,16.,16.)+.4;\n            \n            // fresnel\n            float NDotV = dot(n, rd); \n            float fscale= 2.;\n            float fpow  =2.;\n            float fbump = -.7;\n            float f = 1.-pow(NDotV,fpow) * fscale;\n            f = max(f+fbump,0.);\n            \n            float occ = calcAO(p,n);\n            \n            \n        \tcol = vec3(NDotL+.1) * shadow * occ;\n            col += f *(shadow+.5);\n            //col = n;\n            break;\n        }\n        \n        t += d;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}