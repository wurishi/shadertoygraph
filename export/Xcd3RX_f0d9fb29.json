{"ver":"0.1","info":{"id":"Xcd3RX","date":"1712249409","viewed":57,"name":"Coordinate System 2D","username":"romeosoft","description":"The unique aspect of this code is the use of a custom coordinate system to create and manipulate shapes on the screen. The resulting pattern resembles a geometric design with repeating shapes.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["coordinatesystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n\nreal shape_element(vec2 uv, coord2 c, real sd)\n{\n    vec2 p1 = coord_div(uv, c);\n    \n    real s = mix(0.8, 1.0, p1.x);\n    \n    real rect1 = min(bound_seg(p1.x, 0.0, 0.5),\n                     bound_seg(p1.y, -0.125*s, 0.125*s));\n                     \n    real round1 = max(bound_seg(distance(p1, vec2(0.0, 0.0)), 0.0, 0.125*s),\n                      bound_seg(distance(p1, vec2(0.5, 0.0)), 0.0, 0.125*s));\n                     \n    sd = max(sd, max(rect1, round1*2.0)); \n    \n    return sd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    coord2 c1 = create_coord(vec2(1.0,0.5),vec2(1.,0.),0.5); // Coordinate System\n    \n    real sd = 0.0;\n    {\n        c1 = coord_rot(c1, pi/3.+iTime / 2.0);\n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.5,0), c1);\n        c1 = coord_rot(c1, pi/3.+iTime / 4.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.5,0.0), c1);\n        c1 = coord_rot(c1, -pi/3.+iTime / 8.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.5,0.0), c1);\n        c1 = coord_rot(c1, pi/3.+iTime / 16.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.5,0.0), c1);\n        c1 = coord_rot(c1, -pi/3.+iTime / 32.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.5,0.0), c1);\n        c1 = coord_rot(c1, pi/3.+iTime / 2.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n        c1.o = coord_mul(vec2(0.0,0.0), c1);\n        c1 = coord_rot(c1, -pi/3.+iTime / 2.0);\n        c1.s *= 0.8;\n        \n        sd = shape_element(uv, c1, sd);\n    }\n    {\n         vec2 p = uv-vec2(0.9,0.5);\n         real rect1 = min(bound_seg(p.x, -0.5, 0.5),\n                             bound_seg(p.y, -0.49, 0.49));\n         real rect2 = min(bound_seg(p.x, -0.49, 0.49),\n                             bound_seg(p.y, -0.48, 0.48));\n         sd = max(sd*2.0*rect1, (rect1 - rect2*0.9)); \n    }\n    \n    fragColor = vec4(sd*3.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define real float\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.1415926535\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in two-dimensional space \n// consists of an origin plus two orientation axes \n// c++ version : https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord2\n{\n   vec2 ux,uy;   // two axial unit vectors\n   real s;       // scaling[opt]\n   vec2 o;       // origin\n};\ncoord2 create_coord(vec2 _o, vec2 _ux, real _s)\n{\n   coord2 c; c.ux = _ux;c.uy = vec2(-_ux.y, _ux.x);c.o = _o; c.s = _s;\n    return c;\n}\n// mul: define a vector in a coordinate system\nvec2 coord_mul (vec2 p, coord2 c)\n{\n\treturn c.ux * (p.x*c.s) + c.uy * (p.y*c.s) + c.o;\n}\n// rot: rotate the coord\ncoord2 coord_rot (coord2 c, real ang)\n{\n    ROT(c.ux, ang);\n    ROT(c.uy, ang);\n    return c;\n}\n// div: measure a vector in a coordinate system\nvec2 coord_div (vec2 p, coord2 c)\n{\n    vec2 v = p - c.o;\n    return vec2(dot(v,c.ux)/c.s, dot(v,c.uy)/c.s);\n}\n// ---------------------------------------------------------\n// Boundary\n// ---------------------------------------------------------\nreal bound_seg(real x, real m, real M)\n{\n    if(x < m || x > M)\n        return 0.0;\n    return max(x - m,M - x);\n}\nvec2 bound_seg_v2(vec2 v, vec2 m, vec2 M)\n{\n    if(v.x < m.x || v.y < m.y || v.x > M.x || v.y > M.y)\n        return vec2(0.0);\n    return max(v - m,M - v);\n}","name":"Common","description":"","type":"common"}]}