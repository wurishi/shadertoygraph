{"ver":"0.1","info":{"id":"4d3fzs","date":"1526307001","viewed":349,"name":"bonhommes","username":"louis_C","description":"des bonhommes marchent","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SAMPLES = 24.;\n   lowp float RGBToL(lowp vec3 color)\n    {\n        lowp float fmin = min(min(color.r, color.g), color.b);\n        lowp float fmax = max(max(color.r, color.g), color.b);      \n        return (fmax + fmin) / 2.0; // Luminance\n    }\n    lowp vec3 RGBToHSL(lowp vec3 color)\n    {\n        lowp vec3 hsl; \n        lowp float fmin = min(min(color.r, color.g), color.b);   \n        lowp float fmax = max(max(color.r, color.g), color.b);   \n        lowp float delta = fmax - fmin;          \n        hsl.z = (fmax + fmin) / 2.0; \n        if (delta == 0.0)\t\t\n        {\n            hsl.x = 0.0;\n            hsl.y = 0.0;\n        }\n        else                                   \n        {\n            if (hsl.z < 0.5)\n                hsl.y = delta / (fmax + fmin); \n            else\n                hsl.y = delta / (2.0 - fmax - fmin);            \n            lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n            lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n            lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;            \n            if (color.r == fmax )\n                hsl.x = deltaB - deltaG; \n            else if (color.g == fmax)\n                hsl.x = (1.0 / 3.0) + deltaR - deltaB;\n            else if (color.b == fmax)\n                hsl.x = (2.0 / 3.0) + deltaG - deltaR;             \n            if (hsl.x < 0.0)\n                hsl.x += 1.0; \n            else if (hsl.x > 1.0)\n                hsl.x -= 1.0; \n        }\n        return hsl;\n    }\n\n    lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n    {\n        if (hue < 0.0)\n            hue += 1.0;\n        else if (hue > 1.0)\n            hue -= 1.0;\n        lowp float res;\n        if ((6.0 * hue) < 1.0)\n            res = f1 + (f2 - f1) * 6.0 * hue;\n        else if ((2.0 * hue) < 1.0)\n            res = f2;\n        else if ((3.0 * hue) < 2.0)\n            res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n        else\n            res = f1;\n        return res;\n    }\n\n    lowp vec3 HSLToRGB(lowp vec3 hsl)\n    {\n        lowp vec3 rgb;\n\n        if (hsl.y == 0.0)\n            rgb = vec3(hsl.z); // Luminance\n        else\n        {\n            lowp float f2;\n            \n            if (hsl.z < 0.5)\n                f2 = hsl.z * (1.0 + hsl.y);\n            else\n                f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n            \n            lowp float f1 = 2.0 * hsl.z - f2;\n            \n            rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n            rgb.g = HueToRGB(f1, f2, hsl.x);\n            rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n        }\n\n        return rgb;\n    }\nfloat rand( vec2 p ){ return fract(sin(dot(p, vec2(41.254, 289.256)))*45758.5453); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float decay = 0.7; \n    float density =0.1; \n    float weight = 0.22; \n    vec2 tuv =  uv - .5 ;\n    vec2 dTuv = tuv*density/SAMPLES;\n    vec4 col = texture(iChannel0, uv)*0.25;\n    uv += dTuv*(rand(uv+ fract(iTime))*2. - 1.);\n    for(float i=0.; i < SAMPLES; i++){   \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;      \n    }\n    \n    col *= (1. - dot(tuv, tuv)*0.5);\n    vec3 col2 = clamp(sqrt(smoothstep(0., 1., col.xyz)),0.,1.); \n    lowp float lightness = RGBToL(col2);\nlowp vec3 s = smoothstep(1./1.5,0.,lightness)*vec3(-0.5,-0.2,0.8);\nlowp vec3 m = smoothstep(0.,1./3.,lightness)*smoothstep(1.,2./3.,lightness)*vec3(-0.1,-0.2,0.1);\nlowp vec3 l = smoothstep(2./3.,1.,lightness)*vec3(0.2,0.01,0.);\n    lowp vec3 newColor = col2 +s+m+l ;\n        newColor = clamp(newColor, 0.0, 1.0); \n\t\tlowp vec3 newHSL = clamp(RGBToHSL(newColor),0.,1.);\n        lowp float oldLum = RGBToL(col2);\n        col2 = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum)); \n   fragColor = vec4(col2,1.);\n           \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat rand (vec2 uv ){return fract(sin(dot(floor(uv),vec2(12.326,75.326)))*4589.365);}\nfloat noise ( vec2 uv) {\nfloat a = rand(uv);\nfloat b = rand (uv+vec2(1,0));\n float c  = rand (uv+vec2(0,1));\n float d  = rand ( uv+vec2(1,1));\nvec2 u =smoothstep(0.,1.,fract(uv));\nreturn mix (a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;\n}\nfloat Sph (vec3 pos, float radius){\nreturn length(pos)-radius;\n}\n\nfloat cap ( vec3 pos, vec3 a, vec3 b,float r){\n\nvec3 pa = pos-a;\nvec3 ba = b-a;\nfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.0);\nreturn length (pa-ba*h)-r;\n}\n\nfloat smin (float a,float b,float k){\nfloat h = clamp (0.5+0.5*(b-a)/k,0.0,1.0);\nreturn mix (b,a,h)-k*h*(1.0-h);\n}\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\n    return mat2(c,-s,s,c   );\n}\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat plane (vec3 pos,vec4 n)\n{return dot(pos,n.xyz)+n.w;}\nvec3 hsv (vec3 col,float h,float s,float v){\nvec4 k = vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\nvec4 p = mix(vec4(col.zy,k.wz),vec4(col.yz,k.xy),step(col.z,col.y));\nvec4 q = mix (vec4(p.xyw,col.x),vec4(col.x,p.yzx),step(p.x,col.x));\nfloat d = q.x-min(q.w,q.y);\n    float e = 1.0e-10;\n    vec3 a = vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);\nreturn  mix(vec3(1.),clamp(3.0*abs(1.0-2.0*fract((h+a.r)+vec3(0.,-1./3.,1./3.)))-1.,0.,1.)\n        ,(s+a.g))*(v+a.b);}\nvec4 map (vec3 pos){\n\nvec4 scene = vec4(1.);\n\nfloat al2 = noise(pos.xz*0.1);\npos = pos+vec3(0.,al2*8.,0.);\nvec3 pos1 = pos+vec3(0.,0.,iTime*5.);\nfloat al = rand (pos1.xz*0.25);\npos1 = rep (pos1,vec3(4,0,4));\npos1.xz *= rotate(pos.y*0.1*sin(iTime*5.)+6.);\nfloat zo = plane(pos, vec4(0,-1,0,0.6));\nfloat s1 = Sph(pos1+vec3(0.,1.5,0.),0.6);\nfloat s2 = cap(pos1,vec3(0,-0.5,0),vec3(0,0.5,0),0.6);\nfloat s3 = cap(pos1,vec3(0,-0.5,0),vec3(0,0.5,0),0.6);\nfloat s4 = smin(s1,s2,0.5);\nfloat s5 = cap(pos1,vec3(-0.35,1.,0.),vec3(-0.4,2.,sin(iTime*5.+(al*3.))*0.5),0.25);\nfloat s6 = cap(pos1,vec3(0.35,1.,0.),vec3(0.4,2.,sin(iTime*5.+3.14+(al*3.))*0.5),0.25);\nfloat s7 = min(s5,s6);\nfloat s8 = smin(s4,s7,0.3);\nfloat s9 = cap(pos1,vec3(0.5,-0.7,0.),vec3(0.6,0.3,sin(iTime*5.+(al*3.))),0.25);\nfloat s10 = cap(pos1,vec3(-0.5,-0.7,0.),vec3(-0.6,0.3,sin(iTime*5.+3.14+(al*3.))),0.25);\nfloat s11 = min(s9,s10);\nfloat s12 = smin(s8,s11,0.1);\nfloat s13 = Sph (pos1+vec3 (0.,1.4,0.7),0.2);\nfloat s15 = Sph (pos1+vec3 (0.3,1.6,0.5),0.15);\nfloat s16 = Sph (pos1+vec3 (-0.3,1.6,0.5),0.15);\nfloat s17 = min(s15,s16);\nfloat s14 = smin (s12,s13,0.2);\nfloat s18 = max(-s17,s14);\nfloat s19 = plane (pos, vec4(0,-1,0,2.2));\nfloat s20 = min(s18,s19);\nvec3 col =hsv(vec3(1.,0.,0.),al,0.,0.5);\nvec3 colsec =hsv(vec3(0.,0.,1.),al,0.,0.5);\nvec3 col4 = mix(col,colsec,step(s18,zo));\nvec3 col3 = mix (vec3(1.,0.7,0.7),vec3(1.),smoothstep(0.,0.5,s13));\nvec3 col2 = mix (col3,col4,step(s2,s1));\nvec3 col1 = mix(vec3(0,0,1),col2,step(s18,s19));\n scene = vec4 (col1,s20);\n \nreturn scene;\n}\nvec3 getN (vec3 pos) {\n    float e = 0.01;\n    return normalize(vec3(map(pos+vec3(e,0,0)).w-map(pos-vec3(e,0,0)).w,\n                          map(pos+vec3(0,e,0)).w-map(pos-vec3(0,e,0)).w,\n                          map(pos+vec3(0,0,e)).w-map(pos-vec3(0,0,e)).w));\n}\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t = .01*10.;\n    for (float i = 0.; i <= 1.; i += 1./30.) {\n        float dist = map(pos + dir * t).w;\n        if (dist < .01) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\nfloat fmb ( vec2 uv) {\n\nfloat val = 0.;\nfloat amp = 0.5;\nfloat frec = 0.;\n\nfor (int i =0; i<6; i++){\nval += amp* noise (uv);\nuv*=2.;\namp*=.5;\n}\nreturn val;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv =1.-2.* fragCoord/iResolution.xy;\n\tfloat u = (fragCoord/iResolution.xy).y;\n \t uv.x *= iResolution.x/iResolution.y;  \nfloat f = fmb(uv*20.+cos(iTime+uv.y*10.)+fmb(uv*20.+sin(iTime+uv.x*20.)))*smoothstep(0.4,0.6,u)*0.05;\n    vec2 uv2 = uv+f;\n    vec3 eye = vec3(1.5,-11.,iTime*-10.);\n    vec3 ray = normalize(vec3(uv2,1.));   \n    vec3 pos = eye;\n    float shade = 0.;\n    for (int i=0; i<40;++i){\n    float dist = map(pos).w;\n    if(dist<0.01){\n    shade = 1.-float(i)/40.;\n    break;\n    }\n    pos += ray*dist;\n    }\n    \n    vec2 e = vec2(.01,0);\n \n            vec3 nor = getN(pos);\n        \n        vec3 lightPos = vec3(0,-10.,iTime*-10.+50.);\n        vec3 lightDir = normalize(lightPos-pos);\n        float test = 0.5+7.*getShadow(pos, lightPos, 64.)*clamp(dot(lightDir,nor),0.,1.);\n        vec3 color = map (pos).xyz*shade*test;\n        vec3 seccol = mix(color,clamp(hsv(color,0.,-1.,1.),0.,1.3),smoothstep(iTime*-10.+0.,iTime*-10.+70.,pos.z)+smoothstep(-2.,5.,pos.y));\n        vec3 ciel = mix(vec3(1,0.8,0.75),vec3(1.),smoothstep(0.9,0.2,distance(uv2,vec2(0,-0.5))));\n        vec3 col2 = mix(clamp(seccol,0.,1.),ciel,smoothstep(0.1,-0.4,uv.y));\n        vec3 col3 = mix(hsv(col2,0.,0.,0.1),hsv(col2,1.,0.4+(0.5+sin(iTime)*0.5)*0.5,-0.4),smoothstep(0.5,2.5,distance (vec2(0.),uv)));\n        \n        fragColor= vec4(col3,1.);\n}","name":"Buf A","description":"","type":"buffer"}]}