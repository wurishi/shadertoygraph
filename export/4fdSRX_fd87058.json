{"ver":"0.1","info":{"id":"4fdSRX","date":"1714271759","viewed":75,"name":"Raytracer Test - 01","username":"Switchbreak","description":"Initial test of some custom ray tracing code","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.00001;\nconst float MAX_DISTANCE = 1000000000.0;\nconst float GAMMA = 2.2;\n\n// Plane is defined by a center point and a normal\n// Plane texture-space is defined by two vectors v1 and v2\n// that are perpendicular to each other and parallel to the\n// plane\nconst vec3 Pp0 = vec3(0, -10, 0);\nconst vec3 Pn  = vec3(0, 1, 0);\nconst vec3 Pv1 = vec3(0.1, 0, 0);\nconst vec3 Pv2 = vec3(0, 0, 0.1);\n\n// Sphere is defined by a center point and a radius\nstruct sphere {\n    vec3 Sp0;\n    float Sr;\n    vec4 diffuse;\n};\n\nconst sphere[] spheres = sphere[](\n    sphere(vec3(0, -5, 0), 5.0, vec4(0)),\n    sphere(vec3(-6, -8, -2), 2.0, vec4(0, 1, 1, 1)),\n    sphere(vec3(2, -7.5, 10), 2.5, vec4(1, 0, 1, 1))\n);\n\n// Point light source\nconst vec3  light   = vec3(5, 10, -10);\nconst float ambient = 0.01;\n\n// Sky color is blue\n// Plane texture is a two-color checkerboard pattern of black and white\nconst vec4 skyColor    = vec4(0, 0, 1, 1);\nconst vec4 planeColor1 = vec4(1, 1, 1, 1);\nconst vec4 planeColor2 = vec4(0.5, 0.5, 0.5, 1);\n\nbool sphereCollide(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float radius2, out float t, out vec3 normal)\n{\n    // Check for collision between ray and sphere\n    float t1 = dot(sphereOrigin - rayOrigin, rayDirection - rayOrigin);\n    // Closest point to sphere along ray lies in front of the camera if t1 > 0\n    if (t1 > 0.0)\n    {\n        // Get distance of closest point between ray and sphere and compare it to radius\n        vec3 t1Sphere = (rayOrigin + t1 * (rayDirection - rayOrigin)) - sphereOrigin;\n        float d2 = dot(t1Sphere, t1Sphere);\n        \n        if (d2 <= radius2)\n        {\n            // Calculate intersection point on sphere surface\n            float t0 = t1 - sqrt(radius2 - d2);\n            \n            if (t0 < t)\n            {\n                t = t0;\n\n                // Get surface normal\n                vec3 p = rayOrigin + t * (rayDirection - rayOrigin);\n                normal = normalize(p - sphereOrigin);\n\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool spheresCollide(vec3 rayOrigin, vec3 rayDirection, out float t, out vec3 normal, out vec4 diffuse)\n{\n    bool collision = false;\n\n    for(int i = 0; i < spheres.length(); i++)\n    {\n        if (sphereCollide(rayOrigin, rayDirection, spheres[i].Sp0, spheres[i].Sr * spheres[i].Sr, t, normal))\n        {\n            collision = true;\n            diffuse = spheres[i].diffuse;\n        }\n    }\n    \n    return collision;\n}\n\nbool planeCollide(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 normal, out float t)\n{\n    float denom = dot(normal, rayDirection - rayOrigin);\n    if (denom < EPSILON)\n    {\n        float t0 = dot(Pp0 - rayOrigin, Pn) / denom;\n        if (t0 > EPSILON && t0 < t)\n        {\n            t = t0;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec4 planeTexture(vec3 planeOrigin, vec3 normal, vec3 v1, vec3 v2, vec3 p)\n{\n    // Determine color based on tiling checkerboard pattern texture\n    vec2 uv = vec2(dot(v1, p), dot(v2, p));\n    bool pattern = mod(uv.x, 1.0) > 0.5 ^^ mod(uv.y, 1.0) > 0.5;\n\n    return pattern ? planeColor1 : planeColor2;\n}\n\nbool rayCollide(vec3 origin, vec3 direction, out float t, out vec3 normal, out vec4 diffuse)\n{\n    t = MAX_DISTANCE;\n    bool collision = false;\n    \n    if (spheresCollide(origin, direction, t, normal, diffuse))\n    {\n        collision = true;\n    }\n    if (planeCollide(origin, direction, Pp0, Pn, t))\n    {\n        collision = true;\n        normal = Pn;\n        diffuse = planeTexture(Pp0, Pn, Pv1, Pv2, (direction - origin) * t + origin);\n    }\n    \n    return collision;\n}\n\nvec3 mouseOrbitCamera()\n{\n    vec2 mPosition = iMouse.xy / iResolution.xy;\n    vec2 drag = (mPosition - abs(iMouse.zw) / iResolution.xy);\n    return vec3(drag.y * 2.0, -drag.x * 5.0, 0.0);\n}\n\nvec3 rayFromCamera(vec2 fragCoord, out vec3 camPos, vec3 camRot)\n{\n    // View frustum is defined as width and height of the view screen in\n    // world-space units, with z representing distance from the camera position\n    vec3 frustum = vec3(normalize(iResolution.xy), 1.0);\n    \n    // Convert screen-space pixel coordinate to view-space frustum coordinates\n    vec2 ss = (fragCoord / iResolution.xy - 0.5) * frustum.xy;\n    vec3 ray = normalize(vec3(ss.xy, frustum.z));\n    \n    mat4 transform = mat4(1.0);\n    if (abs(camRot.x) > EPSILON)\n    {\n        float c = cos(camRot.x);\n        float s = sin(camRot.x);\n        mat4 rotate = mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, c,   -s,  0.0,\n            0.0, s,   c,   0.0,\n            0.0, 0.0, 0.0, 1.0);\n        transform *= rotate;\n    }\n    if (abs(camRot.y) > EPSILON)\n    {\n        float c = cos(camRot.y);\n        float s = sin(camRot.y);\n        mat4 rotate = mat4(\n            c,   0.0, s,   0.0,\n            0.0, 1.0, 0.0, 0.0,\n            -s,  0.0, c,   0.0,\n            0.0, 0.0, 0.0, 1.0);\n        transform *= rotate;\n    }\n    if (abs(camRot.z) > EPSILON)\n    {\n        float c = cos(camRot.z);\n        float s = sin(camRot.z);\n        mat4 rotate = mat4(\n            c,   -s,  0.0, 0.0,\n            s,   c,   0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0);\n        transform *= rotate;\n    }\n\n    // Use rotation matrix to calculate the camera orbit position, then add the\n    // position to the transform as a translation matrix before transforming rays\n    // from view-space to world-space\n    camPos = (vec4(camPos.xyz, 1.0) * transform).xyz;\n    transform *= mat4(\n        1.0, 0.0, 0.0, camPos.x,\n        0.0, 1.0, 0.0, camPos.y,\n        0.0, 0.0, 1.0, camPos.z,\n        0.0, 0.0, 0.0, 1.0);\n    return (vec4(ray.xyz, 1.0) * transform).xyz;\n}\n\nbool shadowed(vec3 point, vec3 normal)\n{\n    // Point is in shadow if the surface normal points away from the light\n    if (dot(light - point, normal) < 0.0)\n        return true;\n    \n    vec3 ray = normalize(light - point) + point;\n\n    float t = MAX_DISTANCE;\n    vec4 diffuse = vec4(1);\n    return spheresCollide(point, ray, t, normal, diffuse);\n}\n\nvec4 lightPoint(vec3 point, vec3 normal, vec4 diffuse)\n{\n    if (!shadowed(point, normal))\n    {\n        float lightIncidence = 1.0 - length(cross(normalize(light - point), normal));\n        return diffuse * (ambient + lightIncidence);\n    }\n    else\n    {\n        return diffuse * ambient;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 camPos = vec3(0, 0, -50);\n    vec3 camRot = mouseOrbitCamera();\n    \n    vec3 ray = rayFromCamera(fragCoord, camPos, camRot);\n    \n    float t;\n    vec3 normal;\n    vec4 diffuse;\n    vec4 outColor;\n    \n    if (rayCollide(camPos, ray, t, normal, diffuse))\n    {\n        vec3 p = t * (ray - camPos) + camPos;\n\n        // Diffuse color of 0 indicates a reflective surface\n        if (diffuse == vec4(0))\n        {\n            diffuse = skyColor;\n            vec3 reflection = reflect(ray - camPos, normal);\n            \n            rayCollide(p, reflection + p, t, normal, diffuse);\n            \n            outColor = lightPoint(t * reflection + p, normal, diffuse);\n        }\n        else\n        {\n            outColor = lightPoint(p, normal, diffuse);\n        }\n    }\n    else\n    {\n        outColor = skyColor;\n    }\n    \n    // Gamma correction on the output color\n    fragColor = vec4(pow(outColor.xyz, vec3(1.0/GAMMA)), 1.0);\n}","name":"Image","description":"","type":"image"}]}