{"ver":"0.1","info":{"id":"MflSWl","date":"1707732496","viewed":33,"name":"[inspirnathan] 08 - CamMovement","username":"hrst4","description":"[inspirnathan] 08 - CamMovement","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/55-shadertoy-tutorial-part-9\n#define PART 3\n/*\nSalutations, chers amis ! C'est le jour du poisson d'avril ! \nJ'espère que vous ne tomberez pas dans le panneau aujourd'hui !\nBienvenue dans la partie 9 de ma série de tutoriels Shadertoy. \nDans ce tutoriel, nous allons apprendre à déplacer la caméra dans la scène.\n\n# Setup initial\nCréons un nouveau shader et ajoutons le code de base suivant.\n*/\n#if PART == 0\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), identity()));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nCe code crée une scène avec un sol carrelé, un ciel (couleur de fond) et un cube rouge.\nIl contient également les matrices de rotation que nous avons apprises dans le dernier tutoriel.\nhttps://inspirnathan.com/_nuxt/img/img-1.37ce0dc.png\n\n# Panoramique de la caméra\nLe panoramique de la caméra est en fait très simple. \nLa caméra pointe actuellement vers un cube qui flotte légèrement dans l'air \nà une certaine distance de la caméra le long de l'axe z. \nComme notre système de coordonnées utilise la règle de la main droite,\nl'axe z est négatif lorsqu'il s'éloigne de la caméra et positif lorsqu'il s'en rapproche.\nhttps://inspirnathan.com/_nuxt/img/img-2.f13a4e4.png\n\nNotre caméra se trouve à une position définie par la variable ro, qui est l'origine du rayon.\nActuellement, elle est égale à vec3(0, 0, 3).\nPour faire pivoter la caméra le long de la direction x, il suffit d'ajuster la composante x de ro.\n\nvec3 ro = vec3(1, 0, 3);\n\nNotre caméra s'est maintenant déplacée vers la droite, ce qui a pour effet de déplacer le cube vers la gauche.\nhttps://inspirnathan.com/_nuxt/img/img-3.ea8e96d.png\n\nDe même, nous pouvons ajuster la composante y de ro pour déplacer la caméra vers le haut ou vers le bas.\n\nvec3 ro = vec3(0, 1, 3);\n\nLe fait de déplacer la caméra vers le haut a pour effet de déplacer le cube et le sol vers le bas.\nhttps://inspirnathan.com/_nuxt/img/img-4.3f4630d.png\n\nVous pouvez faire pivoter la caméra le long d'une trajectoire circulaire en utilisant \nles fonctions cos et sin le long de l'axe x et de l'axe y, respectivement.\nhttps://inspirnathan.com/_nuxt/img/gif-1.d94791d.gif\n\nÉvidemment, l'effet commence à être étrange lorsque l'on s'enfonce un peu dans le sol. \nJ'ai donc ajouté 0,1 à la composante y afin d'éviter les effets de clignotement qui pourraient se produire.\n\n# Inclinaison/rotation de la caméra\n\nSupposons que nous voulions garder la position de la caméra, ro, inchangée, mais que nous souhaitions\nl'incliner vers le haut, le bas, la gauche ou la droite. \nPeut-être voulons-nous même tourner la caméra dans tous les sens, de manière à ce qu'elle fasse\nun angle de 180 degrés. \nCela implique l'application d'une matrice de transformation à la direction du rayon, rd.\n\nRemettons l'origine du rayon à la normale :\n\nvec3 ro = vec3(0, 0, 3);\n\nLe cube devrait maintenant être centré sur le canvas. \nActuellement, notre scène vue de côté est similaire à l'illustration suivante :\nhttps://inspirnathan.com/_nuxt/img/img-5.c7cf472.png\n\nNous voulons que la position de la caméra reste inchangée,\nmais qu'elle puisse être inclinée dans n'importe quelle direction. \nSupposons que nous voulions incliner la caméra vers le haut. \nNotre scène ressemblerait à l'illustration suivante :\nhttps://inspirnathan.com/_nuxt/img/img-6.f38ec9b.png\n\nRemarquez que les rayons émis par la caméra se sont également inclinés vers le haut. \nIncliner la caméra signifie incliner tous les rayons qui sortent de la caméra.\n\nL'inclinaison de la caméra est similaire à celle des axes principaux des avions.\nhttps://inspirnathan.com/_nuxt/img/img-7.9976428.png\n\nLa caméra peut non seulement effectuer un panoramique le long de l'axe x, de l'axe y ou de l'axe z,\nmais elle peut également s'incliner (ou pivoter) le long de trois axes de rotation :\nle tangage, le lacet et le roulis. \nLa caméra dispose donc de six degrés de liberté : trois axes de position et trois axes de rotation.\nhttps://inspirnathan.com/_nuxt/img/img-8.10f381d.png\n\nHeureusement pour nous, nous pouvons utiliser les mêmes matrices de rotation que dans le dernier tutoriel\npour appliquer le tangage, le lacet et le roulis.\n\n\"Le tangage est appliqué à l'aide de la fonction rotateX, le lacet à l'aide de la fonction rotateY \net le roulis à l'aide de la fonction rotateZ.\n\nSi nous voulons incliner la caméra vers le haut/bas, ou appliquer le \"tangage\",\nnous devons appliquer la fonction rotateX à la direction du rayon, rd.\n\nvec3 rd = normalize(vec3(uv, -1)) ;\nrd *= rotateX(0.3) ;\n\nIl suffit de multiplier la direction du rayon par une ou plusieurs matrices de rotation pour incliner la caméra.\nCela inclinera la direction de chaque rayon émis par la caméra,\nmodifiant ainsi la vue que nous voyons dans le canvas Shadertoy.\n\nAnimons l'inclinaison de manière à ce que l'angle de \"pitch\" oscille entre -0,5 et 0,5.\nhttps://inspirnathan.com/_nuxt/img/gif-2.3fc5a41.gif\n\nPour incliner la caméra à gauche/droite, ou appliquer un \"mouvement de lacet\",\nnous devons appliquer la fonction rotateY.\n\nvec3 rd = normalize(vec3(uv, -1));\nrd *= rotateY(sin(iTime) * 0.5);\n\nhttps://inspirnathan.com/_nuxt/img/gif-3.f9147b6.gif\n\nPour incliner la caméra d'un côté à l'autre, ou appliquer un \"roulis\", \nnous devons utiliser la fonction rotateZ. Faites un tonneau !\n\nvec3 rd = normalize(vec3(uv, -1));\nrd *= rotateZ(sin(iTime) * 0.5);\n\nhttps://inspirnathan.com/_nuxt/img/gif-4.b70ceba.gif\n\n# Rotation de la caméra à 360 degrés\n\nNous pouvons également appliquer un mouvement de lacet entre pi négatif et pi positif \npour faire tourner la scène sur un angle complet de 360 degrés.\n\nconst float PI = 3.14159265359;\nvec3 rd = normalize(vec3(uv, -1));\nrd *= rotateY(sin(iTime * 0.5) * PI); // 0.5 is used to slow the animation down\n\nhttps://inspirnathan.com/_nuxt/img/gif-5.5e63e13.gif\n\nLorsque vous regardez derrière la caméra, vous trouverez probablement un point lumineux sur le sol. \nCe point lumineux est la position de la lumière, actuellement définie à vec3(2, 2, 7).\nComme l'axe z positif est configuré pour être derrière la caméra, vous finirez par voir la lumière\nlorsque vous tournerez la caméra.\n\nhttps://inspirnathan.com/_nuxt/img/img-9.4218c2f.png\n\nVous pouvez penser que la tache lumineuse est un poisson d'avril,\nmais c'est en fait le résultat du calcul de la réflexion diffuse de la partie 6.\n\nfloat dif = clamp(dot(normal, lightDirection), 0.3, 1.) ;\ncol = dif * co.col + backgroundColor * .2 ;\n\nÉtant donné que nous colorons le sol sur la base de la réflexion diffuse et de la normale à la surface, le sol apparaît le plus lumineux à l'endroit où se trouve la position de la lumière. Si vous souhaitez supprimer cette tache solaire, vous devrez supprimer le sol des calculs d'éclairage.\n\nEn règle générale, cela ne devrait pas poser de problème puisque la lumière se trouve derrière la caméra. Si vous souhaitez avoir des scènes avec un sol où la caméra se retourne, vous devrez probablement supprimer la tache lumineuse.\n\nPour supprimer cette \"tache de soleil\" ou \"reflet de soleil\" comme j'aime à l'appeler, \nil suffit d'attribuer un identifiant à chaque objet de la scène.\nEnsuite, vous pouvez supprimer le sol du calcul de l'éclairage en vérifiant si le sol est l'objet le\nplus proche dans la scène après avoir effectué le ray marching.\n\n\n*/\n#elif PART == 1\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n    int id; // identifier for each surface/object\n};\n\n/*\nSurface IDs:\n1. Floor\n2. Box\n*/\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col, 2);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col, 1);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(.5 + 0.3*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), identity()));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  const float PI = 3.14159265359;\n  vec3 rd = normalize(vec3(uv, -1));\n  rd *= rotateY(sin(iTime * 0.5) * PI); // 0.5 is used to slow the animation down\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n            \n    // check material ID        \n    if( co.id == 1 ) // floor\n    {\n        col = co.col;\n    } else {\n      // lighting\n      vec3 lightPosition = vec3(2, 2, 7);\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      // color\n      float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n      col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n    }\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nAvec cette approche, l'éclairage du sol sera un peu différent, mais la tache solaire aura disparu !\nhttps://inspirnathan.com/_nuxt/img/gif-6.8278618.gif\n\nEn attribuant des ID à chaque surface, matériau ou objet, nous pouvons savoir quel objet \na été touché par un rayon après le ray marching. \n\nCela peut s'avérer utile pour appliquer des calculs d'éclairage ou de coloration propres\nà un ou plusieurs objets.\n\n# Comprendre iMouse\n\nShadertoy fournit un ensemble de variables globales que vous pouvez utiliser dans votre code de shader\npour le rendre plus interactif. \nSi vous ouvrez un nouveau shader et que vous cliquez sur la flèche à côté de \"Shader inputs\",\nvous verrez une liste de variables globales.\nhttps://inspirnathan.com/_nuxt/img/img-10.2e3a0b5.png\n\nVous trouverez ci-dessous une liste de variables globales que vous pouvez utiliser\ndans les shaders Shadertoy.\n\nShader Inputs\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iTime;                 // shader playback time (in seconds)\nuniform float     iTimeDelta;            // render time (in seconds)\nuniform int       iFrame;                // shader playback frame\nuniform float     iChannelTime[4];       // channel playback time (in seconds)\nuniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\nuniform vec4      iDate;                 // (year, month, day, time in seconds)\nuniform float     iSampleRate;           // sound sample rate (i.e., 44100)\n\nParmi elles, vous verrez une variable appelée iMouse qui peut être utilisée pour obtenir \nla position de votre souris lorsque vous cliquez quelque part sur le canvas.\nCette variable est de type vec4 et contient donc quatre informations sur le clic gauche de la souris.\n\nvec4 mouse = iMouse;\n\nmouse.xy = mouse position during last button down\nabs(mouse.zw) = mouse position during last button click\nsign(mouze.z) = button is down (positive if down)\nsign(mouze.w) = button is clicked (positive if clicked)\n\nUn clic de souris est ce qui se produit immédiatement après avoir appuyé sur la souris. \nUn événement d'abaissement de la souris est ce qui se produit lorsque vous continuez à maintenir\nla souris enfoncée.\n\nCe didacticiel d'Inigo Quilez: https://www.shadertoy.com/view/Mss3zH, l'un des co-créateurs de Shadertoy, \nvous montre comment utiliser chaque donnée stockée dans iMouse. \nLorsque vous cliquez n'importe où dans la scène, un cercle blanc apparaît lorsque vous effectuez \nun clic de souris.\nSi vous maintenez la souris enfoncée et que vous la déplacez, une ligne jaune apparaît entre deux cercles.\nLorsque vous relâchez la souris, la ligne jaune disparaît.\n\nCe qui nous intéresse vraiment dans le cadre de ce tutoriel, ce sont les coordonnées de la souris.\nJ'ai réalisé une petite démo pour montrer comment vous pouvez déplacer un cercle dans le canvas\nà l'aide de votre souris. Regardons le code :\n\n\n*/\n\n#elif PART == 2\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return step(0., -d);\n}\n\nvec3 drawScene(vec2 uv, vec2 mp) {\n  vec3 col = vec3(0);\n  float blueCircle = sdfCircle(uv, 0.1, mp);\n  col = mix(col, vec3(0, 1, 1), blueCircle);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy - 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n  \n  // mp = mouse position of the last click\n  vec2 mp = iMouse.xy/iResolution.xy - 0.5; // <-0.5,0.5>\n  mp.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv, mp);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nRemarquez que l'obtention de la position de la souris est très similaire aux coordonnées UV.\nNous pouvons normaliser les coordonnées à l'aide de l'instruction suivante :\n\nvec2 mp = iMouse.xy/iResolution.xy // range is between 0 and 1\n\nCela normalisera les coordonnées de la souris pour qu'elles soient comprises entre zéro et un.\nEn soustrayant 0,5, nous pouvons normaliser les coordonnées de la souris pour qu'elles soient\ncomprises entre -0,5 et 0,5.\n\nvec2 mp = iMouse.xy/iResolution.xy - 0.5 // range is between -0.5 and 0.5\n\n# Panoramique de la caméra avec la souris\n\nMaintenant que nous savons comment utiliser la variable globale iMouse, appliquons-la à notre caméra.\nNous pouvons utiliser la souris pour contrôler le panoramique \nen modifiant la valeur de l'origine du rayon, ro.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 ro = vec3(mouse.x, mouse.y, 3); // ray origin will move as you click on the canvas and drag the mouse\n\nSi vous cliquez sur le canevas et faites glisser votre souris, vous pourrez faire pivoter la caméra\nentre -0,5 et 0,5 sur les axes x et y.\n\nLe centre du canvas sera le point (0, 0), ce qui devrait ramener le cube au centre du canvas. \n\nSi vous souhaitez effectuer un panoramique plus important, vous pouvez toujours multiplier\nles valeurs de la position de la souris par un multiplicateur.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 ro = vec3(2. * mouse.x, 2. * mouse.y, 3);\n\nhttps://inspirnathan.com/_nuxt/img/gif-7.76d9989.gif\n\n# Inclinaison/rotation de la caméra avec la souris\n\nNous pouvons incliner/rotationner la caméra avec la souris en changeant la valeur de theta,\nl'angle que nous fournissons à nos matrices de rotation telles que rotateX, rotateY et rotateZ.\n\nAssurez-vous que vous n'utilisez plus la souris pour contrôler l'origine du rayon, ro.\nSinon, vous risquez de vous retrouver avec une caméra très étrange.\n\nAppliquons la notion de \"lacet\" à la direction du rayon pour incliner la caméra de gauche à droite.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 rd = normalize(vec3(uv, -1)); // ray direction\nrd *= rotateY(mouse.x); // apply yaw\n\nÉtant donné que mouse.x est actuellement contraint entre -0,5 et 0,5, \nil serait peut-être plus judicieux de remapper cette plage à quelque chose comme pi négatif (-π) \nà pi positif (+π).\n\nPour remplacer un intervalle par un nouvel intervalle, nous pouvons utiliser la fonction mix.\nElle est déjà conçue pour gérer l'interpolation linéaire, elle est donc parfaite pour remapper\ndes valeurs d'une plage à une autre.\n\nRemettons la plage <-0,5, 0,5> dans la plage <-π, π>.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 rd = normalize(vec3(uv, -1)); // ray direction\nrd *= rotateY(mix(-PI, PI, mouse.x)); // apply yaw with a 360 degree range\n\nNous pouvons maintenant effectuer une rotation complète de 360° à l'aide de notre souris !\n\nVous vous demandez peut-être comment utiliser la valeur mouse.y.\nNous pouvons utiliser cette valeur pour incliner la caméra vers le haut et vers le bas en tant\nqu'angle de \"pitch\". \n\nCela signifie que nous devons utiliser la fonction rotateX.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 rd = normalize(vec3(uv, -1)); // ray direction\nrd *= rotateX(mouse.y); // apply pitch\n\nCela nous permettra d'incliner la caméra de haut en bas entre les valeurs de -0,5 et 0,5.\n\nSi vous souhaitez utiliser la souris pour modifier simultanément l'angle de \"lacet\" avec mouse.x \net l'angle de \"tangage\" avec mouse.y, nous devons multiplier les matrices de rotation.\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 rd = normalize(vec3(uv, -1));\nrd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\n\nvec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\nvec3 rd = normalize(vec3(uv, -1));\nrd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\n\nMaintenant, vous pouvez librement incliner la caméra avec votre souris pour regarder autour de la scène !\nCela peut être pratique pour dépanner des scènes 3D complexes construites avec Shadertoy.\nDans des logiciels tels que Unity ou Blender, vous disposez déjà d'une caméra puissante\nque vous pouvez utiliser pour regarder autour des scènes 3D.\n\nhttps://inspirnathan.com/_nuxt/img/gif-8.aa8a10f.gif\nVous trouverez le code terminé ci-dessous :\n*/\n\n#elif PART == 3\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n    int id; // identifier for each surface/object\n};\n\n/*\nSurface IDs:\n1. Floor\n2. Box\n*/\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col, 2);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col, 1);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(.5 + 0.3*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), identity()));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  vec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\n\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    // check material ID        \n    if( co.id == 1 ) // floor\n    {\n        col = co.col;\n    } else {\n      // lighting\n      vec3 lightPosition = vec3(2, 2, 7);\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      // color\n      float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n      col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n    }\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Conclusion\nDans ce tutoriel, nous avons appris à déplacer la caméra selon six degrés de liberté.\nNous avons appris à faire pivoter la caméra sur les axes x, y et z. \nNous avons également appris à utiliser les matrices de rotation pour appliquer le lacet, \nle tangage et le roulis, afin de contrôler l'inclinaison de la caméra.\n\nGrâce aux connaissances acquises aujourd'hui, vous pouvez déboguer des scènes 3D dans Shadertoy\net réaliser des animations intéressantes.\n\n*/\n\n#endif\n","name":"Image","description":"","type":"image"}]}