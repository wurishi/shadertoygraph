{"ver":"0.1","info":{"id":"4Xt3Ds","date":"1717154840","viewed":44,"name":"Dark Fractal","username":"CS476","description":"Simple experiment with raymarching and fractals\nFollowed along kishimisu's tutorial on raymarching, then changed some stuff","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265358979323846264\n\n// rotation matrix\nmat2 rot2D(float angle) {\n    float cosine = cos(angle);\n    float sine = sin(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}\n\n// distance methods\nfloat sdfSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat distFromScene(vec3 point) {\n    float result = 1.;\n    //result = min(point.y + 1., result);\n    result = min(sdfSphere(fract(point) - .5, .1), result);\n    return result;\n}\n\n// actual method that draws\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y,\n        mouse = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    // initialization\n    vec3 origin = vec3(0, 0, iTime);\n    vec3 dir = normalize(vec3(uv, 1.5));\n    vec3 color = vec3(0);\n    float dist = 0.;\n    bool hit = false;\n    \n    float angleX = mouse.x * PI, angleY = mouse.y * PI / 2.;\n    dir.yz *= rot2D(-angleY);\n    dir.xz *= rot2D(-angleX);\n    \n    // marching\n    for (int i = 0; i < 160; i++) {\n        vec3 point = origin + dir * dist;\n        //point.xy *= rot2D(dist * .05);\n        \n        float proximity = distFromScene(point);\n        dist += proximity;\n        \n        hit = proximity < 0.005;\n        if (hit || proximity > 1.) break;\n    }\n    \n    // final color\n    color = vec3(0);\n    if (hit) color = vec3(1. / dist / length(uv)); // lighting using distance from camera and uv coords\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}