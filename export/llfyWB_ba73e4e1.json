{"ver":"0.1","info":{"id":"llfyWB","date":"1506231398","viewed":3469,"name":"eigenvapor","username":"albatross","description":"Ｆｉｎａｌｌｙ, ａ ｓｈａｄｅｒ ｔｈａｔ ｍａｋｅｓ ｍｅ ｆｅｅｌ\n\nGreetz to numinit, crertel","likes":51,"published":1,"flags":98,"usePreview":0,"tags":["vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfSWl","filepath":"https://soundcloud.com/ernesto-vaughn/macintosh-plus-floral-shoppe-9","previewfilepath":"https://soundcloud.com/ernesto-vaughn/macintosh-plus-floral-shoppe-9","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHANNEL_OFFSET 2\n\nconst mat3 uneigenvapor = \n    mat3(0.0,             1.0 / sqrt(2.0),  1.0 / sqrt(2.0),\n         1.0 / sqrt(2.0), 0.0,              1.0 / sqrt(2.0),\n         1.0 / sqrt(3.0), 1.0 / sqrt(3.0),  -1.0 / sqrt(3.0));\n\n\nint isClose(float a, float b)\n{\n    float eps = 0.01;\n    if (a > (b - eps) && a < (b + eps)) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n       \n\nfloat sigmoid(float t, float adv)\n{\n    if ((t + adv) > 1.0) {\n        return 1.0;\n    } else {\n        if ((t + adv) < 0.0) {\n            return 0.0;\n        } else {\n            return sin((t + adv) * 1.57);\n        }\n    }   \n}\n\nvec3 punch(vec3 vapor)\n{\n    return vec3(\n        sigmoid(vapor.r, -0.05),\n        sigmoid(vapor.g, -0.05),\n        vapor.b\n        );\n}\n\nvec3 offset_and_combine(vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float sound = texelFetch(iChannel2, ivec2(1,0), 0).x +\n                  texelFetch(iChannel2, ivec2(2,0), 0).x +\n                  texelFetch(iChannel2, ivec2(3,0), 0).x;\n    float scaled_sound = sound / 3.0;\n    vec4 vapor_in_1 = textureOffset(iChannel0, uv, ivec2(0,0));\n    vec4 vapor_in_2 = textureOffset(iChannel0, uv, ivec2(7,7));\n    return vec3(\n        vapor_in_1.r,\n        vapor_in_2.g * scaled_sound + vapor_in_1.g * (1.0 - scaled_sound),\n        vapor_in_1.b\n    );\n}\n\nvec3 light_static(vec2 fragCoord)\n{\n    if (isClose(mod(fragCoord.x + fragCoord.y*3.0 + float(iFrame) / (fragCoord.y), 7.0),  \n                0.0) == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 unvaporize(vec3 rgb)\n{\n    return uneigenvapor * rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 scanlines = texture(iChannel1, uv);\n\tvec3 vapor_offset = offset_and_combine(fragColor, fragCoord);    \n    vec4 vapor_out = vec4(punch(vapor_offset), 1.0);\n    \n\tfragColor = vec4(unvaporize(vapor_out.rgb) + light_static(fragCoord), 1.0) + scanlines;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TOP_U 0.05000000\n#define TOP_V 0.05000000\n#define BOTTOM_U 0.30000000\n#define BOTTOM_V 0.15000000\n\n#define NUM_ROWS 14\n#define NUM_COLS 2\n\n#define SHIFT_AMOUNT 0.15\n#define SHIFT_SPEED 0.25\n#define SHIFT_WIDTH 30.0\n\nconst mat3 eigenvapor =\n    mat3(0.0,             1.0 / sqrt(2.0), 0.2 / sqrt(3.0),\n         1.0 / sqrt(2.0), 0.0,             0.2 / sqrt(3.0),\n         1.0 / sqrt(2.0), 1.0 / sqrt(2.0), -0.2 / sqrt(3.0));\n\nconst uint[NUM_ROWS * NUM_COLS] bitmap = uint[] (\n    0x300030ffU, 0x00003030U,\n    0x780031ffU, 0x03803030U,\n    0xfc003383U, 0x07803030U,\n    0xce003303U, 0x0f803031U,\n    0x87003303U, 0x1f803033U,\n    0x03003383U, 0x3f803873U,\n    0x030031ffU, 0x7f801ce3U,\n    0x030030ffU, 0x7f800fc3U,\n    0xff003003U, 0x3f800783U,\n    0xff003003U, 0x1f800303U,\n    0x03003003U, 0x0f800303U,\n    0x03003003U, 0x07800303U,\n    0x033ff003U, 0x03800303U,\n    0x033ff003U, 0x00000303U\n);\n\nvec4 render_bitmap(in vec2 originalUv, in vec4 pixel) {\n    vec2 uv = vec2(originalUv.x, 1. - originalUv.y);\n    if (uv.x < TOP_U || uv.x > BOTTOM_U ||\n        uv.y < TOP_V || uv.y > BOTTOM_V) {\n        // Not in the u/v box.\n        return pixel;\n    }\n\n    // Pick a pixel to sample\n    float x_fraction = (uv.x - TOP_U) / (BOTTOM_U - TOP_U);\n    float y_fraction = (uv.y - TOP_V) / (BOTTOM_V - TOP_V);\n\n    // Quantize to the nearest bitmap pixel\n    uint x_off = uint(trunc(x_fraction * float(NUM_COLS * 32)));\n    uint x_bit = x_off & 0x1fU;\n    x_off >>= 5;\n    uint y_off = uint(trunc(y_fraction * float(NUM_ROWS)));\n    float color = float(\n        (bitmap[y_off * uint(NUM_COLS) + x_off] & (1U << x_bit)) >> x_bit\n    );\n    return mix(pixel, vec4(color, color, color, 1.), color);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 originalUv = fragCoord.xy / iResolution.xy;\n   vec2 uv = originalUv;\n\n   float scanStart = mod( SHIFT_SPEED*iTime,1.0);\n   float distanceInScan = (uv.y - scanStart);\n   float isInScan = step(scanStart, uv.y);\n   float scanOffset = isInScan*sin(2.*SHIFT_WIDTH*distanceInScan + radians(45.))*exp(1.0-SHIFT_WIDTH*distanceInScan);\n   uv.x += SHIFT_AMOUNT*scanOffset;\n\n   vec4 original = render_bitmap(originalUv, texture(iChannel0, uv));\n     \n   fragColor = vec4(eigenvapor * original.rgb, 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float scan_height = clamp(sin(fragCoord.y*2.5 + float(iFrame)*1.0), -1.0, 0.25) * \n        abs(sin(fragCoord.y / 100.0 + float(iFrame) / 200.0));\n    fragColor = vec4(scan_height, scan_height, scan_height, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}