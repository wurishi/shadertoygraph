{"ver":"0.1","info":{"id":"MlXXz8","date":"1434984052","viewed":176,"name":"Bouncing sphere","username":"ryanmichael","description":"An implicit sphere drawn through screen coordinates. Uses the radius+sphere equation to extract the z-axis coordinate. The surface normal is computed from the z-axis coordinate and is used to create diffuse and specular shading effects.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["specular","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float _max( float a, float b )\n{\n\treturn a < b ? b : a;   \n}\nfloat _pow2( float x )\n{\n\treturn x*x;   \n}\n\nfloat _dot( vec3 a, vec3 b )\n{\n \treturn a.x*b.x + a.y*b.y + a.z*b.z;   \n}\n\nvec3 _normalize( vec3 a )\n{\n\treturn a / sqrt( _dot(a,a) ); \n}\n\n\n//Implicit sphere equation for inside/outside test\nbool insideCircle( vec2 coord, vec2 center, float radius )\n{\n    float phi = _pow2(coord.x - center.x) + _pow2(coord.y - center.y) - _pow2(radius);\n    return (phi < 0.0) ? true : false;\n}\n\n//Sphere Z-coord returned by solving sphere equation\nfloat findSphereZ( vec2 coord, vec2 center, float radius ) \n{\n    //Assume sphere center is at z = 0\n\treturn sqrt( _pow2(radius) - _pow2(coord.x - center.x) - _pow2(coord.y - center.y) );   \n}\n\n//Sphere normal finder\nvec3 getSphereNormal( vec3 coord, vec2 center ) \n{\n    //Assume sphere center is at z = 0 - bad practice to do this though\n    vec3 normVec = vec3( coord.x - center.x, coord.y - center.y, coord.z );\n    return _normalize(normVec);\n}\n\nvec2 getCenter( float loopTime, float radius )\n{\n    vec2 p0 = vec2( iResolution.x / 2.0, radius );\n    vec2 p1 = vec2( radius, iResolution.y / 2.0 );\n    vec2 p2 = vec2( iResolution.x / 2.0, iResolution.y - radius );\n    vec2 p3 = vec2( iResolution.x - radius, iResolution.y / 2.0 );\n        \n    float rem = mod(iTime,loopTime);\n    float frac = rem / loopTime;\n\n    //Scripted motion - compiler wouldn't let me embed ternary operators\n    vec2 center = (frac < 0.25 ) ? (p0 + frac*4.0*(p1-p0)) : vec2(0.0);\n    center = (frac > 0.25 && frac < 0.5 ) ? (p1 + (frac-0.25)*4.0*(p2-p1)) : center;\n    center = (frac > 0.5 && frac < 0.75 ) ? (p2 + (frac-0.5)*4.0*(p3-p2)) : center;\n    center = (frac > 0.75 && frac <= 1.0 ) ? (p3 + (frac-0.75)*4.0*(p0-p3)) : center;\n\n \treturn center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat radius = iResolution.x/5.0;\n    vec2 center = getCenter( 10.0, radius);\n    \n    //Camera position\n    vec3 cam = vec3( iResolution.x/2.0,iResolution.y/2.0, -radius*2.0 );\n    \n    //Light source vector\n    vec3 L1Pos = vec3( iResolution.x/2.0,iResolution.y/2.0, -radius*3.0 );\n    vec3 L1Color = vec3(0.5, 0.25, 0.5);\n    \n    vec3 L2Pos = vec3( iResolution.x,iResolution.y, -radius  );\n    vec3 L2Color = vec3(0.0, 0.5, 1.0);\n    \n    //Draw sphere if coord inside 2-D circle projection\n    if( insideCircle( fragCoord, center, radius ) )\n    {        \n        \n        float z = findSphereZ( fragCoord, center, radius );\n    \tvec3 surfaceCoord = vec3( fragCoord.x, fragCoord.y, -z );\n        vec3 N = getSphereNormal( surfaceCoord, center );\n        \n        vec3 L1 = _normalize( L1Pos - surfaceCoord );\n        \n        vec3 diffuseColor = L1Color * _dot( N, L1 );                  \n        \n        vec3 V = _normalize( cam - surfaceCoord );\n        \n        vec3 L2 = _normalize( L2Pos - surfaceCoord );\n               \n        vec3 R2 = 2.0 * _dot( N, L2 ) * N - L2;\n        \n        vec3 specularColor =L2Color * pow(_max(0.0,_dot(R2,V)),8.0);\n        \n        fragColor = vec4( diffuseColor + specularColor, 1.0 );\n    }\n    //Draw background colour otherwise\n    else fragColor = vec4(.45,.65,0.2,1.0);\n        \n}","name":"","description":"","type":"image"}]}