{"ver":"0.1","info":{"id":"lfdfzB","date":"1733245517","viewed":129,"name":"Ammann-Beenker - 340ch","username":"Elsio","description":"esta não é uma terceira versão das outras duas que fiz.\né a compressão de uma delas. Mas qual? kkk\nhttps://www.shadertoy.com/view/Mf3BRj\nhttps://www.shadertoy.com/view/lftfDM\n\ndescobre aí e me fala. \n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","quasicrystal","pattern","tesselation","short","cutandproject","prototiles","400ch"],"hasliked":0,"parentid":"lftfDM","parentname":"Ammann-Beenker aperiodic tilings"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Well obviously, this is just a projection of a 4D lattice \n// onto a particularly oriented 2D plane :D\n// extracted from https://www.shadertoy.com/view/XccXW8\n// @fabrice, @SnoopethDuckDuck & @elsio golf\n\nvoid mainImage(out vec4 o, vec2 u) {\n    mat4x2 T = mat4x2(  1.41,     0, \n                        1,        1, \n                        0,     1.41,\n                       -1,        1                  \n                     ), M;\n    mat2 m;\n    vec2 v = 4. * u / iResolution.y + iTime / 4.;\n\n    for(int i, j; i < 3; i++ )\n        for(j = i; j++ < 4;)\n            for(int k; k < 4;)\n                M = inverse(m = mat2(T[i], T[j])) * T,\n                u = round(v * m) + vec2(k % 2, k ++ / 2) - .5,\n                o = round(u * M),\n                \n                u = abs(\n                        u - M * (v * T - o)\n                          - vec2(o[i], o[j])\n                    ),\n                    \n                u = max(u, u.y),\n                \n                u.x < .5\n                    ? o = smoothstep(.0, .05, u.xxxx - .4),\n                    i = j = k = 5   : i;\n}\n\n/*\n     #1\n     \n     talvez ajude alguma coisa saber que \n     os valores úteis para (i, j) são exatamente esses seis pares:\n     (0, 1), (0, 2), (1, 2), (0, 3), (1, 3), (2, 3)\n     \n     mat4x2 T = mat4x2(  1.41,     0, \n                         1,        1, \n                         0,     1.41,\n                        -1,        1  ) / 2., M = T;\n                        \n     \n      mat2(T[i], T[j])\n      \n      (0, 1)\n              1.41, 0,  1,  1 \n      \n      (0, 2)\n              1.41, 0,  0, 1.41\n      \n      (1, 2)\n              1,    1,  0, 1.41\n      \n      (0, 3)\n              1.41, 0,  -1,  1 \n     \n      (1, 3)\n              1,    1,  -1,  1   \n      \n      (2, 3)\n              0, 1.41,  -1,  1\n     \n     \n\n*/\n\n\n/* 368ch\n\nvoid mainImage(out vec4 o, vec2 u) {\n    \n    mat4x2 T = mat4x2(  1.41,     0, \n                        1,        1, \n                        0,     1.41,\n                       -1,        1 \n                     \n                     ) / 2.;\n    \n    vec4 P = (8. * u / iResolution.y + iTime) * T;\n    \n    for(int i, j; i < 3; i++)\n        for(j = i; j++ < 4; )\n            for(int k; k < 4;) \n                u = round(vec2(P[i], P[j])) + vec2(k % 2, k++ / 2) - .5,\n                T = inverse(mat2(T[i], T[j])) * T, // #1\n                o = round(u * T),\n                u = abs(T * (P - o) + mat2(T[i], T[j]) * (vec2(o[i], o[j]) - u)) - .45,\n                u.x = max(u.x, u.y),\n                u.x < .05\n                    ? o -= o - smoothstep(.0, .02, u.x),\n                    i = j = k = 5 : i;           \n}\n\n*/\n\n\n/* 399ch\n\nvoid mainImage(out vec4 o, vec2 p) {\n    mat4x2 T = mat4x2(  1.41,     0, \n                        1,        1, \n                        0,     1.41,\n                       -1,        1 \n                     \n                     ) / 2., M = T;\n    float d;\n    vec2 r = iResolution.xy, s;\n    vec4 P = (4. * (p + p - r) / r.y + iTime) * T;\n    \n    for(int i, j; i < 3; i++ )\n        for(j = i; j++ < 4; )\n            for(int k; k < 4;) \n                M = inverse(mat2(T[i], T[j])) * T, // #1\n                s = round(vec2(P[i], P[j])) + vec2(k % 2, k++ / 2) - .5,\n                o = round(s * M),\n                p = abs(M * (P - o) + mat2(M[i], M[j]) * (vec2(o[i], o[j]) - s)),\n                \n                d = max(p.x, p.y) - .45,\n                d < .05\n                    ? o -= o - smoothstep(14. / r.y, 0., -d),\n                    i = j = k = 5 : i;           \n}\n\n\n*/\n\n\n\n\n\n\n\n\n\n/*  910ch\n\n#define pi acos(-1.)\n#define a vec4(cos(pi / 4.), .5, 0, -.5)\n#define b vec4(0, .5, cos(pi / 4.), .5)\n\nfloat sq(vec2 p){\n    p = abs(p) - .5;\n    return max(p.x, p.y);\n}\n\nfloat section(\n          int i, int j, \n          vec4 p4, vec4 id, \n          vec2 s\n      ) {\n    \n    mat2 m = inverse(mat2(a[i], b[i], a[j], b[j]));\n    vec2 p = (vec2(id[i], id[j]) + s) * m;\n    vec4 q = round(p.x * a + p.y * b), ofs = p4 - q;\n         \n    ofs[i] += q[i] - id[i] - s.x + .5;\n    ofs[j] += q[j] - id[j] - s.y + .5;\n        \n    return sq(m * vec2(dot(ofs, a), dot(ofs, b)) - .5);\n}\n\n\nfloat doit(vec4 p, vec4 id, int i, int j){\n    vec2 s = vec2(.5, -.5);\n\n    float \n    d = section(i, j, p, id, s.xx);\n    if(d < 0.) return d;\n\n    d = section(i, j, p, id, s.xy);\n    if(d < 0.) return d;\n\n    d = section(i, j, p, id, s.yx);\n    if(d < 0.) return d;\n\n    d = section(i, j, p, id, s.yy);\n    return d;\n}\n\nfloat map(vec2 z) {\n    vec4 p = z.x * a + z.y * b,\n         id  = round(p),\n         ofs = fract(p);\n    \n    for(int i; i < 3; i++) \n        for(int j = i + 1; j < 4; j++){\n            float d = doit(p, id, i, j);\n            if(d < 0.) return d;\n        } \n            \n    return .0;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;    \n    vec2 p = 3. * (u + u - r) / r.y + iTime;\n    \n    o = vec4(smoothstep(14. / r.y, 0., abs(map(p)) - .05));\n}\n\n*/","name":"Image","description":"","type":"image"}]}