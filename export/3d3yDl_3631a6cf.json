{"ver":"0.1","info":{"id":"3d3yDl","date":"1602873513","viewed":470,"name":"Mohawk","username":"GCScholar","description":"WASD or Arrows to move, QE up/down\nYou can change the resolution changing the #define GAME_RESOLUTION vec2(360.0, 220.0) in common\n ","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["comanchero"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 modulus = ceil(iResolution.xy/GAME_RESOLUTION);\n    vec2 sampleUVCoord = (floor(fragCoord/modulus)*modulus +0.5)/iResolution.xy;\n\tfragColor = vec4(texture(iChannel0, sampleUVCoord));\n   \n    // Gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(0.4545)),1.0);      \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//// SAVING / LOAD state between frames\nint fragCoordToLinear(vec2 fragCoord) { return int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5)); }\nvec2 linearToFragCoord(int i) { return vec2(mod(float(i), iResolution.x) - 0.5, floor(float(i) / iResolution.x) - 0.5); }\nvec4 loadTexelChannel0(int linearIndex) { return texture(iChannel0, linearToFragCoord(linearIndex)/iResolution.xy); }\nvoid saveVec4(vec4 value, vec2 uv, inout int pos, inout vec4 fragValue) { if(pos == fragCoordToLinear(uv)) fragValue = value; pos += 1;}\nvoid saveVec3(vec3 value, vec2 uv, inout int pos, inout vec4 fragValue) { saveVec4(vec4(value, 0.0), uv, pos, fragValue); }\nvoid saveVec2(vec2 value, vec2 uv, inout int pos, inout vec4 fragValue) { saveVec4(vec4(value, 0.0, 0.0), uv, pos, fragValue); }\nvoid saveFloat(float value, vec2 uv, inout int pos, inout vec4 fragValue) { saveVec4(vec4(value, 0.0, 0.0, 0.0), uv, pos, fragValue); }\nvoid saveMat4(mat4 value, vec2 uv, inout int pos, inout vec4 fragValue) { saveVec4(vec4(value[0]), uv, pos, fragValue); saveVec4(vec4(value[1]), uv, pos, fragValue); saveVec4(vec4(value[2]), uv, pos, fragValue); saveVec4(vec4(value[3]), uv, pos, fragValue); }\nvoid saveMat3(mat3 value, vec2 uv, inout int pos, inout vec4 fragValue) { saveMat4(mat4(value), uv, pos, fragValue); }\nvec4 loadVec4(inout int pos) { vec4 v = loadTexelChannel0(pos); pos += 1; return v; } \nvec3 loadVec3(inout int pos) { return loadVec4(pos).xyz; }\nvec2 loadVec2(inout int pos) { return loadVec4(pos).xy; }\nfloat loadFloat(inout int pos) { return loadVec4(pos).x; }\nmat4 loadMat4(inout int pos) { return mat4(loadVec4(pos), loadVec4(pos), loadVec4(pos), loadVec4(pos)); }\nmat3 loadMat3(inout int pos) { return mat3(mat4( loadVec4(pos), loadVec4(pos), loadVec4(pos), loadVec4(pos))); }\n\nState state; // Persistent shader state\n\nvoid saveState(vec2 fragCoord, inout vec4 fragValue) \n{\n    int pos = 1;\n    saveVec3(state.camRight, fragCoord, pos, fragValue);\t\t\n    saveVec3(state.camUp, fragCoord, pos, fragValue);\t\t\t\n    saveVec3(state.camForward, fragCoord, pos, fragValue);\t\t\n    saveVec3(state.camPosition, fragCoord, pos, fragValue);\t\t\n    saveVec2(state.camAngle, fragCoord, pos, fragValue);\t\t\n    saveFloat(state.camFovy, fragCoord, pos, fragValue);\t\t\n    saveVec2(state.lastMousePos, fragCoord, pos, fragValue);\t\n    saveFloat(state.isMouseDragging, fragCoord, pos, fragValue);\n    saveFloat(state.tilting, fragCoord, pos, fragValue);\t\t\n    saveFloat(state.rolling, fragCoord, pos, fragValue);\n    saveFloat(state.speed, fragCoord, pos, fragValue);\n}\n\nvoid loadState() \n{\n    int pos = 1;\n    state.camRight = loadVec3(pos);\t\t\t\n    state.camUp = loadVec3(pos);\t\t\t\n    state.camForward = loadVec3(pos);\t\t\n    state.camPosition = loadVec3(pos);\t\t\n    state.camAngle = loadVec2(pos);\t\t\n    state.camFovy = loadFloat(pos);\t\t\t\n    state.lastMousePos = loadVec2(pos);\t\t\n    state.isMouseDragging = loadFloat(pos);\t\t\t\n    state.tilting = loadFloat(pos);\n    state.rolling = loadFloat(pos);\n    state.speed = loadFloat(pos);\n}\n//// END SAVING / LOADING STATE\n\n\nvec4 getHeightMap(vec2 U) \n{\n    vec2 s = (MAP_DIMENSION-0.5)/iResolution.xy;\n    \n    // Scale U\n    U*=0.05*s;\n    \n    if(mod(U.x, 2.0*s.x) > 1.0*s.x) U.x = 1.0*s.x-(mod(U.x,1.0*s.x));\n    else U.x = mod(U.x,1.0*s.x);\n    if(mod(U.y, 2.0*s.y) > 1.0*s.y) U.y = 1.0*s.y-(mod(U.y,1.0*s.y));\n    else U.y = mod(U.y,1.0*s.y);\n\n    return texture(iChannel2, U); \n}\n\n// Handle keyboard and mouse inputs\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) \n    {\n        // Initialize shader state\n        \n        // Right handed camera frame reference\n        state.camAngle = vec2(0.0,PI/2.0);\n    \tstate.camForward = normalize(vec3(sin(state.camAngle.x)*sin(state.camAngle.y),-cos(state.camAngle.y), -cos(state.camAngle.x)*sin(state.camAngle.y)));\n        state.camRight = normalize(cross(vec3(0.,1.,0.), state.camForward));\n        state.camUp = normalize(cross(state.camForward, state.camRight));\n        state.camPosition = vec3(10.0,2.0,10.0);        \n        state.lastMousePos = vec2(0.0,0.0);\n        state.speed = 0.1;\n        saveState(fragCoord, fragColor);\n    } \n    else\n    {\n        // Update shader state basing on inputs\n        \n    \tloadState();\n        \n        vec2 camAngle;\n        vec3 camDir;\n        camDir = state.camForward;\n        \n        if(iMouse.z <= 0.0) state.isMouseDragging = 0.0;\n        if(iMouse.z > 0.0) \n        {\n            if(state.isMouseDragging == 0.0) { state.isMouseDragging = 1.0;state.lastMousePos = iMouse.xy;}\n            else\n            {\n                state.camAngle -= ((state.lastMousePos - iMouse.xy))/iResolution.xy * vec2(2.0*PI,PI);\n                state.camAngle = state.camAngle;\n                state.lastMousePos = iMouse.xy;\n            }\n        }\n    \t\n        camDir = normalize(vec3(sin(state.camAngle.y)*sin(state.camAngle.x),-cos(state.camAngle.y),sin(state.camAngle.y)*cos(state.camAngle.x)));\n        state.camForward = normalize(camDir);\n        state.camRight = normalize(cross(vec3(0.,1.,0.), state.camForward));\n        state.camUp = normalize(cross(state.camForward, state.camRight));\n        \n    \tfloat A_Pressed = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\t// Strafe left\n    \tfloat D_Pressed = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x; // Strafe right\n    \tfloat W_Pressed = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x; // Walk forward\n    \tfloat S_Pressed = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x; // Walk backforward\n        float LEFT_Pressed = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x;\t// Strafe left\n    \tfloat RIGHT_Pressed = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x; // Strafe right\n    \tfloat UP_Pressed = texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x; // Walk forward\n    \tfloat DOWN_Pressed = texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x; // Walk backforward\n        float Q_Pressed = texelFetch( iChannel1, ivec2(KEY_Q,0), 0 ).x; // Walk forward\n    \tfloat E_Pressed = texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x; // Walk backforward\n        float P_Pressed = texelFetch( iChannel1, ivec2(KEY_P,0), 0 ).x; // Switch camera\n        float O_Pressed = texelFetch( iChannel1, ivec2(KEY_O,0), 0 ).x; // Switch camera\n        float R_Pressed = texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x; // Switch camera\n        float F_Pressed = texelFetch( iChannel1, ivec2(KEY_F,0), 0 ).x; // Switch camera\n               \n        if(W_Pressed != 0.0 || UP_Pressed != 0.0) \n        {\n            state.speed = 0.1;\n            state.camPosition += state.speed*state.camForward; \n        \tstate.tilting = clamp(state.tilting + 0.01, -PI/8.0, PI/8.0);\n        }\n        else if(S_Pressed != 0.0 || DOWN_Pressed != 0.0) \n        {\n            state.speed = -0.1;\n            state.camPosition += state.speed*state.camForward;\n            state.tilting = clamp(state.tilting - 0.01, -PI*0.05, PI*0.03);\n        }\n        else \n        {\n            state.tilting = max(state.tilting - 0.05, 0.0);\t// Automatic zero the tilting\n            state.speed = 0.0;\n        }\n            \n        if(A_Pressed != 0.0 || LEFT_Pressed != 0.0) \n        {\n            state.camPosition -= 0.05*state.camRight;\n            state.rolling = clamp(state.rolling - 0.02, -PI/8.0, PI/8.0);\n            state.camAngle.x -= 0.01;\n        } \n        else if(D_Pressed != 0.0 || RIGHT_Pressed != 0.0) \n        {\n            state.camPosition += 0.05*state.camRight;\n            state.rolling = clamp(state.rolling + 0.02, -PI/8.0, PI/8.0);\n            state.camAngle.x += 0.01;\n        }\n        else state.rolling = max(state.rolling * 0.5, 0.0);\t// Automatic zero the rolling\n        \n        if(R_Pressed != 0.0) \n        {\n\t\t\tstate.speed = clamp(state.speed+0.01, 0.1, 1.0);\n\n        }\n        else if(F_Pressed != 0.0) \n        {\n            state.speed = clamp(state.speed-0.01, 0.1, 1.0);\n        }\n        \n        if(Q_Pressed != 0.0) state.camPosition -= 0.05*state.camUp;\n        if(E_Pressed != 0.0) state.camPosition += 0.05*state.camUp;\n        if(R_Pressed != 0.0) state.camFovy -= 0.1;\n        if(F_Pressed != 0.0) state.camFovy += 0.1;\n        \n        state.camPosition.y = max(state.camPosition.y, getHeightMap(state.camPosition.xz).w + 0.3);\n        state.camPosition.y = min(state.camPosition.y, 2.8);\n        \n        saveState(fragCoord, fragColor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define GAME_RESOLUTION vec2(360.0, 220.0)\n#define MAP_DIMENSION\tvec2(800,450)\n#define MAX_N_ENEMIES 30\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n// Tnx for simplex noise\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 3\nfloat turbulence (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs(snoise(st));\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n#define PI 3.14\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int KEY_LEFT = 37;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\nconst int KEY_Y = 89;\nconst int KEY_H = 72;\n\nmat4 Translate(float Tx, float Ty, float Tz) { return mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., Tx, Ty, Tz, 1. ); }\nmat4 RotateX(float angle) { float c = cos(angle); float s = sin(angle); return mat4(1., 0., 0., 0., 0., c,  s, 0., 0., -s,  c, 0., 0., 0., 0., 1.); }\nmat4 RotateY(float angle) { float c = cos(angle); float s = sin(angle); return mat4(c, 0., -s, 0., 0., 1., 0., 0., s, 0.,  c, 0., 0., 0., 0., 1. ); }\nmat4 RotateZ(float angle) { float c = cos(angle); float s = sin(angle); return mat4(c,  s, 0., 0, -s,  c, 0., 0, 0., 0., 1., 0, 0., 0., 0., 1); }\n\nmat4 RotateAxisAngle(vec3 axis, float angle) \n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//// RANDOM TERRAIN GENERATION\nfloat random(in vec2 st) \n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 4358.5453123);\n}\n\nfloat valueNoise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corner tiles\n    float n1 = random(i);\n    float n2 = random(i + vec2(1.0, 0.0));\n    float n3 = random(i + vec2(0.0, 1.0));\n    float n4 = random(i + vec2(1.0, 1.0));\n\n\t// Bi-linear interpolation of four corner tiles\n    return mix(\n        mix(n1, n2, smoothstep(0.0,1.0,f.x)),\n        mix(n3, n4, smoothstep(0.0,1.0,f.x)),\n        smoothstep(0.0,1.0,f.y));\n}\n\nvec3 applyFog( vec3  rgb, in float distance ) \n{\n    float fogAmount = 1.0 - exp( -distance*0.02);\n    vec3  fogColor  = vec3(0.4,0.7,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat fbm(in vec2 p) \n{\n    float value = 0.0;\n    float amplitude = 0.5;\n\n    p/=2.;\n    p+=vec2(10.0244,314.42); // Just a random value\n    //p+=vec2(9.2854,75.24);\n    \n    // Sum up octaves\n    value += 0.5 * valueNoise(p*0.6);\n    value += 0.225 * valueNoise(p*1.2);\n    value += 0.125 * valueNoise(p*2.4);\n    value += 0.0620 * valueNoise(p*4.8);\n    value += 0.0310 * valueNoise(p*9.6);\n    value += 0.0160 * valueNoise(p*19.2);\n    value += 0.0080 * valueNoise(p*40.0);\n    \n    return value;\n}\n\n// Sample the height map\nfloat heighMap(vec2 U)\n{\n    float value = fbm(U);    \n    \n    U/=2.;\n    float v2 = turbulence(0.2*U)-0.1;\n  \t\n    value = clamp(((v2 - value) + 0.3)*2.0,-10.0,1.0);\n    if(value <= 0.05 && value > -0.40) value = 0.05 * smoothstep(-0.15, 0.06, value);\n    else if(value < -0.4) value = 0.1*smoothstep(-0.4, -0.6, value);\n    \n    return value;    \n}\n\n// SDF functions tnx https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Shader persistent state\nstruct State\n{\n    vec3 camRight;\n    vec3 camUp;\n    vec3 camForward;\n\tvec3 camPosition;\n    vec2 camAngle;\n    float camFovy;\n    vec2 lastMousePos;\n    float isMouseDragging;\n    float tilting;\n    float rolling;\n    float speed;\n};","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// PRE RENDER MAP\n\n#define MAX_RENDER_DISTANCE 1.5\n#define PIXEL_SIZE_METERS   1.0\n#define FOV_X \t\t\t\t(PI/2.0)\n#define FOCAL_LENGTH\t\t(iResolution.x/tan(FOV_X/2.0))\n\n\nfloat getHeightMap(vec2 U) \n{\n    return heighMap(U)*1.5;\n    // Scale U\n    U*=0.05;\n    \n    // Map is mirrerd and repeated\n    if(mod(U.x, 2.0) > 1.0) U.x = 1.0-fract(U).x;\n    else U.x = fract(U.x);\n    if(mod(U.y, 2.0) > 1.0) U.y = 1.0-fract(U).y;\n    else U.y = fract(U.y);\n\n    //return texture(iChannel0, U).w*2.0; \n}\n\n// Ray march the terrain\nvec2 castRay(vec3 ro, vec3 rd, float maxt)\n{\n    float dt = 0.01f;\n    float mint = 0.001f;\n    float resT = 0.0f;\n    float d = 1.0;\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3 p = ro + rd*t;\n        float h = getHeightMap(p.xz);\n        d = min(d, 4.0*(abs(h-p.y)/t));\n        if( p.y < h)\n        {\n            resT = t - 0.8f*dt;\n            return vec2(resT, d);\n        }\n    }\n    return vec2(-1.0, d);\n}\n\n\nvec3 getNormal(vec3 p )\n{\n    float eps = 0.05;\n   // if(p.y>1.0) return vec3(0.0,1.0,0.0);\n    return normalize( vec3( getHeightMap(vec2(p.x-eps,p.z)) - getHeightMap(vec2(p.x+eps,p.z)),\n                            2.0*eps,\n                            getHeightMap(vec2(p.x,p.z-eps)) - getHeightMap(vec2(p.x,p.z+eps)) ));\n}\n\nvec3 getColor(vec3 p, vec3 n, vec3 ray ) \n{\n    vec3 rock = vec3(0.36, 0.3, 0.25);\n    vec3 verticalRock = vec3(0.5, 0.4, 0.6);\n    vec3 water = vec3(0.13, 0.36, 0.5);\n    vec3 grass = vec3(0.27, 0.54, 0.16);\n    vec3 color = vec3(0.0);\n    color = mix( rock/3.0, verticalRock/3.0, dot(n, vec3(0.0,1.0,0.0)));\n    \n    if(p.y<0.05) \n    { \n    \tcolor = mix(water/2.0, rock, p.y*5.0);\n    }\n    if(p.y>0.00 && p.y<0.45) \n    {\n        color = mix( color, grass/2.0, p.y*3.0*dot(n, vec3(0.0,1.0,0.0)));\n    }\n    if(p.y>0.10 && p.y<0.55) \n    {\n        color = mix( color, verticalRock/3.0, (p.y)*2.0);\n    }\n    \n    if(p.y > 0.3) \n    {\n    \tcolor = mix( color, vec3(0.3,0.3,0.3), p.y);\n    }\n    \n    return color;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Screen coordinates\n    \n    if(iFrame == 0)  \n    {\n        vec2 U = (fragCoord)/iResolution.xy;\n\t\tU*=20.0;\n    \t\n        // Shading - Key light\n    \tvec3 sunDir = normalize(vec3(0.8,0.4, 0.4));\n    \tvec3 sunColor = vec3(2.5, 1.5, 1.0);\n\t\n    \t// Sky - Fill light\n        vec3 skyDir = vec3(0.0, 1.0, 0.0);\n        vec3 skyColor = vec3(0.2, 0.2, 0.2);\n\n        // Ray march terrain\n        vec3 eye = vec3(U.x,5.0,U.y);\n        vec3 ray = vec3(0.0, -1.0, 0.0);\n    \tvec2 hit = castRay(eye, ray, 15.0);\n        \n        if(hit.x>0.0) \n        {\n            float d = hit.x;\n            vec3 P = eye+ray*(hit.x-0.03);\n            vec3 N = getNormal(P);\n            vec2 hit2;\n            hit2 = castRay(P, sunDir, 2.0);\n            \n            float sun = clamp( dot( N, sunDir ), 0.0, 1.0 );\n            float sky = clamp( 0.5 + 0.5*N.y, 0.0, 1.0 );\n            float ind = clamp( dot( N, normalize(sunDir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\t// Opposite respect sun light\n            \n            vec3 lin;\n            lin  = sun * vec3(1.5,1.5,0.99);\n            lin *= hit2.y;\n            lin += sky * vec3(0.40,0.20,0.28);\n        \tlin += ind * vec3(0.40,0.40,0.50);//*occ;\n            fragColor = vec4(lin * getColor(P,N, ray) ,1.0); \n            fragColor.w = heighMap(U)*1.5;\n        \n        }\n                        \n        return;\n    }\n    \n           \n   \tfragColor = texture(iChannel0, fragCoord/iResolution.xy );\n   \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define MAX_VIEW_DISTANCE 20.0\n\n// PRINT TEXT\n// Print char tnx https://www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 p, int C) \n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n   //return texture   ( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) );\n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\nvec4 printText(in int asciiCodes[8], in vec2 U) \n{\n\tvec4 color;\n    for(int i=0; i<8; i++)\n    {\n        color += vec4(char(U, asciiCodes[i]).x);  U.x-=0.5; // H\n    }\n    return color;\n}\n// END PRINT TEXT\n\n// SAVING / LOAD state between frames\nint fragCoordToLinear(vec2 fragCoord) { return int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5)); }\nvec2 linearToFragCoord(int i) { return vec2(mod(float(i), iResolution.x) - 0.5, floor(float(i) / iResolution.x) - 0.5); }\nvec4  loadTexelChannel0(int linearIndex) { return texture(iChannel0, linearToFragCoord(linearIndex)/iResolution.xy); }\nvec4  loadVec4(inout int pos) { vec4 v = loadTexelChannel0(pos); pos += 1; return v; } \nvec3  loadVec3(inout int pos) { return loadVec4(pos).xyz; }\nvec2  loadVec2(inout int pos) { return loadVec4(pos).xy; }\nfloat loadFloat(inout int pos) { return loadVec4(pos).x; }\nmat4  loadMat4(inout int pos) { return mat4(loadVec4(pos), loadVec4(pos), loadVec4(pos), loadVec4(pos)); }\nmat3  loadMat3(inout int pos) { return mat3(mat4( loadVec4(pos), loadVec4(pos), loadVec4(pos), loadVec4(pos))); }\n\n// Persistent shader state\nState state;\n\nvoid loadState() \n{\n    int pos = 1;\n    state.camRight = loadVec3(pos);\t\t\t\n    state.camUp = loadVec3(pos);\t\t\t\n    state.camForward = loadVec3(pos);\t\t\n    state.camPosition = loadVec3(pos);\t\t\n    state.camAngle = loadVec2(pos);\t\t\n    state.camFovy = loadFloat(pos);\t\t\t\n    state.lastMousePos = loadVec2(pos);\t\t\n    state.isMouseDragging = loadFloat(pos);\t\n\tstate.tilting = loadFloat(pos);\n\tstate.rolling = loadFloat(pos);\n    state.speed = loadFloat(pos);\n}\n// END SAVING / LOADING STATE\n\n\n// LANDSCAPE\n\n#define MAX_RENDER_DISTANCE 1.5\n#define PIXEL_SIZE_METERS   1.0\n#define FOV_X \t\t\t\t(PI/2.0)\n#define FOCAL_LENGTH\t\t(iResolution.x/tan(FOV_X/2.0))\n\n#define drawPoint(P, r) step( length(U - P), r)\n#define drawLine(A, B, r) smoothstep(0.0, distanceFromSegment(U, A, B), r)\n\nfloat distanceFromSegment(vec2 U, vec2 A, vec2 B) \n{\n\tvec2 UA = U - A;\n    vec2 BA = (B - A);\n    \n    float s = dot(UA, BA) / length(BA);   // scalar projection of U-A on B-A\n    s = s / length(BA); \t\t\t\t  // normalize the projection value in the range [0,1], \n    \t\t\t\t\t\t\t\t      //  a value of 0 means the projection correspond to A, 1 to B,\n    \t\t\t\t\t\t\t\t\t  //  in between the projection is inside the segment, \n                                          //  outside [0,1] the projection is outside the segment.\n    s = clamp(s, 0., 1.);                 // If the scalar projection is outside [0,1], its value is clamped to \n                                          //  0 or 1 ...\n   \t\n    return length(UA - s*BA);          \t  // ... so here we compute the distance of U from its projection if it is\n                                          // inside the segment, or from the extreme points A or B if it is outside\n}\n\n\nvec4 getHeightMap(vec2 U) \n{\n    vec2 s = vec2(MAP_DIMENSION.x-0.5, MAP_DIMENSION.y-0.5)/(iResolution.xy);\n    \n    // Scale U\n    U*=0.05*s;\n    \n    if(mod(U.x, 2.0*s.x) > 1.0*s.x) U.x = 1.0*s.x-(mod(U.x,1.0*s.x));\n    else U.x = mod(U.x,1.0*s.x);\n    if(mod(U.y, 2.0*s.y) > 1.0*s.y) U.y = 1.0*s.y-(mod(U.y,1.0*s.y));\n    else U.y = mod(U.y,1.0*s.y);\n\n    return texture(iChannel1, U); \n}\n\nstruct Hit \n{\n\tfloat t;\n    float h;\n    vec4 textureMap;\n};\n\n\nvec2 sdScene(vec3 P) \n{    \n    float d = MAX_VIEW_DISTANCE;\n    for(int i=0; i<10; i++) \n    {\n    \t//d = min(d, sdSphere(P+state.enemies[i], 0.2));\n    }\n   \t\n    return vec2(d, 1.0);\n}\n\n// Compute the normals at P\nvec3 normal(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.001);\n    return normalize(vec3(\n        sdScene(P+eps.yxx).x - sdScene(P-eps.yxx).x, \n\t\tsdScene(P+eps.xyx).x - sdScene(P-eps.xyx).x, \n        sdScene(P+eps.xxy).x - sdScene(P-eps.xxy).x));\n}\n\nvec2 marchRay(vec3 ro, vec3 rd) \n{\n    float mint = 0.01;\n    float t = 0.0;\n    while(t < MAX_VIEW_DISTANCE+10.0)\n    {\t\n        vec3 p = ro + rd*t;\n        if(p.y < 0.0 && p.y > 2.0) break;\n        vec2 h = sdScene(p);\n        if( h.x < 0.01)\n        {\n            return vec2(t, h.y);\n        }\n        t+=h.x;\n    }\n    return vec2(MAX_VIEW_DISTANCE, -1.0); // No hit\n}\n\n\nvec4 drawHud(vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv, vec2 U)\n{\n    vec4 result = vec4(0.0);\n    \n    vec3 P = vec3(0.0, 0.0, 10.0);\n    P = (RotateAxisAngle(vec3(1.0, 0.0, 0.0), asin(-ww.y)) * vec4(P, 1.0)).xyz;\n    P.y -= state.camPosition.y;\n    \n\t// Draw the overaly hud\n    P = 2.0*(P.xyz/P.z);\n    vec3 P1 = P + vec3(0.4, 0.0, 0.0);\n    vec3 P2 = P + vec3(0.05, 0.0, 0.0);\n    vec3 P3 = P + vec3(-0.05, 0.0, 0.0);\n    vec3 P4 = P + vec3(-0.4, 0.0, 0.0);\n    P1 = (RotateAxisAngle(vec3(0.0, 0.0, 1.0), asin(uu.y)) * vec4(P1, 1.0)).xyz;\n    P2 = (RotateAxisAngle(vec3(0.0, 0.0, 1.0), asin(uu.y)) * vec4(P2, 1.0)).xyz;\n    P3 = (RotateAxisAngle(vec3(0.0, 0.0, 1.0), asin(uu.y)) * vec4(P3, 1.0)).xyz;\n    P4 = (RotateAxisAngle(vec3(0.0, 0.0, 1.0), asin(uu.y)) * vec4(P4, 1.0)).xyz;\n    \n\tresult += \n        vec4(0.0, 0.6 * drawLine(P1.xy, P2.xy, 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(P1.xy*1.2, P2.xy*1.2, 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(P1.xy*1.3, P2.xy*1.3, 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(P3.xy, P4.xy, 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(P3.xy*1.2, P4.xy*1.2, 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(P3.xy*1.3, P4.xy*1.3, 0.002), 0.0, 1.0) +\n    \tvec4(0.0, 0.6 * drawLine(vec2(-0.1,-0.6), vec2(0.1,-0.6), 0.002), 0.0, 1.0) +\n        vec4(0.0, 0.6 * drawLine(vec2(0.0,-0.7), vec2(0.0,-0.5), 0.002), 0.0, 1.0) - \n        vec4(0.0, 0.6 * drawLine(vec2(-0.01,-0.6), vec2(0.01,-0.6), 0.002), 0.0, 1.0)-\n        vec4(0.0, 0.6 * drawLine(vec2(0.0,-0.59), vec2(0.0,-0.61), 0.002), 0.0, 1.0) ;\n    \n    float h = abs(0.3-0.8)*state.camPosition.y/1.5;\n    result += vec4(0.0, 0.6 * drawLine(vec2(1.59,-0.8), vec2(1.59,h-0.8), 0.002), 0.0, 1.0);\n    result += vec4(0.0, 0.6 * drawLine(vec2(1.61,-0.8), vec2(1.61, 0.2), 0.002), 0.0, 1.0);\n   \n    // Print the altitude\n    int text[5] = int[5](48+int(h*10.0), 48+int(mod(h*100.0,10.0)), 48+int(mod(h*1000.0, 10.0)), 46, 0);\n\tvec2 U_t =(U+vec2(-1.38,-h+0.8))*10.0;\n    for(int i=0; i<4; i++) \n    { \n        result += vec4(0.0, char(U_t, text[i]).x, 0.0, 1.0); U_t.x-=0.5;\n    }\n        \n    int text2[10] = int[10](83, 80, 69, 69, 68, 58, 32, 48+int(h*10.0), 48+int(mod(state.speed*100.0,10.0)), 48+int(mod(state.speed*1000.0, 10.0)));\n    U_t =(U+vec2(1.7,1.5))*10.0;\n    for(int i=0; i<10; i++) \n    { \n        result += vec4(0.0, char(U_t, text2[i]).x, 0.0, 1.0);  \n        U_t.x-=0.5; \n    }\n\n    // Peinr directions\n    float cosA;\n    \n    if(ww.z >= -0.2)\n    {\n        cosA = dot(ww.xz, vec2(1.0, 0.0));\n        U_t =(U+vec2(cosA*0.2,-0.2))*10.0;\n        result += vec4(0.0, char(U_t, 78).x, 0.0, 1.0); \n    }\n    \n    if(ww.z <= 0.2)\n    {\n        cosA = dot(ww.xz, vec2(-1.0, -0.0));\n        U_t =(U+vec2(cosA*0.2,-0.2))*10.0;\n        result += vec4(0.0, char(U_t, 83).x, 0.0, 1.0);  \n    }\n    \n    if(ww.x >= -0.2)\n    {\n        cosA = dot(ww.xz, vec2(0.0, -1.0));\n        U_t =(U+vec2(cosA*0.2,-0.2))*10.0;\n        result += vec4(0.0, char(U_t, 87).x, 0.0, 1.0);  \n    }\n    \n    if(ww.x <= 0.2)\n    {\n        cosA = dot(ww.xz, vec2(0.0, 1.0));\n        U_t =(U+vec2(cosA*0.2,-0.2))*10.0;\n        result += vec4(0.0, char(U_t, 69).x, 0.0, 1.0);  \n    }\n    \n    return result; \n}\n\nvec4 drawMap(vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv, vec2 U)\n{\n    vec4 result = vec4(0.0);\n    \n    // Set map position on screen\n    U.y+=0.7;\n    U.y+=0.5;\n    U.x-=1.3;\n    \n    if(abs(U.x) < 0.3 && abs(U.y) < 0.3)\n    {\n        vec3 cp=state.camPosition; \n        result = getHeightMap( (Translate(cp.x,cp.z,0.0)*RotateZ(-state.camAngle.x)*vec4(U*20.0,0.0,1.0)).xy );\n    }\n    \n    return result;\n}\n\nHit castRay(vec3 ro, vec3 rd, float maxt)\n{\n    Hit hit; \n    \n    float dt = 0.01;;\n    float mint = 0.01;\n    float resT = 0.0;\n    float d = 1.0;\n    for( float t = mint; t < maxt; t += dt )\n    {\t\n        vec3 p = ro + rd*t;\n        vec4 tx = getHeightMap(p.xz);\n        hit.textureMap = tx;\n        hit.h = tx.w;\n        if( p.y < hit.h)\n        {\n            resT = t - 0.8f*dt;\n            hit.t = resT; \n            return hit;\n        }\n        dt = 0.01f*t;\n    }\n    hit.t = MAX_VIEW_DISTANCE; \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    loadState();\n    \n    vec2 modulus = ceil(iResolution.xy/GAME_RESOLUTION);\n    if(mod(fragCoord, modulus) != vec2(0.5,0.5)) \n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Screen coordinates\n    vec2 U = (2.0*(fragCoord) - iResolution.xy)/iResolution.y;\n    U.y -= 0.6;\n    // Camera\n    vec3 eye = state.camPosition;    \n    vec3 ww = (RotateAxisAngle(state.camRight, state.tilting) * vec4(state.camForward,1.0)).xyz;\n    vec3 uu = state.camRight.xyz - state.rolling * state.camUp.xyz;\n \tvec3 vv = (RotateAxisAngle(state.camRight, state.tilting) * vec4(state.camUp,1.0)).xyz + state.rolling * ww;\n    vec3 ray = normalize(vec3(U.x*uu + U.y*vv + 2.0*ww));\n    \n    \n    vec2 cloudCoord = vec2(asin(ray.x)*15.0+(1.0-asin(ray.x)),(asin(ray.y)*18.0)*1.0);\n\tfloat cloud = max(fbm(cloudCoord)-0.4, 0.0);\n        \n    // Ray march terrain\n    vec2 en = marchRay(eye, ray);\n    Hit hit = castRay(eye, ray, en.x);\n    \n    if(hit.t < en.x) \n    {\n            fragColor = hit.textureMap;\n            if(hit.h < 0.01) fragColor += cloud*0.2;\n            //fragColor = vec4(applyFog(fragColor.xyz, hit.t), 1.0); \n        \n    }\n    else if(hit.t > en.x) \n    {\n        vec3 P = eye + en.x*ray;\n        vec3 skyDir = vec3(0.0, 1.0, 0.0);\n        vec3 skyColor = vec3(0.2, 0.2, 1.2);\n    \tfragColor = vec4(clamp(dot(normal(P),skyDir),0.0,1.0)*skyColor, 1.0);\n    }\n   else \n    {\n    \tfragColor = vec4(0.31,0.59, 0.7, 1.0);\n        fragColor += cloud;\n    }\n\t\n    // Draw hud\n    vec4 hud  = drawHud(eye, ray, ww, uu, vv, U);\n    if(clamp(hud, 0.1, 1.0) != vec4(0.1,0.1,0.1,1.0)) fragColor += hud;\n    vec4 map = drawMap(eye, ray, ww, uu, vv, U);\n    if(map != vec4(0.0)) fragColor = map;\n                               \n}","name":"Buffer C","description":"","type":"buffer"}]}