{"ver":"0.1","info":{"id":"7tKXRw","date":"1640822278","viewed":50,"name":"Shapes.SV","username":"turtlelover891","description":"I make shapes with raymarching\nhttps://www.youtube.com/watch?v=Ff0jJyyiVyw","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define minDistance 0.0001\n#define maxDistance 100.\n#define maxSteps 100\n#define temp vec2(0.001, 0.)\n\nfloat capsule(vec3 p){\n    float r = .25;\n    vec3 a = vec3(4., 2., 6.);\n    vec3 b = vec3(3., -.5, 6.);\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    float t = dot(ap, ab)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a+t*ab;\n    return length(c-p)-r;\n}\n\nfloat torus(vec3 p){\n    vec3 c = vec3(-2.1, -1., 5.);\n    float r1 = 1.;\n    float r2 = .1;\n    float d1 = length(p.xz-c.xz)-r1;\n    return length(vec2(d1, (p.y-c.y)))-r2;\n}\n\nfloat rectangle(vec3 p){\n    vec3[2] r1 = vec3[2](\n        vec3(1., 1., 5.), \n        vec3(1.,  1.5, 1.));\n    float r1d = length(max(abs(p-r1[0])-r1[1]/2., 0.));\n    return r1d;\n}\n\nfloat sphere(vec3 p){\n    vec4 s1 = vec4(-2., .5, 6., 1.);\n    float s1d = length(p-s1.xyz)-s1.w;\n    return s1d;\n}\n\nfloat mindist(vec3 p){\n    float minfloor = min(p.y+2., -p.z+10.+p.y/2.);\n    float minobj = min(sphere(p), rectangle(p));\n    minobj = min(minobj, torus(p));\n    minobj = min(minobj, capsule(p));\n    return min(minfloor, minobj );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col = vec3(0.);\n    float t = iTime;\n\n    vec3 o = vec3(0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, R.y));\n    vec3 p = o;\n    vec3 lightPos = vec3(sin(t)*2., sin(t*3.), 5.+cos(t)*1.5);\n    float dist = 0.;\n\n    //first march\n    for(int i=0; i<maxSteps; i++){\n        dist = mindist(p);\n        p += dir * dist;\n        if(dist < minDistance || dist > maxDistance) break;\n    }\n    \n    //calculate normals\n    vec3 n = normalize(mindist(p) - vec3(\n        mindist(p-temp.xyy),\n        mindist(p-temp.yxy),\n        mindist(p-temp.yyx)));\n\n    //test if light is inside object\n    bool inside = false;\n    if(mindist(lightPos) <= 0.2){\n        col -= .5;\n        inside = true;\n    }\n    \n    vec3 ldir = normalize(lightPos-p);\n    float l = (dot(n, ldir)+.5)/1.5;\n    col += clamp(l, 0., 1.);\n    float s = 1.;\n    \n    //calculate shadows if light isn't inside object\n    \n    if(!inside){\n        p += n/10.;\n        for(int i=0; i<maxSteps; i++){\n            dist = mindist(p);\n            if(dist > length(lightPos - p)) break;\n            if(dist < s) s = dist;\n            p += dist*ldir;\n            if(dist < minDistance || dist > maxDistance) break;\n        }col += s-.2;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}