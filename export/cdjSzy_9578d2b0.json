{"ver":"0.1","info":{"id":"cdjSzy","date":"1670467681","viewed":99,"name":"Logistic Bifurcation Diagram","username":"complexbezier","description":"A second iChannel is used to convert the output of my previous shadertoy into a diagram of bifurcation. Hit the play button and watch as the beloved bifurcation diagram gradually renders in red (the king color of scalar field plotting).","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["iterative","logistic","bifurcation","mathematical"],"hasliked":0,"parentid":"Ds2SWm","parentname":"Logistic Iteration"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//All the meaningful code is in Buffer A and Buffer B\n//If you want fullscreen, try to click it within 3 seconds\n//Of hitting the play button.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor=texture(iChannel1,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Horizontal zoom factor. Please keep >= 1.0\nfloat zoomFactor=1.0;\n//Max a-value. iteration always escapes after 4, so this is the default.\nfloat aMax = 4.0;\n\n\nfloat f(float x, float a) {\n    return a*x*(1.0-x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Set this higher than 1 if you're interested in seeing the detail on the right\n    float zoom = 1.; \n    float a = uv.x*aMax/zoomFactor+aMax*(1.-1./zoomFactor);\n    \n    float x;\n    if (iTime<3.) {\n        x = uv.y;\n        x = f(x,a);\n    }\n    else {\n        x = texture(iChannel0,uv).r;\n        x = f(x,a);\n    }\n    \n    fragColor = vec4(x,0.,0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = 0.;\n    int steps = 20;\n    float stepsize = 1./float(steps);\n    float offset = mod(mod(iTime,4.324242876),1.)*stepsize;\n    float prev = texture(iChannel1,uv).r;\n    for (int i = 0; i < steps; ++i) {\n        r = texture(iChannel0,vec2(uv.x,offset+float(i)*stepsize)).r;\n        if (abs(uv.y - r) < 0.001) {\n            prev += 0.001;\n        }\n    }\n    fragColor = vec4(prev,0.0,0.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}