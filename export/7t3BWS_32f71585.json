{"ver":"0.1","info":{"id":"7t3BWS","date":"1665762353","viewed":143,"name":"Diffuse Shading Models","username":"H2ongzh","description":"1. Lambert\n3. half-Lambert \n2. Oren Nayar\n4. minaret\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["diffuseshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: HongZhang\n// Date: 08/26/2022\n\n#define PI 3.141592653\n#define FOV 45.\n#define rad(x) x * PI / 180.\n#define MaxV 1e10\n#define Gramma(x) pow(x, vec3(1./2.2))\n\n// Object \nconst vec3 obj_c = vec3(0.5);\n\n// Camera\nconst vec3 cam = vec3(0., 0., 3.5);\n\n// saturate\nfloat saturate(float x){\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x){\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// define the SDF for sphere\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nvec3 sphereNormal(vec3 p){\n    return normalize(p);\n}\n\n// compute the view direction\nvec3 computeView(vec2 uv){\n    uv = (uv - 0.5) * 2.;\n    float h = tan(rad(FOV)/2.);\n    float w = h * (iResolution.x / iResolution.y);\n    return normalize(vec3(w * uv.x, h * uv.y, -1.));\n}\n\n// compute the sphere-line intersection \nvec2 computeIntersection(vec3 origin, vec3 ray, float radius){\n    float factor = pow(dot(origin, ray), 2.) - (dot(origin, origin) - radius * radius);\n    if(factor >= 0.){\n        float t1 = -dot(origin, ray) - sqrt(factor);\n        float t2 = -dot(origin, ray) + sqrt(factor);\n        return vec2(t1, t2);\n    }\n    return vec2(MaxV, -MaxV);\n}\n\n// get the light \nvoid getLight(out vec3 pos, out vec3 col){\n   pos = 5. * vec3(0., cos(iTime), sin(iTime));\n   col = vec3(1.);\n}\n\n\n// Lambert shading \nvec3 Lambert(vec3 l_p, vec3 p, vec3 view, vec3 norm, vec3 col){\n    vec3 l = normalize(l_p - p);\n    float diffuse = saturate(dot(l, norm));\n    return diffuse * col;\n}\n\n// Half-Lambert shading\nvec3 halfLambert(vec3 l_p, vec3 p, vec3 view, vec3 norm, vec3 col){\n    vec3 l = normalize(l_p - p);\n    float diffuse = pow((saturate(dot(l, norm))+1.)/2., 2.);\n    return diffuse * col;\n}\n\n// Minaert shading\nvec3 Minnaert(vec3 l_p, vec3 p, vec3 view, vec3 norm, vec3 col){\n    vec3 l = normalize(l_p - p);\n    float diffuse = pow((saturate(dot(-view, norm)) * saturate(dot(l, norm))), 2.);\n    return diffuse * col;\n}\n\n// Oren Nayar Shading\n// cite: https://mimosa-pudica.net/improved-oren-nayar.html\nvec3 OrenNayar(vec3 l_p, vec3 p, vec3 view, vec3 norm, vec3 col){\n    vec3 l = normalize(l_p - p);\n    \n    float r = PI/2.; // roughness\n    float q = 3.; \n    float l_v = saturate(dot(l, -view));\n    float l_n = saturate(dot(l, norm));\n    float n_v = saturate(dot(-view, norm));\n    float s = l_v - l_n * n_v;\n    float t = 0.;\n    if(s <= 0.)\n        t = 1.;\n    else\n        t = max(l_n, n_v);\n    \n    //float A = 1./(PI + (PI/2. - 2./3.)*r);\n    //float B = A * r;\n   \n    float A = 1./PI*(1. - 0.5 * r * r/(r*r + 0.33) + 0.17 * q * r * r/(r*r + 0.13) );\n    float B = 1./PI * (0.45 * r *r/(r*r + 0.09));\n    float diffuse = q * l_n * (A + B * s/t); \n    \n    return diffuse * col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = vec2(2.);\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    vec2 uv_i = floor(uv * scale);  // integer\n    vec2 uv_f = fract(uv * scale);  // fractions\n        \n    // lights\n    vec3 l_p, l_c;\n    getLight(l_p, l_c);\n    \n    // view\n    vec3 view = computeView(uv_f);\n    \n    // intersections\n    vec2 t_ab = computeIntersection(cam, view, 1.);\n    \n    if(t_ab == vec2(MaxV, -MaxV)){\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 p = min(t_ab.x, t_ab.y) * view + cam;\n    vec3 norm = sphereNormal(p);\n    \n    if(uv_i.x == 0. && uv_i.y == 0.){\n        vec3 col = Minnaert(l_p, p, view, norm, obj_c);\n        fragColor = vec4(Gramma(col), 1.);\n        return;\n    }\n    \n    \n    if(uv_i.x == 0. && uv_i.y == 1.){\n        vec3 col = Lambert(l_p, p, view, norm, obj_c);\n        fragColor = vec4(Gramma(col), 1.);\n        return;\n    }\n    \n    \n    if(uv_i.x == 1. && uv_i.y == 0.){\n        vec3 col = OrenNayar(l_p, p, view, norm, obj_c);\n        fragColor = vec4(Gramma(col), 1.);\n        return;\n    }\n    \n    if(uv_i.x == 1. && uv_i.y == 1.){\n       // vec3 col = Lafortune(l_p, p, view, norm, obj_c);\n       // fragColor = vec4(Gramma(col), 1.);\n        vec3 col1 = Lambert(l_p, p, view, norm, obj_c);\n        vec3 col2 = OrenNayar(l_p, p, view, norm, obj_c);\n        if(col1.r - col2.r <= 0.)\n            fragColor = vec4(vec3(Gramma(col2 - col1).r, 0., 0.), 1.);\n        else\n            fragColor = vec4(vec3(0., 0., Gramma(col1 - col2).r), 1.);\n        return;\n    }\n    \n\n}","name":"Image","description":"","type":"image"}]}