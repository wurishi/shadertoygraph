{"ver":"0.1","info":{"id":"dtGGRG","date":"1684173975","viewed":96,"name":"PBR lighting sample","username":"NikitOS","description":"https://learnopengl.com/PBR/Theory","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 c1 = vec3(0.3, 0.2, 0.7);\nvec3 albedo = vec3(0.980, 0.965, 0.0882);\nvec3 ao = vec3(0.01);\n\nconst float PI = 3.14159265359;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToGamma(vec3 col)\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow(col, vec3(1.0 / GAMMA));\n}\n\n// Fresnel equation (Schlick)\nvec3 F(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n// Normal distribution function (Trowbridge-Reitz GGX)\nfloat NDF(float NdotH, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH2 = NdotH * NdotH;\n\t\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\n// Geometry function (Schlick-Beckmann, Schlick-GGX)\nfloat GGX(float NdotV, float roughness)\n{\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\n// Geometry function (Smith's)\nfloat G(float NdotV, float NdotL, float roughness)\n{\n    float ggx2  = GGX(NdotV, roughness);\n    float ggx1  = GGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n// cook-torrance bidirectional reflective distribution function\nvec3 BRDF(float NdotL, float HdotV, float NdotV, float NdotH, float metallic, float roughness, vec3 F0)\n{\n    float ndf = NDF(NdotH, roughness);\n    float g = G(NdotV, NdotL, roughness);\n    vec3 f = F(HdotV, F0);\n    // PBR модель строится на принципе сохранения энергии и по этому энергия поглощенного и отраженного \n    // света в суммме не могут быть больше чем энергия падающего луча от источника света  \n    // f - Кофф Френеля по сути определяет отраженную часть света, поэтому kD - Кофф поглащенного света\n    // вычисляется просто kD = 1 - f , но с поправкой на металл/диэлектрик. Металл хуже поглощает свет.\n    vec3 kD = vec3(1.0) - f;\n    kD *= 1.0 - metallic;\n        \n    vec3 specular = (ndf * g * f) / (4.0 * NdotV * NdotL + 0.0001);            \n    return kD * albedo / PI + specular;\n}\n\nvec3 Lx(vec3 radiance, vec3 L, vec3 N, vec3 V, float metallic, float roughness, vec3 F0)\n{\n    vec3 H = normalize(L + V);\n    float NdotL = max(dot(N, L), 0.0);\n    float HdotV = max(dot(H, V), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    \n    // Уравнение отражения для источника света\n    return BRDF(NdotL, HdotV, NdotV, NdotH, metallic, roughness, F0) * radiance * NdotL;\n}\n\nvec4 sphere(vec2 pos, vec2 frag, vec3 lightPos, float r, float metallic, float roughness)\n{\n    // Вектор от центра шара до позиции текущего фрагмента в 2х мерных экранных координатах\n    vec2 spVec = frag - pos;\n    float spVecLen = length(spVec);\n    // Антиалиасинг границ шара на глазок\n    float aa = mix(1.0, 0.0, smoothstep(0.98, 1.00, spVecLen / r));\n    // Если длинна этого вектора больша радиуса шара, значит вышли за пределы шара\n    if (spVecLen > r)\n        return vec4(vec3(0.0), aa);\n        \n    // Глубина текущего фрагмента, для простоты центр шара имеет 0 глубину (z0 = 0)\n    // z1 = z0 ± sqrt(R^2 - (x1 - x0)^2 - (y1 - y0)^2)\n    float depth = sqrt((r * r) - (spVec.x * spVec.x) - (spVec.y * spVec.y));\n    // Позиция текущего фрагмента в 3хмерных координатах\n    vec3 spPoint = vec3(frag, depth);\n    // Вектор нормали к шару в текущем фрагменте \n    vec3 spNormal = normalize(spPoint - vec3(pos, 0.0));\n    // Вектор взгляда в текущем фрагменте\n    vec3 eyeDir = normalize(vec3(pos, 1.8) - spPoint);\n    // Модель PBR разделяет металы и диэлектрики, кофф F0 отвечает за это\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    \n    // Вычислим весь отраженный свет поступающий из полусферы на фрагмент\n    // Допустим поступает свет от 4х точечных источников света\n    vec3 L0 = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        // Вектор освещения в текущем фрагменте\n        vec3 lightDir = normalize((lightPos + vec3(float(i) * 2.0, float(i) * 1.0, 0.0)) - spPoint);\n        // Допустим источник света не затухает и светит чистым белым цветом \n        vec3 radiance = vec3(1.0, 1.0, 1.0);\n        // Вычисляем отраженный свет по одному источнику \n        L0 += Lx(radiance, lightDir, spNormal, eyeDir, metallic, roughness, F0);\n    }\n    \n    // Учитываем рассейное освещение (по идее берется из карты SSAO)\n    vec3 ambient = c1 * ao;\n    vec3 color   = ambient + L0;\n    \n    return vec4(color, aa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    vec2 uvCenter = iResolution.xy / min(iResolution.x, iResolution.y) / vec2(2.0, 4.0);\n    float timeCoeff = mod(iTime / 5.0, 6.28318);\n    vec3 lightPos = vec3(sin(timeCoeff) * 5.0, cos(timeCoeff), 6.0);\n    \n    vec4 color = vec4(0.0);\n    // Рисуем 6 шаров\n    float metallic = 0.84;\n    for (int j = 0; j < 2; ++j)\n    {\n        for (int i = -1; i < 2; ++i)\n        {\n            float roughness = (float(j + 1) + float(i + 2)) / 9.0;\n            vec2 pos = uvCenter + vec2(float(i) * 0.5, float(j) * 0.5);\n            color += sphere(pos, uv, lightPos, 0.22, metallic, roughness);\n        }\n        \n        metallic /= 7.7;\n    }\n    \n    // Финальный цвет в HDR\n    vec3 hdr = mix(vec4(c1, 0.0), color, color.a).rgb;\n    // Цвет в HDR надо преобразовать в LDR (0.0-1.0), самый простой способ\n    vec3 ldr = ToGamma(hdr / (hdr + vec3(1.0)));    \n    fragColor = vec4(ldr, 1.0);\n}","name":"Image","description":"","type":"image"}]}