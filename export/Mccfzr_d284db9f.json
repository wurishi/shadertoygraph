{"ver":"0.1","info":{"id":"Mccfzr","date":"1732637405","viewed":94,"name":"PathTraced: Shadows ,Emissive,GI","username":"sadekguerrah2","description":"This shader demonstrates a ray-traced soft shadow effect, leveraging a smooth shadow gradient to simulate realistic light behavior. By casting multiple rays and evaluating occlusion across a surface, it creates a visually pleasing transition between light","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracingsoftshadowsaccumilation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\n\n\n\nvec3 temperature(vec3 color, float temp)\n {    \n     vec3 coff;   \n      if(float(temp) < 0.0) {\n     coff.z = abs(temp/2.0);    \n     } else if (float(temp) > 0.0) {\n \n      coff.z = -temp/2.0; \n      }   \n   color *= vec3(1.0 - coff.x,1.0 - coff.y,1.0 - coff.z);\n  \n  return color;\n}\n\n\n\nvoid mainImage(out vec4 color, in vec2 p) {\n\n\n\n  vec3 col = texelFetch(iChannel0,ivec2(p),0).rgb;\n  \n     float temp = -0.0;    /// -1(warm) ................ 1(cool)\n    \n    col = temperature(col,temp);\n   \n  \n\n  color = vec4(col,1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float PI = 3.1415926535;\nconst float two_pi = 6.283185307f;\n\n\nuvec3 variableSeed = uvec3(0.0f);\n\n\n\nvec3 tempralScreenCoord;\n\n\nvec3 null;  // intentional absence of a value //\nvec3 jitter;  //RGB White Noise//\nvec3 sample_offset;\nvec3 direct_contribution = vec3(0.0f);\n\n\n///IGNOR CAMERA STUFF ETC....///////////////////////////////////////////////////\n\nmat4 m_viewMatrix;\nmat4 m_InversviewMatrix;\n\nmat4 m_projectionMatrix;\nmat4 m_InversprojectionMatrix;\n\nvec2 rotation(vec2 vector, float angle) {\n \n    angle = radians(angle);  //Degree to radians\n\n    float x = sin(angle);\n    float y = cos(angle);\n  \n     vec2 product = vector * mat2(y,x,-x,y);\n    \n    return product;\n    \n}\n\n\n//IGNOR WHITE NOISE FUNCTION ETC....//////////////////////////////////////////////\n\n//Thanks to nojima https://www.shadertoy.com/view/ttc3zr //\n\nint indexContribution;\n\nuvec3 murmurHash33(uvec3 src) {\n         \n        src += uvec3(44*indexContribution); \n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n\n \n\n   vec3 pointOrigin = vec3(1,0,3.66)    ;\n   vec3 sunPosition = vec3(-1,1,0);\n   float sunIntnsity = 3.5f;\n  \n\nconst float eps = 0.0001;\nconst float limit = float(1e20);\nconst float undefinedIndex = float(-1);\n\nstruct Data {\n   \n  vec4 sphere01 ;\n  vec4 sphere02;\n  vec4 sphere03 ;\n  vec4 sphere04;\n  vec4 sphere05;\n};\nData sceneData ;\n\n/////////////////////////////////////////\n/////UnitHemnisphereDistrubution/////////\n/////////////////////////////////////////\n\n  vec3 unitHemnisphereDis(vec3 normal , vec4 distribution) {\n   \n     float varriationDistribution = float(distribution.w);\n     vec2 unitDir = hash33((distribution.xyz)+vec3(321,456,0)*(varriationDistribution)).xy; ///\n     vec3 uDistribution = normalize(cross(normal, vec3(0.0,1.0,1.0) ) );\n\t   vec3  vv = cross( uDistribution, normal );\n\t   float ra = sqrt(unitDir.y);\n\t   float rx = ra*cos(two_pi*unitDir.x); \n\t   float ry = ra*sin(two_pi*unitDir.x);\n\t   float rz = sqrt( 1.0-unitDir.y );\n\t   vec3  rr = vec3( rx*uDistribution + ry*vv + rz*normal );\n    return normalize( rr );\n}\n\n\n// Microfacet\n\nvec3 F_Schlick(vec3 f0, float theta) {\n    return f0 + (1.-f0) * pow(1.0-theta, 5.);\n}\n\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0-theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = pow(roughness, 2.);\n    return a2 / (PI * pow((NoH*NoH)*(a2*a2-1.)+1., k));\n}\n\nfloat SmithG(float NDotV, float alphaG)\n{\n    float a = alphaG * alphaG;\n    float b = NDotV * NDotV;\n    return (2.0 * NDotV) / (NDotV + sqrt(a + b - a * b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness)\n{\n    float a2 = roughness*roughness;\n    float G1 = SmithG(NoV, a2);\n    float G2 = SmithG(NoL, a2);\n    return G1*G2;\n}\n\nvec3 SampleGGXVNDF(vec3 V, float ax, float ay, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(ax * V.x, ay * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(ax * Nh.x, ay * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GGXVNDFPdf(float NoH, float NoV, float roughness)\n{\n \tfloat D = D_GTR(roughness, NoH, 2.);\n    float G1 = SmithG(NoV, roughness*roughness);\n    return (D * G1) / max(0.00001, 4.0f * NoV);\n}\n\n\n\n\n///Sphere Function by iq\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\n///plane Function by iq \n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat hash1int1(int i) {\n \n  float product = sin(float(654321*i));\n   float product2 = cos(float(123456*i));               \n     return ((product-product2)+(product2+product))/2.0f;  \n}  \n\n\nvec4 intersection(vec3 rd, vec3 ro , inout vec3 normal) {\n\n  vec2 res = vec2( limit,undefinedIndex);\n  float t;\n   \n     /*Floor*/\n     t = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0, 0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1000.0); normal = vec3( 0., 1., 0.); }\n     \n     /*Spheres*/\n     \n     //Position & radius :: //radius is the fourth component a/w ;\n         sceneData.sphere01 = vec4( 4 , 1. ,2 , 1) ;\n         sceneData.sphere02 =  vec4( 2 ,1.7, 6.2, 1.0) ;\n         sceneData.sphere03 = vec4(-1 , 1.2f ,3 , 1.2f);\n         sceneData.sphere04 = vec4(5,3,-5.5,4);\n         sceneData.sphere05 = vec4(-7,3,-2.5,3);\n      \n     t = iSphere( ro, rd, sceneData.sphere01 ); if( t>eps && t<res.x ) { res = vec2( t, 1.0 ); normal = nSphere( ro+t*rd, sceneData.sphere01 ); }\n     t = iSphere( ro, rd, sceneData.sphere02 ); if( t>eps && t<res.x ) { res = vec2( t, 2.0 ); normal = nSphere( ro+t*rd, sceneData.sphere02 ); }\n     t = iSphere( ro, rd, sceneData.sphere03 ); if( t>eps && t<res.x ) { res = vec2( t, 3.0 ); normal = nSphere( ro+t*rd, sceneData.sphere03 ); }\n     t = iSphere( ro, rd, sceneData.sphere04 ); if( t>eps && t<res.x ) { res = vec2( t, 4.2 ); normal = nSphere( ro+t*rd, sceneData.sphere04); }\n      t = iSphere( ro, rd, sceneData.sphere05 ); if( t>eps && t<res.x ) { res = vec2( t, 4.3 ); normal = nSphere( ro+t*rd, sceneData.sphere05); }\n     \n   return vec4(res,1.0f,1.0f);\n}  \n   \n   int drawAlbedo(vec2 scene , out vec3 albedo) {\n      \n      if (scene.y == 1000.0 ) { albedo = vec3(.42f,.25f,1.48f);}\n      if (scene.y == 1.0 ) { albedo = vec3(1.0f,1.0,0.0f);}\n      if (scene.y == 2.0 ) { albedo = vec3(1.0f);}\n      if (scene.y == 3.0 ) { albedo = vec3(1.0f);}\n      if (scene.y > 4.0 && scene.y < 5.0) {albedo = vec3(0,1,1) * 0.5f;}\n      if (scene.y == 4.3) {albedo = vec3(1,.13,0.0) * 1.8f;} \n  return 1;\n}\n\n   \n  bool emissiveMaterial(vec2 scene) {\n    \n   bool condition = (scene.y - floor(scene.y)) == 0.0;   \n   if(!condition) {return true;} else { \n   return false ;}\n} \n   \n      int getReflectivity(vec2 scene , out float reflectivity) {\n      \n      if (scene.y == 1000.0 ) { reflectivity = 0.0 ;}\n      \n      if (scene.y == 1.0 ) { reflectivity = 0.0 ;}\n      if (scene.y == 2.0 ) { reflectivity = 0.0 ;}\n      if (scene.y == 3.0 ) { reflectivity = 0.0 ;}\n  return 1;\n}\n   \nbool shadowIntersection(vec3 hitpoint , vec3 sunVector , float ld) \n {\n  \n  vec3 n;\n  vec2 shadowDepth = intersection(sunVector, hitpoint , n).xy; \n    \n  if(shadowDepth.x > 3000.0f ) {return true;}\n\n  return false;\n}\n\n int shade(int loopindex, vec4 light ,vec3 hitpoint ,vec3 normal , out float shade) {\n   \n   vec3 sun = light.xyz + jitter ;\n    \n   float sunDistance = length(sun ); \n   vec3 sunDir = normalize(sun );\n    \n    shade = max(dot(normal , sunDir),0.0f); \n    shade /= pow(sunDistance,2.0f);\n    \n    bool shadows = shadowIntersection( hitpoint , sunDir , sunDistance );\n       \n       shade *= float(shadows) * light.w;\n   \n  return 1;\n}\n \n float isEmissive ;\n \n bool getEmissiveData(vec2 scene) {\n\n   return emissiveMaterial(scene);\n}\n\n float eInt = 30.0f;\n     vec3 contrubutionEmissive = vec3(0.0f); \n int rayShade(in vec3 hitpoint ,in vec3 normal ,in vec3 albedo,out vec3 finalColor , int loopIndex) {\n  \n\n  int i ;\n  float s;\n   hitpoint += jitter*0.5f;\n    \n   \n  \n\n   shade(loopIndex,vec4(sunPosition,2.0f) ,hitpoint, normal, s );\n  \n    finalColor = albedo*s;\n     //if(isEmissive > 0.0f) { finalColor += albedo * eInt ;}\n\n\n     \n       contrubutionEmissive = isEmissive * albedo;\n       contrubutionEmissive *= direct_contribution;\n     finalColor += vec3(contrubutionEmissive) * eInt; \n    \n    return i;\n}\n\n\n//////////////////////////////////////////////////////////////\n\nint GlobalilluminationArray(int indexBounce,inout vec3 contributionAlbedo,inout vec3 hitpoint, inout vec3 normal, inout vec3 color) {\n  \n variableSeed += uvec3(15261,26163,0);\n\n vec3 contribution = vec3(1.0f,1.0f,1.0f);\n  vec3 emissiveAlbedo = contributionAlbedo;\n  vec3 emissive = vec3(0.0f);\n  \n  hitpoint += normal*jitter*0.0005f;\n  vec3 indirectlighting = vec3(0.0f,0.0f,0.0f); // it need to be defined for highprecission color //\n    \n    vec3 rayDir = unitHemnisphereDis(normal , vec4(tempralScreenCoord,indexBounce));\n\n    vec2 hitBounceResults = intersection(rayDir , hitpoint , normal).xy; //normal is a *\n    \n    isEmissive += float(getEmissiveData(hitBounceResults)); \n     \n     vec3 pastrayorgin = hitpoint;\n     \n     hitpoint = rayDir*hitBounceResults.x + pastrayorgin;\n     hitpoint += normal*0.0002f;\n\n      drawAlbedo(hitBounceResults, indirectlighting);\n   \n        contribution *= contributionAlbedo;  \n         \n         contributionAlbedo = indirectlighting; ///for the multi-bounceReCall\n         \n      rayShade(hitpoint , normal , indirectlighting , indirectlighting , indexBounce);\n      \n        indirectlighting *= contribution;\n       \n     color += indirectlighting;\n       \n     \n  return 1;\n}\n/////////////////////////////////////////////////////////////////\n     \n   int reflectionArray(inout vec3 rayDir ,inout vec3 hitpoint , inout vec3 Normal , inout vec3 reflections) {\n    int i;   \n         rayDir = reflect(rayDir,(Normal + jitter*0.1f));\n         hitpoint += Normal*0.0005f;\n          \n           vec2 reflectionResult = intersection(rayDir,hitpoint,Normal).xy; \n                                hitpoint = rayDir*reflectionResult.x + hitpoint;\n                                  hitpoint += Normal*0.0005f;\n            vec3 reflectionAlbedo; \n           float reflectivity;\n\n            getReflectivity(reflectionResult,reflectivity);  \n            drawAlbedo(reflectionResult, reflectionAlbedo);\n              \n           vec3 nReflections;   \n    rayShade(hitpoint , Normal , reflectionAlbedo , nReflections , 0);\n    vec3 rd = rayDir; \n    vec3 hp = hitpoint;\n    vec3 n = Normal; \n    vec3 calbedo = reflectionAlbedo;    \n      const int inDirectReflections = 0;   ///Use only one for better performace and visual no need for 3 bounces \n      \n \n          for(int i = 0 ; i < inDirectReflections ; i++ ) { \n     // GlobalilluminationArray(calbedo,rd, hp , n , nReflections); \n     }\n     \n     reflections = mix(reflections,nReflections,reflectivity);\n\n  return 0;\n}     \n\n///for Global Illumination and multiDirection Reflections ////\n\n  int PathTracing(vec3 rayDir , vec3 hitpoint , vec3 Normal, vec3 ColorTint,in float reflectivity ,inout vec3 finalColor , int loopIndex ) {\n    \n    vec3 reflections;\n    vec3 indirectLighting = vec3(0.0f);\n\n       vec3 n = Normal; ///For Fresnal \n       vec3 inNormal = Normal; //For Global illumination /// \n       vec3 inRayDir = rayDir;\n       vec3 inHitpoint = hitpoint;\n       vec3 contributionAlbedo = ColorTint;\n         \n     for(int i = 0 ; i < 3 ; i++ ) { \n      GlobalilluminationArray(i + loopIndex + loopIndex + 1,contributionAlbedo, inHitpoint , inNormal , finalColor);\n      \n\n     }\n     \n     const int ReflectionsBounces = 2;\n     \n     for(int i = 0 ; i < ReflectionsBounces; i++) {\n   \n    //reflectionArray(rayDir , hitpoint , Normal , reflections);\n  \n}    \n    \n    reflections = max(reflections , 0.000001f); ///high precission correction///     \n    finalColor = max(finalColor , 0.000001f);\n         \n         \n         const float f0 =0.04;\n         float fresnal = f0 + (1.0 - f0 )*pow((dot(n,rayDir)+1.0),5.0);\n         fresnal = 1.0f - (fresnal);\n        // fresnal = clamp(fresnal,0.0f,1.0f);\n\n                  \n         //reflectivity = mix(reflectivity,1.0f,fresnal);\n         reflections *= ColorTint;\n         //reflectivity = 0.0f;\n         finalColor = mix(finalColor,reflections,reflectivity);\n         \n       //finalColor = vec3(fresnal);\n    return 0;\n}\n\n#define AGX_LOOK 1\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform (inset)\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Inverse input transform (outset)\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  // NOTE: We're linearizing the output here. Comment/adjust when\n  // *not* using a sRGB render target\n  val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n  ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/// ACCUMILATE 1 == on , ACCUMILATE 0 == off ///\n\n#define ACCUMILATE 1 \n#define DOF 1\n\n/// soft-Shadows ///\n\n  bool soft_Shadows = true;\n\n////////////////////\n\nfloat fieldOfView = 45.0f;\n\nbool needRefresh;\n int mask;\n \nbool movingCamera = false;   ///Disables ACCUMILATION if true due to movements\n\nvoid getRayTracingCamera(in vec2 coord , float focal ,out vec3 cameraPos, out vec3 rayDir ) {\n      \n     needRefresh = (iFrame == 0);\n    if (iMouse.z > .5) {\n            needRefresh = true;\n           }   \n\n   float lasttime;\n   float time = float(iFrame)/100.0;\n     \n \n   vec2 camDelta;\n   vec3(0,1,0);\n  \n   vec2 m;\n      m = (iMouse.xy / iResolution.xy) * 3. + vec2(-1,-3);\n    \n\n     m *= 0.5;\n      \n      float refreshTime;\n     if(needRefresh ) {float w = 1. / (float(iTime)-refreshTime + 1.) ;\n                            time = w ; } else { refreshTime = iTime; }\n\n     if( needRefresh ) { time *= 0.0;} \n\n  \n     m.x +=( time * 0.5 * float(movingCamera)); \n     \n vec3 Dir = vec3(0,-0.1,1);\n  \n      Dir.yz = rotation(Dir.yz,  90. * m.y);\n      Dir.xz = rotation(Dir.xz, 180. * m.x);\n       \n      Dir.y = min(Dir.y,-0.1); \n  float radius = 7.0f;\n  cameraPos = pointOrigin - Dir*radius; \n\n  rayDir = normalize(vec3(coord,focal));\n          rayDir.yz = rotation(rayDir.yz,  90. * m.y);\n          rayDir.xz = rotation(rayDir.xz, 180. * m.x);\n}\n\nstruct r {\n\nvec3 Direction;\nvec3 Origin;\n\n};\n\nr ray;\n\nstruct p {\n vec3 normal;\n vec3 albedo;\n vec3 hitpoint;\n float distance;\n};\n\n  p payload; \n  \n\n\nvec3 RayTracing(vec3 rd , vec3 ro , int loopIndex){\n  \n  vec3 inColor = vec3(1.0f);\n  vec3 totalColor = vec3(0.0f);\n  \n  float reflectivity;\n  \n  vec2 getSceneData = intersection(rd,ro,payload.normal).rg;\n  \n   isEmissive += float(getEmissiveData(getSceneData)); \n  \n  int getAlbedo = drawAlbedo(getSceneData , payload.albedo);\n     direct_contribution = payload.albedo;\n     getReflectivity(getSceneData,reflectivity); \n  \n   payload.distance = getSceneData.x;\n   payload.hitpoint = ((rd*payload.distance)+ro) + (payload.normal*0.001f);   //to avoid self-interesection add 0.001f * normal\n   \n   \n     rayShade(payload.hitpoint , payload.normal , payload.albedo , totalColor , loopIndex );\n\n\n    PathTracing(rd , payload.hitpoint , payload.normal,payload.albedo ,reflectivity , totalColor, loopIndex );\n\n  return vec3(totalColor);\n}\n\n\n\nvoid mainImage( out vec4 color, in vec2 p )\n{\n    \n\n   \n    float aspect_ratio = iResolution.x/iResolution.y; \n    float focal_length = 1.0f/tan(radians(fieldOfView)/2.0f);  \n    \n    vec3 prvtot = texelFetch(iChannel0 , ivec2(p),0).rgb;\n    \n    vec2 texCoord = (p.xy/iResolution.xy);\n      tempralScreenCoord = vec3(texCoord,iTime);\n    \n    sample_offset = hash33(vec3 (texCoord,iTime));\n    float radialSample = 0.0f;\n    \n    if(!needRefresh) { radialSample = 0.002;}\n    texCoord += sample_offset.yz*radialSample;\n    if (soft_Shadows) {jitter = hash33(vec3(texCoord,iTime)) - 0.5f;} else {jitter = vec3(0.0f);}  ///Activates the Noise\n    \n   \n  \n    vec2 wCoord = (texCoord*2.0f - 1.0f) * vec2(aspect_ratio,1.0f); //ScreenCoord form -1...1 \n       \n    \n       \n       getRayTracingCamera(wCoord,focal_length,ray.Origin , ray.Direction);\n       \n     mask = int(round(sin(iTime)));\n     float mask2 = sin(3.0f*texCoord+iTime).x; \n      \nvec3 tot = vec3(0);\n\n\n\n   for(int i = 1; i < 2 ; i++) {\n      \n      indexContribution = i;\n      jitter = hash33(vec3(texCoord + vec2(i),iTime)) - 0.5f;\n     tot = mix(tot,RayTracing(ray.Direction,ray.Origin, i ),1.0f/float(i));   \n            \n}\n\n vec2 dff = texture(iChannel1,texCoord).rg; \n  \n    \nif (ACCUMILATE != 0 && soft_Shadows && movingCamera == false) {   \n\n    if(needRefresh){\n    color = vec4(tot + prvtot/float(3.987654321),1.0);\n     // color = vec4(dff,0.0,1);\n}\n   else {\n   color = vec4(vec3(tot),1.0) + texelFetch(iChannel0 , ivec2(p),0); \n}\n} else {color = vec4(vec3(tot),1.0);}\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nconst float overlap = 0.2;\n\nconst float rgOverlap = 0.1 * overlap;\nconst float rbOverlap = 0.01 * overlap;\nconst float gbOverlap = 0.04 * overlap;\n\nconst mat3 coneOverlap = mat3(1.0, \t\t\trgOverlap, \trbOverlap,\n\t\t\t\t\t\t\t  rgOverlap, \t1.0, \t\tgbOverlap,\n\t\t\t\t\t\t\t  rbOverlap, \trgOverlap, \t1.0);\n\nconst mat3 coneOverlapInverse = mat3(\t1.0 + (rgOverlap + rbOverlap), \t\t\t-rgOverlap, \t-rbOverlap,\n\t\t\t\t\t\t\t\t\t  \t-rgOverlap, \t\t1.0 + (rgOverlap + gbOverlap), \t\t-gbOverlap,\n\t\t\t\t\t\t\t\t\t  \t-rbOverlap, \t\t-rgOverlap, \t1.0 + (rbOverlap + rgOverlap));\n\nvec3 Uncharted2Tonemap(vec3 x)\n{\n\tx *= 3.0;\n\n\t// float A = 0.15;\n\t// float B = 0.50;\n\t// float C = 0.10;\n\t// float D = 0.20;\n\t// float E = 0.02;\n\t// float F = 0.30;\n\n\tfloat A = 0.9;\n\tfloat B = 0.8;\n\tfloat C = 0.1;\n\tfloat D = 1.0;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\n\tx = x * coneOverlap;\n\n\tx = ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n\n\tx = x * coneOverlapInverse;\n\n    return x;\n}\n\nvec3 lenderToneMapper(in vec3 color) {\n   return 1.5f * color / (color + vec3(1.0f));\n}\n\n\nvoid mainImage(out vec4 color, in vec2 p) {\n  \n  vec4 data = texelFetch(iChannel0, ivec2(p), 0);\n  color.rgb = data.rgb / data.w;\n  \n  /*TONEMAP + GAMMA-CORRECTION*/\n  color.rgb = lenderToneMapper(color.rgb);\n\n // color.rgb -= 0.05f; //some exposer \n  \n  color = pow(color,vec4(1.0/2.2f));\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    \n    vec2 prev_mousePos = texelFetch(iChannel0 , ivec2(p),0).st;\n    vec2 mousePos = (iMouse.xy/iResolution.xy)*2.0f - 1.0f;\n      \n     vec2 diff = (mousePos - prev_mousePos);\n  \n    fragColor = vec4(diff,0.0,1.0f);\n}","name":"Buffer C","description":"","type":"buffer"}]}