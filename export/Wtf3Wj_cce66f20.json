{"ver":"0.1","info":{"id":"Wtf3Wj","date":"1557582209","viewed":172,"name":"Ray March Example","username":"fydrenak","description":"An example ray marcher, I've tried to do my best to use sensible variable names and comment as best I can.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["example","simple","basic","raymarch","cube","shadow","light","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 400.\n#define SURF_DIST .01\n\n\n//standard rotation matrix\nmat2 rotate(float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(-c, -s, s, -c);\n}\n\n\nfloat getSphereDist(vec3 p) {\n    float sphere = length(p) - 1.;\n\treturn sphere;\n}\n\n\nfloat getCubeDist(vec3 p) {\n    vec3 toCorner = abs(p) - 1.;\n    \n    //the max is to make sure that the exterior\n    //dist is zero when inside the cube\n    float exteriorDist = length(max(toCorner, 0.));\n    \n    //max of z y & z\n\tfloat interiorDist = max(toCorner.x, max(toCorner.y, toCorner.z));\n    \n    //interior dist should never be positive\n    interiorDist = min(interiorDist, 0.);\n    \n    return interiorDist + exteriorDist;\n}\n\n\nfloat getPlaneDist(vec3 p) {\n    //plane is at y = 0, so \n    //y component is the distance\n\treturn p.y;\n}\n\n\n//get the distance to the closest\n//point on the closest object\nfloat sceneDist(vec3 p) {\n\tfloat planeDist = getPlaneDist(p);\n    \n    //sphere\n    vec3 spherePos = p;\n    \n \t//translate\n    spherePos -= vec3(2,1,8);\n    \n    //translate y direction (wobble)\n    spherePos.y += sin(iTime * 2.) * .4;\n    \n \t//scale (squash 50% in y dir)\n    spherePos *= vec3(1,1.5,1);\n    \n    float sphereDist = getSphereDist(spherePos);\n    \n    //cube\n    vec3 cubePos = p;\n    \n    //translate\n    cubePos -= vec3(-2,1,8);\n    //rotate on y axis\n    cubePos.xz *= rotate(-iTime); \n    \n    float cubeDist = getCubeDist(cubePos);\n    \n    //find the minimum distance of all objects\n    float dist = min(cubeDist, sphereDist);\n    dist = min(dist, planeDist);\n    \n    return dist;\n}\n\n\nfloat rayMarch(vec3 rayOrig, vec3 rayDir) {\n\tfloat dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = rayOrig + dist * rayDir;\n\t\tfloat sceneDist = sceneDist(p);\n        \n        dist += sceneDist;\n       \n        if (dist > MAX_DIST || sceneDist < SURF_DIST) {\n        \tbreak;\n        }\n\t}\n    \n    return dist;\n}\n\n\n//get the normal of a point in 3d space,\nvec3 getNormal(vec3 p) {\n\tfloat d = sceneDist(p);\n    \n    //just a helper variable\n    vec2 e = vec2(.01, 0);\n    \n    //shift the point by a small\n    //amount along each axis\n    vec3 n = d - vec3(\n        sceneDist(p - e.xyy),\n        sceneDist(p - e.yxy),\n        sceneDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\n//get the strength of the light\n//at a 3d point\nfloat getLight(vec3 p) {\n\tvec3 lightPos = vec3(-2, 5, 8);\n    \n    //move the light in a circle\n    lightPos.xz += vec2(cos(iTime), sin(iTime)) * 10.;\n    \n \tvec3 normal = getNormal(p);\n    vec3 toLight = normalize(lightPos - p);\n    \n    //dot product of two normalised \n    //vectors gives the cosine of the angle between them\n    float angle = dot(normal, toLight);\n    \n    //the amount of light depends directly on the angle\n    float diffuse = clamp(angle, 0., 1.);\n    \n    //add shadows by casting a ray from object to light\n    //offset the starting position a little so it doesn't hit\n    //the object it starts from\n    float dist = rayMarch(p+normal*.02, toLight);\n    \n    //if dist to object less than dist to light,\n    //this area is a shadow\n    if (dist < length(p-lightPos)) {\n    \tdiffuse *= .2;\n    }\n    \n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //ray origin is the camera position\n    vec3 rayOrig = vec3(0, 6, -8);\n    vec3 rayDir = vec3(uv.x, uv.y, 1.0);\n    \n    //tilt the camera down a little\n    rayDir.y -= 0.3;\n    \n    float dist = rayMarch(rayOrig, rayDir);\n    \n    //get the point that the ray hit\n    //to use for lighting\n    vec3 rayHitPos = rayOrig + rayDir * dist;\n    float diff = getLight(rayHitPos);\n    \n    //grayscale colour based on lighting value\n    vec3 col = vec3(diff);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}