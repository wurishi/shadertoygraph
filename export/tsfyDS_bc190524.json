{"ver":"0.1","info":{"id":"tsfyDS","date":"1585443586","viewed":482,"name":"Analys Cube","username":"FMS_Cat","description":"WE ARE BACK. The cube shader from my modchart \"Analys\": https://www.youtube.com/watch?v=eqZE60HanCM","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Analys cube\n// (c) 2019 FMS_Cat, MIT License\n\n// == tweak these numbers, yee =====================================================================\n#define SIZE 0.5\n#define FX_NYOOOM (iMouse.x/iResolution.x)\n#define FX_FORWARD 1.0\n#define FX_KICK (0.1*exp(-3.0*mod(BEAT,4.0)))\n#define FX_TWIST (20.0*exp(-3.0*mod(BEAT-2.0,4.0)))\n#define FX_SKEW 0.0\n#define FX_DEFORM (0.2*iMouse.y/iResolution.y)\n#define FX_DEFORM_FREQ 0.1\n\n// == raymarch related constants ===================================================================\n#define MARCH_ITER 64\n#define MARCH_EPSILON 1E-4\n#define MARCH_NEAR 0.01\n#define MARCH_FAR 40.0\n#define MARCH_MULP 0.6\n\n// == common macros ================================================================================\n#define HALF_PI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define BEAT (iTime*170.0/60.0)\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,t) saturate(((t)-(a))/((b)-(a)))\n\n// == common functions =============================================================================\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n}\n\n// == camera =======================================================================================\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 up;\n  float roll;\n  float fov;\n};\n\nCamera newCamera( vec3 pos, vec3 dir ) {\n  Camera camera;\n  camera.pos = pos;\n  camera.dir = dir;\n  camera.up = vec3( 0.0, 1.0, 0.0 );\n  camera.roll = 0.0;\n  camera.fov = 0.5;\n  return camera;\n}\n\n// == ray ==========================================================================================\nstruct Ray {\n  vec3 orig;\n  vec3 dir;\n};\n\nRay newRay( vec3 ori, vec3 dir ) {\n  Ray ray;\n  ray.orig = ori;\n  ray.dir = dir;\n  return ray;\n}\n\nRay rayFromCamera( Camera camera, vec2 p ) {\n  vec3 dirX = normalize( cross( camera.dir, camera.up ) );\n  vec3 dirY = cross( dirX, camera.dir );\n  vec2 pt = rotate2D( camera.roll ) * p;\n  return newRay(\n    camera.pos,\n    normalize( pt.x * dirX + pt.y * dirY + camera.dir / tan( camera.fov ) )\n  );\n}\n\nvec3 getRayPosition( Ray ray, float len ) {\n  return ray.orig + ray.dir * len;\n}\n\n// == isect ========================================================================================\nstruct Intersection {\n  Ray ray;\n  float len;\n  vec3 pos;\n};\n\nIntersection newIntersection( Ray ray, float len ) {\n  Intersection isect;\n  isect.ray = ray;\n  isect.len = len;\n  isect.pos = getRayPosition( ray, len );\n  return isect;\n}\n\n// == march result =================================================================================\nstruct MarchResult {\n  float dist;\n  vec2 uv;\n};\n\n// == distFuncs ====================================================================================\nfloat distFuncBox( vec3 p, vec3 b ) {\n  vec3 d = abs( p ) - b;\n  return length( max( d, 0.0 ) ) + min( max( d.x, max( d.y, d.z ) ), 0.0 );\n}\n\nvec3 deform( vec3 p ) {\n  vec3 pt = p;\n  pt.xy = rotate2D( FX_SKEW * pt.z ) * pt.xy;\n  pt.x *= 1.0 - sqrt( FX_NYOOOM );\n  pt.yz = rotate2D( FX_NYOOOM * exp( 5.0 * FX_NYOOOM ) * pt.x ) * pt.yz;\n  pt.y += 2.0 * FX_SKEW * pt.x;\n  pt += FX_DEFORM * (\n    texture( iChannel1, FX_DEFORM_FREQ * ( pt.xy ) + 0.5 ).xyz - 0.5\n  );\n  pt.zx = rotate2D( mod( 2.5 * iTime + PI, TAU ) + FX_TWIST * pt.y ) * pt.zx;\n  pt.xy = rotate2D( 0.6 * sin( 0.9 * iTime ) ) * pt.xy;\n  pt.yz = rotate2D( 0.6 * sin( 1.4 * iTime ) ) * pt.yz;\n  pt -= normalize( pt ) * FX_KICK * sin( 15.0 * length( pt ) - 40.0 * iTime );\n  return pt;\n}\n\nMarchResult distFunc( vec3 p ) {\n  MarchResult result;\n\n  vec3 pt = p;\n  pt = deform( pt );\n  result.dist = distFuncBox( pt, vec3( SIZE ) );\n\n  vec3 spt = vec3( 1.0 );\n\n  if ( FX_FORWARD > 0.0 ) {\n    vec3 ptIfs = p;\n    ptIfs.z = mod( ptIfs.z - 16.0 * iTime + 3.0 * sin( HALF_PI * BEAT + 0.5 ), 6.0 ) - 3.0;\n    for ( int i = 0; i < 6; i ++ ) {\n      float fi = float( i );\n      spt *= sign( ptIfs );\n      ptIfs = abs( ptIfs ) - vec3( 3.2, 4.5, 1.2 ) / max( 1E-2, FX_FORWARD ) * pow( 0.5, fi );\n      ptIfs.xy = rotate2D( 1.1 ) * ptIfs.xy;\n      ptIfs.zx = rotate2D( 2.1 ) * ptIfs.zx;\n    }\n\n    ptIfs = deform( ptIfs );\n\n    float distIfs = distFuncBox( ptIfs, vec3( SIZE ) );\n\n    if ( result.dist < distIfs ) {\n      spt = vec3( 1.0 );\n    } else {\n      result.dist = distIfs;\n      pt = ptIfs;\n    }\n  }\n\n  vec3 abspt = abs( pt );\n  float n = max( abspt.x, max( abspt.y, abspt.z ) );\n\n  result.uv = 0.5 + (\n    ( n == abspt.z ) ? ( pt.xy * vec2( sign( pt.z ), 1.0 ) ) :\n    ( n == abspt.x ) ? ( pt.zy * vec2( -sign( pt.x ), 1.0 ) ) :\n    ( pt.xz * vec2( 1.0, -sign( pt.y ) ) )\n  ) * spt.x * spt.y * spt.z * 0.5 / SIZE;\n\n  return result;\n}\n\nvec3 normalFunc( vec3 p, float dd ) {\n  vec2 d = vec2( 0.0, dd );\n  return normalize( vec3(\n    distFunc( p + d.yxx ).dist - distFunc( p - d.yxx ).dist,\n    distFunc( p + d.xyx ).dist - distFunc( p - d.xyx ).dist,\n    distFunc( p + d.xxy ).dist - distFunc( p - d.xxy ).dist\n  ) );\n}\n\nvec3 normalFunc( vec3 p ) {\n  return normalFunc( p, MARCH_NEAR );\n}\n\n// == main procedure ===============================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  Camera camera = newCamera( vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.0, -1.0 ) );\n  camera.fov = 0.6 + 0.9 * FX_FORWARD * ( 0.5 + 0.5 * sin( HALF_PI * BEAT - 0.5 ) );\n  camera.pos.z = 0.5 + 1.5 / camera.fov;\n  Ray ray = rayFromCamera( camera, p );\n\n  Intersection isect;\n  float rayLen = MARCH_NEAR;\n  vec3 rayPos = getRayPosition( ray, rayLen );\n  MarchResult result;\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    result = distFunc( rayPos );\n    if ( abs( result.dist ) < MARCH_NEAR ) { break; }\n    rayLen += result.dist * MARCH_MULP;\n    if ( MARCH_FAR < rayLen ) { break; }\n    rayPos = getRayPosition( ray, rayLen );\n  }\n\n  vec3 bg = vec3( 0.0 );\n\n  if ( abs( result.dist ) < MARCH_NEAR ) {\n    vec3 normal = normalFunc( rayPos );\n    float edge = linearstep( 0.498, 0.499, abs( result.uv.x - 0.5 ) );\n    edge += linearstep( 0.495, 0.497, abs( result.uv.y - 0.5 ) );\n    vec2 uv = result.uv;\n    vec4 tex = texture( iChannel0, uv );\n    float fog = exp( -0.2 * max( 0.0, rayLen - 3.0 ) );\n    fragColor = vec4( fog * mix(\n      0.1 + 0.1 * normal + 0.8 * tex.rgb,\n      1.0 + 1.0 * sin( vec3( 0.0, 1.0, 2.0 ) + 10.0 * length( result.uv - 0.5 ) - 10.0 * iTime ),\n      edge\n    ), 1.0 );\n  } else {\n    // discard;\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n  }\n}\n","name":"Image","description":"","type":"image"}]}