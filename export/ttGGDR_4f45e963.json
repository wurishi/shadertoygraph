{"ver":"0.1","info":{"id":"ttGGDR","date":"1579843247","viewed":63,"name":"mars scene","username":"darthxander","description":"noise-based terrain and raymarched rover, use mouse to rotate camera","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// todo:\n// fractional brownian motion heightmap\n// simple iterary raytracer, with shadows and terrain coloring with the gradient\n\n# define MOVE_SPEED .6\n\n# define TERRAIN -1\n# define WHEEL 1\n# define METAL 2\n# define BODY 3\n\n\nvec3 roverP = vec3(0., 0., 0.);\nvec3 roverWbl = vec3(-.4, 0., -.4);\nvec3 roverWbr = vec3(.4, 0., -.4);\nvec3 roverWfl = vec3(-.4, 0., .4);\nvec3 roverWfr = vec3(.4, 0., .4);\n\nmat3 rotatex(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3 (1, 0, 0,\n                 0, c, -s,\n                 0, s, c);\n}\n\nmat3 rotatey(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3 (c, 0, s,\n                 0, 1, 0,\n                 -s, 0, c);\n}\n\nmat3 rotatez(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3(c, -s, 0,\n                s, c, 0,\n                0, 0, 1);\n}\n\nmat2 rotate2d(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s,\n                s, c);\n}\n\nvec2 hash( vec2 p ) // random function\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat simplexNoise(vec2 p) { // from inigo quilez simplex noise https://www.shadertoy.com/view/Msf3WH\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) ); \n}\n\n/*\n// fractional brownian motion function, using simplex noise from earlier\nfloat fbm(in vec2 x, in float H) {    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        t += a*simplexNoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n*/\n\n// SDFs and terrain generation\n\nfloat terrain(vec2 pt) {\n    /*\n    float noise = .5-simplexNoise(pt*.1);\n    pt = vec2(pt.x + .3*noise, pt.y + .3*noise);\n    float fbmValue = fbm(pt, .5)*.2;\n    return fbmValue;\n\t*/\n    \n    \n    \n\t\n    //return fbm(pt*.05, 1.0)*.55+.2;// + fbm(p*.5, 1.0)*.045;\n   \n    pt.y += MOVE_SPEED*iTime;\n    \n    vec2 offset = vec2(simplexNoise(pt*.5), 0);\n    offset.y = -offset.x;\n    \n    return max(0., .2 + simplexNoise(pt*.2 + offset*.2)*.5);\n    \n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothUnionSDF(float distA, float distB, float k) {\n    return smin(distA, distB, k);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat cappedCylinderSDF(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat wheelSDF(vec3 p, vec3 position) {\n    mat3 rz = rotatez(3.142/2.0);\n    mat3 rx = rotatex(3.142/2.0);\n    mat3 rs1 = rotatex(-.5*3.142/6.0);\n   \tmat3 rs2 = rotatex(-1.5*3.142/6.0);\n    mat3 rs3 = rotatex(-2.5*3.142/6.0);\n    \n    float wheelR = .2;\n    \n    p = p - position - vec3(0., wheelR, 0.);\n    if (position.y > 0.) {\n   \t\tp = rotatex(iTime*MOVE_SPEED/wheelR)*p;\n    }\n    else {\n\t\tp = rotatex(1.5*iTime*MOVE_SPEED/wheelR)*p;\n    }\n     \n    vec2 wheelSize = vec2(wheelR, .1);\n    float wheelThickness = .02;\n    float outer = cappedCylinderSDF(p*rz, wheelSize);\n    float inner = cappedCylinderSDF(p*rz, vec2(wheelSize.x - wheelThickness, wheelSize.y+.5));\n    float rim = differenceSDF(outer, inner);\n    \n    vec3 ps = p;\n    ps.yz = abs(ps.yz);\n    \n    vec3 treadSize = vec3(wheelSize.y, .01, .01);\n    vec3 treadOffset = vec3(0, wheelSize.x + treadSize.y/2.0, 0);\n    float tread1 = boxSDF(ps*rs1 - treadOffset, treadSize);\n    float tread2 = boxSDF(ps*rs2 - treadOffset, treadSize);\n    float tread3 = boxSDF(ps*rs3 - treadOffset, treadSize);\n    float treads = min(min(tread1, tread2), tread3);\n    \n    float tire = unionSDF(rim, treads);\n    \n    float frame1 = boxSDF(p, vec3(.01, wheelSize.x*.99, .01));\n    float frame2 = boxSDF(p*rx, vec3(.01, wheelSize.x*.99, .01));\n    \n    float frame = smoothUnionSDF(frame1, frame2, .05);\n    \n    return unionSDF(tire, frame);\n}\n\nfloat legSDF(vec3 p, vec3 wheel, vec3 body) {\n    mat3 rz = rotatez(3.142/2.0);\n    \n    vec3 dir = body - wheel;\n    float side = sign(dir.x);\n    \n    vec3 motorOffset;\n    \n    motorOffset = side*vec3(.07, 0., 0.);      \n    \n    float motor = cappedCylinderSDF((p - wheel - motorOffset)*rz, vec2(.05, .08));\n    \n    vec3 attach = vec3(wheel + vec3(side*.16, -.025, 0.));\n    \n    \n    float height = abs(length(body - attach));\n    vec3 center = (body + attach)/2.0;\n    \n    float angle = abs(atan(dir.x, dir.y));\n    if (center.z < 0.) {\n        angle *= -1.;\n    }\n    \n    vec3 barrelDir =  normalize(attach - body);\n    \n    float pistonShaft = cappedCylinderSDF((p - center)*rotatex(angle), vec2(.02, height*.5));\n    \n    float piston = smoothUnionSDF(motor, pistonShaft, .07);\n    \n    float telescopeSize = .12;\n    float barrel2 = cappedCylinderSDF((p - body - barrelDir*telescopeSize)*rotatex(angle), vec2(.04, telescopeSize));\n    float barrel1 = cappedCylinderSDF((p - body - barrelDir*clamp(height-telescopeSize*3.5, telescopeSize, 2.5*telescopeSize))*rotatex(angle), vec2(.03, telescopeSize));\n    \n    float barrels = min(barrel1, barrel2);\n    \n    float arm = min(barrels, piston);\n    \n    float ball = cappedCylinderSDF((p - body)*rz, vec2(.07, .04));\n    \n    return min(arm, ball);\n}\n\nfloat bodySDF(vec3 p, float bottomHeight, vec3 size) {\n    return boxSDF(p - vec3(0., bottomHeight, 0.), size);\n}\n\n\nfloat roverSDF(vec3 p, out int material) {\n    \n    float bl = wheelSDF(p, roverWbl);\n    float br = wheelSDF(p, roverWbr);\n    float fl = wheelSDF(p, roverWfl);\n    float fr = wheelSDF(p, roverWfr);\n    \n    float wheels = min(min(bl, br), min(fl, fr));\n        \n    float jointHeight = roverP.y + .65;\n    float wOffset = .2;\n    float jointWidth = .24;\n    \n    float blLeg = legSDF(p, roverWbl + vec3(0., wOffset, 0.), vec3(-jointWidth, jointHeight, -jointWidth));\n    float brLeg = legSDF(p, roverWbr + vec3(0., wOffset, 0.), vec3(jointWidth, jointHeight, -jointWidth));\n    float flLeg = legSDF(p, roverWfl + vec3(0., wOffset, 0.), vec3(-jointWidth, jointHeight, jointWidth));\n    float frLeg = legSDF(p, roverWfr + vec3(0., wOffset, 0.), vec3(jointWidth, jointHeight, jointWidth));\n    \n    float legs = min(min(blLeg, brLeg), min(flLeg, frLeg));\n    \n    float bodyHeight = .1;\n    \n    float body = bodySDF(p, jointHeight + bodyHeight, vec3(jointWidth + .06, bodyHeight, jointWidth + .06));\n    \n    float d = min(body, legs);\n    d = min(d, wheels);\n    \n    if (d == legs) {\n    \tmaterial = METAL;\n    }\n    else if (d == wheels) {\n        material = WHEEL;\n    }\n    else { // if d == body\n        material = BODY;\n    }\n    \n    return d;\n}\n\nfloat roverSDF(vec3 p) {\n    int material;\n    return roverSDF(p, material);\n}\n\nvec3 roverNormal(vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*roverSDF( p + k.xyy*h ) + \n                      k.yyx*roverSDF( p + k.yyx*h ) + \n                      k.yxy*roverSDF( p + k.yxy*h ) + \n                      k.xxx*roverSDF( p + k.xxx*h ) );\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// raytracing method adapted from inigi quilez's article on terrain rendering https://iquilezles.org/articles/terrainmarching\nfloat castRay( const vec3 ro, const vec3 rd, out vec3 normal, out vec3 intersection, out int material)\n{ \n    float dt = 0.01f;\n    float mint = 1.0f;\n    float maxt = 15.0f;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    float resT;\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3  p = ro + rd*t;\n        \n        float h = terrain( p.xz );\n        \n        if (p.y < h) {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            // calculate normals\n            intersection = ro + rd*resT;\n            intersection.y = terrain(intersection.xz);\n            vec3 vx = vec3(intersection.x + .001, 0, intersection.z);\n            vx.y = terrain(vx.xz);\n            vec3 vz = vec3(intersection.x, 0, intersection.z + .001);\n            vz.y = terrain(vz.xz);\n            normal = normalize(cross(intersection - vz, intersection - vx));\n            material = TERRAIN;\n\n            return resT;\n        }\n        \n        dt = 0.01*t;\n        lh = h;\n        ly = p.y;\n        \n        if (sphereSDF(p - vec3(0., roverP.y + .5, 0.), 1.0) < 0.) {\n\t\t\t\n            float dt2 = roverSDF(p, material);\n            \n            if (dt2 < .001) {\n                intersection = p;\n                normal = roverNormal(p);\n                \n                return t;\n            }\n            \n            if (dt2 < dt) {\n                dt = dt2;\n            }\n            \n           \n        }\n    }\n    normal = rd;\n    return -1.0;\n}\n\nvec4 colorPoint(vec3 eye, float d, vec3 pt, vec3 normal, int material) {\n\tvec4 color;\n\n    vec3 sun = normalize(-vec3(1.3, -1., -1.));\n    vec4 skyTop = vec4(.61, .57, .54, 1.0);\n    vec4 skyBottom = vec4(.85, .8, .74, 1.0);\n    \n    float alpha; // determines specular light\n    \n    if (d == -1.0) {\n        color = mix(skyBottom, skyTop, dot(normal, sun));\n    }\n    else {\n        if (material == TERRAIN) {\n            alpha = 1.;\n            float height = pt.y;\n            vec4 ground = vec4(.74, .54, .42, 1.0);\n            vec4 ice = vec4(1.0);\n            vec4 mars = ground;\n            vec2 textureSample = pt.xz + vec2(0, MOVE_SPEED*iTime);\n\n            if (height <= 0.0) {\n                color = texture(iChannel1, .8*textureSample);\n                color = vec4(vec3(color.r + color.g + color.b)/3.0, 1.0);\n                color.b += .05;\n                color = mix(color, vec4(1.0), .5);\n            }\n            else {\n                color = texture(iChannel0, .2*textureSample);\n                color = mix(color, mars, .7);\n\n                if (height <= .1) {\n                    vec4 iceCol = texture(iChannel1, .8*textureSample);\n                    iceCol = vec4(vec3(iceCol.r + iceCol.g + iceCol.b)/3.0, 1.0);\n                    //iceCol.b += .05;\n                    iceCol = mix(iceCol, vec4(1.0), .7);\n\n                    float noise = .5*(1.0 + simplexNoise(4.*textureSample));\n                    noise = clamp(0.0, 1.0, noise + .2 + (.1 - height)*3.0);\n                    noise += .15;\n                    noise *= 10.*(.1 - height);\n                    \n                    //color = vec4(vec3(noise), 1.0);\n                    color = mix(color, iceCol, noise);\n                }\n            }\n        }\n        else if (material == WHEEL) {\n            alpha = 1.0;\n            color = vec4(.44, .32, .21, 1.0);\n        }\n        else if (material == METAL) {\n            alpha = 7.0;\n            color = vec4(.60, .61, .54, 1.0);\n        }\n        else if (material == BODY) {\n            alpha = 1.0;\n            color = vec4(vec3(.3), 1.0);\n        }\n        \n        vec3 phongReflect = 2.*dot(sun, normal)*(normal) - sun;\n        vec3 viewer = normalize(eye - pt);\n        float specularLight = dot(phongReflect, viewer);\n        if (specularLight > 0.) {\n            specularLight = pow(specularLight, alpha);\n        }\n        \n        float light = clamp(0., 1., .15 + dot(normal, sun));\n        color = color*(light + .1*specularLight);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // figure out how extended the rover legs are going to be this frame (maybe figure out how to skip this for some terrain frames)\n    \n    \n    roverWbl.y = terrain(roverWbl.xz);\n    roverWbr.y = terrain(roverWbr.xz);\n    roverWfl.y = terrain(roverWfl.xz);\n    roverWfr.y = terrain(roverWfr.xz);\n    roverP.y = .25*(roverWbl.y + roverWbr.y + roverWfl.y + roverWfr.y);\n    \n    // cast a ray to figure out how to color the point\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    dir = rotatex(3.14*(.5 + -1.*iMouse.y/iResolution.y))*dir;\n    vec3 eye = vec3(0., 3.5, 3);\n    \n    float angle = 2.0*3.14*(.5 + -1.*iMouse.x/iResolution.x);\n    \n    /*\n    dir = rotatex(.55)*dir;\n    dir = rotatey(-.25)*dir;\n    vec3 eye = vec3(1.3, 3.8, 5);\n    */\n    \n    eye = eye*rotatey(angle);\n    dir = dir*rotatey(angle);\n    vec3 normal;\n    vec3 pt;\n    int material;\n    \n    float dist = castRay(eye, dir, normal, pt, material);\n    \n    fragColor = colorPoint(eye, dist, pt, normal, material);\n    \n    if (material == METAL) {\n        vec3 rNormal;\n        vec3 rPt;\n        int rMaterial;\n        vec4 baseColor = vec4(.60, .61, .54, 1.0);\n\n        float reflection = castRay(pt, normal, rNormal, rPt, rMaterial);\n        vec4 reflectColor = colorPoint(pt,  reflection, rPt, rNormal, rMaterial);\n        \n        fragColor = mix(reflectColor, baseColor, .2); \n    }\n        \n        \n    // grid\n    /*\n    vec2 grid = fract(pt.xz);\n    float th = .01;\n    if (grid.x < 0. + th/2.0 || grid.x > 1.0 - th/2.0 || grid.y < 0. + th/2.0 || grid.y > 1.0 - th/2.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } \n    */\n\n    fragColor *= 1.1;\n}","name":"Image","description":"","type":"image"}]}