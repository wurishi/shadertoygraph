{"ver":"0.1","info":{"id":"43sfDS","date":"1728862059","viewed":102,"name":"Check Geometry","username":"dray","description":"For testing geometry ... This is simple for some people, but I wanted to double check my work to see how a 3D problem might be transformed to 2D.   Mouse controls view.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// something for checking geometry using shader functions\n\n\n// From https://www.shadertoy.com/view/MXXcWj (dray):\nstruct Hit { float d; float i; }; // d=distance to object   i=id, color or texture\n\n//Hit opTrue() { return Hit(0.,0.); }\n//Hit opFalse() { return Hit(1e20,0.); }\n\n//Hit opNot(Hit a) { return Hit(-a.d,a.i); }  // not compatible with opTrue\n\nHit opOr(Hit a,Hit b) { if (a.d < b.d) return a; else return b; } // { return a.d < b.d ? a : b; }\n//Hit opAndx(Hit a,Hit b) { if (a.d > b.d) return a; else return b; } // { return (a.d < b.d) ? a : b; }\n//Hit opAnd(Hit a,Hit b) { if (a.d > b.d) return Hit(a.d,b.i); else return Hit(b.d,a.i); }//if (a.d > b.d) return a; else return b; } // { return (a.d < b.d) ? a : b; }\n\n// -----------------------------------------\n\n//#define PI 3.14159265\n//#define TAU (2.*PI)\n\n/*\n#define max3v(v) max(v.x,max(v.y,v.z))\n\nfloat sdBox(vec3 p,vec3 org,vec3 sz) // sdf of orthogonal box at 0, originally iq https://www.shadertoy.com/view/Xds3zN\n{\n  p=abs(p-org)-sz; // everything is symmetrical so just 3 sides need examination\n  return min(max3v(p),.0) + length(max(p,.0));\n}\n*/\n\nfloat sdSphere(vec3 p,vec3 org,float r) {\n  return distance(p,org) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// ----- text ------\n/*\nfloat TextSDF(vec3 p,vec3 orig,float sz,int cha) {\n    p -= orig;\n    vec3 sv = p;\n    vec3 d = abs(p) - vec3(sz*.5,sz*.5,0); // everything is symmetrical so just 3 sides need examination\n    float dst =  min(max3v(d),.0) + length(max(d,.0));\n    return dst > .1 || texelFetch( iChannel0, ivec2( (cha&15)<<6, (64*15)-(((cha>>4)&15)<<6)) + ivec2(p*64./sz+32.), 0 ).x > 0. ? dst : .03;\n}\n\nvec3 chOrg, chAdv=vec3(3.5,0,0);\n#ifdef NOTEXT\n#define ch(cc)\n#else\n#define ch(cc) \\\n  res = opOr(res,Hit(TextSDF(p,chOrg,8.,cc),1000.)); \\\n  chOrg+=chAdv;\n#endif\n*/\n// Map --------------------------------------------------------------\n\nHit Dist(vec3 p) {\n\n  Hit res = Hit( 150. - p.z, 1000. ); // back\n  \n#define LINW(X,Y,Z,X2,Y2,Z2,C,W) \\\n  res=opOr(res,Hit(sdCapsule(p,vec3(X,Y,Z),vec3(X2,Y2,Z2),W),C));\n\n#define LIN(X,Y,Z,X2,Y2,Z2,C) LINW(X,Y,Z,X2,Y2,Z2,C,.5)\n#define LINN(X,Y,Z,X2,Y2,Z2,C) LINW(X,Y,Z,X2,Y2,Z2,C,.3)\n#define LINT(X,Y,Z,X2,Y2,Z2,C) LINW(X,Y,Z,X2,Y2,Z2,C,1.)\n\n#define AXL 400\n  LINT(- AXL,0,0,AXL,0,0,1001.)\n  LINT(0,- AXL,0,0,AXL,0,1001.)\n  LINT(0,0,- AXL,0,0,AXL,1001.)\n\n#define DOT(X,Y,Z,C) \\\n  res=opOr(res,Hit(sdSphere(p,vec3(X,Y,Z),2.),C)); \\\n  \\\n  LINN(X,Y,Z,X,Y,0,C); \\\n  LINN(X,0,0,X,Y,0,C); \\\n  LINN(0,Y,0,X,Y,0,C); \\\n  \\\n  LINN(X,Y,Z,X,0,Z,C); \\\n  LINN(0,0,Z,X,0,Z,C); \\\n  LINN(X,0,0,X,0,Z,C); \\\n  \\\n  LINN(X,Y,Z,0,Y,Z,C); \\\n  LINN(0,Y,0,0,Y,Z,C); \\\n  LINN(0,0,Z,0,Y,Z,C); \\\n  \n  // test case \n  \n  vec3 s1=vec3(-50,30,40);\n  vec3 pt=vec3(-30,-50,-40);\n  \n  // part 1\n  \n  float prog = mod(iTime,6.)-.5;\n  \n  float ang = s1.y == 0. ? 0. : atan(s1.z,s1.y);\n  float scl1 = clamp( prog, 0., 1. );\n  ang *= scl1;\n  vec2 cs;\n  cs = vec2(cos(ang),sin(ang));\n  if ( scl1> .98 ) cs = normalize(s1.yz); // cos, sin\n  \n  mat2 rot = mat2(cs.x,cs.y,-cs.y,cs.x); // reverse direction matrix\n  pt.yz = pt.yz * rot;\n  s1.yz = s1.yz * rot;\n  if ( scl1> .98 ) s1.yz = vec2( length(s1.yz), 0 );\n  \n  // part 2\n  \n  float ang2 = s1.x == 0. ? 0. : atan(s1.y,s1.x);\n  float scl2 = clamp( prog - 1.5, 0., 1. );\n  ang2 *= scl2;\n  vec2 cs2;\n  cs2 = vec2(cos(ang2),sin(ang2));\n  if ( scl2 > .98 ) cs2 = normalize(s1.xy); // cos, sin\n  \n  mat2 rot2 = mat2(cs2.x,cs2.y,-cs2.y,cs2.x); // reverse direction matrix\n  pt.xy = pt.xy * rot2;\n  s1.xy = s1.xy * rot2;\n  if ( scl2 > .98 ) s1.xy = vec2( length(s1.xy), 0 );\n  \n  // part 3\n  \n  float ang3 = pt.y == 0. ? 0. : atan(pt.z,pt.y);\n  float scl3 = clamp( prog - 3., 0., 1. );\n  ang3 *= scl3;\n  vec2 cs3;\n  cs3 = vec2(cos(ang3),sin(ang3));\n  if ( scl3 > .98 ) cs3 = normalize(pt.yz); // cos, sin\n  \n  mat2 rot3 = mat2(cs3.x,cs3.y,-cs3.y,cs3.x); // reverse direction matrix\n  pt.yz = pt.yz * rot3;\n  s1.yz = s1.yz * rot3;\n  if ( scl3 > .98 ) pt.yz = vec2( length(pt.yz), 0 );  \n  \n  \n  // draw\n\n  DOT(s1.x,s1.y,s1.z,3.)\n  DOT(pt.x,pt.y,pt.z,7.)\n  LIN(0,0,0,s1.x,s1.y,s1.z,3.)\n\n  \n  LIN(0,0,30,0,length(s1.xyz),30,3.)\n  LIN(0,0,40,0,distance(pt,s1.xyz),40,7.)\n  LIN(0,0,50,0,length(pt),50,7.)\n  \n\n  return res;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n  float dist = 0.;\n  vec3 pos;\n  Hit obj;\n  for ( int stps = 0; stps < 400; ++stps ) {\n    pos = beg + dir * dist;\n    obj = Dist( pos );\n    if ( obj.d < .01 ) break; // close enough\n    dist += obj.d;\n    if ( pos.z>200. ) return vec4( pos, 91. ); // out of range\n  }\n  return vec4( pos, obj.i ); // use best\n}\n\nvec3 Normal(vec3 pt) {\n  float delta = .001; // large delta gives rounded corners\n  vec3 norm = Dist(pt).d - vec3(\n    Dist(pt-vec3(delta, 0., 0.)).d, \n    Dist(pt-vec3( 0.,delta, 0.)).d, \n    Dist(pt-vec3( 0., 0.,delta)).d );\n  return normalize( norm );\n}\n\nvec2 rot2d(vec2 inp,float ang) {\n    float s = sin(ang);\n    float c = cos(ang);\n    return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\n/*\nvec3 camdir(vec3 dir,vec3 uvz) {\n    vec3 cd = normalize(dir);\n    vec3 cr = normalize(cross(vec3(0,1,0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(cr, cu, cd) * normalize(uvz);\n}\n*/\n\n//#define VARY(L,H,S) ((sin(S)+1.)/2.*(H-L)+L)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\n  vec2 R = iResolution.xy;\n  vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n  float fov = 1.;\n  float zoom = 2.;\n  uv *= fov/zoom;\n  vec3 cam = vec3(40,40,-200./fov);\n  vec3 camdir = vec3( uv, 1. );\n\n  vec2 ms = iMouse.xy;\n  if ( ms.x > 0. ) ms = (ms+ms-R)/min(R.x,R.y); // -1 ... +1\n\n#if 0\n  ms *= 90.;\n  cam.x -= ms.x;\n  cam.y -= ms.y;\n#else\n  ms *= .6;\n  mat2 yaw = mat2( cos(ms.x), sin(ms.x), -sin(ms.x), cos(ms.x) );\n  mat2 pitch = mat2( cos(ms.y), sin(ms.y), -sin(ms.y), cos(ms.y) );\n  cam.yz = pitch * cam.yz;\n  cam.xz = yaw * cam.xz;\n  camdir.yz = pitch * camdir.yz;\n  camdir.xz = yaw * camdir.xz;\n#endif\n\n  camdir = normalize( camdir );\n  vec4 hit = March( cam, camdir );\n\n  //vec3 Light = vec3( 50.+50.*sin(iTime), 50.+50.*cos(iTime*1.5), -100);\n  vec3 Light = vec3( 80, 50, -30);\n  vec3 dir = normalize( Light - hit.xyz );\n\n  //vec4 shadow = March( hit.xyz+dir*.1, dir );\n\n  vec3 norm = Normal(hit.xyz);\n  float difu = dot( norm, dir );\n  difu = .5 + .5*difu;\n  //if ( shadow.z > -10. ) difu = .2;\n\n#define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n \n if (hit.w==1001.)\n   O = vec4(.4);\n else if (hit.w==1000.)\n   O = vec4(0);\n else \n   O = color4(hit.w*.4);\n\n  O *= difu;\n\n  if ( hit.w == 90. ) O = vec4(1); // marching ran out of steps\n\n  O = sqrt(O);\n}\n","name":"Image","description":"","type":"image"}]}