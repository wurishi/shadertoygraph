{"ver":"0.1","info":{"id":"lsVczK","date":"1522699677","viewed":741,"name":"Pyramid torsion","username":"AntoineC","description":"A slightly disquieting animation of torsioned (tortured?) pyramids!","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["2d","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define Pi 3.14159265359\n\n\n\nfloat Pyramid(vec2 uv, float t)\n{\n    float r = 2.0*t*pow(1.0 - length(uv)/sqrt(2.0), 1.5);\n    \n    uv = mat2(cos(r),sin(r),-sin(r),cos(r))*uv;\n    \n    uv = abs(uv)/sqrt(2.0);\n    return max(uv.x, uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.1*iTime;\n    vec2 uv0 = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (uv0+vec2(1.0))/2.0;\n    \n    float eps = 1.0/iResolution.y;\n\n    // Tile:\n    uv*= 4.0;\n    vec2 uvi = floor(uv);\n    uv = 2.0*fract(uv)-vec2(1.0);\n   \n\t// Row/column phase:\n    t = t + uvi.x/2.0 + uvi.y/8.0;\n    \n    // Smooth triangle tweener:\n    t = 2.0*abs(fract(t)-0.5);\n    t = 2.0*smoothstep(0., 1., t) - 1.0;\n\n    \n    // Normal from function gradient:\n    vec2 h = vec2(4.0*eps, 0);\n    vec2 grad = vec2(\n        Pyramid(uv + h.xy, t) - Pyramid(uv - h.xy, t),\n        Pyramid(uv + h.yx, t) - Pyramid(uv - h.yx, t)) / (2.0*h.x);\n\n    vec3 n = cross(vec3(1.0, 0.0, grad.x), vec3(0.0, 1.0, grad.y));\n    n = normalize(n);\n    \n    \n    // Shading:\n    vec3 l = normalize(vec3(0.0, -3.0, 1.0));\n    float cs = dot(l,n);\n  \n \t// Diffuse + weird back lighting!\n    float c;\n    c = 0.7*max(0.0, cs) + 0.07*max(0.0, -cs);\n    c += 0.1*pow(max(0.0, -cs), 0.5);\n    \n    // Contrast correction:\n    c = pow(c, 0.8);\n\t\n    // \"Ambient occlusion\":\n    uv = abs(uv);\n    c *= smoothstep(0.0, 0.2, pow(1.0-max(uv.x, uv.y)/sqrt(2.0), 2.0));\n    \n    \n    // Vertical gradient:\n    c *= mix(0.3, 1.3, pow((uv0.y + 1.0)/2.0, 1.5));\n    \n    // Clipping:\n    c *= step(abs(uv0.x), 1.0);\n    \n    \n    // Temporal noise/dithering:\n    //  (to attenuate solarization on bad LCD screens)\n    vec3 color;\n    color = vec3(c);\n        \n\tfloat rand = fract(sin((iTime + dot(fragCoord.xy, vec2(12.9898, 78.233))))* 43758.5453);\n    color = (floor(90.0*color) + step(rand, fract(90.0*color)))/90.0;\n    \n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}