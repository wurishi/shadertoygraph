{"ver":"0.1","info":{"id":"cdtyzB","date":"1695203749","viewed":62,"name":"My space dividing","username":"gest","description":"No description","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n#endif\n\n\n//-------------------функции расстояний до объектов\n\nfloat dfBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat dfBall(vec3 p, float R) {\n\treturn length(p) - R;\n}\nfloat dfCyl(vec2 p, float R) {\n\treturn length(p) - R;\n}\n\nfloat dfBefore(float p, float h) {\n\treturn p - h;\n}\nfloat dfAfter(float p, float h) {\n\treturn -p + h;\n}\nfloat dfBetween(float p, float p1, float p2) {\n\treturn max(-p + p1, p - p2);\n}\nfloat dfBetween0(float p, float h) {\n\treturn abs(p) - h;\n}\n\n\n#define ID_STAR 1.0\n#define ID_BASE 2.0\n\nfloat glow = 0.;\nfloat calcGlow = 1.;\n\nfloat map(vec3 p, inout Object object) {\n    vec3 q;\n\t\n\tobject = Object(1e6, 0.);\n\t\n\tq = p;\n\t\n\t//Разделяем пространство\n\treplicaAngle(q.xy, 5., -PI/10.);\n\t\n\t//Звезда\n\tObject STAR = Object(1e6, ID_STAR);\n\t{\n\t\tSTAR.distance = AND(dfCyl(q.yz, 0.10 - 0.3*q.x), dfBefore(q.x, 0.7));\n\t}\n\tobject = OR(object, STAR);\n\n\tq.x -= 0.3;\n\t\n\t//Разделяем пространство\n\treplicaAngle(q.xy, 80., 0.);\n\t\n\t//Основа\t\n\tObject BASE = Object(1e6, ID_BASE);\t\n\t{\n\t\tBASE.distance = AND(dfCyl(q.yz, -0.04 + 0.3*q.x), dfBefore(q.x, 0.3));\n\t}\n\tobject = OR(object, BASE);\n\n\tglow += 0.01*(1.+sin(u_time*0.5))/pow(STAR.distance,0.9)*calcGlow;\n\t\n    return object.distance;\n}\n\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(map(p) - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n\t));\n}\n\nfloat rayMarch(inout Ray ray) {\n    ray.distance = ray.near;\n\tfloat steps = 1.;\n    for(int i=0; i<200; i++) {\n        ray.position = ray.origin + ray.direction*ray.distance;\n        ray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance<ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += ray.object.distance*ray.swing;\n        if(ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n\treturn steps;\n}\n\nvec3 lighting(Ray ray, vec3 lightPos, vec3 mColor) {\n\tvec3 lightDir = normalize(lightPos - ray.position);\n\t\n\tfloat sh = 1.;\n\t\n\t#if 0\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin  \t= ray.position;\n\t\t\tray1.direction \t= lightDir;\n\t\t\tray1.steps\t\t= 50.;\n\t\t\tray1.far\t\t= 0.5;\n\t\t}\n\t\trayMarch(ray1);\n\t\tsh = ray1.hit ? 0.1 : 1.;\n\t#endif\n\n\tfloat atten = 1. / pow(ray.distance,2.0);\n\tfloat ambient = 0.1;\n\tfloat diffuse = max(dot(ray.normal, lightDir), 0.);\n\tfloat specular = pow(max(0.0, dot(reflect(ray.direction, ray.normal), lightDir)),8.0);\n\treturn (mColor * (ambient + diffuse*0.9) + specular) * atten * sh;\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv-0.5;\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 60.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0,0,-2);\n\t\trotateY(cam.origin, u_time);\n\t\tcam.target  = vec3(0);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 64.;\n\t\tray.epsilon = 0.0001;\n\t\tray.swing\t= 0.4; //0.8 + 0.1 * rnd(uv)\n\t\tray.steps \t= 100.;\n\t}\n\tcalcGlow = 1.;\n\tfloat steps = rayMarch(ray);\n    \n    vec3 col = vec3(0);\n\n\tif(ray.distance<ray.far) {\n\t\tcalcGlow = 0.;\n\t\tray.normal = mapNormal(ray.position, ray.epsilon*10.);\n\t\t\n\t\tvec3 lightPos = cam.origin/* + vec3(0.5)*/;\n\t\t\n\t\tvec3 mColor = vec3(1);\n\t\tif (ray.object.id==ID_STAR) mColor = vec3(1,0.2,0.2);\n\t\telse if (ray.object.id==ID_BASE) mColor = vec3(0.1,0.6,1);\n\t\t\n\t\tcol = lighting(ray, lightPos, mColor);\n\t}\n\n\tcol += 0.045* glow * vec3(0.1,0.6,1);//vec3(1,0.6,0.2);\n\t\n\tcol = pow( col, vec3(0.4545) );\n    gl_FragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 200.;\n\t\tray.swing\t\t= 1.;\n\t}\n\treturn ray;\n}\n//-------------------Функции позиционирования объектов сцены\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\nvoid rotateX(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(r,0,0));\n\tp = tMat * p;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,r,0));\n\tp = tMat * p;\n}\nvoid rotateZ(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,0,r));\n\tp = tMat * p;\n}\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Размножение. Возвращает центр ячейки с id=0.\nfloat replica(inout float p, float d) {\n    float id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\n\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nfloat replicaLimit(inout float p, float d, float ida, float idb) {\n\tfloat id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec2 replicaLimit(inout vec2 p, vec2 d, vec2 ida, vec2 idb) {\n\tvec2 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec3 replicaLimit(inout vec3 p, vec3 d, vec3 ida, vec3 idb) {\n\tvec3 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nfloat replicaAngle(inout vec2 p, float n, float off) {\n\tfloat a = 2.* PI /n;\n\t//polar\n\tp = vec2(atan(p.y, p.x), length(p.xy));\n\tfloat id = floor(mod(p.x + 0.5*a + off, 2.*PI)/a);\n    p.x = mod(p.x + 0.5*a + off, a) - 0.5*a;\n\tp = p.y * vec2(cos(p.x),sin(p.x));\n\treturn id;\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n    float h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n    return mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\nfloat AND( float distA, float distB, float k ) {\n    float h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n    return mix( distB, distA, h ) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n\n","name":"Common","description":"","type":"common"}]}