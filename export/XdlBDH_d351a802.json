{"ver":"0.1","info":{"id":"XdlBDH","date":"1496006952","viewed":276,"name":"Mandelbulb + Zoom","username":"sixstring982","description":"Control camera with the mouse.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAMERA_DIST (0.7 + 2.0 * iMouse.x / iResolution.x)\n#define CAMERA_Y ((-iMouse.y / iResolution.y + 0.5) * 5.0)\n\n#define MARCH_DIST (sqrt(CAMERA_Y * CAMERA_Y + 2.0 * CAMERA_DIST * CAMERA_DIST))\n\n#define INFTY 1e20\n#define MARCH_ITERS 700\n#define MAX_RAY_DIST 100.0\n#define MARCH_EPSILON (0.0001 + 0.0001 * pow(MARCH_DIST, 3.0))\n#define MBULB_ITERS 100\n#define MBULB_BAILOUT 2.0\n#define MBROT_POW 8.0\n\n#define TAU 6.283185\n\nfloat mbulb(in vec3 p) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < MBULB_ITERS; i++) {\n        r = length(z);\n        if (r > MBULB_BAILOUT) {\n            break;\n        }\n        \n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr = pow(r, MBROT_POW - 1.0) * MBROT_POW * dr + 1.0;\n        \n        float zr = pow(r, MBROT_POW);\n        theta *= MBROT_POW;\n        phi *= MBROT_POW;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n\nfloat sdSphere(in vec3 p, in float s) {\n    return length(p) - s;\n}\n\nfloat map(in vec3 p) {\n    return mbulb(p);\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    float dist = INFTY;\n    float totalDist = 0.0;\n    for (int i = 0; i < MARCH_ITERS; i++) {\n        if (totalDist > MAX_RAY_DIST\n            || dist < MARCH_EPSILON) {\n            break;\n        }\n        \n        dist = map(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (dist < MARCH_EPSILON) {\n        return totalDist;\n    }\n    return INFTY;\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 EV = vec2(MARCH_EPSILON, 0.0);\n    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),\n                          map(ro + EV.yxy) - map(ro - EV.yxy),\n                          map(ro + EV.yyx) - map(ro - EV.yyx)));\n}\n\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.0;\n    float delta = 0.5;\n    for (float i = 1.0; i <= 5.0; i++) {\n        float c = (1.0 / pow(2.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += clamp(c, 0.0, 1.0);\n    }\n    \n    return 1.0 - k * s;\n}\n\n#define COLOR_MAP_INDEX 2\nmat4 COLOR_MAPS[] = mat4[3](\n  mat4(0.5, 0.5, 1.0, 0.00,\n       0.5, 0.5, 1.0, 0.33,\n       0.5, 0.5, 1.0, 0.66,\n       0.0, 0.0, 0.0, 0.00),\n  mat4(0.5, 0.5, 1.0, 0.30,\n       0.5, 0.5, 1.0, 0.20,\n       0.5, 0.5, 1.0, 0.20,\n       0.0, 0.0, 0.0, 0.00),\n  mat4(0.5, 0.5, 1.0, 0.00,\n       0.5, 0.5, 1.0, 0.10,\n       0.5, 0.5, 1.0, 0.20,\n       0.0, 0.0, 0.0, 0.00)\n);\nvec3 colorAt(vec3 p) {\n    float x = length(p);\n    mat4 cmap = COLOR_MAPS[COLOR_MAP_INDEX];\n    \n    return vec3(\n        cmap[0][0] + cmap[0][1] * cos(TAU * (cmap[0][2] * x + cmap[0][3])),\n        cmap[1][0] + cmap[1][1] * cos(TAU * (cmap[1][2] * x + cmap[1][3])),\n        cmap[2][0] + cmap[2][1] * cos(TAU * (cmap[2][2] * x + cmap[2][3])));\n}\n\n#define LIGHT_COUNT 1\nvec3 getLight(in int index) {\n    if (index == 0) {\n        return vec3(0, 5.0, 0);\n    }\n    return vec3(5.0, 0, 0);\n}\n\n#define SPECULAR_POW 8.0\nvec3 lighting(in vec3 ro, in vec3 rd, float dist) {\n    vec3 n = normalAt(ro);\n    vec3 V = -rd;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n        vec3 lp = getLight(i);\n        vec3 L = normalize(lp - ro);\n        vec3 R = reflect(-L, n);\n        float dist = length(ro - lp);\n        float intensity = 100.0 / (dist * dist);\n        \n        float shadow = march(lp, -L);\n        if (length((-L * shadow) - ro) < MARCH_EPSILON) {\n            break; // No hit, no lighting.\n        }\n        \n        diffuse = clamp(diffuse + intensity * max(0.0, dot(L, n)), 0.0, 1.0);\n        specular = clamp(specular + intensity * max(0.0, pow(dot(R, V), 8.0)), 0.0, 1.0);\n    }\n    \n    return colorAt(ro)\n         * vec3(diffuse + specular)\n         * occlusion(ro, n, 1.0);\n}\n\n#define CAMERA_SPEED 0.1\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = vec3(sin(iTime * CAMERA_SPEED) * CAMERA_DIST,\n              (-iMouse.y / iResolution.y + 0.5) * 5.0,\n              cos(iTime * CAMERA_SPEED) * CAMERA_DIST);\n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    \n    vec3 cameraDir = normalize(target - ro);\n    vec3 cameraRight = cross(cameraDir, up);\n    vec3 cameraUp = cross(cameraRight, cameraDir);\n    \n    rd = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    setupCamera(uv, ro, rd);\n    float dist = march(ro, rd);\n    if (dist == INFTY) {\n        fragColor = vec4(.459, .69, .584, 1.0);\n    } else {\n        fragColor = vec4(lighting(ro + rd * dist, rd, dist), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}