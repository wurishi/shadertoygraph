{"ver":"0.1","info":{"id":"XlcBRs","date":"1540568711","viewed":78,"name":"ChamelionCharacter","username":"tqle","description":"Character project added color ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n//Randomizing vectors, parametizes a vec2 to return a float\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\n//Rotating shape using matrix transformation\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n//Produces a cylinder, \nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n//Produces a sphere\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n//Produces a box\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//Mixing colors, where the 3rd parameter is the mixing ratio \nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\n//Mixing shapes, or blending the pixels projected onto the screen\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\n//Produces a cone(circular base)\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\n//Changing coordinate system to polar coordinates, making it easy to stretch shapes\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\n//Modifying the coordinate system\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n//Similar to smooth step function, removing edges of shapes\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n//Rotating shapes on Y axis\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n//Blending shapes, merging them together while creating rippples\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n//Projecting shapes\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n    vec3 b = c; //body\n    vec3 h = c; //head\n    vec3 e = c;\t//eyes\n    vec3 n = c; //nose\n    vec3 m = c; //mouth\n   \tvec3 ha = c; //hands\n    vec3 f = c; //feet\n    vec3 bu = c; //butt\n    vec3 p = c;\n   \tvec3 caone = c; //cap\n    vec3 catwo = c;\n    vec3 cathree = c;\n\t//changing projected pixels and its distance from the camera\n\tp.x = abs(p.x) - .075;\n    float pupils = sphere(p - vec3(0., .6, -2.75), .025);\n    m.xy *= rot(2.5*m.x);\n    vec4 mCol = vec4(1., 1., 1., 1.);\n    float mouth = fBox(m - vec3(0., .5, -2.), vec3(.15, .025, .005));\n    //float nose = sphere(e - vec3(0., .65, - 2.), .05);\n    n.yz *= rot(radians(15.));\n\t\n    //pModPolar(caone.yz, 3.);\n    //caone.y /= cos(sin(c.x)); \n\tcaone.x *= cos(sin(caone.x*3.))*.6;\n    vec4 capCol = vec4(165./255., 42./255., 42./255., 1.);\n    float capone = sphere(caone - vec3(0., 1.5, -2.), .4);\n    catwo.xy *= rot(radians(10.));\n    catwo.y *= cos(sin(catwo.x*3.))*.3;\n    float captwo = sphere(catwo - vec3(.8, 0.18, -2.), .1);\n    cathree.xy *= rot(-radians(10.));\n    cathree.y *= cos(sin(catwo.x*3.))*.3;\n    float capthree = sphere(cathree - vec3(-.8, .15, -2.), .1);\n    //ca.xy *= rot(1.5 * ca.x);\n    //float cap = fBox(ca - vec3(0., 1.5, -2.), vec3(.5, .075, .002));\n    float nose = fCone(n - vec3(0., .65, -2.), .05, .5);\n\n    e.x = abs(e.x) - .1;\n    vec4 eCol = vec4(sin(e.x), cos(iTime)*.1, 135./255., 1. - sin(iTime)*.1); \n    float eye = sphere(e - vec3(0., .75, - 2.), .1); \n    //b.y = cos(sin(b.y*1.) * cos(.1));\n    vec4 bCol = vec4(222./255. + sin(e.x * iTime*100.), 184./255. - e.y*cos(iTime), 135./255., .1);\n    float body = sphere(b - vec3(0., -.5, 0.), 1.5);\n    \n    //float body = fBox(b - vec3(0., -.15, 0.), vec3(.1, .4, .005));\n    float butt = sphere(bu - vec3(0., -.5, .01), .11);\n    vec4 hCol = vec4(1., 248./255., 220./255., 1.);\n    ha.x = abs(ha.x) - .75;\n    float hands = sphere(ha - vec3(0., .25, - 1.5), .15);\n    float head = sphere(h - vec3(0., 1., -1.), .85);\n    \n    f.x = abs(f.x) - .4;\n    f.y *= cos(sin(f.x*2.))*.6;\n    f.z *= cos(sin(f.x*2.5));\n    vec4 fCol = hCol;\n    fCol[0] *= cos(iTime);\n    float feet = sphere(f - vec3(0., -.75, -2.5), .1);\n    //float feet = sdEllipsoid(f + vec3(.0, -.8, 2.5), vec3(.1, .02, .2));\n    //f.x = abs(f.x) - .4;\n    //float feet = fBox(f - vec3(0., -.9, -1.9), vec3(.125, .06, .1));\n    \n\t\n    //adding the instantiated variables onto the shape.dist. \n    shape.dist = fOpUnionRound(body, head, 1.);\n    shape.dist = min(shape.dist, eye);\n    shape.dist = min(shape.dist, nose);\n    shape.dist = min(shape.dist, mouth);\n    shape.dist = min(shape.dist, hands);\n    shape.dist = min(shape.dist, feet);\n    shape.dist = min(shape.dist, butt);\n\tshape.dist = min(shape.dist, pupils);\n    shape.dist = fOpUnionColumns(shape.dist, capone, .25, 3.);\n    shape.dist = fOpUnionColumns(shape.dist, captwo, .25, 1.);\n    shape.dist = min(shape.dist, capthree);\n    \n    //shape.color = bCol;\n    shape.color = mix(bCol, mCol, mixColors(mouth, body, .01));\n    shape.color = mix(shape.color, hCol, mixColors(hands, shape.dist, .01));\n    shape.color = mix(shape.color, capCol, mixColors(capone, shape.dist, 0.01));\n    shape.color = mix(shape.color, capCol, mixColors(captwo, shape.dist, 0.01));\n    shape.color = mix(shape.color, capCol, mixColors(capthree, shape.dist, 0.01));\n    shape.color = mix(shape.color, fCol, mixColors(feet, shape.dist*5., .01));\n    shape.color = mix(shape.color, eCol, mixColors(eye, shape.dist, .01));\n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //modifying the coordinate system \n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  //setting camera position \n  vec3 cam = vec3(0., 0., -6.5);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ","name":"Image","description":"","type":"image"}]}