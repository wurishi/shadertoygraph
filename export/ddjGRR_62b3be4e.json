{"ver":"0.1","info":{"id":"ddjGRR","date":"1667168071","viewed":104,"name":"Raymarching v2 - azavier","username":"azavier","description":"hopefully easier to read, maintain, and add onto\n\nif someone has a better system for shadows, please do let me know.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR_PLANE 250.\n#define HIT_DISTANCE 0.01\n\n// set AA to 2 or higher to enable anti-aliasing\n#define AA 2\n\n#define AMBIENT_INTENSITY 0.01\n\n#define DIFFUSE_INTENSITY 1.\n\n#define SPECULAR_INTENSITY 5.\n#define SPECULAR_FALLOFF 50.\n\n#define SHADOWS 1\n#define ATTENUATION 1\n\n#define AMBIENT_PERCENT vec3(0.01)\n\n#define SKY_COLOR(dir) dir\n\n#define MAX_SHADOW_DARKNESS 0.2\n#define SHADOW_PENUMBRA 17.5\n#define SHADOW_MAX_STEPS 32\n#define SHADOW_MAX_DISTANCE 50.\n\n#define ATTENUATION_CONSTANT 0.05\n#define ATTENUATION_LINEAR 0.1\n#define ATTENUATION_QUADRATIC 0.5\n\n\n#define REFLECTIONS 10\n\nstruct Material {\n  vec3 albedo;\n  float roughness;\n  float metallic;\n};\nMaterial defaultMaterial = Material(vec3(1), 1., 0.);\nMaterial mirrorRed = Material(vec3(0.9, 0, 0), 1., 1.); // 0.\nMaterial mirrorBlue = Material(vec3(0, 0, 0.9), 1., 0.); // 0.09\nMaterial mirrorGreen = Material(vec3(0, 0.9, 0), 0., 0.); //0.3\nMaterial metallic = Material(vec3(0.4), 0., 1.);\nMaterial wallMaterial = Material(vec3(1), 1., 0.);\nMaterial groundMaterial = Material(vec3(1), 1., 0.);\nMaterial ceilingMaterial = Material(vec3(1), 1., 0.);\n\nstruct Sphere {\n  vec4 worldData;\n  Material material;\n};\n\nstruct HitData {\n  float distance;\n  vec3 point;\n  vec3 direction;\n  vec3 normal;\n  \n  vec3 albedo;              \n  float roughness;\n  float metallic;\n};\nstruct SceneData {\n  float closestDistance;\n  Material surfaceMaterial;\n};\n\n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat Hash21(vec2 hash) {\n  vec2 p = fract(hash*vec2(25.124, 85.124));\n  p += dot(p, p + 234.124);\n  return fract(p.x * p.y);\n}\n\nvec3 randomVec3(vec3 point) {\n  vec3 ret;\n  ret.x = Hash21(vec2(point.x * point.y, point.z * point.y));\n  ret.y = Hash21(vec2(point.x * point.z, point.y * point.x));\n  ret.z = Hash21(vec2(point.y * point.z, point.z * point.y));\n  return normalize(ret);\n}\n\nfloat SignedSphereDistance(in vec3 position, in Sphere sphere) { return length(position - sphere.worldData.xyz) - sphere.worldData.w; }\nSceneData SceneField(in vec3 position) {\n  // for any position in the scene, SceneDistance will return the distance to\n  // the closest object in the scene, as well as the material of the object.\n  SceneData data;\n  data.closestDistance = FAR_PLANE;\n  \n  Sphere[] spheres = Sphere[](\n    Sphere(\n      vec4(0,1.5,0, 1), // x,y,z, r\n      mirrorRed\n    ),\n    Sphere(\n      vec4(2,0.5,1, 0.5),\n      mirrorBlue\n    ),\n    Sphere(\n      vec4(2,2.5,3, 1.5),\n      metallic\n    )\n  ); // Material(hsv2rgb(vec3(0.5+0.5*sin(1.25*iTime), 1., 1.)), 0.1, true)\n  for(int i = 0; i < spheres.length(); i++) {\n    float sphereDistance = SignedSphereDistance(position, spheres[i]);\n    if(sphereDistance < data.closestDistance) {\n      data.surfaceMaterial = spheres[i].material;\n      data.closestDistance = sphereDistance;\n    }\n  }\n  \n  /*\n  float[] walls = float[](\n    15. + position.z,\n    15. + position.x,\n    15. - position.z,\n    15. - position.x\n  );\n  \n  for(int i = 0; i < walls.length(); i++)\n    if(walls[i] < data.closestDistance) {\n      data.surfaceMaterial = wallMaterial;\n      data.closestDistance = walls[i];\n    }*/\n  \n  // the y-value of any point is the distance to y=0, \n  // you can think of subtraction as the distance from the right\n  // to the left (5 - 2 is a distance of 3, since to go from 2 to 5 is 3 steps)\n  // so this line of code says 'if the distance of my y-value to 15 is closest'\n  /*\n  if(15. - position.y < data.closestDistance) {\n    data.surfaceMaterial = ceilingMaterial;  \n    data.closestDistance = 15. - position.y;\n  }*/\n  // these lines of code\n  // set our ground to be at y=0\n  if(position.y < data.closestDistance) {\n    /*\n    vec3 groundText = round(vec3(sin(position.x*2.)))\n                    + round(vec3(sin(position.z*2.)));\n    groundText = abs(groundText);\n    */\n    vec3 groundText = ceil(clamp(vec3(sin(position.x*2.) + sin(position.z*2.)), 0., 1.));\n    data.surfaceMaterial = Material(groundText, 1., 0.);  \n    data.closestDistance = position.y;\n  }\n  \n  return data;\n}\n\nHitData MarchScene(in vec3 rayOrigin, in vec3 rayDirection) {\n  HitData hit;\n  hit.albedo = vec3(1);\n  hit.direction = rayDirection;\n  \n  SceneData data;\n  for(hit.distance = 0.; hit.distance < FAR_PLANE;) {\n    data = SceneField(rayOrigin + rayDirection*hit.distance);\n    \n    if(data.closestDistance < HIT_DISTANCE)\n      break;\n    \n    hit.distance += data.closestDistance;\n  }\n  \n  // If we hit something\n  if(hit.distance < FAR_PLANE) {\n    hit.point = rayOrigin + rayDirection*hit.distance;\n    \n    hit.albedo = data.surfaceMaterial.albedo;\n    hit.roughness = data.surfaceMaterial.roughness;\n    hit.metallic = data.surfaceMaterial.metallic;\n  \n    vec2 delta = vec2(0.0001, 0);\n    vec3 gradient = vec3(\n      SceneField(hit.point - delta.xyy).closestDistance,\n      SceneField(hit.point - delta.yxy).closestDistance,\n      SceneField(hit.point - delta.yyx).closestDistance\n    );\n    hit.normal = normalize(data.closestDistance - gradient);\n    return hit;\n  }\n  // If we didn't hit anything\n  hit.albedo = SKY_COLOR(rayDirection);\n  hit.distance = -1.;\n  \n  return hit;\n}\n\nfloat SurfaceShadow(in vec3 surfacePoint, in vec3 lightsourceDirection) {\n  float surfaceLight = 1.;\n  \n  float rayDistance;\n  SceneData data;\n  //for(rayDistance = 0.; rayDistance < SHADOW_MAX_DISTANCE;) {\n  for(int step = 0; step < SHADOW_MAX_STEPS && rayDistance < SHADOW_MAX_DISTANCE; step++) {\n    data = SceneField(surfacePoint + lightsourceDirection*rayDistance);\n    \n    if(data.closestDistance < 0.)\n      break;\n    \n    surfaceLight = min(surfaceLight, smoothstep(0., 1., SHADOW_PENUMBRA*data.closestDistance/rayDistance));\n    rayDistance += data.closestDistance;\n  }\n  return min(max(surfaceLight, MAX_SHADOW_DARKNESS), 1.);\n}\n\nvec3 GlobalIllumination(in HitData hit, in vec3 rayOrigin, in vec3 lightPosition, in vec3 lightColor) {\n  vec3 lightDirection = lightPosition - hit.point;\n  float lightDistance = length(lightDirection);\n  lightDirection = normalize(lightDirection);\n  vec3 halfway = normalize(normalize(rayOrigin - hit.point) + lightDirection);\n  \n  #if SHADOWS == 1\n    float surfaceShadow = SurfaceShadow(hit.point + hit.normal*0.02, lightDirection);\n    surfaceShadow = max(MAX_SHADOW_DARKNESS, surfaceShadow);\n  #else\n    float surfaceShadow = 1.;\n  #endif\n  \n  #if ATTENUATION == 1\n    // attenuation curve\n    float attenuation = ATTENUATION_CONSTANT \n                      + ATTENUATION_LINEAR*lightDistance \n                      + ATTENUATION_QUADRATIC*lightDistance*lightDistance;\n    attenuation = 1./attenuation;\n  #else\n    float attenuation = 0.333;\n  #endif\n  // ambient lighting calculations\n  vec3 ambient = (AMBIENT_PERCENT + (attenuation*1.*lightColor));\n  // diffuse lighting calculations\n  vec3 diffuse = (lightColor*dot(hit.normal, lightDirection)*attenuation*1.);\n  // specular lighting calculations\n  vec3 specular = (lightColor*pow(dot(hit.normal, halfway), SPECULAR_FALLOFF*hit.metallic)*attenuation*1.);\n  // calculate the illumination values from the light source\n  // global is a (mostly) grayscale vec3 soley with light data.\n  vec3 global = ambient*AMBIENT_INTENSITY \n              + diffuse*DIFFUSE_INTENSITY \n              + specular*SPECULAR_INTENSITY;\n  // return this vector multiplied by the hit albedo for colors\n  return global*hit.albedo*surfaceShadow;\n}\n\nvec3 SurfaceReflection(inout HitData hit, in vec3 lightPosition, in vec3 lightColor) {\n  // the new point we are reflecting from.\n  vec3 reflectionOrigin = hit.point; \n  // the albedo of the reflective object\n  vec3 objectAlbedo = hit.albedo;\n  // reflect ray along normal\n  hit.direction = reflect(hit.direction, hit.normal + hit.roughness*randomVec3(hit.point)); // MULTIPLY hit.normal BY THE ROUGNESS AND A RANDOM VALUE\n  // save the texture of the skybox before we modify hit\n  vec3 skybox = SKY_COLOR(hit.direction);\n  // march along the reflected ray\n  hit = MarchScene(reflectionOrigin+hit.normal*HIT_DISTANCE, hit.direction);\n  // if we hit nothing, return the skybox color (hit.albedo = SKY_COLOR if dist < 0)\n  \n  if(hit.distance < 0.)\n    return hit.albedo;\n  \n  // if we hit something, add the color of the hit.\n  hit.albedo *= objectAlbedo;\n  \n  return GlobalIllumination(hit, reflectionOrigin, lightPosition, lightColor);\n  /*\n  // return contributions of new ray\n  return hit.distance < 0.\n       ? hit.albedo\n       : GlobalIllumination(hit, reflectionOrigin, lightPosition, lightColor);\n  */\n}\n\n// https://www.shadertoy.com/view/tlKSzK\nvec3 LookAt(in vec2 uv, in vec3 rayOrigin, in vec3 lookPoint){\n  vec3 toVec = normalize(lookPoint - rayOrigin),\n       r = normalize(cross(toVec, vec3(0, 1, 0))),\n       upVector = cross(r, toVec),\n       c = rayOrigin + toVec,\n       i = c - r*uv.x + upVector*uv.y;\n    \n  return normalize(i-rayOrigin);\n}\n\nvec3 PixelColor(in vec2 uv) {\n  vec3 pixelColor;\n  \n  vec3 lightPosition = vec3(7.*sin(iTime), 4.5, 7.*cos(iTime));\n  vec3 lightColor = vec3(1);\n  \n  vec3 camPosition = vec3(6, 2.5, -2);\n  vec3 camLook = vec3(1, 1.5, 2);\n  // the weird camera rotation\n  camLook.xz += 0.1*vec2(sin(iTime), cos(iTime));\n  // calculate the view direction\n  vec3 rayDirection = LookAt(uv, camPosition, camLook);\n  // march out from the camera in the rayDirection\n  HitData hit = MarchScene(camPosition, rayDirection);\n  // distance is < 0 when nothing is hit\n  if(hit.distance > 0.) {\n    // calculate global illumination at the point hit\n    pixelColor = GlobalIllumination(hit, camPosition, lightPosition, lightColor);\n    // variable to hold the number of times the reflection loop ran.\n    int timesReflected;\n    // if the object is reflective, run this loop for reflection contributions\n    for(timesReflected; hit.roughness < 1. && timesReflected < REFLECTIONS; timesReflected++)\n      pixelColor += SurfaceReflection(hit, lightPosition, lightColor);\n    // if we reflected at all, average out the extra contributions\n    if(timesReflected > 0)\n      pixelColor /= float(timesReflected);\n  } else\n    pixelColor = hit.albedo;\n  // if the hit distance is less than 0, we hit nothing within the\n  // bounds of the FAR_PLANE, so set these pixels to the sky color\n  return pixelColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y; // the center of the screen is (0, 0), the edges are at 0.5 and -0.5\n  vec3 pixelColor = vec3(0);\n  \n  #if AA > 1\n    vec2 AAO;\n    const float AA_INCREMENT = 1./float(AA);\n    \n    for(AAO.x = -0.5; AAO.x < 0.5; AAO.x += AA_INCREMENT) {\n      for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT) {\n        pixelColor += PixelColor(uv + AAO/iResolution.y);\n      }\n    }\n    pixelColor /= float(AA*AA);\n  #else\n    pixelColor += PixelColor(uv);\n  #endif\n  // Output to the screen, apply light color correction (the sqrt)\n  fragColor = vec4(sqrt(clamp(pixelColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}