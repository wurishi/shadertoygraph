{"ver":"0.1","info":{"id":"tsXXz7","date":"1550871592","viewed":273,"name":"hw3 566 2","username":"24602848yan","description":"hw3 566 last one crash...\nthis one also dangerous...\ni think i need to learn more in efficiently rendeirng things.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 256\n#define FAR 10.0\n#define PI 3.14159265359\n#define EPS 0.0001\n#define MoveSpeedT (iTime * 0.1)\n#define iGT (iTime + 1.0)\n\n//pow is to increase the contrast of the color\nvec3 skyCol = pow(vec3(163., 175., 223.) / 255., vec3(2.0));\nvec3 sunCol = 2. * pow(vec3(207., 255., 255.) / 255., vec3(2.));\n\nvec4 lights[3];\nvec3 lightColor1 = vec3(231., 231., 238.) / 255.;\nvec3 lightColor2 = vec3(55, 56, 83) / 255.;\nvec3 lightColor3 = vec3(93, 72, 123) / 255.;\n\n//remap\nvec3 Colora = vec3(128., 128., 128.) / 255.;\nvec3 Colorb = vec3(128., 128., 128.) / 255.;\nvec3 Colorc = vec3(510., 255., 0.) / 255.;\nvec3 Colord = vec3(128., 51., 64.) / 255.;\n\n//this perlin noise comes from https://www.shadertoy.com/view/MlfXWH\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    // Quintic\n    vec2 df = 30.f * f * f * (f * (f - 2.0) + 1.0);\n    f = f * f * f * (f * (f * 6.-15.) + 10.);  \n    float a = texture(iChannel0, (i+vec2(0.5, 0.5))/256., -100.0).r;\n    float b = texture(iChannel0, (i+vec2(1.5, 0.5))/256., -100.0).r;\n    float c = texture(iChannel0, (i+vec2(0.5, 1.5))/256., -100.0).r;\n    float d = texture(iChannel0, (i+vec2(1.5, 1.5))/256., -100.0).r;    \n    float k = a-b-c+d;\n    float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);   \n    return vec3(n, vec2(b-a+k*f.y, c-a+k*f.x)*df);\n}\n//2d space rotation\nmat2 m = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbmSimple(vec2 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 2; i++){ \n        f += amp * noise(p).x;\n        p = 2.0 * m * p;\n        amp = amp * 0.5;\n    }\n    return f;\n}\nfloat fbmL(vec2 p) {\n    float f = 0.0, w = 0.5;\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 6; ++i) {\n        vec3 n = noise(p);\n        f += abs(w * 1.8 * n.x);\n        w *= 0.5; \n        p = 2.* m * p;\n    }\n    return f;\n}\nfloat fbmM(vec2 p) {\n    float f = 0.0, w = 0.5;\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 6; ++i) {\n        vec3 n = noise(p);\n        f += abs(w * n.x);\n        w *= 0.5; \n        p = 1.6 * rot * p;\n    }\n    return f;\n}\n//sdf things\nvec2 sdfmoutain(vec3 p) {\n\treturn vec2(p.y + 0.9 - fbmM(p.xz), 2.0);\n}\n//from iq https://iquilezles.org/articles/distfunctions\nvec2 sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  float ss = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return vec2(ss, 3.0);\n}\n\nvec2 sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2( length(p.xz)- 2.0 * ra+rb, abs(p.y) - h );\n    float ss = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n    return vec2(ss, 4.0);\n}\n\nvec2 sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0 * p.x < m ) q = p.xyz;\n    else if( 3.0 * p.y < m ) q = p.yzx;\n    else if( 3.0 * p.z < m ) q = p.zxy;\n    else return vec2(m * 0.57735027, 5.0);    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    float dis = length(vec3(q.x,q.y-s+k,q.z-k));\n    return vec2(dis, 5.0); \n}\n\nvec2 sdRoundCone(vec3 p, float r1, float r2, float h){\n    vec2 q = vec2( length(p.xz), p.y );  \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    if(k < 0.0) return vec2(length(q) - r1, 7.0);\n    if(k > a*h) return vec2(length(q-vec2(0.0,h)) - r2, 7.0);\n    float dis = dot(q, vec2(a,b) ) - r1;\n    return vec2(dis, 7.0);\n}\n\nvec2 minDist(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x)? d1 : d2;\n}\n\nvec2 rotatesdOctahedron(vec3 p, float ss, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n    mat4 rotaEar = mat4(vec4(c, 0, s, 0),\n                        vec4(0, 1, 0, 0),\n                        vec4(-s, 0, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return sdOctahedron(poi, ss);\n}\n\nvec2 rotatesdRoundedCylinder(vec3 p, float ra, float rb, float h, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n\tmat4 rotaEar = mat4(vec4(1, 0, 0, 0),\n                        vec4(0, c, -s, 0),\n                        vec4(0, s, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return sdRoundedCylinder(poi, ra, rb, h);\n}\n\n//actually is a frog\nvec2 CatHead(vec3 p) {\n\tvec2 dishead =  vec2(sdRoundedCylinder(p - vec3(0, -2.0, 0.4), 1.5, 2.0, 0.6).x, 3.0);\n    vec2 ear1 = vec2(sdRoundCone(p - vec3(1.2, 0.9, 0.8), 0.2, 0.9, 0.9).x, 4.0);\n    vec2 ear2 = vec2(sdRoundCone(p - vec3(-1.2, 0.9, 0.6), 0.2, 0.9, 0.9).x, 4.0);\n    vec2 eye1 = vec2(rotatesdOctahedron(p - vec3(-1, -0.6, 2.8), 0.5, 22.).x, 6.0);\n    vec2 eye2 = vec2(rotatesdOctahedron(p - vec3(1, -0.6, 2.8), 0.5, -22.).x, 6.0);\n    vec2 eyeball = vec2(rotatesdRoundedCylinder(p - vec3(-1.5, 1.5, 1.2), 0.2, 0.3, 0.1, 90.).x, 8.0);\n    vec2 eyeball2 = vec2(rotatesdRoundedCylinder(p - vec3(0.8, 1.5, 1.6), 0.2, 0.3, 0.1, 90.).x, 8.0);\n    \n    vec2 dismin = minDist(minDist(minDist(minDist(dishead, eye1), ear1), eye2), ear2);\n    dismin = minDist(minDist(dismin, eyeball), eyeball2);\n    return dismin;\n}\nvec2 catScale(in vec3 p, in float s){\n    //return primitive(p/s)*s;\n    return CatHead(p / s) * vec2(s, 1.);\n}\nvec2 rotatesdcat(vec3 p, float sc, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n    mat4 rotaEar = mat4(vec4(c, 0, s, 0),\n                        vec4(0, 1, 0, 0),\n                        vec4(-s, 0, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return catScale(poi, sc);\n}\nvec2 map(vec3 p) {\n    vec2 dis1 = sdfmoutain(p);\n    vec2 dis2 = rotatesdcat(p - vec3(-2.5, -0.38, 3.), 0.03, -60.);\n    return minDist(dis1, dis2);\n    //return dis1;\n}\n\n//color remap\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n//clouds inspiration comes from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m2 = mat2(1.6, 1.2, -1.2, 1.6);\nconst mat2 rot = mat2(0.75, 0.66, -0.66, 0.75);\n//perlin noise comes from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(vec2 p) {return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise2(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat fbmClouds(vec2 uv) {\n    float sum = 0.0;\n    float freq = 2.0;\n    float amp = 0.5;\n    for(int i = 0; i < 8; i++) {\n        sum += noise2(uv) * amp;\n        uv = uv * m2;\n        amp *= 0.4;\n    }\n    return sum;\n}\nfloat fbmClouds2(vec2 uv){\n\tfloat q = fbmClouds(uv);\n    float r = 0.0;\n    uv -= q - iTime * 0.03f;\n    float weight = 0.6;\n    for (int i = 0; i < 8; i++){\n        r += abs(weight * noise2(uv));\n        uv = m * uv + iTime * 0.5;\n        weight *= 0.7;\n    }\n    return r;\n}\nfloat fbmClouds3(vec2 uv){\n\tfloat q = fbmClouds(uv);\n    float r = 0.0;\n    uv -= q - iTime * 0.03f;\n    float weight = 0.6;\n    for (int i = 0; i < 8; i++){\n        r += abs(weight * noise2(uv));\n        uv = rot * uv + iTime * 0.5;\n        weight *= 0.7;\n    }\n    return r;\n}\n//////////////////////////////////////////////\n//tool box\nfloat smooththestep(float edge0, float edge1, float x) {\n\tx = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * (3.0 - 2. * x);    \n}\nvec3 Sky(vec3 sundir, vec3 dir) {\n    ////////star////////////////\n    vec3 stars = vec3(smooththestep(0.85, 0.9, 0.18 + fbmSimple(iTime * 0.2 + 100.0 * dir.xy)));\n    ////////////////////clouds\n    vec3 clouds = vec3(0.0);\n    vec3 clouds2 = vec3(0.0);\n    vec3 pale = palette(iTime * 0.02, Colora, Colorb, Colorc, Colord);\n    //clouds += vec3(195., 93., 249.)/255. * fbmClouds2(vec2((dir.x) / dir.y, -dir.z / dir.y ));   \n    clouds2 += pale * fbmClouds3(vec2((dir.z - iTime * 0.02) / dir.y, -(dir.x - 0.1) / dir.y));        \n    vec3 col = 0.4 * skyCol/* + 0.55 * clouds * max(0.0, dir.y)*/ + 0.75 * clouds2 * max(0.0, dir.y);    \n    vec3 starcol = vec3(232., 183., 124.)/255.;\n    col = mix(col, 2.5 * starcol * stars * max(0.0, dir.y), 0.8);  \n    ///////////////////////////////////////\n    vec2 sunPos = dir.xy/dir.z - sundir.xy/sundir.z;\n    col +=  max(0.0, -dir.z - 0.1) * sunCol * 0.29 * pow(max(dot(sundir, dir) - 0.19, 0.0), 10.0);       \n    col = mix(col, vec3(0.8), max(0.0, -dir.z) * fbmSimple(7. * sunPos + iTime * 0.2) * smoothstep(0.30, 0.29, length(sunPos)));\n    return col;\n}\nvec3 terrainbasecolor(vec3 p, vec3 n) {\n    vec3 color = pow(vec3(80., 61., 89.)/255., vec3(2.4));\n    //return color;\n    return mix(vec3(1.0), color, smoothstep(0.09 * n.y, 0.5 * n.y, fbmM(p.xz)));\n}\n//get normal\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(map(p+q.yxx).x - map(p-q.yxx).x,\n                \t\t   map(p+q.xyx).x - map(p-q.xyx).x,\n                \t\t   map(p+q.xxy).x - map(p-q.xxy).x));\n}\n/////////////////////////////AO////////////////////////////////\nconst int AO_SAMPLES = 100;\nconst float AO_DIST = 0.5;\n//tangent space axis get from adam\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {   \n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\nfloat computeAO(vec3 p, vec3 n, float dist) {\n    float aoSum = 0.0;\n    // Sample a few points in the hemisphere around n at p\n    vec3 t, b;\n    // Make a tangent and bitangent vector\n    coordinateSystem(n, t, b);\n    for(int i = 0; i < AO_SAMPLES; ++i) {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(p + float(i) * 100.);//square random        \n        // Convert the xi pair to a vector in the hemisphere\n        float rz = xi.x;\n        float rx = cos(2.* PI * xi.y) * sqrt(1. - rz * rz);\n     \tfloat ry = sin(2.* PI * xi.y) * sqrt(1. - rz * rz);       \n        //local to world\n        vec3 dir = transpose(mat3(t, b ,n)) * vec3(rx, ry, rz);\n        //step if dis < 0 return 0, else return 1\n        aoSum += step(0.55, map(p + dir * dist).x);\n    }\n    return aoSum / float(AO_SAMPLES);\n}\n//iq fog\nvec3 applyFog(vec3  rgb,     // original color of the pixel\n               float distance,// camera to point distance\n               vec3  rayOri, // camera position\n               vec3  rayDir) // camera to point vector\n{\n    rayOri = rayOri + rayDir * 0.01;\n    float c = 6., b = 80.0, b2 = 0.03;\n    float fogAmount = c * exp(-rayOri.y * b2) * (1.0-exp(-distance*rayDir.y * b)) / rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.5,0.7);\n    vec3 col = mix(rgb, fogColor, fogAmount);\n    if(col.x < 0.1 && col.y < 0.1 && col.z < 0.1) {\n    \tcol =  0.5 * rgb;\n    }\n    return col;\n    //return vec3(fogAmount);\n}\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\nvec2 Shadowmap(vec3 p){\n    vec2 dis1 = sdfmoutain(p);\n    //vec2 dis2 = CatHead(p);\n    //return minDist(dis1, dis2);\n    return dis1;\n}\n//iq soft shadow\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;//min t\n    for(int i = 0; i < MAX_STEP; ++i) {\n        float m = Shadowmap(origin + t * dir).x;\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t, float id) {\n    vec3 sunpos = normalize(vec3(1.0, 0.9, -1.0));     \n    // Light positions with intensity as w-component\n\tlights[0] = vec4(sunpos, 2.0); // key light\n\tlights[1] = vec4(-6.0, 3.0, -1.0, 1.5); // fill light\n\tlights[2] = vec4(5.0, 5.0, -1.5, 4.0); // back light            \n    \n    //if t = -1\n    vec3 col = Sky(sunpos, rd);        \n    vec3 p = ro + t * rd;//p\n    vec3 n = normal(p);//normal\n    vec3 lightp = normalize(sunpos - p);\n    vec3 lightp2 = normalize(lights[1].xyz - p);\n    vec3 lightp3 = normalize(lights[2].xyz - p);\n    vec3 pale = palette(iTime * 0.002, Colora, Colorb, Colorc, Colord);\n    \n    float dis = map(ro + t * rd).x; \n    //if t > 0\n    if (t > 0.0 && id == 2.0) {//moutain\n        //basecolor//////////////////////////////\n        vec3 tex = terrainbasecolor(p, n);\n        /////fog////////////////////////////////\n        vec3 afterfog = applyFog(tex, dis, ro, rd);\n        /////ao.////////////////////////////////\n        vec3 ao = vec3(computeAO(p, n, 1.0)); \n        /////diffuse color////////////////////////////////\n        //shadow//////////////////////////////\n        vec3 lightfinal = pow(lightColor1, vec3(2.2)) * max(dot(n, sunpos), 0.0);\n        float shadow = softShadow(lightp, p + 0.01 * n, 0.02, 2.);\n        vec3 lightfinal2 = pow(lightColor2, vec3(1.2)) * max(dot(n, lights[1].xyz), 0.0);\n        float shadow2 = softShadow(lightp2, p + 0.01 * n, 0.02, 2.);\n        vec3 lightfinal3 = pow(pale, vec3(1.2)) * max(dot(n, lights[2].xyz), 0.0);\n        float shadow3 =  0.05 + softShadow(lightp3, p + 0.01 * n, 0.2, 2.);\n        \n        vec3 diff_light = 0.7 * lightfinal * shadow\n            \t\t\t+ 0.25 * lightfinal2 * shadow2\n            \t\t\t+ 0.05 * lightfinal3 * shadow3;\n        \n        vec3 lcol = ao * diff_light;\n    \tcol = mix(lcol, afterfog, 0.3);\n        //col = vec3(afterfog);\n    } else if(t > 0.0 && id != 2.0){//frog\n        vec3 ao = vec3(1.);\n        vec3 basecolor = vec3(1.);\n        switch(int(id)) {\n            case 3:{\n                ao = vec3(computeAO(p, n, 1.0));\n                vec3 lightfinal = pow(lightColor1, vec3(2.2)) * max(dot(n, sunpos), 0.0);\n        \t\tfloat shadow = softShadow(lightp, p + 0.01 * n, 0.02, 2.);\n        \t\tvec3 lightfinal2 = pow(lightColor2, vec3(1.2)) * max(dot(n, lights[1].xyz), 0.0);\n        \t\tfloat shadow2 = softShadow(lightp2, p + 0.01 * n, 0.02, 2.);\n        \t\tvec3 lightfinal3 = pow(pale, vec3(1.2)) * max(dot(n, lights[2].xyz), 0.0);\n        \t\tfloat shadow3 =  0.05 + softShadow(lightp3, p + 0.01 * n, 0.2, 2.);        \n        \t\tbasecolor = vec3(0.5, 0.6, 0.6) * ao * (0.7 * lightfinal * shadow\n            \t\t\t\t\t+ 0.28 * lightfinal2 * shadow2\n            \t\t\t\t\t+ 0.02 * lightfinal3 * shadow3);\n                break;\n            }\n            case 4:{//eye\n                basecolor = vec3(.7, .8, .7);\n                break;\n            }\n            case 8:{\n\t\t\t\tbasecolor = vec3(0.0, 0.0, 0.0);\n                break;\n            }            \n        }\n                \n        vec3 lcol = basecolor;\n        col = lcol;\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    vec2 d = vec2(0.); \n    float t = 0.0;\n    for (int i = 0; i < MAX_STEP; i++) {\n        d = map(ro + t * rd);\n        //id = \n        if (d.x < EPS * t || t > FAR){\n            break;\n        }\n        t +=  d.x;\n    }  \n    return d.x < EPS * t ? vec2(t, d.y) : vec2(-1., d.y);\n}\n\n//from tool box\nfloat parabola(float x, float k) {\n    return pow( 4.0 * x * (1.0 - x), k );\n}\nvec3 raycas(vec2 p, vec3 u_Ref, vec3 u_Eye, vec3 u_Up) {\n vec3 forward = u_Ref - u_Eye;\n float ratio =  iResolution.x / iResolution.y;\n vec3 Right = normalize(cross(forward, u_Up)) * ratio;\n vec3 up = normalize(cross(Right, forward));\n float len = length(forward);\n vec3 dir = normalize(forward + len * p.x * Right + len * p.y * up);\n return dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //camera pos\n    float xpos = parabola(-0.02 * iGT, 2.0);\n    vec3 ct = vec3(0.0, 0.1, -2.0);//target\n\tvec3 cp = vec3(xpos, 0.1 , 5.0);//position\n\tvec3 up = vec3(0.0, 1.0, 0.0);//forward\t\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\t\n\tvec3 ro = cp;\n    vec3 rd = raycas(uv, ct, cp, up);//ray cast a ray\t\t\t      \n \tvec2 t = raymarch(ro, rd);//ray march\n    vec3 col = pow(shade(ro, rd, t.x, t.y), vec3(1.0/2.2));\n    col = smoothstep(0.0, 1.0, col * 1.2);\n    \n    //Vignette/////////////////////////////\n    float point = length(fragCoord.xy + vec2(0.5, 0.5) - vec2(iResolution.xy) / 2.0);\n    float distance = 1.0 - point / length(vec2(iResolution.xy) / 2.0 - vec2(0.5,0.5));//circle the 0.5 0.5\n    col *= pow(distance, 0.4);\n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}