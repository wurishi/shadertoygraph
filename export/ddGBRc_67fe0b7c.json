{"ver":"0.1","info":{"id":"ddGBRc","date":"1698439788","viewed":136,"name":"Chocolate Triangles and Squares","username":"sylvain69780","description":"Chocolate Triangles and Squares\nUse your mouse to change the color palette","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["palette","square","tiling","snub","cairo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \nSimple Semi-regular 3,3,4,3,4 Extrusion \n\nYou can play with the mouse to change the colors or changing the code\n\nReferences\n\n    Shane - Semi-regular 3,3,4,3,4 Extrusion \n    https://www.shadertoy.com/view/DllSWB\n    \n    Nimitz - Cairo tiling \n    https://www.shadertoy.com/view/4ssSWf\n    \n    Live Coding: Cairo Tiling Explained! - The Art of Code\n    https://youtu.be/51LwM2R_e_o?si=WK5B6F_dvMVV-2l-\n    \n    Wythoff Uniform Tilings + Duals - Fizzer \n    https://www.shadertoy.com/view/3tyXWw\n    \n    Parallelogram Grid - Shane (unlisted)\n    https://www.shadertoy.com/view/dlBSRG\n    \n    IQ Distance functions\n    https://iquilezles.org/articles/distfunctions\n    https://iquilezles.org/articles/distfunctions2d\n    \n    iResolution, iMouse, iDate, etc - Fabrice Neyret\n    https://www.shadertoy.com/view/llySRh\n    \n    Palettes - IQ\n    https://www.shadertoy.com/view/ll2GD3\n    \n    Snub square tiling - Wikipedia\n    https://en.wikipedia.org/wiki/Snub_square_tiling\n\n*/\n\nconst float squareOneId = 5.7;\nconst float squareTwoId = 6.;\nconst float triangleOneId =4.2;\nconst float triangleTwoId = 5.5;\nconst float triangleThreeId = 5.8;\nconst float triangleFourId = 4.9;\n\nfloat hash( vec2 f )\n{   uvec2 x = floatBitsToUint(f),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nconst float maxHeight = .35;\n\nfloat getHeight(vec2 cell)\n{\n    return hash(cell)*maxHeight*.8;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, p.y - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdColumn(vec3 p, vec4 cell, float sdf, float h)\n{\n    const float rounding = 0.02;\n    float d = opExtrussion(p,sdf,h-sdf*.2); // nice rooftop trick\n    return d-rounding;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nconst float PI=3.141592;\nconst float shapeSize = .25/cos(PI/12.);\nconst float margin = .03;\n\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec4 getCell(vec2 p)\n{\n    vec2 id = floor(p);\n    p -= id + .5;\n    return vec4(p,id);\n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 rotatedCell(vec4 cell,float an)\n{\n    cell.xy *= rot(an);\n    return cell;\n}\n\nvec2 sdSquaresWithHoles(vec3 p)\n{\n    const vec2 off = vec2(-.25,-.25);\n    vec4 cell = rotatedCell(getCell(p.xz - off),PI/12.);\n    float sdf = sdBox(cell.xy, vec2(shapeSize-margin));\n    sdf = max(sdf,-sdBox(abs(cell.xy)-margin*3., vec2(margin*2.)));    \n    float d = sdColumn(p,cell,sdf,getHeight(cell.zw + off));\n    return vec2(d,squareOneId);\n}\n\nvec2 sdSolidSquares(vec3 p)\n{\n    const vec2 off = vec2(.25,.25);\n    vec4 cell = rotatedCell(getCell(p.xz - off),-PI/12.);\n    float sdf = sdBox(cell.xy, vec2(shapeSize-margin));\n    float d = sdColumn(p,cell,sdf,getHeight(cell.zw + off));\n    return vec2(d,squareTwoId);\n}\n\nvec2 sdFirstTwoTriangles(vec3 p)\n{\n    vec2 off = vec2(.25,-.25);\n    float size = shapeSize-margin*2.;\n    vec4 cell = getCell(p.xz - off);\n    cell.xy = (cell.xy + vec2(-cell.y, cell.x))*sqrt(0.5);\n    return opU(\n        vec2(sdColumn(p,cell,sdEquilateralTriangle(vec2(cell.x, cell.y - margin), size),getHeight(cell.zw+off+.1)),triangleOneId),\n        vec2(sdColumn(p,cell,sdEquilateralTriangle(vec2(cell.x,-cell.y - margin), size),getHeight(cell.zw+off-.1)),triangleTwoId));\n}\n\nvec2 sdSecondTwoTriangles(vec3 p)\n{\n    vec2 off = vec2(-.25,.25);\n    float size = shapeSize-margin*2.;\n    vec4 cell = getCell(p.xz - off);\n    cell.xy = (cell.xy + vec2(cell.y, -cell.x))*sqrt(0.5);\n    return opU(\n        vec2(sdColumn(p,cell,sdEquilateralTriangle(vec2(cell.x, cell.y - margin), size),getHeight(cell.zw+off+.1)),triangleThreeId),\n        vec2(sdColumn(p,cell,sdEquilateralTriangle(vec2(cell.x,-cell.y - margin), size),getHeight(cell.zw+off-.1)),triangleFourId));\n}\n\nvec2 getDist2(vec3 p) {\n    vec2 dm = vec2(1e10,0.);\n    dm = opU(dm,sdSquaresWithHoles(p));\n    dm = opU(dm,sdSolidSquares(p));\n    dm = opU(dm,sdFirstTwoTriangles(p));\n    dm = opU(dm,sdSecondTwoTriangles(p));\n    return dm;\n}\n\nfloat getDist(vec3 p)\n{\n    return getDist2(p).x;\n}\n\nconst float maxDistance=10.;\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    const float surfaceDist=.001;\n\tfloat dO=(maxHeight-ro.y)/rd.y;\n    for(int i=0; i<100; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>maxDistance || abs(dS)<surfaceDist) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p) - \n        vec3(getDist(p-e.xyy), getDist(p-e.yxy),getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = getDist(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec2 path(float z)\n{\n    return vec2(sin(z*.8)*.35,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.5;\n    vec3 ta = vec3(0, 0, t);\n    vec3 ro = ta+vec3(0,1.0,-1.5);\n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n    uv *= rot(sin(t)*.05);\n    vec3 rd = getRayDir(uv, ro, ta, 1.);\n    vec3 lp = ro+vec3(0,0,1.0);\n    vec3 col = vec3(0);\n    float d = rayMarch(ro, rd);\n    if(d<maxDistance) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 ld = normalize(lp-p);\n        float m = getDist2(p).y;\n        vec3 c = vec3(.5);\n        if ( m > 0.0 ) {\n            vec2 mse = vec2(.3,1.);\n            if ( iMouse.x > 0.0 )\n                mse = iMouse.xy/iResolution.xy;\n            c = .5+.48*cos(6.2832*mse.x+vec3(0,1,2)*mse.y+m); // Palette https://www.shadertoy.com/view/Dddfz7\n        }\n        float dif = dot(n, ld)*.8+.2;\n        float spe = pow(clamp(dot(n,normalize(ld-rd)),0.0,1.0),8.0) * dif; // Blinn \n        float occ = calcOcclusion(p,n);\n        col = dif*c*occ;\n        col += spe;\n    }\n    col = mix(vec3(0),col,exp(-d*.5)); // fog\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}