{"ver":"0.1","info":{"id":"lt2Bz1","date":"1514726784","viewed":96,"name":"Pattern04","username":"edapx","description":"patterns, flower","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["patterns","flower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\t// http://thebookofshaders.com/09/\n    // Here is where the offset is happening\n    float pari = step(1., mod(_st.y,2.0));\n    _st.x += pari * 0.5;\n\t\n\tfloat frequency = 0.4;\n    //_st.x += fract(iTime * frequency) * pari;\n    _st.x += iTime * frequency * ( pari - step(pari, .1) );\n\n    return fract(_st);\n}\n\nvec3 elica(vec2 st, vec2 orig, float resize, float smoothness, float nPale){\n    // https://thebookofshaders.com/07/\n    // Use polar coordinates instead of cartesian\n    // This technique is a little restrictive but very simple.\n    // It consists of changing the radius of a circle depending \n    // on the angle to achieve different shapes.\n    vec2 toCenter = vec2(orig)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*resize;\n\n    float f = cos(angle*nPale);\n    return vec3( 1.-smoothstep(f,f+smoothness,radius) );;\n}\n\n\nvec3 when_eq(vec3 x, vec3 y) {\n  return 1.0 - abs(sign(x - y));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord/iResolution.y;\n    vec3 color = vec3(1.0);\n    \n    vec3 orange = vec3(0.9, 0.5, 0.0);\n    vec3 azul = vec3(0.2, 0.6, 0.7);\n    vec3 yellow = vec3(0.8, 0.7, 0.0);\n    \n    // Apply the brick tiling\n    st = brickTile(st,6.0);\n   \n    orange *= elica(st, vec2(0.44), 4.6, 1.2, 3.0);\n    azul *= elica(st, vec2(0.47), 4.8, 1.9, 6.0);\n    yellow *= elica(st, vec2(0.5), 4.6, 1.2, 9.0);\n    \n    color = orange +azul + yellow;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}