{"ver":"0.1","info":{"id":"MdGXRz","date":"1462428549","viewed":293,"name":"Cube Fx","username":"gigatron","description":"3D rotation cube.. performed first by mr IQ ;","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","demo","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Analytical ambient occlusion of a box. Left side of screen, stochastically \n// sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n//\n// If the box was intersecting the ground plane, we'd need to perform clipping\n// and use the resulting triangles for the analytic formula instead.\n// Thank you MR IQ;    \n\n//=====================================================\n\n// returns t and normal\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n*/\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 2.*sin(iTime) );\n\tmat4 tra = translate( -1.5*  sin(iTime*2.) , -.5+abs(sin(iTime*4.) ), 0.5*sin(iTime) );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(1.,1.,1.) ;\n\n   \n    vec3 col = vec3(0.0);\n\n \n    \n \n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n          res += boxIntersect(  ro,  rd, txx, txi, box+vec3(0.2,0.2,0.2));\n   \n    float t2 = res.x;\n  \n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw ;\n\t\tcol = vec3(0.4,0.4,0.9);\n \n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\tcol *= abs(onor.x)*texture( iChannel0, 0.5+0.5*opos.yz ).xyz + \n               abs(onor.y)*texture( iChannel0, 0.5+0.5*opos.zx ).xyz + \n               abs(onor.z)*texture( iChannel0, 0.5+0.5*opos.xy ).xyz;\n       // col *= 1.7;\n        col *= 0.9 + 0.4*nor.x;\n        \n        \n \n\n\t//col *= exp( -0.05  );\n\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}