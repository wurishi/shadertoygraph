{"ver":"0.1","info":{"id":"X3SczK","date":"1728759429","viewed":33,"name":"raytrace one step further","username":"HyperQuantum","description":"raytracing polygon 2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","barycentric","quaternion","polygon","molle","trumborer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct polyface{\n    vec3 pos1;\n    vec3 pos2;\n    vec3 pos3;\n};\n\n\nstruct testpack{\n    float t;\n    bool flag;\n    vec3 arrive;\n    int index;\n};\n\n\nvec3 CalHeightVec(vec3 P1, vec3 P2, vec3 S){\n    vec3 V =  normalize(P2-P1);\n    vec3 H =  P1-S;\n    float t = -(H.x*V.x + H.y*V.y + H.z*V.z)/(V.x*V.x + V.y*V.y + V.z*V.z);\n    return P1+V*t;\n}\n\n\npolyface tricolors[12] = polyface[12](\n    polyface(vec3(215., 124., 105.),vec3(244., 255.,  11.),vec3(103.,  95.,  71.)),\n    polyface(vec3(215., 124., 105.),vec3(103.,  95.,  71.),vec3( 72.,  37., 134.)),\n    polyface(vec3( 90.,  19.,  62.),vec3( 72.,  37., 134.),vec3(103.,  95.,  71.)),\n    polyface(vec3( 90.,  19.,  62.),vec3(103.,  95.,  71.),vec3(184., 224., 209.)),\n    polyface(vec3( 57., 255., 217.),vec3( 70., 213., 114.),vec3( 90.,  19.,  62.)),\n    polyface(vec3( 70., 213., 114.),vec3(184., 224., 209.),vec3( 90.,  19.,  62.)),\n    polyface(vec3(256., 0., 0.),vec3(0., 256.,  0.),vec3( 0., 0., 256.)),\n    polyface(vec3(256., 0., 0.),vec3( 0., 0., 256.),vec3( 0., 256., 0.)),\n    polyface(vec3(215., 124., 105.),vec3( 57., 255., 217.),vec3( 90.,  19.,  62.)),\n    polyface(vec3(215., 124., 105.),vec3( 90.,  19.,  62.),vec3( 72.,  37., 134.)),\n    polyface(vec3(103.,  95.,  71.),vec3(244., 255.,  11.),vec3( 70., 213., 114.)),\n    polyface(vec3(103.,  95.,  71.),vec3( 70., 213., 114.),vec3(184., 224., 209.))\n);\n\n\npolyface triangles[12] = polyface[12](\n    polyface(vec3(.2, .2, .2),vec3(.2, -.2, .2),vec3(-.2, -.2, .2)),\n    polyface(vec3(.2, .2, .2),vec3(-.2, -.2, .2),vec3(-.2, .2, .2)),\n    polyface(vec3(-.2, .2, -.2),vec3(-.2, .2, .2),vec3(-.2, -.2, .2)),\n    polyface(vec3(-.2, .2, -.2),vec3(-.2, -.2, .2),vec3(-.2, -.2, -.2)),\n    polyface(vec3(.2, .2, -.2),vec3(.2, -.2, -.2),vec3(-.2, .2, -.2)),\n    polyface(vec3(.2, -.2, -.2),vec3(-.2, -.2, -.2),vec3(-.2, .2, -.2)),\n    polyface(vec3(.2, .2, .2),vec3(.2, -.2, .2),vec3(.2, -.2, -.2)),\n    polyface(vec3(.2, .2, .2),vec3(.2, -.2, -.2),vec3(.2, .2, -.2)),\n    polyface(vec3(.2, .2, .2),vec3(.2, .2, -.2),vec3(-.2, .2, -.2)),\n    polyface(vec3(.2, .2, .2),vec3(-.2, .2, -.2),vec3(-.2, .2, .2)),\n    polyface(vec3(-.2, -.2, .2),vec3(.2, -.2, .2),vec3(.2, -.2, -.2)),\n    polyface(vec3(-.2, -.2, .2),vec3(.2, -.2, -.2),vec3(-.2, -.2, -.2))\n);\n\n\n\nvec3 calRaydirec(vec3 rayorigin, vec2 uv, bool ortho){\n    vec3 orthogonal = vec3(uv-rayorigin.xy, -rayorigin.z);\n    if(!ortho)\n        return normalize(orthogonal);\n    else\n        return orthogonal;\n}\n\nvec4 quatmul(vec4 P, vec4 Q){\n    vec3 vQ = Q.xyz;\n    float rQ = Q.w;\n    vec3 vP = P.xyz;\n    float rP = P.w;\n    \n    float W = rQ*rP-dot(vQ,vP);\n    vec3 V = rQ * vP + rP * vQ + cross(vQ,vP);\n    \n    return vec4(V,W);\n\n}\n\n\ntestpack testCollision(vec3 ro, vec3 rd, vec4 Q){\n    //the basic idea is to test being in triangle for every triangle\n    //https://zhuanlan.zhihu.com/p/106253152\n    float lastc = 50000.0f;\n    vec3 outp;\n    int index = -1;\n    //firstly we have to know where ray reaches ; where the intersecting point is located\n    //see moller trumbore intersection\n    for(int i=0;i<12;i++){\n        //Given raydirection & rayorigin , we have to calculate where this ray may intersect with plane\n        //Plane is defined by triangle . For an arbitary point on that plane , P = a(P3-P1) + b(P2-P1) + P1\n        //P is also on ray, so we have P = RO + i*RD\n        //RO - P1 = a(P3-P1) + b(P2-P1) - i*RD\n        vec3 P1 = triangles[i].pos1;\n        vec3 P2 = triangles[i].pos2;\n        vec3 P3 = triangles[i].pos3;\n        \n        P1 = quatmul(vec4(-Q.xyz,Q.w),quatmul(vec4(P1,0),Q)).xyz;\n        P2 = quatmul(vec4(-Q.xyz,Q.w),quatmul(vec4(P2,0),Q)).xyz;\n        P3 = quatmul(vec4(-Q.xyz,Q.w),quatmul(vec4(P3,0),Q)).xyz;\n\n        vec3 e1 = P3-P1;\n        vec3 e2 = P2-P1;\n        vec3 res = ro-P1;\n        float det = dot(e1,cross(e2,rd));\n        float deta = dot(res,cross(e2,rd));\n        float detb = dot(e1,cross(res,rd));\n        float deti = dot(e1,cross(e2,res));\n        float a = deta/det;\n        float b = detb/det;\n        float c = -deti/det;\n        vec3 reached = ro + c*rd;\n        //The interesting thing is , the algorithm we're going to use to test being in triangle , matches our definitions of \n        //P = a(P3-P1) + b(P2-P1) + P1\n        //That is , a∈[0,1] , b∈[0,1] , a+b∈[0,1]\n        if(a>=0. && a<=1. && b>=0. && b<=1. && a+b<=1.){\n            if(c<=lastc){\n                lastc = c;\n                outp = reached;\n                index = i;\n            }\n        }\n    }\n    \n    //redo rotation to make outp perspective-indepedent \n    Q = vec4(-Q.xyz,Q.w);\n    outp = quatmul(vec4(-Q.xyz,Q.w),quatmul(vec4(outp,0),Q)).xyz;\n    \n    if(lastc == 50000.0f){\n        return testpack(0.0,false,vec3(0),index);\n    }\n    else{\n        return testpack(lastc,true,outp,index);\n    }\n}\n\n//how to trace polygon?\n\n\n//求t比.xyz有个问题：0乘以任何数都是0，不存在t能够使t*dir=a（dir.x==0;a.x!=0）\nbool tsimilar(vec3 a, vec3 dir){\n    float COS = dot(normalize(a), normalize(dir));\n    float SIN = sqrt(1.0-COS*COS);\n    float dist = SIN * length(a);\n    if(dist<0.001)return true;\n    return false;\n}\n\nvec3 getbarycentric(testpack pack){\n    \n    int i = pack.index;\n    vec3 a = pack.arrive;\n\n    vec3 P1 = triangles[i].pos1;\n    vec3 P2 = triangles[i].pos2;\n    vec3 P3 = triangles[i].pos3;\n    \n    float E = 0.01;\n    float plerp = 0.;\n    if(length(P1-a)<E||length(P2-a)<E||length(P3-a)<E){\n        plerp = 1.;\n    }\n    \n    \n\n    //_______________________________________-\n    //height and perpendicular foot\n    vec3 foot3 = CalHeightVec(P2,P1,P3);\n    vec3 foot2 = CalHeightVec(P1,P3,P2);\n    vec3 foot1 = CalHeightVec(P3,P2,P1);\n    \n    float hlerp = 0.;\n    if(length(foot3-a)<E||length(foot2-a)<E||length(foot1-a)<E){\n        hlerp = 1.;\n    }\n    \n    vec3 heightvec3 = foot3 - P3;\n    vec3 heightvec2 = foot2 - P2;\n    vec3 heightvec1 = foot1 - P1;\n    \n    vec3 a1 = P1 - a;\n    vec3 a2 = P2 - a;\n    vec3 a3 = P3 - a;\n    \n    float hvlerp = 0.0;\n    //点在线上：cos=1，t.x=t.y=t.z，S=0\n    if(tsimilar(a1,heightvec1)||tsimilar(a2,heightvec2)||tsimilar(a3,heightvec3))\n    {\n        //输出了垂直边\n        hvlerp = 1.0;\n    }\n    \n    float project1 = -dot(normalize(heightvec1), a1);\n    float project2 = -dot(normalize(heightvec2), a2);\n    float project3 = -dot(normalize(heightvec3), a3);\n    \n    float weight1 = 1.0 - project1/length(heightvec1);\n    float weight2 = 1.0 - project2/length(heightvec2);\n    float weight3 = 1.0 - project3/length(heightvec3);\n    //准备好了用于插值的垂直边\n    \n    \n    //改变插值。默认weight插出来的是重心坐标\n    //weight1 = \n    \n    \n    \n    vec3 P12 = P2-P1;\n    vec3 P13 = P3-P1;\n    //面积坐标\n    float Sa12 = length(cross(a1,a2));\n    float Sa13 = length(cross(a1,a3));\n    float Sa23 = length(cross(a2,a3));\n    float Ssum = length(cross(P12,P13));\n    \n    E = 0.001;\n    float llerp = 0.;\n    if(Sa12<E||Sa23<E||Sa13<E){\n        llerp=1.0;\n    }\n    \n    float c3 = Sa12/Ssum;\n    float c2 = Sa13/Ssum;\n    float c1 = Sa23/Ssum;\n\n\n    vec3 U1 = tricolors[i].pos1/256.;\n    vec3 U2 = tricolors[i].pos2/256.;\n    vec3 U3 = tricolors[i].pos3/256.;\n\n    vec3 barypos = c1*U1 + c2*U2 + c3*U3;\n    //vec3 barypos = (c1*P1 + c2*P2 + c3*P3)*3.;\n    \n    //将col右边的barypos替换为perpendi，你可以使用该多此一举的插值方式\n    //vec3 perpendi = (weight1*P1 + weight2*P2 + weight3*P3)*3.;\n    vec3 perpendi = weight1*U1 + weight2*U2 + weight3*U3;\n\n    vec3 col;\n    col=mix(perpendi,vec3(0.78),llerp);\n    col=mix(col,vec3(1),plerp);\n    col=mix(col,vec3(1,0,0),hlerp);\n    col=mix(col,vec3(1,0,0),hvlerp);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy)*2.0)-1.0; //-1~1\n    vec2 curor = iMouse.xy/iResolution.xy;\n    vec3 rayorigin = vec3(0,curor.y,mix(0.32f, 1.0f, curor.y));\n    vec3 raydirection = calRaydirec(rayorigin, uv,false);\n    \n    //四元数\n    float angle = curor.x*3.1415926535f*2.f;\n    float ca = cos(angle/2.f);\n    float sa = sin(angle/2.f);\n    vec3 axis = normalize(vec3(0,1,0));\n    vec4 Q = vec4(axis*sa,ca);\n    \n    testpack package = testCollision(rayorigin,raydirection,Q);\n    \n    vec3 color;\n    color = getbarycentric(package);\n    \n    color = floor(color*4.)/4.;\n    \n    fragColor = vec4(color,1.0f);\n}","name":"Image","description":"","type":"image"}]}