{"ver":"0.1","info":{"id":"mdB3Wt","date":"1668326365","viewed":73,"name":"[steve] camera + morph shape","username":"import_shader_steve","description":"Combining The Art of Code's camera module, ray marching & primitives tutorial.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pSphere = vec3(0., 1., 6.);\n    float dSphere = sdSphere(p - pSphere, 1.);\n    float dBox = sdBox(p - pSphere, vec3(1.));\n    float dMorph = mix(dSphere, dBox, sin(iTime)/2.+0.5);\n    vec3 pGround = vec3(0., 0., 3.);\n    float dGround = sdGround(p - pGround);\n    \n    //float dScene = dSphere;\n    float dScene = min(dMorph, dGround);\n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(0, 5, 6);\n\nfloat GetLight(vec3 p) {\n    lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURF_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nfloat GetShadow(vec3 p) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd);\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, vec2 uv) {\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + zoomFactor * fVect);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float col = 0.;\n    \n    vec3 ro = vec3(0., 1.5, -3.);\n    vec3 lookAt = vec3(0., 1.5, 0.);\n    lookAt.x = sin(sin(iTime)*PI/6.);\n    // lookAt.y = sin((sin(iTime)/2.+0.5)*(PI*2.));\n    float zoomFactor = 1.5;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv);\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    float l = GetLight(p) * GetShadow(p);\n    col += l;\n    \n    \n    fragColor = vec4(vec3(col) ,1.0);\n}","name":"Image","description":"","type":"image"}]}