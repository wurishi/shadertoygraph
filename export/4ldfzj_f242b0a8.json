{"ver":"0.1","info":{"id":"4ldfzj","date":"1540684878","viewed":366,"name":"Terminator Bee","username":"saidwho12","description":"test","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["sdf","blur","hexagon","bee","gaussian","terminator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    \n    if (enabledPixelize)\n    {\n        vec2 R = iResolution.xy/float(pixelWidth);\n        vec2 f = fragCoord/float(pixelWidth);\n        \n        ivec2 u = ivec2(floor(f)*float(pixelWidth));\n        vec3 c = vec3(0);\n        \n        for(int x = 0; x < pixelWidth; x++) {\n            for(int y = 0; y < pixelWidth; y++) {\n        \t\tc += texelFetch(iChannel0, ivec2(u) + ivec2(x,y), 0).rgb;\n            }\n        }\n        float ww = float(pixelWidth * pixelWidth);\n        c /= ww;\n        c *= 2.1;\n        \n        vec2 uv = fract(f);\n        vec2 p = 2.*uv-1.;\n        \n   \t\t//const float x = 1./3.;\n        \n        uv.x *= 3.;\n       \tint i = int(floor(uv.x));\n        uv.x = fract(uv.x);\n        \n        uv = uv*2.-1.;\n        float t = max(udBox(uv, vec2(0.9)), udBox(p,vec2(.99)));\n        \n        \n        //col.rg = uv;\n        switch(i) {\n        \tcase 0:\n            col.r = c.r;\n            break;\n            case 1:\n            col.g = c.g;\n            break;\n            case 2:\n            col.b = c.b;\n        }\n        \n    \tfragColor.rgb = sqrt(col);\n    } else {\n        fragColor.rgb = sqrt(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Math constants\nconst float PI = 3.14159;\nconst float PI_2 = 2.0*PI;\n\n// Program constants\nconst bool enabledBabies = true;\nconst bool enabledClouds = true;\nconst bool enabledBlur = true;\n\nconst bool varyColor = true;\n\nconst bool enabledMotionBlur = true;\nconst int blurFrames = 10;\nconst int blurFramerate = 60;\n\nconst bool enabledAntialiasing = true; // Supersampling style antialiasing\nconst float antialiasWidth = 0.01;\n\nconst bool enabledStripes = true;\n\nconst bool enabledPixelize = true;\nconst bool enabledLasers = true;\n\nconst bool enabledMirror = false;\n\n// Scale of a pixel for antialiasing\nconst float pixelScale = 2.;\nconst float stdDev = 15.;\n\nconst int pixelWidth = 3;\n\n#define saturate(x) clamp(x,0.,1.)\n#define range_01(x) (x*.5+.5)\n#define range_n1p1(x) (x*2.-1.)\n\n#define PI 3.14159\n#define PI_2 (2.0*PI)\n\n\nvec2 lissajous( float n, float theta, float phi )\n{\n\treturn vec2(sin(theta), sin(n*theta + phi));\n}\n\nmat2 rotate(in float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCircle(vec2 p, float r) { return length(p)-r; }\nfloat udBox(vec2 p, vec2 b) { return length(max(abs(p)-b,0.0)); }\n\nfloat udLine( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = -p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x, d.y),0.0); \n}\n\nfloat sdRoundBox(vec2 p, vec2 b, float r)\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,d.y),0.0);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))\n                               : length(p-vec2(-d,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// There'd be situations where you'd prefer the hexagons to be oriented to a flat\n// top postion, which means making some simple changes.\n//#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    // Below is equivalent to:\n    //return max(p.x*.866025 + p.y*.5, p.y); \n\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    #ifdef FLAT_TOP_HEXAGON\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(1, .5));\n    #else\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    #endif\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//###############################################################################\n\n//----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33w(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.1030f, 0.0973f));\n    p3 += dot(p3, p3.yxz+19.19f);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 hash33s(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.11369f, 0.13787f));\n    p3 += dot(p3, p3.yxz + 19.19f);\n    return -1.0f + 2.0f * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 fade2( vec2 p )\n{\n    return 6.0*pow(p,vec2(5.0)) - 15.0*pow(p,vec2(4.0)) + 10.0*pow(p,vec2(3.0));\n}\n\nvec2 vrand2( vec2 x )\n{\n    float a = hash12(x) * PI_2;\n    return vec2(sin(a), cos(a));\n}\n\nfloat perlin2( vec2 p )\n{\n    vec2 a = floor(p), b = ceil(p);\n    vec2 s = fade2(p-a);\n\n    vec2 v1 = vrand2(a);\n    vec2 v2 = vrand2(vec2(b.x, a.y));\n    vec2 v3 = vrand2(vec2(a.x, b.y));\n    vec2 v4 = vrand2(b);\n\n    vec2 d1 = normalize(v1-p);\n    vec2 d2 = normalize(v2-p);\n    vec2 d3 = normalize(v3-p);\n    vec2 d4 = normalize(v4-p);\n\n    return mix(mix(dot(d1, v1), dot(d2, v2), s.x),\n               mix(dot(d3, v3), dot(d4, v4), s.x), s.y);\n}\n\nfloat simplex(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33s(i)), dot(d1, hash33s(i + i1)), dot(d2, hash33s(i + i2)), dot(d3, hash33s(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nfloat simplexFbm(vec3 pos, float octaves, float persistence, float scale)\n{\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n\n    for(float i = 0.0; i < octaves; ++i)\n    {\n        final        += simplex(pos * scale) * amplitude;\n        scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= persistence;\n    }\n\n    return (min(final, 1.0f) + 1.0f) * 0.5f;\n}\n\nvec2 map(in vec2 p) {\n    vec4 h = getHex(p.xy);\n\n    float eDist = hex(h.xy);\n    float cDist = dot(h.xy, h.xy);\n\n    return vec2(eDist, cDist);\n}\n\n\nvec3 hive(in vec2 fragCoord) {\n    // Centered normalized pixel coordinated (from -1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 offset = vec2(0, iTime * 0.9);\n    float scale = 5.2;\n    float alpha = radians(4.0) * sin(iTime * 0.22 * PI_2);\n\n    p = rotate(alpha) * p;\n\n    p += offset;\n    p *= scale;\n    vec2 m = map(p);\n\n    vec3 col = vec3(0);\n\n    bool hex = false;\n    vec4 h = getHex(p);\n\n    hex = perlin2(h.zw*0.8)*0.5+0.5 < 0.75;\n\n    vec3 honeyAlbedo = vec3(0.72, 0.73, 0.5);\n    if (varyColor) honeyAlbedo *= .9 + .1 * vec3(hash21(h.zw),.75,.75);\n\n    vec3 honeyShadow = .05 * honeyAlbedo;\n    vec3 honeySpecular = 1.5 * honeyAlbedo;\n\n    vec3 beeswaxAlbedo = vec3(0.75, .65, .4);\n    vec3 beeswaxAlbedo0 = vec3(0.45, .4, .25);\n    //beeswaxAlbedo = vec3(0.025);\n\n    if (enabledStripes)\n    {\n        float x0 = p.x + p.y;\n        float x1 = p.x - p.y;\n        x1 -= .5*sin(0.25*x1*PI_2);\n        float a0 = abs(range_n1p1(fract(2.7*x0 - .15*sin(0.25*x1*PI_2) ))) + .7*(perlin2(.5*p)*.5 + .5) + 0.1;\n        beeswaxAlbedo = mix(beeswaxAlbedo, beeswaxAlbedo0, pow(saturate(a0),5.) );\n    }\n\n    //m.x = 1.0-mix(m.x, 2.7*m.y, 0.5)*2.0 - 0.15; // Wall of wax at edge of cell distance\n    m.x = 1.0-mix(m.x, 1.7*m.y, 0.3) * 2.0 - 0.3 - 0.2 * hash21(h.wz); // Wall of wax at edge of cell distance\n\n    vec3 albedo;\n\n    if (enabledClouds)\n    {\n        float a = hex ? 0.0 : saturate(m.x*100.);\n\n        float x0 = p.x + p.y;\n        //float a0 = range_01(cos(range_n1p1(fract(.05*-x0-.2*iTime))*PI_2));\n        //a0 = pow(a0, mix(2.,4.,a));\n        float a0 = simplexFbm(vec3(p + .32*iTime, 0.4*iTime), 4., 0.5, 0.4);\n        a0 = pow(range_01(a0),1.7);\n\n        //honeyAlbedo = mix(honeyAlbedo, honeyShadow, (1.0-a0)*saturate(pow(1.0-map(p+.05).y,7.)) );\n        honeyAlbedo = mix(honeyAlbedo, honeySpecular, a0 * max(pow(1.-map(p-.15).y*2., 200.),0.) );\n\n        albedo = mix(beeswaxAlbedo, honeyAlbedo, a);\n        albedo = saturate(mix(albedo*.3, albedo * vec3(1.13, 1.07, 1.04), a0));\n    }\n\n    col += albedo;\n\n    float w = antialiasWidth * scale;\n    float ao = saturate(exp(-9.0 * mix(mix(m.x, 1.0, hex), 1.0,\n                                       smoothstep(w, -w, m.x))) );\n    col -= 0.75*ao;\n\n    return col;\n}\n\nvec3 shade(in vec2 fragCoord) {\n    vec3 col = vec3(0);\n\n    if (enabledAntialiasing)\n    {\n        for(float i = 0.0; i < pixelScale; i++) {\n            for(float j = 0.0; j < pixelScale; j++) {\n                vec2 offset = vec2(i,j) + 0.5;\n\n                col += hive(fragCoord + offset/pixelScale);\n            }\n        }\n        float pixelScale2 = pixelScale*pixelScale;\n        col = saturate(col / pixelScale2);\n    }\n    else\n    {\n        col = hive(fragCoord);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor.rgb = shade(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float sdBeeBody(in vec2 p, in float r, in float k) {\n    return smin(sdVesica(p + vec2(0, r), r, r*0.6),\n                sdCircle(p, r), k);\n}\n\nfloat sdBeeWing( vec2 p, float r1, float r2, float d )\n{\n    float d_2 = d * 0.5;\n    float h = max(r1+r2-d, 0.0);\n\n    float h_2 = h * 0.5;\n    float b1 = r1 - h_2;\n    float b2 = r2 - h_2;\n    float w1_2 = sqrt(r1*r1 - b1*b1);\n    float w2_2 = sqrt(r2*r2 - b2*b2);\n\n    float w_2 = min(w1_2, w2_2);\n\n    p.x -= w_2;\n\n    return max(sdCircle(p+vec2(0,d_2), r1), sdCircle(p-vec2(0,d_2), r2));\n}\n\nfloat sdBeeCrown( vec2 p, float r, float n )\n{\n    float d = sdCircle(p, r);\n    float x = atan(p.x, p.y) / PI;\n    d += 0.3 * r * abs(sin(n * x * PI));\n\n    d = max(d, -sdCircle(p + vec2(0, r*0.85), r*0.85));\n    return d;\n}\n\n\n// vec4(rgb: color, a: distance)\nvec4 bee(in vec2 p) {\n\n    vec3 dark =  vec3(0.06);\n    vec3 light = vec3(0.65, 0.48, 0.15);\n\n    // Middle body\n    float r1 = .14;\n    float d1 = sdCircle(p, r1);\n    vec3 c1 = mix(dark, light, .37);\n\n    // Abdomen\n    float r2 = .2;\n    vec2 p2 = rotate(sin(iTime * PI_2) * radians(18.0)) * p + vec2(0,r1+r2);\n    float d2 = sdBeeBody(p2, r2, 0.25);\n\n    float stripeScalar = 8.0;\n    float y0 = (-p2.y + r2 - pow(p2.x, 2.0)) * stripeScalar;\n\n    float x = fract(y0);\n    float x0 = floor(max(y0,0.0));\n\n    /*\n\tfloat a = clamp(0.5 - 0.8*x1, 0.0, 0.5); // .5 < a < 1\n\tfloat y = sin(PI * sqrt(pow(x0,a)));\n\t*/\n\n    float a = clamp(2.0 + pow(x0,2.0) * 0.5, 1.0, 10.0);\n    float y = sin(pow(1.0 - x, a) * PI);\n\n    float s = saturate(cos(p2.x/(3.0*r2) * PI));\n    vec3 c2 = mix(dark, light, y * (1.0 - min((1.7*x0)/stripeScalar,1.0))) * s;\n\n\n    float d = min(d1, d2);\n\n    vec3 c;\n\n    if(d == d1) {\n        c = c1;\n    }\n    else if(d == d2) {\n        c = c2;\n    }\n\n    return vec4(c, d);\n}\n\n/*\nvec4 wing( vec2 p ) \n{\np = vec2(abs(p.x)-0.2,p.y);\n\nfloat opacity = 0.0;\n\nfloat deltaTime = 1.0/120.0;\n\nconst vec3 wingAlbedo = vec3(0);\n\nfor(int i = -blurFrames; i < blurFrames; i++) {\nfloat time = iTime + float(i) * deltaTime;\nvec2 p0 = rotate(sin(2.0 * time * PI_2) * radians(60.0)) * p;\nfloat d = sdBeeWing(p0, 0.3, 0.3, 0.3) / 10.;\nfloat a = smoothstep(3./iResolution.y, 0., d);\nopacity += (a * 0.3) / float(abs(i) + 1);\n}\n\nreturn vec4(wingAlbedo, opacity);\n}\n*/\n\nvec4 wing( vec2 p ) \n{\n    p = vec2(abs(p.x)-0.1,p.y);\n\n    float opacity = 0.0;\n\n    const vec3 wingAlbedo = vec3(0.05);\n\n    for(int i = 0; i < blurFrames; i++)\n    {\t\n        float time = iTime - float(i) / float(blurFramerate * blurFrames);\n\n        vec2 p0 = rotate(sin(13.0 * time * PI_2) * radians(55.0) - radians(20.0)) * p;\n        float d = sdBeeWing(p0, 0.3, 0.3, 0.3);\n        float a = smoothstep(3./iResolution.y, 0., d);\n\n        opacity += saturate(a) * 0.96;\n    }\n\n    return vec4(wingAlbedo, opacity / float(blurFrames));\n}\n\nvec4 head( vec2 p, float r ) {\n    vec4 color = vec4(0);\n\n    vec2 p0 = p - vec2(0, r + 0.14);\n    float distHead = sdCircle(p0, r);\n\n    color = mix(color, vec4(0.14, 0.14, 0.14, 1), smoothstep(3.0/iResolution.y, 0.0, distHead));\n\n    // Eyes\n    float r0 = 0.4 * r;\n\n    float o = 0.5*r; // offset of eyes from middle\n    vec2 p1 = vec2(abs(p0.x)-o,p0.y);\n    float distSockets = sdCircle(p1, r0);\n\n    color = mix(color, vec4(0, 0, 0, 1), smoothstep(3.0/iResolution.y, 0.0, distSockets));\n\n    float a0 = sin( 1.5 * iTime * PI_2) * radians(25.0) + radians(-30.0);\n    float a1 = cos(-1.5 * iTime * PI_2) * radians(25.0) + radians( 30.0);\n\n    float r1 = 0.4 * r0;\n\n    vec2 d0 = vec2(sin(a0),cos(a0));\n    vec2 d1 = vec2(sin(a1),cos(a1));\n\n    vec2 p10 = vec2(p0.x+o,p0.y) - 0.5*r0*d0;\n    vec2 p11 = vec2(p0.x-o,p0.y) - 0.5*r0*d1;\n\n    float distLeft = sdCircle(p10, r1);\n    float distRight = sdCircle(p11, r1);\n\n    float distEyes = min(distLeft, distRight);\n\n    // Lasers from eyeballs\n    float distLaserLeft = udLine(p10, vec2(0), -d0 * 100.0);\n    float distLaserRight = udLine(p11, vec2(0), -d1 * 100.0);\n\n    float distLaser = min(distLaserLeft, distLaserRight) - 0.0075;\n\n    color = mix(color, vec4(1, 0, 0, 1), smoothstep(3.0/iResolution.y, 0.0, distEyes));\n\n    if (enabledLasers)\n    {\n        float ss = smoothstep(3.0/iResolution.y, 0.0, distLaser);\n\n        color.rgb = mix(color.rgb, vec3(1, 0, 0), ss);\n        color.a = max(color.a, mix(color.a, 0.6, ss));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Centered normalized pixel coordinated (from -1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Initialize color to black\n    vec3 col = vec3(0);\n\n    // Layer bee on top of the honeycombs\n\n    float theta = 0.5 * iTime * PI_2;\n    float phi = radians(90.0);\n    vec2 p0 = p*1.6 - .3*lissajous(1.7, theta, phi);\n    p0 += vec2(.9, .3)*lissajous(5., .15 * iTime * PI_2, radians(0.));\n    //p0 = p;\n\n    col = texture(iChannel0, uv).rgb;\n    \n    vec4 b = bee(p0);\n\n    float a0 = smoothstep(3./iResolution.y, 0., b.w);\n    float a1 = 0.35 * smoothstep(3./iResolution.y, 0., b.w - 0.05);\n    float a2 = 0.9 * smoothstep(3./iResolution.y, 0., b.w - 0.01);\n\n    col = mix(col, vec3(0), a1);\n    col = mix(col, vec3(0), a2);\n\n    col = mix(col, b.rgb, a0);\n\n    vec4 w = wing(p0);\n    col = mix(col, w.rgb, w.a);\n\n    vec4 h = head(p0, 0.145);\n    col = mix(col, h.rgb, h.a);\n\n    fragColor = vec4(col, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float G(in vec2 p, in float sigma) {\n    float sigma2 = sigma*sigma;\n    return (1.0/(2.0 * PI * sigma2))\n        *exp(-dot(p,p)/(2.0*sigma2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    // Calculate the standard deviation for the blur based on distance from center\n    // of the screen. I'm using a simple mix() for this...\n\n    float a = pow(saturate(length(p)-0.4), 1.3);\n    \n    if(stdDev >= 1.0 && enabledBlur) {\n        // Simple gaussian blur\n        float sumGauss = 0.0;\n\n        for(float i = 0.0; i < stdDev; i++) {\n            for(float j = 0.0; j < stdDev; j++) {\n\n                vec2 offset = vec2(i,j);\n                float g = G(range_n1p1(offset / stdDev), 0.7);\n\n                sumGauss += g;\n\n                col += g * texture(iChannel0, (fragCoord + offset - 0.5*stdDev) / iResolution.xy).rgb; \n            }\n        }\n        col /= sumGauss;\n        col = mix(texture(iChannel0, uv).rgb, col, a);\n\n    } else {\n        col = texture(iChannel0, uv).rgb;\n    }\n    /*\n    if(enabledMirror) {\n    \n    \tfragColor = texture(iChannel0, abs(uv-vec2(0.5,0)) + vec2(0.5,0));\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }*/\n    \n    fragColor = vec4(col, 1);\n}","name":"Buffer C","description":"","type":"buffer"}]}