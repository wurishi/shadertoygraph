{"ver":"0.1","info":{"id":"WsX3zX","date":"1546948283","viewed":281,"name":"Warping Marble","username":"Elyxian","description":"A simple experiment with raytracing. The distance field is a union between a sphere and a perlin noise field moving towards the camera. The mouse can be used to rotate the camera.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n\n}\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// 3D Perlin Noise Implementation\n\nvec3 fade3(vec3 t) {\n\treturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nvec3 getGradient3D(vec3 p) {\n\treturn normalize(-1.0 + 2.0 * hash33(p));\n}\n\nfloat perlin3D(vec3 p) {\n\t\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = fade3(f);\n    \n    float value000 = dot(getGradient3D(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat value100 = dot(getGradient3D(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat value010 = dot(getGradient3D(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat value110 = dot(getGradient3D(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat value001 = dot(getGradient3D(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat value101 = dot(getGradient3D(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat value011 = dot(getGradient3D(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat value111 = dot(getGradient3D(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\treturn mix(\n\t\tmix(\n\t\t\tmix(value000, value100, u.x),\n\t\t\tmix(value010, value110, u.x),\n\t\t\tu.y),\n\t\tmix(\n\t\t\tmix(value001, value101, u.x),\n\t\t\tmix(value011, value111, u.x),\n\t\t\tu.y),\n\t\tu.z);\n\n}\n\n// The distance field\nfloat map(vec3 pos) {\n    \n    vec3 offset = vec3(1.5, 0.0, iTime);\n    float noise1 = 0.05 * perlin3D(10.0 * pos + offset);\n    float noise2 = length(pos) - 1.0;\n        \n    return max(noise1, noise2);\n    \n    // Iq style smooth union (https://iquilezles.org/articles/distfunctions)\n    //float k = 0.05;\n    //float h = clamp(0.5 - 0.5*(noise2-noise1)/k, 0.0, 1.0);\n    //return mix(noise2, noise1, h) + k*h*(1.0-h);\n    \n}\n\n\n// The colour at a given position\nvec3 getBaseCol(vec3 pos) {\n    return vec3(1.0, 1.0, 1.0) * (0.5 + 0.5 * sin(length(pos * 10.0)));\n}\n\n// Determines the output colour of the surface at a given position using simple normal-based lighting\nvec3 renderSurface(vec3 pos) {\n\t\n    vec2 eps = vec2(0.00, 0.01);\n    \n    float ambientIntensity = 0.1;\n    vec3 lightDir = normalize(vec3(sin(iTime * 0.3), -0.3, 0.2));\n    \n    vec3 normal = normalize(vec3(\n    \tmap(pos + eps.yxx) - map(pos - eps.yxx),\n\t\tmap(pos + eps.xyx) - map(pos - eps.xyx),\n\t\tmap(pos + eps.xxy) - map(pos - eps.xxy)\n    ));\n    \n    vec3 baseColor = getBaseCol(pos);\n    \n    float diffuse = ambientIntensity + max(dot(-lightDir, normal), 0.0);\n    return baseColor * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ps = uv - 0.5;\n    ps.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(ps, 0.7));\n\t\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0,0.0):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Raymarch\n    float t = 0.0;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float eps = 0.001;\n    int iterations = 60;\n    \n    for (int i = 0; i < iterations; i++) {\n    \t\n       \tvec3 ps = ro + t * rd;\n        float d = abs(map(ps));\n        \n        if (d < eps) {\n            col = renderSurface(ps);\n            break;\n        }\n        \n        t += d;\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}