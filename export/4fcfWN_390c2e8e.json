{"ver":"0.1","info":{"id":"4fcfWN","date":"1733112054","viewed":31,"name":"Creased Bilinear Interpolation","username":"lowellcamp","description":"A variation on bilinear interpolation that allows certain edges to be marked as discontinuous.\nI mainly came up with this to be used when smoothly sampling flood fill lighting.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLOCKED_PROB 0.1\n#define BLOCKER_VIS_THICKNESS (1.0 / 64.0)\n\nbvec4 decode(float value) {\n    int iv = int(value * 256.0);\n    return bvec4(\n        iv % 2 >= 1,\n        iv % 4 >= 2,\n        iv % 8 >= 4,\n        iv % 16 >= 8\n    );\n}\n\nvec3 colorTexture(ivec2 texel) {\n    return texelFetch(iChannel1, texel % ivec2(iChannelResolution[1].xy), 0).rgb;\n}\n\nbvec4 edgeTexture(ivec2 texel) {\n    float value = texelFetch(iChannel0, texel % ivec2(iChannelResolution[0].xy), 0).x;\n    int iv = int(value * 256.0);\n    return bvec4(\n        iv % 2 >= 1,\n        iv % 4 >= 2,\n        iv % 8 >= 4,\n        iv % 16 >= 8\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 texelPos = fragCoord / 32.0 + vec2(1.0, 0.7) * iTime;\n    vec2 texelFract = fract(texelPos);\n    ivec2 iTexel = ivec2(texelPos);\n    vec2 offset = texelFract - 0.5;\n    \n    // edges within each bvec4 is down, up, left, right\n    bvec4 edges_d = edgeTexture(iTexel - ivec2(0, 1));\n    bvec4 edges_u = edgeTexture(iTexel + ivec2(0, 1));\n    bvec4 edges_l = edgeTexture(iTexel - ivec2(1, 0));\n    bvec4 edges_r = edgeTexture(iTexel + ivec2(1, 0));\n    \n    bvec4 edges = bvec4(\n        edges_d.y,\n        edges_u.x,\n        edges_l.w,\n        edges_r.z\n    );\n    \n    // We will parametrize this by a single quadrant of a pixel.\n    bool edge_h;\n    bool edge_hv;\n    bool edge_v;\n    bool edge_vh;\n    vec3 color_h;\n    vec3 color_v;\n    vec3 color_diag;\n    \n    vec3 color_center = colorTexture(iTexel);\n    \n    if (offset.x > 0.0) {\n        color_h = colorTexture(iTexel + ivec2(1, 0));\n        edge_h = edges_r.z;\n        edge_hv = offset.y > 0.0 ? edges_r.y : edges_r.x;\n    } else {\n        color_h = colorTexture(iTexel - ivec2(1, 0));\n        edge_h = edges_l.w;\n        edge_hv = offset.y > 0.0 ? edges_l.y : edges_l.x;\n    }\n    if (offset.y > 0.0) {\n        color_v = colorTexture(iTexel + ivec2(0, 1));\n        edge_v = edges_u.x;\n        edge_vh = offset.x > 0.0 ? edges_u.w : edges_u.z;\n    } else {\n        color_v = colorTexture(iTexel - ivec2(0, 1));\n        edge_v = edges_d.y;\n        edge_vh = offset.x > 0.0 ? edges_d.w : edges_d.z;\n    }\n    color_diag = colorTexture(iTexel + ivec2(sign(offset)));\n    \n    // From here, we no longer care about the sign of the offset.\n    offset = abs(offset);\n    \n    // We will separate out the individual components of bilinear sampling and add them individually.\n    // This will allow us to introduce discontinuities.\n    float weight = (1.0 - offset.x) * (1.0 - offset.y);\n    vec3 col = color_center * weight;\n    float totalWeight = weight;\n    \n    // The diagonal cell will always have the same weight unless it is blocked.\n    if (\n        !(edge_h && edge_vh) && // wall to the left/right\n        !(edge_v && edge_hv) && // wall above/below\n        !(edge_h && edge_v) && // corner around here\n        !(edge_hv && edge_vh) // corner around the diagonal\n    ) {\n        weight = offset.x * offset.y;\n        col += color_diag * weight;\n        totalWeight += weight;\n    }\n    \n    // horizontal edge\n    if (!edge_h) {\n        // The horizontal neighbor is unobstructed\n        weight = offset.x * (1.0 - offset.y);\n        col += color_h * weight;\n        totalWeight += weight;\n    } else if (!(edge_v || edge_vh || edge_hv)) {\n        // The horizontal neighbor can be reached around the corner\n        weight = offset.x * offset.y;\n        col += color_h * weight;\n        totalWeight += weight;\n    }\n    \n    // vertical edge\n    if (!edge_v) {\n        // The vertical neighbor is unobstructed\n        weight = (1.0 - offset.x) * offset.y;\n        col += color_v * weight;\n        totalWeight += weight;\n    } else if (!(edge_h || edge_hv || edge_vh)) {\n        // The vertical neighbor can be reached around the corner\n        weight = offset.x * offset.y;\n        col += color_v * weight;\n        totalWeight += weight;\n    }\n    \n    col /= totalWeight;\n    \n    float edge = 0.0;\n    #ifdef BLOCKER_VIS_THICKNESS\n    if (offset.x > 0.5 - BLOCKER_VIS_THICKNESS && edge_h) {\n        edge = 1.0;\n    }\n    if (offset.y > 0.5 - BLOCKER_VIS_THICKNESS && edge_v) {\n        edge = 1.0;\n    }\n    \n    #endif\n    \n    fragColor = vec4(mix(col, vec3(0, 0, 0), 0.25 * edge), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generate the edge mask and write it to a texture.\n\n#define THRESHOLD 0.08\n\nfloat encode_b4(bool up, bool down, bool left, bool right) {\n    return float(\n        (up ? 1 : 0) +\n        (down ? 2 : 0) +\n        (left ? 4 : 0) +\n        (right ? 8 : 0)\n    ) / 256.0;\n}\n\n\nvec3 grab(ivec2 texel) {\n    return texelFetch(iChannel0, texel % ivec2(iChannelResolution[0].xy), 0).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float center = grab(ivec2(fragCoord)).x;\n    \n    bool down  = abs(grab(ivec2(fragCoord) - ivec2(0, 1)).x - center) > THRESHOLD;\n    bool up    = abs(grab(ivec2(fragCoord) + ivec2(0, 1)).x - center) > THRESHOLD;\n    bool left  = abs(grab(ivec2(fragCoord) - ivec2(1, 0)).x - center) > THRESHOLD;\n    bool right = abs(grab(ivec2(fragCoord) + ivec2(1, 0)).x - center) > THRESHOLD;\n    \n    fragColor  = vec4(vec3(encode_b4(down, up, left, right)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}