{"ver":"0.1","info":{"id":"tsVyRV","date":"1638432542","viewed":97,"name":"Straightforward grid test","username":"toninoni","description":"Test for simple circular and square grids, with a pulsating animation and some noise.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592\n#define N 5.0\n#define WIDTH 30.0\n#define RAD PI / 180.0\n#define COLOR_GREEN vec3(0.1, 0.7, 0.4)\n#define COLOR_RED   vec3(0.8, 0.2, 0.1)\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rotateUV(vec2 uv, float rotation){\n    return vec2(\n        cos(rotation) * (uv.x) + sin(rotation) * (uv.y),\n        cos(rotation) * (uv.y) - sin(rotation) * (uv.x)\n    );\n}\n\nvec3 circle(vec2 tc, vec3 color) {\n    float lw = WIDTH / iResolution.x;\n    float factor = 1.0 - lw;\n    \n    vec2 tcorig = tc;\n    // in [-1..1]\n    tc = (tc - 0.5) * 2.0;\n    float alpha = 1.3 - length(tc);\n    \n\n    \n    vec2 coord = tc * (N - 1.0) * 2.0;\n    float dist = length(coord);\n    \n    // the grid in itself\n    float func = cos(PI * dist);\n\n    // lines (cross)\n    vec2 lines_cross = smoothstep(factor, 1.0, pow(1.0 - abs(tc), vec2(2.5)));\n    \n    // lines (diagonal)\n    vec2 tc_rotated1 = rotateUV(tc, 30.0 * RAD);\n    vec2 lines_diag1 = smoothstep(factor, 1.0, pow(1.0 - abs(tc_rotated1), vec2(15.5)));\n    vec2 tc_rotated2 = rotateUV(tc, 60.0 * RAD);\n    vec2 lines_diag2 = smoothstep(factor, 1.0, pow(1.0 - abs(tc_rotated2), vec2(15.5)));\n    \n    // Grid\n    vec3 result = color * (smoothstep(factor, 1.0, func) \n                    + lines_cross.x + lines_cross.y \n                    + lines_diag1.x + lines_diag1.y\n                    + lines_diag2.x + lines_diag2.y);\n    // Background                \n    result.rgb = max(result.rgb, color * 0.2);\n\n    return result;\n}\n\n\nvec3 square(vec2 tc, vec3 color) {\n    float lw = WIDTH / iResolution.x;\n    vec2 coord = tc;\n    coord *= 16.0;\n    \n    // Normalize in -1..0..1\n    vec2 norm = abs((tc - 0.5) * 2.0);\n    \n    coord = cos(PI * coord);\n    \n    // Grid\n    vec3 result = color * smoothstep(1.0 - lw, 1.0, max(coord.x, coord.y));\n    result = clamp(result, 0.0, 1.0);\n    \n    // Background                \n    result.rgb = max(result.rgb, color * 0.2);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = vec2(fragCoord - 0.5 * res ) / res.y;\n    uv = uv + vec2(0.5, 0.5);\n    \n    // Output to screen\n    if(mod(iTime, 6.0) < 3.0) {\n        fragColor.rgb = circle(uv, COLOR_GREEN);\n    } else {\n        fragColor.rgb = square(uv, COLOR_RED);\n    }\n    \n    // Pulse\n    float distCenter = length((uv - 0.5) * 2.0);\n    float fac = clamp(pow(abs(sin(iTime * 1.5 - pow(distCenter, 2.0))), 0.2), 0.5, 1.0);\n    fragColor *= fac;\n    fragColor.a = 1.0;\n    \n    // Noise\n    fragColor.rgb += (0.3 * rand(1.0e2 * uv + iTime * 0.0001) - 0.15);\n}\n\n","name":"Image","description":"","type":"image"}]}