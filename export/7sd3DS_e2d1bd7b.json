{"ver":"0.1","info":{"id":"7sd3DS","date":"1630606188","viewed":231,"name":"4d perlin noise","username":"Sprocket","description":"Demo of a 4d perlin noise function","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------- From https://www.shadertoy.com/view/4djSRW -------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random_gradient(vec4 vector)\n{\n    return hash44(vector) * 2.0 - 1.0;\n}\n\nfloat perlin_noise(vec4 point)\n{\n    vec4 gridCell = floor(point);\n    vec4 local = point - gridCell;\n\n    vec4 weight = local * local * (3.0 - 2.0 * local);\n\n    return mix(//W\n        mix(//w0 z\n            mix(//w0 z0 y\n                mix(//w0 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,0),\n                        random_gradient(gridCell + vec4(0,0,0,0))),\n                    dot(\n                        local - vec4(1,0,0,0),\n                        random_gradient(gridCell + vec4(1,0,0,0))),\n                    weight.x),\n                mix(//w0 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,0),\n                        random_gradient(gridCell + vec4(0,1,0,0))),\n                    dot(\n                        local - vec4(1,1,0,0),\n                        random_gradient(gridCell + vec4(1,1,0,0))),\n                    weight.x),\n                weight.y),\n            mix(//w0 z1 y\n                mix(//w0 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,0),\n                        random_gradient(gridCell + vec4(0,0,1,0))),\n                    dot(\n                        local - vec4(1,0,1,0),\n                        random_gradient(gridCell + vec4(1,0,1,0))),\n                    weight.x),\n                mix(//w0 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,0),\n                        random_gradient(gridCell + vec4(0,1,1,0))),\n                    dot(\n                        local - vec4(1,1,1,0),\n                        random_gradient(gridCell + vec4(1,1,1,0))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        mix(//w1 z\n            mix(//w1 z0 y\n                mix(//w1 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,1),\n                        random_gradient(gridCell + vec4(0,0,0,1))),\n                    dot(\n                        local - vec4(1,0,0,1),\n                        random_gradient(gridCell + vec4(1,0,0,1))),\n                    weight.x),\n                mix(//w1 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,1),\n                        random_gradient(gridCell + vec4(0,1,0,1))),\n                    dot(\n                        local - vec4(1,1,0,1),\n                        random_gradient(gridCell + vec4(1,1,0,1))),\n                    weight.x),\n                weight.y),\n            mix(//w1 z1 y\n                mix(//w1 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,1),\n                        random_gradient(gridCell + vec4(0,0,1,1))),\n                    dot(\n                        local - vec4(1,0,1,1),\n                        random_gradient(gridCell + vec4(1,0,1,1))),\n                    weight.x),\n                mix(//w1 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,1),\n                        random_gradient(gridCell + vec4(0,1,1,1))),\n                    dot(\n                        local - vec4(1,1,1,1),\n                        random_gradient(gridCell + vec4(1,1,1,1))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        weight.w);\n}\n\nfloat noise(vec3 point)\n{\n    return perlin_noise(vec4(point, iTime)) * 0.5 + 0.5;\n}\n\nfloat sample_point(vec3 point)\n{\n    return noise(point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(sample_point(vec3(uv * 8., iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}