{"ver":"0.1","info":{"id":"4sjyRz","date":"1490644102","viewed":778,"name":"2dsdf","username":"psykotic","description":"fooling around. poly is \"kaleidoscopic max norm\", not euclidean, so using it for aa will blur the vertices for very acute angles, but it makes it easy to do miter joints for outlining. could fix with voronoi regions as in roundrect.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dunion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat dintersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat halfplane(vec2 p, vec2 n, float d) {\n    return dot(n, p) + d;\n}\n\nfloat disk(vec2 p, vec2 c, float r) {\n    return distance(c, p) - r;\n}\n\nfloat poly(vec2 p, float n, vec2 c, float r) {\n    float pi = 3.1415926;\n    p -= c;\n    float b = 2.0*pi / n;\n    float a = atan(p.y, p.x);\n    a = mod(a + 0.5*b, b) - 0.5*b;\n    return length(p)*cos(a) - r;\n}\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n    p = abs(p - c) - r;\n\tif (p.x >= 0.0 && p.y >= 0.0)\n        return length(p);\n    else\n        return max(p.x, p.y);\n}\n\nvec2 rotate(vec2 v, vec2 c, float a) {\n    v -= c;\n    vec2 w = vec2(cos(a), sin(a));\n    return c + vec2(w.x * v.x - w.y * v.y, w.y * v.x + w.x * v.y);\n}\n\nfloat ramp(float x) {\n    return x;\n}\n\nvec4 over(vec4 c1, vec4 c2) {\n    return c1 + (1.0 - c1.a) * c2;\n}\n\nfloat scene(vec2 p) {\n    float t = 0.5 * sin(iTime) + 0.5;\n    float t2 = 0.5 * sin(2.0 * iTime) + 0.5;\n    float boxdist = roundrect(p, vec2(1.45, 0.35 + 0.3 * t2), vec2(0.15 + 0.08 * t2, 0.15));\n    p = rotate(p, vec2(0.5, 0.5), iTime);\n    float sides = 3.0 + 3.0 * t;\n    float radius = 0.1 + 0.15 * t2;\n    float dist = dunion(boxdist,\n      \t\t\t\t\tdunion(poly(p, sides, vec2(0.3, 0.5), 0.2),\n                        disk(p, vec2(0.9, 0.5), radius)));\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float pixwidth = length(1.0 / iResolution.xy);\n\tvec2 pos = fragCoord.xy / iResolution.y;\n    \n    float aawidth = 1.0; // 0.0 to turn off aa or > 1.0 to see sdf falloff.\n    float aa = aawidth * pixwidth;\n\n    float dist = scene(pos);\n    float dist2 = scene(pos + vec2(-0.02, 0.02));\n\n    vec4 interior = vec4(0.9, 0.2, 0.2, 0.0);\n    \n    if (dist <= 0.0)\n        interior.a = 1.0;\n    else if (dist < aa)\n        interior.a = ramp(1.0 - dist / aa);\n\n    interior.rgb *= interior.a;\n    \n\tvec4 outline = vec4(0.15, 0.15, 0.15, 0.0);\n    float outline_radius = pixwidth * 10.0;\n    if (dist >= -aa) {\n        if (dist < 0.0)\n            outline.a = ramp(1.0 - (-dist / aa));\n        else if (dist <= outline_radius)\n        \toutline.a = 1.0;\n\t\telse if (dist < outline_radius + aa)\n            outline.a = ramp(1.0 - (dist - outline_radius) / aa);\n    }\n        \n    outline.rgb *= outline.a;\n\n    vec4 shadow = vec4(0.1, 0.1, 0.1, 0.0);\n    if (dist2 <= outline_radius)\n        shadow.a = 1.0;\n     else if (dist2 < outline_radius + aa)\n        shadow.a = ramp(1.0 - (dist2 - outline_radius) / aa);\n\n    shadow.a *= 0.2;\n    shadow.rgb *= shadow.a;\n    \n    vec4 background = vec4(0.6, 0.6, 0.8, 1.0);\n\n    fragColor = over(outline, over(interior, over(shadow, background)));\n}\n\t","name":"Image","description":"","type":"image"}]}