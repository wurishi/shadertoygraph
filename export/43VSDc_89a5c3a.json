{"ver":"0.1","info":{"id":"43VSDc","date":"1720582117","viewed":67,"name":"Simple Starbox","username":"NAME_REDACTED","description":"A simple demonstration of a very fast method of generating a skybox full of stars.","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["stars","night","starry","skybox","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nInstead of tracking multiple stars or using a hash function (which very often\ncauses artifacts), here we have a simple fast method of generating a random starbox\nusing only 3 texelFetch operations per pixel. The downside is these stars are fixed\non the sky, ie there is no depth perception.\n\nIn this example, each layer has 1/4 the number of stars and is 4x brighter.\n*/\n\n//each additional layer of stars draws bigger, closer stars\n#define STAR_LAYERS 4\n//the main function just returns black-and-white stars\nfloat stars(vec2 uv)\n{\n    vec2 uvm = (2. + uv) * 128.; //initial cell size, furthest layer\n    float sm = 1.; //layer brightness\n    float ex = -2170.; //inverse sharpness\n    float result = 0.;\n    for (int i = 0; i < STAR_LAYERS; i++) \n    {\n        ivec2 cell = ivec2(uvm);\n        vec4 samp = texelFetch(iChannel2, cell % 256, 0);\n        vec2 offs = samp.rg - .5;\n        vec2 cp = fract(uvm) - .5;\n        float star = length(cp - offs * .9); //star image - the 0.9 multiplier prevents artifacts in close stars\n        float br = samp.a + .1; //star brightness\n        result += exp(ex * star) * sm * br;\n        //result += smoothstep(.985, 1., 1. - star) * sm * br;\n        uvm *= .25; //next layer has 1/4 the number of stars\n        sm *= 2.; //next layer is twice as bright\n        ex *= 1.75; //need to adjust the sharpness with each layer or we get big blurry stars\n    }\n    //return pow(star, 40.);\n    //return smoothstep(.98, 1., star);\n    return result;\n}\n\n//fast function to convert chroma (0..1) to a star-like color\nvec3 starColorFromChroma(float chroma)\n{\n    return vec3(1. - chroma + pow(chroma, 5.), .5, chroma);\n}\n\n//same stars but with color\n//rg is the star position, a is brightness, b is chroma\nvec3 starsColored(vec2 uv)\n{\n    vec2 uvm = (2. + uv) * 128.; //initial cell size, furthest layer\n    float sm = 1.; //initial layer brightness\n    float ex = -20.; //inverse sharpness\n    vec3 result = vec3(0.);\n    for (int i = 0; i < STAR_LAYERS; i++) \n    {\n        ivec2 cell = ivec2(uvm);\n        vec4 samp = texelFetch(iChannel2, cell % 256, 0);\n        vec2 offs = samp.rg - .5;\n        vec2 cp = fract(uvm) - .5;\n        float star = length(cp - offs * .9); //star image\n        float br = samp.a; //per-star brightness\n        //a little trick to reduce the amout of color in more distant stars\n        float chroma = .5 + (samp.b - .5) * sm * .1;\n        vec3 color = starColorFromChroma(chroma);\n        result += color * exp(ex * star) * sm * (br * br + .1);\n        uvm *= .25;\n        sm *= 2.;\n        ex *= 1.75;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.x += iTime * .1;\n\n    //black and white stars\n    //vec3 col = vec3(stars1(uv));\n    \n    //colored stars\n    vec3 col = starsColored(uv);    \n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}