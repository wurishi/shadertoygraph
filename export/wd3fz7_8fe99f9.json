{"ver":"0.1","info":{"id":"wd3fz7","date":"1605092121","viewed":188,"name":"[JFIG] Bubbles","username":"nanored","description":"Bubbles with a lower speed at some points in order to form JFIG 2020","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["bubble","jfig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define Z .66\n\nuint[] im = uint[](0x0u, 0x0u, 0x3f9e7cfcu, 0x3f9e7cfcu, 0x18c0c30u, 0x18c0c30u, 0x398c3c30u, 0x218c3c30u, 0x339e0c3cu, 0x3f9e0c3cu, 0x0u, 0x0u, 0x3e7e7cfcu, 0x36606cc0u, 0x227044e0u, 0x22184430u, 0x220e441cu, 0x36066c0cu, 0x3e7e7cfcu, 0x0u);\n#define IM_H 20\n#define IM_Hf 20.\n#define IM_W 32\n#define IM_Wf 32.\n\n// number of columns\n#define W 60\n#define Wf 60.\n\nfloat rand(int seed) {\n    seed += 15682;\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat noise(vec2 co) {\n  co = 256.*fract(co);\n  int x = int(co.x);\n  int x2 = (x+1)%256;\n  int y = int(co.y);\n  int y2 = (y+1)%256;\n  float dx = co.x - float(x);\n  float dy = co.y - float(y);\n  y <<= 8;\n  y2 <<= 8;\n  return (1.-dx) * ((1.-dy)*rand(x+y) + dy*rand(x+y2))\n            + dx * ((1.-dy)*rand(x2+y) + dy*rand(x2+y2));\n}\n\nfloat noise_multiscale(vec2 uv) {\n    float ans = 1./64.;\n    for(float x = 2.0; x < 60.; x *= 2.) ans += noise(x*uv) / x;\n\treturn ans;\n}\n\nmat2 rotate (float fi) {\n\tfloat cfi = cos(fi);\n\tfloat sfi = sin(fi);\n\treturn mat2 (-sfi, cfi, cfi, sfi);\n}\n\nvec3 iridescence(vec2 uv, float t) {\t\n\tuv *= rotate(.25*noise_multiscale(uv/500.) * length(uv) + t);\n\tuv = (t+uv)/700.;\n    float noi = noise_multiscale(uv)*5.;\n    vec3 p = abs((fract(noi + vec3(3., 2., 1.)/3.) - .5) * 4.5) - 1.;\n\treturn 4.5*clamp(p, 0.0, 1.0) ;\n}\n\nfloat fresnel2(float n, vec3 N, vec3 I) {\n    float r0 = (1.-n) / (1.+n);\n    r0 *= r0;\n    float C = -dot(N, I);\n    float C2 = sqrt(1. - (1.-C*C)/(n*n));\n    float re = (C - n*C2)/(C + n*C2);\n    float rm = (C2 - n*C)/(C2 + n*C);\n    float r1 = .5 * (re*re + rm*rm);\n    return 2. * r1 / (1.+r1);\n}\n\nvec2 spherical(vec3 cart) {\n\tfloat a = atan(cart.x, cart.z)/PI * 2.0;\n\tfloat b = (acos(cart.y)/PI - 0.5) * 2.0;\n\treturn vec2(a, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    vec3 ray = normalize(vec3(uv.x - .5, (uv.y - .5)*ratio, Z));\n    float tt = 5., tt2 = 0.;\n    vec3 O, O2;\n    float over;\n    int index;\n    \n    float l = 1.25 / Wf; // width of columns (adjacent columns have a non empty intersection)\n    float sp = (1.-l) / (Wf-1.); // space between columns\n    float r0 = 7e-3, r1=1.67e-2; // bounds of bubble radius\n    float r1y = r1 * ratio;\n    float x0 = uv.x - l - 1.6*r1, x1 = uv.x + 1.6*r1; // bounds of usefull columns\n\tint i0 = max(0, int(x0 / sp)), i1 = min(W-1, int(x1 / sp)); // indices of usefull columns\n    while(float(i0)*sp < x0) ++ i0;\n    while(float(i1)*sp > x1) -- i1;\n    uv -= vec2(.5, .5);\n    uv.y *= ratio;\n    \n    for(int i = i0; i <= i1; ++i) { // we iter over usefull columns\n    \tfloat dt = .6 + .05*rand(47*i); // time between generation of two bubbles\n        float t0 = rand(59*i); // emission of bubbles starts at time t0 in this column\n        int b = int((iTime + t0 + r1y*2.) / dt) + 1; // indice of the emitted bubble in this column\n        int j1 = int(IM_Wf * (float(i)*sp+l));\n        // stop[j] is true if next bubbles in the j-column of im are outside the screen\n        uint stop = 0u;\n        \n        while(true) {\n            -- b;\n        \tfloat by = iTime + t0 - float(b)*dt;\n            if(by > 9.5) break; // The bubble is above the screen\n            float bx = float(i)*sp + l*rand(W*5*b+i); // X coordinate of the bubble\n            uint ii = uint(IM_Wf*bx); // X coordinate in im\n            if(bool(1u & (stop >> ii))) continue; // We already know that this bubble is above\n            \n            bx -= .5;\n            float bz = Z * (1. + .03*rand(W*(5*b+2)+i)); // Z value of the bubble\n            float dx = bx - uv.x*(bz/Z);\n        \tfloat r = r0 + (r1-r0) * rand(W*(5*b+1)+i); // radius of the bubble\n           \tif(abs(dx) > 1.1*r) continue; // the bubble is too far from the pixel\n            \n            // We compute the Y value of the bubble\n            int j = IM_H-1;\n            float im_val, pix_t;\n            float speed = 1. + dt/(10.-dt)*rand(W*(5*b+4)+i); // speed of the bubble\n            by /= speed;\n            while(j >= 0) {\n                im_val = float(1u & (im[j] >> ii)); // value of the pixel\n                pix_t = (2. + 10. * im_val)/IM_Hf; // time to cross the pixel\n                if(by > pix_t) {\n                    by -= pix_t;\n                    -- j;\n                } else break;\n            }\n            if(j < 0) { // We are outside the screen\n            \tstop |= 1u << ii;\n                continue;\n            }\n            by = (float(IM_H-1 - j) + by / pix_t) / IM_Hf;\n            by = (by - .5) * ratio;\n            float dy = by - uv.y*(bz/Z);\n            if(dy > 1.1*r1) { // We are above\n            \tstop |= 1u << ii;\n                continue;\n            }\n            \n            if(dx*dx + dy*dy <= 1.2*r*r) { // We can compute the intersection with the bubble\n                vec3 B = vec3(bx, by, bz);\n                float P1 = dot(ray, B);\n                float P0 = dot(B, B) - r*r;\n                float Delta = P1*P1 - P0;\n                if(Delta < 0.) continue;\n                float delta = sqrt(Delta);\n                float t = P1 - delta;\n                if(t < tt) {\n                    tt = t;\n                    O = B;\n                    over = im_val;\n                    index = W*(5*b+3)+i;\n                }\n                t = P1 + delta;\n                if(t > tt2) {\n                \ttt2 = t;\n                    O2 = B;\n                }\n            }\n        }\n    }\n    \n    vec3 Isd = .5 + .5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = texture(iChannel0, ray).xyz;\n    col *= (7. + Isd)/8.;\n    if(tt < 5.) { // we found a bubble   \n        vec3 P = tt*ray; // entering point\n        vec3 N = normalize(P - O);\n\t\tvec3 R = ray - 2.*dot(ray, N)*N;\n        vec3 P2 = tt2*ray; // leaving point\n        vec3 N2 = normalize(O2 - P2);\n\t\tvec3 R2 = ray - 2.*dot(ray, N2)*N2;\n\t\n        // Reflexion and Transmision\n        float ti = 600. * cos(500. * rand(index) + iTime/1000.);\n\t\tvec3 s = iridescence(spherical(N), ti);\n\t\tvec3 s2 = iridescence(spherical(-N2), ti);\n\t\tvec3 c = texture(iChannel0, R).xyz;\n\t\tvec3 c2 = texture(iChannel0, R2).xyz;\n\t\tcol = mix(col, c2 * (1.+s2), fresnel2(1.4, N2, ray));\n\t\tcol = mix(col, c * (1.+s), fresnel2(1.4, N, ray));\n        \n        //specular\n        vec3 Light = vec3(-.16, .33, .0);\n        float ks = .2;\n        float alpha = 5.;\n        vec3 L = normalize(Light - P);\n        vec3 Rl = 2.*dot(L, N)*N - L;\n    \tcol += ks * pow(max(0., -dot(Rl, ray)), alpha) * Isd;\n        \n        // More light over the text\n        col = clamp(col, 0., 1.);\n        vec2 p = ray.xy / ray.z * Z * vec2(1., 1./ratio) + vec2(.485, .515);\n        p = clamp(p, 0., 1.);\n    \tp = vec2(p.x*IM_Wf, (1.-p.y)*IM_Hf);\n        int x = int(p.x);\n        int y = int(p.y);\n        int x2 = min(IM_W-1, x+1);\n        int y2 = min(IM_H-1, y+1);\n        float dx = p.x-float(x);\n        float dy = p.y-float(y);\n        over = (1.-dx) * ((1.-dy)*float(1u & (im[y] >> x)) + dy*float(1u & (im[y2] >> x)))\n            + dx * ((1.-dy)*float(1u & (im[y] >> x2)) + dy*float(1u & (im[y2] >> x2)));\n        col *= .6 + .4*over;\n        col = clamp(col, 0., 1.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}