{"ver":"0.1","info":{"id":"wdjfzd","date":"1590648696","viewed":99,"name":"KIFS-flake","username":"blepfo","description":"TODO: 3D print this","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define PI (3.141)\n#define TWOPI (2.*PI)\n#define RAND_SEED (87629.3453)\n\n#define MARCH_MAX_STEPS (512)\n#define MARCH_MAX_DIST (1000.)\n#define MARCH_HIT_DIST (0.001)\n\n#define AO_ITERATIONS (5)\n#define GLOBAL_AO (0.327)\n\n#define SHADE_AO_ONLY (false)\n\n\nstruct Ray {\n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// direction\n};\n\nstruct PointLight { \n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct DirectionLight {\n    vec3 dir;\t\t// direction\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct Material {\n    vec3 d;\t\t\t// diffuse\n    vec3 s;\t\t\t// specular\n    vec3 a;\t\t\t// ambient\n    float shiny;\t// shininess\n};\n\nstruct SceneObj {\n    float sdf;\n\tint matId;\n};\n\nstruct Hit {\n    vec3 p;\n    vec3 n;\n    SceneObj obj;\n};\n\n\nvec3 translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nmat2 rotate2d(float theta) { \n    return mat2(cos(theta), -sin(theta), \n                sin(theta), cos(theta)); \n}\n\n\n\n/********* Signed Distance Functions (SDFs)\n\nReferences for SDFs:\nSphere, Cube, Torus, Capsule, Cylinder - https://youtu.be/Ff0jJyyiVyw (ArtOfCode)\nRotate, Scale, Union, Intersection, Difference - https://youtu.be/AfKGMUDWfuE (ArtOfCode)\nOnioning, Displacement Mapping, Twisting - https://youtu.be/Vmb7VGBVZJA (ArtOfCode)\n\nhttps://iquilezles.org/articles/distfunctions (Inigo Quilez)\n**********/\n\nfloat sdfCube(vec3 p, vec3 halfSize) {\n    vec3 edgeDist = abs(p) - halfSize;\n    return length(max(edgeDist, 0.))\n        + min(max(edgeDist.x, max(edgeDist.y, edgeDist.z)), 0.);\n}\n\nSceneObj objUnion(SceneObj s1, SceneObj s2) {\n    if (s1.sdf < s2.sdf) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nvec3 fold(vec3 p, vec3 n) {\n    n = normalize(n);\n    float d = dot(p, n);\n    return p - (2. * max(d, 0.) * n);\n}\n\nvec3 fold(vec3 p, float pitch, float yaw) {\n\tfloat cp = cos(pitch);\n    vec3 n = vec3(cp*sin(yaw), sin(pitch), cp*cos(yaw));\n    return fold(p, n);\n}\n\n// Define all objects in the scene\n// Use material Ids so we can wait until later to calculate Material colors\n// Materials using textures need scene normal, which we can't get until after\n// scene SDF is defined\nSceneObj mapScene(vec3 p) {\n    p /= 0.5;\n    vec3 sphereP = p;\n\tfloat hPi = PI / 2.0;\n    \n\tsphereP.y *= -1.;\n    sphereP /= 3.;\n    #define iterations (4)\n    for (int i = 0; i < iterations; i++) {\n        sphereP *= 3.;\n    \tsphereP = translate(sphereP, vec3(0., -2., 0.));\n    \tsphereP = fold(sphereP, vec3(0., 1., 0.));\n    \tsphereP = translate(sphereP, vec3(0., -2. ,0.));\n    \tsphereP = fold(sphereP, vec3(-1., 0., 0.));\n    \tsphereP = translate(sphereP, vec3(2., 0., 0.));\n\t\tsphereP = fold(sphereP, 0., 0.);\n    \tsphereP = translate(sphereP, vec3(0., 0., -2.));\n    \tsphereP = fold(sphereP, -1.064, 1.112);\n    \tsphereP = fold(sphereP, vec3(1., 1., 0.));\n    \tsphereP = translate(sphereP, vec3(-2., 0., 0.));\n    \tsphereP = fold(sphereP, vec3(1.,0.,0.));\n    \tsphereP = translate(sphereP, vec3(-1, 0., 0.));\n    \tsphereP = fold(sphereP, vec3(1.,0.,0.));\n\t\tsphereP = translate(sphereP, vec3(-1., 0., 0.));\n    \tsphereP = fold(sphereP, vec3(1., 1.,0.));\n    }\n    \n    \n\n\n\n    float sphere1Sdf = sdfCube(sphereP, vec3(1.));\n    sphere1Sdf /= pow(3., float(iterations));\n    SceneObj sphere1 = SceneObj(sphere1Sdf, 0);\n\n    SceneObj s = sphere1;\n    return s ;\n}\n\nfloat sdfScene(vec3 p) {\n\tSceneObj objAtP = mapScene(p);\n    return objAtP.sdf;\n}\n\n\n// Scene normals using SDF gradient\n// References for normal calculation: \n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://iquilezles.org/articles/normalsSDF (Inigo Quilez)\nvec3 sceneNormal(vec3 p) {\n    vec2 epsilon = vec2(0.01, 0.);\n    return normalize(vec3(\n        sdfScene(p + epsilon.xyy) - sdfScene(p - epsilon.xyy),\n        sdfScene(p + epsilon.yxy) - sdfScene(p - epsilon.yxy),\n        sdfScene(p + epsilon.yyx) - sdfScene(p - epsilon.yyx)\n    ));\n}\n\n\n/********** MATERIALS **********/\n\nMaterial materialLookup(Hit hit) {\n    int matId = hit.obj.matId;\n    if (matId == 0) {\n        // Plane material\n        return Material(\n        \tvec3(0.535,0.535,0.535),\n        \tvec3(0.245,0.245,0.245), \n        \tvec3(0.245,0.239,0.245),\n        \t256.\n        );\n    }\n}\n\n\n// References for raymarching:\n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://youtu.be/PGtv-dBi2wE (ArtofCode)\nbool rayMarch(Ray r, out Hit hit) {\n    // Accumulated distance to ray origin\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        vec3 p = r.o + (dO * r.d);\n        // Current distance to scene\n        float dS = sdfScene(p);\n        dO += dS;\n        if (abs(dS) < MARCH_HIT_DIST) {\n            hit = Hit(\n                p,\n                sceneNormal(p),\n                mapScene(p)\n            );\n            return true;\n        }\n        if (dO >= MARCH_MAX_DIST) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\n/********** LIGHTING **********/\n\n// Reference for shadows: \n// https://youtu.be/2YZClgDWCaM (3dGraphicsFromScratch)\n// http://www.polygonpi.com/?p=318 (Polygon Pi)\n// https://iquilezles.org/articles/rmshadows (Inigo Quilez)\nfloat calcShadow(Ray shadowRay, float maxMarch, float k) {\n    // Shadow increases when ray from surface to light gets closer to scene (dS gets smaller)\n    // More distant objects cast darker shadows (dO gets larger)\n    float shadowMultiplier = 1.;\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        if (dO > maxMarch) { break; }\n        vec3 p = shadowRay.o + (dO * shadowRay.d);\n        float dS = sdfScene(p);\n        if (abs(dS) < MARCH_HIT_DIST) {\n            // Hit surface -- we are in a shadow\n            return 0.;\n        }\n        dO += dS;\n        shadowMultiplier = min(shadowMultiplier, k * dS / dO);\n    }\n\treturn clamp(shadowMultiplier, 0., 1.);\n}\n\n// Reference for ambient occlusion:\n// https://youtu.be/6zYTrFRVGiU (3dGraphicsFromScratch)\nfloat calcAO(vec3 p, vec3 normal, float epsilon) {\n    float aoMultiplier = 0.;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITERATIONS ; i++) {\n        float t = epsilon * float(i);\n        aoMultiplier += (weight * (1. - (t - sdfScene(p + t*normal))));\n        weight /= 2.;\n    }\n    return aoMultiplier;\n}\n\n\n// Reference for lighting:\n// Basics - http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// Diffuse - https://youtu.be/9VJReTr7YXY (3dGraphicsFromScratch)\n// Diffuse - shadows - https://youtu.be/PGtv-dBi2wE (ArtOfCode)\nvec3 illuminateSingleLight(\n    Hit hit, \n    vec3 lDir, \n    vec3 lDiffuse, \n    vec3 lSpec, \n    vec3 lAmbient, \n    vec3 eye,\n    float maxMarch\n) {\n    Material mat = materialLookup(hit);\n    // DIRECT LIGHTING\n    // Diffuse illumination\n    float diffuse = dot(hit.n, lDir);\n    vec3 diffuseIllum = diffuse * lDiffuse * mat.d;\n    // Specular illumination\n    vec3 r = reflect(lDir, hit.n);\n    vec3 viewDir = normalize(eye - hit.p);\n    float specular = dot(r, viewDir);\n    vec3 specularIllum = pow(specular, mat.shiny) * mat.s * lSpec;\n    vec3 directLight = diffuseIllum + specularIllum;\n    // Estimate shadow\n    vec3 pNearSurface = hit.p + (hit.n * MARCH_HIT_DIST * 2.);\n    float shadow = calcShadow(Ray(pNearSurface, lDir), maxMarch, 3.);\n    directLight *= shadow;\n    // INDIRECT LIGHTING\n    vec3 ambientIllum = lAmbient * mat.a;\n    float ambientOcclusion = calcAO(hit.p, hit.n, GLOBAL_AO);\n    vec3 indirectLight = ambientIllum * ambientOcclusion;\n    \n    vec3 illum = directLight + indirectLight;\n    \n    if (SHADE_AO_ONLY) {\n        return vec3(ambientOcclusion);\n    }\n\n    return clamp(illum, 0., 1.);\n}\n\n\n// DirectionalLight\nvec3 illuminateSingleLight(Hit hit, DirectionLight l, vec3 eye, float maxMarch) {\n    vec3 illum = illuminateSingleLight(hit, l.dir, l.d, l.s, l.a, eye, maxMarch);\n    return illum;\n}\n\n\n// Point light\nvec3 illuminateSingleLight(Hit hit, PointLight l, vec3 eye) {\n    vec3 lDir = normalize(l.o - hit.p);\n    // Light intensity decayed by 1/(dist^2)\n    vec3 lDiff = (hit.p - l.o);\n    float falloff = 1. / dot(lDiff, lDiff);\n    vec3 illum = illuminateSingleLight(hit, DirectionLight(lDir, l.d*falloff, l.s*falloff, l.a), eye, distance(hit.p, l.o));\n\n    return illum;\n}\n\n\n// Define all lights in the scene\nvec3 illuminateScene(Hit hit, vec3 eye) {\n    vec3 l1Pos = vec3(0.769,4.652,4.080);\n    vec3 l1Intensity = vec3(20.);\n    PointLight l1 = PointLight(\n        l1Pos, \t\t\t\n        l1Intensity, \n        l1Intensity, \n        vec3(0.090,0.090,0.090)\n    );\n    \n    vec3 l2Pos = vec3(6., 4., -7.);\n    vec3 l2Intensity = vec3(20.);\n    PointLight l2 = PointLight(\n        l2Pos, \t\t\t\n        l2Intensity, \n        l2Intensity, \n        vec3(0.075,0.075,0.075)\n    );\n    \n    DirectionLight l3 = DirectionLight(\n        vec3(0.000,0.000,0.835), \n        vec3(1.),\n        vec3(1.),\n        vec3(0.1)\n    );\n\n    vec3 i1 = illuminateSingleLight(hit, l1, eye);\n    vec3 i2 = illuminateSingleLight(hit, l2, eye);\n    vec3 i3 = illuminateSingleLight(hit, l3, eye, 100.);\n    return i1 + i2 + i3;\n}\n\n\n/********* RENDER SCENE *********/\n\n// References for camera:\n// https://youtu.be/PBxuVlp7nuM (ArtofCode)\n// https://youtu.be/2SaGgTlkhSs (3dGraphicsFromScratch)\nRay cameraViewRay(vec2 uv, vec3 eye, vec3 lookat, float fovDegrees, float roll) {\n    // Axes\n    vec3 f = normalize(lookat - eye);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    // Image plane\n    float zoom = 1. / tan(radians(fovDegrees) / 2.);\n    vec3 c = eye + f*zoom;\n    uv *= rotate2d(roll);\n    vec3 i = c + (uv.x*r) + (uv.y*u);\n    // Ray from camera origin to intersection with image plane\n    return Ray(eye, normalize(i - eye));\n}\n\n\nvec3 renderScene(Ray viewRay) {\n    Hit sceneHit;\n    // rayMarch returns false if no scene intersection\n    if(!rayMarch(viewRay, sceneHit)) return vec3(0.012,0.025,0.006);\n    else return illuminateScene(sceneHit, viewRay.o);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Move origin to center of viewing plane\n    uv -= 0.5;\n    // Normalize aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    // Remap to [-1, -1] x [1, 1]\n    uv *= 2.;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    \n    // CAMERA SETUP\n    vec2 cameraXZ = 7. * vec2(cos(mouse.x*TWOPI*2.), sin(mouse.x*TWOPI*2.));\n    vec3 eye = vec3(cameraXZ[0], 6. + sin(mouse.y)*10., cameraXZ[1]);\n    vec3 lookat = vec3(0., 0., 0.);\n    Ray viewRay = cameraViewRay(uv, eye, lookat,  65., 0.);\n\n    // CALCULATE PIXEL COLOR\n    vec3 color = vec3(0.);\n    color = renderScene(viewRay);\n    \n\t//color *= (1. / (1. + color));\n    \n    // Gamma correction\n    color = pow(color, vec3(0.6));\n    \n    // Uncomment to see 2d value noise texture\n    //color = vec3(valueNoiseColor(uv, 5.472));\n\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}