{"ver":"0.1","info":{"id":"4stSRM","date":"1458393410","viewed":2661,"name":"Bokeh Blur (modified)","username":"SolarLiner","description":"From the original by David Hoskins: https://www.shadertoy.com/view/4d2Xzw\nAdded barrel (wip) and anamorphic distortion of the shapes.","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["blur","bokeh","postprocess","process"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bokeh disc.\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. (https://www.shadertoy.com/view/4d2Xzw)\n// Modified by SolarLiner\n\n#define USE_MIPMAP\n\n// The Golden Angle is (3.-sqrt(5.0))*PI radians, which doesn't precompiled for some reason.\n// The compiler is a dunce I tells-ya!!\n#define GOLDEN_ANGLE 2.39996323\n\n#define ITERATIONS 512\n\n#define DISTORTION_ANAMORPHIC\t0.6;\n#define DISTORTION_BARREL\t\t0.6;\n// Helpers-----------------------------------------------------------------------------------\nvec2 rotate(vec2 vector, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec2(c*vector.x-s*vector.y, s*vector.x+c*vector.y);\n}\n\nmat2 rotMatrix(float angle)\n{\n    return mat2(cos(angle), sin(angle),\n                    -sin(angle), cos(angle));\n}\n\n// Additions by SolarLiner ------------------------------------------------------------------\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy+vec2(-0.5,0.5);\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset,0.0);\n    float anam = 1.0-DISTORTION_ANAMORPHIC; // Prevents a strange syntax error\n    oldoffset.x *= anam;\n    \n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset) * sin(angle) + prep * dot(prep, oldoffset) * (1.0-cos(angle));\n    \n    return rotated.xy;\n}\n\n//-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float amount)\n{\n\tvec3 acc = vec3(0.0);\n\tvec3 div = vec3(0.0);\n    vec2 tocenter = uv.xy+vec2(-0.5,0.5);\n    vec2 pixel = 1.0 / iResolution.xy;\n    float r = 1.0;\n    vec2 vangle = vec2(0.0,radius); // Start angle\n    mat2 rot = rotMatrix(GOLDEN_ANGLE);\n    \n    amount += radius*500.0;\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle = rot * vangle;\n        // (r-1.0) here is the equivalent to sqrt(0, 1, 2, 3...)\n        vec2 pos = GetDistOffset(uv, pixel*(r-1.)*vangle);\n        \n        #ifdef USE_MIPMAP\n\t\tvec3 col = texture(tex, uv + pos, radius*1.25).xyz;\n        #else\n        vec3 col = texture(tex, uv + pos).xyz;\n        #endif\n        col = col * col * 1.5; // ...contrast it for better highlights - leave this out elsewhere.\n\t\tvec3 bokeh = pow(col, vec3(9.0)) * amount+.4;\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime*.2 + .5;\n\tfloat r = .5 - .5*cos(time * 6.283);\n       \n\tfloat a = 40.0;\n    if (iMouse.w >= 1.0)\n    {\n    \tr = (iMouse.x/iResolution.x)*3.0;\n        a = iMouse.y/iResolution.y * 50.0;\n    }\n    \n    uv *= vec2(1.0, -1.0);\n    \n    if (mod(time-.5, 3.0) < 1.0)\n    {        \n\t\tfragColor = vec4(Bokeh(iChannel0, uv, r, a), 1.0);\n    }else\n    if (mod(time-.5, 3.0) < 2.0)\n    {\n        fragColor = vec4(Bokeh(iChannel1, uv, r, a), 1.0);    \n    }else\n    {\n\t\tfragColor = vec4(Bokeh(iChannel2, uv, r, a), 1.0);\n    }\n    \n    //fragColor.xyz = BarrelDistOffset(uv).xyz;\n}","name":"Image","description":"","type":"image"}]}