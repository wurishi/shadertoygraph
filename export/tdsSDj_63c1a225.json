{"ver":"0.1","info":{"id":"tdsSDj","date":"1552250643","viewed":65,"name":"MG","username":"AlexRom","description":"mg","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 2\n\n#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 655;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nstruct DistanceField\n{\n    float distance;\n    int id;\n};\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 specular;\n    vec3 diffuse;\n    float m;\n};\n    \nvec3 fresnel(vec3 f0, vec3 l, vec3 h)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, dot(l, h)), 5.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nDistanceField opSmoothSubtraction( DistanceField Dist1, DistanceField Dist2, float k ) {\n    float d1 = Dist1.distance;\n    float d2 = Dist2.distance;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    Dist1.distance = mix( d2, -d1, h ) + k*h*(1.0-h);\n    \n    return Dist1; \n}\n\nDistanceField df_union(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= d2.distance)\n        return d1;\n    else\n        return d2;\n}\n\nDistanceField df_intersect(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= d2.distance)\n        return d2;\n    else\n        return d1;\n}\n\nDistanceField df_difference(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= -d2.distance)\n        return d1;\n    else\n        return d2;\n}\n\n\n#define SCENE_WHITE 1\n#define SCENE_PURPLE 2\n#define SCENE_GOLD 3\n#define SCENE_FLOOR 4\n#define SCENE_CRIMSON 5\n#define SCENE_LIME 6\n#define SCENE_BLUE 7\n#define SCENE_AQUA 8\n#define DEFAULT 10\n\nvoid df_material(vec3 pos, int id, inout Material mtl)\n{\n    if (id == SCENE_WHITE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 1.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_PURPLE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.4, 0.3, 0.5) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_CRIMSON)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.1, 0.2, 0.6) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_LIME)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.2, 1.0, 0.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_BLUE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.0, 0.0, 0.9) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_AQUA)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.9, 0.44, 0.44) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_GOLD)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.85, 0.782, 0.344);\n        mtl.diffuse = vec3(0.0, 0.0, 0.0);\n        mtl.m = 8.0;\n    }\n    \n    else if (id == SCENE_FLOOR)\n    {\n        float checker_size = 0.5;\n        float alpha = floor(pos.x / checker_size) + floor(pos.z / checker_size);\n        alpha = abs(alpha);\n        alpha -= 2.0 * floor(alpha / 2.0);\n\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        /* mtl.diffuse = mix(vec3(0.95, 0.95, 0.95), vec3(0.25, 0.25, 0.25), alpha); */\n        mtl.diffuse = mix(vec3(0.25, 0.25, 0.95), vec3(0.95, 0.95, 0.25), alpha);\n        mtl.m = 128.0;\n    }\n    else\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n}\n\n\nDistanceField sceneSDF(vec3 samplePoint) {\n    float sphereDist1 = sdSphere(samplePoint + vec3(0.0,2.0,8.0),1.3);\n    float cubeDist2 = cubeSDF(samplePoint + vec3(0.0,2.0,8.0));\n    \n    float sphereDist2 = sdSphere(samplePoint + vec3(2.0,3.0,2.0),1.0);\n\n    \n    float cubeDist = cubeSDF(samplePoint + vec3(-4.0,2.0,2.0));\n    float planeDist = sdPlane(samplePoint + vec3(0.0,5.0,0.0),vec4(0.0,1.0,0.0,0.5));\n    float prismDist = sdTriPrism(samplePoint + vec3(9.0,4.0,7.0), vec2(1.0,2.0));\n    \n    float torusDist = sdTorus(samplePoint + vec3(-6.0,1.0, 7.0),vec2(2.20,0.55));\n    \n    float sphereDist3 = sdSphere(samplePoint + vec3(8.0,2.0,0.0),1.0);\n    float boxDist = sdBox(samplePoint + vec3(8.0,2.0,0.0),vec3(1.0,2.0,1.0));\n    \n    DistanceField sphereD3 = DistanceField(sphereDist3, SCENE_LIME);\n    DistanceField boxD = DistanceField(boxDist, SCENE_LIME);\n    \n    DistanceField torusD = DistanceField(torusDist, SCENE_PURPLE);\n    \n    DistanceField sphereD1 = DistanceField(sphereDist1, SCENE_CRIMSON);\n    DistanceField cubeD2 = DistanceField(cubeDist2, SCENE_CRIMSON);\n    \n    \n    DistanceField sphereD2 = DistanceField(sphereDist2, SCENE_GOLD);\n    \n    \n    DistanceField cubeD = DistanceField(cubeDist, SCENE_BLUE);\n    DistanceField planeD = DistanceField(planeDist, SCENE_FLOOR);\n    DistanceField prismD = DistanceField(prismDist, SCENE_AQUA);\n       \n    return df_union(opSmoothSubtraction(sphereD3,boxD,0.55),df_union(torusD,df_union(df_union(df_union(df_union(df_intersect(sphereD1,cubeD2),sphereD2),cubeD),planeD),prismD)));\n}\n\n\nDistanceField shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, DistanceField end) {\n    DistanceField depth = DistanceField(0.0,DEFAULT);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        DistanceField dist = sceneSDF(eye + depth.distance * marchingDirection);\n        if (dist.distance < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth.distance += dist.distance;\n        depth.id = dist.id;\n        if (depth.distance >= end.distance) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).distance - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).distance,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).distance - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).distance,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).distance - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).distance\n    ));\n}\n\n\n\nfloat raymarch_shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = sceneSDF(ro + rd*t).distance;\n        if( h<0.001 )\n            return 0.15;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float c = 1.0;\n    float b = 0.00002;\n    float fogAmount = 1.0 - exp( -pow(distance,3.0) * b );\n    vec3  fogColor  = vec3(0.8,0.9,1.0);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 8.;\n    float ao = 0.;\n    float dist;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - sceneSDF(p + n * dist).distance) / dist);  \n    }\n    return 1. - ao * 0.1;\n}\n\nvec3 render(int id, float alpha, vec3 p, vec3 eye) {\n    \n    Material mtl;\n    df_material(p, id, mtl);\n    \n    vec3 k_a = mtl.ambient;\n    vec3 k_d = mtl.diffuse;\n    vec3 k_s = mtl.specular;\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 light_pos = 2.0 * vec3(cos( PI * iTime / 4.0), 1.0, sin( PI * iTime / 4.0));\n    vec3 camera_pos = eye;\n    vec3 pos = p;\n    vec3 normal = estimateNormal(p);\n    \n    vec3 l = normalize(light_pos - pos);\n    vec3 v = normalize(camera_pos - pos);\n    vec3 h = normalize(v + l);\n    float n_l = max(0.0, dot(normal, l));\n    float n_h = max(0.0, dot(normal, h));\n\n    float shadow = raymarch_shadow(light_pos, -l, 0.0, 0.9 * distance(light_pos, pos), 32.0);\n\n    // Lambertian BRDF diffuse + Blinn-Phong BRDF specular\n    color += mtl.ambient;\n    \n    color += shadow * n_l * (mtl.diffuse + (mtl.m + 2.0) / 8.0 * pow(n_h, mtl.m) * fresnel(mtl.specular, l, h));\n    \n    vec3 light_pos2 =     4.0 * vec3(cos( PI * iTime / 2.0), 1.0, sin( PI * iTime / 2.0));\n    \n    \n    vec3 l2 = normalize(light_pos2 - pos);\n    vec3 h2 = normalize(v + l);\n    \n    float n_l2 = max(0.0, dot(normal, l2));\n    float n_h2 = max(0.0, dot(normal, h2));\n    \n    float shadow2 = raymarch_shadow(light_pos2, -l2, 0.0, 0.9 * distance(light_pos2, pos), 32.0);\n    \n    color += shadow2 * n_l2 * (mtl.diffuse + (mtl.m + 2.0) / 8.0 * pow(n_h2, mtl.m) * fresnel(mtl.specular, l2, h2));\n    \n    \n    float ao = ambientOcclusion(p, normal);\n\tcolor *= ao;\n    \n     \n    return color;\n}\n\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3( 8, 12, 8 );\n    \n    mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    eye = eye * rot;\n    \n    vec3 ta = vec3( -0.5, -0.5, 0.5 );\n    mat3 ca = setCamera( eye, ta, 0.0 );\n    \n    \n    DistanceField Max = DistanceField(MAX_DIST,DEFAULT);\n    \n    vec3 tot = vec3(0.0);\n\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n           \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pix = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        \n        dir = ca * normalize( vec3(pix.xy,2.0) );\n        \n        DistanceField dist = shortestDistanceToSurface(eye, dir, MIN_DIST, Max);\n\n        if (dist.distance > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(0.0, 1.0, 1.0, 0.0);\n            return;\n        }\n\n        vec3 p = eye + dist.distance * dir;\n\n        float shininess = 10.0;\n\n        vec3 color = render(dist.id, shininess, p, eye);\n        \n        color = applyFog(color,dist.distance,eye,dir);\n        \n        tot += color;\n        \n    }\n    tot /= float(AA*AA);\n    \n    \n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}