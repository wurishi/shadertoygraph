{"ver":"0.1","info":{"id":"stKBRz","date":"1663953883","viewed":47,"name":"pathtracing-template","username":"nethe550","description":"A 3D path-traced SDF renderer template.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","ray","sdf","raytrace","template","pathtrace","pathtracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Camera cam = Camera(\n    vec3(0.00, 0.25, 0.25), // position\n    vec3(0.00, 0.25, 0.00), // target\n    vec3(0.0, 1.0, 0.0),    // up direction\n    0.01,                   // near plane\n    100.0,                  // far plane\n    1.125                   // field of view\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // animate camera\n     float t = iTime * 0.5;\n    // float t = 0.0;\n    cam.position.x = cam.target.x + cos(t);\n    cam.position.z = cam.target.z + sin(t);\n    \n    fragColor = pathtrace(fragCoord, iResolution.xy, cam);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ========================= //\n// Constants\n// ========================= //\n\n#define RAY_MAX_STEPS 256\n#define RAY_COLLISION_EPSILON 0.001\n#define NORMAL_PRECISION 0.001\n\n// ========================= //\n// Structures\n// ========================= //\n\nstruct Material {\n    vec3 color;\n    float roughness;\n};\n\nstruct SDF {\n    float dist;\n    Material material;\n};\n\nstruct Raycast {\n    vec3 position;\n    vec3 normal;\n    vec3 direction;\n    bool hit;\n    SDF sdf;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float nearPlane;\n    float farPlane;\n    float FOV; // in radians\n};\n\n// ========================= //\n// SDFs (implicit)\n// ========================= //\n\n// Operations\nSDF sdfUnion(in SDF a, in SDF b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// cubic smooth minimum\nSDF sdfSmoothUnion(in SDF a, in SDF b, in float k) {\n    float h = max(k - abs(a.dist - b.dist), 0.0) / k;\n    float closest = min(a.dist, b.dist);\n    float dist = closest - h * h * h * k * (1.0 / 6.0);\n    if (closest == a.dist) {\n        a.dist = dist;\n        return a;\n    }\n    else {\n        b.dist = dist;\n        return b;\n    }\n    \n}\n\nvec3 opMirrorX(in vec3 p) {\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 opMirrorY(in vec3 p) {\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 opMirrorZ(in vec3 p) {\n    return vec3(p.x, p.y, abs(p.y));\n}\n\n// SDFs\nSDF sdfSphere(in vec3 p, in Material material, in vec3 position, in float radius) {\n    SDF sdf;\n    sdf.dist = length(p + position) - radius;\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfBox(in vec3 p, in Material material, in vec3 position, in vec3 size, in float radius) {\n    SDF sdf;\n    vec3 hs = abs(p + position) - size;\n    sdf.dist = min(max(hs.x, max(hs.y, hs.z)), 0.0) + length(max(hs, 0.0)) - radius;\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfLine(in vec3 p, in Material material, in vec3 a, in vec3 b, in float radius) {\n    SDF sdf;\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    sdf.dist = length(pa - ba * h) - radius;\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfCylinderY(in vec3 p, in Material material, in vec3 position, in float radius, in float height) {\n    SDF sdf;\n    p += position;\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);\n    sdf.dist = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfPlaneX(in vec3 p, in Material material, in float x) {\n    SDF sdf;\n    sdf.dist = p.x - x;\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfPlaneY(in vec3 p, in Material material, in float y) {\n    SDF sdf;\n    sdf.dist = p.y - y;\n    sdf.material = material;\n    return sdf;\n}\n\nSDF sdfPlaneZ(in vec3 p, in Material material, in float z) {\n    SDF sdf;\n    sdf.dist = p.z - z;\n    sdf.material = material;\n    return sdf;\n}\n\n// ========================= //\n// Shading\n// ========================= //\n\nfloat lightDirectional(in vec3 lightDir, in vec3 normal, in float bias) {\n    return (1.0 - bias) + bias * clamp(dot(lightDir, normal), 0.0, 1.0);\n}\n\n// ========================= //\n// Path-Tracing\n// ========================= //\n\n// The SDF of the entire scene\nSDF scene(in vec3 p) {\n\n    vec3 characterPos = vec3(0.0, -0.25, 0.0);\n\n    Material characterMat = Material(\n        vec3(0.5, 0.0, 1.0), // color\n        0.5                  // roughness\n    );\n    \n    Material eyesMat = Material(\n        vec3(0.9),\n        0.05\n    );\n    \n    Material pupilsMat = Material(\n        vec3(0.1),\n        1.0\n    );\n    \n    Material groundMat = Material(\n        vec3(0.25, 0.75, 0.25), \n        1.0                     \n    );\n    \n    SDF sdf = sdfSphere(p, characterMat, characterPos + vec3(0.0, -0.25, 0.0), 0.25);\n    sdf = sdfSmoothUnion(sdf, sdfCylinderY(p, characterMat, characterPos, 0.125, 0.25), 0.25);\n    SDF eyes = sdfSphere(opMirrorX(p), eyesMat, characterPos + vec3(-0.1, -0.3, -0.2), 0.0625);\n    sdf = sdfUnion(sdf, eyes);\n    SDF pupils = sdfSphere(opMirrorX(p), pupilsMat, characterPos + vec3(-0.1, -0.3, -0.233), 0.03125);\n    sdf = sdfUnion(sdf, pupils);\n    \n    sdf = sdfUnion(sdf, sdfPlaneY(p, groundMat, -0.25));\n    \n    return sdf;\n\n}\n\n// creates a ray direction from a screen coordinate and a camera\nvec3 perspective(in vec2 clip, in Camera camera) {\n    vec3 w = normalize(camera.target - camera.position);\n    vec3 u = normalize(cross(w, camera.up));\n    vec3 v = normalize(cross(u, w));\n    return vec3(normalize(clip.x * u + clip.y * v + (camera.FOV) * w));\n}\n\n// approximates the normal direction of the scene SDF's surface\nvec3 approximateNormal(in vec3 p, in float e) {\n    vec2 a = vec2(e, 0.0);\n    return normalize(vec3(\n        scene(p + a.xyy).dist - scene(p - a.xyy).dist,\n        scene(p + a.yxy).dist - scene(p - a.yxy).dist,\n        scene(p + a.yyx).dist - scene(p - a.yyx).dist\n    ));\n}\n\nvec3 approximateNormal(in vec3 position) {\n    return approximateNormal(position, NORMAL_PRECISION);\n}\n\n// casts a ray from a camera and screen coordinate\nRaycast castRay(in Camera camera, in vec2 clip) {\n    Raycast r;\n    float t = camera.nearPlane;\n    vec3 origin = camera.position;\n    r.direction = perspective(clip, camera);\n    r.hit = false;\n    for (int i = 0; i < RAY_MAX_STEPS; i++) {\n        \n        r.position = origin + r.direction * t;\n        SDF s = scene(r.position);\n        \n        if (s.dist < RAY_COLLISION_EPSILON) {\n            r.sdf = s;\n            r.hit = true;\n            r.normal = approximateNormal(r.position);\n            break;\n        }\n        t += s.dist;\n        if (t > camera.farPlane) break;\n    }\n    return r;\n}\n\n// casts a ray from a point toward to generate a shadow\nfloat castShadow(in Camera cam, in vec3 p, in vec3 lightDir, float sharpness) {\n    float o = 1.0;\n    float penumbra = 1e20;\n    for(float t = cam.nearPlane; t < cam.farPlane;) {\n    \n        float d = scene(p + lightDir * t).dist;\n        \n        if(d < RAY_COLLISION_EPSILON) return 0.0;\n        \n        float y = d * d / (2.0 * penumbra);\n        float h = sqrt(d * d - y * y);\n        o = min(o, sharpness * h / max(0.0, t - y));\n        \n        penumbra = d;\n        t += d;\n        \n    }\n    return o;\n}\n\n// applies shading to a pixel\nvec3 applyShading(in Raycast hit, in Camera cam) {\n\n    vec3 color = vec3(0.0);\n    \n    // key light\n    vec3 keyLightDir = normalize(vec3(0.2, 0.4, 0.8));\n    float keyLight = lightDirectional(keyLightDir, hit.normal, 1.0);\n    float keyShadow = castShadow(cam, hit.position, keyLightDir, 16.0);\n    vec3 keyColor = vec3(0.9, 0.7, 0.4);\n    color += hit.sdf.material.color * keyLight * keyShadow * keyColor;\n    if (hit.sdf.material.roughness < 1.0) {\n        vec3 hv = normalize(keyLightDir + cam.position);\n        float keySpecular = pow(clamp(dot(hit.normal, hv), 0.0, 1.0), (1.0 - hit.sdf.material.roughness) * 256.0) * keyLight;\n        color += keySpecular;\n    }\n    \n    // bounce light\n    vec3 bounceLightDir = vec3(0.0, -1.0, 0.0);\n    float bounceLight = lightDirectional(bounceLightDir, hit.normal, 0.5);\n    vec3 bounceColor = vec3(0.25, 0.125, 0.1);\n    color += hit.sdf.material.color * bounceLight * bounceColor;\n\n    // sky light\n    vec3 skyLightDir = vec3(0.0, 1.0, 0.0);\n    float skyLight = lightDirectional(skyLightDir, hit.normal, 0.5);\n    vec3 skyColor = vec3(0.1, 0.125, 0.25);\n    color += hit.sdf.material.color * skyLight * skyColor;\n\n    return color;\n\n}\n\n// creates a color from a given UV coordinate and camera\nvec4 pathtrace(in vec2 fragCoord, in vec2 resolution, in Camera camera) {\n    \n    vec2 clip = (2.0 * fragCoord - resolution) / resolution.y;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    Raycast fill = castRay(camera, clip);\n    \n    if (fill.hit) color = applyShading(fill, camera);\n    else {\n        // skybox\n        color = vec3(0.4, 0.5, 0.9) - 0.5 * (0.5 * fill.direction.y);\n        color = mix(color, vec3(0.5), exp(-10.0 * fill.direction.y));\n    }\n    \n    color = pow(color, vec3(0.4545));\n    \n    return vec4(color, 1.0);\n    \n}","name":"Common","description":"","type":"common"}]}