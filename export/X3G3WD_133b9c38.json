{"ver":"0.1","info":{"id":"X3G3WD","date":"1729470999","viewed":135,"name":"Cubic Hermite Fluid Sim","username":"capslpop","description":"cubic Hermite fluid sim","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["hermite"],"hasliked":0,"parentid":"XcVXRt","parentname":"Fork Fluid Sim #1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float _zoom = zooming;\n\n    vec2 pixPos = vec2(fract(fragCoord/_zoom));\n    ivec2 zoom = ivec2(fragCoord/_zoom);\n\n    point p = getPoint(texelFetch(iChannel0, zoom, 0));\n    fragColor = vec4(P2F(p.height))*vec4(0.424,0.608,0.675,0.0);\n    \n    // display over shoot\n    if (P2F(p.height) > 4.0)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    if (p.type1 == 1u)\n    {\n        fragColor = vec4(0.5);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define range(i,a,b) for(int i = a; i <= b; i++)\n#define sizer 256.0\n#define zooming iResolution.x/sizer\n\nfloat Pf(float rho)\n{\n    return 1.2*(rho - 0.3);\n}\n\nfloat G(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n// Dave's hash function\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Created by nilrem\nhighp uint packUnorm(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackUnorm(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackUnorm(float a) { return vec4(unpackUnorm(floatBitsToUint(a))) / 255.; }\nfloat packSnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackSnorm(float a) { return clamp((vec4(unpackUnorm(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n// this is contains the graph for the particals\nstruct point\n{\n    uint height;\n    vec2 velocity;\n    \n    uint type1;\n    uint type2;\n    float percent; // this tell us how much mass is which mattiral type -- 0.0 is type 1, 1.0 is type 2\n};\n\npoint getPoint(vec4 info)\n{\n    point p;\n    p.height = floatBitsToUint(info.r);\n    p.velocity = unpackSnorm(info.g).xy;\n    \n    uvec4 a = unpackUnorm(floatBitsToUint(info.b));\n    p.type1 = a.x;\n    p.type2 = a.y;\n    p.percent = float(a.z) / 255.0;\n\n    return p;\n}\n\nvec4 savePoint(point p)\n{\n    vec4 info;   \n    info.r = uintBitsToFloat(p.height);\n    info.g = packSnorm(vec4(p.velocity, 0.0, 0.0));\n    \n    info.b = uintBitsToFloat(packUnorm( uvec4(p.type1, p.type2, round(p.percent*255.), 0u) ));\n    \n    return info;\n}\n\nfloat P2F(uint p)\n{\n    return float(p) / (65535.0 / 4.0);\n}\n\nuint getNext(vec2 dx, vec2 pos, point p, float s)\n{\n    vec2 then = smoothstep(0.0, 1.0, 1.0 - abs(dx));\n    float percent = then.x*then.y;\n    \n    // here make fully conservative:\n    uint error = 0u;\n    if (p.height > 0u && percent > 0.0 && all(lessThan(sign(dx), vec2(0.0))))\n    {\n        vec2 then2 = smoothstep(0.0, 1.0, abs(dx));\n    \n        uint total =  \n        uint(mix(then.x  * then.y,   1.0 / 9.0, s)*float(p.height)) +\n        uint(mix(then2.x * then.y,   1.0 / 9.0, s)*float(p.height)) +\n        uint(mix(then.x  * then2.y,  1.0 / 9.0, s)*float(p.height)) +\n        uint(mix(then2.x * then2.y,  1.0 / 9.0, s)*float(p.height)) +\n        uint(mix(0.0,  1.0 / 9.0, s)*float(p.height)) * 5u;\n\n        \n        error = (p.height - total);\n    }\n    \n    return uint(float(p.height) * mix(percent, 1.0 / 9.0, s)) + error;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_UP    = 38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord.xy);\n    \n    point p = point(0u, vec2(0.0), 0u, 0u, 0.0);\n    \n    point pCenter = getPoint(texelFetch(iChannel0, pos, 0));\n    \n    float centerPressure = Pf(P2F(pCenter.height));\n    \n    p.type1 = pCenter.type1;\n    p.type2 = pCenter.type2;\n\n    vec2 F = vec2(0.0);\n    \n    vec2 surfaceNormal = vec2(0.0);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        point p_ = getPoint(texelFetch(iChannel0, pos + ivec2(i, j), 0));\n        \n        vec2 dx = -p_.velocity - vec2(i, j);\n\n        uint nextPoint = getNext(dx, vec2(pos), p_, P2F(p_.height)/4.0);\n\n        p.height += nextPoint;\n        p.velocity += p_.velocity * float(nextPoint);\n        \n        // make sure that there is a force added to the oposite matirial\n        float pres = Pf(P2F(p_.height));\n        if (pCenter.type1 == 1u)\n        {\n            pres = Pf(-16.0);\n        }\n        \n        F -= 0.25*G(dx)*dx*P2F(p_.height)*(centerPressure + pres);\n    }\n    \n    p.velocity = p.velocity / float(p.height);\n    \n    // force from mouse\n    if (distance(fragCoord, vec2(iMouse.xy/(zooming))) < 20.0 && iMouse.z > 1.0)\n    {\n        vec2 newF = (fragCoord - vec2(iMouse.xy/(zooming))) / 3000.0;\n        F.x += -newF.y + newF.x;\n        F.y += newF.x + newF.y;\n        p.height += 150u;\n        //p.height = 0u;\n    }\n    if (distance(fragCoord, vec2(iResolution.xy/2.0/(zooming))) < 6.0  && iMouse.x < 0.1)\n    {\n        vec2 newF = (fragCoord - vec2(iResolution.xy/2.0/(zooming))) / 3000.0;\n        F.x += -newF.y + newF.x;\n        F.y += newF.x + newF.y;\n        p.height += 150u;\n        //p.height = 0u;\n    }\n    \n    p.velocity -= (F/P2F(p.height)) + vec2(0.0, 0.005); // calculate velocity and gravidy\n    p.velocity += (hash22(fragCoord + iTime) - 0.5) / 100.0; // then add some randomness\n    if (P2F(p.height) < 0.4)\n    {\n        p.velocity *= hash22(fragCoord + iTime) / 128.0 + 1.0;\n    }\n\n    float vel = length(p.velocity);\n    p.velocity /= (vel > 1.0)?vel:1.0;\n    \n    // hard\n    if (pos.y <= 1)\n        p.velocity.y = 1.0;\n    if (pos.x <= 1)\n        p.velocity.x = 1.0;\n    if (pos.x >= int(sizer) - 1)\n        p.velocity.x = -1.0;\n    \n    fragColor = savePoint(p);\n}","name":"Buffer A","description":"","type":"buffer"}]}