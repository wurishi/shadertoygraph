{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Santa's Workshop by eiffie\n//All this bs just to try out something I will call \"abnormals\". They desparkle the lighting calc\n//The AA here is like SoC lite for pixels - I think the same as Dave Hoskins is doing.\n//It is slower than the edge detect but it works better. It is turned off by default.\n\n//#define HI_QUAL\n#define USE_TEXTURE\n\n#define MarchSteps 64\n#define FudgeFactor 0.8\n#define ShadowSteps 12\n\n#define size iResolution\n#define time iTime\n#define tex iChannel0\n\nconst vec3 LightDir=vec3(0.1,0.975,0.05),LightColor=vec3(1.0,0.99,0.9);\n\nfloat PixelSize;\nvec3 mcolor;\n\nfloat rnd(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\nfloat noyz(vec2 p){\n\tvec2 c=floor(p),f=fract(p),v=vec2(1.0,0.0);\n\treturn mix(mix(rnd(c),rnd(c+v.xy),f.x),mix(rnd(c+v.yx),rnd(c+v.xx),f.x),f.y);\n}\nvec3 texturef(vec2 p){\n#ifdef USE_TEXTURE\n\treturn texture(tex,p).rgb;\n#else\n\tfloat n=noyz(p*vec2(16.0,256.0));\n\treturn vec3(0.4,0.25,0.1)+vec3(0.5,0.125,0.25)*n;\n#endif\n}\n\nfloat DE(in vec3 p){//shape builder\n\tvec2 c=floor(p.xz);\n\tfloat b=c.x+13.0*c.y,cb=cos(b),sb=sin(b-0.24);\n\tp.xz=abs(fract(p.xz)-vec2(0.5));\n\tfloat w=0.47-max(p.x,p.z);\n\tc=vec2(cb,sb)*0.05;\n\tp.xz+=c;\n\tp.xz=cb*p.xz+sb*vec2(p.z,-p.x)+c;\n\tp.xz=abs(p.xz)+c;\n\tvec4 r=vec4(p-0.20,0.0);\n\t\n\tif(mod(b,9.0)==0.0){r.x=length(p.xz)-0.2;r.z=0.0;}\n\tif(mod(b,7.0)==0.0){r.x=length(p)-0.2;r.yz=vec2(0.0);}\n\tif(mod(b,5.0)==0.0){r.x=length(p.xy)-0.2;r.y=0.0;r.z=p.z;r.w=0.1;}\n\tif(mod(b,4.0)==0.0){r.zy=(abs(vec2(p.z+p.y,p.z-p.y))-0.15)*0.577;}\n\tif(mod(b,2.0)==0.0){r.w=0.05+0.025*cb;}\n\tif(mod(b,3.0)==0.0){r.x=abs(length(max(r.xyz+0.12,0.0))-0.19);r.y=p.y-0.05;r.z=0.0;r.w=0.05;}\n\t\n\treturn min(max(min(length(max(r.xyz,0.0))-r.w,w),p.y-0.4),p.y+0.25);\n}\nfloat CE(in vec3 p){\n\tvec2 c=floor(p.xz);\n\tfloat b=(c.x+14.0*c.y)*2.0;\n\tvec3 col=texturef(p.xy+0.5*p.zz);\n\tc=abs(fract(p.xz)-vec2(0.5));\n\tfloat w=0.47-max(c.x,c.y);\n\tfloat d=DE(p);\n\tif(min(w,p.y+0.25)>d){col*=vec3(1.0)+0.5*vec3(sin(b),0.0,sin(b+13.0));w=0.0005*mod(b,11.0);}\n\telse w=0.0075;\n\tmcolor+=col;\n\treturn d-col.r*w;\n}\n\nvec3 getBackground( in vec3 rd ){\n\tvec3 bcol=abs(rd)*0.1+LightColor*max(0.0,dot(rd,LightDir))*0.2;\n\tbcol+=LightColor*pow(max(0.0,dot(rd,LightDir)),50.0);\n\treturn bcol;\n}\n\nfloat shadao(vec3 ro, vec3 rd, float px){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=2.0*px,min_step=0.5*PixelSize;\n\tfor(int i=0;i<ShadowSteps;i++){\n\t\td=max(0.0,DE(ro+rd*t))+min_step;\n\t\tt+=d;\n\t\tres=min(res,3.0*d/t);\n\t}\n\treturn res;\n}\n\nconst float mspec=2.0,mspecExp=6.0;\nvec3 shade(in vec3 ro, in vec3 rd, in float t, in vec3 color){\n\tfloat px=PixelSize*t;\n\tvec2 v=vec2(0.5*px,0.0);\n\tfloat ds=DE(ro+rd*t);\n\tro+=rd*(t+ds-PixelSize);\n\tmcolor=vec3(0.0);//clear material color before taking samples\n\tfloat d=CE(ro);\n\tvec3 dn=vec3(CE(ro-v.xyy),CE(ro-v.yxy),CE(ro-v.yyx));\n\tvec3 dp=vec3(CE(ro+v.xyy),CE(ro+v.yxy),CE(ro+v.yyx));\n\tmcolor*=0.143;\n    //so here is the \"abnormal\" an un-normalized weighted average of normals\n    //they reduce the light on edges so not so much sparkle\n\tvec3 norm=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\t//vec3 norm=normalize(dp-dn);\n\tfloat shad=shadao(ro,LightDir,PixelSize);\n\tfloat dif=dot(norm,LightDir)*0.5+0.5;\n\tvec3 reflDir=reflect(rd,norm);\n\tfloat refl=dot(LightDir,reflDir);\n\tfloat spec=mspec*pow(max(0.0,refl),mspecExp)*mcolor.r;\n\tdif=min(dif,shad+0.05);\n\tvec3 diffuse_col=mcolor+vec3(0.125,0.0,-0.125)*refl;\n\tvec3 bcol=getBackground(reflDir);\n\treturn mix(diffuse_col*dif+bcol*shad*spec,color,clamp(ds/px,0.0,1.0));\n}\n\nvec3 scene( vec3 ro, vec3 rd )\n{// find color and distance of scene\n\t//march\n\tfloat t=(0.41-ro.y)/rd.y;//DE(ro)*rnd(fragCoord.xy)*0.75;\n\tif(t<0.0)t=100.0;\n\tfloat d,dm=100.0,tm=0.0,MIN_DIST=PixelSize*0.01,od=1000.0;//distances\n\tvec4 hit=vec4(-1.0);//we will grab up to 4 depths that are local mins\n\tfor(int i=0;i<MarchSteps;i++){\n\t\td=DE(ro+rd*t)*FudgeFactor;\n#ifdef HI_QUAL\n\t\tif(d<od && hit.x<0.0 && d<0.5*PixelSize*t){\n\t\t\thit.x=t;//save the depth\n\t\t\thit=hit.yzwx;//push\n\t\t}\n\t\tod=d;\n#endif\n\t\tif(d<dm){tm=t;dm=d;}//and save the max occluder\n\t\tt+=d;\n\t\tif(t>70.0 || d<MIN_DIST)break;\n\t}\n\t//we have saved the edges but there is also a min or final surface\n\tif(tm>hit.w && dm<PixelSize*(tm-dm)){//if minimum has not been saved\n\t\tif(hit.x>0.0)hit=hit.wxyz;//write over the last entry, not the first\n\t\thit.x=tm-dm;hit=hit.yzwx;//this is the only sample for lo_qual\n\t}\n#ifdef HI_QUAL\n\tif(d<PixelSize*(t-d) && hit.x<0.0){//save final distance if we have room\n\t\thit.x=t-d;hit=hit.yzwx;\t\n\t}\n#endif\n\t//color the background \n\tvec3 col=getBackground(rd);\n\t\n\t//add in the object(s)\n\n#ifdef HI_QUAL\n\tfor(int i=0;i<4;i++){//play back the hits and mix the color samples\n#endif\n\t\thit=hit.wxyz;//pop\n\t\tif(hit.x>0.0)col=shade(ro,rd,hit.x,col);\n#ifdef HI_QUAL\n\t}\n#endif\n\n\tcol*=8.0*exp(-t*0.3);\n\treturn clamp(col,0.0,1.0);\n}\n\t \nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 ro=vec3(100.0+sin(time*0.04)*12.0,4.0,100.0+cos(time*0.042)*15.0);\n\tvec3 dr=vec3((2.0*fragCoord.xy-size.xy)/size.y,2.5);\n\tvec3 rd=normalize(dr);\n\tPixelSize=2.5/(size.y*dot(rd,dr));\n\tvec3 fw=vec3(sin(time*0.1),-0.7,0.5);\n\trd=lookat(fw,vec3(0.3*sin(time*0.23),1.0,0.2))*rd;\n\tvec3 color=scene(ro,rd);\n\tif(color!=color)color=vec3(0.0,1.0,0.0);\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"XsfGRr"}],"inputs":[],"code":"#define bps 3.0\n\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return 440.0 * pow(2.0, (n - 69.0) / 12.0);}\nfloat saw(float t){return fract(t+0.5)-0.5;}\nfloat rand(float t){return fract(sin(t*200.0)*1531.2341);}\n\nvec2 mainSound( in int samp,float time)\n{\n int b=int(floor(time*bps))-8;\n float t=fract(time*bps),f=0.0,n=0.0;\n \n if(b>63)b-=64;\n if(b==0||b==4||b==8||b==16||b==20)n=43.0;\n else if(b==3||b==7||b==60)n=48.0;\n else if(b==1||b==5||b==11||b==18||b==22||b==44||b==55||b==58)n=52.0;\n else if(b==2||b==6||b==19||b==59)n=50.0;\n else if(b==9||b==10||b==12||b==17||b==21||b==23||b==40||b==41||b==57)n=53.0;\n else if(b==27)n=54.0;\n else if(b==24||b==25||b==26||b==28||b==36||b==39||b==43||b==47||b==52||b==56)n=55.0;\n else if(b==32||b==35||b==38||b==42||b==48||b==51||b==54)n=57.0;\n else if(b==34||b==37||b==50||b==53)n=59.0;\n else if(b==33||b==49)n=60.0;\n if(n>0.5)f=ntof(n);\n float tm=time*f*2.0;\n float a=saw(tm)+saw(tm*1.51)*0.5;\n return vec2(a*exp(-t*1.5)+0.2*rand(time-time*time*0.01)*cos(-0.785+3.1416*time*bps));\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ll3Rn","date":"1417973699","viewed":386,"name":"Santa's Workshop","username":"eiffie","description":"Santa is hopeful that wooden toys will come back in fashion to reduce the inventory.","likes":16,"published":1,"flags":8,"usePreview":0,"tags":["abnormals"],"hasliked":0,"parentid":"","parentname":""}}